<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-normalize.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-tag.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<span class="line-modified">  29 #define HB_SHAPER ot</span>
<span class="line-modified">  30 #define hb_ot_shaper_face_data_t hb_ot_layout_t</span>
<span class="line-modified">  31 #define hb_ot_shaper_shape_plan_data_t hb_ot_shape_plan_t</span>
<span class="line-modified">  32 #include &quot;hb-shaper-impl-private.hh&quot;</span>
<span class="line-modified">  33 </span>
<span class="line-modified">  34 #include &quot;hb-ot-shape-private.hh&quot;</span>
<span class="line-modified">  35 #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="line-modified">  36 #include &quot;hb-ot-shape-fallback-private.hh&quot;</span>
<span class="line-modified">  37 #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="line-modified">  38 </span>
<span class="line-modified">  39 #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified">  40 #include &quot;hb-unicode-private.hh&quot;</span>
<span class="line-modified">  41 #include &quot;hb-set-private.hh&quot;</span>
<span class="line-modified">  42 </span>
<span class="line-modified">  43 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
<span class="line-modified">  44 //#include &quot;hb-aat-layout-private.hh&quot;</span>
<span class="line-modified">  45 </span>
<span class="line-modified">  46 static hb_tag_t common_features[] = {</span>
<span class="line-modified">  47   HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;),</span>
<span class="line-modified">  48   HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;),</span>
<span class="line-modified">  49   HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;),</span>
<span class="line-modified">  50   HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;),</span>
<span class="line-modified">  51   HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified">  52 };</span>










































































































































































  53 



  54 
<span class="line-modified">  55 static hb_tag_t horizontal_features[] = {</span>
<span class="line-modified">  56   HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;),</span>
<span class="line-modified">  57   HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified">  58   HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;),</span>
<span class="line-modified">  59   HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;),</span>
<span class="line-modified">  60   HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;),</span>
<span class="line-modified">  61   HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;),</span>


  62 };
  63 
  64 










  65 
  66 static void
  67 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
<span class="line-removed">  68                               const hb_segment_properties_t  *props,</span>
  69                               const hb_feature_t             *user_features,
  70                               unsigned int                    num_user_features)
  71 {
  72   hb_ot_map_builder_t *map = &amp;planner-&gt;map;
  73 
<span class="line-modified">  74   map-&gt;add_global_bool_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
  75   map-&gt;add_gsub_pause (nullptr);
  76 
<span class="line-modified">  77   switch (props-&gt;direction) {</span>
  78     case HB_DIRECTION_LTR:
<span class="line-modified">  79       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified">  80       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
  81       break;
  82     case HB_DIRECTION_RTL:
<span class="line-modified">  83       map-&gt;add_global_bool_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified">  84       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;), 1, F_NONE);</span>
  85       break;
  86     case HB_DIRECTION_TTB:
  87     case HB_DIRECTION_BTT:
  88     case HB_DIRECTION_INVALID:
  89     default:
  90       break;
  91   }
  92 
<span class="line-modified">  93   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;), 1, F_NONE);</span>
<span class="line-modified">  94   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;), 1, F_NONE);</span>
<span class="line-modified">  95   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;), 1, F_NONE);</span>











  96 
  97   if (planner-&gt;shaper-&gt;collect_features)
  98     planner-&gt;shaper-&gt;collect_features (planner);
  99 


 100   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<span class="line-modified"> 101     map-&gt;add_global_bool_feature (common_features[i]);</span>
 102 
<span class="line-modified"> 103   if (HB_DIRECTION_IS_HORIZONTAL (props-&gt;direction))</span>
 104     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<span class="line-modified"> 105       map-&gt;add_feature (horizontal_features[i], 1, F_GLOBAL |</span>
<span class="line-removed"> 106                         (horizontal_features[i] == HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) ?</span>
<span class="line-removed"> 107                          F_HAS_FALLBACK : F_NONE));</span>
 108   else
 109   {
 110     /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
 111      * matter which script/langsys it is listed (or not) under.
 112      * See various bugs referenced from:
 113      * https://github.com/harfbuzz/harfbuzz/issues/63 */
<span class="line-modified"> 114     map-&gt;add_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), 1, F_GLOBAL | F_GLOBAL_SEARCH);</span>
 115   }
 116 
<span class="line-modified"> 117   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-modified"> 118     planner-&gt;shaper-&gt;override_features (planner);</span>
<span class="line-removed"> 119 </span>
<span class="line-removed"> 120   for (unsigned int i = 0; i &lt; num_user_features; i++) {</span>
 121     const hb_feature_t *feature = &amp;user_features[i];
<span class="line-modified"> 122     map-&gt;add_feature (feature-&gt;tag, feature-&gt;value,</span>
<span class="line-modified"> 123                       (feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int) -1) ?</span>
<span class="line-modified"> 124                        F_GLOBAL : F_NONE);</span>

 125   }













 126 }
 127 
 128 
 129 /*
 130  * shaper face data
 131  */
 132 
<span class="line-modified"> 133 HB_SHAPER_DATA_ENSURE_DEFINE(ot, face)</span>
 134 
<span class="line-modified"> 135 hb_ot_shaper_face_data_t *</span>
 136 _hb_ot_shaper_face_data_create (hb_face_t *face)
 137 {
<span class="line-modified"> 138   return _hb_ot_layout_create (face);</span>
 139 }
 140 
 141 void
<span class="line-modified"> 142 _hb_ot_shaper_face_data_destroy (hb_ot_shaper_face_data_t *data)</span>
 143 {
<span class="line-removed"> 144   _hb_ot_layout_destroy (data);</span>
 145 }
 146 
 147 
 148 /*
 149  * shaper font data
 150  */
 151 
<span class="line-modified"> 152 HB_SHAPER_DATA_ENSURE_DEFINE(ot, font)</span>
<span class="line-removed"> 153 </span>
<span class="line-removed"> 154 struct hb_ot_shaper_font_data_t {};</span>
 155 
<span class="line-modified"> 156 hb_ot_shaper_font_data_t *</span>
 157 _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
 158 {
<span class="line-modified"> 159   return (hb_ot_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
<span class="line-removed"> 160 }</span>
<span class="line-removed"> 161 </span>
<span class="line-removed"> 162 void</span>
<span class="line-removed"> 163 _hb_ot_shaper_font_data_destroy (hb_ot_shaper_font_data_t *data)</span>
<span class="line-removed"> 164 {</span>
<span class="line-removed"> 165 }</span>
<span class="line-removed"> 166 </span>
<span class="line-removed"> 167 </span>
<span class="line-removed"> 168 /*</span>
<span class="line-removed"> 169  * shaper shape_plan data</span>
<span class="line-removed"> 170  */</span>
<span class="line-removed"> 171 </span>
<span class="line-removed"> 172 hb_ot_shaper_shape_plan_data_t *</span>
<span class="line-removed"> 173 _hb_ot_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,</span>
<span class="line-removed"> 174                                       const hb_feature_t *user_features,</span>
<span class="line-removed"> 175                                       unsigned int        num_user_features,</span>
<span class="line-removed"> 176                                       const int          *coords,</span>
<span class="line-removed"> 177                                       unsigned int        num_coords)</span>
<span class="line-removed"> 178 {</span>
<span class="line-removed"> 179   hb_ot_shape_plan_t *plan = (hb_ot_shape_plan_t *) calloc (1, sizeof (hb_ot_shape_plan_t));</span>
<span class="line-removed"> 180   if (unlikely (!plan))</span>
<span class="line-removed"> 181     return nullptr;</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183   plan-&gt;init ();</span>
<span class="line-removed"> 184 </span>
<span class="line-removed"> 185   hb_ot_shape_planner_t planner (shape_plan);</span>
<span class="line-removed"> 186 </span>
<span class="line-removed"> 187   planner.shaper = hb_ot_shape_complex_categorize (&amp;planner);</span>
<span class="line-removed"> 188 </span>
<span class="line-removed"> 189   hb_ot_shape_collect_features (&amp;planner, &amp;shape_plan-&gt;props,</span>
<span class="line-removed"> 190                                 user_features, num_user_features);</span>
<span class="line-removed"> 191 </span>
<span class="line-removed"> 192   planner.compile (*plan, coords, num_coords);</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194   if (plan-&gt;shaper-&gt;data_create) {</span>
<span class="line-removed"> 195     plan-&gt;data = plan-&gt;shaper-&gt;data_create (plan);</span>
<span class="line-removed"> 196     if (unlikely (!plan-&gt;data)) {</span>
<span class="line-removed"> 197       free(plan);</span>
<span class="line-removed"> 198       return nullptr;</span>
<span class="line-removed"> 199     }</span>
<span class="line-removed"> 200   }</span>
<span class="line-removed"> 201 </span>
<span class="line-removed"> 202   return plan;</span>
 203 }
 204 
 205 void
<span class="line-modified"> 206 _hb_ot_shaper_shape_plan_data_destroy (hb_ot_shaper_shape_plan_data_t *plan)</span>
 207 {
<span class="line-removed"> 208   if (plan-&gt;shaper-&gt;data_destroy)</span>
<span class="line-removed"> 209     plan-&gt;shaper-&gt;data_destroy (const_cast&lt;void *&gt; (plan-&gt;data));</span>
<span class="line-removed"> 210 </span>
<span class="line-removed"> 211   plan-&gt;fini ();</span>
<span class="line-removed"> 212 </span>
<span class="line-removed"> 213   free (plan);</span>
 214 }
 215 
 216 
 217 /*
 218  * shaper
 219  */
 220 
 221 struct hb_ot_shape_context_t
 222 {
 223   hb_ot_shape_plan_t *plan;
 224   hb_font_t *font;
 225   hb_face_t *face;
 226   hb_buffer_t  *buffer;
 227   const hb_feature_t *user_features;
 228   unsigned int        num_user_features;
 229 
 230   /* Transient stuff */
<span class="line-removed"> 231   bool fallback_positioning;</span>
<span class="line-removed"> 232   bool fallback_glyph_classes;</span>
 233   hb_direction_t target_direction;
 234 };
 235 
 236 
 237 
 238 /* Main shaper */
 239 
 240 
 241 /* Prepare */
 242 
 243 static void
 244 hb_set_unicode_props (hb_buffer_t *buffer)
 245 {








 246   unsigned int count = buffer-&gt;len;
 247   hb_glyph_info_t *info = buffer-&gt;info;
 248   for (unsigned int i = 0; i &lt; count; i++)

 249     _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);


































 250 }
 251 
 252 static void
 253 hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
 254 {
 255   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
 256       buffer-&gt;context_len[0] ||
<span class="line-modified"> 257       _hb_glyph_info_get_general_category (&amp;buffer-&gt;info[0]) !=</span>
<span class="line-removed"> 258       HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)</span>
 259     return;
 260 
 261   if (!font-&gt;has_glyph (0x25CCu))
 262     return;
 263 
 264   hb_glyph_info_t dottedcircle = {0};
 265   dottedcircle.codepoint = 0x25CCu;
 266   _hb_glyph_info_set_unicode_props (&amp;dottedcircle, buffer);
 267 
 268   buffer-&gt;clear_output ();
 269 
 270   buffer-&gt;idx = 0;
 271   hb_glyph_info_t info = dottedcircle;
 272   info.cluster = buffer-&gt;cur().cluster;
 273   info.mask = buffer-&gt;cur().mask;
 274   buffer-&gt;output_info (info);
 275   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
 276     buffer-&gt;next_glyph ();
<span class="line-removed"> 277 </span>
 278   buffer-&gt;swap_buffers ();
 279 }
 280 
 281 static void
 282 hb_form_clusters (hb_buffer_t *buffer)
 283 {
 284   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
 285     return;
 286 
<span class="line-removed"> 287   /* Loop duplicated in hb_ensure_native_direction(), and in _hb-coretext.cc */</span>
<span class="line-removed"> 288   unsigned int base = 0;</span>
<span class="line-removed"> 289   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed"> 290   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed"> 291   for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed"> 292   {</span>
<span class="line-removed"> 293     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])) &amp;&amp;</span>
<span class="line-removed"> 294                 !_hb_glyph_info_is_joiner (&amp;info[i])))</span>
<span class="line-removed"> 295     {</span>
<span class="line-removed"> 296       if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)</span>
<span class="line-removed"> 297         buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed"> 298       else</span>
<span class="line-removed"> 299         buffer-&gt;unsafe_to_break (base, i);</span>
<span class="line-removed"> 300       base = i;</span>
<span class="line-removed"> 301     }</span>
<span class="line-removed"> 302   }</span>
 303   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<span class="line-modified"> 304     buffer-&gt;merge_clusters (base, count);</span>

 305   else
<span class="line-modified"> 306     buffer-&gt;unsafe_to_break (base, count);</span>

 307 }
 308 
 309 static void
 310 hb_ensure_native_direction (hb_buffer_t *buffer)
 311 {
 312   hb_direction_t direction = buffer-&gt;props.direction;
 313   hb_direction_t horiz_dir = hb_script_get_horizontal_direction (buffer-&gt;props.script);
 314 
 315   /* TODO vertical:
 316    * The only BTT vertical script is Ogham, but it&#39;s not clear to me whether OpenType
 317    * Ogham fonts are supposed to be implemented BTT or not.  Need to research that
 318    * first. */
 319   if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
 320        direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
 321       (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
 322        direction != HB_DIRECTION_TTB))
 323   {
<span class="line-removed"> 324     /* Same loop as hb_form_clusters().</span>
<span class="line-removed"> 325      * Since form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-removed"> 326     unsigned int base = 0;</span>
<span class="line-removed"> 327     unsigned int count = buffer-&gt;len;</span>
<span class="line-removed"> 328     hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed"> 329     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed"> 330     {</span>
<span class="line-removed"> 331       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i]))))</span>
<span class="line-removed"> 332       {</span>
<span class="line-removed"> 333         if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)</span>
<span class="line-removed"> 334           buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed"> 335         buffer-&gt;reverse_range (base, i);</span>
 336 
<span class="line-removed"> 337         base = i;</span>
<span class="line-removed"> 338       }</span>
<span class="line-removed"> 339     }</span>
 340     if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<span class="line-modified"> 341       buffer-&gt;merge_clusters (base, count);</span>
<span class="line-modified"> 342     buffer-&gt;reverse_range (base, count);</span>







 343 
 344     buffer-&gt;reverse ();
 345 
 346     buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
 347   }
 348 }
 349 
 350 
<span class="line-modified"> 351 /* Substitute */</span>


 352 
 353 static inline void
<span class="line-modified"> 354 hb_ot_mirror_chars (hb_ot_shape_context_t *c)</span>
 355 {
 356   if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
 357     return;
 358 
 359   hb_buffer_t *buffer = c-&gt;buffer;
 360   hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 361   hb_mask_t rtlm_mask = c-&gt;plan-&gt;rtlm_mask;
 362 
 363   unsigned int count = buffer-&gt;len;
 364   hb_glyph_info_t *info = buffer-&gt;info;
 365   for (unsigned int i = 0; i &lt; count; i++) {
 366     hb_codepoint_t codepoint = unicode-&gt;mirroring (info[i].codepoint);
 367     if (likely (codepoint == info[i].codepoint || !c-&gt;font-&gt;has_glyph (codepoint)))
 368       info[i].mask |= rtlm_mask;
 369     else
 370       info[i].codepoint = codepoint;
 371   }
 372 }
 373 
 374 static inline void
<span class="line-modified"> 375 hb_ot_shape_setup_masks_fraction (hb_ot_shape_context_t *c)</span>
 376 {
 377   if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
 378       !c-&gt;plan-&gt;has_frac)
 379     return;
 380 
 381   hb_buffer_t *buffer = c-&gt;buffer;
 382 
 383   hb_mask_t pre_mask, post_mask;
 384   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction))
 385   {
 386     pre_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 387     post_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 388   }
 389   else
 390   {
 391     pre_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 392     post_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 393   }
 394 
 395   unsigned int count = buffer-&gt;len;
</pre>
<hr />
<pre>
 405         start--;
 406       while (end &lt; count &amp;&amp;
 407              _hb_glyph_info_get_general_category (&amp;info[end]) ==
 408              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
 409         end++;
 410 
 411       buffer-&gt;unsafe_to_break (start, end);
 412 
 413       for (unsigned int j = start; j &lt; i; j++)
 414         info[j].mask |= pre_mask;
 415       info[i].mask |= c-&gt;plan-&gt;frac_mask;
 416       for (unsigned int j = i + 1; j &lt; end; j++)
 417         info[j].mask |= post_mask;
 418 
 419       i = end - 1;
 420     }
 421   }
 422 }
 423 
 424 static inline void
<span class="line-modified"> 425 hb_ot_shape_initialize_masks (hb_ot_shape_context_t *c)</span>
 426 {
 427   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 428   hb_buffer_t *buffer = c-&gt;buffer;
 429 
 430   hb_mask_t global_mask = map-&gt;get_global_mask ();
 431   buffer-&gt;reset_masks (global_mask);
 432 }
 433 
 434 static inline void
<span class="line-modified"> 435 hb_ot_shape_setup_masks (hb_ot_shape_context_t *c)</span>
 436 {
 437   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 438   hb_buffer_t *buffer = c-&gt;buffer;
 439 
 440   hb_ot_shape_setup_masks_fraction (c);
 441 
 442   if (c-&gt;plan-&gt;shaper-&gt;setup_masks)
 443     c-&gt;plan-&gt;shaper-&gt;setup_masks (c-&gt;plan, buffer, c-&gt;font);
 444 
 445   for (unsigned int i = 0; i &lt; c-&gt;num_user_features; i++)
 446   {
 447     const hb_feature_t *feature = &amp;c-&gt;user_features[i];
 448     if (!(feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int)-1)) {
 449       unsigned int shift;
 450       hb_mask_t mask = map-&gt;get_mask (feature-&gt;tag, &amp;shift);
 451       buffer-&gt;set_masks (feature-&gt;value &lt;&lt; shift, mask, feature-&gt;start, feature-&gt;end);
 452     }
 453   }
 454 }
 455 
 456 static void
<span class="line-modified"> 457 hb_ot_zero_width_default_ignorables (hb_ot_shape_context_t *c)</span>
 458 {
<span class="line-removed"> 459   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed"> 460 </span>
 461   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 462       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
 463       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
 464     return;
 465 
 466   unsigned int count = buffer-&gt;len;
 467   hb_glyph_info_t *info = buffer-&gt;info;
 468   hb_glyph_position_t *pos = buffer-&gt;pos;
 469   unsigned int i = 0;
 470   for (i = 0; i &lt; count; i++)
 471     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
 472       pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
 473 }
 474 
 475 static void
<span class="line-modified"> 476 hb_ot_hide_default_ignorables (hb_ot_shape_context_t *c)</span>

 477 {
<span class="line-removed"> 478   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed"> 479 </span>
 480   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 481       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
 482     return;
 483 
 484   unsigned int count = buffer-&gt;len;
 485   hb_glyph_info_t *info = buffer-&gt;info;
<span class="line-removed"> 486   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-removed"> 487   unsigned int i = 0;</span>
<span class="line-removed"> 488   for (i = 0; i &lt; count; i++)</span>
<span class="line-removed"> 489   {</span>
<span class="line-removed"> 490     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))</span>
<span class="line-removed"> 491       break;</span>
<span class="line-removed"> 492   }</span>
<span class="line-removed"> 493 </span>
<span class="line-removed"> 494   /* No default-ignorables found; return. */</span>
<span class="line-removed"> 495   if (i == count)</span>
<span class="line-removed"> 496     return;</span>
 497 
<span class="line-modified"> 498   hb_codepoint_t space;</span>
 499   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<span class="line-modified"> 500       c-&gt;font-&gt;get_nominal_glyph (&#39; &#39;, &amp;space))</span>
 501   {
<span class="line-modified"> 502     /* Replace default-ignorables with a zero-advance space glyph. */</span>
<span class="line-modified"> 503     for (/*continue*/; i &lt; count; i++)</span>
 504     {
 505       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<span class="line-modified"> 506         info[i].codepoint = space;</span>
 507     }
 508   }
 509   else
<span class="line-modified"> 510   {</span>
<span class="line-removed"> 511     /* Merge clusters and delete default-ignorables.</span>
<span class="line-removed"> 512      * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-removed"> 513     unsigned int j = i;</span>
<span class="line-removed"> 514     for (; i &lt; count; i++)</span>
<span class="line-removed"> 515     {</span>
<span class="line-removed"> 516       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))</span>
<span class="line-removed"> 517       {</span>
<span class="line-removed"> 518         /* Merge clusters.</span>
<span class="line-removed"> 519          * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-removed"> 520 </span>
<span class="line-removed"> 521         unsigned int cluster = info[i].cluster;</span>
<span class="line-removed"> 522         if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-removed"> 523           continue; /* Cluster survives; do nothing. */</span>
<span class="line-removed"> 524 </span>
<span class="line-removed"> 525         if (j)</span>
<span class="line-removed"> 526         {</span>
<span class="line-removed"> 527           /* Merge cluster backward. */</span>
<span class="line-removed"> 528           if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-removed"> 529           {</span>
<span class="line-removed"> 530             unsigned int mask = info[i].mask;</span>
<span class="line-removed"> 531             unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-removed"> 532             for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-removed"> 533               buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-removed"> 534           }</span>
<span class="line-removed"> 535           continue;</span>
<span class="line-removed"> 536         }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538         if (i + 1 &lt; count)</span>
<span class="line-removed"> 539           buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-removed"> 540 </span>
<span class="line-removed"> 541         continue;</span>
<span class="line-removed"> 542       }</span>
<span class="line-removed"> 543 </span>
<span class="line-removed"> 544       if (j != i)</span>
<span class="line-removed"> 545       {</span>
<span class="line-removed"> 546         info[j] = info[i];</span>
<span class="line-removed"> 547         pos[j] = pos[i];</span>
<span class="line-removed"> 548       }</span>
<span class="line-removed"> 549       j++;</span>
<span class="line-removed"> 550     }</span>
<span class="line-removed"> 551     buffer-&gt;len = j;</span>
<span class="line-removed"> 552   }</span>
 553 }
 554 
 555 
 556 static inline void
 557 hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
 558 {
 559   /* Normalization process sets up glyph_index(), we just copy it. */
 560   unsigned int count = buffer-&gt;len;
 561   hb_glyph_info_t *info = buffer-&gt;info;
 562   for (unsigned int i = 0; i &lt; count; i++)
 563     info[i].codepoint = info[i].glyph_index();
 564 
 565   buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
 566 }
 567 
 568 static inline void
<span class="line-modified"> 569 hb_synthesize_glyph_classes (hb_ot_shape_context_t *c)</span>
 570 {
<span class="line-modified"> 571   unsigned int count = c-&gt;buffer-&gt;len;</span>
<span class="line-modified"> 572   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;</span>
 573   for (unsigned int i = 0; i &lt; count; i++)
 574   {
 575     hb_ot_layout_glyph_props_flags_t klass;
 576 
 577     /* Never mark default-ignorables as marks.
 578      * They won&#39;t get in the way of lookups anyway,
 579      * but having them as mark will cause them to be skipped
 580      * over if the lookup-flag says so, but at least for the
 581      * Mongolian variation selectors, looks like Uniscribe
 582      * marks them as non-mark.  Some Mongolian fonts without
 583      * GDEF rely on this.  Another notable character that
 584      * this applies to is COMBINING GRAPHEME JOINER. */
 585     klass = (_hb_glyph_info_get_general_category (&amp;info[i]) !=
 586              HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ||
 587              _hb_glyph_info_is_default_ignorable (&amp;info[i])) ?
 588             HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH :
 589             HB_OT_LAYOUT_GLYPH_PROPS_MARK;
 590     _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
 591   }
 592 }
 593 
 594 static inline void
<span class="line-modified"> 595 hb_ot_substitute_default (hb_ot_shape_context_t *c)</span>
 596 {
 597   hb_buffer_t *buffer = c-&gt;buffer;
 598 
 599   hb_ot_mirror_chars (c);
 600 
 601   HB_BUFFER_ALLOCATE_VAR (buffer, glyph_index);
 602 
 603   _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
 604 
 605   hb_ot_shape_setup_masks (c);
 606 
 607   /* This is unfortunate to go here, but necessary... */
<span class="line-modified"> 608   if (c-&gt;fallback_positioning)</span>
<span class="line-modified"> 609     _hb_ot_shape_fallback_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
 610 
 611   hb_ot_map_glyphs_fast (buffer);
 612 
 613   HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
 614 }
 615 
 616 static inline void
<span class="line-modified"> 617 hb_ot_substitute_complex (hb_ot_shape_context_t *c)</span>
 618 {
 619   hb_buffer_t *buffer = c-&gt;buffer;
 620 
 621   hb_ot_layout_substitute_start (c-&gt;font, buffer);
 622 
<span class="line-modified"> 623   if (!hb_ot_layout_has_glyph_classes (c-&gt;face))</span>
<span class="line-modified"> 624     hb_synthesize_glyph_classes (c);</span>
 625 
 626   c-&gt;plan-&gt;substitute (c-&gt;font, buffer);
<span class="line-removed"> 627 </span>
<span class="line-removed"> 628   /* XXX Call morx instead. */</span>
<span class="line-removed"> 629   //hb_aat_layout_substitute (c-&gt;font, c-&gt;buffer);</span>
 630 }
 631 
 632 static inline void
<span class="line-modified"> 633 hb_ot_substitute (hb_ot_shape_context_t *c)</span>
 634 {
 635   hb_ot_substitute_default (c);
 636 
 637   _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
 638 
 639   hb_ot_substitute_complex (c);
 640 }
 641 
<span class="line-modified"> 642 /* Position */</span>














 643 
 644 static inline void
 645 adjust_mark_offsets (hb_glyph_position_t *pos)
 646 {
 647   pos-&gt;x_offset -= pos-&gt;x_advance;
 648   pos-&gt;y_offset -= pos-&gt;y_advance;
 649 }
 650 
 651 static inline void
 652 zero_mark_width (hb_glyph_position_t *pos)
 653 {
 654   pos-&gt;x_advance = 0;
 655   pos-&gt;y_advance = 0;
 656 }
 657 
 658 static inline void
 659 zero_mark_widths_by_gdef (hb_buffer_t *buffer, bool adjust_offsets)
 660 {
 661   unsigned int count = buffer-&gt;len;
 662   hb_glyph_info_t *info = buffer-&gt;info;
 663   for (unsigned int i = 0; i &lt; count; i++)
 664     if (_hb_glyph_info_is_mark (&amp;info[i]))
 665     {
 666       if (adjust_offsets)
 667         adjust_mark_offsets (&amp;buffer-&gt;pos[i]);
 668       zero_mark_width (&amp;buffer-&gt;pos[i]);
 669     }
 670 }
 671 
 672 static inline void
<span class="line-modified"> 673 hb_ot_position_default (hb_ot_shape_context_t *c)</span>
 674 {
 675   hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
 676   unsigned int count = c-&gt;buffer-&gt;len;
 677   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 678   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 679 
 680   if (HB_DIRECTION_IS_HORIZONTAL (direction))
 681   {
<span class="line-modified"> 682     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified"> 683       pos[i].x_advance = c-&gt;font-&gt;get_glyph_h_advance (info[i].codepoint);</span>
 684     /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 685     if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 686       for (unsigned int i = 0; i &lt; count; i++)
 687         c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 688                                           &amp;pos[i].x_offset,
 689                                           &amp;pos[i].y_offset);
 690   }
 691   else
 692   {


 693     for (unsigned int i = 0; i &lt; count; i++)
 694     {
<span class="line-removed"> 695       pos[i].y_advance = c-&gt;font-&gt;get_glyph_v_advance (info[i].codepoint);</span>
 696       c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
 697                                         &amp;pos[i].x_offset,
 698                                         &amp;pos[i].y_offset);
 699     }
 700   }
 701   if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
 702     _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
 703 }
 704 
 705 static inline void
<span class="line-modified"> 706 hb_ot_position_complex (hb_ot_shape_context_t *c)</span>
 707 {
 708   unsigned int count = c-&gt;buffer-&gt;len;
 709   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 710   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 711 
<span class="line-modified"> 712   /* If the font has no GPOS, AND, no fallback positioning will</span>
<span class="line-modified"> 713    * happen, AND, direction is forward, then when zeroing mark</span>
<span class="line-modified"> 714    * widths, we shift the mark with it, such that the mark</span>
<span class="line-removed"> 715    * is positioned hanging over the previous glyph.  When</span>
 716    * direction is backward we don&#39;t shift and it will end up
 717    * hanging over the next glyph after the final reordering.
<span class="line-modified"> 718    * If fallback positinoing happens or GPOS is present, we don&#39;t</span>
<span class="line-modified"> 719    * care.</span>

 720    */
<span class="line-modified"> 721   bool adjust_offsets_when_zeroing = c-&gt;fallback_positioning &amp;&amp;</span>
<span class="line-removed"> 722                                      !c-&gt;plan-&gt;shaper-&gt;fallback_position &amp;&amp;</span>
 723                                      HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
 724 
 725   /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
 726 
 727   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 728   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 729     for (unsigned int i = 0; i &lt; count; i++)
 730       c-&gt;font-&gt;add_glyph_h_origin (info[i].codepoint,
 731                                    &amp;pos[i].x_offset,
 732                                    &amp;pos[i].y_offset);
 733 
 734   hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
 735 
<span class="line-modified"> 736   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified"> 737   {</span>
<span class="line-modified"> 738     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified"> 739       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified"> 740       break;</span>
<span class="line-modified"> 741 </span>
<span class="line-modified"> 742     default:</span>
<span class="line-modified"> 743     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified"> 744     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified"> 745       break;</span>
<span class="line-modified"> 746   }</span>
<span class="line-modified"> 747 </span>
<span class="line-removed"> 748   if (likely (!c-&gt;fallback_positioning))</span>
<span class="line-removed"> 749     c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>
 750 
<span class="line-modified"> 751   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-removed"> 752   {</span>
<span class="line-removed"> 753     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-removed"> 754       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-removed"> 755       break;</span>
 756 
<span class="line-modified"> 757     default:</span>
<span class="line-modified"> 758     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified"> 759     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified"> 760       break;</span>
<span class="line-modified"> 761   }</span>







 762 
<span class="line-modified"> 763   /* Finishing off GPOS has to follow a certain order. */</span>
 764   hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<span class="line-modified"> 765   hb_ot_zero_width_default_ignorables (c);</span>


 766   hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
 767 
 768   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 769   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 770     for (unsigned int i = 0; i &lt; count; i++)
 771       c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 772                                         &amp;pos[i].x_offset,
 773                                         &amp;pos[i].y_offset);




 774 }
 775 
 776 static inline void
<span class="line-modified"> 777 hb_ot_position (hb_ot_shape_context_t *c)</span>
 778 {
 779   c-&gt;buffer-&gt;clear_positions ();
 780 
 781   hb_ot_position_default (c);
 782 
 783   hb_ot_position_complex (c);
 784 
<span class="line-removed"> 785   if (c-&gt;fallback_positioning &amp;&amp; c-&gt;plan-&gt;shaper-&gt;fallback_position)</span>
<span class="line-removed"> 786     _hb_ot_shape_fallback_position (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed"> 787 </span>
 788   if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
 789     hb_buffer_reverse (c-&gt;buffer);
 790 
<span class="line-removed"> 791   /* Visual fallback goes here. */</span>
<span class="line-removed"> 792 </span>
<span class="line-removed"> 793   if (c-&gt;fallback_positioning)</span>
<span class="line-removed"> 794     _hb_ot_shape_fallback_kern (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed"> 795 </span>
 796   _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);
<span class="line-removed"> 797 </span>
<span class="line-removed"> 798   //hb_aat_layout_position (c-&gt;font, c-&gt;buffer);</span>
 799 }
 800 
 801 static inline void
 802 hb_propagate_flags (hb_buffer_t *buffer)
 803 {
 804   /* Propagate cluster-level glyph flags to be the same on all cluster glyphs.
 805    * Simplifies using them. */
 806 
 807   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))
 808     return;
 809 
 810   hb_glyph_info_t *info = buffer-&gt;info;
 811 
 812   foreach_cluster (buffer, start, end)
 813   {
 814     unsigned int mask = 0;
 815     for (unsigned int i = start; i &lt; end; i++)
 816       if (info[i].mask &amp; HB_GLYPH_FLAG_UNSAFE_TO_BREAK)
 817       {
 818          mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
 819          break;
 820       }
 821     if (mask)
 822       for (unsigned int i = start; i &lt; end; i++)
 823         info[i].mask |= mask;
 824   }
 825 }
 826 
 827 /* Pull it all together! */
 828 
 829 static void
 830 hb_ot_shape_internal (hb_ot_shape_context_t *c)
 831 {
 832   c-&gt;buffer-&gt;deallocate_var_all ();
 833   c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<span class="line-modified"> 834   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
 835   {
 836     c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
 837                               (unsigned) HB_BUFFER_MAX_LEN_MIN);
 838   }
<span class="line-modified"> 839   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
 840   {
 841     c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
 842                               (unsigned) HB_BUFFER_MAX_OPS_MIN);
 843   }
 844 
<span class="line-removed"> 845   bool disable_otl = c-&gt;plan-&gt;shaper-&gt;disable_otl &amp;&amp; c-&gt;plan-&gt;shaper-&gt;disable_otl (c-&gt;plan);</span>
<span class="line-removed"> 846   //c-&gt;fallback_substitute     = disable_otl || !hb_ot_layout_has_substitution (c-&gt;face);</span>
<span class="line-removed"> 847   c-&gt;fallback_positioning    = disable_otl || !hb_ot_layout_has_positioning (c-&gt;face);</span>
<span class="line-removed"> 848   c-&gt;fallback_glyph_classes  = disable_otl || !hb_ot_layout_has_glyph_classes (c-&gt;face);</span>
<span class="line-removed"> 849 </span>
 850   /* Save the original direction, we use it later. */
 851   c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
 852 
 853   _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
 854 
 855   c-&gt;buffer-&gt;clear_output ();
 856 
 857   hb_ot_shape_initialize_masks (c);
 858   hb_set_unicode_props (c-&gt;buffer);
 859   hb_insert_dotted_circle (c-&gt;buffer, c-&gt;font);
 860 
 861   hb_form_clusters (c-&gt;buffer);
 862 
 863   hb_ensure_native_direction (c-&gt;buffer);
 864 
 865   if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
 866     c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
 867 
<span class="line-modified"> 868   hb_ot_substitute (c);</span>
 869   hb_ot_position (c);
<span class="line-modified"> 870 </span>
<span class="line-removed"> 871   hb_ot_hide_default_ignorables (c);</span>
<span class="line-removed"> 872 </span>
<span class="line-removed"> 873   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-removed"> 874     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
 875 
 876   hb_propagate_flags (c-&gt;buffer);
 877 
 878   _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
 879 
 880   c-&gt;buffer-&gt;props.direction = c-&gt;target_direction;
 881 
 882   c-&gt;buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
 883   c-&gt;buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
 884   c-&gt;buffer-&gt;deallocate_var_all ();
 885 }
 886 
 887 
 888 hb_bool_t
 889 _hb_ot_shape (hb_shape_plan_t    *shape_plan,
 890               hb_font_t          *font,
 891               hb_buffer_t        *buffer,
 892               const hb_feature_t *features,
 893               unsigned int        num_features)
 894 {
<span class="line-modified"> 895   hb_ot_shape_context_t c = {HB_SHAPER_DATA_GET (shape_plan), font, font-&gt;face, buffer, features, num_features};</span>
 896   hb_ot_shape_internal (&amp;c);
 897 
 898   return true;
 899 }
 900 
 901 
 902 /**
 903  * hb_ot_shape_plan_collect_lookups:
 904  *
 905  * Since: 0.9.7
 906  **/
 907 void
 908 hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
 909                                   hb_tag_t         table_tag,
 910                                   hb_set_t        *lookup_indexes /* OUT */)
 911 {
<span class="line-modified"> 912   /* XXX Does the first part always succeed? */</span>
<span class="line-removed"> 913   HB_SHAPER_DATA_GET (shape_plan)-&gt;collect_lookups (table_tag, lookup_indexes);</span>
 914 }
 915 
 916 
 917 /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
 918 static void
 919 add_char (hb_font_t          *font,
 920           hb_unicode_funcs_t *unicode,
 921           hb_bool_t           mirror,
 922           hb_codepoint_t      u,
 923           hb_set_t           *glyphs)
 924 {
 925   hb_codepoint_t glyph;
 926   if (font-&gt;get_nominal_glyph (u, &amp;glyph))
 927     glyphs-&gt;add (glyph);
 928   if (mirror)
 929   {
 930     hb_codepoint_t m = unicode-&gt;mirroring (u);
 931     if (m != u &amp;&amp; font-&gt;get_nominal_glyph (m, &amp;glyph))
 932       glyphs-&gt;add (glyph);
 933   }
</pre>
</td>
<td>
<hr />
<pre>
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<span class="line-modified">  29 #include &quot;hb-shaper-impl.hh&quot;</span>
<span class="line-modified">  30 </span>
<span class="line-modified">  31 #include &quot;hb-ot-shape.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-shape-complex.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-shape-fallback.hh&quot;</span>
<span class="line-modified">  34 #include &quot;hb-ot-shape-normalize.hh&quot;</span>
<span class="line-modified">  35 </span>
<span class="line-modified">  36 #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">  37 </span>
<span class="line-modified">  38 #include &quot;hb-set.hh&quot;</span>
<span class="line-modified">  39 </span>
<span class="line-modified">  40 #include &quot;hb-aat-layout.hh&quot;</span>
<span class="line-modified">  41 </span>
<span class="line-modified">  42 </span>
<span class="line-modified">  43 /**</span>
<span class="line-modified">  44  * SECTION:hb-ot-shape</span>
<span class="line-modified">  45  * @title: hb-ot-shape</span>
<span class="line-modified">  46  * @short_description: OpenType shaping support</span>
<span class="line-modified">  47  * @include: hb-ot.h</span>
<span class="line-modified">  48  *</span>
<span class="line-modified">  49  * Support functions for OpenType shaping related queries.</span>
<span class="line-modified">  50  **/</span>
<span class="line-modified">  51 </span>
<span class="line-modified">  52 </span>
<span class="line-added">  53 static void</span>
<span class="line-added">  54 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,</span>
<span class="line-added">  55                               const hb_feature_t             *user_features,</span>
<span class="line-added">  56                               unsigned int                    num_user_features);</span>
<span class="line-added">  57 </span>
<span class="line-added">  58 static bool</span>
<span class="line-added">  59 _hb_apply_morx (hb_face_t *face)</span>
<span class="line-added">  60 {</span>
<span class="line-added">  61   if (hb_options ().aat &amp;&amp;</span>
<span class="line-added">  62       hb_aat_layout_has_substitution (face))</span>
<span class="line-added">  63     return true;</span>
<span class="line-added">  64 </span>
<span class="line-added">  65   /* Ignore empty GSUB tables. */</span>
<span class="line-added">  66   return (!hb_ot_layout_has_substitution (face) ||</span>
<span class="line-added">  67           !hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-added">  68                                                HB_OT_TAG_GSUB,</span>
<span class="line-added">  69                                                0, nullptr, nullptr)) &amp;&amp;</span>
<span class="line-added">  70          hb_aat_layout_has_substitution (face);</span>
<span class="line-added">  71 }</span>
<span class="line-added">  72 </span>
<span class="line-added">  73 hb_ot_shape_planner_t::hb_ot_shape_planner_t (hb_face_t                     *face,</span>
<span class="line-added">  74                                               const hb_segment_properties_t *props) :</span>
<span class="line-added">  75                                                 face (face),</span>
<span class="line-added">  76                                                 props (*props),</span>
<span class="line-added">  77                                                 map (face, props),</span>
<span class="line-added">  78                                                 aat_map (face, props),</span>
<span class="line-added">  79                                                 apply_morx (_hb_apply_morx (face))</span>
<span class="line-added">  80 {</span>
<span class="line-added">  81   shaper = hb_ot_shape_complex_categorize (this);</span>
<span class="line-added">  82 </span>
<span class="line-added">  83   script_zero_marks = shaper-&gt;zero_width_marks != HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE;</span>
<span class="line-added">  84   script_fallback_mark_positioning = shaper-&gt;fallback_position;</span>
<span class="line-added">  85 </span>
<span class="line-added">  86   if (apply_morx)</span>
<span class="line-added">  87     shaper = &amp;_hb_ot_complex_shaper_default;</span>
<span class="line-added">  88 }</span>
<span class="line-added">  89 </span>
<span class="line-added">  90 void</span>
<span class="line-added">  91 hb_ot_shape_planner_t::compile (hb_ot_shape_plan_t           &amp;plan,</span>
<span class="line-added">  92                                 const hb_ot_shape_plan_key_t &amp;key)</span>
<span class="line-added">  93 {</span>
<span class="line-added">  94   plan.props = props;</span>
<span class="line-added">  95   plan.shaper = shaper;</span>
<span class="line-added">  96   map.compile (plan.map, key);</span>
<span class="line-added">  97   if (apply_morx)</span>
<span class="line-added">  98     aat_map.compile (plan.aat_map);</span>
<span class="line-added">  99 </span>
<span class="line-added"> 100   plan.frac_mask = plan.map.get_1_mask (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-added"> 101   plan.numr_mask = plan.map.get_1_mask (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added"> 102   plan.dnom_mask = plan.map.get_1_mask (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added"> 103   plan.has_frac = plan.frac_mask || (plan.numr_mask &amp;&amp; plan.dnom_mask);</span>
<span class="line-added"> 104   plan.rtlm_mask = plan.map.get_1_mask (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
<span class="line-added"> 105   hb_tag_t kern_tag = HB_DIRECTION_IS_HORIZONTAL (props.direction) ?</span>
<span class="line-added"> 106                       HB_TAG (&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) : HB_TAG (&#39;v&#39;,&#39;k&#39;,&#39;r&#39;,&#39;n&#39;);</span>
<span class="line-added"> 107   plan.kern_mask = plan.map.get_mask (kern_tag);</span>
<span class="line-added"> 108   plan.trak_mask = plan.map.get_mask (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;));</span>
<span class="line-added"> 109 </span>
<span class="line-added"> 110   plan.requested_kerning = !!plan.kern_mask;</span>
<span class="line-added"> 111   plan.requested_tracking = !!plan.trak_mask;</span>
<span class="line-added"> 112   bool has_gpos_kern = plan.map.get_feature_index (1, kern_tag) != HB_OT_LAYOUT_NO_FEATURE_INDEX;</span>
<span class="line-added"> 113   bool disable_gpos = plan.shaper-&gt;gpos_tag &amp;&amp;</span>
<span class="line-added"> 114                       plan.shaper-&gt;gpos_tag != plan.map.chosen_script[1];</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116   /*</span>
<span class="line-added"> 117    * Decide who provides glyph classes. GDEF or Unicode.</span>
<span class="line-added"> 118    */</span>
<span class="line-added"> 119 </span>
<span class="line-added"> 120   if (!hb_ot_layout_has_glyph_classes (face))</span>
<span class="line-added"> 121     plan.fallback_glyph_classes = true;</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123   /*</span>
<span class="line-added"> 124    * Decide who does substitutions. GSUB, morx, or fallback.</span>
<span class="line-added"> 125    */</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   plan.apply_morx = apply_morx;</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129   /*</span>
<span class="line-added"> 130    * Decide who does positioning. GPOS, kerx, kern, or fallback.</span>
<span class="line-added"> 131    */</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133   if (hb_options ().aat &amp;&amp; hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 134     plan.apply_kerx = true;</span>
<span class="line-added"> 135   else if (!apply_morx &amp;&amp; !disable_gpos &amp;&amp; hb_ot_layout_has_positioning (face))</span>
<span class="line-added"> 136     plan.apply_gpos = true;</span>
<span class="line-added"> 137   else if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 138     plan.apply_kerx = true;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   if (!plan.apply_kerx &amp;&amp; !has_gpos_kern)</span>
<span class="line-added"> 141   {</span>
<span class="line-added"> 142     /* Apparently Apple applies kerx if GPOS kern was not applied. */</span>
<span class="line-added"> 143     if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 144       plan.apply_kerx = true;</span>
<span class="line-added"> 145     else if (hb_ot_layout_has_kerning (face))</span>
<span class="line-added"> 146       plan.apply_kern = true;</span>
<span class="line-added"> 147   }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149   plan.zero_marks = script_zero_marks &amp;&amp;</span>
<span class="line-added"> 150                     !plan.apply_kerx &amp;&amp;</span>
<span class="line-added"> 151                     (!plan.apply_kern || !hb_ot_layout_has_machine_kerning (face));</span>
<span class="line-added"> 152   plan.has_gpos_mark = !!plan.map.get_1_mask (HB_TAG (&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;));</span>
<span class="line-added"> 153 </span>
<span class="line-added"> 154   plan.adjust_mark_positioning_when_zeroing = !plan.apply_gpos &amp;&amp;</span>
<span class="line-added"> 155                                               !plan.apply_kerx &amp;&amp;</span>
<span class="line-added"> 156                                               (!plan.apply_kern || !hb_ot_layout_has_cross_kerning (face));</span>
<span class="line-added"> 157 </span>
<span class="line-added"> 158   plan.fallback_mark_positioning = plan.adjust_mark_positioning_when_zeroing &amp;&amp;</span>
<span class="line-added"> 159                                    script_fallback_mark_positioning;</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161   /* Currently we always apply trak. */</span>
<span class="line-added"> 162   plan.apply_trak = plan.requested_tracking &amp;&amp; hb_aat_layout_has_tracking (face);</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 bool</span>
<span class="line-added"> 166 hb_ot_shape_plan_t::init0 (hb_face_t                     *face,</span>
<span class="line-added"> 167                            const hb_shape_plan_key_t     *key)</span>
<span class="line-added"> 168 {</span>
<span class="line-added"> 169   map.init ();</span>
<span class="line-added"> 170   aat_map.init ();</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172   hb_ot_shape_planner_t planner (face,</span>
<span class="line-added"> 173                                  &amp;key-&gt;props);</span>
<span class="line-added"> 174 </span>
<span class="line-added"> 175   hb_ot_shape_collect_features (&amp;planner,</span>
<span class="line-added"> 176                                 key-&gt;user_features,</span>
<span class="line-added"> 177                                 key-&gt;num_user_features);</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179   planner.compile (*this, key-&gt;ot);</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181   if (shaper-&gt;data_create)</span>
<span class="line-added"> 182   {</span>
<span class="line-added"> 183     data = shaper-&gt;data_create (this);</span>
<span class="line-added"> 184     if (unlikely (!data))</span>
<span class="line-added"> 185       return false;</span>
<span class="line-added"> 186   }</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188   return true;</span>
<span class="line-added"> 189 }</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191 void</span>
<span class="line-added"> 192 hb_ot_shape_plan_t::fini ()</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194   if (shaper-&gt;data_destroy)</span>
<span class="line-added"> 195     shaper-&gt;data_destroy (const_cast&lt;void *&gt; (data));</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197   map.fini ();</span>
<span class="line-added"> 198   aat_map.fini ();</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 void</span>
<span class="line-added"> 202 hb_ot_shape_plan_t::substitute (hb_font_t   *font,</span>
<span class="line-added"> 203                                 hb_buffer_t *buffer) const</span>
<span class="line-added"> 204 {</span>
<span class="line-added"> 205   if (unlikely (apply_morx))</span>
<span class="line-added"> 206     hb_aat_layout_substitute (this, font, buffer);</span>
<span class="line-added"> 207   else</span>
<span class="line-added"> 208     map.substitute (this, font, buffer);</span>
<span class="line-added"> 209 }</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211 void</span>
<span class="line-added"> 212 hb_ot_shape_plan_t::position (hb_font_t   *font,</span>
<span class="line-added"> 213                               hb_buffer_t *buffer) const</span>
<span class="line-added"> 214 {</span>
<span class="line-added"> 215   if (this-&gt;apply_gpos)</span>
<span class="line-added"> 216     map.position (this, font, buffer);</span>
<span class="line-added"> 217   else if (this-&gt;apply_kerx)</span>
<span class="line-added"> 218     hb_aat_layout_position (this, font, buffer);</span>
<span class="line-added"> 219   else if (this-&gt;apply_kern)</span>
<span class="line-added"> 220     hb_ot_layout_kern (this, font, buffer);</span>
<span class="line-added"> 221   else</span>
<span class="line-added"> 222     _hb_ot_shape_fallback_kern (this, font, buffer);</span>
 223 
<span class="line-added"> 224   if (this-&gt;apply_trak)</span>
<span class="line-added"> 225     hb_aat_layout_track (this, font, buffer);</span>
<span class="line-added"> 226 }</span>
 227 
<span class="line-modified"> 228 </span>
<span class="line-modified"> 229 static const hb_ot_map_feature_t</span>
<span class="line-modified"> 230 common_features[] =</span>
<span class="line-modified"> 231 {</span>
<span class="line-modified"> 232   {HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;), F_GLOBAL},</span>
<span class="line-modified"> 233   {HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;), F_GLOBAL},</span>
<span class="line-modified"> 234   {HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 235   {HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 236   {HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
 237 };
 238 
 239 
<span class="line-added"> 240 static const hb_ot_map_feature_t</span>
<span class="line-added"> 241 horizontal_features[] =</span>
<span class="line-added"> 242 {</span>
<span class="line-added"> 243   {HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added"> 244   {HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
<span class="line-added"> 245   {HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-added"> 246   {HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), F_GLOBAL_HAS_FALLBACK},</span>
<span class="line-added"> 247   {HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), F_GLOBAL},</span>
<span class="line-added"> 248   {HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added"> 249 };</span>
 250 
 251 static void
 252 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,

 253                               const hb_feature_t             *user_features,
 254                               unsigned int                    num_user_features)
 255 {
 256   hb_ot_map_builder_t *map = &amp;planner-&gt;map;
 257 
<span class="line-modified"> 258   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
 259   map-&gt;add_gsub_pause (nullptr);
 260 
<span class="line-modified"> 261   switch (planner-&gt;props.direction) {</span>
 262     case HB_DIRECTION_LTR:
<span class="line-modified"> 263       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 264       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
 265       break;
 266     case HB_DIRECTION_RTL:
<span class="line-modified"> 267       map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 268       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
 269       break;
 270     case HB_DIRECTION_TTB:
 271     case HB_DIRECTION_BTT:
 272     case HB_DIRECTION_INVALID:
 273     default:
 274       break;
 275   }
 276 
<span class="line-modified"> 277   /* Automatic fractions. */</span>
<span class="line-modified"> 278   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-modified"> 279   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added"> 280   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282   /* Random! */</span>
<span class="line-added"> 283   map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), F_RANDOM, HB_OT_MAP_MAX_VALUE);</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285   /* Tracking.  We enable dummy feature here just to allow disabling</span>
<span class="line-added"> 286    * AAT &#39;trak&#39; table using features.</span>
<span class="line-added"> 287    * https://github.com/harfbuzz/harfbuzz/issues/1303 */</span>
<span class="line-added"> 288   map-&gt;enable_feature (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;), F_HAS_FALLBACK);</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290   map-&gt;enable_feature (HB_TAG (&#39;H&#39;,&#39;A&#39;,&#39;R&#39;,&#39;F&#39;));</span>
 291 
 292   if (planner-&gt;shaper-&gt;collect_features)
 293     planner-&gt;shaper-&gt;collect_features (planner);
 294 
<span class="line-added"> 295   map-&gt;enable_feature (HB_TAG (&#39;B&#39;,&#39;U&#39;,&#39;Z&#39;,&#39;Z&#39;));</span>
<span class="line-added"> 296 </span>
 297   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<span class="line-modified"> 298     map-&gt;add_feature (common_features[i]);</span>
 299 
<span class="line-modified"> 300   if (HB_DIRECTION_IS_HORIZONTAL (planner-&gt;props.direction))</span>
 301     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<span class="line-modified"> 302       map-&gt;add_feature (horizontal_features[i]);</span>


 303   else
 304   {
 305     /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
 306      * matter which script/langsys it is listed (or not) under.
 307      * See various bugs referenced from:
 308      * https://github.com/harfbuzz/harfbuzz/issues/63 */
<span class="line-modified"> 309     map-&gt;enable_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), F_GLOBAL_SEARCH);</span>
 310   }
 311 
<span class="line-modified"> 312   for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-modified"> 313   {</span>


 314     const hb_feature_t *feature = &amp;user_features[i];
<span class="line-modified"> 315     map-&gt;add_feature (feature-&gt;tag,</span>
<span class="line-modified"> 316                       (feature-&gt;start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-modified"> 317                        feature-&gt;end == HB_FEATURE_GLOBAL_END) ?  F_GLOBAL : F_NONE,</span>
<span class="line-added"> 318                       feature-&gt;value);</span>
 319   }
<span class="line-added"> 320 </span>
<span class="line-added"> 321   if (planner-&gt;apply_morx)</span>
<span class="line-added"> 322   {</span>
<span class="line-added"> 323     hb_aat_map_builder_t *aat_map = &amp;planner-&gt;aat_map;</span>
<span class="line-added"> 324     for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added"> 325     {</span>
<span class="line-added"> 326       const hb_feature_t *feature = &amp;user_features[i];</span>
<span class="line-added"> 327       aat_map-&gt;add_feature (feature-&gt;tag, feature-&gt;value);</span>
<span class="line-added"> 328     }</span>
<span class="line-added"> 329   }</span>
<span class="line-added"> 330 </span>
<span class="line-added"> 331   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-added"> 332     planner-&gt;shaper-&gt;override_features (planner);</span>
 333 }
 334 
 335 
 336 /*
 337  * shaper face data
 338  */
 339 
<span class="line-modified"> 340 struct hb_ot_face_data_t {};</span>
 341 
<span class="line-modified"> 342 hb_ot_face_data_t *</span>
 343 _hb_ot_shaper_face_data_create (hb_face_t *face)
 344 {
<span class="line-modified"> 345   return (hb_ot_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
 346 }
 347 
 348 void
<span class="line-modified"> 349 _hb_ot_shaper_face_data_destroy (hb_ot_face_data_t *data)</span>
 350 {

 351 }
 352 
 353 
 354 /*
 355  * shaper font data
 356  */
 357 
<span class="line-modified"> 358 struct hb_ot_font_data_t {};</span>


 359 
<span class="line-modified"> 360 hb_ot_font_data_t *</span>
 361 _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
 362 {
<span class="line-modified"> 363   return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>











































 364 }
 365 
 366 void
<span class="line-modified"> 367 _hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data HB_UNUSED)</span>
 368 {






 369 }
 370 
 371 
 372 /*
 373  * shaper
 374  */
 375 
 376 struct hb_ot_shape_context_t
 377 {
 378   hb_ot_shape_plan_t *plan;
 379   hb_font_t *font;
 380   hb_face_t *face;
 381   hb_buffer_t  *buffer;
 382   const hb_feature_t *user_features;
 383   unsigned int        num_user_features;
 384 
 385   /* Transient stuff */


 386   hb_direction_t target_direction;
 387 };
 388 
 389 
 390 
 391 /* Main shaper */
 392 
 393 
 394 /* Prepare */
 395 
 396 static void
 397 hb_set_unicode_props (hb_buffer_t *buffer)
 398 {
<span class="line-added"> 399   /* Implement enough of Unicode Graphemes here that shaping</span>
<span class="line-added"> 400    * in reverse-direction wouldn&#39;t break graphemes.  Namely,</span>
<span class="line-added"> 401    * we mark all marks and ZWJ and ZWJ,Extended_Pictographic</span>
<span class="line-added"> 402    * sequences as continuations.  The foreach_grapheme()</span>
<span class="line-added"> 403    * macro uses this bit.</span>
<span class="line-added"> 404    *</span>
<span class="line-added"> 405    * https://www.unicode.org/reports/tr29/#Regex_Definitions</span>
<span class="line-added"> 406    */</span>
 407   unsigned int count = buffer-&gt;len;
 408   hb_glyph_info_t *info = buffer-&gt;info;
 409   for (unsigned int i = 0; i &lt; count; i++)
<span class="line-added"> 410   {</span>
 411     _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);
<span class="line-added"> 412 </span>
<span class="line-added"> 413     /* Marks are already set as continuation by the above line.</span>
<span class="line-added"> 414      * Handle Emoji_Modifier and ZWJ-continuation. */</span>
<span class="line-added"> 415     if (unlikely (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL &amp;&amp;</span>
<span class="line-added"> 416                   hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0x1F3FBu, 0x1F3FFu)))</span>
<span class="line-added"> 417     {</span>
<span class="line-added"> 418         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420     else if (unlikely (_hb_glyph_info_is_zwj (&amp;info[i])))</span>
<span class="line-added"> 421     {</span>
<span class="line-added"> 422       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 423       if (i + 1 &lt; count &amp;&amp;</span>
<span class="line-added"> 424           _hb_unicode_is_emoji_Extended_Pictographic (info[i + 1].codepoint))</span>
<span class="line-added"> 425       {</span>
<span class="line-added"> 426         i++;</span>
<span class="line-added"> 427         _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);</span>
<span class="line-added"> 428         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 429       }</span>
<span class="line-added"> 430     }</span>
<span class="line-added"> 431     /* Or part of the Other_Grapheme_Extend that is not marks.</span>
<span class="line-added"> 432      * As of Unicode 11 that is just:</span>
<span class="line-added"> 433      *</span>
<span class="line-added"> 434      * 200C          ; Other_Grapheme_Extend # Cf       ZERO WIDTH NON-JOINER</span>
<span class="line-added"> 435      * FF9E..FF9F    ; Other_Grapheme_Extend # Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK</span>
<span class="line-added"> 436      * E0020..E007F  ; Other_Grapheme_Extend # Cf  [96] TAG SPACE..CANCEL TAG</span>
<span class="line-added"> 437      *</span>
<span class="line-added"> 438      * ZWNJ is special, we don&#39;t want to merge it as there&#39;s no need, and keeping</span>
<span class="line-added"> 439      * it separate results in more granular clusters.  Ignore Katakana for now.</span>
<span class="line-added"> 440      * Tags are used for Emoji sub-region flag sequences:</span>
<span class="line-added"> 441      * https://github.com/harfbuzz/harfbuzz/issues/1556</span>
<span class="line-added"> 442      */</span>
<span class="line-added"> 443     else if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0xE0020u, 0xE007Fu)))</span>
<span class="line-added"> 444       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 445   }</span>
 446 }
 447 
 448 static void
 449 hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
 450 {
 451   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
 452       buffer-&gt;context_len[0] ||
<span class="line-modified"> 453       !_hb_glyph_info_is_unicode_mark (&amp;buffer-&gt;info[0]))</span>

 454     return;
 455 
 456   if (!font-&gt;has_glyph (0x25CCu))
 457     return;
 458 
 459   hb_glyph_info_t dottedcircle = {0};
 460   dottedcircle.codepoint = 0x25CCu;
 461   _hb_glyph_info_set_unicode_props (&amp;dottedcircle, buffer);
 462 
 463   buffer-&gt;clear_output ();
 464 
 465   buffer-&gt;idx = 0;
 466   hb_glyph_info_t info = dottedcircle;
 467   info.cluster = buffer-&gt;cur().cluster;
 468   info.mask = buffer-&gt;cur().mask;
 469   buffer-&gt;output_info (info);
 470   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
 471     buffer-&gt;next_glyph ();

 472   buffer-&gt;swap_buffers ();
 473 }
 474 
 475 static void
 476 hb_form_clusters (hb_buffer_t *buffer)
 477 {
 478   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
 479     return;
 480 
















 481   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<span class="line-modified"> 482     foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 483       buffer-&gt;merge_clusters (start, end);</span>
 484   else
<span class="line-modified"> 485     foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 486       buffer-&gt;unsafe_to_break (start, end);</span>
 487 }
 488 
 489 static void
 490 hb_ensure_native_direction (hb_buffer_t *buffer)
 491 {
 492   hb_direction_t direction = buffer-&gt;props.direction;
 493   hb_direction_t horiz_dir = hb_script_get_horizontal_direction (buffer-&gt;props.script);
 494 
 495   /* TODO vertical:
 496    * The only BTT vertical script is Ogham, but it&#39;s not clear to me whether OpenType
 497    * Ogham fonts are supposed to be implemented BTT or not.  Need to research that
 498    * first. */
 499   if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
 500        direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
 501       (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
 502        direction != HB_DIRECTION_TTB))
 503   {












 504 



 505     if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<span class="line-modified"> 506       foreach_grapheme (buffer, start, end)</span>
<span class="line-modified"> 507       {</span>
<span class="line-added"> 508         buffer-&gt;merge_clusters (start, end);</span>
<span class="line-added"> 509         buffer-&gt;reverse_range (start, end);</span>
<span class="line-added"> 510       }</span>
<span class="line-added"> 511     else</span>
<span class="line-added"> 512       foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 513         /* form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-added"> 514         buffer-&gt;reverse_range (start, end);</span>
 515 
 516     buffer-&gt;reverse ();
 517 
 518     buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
 519   }
 520 }
 521 
 522 
<span class="line-modified"> 523 /*</span>
<span class="line-added"> 524  * Substitute</span>
<span class="line-added"> 525  */</span>
 526 
 527 static inline void
<span class="line-modified"> 528 hb_ot_mirror_chars (const hb_ot_shape_context_t *c)</span>
 529 {
 530   if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
 531     return;
 532 
 533   hb_buffer_t *buffer = c-&gt;buffer;
 534   hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 535   hb_mask_t rtlm_mask = c-&gt;plan-&gt;rtlm_mask;
 536 
 537   unsigned int count = buffer-&gt;len;
 538   hb_glyph_info_t *info = buffer-&gt;info;
 539   for (unsigned int i = 0; i &lt; count; i++) {
 540     hb_codepoint_t codepoint = unicode-&gt;mirroring (info[i].codepoint);
 541     if (likely (codepoint == info[i].codepoint || !c-&gt;font-&gt;has_glyph (codepoint)))
 542       info[i].mask |= rtlm_mask;
 543     else
 544       info[i].codepoint = codepoint;
 545   }
 546 }
 547 
 548 static inline void
<span class="line-modified"> 549 hb_ot_shape_setup_masks_fraction (const hb_ot_shape_context_t *c)</span>
 550 {
 551   if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
 552       !c-&gt;plan-&gt;has_frac)
 553     return;
 554 
 555   hb_buffer_t *buffer = c-&gt;buffer;
 556 
 557   hb_mask_t pre_mask, post_mask;
 558   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction))
 559   {
 560     pre_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 561     post_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 562   }
 563   else
 564   {
 565     pre_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 566     post_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 567   }
 568 
 569   unsigned int count = buffer-&gt;len;
</pre>
<hr />
<pre>
 579         start--;
 580       while (end &lt; count &amp;&amp;
 581              _hb_glyph_info_get_general_category (&amp;info[end]) ==
 582              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
 583         end++;
 584 
 585       buffer-&gt;unsafe_to_break (start, end);
 586 
 587       for (unsigned int j = start; j &lt; i; j++)
 588         info[j].mask |= pre_mask;
 589       info[i].mask |= c-&gt;plan-&gt;frac_mask;
 590       for (unsigned int j = i + 1; j &lt; end; j++)
 591         info[j].mask |= post_mask;
 592 
 593       i = end - 1;
 594     }
 595   }
 596 }
 597 
 598 static inline void
<span class="line-modified"> 599 hb_ot_shape_initialize_masks (const hb_ot_shape_context_t *c)</span>
 600 {
 601   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 602   hb_buffer_t *buffer = c-&gt;buffer;
 603 
 604   hb_mask_t global_mask = map-&gt;get_global_mask ();
 605   buffer-&gt;reset_masks (global_mask);
 606 }
 607 
 608 static inline void
<span class="line-modified"> 609 hb_ot_shape_setup_masks (const hb_ot_shape_context_t *c)</span>
 610 {
 611   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 612   hb_buffer_t *buffer = c-&gt;buffer;
 613 
 614   hb_ot_shape_setup_masks_fraction (c);
 615 
 616   if (c-&gt;plan-&gt;shaper-&gt;setup_masks)
 617     c-&gt;plan-&gt;shaper-&gt;setup_masks (c-&gt;plan, buffer, c-&gt;font);
 618 
 619   for (unsigned int i = 0; i &lt; c-&gt;num_user_features; i++)
 620   {
 621     const hb_feature_t *feature = &amp;c-&gt;user_features[i];
 622     if (!(feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int)-1)) {
 623       unsigned int shift;
 624       hb_mask_t mask = map-&gt;get_mask (feature-&gt;tag, &amp;shift);
 625       buffer-&gt;set_masks (feature-&gt;value &lt;&lt; shift, mask, feature-&gt;start, feature-&gt;end);
 626     }
 627   }
 628 }
 629 
 630 static void
<span class="line-modified"> 631 hb_ot_zero_width_default_ignorables (const hb_buffer_t *buffer)</span>
 632 {


 633   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 634       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
 635       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
 636     return;
 637 
 638   unsigned int count = buffer-&gt;len;
 639   hb_glyph_info_t *info = buffer-&gt;info;
 640   hb_glyph_position_t *pos = buffer-&gt;pos;
 641   unsigned int i = 0;
 642   for (i = 0; i &lt; count; i++)
 643     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
 644       pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
 645 }
 646 
 647 static void
<span class="line-modified"> 648 hb_ot_hide_default_ignorables (hb_buffer_t *buffer,</span>
<span class="line-added"> 649                                hb_font_t   *font)</span>
 650 {


 651   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 652       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
 653     return;
 654 
 655   unsigned int count = buffer-&gt;len;
 656   hb_glyph_info_t *info = buffer-&gt;info;











 657 
<span class="line-modified"> 658   hb_codepoint_t invisible = buffer-&gt;invisible;</span>
 659   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<span class="line-modified"> 660       (invisible || font-&gt;get_nominal_glyph (&#39; &#39;, &amp;invisible)))</span>
 661   {
<span class="line-modified"> 662     /* Replace default-ignorables with a zero-advance invisible glyph. */</span>
<span class="line-modified"> 663     for (unsigned int i = 0; i &lt; count; i++)</span>
 664     {
 665       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<span class="line-modified"> 666         info[i].codepoint = invisible;</span>
 667     }
 668   }
 669   else
<span class="line-modified"> 670     hb_ot_layout_delete_glyphs_inplace (buffer, _hb_glyph_info_is_default_ignorable);</span>










































 671 }
 672 
 673 
 674 static inline void
 675 hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
 676 {
 677   /* Normalization process sets up glyph_index(), we just copy it. */
 678   unsigned int count = buffer-&gt;len;
 679   hb_glyph_info_t *info = buffer-&gt;info;
 680   for (unsigned int i = 0; i &lt; count; i++)
 681     info[i].codepoint = info[i].glyph_index();
 682 
 683   buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
 684 }
 685 
 686 static inline void
<span class="line-modified"> 687 hb_synthesize_glyph_classes (hb_buffer_t *buffer)</span>
 688 {
<span class="line-modified"> 689   unsigned int count = buffer-&gt;len;</span>
<span class="line-modified"> 690   hb_glyph_info_t *info = buffer-&gt;info;</span>
 691   for (unsigned int i = 0; i &lt; count; i++)
 692   {
 693     hb_ot_layout_glyph_props_flags_t klass;
 694 
 695     /* Never mark default-ignorables as marks.
 696      * They won&#39;t get in the way of lookups anyway,
 697      * but having them as mark will cause them to be skipped
 698      * over if the lookup-flag says so, but at least for the
 699      * Mongolian variation selectors, looks like Uniscribe
 700      * marks them as non-mark.  Some Mongolian fonts without
 701      * GDEF rely on this.  Another notable character that
 702      * this applies to is COMBINING GRAPHEME JOINER. */
 703     klass = (_hb_glyph_info_get_general_category (&amp;info[i]) !=
 704              HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ||
 705              _hb_glyph_info_is_default_ignorable (&amp;info[i])) ?
 706             HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH :
 707             HB_OT_LAYOUT_GLYPH_PROPS_MARK;
 708     _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
 709   }
 710 }
 711 
 712 static inline void
<span class="line-modified"> 713 hb_ot_substitute_default (const hb_ot_shape_context_t *c)</span>
 714 {
 715   hb_buffer_t *buffer = c-&gt;buffer;
 716 
 717   hb_ot_mirror_chars (c);
 718 
 719   HB_BUFFER_ALLOCATE_VAR (buffer, glyph_index);
 720 
 721   _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
 722 
 723   hb_ot_shape_setup_masks (c);
 724 
 725   /* This is unfortunate to go here, but necessary... */
<span class="line-modified"> 726   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-modified"> 727     _hb_ot_shape_fallback_mark_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
 728 
 729   hb_ot_map_glyphs_fast (buffer);
 730 
 731   HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
 732 }
 733 
 734 static inline void
<span class="line-modified"> 735 hb_ot_substitute_complex (const hb_ot_shape_context_t *c)</span>
 736 {
 737   hb_buffer_t *buffer = c-&gt;buffer;
 738 
 739   hb_ot_layout_substitute_start (c-&gt;font, buffer);
 740 
<span class="line-modified"> 741   if (c-&gt;plan-&gt;fallback_glyph_classes)</span>
<span class="line-modified"> 742     hb_synthesize_glyph_classes (c-&gt;buffer);</span>
 743 
 744   c-&gt;plan-&gt;substitute (c-&gt;font, buffer);



 745 }
 746 
 747 static inline void
<span class="line-modified"> 748 hb_ot_substitute_pre (const hb_ot_shape_context_t *c)</span>
 749 {
 750   hb_ot_substitute_default (c);
 751 
 752   _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
 753 
 754   hb_ot_substitute_complex (c);
 755 }
 756 
<span class="line-modified"> 757 static inline void</span>
<span class="line-added"> 758 hb_ot_substitute_post (const hb_ot_shape_context_t *c)</span>
<span class="line-added"> 759 {</span>
<span class="line-added"> 760   hb_ot_hide_default_ignorables (c-&gt;buffer, c-&gt;font);</span>
<span class="line-added"> 761   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added"> 762     hb_aat_layout_remove_deleted_glyphs (c-&gt;buffer);</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-added"> 765     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
<span class="line-added"> 766 }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769 /*</span>
<span class="line-added"> 770  * Position</span>
<span class="line-added"> 771  */</span>
 772 
 773 static inline void
 774 adjust_mark_offsets (hb_glyph_position_t *pos)
 775 {
 776   pos-&gt;x_offset -= pos-&gt;x_advance;
 777   pos-&gt;y_offset -= pos-&gt;y_advance;
 778 }
 779 
 780 static inline void
 781 zero_mark_width (hb_glyph_position_t *pos)
 782 {
 783   pos-&gt;x_advance = 0;
 784   pos-&gt;y_advance = 0;
 785 }
 786 
 787 static inline void
 788 zero_mark_widths_by_gdef (hb_buffer_t *buffer, bool adjust_offsets)
 789 {
 790   unsigned int count = buffer-&gt;len;
 791   hb_glyph_info_t *info = buffer-&gt;info;
 792   for (unsigned int i = 0; i &lt; count; i++)
 793     if (_hb_glyph_info_is_mark (&amp;info[i]))
 794     {
 795       if (adjust_offsets)
 796         adjust_mark_offsets (&amp;buffer-&gt;pos[i]);
 797       zero_mark_width (&amp;buffer-&gt;pos[i]);
 798     }
 799 }
 800 
 801 static inline void
<span class="line-modified"> 802 hb_ot_position_default (const hb_ot_shape_context_t *c)</span>
 803 {
 804   hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
 805   unsigned int count = c-&gt;buffer-&gt;len;
 806   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 807   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 808 
 809   if (HB_DIRECTION_IS_HORIZONTAL (direction))
 810   {
<span class="line-modified"> 811     c-&gt;font-&gt;get_glyph_h_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-modified"> 812                                    &amp;pos[0].x_advance, sizeof(pos[0]));</span>
 813     /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 814     if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 815       for (unsigned int i = 0; i &lt; count; i++)
 816         c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 817                                           &amp;pos[i].x_offset,
 818                                           &amp;pos[i].y_offset);
 819   }
 820   else
 821   {
<span class="line-added"> 822     c-&gt;font-&gt;get_glyph_v_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-added"> 823                                    &amp;pos[0].y_advance, sizeof(pos[0]));</span>
 824     for (unsigned int i = 0; i &lt; count; i++)
 825     {

 826       c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
 827                                         &amp;pos[i].x_offset,
 828                                         &amp;pos[i].y_offset);
 829     }
 830   }
 831   if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
 832     _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
 833 }
 834 
 835 static inline void
<span class="line-modified"> 836 hb_ot_position_complex (const hb_ot_shape_context_t *c)</span>
 837 {
 838   unsigned int count = c-&gt;buffer-&gt;len;
 839   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 840   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 841 
<span class="line-modified"> 842   /* If the font has no GPOS and direction is forward, then when</span>
<span class="line-modified"> 843    * zeroing mark widths, we shift the mark with it, such that the</span>
<span class="line-modified"> 844    * mark is positioned hanging over the previous glyph.  When</span>

 845    * direction is backward we don&#39;t shift and it will end up
 846    * hanging over the next glyph after the final reordering.
<span class="line-modified"> 847    *</span>
<span class="line-modified"> 848    * Note: If fallback positinoing happens, we don&#39;t care about</span>
<span class="line-added"> 849    * this as it will be overriden.</span>
 850    */
<span class="line-modified"> 851   bool adjust_offsets_when_zeroing = c-&gt;plan-&gt;adjust_mark_positioning_when_zeroing &amp;&amp;</span>

 852                                      HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
 853 
 854   /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
 855 
 856   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 857   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 858     for (unsigned int i = 0; i &lt; count; i++)
 859       c-&gt;font-&gt;add_glyph_h_origin (info[i].codepoint,
 860                                    &amp;pos[i].x_offset,
 861                                    &amp;pos[i].y_offset);
 862 
 863   hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
 864 
<span class="line-modified"> 865   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified"> 866     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified"> 867     {</span>
<span class="line-modified"> 868       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified"> 869         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified"> 870         break;</span>
<span class="line-modified"> 871 </span>
<span class="line-modified"> 872       default:</span>
<span class="line-modified"> 873       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified"> 874       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified"> 875         break;</span>
<span class="line-modified"> 876     }</span>


 877 
<span class="line-modified"> 878   c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>




 879 
<span class="line-modified"> 880   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified"> 881     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified"> 882     {</span>
<span class="line-modified"> 883       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified"> 884         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-added"> 885         break;</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887       default:</span>
<span class="line-added"> 888       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-added"> 889       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-added"> 890         break;</span>
<span class="line-added"> 891     }</span>
 892 
<span class="line-modified"> 893   /* Finish off.  Has to follow a certain order. */</span>
 894   hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<span class="line-modified"> 895   hb_ot_zero_width_default_ignorables (c-&gt;buffer);</span>
<span class="line-added"> 896   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added"> 897     hb_aat_layout_zero_width_deleted_glyphs (c-&gt;buffer);</span>
 898   hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
 899 
 900   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 901   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 902     for (unsigned int i = 0; i &lt; count; i++)
 903       c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 904                                         &amp;pos[i].x_offset,
 905                                         &amp;pos[i].y_offset);
<span class="line-added"> 906 </span>
<span class="line-added"> 907   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-added"> 908     _hb_ot_shape_fallback_mark_position (c-&gt;plan, c-&gt;font, c-&gt;buffer,</span>
<span class="line-added"> 909                                          adjust_offsets_when_zeroing);</span>
 910 }
 911 
 912 static inline void
<span class="line-modified"> 913 hb_ot_position (const hb_ot_shape_context_t *c)</span>
 914 {
 915   c-&gt;buffer-&gt;clear_positions ();
 916 
 917   hb_ot_position_default (c);
 918 
 919   hb_ot_position_complex (c);
 920 



 921   if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
 922     hb_buffer_reverse (c-&gt;buffer);
 923 





 924   _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);


 925 }
 926 
 927 static inline void
 928 hb_propagate_flags (hb_buffer_t *buffer)
 929 {
 930   /* Propagate cluster-level glyph flags to be the same on all cluster glyphs.
 931    * Simplifies using them. */
 932 
 933   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))
 934     return;
 935 
 936   hb_glyph_info_t *info = buffer-&gt;info;
 937 
 938   foreach_cluster (buffer, start, end)
 939   {
 940     unsigned int mask = 0;
 941     for (unsigned int i = start; i &lt; end; i++)
 942       if (info[i].mask &amp; HB_GLYPH_FLAG_UNSAFE_TO_BREAK)
 943       {
 944          mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
 945          break;
 946       }
 947     if (mask)
 948       for (unsigned int i = start; i &lt; end; i++)
 949         info[i].mask |= mask;
 950   }
 951 }
 952 
 953 /* Pull it all together! */
 954 
 955 static void
 956 hb_ot_shape_internal (hb_ot_shape_context_t *c)
 957 {
 958   c-&gt;buffer-&gt;deallocate_var_all ();
 959   c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<span class="line-modified"> 960   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
 961   {
 962     c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
 963                               (unsigned) HB_BUFFER_MAX_LEN_MIN);
 964   }
<span class="line-modified"> 965   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
 966   {
 967     c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
 968                               (unsigned) HB_BUFFER_MAX_OPS_MIN);
 969   }
 970 





 971   /* Save the original direction, we use it later. */
 972   c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
 973 
 974   _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
 975 
 976   c-&gt;buffer-&gt;clear_output ();
 977 
 978   hb_ot_shape_initialize_masks (c);
 979   hb_set_unicode_props (c-&gt;buffer);
 980   hb_insert_dotted_circle (c-&gt;buffer, c-&gt;font);
 981 
 982   hb_form_clusters (c-&gt;buffer);
 983 
 984   hb_ensure_native_direction (c-&gt;buffer);
 985 
 986   if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
 987     c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
 988 
<span class="line-modified"> 989   hb_ot_substitute_pre (c);</span>
 990   hb_ot_position (c);
<span class="line-modified"> 991   hb_ot_substitute_post (c);</span>




 992 
 993   hb_propagate_flags (c-&gt;buffer);
 994 
 995   _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
 996 
 997   c-&gt;buffer-&gt;props.direction = c-&gt;target_direction;
 998 
 999   c-&gt;buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
1000   c-&gt;buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
1001   c-&gt;buffer-&gt;deallocate_var_all ();
1002 }
1003 
1004 
1005 hb_bool_t
1006 _hb_ot_shape (hb_shape_plan_t    *shape_plan,
1007               hb_font_t          *font,
1008               hb_buffer_t        *buffer,
1009               const hb_feature_t *features,
1010               unsigned int        num_features)
1011 {
<span class="line-modified">1012   hb_ot_shape_context_t c = {&amp;shape_plan-&gt;ot, font, font-&gt;face, buffer, features, num_features};</span>
1013   hb_ot_shape_internal (&amp;c);
1014 
1015   return true;
1016 }
1017 
1018 
1019 /**
1020  * hb_ot_shape_plan_collect_lookups:
1021  *
1022  * Since: 0.9.7
1023  **/
1024 void
1025 hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
1026                                   hb_tag_t         table_tag,
1027                                   hb_set_t        *lookup_indexes /* OUT */)
1028 {
<span class="line-modified">1029   shape_plan-&gt;ot.collect_lookups (table_tag, lookup_indexes);</span>

1030 }
1031 
1032 
1033 /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
1034 static void
1035 add_char (hb_font_t          *font,
1036           hb_unicode_funcs_t *unicode,
1037           hb_bool_t           mirror,
1038           hb_codepoint_t      u,
1039           hb_set_t           *glyphs)
1040 {
1041   hb_codepoint_t glyph;
1042   if (font-&gt;get_nominal_glyph (u, &amp;glyph))
1043     glyphs-&gt;add (glyph);
1044   if (mirror)
1045   {
1046     hb_codepoint_t m = unicode-&gt;mirroring (u);
1047     if (m != u &amp;&amp; font-&gt;get_nominal_glyph (m, &amp;glyph))
1048       glyphs-&gt;add (glyph);
1049   }
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-normalize.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-tag.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
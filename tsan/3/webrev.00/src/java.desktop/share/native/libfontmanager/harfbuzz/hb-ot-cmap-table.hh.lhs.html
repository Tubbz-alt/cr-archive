<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright Â© 2014  Google, Inc.
   3  *
   4  *  This is part of HarfBuzz, a text shaping library.
   5  *
   6  * Permission is hereby granted, without written agreement and without
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #ifndef HB_OT_CMAP_TABLE_HH
  28 #define HB_OT_CMAP_TABLE_HH
  29 
<a name="1" id="anc1"></a><span class="line-modified">  30 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-set-private.hh&quot;</span>
<span class="line-removed">  32 #include &quot;hb-subset-plan.hh&quot;</span>
  33 
  34 /*
  35  * cmap -- Character to Glyph Index Mapping
  36  * https://docs.microsoft.com/en-us/typography/opentype/spec/cmap
  37  */
  38 #define HB_OT_TAG_cmap HB_TAG(&#39;c&#39;,&#39;m&#39;,&#39;a&#39;,&#39;p&#39;)
  39 
<a name="2" id="anc2"></a><span class="line-removed">  40 </span>
  41 namespace OT {
  42 
  43 
  44 struct CmapSubtableFormat0
  45 {
<a name="3" id="anc3"></a><span class="line-modified">  46   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
  47   {
  48     hb_codepoint_t gid = codepoint &lt; 256 ? glyphIdArray[codepoint] : 0;
  49     if (!gid)
  50       return false;
  51     *glyph = gid;
  52     return true;
  53   }
<a name="4" id="anc4"></a>





  54 
<a name="5" id="anc5"></a><span class="line-modified">  55   inline bool sanitize (hb_sanitize_context_t *c) const</span>
  56   {
  57     TRACE_SANITIZE (this);
  58     return_trace (c-&gt;check_struct (this));
  59   }
  60 
  61   protected:
  62   HBUINT16      format;         /* Format number is set to 0. */
  63   HBUINT16      length;         /* Byte length of this subtable. */
  64   HBUINT16      language;       /* Ignore. */
  65   HBUINT8       glyphIdArray[256];/* An array that maps character
  66                                  * code to glyph index values. */
  67   public:
  68   DEFINE_SIZE_STATIC (6 + 256);
  69 };
  70 
  71 struct CmapSubtableFormat4
  72 {
  73   struct segment_plan
  74   {
  75     HBUINT16 start_code;
  76     HBUINT16 end_code;
  77     bool use_delta;
  78   };
  79 
  80   bool serialize (hb_serialize_context_t *c,
  81                   const hb_subset_plan_t *plan,
  82                   const hb_vector_t&lt;segment_plan&gt; &amp;segments)
  83   {
  84     TRACE_SERIALIZE (this);
  85 
  86     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
  87 
  88     this-&gt;format.set (4);
  89     this-&gt;length.set (get_sub_table_size (segments));
  90 
<a name="6" id="anc6"></a><span class="line-modified">  91     this-&gt;segCountX2.set (segments.len * 2);</span>
<span class="line-modified">  92     this-&gt;entrySelector.set (MAX (1u, _hb_bit_storage (segments.len)) - 1);</span>
  93     this-&gt;searchRange.set (2 * (1u &lt;&lt; this-&gt;entrySelector));
<a name="7" id="anc7"></a><span class="line-modified">  94     this-&gt;rangeShift.set (segments.len * 2 &gt; this-&gt;searchRange</span>
<span class="line-modified">  95                           ? 2 * segments.len - this-&gt;searchRange</span>
  96                           : 0);
  97 
<a name="8" id="anc8"></a><span class="line-modified">  98     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
  99     c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size); // 2 bytes of padding.
<a name="9" id="anc9"></a><span class="line-modified"> 100     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="line-modified"> 101     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="line-modified"> 102     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
 103 
 104     if (id_range_offset == nullptr)
 105       return_trace (false);
 106 
<a name="10" id="anc10"></a><span class="line-modified"> 107     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
 108     {
 109       end_count[i].set (segments[i].end_code);
 110       start_count[i].set (segments[i].start_code);
 111       if (segments[i].use_delta)
 112       {
 113         hb_codepoint_t cp = segments[i].start_code;
 114         hb_codepoint_t start_gid = 0;
 115         if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;start_gid) &amp;&amp; cp != 0xFFFF))
 116           return_trace (false);
 117         id_delta[i].set (start_gid - segments[i].start_code);
 118       } else {
 119         id_delta[i].set (0);
 120         unsigned int num_codepoints = segments[i].end_code - segments[i].start_code + 1;
 121         HBUINT16 *glyph_id_array = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * num_codepoints);
 122         if (glyph_id_array == nullptr)
 123           return_trace (false);
 124         // From the cmap spec:
 125         //
 126         // id_range_offset[i]/2
 127         // + (cp - segments[i].start_code)
 128         // + (id_range_offset + i)
 129         // =
 130         // glyph_id_array + (cp - segments[i].start_code)
 131         //
 132         // So, solve for id_range_offset[i]:
 133         //
 134         // id_range_offset[i]
 135         // =
 136         // 2 * (glyph_id_array - id_range_offset - i)
 137         id_range_offset[i].set (2 * (
 138             glyph_id_array - id_range_offset - i));
 139         for (unsigned int j = 0; j &lt; num_codepoints; j++)
 140         {
 141           hb_codepoint_t cp = segments[i].start_code + j;
 142           hb_codepoint_t new_gid;
 143           if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 144             return_trace (false);
 145           glyph_id_array[j].set (new_gid);
 146         }
 147       }
 148     }
 149 
 150     return_trace (true);
 151   }
 152 
<a name="11" id="anc11"></a><span class="line-modified"> 153   static inline size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
 154   {
 155     size_t segment_size = 0;
<a name="12" id="anc12"></a><span class="line-modified"> 156     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
 157     {
 158       // Parallel array entries
 159       segment_size +=
 160             2  // end count
 161           + 2  // start count
 162           + 2  // delta
 163           + 2; // range offset
 164 
 165       if (!segments[i].use_delta)
 166         // Add bytes for the glyph index array entries for this segment.
 167         segment_size += (segments[i].end_code - segments[i].start_code + 1) * 2;
 168     }
 169 
 170     return min_size
 171         + 2 // Padding
 172         + segment_size;
 173   }
 174 
<a name="13" id="anc13"></a><span class="line-modified"> 175   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 176                                             hb_vector_t&lt;segment_plan&gt; *segments)</span>
 177   {
 178     segment_plan *segment = nullptr;
 179     hb_codepoint_t last_gid = 0;
 180 
 181     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 182     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 183       hb_codepoint_t new_gid;
 184       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 185       {
 186         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 187         return false;
 188       }
 189 
<a name="14" id="anc14"></a><span class="line-modified"> 190       if (cp &gt; 0xFFFF) {</span>
<span class="line-modified"> 191         // We are now outside of unicode BMP, stop adding to this cmap.</span>
<span class="line-removed"> 192         break;</span>
<span class="line-removed"> 193       }</span>
 194 
<a name="15" id="anc15"></a><span class="line-modified"> 195       if (!segment</span>
<span class="line-modified"> 196           || cp != segment-&gt;end_code + 1u)</span>
 197       {
 198         segment = segments-&gt;push ();
 199         segment-&gt;start_code.set (cp);
 200         segment-&gt;end_code.set (cp);
 201         segment-&gt;use_delta = true;
 202       } else {
 203         segment-&gt;end_code.set (cp);
 204         if (last_gid + 1u != new_gid)
 205           // gid&#39;s are not consecutive in this segment so delta
 206           // cannot be used.
 207           segment-&gt;use_delta = false;
 208       }
 209 
 210       last_gid = new_gid;
 211     }
 212 
 213     // There must be a final entry with end_code == 0xFFFF. Check if we need to add one.
 214     if (segment == nullptr || segment-&gt;end_code != 0xFFFF)
 215     {
 216       segment = segments-&gt;push ();
 217       segment-&gt;start_code.set (0xFFFF);
 218       segment-&gt;end_code.set (0xFFFF);
 219       segment-&gt;use_delta = true;
 220     }
 221 
 222     return true;
 223   }
 224 
 225   struct accelerator_t
 226   {
<a name="16" id="anc16"></a><span class="line-modified"> 227     inline void init (const CmapSubtableFormat4 *subtable)</span>




 228     {
 229       segCount = subtable-&gt;segCountX2 / 2;
<a name="17" id="anc17"></a><span class="line-modified"> 230       endCount = subtable-&gt;values;</span>
 231       startCount = endCount + segCount + 1;
 232       idDelta = startCount + segCount;
 233       idRangeOffset = idDelta + segCount;
 234       glyphIdArray = idRangeOffset + segCount;
 235       glyphIdArrayLength = (subtable-&gt;length - 16 - 8 * segCount) / 2;
 236     }
<a name="18" id="anc18"></a>
 237 
<a name="19" id="anc19"></a><span class="line-modified"> 238     static inline bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
 239     {
<a name="20" id="anc20"></a><span class="line-removed"> 240       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="line-removed"> 241 </span>
 242       /* Custom two-array bsearch. */
<a name="21" id="anc21"></a><span class="line-modified"> 243       int min = 0, max = (int) thiz-&gt;segCount - 1;</span>
<span class="line-modified"> 244       const HBUINT16 *startCount = thiz-&gt;startCount;</span>
<span class="line-modified"> 245       const HBUINT16 *endCount = thiz-&gt;endCount;</span>
 246       unsigned int i;
 247       while (min &lt;= max)
 248       {
<a name="22" id="anc22"></a><span class="line-modified"> 249         int mid = (min + max) / 2;</span>
 250         if (codepoint &lt; startCount[mid])
 251           max = mid - 1;
 252         else if (codepoint &gt; endCount[mid])
 253           min = mid + 1;
 254         else
 255         {
 256           i = mid;
 257           goto found;
 258         }
 259       }
 260       return false;
 261 
 262     found:
 263       hb_codepoint_t gid;
<a name="23" id="anc23"></a><span class="line-modified"> 264       unsigned int rangeOffset = thiz-&gt;idRangeOffset[i];</span>
 265       if (rangeOffset == 0)
<a name="24" id="anc24"></a><span class="line-modified"> 266         gid = codepoint + thiz-&gt;idDelta[i];</span>
 267       else
 268       {
 269         /* Somebody has been smoking... */
<a name="25" id="anc25"></a><span class="line-modified"> 270         unsigned int index = rangeOffset / 2 + (codepoint - thiz-&gt;startCount[i]) + i - thiz-&gt;segCount;</span>
<span class="line-modified"> 271         if (unlikely (index &gt;= thiz-&gt;glyphIdArrayLength))</span>
 272           return false;
<a name="26" id="anc26"></a><span class="line-modified"> 273         gid = thiz-&gt;glyphIdArray[index];</span>
 274         if (unlikely (!gid))
 275           return false;
<a name="27" id="anc27"></a><span class="line-modified"> 276         gid += thiz-&gt;idDelta[i];</span>
 277       }
<a name="28" id="anc28"></a><span class="line-modified"> 278 </span>
<span class="line-modified"> 279       *glyph = gid &amp; 0xFFFFu;</span>


 280       return true;
 281     }
<a name="29" id="anc29"></a><span class="line-modified"> 282 </span>
<span class="line-modified"> 283     static inline void get_all_codepoints_func (const void *obj, hb_set_t *out)</span>



 284     {
<a name="30" id="anc30"></a><span class="line-modified"> 285       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="line-modified"> 286       for (unsigned int i = 0; i &lt; thiz-&gt;segCount; i++)</span>


 287       {
<a name="31" id="anc31"></a><span class="line-modified"> 288         if (thiz-&gt;startCount[i] != 0xFFFFu</span>
<span class="line-modified"> 289             || thiz-&gt;endCount[i] != 0xFFFFu) // Skip the last segment (0xFFFF)</span>
<span class="line-modified"> 290           hb_set_add_range (out, thiz-&gt;startCount[i], thiz-&gt;endCount[i]);</span>















 291       }
 292     }
 293 
 294     const HBUINT16 *endCount;
 295     const HBUINT16 *startCount;
 296     const HBUINT16 *idDelta;
 297     const HBUINT16 *idRangeOffset;
 298     const HBUINT16 *glyphIdArray;
 299     unsigned int segCount;
 300     unsigned int glyphIdArrayLength;
 301   };
 302 
<a name="32" id="anc32"></a><span class="line-modified"> 303   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 304   {
<a name="33" id="anc33"></a><span class="line-modified"> 305     accelerator_t accel;</span>
<span class="line-removed"> 306     accel.init (this);</span>
 307     return accel.get_glyph_func (&amp;accel, codepoint, glyph);
 308   }
<a name="34" id="anc34"></a>




 309 
<a name="35" id="anc35"></a><span class="line-modified"> 310   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 311   {
 312     TRACE_SANITIZE (this);
 313     if (unlikely (!c-&gt;check_struct (this)))
 314       return_trace (false);
 315 
 316     if (unlikely (!c-&gt;check_range (this, length)))
 317     {
 318       /* Some broken fonts have too long of a &quot;length&quot; value.
 319        * If that is the case, just change the value to truncate
 320        * the subtable at the end of the blob. */
 321       uint16_t new_length = (uint16_t) MIN ((uintptr_t) 65535,
 322                                             (uintptr_t) (c-&gt;end -
 323                                                          (char *) this));
 324       if (!c-&gt;try_set (&amp;length, new_length))
 325         return_trace (false);
 326     }
 327 
 328     return_trace (16 + 4 * (unsigned int) segCountX2 &lt;= length);
 329   }
 330 
 331 
 332 
 333   protected:
 334   HBUINT16      format;         /* Format number is set to 4. */
 335   HBUINT16      length;         /* This is the length in bytes of the
 336                                  * subtable. */
 337   HBUINT16      language;       /* Ignore. */
 338   HBUINT16      segCountX2;     /* 2 x segCount. */
 339   HBUINT16      searchRange;    /* 2 * (2**floor(log2(segCount))) */
 340   HBUINT16      entrySelector;  /* log2(searchRange/2) */
 341   HBUINT16      rangeShift;     /* 2 x segCount - searchRange */
 342 
<a name="36" id="anc36"></a><span class="line-modified"> 343   HBUINT16      values[VAR];</span>

 344 #if 0
 345   HBUINT16      endCount[segCount];     /* End characterCode for each segment,
 346                                          * last=0xFFFFu. */
 347   HBUINT16      reservedPad;            /* Set to 0. */
 348   HBUINT16      startCount[segCount];   /* Start character code for each segment. */
 349   HBINT16               idDelta[segCount];      /* Delta for all character codes in segment. */
 350   HBUINT16      idRangeOffset[segCount];/* Offsets into glyphIdArray or 0 */
<a name="37" id="anc37"></a><span class="line-modified"> 351   HBUINT16      glyphIdArray[VAR];      /* Glyph index array (arbitrary length) */</span>

 352 #endif
 353 
 354   public:
 355   DEFINE_SIZE_ARRAY (14, values);
 356 };
 357 
 358 struct CmapSubtableLongGroup
 359 {
 360   friend struct CmapSubtableFormat12;
 361   friend struct CmapSubtableFormat13;
 362   template&lt;typename U&gt;
 363   friend struct CmapSubtableLongSegmented;
 364   friend struct cmap;
 365 
 366   int cmp (hb_codepoint_t codepoint) const
 367   {
 368     if (codepoint &lt; startCharCode) return -1;
 369     if (codepoint &gt; endCharCode)   return +1;
 370     return 0;
 371   }
 372 
<a name="38" id="anc38"></a><span class="line-modified"> 373   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 374   {
 375     TRACE_SANITIZE (this);
 376     return_trace (c-&gt;check_struct (this));
 377   }
 378 
 379   private:
 380   HBUINT32              startCharCode;  /* First character code in this group. */
 381   HBUINT32              endCharCode;    /* Last character code in this group. */
 382   HBUINT32              glyphID;        /* Glyph index; interpretation depends on
<a name="39" id="anc39"></a><span class="line-modified"> 383                                  * subtable format. */</span>
 384   public:
 385   DEFINE_SIZE_STATIC (12);
 386 };
<a name="40" id="anc40"></a>
 387 
 388 template &lt;typename UINT&gt;
 389 struct CmapSubtableTrimmed
 390 {
<a name="41" id="anc41"></a><span class="line-modified"> 391   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 392   {
 393     /* Rely on our implicit array bound-checking. */
 394     hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];
 395     if (!gid)
 396       return false;
 397     *glyph = gid;
 398     return true;
 399   }
<a name="42" id="anc42"></a>







 400 
<a name="43" id="anc43"></a><span class="line-modified"> 401   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 402   {
 403     TRACE_SANITIZE (this);
 404     return_trace (c-&gt;check_struct (this) &amp;&amp; glyphIdArray.sanitize (c));
 405   }
 406 
 407   protected:
 408   UINT          formatReserved; /* Subtable format and (maybe) padding. */
 409   UINT          length;         /* Byte length of this subtable. */
 410   UINT          language;       /* Ignore. */
 411   UINT          startCharCode;  /* First character code covered. */
 412   ArrayOf&lt;GlyphID, UINT&gt;
 413                 glyphIdArray;   /* Array of glyph index values for character
 414                                  * codes in the range. */
 415   public:
 416   DEFINE_SIZE_ARRAY (5 * sizeof (UINT), glyphIdArray);
 417 };
 418 
 419 struct CmapSubtableFormat6  : CmapSubtableTrimmed&lt;HBUINT16&gt; {};
 420 struct CmapSubtableFormat10 : CmapSubtableTrimmed&lt;HBUINT32 &gt; {};
 421 
 422 template &lt;typename T&gt;
 423 struct CmapSubtableLongSegmented
 424 {
 425   friend struct cmap;
 426 
<a name="44" id="anc44"></a><span class="line-modified"> 427   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 428   {
<a name="45" id="anc45"></a><span class="line-modified"> 429     int i = groups.bsearch (codepoint);</span>
<span class="line-modified"> 430     if (i == -1)</span>
 431       return false;
<a name="46" id="anc46"></a><span class="line-modified"> 432     *glyph = T::group_get_glyph (groups[i], codepoint);</span>
 433     return true;
 434   }
 435 
<a name="47" id="anc47"></a><span class="line-modified"> 436   inline void get_all_codepoints (hb_set_t *out) const</span>
 437   {
 438     for (unsigned int i = 0; i &lt; this-&gt;groups.len; i++) {
<a name="48" id="anc48"></a><span class="line-modified"> 439       hb_set_add_range (out,</span>
<span class="line-modified"> 440                         this-&gt;groups[i].startCharCode,</span>
<span class="line-modified"> 441                         this-&gt;groups[i].endCharCode);</span>
 442     }
 443   }
 444 
<a name="49" id="anc49"></a><span class="line-modified"> 445   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 446   {
 447     TRACE_SANITIZE (this);
 448     return_trace (c-&gt;check_struct (this) &amp;&amp; groups.sanitize (c));
 449   }
 450 
<a name="50" id="anc50"></a><span class="line-modified"> 451   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 452                          const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
 453   {
 454     TRACE_SERIALIZE (this);
 455     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="51" id="anc51"></a><span class="line-modified"> 456     Supplier&lt;CmapSubtableLongGroup&gt; supplier (group_data.arrayZ, group_data.len);</span>
<span class="line-removed"> 457     if (unlikely (!groups.serialize (c, supplier, group_data.len))) return_trace (false);</span>
 458     return true;
 459   }
 460 
 461   protected:
 462   HBUINT16      format;         /* Subtable format; set to 12. */
 463   HBUINT16      reserved;       /* Reserved; set to 0. */
 464   HBUINT32      length;         /* Byte length of this subtable. */
 465   HBUINT32      language;       /* Ignore. */
 466   SortedArrayOf&lt;CmapSubtableLongGroup, HBUINT32&gt;
 467                 groups;         /* Groupings. */
 468   public:
 469   DEFINE_SIZE_ARRAY (16, groups);
 470 };
 471 
 472 struct CmapSubtableFormat12 : CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;
 473 {
<a name="52" id="anc52"></a><span class="line-modified"> 474   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 475                                                 hb_codepoint_t u)</span>
<span class="line-modified"> 476   { return group.glyphID + (u - group.startCharCode); }</span>

 477 
 478 
 479   bool serialize (hb_serialize_context_t *c,
 480                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)
 481   {
 482     if (unlikely (!c-&gt;extend_min (*this))) return false;
 483 
 484     this-&gt;format.set (12);
 485     this-&gt;reserved.set (0);
 486     this-&gt;length.set (get_sub_table_size (groups));
 487 
 488     return CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;::serialize (c, groups);
 489   }
 490 
<a name="53" id="anc53"></a><span class="line-modified"> 491   static inline size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
 492   {
<a name="54" id="anc54"></a><span class="line-modified"> 493     return 16 + 12 * groups.len;</span>
 494   }
 495 
<a name="55" id="anc55"></a><span class="line-modified"> 496   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 497                                             hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
 498   {
 499     CmapSubtableLongGroup *group = nullptr;
 500 
 501     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 502     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 503       hb_codepoint_t new_gid;
 504       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 505       {
 506         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 507         return false;
 508       }
 509 
 510       if (!group || !_is_gid_consecutive (group, cp, new_gid))
 511       {
 512         group = groups-&gt;push ();
 513         group-&gt;startCharCode.set (cp);
 514         group-&gt;endCharCode.set (cp);
 515         group-&gt;glyphID.set (new_gid);
<a name="56" id="anc56"></a><span class="line-removed"> 516       } else</span>
<span class="line-removed"> 517       {</span>
<span class="line-removed"> 518         group-&gt;endCharCode.set (cp);</span>
 519       }
<a name="57" id="anc57"></a>
 520     }
 521 
 522     DEBUG_MSG(SUBSET, nullptr, &quot;cmap&quot;);
<a name="58" id="anc58"></a><span class="line-modified"> 523     for (unsigned int i = 0; i &lt; groups-&gt;len; i++) {</span>
 524       CmapSubtableLongGroup&amp; group = (*groups)[i];
 525       DEBUG_MSG(SUBSET, nullptr, &quot;  %d: U+%04X-U+%04X, gid %d-%d&quot;, i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));
 526     }
 527 
 528     return true;
 529   }
 530 
 531  private:
<a name="59" id="anc59"></a><span class="line-modified"> 532   static inline bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="line-modified"> 533                                           hb_codepoint_t cp,</span>
<span class="line-modified"> 534                                           hb_codepoint_t new_gid)</span>
 535   {
 536     return (cp - 1 == group-&gt;endCharCode) &amp;&amp;
 537         new_gid == group-&gt;glyphID + (cp - group-&gt;startCharCode);
 538   }
 539 
 540 };
 541 
 542 struct CmapSubtableFormat13 : CmapSubtableLongSegmented&lt;CmapSubtableFormat13&gt;
 543 {
<a name="60" id="anc60"></a><span class="line-modified"> 544   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 545                                                 hb_codepoint_t u HB_UNUSED)</span>
 546   { return group.glyphID; }
 547 };
 548 
 549 typedef enum
 550 {
 551   GLYPH_VARIANT_NOT_FOUND = 0,
 552   GLYPH_VARIANT_FOUND = 1,
 553   GLYPH_VARIANT_USE_DEFAULT = 2
 554 } glyph_variant_t;
 555 
 556 struct UnicodeValueRange
 557 {
<a name="61" id="anc61"></a><span class="line-modified"> 558   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 559   {
 560     if (codepoint &lt; startUnicodeValue) return -1;
 561     if (codepoint &gt; startUnicodeValue + additionalCount) return +1;
 562     return 0;
 563   }
 564 
<a name="62" id="anc62"></a><span class="line-modified"> 565   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 566   {
 567     TRACE_SANITIZE (this);
 568     return_trace (c-&gt;check_struct (this));
 569   }
 570 
 571   HBUINT24      startUnicodeValue;      /* First value in this range. */
<a name="63" id="anc63"></a><span class="line-modified"> 572   HBUINT8               additionalCount;        /* Number of additional values in this</span>
 573                                          * range. */
 574   public:
 575   DEFINE_SIZE_STATIC (4);
 576 };
 577 
<a name="64" id="anc64"></a><span class="line-modified"> 578 typedef SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt; DefaultUVS;</span>
















 579 
 580 struct UVSMapping
 581 {
<a name="65" id="anc65"></a><span class="line-modified"> 582   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 583   {
 584     return unicodeValue.cmp (codepoint);
 585   }
 586 
<a name="66" id="anc66"></a><span class="line-modified"> 587   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 588   {
 589     TRACE_SANITIZE (this);
 590     return_trace (c-&gt;check_struct (this));
 591   }
 592 
 593   HBUINT24      unicodeValue;   /* Base Unicode value of the UVS */
 594   GlyphID       glyphID;        /* Glyph ID of the UVS */
 595   public:
 596   DEFINE_SIZE_STATIC (5);
 597 };
 598 
<a name="67" id="anc67"></a><span class="line-modified"> 599 typedef SortedArrayOf&lt;UVSMapping, HBUINT32&gt; NonDefaultUVS;</span>











 600 
 601 struct VariationSelectorRecord
 602 {
<a name="68" id="anc68"></a><span class="line-modified"> 603   inline glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 604                                     hb_codepoint_t *glyph,</span>
<span class="line-modified"> 605                                     const void *base) const</span>
 606   {
<a name="69" id="anc69"></a><span class="line-modified"> 607     int i;</span>
<span class="line-removed"> 608     const DefaultUVS &amp;defaults = base+defaultUVS;</span>
<span class="line-removed"> 609     i = defaults.bsearch (codepoint);</span>
<span class="line-removed"> 610     if (i != -1)</span>
 611       return GLYPH_VARIANT_USE_DEFAULT;
<a name="70" id="anc70"></a><span class="line-modified"> 612     const NonDefaultUVS &amp;nonDefaults = base+nonDefaultUVS;</span>
<span class="line-modified"> 613     i = nonDefaults.bsearch (codepoint);</span>
<span class="line-removed"> 614     if (i != -1)</span>
 615     {
<a name="71" id="anc71"></a><span class="line-modified"> 616       *glyph = nonDefaults[i].glyphID;</span>
 617        return GLYPH_VARIANT_FOUND;
 618     }
 619     return GLYPH_VARIANT_NOT_FOUND;
 620   }
 621 
<a name="72" id="anc72"></a><span class="line-modified"> 622   inline int cmp (const hb_codepoint_t &amp;variation_selector) const</span>






 623   {
 624     return varSelector.cmp (variation_selector);
 625   }
 626 
<a name="73" id="anc73"></a><span class="line-modified"> 627   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 628   {
 629     TRACE_SANITIZE (this);
 630     return_trace (c-&gt;check_struct (this) &amp;&amp;
 631                   defaultUVS.sanitize (c, base) &amp;&amp;
 632                   nonDefaultUVS.sanitize (c, base));
 633   }
 634 
 635   HBUINT24      varSelector;    /* Variation selector. */
 636   LOffsetTo&lt;DefaultUVS&gt;
<a name="74" id="anc74"></a><span class="line-modified"> 637                 defaultUVS;     /* Offset to Default UVS Table. May be 0. */</span>
 638   LOffsetTo&lt;NonDefaultUVS&gt;
<a name="75" id="anc75"></a><span class="line-modified"> 639                 nonDefaultUVS;  /* Offset to Non-Default UVS Table. May be 0. */</span>
 640   public:
 641   DEFINE_SIZE_STATIC (11);
 642 };
 643 
 644 struct CmapSubtableFormat14
 645 {
<a name="76" id="anc76"></a><span class="line-modified"> 646   inline glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 647                                             hb_codepoint_t variation_selector,</span>
<span class="line-modified"> 648                                             hb_codepoint_t *glyph) const</span>
 649   {
<a name="77" id="anc77"></a><span class="line-modified"> 650     return record[record.bsearch(variation_selector)].get_glyph (codepoint, glyph, this);</span>
 651   }
 652 
<a name="78" id="anc78"></a><span class="line-modified"> 653   inline bool sanitize (hb_sanitize_context_t *c) const</span>












 654   {
 655     TRACE_SANITIZE (this);
 656     return_trace (c-&gt;check_struct (this) &amp;&amp;
 657                   record.sanitize (c, this));
 658   }
 659 
 660   protected:
 661   HBUINT16      format;         /* Format number is set to 14. */
 662   HBUINT32      length;         /* Byte length of this subtable. */
 663   SortedArrayOf&lt;VariationSelectorRecord, HBUINT32&gt;
 664                 record;         /* Variation selector records; sorted
 665                                  * in increasing order of `varSelector&#39;. */
 666   public:
 667   DEFINE_SIZE_ARRAY (10, record);
 668 };
 669 
 670 struct CmapSubtable
 671 {
 672   /* Note: We intentionally do NOT implement subtable formats 2 and 8. */
 673 
<a name="79" id="anc79"></a><span class="line-modified"> 674   inline bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 675                          hb_codepoint_t *glyph) const</span>
 676   {
 677     switch (u.format) {
 678     case  0: return u.format0 .get_glyph (codepoint, glyph);
 679     case  4: return u.format4 .get_glyph (codepoint, glyph);
 680     case  6: return u.format6 .get_glyph (codepoint, glyph);
 681     case 10: return u.format10.get_glyph (codepoint, glyph);
 682     case 12: return u.format12.get_glyph (codepoint, glyph);
 683     case 13: return u.format13.get_glyph (codepoint, glyph);
 684     case 14:
 685     default: return false;
 686     }
 687   }
<a name="80" id="anc80"></a>












 688 
<a name="81" id="anc81"></a><span class="line-modified"> 689   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 690   {
 691     TRACE_SANITIZE (this);
 692     if (!u.format.sanitize (c)) return_trace (false);
 693     switch (u.format) {
 694     case  0: return_trace (u.format0 .sanitize (c));
 695     case  4: return_trace (u.format4 .sanitize (c));
 696     case  6: return_trace (u.format6 .sanitize (c));
 697     case 10: return_trace (u.format10.sanitize (c));
 698     case 12: return_trace (u.format12.sanitize (c));
 699     case 13: return_trace (u.format13.sanitize (c));
 700     case 14: return_trace (u.format14.sanitize (c));
 701     default:return_trace (true);
 702     }
 703   }
 704 
 705   public:
 706   union {
 707   HBUINT16              format;         /* Format identifier */
 708   CmapSubtableFormat0   format0;
 709   CmapSubtableFormat4   format4;
 710   CmapSubtableFormat6   format6;
 711   CmapSubtableFormat10  format10;
 712   CmapSubtableFormat12  format12;
 713   CmapSubtableFormat13  format13;
 714   CmapSubtableFormat14  format14;
 715   } u;
 716   public:
 717   DEFINE_SIZE_UNION (2, format);
 718 };
 719 
 720 
 721 struct EncodingRecord
 722 {
<a name="82" id="anc82"></a><span class="line-modified"> 723   inline int cmp (const EncodingRecord &amp;other) const</span>
 724   {
 725     int ret;
 726     ret = platformID.cmp (other.platformID);
 727     if (ret) return ret;
 728     ret = encodingID.cmp (other.encodingID);
 729     if (ret) return ret;
 730     return 0;
 731   }
 732 
<a name="83" id="anc83"></a><span class="line-modified"> 733   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 734   {
 735     TRACE_SANITIZE (this);
 736     return_trace (c-&gt;check_struct (this) &amp;&amp;
 737                   subtable.sanitize (c, base));
 738   }
 739 
 740   HBUINT16      platformID;     /* Platform ID. */
 741   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 742   LOffsetTo&lt;CmapSubtable&gt;
 743                 subtable;       /* Byte offset from beginning of table to the subtable for this encoding. */
 744   public:
 745   DEFINE_SIZE_STATIC (8);
 746 };
 747 
 748 struct cmap
 749 {
<a name="84" id="anc84"></a><span class="line-modified"> 750   static const hb_tag_t tableTag        = HB_OT_TAG_cmap;</span>
<span class="line-removed"> 751 </span>
<span class="line-removed"> 752   struct subset_plan {</span>
<span class="line-removed"> 753     subset_plan(void)</span>
<span class="line-removed"> 754     {</span>
<span class="line-removed"> 755       format4_segments.init();</span>
<span class="line-removed"> 756       format12_groups.init();</span>
<span class="line-removed"> 757     }</span>
 758 
<a name="85" id="anc85"></a><span class="line-modified"> 759     ~subset_plan(void)</span>
<span class="line-modified"> 760     {</span>
<span class="line-modified"> 761       format4_segments.fini();</span>
<span class="line-removed"> 762       format12_groups.fini();</span>
<span class="line-removed"> 763     }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765     inline size_t final_size() const</span>
 766     {
 767       return 4 // header
 768           +  8 * 3 // 3 EncodingRecord
 769           +  CmapSubtableFormat4::get_sub_table_size (this-&gt;format4_segments)
 770           +  CmapSubtableFormat12::get_sub_table_size (this-&gt;format12_groups);
 771     }
 772 
<a name="86" id="anc86"></a><span class="line-removed"> 773     // Format 4</span>
 774     hb_vector_t&lt;CmapSubtableFormat4::segment_plan&gt; format4_segments;
<a name="87" id="anc87"></a><span class="line-removed"> 775     // Format 12</span>
 776     hb_vector_t&lt;CmapSubtableLongGroup&gt; format12_groups;
 777   };
 778 
<a name="88" id="anc88"></a><span class="line-modified"> 779   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified"> 780   {</span>
<span class="line-removed"> 781     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 782     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed"> 783                   likely (version == 0) &amp;&amp;</span>
<span class="line-removed"> 784                   encodingRecord.sanitize (c, this));</span>
<span class="line-removed"> 785   }</span>
<span class="line-removed"> 786 </span>
<span class="line-removed"> 787   inline bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="line-removed"> 788                             subset_plan *cmap_plan) const</span>
 789   {
<a name="89" id="anc89"></a><span class="line-modified"> 790     if (unlikely( !CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
 791       return false;
 792 
 793     return CmapSubtableFormat12::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format12_groups);
 794   }
 795 
<a name="90" id="anc90"></a><span class="line-modified"> 796   inline bool _subset (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 797                        const subset_plan &amp;cmap_subset_plan,</span>
<span class="line-modified"> 798                        size_t dest_sz,</span>
<span class="line-modified"> 799                        void *dest) const</span>
 800   {
 801     hb_serialize_context_t c (dest, dest_sz);
 802 
<a name="91" id="anc91"></a><span class="line-modified"> 803     OT::cmap *cmap = c.start_serialize&lt;OT::cmap&gt; ();</span>
<span class="line-modified"> 804     if (unlikely (!c.extend_min (*cmap)))</span>
 805     {
 806       return false;
 807     }
 808 
<a name="92" id="anc92"></a><span class="line-modified"> 809     cmap-&gt;version.set (0);</span>
 810 
<a name="93" id="anc93"></a><span class="line-modified"> 811     if (unlikely (!cmap-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
 812       return false;
 813 
 814     // TODO(grieger): Convert the below to a for loop
 815 
 816     // Format 4, Plat 0 Encoding Record
<a name="94" id="anc94"></a><span class="line-modified"> 817     EncodingRecord &amp;format4_plat0_rec = cmap-&gt;encodingRecord[0];</span>
 818     format4_plat0_rec.platformID.set (0); // Unicode
 819     format4_plat0_rec.encodingID.set (3);
 820 
 821     // Format 4, Plat 3 Encoding Record
<a name="95" id="anc95"></a><span class="line-modified"> 822     EncodingRecord &amp;format4_plat3_rec = cmap-&gt;encodingRecord[1];</span>
 823     format4_plat3_rec.platformID.set (3); // Windows
 824     format4_plat3_rec.encodingID.set (1); // Unicode BMP
 825 
 826     // Format 12 Encoding Record
<a name="96" id="anc96"></a><span class="line-modified"> 827     EncodingRecord &amp;format12_rec = cmap-&gt;encodingRecord[2];</span>
 828     format12_rec.platformID.set (3); // Windows
 829     format12_rec.encodingID.set (10); // Unicode UCS-4
 830 
 831     // Write out format 4 sub table
 832     {
<a name="97" id="anc97"></a><span class="line-modified"> 833       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, cmap);</span>
 834       format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);
 835       subtable.u.format.set (4);
 836 
 837       CmapSubtableFormat4 &amp;format4 = subtable.u.format4;
 838       if (unlikely (!format4.serialize (&amp;c, plan, cmap_subset_plan.format4_segments)))
 839         return false;
 840     }
 841 
 842     // Write out format 12 sub table.
 843     {
<a name="98" id="anc98"></a><span class="line-modified"> 844       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, cmap);</span>
 845       subtable.u.format.set (12);
 846 
 847       CmapSubtableFormat12 &amp;format12 = subtable.u.format12;
 848       if (unlikely (!format12.serialize (&amp;c, cmap_subset_plan.format12_groups)))
 849         return false;
 850     }
 851 
 852     c.end_serialize ();
 853 
 854     return true;
 855   }
 856 
<a name="99" id="anc99"></a><span class="line-modified"> 857   inline bool subset (hb_subset_plan_t *plan) const</span>
 858   {
 859     subset_plan cmap_subset_plan;
 860 
 861     if (unlikely (!_create_plan (plan, &amp;cmap_subset_plan)))
 862     {
 863       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to generate a cmap subsetting plan.&quot;);
 864       return false;
 865     }
 866 
 867     // We now know how big our blob needs to be
<a name="100" id="anc100"></a><span class="line-modified"> 868     size_t dest_sz = cmap_subset_plan.final_size();</span>
 869     void *dest = malloc (dest_sz);
 870     if (unlikely (!dest)) {
 871       DEBUG_MSG(SUBSET, nullptr, &quot;Unable to alloc %lu for cmap subset output&quot;, (unsigned long) dest_sz);
 872       return false;
 873     }
 874 
 875     if (unlikely (!_subset (plan, cmap_subset_plan, dest_sz, dest)))
 876     {
 877       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to perform subsetting of cmap.&quot;);
 878       free (dest);
 879       return false;
 880     }
 881 
 882     // all done, write the blob into dest
<a name="101" id="anc101"></a><span class="line-modified"> 883     hb_blob_t *cmap_prime = hb_blob_create ((const char *)dest,</span>
 884                                             dest_sz,
 885                                             HB_MEMORY_MODE_READONLY,
 886                                             dest,
 887                                             free);
 888     bool result =  plan-&gt;add_table (HB_OT_TAG_cmap, cmap_prime);
 889     hb_blob_destroy (cmap_prime);
 890     return result;
 891   }
 892 
<a name="102" id="anc102"></a><span class="line-modified"> 893   struct accelerator_t</span>
 894   {
<a name="103" id="anc103"></a><span class="line-modified"> 895     inline void init (hb_face_t *face)</span>

















 896     {
<a name="104" id="anc104"></a><span class="line-modified"> 897       this-&gt;blob = OT::Sanitizer&lt;OT::cmap&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_cmap));</span>
<span class="line-modified"> 898       const OT::cmap *cmap = this-&gt;blob-&gt;as&lt;OT::cmap&gt; ();</span>
<span class="line-modified"> 899       const OT::CmapSubtable *subtable = nullptr;</span>
<span class="line-modified"> 900       const OT::CmapSubtableFormat14 *subtable_uvs = nullptr;</span>
<span class="line-modified"> 901 </span>
<span class="line-modified"> 902       bool symbol = false;</span>
<span class="line-modified"> 903       /* 32-bit subtables. */</span>
<span class="line-removed"> 904       if (!subtable) subtable = cmap-&gt;find_subtable (3, 10);</span>
<span class="line-removed"> 905       if (!subtable) subtable = cmap-&gt;find_subtable (0, 6);</span>
<span class="line-removed"> 906       if (!subtable) subtable = cmap-&gt;find_subtable (0, 4);</span>
<span class="line-removed"> 907       /* 16-bit subtables. */</span>
<span class="line-removed"> 908       if (!subtable) subtable = cmap-&gt;find_subtable (3, 1);</span>
<span class="line-removed"> 909       if (!subtable) subtable = cmap-&gt;find_subtable (0, 3);</span>
<span class="line-removed"> 910       if (!subtable) subtable = cmap-&gt;find_subtable (0, 2);</span>
<span class="line-removed"> 911       if (!subtable) subtable = cmap-&gt;find_subtable (0, 1);</span>
<span class="line-removed"> 912       if (!subtable) subtable = cmap-&gt;find_subtable (0, 0);</span>
<span class="line-removed"> 913       if (!subtable)</span>
<span class="line-removed"> 914       {</span>
<span class="line-removed"> 915         subtable = cmap-&gt;find_subtable (3, 0);</span>
<span class="line-removed"> 916         if (subtable) symbol = true;</span>
<span class="line-removed"> 917       }</span>
<span class="line-removed"> 918       /* Meh. */</span>
<span class="line-removed"> 919       if (!subtable) subtable = &amp;Null(OT::CmapSubtable);</span>
 920 
<a name="105" id="anc105"></a><span class="line-modified"> 921       /* UVS subtable. */</span>
<span class="line-modified"> 922       if (!subtable_uvs)</span>






 923       {
<a name="106" id="anc106"></a><span class="line-modified"> 924         const OT::CmapSubtable *st = cmap-&gt;find_subtable (0, 5);</span>
 925         if (st &amp;&amp; st-&gt;u.format == 14)
 926           subtable_uvs = &amp;st-&gt;u.format14;
 927       }
<a name="107" id="anc107"></a><span class="line-removed"> 928       /* Meh. */</span>
<span class="line-removed"> 929       if (!subtable_uvs) subtable_uvs = &amp;Null(OT::CmapSubtableFormat14);</span>
<span class="line-removed"> 930 </span>
<span class="line-removed"> 931       this-&gt;uvs_table = subtable_uvs;</span>
 932 
 933       this-&gt;get_glyph_data = subtable;
 934       if (unlikely (symbol))
 935       {
<a name="108" id="anc108"></a><span class="line-modified"> 936         this-&gt;get_glyph_func = get_glyph_from_symbol&lt;OT::CmapSubtable&gt;;</span>
<span class="line-removed"> 937         this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
 938       } else {
 939         switch (subtable-&gt;u.format) {
 940         /* Accelerate format 4 and format 12. */
 941         default:
<a name="109" id="anc109"></a><span class="line-modified"> 942           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtable&gt;;</span>
<span class="line-removed"> 943           this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
 944           break;
 945         case 12:
<a name="110" id="anc110"></a><span class="line-modified"> 946           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtableFormat12&gt;;</span>
<span class="line-removed"> 947           this-&gt;get_all_codepoints_func = get_all_codepoints_from&lt;OT::CmapSubtableFormat12&gt;;</span>
 948           break;
 949         case  4:
 950           {
 951             this-&gt;format4_accel.init (&amp;subtable-&gt;u.format4);
 952             this-&gt;get_glyph_data = &amp;this-&gt;format4_accel;
<a name="111" id="anc111"></a><span class="line-modified"> 953             this-&gt;get_glyph_func = this-&gt;format4_accel.get_glyph_func;</span>
<span class="line-removed"> 954             this-&gt;get_all_codepoints_func = this-&gt;format4_accel.get_all_codepoints_func;</span>
 955           }
 956           break;
 957         }
 958       }
 959     }
 960 
<a name="112" id="anc112"></a><span class="line-modified"> 961     inline void fini (void)</span>
<span class="line-removed"> 962     {</span>
<span class="line-removed"> 963       hb_blob_destroy (this-&gt;blob);</span>
<span class="line-removed"> 964     }</span>
 965 
<a name="113" id="anc113"></a><span class="line-modified"> 966     inline bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
 967                                    hb_codepoint_t *glyph) const
 968     {
<a name="114" id="anc114"></a><span class="line-modified"> 969       return this-&gt;get_glyph_func (this-&gt;get_glyph_data, unicode, glyph);</span>






















 970     }
 971 
<a name="115" id="anc115"></a><span class="line-modified"> 972     inline bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="line-modified"> 973                                      hb_codepoint_t  variation_selector,</span>
<span class="line-modified"> 974                                      hb_codepoint_t *glyph) const</span>
 975     {
<a name="116" id="anc116"></a><span class="line-modified"> 976       switch (this-&gt;uvs_table-&gt;get_glyph_variant (unicode,</span>
<span class="line-modified"> 977                                                   variation_selector,</span>
<span class="line-modified"> 978                                                   glyph))</span>
 979       {
<a name="117" id="anc117"></a><span class="line-modified"> 980         case OT::GLYPH_VARIANT_NOT_FOUND:               return false;</span>
<span class="line-modified"> 981         case OT::GLYPH_VARIANT_FOUND:           return true;</span>
<span class="line-modified"> 982         case OT::GLYPH_VARIANT_USE_DEFAULT:     break;</span>
 983       }
 984 
 985       return get_nominal_glyph (unicode, glyph);
 986     }
 987 
<a name="118" id="anc118"></a><span class="line-modified"> 988     inline void get_all_codepoints (hb_set_t *out) const</span>









 989     {
<a name="119" id="anc119"></a><span class="line-modified"> 990       this-&gt;get_all_codepoints_func (get_glyph_data, out);</span>
 991     }
 992 
 993     protected:
 994     typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,
 995                                               hb_codepoint_t codepoint,
 996                                               hb_codepoint_t *glyph);
<a name="120" id="anc120"></a><span class="line-removed"> 997     typedef void (*hb_cmap_get_all_codepoints_func_t) (const void *obj,</span>
<span class="line-removed"> 998                                                        hb_set_t *out);</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000     static inline void null_get_all_codepoints_func (const void *obj, hb_set_t *out)</span>
<span class="line-removed">1001     {</span>
<span class="line-removed">1002       // NOOP</span>
<span class="line-removed">1003     }</span>
1004 
1005     template &lt;typename Type&gt;
<a name="121" id="anc121"></a><span class="line-modified">1006     static inline bool get_glyph_from (const void *obj,</span>
<span class="line-modified">1007                                        hb_codepoint_t codepoint,</span>
<span class="line-modified">1008                                        hb_codepoint_t *glyph)</span>
1009     {
1010       const Type *typed_obj = (const Type *) obj;
1011       return typed_obj-&gt;get_glyph (codepoint, glyph);
1012     }
1013 
1014     template &lt;typename Type&gt;
<a name="122" id="anc122"></a><span class="line-modified">1015     static inline void get_all_codepoints_from (const void *obj,</span>
<span class="line-removed">1016                                                 hb_set_t *out)</span>
<span class="line-removed">1017     {</span>
<span class="line-removed">1018       const Type *typed_obj = (const Type *) obj;</span>
<span class="line-removed">1019       typed_obj-&gt;get_all_codepoints (out);</span>
<span class="line-removed">1020     }</span>
<span class="line-removed">1021 </span>
<span class="line-removed">1022     template &lt;typename Type&gt;</span>
<span class="line-removed">1023     static inline bool get_glyph_from_symbol (const void *obj,</span>
1024                                               hb_codepoint_t codepoint,
1025                                               hb_codepoint_t *glyph)
1026     {
1027       const Type *typed_obj = (const Type *) obj;
1028       if (likely (typed_obj-&gt;get_glyph (codepoint, glyph)))
1029         return true;
1030 
1031       if (codepoint &lt;= 0x00FFu)
1032       {
1033         /* For symbol-encoded OpenType fonts, we duplicate the
1034          * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
1035          * Windows seems to do, and that&#39;s hinted about at:
1036          * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
1037          * under &quot;Non-Standard (Symbol) Fonts&quot;. */
1038         return typed_obj-&gt;get_glyph (0xF000u + codepoint, glyph);
1039       }
1040 
1041       return false;
1042     }
1043 
1044     private:
<a name="123" id="anc123"></a><span class="line-modified">1045     hb_cmap_get_glyph_func_t get_glyph_func;</span>



1046     const void *get_glyph_data;
<a name="124" id="anc124"></a><span class="line-removed">1047     hb_cmap_get_all_codepoints_func_t get_all_codepoints_func;</span>
1048 
<a name="125" id="anc125"></a><span class="line-modified">1049     OT::CmapSubtableFormat4::accelerator_t format4_accel;</span>
1050 
<a name="126" id="anc126"></a><span class="line-modified">1051     const OT::CmapSubtableFormat14 *uvs_table;</span>
<span class="line-removed">1052     hb_blob_t *blob;</span>
1053   };
1054 
1055   protected:
1056 
<a name="127" id="anc127"></a><span class="line-modified">1057   inline const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="line-modified">1058                                             unsigned int encoding_id) const</span>
1059   {
1060     EncodingRecord key;
1061     key.platformID.set (platform_id);
1062     key.encodingID.set (encoding_id);
1063 
<a name="128" id="anc128"></a><span class="line-modified">1064     /* Note: We can use bsearch, but since it has no performance</span>
<span class="line-modified">1065      * implications, we use lsearch and as such accept fonts with</span>
<span class="line-removed">1066      * unsorted subtable list. */</span>
<span class="line-removed">1067     int result = encodingRecord./*bsearch*/lsearch (key);</span>
<span class="line-removed">1068     if (result == -1 || !encodingRecord[result].subtable)</span>
1069       return nullptr;
1070 
<a name="129" id="anc129"></a><span class="line-modified">1071     return &amp;(this+encodingRecord[result].subtable);</span>










1072   }
1073 
1074   protected:
1075   HBUINT16              version;        /* Table version number (0). */
1076   SortedArrayOf&lt;EncodingRecord&gt;
1077                         encodingRecord; /* Encoding tables. */
1078   public:
1079   DEFINE_SIZE_ARRAY (4, encodingRecord);
1080 };
1081 
<a name="130" id="anc130"></a>
1082 
1083 } /* namespace OT */
1084 
1085 
1086 #endif /* HB_OT_CMAP_TABLE_HH */
<a name="131" id="anc131"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="131" type="hidden" />
</body>
</html>
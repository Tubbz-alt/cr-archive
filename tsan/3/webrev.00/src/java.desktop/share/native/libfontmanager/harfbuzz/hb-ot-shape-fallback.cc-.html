<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #include &quot;hb-ot-shape-fallback-private.hh&quot;
 28 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;
 29 
 30 static unsigned int
 31 recategorize_combining_class (hb_codepoint_t u,
 32                               unsigned int klass)
 33 {
 34   if (klass &gt;= 200)
 35     return klass;
 36 
 37   /* Thai / Lao need some per-character work. */
 38   if ((u &amp; ~0xFF) == 0x0E00u)
 39   {
 40     if (unlikely (klass == 0))
 41     {
 42       switch (u)
 43       {
 44         case 0x0E31u:
 45         case 0x0E34u:
 46         case 0x0E35u:
 47         case 0x0E36u:
 48         case 0x0E37u:
 49         case 0x0E47u:
 50         case 0x0E4Cu:
 51         case 0x0E4Du:
 52         case 0x0E4Eu:
 53           klass = HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;
 54           break;
 55 
 56         case 0x0EB1u:
 57         case 0x0EB4u:
 58         case 0x0EB5u:
 59         case 0x0EB6u:
 60         case 0x0EB7u:
 61         case 0x0EBBu:
 62         case 0x0ECCu:
 63         case 0x0ECDu:
 64           klass = HB_UNICODE_COMBINING_CLASS_ABOVE;
 65           break;
 66 
 67         case 0x0EBCu:
 68           klass = HB_UNICODE_COMBINING_CLASS_BELOW;
 69           break;
 70       }
 71     } else {
 72       /* Thai virama is below-right */
 73       if (u == 0x0E3Au)
 74         klass = HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT;
 75     }
 76   }
 77 
 78   switch (klass)
 79   {
 80 
 81     /* Hebrew */
 82 
 83     case HB_MODIFIED_COMBINING_CLASS_CCC10: /* sheva */
 84     case HB_MODIFIED_COMBINING_CLASS_CCC11: /* hataf segol */
 85     case HB_MODIFIED_COMBINING_CLASS_CCC12: /* hataf patah */
 86     case HB_MODIFIED_COMBINING_CLASS_CCC13: /* hataf qamats */
 87     case HB_MODIFIED_COMBINING_CLASS_CCC14: /* hiriq */
 88     case HB_MODIFIED_COMBINING_CLASS_CCC15: /* tsere */
 89     case HB_MODIFIED_COMBINING_CLASS_CCC16: /* segol */
 90     case HB_MODIFIED_COMBINING_CLASS_CCC17: /* patah */
 91     case HB_MODIFIED_COMBINING_CLASS_CCC18: /* qamats */
 92     case HB_MODIFIED_COMBINING_CLASS_CCC20: /* qubuts */
 93     case HB_MODIFIED_COMBINING_CLASS_CCC22: /* meteg */
 94       return HB_UNICODE_COMBINING_CLASS_BELOW;
 95 
 96     case HB_MODIFIED_COMBINING_CLASS_CCC23: /* rafe */
 97       return HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE;
 98 
 99     case HB_MODIFIED_COMBINING_CLASS_CCC24: /* shin dot */
100       return HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;
101 
102     case HB_MODIFIED_COMBINING_CLASS_CCC25: /* sin dot */
103     case HB_MODIFIED_COMBINING_CLASS_CCC19: /* holam */
104       return HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT;
105 
106     case HB_MODIFIED_COMBINING_CLASS_CCC26: /* point varika */
107       return HB_UNICODE_COMBINING_CLASS_ABOVE;
108 
109     case HB_MODIFIED_COMBINING_CLASS_CCC21: /* dagesh */
110       break;
111 
112 
113     /* Arabic and Syriac */
114 
115     case HB_MODIFIED_COMBINING_CLASS_CCC27: /* fathatan */
116     case HB_MODIFIED_COMBINING_CLASS_CCC28: /* dammatan */
117     case HB_MODIFIED_COMBINING_CLASS_CCC30: /* fatha */
118     case HB_MODIFIED_COMBINING_CLASS_CCC31: /* damma */
119     case HB_MODIFIED_COMBINING_CLASS_CCC33: /* shadda */
120     case HB_MODIFIED_COMBINING_CLASS_CCC34: /* sukun */
121     case HB_MODIFIED_COMBINING_CLASS_CCC35: /* superscript alef */
122     case HB_MODIFIED_COMBINING_CLASS_CCC36: /* superscript alaph */
123       return HB_UNICODE_COMBINING_CLASS_ABOVE;
124 
125     case HB_MODIFIED_COMBINING_CLASS_CCC29: /* kasratan */
126     case HB_MODIFIED_COMBINING_CLASS_CCC32: /* kasra */
127       return HB_UNICODE_COMBINING_CLASS_BELOW;
128 
129 
130     /* Thai */
131 
132     case HB_MODIFIED_COMBINING_CLASS_CCC103: /* sara u / sara uu */
133       return HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT;
134 
135     case HB_MODIFIED_COMBINING_CLASS_CCC107: /* mai */
136       return HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;
137 
138 
139     /* Lao */
140 
141     case HB_MODIFIED_COMBINING_CLASS_CCC118: /* sign u / sign uu */
142       return HB_UNICODE_COMBINING_CLASS_BELOW;
143 
144     case HB_MODIFIED_COMBINING_CLASS_CCC122: /* mai */
145       return HB_UNICODE_COMBINING_CLASS_ABOVE;
146 
147 
148     /* Tibetan */
149 
150     case HB_MODIFIED_COMBINING_CLASS_CCC129: /* sign aa */
151       return HB_UNICODE_COMBINING_CLASS_BELOW;
152 
153     case HB_MODIFIED_COMBINING_CLASS_CCC130: /* sign i*/
154       return HB_UNICODE_COMBINING_CLASS_ABOVE;
155 
156     case HB_MODIFIED_COMBINING_CLASS_CCC132: /* sign u */
157       return HB_UNICODE_COMBINING_CLASS_BELOW;
158 
159   }
160 
161   return klass;
162 }
163 
164 void
165 _hb_ot_shape_fallback_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,
166                                                    hb_font_t *font HB_UNUSED,
167                                                    hb_buffer_t  *buffer)
168 {
169   unsigned int count = buffer-&gt;len;
170   hb_glyph_info_t *info = buffer-&gt;info;
171   for (unsigned int i = 0; i &lt; count; i++)
172     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
173       unsigned int combining_class = _hb_glyph_info_get_modified_combining_class (&amp;info[i]);
174       combining_class = recategorize_combining_class (info[i].codepoint, combining_class);
175       _hb_glyph_info_set_modified_combining_class (&amp;info[i], combining_class);
176     }
177 }
178 
179 
180 static void
181 zero_mark_advances (hb_buffer_t *buffer,
182                     unsigned int start,
183                     unsigned int end)
184 {
185   hb_glyph_info_t *info = buffer-&gt;info;
186   for (unsigned int i = start; i &lt; end; i++)
187     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
188     {
189       buffer-&gt;pos[i].x_advance = 0;
190       buffer-&gt;pos[i].y_advance = 0;
191     }
192 }
193 
194 static inline void
195 position_mark (const hb_ot_shape_plan_t *plan,
196                hb_font_t *font,
197                hb_buffer_t  *buffer,
198                hb_glyph_extents_t &amp;base_extents,
199                unsigned int i,
200                unsigned int combining_class)
201 {
202   hb_glyph_extents_t mark_extents;
203   if (!font-&gt;get_glyph_extents (buffer-&gt;info[i].codepoint, &amp;mark_extents))
204     return;
205 
206   hb_position_t y_gap = font-&gt;y_scale / 16;
207 
208   hb_glyph_position_t &amp;pos = buffer-&gt;pos[i];
209   pos.x_offset = pos.y_offset = 0;
210 
211 
212   /* We don&#39;t position LEFT and RIGHT marks. */
213 
214   /* X positioning */
215   switch (combining_class)
216   {
217     case HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW:
218     case HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE:
219       if (buffer-&gt;props.direction == HB_DIRECTION_LTR) {
220         pos.x_offset += base_extents.x_bearing + base_extents.width - mark_extents.width / 2 - mark_extents.x_bearing;
221         break;
222       } else if (buffer-&gt;props.direction == HB_DIRECTION_RTL) {
223         pos.x_offset += base_extents.x_bearing - mark_extents.width / 2 - mark_extents.x_bearing;
224         break;
225       }
226       HB_FALLTHROUGH;
227 
228     default:
229     case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW:
230     case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE:
231     case HB_UNICODE_COMBINING_CLASS_BELOW:
232     case HB_UNICODE_COMBINING_CLASS_ABOVE:
233       /* Center align. */
234       pos.x_offset += base_extents.x_bearing + (base_extents.width - mark_extents.width) / 2 - mark_extents.x_bearing;
235       break;
236 
237     case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT:
238     case HB_UNICODE_COMBINING_CLASS_BELOW_LEFT:
239     case HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT:
240       /* Left align. */
241       pos.x_offset += base_extents.x_bearing - mark_extents.x_bearing;
242       break;
243 
244     case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT:
245     case HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT:
246     case HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT:
247       /* Right align. */
248       pos.x_offset += base_extents.x_bearing + base_extents.width - mark_extents.width - mark_extents.x_bearing;
249       break;
250   }
251 
252   /* Y positioning */
253   switch (combining_class)
254   {
255     case HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW:
256     case HB_UNICODE_COMBINING_CLASS_BELOW_LEFT:
257     case HB_UNICODE_COMBINING_CLASS_BELOW:
258     case HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT:
259       /* Add gap, fall-through. */
260       base_extents.height -= y_gap;
261       HB_FALLTHROUGH;
262 
263     case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT:
264     case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW:
265       pos.y_offset = base_extents.y_bearing + base_extents.height - mark_extents.y_bearing;
266       /* Never shift up &quot;below&quot; marks. */
267       if ((y_gap &gt; 0) == (pos.y_offset &gt; 0))
268       {
269         base_extents.height -= pos.y_offset;
270         pos.y_offset = 0;
271       }
272       base_extents.height += mark_extents.height;
273       break;
274 
275     case HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE:
276     case HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT:
277     case HB_UNICODE_COMBINING_CLASS_ABOVE:
278     case HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT:
279       /* Add gap, fall-through. */
280       base_extents.y_bearing += y_gap;
281       base_extents.height -= y_gap;
282       HB_FALLTHROUGH;
283 
284     case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE:
285     case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT:
286       pos.y_offset = base_extents.y_bearing - (mark_extents.y_bearing + mark_extents.height);
287       /* Don&#39;t shift down &quot;above&quot; marks too much. */
288       if ((y_gap &gt; 0) != (pos.y_offset &gt; 0))
289       {
290         unsigned int correction = -pos.y_offset / 2;
291         base_extents.y_bearing += correction;
292         base_extents.height -= correction;
293         pos.y_offset += correction;
294       }
295       base_extents.y_bearing -= mark_extents.height;
296       base_extents.height += mark_extents.height;
297       break;
298   }
299 }
300 
301 static inline void
302 position_around_base (const hb_ot_shape_plan_t *plan,
303                       hb_font_t *font,
304                       hb_buffer_t  *buffer,
305                       unsigned int base,
306                       unsigned int end)
307 {
308   hb_direction_t horiz_dir = HB_DIRECTION_INVALID;
309 
310   buffer-&gt;unsafe_to_break (base, end);
311 
312   hb_glyph_extents_t base_extents;
313   if (!font-&gt;get_glyph_extents (buffer-&gt;info[base].codepoint,
314                                 &amp;base_extents))
315   {
316     /* If extents don&#39;t work, zero marks and go home. */
317     zero_mark_advances (buffer, base + 1, end);
318     return;
319   }
320   base_extents.x_bearing += buffer-&gt;pos[base].x_offset;
321   base_extents.y_bearing += buffer-&gt;pos[base].y_offset;
322 
323   unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[base]);
324   /* Use integer for num_lig_components such that it doesn&#39;t convert to unsigned
325    * when we divide or multiply by it. */
326   int num_lig_components = _hb_glyph_info_get_lig_num_comps (&amp;buffer-&gt;info[base]);
327 
328   hb_position_t x_offset = 0, y_offset = 0;
329   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
330     x_offset -= buffer-&gt;pos[base].x_advance;
331     y_offset -= buffer-&gt;pos[base].y_advance;
332   }
333 
334   hb_glyph_extents_t component_extents = base_extents;
335   int last_lig_component = -1;
336   unsigned int last_combining_class = 255;
337   hb_glyph_extents_t cluster_extents = base_extents; /* Initialization is just to shut gcc up. */
338   hb_glyph_info_t *info = buffer-&gt;info;
339   for (unsigned int i = base + 1; i &lt; end; i++)
340     if (_hb_glyph_info_get_modified_combining_class (&amp;info[i]))
341     {
342       if (num_lig_components &gt; 1) {
343         unsigned int this_lig_id = _hb_glyph_info_get_lig_id (&amp;info[i]);
344         int this_lig_component = _hb_glyph_info_get_lig_comp (&amp;info[i]) - 1;
345         /* Conditions for attaching to the last component. */
346         if (!lig_id || lig_id != this_lig_id || this_lig_component &gt;= num_lig_components)
347           this_lig_component = num_lig_components - 1;
348         if (last_lig_component != this_lig_component)
349         {
350           last_lig_component = this_lig_component;
351           last_combining_class = 255;
352           component_extents = base_extents;
353           if (unlikely (horiz_dir == HB_DIRECTION_INVALID)) {
354             if (HB_DIRECTION_IS_HORIZONTAL (plan-&gt;props.direction))
355               horiz_dir = plan-&gt;props.direction;
356             else
357               horiz_dir = hb_script_get_horizontal_direction (plan-&gt;props.script);
358           }
359           if (horiz_dir == HB_DIRECTION_LTR)
360             component_extents.x_bearing += (this_lig_component * component_extents.width) / num_lig_components;
361           else
362             component_extents.x_bearing += ((num_lig_components - 1 - this_lig_component) * component_extents.width) / num_lig_components;
363           component_extents.width /= num_lig_components;
364         }
365       }
366 
367       unsigned int this_combining_class = _hb_glyph_info_get_modified_combining_class (&amp;info[i]);
368       if (last_combining_class != this_combining_class)
369       {
370         last_combining_class = this_combining_class;
371         cluster_extents = component_extents;
372       }
373 
374       position_mark (plan, font, buffer, cluster_extents, i, this_combining_class);
375 
376       buffer-&gt;pos[i].x_advance = 0;
377       buffer-&gt;pos[i].y_advance = 0;
378       buffer-&gt;pos[i].x_offset += x_offset;
379       buffer-&gt;pos[i].y_offset += y_offset;
380 
381     } else {
382       if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
383         x_offset -= buffer-&gt;pos[i].x_advance;
384         y_offset -= buffer-&gt;pos[i].y_advance;
385       } else {
386         x_offset += buffer-&gt;pos[i].x_advance;
387         y_offset += buffer-&gt;pos[i].y_advance;
388       }
389     }
390 }
391 
392 static inline void
393 position_cluster (const hb_ot_shape_plan_t *plan,
394                   hb_font_t *font,
395                   hb_buffer_t  *buffer,
396                   unsigned int start,
397                   unsigned int end)
398 {
399   if (end - start &lt; 2)
400     return;
401 
402   /* Find the base glyph */
403   hb_glyph_info_t *info = buffer-&gt;info;
404   for (unsigned int i = start; i &lt; end; i++)
405     if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))
406     {
407       /* Find mark glyphs */
408       unsigned int j;
409       for (j = i + 1; j &lt; end; j++)
410         if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[j])))
411           break;
412 
413       position_around_base (plan, font, buffer, i, j);
414 
415       i = j - 1;
416     }
417 }
418 
419 void
420 _hb_ot_shape_fallback_position (const hb_ot_shape_plan_t *plan,
421                                 hb_font_t *font,
422                                 hb_buffer_t  *buffer)
423 {
424   _hb_buffer_assert_gsubgpos_vars (buffer);
425 
426   unsigned int start = 0;
427   unsigned int count = buffer-&gt;len;
428   hb_glyph_info_t *info = buffer-&gt;info;
429   for (unsigned int i = 1; i &lt; count; i++)
430     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))) {
431       position_cluster (plan, font, buffer, start, i);
432       start = i;
433     }
434   position_cluster (plan, font, buffer, start, count);
435 }
436 
437 
438 /* Performs old-style TrueType kerning. */
439 void
440 _hb_ot_shape_fallback_kern (const hb_ot_shape_plan_t *plan,
441                             hb_font_t *font,
442                             hb_buffer_t  *buffer)
443 {
444   if (!plan-&gt;has_kern) return;
445 
446   OT::hb_ot_apply_context_t c (1, font, buffer);
447   c.set_lookup_mask (plan-&gt;kern_mask);
448   c.set_lookup_props (OT::LookupFlag::IgnoreMarks);
449   OT::hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c.iter_input;
450   skippy_iter.init (&amp;c);
451 
452   unsigned int count = buffer-&gt;len;
453   hb_glyph_info_t *info = buffer-&gt;info;
454   hb_glyph_position_t *pos = buffer-&gt;pos;
455   for (unsigned int idx = 0; idx &lt; count;)
456   {
457     skippy_iter.reset (idx, 1);
458     if (!skippy_iter.next ())
459     {
460       idx++;
461       continue;
462     }
463 
464     hb_position_t x_kern, y_kern;
465     font-&gt;get_glyph_kerning_for_direction (info[idx].codepoint,
466                                            info[skippy_iter.idx].codepoint,
467                                            buffer-&gt;props.direction,
468                                            &amp;x_kern, &amp;y_kern);
469 
470     if (x_kern)
471     {
472       hb_position_t kern1 = x_kern &gt;&gt; 1;
473       hb_position_t kern2 = x_kern - kern1;
474       pos[idx].x_advance += kern1;
475       pos[skippy_iter.idx].x_advance += kern2;
476       pos[skippy_iter.idx].x_offset += kern2;
477       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);
478     }
479 
480     if (y_kern)
481     {
482       hb_position_t kern1 = y_kern &gt;&gt; 1;
483       hb_position_t kern2 = y_kern - kern1;
484       pos[idx].y_advance += kern1;
485       pos[skippy_iter.idx].y_advance += kern2;
486       pos[skippy_iter.idx].y_offset += kern2;
487       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);
488     }
489 
490     idx = skippy_iter.idx;
491   }
492 }
493 
494 
495 /* Adjusts width of various spaces. */
496 void
497 _hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan,
498                               hb_font_t *font,
499                               hb_buffer_t  *buffer)
500 {
501   if (!HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))
502     return;
503 
504   hb_glyph_info_t *info = buffer-&gt;info;
505   hb_glyph_position_t *pos = buffer-&gt;pos;
506   unsigned int count = buffer-&gt;len;
507   for (unsigned int i = 0; i &lt; count; i++)
508     if (_hb_glyph_info_is_unicode_space (&amp;info[i]) &amp;&amp; !_hb_glyph_info_ligated (&amp;info[i]))
509     {
510       hb_unicode_funcs_t::space_t space_type = _hb_glyph_info_get_unicode_space_fallback_type (&amp;info[i]);
511       hb_codepoint_t glyph;
512       typedef hb_unicode_funcs_t t;
513       switch (space_type)
514       {
515         case t::NOT_SPACE: /* Shouldn&#39;t happen. */
516         case t::SPACE:
517           break;
518 
519         case t::SPACE_EM:
520         case t::SPACE_EM_2:
521         case t::SPACE_EM_3:
522         case t::SPACE_EM_4:
523         case t::SPACE_EM_5:
524         case t::SPACE_EM_6:
525         case t::SPACE_EM_16:
526           pos[i].x_advance = (font-&gt;x_scale + ((int) space_type)/2) / (int) space_type;
527           break;
528 
529         case t::SPACE_4_EM_18:
530           pos[i].x_advance = (int64_t) font-&gt;x_scale * 4 / 18;
531           break;
532 
533         case t::SPACE_FIGURE:
534           for (char u = &#39;0&#39;; u &lt;= &#39;9&#39;; u++)
535             if (font-&gt;get_nominal_glyph (u, &amp;glyph))
536             {
537               pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);
538               break;
539             }
540           break;
541 
542         case t::SPACE_PUNCTUATION:
543           if (font-&gt;get_nominal_glyph (&#39;.&#39;, &amp;glyph))
544             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);
545           else if (font-&gt;get_nominal_glyph (&#39;,&#39;, &amp;glyph))
546             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);
547           break;
548 
549         case t::SPACE_NARROW:
550           /* Half-space?
551            * Unicode doc https://unicode.org/charts/PDF/U2000.pdf says ~1/4 or 1/5 of EM.
552            * However, in my testing, many fonts have their regular space being about that
553            * size.  To me, a percentage of the space width makes more sense.  Half is as
554            * good as any. */
555           pos[i].x_advance /= 2;
556           break;
557       }
558     }
559 }
    </pre>
  </body>
</html>
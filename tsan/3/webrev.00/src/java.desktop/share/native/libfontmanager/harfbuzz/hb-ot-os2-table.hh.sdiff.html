<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-name-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-unicode-ranges.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright © 2011,2012  Google, Inc.

  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_OS2_TABLE_HH
 28 #define HB_OT_OS2_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 #include &quot;hb-ot-os2-unicode-ranges.hh&quot;
<span class="line-removed"> 32 #include &quot;hb-subset-plan.hh&quot;</span>
 33 
<span class="line-modified"> 34 namespace OT {</span>
 35 
 36 /*
 37  * OS/2 and Windows Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/os2
 39  */
<span class="line-modified"> 40 #define HB_OT_TAG_os2 HB_TAG(&#39;O&#39;,&#39;S&#39;,&#39;/&#39;,&#39;2&#39;)</span>



 41 
<span class="line-modified"> 42 struct os2</span>
 43 {
<span class="line-modified"> 44   static const hb_tag_t tableTag = HB_OT_TAG_os2;</span>











 45 
<span class="line-modified"> 46   inline bool sanitize (hb_sanitize_context_t *c) const</span>


 47   {
 48     TRACE_SANITIZE (this);
 49     return_trace (c-&gt;check_struct (this));
 50   }
 51 
<span class="line-modified"> 52   inline bool subset (hb_subset_plan_t *plan) const</span>












 53   {
<span class="line-modified"> 54     hb_blob_t *os2_blob = OT::Sanitizer&lt;OT::os2&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_os2));</span>




































































 55     hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);
 56     // TODO(grieger): move to hb_blob_copy_writable_or_fail
 57     hb_blob_destroy (os2_blob);
 58 
<span class="line-modified"> 59     OT::os2 *os2_prime = (OT::os2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);</span>
 60     if (unlikely (!os2_prime)) {
 61       hb_blob_destroy (os2_prime_blob);
 62       return false;
 63     }
 64 
 65     uint16_t min_cp, max_cp;
 66     find_min_and_max_codepoint (plan-&gt;unicodes, &amp;min_cp, &amp;max_cp);
 67     os2_prime-&gt;usFirstCharIndex.set (min_cp);
 68     os2_prime-&gt;usLastCharIndex.set (max_cp);
 69 
 70     _update_unicode_ranges (plan-&gt;unicodes, os2_prime-&gt;ulUnicodeRange);
<span class="line-modified"> 71     bool result = plan-&gt;add_table (HB_OT_TAG_os2, os2_prime_blob);</span>
 72 
 73     hb_blob_destroy (os2_prime_blob);
 74     return result;
 75   }
 76 
<span class="line-modified"> 77   inline void _update_unicode_ranges (const hb_set_t *codepoints,</span>
<span class="line-modified"> 78                                       HBUINT32 ulUnicodeRange[4]) const</span>
 79   {
 80     for (unsigned int i = 0; i &lt; 4; i++)
 81       ulUnicodeRange[i].set (0);
 82 
 83     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 84     while (codepoints-&gt;next (&amp;cp)) {
<span class="line-modified"> 85       unsigned int bit = hb_get_unicode_range_bit (cp);</span>
 86       if (bit &lt; 128)
 87       {
 88         unsigned int block = bit / 32;
 89         unsigned int bit_in_block = bit % 32;
 90         unsigned int mask = 1 &lt;&lt; bit_in_block;
 91         ulUnicodeRange[block].set (ulUnicodeRange[block] | mask);
 92       }
 93       if (cp &gt;= 0x10000 &amp;&amp; cp &lt;= 0x110000)
 94       {
 95         /* the spec says that bit 57 (&quot;Non Plane 0&quot;) implies that there&#39;s
 96            at least one codepoint beyond the BMP; so I also include all
 97            the non-BMP codepoints here */
 98         ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 &lt;&lt; 25));
 99       }
100     }
101   }
102 
<span class="line-modified">103   static inline void find_min_and_max_codepoint (const hb_set_t *codepoints,</span>
104                                                  uint16_t *min_cp, /* OUT */
105                                                  uint16_t *max_cp  /* OUT */)
106   {
107     *min_cp = codepoints-&gt;get_min ();
108     *max_cp = codepoints-&gt;get_max ();
109   }
110 
111   enum font_page_t {
112     HEBREW_FONT_PAGE            = 0xB100, // Hebrew Windows 3.1 font page
113     SIMP_ARABIC_FONT_PAGE       = 0xB200, // Simplified Arabic Windows 3.1 font page
114     TRAD_ARABIC_FONT_PAGE       = 0xB300, // Traditional Arabic Windows 3.1 font page
115     OEM_ARABIC_FONT_PAGE        = 0xB400, // OEM Arabic Windows 3.1 font page
116     SIMP_FARSI_FONT_PAGE        = 0xBA00, // Simplified Farsi Windows 3.1 font page
117     TRAD_FARSI_FONT_PAGE        = 0xBB00, // Traditional Farsi Windows 3.1 font page
118     THAI_FONT_PAGE              = 0xDE00  // Thai Windows 3.1 font page
119   };
120 
121   // https://github.com/Microsoft/Font-Validator/blob/520aaae/OTFontFileVal/val_OS2.cs#L644-L681
<span class="line-modified">122   inline font_page_t get_font_page () const</span>



123   {
<span class="line-modified">124     if (version != 0)</span>
<span class="line-modified">125       return (font_page_t) 0;</span>
<span class="line-modified">126     return (font_page_t) (fsSelection &amp; 0xFF00);</span>



127   }
128 
129   public:
130   HBUINT16      version;
<span class="line-removed">131 </span>
<span class="line-removed">132   /* Version 0 */</span>
133   HBINT16       xAvgCharWidth;
134   HBUINT16      usWeightClass;
135   HBUINT16      usWidthClass;
136   HBUINT16      fsType;
137   HBINT16       ySubscriptXSize;
138   HBINT16       ySubscriptYSize;
139   HBINT16       ySubscriptXOffset;
140   HBINT16       ySubscriptYOffset;
141   HBINT16       ySuperscriptXSize;
142   HBINT16       ySuperscriptYSize;
143   HBINT16       ySuperscriptXOffset;
144   HBINT16       ySuperscriptYOffset;
145   HBINT16       yStrikeoutSize;
146   HBINT16       yStrikeoutPosition;
147   HBINT16       sFamilyClass;
148   HBUINT8       panose[10];
149   HBUINT32      ulUnicodeRange[4];
150   Tag           achVendID;
151   HBUINT16      fsSelection;
152   HBUINT16      usFirstCharIndex;
153   HBUINT16      usLastCharIndex;
154   HBINT16       sTypoAscender;
155   HBINT16       sTypoDescender;
156   HBINT16       sTypoLineGap;
157   HBUINT16      usWinAscent;
158   HBUINT16      usWinDescent;
<span class="line-modified">159 </span>
<span class="line-modified">160   /* Version 1 */</span>
<span class="line-modified">161   //HBUINT32    ulCodePageRange1;</span>
<span class="line-removed">162   //HBUINT32    ulCodePageRange2;</span>
<span class="line-removed">163 </span>
<span class="line-removed">164   /* Version 2 */</span>
<span class="line-removed">165   //HBINT16     sxHeight;</span>
<span class="line-removed">166   //HBINT16     sCapHeight;</span>
<span class="line-removed">167   //HBUINT16    usDefaultChar;</span>
<span class="line-removed">168   //HBUINT16    usBreakChar;</span>
<span class="line-removed">169   //HBUINT16    usMaxContext;</span>
<span class="line-removed">170 </span>
<span class="line-removed">171   /* Version 5 */</span>
<span class="line-removed">172   //HBUINT16    usLowerOpticalPointSize;</span>
<span class="line-removed">173   //HBUINT16    usUpperOpticalPointSize;</span>
<span class="line-removed">174 </span>
175   public:
<span class="line-modified">176   DEFINE_SIZE_STATIC (78);</span>
177 };
178 
179 } /* namespace OT */
180 
181 
182 #endif /* HB_OT_OS2_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright © 2011,2012  Google, Inc.
<span class="line-added">  3  * Copyright © 2018  Ebrahim Byagowi</span>
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Google Author(s): Behdad Esfahbod
 26  */
 27 
 28 #ifndef HB_OT_OS2_TABLE_HH
 29 #define HB_OT_OS2_TABLE_HH
 30 
<span class="line-modified"> 31 #include &quot;hb-open-type.hh&quot;</span>
 32 #include &quot;hb-ot-os2-unicode-ranges.hh&quot;

 33 
<span class="line-modified"> 34 #include &quot;hb-set.hh&quot;</span>
 35 
 36 /*
 37  * OS/2 and Windows Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/os2
 39  */
<span class="line-modified"> 40 #define HB_OT_TAG_OS2 HB_TAG(&#39;O&#39;,&#39;S&#39;,&#39;/&#39;,&#39;2&#39;)</span>
<span class="line-added"> 41 </span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 namespace OT {</span>
 44 
<span class="line-modified"> 45 struct OS2V1Tail</span>
 46 {
<span class="line-modified"> 47   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added"> 48   {</span>
<span class="line-added"> 49     TRACE_SANITIZE (this);</span>
<span class="line-added"> 50     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added"> 51   }</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53   public:</span>
<span class="line-added"> 54   HBUINT32      ulCodePageRange1;</span>
<span class="line-added"> 55   HBUINT32      ulCodePageRange2;</span>
<span class="line-added"> 56   public:</span>
<span class="line-added"> 57   DEFINE_SIZE_STATIC (8);</span>
<span class="line-added"> 58 };</span>
 59 
<span class="line-modified"> 60 struct OS2V2Tail</span>
<span class="line-added"> 61 {</span>
<span class="line-added"> 62   bool sanitize (hb_sanitize_context_t *c) const</span>
 63   {
 64     TRACE_SANITIZE (this);
 65     return_trace (c-&gt;check_struct (this));
 66   }
 67 
<span class="line-modified"> 68   public:</span>
<span class="line-added"> 69   HBINT16       sxHeight;</span>
<span class="line-added"> 70   HBINT16       sCapHeight;</span>
<span class="line-added"> 71   HBUINT16      usDefaultChar;</span>
<span class="line-added"> 72   HBUINT16      usBreakChar;</span>
<span class="line-added"> 73   HBUINT16      usMaxContext;</span>
<span class="line-added"> 74   public:</span>
<span class="line-added"> 75   DEFINE_SIZE_STATIC (10);</span>
<span class="line-added"> 76 };</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78 struct OS2V5Tail</span>
<span class="line-added"> 79 {</span>
<span class="line-added"> 80   bool sanitize (hb_sanitize_context_t *c) const</span>
 81   {
<span class="line-modified"> 82     TRACE_SANITIZE (this);</span>
<span class="line-added"> 83     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added"> 84   }</span>
<span class="line-added"> 85 </span>
<span class="line-added"> 86   public:</span>
<span class="line-added"> 87   HBUINT16      usLowerOpticalPointSize;</span>
<span class="line-added"> 88   HBUINT16      usUpperOpticalPointSize;</span>
<span class="line-added"> 89   public:</span>
<span class="line-added"> 90   DEFINE_SIZE_STATIC (4);</span>
<span class="line-added"> 91 };</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93 struct OS2</span>
<span class="line-added"> 94 {</span>
<span class="line-added"> 95   static constexpr hb_tag_t tableTag = HB_OT_TAG_OS2;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97   bool has_data () const { return this != &amp;Null (OS2); }</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99   const OS2V1Tail &amp;v1 () const { return version &gt;= 1 ? v1X : Null (OS2V1Tail); }</span>
<span class="line-added">100   const OS2V2Tail &amp;v2 () const { return version &gt;= 2 ? v2X : Null (OS2V2Tail); }</span>
<span class="line-added">101   const OS2V5Tail &amp;v5 () const { return version &gt;= 5 ? v5X : Null (OS2V5Tail); }</span>
<span class="line-added">102 </span>
<span class="line-added">103   enum selection_flag_t {</span>
<span class="line-added">104     ITALIC              = 1u&lt;&lt;0,</span>
<span class="line-added">105     UNDERSCORE          = 1u&lt;&lt;1,</span>
<span class="line-added">106     NEGATIVE            = 1u&lt;&lt;2,</span>
<span class="line-added">107     OUTLINED            = 1u&lt;&lt;3,</span>
<span class="line-added">108     STRIKEOUT           = 1u&lt;&lt;4,</span>
<span class="line-added">109     BOLD                = 1u&lt;&lt;5,</span>
<span class="line-added">110     REGULAR             = 1u&lt;&lt;6,</span>
<span class="line-added">111     USE_TYPO_METRICS    = 1u&lt;&lt;7,</span>
<span class="line-added">112     WWS                 = 1u&lt;&lt;8,</span>
<span class="line-added">113     OBLIQUE             = 1u&lt;&lt;9</span>
<span class="line-added">114   };</span>
<span class="line-added">115 </span>
<span class="line-added">116   bool is_italic () const       { return fsSelection &amp; ITALIC; }</span>
<span class="line-added">117   bool is_oblique () const      { return fsSelection &amp; OBLIQUE; }</span>
<span class="line-added">118   bool is_typo_metrics () const { return fsSelection &amp; USE_TYPO_METRICS; }</span>
<span class="line-added">119 </span>
<span class="line-added">120   enum width_class_t {</span>
<span class="line-added">121     FWIDTH_ULTRA_CONDENSED      = 1, /* 50% */</span>
<span class="line-added">122     FWIDTH_EXTRA_CONDENSED      = 2, /* 62.5% */</span>
<span class="line-added">123     FWIDTH_CONDENSED            = 3, /* 75% */</span>
<span class="line-added">124     FWIDTH_SEMI_CONDENSED       = 4, /* 87.5% */</span>
<span class="line-added">125     FWIDTH_NORMAL               = 5, /* 100% */</span>
<span class="line-added">126     FWIDTH_SEMI_EXPANDED        = 6, /* 112.5% */</span>
<span class="line-added">127     FWIDTH_EXPANDED             = 7, /* 125% */</span>
<span class="line-added">128     FWIDTH_EXTRA_EXPANDED       = 8, /* 150% */</span>
<span class="line-added">129     FWIDTH_ULTRA_EXPANDED       = 9  /* 200% */</span>
<span class="line-added">130   };</span>
<span class="line-added">131 </span>
<span class="line-added">132   float get_width () const</span>
<span class="line-added">133   {</span>
<span class="line-added">134     switch (usWidthClass) {</span>
<span class="line-added">135     case FWIDTH_ULTRA_CONDENSED:return 50.f;</span>
<span class="line-added">136     case FWIDTH_EXTRA_CONDENSED:return 62.5f;</span>
<span class="line-added">137     case FWIDTH_CONDENSED:      return 75.f;</span>
<span class="line-added">138     case FWIDTH_SEMI_CONDENSED: return 87.5f;</span>
<span class="line-added">139     default:</span>
<span class="line-added">140     case FWIDTH_NORMAL:         return 100.f;</span>
<span class="line-added">141     case FWIDTH_SEMI_EXPANDED:  return 112.5f;</span>
<span class="line-added">142     case FWIDTH_EXPANDED:       return 125.f;</span>
<span class="line-added">143     case FWIDTH_EXTRA_EXPANDED: return 150.f;</span>
<span class="line-added">144     case FWIDTH_ULTRA_EXPANDED: return 200.f;</span>
<span class="line-added">145     }</span>
<span class="line-added">146   }</span>
<span class="line-added">147 </span>
<span class="line-added">148   bool subset (hb_subset_plan_t *plan) const</span>
<span class="line-added">149   {</span>
<span class="line-added">150     hb_blob_t *os2_blob = hb_sanitize_context_t ().reference_table&lt;OS2&gt; (plan-&gt;source);</span>
151     hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);
152     // TODO(grieger): move to hb_blob_copy_writable_or_fail
153     hb_blob_destroy (os2_blob);
154 
<span class="line-modified">155     OS2 *os2_prime = (OS2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);</span>
156     if (unlikely (!os2_prime)) {
157       hb_blob_destroy (os2_prime_blob);
158       return false;
159     }
160 
161     uint16_t min_cp, max_cp;
162     find_min_and_max_codepoint (plan-&gt;unicodes, &amp;min_cp, &amp;max_cp);
163     os2_prime-&gt;usFirstCharIndex.set (min_cp);
164     os2_prime-&gt;usLastCharIndex.set (max_cp);
165 
166     _update_unicode_ranges (plan-&gt;unicodes, os2_prime-&gt;ulUnicodeRange);
<span class="line-modified">167     bool result = plan-&gt;add_table (HB_OT_TAG_OS2, os2_prime_blob);</span>
168 
169     hb_blob_destroy (os2_prime_blob);
170     return result;
171   }
172 
<span class="line-modified">173   void _update_unicode_ranges (const hb_set_t *codepoints,</span>
<span class="line-modified">174                                HBUINT32 ulUnicodeRange[4]) const</span>
175   {
176     for (unsigned int i = 0; i &lt; 4; i++)
177       ulUnicodeRange[i].set (0);
178 
179     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
180     while (codepoints-&gt;next (&amp;cp)) {
<span class="line-modified">181       unsigned int bit = _hb_ot_os2_get_unicode_range_bit (cp);</span>
182       if (bit &lt; 128)
183       {
184         unsigned int block = bit / 32;
185         unsigned int bit_in_block = bit % 32;
186         unsigned int mask = 1 &lt;&lt; bit_in_block;
187         ulUnicodeRange[block].set (ulUnicodeRange[block] | mask);
188       }
189       if (cp &gt;= 0x10000 &amp;&amp; cp &lt;= 0x110000)
190       {
191         /* the spec says that bit 57 (&quot;Non Plane 0&quot;) implies that there&#39;s
192            at least one codepoint beyond the BMP; so I also include all
193            the non-BMP codepoints here */
194         ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 &lt;&lt; 25));
195       }
196     }
197   }
198 
<span class="line-modified">199   static void find_min_and_max_codepoint (const hb_set_t *codepoints,</span>
200                                                  uint16_t *min_cp, /* OUT */
201                                                  uint16_t *max_cp  /* OUT */)
202   {
203     *min_cp = codepoints-&gt;get_min ();
204     *max_cp = codepoints-&gt;get_max ();
205   }
206 
207   enum font_page_t {
208     HEBREW_FONT_PAGE            = 0xB100, // Hebrew Windows 3.1 font page
209     SIMP_ARABIC_FONT_PAGE       = 0xB200, // Simplified Arabic Windows 3.1 font page
210     TRAD_ARABIC_FONT_PAGE       = 0xB300, // Traditional Arabic Windows 3.1 font page
211     OEM_ARABIC_FONT_PAGE        = 0xB400, // OEM Arabic Windows 3.1 font page
212     SIMP_FARSI_FONT_PAGE        = 0xBA00, // Simplified Farsi Windows 3.1 font page
213     TRAD_FARSI_FONT_PAGE        = 0xBB00, // Traditional Farsi Windows 3.1 font page
214     THAI_FONT_PAGE              = 0xDE00  // Thai Windows 3.1 font page
215   };
216 
217   // https://github.com/Microsoft/Font-Validator/blob/520aaae/OTFontFileVal/val_OS2.cs#L644-L681
<span class="line-modified">218   font_page_t get_font_page () const</span>
<span class="line-added">219   { return (font_page_t) (version == 0 ? fsSelection &amp; 0xFF00 : 0); }</span>
<span class="line-added">220 </span>
<span class="line-added">221   bool sanitize (hb_sanitize_context_t *c) const</span>
222   {
<span class="line-modified">223     TRACE_SANITIZE (this);</span>
<span class="line-modified">224     if (unlikely (!c-&gt;check_struct (this))) return_trace (false);</span>
<span class="line-modified">225     if (unlikely (version &gt;= 1 &amp;&amp; !v1X.sanitize (c))) return_trace (false);</span>
<span class="line-added">226     if (unlikely (version &gt;= 2 &amp;&amp; !v2X.sanitize (c))) return_trace (false);</span>
<span class="line-added">227     if (unlikely (version &gt;= 5 &amp;&amp; !v5X.sanitize (c))) return_trace (false);</span>
<span class="line-added">228     return_trace (true);</span>
229   }
230 
231   public:
232   HBUINT16      version;


233   HBINT16       xAvgCharWidth;
234   HBUINT16      usWeightClass;
235   HBUINT16      usWidthClass;
236   HBUINT16      fsType;
237   HBINT16       ySubscriptXSize;
238   HBINT16       ySubscriptYSize;
239   HBINT16       ySubscriptXOffset;
240   HBINT16       ySubscriptYOffset;
241   HBINT16       ySuperscriptXSize;
242   HBINT16       ySuperscriptYSize;
243   HBINT16       ySuperscriptXOffset;
244   HBINT16       ySuperscriptYOffset;
245   HBINT16       yStrikeoutSize;
246   HBINT16       yStrikeoutPosition;
247   HBINT16       sFamilyClass;
248   HBUINT8       panose[10];
249   HBUINT32      ulUnicodeRange[4];
250   Tag           achVendID;
251   HBUINT16      fsSelection;
252   HBUINT16      usFirstCharIndex;
253   HBUINT16      usLastCharIndex;
254   HBINT16       sTypoAscender;
255   HBINT16       sTypoDescender;
256   HBINT16       sTypoLineGap;
257   HBUINT16      usWinAscent;
258   HBUINT16      usWinDescent;
<span class="line-modified">259   OS2V1Tail     v1X;</span>
<span class="line-modified">260   OS2V2Tail     v2X;</span>
<span class="line-modified">261   OS2V5Tail     v5X;</span>













262   public:
<span class="line-modified">263   DEFINE_SIZE_MIN (78);</span>
264 };
265 
266 } /* namespace OT */
267 
268 
269 #endif /* HB_OT_OS2_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-name-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-unicode-ranges.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
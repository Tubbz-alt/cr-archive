<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-fvar-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-var-avar-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-var-hvar-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-fvar-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_VAR_FVAR_TABLE_HH
 28 #define HB_OT_VAR_FVAR_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 
 32 /*
 33  * fvar -- Font Variations
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/fvar
 35  */
 36 
 37 #define HB_OT_TAG_fvar HB_TAG(&#39;f&#39;,&#39;v&#39;,&#39;a&#39;,&#39;r&#39;)
 38 
 39 
 40 namespace OT {
 41 
 42 
 43 struct InstanceRecord
 44 {
<span class="line-modified"> 45   inline bool sanitize (hb_sanitize_context_t *c, unsigned int axis_count) const</span>





 46   {
 47     TRACE_SANITIZE (this);
 48     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified"> 49                   c-&gt;check_array (coordinates, coordinates[0].static_size, axis_count));</span>
 50   }
 51 
 52   protected:
 53   NameID        subfamilyNameID;/* The name ID for entries in the &#39;name&#39; table
 54                                  * that provide subfamily names for this instance. */
<span class="line-modified"> 55   HBUINT16      reserved;       /* Reserved for future use — set to 0. */</span>
<span class="line-modified"> 56   Fixed         coordinates[VAR];/* The coordinates array for this instance. */</span>

 57   //NameID      postScriptNameIDX;/*Optional. The name ID for entries in the &#39;name&#39;
 58   //                              * table that provide PostScript names for this
 59   //                              * instance. */
 60 
 61   public:
<span class="line-modified"> 62   DEFINE_SIZE_ARRAY (4, coordinates);</span>
 63 };
 64 
 65 struct AxisRecord
 66 {
<span class="line-modified"> 67   inline bool sanitize (hb_sanitize_context_t *c) const</span>





 68   {
 69     TRACE_SANITIZE (this);
 70     return_trace (c-&gt;check_struct (this));
 71   }
 72 
 73   public:
 74   Tag           axisTag;        /* Tag identifying the design variation for the axis. */
 75   Fixed         minValue;       /* The minimum coordinate value for the axis. */
 76   Fixed         defaultValue;   /* The default coordinate value for the axis. */
 77   Fixed         maxValue;       /* The maximum coordinate value for the axis. */
<span class="line-modified"> 78   HBUINT16      reserved;       /* Reserved for future use — set to 0. */</span>
 79   NameID        axisNameID;     /* The name ID for entries in the &#39;name&#39; table that
 80                                  * provide a display name for this axis. */
 81 
 82   public:
 83   DEFINE_SIZE_STATIC (20);
 84 };
 85 
 86 struct fvar
 87 {
<span class="line-modified"> 88   static const hb_tag_t tableTag        = HB_OT_TAG_fvar;</span>
 89 
<span class="line-modified"> 90   inline bool sanitize (hb_sanitize_context_t *c) const</span>


 91   {
 92     TRACE_SANITIZE (this);
 93     return_trace (version.sanitize (c) &amp;&amp;
 94                   likely (version.major == 1) &amp;&amp;
 95                   c-&gt;check_struct (this) &amp;&amp;

 96                   instanceSize &gt;= axisCount * 4 + 4 &amp;&amp;
<span class="line-modified"> 97                   axisSize &lt;= 1024 &amp;&amp; /* Arbitrary, just to simplify overflow checks. */</span>
<span class="line-modified"> 98                   instanceSize &lt;= 1024 &amp;&amp; /* Arbitrary, just to simplify overflow checks. */</span>
<span class="line-removed"> 99                   c-&gt;check_range (this, things) &amp;&amp;</span>
<span class="line-removed">100                   c-&gt;check_range (&amp;StructAtOffset&lt;char&gt; (this, things),</span>
<span class="line-removed">101                                   axisCount * axisSize + instanceCount * instanceSize));</span>
102   }
103 
<span class="line-modified">104   inline unsigned int get_axis_count (void) const</span>
<span class="line-modified">105   { return axisCount; }</span>











106 
<span class="line-modified">107   inline bool get_axis (unsigned int index, hb_ot_var_axis_t *info) const</span>

108   {
<span class="line-modified">109     if (unlikely (index &gt;= axisCount))</span>
<span class="line-modified">110       return false;</span>









111 
<span class="line-modified">112     if (info)</span>




113     {
<span class="line-modified">114       const AxisRecord &amp;axis = get_axes ()[index];</span>
<span class="line-modified">115       info-&gt;tag = axis.axisTag;</span>
<span class="line-modified">116       info-&gt;name_id =  axis.axisNameID;</span>
<span class="line-removed">117       info-&gt;default_value = axis.defaultValue / 65536.;</span>
<span class="line-removed">118       /* Ensure order, to simplify client math. */</span>
<span class="line-removed">119       info-&gt;min_value = MIN&lt;float&gt; (info-&gt;default_value, axis.minValue / 65536.);</span>
<span class="line-removed">120       info-&gt;max_value = MAX&lt;float&gt; (info-&gt;default_value, axis.maxValue / 65536.);</span>
<span class="line-removed">121     }</span>
122 
<span class="line-modified">123     return true;</span>









124   }
125 
<span class="line-modified">126   inline unsigned int get_axis_infos (unsigned int      start_offset,</span>
<span class="line-modified">127                                       unsigned int     *axes_count /* IN/OUT */,</span>
<span class="line-modified">128                                       hb_ot_var_axis_t *axes_array /* OUT */) const</span>
129   {
130     if (axes_count)
131     {

132       unsigned int count = axisCount;
133       start_offset = MIN (start_offset, count);
134 
135       count -= start_offset;
136       axes_array += start_offset;
137 
138       count = MIN (count, *axes_count);
139       *axes_count = count;
140 
141       for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">142         get_axis (start_offset + i, axes_array + i);</span>
143     }
144     return axisCount;
145   }
146 
<span class="line-modified">147   inline bool find_axis (hb_tag_t tag, unsigned int *index, hb_ot_var_axis_t *info) const</span>


148   {
149     const AxisRecord *axes = get_axes ();
150     unsigned int count = get_axis_count ();
151     for (unsigned int i = 0; i &lt; count; i++)
152       if (axes[i].axisTag == tag)
153       {
<span class="line-modified">154         if (index)</span>
<span class="line-modified">155           *index = i;</span>
<span class="line-modified">156         return get_axis (i, info);</span>

157       }
<span class="line-modified">158     if (index)</span>
<span class="line-modified">159       *index = HB_OT_VAR_NO_AXIS_INDEX;</span>
160     return false;
161   }
162 
<span class="line-modified">163   inline int normalize_axis_value (unsigned int axis_index, float v) const</span>

164   {
<span class="line-modified">165     hb_ot_var_axis_t axis;</span>
<span class="line-modified">166     if (!get_axis (axis_index, &amp;axis))</span>
<span class="line-modified">167       return 0;</span>












168 
169     v = MAX (MIN (v, axis.max_value), axis.min_value); /* Clamp. */
170 
171     if (v == axis.default_value)
172       return 0;
173     else if (v &lt; axis.default_value)
174       v = (v - axis.default_value) / (axis.default_value - axis.min_value);
175     else
176       v = (v - axis.default_value) / (axis.max_value - axis.default_value);
<span class="line-modified">177     return (int) (v * 16384. + (v &gt;= 0. ? .5 : -.5));</span>








































178   }
179 
180   protected:
<span class="line-modified">181   inline const AxisRecord * get_axes (void) const</span>
<span class="line-modified">182   { return &amp;StructAtOffset&lt;AxisRecord&gt; (this, things); }</span>
183 
<span class="line-modified">184   inline const InstanceRecord * get_instances (void) const</span>
<span class="line-modified">185   { return &amp;StructAtOffset&lt;InstanceRecord&gt; (get_axes () + axisCount, 0); }</span>




186 
187   protected:
188   FixedVersion&lt;&gt;version;        /* Version of the fvar table
189                                  * initially set to 0x00010000u */
<span class="line-modified">190   Offset16      things;         /* Offset in bytes from the beginning of the table</span>

191                                  * to the start of the AxisRecord array. */
192   HBUINT16      reserved;       /* This field is permanently reserved. Set to 2. */
193   HBUINT16      axisCount;      /* The number of variation axes in the font (the
194                                  * number of records in the axes array). */
195   HBUINT16      axisSize;       /* The size in bytes of each VariationAxisRecord —
196                                  * set to 20 (0x0014) for this version. */
197   HBUINT16      instanceCount;  /* The number of named instances defined in the font
198                                  * (the number of records in the instances array). */
199   HBUINT16      instanceSize;   /* The size in bytes of each InstanceRecord — set
200                                  * to either axisCount * sizeof(Fixed) + 4, or to
201                                  * axisCount * sizeof(Fixed) + 6. */
202 
203   public:
204   DEFINE_SIZE_STATIC (16);
205 };
206 
207 } /* namespace OT */
208 
209 
210 #endif /* HB_OT_VAR_FVAR_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_VAR_FVAR_TABLE_HH
 28 #define HB_OT_VAR_FVAR_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
 31 
 32 /*
 33  * fvar -- Font Variations
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/fvar
 35  */
 36 
 37 #define HB_OT_TAG_fvar HB_TAG(&#39;f&#39;,&#39;v&#39;,&#39;a&#39;,&#39;r&#39;)
 38 
 39 
 40 namespace OT {
 41 
 42 
 43 struct InstanceRecord
 44 {
<span class="line-modified"> 45   friend struct fvar;</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47   hb_array_t&lt;const Fixed&gt; get_coordinates (unsigned int axis_count) const</span>
<span class="line-added"> 48   { return coordinatesZ.as_array (axis_count); }</span>
<span class="line-added"> 49 </span>
<span class="line-added"> 50   bool sanitize (hb_sanitize_context_t *c, unsigned int axis_count) const</span>
 51   {
 52     TRACE_SANITIZE (this);
 53     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified"> 54                   c-&gt;check_array (coordinatesZ.arrayZ, axis_count));</span>
 55   }
 56 
 57   protected:
 58   NameID        subfamilyNameID;/* The name ID for entries in the &#39;name&#39; table
 59                                  * that provide subfamily names for this instance. */
<span class="line-modified"> 60   HBUINT16      flags;          /* Reserved for future use — set to 0. */</span>
<span class="line-modified"> 61   UnsizedArrayOf&lt;Fixed&gt;</span>
<span class="line-added"> 62                 coordinatesZ;   /* The coordinates array for this instance. */</span>
 63   //NameID      postScriptNameIDX;/*Optional. The name ID for entries in the &#39;name&#39;
 64   //                              * table that provide PostScript names for this
 65   //                              * instance. */
 66 
 67   public:
<span class="line-modified"> 68   DEFINE_SIZE_UNBOUNDED (4);</span>
 69 };
 70 
 71 struct AxisRecord
 72 {
<span class="line-modified"> 73   enum</span>
<span class="line-added"> 74   {</span>
<span class="line-added"> 75     AXIS_FLAG_HIDDEN    = 0x0001,</span>
<span class="line-added"> 76   };</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78   bool sanitize (hb_sanitize_context_t *c) const</span>
 79   {
 80     TRACE_SANITIZE (this);
 81     return_trace (c-&gt;check_struct (this));
 82   }
 83 
 84   public:
 85   Tag           axisTag;        /* Tag identifying the design variation for the axis. */
 86   Fixed         minValue;       /* The minimum coordinate value for the axis. */
 87   Fixed         defaultValue;   /* The default coordinate value for the axis. */
 88   Fixed         maxValue;       /* The maximum coordinate value for the axis. */
<span class="line-modified"> 89   HBUINT16      flags;          /* Axis flags. */</span>
 90   NameID        axisNameID;     /* The name ID for entries in the &#39;name&#39; table that
 91                                  * provide a display name for this axis. */
 92 
 93   public:
 94   DEFINE_SIZE_STATIC (20);
 95 };
 96 
 97 struct fvar
 98 {
<span class="line-modified"> 99   static constexpr hb_tag_t tableTag = HB_OT_TAG_fvar;</span>
100 
<span class="line-modified">101   bool has_data () const { return version.to_int (); }</span>
<span class="line-added">102 </span>
<span class="line-added">103   bool sanitize (hb_sanitize_context_t *c) const</span>
104   {
105     TRACE_SANITIZE (this);
106     return_trace (version.sanitize (c) &amp;&amp;
107                   likely (version.major == 1) &amp;&amp;
108                   c-&gt;check_struct (this) &amp;&amp;
<span class="line-added">109                   axisSize == 20 &amp;&amp; /* Assumed in our code. */</span>
110                   instanceSize &gt;= axisCount * 4 + 4 &amp;&amp;
<span class="line-modified">111                   get_axes ().sanitize (c) &amp;&amp;</span>
<span class="line-modified">112                   c-&gt;check_range (get_instance (0), instanceCount, instanceSize));</span>



113   }
114 
<span class="line-modified">115   unsigned int get_axis_count () const { return axisCount; }</span>
<span class="line-modified">116 </span>
<span class="line-added">117   void get_axis_deprecated (unsigned int axis_index,</span>
<span class="line-added">118                                    hb_ot_var_axis_t *info) const</span>
<span class="line-added">119   {</span>
<span class="line-added">120     const AxisRecord &amp;axis = get_axes ()[axis_index];</span>
<span class="line-added">121     info-&gt;tag = axis.axisTag;</span>
<span class="line-added">122     info-&gt;name_id =  axis.axisNameID;</span>
<span class="line-added">123     info-&gt;default_value = axis.defaultValue / 65536.;</span>
<span class="line-added">124     /* Ensure order, to simplify client math. */</span>
<span class="line-added">125     info-&gt;min_value = MIN&lt;float&gt; (info-&gt;default_value, axis.minValue / 65536.);</span>
<span class="line-added">126     info-&gt;max_value = MAX&lt;float&gt; (info-&gt;default_value, axis.maxValue / 65536.);</span>
<span class="line-added">127   }</span>
128 
<span class="line-modified">129   void get_axis_info (unsigned int axis_index,</span>
<span class="line-added">130                       hb_ot_var_axis_info_t *info) const</span>
131   {
<span class="line-modified">132     const AxisRecord &amp;axis = get_axes ()[axis_index];</span>
<span class="line-modified">133     info-&gt;axis_index = axis_index;</span>
<span class="line-added">134     info-&gt;tag = axis.axisTag;</span>
<span class="line-added">135     info-&gt;name_id =  axis.axisNameID;</span>
<span class="line-added">136     info-&gt;flags = (hb_ot_var_axis_flags_t) (unsigned int) axis.flags;</span>
<span class="line-added">137     info-&gt;default_value = axis.defaultValue / 65536.;</span>
<span class="line-added">138     /* Ensure order, to simplify client math. */</span>
<span class="line-added">139     info-&gt;min_value = MIN&lt;float&gt; (info-&gt;default_value, axis.minValue / 65536.);</span>
<span class="line-added">140     info-&gt;max_value = MAX&lt;float&gt; (info-&gt;default_value, axis.maxValue / 65536.);</span>
<span class="line-added">141     info-&gt;reserved = 0;</span>
<span class="line-added">142   }</span>
143 
<span class="line-modified">144   unsigned int get_axes_deprecated (unsigned int      start_offset,</span>
<span class="line-added">145                                     unsigned int     *axes_count /* IN/OUT */,</span>
<span class="line-added">146                                     hb_ot_var_axis_t *axes_array /* OUT */) const</span>
<span class="line-added">147   {</span>
<span class="line-added">148     if (axes_count)</span>
149     {
<span class="line-modified">150       /* TODO Rewrite as hb_array_t&lt;&gt;::sub-array() */</span>
<span class="line-modified">151       unsigned int count = axisCount;</span>
<span class="line-modified">152       start_offset = MIN (start_offset, count);</span>





153 
<span class="line-modified">154       count -= start_offset;</span>
<span class="line-added">155       axes_array += start_offset;</span>
<span class="line-added">156 </span>
<span class="line-added">157       count = MIN (count, *axes_count);</span>
<span class="line-added">158       *axes_count = count;</span>
<span class="line-added">159 </span>
<span class="line-added">160       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">161         get_axis_deprecated (start_offset + i, axes_array + i);</span>
<span class="line-added">162     }</span>
<span class="line-added">163     return axisCount;</span>
164   }
165 
<span class="line-modified">166   unsigned int get_axis_infos (unsigned int           start_offset,</span>
<span class="line-modified">167                                unsigned int          *axes_count /* IN/OUT */,</span>
<span class="line-modified">168                                hb_ot_var_axis_info_t *axes_array /* OUT */) const</span>
169   {
170     if (axes_count)
171     {
<span class="line-added">172       /* TODO Rewrite as hb_array_t&lt;&gt;::sub-array() */</span>
173       unsigned int count = axisCount;
174       start_offset = MIN (start_offset, count);
175 
176       count -= start_offset;
177       axes_array += start_offset;
178 
179       count = MIN (count, *axes_count);
180       *axes_count = count;
181 
182       for (unsigned int i = 0; i &lt; count; i++)
<span class="line-modified">183         get_axis_info (start_offset + i, axes_array + i);</span>
184     }
185     return axisCount;
186   }
187 
<span class="line-modified">188   bool find_axis_deprecated (hb_tag_t tag,</span>
<span class="line-added">189                              unsigned int *axis_index,</span>
<span class="line-added">190                              hb_ot_var_axis_t *info) const</span>
191   {
192     const AxisRecord *axes = get_axes ();
193     unsigned int count = get_axis_count ();
194     for (unsigned int i = 0; i &lt; count; i++)
195       if (axes[i].axisTag == tag)
196       {
<span class="line-modified">197         if (axis_index)</span>
<span class="line-modified">198           *axis_index = i;</span>
<span class="line-modified">199         get_axis_deprecated (i, info);</span>
<span class="line-added">200         return true;</span>
201       }
<span class="line-modified">202     if (axis_index)</span>
<span class="line-modified">203       *axis_index = HB_OT_VAR_NO_AXIS_INDEX;</span>
204     return false;
205   }
206 
<span class="line-modified">207   bool find_axis_info (hb_tag_t tag,</span>
<span class="line-added">208                        hb_ot_var_axis_info_t *info) const</span>
209   {
<span class="line-modified">210     const AxisRecord *axes = get_axes ();</span>
<span class="line-modified">211     unsigned int count = get_axis_count ();</span>
<span class="line-modified">212     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">213       if (axes[i].axisTag == tag)</span>
<span class="line-added">214       {</span>
<span class="line-added">215         get_axis_info (i, info);</span>
<span class="line-added">216         return true;</span>
<span class="line-added">217       }</span>
<span class="line-added">218     return false;</span>
<span class="line-added">219   }</span>
<span class="line-added">220 </span>
<span class="line-added">221   int normalize_axis_value (unsigned int axis_index, float v) const</span>
<span class="line-added">222   {</span>
<span class="line-added">223     hb_ot_var_axis_info_t axis;</span>
<span class="line-added">224     get_axis_info (axis_index, &amp;axis);</span>
225 
226     v = MAX (MIN (v, axis.max_value), axis.min_value); /* Clamp. */
227 
228     if (v == axis.default_value)
229       return 0;
230     else if (v &lt; axis.default_value)
231       v = (v - axis.default_value) / (axis.default_value - axis.min_value);
232     else
233       v = (v - axis.default_value) / (axis.max_value - axis.default_value);
<span class="line-modified">234     return (int) (v * 16384.f + (v &gt;= 0.f ? .5f : -.5f));</span>
<span class="line-added">235   }</span>
<span class="line-added">236 </span>
<span class="line-added">237   unsigned int get_instance_count () const { return instanceCount; }</span>
<span class="line-added">238 </span>
<span class="line-added">239   hb_ot_name_id_t get_instance_subfamily_name_id (unsigned int instance_index) const</span>
<span class="line-added">240   {</span>
<span class="line-added">241     const InstanceRecord *instance = get_instance (instance_index);</span>
<span class="line-added">242     if (unlikely (!instance)) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">243     return instance-&gt;subfamilyNameID;</span>
<span class="line-added">244   }</span>
<span class="line-added">245 </span>
<span class="line-added">246   hb_ot_name_id_t get_instance_postscript_name_id (unsigned int instance_index) const</span>
<span class="line-added">247   {</span>
<span class="line-added">248     const InstanceRecord *instance = get_instance (instance_index);</span>
<span class="line-added">249     if (unlikely (!instance)) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">250     if (instanceSize &gt;= axisCount * 4 + 6)</span>
<span class="line-added">251       return StructAfter&lt;NameID&gt; (instance-&gt;get_coordinates (axisCount));</span>
<span class="line-added">252     return HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">253   }</span>
<span class="line-added">254 </span>
<span class="line-added">255   unsigned int get_instance_coords (unsigned int  instance_index,</span>
<span class="line-added">256                                            unsigned int *coords_length, /* IN/OUT */</span>
<span class="line-added">257                                            float        *coords         /* OUT */) const</span>
<span class="line-added">258   {</span>
<span class="line-added">259     const InstanceRecord *instance = get_instance (instance_index);</span>
<span class="line-added">260     if (unlikely (!instance))</span>
<span class="line-added">261     {</span>
<span class="line-added">262       if (coords_length)</span>
<span class="line-added">263         *coords_length = 0;</span>
<span class="line-added">264       return 0;</span>
<span class="line-added">265     }</span>
<span class="line-added">266 </span>
<span class="line-added">267     if (coords_length &amp;&amp; *coords_length)</span>
<span class="line-added">268     {</span>
<span class="line-added">269       hb_array_t&lt;const Fixed&gt; instanceCoords = instance-&gt;get_coordinates (axisCount)</span>
<span class="line-added">270                                                          .sub_array (0, *coords_length);</span>
<span class="line-added">271       for (unsigned int i = 0; i &lt; instanceCoords.length; i++)</span>
<span class="line-added">272         coords[i] = instanceCoords.arrayZ[i].to_float ();</span>
<span class="line-added">273     }</span>
<span class="line-added">274     return axisCount;</span>
275   }
276 
277   protected:
<span class="line-modified">278   hb_array_t&lt;const AxisRecord&gt; get_axes () const</span>
<span class="line-modified">279   { return hb_array (&amp;(this+firstAxis), axisCount); }</span>
280 
<span class="line-modified">281   const InstanceRecord *get_instance (unsigned int i) const</span>
<span class="line-modified">282   {</span>
<span class="line-added">283     if (unlikely (i &gt;= instanceCount)) return nullptr;</span>
<span class="line-added">284    return &amp;StructAtOffset&lt;InstanceRecord&gt; (&amp;StructAfter&lt;InstanceRecord&gt; (get_axes ()),</span>
<span class="line-added">285                                            i * instanceSize);</span>
<span class="line-added">286   }</span>
287 
288   protected:
289   FixedVersion&lt;&gt;version;        /* Version of the fvar table
290                                  * initially set to 0x00010000u */
<span class="line-modified">291   OffsetTo&lt;AxisRecord&gt;</span>
<span class="line-added">292                 firstAxis;      /* Offset in bytes from the beginning of the table</span>
293                                  * to the start of the AxisRecord array. */
294   HBUINT16      reserved;       /* This field is permanently reserved. Set to 2. */
295   HBUINT16      axisCount;      /* The number of variation axes in the font (the
296                                  * number of records in the axes array). */
297   HBUINT16      axisSize;       /* The size in bytes of each VariationAxisRecord —
298                                  * set to 20 (0x0014) for this version. */
299   HBUINT16      instanceCount;  /* The number of named instances defined in the font
300                                  * (the number of records in the instances array). */
301   HBUINT16      instanceSize;   /* The size in bytes of each InstanceRecord — set
302                                  * to either axisCount * sizeof(Fixed) + 4, or to
303                                  * axisCount * sizeof(Fixed) + 6. */
304 
305   public:
306   DEFINE_SIZE_STATIC (16);
307 };
308 
309 } /* namespace OT */
310 
311 
312 #endif /* HB_OT_VAR_FVAR_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-var-avar-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-var-hvar-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-post-macroman.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-fallback.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_POST_TABLE_HH
 28 #define HB_OT_POST_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-removed"> 31 #include &quot;hb-dsalgs.hh&quot;</span>
<span class="line-removed"> 32 #include &quot;hb-subset-plan.hh&quot;</span>
 33 
 34 #define HB_STRING_ARRAY_NAME format1_names
 35 #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
 36 #include &quot;hb-string-array.hh&quot;
 37 #undef HB_STRING_ARRAY_LIST
 38 #undef HB_STRING_ARRAY_NAME
 39 
 40 #define NUM_FORMAT1_NAMES 258
 41 
 42 /*
 43  * post -- PostScript
 44  * https://docs.microsoft.com/en-us/typography/opentype/spec/post
 45  */
 46 #define HB_OT_TAG_post HB_TAG(&#39;p&#39;,&#39;o&#39;,&#39;s&#39;,&#39;t&#39;)
 47 
 48 
 49 namespace OT {
 50 
 51 
 52 struct postV2Tail
 53 {
<span class="line-modified"> 54   inline bool sanitize (hb_sanitize_context_t *c) const</span>


 55   {
 56     TRACE_SANITIZE (this);
 57     return_trace (glyphNameIndex.sanitize (c));
 58   }
 59 
<span class="line-modified"> 60   ArrayOf&lt;HBUINT16&gt;glyphNameIndex;      /* This is not an offset, but is the</span>

 61                                          * ordinal number of the glyph in &#39;post&#39;
 62                                          * string tables. */
<span class="line-modified"> 63   HBUINT8               namesX[VAR];            /* Glyph names with length bytes [variable]</span>

 64                                          * (a Pascal string). */
 65 
<span class="line-modified"> 66   DEFINE_SIZE_ARRAY2 (2, glyphNameIndex, namesX);</span>

 67 };
 68 
 69 struct post
 70 {
<span class="line-modified"> 71   static const hb_tag_t tableTag = HB_OT_TAG_post;</span>
<span class="line-removed"> 72 </span>
<span class="line-removed"> 73   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed"> 74   {</span>
<span class="line-removed"> 75     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 76     if (unlikely (!c-&gt;check_struct (this)))</span>
<span class="line-removed"> 77       return_trace (false);</span>
<span class="line-removed"> 78     if (version.to_int () == 0x00020000)</span>
<span class="line-removed"> 79     {</span>
<span class="line-removed"> 80       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*this);</span>
<span class="line-removed"> 81       return_trace (v2.sanitize (c));</span>
<span class="line-removed"> 82     }</span>
<span class="line-removed"> 83     return_trace (true);</span>
<span class="line-removed"> 84   }</span>
 85 
<span class="line-modified"> 86   inline bool subset (hb_subset_plan_t *plan) const</span>
 87   {
 88     unsigned int post_prime_length;
<span class="line-modified"> 89     hb_blob_t *post_blob = OT::Sanitizer&lt;post&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_post));</span>
<span class="line-modified"> 90     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::static_size);</span>
 91     post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
 92     hb_blob_destroy (post_blob);
 93 
<span class="line-modified"> 94     if (unlikely (!post_prime || post_prime_length != post::static_size))</span>
 95     {
 96       hb_blob_destroy (post_prime_blob);
 97       DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
 98       return false;
 99     }
100 
101     post_prime-&gt;version.major.set (3); // Version 3 does not have any glyph names.
102     bool result = plan-&gt;add_table (HB_OT_TAG_post, post_prime_blob);
103     hb_blob_destroy (post_prime_blob);
104 
105     return result;
106   }
107 
108   struct accelerator_t
109   {
<span class="line-modified">110     inline void init (hb_face_t *face)</span>
111     {
112       index_to_offset.init ();
113 
<span class="line-modified">114       blob = Sanitizer&lt;post&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_post));</span>
<span class="line-modified">115       const post *table = blob-&gt;as&lt;post&gt; ();</span>
<span class="line-removed">116       unsigned int table_length = blob-&gt;length;</span>
117 
118       version = table-&gt;version.to_int ();
<span class="line-modified">119       if (version != 0x00020000)</span>
<span class="line-removed">120         return;</span>
121 
<span class="line-modified">122       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*table);</span>
123 
124       glyphNameIndex = &amp;v2.glyphNameIndex;
125       pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
126 
<span class="line-modified">127       const uint8_t *end = (uint8_t *) table + table_length;</span>
<span class="line-modified">128       for (const uint8_t *data = pool; data &lt; end &amp;&amp; data + *data &lt;= end; data += 1 + *data)</span>


129         index_to_offset.push (data - pool);
130     }
<span class="line-modified">131     inline void fini (void)</span>
132     {
133       index_to_offset.fini ();
<span class="line-modified">134       free (gids_sorted_by_name);</span>

135     }
136 
<span class="line-modified">137     inline bool get_glyph_name (hb_codepoint_t glyph,</span>
<span class="line-modified">138                                 char *buf, unsigned int buf_len) const</span>
139     {
140       hb_bytes_t s = find_glyph_name (glyph);
<span class="line-modified">141       if (!s.len)</span>
<span class="line-modified">142         return false;</span>
<span class="line-modified">143       if (!buf_len)</span>
<span class="line-modified">144         return true;</span>
<span class="line-modified">145       if (buf_len &lt;= s.len) /* What to do with truncation? Returning false for now. */</span>
<span class="line-removed">146         return false;</span>
<span class="line-removed">147       strncpy (buf, s.bytes, s.len);</span>
<span class="line-removed">148       buf[s.len] = &#39;\0&#39;;</span>
149       return true;
150     }
151 
<span class="line-modified">152     inline bool get_glyph_from_name (const char *name, int len,</span>
<span class="line-modified">153                                      hb_codepoint_t *glyph) const</span>
154     {
155       unsigned int count = get_glyph_count ();
<span class="line-modified">156       if (unlikely (!count))</span>
<span class="line-removed">157         return false;</span>
158 
<span class="line-modified">159       if (len &lt; 0)</span>
<span class="line-removed">160         len = strlen (name);</span>
161 
<span class="line-modified">162       if (unlikely (!len))</span>
<span class="line-removed">163         return false;</span>
164 
165     retry:
<span class="line-modified">166       uint16_t *gids = (uint16_t *) hb_atomic_ptr_get (&amp;gids_sorted_by_name);</span>
167 
168       if (unlikely (!gids))
169       {
170         gids = (uint16_t *) malloc (count * sizeof (gids[0]));
171         if (unlikely (!gids))
172           return false; /* Anything better?! */
173 
174         for (unsigned int i = 0; i &lt; count; i++)
175           gids[i] = i;
176         hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
177 
<span class="line-modified">178         if (!hb_atomic_ptr_cmpexch (&amp;gids_sorted_by_name, nullptr, gids)) {</span>

179           free (gids);
180           goto retry;
181         }
182       }
183 
184       hb_bytes_t st (name, len);
<span class="line-modified">185       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (&amp;st, gids, count, sizeof (gids[0]), cmp_key, (void *) this);</span>

186       if (gid)
187       {
188         *glyph = *gid;
189         return true;
190       }
191 
192       return false;
193     }
194 
195     protected:
196 
<span class="line-modified">197     inline unsigned int get_glyph_count (void) const</span>
198     {
199       if (version == 0x00010000)
200         return NUM_FORMAT1_NAMES;
201 
202       if (version == 0x00020000)
203         return glyphNameIndex-&gt;len;
204 
205       return 0;
206     }
207 
<span class="line-modified">208     static inline int cmp_gids (const void *pa, const void *pb, void *arg)</span>
209     {
210       const accelerator_t *thiz = (const accelerator_t *) arg;
211       uint16_t a = * (const uint16_t *) pa;
212       uint16_t b = * (const uint16_t *) pb;
213       return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
214     }
215 
<span class="line-modified">216     static inline int cmp_key (const void *pk, const void *po, void *arg)</span>
217     {
218       const accelerator_t *thiz = (const accelerator_t *) arg;
219       const hb_bytes_t *key = (const hb_bytes_t *) pk;
220       uint16_t o = * (const uint16_t *) po;
221       return thiz-&gt;find_glyph_name (o).cmp (*key);
222     }
223 
<span class="line-modified">224     inline hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const</span>
225     {
226       if (version == 0x00010000)
227       {
228         if (glyph &gt;= NUM_FORMAT1_NAMES)
229           return hb_bytes_t ();
230 
231         return format1_names (glyph);
232       }
233 
234       if (version != 0x00020000 || glyph &gt;= glyphNameIndex-&gt;len)
235         return hb_bytes_t ();
236 
237       unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
238       if (index &lt; NUM_FORMAT1_NAMES)
239         return format1_names (index);
240       index -= NUM_FORMAT1_NAMES;
241 
<span class="line-modified">242       if (index &gt;= index_to_offset.len)</span>
243         return hb_bytes_t ();
<span class="line-modified">244       unsigned int offset = index_to_offset.arrayZ[index];</span>
245 
246       const uint8_t *data = pool + offset;
247       unsigned int name_length = *data;
248       data++;
249 
250       return hb_bytes_t ((const char *) data, name_length);
251     }
252 
253     private:
<span class="line-modified">254     hb_blob_t *blob;</span>
255     uint32_t version;
256     const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
<span class="line-modified">257     hb_vector_t&lt;uint32_t, 1&gt; index_to_offset;</span>
258     const uint8_t *pool;
<span class="line-modified">259     mutable uint16_t *gids_sorted_by_name;</span>
260   };
261 









262   public:
263   FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
264                                          * 0x00020000 for version 2.0
265                                          * 0x00025000 for version 2.5 (deprecated)
266                                          * 0x00030000 for version 3.0 */
267   Fixed         italicAngle;            /* Italic angle in counter-clockwise degrees
268                                          * from the vertical. Zero for upright text,
269                                          * negative for text that leans to the right
270                                          * (forward). */
271   FWORD         underlinePosition;      /* This is the suggested distance of the top
272                                          * of the underline from the baseline
273                                          * (negative values indicate below baseline).
274                                          * The PostScript definition of this FontInfo
275                                          * dictionary key (the y coordinate of the
276                                          * center of the stroke) is not used for
277                                          * historical reasons. The value of the
278                                          * PostScript key may be calculated by
279                                          * subtracting half the underlineThickness
280                                          * from the value of this field. */
281   FWORD         underlineThickness;     /* Suggested values for the underline
282                                            thickness. */
283   HBUINT32      isFixedPitch;           /* Set to 0 if the font is proportionally
284                                          * spaced, non-zero if the font is not
285                                          * proportionally spaced (i.e. monospaced). */
286   HBUINT32      minMemType42;           /* Minimum memory usage when an OpenType font
287                                          * is downloaded. */
288   HBUINT32      maxMemType42;           /* Maximum memory usage when an OpenType font
289                                          * is downloaded. */
290   HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
291                                          * is downloaded as a Type 1 font. */
292   HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
293                                          * is downloaded as a Type 1 font. */
<span class="line-modified">294 /*postV2Tail    v2[VAR];*/</span>
<span class="line-modified">295   DEFINE_SIZE_STATIC (32);</span>
296 };
297 


298 } /* namespace OT */
299 
300 
301 #endif /* HB_OT_POST_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_POST_TABLE_HH
 28 #define HB_OT_POST_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>


 31 
 32 #define HB_STRING_ARRAY_NAME format1_names
 33 #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
 34 #include &quot;hb-string-array.hh&quot;
 35 #undef HB_STRING_ARRAY_LIST
 36 #undef HB_STRING_ARRAY_NAME
 37 
 38 #define NUM_FORMAT1_NAMES 258
 39 
 40 /*
 41  * post -- PostScript
 42  * https://docs.microsoft.com/en-us/typography/opentype/spec/post
 43  */
 44 #define HB_OT_TAG_post HB_TAG(&#39;p&#39;,&#39;o&#39;,&#39;s&#39;,&#39;t&#39;)
 45 
 46 
 47 namespace OT {
 48 
 49 
 50 struct postV2Tail
 51 {
<span class="line-modified"> 52   friend struct post;</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54   bool sanitize (hb_sanitize_context_t *c) const</span>
 55   {
 56     TRACE_SANITIZE (this);
 57     return_trace (glyphNameIndex.sanitize (c));
 58   }
 59 
<span class="line-modified"> 60   protected:</span>
<span class="line-added"> 61   ArrayOf&lt;HBUINT16&gt;     glyphNameIndex; /* This is not an offset, but is the</span>
 62                                          * ordinal number of the glyph in &#39;post&#39;
 63                                          * string tables. */
<span class="line-modified"> 64 /*UnsizedArrayOf&lt;HBUINT8&gt;</span>
<span class="line-added"> 65                         namesX;*/       /* Glyph names with length bytes [variable]</span>
 66                                          * (a Pascal string). */
 67 
<span class="line-modified"> 68   public:</span>
<span class="line-added"> 69   DEFINE_SIZE_ARRAY (2, glyphNameIndex);</span>
 70 };
 71 
 72 struct post
 73 {
<span class="line-modified"> 74   static constexpr hb_tag_t tableTag = HB_OT_TAG_post;</span>













 75 
<span class="line-modified"> 76   bool subset (hb_subset_plan_t *plan) const</span>
 77   {
 78     unsigned int post_prime_length;
<span class="line-modified"> 79     hb_blob_t *post_blob = hb_sanitize_context_t ().reference_table&lt;post&gt;(plan-&gt;source);</span>
<span class="line-modified"> 80     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::min_size);</span>
 81     post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
 82     hb_blob_destroy (post_blob);
 83 
<span class="line-modified"> 84     if (unlikely (!post_prime || post_prime_length != post::min_size))</span>
 85     {
 86       hb_blob_destroy (post_prime_blob);
 87       DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
 88       return false;
 89     }
 90 
 91     post_prime-&gt;version.major.set (3); // Version 3 does not have any glyph names.
 92     bool result = plan-&gt;add_table (HB_OT_TAG_post, post_prime_blob);
 93     hb_blob_destroy (post_prime_blob);
 94 
 95     return result;
 96   }
 97 
 98   struct accelerator_t
 99   {
<span class="line-modified">100     void init (hb_face_t *face)</span>
101     {
102       index_to_offset.init ();
103 
<span class="line-modified">104       table = hb_sanitize_context_t ().reference_table&lt;post&gt; (face);</span>
<span class="line-modified">105       unsigned int table_length = table.get_length ();</span>

106 
107       version = table-&gt;version.to_int ();
<span class="line-modified">108       if (version != 0x00020000) return;</span>

109 
<span class="line-modified">110       const postV2Tail &amp;v2 = table-&gt;v2X;</span>
111 
112       glyphNameIndex = &amp;v2.glyphNameIndex;
113       pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
114 
<span class="line-modified">115       const uint8_t *end = (const uint8_t *) (const void *) table + table_length;</span>
<span class="line-modified">116       for (const uint8_t *data = pool;</span>
<span class="line-added">117            index_to_offset.length &lt; 65535 &amp;&amp; data &lt; end &amp;&amp; data + *data &lt; end;</span>
<span class="line-added">118            data += 1 + *data)</span>
119         index_to_offset.push (data - pool);
120     }
<span class="line-modified">121     void fini ()</span>
122     {
123       index_to_offset.fini ();
<span class="line-modified">124       free (gids_sorted_by_name.get ());</span>
<span class="line-added">125       table.destroy ();</span>
126     }
127 
<span class="line-modified">128     bool get_glyph_name (hb_codepoint_t glyph,</span>
<span class="line-modified">129                          char *buf, unsigned int buf_len) const</span>
130     {
131       hb_bytes_t s = find_glyph_name (glyph);
<span class="line-modified">132       if (!s.length) return false;</span>
<span class="line-modified">133       if (!buf_len) return true;</span>
<span class="line-modified">134       unsigned int len = MIN (buf_len - 1, s.length);</span>
<span class="line-modified">135       strncpy (buf, s.arrayZ, len);</span>
<span class="line-modified">136       buf[len] = &#39;\0&#39;;</span>



137       return true;
138     }
139 
<span class="line-modified">140     bool get_glyph_from_name (const char *name, int len,</span>
<span class="line-modified">141                               hb_codepoint_t *glyph) const</span>
142     {
143       unsigned int count = get_glyph_count ();
<span class="line-modified">144       if (unlikely (!count)) return false;</span>

145 
<span class="line-modified">146       if (len &lt; 0) len = strlen (name);</span>

147 
<span class="line-modified">148       if (unlikely (!len)) return false;</span>

149 
150     retry:
<span class="line-modified">151       uint16_t *gids = gids_sorted_by_name.get ();</span>
152 
153       if (unlikely (!gids))
154       {
155         gids = (uint16_t *) malloc (count * sizeof (gids[0]));
156         if (unlikely (!gids))
157           return false; /* Anything better?! */
158 
159         for (unsigned int i = 0; i &lt; count; i++)
160           gids[i] = i;
161         hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
162 
<span class="line-modified">163         if (unlikely (!gids_sorted_by_name.cmpexch (nullptr, gids)))</span>
<span class="line-added">164         {</span>
165           free (gids);
166           goto retry;
167         }
168       }
169 
170       hb_bytes_t st (name, len);
<span class="line-modified">171       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (hb_addressof (st), gids, count,</span>
<span class="line-added">172                                                              sizeof (gids[0]), cmp_key, (void *) this);</span>
173       if (gid)
174       {
175         *glyph = *gid;
176         return true;
177       }
178 
179       return false;
180     }
181 
182     protected:
183 
<span class="line-modified">184     unsigned int get_glyph_count () const</span>
185     {
186       if (version == 0x00010000)
187         return NUM_FORMAT1_NAMES;
188 
189       if (version == 0x00020000)
190         return glyphNameIndex-&gt;len;
191 
192       return 0;
193     }
194 
<span class="line-modified">195     static int cmp_gids (const void *pa, const void *pb, void *arg)</span>
196     {
197       const accelerator_t *thiz = (const accelerator_t *) arg;
198       uint16_t a = * (const uint16_t *) pa;
199       uint16_t b = * (const uint16_t *) pb;
200       return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
201     }
202 
<span class="line-modified">203     static int cmp_key (const void *pk, const void *po, void *arg)</span>
204     {
205       const accelerator_t *thiz = (const accelerator_t *) arg;
206       const hb_bytes_t *key = (const hb_bytes_t *) pk;
207       uint16_t o = * (const uint16_t *) po;
208       return thiz-&gt;find_glyph_name (o).cmp (*key);
209     }
210 
<span class="line-modified">211     hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const</span>
212     {
213       if (version == 0x00010000)
214       {
215         if (glyph &gt;= NUM_FORMAT1_NAMES)
216           return hb_bytes_t ();
217 
218         return format1_names (glyph);
219       }
220 
221       if (version != 0x00020000 || glyph &gt;= glyphNameIndex-&gt;len)
222         return hb_bytes_t ();
223 
224       unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
225       if (index &lt; NUM_FORMAT1_NAMES)
226         return format1_names (index);
227       index -= NUM_FORMAT1_NAMES;
228 
<span class="line-modified">229       if (index &gt;= index_to_offset.length)</span>
230         return hb_bytes_t ();
<span class="line-modified">231       unsigned int offset = index_to_offset[index];</span>
232 
233       const uint8_t *data = pool + offset;
234       unsigned int name_length = *data;
235       data++;
236 
237       return hb_bytes_t ((const char *) data, name_length);
238     }
239 
240     private:
<span class="line-modified">241     hb_blob_ptr_t&lt;post&gt; table;</span>
242     uint32_t version;
243     const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
<span class="line-modified">244     hb_vector_t&lt;uint32_t&gt; index_to_offset;</span>
245     const uint8_t *pool;
<span class="line-modified">246     hb_atomic_ptr_t&lt;uint16_t *&gt; gids_sorted_by_name;</span>
247   };
248 
<span class="line-added">249   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">250   {</span>
<span class="line-added">251     TRACE_SANITIZE (this);</span>
<span class="line-added">252     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">253                           (version.to_int () == 0x00010000 ||</span>
<span class="line-added">254                            (version.to_int () == 0x00020000 &amp;&amp; v2X.sanitize (c)) ||</span>
<span class="line-added">255                            version.to_int () == 0x00030000)));</span>
<span class="line-added">256   }</span>
<span class="line-added">257 </span>
258   public:
259   FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
260                                          * 0x00020000 for version 2.0
261                                          * 0x00025000 for version 2.5 (deprecated)
262                                          * 0x00030000 for version 3.0 */
263   Fixed         italicAngle;            /* Italic angle in counter-clockwise degrees
264                                          * from the vertical. Zero for upright text,
265                                          * negative for text that leans to the right
266                                          * (forward). */
267   FWORD         underlinePosition;      /* This is the suggested distance of the top
268                                          * of the underline from the baseline
269                                          * (negative values indicate below baseline).
270                                          * The PostScript definition of this FontInfo
271                                          * dictionary key (the y coordinate of the
272                                          * center of the stroke) is not used for
273                                          * historical reasons. The value of the
274                                          * PostScript key may be calculated by
275                                          * subtracting half the underlineThickness
276                                          * from the value of this field. */
277   FWORD         underlineThickness;     /* Suggested values for the underline
278                                            thickness. */
279   HBUINT32      isFixedPitch;           /* Set to 0 if the font is proportionally
280                                          * spaced, non-zero if the font is not
281                                          * proportionally spaced (i.e. monospaced). */
282   HBUINT32      minMemType42;           /* Minimum memory usage when an OpenType font
283                                          * is downloaded. */
284   HBUINT32      maxMemType42;           /* Maximum memory usage when an OpenType font
285                                          * is downloaded. */
286   HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
287                                          * is downloaded as a Type 1 font. */
288   HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
289                                          * is downloaded as a Type 1 font. */
<span class="line-modified">290   postV2Tail    v2X;</span>
<span class="line-modified">291   DEFINE_SIZE_MIN (32);</span>
292 };
293 
<span class="line-added">294 struct post_accelerator_t : post::accelerator_t {};</span>
<span class="line-added">295 </span>
296 } /* namespace OT */
297 
298 
299 #endif /* HB_OT_POST_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-post-macroman.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-fallback.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
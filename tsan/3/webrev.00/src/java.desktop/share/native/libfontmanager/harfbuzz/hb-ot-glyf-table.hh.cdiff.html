<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-font.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-head-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,15 ***</span>
   */
  
  #ifndef HB_OT_GLYF_TABLE_HH
  #define HB_OT_GLYF_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
  #include &quot;hb-ot-head-table.hh&quot;
  #include &quot;hb-subset-glyf.hh&quot;
<span class="line-removed">- #include &quot;hb-subset-plan.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-subset-private.hh&quot;</span>
  
  namespace OT {
  
  
  /*
<span class="line-new-header">--- 25,13 ---</span>
   */
  
  #ifndef HB_OT_GLYF_TABLE_HH
  #define HB_OT_GLYF_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
  #include &quot;hb-ot-head-table.hh&quot;
  #include &quot;hb-subset-glyf.hh&quot;
  
  namespace OT {
  
  
  /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 45,21 ***</span>
  
  struct loca
  {
    friend struct glyf;
  
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_loca;</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (true);
    }
  
    protected:
<span class="line-modified">!   HBUINT8               dataZ[VAR];             /* Location data. */</span>
<span class="line-modified">!   DEFINE_SIZE_ARRAY (0, dataZ);</span>
  };
  
  
  /*
   * glyf -- TrueType Glyph Data
<span class="line-new-header">--- 43,24 ---</span>
  
  struct loca
  {
    friend struct glyf;
  
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (true);
    }
  
    protected:
<span class="line-modified">!   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Location data. */</span>
<span class="line-modified">!   public:</span>
<span class="line-added">+   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added">+                         * check the size externally, allow Null() object of it by</span>
<span class="line-added">+                         * defining it MIN() instead. */</span>
  };
  
  
  /*
   * glyf -- TrueType Glyph Data
</pre>
<hr />
<pre>
<span class="line-old-header">*** 68,21 ***</span>
  #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
  
  
  struct glyf
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      /* We don&#39;t check for anything specific here.  The users of the
       * struct do all the hard work... */
      return_trace (true);
    }
  
<span class="line-modified">!   inline bool subset (hb_subset_plan_t *plan) const</span>
    {
      hb_blob_t *glyf_prime = nullptr;
      hb_blob_t *loca_prime = nullptr;
  
      bool success = true;
<span class="line-new-header">--- 69,21 ---</span>
  #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
  
  
  struct glyf
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
    {
      TRACE_SANITIZE (this);
      /* We don&#39;t check for anything specific here.  The users of the
       * struct do all the hard work... */
      return_trace (true);
    }
  
<span class="line-modified">!   bool subset (hb_subset_plan_t *plan) const</span>
    {
      hb_blob_t *glyf_prime = nullptr;
      hb_blob_t *loca_prime = nullptr;
  
      bool success = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 101,18 ***</span>
    }
  
    static bool
    _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
    {
<span class="line-modified">!     hb_blob_t *head_blob = OT::Sanitizer&lt;OT::head&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_head));</span>
      hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
      hb_blob_destroy (head_blob);
  
      if (unlikely (!head_prime_blob))
        return false;
  
<span class="line-modified">!     OT::head *head_prime = (OT::head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
      head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
      bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
  
      hb_blob_destroy (head_prime_blob);
      return success;
<span class="line-new-header">--- 102,18 ---</span>
    }
  
    static bool
    _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
    {
<span class="line-modified">!     hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table&lt;head&gt; (plan-&gt;source);</span>
      hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
      hb_blob_destroy (head_blob);
  
      if (unlikely (!head_prime_blob))
        return false;
  
<span class="line-modified">!     head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
      head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
      bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
  
      hb_blob_destroy (head_prime_blob);
      return success;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,42 ***</span>
        SCALED_COMPONENT_OFFSET =    0x0800,
        UNSCALED_COMPONENT_OFFSET =  0x1000
      };
  
      HBUINT16 flags;
<span class="line-modified">!     HBUINT16 glyphIndex;</span>
  
<span class="line-modified">!     inline unsigned int get_size (void) const</span>
      {
        unsigned int size = min_size;
<span class="line-modified">!       if (flags &amp; ARG_1_AND_2_ARE_WORDS) {</span>
<span class="line-modified">!         // arg1 and 2 are int16</span>
<span class="line-modified">!         size += 4;</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         // arg1 and 2 are int8</span>
<span class="line-modified">!         size += 2;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       if (flags &amp; WE_HAVE_A_SCALE) {</span>
<span class="line-modified">!         // One x 16 bit (scale)</span>
<span class="line-modified">!         size += 2;</span>
<span class="line-modified">!       } else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) {</span>
<span class="line-modified">!         // Two x 16 bit (xscale, yscale)</span>
<span class="line-removed">-         size += 4;</span>
<span class="line-removed">-       } else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) {</span>
<span class="line-removed">-         // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-removed">-         size += 8;</span>
<span class="line-removed">-       }</span>
        return size;
      }
  
      struct Iterator
      {
        const char *glyph_start;
        const char *glyph_end;
        const CompositeGlyphHeader *current;
  
<span class="line-modified">!       inline bool move_to_next ()</span>
        {
          if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
          {
            const CompositeGlyphHeader *possible =
              &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
<span class="line-new-header">--- 149,37 ---</span>
        SCALED_COMPONENT_OFFSET =    0x0800,
        UNSCALED_COMPONENT_OFFSET =  0x1000
      };
  
      HBUINT16 flags;
<span class="line-modified">!     GlyphID  glyphIndex;</span>
  
<span class="line-modified">!     unsigned int get_size () const</span>
      {
        unsigned int size = min_size;
<span class="line-modified">!       // arg1 and 2 are int16</span>
<span class="line-modified">!       if (flags &amp; ARG_1_AND_2_ARE_WORDS) size += 4;</span>
<span class="line-modified">!       // arg1 and 2 are int8</span>
<span class="line-modified">!       else size += 2;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       // One x 16 bit (scale)</span>
<span class="line-modified">!       if (flags &amp; WE_HAVE_A_SCALE) size += 2;</span>
<span class="line-modified">!       // Two x 16 bit (xscale, yscale)</span>
<span class="line-modified">!       else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) size += 4;</span>
<span class="line-modified">!       // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-modified">!       else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) size += 8;</span>
<span class="line-modified">! </span>
        return size;
      }
  
      struct Iterator
      {
        const char *glyph_start;
        const char *glyph_end;
        const CompositeGlyphHeader *current;
  
<span class="line-modified">!       bool move_to_next ()</span>
        {
          if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
          {
            const CompositeGlyphHeader *possible =
              &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 193,21 ***</span>
            return true;
          }
          return false;
        }
  
<span class="line-modified">!       inline bool in_range (const CompositeGlyphHeader *composite) const</span>
        {
          return (const char *) composite &gt;= glyph_start
            &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<span class="line-modified">!           &amp;&amp; ((const char *) composite + composite-&gt;get_size()) &lt;= glyph_end;</span>
        }
      };
  
<span class="line-modified">!     static inline bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">!                                      unsigned int length,</span>
<span class="line-modified">!                                      CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
      {
        if (length &lt; GlyphHeader::static_size)
          return false; /* Empty glyph; zero extents. */
  
        const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
<span class="line-new-header">--- 189,21 ---</span>
            return true;
          }
          return false;
        }
  
<span class="line-modified">!       bool in_range (const CompositeGlyphHeader *composite) const</span>
        {
          return (const char *) composite &gt;= glyph_start
            &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<span class="line-modified">!           &amp;&amp; ((const char *) composite + composite-&gt;get_size ()) &lt;= glyph_end;</span>
        }
      };
  
<span class="line-modified">!     static bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">!                               unsigned int length,</span>
<span class="line-modified">!                               CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
      {
        if (length &lt; GlyphHeader::static_size)
          return false; /* Empty glyph; zero extents. */
  
        const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,74 ***</span>
      DEFINE_SIZE_MIN (4);
    };
  
    struct accelerator_t
    {
<span class="line-modified">!     inline void init (hb_face_t *face)</span>
      {
        memset (this, 0, sizeof (accelerator_t));
  
<span class="line-modified">!       hb_blob_t *head_blob = Sanitizer&lt;head&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_head));</span>
<span class="line-modified">!       const head *head_table = head_blob-&gt;as&lt;head&gt; ();</span>
<span class="line-modified">!       if (head_table == &amp;Null(head) || (unsigned int) head_table-&gt;indexToLocFormat &gt; 1 || head_table-&gt;glyphDataFormat != 0)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         /* head table is not present, or in an unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>
<span class="line-removed">-         hb_blob_destroy (head_blob);</span>
          return;
<span class="line-modified">!       }</span>
<span class="line-removed">-       short_offset = 0 == head_table-&gt;indexToLocFormat;</span>
<span class="line-removed">-       hb_blob_destroy (head_blob);</span>
  
<span class="line-modified">!       loca_blob = Sanitizer&lt;loca&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_loca));</span>
<span class="line-modified">!       loca_table = loca_blob-&gt;as&lt;loca&gt; ();</span>
<span class="line-removed">-       glyf_blob = Sanitizer&lt;glyf&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_glyf));</span>
<span class="line-removed">-       glyf_table = glyf_blob-&gt;as&lt;glyf&gt; ();</span>
  
<span class="line-modified">!       num_glyphs = MAX (1u, hb_blob_get_length (loca_blob) / (short_offset ? 2 : 4)) - 1;</span>
<span class="line-removed">-       glyf_len = hb_blob_get_length (glyf_blob);</span>
      }
  
<span class="line-modified">!     inline void fini (void)</span>
      {
<span class="line-modified">!       hb_blob_destroy (loca_blob);</span>
<span class="line-modified">!       hb_blob_destroy (glyf_blob);</span>
      }
  
      /*
       * Returns true if the referenced glyph is a valid glyph and a composite glyph.
       * If true is returned a pointer to the composite glyph will be written into
       * composite.
       */
<span class="line-modified">!     inline bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">!                                CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
      {
<span class="line-modified">!       if (this-&gt;glyf_table == &amp;Null(glyf) || !num_glyphs)</span>
          return false;
  
        unsigned int start_offset, end_offset;
        if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
          return false; /* glyph not found */
  
<span class="line-modified">!       return CompositeGlyphHeader::get_iterator ((const char*) this-&gt;glyf_table + start_offset,</span>
                                                   end_offset - start_offset,
                                                   composite);
      }
  
      enum simple_glyph_flag_t {
        FLAG_X_SHORT = 0x02,
        FLAG_Y_SHORT = 0x04,
        FLAG_REPEAT = 0x08,
        FLAG_X_SAME = 0x10,
<span class="line-modified">!       FLAG_Y_SAME = 0x20</span>
      };
  
      /* based on FontTools _g_l_y_f.py::trim */
<span class="line-modified">!     inline bool remove_padding(unsigned int start_offset,</span>
<span class="line-modified">!                                unsigned int *end_offset) const</span>
      {
<span class="line-modified">!       if (*end_offset - start_offset &lt; GlyphHeader::static_size)</span>
<span class="line-removed">-         return true;</span>
  
        const char *glyph = ((const char *) glyf_table) + start_offset;
        const char * const glyph_end = glyph + (*end_offset - start_offset);
        const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
        int16_t num_contours = (int16_t) glyph_header.numberOfContours;
<span class="line-new-header">--- 226,68 ---</span>
      DEFINE_SIZE_MIN (4);
    };
  
    struct accelerator_t
    {
<span class="line-modified">!     void init (hb_face_t *face)</span>
      {
        memset (this, 0, sizeof (accelerator_t));
  
<span class="line-modified">!       const OT::head &amp;head = *face-&gt;table.head;</span>
<span class="line-modified">!       if (head.indexToLocFormat &gt; 1 || head.glyphDataFormat != 0)</span>
<span class="line-modified">!         /* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>
          return;
<span class="line-modified">!       short_offset = 0 == head.indexToLocFormat;</span>
  
<span class="line-modified">!       loca_table = hb_sanitize_context_t ().reference_table&lt;loca&gt; (face);</span>
<span class="line-modified">!       glyf_table = hb_sanitize_context_t ().reference_table&lt;glyf&gt; (face);</span>
  
<span class="line-modified">!       num_glyphs = MAX (1u, loca_table.get_length () / (short_offset ? 2 : 4)) - 1;</span>
      }
  
<span class="line-modified">!     void fini ()</span>
      {
<span class="line-modified">!       loca_table.destroy ();</span>
<span class="line-modified">!       glyf_table.destroy ();</span>
      }
  
      /*
       * Returns true if the referenced glyph is a valid glyph and a composite glyph.
       * If true is returned a pointer to the composite glyph will be written into
       * composite.
       */
<span class="line-modified">!     bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">!                         CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
      {
<span class="line-modified">!       if (unlikely (!num_glyphs))</span>
          return false;
  
        unsigned int start_offset, end_offset;
        if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
          return false; /* glyph not found */
  
<span class="line-modified">!       return CompositeGlyphHeader::get_iterator ((const char *) this-&gt;glyf_table + start_offset,</span>
                                                   end_offset - start_offset,
                                                   composite);
      }
  
      enum simple_glyph_flag_t {
<span class="line-added">+       FLAG_ON_CURVE = 0x01,</span>
        FLAG_X_SHORT = 0x02,
        FLAG_Y_SHORT = 0x04,
        FLAG_REPEAT = 0x08,
        FLAG_X_SAME = 0x10,
<span class="line-modified">!       FLAG_Y_SAME = 0x20,</span>
<span class="line-added">+       FLAG_RESERVED1 = 0x40,</span>
<span class="line-added">+       FLAG_RESERVED2 = 0x80</span>
      };
  
      /* based on FontTools _g_l_y_f.py::trim */
<span class="line-modified">!     bool remove_padding (unsigned int start_offset,</span>
<span class="line-modified">!                                 unsigned int *end_offset) const</span>
      {
<span class="line-modified">!       if (*end_offset - start_offset &lt; GlyphHeader::static_size) return true;</span>
  
        const char *glyph = ((const char *) glyf_table) + start_offset;
        const char * const glyph_end = glyph + (*end_offset - start_offset);
        const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
        int16_t num_contours = (int16_t) glyph_header.numberOfContours;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,12 ***</span>
        {
          /* simple glyph w/contours, possibly trimmable */
          glyph += GlyphHeader::static_size + 2 * num_contours;
  
          if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<span class="line-modified">!         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph - 2, 0) + 1;</span>
<span class="line-modified">!         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph, 0);</span>
  
          glyph += 2 + nInstructions;
          if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
  
          unsigned int coordBytes = 0;
<span class="line-new-header">--- 300,12 ---</span>
        {
          /* simple glyph w/contours, possibly trimmable */
          glyph += GlyphHeader::static_size + 2 * num_contours;
  
          if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<span class="line-modified">!         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph - 2, 0) + 1;</span>
<span class="line-modified">!         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph, 0);</span>
  
          glyph += 2 + nInstructions;
          if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
  
          unsigned int coordBytes = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 337,19 ***</span>
              glyph++;
            }
  
            unsigned int xBytes, yBytes;
            xBytes = yBytes = 0;
<span class="line-modified">!           if (flag &amp; FLAG_X_SHORT)</span>
<span class="line-modified">!             xBytes = 1;</span>
<span class="line-removed">-           else if ((flag &amp; FLAG_X_SAME) == 0)</span>
<span class="line-removed">-             xBytes = 2;</span>
  
<span class="line-modified">!           if (flag &amp; FLAG_Y_SHORT)</span>
<span class="line-modified">!             yBytes = 1;</span>
<span class="line-removed">-           else if ((flag &amp; FLAG_Y_SAME) == 0)</span>
<span class="line-removed">-             yBytes = 2;</span>
  
            coordBytes += (xBytes + yBytes) * repeat;
            coordsWithFlags += repeat;
            if (coordsWithFlags &gt;= nCoordinates)
              break;
<span class="line-new-header">--- 327,15 ---</span>
              glyph++;
            }
  
            unsigned int xBytes, yBytes;
            xBytes = yBytes = 0;
<span class="line-modified">!           if (flag &amp; FLAG_X_SHORT) xBytes = 1;</span>
<span class="line-modified">!           else if ((flag &amp; FLAG_X_SAME) == 0) xBytes = 2;</span>
  
<span class="line-modified">!           if (flag &amp; FLAG_Y_SHORT) yBytes = 1;</span>
<span class="line-modified">!           else if ((flag &amp; FLAG_Y_SAME) == 0) yBytes = 2;</span>
  
            coordBytes += (xBytes + yBytes) * repeat;
            coordsWithFlags += repeat;
            if (coordsWithFlags &gt;= nCoordinates)
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 366,41 ***</span>
            *end_offset -= glyph_end - glyph;
        }
        return true;
      }
  
<span class="line-modified">!     inline bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">!                              unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">!                              unsigned int   *end_offset   /* OUT */) const</span>
      {
        if (unlikely (glyph &gt;= num_glyphs))
          return false;
  
        if (short_offset)
        {
<span class="line-modified">!         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ;</span>
          *start_offset = 2 * offsets[glyph];
          *end_offset   = 2 * offsets[glyph + 1];
        }
        else
        {
<span class="line-modified">!         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ;</span>
  
          *start_offset = offsets[glyph];
          *end_offset   = offsets[glyph + 1];
        }
  
<span class="line-modified">!       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_len)</span>
          return false;
  
        return true;
      }
  
<span class="line-modified">!     inline bool get_instruction_offsets(unsigned int start_offset,</span>
<span class="line-modified">!                                         unsigned int end_offset,</span>
<span class="line-modified">!                                         unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">!                                         unsigned int *instruction_end /* OUT */) const</span>
      {
        if (end_offset - start_offset &lt; GlyphHeader::static_size)
        {
          *instruction_start = 0;
          *instruction_end = 0;
<span class="line-new-header">--- 352,41 ---</span>
            *end_offset -= glyph_end - glyph;
        }
        return true;
      }
  
<span class="line-modified">!     bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">!                       unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">!                       unsigned int   *end_offset   /* OUT */) const</span>
      {
        if (unlikely (glyph &gt;= num_glyphs))
          return false;
  
        if (short_offset)
        {
<span class="line-modified">!         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ.arrayZ;</span>
          *start_offset = 2 * offsets[glyph];
          *end_offset   = 2 * offsets[glyph + 1];
        }
        else
        {
<span class="line-modified">!         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ.arrayZ;</span>
  
          *start_offset = offsets[glyph];
          *end_offset   = offsets[glyph + 1];
        }
  
<span class="line-modified">!       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_table.get_length ())</span>
          return false;
  
        return true;
      }
  
<span class="line-modified">!     bool get_instruction_offsets (unsigned int start_offset,</span>
<span class="line-modified">!                                   unsigned int end_offset,</span>
<span class="line-modified">!                                   unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">!                                   unsigned int *instruction_end /* OUT */) const</span>
      {
        if (end_offset - start_offset &lt; GlyphHeader::static_size)
        {
          *instruction_start = 0;
          *instruction_end = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,14 ***</span>
              (const char*) this-&gt;glyf_table + start_offset,
               end_offset - start_offset, &amp;composite_it))) return false;
          const CompositeGlyphHeader *last;
          do {
            last = composite_it.current;
<span class="line-modified">!         } while (composite_it.move_to_next());</span>
  
<span class="line-modified">!         if ( (uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">!           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ) + last-&gt;get_size();</span>
          else
            *instruction_start = end_offset;
          *instruction_end = end_offset;
          if (unlikely (*instruction_start &gt; *instruction_end))
          {
<span class="line-new-header">--- 401,14 ---</span>
              (const char*) this-&gt;glyf_table + start_offset,
               end_offset - start_offset, &amp;composite_it))) return false;
          const CompositeGlyphHeader *last;
          do {
            last = composite_it.current;
<span class="line-modified">!         } while (composite_it.move_to_next ());</span>
  
<span class="line-modified">!         if ((uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">!           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ.arrayZ) + last-&gt;get_size ();</span>
          else
            *instruction_start = end_offset;
          *instruction_end = end_offset;
          if (unlikely (*instruction_start &gt; *instruction_end))
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,12 ***</span>
          *instruction_end = end;
        }
        return true;
      }
  
<span class="line-modified">!     inline bool get_extents (hb_codepoint_t glyph,</span>
<span class="line-removed">-                              hb_glyph_extents_t *extents) const</span>
      {
        unsigned int start_offset, end_offset;
        if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
          return false;
  
<span class="line-new-header">--- 438,11 ---</span>
          *instruction_end = end;
        }
        return true;
      }
  
<span class="line-modified">!     bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>
      {
        unsigned int start_offset, end_offset;
        if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
          return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 475,22 ***</span>
      }
  
      private:
      bool short_offset;
      unsigned int num_glyphs;
<span class="line-modified">!     const loca *loca_table;</span>
<span class="line-modified">!     const glyf *glyf_table;</span>
<span class="line-removed">-     hb_blob_t *loca_blob;</span>
<span class="line-removed">-     hb_blob_t *glyf_blob;</span>
<span class="line-removed">-     unsigned int glyf_len;</span>
    };
  
    protected:
<span class="line-modified">!   HBUINT8               dataZ[VAR];             /* Glyphs data. */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   DEFINE_SIZE_ARRAY (0, dataZ);</span>
  };
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_GLYF_TABLE_HH */
<span class="line-new-header">--- 460,23 ---</span>
      }
  
      private:
      bool short_offset;
      unsigned int num_glyphs;
<span class="line-modified">!     hb_blob_ptr_t&lt;loca&gt; loca_table;</span>
<span class="line-modified">!     hb_blob_ptr_t&lt;glyf&gt; glyf_table;</span>
    };
  
    protected:
<span class="line-modified">!   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Glyphs data. */</span>
<span class="line-modified">!   public:</span>
<span class="line-modified">!   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added">+                         * check the size externally, allow Null() object of it by</span>
<span class="line-added">+                         * defining it MIN() instead. */</span>
  };
  
<span class="line-added">+ struct glyf_accelerator_t : glyf::accelerator_t {};</span>
<span class="line-added">+ </span>
  } /* namespace OT */
  
  
  #endif /* HB_OT_GLYF_TABLE_HH */
</pre>
<center><a href="hb-ot-font.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-head-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-arabic-win1256.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-default.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-debug.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-ot-shape-complex-arabic-private.hh&quot;</span>
<span class="line-removed"> 30 #include &quot;hb-ot-shape-private.hh&quot;</span>
 31 
 32 
 33 /* buffer var allocations */
 34 #define arabic_shaping_action() complex_var_u8_0() /* arabic shaping action */
 35 
 36 #define HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH HB_BUFFER_SCRATCH_FLAG_COMPLEX0
 37 
 38 /* See:
 39  * https://github.com/harfbuzz/harfbuzz/commit/6e6f82b6f3dde0fc6c3c7d991d9ec6cfff57823d#commitcomment-14248516 */
 40 #define HB_ARABIC_GENERAL_CATEGORY_IS_WORD(gen_cat) \
 41         (FLAG_UNSAFE (gen_cat) &amp; \
 42          (FLAG (HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED) | \
 43           FLAG (HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE) | \
 44           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER) |*/ \
 45           FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER) | \
 46           FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER) | \
 47           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER) |*/ \
 48           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER) |*/ \
 49           FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) | \
 50           FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) | \
</pre>
<hr />
<pre>
142   /* State 1: prev was R or ISOL/ALAPH, not willing to join. */
143   { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN2,5}, {NONE,ISOL,6}, },
144 
145   /* State 2: prev was D/L in ISOL form, willing to join. */
146   { {NONE,NONE,0}, {NONE,ISOL,2}, {INIT,FINA,1}, {INIT,FINA,3}, {INIT,FINA,4}, {INIT,FINA,6}, },
147 
148   /* State 3: prev was D in FINA form, willing to join. */
149   { {NONE,NONE,0}, {NONE,ISOL,2}, {MEDI,FINA,1}, {MEDI,FINA,3}, {MEDI,FINA,4}, {MEDI,FINA,6}, },
150 
151   /* State 4: prev was FINA ALAPH, not willing to join. */
152   { {NONE,NONE,0}, {NONE,ISOL,2}, {MED2,ISOL,1}, {MED2,ISOL,2}, {MED2,FIN2,5}, {MED2,ISOL,6}, },
153 
154   /* State 5: prev was FIN2/FIN3 ALAPH, not willing to join. */
155   { {NONE,NONE,0}, {NONE,ISOL,2}, {ISOL,ISOL,1}, {ISOL,ISOL,2}, {ISOL,FIN2,5}, {ISOL,ISOL,6}, },
156 
157   /* State 6: prev was DALATH/RISH, not willing to join. */
158   { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }
159 };
160 
161 
<span class="line-removed">162 static void</span>
<span class="line-removed">163 nuke_joiners (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">164               hb_font_t *font,</span>
<span class="line-removed">165               hb_buffer_t *buffer);</span>
<span class="line-removed">166 </span>
167 static void
168 arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
169                        hb_font_t *font,
170                        hb_buffer_t *buffer);
171 
172 static void
173 record_stch (const hb_ot_shape_plan_t *plan,
174              hb_font_t *font,
175              hb_buffer_t *buffer);
176 
177 static void
178 collect_features_arabic (hb_ot_shape_planner_t *plan)
179 {
180   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
181 
182   /* We apply features according to the Arabic spec, with pauses
183    * in between most.
184    *
185    * The pause between init/medi/... and rlig is required.  See eg:
186    * https://bugzilla.mozilla.org/show_bug.cgi?id=644184
187    *
188    * The pauses between init/medi/... themselves are not necessarily
189    * needed as only one of those features is applied to any character.
190    * The only difference it makes is when fonts have contextual
191    * substitutions.  We now follow the order of the spec, which makes
192    * for better experience if that&#39;s what Uniscribe is doing.
193    *
194    * At least for Arabic, looks like Uniscribe has a pause between
195    * rlig and calt.  Otherwise the IranNastaliq&#39;s ALLAH ligature won&#39;t
196    * work.  However, testing shows that rlig and calt are applied
197    * together for Mongolian in Uniscribe.  As such, we only add a
198    * pause for Arabic, not other scripts.
199    *
200    * A pause after calt is required to make KFGQPC Uthmanic Script HAFS
201    * work correctly.  See https://github.com/harfbuzz/harfbuzz/issues/505
202    */
203 
<span class="line-removed">204   map-&gt;add_gsub_pause (nuke_joiners);</span>
205 
<span class="line-modified">206   map-&gt;add_global_bool_feature (HB_TAG(&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));</span>
207   map-&gt;add_gsub_pause (record_stch);
208 
<span class="line-modified">209   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">210   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
211 
212   map-&gt;add_gsub_pause (nullptr);
213 
214   for (unsigned int i = 0; i &lt; ARABIC_NUM_FEATURES; i++)
215   {
216     bool has_fallback = plan-&gt;props.script == HB_SCRIPT_ARABIC &amp;&amp; !FEATURE_IS_SYRIAC (arabic_features[i]);
<span class="line-modified">217     map-&gt;add_feature (arabic_features[i], 1, has_fallback ? F_HAS_FALLBACK : F_NONE);</span>
218     map-&gt;add_gsub_pause (nullptr);
219   }
220 
<span class="line-modified">221   map-&gt;add_feature (HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), 1, F_GLOBAL|F_HAS_FALLBACK);</span>





222   if (plan-&gt;props.script == HB_SCRIPT_ARABIC)
223     map-&gt;add_gsub_pause (arabic_fallback_shape);
224 
225   /* No pause after rclt.  See 98460779bae19e4d64d29461ff154b3527bf8420. */
<span class="line-modified">226   map-&gt;add_global_bool_feature (HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-modified">227   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
228   map-&gt;add_gsub_pause (nullptr);
229 


230   /* The spec includes &#39;cswh&#39;.  Earlier versions of Windows
231    * used to enable this by default, but testing suggests
232    * that Windows 8 and later do not enable it by default,
233    * and spec now says &#39;Off by default&#39;.
234    * We disabled this in ae23c24c32.
235    * Note that IranNastaliq uses this feature extensively
236    * to fixup broken glyph sequences.  Oh well...
237    * Test case: U+0643,U+0640,U+0631. */
<span class="line-modified">238   //map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;s&#39;,&#39;w&#39;,&#39;h&#39;));</span>
<span class="line-modified">239   map-&gt;add_global_bool_feature (HB_TAG(&#39;m&#39;,&#39;s&#39;,&#39;e&#39;,&#39;t&#39;));</span>
240 }
241 
242 #include &quot;hb-ot-shape-complex-arabic-fallback.hh&quot;
243 
244 struct arabic_shape_plan_t
245 {
<span class="line-removed">246   ASSERT_POD ();</span>
<span class="line-removed">247 </span>
248   /* The &quot;+ 1&quot; in the next array is to accommodate for the &quot;NONE&quot; command,
249    * which is not an OpenType feature, but this simplifies the code by not
250    * having to do a &quot;if (... &lt; NONE) ...&quot; and just rely on the fact that
251    * mask_array[NONE] == 0. */
252   hb_mask_t mask_array[ARABIC_NUM_FEATURES + 1];
253 
<span class="line-modified">254   arabic_fallback_plan_t *fallback_plan;</span>
255 
256   unsigned int do_fallback : 1;
257   unsigned int has_stch : 1;
258 };
259 
260 void *
261 data_create_arabic (const hb_ot_shape_plan_t *plan)
262 {
263   arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) calloc (1, sizeof (arabic_shape_plan_t));
264   if (unlikely (!arabic_plan))
265     return nullptr;
266 
267   arabic_plan-&gt;do_fallback = plan-&gt;props.script == HB_SCRIPT_ARABIC;
268   arabic_plan-&gt;has_stch = !!plan-&gt;map.get_1_mask (HB_TAG (&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));
269   for (unsigned int i = 0; i &lt; ARABIC_NUM_FEATURES; i++) {
270     arabic_plan-&gt;mask_array[i] = plan-&gt;map.get_1_mask (arabic_features[i]);
271     arabic_plan-&gt;do_fallback = arabic_plan-&gt;do_fallback &amp;&amp;
272                                (FEATURE_IS_SYRIAC (arabic_features[i]) ||
273                                 plan-&gt;map.needs_fallback (arabic_features[i]));
274   }
</pre>
<hr />
<pre>
363 
364   arabic_joining (buffer);
365   if (script == HB_SCRIPT_MONGOLIAN)
366     mongolian_variation_selectors (buffer);
367 
368   unsigned int count = buffer-&gt;len;
369   hb_glyph_info_t *info = buffer-&gt;info;
370   for (unsigned int i = 0; i &lt; count; i++)
371     info[i].mask |= arabic_plan-&gt;mask_array[info[i].arabic_shaping_action()];
372 }
373 
374 static void
375 setup_masks_arabic (const hb_ot_shape_plan_t *plan,
376                     hb_buffer_t              *buffer,
377                     hb_font_t                *font HB_UNUSED)
378 {
379   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
380   setup_masks_arabic_plan (arabic_plan, buffer, plan-&gt;props.script);
381 }
382 
<span class="line-removed">383 </span>
<span class="line-removed">384 static void</span>
<span class="line-removed">385 nuke_joiners (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-removed">386               hb_font_t *font HB_UNUSED,</span>
<span class="line-removed">387               hb_buffer_t *buffer)</span>
<span class="line-removed">388 {</span>
<span class="line-removed">389   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">390   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">391   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">392     if (_hb_glyph_info_is_zwj (&amp;info[i]))</span>
<span class="line-removed">393       _hb_glyph_info_flip_joiners (&amp;info[i]);</span>
<span class="line-removed">394 }</span>
<span class="line-removed">395 </span>
396 static void
397 arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
398                        hb_font_t *font,
399                        hb_buffer_t *buffer)
400 {
401   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
402 
403   if (!arabic_plan-&gt;do_fallback)
404     return;
405 
406 retry:
<span class="line-modified">407   arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) hb_atomic_ptr_get (&amp;arabic_plan-&gt;fallback_plan);</span>
408   if (unlikely (!fallback_plan))
409   {
410     /* This sucks.  We need a font to build the fallback plan... */
411     fallback_plan = arabic_fallback_plan_create (plan, font);
<span class="line-modified">412     if (unlikely (!hb_atomic_ptr_cmpexch (&amp;(const_cast&lt;arabic_shape_plan_t *&gt; (arabic_plan))-&gt;fallback_plan, nullptr, fallback_plan))) {</span>

413       arabic_fallback_plan_destroy (fallback_plan);
414       goto retry;
415     }
416   }
417 
418   arabic_fallback_plan_shape (fallback_plan, font, buffer);
419 }
420 
421 /*
422  * Stretch feature: &quot;stch&quot;.
423  * See example here:
424  * https://docs.microsoft.com/en-us/typography/script-development/syriac
425  * We implement this in a generic way, such that the Arabic subtending
426  * marks can use it as well.
427  */
428 
429 static void
430 record_stch (const hb_ot_shape_plan_t *plan,
<span class="line-modified">431              hb_font_t *font,</span>
432              hb_buffer_t *buffer)
433 {
434   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
435   if (!arabic_plan-&gt;has_stch)
436     return;
437 
438   /* &#39;stch&#39; feature was just applied.  Look for anything that multiplied,
439    * and record it for stch treatment later.  Note that rtlm, frac, etc
440    * are applied before stch, but we assume that they didn&#39;t result in
441    * anything multiplying into 5 pieces, so it&#39;s safe-ish... */
442 
443   unsigned int count = buffer-&gt;len;
444   hb_glyph_info_t *info = buffer-&gt;info;
445   for (unsigned int i = 0; i &lt; count; i++)
446     if (unlikely (_hb_glyph_info_multiplied (&amp;info[i])))
447     {
448       unsigned int comp = _hb_glyph_info_get_lig_comp (&amp;info[i]);
449       info[i].arabic_shaping_action() = comp % 2 ? STCH_REPEATING : STCH_FIXED;
450       buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH;
451     }
452 }
453 
454 static void
<span class="line-modified">455 apply_stch (const hb_ot_shape_plan_t *plan,</span>
456             hb_buffer_t              *buffer,
457             hb_font_t                *font)
458 {
459   if (likely (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH)))
460     return;
461 
462   /* The Arabic shaper currently always processes in RTL mode, so we should
463    * stretch / position the stretched pieces to the left / preceding glyphs. */
464 
465   /* We do a two pass implementation:
466    * First pass calculates the exact number of extra glyphs we need,
467    * We then enlarge buffer to have that much room,
468    * Second pass applies the stretch, copying things to the end of buffer.
469    */
470 
471   int sign = font-&gt;x_scale &lt; 0 ? -1 : +1;
472   unsigned int extra_glyphs_needed = 0; // Set during MEASURE, used during CUT
<span class="line-modified">473   typedef enum { MEASURE, CUT } step_t;</span>
474 
<span class="line-modified">475   for (step_t step = MEASURE; step &lt;= CUT; step = (step_t) (step + 1))</span>
476   {
477     unsigned int count = buffer-&gt;len;
478     hb_glyph_info_t *info = buffer-&gt;info;
479     hb_glyph_position_t *pos = buffer-&gt;pos;
480     unsigned int new_len = count + extra_glyphs_needed; // write head during CUT
481     unsigned int j = new_len;
482     for (unsigned int i = count; i; i--)
483     {
484       if (!hb_in_range&lt;unsigned&gt; (info[i - 1].arabic_shaping_action(), STCH_FIXED, STCH_REPEATING))
485       {
486         if (step == CUT)
487         {
488           --j;
489           info[j] = info[i - 1];
490           pos[j] = pos[i - 1];
491         }
492         continue;
493       }
494 
495       /* Yay, justification! */
</pre>
<hr />
<pre>
594     }
595     else
596     {
597       assert (j == 0);
598       buffer-&gt;len = new_len;
599     }
600   }
601 }
602 
603 
604 static void
605 postprocess_glyphs_arabic (const hb_ot_shape_plan_t *plan,
606                            hb_buffer_t              *buffer,
607                            hb_font_t                *font)
608 {
609   apply_stch (plan, buffer, font);
610 
611   HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);
612 }
613 
<span class="line-modified">614 /* https://unicode.org/reports/tr53/tr53-1.pdf */</span>
615 
616 static hb_codepoint_t
617 modifier_combining_marks[] =
618 {
619   0x0654u, /* ARABIC HAMZA ABOVE */
620   0x0655u, /* ARABIC HAMZA BELOW */
621   0x0658u, /* ARABIC MARK NOON GHUNNA */
622   0x06DCu, /* ARABIC SMALL HIGH SEEN */
623   0x06E3u, /* ARABIC SMALL LOW SEEN */
624   0x06E7u, /* ARABIC SMALL HIGH YEH */
625   0x06E8u, /* ARABIC SMALL HIGH NOON */

626   0x08F3u, /* ARABIC SMALL HIGH WAW */
627 };
628 
629 static inline bool
630 info_is_mcm (const hb_glyph_info_t &amp;info)
631 {
632   hb_codepoint_t u = info.codepoint;
633   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (modifier_combining_marks); i++)
634     if (u == modifier_combining_marks[i])
635       return true;
636   return false;
637 }
638 
639 static void
<span class="line-modified">640 reorder_marks_arabic (const hb_ot_shape_plan_t *plan,</span>
641                       hb_buffer_t              *buffer,
642                       unsigned int              start,
643                       unsigned int              end)
644 {
645   hb_glyph_info_t *info = buffer-&gt;info;
646 
647   DEBUG_MSG (ARABIC, buffer, &quot;Reordering marks from %d to %d&quot;, start, end);
648 
649   unsigned int i = start;
650   for (unsigned int cc = 220; cc &lt;= 230; cc += 10)
651   {
652     DEBUG_MSG (ARABIC, buffer, &quot;Looking for %d&#39;s starting at %d&quot;, cc, i);
653     while (i &lt; end &amp;&amp; info_cc(info[i]) &lt; cc)
654       i++;
655     DEBUG_MSG (ARABIC, buffer, &quot;Looking for %d&#39;s stopped at %d&quot;, cc, i);
656 
657     if (i == end)
658       break;
659 
660     if (info_cc(info[i]) &gt; cc)
</pre>
<hr />
<pre>
697       _hb_glyph_info_set_modified_combining_class (&amp;info[start], new_cc);
698       start++;
699     }
700 
701     i = j;
702   }
703 }
704 
705 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_arabic =
706 {
707   collect_features_arabic,
708   nullptr, /* override_features */
709   data_create_arabic,
710   data_destroy_arabic,
711   nullptr, /* preprocess_text */
712   postprocess_glyphs_arabic,
713   HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,
714   nullptr, /* decompose */
715   nullptr, /* compose */
716   setup_masks_arabic,
<span class="line-modified">717   nullptr, /* disable_otl */</span>
718   reorder_marks_arabic,
719   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,
720   true, /* fallback_position */
721 };
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-shape-complex-arabic.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-ot-shape.hh&quot;</span>

 30 
 31 
 32 /* buffer var allocations */
 33 #define arabic_shaping_action() complex_var_u8_0() /* arabic shaping action */
 34 
 35 #define HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH HB_BUFFER_SCRATCH_FLAG_COMPLEX0
 36 
 37 /* See:
 38  * https://github.com/harfbuzz/harfbuzz/commit/6e6f82b6f3dde0fc6c3c7d991d9ec6cfff57823d#commitcomment-14248516 */
 39 #define HB_ARABIC_GENERAL_CATEGORY_IS_WORD(gen_cat) \
 40         (FLAG_UNSAFE (gen_cat) &amp; \
 41          (FLAG (HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED) | \
 42           FLAG (HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE) | \
 43           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER) |*/ \
 44           FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER) | \
 45           FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER) | \
 46           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER) |*/ \
 47           /*FLAG (HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER) |*/ \
 48           FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) | \
 49           FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) | \
</pre>
<hr />
<pre>
141   /* State 1: prev was R or ISOL/ALAPH, not willing to join. */
142   { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN2,5}, {NONE,ISOL,6}, },
143 
144   /* State 2: prev was D/L in ISOL form, willing to join. */
145   { {NONE,NONE,0}, {NONE,ISOL,2}, {INIT,FINA,1}, {INIT,FINA,3}, {INIT,FINA,4}, {INIT,FINA,6}, },
146 
147   /* State 3: prev was D in FINA form, willing to join. */
148   { {NONE,NONE,0}, {NONE,ISOL,2}, {MEDI,FINA,1}, {MEDI,FINA,3}, {MEDI,FINA,4}, {MEDI,FINA,6}, },
149 
150   /* State 4: prev was FINA ALAPH, not willing to join. */
151   { {NONE,NONE,0}, {NONE,ISOL,2}, {MED2,ISOL,1}, {MED2,ISOL,2}, {MED2,FIN2,5}, {MED2,ISOL,6}, },
152 
153   /* State 5: prev was FIN2/FIN3 ALAPH, not willing to join. */
154   { {NONE,NONE,0}, {NONE,ISOL,2}, {ISOL,ISOL,1}, {ISOL,ISOL,2}, {ISOL,FIN2,5}, {ISOL,ISOL,6}, },
155 
156   /* State 6: prev was DALATH/RISH, not willing to join. */
157   { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }
158 };
159 
160 





161 static void
162 arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
163                        hb_font_t *font,
164                        hb_buffer_t *buffer);
165 
166 static void
167 record_stch (const hb_ot_shape_plan_t *plan,
168              hb_font_t *font,
169              hb_buffer_t *buffer);
170 
171 static void
172 collect_features_arabic (hb_ot_shape_planner_t *plan)
173 {
174   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
175 
176   /* We apply features according to the Arabic spec, with pauses
177    * in between most.
178    *
179    * The pause between init/medi/... and rlig is required.  See eg:
180    * https://bugzilla.mozilla.org/show_bug.cgi?id=644184
181    *
182    * The pauses between init/medi/... themselves are not necessarily
183    * needed as only one of those features is applied to any character.
184    * The only difference it makes is when fonts have contextual
185    * substitutions.  We now follow the order of the spec, which makes
186    * for better experience if that&#39;s what Uniscribe is doing.
187    *
188    * At least for Arabic, looks like Uniscribe has a pause between
189    * rlig and calt.  Otherwise the IranNastaliq&#39;s ALLAH ligature won&#39;t
190    * work.  However, testing shows that rlig and calt are applied
191    * together for Mongolian in Uniscribe.  As such, we only add a
192    * pause for Arabic, not other scripts.
193    *
194    * A pause after calt is required to make KFGQPC Uthmanic Script HAFS
195    * work correctly.  See https://github.com/harfbuzz/harfbuzz/issues/505
196    */
197 

198 
<span class="line-modified">199   map-&gt;enable_feature (HB_TAG(&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));</span>
200   map-&gt;add_gsub_pause (record_stch);
201 
<span class="line-modified">202   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">203   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
204 
205   map-&gt;add_gsub_pause (nullptr);
206 
207   for (unsigned int i = 0; i &lt; ARABIC_NUM_FEATURES; i++)
208   {
209     bool has_fallback = plan-&gt;props.script == HB_SCRIPT_ARABIC &amp;&amp; !FEATURE_IS_SYRIAC (arabic_features[i]);
<span class="line-modified">210     map-&gt;add_feature (arabic_features[i], has_fallback ? F_HAS_FALLBACK : F_NONE);</span>
211     map-&gt;add_gsub_pause (nullptr);
212   }
213 
<span class="line-modified">214   /* Normally, Unicode says a ZWNJ means &quot;don&#39;t ligate&quot;.  In Arabic script</span>
<span class="line-added">215    * however, it says a ZWJ should also mean &quot;don&#39;t ligate&quot;.  So we run</span>
<span class="line-added">216    * the main ligating features as MANUAL_ZWJ. */</span>
<span class="line-added">217 </span>
<span class="line-added">218   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_MANUAL_ZWJ | F_HAS_FALLBACK);</span>
<span class="line-added">219 </span>
220   if (plan-&gt;props.script == HB_SCRIPT_ARABIC)
221     map-&gt;add_gsub_pause (arabic_fallback_shape);
222 
223   /* No pause after rclt.  See 98460779bae19e4d64d29461ff154b3527bf8420. */
<span class="line-modified">224   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;), F_MANUAL_ZWJ);</span>
<span class="line-modified">225   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), F_MANUAL_ZWJ);</span>
226   map-&gt;add_gsub_pause (nullptr);
227 
<span class="line-added">228   /* And undo here. */</span>
<span class="line-added">229 </span>
230   /* The spec includes &#39;cswh&#39;.  Earlier versions of Windows
231    * used to enable this by default, but testing suggests
232    * that Windows 8 and later do not enable it by default,
233    * and spec now says &#39;Off by default&#39;.
234    * We disabled this in ae23c24c32.
235    * Note that IranNastaliq uses this feature extensively
236    * to fixup broken glyph sequences.  Oh well...
237    * Test case: U+0643,U+0640,U+0631. */
<span class="line-modified">238   //map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;s&#39;,&#39;w&#39;,&#39;h&#39;));</span>
<span class="line-modified">239   map-&gt;enable_feature (HB_TAG(&#39;m&#39;,&#39;s&#39;,&#39;e&#39;,&#39;t&#39;));</span>
240 }
241 
242 #include &quot;hb-ot-shape-complex-arabic-fallback.hh&quot;
243 
244 struct arabic_shape_plan_t
245 {


246   /* The &quot;+ 1&quot; in the next array is to accommodate for the &quot;NONE&quot; command,
247    * which is not an OpenType feature, but this simplifies the code by not
248    * having to do a &quot;if (... &lt; NONE) ...&quot; and just rely on the fact that
249    * mask_array[NONE] == 0. */
250   hb_mask_t mask_array[ARABIC_NUM_FEATURES + 1];
251 
<span class="line-modified">252   hb_atomic_ptr_t&lt;arabic_fallback_plan_t&gt; fallback_plan;</span>
253 
254   unsigned int do_fallback : 1;
255   unsigned int has_stch : 1;
256 };
257 
258 void *
259 data_create_arabic (const hb_ot_shape_plan_t *plan)
260 {
261   arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) calloc (1, sizeof (arabic_shape_plan_t));
262   if (unlikely (!arabic_plan))
263     return nullptr;
264 
265   arabic_plan-&gt;do_fallback = plan-&gt;props.script == HB_SCRIPT_ARABIC;
266   arabic_plan-&gt;has_stch = !!plan-&gt;map.get_1_mask (HB_TAG (&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));
267   for (unsigned int i = 0; i &lt; ARABIC_NUM_FEATURES; i++) {
268     arabic_plan-&gt;mask_array[i] = plan-&gt;map.get_1_mask (arabic_features[i]);
269     arabic_plan-&gt;do_fallback = arabic_plan-&gt;do_fallback &amp;&amp;
270                                (FEATURE_IS_SYRIAC (arabic_features[i]) ||
271                                 plan-&gt;map.needs_fallback (arabic_features[i]));
272   }
</pre>
<hr />
<pre>
361 
362   arabic_joining (buffer);
363   if (script == HB_SCRIPT_MONGOLIAN)
364     mongolian_variation_selectors (buffer);
365 
366   unsigned int count = buffer-&gt;len;
367   hb_glyph_info_t *info = buffer-&gt;info;
368   for (unsigned int i = 0; i &lt; count; i++)
369     info[i].mask |= arabic_plan-&gt;mask_array[info[i].arabic_shaping_action()];
370 }
371 
372 static void
373 setup_masks_arabic (const hb_ot_shape_plan_t *plan,
374                     hb_buffer_t              *buffer,
375                     hb_font_t                *font HB_UNUSED)
376 {
377   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
378   setup_masks_arabic_plan (arabic_plan, buffer, plan-&gt;props.script);
379 }
380 













381 static void
382 arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
383                        hb_font_t *font,
384                        hb_buffer_t *buffer)
385 {
386   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
387 
388   if (!arabic_plan-&gt;do_fallback)
389     return;
390 
391 retry:
<span class="line-modified">392   arabic_fallback_plan_t *fallback_plan = arabic_plan-&gt;fallback_plan;</span>
393   if (unlikely (!fallback_plan))
394   {
395     /* This sucks.  We need a font to build the fallback plan... */
396     fallback_plan = arabic_fallback_plan_create (plan, font);
<span class="line-modified">397     if (unlikely (!arabic_plan-&gt;fallback_plan.cmpexch (nullptr, fallback_plan)))</span>
<span class="line-added">398     {</span>
399       arabic_fallback_plan_destroy (fallback_plan);
400       goto retry;
401     }
402   }
403 
404   arabic_fallback_plan_shape (fallback_plan, font, buffer);
405 }
406 
407 /*
408  * Stretch feature: &quot;stch&quot;.
409  * See example here:
410  * https://docs.microsoft.com/en-us/typography/script-development/syriac
411  * We implement this in a generic way, such that the Arabic subtending
412  * marks can use it as well.
413  */
414 
415 static void
416 record_stch (const hb_ot_shape_plan_t *plan,
<span class="line-modified">417              hb_font_t *font HB_UNUSED,</span>
418              hb_buffer_t *buffer)
419 {
420   const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
421   if (!arabic_plan-&gt;has_stch)
422     return;
423 
424   /* &#39;stch&#39; feature was just applied.  Look for anything that multiplied,
425    * and record it for stch treatment later.  Note that rtlm, frac, etc
426    * are applied before stch, but we assume that they didn&#39;t result in
427    * anything multiplying into 5 pieces, so it&#39;s safe-ish... */
428 
429   unsigned int count = buffer-&gt;len;
430   hb_glyph_info_t *info = buffer-&gt;info;
431   for (unsigned int i = 0; i &lt; count; i++)
432     if (unlikely (_hb_glyph_info_multiplied (&amp;info[i])))
433     {
434       unsigned int comp = _hb_glyph_info_get_lig_comp (&amp;info[i]);
435       info[i].arabic_shaping_action() = comp % 2 ? STCH_REPEATING : STCH_FIXED;
436       buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH;
437     }
438 }
439 
440 static void
<span class="line-modified">441 apply_stch (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
442             hb_buffer_t              *buffer,
443             hb_font_t                *font)
444 {
445   if (likely (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH)))
446     return;
447 
448   /* The Arabic shaper currently always processes in RTL mode, so we should
449    * stretch / position the stretched pieces to the left / preceding glyphs. */
450 
451   /* We do a two pass implementation:
452    * First pass calculates the exact number of extra glyphs we need,
453    * We then enlarge buffer to have that much room,
454    * Second pass applies the stretch, copying things to the end of buffer.
455    */
456 
457   int sign = font-&gt;x_scale &lt; 0 ? -1 : +1;
458   unsigned int extra_glyphs_needed = 0; // Set during MEASURE, used during CUT
<span class="line-modified">459   enum { MEASURE, CUT } /* step_t */;</span>
460 
<span class="line-modified">461   for (unsigned int step = MEASURE; step &lt;= CUT; step = step + 1)</span>
462   {
463     unsigned int count = buffer-&gt;len;
464     hb_glyph_info_t *info = buffer-&gt;info;
465     hb_glyph_position_t *pos = buffer-&gt;pos;
466     unsigned int new_len = count + extra_glyphs_needed; // write head during CUT
467     unsigned int j = new_len;
468     for (unsigned int i = count; i; i--)
469     {
470       if (!hb_in_range&lt;unsigned&gt; (info[i - 1].arabic_shaping_action(), STCH_FIXED, STCH_REPEATING))
471       {
472         if (step == CUT)
473         {
474           --j;
475           info[j] = info[i - 1];
476           pos[j] = pos[i - 1];
477         }
478         continue;
479       }
480 
481       /* Yay, justification! */
</pre>
<hr />
<pre>
580     }
581     else
582     {
583       assert (j == 0);
584       buffer-&gt;len = new_len;
585     }
586   }
587 }
588 
589 
590 static void
591 postprocess_glyphs_arabic (const hb_ot_shape_plan_t *plan,
592                            hb_buffer_t              *buffer,
593                            hb_font_t                *font)
594 {
595   apply_stch (plan, buffer, font);
596 
597   HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);
598 }
599 
<span class="line-modified">600 /* http://www.unicode.org/reports/tr53/ */</span>
601 
602 static hb_codepoint_t
603 modifier_combining_marks[] =
604 {
605   0x0654u, /* ARABIC HAMZA ABOVE */
606   0x0655u, /* ARABIC HAMZA BELOW */
607   0x0658u, /* ARABIC MARK NOON GHUNNA */
608   0x06DCu, /* ARABIC SMALL HIGH SEEN */
609   0x06E3u, /* ARABIC SMALL LOW SEEN */
610   0x06E7u, /* ARABIC SMALL HIGH YEH */
611   0x06E8u, /* ARABIC SMALL HIGH NOON */
<span class="line-added">612   0x08D3u, /* ARABIC SMALL LOW WAW */</span>
613   0x08F3u, /* ARABIC SMALL HIGH WAW */
614 };
615 
616 static inline bool
617 info_is_mcm (const hb_glyph_info_t &amp;info)
618 {
619   hb_codepoint_t u = info.codepoint;
620   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (modifier_combining_marks); i++)
621     if (u == modifier_combining_marks[i])
622       return true;
623   return false;
624 }
625 
626 static void
<span class="line-modified">627 reorder_marks_arabic (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
628                       hb_buffer_t              *buffer,
629                       unsigned int              start,
630                       unsigned int              end)
631 {
632   hb_glyph_info_t *info = buffer-&gt;info;
633 
634   DEBUG_MSG (ARABIC, buffer, &quot;Reordering marks from %d to %d&quot;, start, end);
635 
636   unsigned int i = start;
637   for (unsigned int cc = 220; cc &lt;= 230; cc += 10)
638   {
639     DEBUG_MSG (ARABIC, buffer, &quot;Looking for %d&#39;s starting at %d&quot;, cc, i);
640     while (i &lt; end &amp;&amp; info_cc(info[i]) &lt; cc)
641       i++;
642     DEBUG_MSG (ARABIC, buffer, &quot;Looking for %d&#39;s stopped at %d&quot;, cc, i);
643 
644     if (i == end)
645       break;
646 
647     if (info_cc(info[i]) &gt; cc)
</pre>
<hr />
<pre>
684       _hb_glyph_info_set_modified_combining_class (&amp;info[start], new_cc);
685       start++;
686     }
687 
688     i = j;
689   }
690 }
691 
692 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_arabic =
693 {
694   collect_features_arabic,
695   nullptr, /* override_features */
696   data_create_arabic,
697   data_destroy_arabic,
698   nullptr, /* preprocess_text */
699   postprocess_glyphs_arabic,
700   HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,
701   nullptr, /* decompose */
702   nullptr, /* compose */
703   setup_masks_arabic,
<span class="line-modified">704   HB_TAG_NONE, /* gpos_tag */</span>
705   reorder_marks_arabic,
706   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,
707   true, /* fallback_position */
708 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-arabic-win1256.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-default.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2009,2010  Red Hat, Inc.
  3  * Copyright © 2010,2011,2013  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;hb-ot-map.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-ot-shape.hh&quot;</span>
<span class="line-modified"> 31 #include &quot;hb-ot-layout.hh&quot;</span>
 32 
 33 
 34 void hb_ot_map_t::collect_lookups (unsigned int table_index, hb_set_t *lookups_out) const
 35 {
<a name="2" id="anc2"></a><span class="line-modified"> 36   for (unsigned int i = 0; i &lt; lookups[table_index].length; i++)</span>
 37     hb_set_add (lookups_out, lookups[table_index][i].index);
 38 }
 39 
 40 
 41 hb_ot_map_builder_t::hb_ot_map_builder_t (hb_face_t *face_,
 42                                           const hb_segment_properties_t *props_)
 43 {
 44   memset (this, 0, sizeof (*this));
 45 
 46   feature_infos.init ();
 47   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 48     stages[table_index].init ();
 49 
 50   face = face_;
 51   props = *props_;
 52 
 53 
 54   /* Fetch script/language indices for GSUB/GPOS.  We need these later to skip
 55    * features not available in either table and not waste precious bits for them. */
 56 
<a name="3" id="anc3"></a><span class="line-modified"> 57   unsigned int script_count = HB_OT_MAX_TAGS_PER_SCRIPT;</span>
<span class="line-modified"> 58   unsigned int language_count = HB_OT_MAX_TAGS_PER_LANGUAGE;</span>
<span class="line-added"> 59   hb_tag_t script_tags[HB_OT_MAX_TAGS_PER_SCRIPT];</span>
<span class="line-added"> 60   hb_tag_t language_tags[HB_OT_MAX_TAGS_PER_LANGUAGE];</span>
 61 
<a name="4" id="anc4"></a><span class="line-modified"> 62   hb_ot_tags_from_script_and_language (props.script, props.language, &amp;script_count, script_tags, &amp;language_count, language_tags);</span>

 63 
 64   for (unsigned int table_index = 0; table_index &lt; 2; table_index++) {
 65     hb_tag_t table_tag = table_tags[table_index];
<a name="5" id="anc5"></a><span class="line-modified"> 66     found_script[table_index] = (bool) hb_ot_layout_table_select_script (face, table_tag, script_count, script_tags, &amp;script_index[table_index], &amp;chosen_script[table_index]);</span>
<span class="line-modified"> 67     hb_ot_layout_script_select_language (face, table_tag, script_index[table_index], language_count, language_tags, &amp;language_index[table_index]);</span>
 68   }
 69 }
 70 
<a name="6" id="anc6"></a><span class="line-modified"> 71 hb_ot_map_builder_t::~hb_ot_map_builder_t ()</span>
 72 {
 73   feature_infos.fini ();
 74   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 75     stages[table_index].fini ();
 76 }
 77 
<a name="7" id="anc7"></a><span class="line-modified"> 78 void hb_ot_map_builder_t::add_feature (hb_tag_t tag,</span>
<span class="line-modified"> 79                                        hb_ot_map_feature_flags_t flags,</span>
<span class="line-added"> 80                                        unsigned int value)</span>
 81 {
<a name="8" id="anc8"></a>
 82   if (unlikely (!tag)) return;
<a name="9" id="anc9"></a><span class="line-added"> 83   feature_info_t *info = feature_infos.push();</span>
 84   info-&gt;tag = tag;
<a name="10" id="anc10"></a><span class="line-modified"> 85   info-&gt;seq = feature_infos.length;</span>
 86   info-&gt;max_value = value;
 87   info-&gt;flags = flags;
 88   info-&gt;default_value = (flags &amp; F_GLOBAL) ? value : 0;
 89   info-&gt;stage[0] = current_stage[0];
 90   info-&gt;stage[1] = current_stage[1];
 91 }
 92 
 93 void
 94 hb_ot_map_builder_t::add_lookups (hb_ot_map_t  &amp;m,
 95                                   unsigned int  table_index,
 96                                   unsigned int  feature_index,
 97                                   unsigned int  variations_index,
 98                                   hb_mask_t     mask,
 99                                   bool          auto_zwnj,
<a name="11" id="anc11"></a><span class="line-modified">100                                   bool          auto_zwj,</span>
<span class="line-added">101                                   bool          random)</span>
102 {
103   unsigned int lookup_indices[32];
104   unsigned int offset, len;
105   unsigned int table_lookup_count;
106 
107   table_lookup_count = hb_ot_layout_table_get_lookup_count (face, table_tags[table_index]);
108 
109   offset = 0;
110   do {
111     len = ARRAY_LENGTH (lookup_indices);
112     hb_ot_layout_feature_with_variations_get_lookups (face,
113                                                       table_tags[table_index],
114                                                       feature_index,
115                                                       variations_index,
116                                                       offset, &amp;len,
117                                                       lookup_indices);
118 
119     for (unsigned int i = 0; i &lt; len; i++)
120     {
121       if (lookup_indices[i] &gt;= table_lookup_count)
122         continue;
123       hb_ot_map_t::lookup_map_t *lookup = m.lookups[table_index].push ();
124       lookup-&gt;mask = mask;
125       lookup-&gt;index = lookup_indices[i];
126       lookup-&gt;auto_zwnj = auto_zwnj;
127       lookup-&gt;auto_zwj = auto_zwj;
<a name="12" id="anc12"></a><span class="line-added">128       lookup-&gt;random = random;</span>
129     }
130 
131     offset += len;
132   } while (len == ARRAY_LENGTH (lookup_indices));
133 }
134 
135 
136 void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)
137 {
138   stage_info_t *s = stages[table_index].push ();
139   s-&gt;index = current_stage[table_index];
140   s-&gt;pause_func = pause_func;
141 
142   current_stage[table_index]++;
143 }
144 
145 void
<a name="13" id="anc13"></a><span class="line-modified">146 hb_ot_map_builder_t::compile (hb_ot_map_t                  &amp;m,</span>
<span class="line-modified">147                               const hb_ot_shape_plan_key_t &amp;key)</span>

148 {
149   static_assert ((!(HB_GLYPH_FLAG_DEFINED &amp; (HB_GLYPH_FLAG_DEFINED + 1))), &quot;&quot;);
150   unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;
<a name="14" id="anc14"></a><span class="line-modified">151   unsigned int global_bit_shift = hb_popcount (HB_GLYPH_FLAG_DEFINED);</span>
152 
153   m.global_mask = global_bit_mask;
154 
155   unsigned int required_feature_index[2];
156   hb_tag_t required_feature_tag[2];
157   /* We default to applying required feature in stage 0.  If the required
158    * feature has a tag that is known to the shaper, we apply required feature
159    * in the stage for that tag.
160    */
161   unsigned int required_feature_stage[2] = {0, 0};
162 
163   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
164   {
165     m.chosen_script[table_index] = chosen_script[table_index];
166     m.found_script[table_index] = found_script[table_index];
167 
168     hb_ot_layout_language_get_required_feature (face,
169                                                 table_tags[table_index],
170                                                 script_index[table_index],
171                                                 language_index[table_index],
172                                                 &amp;required_feature_index[table_index],
173                                                 &amp;required_feature_tag[table_index]);
174   }
175 
176   /* Sort features and merge duplicates */
<a name="15" id="anc15"></a><span class="line-added">177   if (feature_infos.length)</span>
178   {
179     feature_infos.qsort ();
180     unsigned int j = 0;
<a name="16" id="anc16"></a><span class="line-modified">181     for (unsigned int i = 1; i &lt; feature_infos.length; i++)</span>
182       if (feature_infos[i].tag != feature_infos[j].tag)
183         feature_infos[++j] = feature_infos[i];
184       else {
185         if (feature_infos[i].flags &amp; F_GLOBAL) {
186           feature_infos[j].flags |= F_GLOBAL;
187           feature_infos[j].max_value = feature_infos[i].max_value;
188           feature_infos[j].default_value = feature_infos[i].default_value;
189         } else {
190           feature_infos[j].flags &amp;= ~F_GLOBAL;
191           feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);
192           /* Inherit default_value from j */
193         }
194         feature_infos[j].flags |= (feature_infos[i].flags &amp; F_HAS_FALLBACK);
195         feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);
196         feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);
197       }
198     feature_infos.shrink (j + 1);
199   }
200 
201 
202   /* Allocate bits now */
203   unsigned int next_bit = global_bit_shift + 1;
204 
<a name="17" id="anc17"></a><span class="line-modified">205   for (unsigned int i = 0; i &lt; feature_infos.length; i++)</span>
206   {
207     const feature_info_t *info = &amp;feature_infos[i];
208 
209     unsigned int bits_needed;
210 
211     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1)
212       /* Uses the global bit */
213       bits_needed = 0;
214     else
<a name="18" id="anc18"></a><span class="line-modified">215       /* Limit bits per feature. */</span>
<span class="line-modified">216       bits_needed = MIN(HB_OT_MAP_MAX_BITS, hb_bit_storage (info-&gt;max_value));</span>
217 
218     if (!info-&gt;max_value || next_bit + bits_needed &gt; 8 * sizeof (hb_mask_t))
219       continue; /* Feature disabled, or not enough bits. */
220 
221 
222     hb_bool_t found = false;
223     unsigned int feature_index[2];
224     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
225     {
226       if (required_feature_tag[table_index] == info-&gt;tag)
227         required_feature_stage[table_index] = info-&gt;stage[table_index];
228 
229       found |= hb_ot_layout_language_find_feature (face,
230                                                    table_tags[table_index],
231                                                    script_index[table_index],
232                                                    language_index[table_index],
233                                                    info-&gt;tag,
234                                                    &amp;feature_index[table_index]);
235     }
236     if (!found &amp;&amp; (info-&gt;flags &amp; F_GLOBAL_SEARCH))
237     {
238       for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
239       {
240         found |= hb_ot_layout_table_find_feature (face,
241                                                   table_tags[table_index],
242                                                   info-&gt;tag,
243                                                   &amp;feature_index[table_index]);
244       }
245     }
246     if (!found &amp;&amp; !(info-&gt;flags &amp; F_HAS_FALLBACK))
247       continue;
248 
249 
250     hb_ot_map_t::feature_map_t *map = m.features.push ();
251 
252     map-&gt;tag = info-&gt;tag;
253     map-&gt;index[0] = feature_index[0];
254     map-&gt;index[1] = feature_index[1];
255     map-&gt;stage[0] = info-&gt;stage[0];
256     map-&gt;stage[1] = info-&gt;stage[1];
257     map-&gt;auto_zwnj = !(info-&gt;flags &amp; F_MANUAL_ZWNJ);
258     map-&gt;auto_zwj = !(info-&gt;flags &amp; F_MANUAL_ZWJ);
<a name="19" id="anc19"></a><span class="line-added">259     map-&gt;random = !!(info-&gt;flags &amp; F_RANDOM);</span>
260     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1) {
261       /* Uses the global bit */
262       map-&gt;shift = global_bit_shift;
263       map-&gt;mask = global_bit_mask;
264     } else {
265       map-&gt;shift = next_bit;
266       map-&gt;mask = (1u &lt;&lt; (next_bit + bits_needed)) - (1u &lt;&lt; next_bit);
267       next_bit += bits_needed;
268       m.global_mask |= (info-&gt;default_value &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
269     }
270     map-&gt;_1_mask = (1u &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
271     map-&gt;needs_fallback = !found;
272 
273   }
274   feature_infos.shrink (0); /* Done with these */
275 
276 
277   add_gsub_pause (nullptr);
278   add_gpos_pause (nullptr);
279 
280   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
281   {
282     /* Collect lookup indices for features */
283 
<a name="20" id="anc20"></a>






284     unsigned int stage_index = 0;
285     unsigned int last_num_lookups = 0;
286     for (unsigned stage = 0; stage &lt; current_stage[table_index]; stage++)
287     {
288       if (required_feature_index[table_index] != HB_OT_LAYOUT_NO_FEATURE_INDEX &amp;&amp;
289           required_feature_stage[table_index] == stage)
290         add_lookups (m, table_index,
291                      required_feature_index[table_index],
<a name="21" id="anc21"></a><span class="line-modified">292                      key.variations_index[table_index],</span>
293                      global_bit_mask);
294 
<a name="22" id="anc22"></a><span class="line-modified">295       for (unsigned i = 0; i &lt; m.features.length; i++)</span>
296         if (m.features[i].stage[table_index] == stage)
297           add_lookups (m, table_index,
298                        m.features[i].index[table_index],
<a name="23" id="anc23"></a><span class="line-modified">299                        key.variations_index[table_index],</span>
300                        m.features[i].mask,
301                        m.features[i].auto_zwnj,
<a name="24" id="anc24"></a><span class="line-modified">302                        m.features[i].auto_zwj,</span>
<span class="line-added">303                        m.features[i].random);</span>
304 
305       /* Sort lookups and merge duplicates */
<a name="25" id="anc25"></a><span class="line-modified">306       if (last_num_lookups &lt; m.lookups[table_index].length)</span>
307       {
<a name="26" id="anc26"></a><span class="line-modified">308         m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].length);</span>
309 
310         unsigned int j = last_num_lookups;
<a name="27" id="anc27"></a><span class="line-modified">311         for (unsigned int i = j + 1; i &lt; m.lookups[table_index].length; i++)</span>
312           if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)
313             m.lookups[table_index][++j] = m.lookups[table_index][i];
314           else
315           {
316             m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;
317             m.lookups[table_index][j].auto_zwnj &amp;= m.lookups[table_index][i].auto_zwnj;
318             m.lookups[table_index][j].auto_zwj &amp;= m.lookups[table_index][i].auto_zwj;
319           }
320         m.lookups[table_index].shrink (j + 1);
321       }
322 
<a name="28" id="anc28"></a><span class="line-modified">323       last_num_lookups = m.lookups[table_index].length;</span>
324 
<a name="29" id="anc29"></a><span class="line-modified">325       if (stage_index &lt; stages[table_index].length &amp;&amp; stages[table_index][stage_index].index == stage) {</span>
326         hb_ot_map_t::stage_map_t *stage_map = m.stages[table_index].push ();
327         stage_map-&gt;last_lookup = last_num_lookups;
328         stage_map-&gt;pause_func = stages[table_index][stage_index].pause_func;
329 
330         stage_index++;
331       }
332     }
333   }
334 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
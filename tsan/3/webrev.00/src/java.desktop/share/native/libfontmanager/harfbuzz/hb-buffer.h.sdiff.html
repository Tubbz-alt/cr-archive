<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-buffer.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-common.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27  * Google Author(s): Behdad Esfahbod
 28  */
 29 
 30 #ifndef HB_H_IN
 31 #error &quot;Include &lt;hb.h&gt; instead.&quot;
 32 #endif
 33 
 34 #ifndef HB_BUFFER_H
 35 #define HB_BUFFER_H
 36 
 37 #include &quot;hb-common.h&quot;
 38 #include &quot;hb-unicode.h&quot;
 39 #include &quot;hb-font.h&quot;
 40 
 41 HB_BEGIN_DECLS
 42 
 43 /**
 44  * hb_glyph_info_t:
 45  * @codepoint: either a Unicode code point (before shaping) or a glyph index
 46  *             (after shaping).
<span class="line-removed"> 47  * @mask:</span>
 48  * @cluster: the index of the character in the original text that corresponds
 49  *           to this #hb_glyph_info_t, or whatever the client passes to
 50  *           hb_buffer_add(). More than one #hb_glyph_info_t can have the same
 51  *           @cluster value, if they resulted from the same character (e.g. one
 52  *           to many glyph substitution), and when more than one character gets
 53  *           merged in the same glyph (e.g. many to one glyph substitution) the
 54  *           #hb_glyph_info_t will have the smallest cluster value of them.
 55  *           By default some characters are merged into the same cluster
 56  *           (e.g. combining marks have the same cluster as their bases)
 57  *           even if they are separate glyphs, hb_buffer_set_cluster_level()
 58  *           allow selecting more fine-grained cluster handling.
 59  *
 60  * The #hb_glyph_info_t is the structure that holds information about the
 61  * glyphs and their relation to input text.
<span class="line-removed"> 62  *</span>
 63  */
<span class="line-modified"> 64 typedef struct hb_glyph_info_t {</span>

 65   hb_codepoint_t codepoint;
<span class="line-modified"> 66   hb_mask_t      mask; /* Holds hb_glyph_flags_t after hb_shape(), plus other things. */</span>


 67   uint32_t       cluster;
 68 
 69   /*&lt; private &gt;*/
 70   hb_var_int_t   var1;
 71   hb_var_int_t   var2;
 72 } hb_glyph_info_t;
 73 
 74 /**
 75  * hb_glyph_flags_t:
 76  * @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the
 77  *                                 beginning of the cluster this glyph is part of,
 78  *                                 then both sides need to be re-shaped, as the
 79  *                                 result might be different.  On the flip side,
 80  *                                 it means that when this flag is not present,
 81  *                                 then it&#39;s safe to break the glyph-run at the
 82  *                                 beginning of this cluster, and the two sides
 83  *                                 represent the exact same result one would get
 84  *                                 if breaking input text at the beginning of
 85  *                                 this cluster and shaping the two sides
 86  *                                 separately.  This can be used to optimize
 87  *                                 paragraph layout, by avoiding re-shaping
 88  *                                 of each line after line-breaking, or limiting
 89  *                                 the reshaping to a small piece around the
 90  *                                 breaking point only.



 91  */
 92 typedef enum { /*&lt; flags &gt;*/
 93   HB_GLYPH_FLAG_UNSAFE_TO_BREAK         = 0x00000001,
 94 
 95   HB_GLYPH_FLAG_DEFINED                 = 0x00000001 /* OR of all defined flags */
 96 } hb_glyph_flags_t;
 97 
 98 HB_EXTERN hb_glyph_flags_t
 99 hb_glyph_info_get_glyph_flags (const hb_glyph_info_t *info);
100 
101 #define hb_glyph_info_get_glyph_flags(info) \
102         ((hb_glyph_flags_t) ((unsigned int) (info)-&gt;mask &amp; HB_GLYPH_FLAG_DEFINED))
103 
104 
105 /**
106  * hb_glyph_position_t:
107  * @x_advance: how much the line advances after drawing this glyph when setting
108  *             text in horizontal direction.
109  * @y_advance: how much the line advances after drawing this glyph when setting
110  *             text in vertical direction.
</pre>
<hr />
<pre>
281  *                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes
282  *                      precedence over this flag. Since: 1.8.0
283  *
284  * Since: 0.9.20
285  */
286 typedef enum { /*&lt; flags &gt;*/
287   HB_BUFFER_FLAG_DEFAULT                        = 0x00000000u,
288   HB_BUFFER_FLAG_BOT                            = 0x00000001u, /* Beginning-of-text */
289   HB_BUFFER_FLAG_EOT                            = 0x00000002u, /* End-of-text */
290   HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES    = 0x00000004u,
291   HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES      = 0x00000008u
292 } hb_buffer_flags_t;
293 
294 HB_EXTERN void
295 hb_buffer_set_flags (hb_buffer_t       *buffer,
296                      hb_buffer_flags_t  flags);
297 
298 HB_EXTERN hb_buffer_flags_t
299 hb_buffer_get_flags (hb_buffer_t *buffer);
300 
<span class="line-modified">301 /*</span>








302  * Since: 0.9.42
303  */
304 typedef enum {
305   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES    = 0,
306   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS   = 1,
307   HB_BUFFER_CLUSTER_LEVEL_CHARACTERS            = 2,
308   HB_BUFFER_CLUSTER_LEVEL_DEFAULT = HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES
309 } hb_buffer_cluster_level_t;
310 
311 HB_EXTERN void
312 hb_buffer_set_cluster_level (hb_buffer_t               *buffer,
313                              hb_buffer_cluster_level_t  cluster_level);
314 
315 HB_EXTERN hb_buffer_cluster_level_t
316 hb_buffer_get_cluster_level (hb_buffer_t *buffer);
317 
318 /**
319  * HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT:
320  *
321  * The default code point for replacing invalid characters in a given encoding.
322  * Set to U+FFFD REPLACEMENT CHARACTER.
323  *
324  * Since: 0.9.31
325  */
326 #define HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT 0xFFFDu
327 
328 HB_EXTERN void
329 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
330                                      hb_codepoint_t  replacement);
331 
332 HB_EXTERN hb_codepoint_t
333 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer);
334 







335 
336 HB_EXTERN void
337 hb_buffer_reset (hb_buffer_t *buffer);
338 
339 HB_EXTERN void
340 hb_buffer_clear_contents (hb_buffer_t *buffer);
341 
342 HB_EXTERN hb_bool_t
343 hb_buffer_pre_allocate (hb_buffer_t  *buffer,
344                         unsigned int  size);
345 
346 
347 HB_EXTERN hb_bool_t
348 hb_buffer_allocation_successful (hb_buffer_t  *buffer);
349 
350 HB_EXTERN void
351 hb_buffer_reverse (hb_buffer_t *buffer);
352 
353 HB_EXTERN void
354 hb_buffer_reverse_range (hb_buffer_t *buffer,
</pre>
</td>
<td>
<hr />
<pre>
 27  * Google Author(s): Behdad Esfahbod
 28  */
 29 
 30 #ifndef HB_H_IN
 31 #error &quot;Include &lt;hb.h&gt; instead.&quot;
 32 #endif
 33 
 34 #ifndef HB_BUFFER_H
 35 #define HB_BUFFER_H
 36 
 37 #include &quot;hb-common.h&quot;
 38 #include &quot;hb-unicode.h&quot;
 39 #include &quot;hb-font.h&quot;
 40 
 41 HB_BEGIN_DECLS
 42 
 43 /**
 44  * hb_glyph_info_t:
 45  * @codepoint: either a Unicode code point (before shaping) or a glyph index
 46  *             (after shaping).

 47  * @cluster: the index of the character in the original text that corresponds
 48  *           to this #hb_glyph_info_t, or whatever the client passes to
 49  *           hb_buffer_add(). More than one #hb_glyph_info_t can have the same
 50  *           @cluster value, if they resulted from the same character (e.g. one
 51  *           to many glyph substitution), and when more than one character gets
 52  *           merged in the same glyph (e.g. many to one glyph substitution) the
 53  *           #hb_glyph_info_t will have the smallest cluster value of them.
 54  *           By default some characters are merged into the same cluster
 55  *           (e.g. combining marks have the same cluster as their bases)
 56  *           even if they are separate glyphs, hb_buffer_set_cluster_level()
 57  *           allow selecting more fine-grained cluster handling.
 58  *
 59  * The #hb_glyph_info_t is the structure that holds information about the
 60  * glyphs and their relation to input text.

 61  */
<span class="line-modified"> 62 typedef struct hb_glyph_info_t</span>
<span class="line-added"> 63 {</span>
 64   hb_codepoint_t codepoint;
<span class="line-modified"> 65   /*&lt; private &gt;*/</span>
<span class="line-added"> 66   hb_mask_t      mask;</span>
<span class="line-added"> 67   /*&lt; public &gt;*/</span>
 68   uint32_t       cluster;
 69 
 70   /*&lt; private &gt;*/
 71   hb_var_int_t   var1;
 72   hb_var_int_t   var2;
 73 } hb_glyph_info_t;
 74 
 75 /**
 76  * hb_glyph_flags_t:
 77  * @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the
 78  *                                 beginning of the cluster this glyph is part of,
 79  *                                 then both sides need to be re-shaped, as the
 80  *                                 result might be different.  On the flip side,
 81  *                                 it means that when this flag is not present,
 82  *                                 then it&#39;s safe to break the glyph-run at the
 83  *                                 beginning of this cluster, and the two sides
 84  *                                 represent the exact same result one would get
 85  *                                 if breaking input text at the beginning of
 86  *                                 this cluster and shaping the two sides
 87  *                                 separately.  This can be used to optimize
 88  *                                 paragraph layout, by avoiding re-shaping
 89  *                                 of each line after line-breaking, or limiting
 90  *                                 the reshaping to a small piece around the
 91  *                                 breaking point only.
<span class="line-added"> 92  * @HB_GLYPH_FLAG_DEFINED: All the currently defined flags.</span>
<span class="line-added"> 93  *</span>
<span class="line-added"> 94  * Since: 1.5.0</span>
 95  */
 96 typedef enum { /*&lt; flags &gt;*/
 97   HB_GLYPH_FLAG_UNSAFE_TO_BREAK         = 0x00000001,
 98 
 99   HB_GLYPH_FLAG_DEFINED                 = 0x00000001 /* OR of all defined flags */
100 } hb_glyph_flags_t;
101 
102 HB_EXTERN hb_glyph_flags_t
103 hb_glyph_info_get_glyph_flags (const hb_glyph_info_t *info);
104 
105 #define hb_glyph_info_get_glyph_flags(info) \
106         ((hb_glyph_flags_t) ((unsigned int) (info)-&gt;mask &amp; HB_GLYPH_FLAG_DEFINED))
107 
108 
109 /**
110  * hb_glyph_position_t:
111  * @x_advance: how much the line advances after drawing this glyph when setting
112  *             text in horizontal direction.
113  * @y_advance: how much the line advances after drawing this glyph when setting
114  *             text in vertical direction.
</pre>
<hr />
<pre>
285  *                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes
286  *                      precedence over this flag. Since: 1.8.0
287  *
288  * Since: 0.9.20
289  */
290 typedef enum { /*&lt; flags &gt;*/
291   HB_BUFFER_FLAG_DEFAULT                        = 0x00000000u,
292   HB_BUFFER_FLAG_BOT                            = 0x00000001u, /* Beginning-of-text */
293   HB_BUFFER_FLAG_EOT                            = 0x00000002u, /* End-of-text */
294   HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES    = 0x00000004u,
295   HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES      = 0x00000008u
296 } hb_buffer_flags_t;
297 
298 HB_EXTERN void
299 hb_buffer_set_flags (hb_buffer_t       *buffer,
300                      hb_buffer_flags_t  flags);
301 
302 HB_EXTERN hb_buffer_flags_t
303 hb_buffer_get_flags (hb_buffer_t *buffer);
304 
<span class="line-modified">305 /**</span>
<span class="line-added">306  * hb_buffer_cluster_level_t:</span>
<span class="line-added">307  * @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: Return cluster values grouped by graphemes into</span>
<span class="line-added">308  *   monotone order.</span>
<span class="line-added">309  * @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: Return cluster values grouped into monotone order.</span>
<span class="line-added">310  * @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: Don&#39;t group cluster values.</span>
<span class="line-added">311  * @HB_BUFFER_CLUSTER_LEVEL_DEFAULT: Default cluster level,</span>
<span class="line-added">312  *   equal to @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES.</span>
<span class="line-added">313  *</span>
314  * Since: 0.9.42
315  */
316 typedef enum {
317   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES    = 0,
318   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS   = 1,
319   HB_BUFFER_CLUSTER_LEVEL_CHARACTERS            = 2,
320   HB_BUFFER_CLUSTER_LEVEL_DEFAULT = HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES
321 } hb_buffer_cluster_level_t;
322 
323 HB_EXTERN void
324 hb_buffer_set_cluster_level (hb_buffer_t               *buffer,
325                              hb_buffer_cluster_level_t  cluster_level);
326 
327 HB_EXTERN hb_buffer_cluster_level_t
328 hb_buffer_get_cluster_level (hb_buffer_t *buffer);
329 
330 /**
331  * HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT:
332  *
333  * The default code point for replacing invalid characters in a given encoding.
334  * Set to U+FFFD REPLACEMENT CHARACTER.
335  *
336  * Since: 0.9.31
337  */
338 #define HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT 0xFFFDu
339 
340 HB_EXTERN void
341 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
342                                      hb_codepoint_t  replacement);
343 
344 HB_EXTERN hb_codepoint_t
345 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer);
346 
<span class="line-added">347 HB_EXTERN void</span>
<span class="line-added">348 hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,</span>
<span class="line-added">349                                hb_codepoint_t  invisible);</span>
<span class="line-added">350 </span>
<span class="line-added">351 HB_EXTERN hb_codepoint_t</span>
<span class="line-added">352 hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer);</span>
<span class="line-added">353 </span>
354 
355 HB_EXTERN void
356 hb_buffer_reset (hb_buffer_t *buffer);
357 
358 HB_EXTERN void
359 hb_buffer_clear_contents (hb_buffer_t *buffer);
360 
361 HB_EXTERN hb_bool_t
362 hb_buffer_pre_allocate (hb_buffer_t  *buffer,
363                         unsigned int  size);
364 
365 
366 HB_EXTERN hb_bool_t
367 hb_buffer_allocation_successful (hb_buffer_t  *buffer);
368 
369 HB_EXTERN void
370 hb_buffer_reverse (hb_buffer_t *buffer);
371 
372 HB_EXTERN void
373 hb_buffer_reverse_range (hb_buffer_t *buffer,
</pre>
</td>
</tr>
</table>
<center><a href="hb-buffer.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-common.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2018  Ebrahim Byagowi
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  */
 24 
 25 #ifndef HB_OT_COLOR_COLR_TABLE_HH
 26 #define HB_OT_COLOR_COLR_TABLE_HH
 27 
<a name="1" id="anc1"></a><span class="line-modified"> 28 #include &quot;hb-open-type.hh&quot;</span>
 29 
 30 /*
 31  * COLR -- Color
 32  * https://docs.microsoft.com/en-us/typography/opentype/spec/colr
 33  */
 34 #define HB_OT_TAG_COLR HB_TAG(&#39;C&#39;,&#39;O&#39;,&#39;L&#39;,&#39;R&#39;)
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 struct LayerRecord
 41 {
<a name="2" id="anc2"></a><span class="line-modified"> 42   bool sanitize (hb_sanitize_context_t *c) const</span>


 43   {
 44     TRACE_SANITIZE (this);
 45     return_trace (c-&gt;check_struct (this));
 46   }
 47 
<a name="3" id="anc3"></a><span class="line-modified"> 48   public:</span>
<span class="line-modified"> 49   GlyphID       glyphId;        /* Glyph ID of layer glyph */</span>
<span class="line-modified"> 50   Index         colorIdx;       /* Index value to use with a</span>
<span class="line-added"> 51                                  * selected color palette.</span>
<span class="line-added"> 52                                  * An index value of 0xFFFF</span>
<span class="line-added"> 53                                  * is a special case indicating</span>
<span class="line-added"> 54                                  * that the text foreground</span>
<span class="line-added"> 55                                  * color (defined by a</span>
<span class="line-added"> 56                                  * higher-level client) should</span>
<span class="line-added"> 57                                  * be used and shall not be</span>
<span class="line-added"> 58                                  * treated as actual index</span>
<span class="line-added"> 59                                  * into CPAL ColorRecord array. */</span>
 60   public:
 61   DEFINE_SIZE_STATIC (4);
 62 };
 63 
 64 struct BaseGlyphRecord
 65 {
<a name="4" id="anc4"></a><span class="line-modified"> 66   int cmp (hb_codepoint_t g) const</span>
<span class="line-added"> 67   { return g &lt; glyphId ? -1 : g &gt; glyphId ? 1 : 0; }</span>
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69   bool sanitize (hb_sanitize_context_t *c) const</span>
 70   {
 71     TRACE_SANITIZE (this);
 72     return_trace (likely (c-&gt;check_struct (this)));
 73   }
 74 
<a name="6" id="anc6"></a><span class="line-modified"> 75   public:</span>
<span class="line-modified"> 76   GlyphID       glyphId;        /* Glyph ID of reference glyph */</span>
<span class="line-modified"> 77   HBUINT16      firstLayerIdx;  /* Index (from beginning of</span>
<span class="line-modified"> 78                                  * the Layer Records) to the</span>
<span class="line-modified"> 79                                  * layer record. There will be</span>
<span class="line-modified"> 80                                  * numLayers consecutive entries</span>
<span class="line-modified"> 81                                  * for this base glyph. */</span>
<span class="line-modified"> 82   HBUINT16      numLayers;      /* Number of color layers</span>
<span class="line-added"> 83                                  * associated with this glyph */</span>
 84   public:
 85   DEFINE_SIZE_STATIC (6);
 86 };
 87 
<a name="7" id="anc7"></a>






 88 struct COLR
 89 {
<a name="8" id="anc8"></a><span class="line-modified"> 90   static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;</span>
 91 
<a name="9" id="anc9"></a><span class="line-modified"> 92   bool has_data () const { return numBaseGlyphs; }</span>






 93 
<a name="10" id="anc10"></a><span class="line-modified"> 94   unsigned int get_glyph_layers (hb_codepoint_t       glyph,</span>
<span class="line-modified"> 95                                  unsigned int         start_offset,</span>
<span class="line-modified"> 96                                  unsigned int        *count, /* IN/OUT.  May be NULL. */</span>
<span class="line-added"> 97                                  hb_ot_color_layer_t *layers /* OUT.     May be NULL. */) const</span>
 98   {
<a name="11" id="anc11"></a><span class="line-modified"> 99     const BaseGlyphRecord &amp;record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);</span>









100 
<a name="12" id="anc12"></a><span class="line-modified">101     hb_array_t&lt;const LayerRecord&gt; all_layers ((this+layersZ).arrayZ, numLayers);</span>
<span class="line-modified">102     hb_array_t&lt;const LayerRecord&gt; glyph_layers = all_layers.sub_array (record.firstLayerIdx,</span>
<span class="line-modified">103                                                                        record.numLayers);</span>
<span class="line-modified">104     if (count)</span>

105     {
<a name="13" id="anc13"></a><span class="line-modified">106       hb_array_t&lt;const LayerRecord&gt; segment_layers = glyph_layers.sub_array (start_offset, *count);</span>
<span class="line-modified">107       *count = segment_layers.length;</span>
<span class="line-modified">108       for (unsigned int i = 0; i &lt; segment_layers.length; i++)</span>
<span class="line-added">109       {</span>
<span class="line-added">110         layers[i].glyph = segment_layers.arrayZ[i].glyphId;</span>
<span class="line-added">111         layers[i].color_index = segment_layers.arrayZ[i].colorIdx;</span>
<span class="line-added">112       }</span>
113     }
<a name="14" id="anc14"></a><span class="line-modified">114     return glyph_layers.length;</span>
<span class="line-modified">115   }</span>
<span class="line-modified">116 </span>
<span class="line-modified">117   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">118   {</span>
<span class="line-added">119     TRACE_SANITIZE (this);</span>
<span class="line-added">120     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">121                           (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &amp;&amp;</span>
<span class="line-added">122                           (this+layersZ).sanitize (c, numLayers)));</span>
123   }
124 
125   protected:
<a name="15" id="anc15"></a><span class="line-modified">126   HBUINT16      version;        /* Table version number (starts at 0). */</span>
<span class="line-modified">127   HBUINT16      numBaseGlyphs;  /* Number of Base Glyph Records. */</span>
<span class="line-modified">128   LNNOffsetTo&lt;SortedUnsizedArrayOf&lt;BaseGlyphRecord&gt; &gt;</span>
129                 baseGlyphsZ;    /* Offset to Base Glyph records. */
<a name="16" id="anc16"></a><span class="line-modified">130   LNNOffsetTo&lt;UnsizedArrayOf&lt;LayerRecord&gt; &gt;</span>
<span class="line-modified">131                 layersZ;        /* Offset to Layer Records. */</span>
<span class="line-modified">132   HBUINT16      numLayers;      /* Number of Layer Records. */</span>
133   public:
134   DEFINE_SIZE_STATIC (14);
135 };
136 
137 } /* namespace OT */
138 
139 
140 #endif /* HB_OT_COLOR_COLR_TABLE_HH */
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
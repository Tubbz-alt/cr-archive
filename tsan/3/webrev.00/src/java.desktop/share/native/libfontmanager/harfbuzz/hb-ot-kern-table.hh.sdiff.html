<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-hmtx-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-base-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_KERN_TABLE_HH
 28 #define HB_OT_KERN_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>

 31 
 32 /*
 33  * kern -- Kerning
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
 35  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
 36  */
 37 #define HB_OT_TAG_kern HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;)
 38 
 39 
 40 namespace OT {
 41 
 42 
<span class="line-modified"> 43 struct hb_glyph_pair_t</span>
<span class="line-modified"> 44 {</span>
<span class="line-removed"> 45   hb_codepoint_t left;</span>
<span class="line-removed"> 46   hb_codepoint_t right;</span>
<span class="line-removed"> 47 };</span>
<span class="line-removed"> 48 </span>
<span class="line-removed"> 49 struct KernPair</span>
<span class="line-removed"> 50 {</span>
<span class="line-removed"> 51   inline int get_kerning (void) const</span>
<span class="line-removed"> 52   { return value; }</span>
<span class="line-removed"> 53 </span>
<span class="line-removed"> 54   inline int cmp (const hb_glyph_pair_t &amp;o) const</span>
<span class="line-removed"> 55   {</span>
<span class="line-removed"> 56     int ret = left.cmp (o.left);</span>
<span class="line-removed"> 57     if (ret) return ret;</span>
<span class="line-removed"> 58     return right.cmp (o.right);</span>
<span class="line-removed"> 59   }</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed"> 62   {</span>
<span class="line-removed"> 63     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 64     return_trace (c-&gt;check_struct (this));</span>
<span class="line-removed"> 65   }</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   protected:</span>
<span class="line-removed"> 68   GlyphID       left;</span>
<span class="line-removed"> 69   GlyphID       right;</span>
<span class="line-removed"> 70   FWORD         value;</span>
<span class="line-removed"> 71   public:</span>
<span class="line-removed"> 72   DEFINE_SIZE_STATIC (6);</span>
<span class="line-removed"> 73 };</span>
<span class="line-removed"> 74 </span>
<span class="line-removed"> 75 struct KernSubTableFormat0</span>
 76 {
<span class="line-modified"> 77   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
 78   {
<span class="line-modified"> 79     hb_glyph_pair_t pair = {left, right};</span>
<span class="line-modified"> 80     int i = pairs.bsearch (pair);</span>
<span class="line-modified"> 81     if (i == -1)</span>





 82       return 0;
<span class="line-modified"> 83     return pairs[i].get_kerning ();</span>

 84   }
 85 
<span class="line-modified"> 86   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 87   {
<span class="line-modified"> 88     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 89     return_trace (pairs.sanitize (c));</span>
<span class="line-removed"> 90   }</span>
<span class="line-removed"> 91 </span>
<span class="line-removed"> 92   protected:</span>
<span class="line-removed"> 93   BinSearchArrayOf&lt;KernPair&gt; pairs;     /* Array of kerning pairs. */</span>
<span class="line-removed"> 94   public:</span>
<span class="line-removed"> 95   DEFINE_SIZE_ARRAY (8, pairs);</span>
<span class="line-removed"> 96 };</span>
 97 
<span class="line-modified"> 98 struct KernClassTable</span>
<span class="line-modified"> 99 {</span>
<span class="line-removed">100   inline unsigned int get_class (hb_codepoint_t g) const { return classes[g - firstGlyph]; }</span>
101 
<span class="line-modified">102   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">103   {</span>
<span class="line-removed">104     TRACE_SANITIZE (this);</span>
<span class="line-removed">105     return_trace (firstGlyph.sanitize (c) &amp;&amp; classes.sanitize (c));</span>
<span class="line-removed">106   }</span>
107 
<span class="line-modified">108   protected:</span>
<span class="line-modified">109   HBUINT16              firstGlyph;     /* First glyph in class range. */</span>
<span class="line-removed">110   ArrayOf&lt;HBUINT16&gt;     classes;        /* Glyph classes. */</span>
<span class="line-removed">111   public:</span>
<span class="line-removed">112   DEFINE_SIZE_ARRAY (4, classes);</span>
<span class="line-removed">113 };</span>
114 
<span class="line-modified">115 struct KernSubTableFormat2</span>
<span class="line-removed">116 {</span>
<span class="line-removed">117   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-removed">118   {</span>
<span class="line-removed">119     unsigned int l = (this+leftClassTable).get_class (left);</span>
<span class="line-removed">120     unsigned int r = (this+rightClassTable).get_class (right);</span>
<span class="line-removed">121     unsigned int offset = l * rowWidth + r * sizeof (FWORD);</span>
<span class="line-removed">122     const FWORD *arr = &amp;(this+array);</span>
<span class="line-removed">123     if (unlikely ((const void *) arr &lt; (const void *) this || (const void *) arr &gt;= (const void *) end))</span>
<span class="line-removed">124       return 0;</span>
<span class="line-removed">125     const FWORD *v = &amp;StructAtOffset&lt;FWORD&gt; (arr, offset);</span>
<span class="line-removed">126     if (unlikely ((const void *) v &lt; (const void *) arr || (const void *) (v + 1) &gt; (const void *) end))</span>
<span class="line-removed">127       return 0;</span>
<span class="line-removed">128     return *v;</span>
129   }
130 
<span class="line-modified">131   inline bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
<span class="line-modified">134     return_trace (rowWidth.sanitize (c) &amp;&amp;</span>
<span class="line-modified">135                   leftClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">136                   rightClassTable.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">137                   array.sanitize (c, this));</span>

138   }
139 
140   protected:
<span class="line-modified">141   HBUINT16      rowWidth;       /* The width, in bytes, of a row in the table. */</span>
<span class="line-modified">142   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">143                 leftClassTable; /* Offset from beginning of this subtable to</span>
<span class="line-modified">144                                  * left-hand class table. */</span>
<span class="line-modified">145   OffsetTo&lt;KernClassTable&gt;</span>
<span class="line-modified">146                 rightClassTable;/* Offset from beginning of this subtable to</span>
<span class="line-modified">147                                  * right-hand class table. */</span>
<span class="line-modified">148   OffsetTo&lt;FWORD&gt;</span>
<span class="line-modified">149                 array;          /* Offset from beginning of this subtable to</span>
<span class="line-modified">150                                  * the start of the kerning array. */</span>






151   public:
<span class="line-modified">152   DEFINE_SIZE_MIN (8);</span>
153 };
154 

155 struct KernSubTable
156 {
<span class="line-modified">157   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end, unsigned int format) const</span>



158   {
<span class="line-modified">159     switch (format) {</span>

160     case 0: return u.format0.get_kerning (left, right);
<span class="line-removed">161     case 2: return u.format2.get_kerning (left, right, end);</span>
162     default:return 0;
163     }
164   }
165 
<span class="line-modified">166   inline bool sanitize (hb_sanitize_context_t *c, unsigned int format) const</span>

167   {
<span class="line-modified">168     TRACE_SANITIZE (this);</span>
<span class="line-modified">169     switch (format) {</span>
<span class="line-modified">170     case 0: return_trace (u.format0.sanitize (c));</span>
<span class="line-modified">171     case 2: return_trace (u.format2.sanitize (c));</span>
<span class="line-modified">172     default:return_trace (true);</span>



173     }
174   }
175 
<span class="line-modified">176   protected:</span>










177   union {
<span class="line-modified">178   KernSubTableFormat0   format0;</span>
<span class="line-modified">179   KernSubTableFormat2   format2;</span>



180   } u;
181   public:
<span class="line-modified">182   DEFINE_SIZE_MIN (0);</span>
183 };
184 
185 
<span class="line-modified">186 template &lt;typename T&gt;</span>
<span class="line-removed">187 struct KernSubTableWrapper</span>
188 {
<span class="line-modified">189   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-modified">190   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192   inline bool is_horizontal (void) const</span>
<span class="line-removed">193   { return (thiz()-&gt;coverage &amp; T::COVERAGE_CHECK_FLAGS) == T::COVERAGE_CHECK_HORIZONTAL; }</span>
194 
<span class="line-modified">195   inline bool is_override (void) const</span>
<span class="line-modified">196   { return bool (thiz()-&gt;coverage &amp; T::COVERAGE_OVERRIDE_FLAG); }</span>
197 
<span class="line-modified">198   inline int get_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">199   { return thiz()-&gt;subtable.get_kerning (left, right, end, thiz()-&gt;format); }</span>
<span class="line-modified">200 </span>
<span class="line-modified">201   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, const char *end) const</span>
<span class="line-modified">202   { return is_horizontal () ? get_kerning (left, right, end) : 0; }</span>
<span class="line-modified">203 </span>
<span class="line-modified">204   inline unsigned int get_size (void) const { return thiz()-&gt;length; }</span>




205 
<span class="line-modified">206   inline bool sanitize (hb_sanitize_context_t *c) const</span>
207   {
208     TRACE_SANITIZE (this);
<span class="line-modified">209     return_trace (c-&gt;check_struct (thiz()) &amp;&amp;</span>
<span class="line-removed">210                   thiz()-&gt;length &gt;= T::min_size &amp;&amp;</span>
<span class="line-removed">211                   c-&gt;check_array (thiz(), 1, thiz()-&gt;length) &amp;&amp;</span>
<span class="line-removed">212                   thiz()-&gt;subtable.sanitize (c, thiz()-&gt;format));</span>
213   }








214 };
215 
<span class="line-modified">216 template &lt;typename T&gt;</span>
<span class="line-removed">217 struct KernTable</span>
218 {
<span class="line-modified">219   /* https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern */</span>
<span class="line-removed">220   inline const T* thiz (void) const { return static_cast&lt;const T *&gt; (this); }</span>
221 
<span class="line-modified">222   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>
<span class="line-modified">223   {</span>
<span class="line-removed">224     int v = 0;</span>
<span class="line-removed">225     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">226     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">227     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">228     {</span>
<span class="line-removed">229       if (st-&gt;is_override ())</span>
<span class="line-removed">230         v = 0;</span>
<span class="line-removed">231       v += st-&gt;get_h_kerning (left, right, table_length + (const char *) this);</span>
<span class="line-removed">232       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">233     }</span>
<span class="line-removed">234     return v;</span>
<span class="line-removed">235   }</span>
236 
<span class="line-modified">237   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">238   {</span>
<span class="line-modified">239     TRACE_SANITIZE (this);</span>
<span class="line-removed">240     if (unlikely (!c-&gt;check_struct (thiz()) ||</span>
<span class="line-removed">241                   thiz()-&gt;version != T::VERSION))</span>
<span class="line-removed">242       return_trace (false);</span>
<span class="line-removed">243 </span>
<span class="line-removed">244     const typename T::SubTableWrapper *st = CastP&lt;typename T::SubTableWrapper&gt; (thiz()-&gt;data);</span>
<span class="line-removed">245     unsigned int count = thiz()-&gt;nTables;</span>
<span class="line-removed">246     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">247     {</span>
<span class="line-removed">248       if (unlikely (!st-&gt;sanitize (c)))</span>
<span class="line-removed">249         return_trace (false);</span>
<span class="line-removed">250       st = &amp;StructAfter&lt;typename T::SubTableWrapper&gt; (*st);</span>
<span class="line-removed">251     }</span>
252 
<span class="line-modified">253     return_trace (true);</span>
<span class="line-modified">254   }</span>




255 };
256 
<span class="line-modified">257 struct KernOT : KernTable&lt;KernOT&gt;</span>

258 {
<span class="line-modified">259   friend struct KernTable&lt;KernOT&gt;;</span>

260 
<span class="line-modified">261   static const uint16_t VERSION = 0x0000u;</span>

262 
<span class="line-modified">263   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
264   {
<span class="line-modified">265     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-modified">266 </span>
<span class="line-modified">267     enum coverage_flags_t {</span>
<span class="line-modified">268       COVERAGE_DIRECTION_FLAG   = 0x01u,</span>
<span class="line-modified">269       COVERAGE_MINIMUM_FLAG     = 0x02u,</span>
<span class="line-modified">270       COVERAGE_CROSSSTREAM_FLAG = 0x04u,</span>
<span class="line-removed">271       COVERAGE_OVERRIDE_FLAG    = 0x08u,</span>
<span class="line-removed">272 </span>
<span class="line-removed">273       COVERAGE_VARIATION_FLAG   = 0x00u, /* Not supported. */</span>
<span class="line-removed">274 </span>
<span class="line-removed">275       COVERAGE_CHECK_FLAGS      = 0x07u,</span>
<span class="line-removed">276       COVERAGE_CHECK_HORIZONTAL = 0x01u</span>
<span class="line-removed">277     };</span>
<span class="line-removed">278 </span>
<span class="line-removed">279     protected:</span>
<span class="line-removed">280     HBUINT16    versionZ;       /* Unused. */</span>
<span class="line-removed">281     HBUINT16    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">282     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">283     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">284     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">285     public:</span>
<span class="line-removed">286     DEFINE_SIZE_MIN (6);</span>
287   };
288 
<span class="line-modified">289   protected:</span>
<span class="line-modified">290   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-modified">291   HBUINT16      nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">292   HBUINT8               data[VAR];</span>









293   public:
<span class="line-modified">294   DEFINE_SIZE_ARRAY (4, data);</span>
295 };
296 
<span class="line-modified">297 struct KernAAT : KernTable&lt;KernAAT&gt;</span>
298 {
<span class="line-modified">299   friend struct KernTable&lt;KernAAT&gt;;</span>
300 
<span class="line-modified">301   static const uint32_t VERSION = 0x00010000u;</span>

302 
<span class="line-modified">303   struct SubTableWrapper : KernSubTableWrapper&lt;SubTableWrapper&gt;</span>
<span class="line-modified">304   {</span>
<span class="line-modified">305     friend struct KernSubTableWrapper&lt;SubTableWrapper&gt;;</span>
<span class="line-removed">306 </span>
<span class="line-removed">307     enum coverage_flags_t {</span>
<span class="line-removed">308       COVERAGE_DIRECTION_FLAG   = 0x80u,</span>
<span class="line-removed">309       COVERAGE_CROSSSTREAM_FLAG = 0x40u,</span>
<span class="line-removed">310       COVERAGE_VARIATION_FLAG   = 0x20u,</span>
<span class="line-removed">311 </span>
<span class="line-removed">312       COVERAGE_OVERRIDE_FLAG    = 0x00u, /* Not supported. */</span>
<span class="line-removed">313 </span>
<span class="line-removed">314       COVERAGE_CHECK_FLAGS      = 0xE0u,</span>
<span class="line-removed">315       COVERAGE_CHECK_HORIZONTAL = 0x00u</span>
<span class="line-removed">316     };</span>
<span class="line-removed">317 </span>
<span class="line-removed">318     protected:</span>
<span class="line-removed">319     HBUINT32    length;         /* Length of the subtable (including this header). */</span>
<span class="line-removed">320     HBUINT8     coverage;       /* Coverage bits. */</span>
<span class="line-removed">321     HBUINT8     format;         /* Subtable format. */</span>
<span class="line-removed">322     HBUINT16    tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-removed">323                                  * This value specifies which tuple this subtable covers. */</span>
<span class="line-removed">324     KernSubTable subtable;      /* Subtable data. */</span>
<span class="line-removed">325     public:</span>
<span class="line-removed">326     DEFINE_SIZE_MIN (8);</span>
<span class="line-removed">327   };</span>
328 
329   protected:
<span class="line-modified">330   HBUINT32              version;        /* Version--0x00010000u */</span>
<span class="line-modified">331   HBUINT32              nTables;        /* Number of subtables in the kerning table. */</span>
<span class="line-modified">332   HBUINT8               data[VAR];</span>
333   public:
<span class="line-modified">334   DEFINE_SIZE_ARRAY (8, data);</span>
335 };
336 
337 struct kern
338 {
<span class="line-modified">339   static const hb_tag_t tableTag = HB_OT_TAG_kern;</span>
340 
<span class="line-modified">341   inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right, unsigned int table_length) const</span>



342   {
<span class="line-modified">343     switch (u.major) {</span>
<span class="line-modified">344     case 0: return u.ot.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">345     case 1: return u.aat.get_h_kerning (left, right, table_length);</span>
<span class="line-modified">346     default:return 0;</span>
347     }
348   }
349 
<span class="line-modified">350   inline bool sanitize (hb_sanitize_context_t *c) const</span>
351   {
<span class="line-modified">352     TRACE_SANITIZE (this);</span>
<span class="line-modified">353     if (!u.major.sanitize (c)) return_trace (false);</span>
<span class="line-modified">354     switch (u.major) {</span>
<span class="line-modified">355     case 0: return_trace (u.ot.sanitize (c));</span>
<span class="line-removed">356     case 1: return_trace (u.aat.sanitize (c));</span>
<span class="line-removed">357     default:return_trace (true);</span>
358     }
359   }
360 
<span class="line-modified">361   struct accelerator_t</span>
362   {
<span class="line-modified">363     inline void init (hb_face_t *face)</span>
<span class="line-modified">364     {</span>
<span class="line-modified">365       blob = Sanitizer&lt;kern&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_kern));</span>
<span class="line-modified">366       table = blob-&gt;as&lt;kern&gt; ();</span>
<span class="line-removed">367       table_length = blob-&gt;length;</span>
<span class="line-removed">368     }</span>
<span class="line-removed">369     inline void fini (void)</span>
<span class="line-removed">370     {</span>
<span class="line-removed">371       hb_blob_destroy (blob);</span>
372     }

373 
<span class="line-modified">374     inline int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
<span class="line-modified">375     { return table-&gt;get_h_kerning (left, right, table_length); }</span>
376 
<span class="line-modified">377     private:</span>
<span class="line-modified">378     hb_blob_t *blob;</span>
<span class="line-modified">379     const kern *table;</span>
<span class="line-modified">380     unsigned int table_length;</span>
<span class="line-modified">381   };</span>













382 
383   protected:
384   union {

385   HBUINT16              major;
386   KernOT                ot;
387   KernAAT               aat;
388   } u;
389   public:
<span class="line-modified">390   DEFINE_SIZE_UNION (2, major);</span>
391 };
392 
393 } /* namespace OT */
394 
395 
396 #endif /* HB_OT_KERN_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_KERN_TABLE_HH
 28 #define HB_OT_KERN_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-aat-layout-kerx-table.hh&quot;</span>
<span class="line-added"> 31 </span>
 32 
 33 /*
 34  * kern -- Kerning
 35  * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
 36  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
 37  */
 38 #define HB_OT_TAG_kern HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;)
 39 
 40 
 41 namespace OT {
 42 
 43 
<span class="line-modified"> 44 template &lt;typename KernSubTableHeader&gt;</span>
<span class="line-modified"> 45 struct KernSubTableFormat3</span>































 46 {
<span class="line-modified"> 47   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
 48   {
<span class="line-modified"> 49     hb_array_t&lt;const FWORD&gt; kernValue = kernValueZ.as_array (kernValueCount);</span>
<span class="line-modified"> 50     hb_array_t&lt;const HBUINT8&gt; leftClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (kernValue).as_array (glyphCount);</span>
<span class="line-modified"> 51     hb_array_t&lt;const HBUINT8&gt; rightClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (leftClass).as_array (glyphCount);</span>
<span class="line-added"> 52     hb_array_t&lt;const HBUINT8&gt; kernIndex = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (rightClass).as_array (leftClassCount * rightClassCount);</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54     unsigned int leftC = leftClass[left];</span>
<span class="line-added"> 55     unsigned int rightC = rightClass[right];</span>
<span class="line-added"> 56     if (unlikely (leftC &gt;= leftClassCount || rightC &gt;= rightClassCount))</span>
 57       return 0;
<span class="line-modified"> 58     unsigned int i = leftC * rightClassCount + rightC;</span>
<span class="line-added"> 59     return kernValue[kernIndex[i]];</span>
 60   }
 61 
<span class="line-modified"> 62   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
 63   {
<span class="line-modified"> 64     TRACE_APPLY (this);</span>








 65 
<span class="line-modified"> 66     if (!c-&gt;plan-&gt;requested_kerning)</span>
<span class="line-modified"> 67       return false;</span>

 68 
<span class="line-modified"> 69     if (header.coverage &amp; header.Backwards)</span>
<span class="line-modified"> 70       return false;</span>



 71 
<span class="line-modified"> 72     hb_kern_machine_t&lt;KernSubTableFormat3&gt; machine (*this, header.coverage &amp; header.CrossStream);</span>
<span class="line-modified"> 73     machine.kern (c-&gt;font, c-&gt;buffer, c-&gt;plan-&gt;kern_mask);</span>




 74 
<span class="line-modified"> 75     return_trace (true);</span>













 76   }
 77 
<span class="line-modified"> 78   bool sanitize (hb_sanitize_context_t *c) const</span>
 79   {
 80     TRACE_SANITIZE (this);
<span class="line-modified"> 81     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified"> 82                   c-&gt;check_range (kernValueZ,</span>
<span class="line-modified"> 83                                   kernValueCount * sizeof (FWORD) +</span>
<span class="line-modified"> 84                                   glyphCount * 2 +</span>
<span class="line-added"> 85                                   leftClassCount * rightClassCount));</span>
 86   }
 87 
 88   protected:
<span class="line-modified"> 89   KernSubTableHeader    header;</span>
<span class="line-modified"> 90   HBUINT16              glyphCount;     /* The number of glyphs in this font. */</span>
<span class="line-modified"> 91   HBUINT8               kernValueCount; /* The number of kerning values. */</span>
<span class="line-modified"> 92   HBUINT8               leftClassCount; /* The number of left-hand classes. */</span>
<span class="line-modified"> 93   HBUINT8               rightClassCount;/* The number of right-hand classes. */</span>
<span class="line-modified"> 94   HBUINT8               flags;          /* Set to zero (reserved for future use). */</span>
<span class="line-modified"> 95   UnsizedArrayOf&lt;FWORD&gt; kernValueZ;     /* The kerning values.</span>
<span class="line-modified"> 96                                          * Length kernValueCount. */</span>
<span class="line-modified"> 97 #if 0</span>
<span class="line-modified"> 98   UnsizedArrayOf&lt;HBUINT8&gt;leftClass;     /* The left-hand classes.</span>
<span class="line-added"> 99                                          * Length glyphCount. */</span>
<span class="line-added">100   UnsizedArrayOf&lt;HBUINT8&gt;rightClass;    /* The right-hand classes.</span>
<span class="line-added">101                                          * Length glyphCount. */</span>
<span class="line-added">102   UnsizedArrayOf&lt;HBUINT8&gt;kernIndex;     /* The indices into the kernValue array.</span>
<span class="line-added">103                                          * Length leftClassCount * rightClassCount */</span>
<span class="line-added">104 #endif</span>
105   public:
<span class="line-modified">106   DEFINE_SIZE_ARRAY (KernSubTableHeader::static_size + 6, kernValueZ);</span>
107 };
108 
<span class="line-added">109 template &lt;typename KernSubTableHeader&gt;</span>
110 struct KernSubTable
111 {
<span class="line-modified">112   unsigned int get_size () const { return u.header.length; }</span>
<span class="line-added">113   unsigned int get_type () const { return u.header.format; }</span>
<span class="line-added">114 </span>
<span class="line-added">115   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
116   {
<span class="line-modified">117     switch (get_type ()) {</span>
<span class="line-added">118     /* This method hooks up to hb_font_t&#39;s get_h_kerning.  Only support Format0. */</span>
119     case 0: return u.format0.get_kerning (left, right);

120     default:return 0;
121     }
122   }
123 
<span class="line-modified">124   template &lt;typename context_t&gt;</span>
<span class="line-added">125   typename context_t::return_t dispatch (context_t *c) const</span>
126   {
<span class="line-modified">127     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">128     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-modified">129     switch (subtable_type) {</span>
<span class="line-modified">130     case 0:     return_trace (c-&gt;dispatch (u.format0));</span>
<span class="line-modified">131     case 1:     return_trace (u.header.apple ? c-&gt;dispatch (u.format1) : c-&gt;default_return_value ());</span>
<span class="line-added">132     case 2:     return_trace (c-&gt;dispatch (u.format2));</span>
<span class="line-added">133     case 3:     return_trace (u.header.apple ? c-&gt;dispatch (u.format3) : c-&gt;default_return_value ());</span>
<span class="line-added">134     default:    return_trace (c-&gt;default_return_value ());</span>
135     }
136   }
137 
<span class="line-modified">138   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">139   {</span>
<span class="line-added">140     TRACE_SANITIZE (this);</span>
<span class="line-added">141     if (unlikely (!u.header.sanitize (c) ||</span>
<span class="line-added">142                   u.header.length &lt; u.header.min_size ||</span>
<span class="line-added">143                   !c-&gt;check_range (this, u.header.length))) return_trace (false);</span>
<span class="line-added">144 </span>
<span class="line-added">145     return_trace (dispatch (c));</span>
<span class="line-added">146   }</span>
<span class="line-added">147 </span>
<span class="line-added">148   public:</span>
149   union {
<span class="line-modified">150   KernSubTableHeader                            header;</span>
<span class="line-modified">151   AAT::KerxSubTableFormat0&lt;KernSubTableHeader&gt;  format0;</span>
<span class="line-added">152   AAT::KerxSubTableFormat1&lt;KernSubTableHeader&gt;  format1;</span>
<span class="line-added">153   AAT::KerxSubTableFormat2&lt;KernSubTableHeader&gt;  format2;</span>
<span class="line-added">154   KernSubTableFormat3&lt;KernSubTableHeader&gt;       format3;</span>
155   } u;
156   public:
<span class="line-modified">157   DEFINE_SIZE_MIN (KernSubTableHeader::static_size);</span>
158 };
159 
160 
<span class="line-modified">161 struct KernOTSubTableHeader</span>

162 {
<span class="line-modified">163   static constexpr bool apple = false;</span>
<span class="line-modified">164   typedef AAT::ObsoleteTypes Types;</span>



165 
<span class="line-modified">166   unsigned int tuple_count () const { return 0; }</span>
<span class="line-modified">167   bool is_horizontal () const { return (coverage &amp; Horizontal); }</span>
168 
<span class="line-modified">169   enum Coverage</span>
<span class="line-modified">170   {</span>
<span class="line-modified">171     Horizontal  = 0x01u,</span>
<span class="line-modified">172     Minimum     = 0x02u,</span>
<span class="line-modified">173     CrossStream = 0x04u,</span>
<span class="line-modified">174     Override    = 0x08u,</span>
<span class="line-modified">175 </span>
<span class="line-added">176     /* Not supported: */</span>
<span class="line-added">177     Backwards   = 0x00u,</span>
<span class="line-added">178     Variation   = 0x00u,</span>
<span class="line-added">179   };</span>
180 
<span class="line-modified">181   bool sanitize (hb_sanitize_context_t *c) const</span>
182   {
183     TRACE_SANITIZE (this);
<span class="line-modified">184     return_trace (c-&gt;check_struct (this));</span>



185   }
<span class="line-added">186 </span>
<span class="line-added">187   public:</span>
<span class="line-added">188   HBUINT16      versionZ;       /* Unused. */</span>
<span class="line-added">189   HBUINT16      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">190   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">191   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">192   public:</span>
<span class="line-added">193   DEFINE_SIZE_STATIC (6);</span>
194 };
195 
<span class="line-modified">196 struct KernOT : AAT::KerxTable&lt;KernOT&gt;</span>

197 {
<span class="line-modified">198   friend struct AAT::KerxTable&lt;KernOT&gt;;</span>

199 
<span class="line-modified">200   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-modified">201   static constexpr unsigned minVersion = 0u;</span>












202 
<span class="line-modified">203   typedef KernOTSubTableHeader SubTableHeader;</span>
<span class="line-modified">204   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">205   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>












206 
<span class="line-modified">207   protected:</span>
<span class="line-modified">208   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-added">209   HBUINT16      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-added">210   SubTable      firstSubTable;  /* Subtables. */</span>
<span class="line-added">211   public:</span>
<span class="line-added">212   DEFINE_SIZE_MIN (4);</span>
213 };
214 
<span class="line-modified">215 </span>
<span class="line-added">216 struct KernAATSubTableHeader</span>
217 {
<span class="line-modified">218   static constexpr bool apple = true;</span>
<span class="line-added">219   typedef AAT::ObsoleteTypes Types;</span>
220 
<span class="line-modified">221   unsigned int tuple_count () const { return 0; }</span>
<span class="line-added">222   bool is_horizontal () const       { return !(coverage &amp; Vertical); }</span>
223 
<span class="line-modified">224   enum Coverage</span>
225   {
<span class="line-modified">226     Vertical    = 0x80u,</span>
<span class="line-modified">227     CrossStream = 0x40u,</span>
<span class="line-modified">228     Variation   = 0x20u,</span>
<span class="line-modified">229 </span>
<span class="line-modified">230     /* Not supported: */</span>
<span class="line-modified">231     Backwards   = 0x00u,</span>
















232   };
233 
<span class="line-modified">234   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">235   {</span>
<span class="line-modified">236     TRACE_SANITIZE (this);</span>
<span class="line-modified">237     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added">238   }</span>
<span class="line-added">239 </span>
<span class="line-added">240   public:</span>
<span class="line-added">241   HBUINT32      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">242   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">243   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">244   HBUINT16      tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-added">245                                * This value specifies which tuple this subtable covers.</span>
<span class="line-added">246                                * Note: We don&#39;t implement. */</span>
247   public:
<span class="line-modified">248   DEFINE_SIZE_STATIC (8);</span>
249 };
250 
<span class="line-modified">251 struct KernAAT : AAT::KerxTable&lt;KernAAT&gt;</span>
252 {
<span class="line-modified">253   friend struct AAT::KerxTable&lt;KernAAT&gt;;</span>
254 
<span class="line-modified">255   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-added">256   static constexpr unsigned minVersion = 0x00010000u;</span>
257 
<span class="line-modified">258   typedef KernAATSubTableHeader SubTableHeader;</span>
<span class="line-modified">259   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">260   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>






















261 
262   protected:
<span class="line-modified">263   HBUINT32      version;        /* Version--0x00010000u */</span>
<span class="line-modified">264   HBUINT32      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-modified">265   SubTable      firstSubTable;  /* Subtables. */</span>
266   public:
<span class="line-modified">267   DEFINE_SIZE_MIN (8);</span>
268 };
269 
270 struct kern
271 {
<span class="line-modified">272   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
273 
<span class="line-modified">274   bool has_data () const { return u.version32; }</span>
<span class="line-added">275   unsigned int get_type () const { return u.major; }</span>
<span class="line-added">276 </span>
<span class="line-added">277   bool has_state_machine () const</span>
278   {
<span class="line-modified">279     switch (get_type ()) {</span>
<span class="line-modified">280     case 0: return u.ot.has_state_machine ();</span>
<span class="line-modified">281     case 1: return u.aat.has_state_machine ();</span>
<span class="line-modified">282     default:return false;</span>
283     }
284   }
285 
<span class="line-modified">286   bool has_cross_stream () const</span>
287   {
<span class="line-modified">288     switch (get_type ()) {</span>
<span class="line-modified">289     case 0: return u.ot.has_cross_stream ();</span>
<span class="line-modified">290     case 1: return u.aat.has_cross_stream ();</span>
<span class="line-modified">291     default:return false;</span>


292     }
293   }
294 
<span class="line-modified">295   int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
296   {
<span class="line-modified">297     switch (get_type ()) {</span>
<span class="line-modified">298     case 0: return u.ot.get_h_kerning (left, right);</span>
<span class="line-modified">299     case 1: return u.aat.get_h_kerning (left, right);</span>
<span class="line-modified">300     default:return 0;</span>





301     }
<span class="line-added">302   }</span>
303 
<span class="line-modified">304   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
<span class="line-modified">305   { return dispatch (c); }</span>
306 
<span class="line-modified">307   template &lt;typename context_t&gt;</span>
<span class="line-modified">308   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">309   {</span>
<span class="line-modified">310     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">311     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-added">312     switch (subtable_type) {</span>
<span class="line-added">313     case 0:     return_trace (c-&gt;dispatch (u.ot));</span>
<span class="line-added">314     case 1:     return_trace (c-&gt;dispatch (u.aat));</span>
<span class="line-added">315     default:    return_trace (c-&gt;default_return_value ());</span>
<span class="line-added">316     }</span>
<span class="line-added">317   }</span>
<span class="line-added">318 </span>
<span class="line-added">319   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">320   {</span>
<span class="line-added">321     TRACE_SANITIZE (this);</span>
<span class="line-added">322     if (!u.version32.sanitize (c)) return_trace (false);</span>
<span class="line-added">323     return_trace (dispatch (c));</span>
<span class="line-added">324   }</span>
325 
326   protected:
327   union {
<span class="line-added">328   HBUINT32              version32;</span>
329   HBUINT16              major;
330   KernOT                ot;
331   KernAAT               aat;
332   } u;
333   public:
<span class="line-modified">334   DEFINE_SIZE_UNION (4, version32);</span>
335 };
336 
337 } /* namespace OT */
338 
339 
340 #endif /* HB_OT_KERN_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-hmtx-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-base-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-hhea-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-kern-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod, Roderick Sheeter
 25  */
 26 
 27 #ifndef HB_OT_HMTX_TABLE_HH
 28 #define HB_OT_HMTX_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 #include &quot;hb-ot-hhea-table.hh&quot;
 32 #include &quot;hb-ot-os2-table.hh&quot;
 33 #include &quot;hb-ot-var-hvar-table.hh&quot;
<span class="line-removed"> 34 #include &quot;hb-subset-plan.hh&quot;</span>
 35 
 36 /*
 37  * hmtx -- Horizontal Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx
 39  * vmtx -- Vertical Metrics
 40  * https://docs.microsoft.com/en-us/typography/opentype/spec/vmtx
 41  */
 42 #define HB_OT_TAG_hmtx HB_TAG(&#39;h&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 43 #define HB_OT_TAG_vmtx HB_TAG(&#39;v&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 44 
 45 
 46 namespace OT {
 47 
 48 
 49 struct LongMetric
 50 {
 51   UFWORD        advance; /* Advance width/height. */
<span class="line-modified"> 52   FWORD         lsb; /* Leading (left/top) side bearing. */</span>
 53   public:
 54   DEFINE_SIZE_STATIC (4);
 55 };
 56 
 57 template &lt;typename T, typename H&gt;
 58 struct hmtxvmtx
 59 {
<span class="line-modified"> 60   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 61   {
 62     TRACE_SANITIZE (this);
 63     /* We don&#39;t check for anything specific here.  The users of the
 64      * struct do all the hard work... */
 65     return_trace (true);
 66   }
 67 
 68 
<span class="line-modified"> 69   inline bool subset_update_header (hb_subset_plan_t *plan,</span>
 70                                     unsigned int num_hmetrics) const
 71   {
<span class="line-modified"> 72     hb_blob_t *src_blob = OT::Sanitizer&lt;H&gt; ().sanitize (plan-&gt;source-&gt;reference_table (H::tableTag));</span>
<span class="line-modified"> 73     hb_blob_t *dest_blob = hb_blob_copy_writable_or_fail(src_blob);</span>
 74     hb_blob_destroy (src_blob);
 75 
 76     if (unlikely (!dest_blob)) {
 77       return false;
 78     }
 79 
 80     unsigned int length;
 81     H *table = (H *) hb_blob_get_data (dest_blob, &amp;length);
 82     table-&gt;numberOfLongMetrics.set (num_hmetrics);
 83 
 84     bool result = plan-&gt;add_table (H::tableTag, dest_blob);
 85     hb_blob_destroy (dest_blob);
 86 
 87     return result;
 88   }
 89 
<span class="line-modified"> 90   inline bool subset (hb_subset_plan_t *plan) const</span>
 91   {
 92     typename T::accelerator_t _mtx;
 93     _mtx.init (plan-&gt;source);
 94 
 95     /* All the trailing glyphs with the same advance can use one LongMetric
 96      * and just keep LSB */
 97     hb_vector_t&lt;hb_codepoint_t&gt; &amp;gids = plan-&gt;glyphs;
<span class="line-modified"> 98     unsigned int num_advances = gids.len;</span>
 99     unsigned int last_advance = _mtx.get_advance (gids[num_advances - 1]);
<span class="line-modified">100     while (num_advances &gt; 1</span>
<span class="line-modified">101         &amp;&amp; last_advance == _mtx.get_advance (gids[num_advances - 2]))</span>
102     {
103       num_advances--;
104     }
105 
106     /* alloc the new table */
107     size_t dest_sz = num_advances * 4
<span class="line-modified">108                   + (gids.len - num_advances) * 2;</span>
109     void *dest = (void *) malloc (dest_sz);
110     if (unlikely (!dest))
111     {
112       return false;
113     }
114     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in src has %d advances, %d lsbs&quot;, HB_UNTAG(T::tableTag), _mtx.num_advances, _mtx.num_metrics - _mtx.num_advances);
<span class="line-modified">115     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in dest has %d advances, %d lsbs, %u bytes&quot;, HB_UNTAG(T::tableTag), num_advances, gids.len - num_advances, (unsigned int) dest_sz);</span>
116 
<span class="line-modified">117     const char *source_table = hb_blob_get_data (_mtx.blob, nullptr);</span>
118     // Copy everything over
119     LongMetric * old_metrics = (LongMetric *) source_table;
120     FWORD *lsbs = (FWORD *) (old_metrics + _mtx.num_advances);
121     char * dest_pos = (char *) dest;
122 
123     bool failed = false;
<span class="line-modified">124     for (unsigned int i = 0; i &lt; gids.len; i++)</span>
125     {
126       /* the last metric or the one for gids[i] */
127       LongMetric *src_metric = old_metrics + MIN ((hb_codepoint_t) _mtx.num_advances - 1, gids[i]);
128       if (gids[i] &lt; _mtx.num_advances)
129       {
130         /* src is a LongMetric */
131         if (i &lt; num_advances)
132         {
133           /* dest is a LongMetric, copy it */
134           *((LongMetric *) dest_pos) = *src_metric;
135         }
136         else
137         {
<span class="line-modified">138           /* dest just lsb */</span>
<span class="line-modified">139           *((FWORD *) dest_pos) = src_metric-&gt;lsb;</span>
140         }
141       }
142       else
143       {
144         if (gids[i] &gt;= _mtx.num_metrics)
145         {
146           DEBUG_MSG(SUBSET, nullptr, &quot;gid %d is &gt;= number of source metrics %d&quot;,
147                     gids[i], _mtx.num_metrics);
148           failed = true;
149           break;
150         }
<span class="line-modified">151         FWORD src_lsb = *(lsbs + gids[i] - _mtx.num_advances);</span>
152         if (i &lt; num_advances)
153         {
154           /* dest needs a full LongMetric */
155           LongMetric *metric = (LongMetric *)dest_pos;
156           metric-&gt;advance = src_metric-&gt;advance;
<span class="line-modified">157           metric-&gt;lsb = src_lsb;</span>
158         }
159         else
160         {
<span class="line-modified">161           /* dest just needs an lsb */</span>
<span class="line-modified">162           *((FWORD *) dest_pos) = src_lsb;</span>
163         }
164       }
165       dest_pos += (i &lt; num_advances ? 4 : 2);
166     }
167     _mtx.fini ();
168 
169     // Amend header num hmetrics
170     if (failed || unlikely (!subset_update_header (plan, num_advances)))
171     {
172       free (dest);
173       return false;
174     }
175 
176     hb_blob_t *result = hb_blob_create ((const char *)dest,
177                                         dest_sz,
178                                         HB_MEMORY_MODE_READONLY,
179                                         dest,
180                                         free);
181     bool success = plan-&gt;add_table (T::tableTag, result);
182     hb_blob_destroy (result);
183     return success;
184   }
185 
186   struct accelerator_t
187   {
188     friend struct hmtxvmtx;
189 
<span class="line-modified">190     inline void init (hb_face_t *face,</span>
191                       unsigned int default_advance_ = 0)
192     {
193       default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);
194 
195       bool got_font_extents = false;
<span class="line-modified">196       if (T::os2Tag)</span>
197       {
<span class="line-modified">198         hb_blob_t *os2_blob = Sanitizer&lt;os2&gt; ().sanitize (face-&gt;reference_table (T::os2Tag));</span>
<span class="line-modified">199         const os2 *os2_table = os2_blob-&gt;as&lt;os2&gt; ();</span>
<span class="line-modified">200 #define USE_TYPO_METRICS (1u&lt;&lt;7)</span>
<span class="line-modified">201         if (0 != (os2_table-&gt;fsSelection &amp; USE_TYPO_METRICS))</span>
<span class="line-removed">202         {</span>
<span class="line-removed">203           ascender = os2_table-&gt;sTypoAscender;</span>
<span class="line-removed">204           descender = os2_table-&gt;sTypoDescender;</span>
<span class="line-removed">205           line_gap = os2_table-&gt;sTypoLineGap;</span>
<span class="line-removed">206           got_font_extents = (ascender | descender) != 0;</span>
<span class="line-removed">207         }</span>
<span class="line-removed">208         hb_blob_destroy (os2_blob);</span>
209       }
210 
<span class="line-modified">211       hb_blob_t *_hea_blob = Sanitizer&lt;H&gt; ().sanitize (face-&gt;reference_table (H::tableTag));</span>
212       const H *_hea_table = _hea_blob-&gt;as&lt;H&gt; ();
213       num_advances = _hea_table-&gt;numberOfLongMetrics;
214       if (!got_font_extents)
215       {
<span class="line-modified">216         ascender = _hea_table-&gt;ascender;</span>
<span class="line-modified">217         descender = _hea_table-&gt;descender;</span>
218         line_gap = _hea_table-&gt;lineGap;
219         got_font_extents = (ascender | descender) != 0;
220       }
221       hb_blob_destroy (_hea_blob);
222 
223       has_font_extents = got_font_extents;
224 
<span class="line-modified">225       blob = Sanitizer&lt;hmtxvmtx&gt; ().sanitize (face-&gt;reference_table (T::tableTag));</span>
226 
227       /* Cap num_metrics() and num_advances() based on table length. */
<span class="line-modified">228       unsigned int len = hb_blob_get_length (blob);</span>
229       if (unlikely (num_advances * 4 &gt; len))
230         num_advances = len / 4;
231       num_metrics = num_advances + (len - 4 * num_advances) / 2;
232 
233       /* We MUST set num_metrics to zero if num_advances is zero.
234        * Our get_advance() depends on that. */
235       if (unlikely (!num_advances))
236       {
237         num_metrics = num_advances = 0;
<span class="line-modified">238         hb_blob_destroy (blob);</span>
<span class="line-modified">239         blob = hb_blob_get_empty ();</span>
240       }
<span class="line-removed">241       table = blob-&gt;as&lt;hmtxvmtx&gt; ();</span>
242 
<span class="line-modified">243       var_blob = Sanitizer&lt;HVARVVAR&gt; ().sanitize (face-&gt;reference_table (T::variationsTag));</span>
<span class="line-modified">244       var_table = var_blob-&gt;as&lt;HVARVVAR&gt; ();</span>





245     }
246 
<span class="line-modified">247     inline void fini (void)</span>

248     {
<span class="line-modified">249       hb_blob_destroy (blob);</span>
<span class="line-modified">250       hb_blob_destroy (var_blob);</span>






251     }
252 
<span class="line-modified">253     inline unsigned int get_advance (hb_codepoint_t  glyph) const</span>
254     {
255       if (unlikely (glyph &gt;= num_metrics))
256       {
257         /* If num_metrics is zero, it means we don&#39;t have the metrics table
258          * for this direction: return default advance.  Otherwise, it means that the
259          * glyph index is out of bound: return zero. */
260         if (num_metrics)
261           return 0;
262         else
263           return default_advance;
264       }
265 
<span class="line-modified">266       return table-&gt;longMetric[MIN (glyph, (uint32_t) num_advances - 1)].advance;</span>
267     }
268 
<span class="line-modified">269     inline unsigned int get_advance (hb_codepoint_t  glyph,</span>
<span class="line-modified">270                                      hb_font_t      *font) const</span>
271     {
272       unsigned int advance = get_advance (glyph);
<span class="line-modified">273       if (likely(glyph &lt; num_metrics))</span>
274       {
275         advance += (font-&gt;num_coords ? var_table-&gt;get_advance_var (glyph, font-&gt;coords, font-&gt;num_coords) : 0); // TODO Optimize?!
276       }
277       return advance;
278     }
279 
280     public:
281     bool has_font_extents;
<span class="line-modified">282     unsigned short ascender;</span>
<span class="line-modified">283     unsigned short descender;</span>
<span class="line-modified">284     unsigned short line_gap;</span>
285 
286     protected:
287     unsigned int num_metrics;
288     unsigned int num_advances;
289     unsigned int default_advance;
290 
291     private:
<span class="line-modified">292     const hmtxvmtx *table;</span>
<span class="line-modified">293     hb_blob_t *blob;</span>
<span class="line-removed">294     const HVARVVAR *var_table;</span>
<span class="line-removed">295     hb_blob_t *var_blob;</span>
296   };
297 
298   protected:
<span class="line-modified">299   LongMetric    longMetric[VAR];        /* Paired advance width and leading</span>
300                                          * bearing values for each glyph. The
301                                          * value numOfHMetrics comes from
302                                          * the &#39;hhea&#39; table. If the font is
303                                          * monospaced, only one entry need
304                                          * be in the array, but that entry is
305                                          * required. The last entry applies to
306                                          * all subsequent glyphs. */
<span class="line-modified">307 /*FWORD         leadingBearingX[VAR];*/ /* Here the advance is assumed</span>
308                                          * to be the same as the advance
309                                          * for the last entry above. The
310                                          * number of entries in this array is
311                                          * derived from numGlyphs (from &#39;maxp&#39;
312                                          * table) minus numberOfLongMetrics.
313                                          * This generally is used with a run
314                                          * of monospaced glyphs (e.g., Kanji
315                                          * fonts or Courier fonts). Only one
316                                          * run is allowed and it must be at
317                                          * the end. This allows a monospaced
318                                          * font to vary the side bearing
319                                          * values for each glyph. */
320   public:
<span class="line-modified">321   DEFINE_SIZE_ARRAY (0, longMetric);</span>
322 };
323 
324 struct hmtx : hmtxvmtx&lt;hmtx, hhea&gt; {
<span class="line-modified">325   static const hb_tag_t tableTag        = HB_OT_TAG_hmtx;</span>
<span class="line-modified">326   static const hb_tag_t variationsTag   = HB_OT_TAG_HVAR;</span>
<span class="line-modified">327   static const hb_tag_t os2Tag          = HB_OT_TAG_os2;</span>
328 };
329 struct vmtx : hmtxvmtx&lt;vmtx, vhea&gt; {
<span class="line-modified">330   static const hb_tag_t tableTag        = HB_OT_TAG_vmtx;</span>
<span class="line-modified">331   static const hb_tag_t variationsTag   = HB_OT_TAG_VVAR;</span>
<span class="line-modified">332   static const hb_tag_t os2Tag          = HB_TAG_NONE;</span>
333 };
334 



335 } /* namespace OT */
336 
337 
338 #endif /* HB_OT_HMTX_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod, Roderick Sheeter
 25  */
 26 
 27 #ifndef HB_OT_HMTX_TABLE_HH
 28 #define HB_OT_HMTX_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
 31 #include &quot;hb-ot-hhea-table.hh&quot;
 32 #include &quot;hb-ot-os2-table.hh&quot;
 33 #include &quot;hb-ot-var-hvar-table.hh&quot;

 34 
 35 /*
 36  * hmtx -- Horizontal Metrics
 37  * https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx
 38  * vmtx -- Vertical Metrics
 39  * https://docs.microsoft.com/en-us/typography/opentype/spec/vmtx
 40  */
 41 #define HB_OT_TAG_hmtx HB_TAG(&#39;h&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 42 #define HB_OT_TAG_vmtx HB_TAG(&#39;v&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 43 
 44 
 45 namespace OT {
 46 
 47 
 48 struct LongMetric
 49 {
 50   UFWORD        advance; /* Advance width/height. */
<span class="line-modified"> 51   FWORD         sb; /* Leading (left/top) side bearing. */</span>
 52   public:
 53   DEFINE_SIZE_STATIC (4);
 54 };
 55 
 56 template &lt;typename T, typename H&gt;
 57 struct hmtxvmtx
 58 {
<span class="line-modified"> 59   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
 60   {
 61     TRACE_SANITIZE (this);
 62     /* We don&#39;t check for anything specific here.  The users of the
 63      * struct do all the hard work... */
 64     return_trace (true);
 65   }
 66 
 67 
<span class="line-modified"> 68   bool subset_update_header (hb_subset_plan_t *plan,</span>
 69                                     unsigned int num_hmetrics) const
 70   {
<span class="line-modified"> 71     hb_blob_t *src_blob = hb_sanitize_context_t ().reference_table&lt;H&gt; (plan-&gt;source, H::tableTag);</span>
<span class="line-modified"> 72     hb_blob_t *dest_blob = hb_blob_copy_writable_or_fail (src_blob);</span>
 73     hb_blob_destroy (src_blob);
 74 
 75     if (unlikely (!dest_blob)) {
 76       return false;
 77     }
 78 
 79     unsigned int length;
 80     H *table = (H *) hb_blob_get_data (dest_blob, &amp;length);
 81     table-&gt;numberOfLongMetrics.set (num_hmetrics);
 82 
 83     bool result = plan-&gt;add_table (H::tableTag, dest_blob);
 84     hb_blob_destroy (dest_blob);
 85 
 86     return result;
 87   }
 88 
<span class="line-modified"> 89   bool subset (hb_subset_plan_t *plan) const</span>
 90   {
 91     typename T::accelerator_t _mtx;
 92     _mtx.init (plan-&gt;source);
 93 
 94     /* All the trailing glyphs with the same advance can use one LongMetric
 95      * and just keep LSB */
 96     hb_vector_t&lt;hb_codepoint_t&gt; &amp;gids = plan-&gt;glyphs;
<span class="line-modified"> 97     unsigned int num_advances = gids.length;</span>
 98     unsigned int last_advance = _mtx.get_advance (gids[num_advances - 1]);
<span class="line-modified"> 99     while (num_advances &gt; 1 &amp;&amp;</span>
<span class="line-modified">100            last_advance == _mtx.get_advance (gids[num_advances - 2]))</span>
101     {
102       num_advances--;
103     }
104 
105     /* alloc the new table */
106     size_t dest_sz = num_advances * 4
<span class="line-modified">107                   + (gids.length - num_advances) * 2;</span>
108     void *dest = (void *) malloc (dest_sz);
109     if (unlikely (!dest))
110     {
111       return false;
112     }
113     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in src has %d advances, %d lsbs&quot;, HB_UNTAG(T::tableTag), _mtx.num_advances, _mtx.num_metrics - _mtx.num_advances);
<span class="line-modified">114     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in dest has %d advances, %d lsbs, %u bytes&quot;, HB_UNTAG(T::tableTag), num_advances, gids.length - num_advances, (unsigned int) dest_sz);</span>
115 
<span class="line-modified">116     const char *source_table = hb_blob_get_data (_mtx.table.get_blob (), nullptr);</span>
117     // Copy everything over
118     LongMetric * old_metrics = (LongMetric *) source_table;
119     FWORD *lsbs = (FWORD *) (old_metrics + _mtx.num_advances);
120     char * dest_pos = (char *) dest;
121 
122     bool failed = false;
<span class="line-modified">123     for (unsigned int i = 0; i &lt; gids.length; i++)</span>
124     {
125       /* the last metric or the one for gids[i] */
126       LongMetric *src_metric = old_metrics + MIN ((hb_codepoint_t) _mtx.num_advances - 1, gids[i]);
127       if (gids[i] &lt; _mtx.num_advances)
128       {
129         /* src is a LongMetric */
130         if (i &lt; num_advances)
131         {
132           /* dest is a LongMetric, copy it */
133           *((LongMetric *) dest_pos) = *src_metric;
134         }
135         else
136         {
<span class="line-modified">137           /* dest just sb */</span>
<span class="line-modified">138           *((FWORD *) dest_pos) = src_metric-&gt;sb;</span>
139         }
140       }
141       else
142       {
143         if (gids[i] &gt;= _mtx.num_metrics)
144         {
145           DEBUG_MSG(SUBSET, nullptr, &quot;gid %d is &gt;= number of source metrics %d&quot;,
146                     gids[i], _mtx.num_metrics);
147           failed = true;
148           break;
149         }
<span class="line-modified">150         FWORD src_sb = *(lsbs + gids[i] - _mtx.num_advances);</span>
151         if (i &lt; num_advances)
152         {
153           /* dest needs a full LongMetric */
154           LongMetric *metric = (LongMetric *)dest_pos;
155           metric-&gt;advance = src_metric-&gt;advance;
<span class="line-modified">156           metric-&gt;sb = src_sb;</span>
157         }
158         else
159         {
<span class="line-modified">160           /* dest just needs an sb */</span>
<span class="line-modified">161           *((FWORD *) dest_pos) = src_sb;</span>
162         }
163       }
164       dest_pos += (i &lt; num_advances ? 4 : 2);
165     }
166     _mtx.fini ();
167 
168     // Amend header num hmetrics
169     if (failed || unlikely (!subset_update_header (plan, num_advances)))
170     {
171       free (dest);
172       return false;
173     }
174 
175     hb_blob_t *result = hb_blob_create ((const char *)dest,
176                                         dest_sz,
177                                         HB_MEMORY_MODE_READONLY,
178                                         dest,
179                                         free);
180     bool success = plan-&gt;add_table (T::tableTag, result);
181     hb_blob_destroy (result);
182     return success;
183   }
184 
185   struct accelerator_t
186   {
187     friend struct hmtxvmtx;
188 
<span class="line-modified">189     void init (hb_face_t *face,</span>
190                       unsigned int default_advance_ = 0)
191     {
192       default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);
193 
194       bool got_font_extents = false;
<span class="line-modified">195       if (T::os2Tag != HB_TAG_NONE &amp;&amp; face-&gt;table.OS2-&gt;is_typo_metrics ())</span>
196       {
<span class="line-modified">197         ascender = abs (face-&gt;table.OS2-&gt;sTypoAscender);</span>
<span class="line-modified">198         descender = -abs (face-&gt;table.OS2-&gt;sTypoDescender);</span>
<span class="line-modified">199         line_gap = face-&gt;table.OS2-&gt;sTypoLineGap;</span>
<span class="line-modified">200         got_font_extents = (ascender | descender) != 0;</span>







201       }
202 
<span class="line-modified">203       hb_blob_t *_hea_blob = hb_sanitize_context_t().reference_table&lt;H&gt; (face);</span>
204       const H *_hea_table = _hea_blob-&gt;as&lt;H&gt; ();
205       num_advances = _hea_table-&gt;numberOfLongMetrics;
206       if (!got_font_extents)
207       {
<span class="line-modified">208         ascender = abs (_hea_table-&gt;ascender);</span>
<span class="line-modified">209         descender = -abs (_hea_table-&gt;descender);</span>
210         line_gap = _hea_table-&gt;lineGap;
211         got_font_extents = (ascender | descender) != 0;
212       }
213       hb_blob_destroy (_hea_blob);
214 
215       has_font_extents = got_font_extents;
216 
<span class="line-modified">217       table = hb_sanitize_context_t().reference_table&lt;hmtxvmtx&gt; (face, T::tableTag);</span>
218 
219       /* Cap num_metrics() and num_advances() based on table length. */
<span class="line-modified">220       unsigned int len = table.get_length ();</span>
221       if (unlikely (num_advances * 4 &gt; len))
222         num_advances = len / 4;
223       num_metrics = num_advances + (len - 4 * num_advances) / 2;
224 
225       /* We MUST set num_metrics to zero if num_advances is zero.
226        * Our get_advance() depends on that. */
227       if (unlikely (!num_advances))
228       {
229         num_metrics = num_advances = 0;
<span class="line-modified">230         table.destroy ();</span>
<span class="line-modified">231         table = hb_blob_get_empty ();</span>
232       }

233 
<span class="line-modified">234       var_table = hb_sanitize_context_t().reference_table&lt;HVARVVAR&gt; (face, T::variationsTag);</span>
<span class="line-modified">235     }</span>
<span class="line-added">236 </span>
<span class="line-added">237     void fini ()</span>
<span class="line-added">238     {</span>
<span class="line-added">239       table.destroy ();</span>
<span class="line-added">240       var_table.destroy ();</span>
241     }
242 
<span class="line-modified">243     /* TODO Add variations version. */</span>
<span class="line-added">244     unsigned int get_side_bearing (hb_codepoint_t glyph) const</span>
245     {
<span class="line-modified">246       if (glyph &lt; num_advances)</span>
<span class="line-modified">247         return table-&gt;longMetricZ[glyph].sb;</span>
<span class="line-added">248 </span>
<span class="line-added">249       if (unlikely (glyph &gt;= num_metrics))</span>
<span class="line-added">250         return 0;</span>
<span class="line-added">251 </span>
<span class="line-added">252       const FWORD *bearings = (const FWORD *) &amp;table-&gt;longMetricZ[num_advances];</span>
<span class="line-added">253       return bearings[glyph - num_advances];</span>
254     }
255 
<span class="line-modified">256     unsigned int get_advance (hb_codepoint_t glyph) const</span>
257     {
258       if (unlikely (glyph &gt;= num_metrics))
259       {
260         /* If num_metrics is zero, it means we don&#39;t have the metrics table
261          * for this direction: return default advance.  Otherwise, it means that the
262          * glyph index is out of bound: return zero. */
263         if (num_metrics)
264           return 0;
265         else
266           return default_advance;
267       }
268 
<span class="line-modified">269       return table-&gt;longMetricZ[MIN (glyph, (uint32_t) num_advances - 1)].advance;</span>
270     }
271 
<span class="line-modified">272     unsigned int get_advance (hb_codepoint_t  glyph,</span>
<span class="line-modified">273                               hb_font_t      *font) const</span>
274     {
275       unsigned int advance = get_advance (glyph);
<span class="line-modified">276       if (likely (glyph &lt; num_metrics))</span>
277       {
278         advance += (font-&gt;num_coords ? var_table-&gt;get_advance_var (glyph, font-&gt;coords, font-&gt;num_coords) : 0); // TODO Optimize?!
279       }
280       return advance;
281     }
282 
283     public:
284     bool has_font_extents;
<span class="line-modified">285     int ascender;</span>
<span class="line-modified">286     int descender;</span>
<span class="line-modified">287     int line_gap;</span>
288 
289     protected:
290     unsigned int num_metrics;
291     unsigned int num_advances;
292     unsigned int default_advance;
293 
294     private:
<span class="line-modified">295     hb_blob_ptr_t&lt;hmtxvmtx&gt; table;</span>
<span class="line-modified">296     hb_blob_ptr_t&lt;HVARVVAR&gt; var_table;</span>


297   };
298 
299   protected:
<span class="line-modified">300   UnsizedArrayOf&lt;LongMetric&gt;longMetricZ;/* Paired advance width and leading</span>
301                                          * bearing values for each glyph. The
302                                          * value numOfHMetrics comes from
303                                          * the &#39;hhea&#39; table. If the font is
304                                          * monospaced, only one entry need
305                                          * be in the array, but that entry is
306                                          * required. The last entry applies to
307                                          * all subsequent glyphs. */
<span class="line-modified">308 /*UnsizedArrayOf&lt;FWORD&gt; leadingBearingX;*//* Here the advance is assumed</span>
309                                          * to be the same as the advance
310                                          * for the last entry above. The
311                                          * number of entries in this array is
312                                          * derived from numGlyphs (from &#39;maxp&#39;
313                                          * table) minus numberOfLongMetrics.
314                                          * This generally is used with a run
315                                          * of monospaced glyphs (e.g., Kanji
316                                          * fonts or Courier fonts). Only one
317                                          * run is allowed and it must be at
318                                          * the end. This allows a monospaced
319                                          * font to vary the side bearing
320                                          * values for each glyph. */
321   public:
<span class="line-modified">322   DEFINE_SIZE_ARRAY (0, longMetricZ);</span>
323 };
324 
325 struct hmtx : hmtxvmtx&lt;hmtx, hhea&gt; {
<span class="line-modified">326   static constexpr hb_tag_t tableTag = HB_OT_TAG_hmtx;</span>
<span class="line-modified">327   static constexpr hb_tag_t variationsTag = HB_OT_TAG_HVAR;</span>
<span class="line-modified">328   static constexpr hb_tag_t os2Tag = HB_OT_TAG_OS2;</span>
329 };
330 struct vmtx : hmtxvmtx&lt;vmtx, vhea&gt; {
<span class="line-modified">331   static constexpr hb_tag_t tableTag = HB_OT_TAG_vmtx;</span>
<span class="line-modified">332   static constexpr hb_tag_t variationsTag = HB_OT_TAG_VVAR;</span>
<span class="line-modified">333   static constexpr hb_tag_t os2Tag = HB_TAG_NONE;</span>
334 };
335 
<span class="line-added">336 struct hmtx_accelerator_t : hmtx::accelerator_t {};</span>
<span class="line-added">337 struct vmtx_accelerator_t : vmtx::accelerator_t {};</span>
<span class="line-added">338 </span>
339 } /* namespace OT */
340 
341 
342 #endif /* HB_OT_HMTX_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-hhea-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-kern-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-name-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-unicode-ranges.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-os2-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright © 2011,2012  Google, Inc.
<span class="line-added">+  * Copyright © 2018  Ebrahim Byagowi</span>
   *
   *  This is part of HarfBuzz, a text shaping library.
   *
   * Permission is hereby granted, without written agreement and without
   * license or royalty fees, to use, copy, modify, and distribute this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,40 ***</span>
   */
  
  #ifndef HB_OT_OS2_TABLE_HH
  #define HB_OT_OS2_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
  #include &quot;hb-ot-os2-unicode-ranges.hh&quot;
<span class="line-removed">- #include &quot;hb-subset-plan.hh&quot;</span>
  
<span class="line-modified">! namespace OT {</span>
  
  /*
   * OS/2 and Windows Metrics
   * https://docs.microsoft.com/en-us/typography/opentype/spec/os2
   */
<span class="line-modified">! #define HB_OT_TAG_os2 HB_TAG(&#39;O&#39;,&#39;S&#39;,&#39;/&#39;,&#39;2&#39;)</span>
  
<span class="line-modified">! struct os2</span>
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_os2;</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-modified">!   inline bool subset (hb_subset_plan_t *plan) const</span>
    {
<span class="line-modified">!     hb_blob_t *os2_blob = OT::Sanitizer&lt;OT::os2&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_os2));</span>
      hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);
      // TODO(grieger): move to hb_blob_copy_writable_or_fail
      hb_blob_destroy (os2_blob);
  
<span class="line-modified">!     OT::os2 *os2_prime = (OT::os2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);</span>
      if (unlikely (!os2_prime)) {
        hb_blob_destroy (os2_prime_blob);
        return false;
      }
  
<span class="line-new-header">--- 26,135 ---</span>
   */
  
  #ifndef HB_OT_OS2_TABLE_HH
  #define HB_OT_OS2_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
  #include &quot;hb-ot-os2-unicode-ranges.hh&quot;
  
<span class="line-modified">! #include &quot;hb-set.hh&quot;</span>
  
  /*
   * OS/2 and Windows Metrics
   * https://docs.microsoft.com/en-us/typography/opentype/spec/os2
   */
<span class="line-modified">! #define HB_OT_TAG_OS2 HB_TAG(&#39;O&#39;,&#39;S&#39;,&#39;/&#39;,&#39;2&#39;)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ namespace OT {</span>
  
<span class="line-modified">! struct OS2V1Tail</span>
  {
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   HBUINT32      ulCodePageRange1;</span>
<span class="line-added">+   HBUINT32      ulCodePageRange2;</span>
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_STATIC (8);</span>
<span class="line-added">+ };</span>
  
<span class="line-modified">! struct OS2V2Tail</span>
<span class="line-added">+ {</span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
<span class="line-modified">!   public:</span>
<span class="line-added">+   HBINT16       sxHeight;</span>
<span class="line-added">+   HBINT16       sCapHeight;</span>
<span class="line-added">+   HBUINT16      usDefaultChar;</span>
<span class="line-added">+   HBUINT16      usBreakChar;</span>
<span class="line-added">+   HBUINT16      usMaxContext;</span>
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_STATIC (10);</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ struct OS2V5Tail</span>
<span class="line-added">+ {</span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   HBUINT16      usLowerOpticalPointSize;</span>
<span class="line-added">+   HBUINT16      usUpperOpticalPointSize;</span>
<span class="line-added">+   public:</span>
<span class="line-added">+   DEFINE_SIZE_STATIC (4);</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ struct OS2</span>
<span class="line-added">+ {</span>
<span class="line-added">+   static constexpr hb_tag_t tableTag = HB_OT_TAG_OS2;</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool has_data () const { return this != &amp;Null (OS2); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   const OS2V1Tail &amp;v1 () const { return version &gt;= 1 ? v1X : Null (OS2V1Tail); }</span>
<span class="line-added">+   const OS2V2Tail &amp;v2 () const { return version &gt;= 2 ? v2X : Null (OS2V2Tail); }</span>
<span class="line-added">+   const OS2V5Tail &amp;v5 () const { return version &gt;= 5 ? v5X : Null (OS2V5Tail); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   enum selection_flag_t {</span>
<span class="line-added">+     ITALIC              = 1u&lt;&lt;0,</span>
<span class="line-added">+     UNDERSCORE          = 1u&lt;&lt;1,</span>
<span class="line-added">+     NEGATIVE            = 1u&lt;&lt;2,</span>
<span class="line-added">+     OUTLINED            = 1u&lt;&lt;3,</span>
<span class="line-added">+     STRIKEOUT           = 1u&lt;&lt;4,</span>
<span class="line-added">+     BOLD                = 1u&lt;&lt;5,</span>
<span class="line-added">+     REGULAR             = 1u&lt;&lt;6,</span>
<span class="line-added">+     USE_TYPO_METRICS    = 1u&lt;&lt;7,</span>
<span class="line-added">+     WWS                 = 1u&lt;&lt;8,</span>
<span class="line-added">+     OBLIQUE             = 1u&lt;&lt;9</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool is_italic () const       { return fsSelection &amp; ITALIC; }</span>
<span class="line-added">+   bool is_oblique () const      { return fsSelection &amp; OBLIQUE; }</span>
<span class="line-added">+   bool is_typo_metrics () const { return fsSelection &amp; USE_TYPO_METRICS; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   enum width_class_t {</span>
<span class="line-added">+     FWIDTH_ULTRA_CONDENSED      = 1, /* 50% */</span>
<span class="line-added">+     FWIDTH_EXTRA_CONDENSED      = 2, /* 62.5% */</span>
<span class="line-added">+     FWIDTH_CONDENSED            = 3, /* 75% */</span>
<span class="line-added">+     FWIDTH_SEMI_CONDENSED       = 4, /* 87.5% */</span>
<span class="line-added">+     FWIDTH_NORMAL               = 5, /* 100% */</span>
<span class="line-added">+     FWIDTH_SEMI_EXPANDED        = 6, /* 112.5% */</span>
<span class="line-added">+     FWIDTH_EXPANDED             = 7, /* 125% */</span>
<span class="line-added">+     FWIDTH_EXTRA_EXPANDED       = 8, /* 150% */</span>
<span class="line-added">+     FWIDTH_ULTRA_EXPANDED       = 9  /* 200% */</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
<span class="line-added">+   float get_width () const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     switch (usWidthClass) {</span>
<span class="line-added">+     case FWIDTH_ULTRA_CONDENSED:return 50.f;</span>
<span class="line-added">+     case FWIDTH_EXTRA_CONDENSED:return 62.5f;</span>
<span class="line-added">+     case FWIDTH_CONDENSED:      return 75.f;</span>
<span class="line-added">+     case FWIDTH_SEMI_CONDENSED: return 87.5f;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+     case FWIDTH_NORMAL:         return 100.f;</span>
<span class="line-added">+     case FWIDTH_SEMI_EXPANDED:  return 112.5f;</span>
<span class="line-added">+     case FWIDTH_EXPANDED:       return 125.f;</span>
<span class="line-added">+     case FWIDTH_EXTRA_EXPANDED: return 150.f;</span>
<span class="line-added">+     case FWIDTH_ULTRA_EXPANDED: return 200.f;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool subset (hb_subset_plan_t *plan) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_blob_t *os2_blob = hb_sanitize_context_t ().reference_table&lt;OS2&gt; (plan-&gt;source);</span>
      hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);
      // TODO(grieger): move to hb_blob_copy_writable_or_fail
      hb_blob_destroy (os2_blob);
  
<span class="line-modified">!     OS2 *os2_prime = (OS2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);</span>
      if (unlikely (!os2_prime)) {
        hb_blob_destroy (os2_prime_blob);
        return false;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 66,25 ***</span>
      find_min_and_max_codepoint (plan-&gt;unicodes, &amp;min_cp, &amp;max_cp);
      os2_prime-&gt;usFirstCharIndex.set (min_cp);
      os2_prime-&gt;usLastCharIndex.set (max_cp);
  
      _update_unicode_ranges (plan-&gt;unicodes, os2_prime-&gt;ulUnicodeRange);
<span class="line-modified">!     bool result = plan-&gt;add_table (HB_OT_TAG_os2, os2_prime_blob);</span>
  
      hb_blob_destroy (os2_prime_blob);
      return result;
    }
  
<span class="line-modified">!   inline void _update_unicode_ranges (const hb_set_t *codepoints,</span>
<span class="line-modified">!                                       HBUINT32 ulUnicodeRange[4]) const</span>
    {
      for (unsigned int i = 0; i &lt; 4; i++)
        ulUnicodeRange[i].set (0);
  
      hb_codepoint_t cp = HB_SET_VALUE_INVALID;
      while (codepoints-&gt;next (&amp;cp)) {
<span class="line-modified">!       unsigned int bit = hb_get_unicode_range_bit (cp);</span>
        if (bit &lt; 128)
        {
          unsigned int block = bit / 32;
          unsigned int bit_in_block = bit % 32;
          unsigned int mask = 1 &lt;&lt; bit_in_block;
<span class="line-new-header">--- 162,25 ---</span>
      find_min_and_max_codepoint (plan-&gt;unicodes, &amp;min_cp, &amp;max_cp);
      os2_prime-&gt;usFirstCharIndex.set (min_cp);
      os2_prime-&gt;usLastCharIndex.set (max_cp);
  
      _update_unicode_ranges (plan-&gt;unicodes, os2_prime-&gt;ulUnicodeRange);
<span class="line-modified">!     bool result = plan-&gt;add_table (HB_OT_TAG_OS2, os2_prime_blob);</span>
  
      hb_blob_destroy (os2_prime_blob);
      return result;
    }
  
<span class="line-modified">!   void _update_unicode_ranges (const hb_set_t *codepoints,</span>
<span class="line-modified">!                                HBUINT32 ulUnicodeRange[4]) const</span>
    {
      for (unsigned int i = 0; i &lt; 4; i++)
        ulUnicodeRange[i].set (0);
  
      hb_codepoint_t cp = HB_SET_VALUE_INVALID;
      while (codepoints-&gt;next (&amp;cp)) {
<span class="line-modified">!       unsigned int bit = _hb_ot_os2_get_unicode_range_bit (cp);</span>
        if (bit &lt; 128)
        {
          unsigned int block = bit / 32;
          unsigned int bit_in_block = bit % 32;
          unsigned int mask = 1 &lt;&lt; bit_in_block;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
          ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 &lt;&lt; 25));
        }
      }
    }
  
<span class="line-modified">!   static inline void find_min_and_max_codepoint (const hb_set_t *codepoints,</span>
                                                   uint16_t *min_cp, /* OUT */
                                                   uint16_t *max_cp  /* OUT */)
    {
      *min_cp = codepoints-&gt;get_min ();
      *max_cp = codepoints-&gt;get_max ();
<span class="line-new-header">--- 194,11 ---</span>
          ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 &lt;&lt; 25));
        }
      }
    }
  
<span class="line-modified">!   static void find_min_and_max_codepoint (const hb_set_t *codepoints,</span>
                                                   uint16_t *min_cp, /* OUT */
                                                   uint16_t *max_cp  /* OUT */)
    {
      *min_cp = codepoints-&gt;get_min ();
      *max_cp = codepoints-&gt;get_max ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,21 ***</span>
      TRAD_FARSI_FONT_PAGE        = 0xBB00, // Traditional Farsi Windows 3.1 font page
      THAI_FONT_PAGE              = 0xDE00  // Thai Windows 3.1 font page
    };
  
    // https://github.com/Microsoft/Font-Validator/blob/520aaae/OTFontFileVal/val_OS2.cs#L644-L681
<span class="line-modified">!   inline font_page_t get_font_page () const</span>
    {
<span class="line-modified">!     if (version != 0)</span>
<span class="line-modified">!       return (font_page_t) 0;</span>
<span class="line-modified">!     return (font_page_t) (fsSelection &amp; 0xFF00);</span>
    }
  
    public:
    HBUINT16      version;
<span class="line-removed">- </span>
<span class="line-removed">-   /* Version 0 */</span>
    HBINT16       xAvgCharWidth;
    HBUINT16      usWeightClass;
    HBUINT16      usWidthClass;
    HBUINT16      fsType;
    HBINT16       ySubscriptXSize;
<span class="line-new-header">--- 213,25 ---</span>
      TRAD_FARSI_FONT_PAGE        = 0xBB00, // Traditional Farsi Windows 3.1 font page
      THAI_FONT_PAGE              = 0xDE00  // Thai Windows 3.1 font page
    };
  
    // https://github.com/Microsoft/Font-Validator/blob/520aaae/OTFontFileVal/val_OS2.cs#L644-L681
<span class="line-modified">!   font_page_t get_font_page () const</span>
<span class="line-added">+   { return (font_page_t) (version == 0 ? fsSelection &amp; 0xFF00 : 0); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     if (unlikely (!c-&gt;check_struct (this))) return_trace (false);</span>
<span class="line-modified">!     if (unlikely (version &gt;= 1 &amp;&amp; !v1X.sanitize (c))) return_trace (false);</span>
<span class="line-added">+     if (unlikely (version &gt;= 2 &amp;&amp; !v2X.sanitize (c))) return_trace (false);</span>
<span class="line-added">+     if (unlikely (version &gt;= 5 &amp;&amp; !v5X.sanitize (c))) return_trace (false);</span>
<span class="line-added">+     return_trace (true);</span>
    }
  
    public:
    HBUINT16      version;
    HBINT16       xAvgCharWidth;
    HBUINT16      usWeightClass;
    HBUINT16      usWidthClass;
    HBUINT16      fsType;
    HBINT16       ySubscriptXSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,28 ***</span>
    HBINT16       sTypoAscender;
    HBINT16       sTypoDescender;
    HBINT16       sTypoLineGap;
    HBUINT16      usWinAscent;
    HBUINT16      usWinDescent;
<span class="line-modified">! </span>
<span class="line-modified">!   /* Version 1 */</span>
<span class="line-modified">!   //HBUINT32    ulCodePageRange1;</span>
<span class="line-removed">-   //HBUINT32    ulCodePageRange2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Version 2 */</span>
<span class="line-removed">-   //HBINT16     sxHeight;</span>
<span class="line-removed">-   //HBINT16     sCapHeight;</span>
<span class="line-removed">-   //HBUINT16    usDefaultChar;</span>
<span class="line-removed">-   //HBUINT16    usBreakChar;</span>
<span class="line-removed">-   //HBUINT16    usMaxContext;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Version 5 */</span>
<span class="line-removed">-   //HBUINT16    usLowerOpticalPointSize;</span>
<span class="line-removed">-   //HBUINT16    usUpperOpticalPointSize;</span>
<span class="line-removed">- </span>
    public:
<span class="line-modified">!   DEFINE_SIZE_STATIC (78);</span>
  };
  
  } /* namespace OT */
  
  
<span class="line-new-header">--- 254,15 ---</span>
    HBINT16       sTypoAscender;
    HBINT16       sTypoDescender;
    HBINT16       sTypoLineGap;
    HBUINT16      usWinAscent;
    HBUINT16      usWinDescent;
<span class="line-modified">!   OS2V1Tail     v1X;</span>
<span class="line-modified">!   OS2V2Tail     v2X;</span>
<span class="line-modified">!   OS2V5Tail     v5X;</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_MIN (78);</span>
  };
  
  } /* namespace OT */
  
  
</pre>
<center><a href="hb-ot-name-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-unicode-ranges.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
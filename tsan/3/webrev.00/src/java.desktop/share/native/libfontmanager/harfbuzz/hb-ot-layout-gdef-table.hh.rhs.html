<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2007,2008,2009  Red Hat, Inc.
  3  * Copyright © 2010,2011,2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
 30 #define HB_OT_LAYOUT_GDEF_TABLE_HH
 31 
<a name="1" id="anc1"></a><span class="line-modified"> 32 #include &quot;hb-ot-layout-common.hh&quot;</span>
 33 
<a name="2" id="anc2"></a><span class="line-modified"> 34 #include &quot;hb-font.hh&quot;</span>
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 /*
 41  * Attachment List Table
 42  */
 43 
 44 typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
 45                                          * increasing numerical order */
 46 
 47 struct AttachList
 48 {
<a name="3" id="anc3"></a><span class="line-modified"> 49   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 50                                   unsigned int start_offset,</span>
<span class="line-modified"> 51                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified"> 52                                   unsigned int *point_array /* OUT */) const</span>
 53   {
 54     unsigned int index = (this+coverage).get_coverage (glyph_id);
 55     if (index == NOT_COVERED)
 56     {
 57       if (point_count)
 58         *point_count = 0;
 59       return 0;
 60     }
 61 
 62     const AttachPoint &amp;points = this+attachPoint[index];
 63 
<a name="4" id="anc4"></a><span class="line-modified"> 64     if (point_count)</span>
<span class="line-modified"> 65     {</span>
<span class="line-modified"> 66       hb_array_t&lt;const HBUINT16&gt; array = points.sub_array (start_offset, point_count);</span>
<span class="line-added"> 67       unsigned int count = array.length;</span>
 68       for (unsigned int i = 0; i &lt; count; i++)
 69         point_array[i] = array[i];
 70     }
 71 
 72     return points.len;
 73   }
 74 
<a name="5" id="anc5"></a><span class="line-modified"> 75   bool sanitize (hb_sanitize_context_t *c) const</span>
 76   {
 77     TRACE_SANITIZE (this);
 78     return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
 79   }
 80 
 81   protected:
 82   OffsetTo&lt;Coverage&gt;
 83                 coverage;               /* Offset to Coverage table -- from
 84                                          * beginning of AttachList table */
 85   OffsetArrayOf&lt;AttachPoint&gt;
 86                 attachPoint;            /* Array of AttachPoint tables
 87                                          * in Coverage Index order */
 88   public:
 89   DEFINE_SIZE_ARRAY (4, attachPoint);
 90 };
 91 
 92 /*
 93  * Ligature Caret Table
 94  */
 95 
 96 struct CaretValueFormat1
 97 {
 98   friend struct CaretValue;
 99 
100   private:
<a name="6" id="anc6"></a><span class="line-modified">101   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
102   {
103     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
104   }
105 
<a name="7" id="anc7"></a><span class="line-modified">106   bool sanitize (hb_sanitize_context_t *c) const</span>
107   {
108     TRACE_SANITIZE (this);
109     return_trace (c-&gt;check_struct (this));
110   }
111 
112   protected:
113   HBUINT16      caretValueFormat;       /* Format identifier--format = 1 */
114   FWORD         coordinate;             /* X or Y value, in design units */
115   public:
116   DEFINE_SIZE_STATIC (4);
117 };
118 
119 struct CaretValueFormat2
120 {
121   friend struct CaretValue;
122 
123   private:
<a name="8" id="anc8"></a><span class="line-modified">124   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
125   {
126     hb_position_t x, y;
<a name="9" id="anc9"></a><span class="line-modified">127     font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y);</span>
<span class="line-modified">128     return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>


129   }
130 
<a name="10" id="anc10"></a><span class="line-modified">131   bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
134     return_trace (c-&gt;check_struct (this));
135   }
136 
137   protected:
138   HBUINT16      caretValueFormat;       /* Format identifier--format = 2 */
139   HBUINT16      caretValuePoint;        /* Contour point index on glyph */
140   public:
141   DEFINE_SIZE_STATIC (4);
142 };
143 
144 struct CaretValueFormat3
145 {
146   friend struct CaretValue;
147 
<a name="11" id="anc11"></a><span class="line-modified">148   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,</span>
<span class="line-added">149                                  const VariationStore &amp;var_store) const</span>
150   {
151     return HB_DIRECTION_IS_HORIZONTAL (direction) ?
152            font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
153            font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
154   }
155 
<a name="12" id="anc12"></a><span class="line-modified">156   bool sanitize (hb_sanitize_context_t *c) const</span>
157   {
158     TRACE_SANITIZE (this);
159     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
160   }
161 
162   protected:
163   HBUINT16      caretValueFormat;       /* Format identifier--format = 3 */
164   FWORD         coordinate;             /* X or Y value, in design units */
165   OffsetTo&lt;Device&gt;
166                 deviceTable;            /* Offset to Device table for X or Y
167                                          * value--from beginning of CaretValue
168                                          * table */
169   public:
170   DEFINE_SIZE_STATIC (6);
171 };
172 
173 struct CaretValue
174 {
<a name="13" id="anc13"></a><span class="line-modified">175   hb_position_t get_caret_value (hb_font_t *font,</span>
176                                         hb_direction_t direction,
177                                         hb_codepoint_t glyph_id,
178                                         const VariationStore &amp;var_store) const
179   {
180     switch (u.format) {
181     case 1: return u.format1.get_caret_value (font, direction);
182     case 2: return u.format2.get_caret_value (font, direction, glyph_id);
183     case 3: return u.format3.get_caret_value (font, direction, var_store);
184     default:return 0;
185     }
186   }
187 
<a name="14" id="anc14"></a><span class="line-modified">188   bool sanitize (hb_sanitize_context_t *c) const</span>
189   {
190     TRACE_SANITIZE (this);
191     if (!u.format.sanitize (c)) return_trace (false);
192     switch (u.format) {
193     case 1: return_trace (u.format1.sanitize (c));
194     case 2: return_trace (u.format2.sanitize (c));
195     case 3: return_trace (u.format3.sanitize (c));
196     default:return_trace (true);
197     }
198   }
199 
200   protected:
201   union {
202   HBUINT16              format;         /* Format identifier */
203   CaretValueFormat1     format1;
204   CaretValueFormat2     format2;
205   CaretValueFormat3     format3;
206   } u;
207   public:
208   DEFINE_SIZE_UNION (2, format);
209 };
210 
211 struct LigGlyph
212 {
<a name="15" id="anc15"></a><span class="line-modified">213   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">214                                hb_direction_t direction,</span>
<span class="line-modified">215                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">216                                const VariationStore &amp;var_store,</span>
<span class="line-modified">217                                unsigned int start_offset,</span>
<span class="line-modified">218                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">219                                hb_position_t *caret_array /* OUT */) const</span>
220   {
<a name="16" id="anc16"></a><span class="line-modified">221     if (caret_count)</span>
<span class="line-modified">222     {</span>
<span class="line-modified">223       hb_array_t &lt;const OffsetTo&lt;CaretValue&gt; &gt; array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-added">224       unsigned int count = array.length;</span>
225       for (unsigned int i = 0; i &lt; count; i++)
226         caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
227     }
228 
229     return carets.len;
230   }
231 
<a name="17" id="anc17"></a><span class="line-modified">232   bool sanitize (hb_sanitize_context_t *c) const</span>
233   {
234     TRACE_SANITIZE (this);
235     return_trace (carets.sanitize (c, this));
236   }
237 
238   protected:
239   OffsetArrayOf&lt;CaretValue&gt;
240                 carets;                 /* Offset array of CaretValue tables
241                                          * --from beginning of LigGlyph table
242                                          * --in increasing coordinate order */
243   public:
244   DEFINE_SIZE_ARRAY (2, carets);
245 };
246 
247 struct LigCaretList
248 {
<a name="18" id="anc18"></a><span class="line-modified">249   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">250                                hb_direction_t direction,</span>
<span class="line-modified">251                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">252                                const VariationStore &amp;var_store,</span>
<span class="line-modified">253                                unsigned int start_offset,</span>
<span class="line-modified">254                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">255                                hb_position_t *caret_array /* OUT */) const</span>
256   {
257     unsigned int index = (this+coverage).get_coverage (glyph_id);
258     if (index == NOT_COVERED)
259     {
260       if (caret_count)
261         *caret_count = 0;
262       return 0;
263     }
264     const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
265     return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
266   }
267 
<a name="19" id="anc19"></a><span class="line-modified">268   bool sanitize (hb_sanitize_context_t *c) const</span>
269   {
270     TRACE_SANITIZE (this);
271     return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
272   }
273 
274   protected:
275   OffsetTo&lt;Coverage&gt;
276                 coverage;               /* Offset to Coverage table--from
277                                          * beginning of LigCaretList table */
278   OffsetArrayOf&lt;LigGlyph&gt;
279                 ligGlyph;               /* Array of LigGlyph tables
280                                          * in Coverage Index order */
281   public:
282   DEFINE_SIZE_ARRAY (4, ligGlyph);
283 };
284 
285 
286 struct MarkGlyphSetsFormat1
287 {
<a name="20" id="anc20"></a><span class="line-modified">288   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
289   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
290 
<a name="21" id="anc21"></a><span class="line-modified">291   bool sanitize (hb_sanitize_context_t *c) const</span>
292   {
293     TRACE_SANITIZE (this);
294     return_trace (coverage.sanitize (c, this));
295   }
296 
297   protected:
298   HBUINT16      format;                 /* Format identifier--format = 1 */
299   ArrayOf&lt;LOffsetTo&lt;Coverage&gt; &gt;
300                 coverage;               /* Array of long offsets to mark set
301                                          * coverage tables */
302   public:
303   DEFINE_SIZE_ARRAY (4, coverage);
304 };
305 
306 struct MarkGlyphSets
307 {
<a name="22" id="anc22"></a><span class="line-modified">308   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
309   {
310     switch (u.format) {
311     case 1: return u.format1.covers (set_index, glyph_id);
312     default:return false;
313     }
314   }
315 
<a name="23" id="anc23"></a><span class="line-modified">316   bool sanitize (hb_sanitize_context_t *c) const</span>
317   {
318     TRACE_SANITIZE (this);
319     if (!u.format.sanitize (c)) return_trace (false);
320     switch (u.format) {
321     case 1: return_trace (u.format1.sanitize (c));
322     default:return_trace (true);
323     }
324   }
325 
326   protected:
327   union {
328   HBUINT16              format;         /* Format identifier */
329   MarkGlyphSetsFormat1  format1;
330   } u;
331   public:
332   DEFINE_SIZE_UNION (2, format);
333 };
334 
335 
336 /*
337  * GDEF -- Glyph Definition
338  * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
339  */
340 
<a name="24" id="anc24"></a><span class="line-added">341 </span>
342 struct GDEF
343 {
<a name="25" id="anc25"></a><span class="line-modified">344   static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;</span>
345 
346   enum GlyphClasses {
347     UnclassifiedGlyph   = 0,
348     BaseGlyph           = 1,
349     LigatureGlyph       = 2,
350     MarkGlyph           = 3,
351     ComponentGlyph      = 4
352   };
353 
<a name="26" id="anc26"></a><span class="line-modified">354   bool has_data () const { return version.to_int (); }</span>
<span class="line-modified">355   bool has_glyph_classes () const { return glyphClassDef != 0; }</span>
<span class="line-added">356   unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>
357   { return (this+glyphClassDef).get_class (glyph); }
<a name="27" id="anc27"></a><span class="line-modified">358   void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
359   { (this+glyphClassDef).add_class (glyphs, klass); }
360 
<a name="28" id="anc28"></a><span class="line-modified">361   bool has_mark_attachment_types () const { return markAttachClassDef != 0; }</span>
<span class="line-modified">362   unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
363   { return (this+markAttachClassDef).get_class (glyph); }
364 
<a name="29" id="anc29"></a><span class="line-modified">365   bool has_attach_points () const { return attachList != 0; }</span>
<span class="line-modified">366   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">367                                   unsigned int start_offset,</span>
<span class="line-modified">368                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">369                                   unsigned int *point_array /* OUT */) const</span>
370   { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
371 
<a name="30" id="anc30"></a><span class="line-modified">372   bool has_lig_carets () const { return ligCaretList != 0; }</span>
<span class="line-modified">373   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">374                                hb_direction_t direction,</span>
<span class="line-modified">375                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">376                                unsigned int start_offset,</span>
<span class="line-modified">377                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">378                                hb_position_t *caret_array /* OUT */) const</span>
379   { return (this+ligCaretList).get_lig_carets (font,
380                                                direction, glyph_id, get_var_store(),
381                                                start_offset, caret_count, caret_array); }
382 
<a name="31" id="anc31"></a><span class="line-modified">383   bool has_mark_sets () const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">384   bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
385   { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
386 
<a name="32" id="anc32"></a><span class="line-modified">387   bool has_var_store () const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">388   const VariationStore &amp;get_var_store () const</span>
389   { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
390 
<a name="33" id="anc33"></a>












391   /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<a name="34" id="anc34"></a><span class="line-modified">392    * glyph class and other bits, and high 8-bit the mark attachment type (if any).</span>
393    * Not to be confused with lookup_props which is very similar. */
<a name="35" id="anc35"></a><span class="line-modified">394   unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
395   {
396     unsigned int klass = get_glyph_class (glyph);
397 
398     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
399     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
400     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), &quot;&quot;);
401 
402     switch (klass) {
403     default:                    return 0;
404     case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;
405     case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;
406     case MarkGlyph:
407           klass = get_mark_attachment_type (glyph);
408           return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
409     }
410   }
411 
<a name="36" id="anc36"></a><span class="line-added">412   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">413                                    hb_face_t *face) const;</span>
<span class="line-added">414 </span>
<span class="line-added">415   struct accelerator_t</span>
<span class="line-added">416   {</span>
<span class="line-added">417     void init (hb_face_t *face)</span>
<span class="line-added">418     {</span>
<span class="line-added">419       this-&gt;table = hb_sanitize_context_t().reference_table&lt;GDEF&gt; (face);</span>
<span class="line-added">420       if (unlikely (this-&gt;table-&gt;is_blacklisted (this-&gt;table.get_blob (), face)))</span>
<span class="line-added">421       {</span>
<span class="line-added">422         hb_blob_destroy (this-&gt;table.get_blob ());</span>
<span class="line-added">423         this-&gt;table = hb_blob_get_empty ();</span>
<span class="line-added">424       }</span>
<span class="line-added">425     }</span>
<span class="line-added">426 </span>
<span class="line-added">427     void fini () { this-&gt;table.destroy (); }</span>
<span class="line-added">428 </span>
<span class="line-added">429     hb_blob_ptr_t&lt;GDEF&gt; table;</span>
<span class="line-added">430   };</span>
<span class="line-added">431 </span>
<span class="line-added">432   unsigned int get_size () const</span>
<span class="line-added">433   {</span>
<span class="line-added">434     return min_size +</span>
<span class="line-added">435            (version.to_int () &gt;= 0x00010002u ? markGlyphSetsDef.static_size : 0) +</span>
<span class="line-added">436            (version.to_int () &gt;= 0x00010003u ? varStore.static_size : 0);</span>
<span class="line-added">437   }</span>
<span class="line-added">438 </span>
<span class="line-added">439   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">440   {</span>
<span class="line-added">441     TRACE_SUBSET (this);</span>
<span class="line-added">442     struct GDEF *out = c-&gt;serializer-&gt;embed (*this);</span>
<span class="line-added">443     if (unlikely (!out)) return_trace (false);</span>
<span class="line-added">444 </span>
<span class="line-added">445     out-&gt;glyphClassDef.serialize_subset (c, this+glyphClassDef, out);</span>
<span class="line-added">446     out-&gt;attachList.set (0);//TODO(subset) serialize_subset (c, this+attachList, out);</span>
<span class="line-added">447     out-&gt;ligCaretList.set (0);//TODO(subset) serialize_subset (c, this+ligCaretList, out);</span>
<span class="line-added">448     out-&gt;markAttachClassDef.serialize_subset (c, this+markAttachClassDef, out);</span>
<span class="line-added">449 </span>
<span class="line-added">450     if (version.to_int () &gt;= 0x00010002u)</span>
<span class="line-added">451       out-&gt;markGlyphSetsDef.set (0);// TODO(subset) serialize_subset (c, this+markGlyphSetsDef, out);</span>
<span class="line-added">452 </span>
<span class="line-added">453     if (version.to_int () &gt;= 0x00010003u)</span>
<span class="line-added">454       out-&gt;varStore.set (0);// TODO(subset) serialize_subset (c, this+varStore, out);</span>
<span class="line-added">455 </span>
<span class="line-added">456     return_trace (true);</span>
<span class="line-added">457   }</span>
<span class="line-added">458 </span>
<span class="line-added">459   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">460   {</span>
<span class="line-added">461     TRACE_SANITIZE (this);</span>
<span class="line-added">462     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-added">463                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-added">464                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">465                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">466                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">467                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">468                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-added">469                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-added">470   }</span>
471 
472   protected:
473   FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
474                                          * 0x00010003u */
475   OffsetTo&lt;ClassDef&gt;
476                 glyphClassDef;          /* Offset to class definition table
477                                          * for glyph type--from beginning of
478                                          * GDEF header (may be Null) */
479   OffsetTo&lt;AttachList&gt;
480                 attachList;             /* Offset to list of glyphs with
481                                          * attachment points--from beginning
482                                          * of GDEF header (may be Null) */
483   OffsetTo&lt;LigCaretList&gt;
484                 ligCaretList;           /* Offset to list of positioning points
485                                          * for ligature carets--from beginning
486                                          * of GDEF header (may be Null) */
487   OffsetTo&lt;ClassDef&gt;
488                 markAttachClassDef;     /* Offset to class definition table for
489                                          * mark attachment type--from beginning
490                                          * of GDEF header (may be Null) */
491   OffsetTo&lt;MarkGlyphSets&gt;
492                 markGlyphSetsDef;       /* Offset to the table of mark set
493                                          * definitions--from beginning of GDEF
494                                          * header (may be NULL).  Introduced
495                                          * in version 0x00010002. */
496   LOffsetTo&lt;VariationStore&gt;
497                 varStore;               /* Offset to the table of Item Variation
498                                          * Store--from beginning of GDEF
499                                          * header (may be NULL).  Introduced
500                                          * in version 0x00010003. */
501   public:
502   DEFINE_SIZE_MIN (12);
503 };
504 
<a name="37" id="anc37"></a><span class="line-added">505 struct GDEF_accelerator_t : GDEF::accelerator_t {};</span>
506 
507 } /* namespace OT */
508 
509 
510 #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
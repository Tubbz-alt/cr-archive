<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-use.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-normalize.cc.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,12 +22,12 @@</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-fallback-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-fallback.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-kern.hh&quot;</span>
  
  static unsigned int
  recategorize_combining_class (hb_codepoint_t u,
                                unsigned int klass)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -160,13 +160,13 @@</span>
  
    return klass;
  }
  
  void
<span class="udiff-line-modified-removed">- _hb_ot_shape_fallback_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="udiff-line-modified-removed">-                                                    hb_font_t *font HB_UNUSED,</span>
<span class="udiff-line-modified-removed">-                                                    hb_buffer_t  *buffer)</span>
<span class="udiff-line-modified-added">+ _hb_ot_shape_fallback_mark_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="udiff-line-modified-added">+                                                         hb_font_t *font HB_UNUSED,</span>
<span class="udiff-line-modified-added">+                                                         hb_buffer_t  *buffer)</span>
  {
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = 0; i &lt; count; i++)
      if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -178,23 +178,29 @@</span>
  
  
  static void
  zero_mark_advances (hb_buffer_t *buffer,
                      unsigned int start,
<span class="udiff-line-modified-removed">-                     unsigned int end)</span>
<span class="udiff-line-modified-added">+                     unsigned int end,</span>
<span class="udiff-line-added">+                     bool adjust_offsets_when_zeroing)</span>
  {
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = start; i &lt; end; i++)
      if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
      {
<span class="udiff-line-added">+       if (adjust_offsets_when_zeroing)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         buffer-&gt;pos[i].x_offset -= buffer-&gt;pos[i].x_advance;</span>
<span class="udiff-line-added">+         buffer-&gt;pos[i].y_offset -= buffer-&gt;pos[i].y_advance;</span>
<span class="udiff-line-added">+       }</span>
        buffer-&gt;pos[i].x_advance = 0;
        buffer-&gt;pos[i].y_advance = 0;
      }
  }
  
  static inline void
<span class="udiff-line-modified-removed">- position_mark (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-added">+ position_mark (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
                 hb_font_t *font,
                 hb_buffer_t  *buffer,
                 hb_glyph_extents_t &amp;base_extents,
                 unsigned int i,
                 unsigned int combining_class)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -301,26 +307,31 @@</span>
  static inline void
  position_around_base (const hb_ot_shape_plan_t *plan,
                        hb_font_t *font,
                        hb_buffer_t  *buffer,
                        unsigned int base,
<span class="udiff-line-modified-removed">-                       unsigned int end)</span>
<span class="udiff-line-modified-added">+                       unsigned int end,</span>
<span class="udiff-line-added">+                       bool adjust_offsets_when_zeroing)</span>
  {
    hb_direction_t horiz_dir = HB_DIRECTION_INVALID;
  
    buffer-&gt;unsafe_to_break (base, end);
  
    hb_glyph_extents_t base_extents;
    if (!font-&gt;get_glyph_extents (buffer-&gt;info[base].codepoint,
                                  &amp;base_extents))
    {
      /* If extents don&#39;t work, zero marks and go home. */
<span class="udiff-line-modified-removed">-     zero_mark_advances (buffer, base + 1, end);</span>
<span class="udiff-line-modified-added">+     zero_mark_advances (buffer, base + 1, end, adjust_offsets_when_zeroing);</span>
      return;
    }
<span class="udiff-line-removed">-   base_extents.x_bearing += buffer-&gt;pos[base].x_offset;</span>
    base_extents.y_bearing += buffer-&gt;pos[base].y_offset;
<span class="udiff-line-added">+   /* Use horizontal advance for horizontal positioning.</span>
<span class="udiff-line-added">+    * Generally a better idea.  Also works for zero-ink glyphs.  See:</span>
<span class="udiff-line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1532 */</span>
<span class="udiff-line-added">+   base_extents.x_bearing = 0;</span>
<span class="udiff-line-added">+   base_extents.width = font-&gt;get_glyph_h_advance (buffer-&gt;info[base].codepoint);</span>
  
    unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[base]);
    /* Use integer for num_lig_components such that it doesn&#39;t convert to unsigned
     * when we divide or multiply by it. */
    int num_lig_components = _hb_glyph_info_get_lig_num_comps (&amp;buffer-&gt;info[base]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -392,11 +403,12 @@</span>
  static inline void
  position_cluster (const hb_ot_shape_plan_t *plan,
                    hb_font_t *font,
                    hb_buffer_t  *buffer,
                    unsigned int start,
<span class="udiff-line-modified-removed">-                   unsigned int end)</span>
<span class="udiff-line-modified-added">+                   unsigned int end,</span>
<span class="udiff-line-added">+                   bool adjust_offsets_when_zeroing)</span>
  {
    if (end - start &lt; 2)
      return;
  
    /* Find the base glyph */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -408,103 +420,89 @@</span>
        unsigned int j;
        for (j = i + 1; j &lt; end; j++)
          if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[j])))
            break;
  
<span class="udiff-line-modified-removed">-       position_around_base (plan, font, buffer, i, j);</span>
<span class="udiff-line-modified-added">+       position_around_base (plan, font, buffer, i, j, adjust_offsets_when_zeroing);</span>
  
        i = j - 1;
      }
  }
  
  void
<span class="udiff-line-modified-removed">- _hb_ot_shape_fallback_position (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-removed">-                                 hb_font_t *font,</span>
<span class="udiff-line-modified-removed">-                                 hb_buffer_t  *buffer)</span>
<span class="udiff-line-modified-added">+ _hb_ot_shape_fallback_mark_position (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-added">+                                      hb_font_t *font,</span>
<span class="udiff-line-modified-added">+                                      hb_buffer_t  *buffer,</span>
<span class="udiff-line-added">+                                      bool adjust_offsets_when_zeroing)</span>
  {
    _hb_buffer_assert_gsubgpos_vars (buffer);
  
    unsigned int start = 0;
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = 1; i &lt; count; i++)
      if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))) {
<span class="udiff-line-modified-removed">-       position_cluster (plan, font, buffer, start, i);</span>
<span class="udiff-line-modified-added">+       position_cluster (plan, font, buffer, start, i, adjust_offsets_when_zeroing);</span>
        start = i;
      }
<span class="udiff-line-modified-removed">-   position_cluster (plan, font, buffer, start, count);</span>
<span class="udiff-line-modified-added">+   position_cluster (plan, font, buffer, start, count, adjust_offsets_when_zeroing);</span>
  }
  
  
<span class="udiff-line-modified-removed">- /* Performs old-style TrueType kerning. */</span>
<span class="udiff-line-modified-added">+ struct hb_ot_shape_fallback_kern_driver_t</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   hb_ot_shape_fallback_kern_driver_t (hb_font_t   *font_,</span>
<span class="udiff-line-added">+                                       hb_buffer_t *buffer) :</span>
<span class="udiff-line-added">+     font (font_), direction (buffer-&gt;props.direction) {}</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   hb_position_t get_kerning (hb_codepoint_t first, hb_codepoint_t second) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     hb_position_t kern = 0;</span>
<span class="udiff-line-added">+     font-&gt;get_glyph_kerning_for_direction (first, second,</span>
<span class="udiff-line-added">+                                            direction,</span>
<span class="udiff-line-added">+                                            &amp;kern, &amp;kern);</span>
<span class="udiff-line-added">+     return kern;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   hb_font_t *font;</span>
<span class="udiff-line-added">+   hb_direction_t direction;</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /* Performs font-assisted kerning. */</span>
  void
  _hb_ot_shape_fallback_kern (const hb_ot_shape_plan_t *plan,
                              hb_font_t *font,
<span class="udiff-line-modified-removed">-                             hb_buffer_t  *buffer)</span>
<span class="udiff-line-modified-added">+                             hb_buffer_t *buffer)</span>
  {
<span class="udiff-line-modified-removed">-   if (!plan-&gt;has_kern) return;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   OT::hb_ot_apply_context_t c (1, font, buffer);</span>
<span class="udiff-line-modified-removed">-   c.set_lookup_mask (plan-&gt;kern_mask);</span>
<span class="udiff-line-removed">-   c.set_lookup_props (OT::LookupFlag::IgnoreMarks);</span>
<span class="udiff-line-removed">-   OT::hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c.iter_input;</span>
<span class="udiff-line-removed">-   skippy_iter.init (&amp;c);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   unsigned int count = buffer-&gt;len;</span>
<span class="udiff-line-removed">-   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="udiff-line-removed">-   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="udiff-line-removed">-   for (unsigned int idx = 0; idx &lt; count;)</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     skippy_iter.reset (idx, 1);</span>
<span class="udiff-line-removed">-     if (!skippy_iter.next ())</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       idx++;</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction) ?</span>
<span class="udiff-line-modified-added">+       !font-&gt;has_glyph_h_kerning_func () :</span>
<span class="udiff-line-modified-added">+       !font-&gt;has_glyph_v_kerning_func ())</span>
<span class="udiff-line-modified-added">+     return;</span>
  
<span class="udiff-line-modified-removed">-     hb_position_t x_kern, y_kern;</span>
<span class="udiff-line-removed">-     font-&gt;get_glyph_kerning_for_direction (info[idx].codepoint,</span>
<span class="udiff-line-removed">-                                            info[skippy_iter.idx].codepoint,</span>
<span class="udiff-line-removed">-                                            buffer-&gt;props.direction,</span>
<span class="udiff-line-removed">-                                            &amp;x_kern, &amp;y_kern);</span>
<span class="udiff-line-modified-added">+   bool reverse = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);</span>
  
<span class="udiff-line-modified-removed">-     if (x_kern)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-removed">-       hb_position_t kern1 = x_kern &gt;&gt; 1;</span>
<span class="udiff-line-removed">-       hb_position_t kern2 = x_kern - kern1;</span>
<span class="udiff-line-removed">-       pos[idx].x_advance += kern1;</span>
<span class="udiff-line-removed">-       pos[skippy_iter.idx].x_advance += kern2;</span>
<span class="udiff-line-removed">-       pos[skippy_iter.idx].x_offset += kern2;</span>
<span class="udiff-line-removed">-       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   if (reverse)</span>
<span class="udiff-line-modified-added">+     buffer-&gt;reverse ();</span>
  
<span class="udiff-line-modified-removed">-     if (y_kern)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       hb_position_t kern1 = y_kern &gt;&gt; 1;</span>
<span class="udiff-line-removed">-       hb_position_t kern2 = y_kern - kern1;</span>
<span class="udiff-line-removed">-       pos[idx].y_advance += kern1;</span>
<span class="udiff-line-removed">-       pos[skippy_iter.idx].y_advance += kern2;</span>
<span class="udiff-line-removed">-       pos[skippy_iter.idx].y_offset += kern2;</span>
<span class="udiff-line-removed">-       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   hb_ot_shape_fallback_kern_driver_t driver (font, buffer);</span>
<span class="udiff-line-modified-added">+   OT::hb_kern_machine_t&lt;hb_ot_shape_fallback_kern_driver_t&gt; machine (driver);</span>
<span class="udiff-line-modified-added">+   machine.kern (font, buffer, plan-&gt;kern_mask, false);</span>
  
<span class="udiff-line-modified-removed">-     idx = skippy_iter.idx;</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-added">+   if (reverse)</span>
<span class="udiff-line-modified-added">+     buffer-&gt;reverse ();</span>
  }
  
  
  /* Adjusts width of various spaces. */
  void
<span class="udiff-line-modified-removed">- _hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-added">+ _hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
                                hb_font_t *font,
                                hb_buffer_t  *buffer)
  {
<span class="udiff-line-removed">-   if (!HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">- </span>
    hb_glyph_info_t *info = buffer-&gt;info;
    hb_glyph_position_t *pos = buffer-&gt;pos;
<span class="udiff-line-added">+   bool horizontal = HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction);</span>
    unsigned int count = buffer-&gt;len;
    for (unsigned int i = 0; i &lt; count; i++)
      if (_hb_glyph_info_is_unicode_space (&amp;info[i]) &amp;&amp; !_hb_glyph_info_ligated (&amp;info[i]))
      {
        hb_unicode_funcs_t::space_t space_type = _hb_glyph_info_get_unicode_space_fallback_type (&amp;info[i]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -521,39 +519,55 @@</span>
          case t::SPACE_EM_3:
          case t::SPACE_EM_4:
          case t::SPACE_EM_5:
          case t::SPACE_EM_6:
          case t::SPACE_EM_16:
<span class="udiff-line-modified-removed">-           pos[i].x_advance = (font-&gt;x_scale + ((int) space_type)/2) / (int) space_type;</span>
<span class="udiff-line-modified-added">+           if (horizontal)</span>
<span class="udiff-line-added">+             pos[i].x_advance = +(font-&gt;x_scale + ((int) space_type)/2) / (int) space_type;</span>
<span class="udiff-line-added">+           else</span>
<span class="udiff-line-added">+             pos[i].y_advance = -(font-&gt;y_scale + ((int) space_type)/2) / (int) space_type;</span>
            break;
  
          case t::SPACE_4_EM_18:
<span class="udiff-line-modified-removed">-           pos[i].x_advance = (int64_t) font-&gt;x_scale * 4 / 18;</span>
<span class="udiff-line-modified-added">+           if (horizontal)</span>
<span class="udiff-line-added">+             pos[i].x_advance = (int64_t) +font-&gt;x_scale * 4 / 18;</span>
<span class="udiff-line-added">+           else</span>
<span class="udiff-line-added">+             pos[i].y_advance = (int64_t) -font-&gt;y_scale * 4 / 18;</span>
            break;
  
          case t::SPACE_FIGURE:
            for (char u = &#39;0&#39;; u &lt;= &#39;9&#39;; u++)
              if (font-&gt;get_nominal_glyph (u, &amp;glyph))
              {
<span class="udiff-line-modified-removed">-               pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="udiff-line-modified-added">+               if (horizontal)</span>
<span class="udiff-line-added">+                 pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="udiff-line-added">+               else</span>
<span class="udiff-line-added">+                 pos[i].y_advance = font-&gt;get_glyph_v_advance (glyph);</span>
                break;
              }
            break;
  
          case t::SPACE_PUNCTUATION:
<span class="udiff-line-modified-removed">-           if (font-&gt;get_nominal_glyph (&#39;.&#39;, &amp;glyph))</span>
<span class="udiff-line-modified-removed">-             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="udiff-line-modified-removed">-           else if (font-&gt;get_nominal_glyph (&#39;,&#39;, &amp;glyph))</span>
<span class="udiff-line-modified-removed">-             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="udiff-line-modified-added">+           if (font-&gt;get_nominal_glyph (&#39;.&#39;, &amp;glyph) ||</span>
<span class="udiff-line-modified-added">+               font-&gt;get_nominal_glyph (&#39;,&#39;, &amp;glyph))</span>
<span class="udiff-line-modified-added">+           {</span>
<span class="udiff-line-modified-added">+             if (horizontal)</span>
<span class="udiff-line-added">+               pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+               pos[i].y_advance = font-&gt;get_glyph_v_advance (glyph);</span>
<span class="udiff-line-added">+           }</span>
            break;
  
          case t::SPACE_NARROW:
            /* Half-space?
             * Unicode doc https://unicode.org/charts/PDF/U2000.pdf says ~1/4 or 1/5 of EM.
             * However, in my testing, many fonts have their regular space being about that
             * size.  To me, a percentage of the space width makes more sense.  Half is as
             * good as any. */
<span class="udiff-line-modified-removed">-           pos[i].x_advance /= 2;</span>
<span class="udiff-line-modified-added">+           if (horizontal)</span>
<span class="udiff-line-added">+             pos[i].x_advance /= 2;</span>
<span class="udiff-line-added">+           else</span>
<span class="udiff-line-added">+             pos[i].y_advance /= 2;</span>
            break;
        }
      }
  }
</pre>
<center><a href="hb-ot-shape-complex-use.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-normalize.cc.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-serialize.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-buffer-deserialize-text.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer-serialize.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-buffer-private.hh&quot;</span>
 28 
 29 
 30 static const char *serialize_formats[] = {
 31   &quot;text&quot;,
 32   &quot;json&quot;,
 33   nullptr
 34 };
 35 
 36 /**
 37  * hb_buffer_serialize_list_formats:
 38  *
 39  * Returns a list of supported buffer serialization formats.
 40  *
 41  * Return value: (transfer none):
 42  * A string array of buffer serialization formats. Should not be freed.
 43  *
 44  * Since: 0.9.7
 45  **/
 46 const char **
<span class="line-modified"> 47 hb_buffer_serialize_list_formats (void)</span>
 48 {
 49   return serialize_formats;
 50 }
 51 
 52 /**
 53  * hb_buffer_serialize_format_from_string:
 54  * @str: (array length=len) (element-type uint8_t): a string to parse
 55  * @len: length of @str, or -1 if string is %NULL terminated
 56  *
 57  * Parses a string into an #hb_buffer_serialize_format_t. Does not check if
 58  * @str is a valid buffer serialization format, use
 59  * hb_buffer_serialize_list_formats() to get the list of supported formats.
 60  *
 61  * Return value:
 62  * The parsed #hb_buffer_serialize_format_t.
 63  *
 64  * Since: 0.9.7
 65  **/
 66 hb_buffer_serialize_format_t
 67 hb_buffer_serialize_format_from_string (const char *str, int len)
</pre>
<hr />
<pre>
229     if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS)) {
230       p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;=%u&quot;, info[i].cluster));
231     }
232 
233     if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS))
234     {
235       if (x+pos[i].x_offset || y+pos[i].y_offset)
236         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;@%d,%d&quot;, x+pos[i].x_offset, y+pos[i].y_offset));
237 
238       if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))
239       {
240         *p++ = &#39;+&#39;;
241         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;%d&quot;, pos[i].x_advance));
242         if (pos[i].y_advance)
243           p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;,%d&quot;, pos[i].y_advance));
244       }
245     }
246 
247     if (flags &amp; HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS)
248     {
<span class="line-modified">249       if (info[i].mask &amp;HB_GLYPH_FLAG_DEFINED)</span>
250         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;#%X&quot;, info[i].mask &amp;HB_GLYPH_FLAG_DEFINED));
251     }
252 
253     if (flags &amp; HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS)
254     {
255       hb_glyph_extents_t extents;
256       hb_font_get_glyph_extents(font, info[i].codepoint, &amp;extents);
257       p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;&lt;%d,%d,%d,%d&gt;&quot;, extents.x_bearing, extents.y_bearing, extents.width, extents.height));
258     }
259 
260     unsigned int l = p - b;
261     if (buf_size &gt; l)
262     {
263       memcpy (buf, b, l);
264       buf += l;
265       buf_size -= l;
266       *buf_consumed += l;
267       *buf = &#39;\0&#39;;
268     } else
269       return i - start;
</pre>
<hr />
<pre>
423 
424 /**
425  * hb_buffer_deserialize_glyphs:
426  * @buffer: an #hb_buffer_t buffer.
427  * @buf: (array length=buf_len):
428  * @buf_len:
429  * @end_ptr: (out):
430  * @font:
431  * @format:
432  *
433  *
434  *
435  * Return value:
436  *
437  * Since: 0.9.7
438  **/
439 hb_bool_t
440 hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,
441                               const char *buf,
442                               int buf_len, /* -1 means nul-terminated */
<span class="line-modified">443                               const char **end_ptr, /* May be nullptr */</span>
<span class="line-modified">444                               hb_font_t *font, /* May be nullptr */</span>
445                               hb_buffer_serialize_format_t format)
446 {
447   const char *end;
448   if (!end_ptr)
449     end_ptr = &amp;end;
450   *end_ptr = buf;
451 
452   assert ((!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID) ||
453           buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS);
454 
455   if (buf_len == -1)
456     buf_len = strlen (buf);
457 
458   if (!buf_len)
459   {
460     *end_ptr = buf;
461     return false;
462   }
463 
464   hb_buffer_set_content_type (buffer, HB_BUFFER_CONTENT_TYPE_GLYPHS);
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-buffer.hh&quot;</span>
 28 
 29 
 30 static const char *serialize_formats[] = {
 31   &quot;text&quot;,
 32   &quot;json&quot;,
 33   nullptr
 34 };
 35 
 36 /**
 37  * hb_buffer_serialize_list_formats:
 38  *
 39  * Returns a list of supported buffer serialization formats.
 40  *
 41  * Return value: (transfer none):
 42  * A string array of buffer serialization formats. Should not be freed.
 43  *
 44  * Since: 0.9.7
 45  **/
 46 const char **
<span class="line-modified"> 47 hb_buffer_serialize_list_formats ()</span>
 48 {
 49   return serialize_formats;
 50 }
 51 
 52 /**
 53  * hb_buffer_serialize_format_from_string:
 54  * @str: (array length=len) (element-type uint8_t): a string to parse
 55  * @len: length of @str, or -1 if string is %NULL terminated
 56  *
 57  * Parses a string into an #hb_buffer_serialize_format_t. Does not check if
 58  * @str is a valid buffer serialization format, use
 59  * hb_buffer_serialize_list_formats() to get the list of supported formats.
 60  *
 61  * Return value:
 62  * The parsed #hb_buffer_serialize_format_t.
 63  *
 64  * Since: 0.9.7
 65  **/
 66 hb_buffer_serialize_format_t
 67 hb_buffer_serialize_format_from_string (const char *str, int len)
</pre>
<hr />
<pre>
229     if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS)) {
230       p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;=%u&quot;, info[i].cluster));
231     }
232 
233     if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS))
234     {
235       if (x+pos[i].x_offset || y+pos[i].y_offset)
236         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;@%d,%d&quot;, x+pos[i].x_offset, y+pos[i].y_offset));
237 
238       if (!(flags &amp; HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))
239       {
240         *p++ = &#39;+&#39;;
241         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;%d&quot;, pos[i].x_advance));
242         if (pos[i].y_advance)
243           p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;,%d&quot;, pos[i].y_advance));
244       }
245     }
246 
247     if (flags &amp; HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS)
248     {
<span class="line-modified">249       if (info[i].mask &amp; HB_GLYPH_FLAG_DEFINED)</span>
250         p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;#%X&quot;, info[i].mask &amp;HB_GLYPH_FLAG_DEFINED));
251     }
252 
253     if (flags &amp; HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS)
254     {
255       hb_glyph_extents_t extents;
256       hb_font_get_glyph_extents(font, info[i].codepoint, &amp;extents);
257       p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), &quot;&lt;%d,%d,%d,%d&gt;&quot;, extents.x_bearing, extents.y_bearing, extents.width, extents.height));
258     }
259 
260     unsigned int l = p - b;
261     if (buf_size &gt; l)
262     {
263       memcpy (buf, b, l);
264       buf += l;
265       buf_size -= l;
266       *buf_consumed += l;
267       *buf = &#39;\0&#39;;
268     } else
269       return i - start;
</pre>
<hr />
<pre>
423 
424 /**
425  * hb_buffer_deserialize_glyphs:
426  * @buffer: an #hb_buffer_t buffer.
427  * @buf: (array length=buf_len):
428  * @buf_len:
429  * @end_ptr: (out):
430  * @font:
431  * @format:
432  *
433  *
434  *
435  * Return value:
436  *
437  * Since: 0.9.7
438  **/
439 hb_bool_t
440 hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,
441                               const char *buf,
442                               int buf_len, /* -1 means nul-terminated */
<span class="line-modified">443                               const char **end_ptr, /* May be NULL */</span>
<span class="line-modified">444                               hb_font_t *font, /* May be NULL */</span>
445                               hb_buffer_serialize_format_t format)
446 {
447   const char *end;
448   if (!end_ptr)
449     end_ptr = &amp;end;
450   *end_ptr = buf;
451 
452   assert ((!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID) ||
453           buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS);
454 
455   if (buf_len == -1)
456     buf_len = strlen (buf);
457 
458   if (!buf_len)
459   {
460     *end_ptr = buf;
461     return false;
462   }
463 
464   hb_buffer_set_content_type (buffer, HB_BUFFER_CONTENT_TYPE_GLYPHS);
</pre>
</td>
</tr>
</table>
<center><a href="hb-buffer-deserialize-text.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
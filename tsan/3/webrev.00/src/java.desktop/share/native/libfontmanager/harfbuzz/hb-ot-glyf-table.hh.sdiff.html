<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-font.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-head-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-glyf-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_GLYF_TABLE_HH
 28 #define HB_OT_GLYF_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 #include &quot;hb-ot-head-table.hh&quot;
 32 #include &quot;hb-subset-glyf.hh&quot;
<span class="line-removed"> 33 #include &quot;hb-subset-plan.hh&quot;</span>
<span class="line-removed"> 34 #include &quot;hb-subset-private.hh&quot;</span>
 35 
 36 namespace OT {
 37 
 38 
 39 /*
 40  * loca -- Index to Location
 41  * https://docs.microsoft.com/en-us/typography/opentype/spec/loca
 42  */
 43 #define HB_OT_TAG_loca HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;a&#39;)
 44 
 45 
 46 struct loca
 47 {
 48   friend struct glyf;
 49 
<span class="line-modified"> 50   static const hb_tag_t tableTag = HB_OT_TAG_loca;</span>
 51 
<span class="line-modified"> 52   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 53   {
 54     TRACE_SANITIZE (this);
 55     return_trace (true);
 56   }
 57 
 58   protected:
<span class="line-modified"> 59   HBUINT8               dataZ[VAR];             /* Location data. */</span>
<span class="line-modified"> 60   DEFINE_SIZE_ARRAY (0, dataZ);</span>



 61 };
 62 
 63 
 64 /*
 65  * glyf -- TrueType Glyph Data
 66  * https://docs.microsoft.com/en-us/typography/opentype/spec/glyf
 67  */
 68 #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
 69 
 70 
 71 struct glyf
 72 {
<span class="line-modified"> 73   static const hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
 74 
<span class="line-modified"> 75   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 76   {
 77     TRACE_SANITIZE (this);
 78     /* We don&#39;t check for anything specific here.  The users of the
 79      * struct do all the hard work... */
 80     return_trace (true);
 81   }
 82 
<span class="line-modified"> 83   inline bool subset (hb_subset_plan_t *plan) const</span>
 84   {
 85     hb_blob_t *glyf_prime = nullptr;
 86     hb_blob_t *loca_prime = nullptr;
 87 
 88     bool success = true;
 89     bool use_short_loca = false;
 90     if (hb_subset_glyf_and_loca (plan, &amp;use_short_loca, &amp;glyf_prime, &amp;loca_prime)) {
 91       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_glyf, glyf_prime);
 92       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_loca, loca_prime);
 93       success = success &amp;&amp; _add_head_and_set_loca_version (plan, use_short_loca);
 94     } else {
 95       success = false;
 96     }
 97     hb_blob_destroy (loca_prime);
 98     hb_blob_destroy (glyf_prime);
 99 
100     return success;
101   }
102 
103   static bool
104   _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
105   {
<span class="line-modified">106     hb_blob_t *head_blob = OT::Sanitizer&lt;OT::head&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_head));</span>
107     hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
108     hb_blob_destroy (head_blob);
109 
110     if (unlikely (!head_prime_blob))
111       return false;
112 
<span class="line-modified">113     OT::head *head_prime = (OT::head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
114     head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
115     bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
116 
117     hb_blob_destroy (head_prime_blob);
118     return success;
119   }
120 
121   struct GlyphHeader
122   {
123     HBINT16             numberOfContours;       /* If the number of contours is
124                                                  * greater than or equal to zero,
125                                                  * this is a simple glyph; if negative,
126                                                  * this is a composite glyph. */
127     FWORD               xMin;                   /* Minimum x for coordinate data. */
128     FWORD               yMin;                   /* Minimum y for coordinate data. */
129     FWORD               xMax;                   /* Maximum x for coordinate data. */
130     FWORD               yMax;                   /* Maximum y for coordinate data. */
131 
132     DEFINE_SIZE_STATIC (10);
133   };
134 
135   struct CompositeGlyphHeader
136   {
137     enum composite_glyph_flag_t {
138       ARG_1_AND_2_ARE_WORDS =      0x0001,
139       ARGS_ARE_XY_VALUES =         0x0002,
140       ROUND_XY_TO_GRID =           0x0004,
141       WE_HAVE_A_SCALE =            0x0008,
142       MORE_COMPONENTS =            0x0020,
143       WE_HAVE_AN_X_AND_Y_SCALE =   0x0040,
144       WE_HAVE_A_TWO_BY_TWO =       0x0080,
145       WE_HAVE_INSTRUCTIONS =       0x0100,
146       USE_MY_METRICS =             0x0200,
147       OVERLAP_COMPOUND =           0x0400,
148       SCALED_COMPONENT_OFFSET =    0x0800,
149       UNSCALED_COMPONENT_OFFSET =  0x1000
150     };
151 
152     HBUINT16 flags;
<span class="line-modified">153     HBUINT16 glyphIndex;</span>
154 
<span class="line-modified">155     inline unsigned int get_size (void) const</span>
156     {
157       unsigned int size = min_size;
<span class="line-modified">158       if (flags &amp; ARG_1_AND_2_ARE_WORDS) {</span>
<span class="line-modified">159         // arg1 and 2 are int16</span>
<span class="line-modified">160         size += 4;</span>
<span class="line-modified">161       } else {</span>
<span class="line-modified">162         // arg1 and 2 are int8</span>
<span class="line-modified">163         size += 2;</span>
<span class="line-modified">164       }</span>
<span class="line-modified">165       if (flags &amp; WE_HAVE_A_SCALE) {</span>
<span class="line-modified">166         // One x 16 bit (scale)</span>
<span class="line-modified">167         size += 2;</span>
<span class="line-modified">168       } else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) {</span>
<span class="line-modified">169         // Two x 16 bit (xscale, yscale)</span>
<span class="line-removed">170         size += 4;</span>
<span class="line-removed">171       } else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) {</span>
<span class="line-removed">172         // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-removed">173         size += 8;</span>
<span class="line-removed">174       }</span>
175       return size;
176     }
177 
178     struct Iterator
179     {
180       const char *glyph_start;
181       const char *glyph_end;
182       const CompositeGlyphHeader *current;
183 
<span class="line-modified">184       inline bool move_to_next ()</span>
185       {
186         if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
187         {
188           const CompositeGlyphHeader *possible =
189             &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
190           if (!in_range (possible))
191             return false;
192           current = possible;
193           return true;
194         }
195         return false;
196       }
197 
<span class="line-modified">198       inline bool in_range (const CompositeGlyphHeader *composite) const</span>
199       {
200         return (const char *) composite &gt;= glyph_start
201           &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<span class="line-modified">202           &amp;&amp; ((const char *) composite + composite-&gt;get_size()) &lt;= glyph_end;</span>
203       }
204     };
205 
<span class="line-modified">206     static inline bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">207                                      unsigned int length,</span>
<span class="line-modified">208                                      CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
209     {
210       if (length &lt; GlyphHeader::static_size)
211         return false; /* Empty glyph; zero extents. */
212 
213       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
214       if (glyph_header.numberOfContours &lt; 0)
215       {
216         const CompositeGlyphHeader *possible =
217           &amp;StructAfter&lt;CompositeGlyphHeader, GlyphHeader&gt; (glyph_header);
218 
219         iterator-&gt;glyph_start = glyph_data;
220         iterator-&gt;glyph_end = (const char *) glyph_data + length;
221         if (!iterator-&gt;in_range (possible))
222           return false;
223         iterator-&gt;current = possible;
224         return true;
225       }
226 
227       return false;
228     }
229 
230     DEFINE_SIZE_MIN (4);
231   };
232 
233   struct accelerator_t
234   {
<span class="line-modified">235     inline void init (hb_face_t *face)</span>
236     {
237       memset (this, 0, sizeof (accelerator_t));
238 
<span class="line-modified">239       hb_blob_t *head_blob = Sanitizer&lt;head&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_head));</span>
<span class="line-modified">240       const head *head_table = head_blob-&gt;as&lt;head&gt; ();</span>
<span class="line-modified">241       if (head_table == &amp;Null(head) || (unsigned int) head_table-&gt;indexToLocFormat &gt; 1 || head_table-&gt;glyphDataFormat != 0)</span>
<span class="line-removed">242       {</span>
<span class="line-removed">243         /* head table is not present, or in an unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>
<span class="line-removed">244         hb_blob_destroy (head_blob);</span>
245         return;
<span class="line-modified">246       }</span>
<span class="line-removed">247       short_offset = 0 == head_table-&gt;indexToLocFormat;</span>
<span class="line-removed">248       hb_blob_destroy (head_blob);</span>
249 
<span class="line-modified">250       loca_blob = Sanitizer&lt;loca&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_loca));</span>
<span class="line-modified">251       loca_table = loca_blob-&gt;as&lt;loca&gt; ();</span>
<span class="line-removed">252       glyf_blob = Sanitizer&lt;glyf&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_glyf));</span>
<span class="line-removed">253       glyf_table = glyf_blob-&gt;as&lt;glyf&gt; ();</span>
254 
<span class="line-modified">255       num_glyphs = MAX (1u, hb_blob_get_length (loca_blob) / (short_offset ? 2 : 4)) - 1;</span>
<span class="line-removed">256       glyf_len = hb_blob_get_length (glyf_blob);</span>
257     }
258 
<span class="line-modified">259     inline void fini (void)</span>
260     {
<span class="line-modified">261       hb_blob_destroy (loca_blob);</span>
<span class="line-modified">262       hb_blob_destroy (glyf_blob);</span>
263     }
264 
265     /*
266      * Returns true if the referenced glyph is a valid glyph and a composite glyph.
267      * If true is returned a pointer to the composite glyph will be written into
268      * composite.
269      */
<span class="line-modified">270     inline bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">271                                CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
272     {
<span class="line-modified">273       if (this-&gt;glyf_table == &amp;Null(glyf) || !num_glyphs)</span>
274         return false;
275 
276       unsigned int start_offset, end_offset;
277       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
278         return false; /* glyph not found */
279 
<span class="line-modified">280       return CompositeGlyphHeader::get_iterator ((const char*) this-&gt;glyf_table + start_offset,</span>
281                                                  end_offset - start_offset,
282                                                  composite);
283     }
284 
285     enum simple_glyph_flag_t {

286       FLAG_X_SHORT = 0x02,
287       FLAG_Y_SHORT = 0x04,
288       FLAG_REPEAT = 0x08,
289       FLAG_X_SAME = 0x10,
<span class="line-modified">290       FLAG_Y_SAME = 0x20</span>


291     };
292 
293     /* based on FontTools _g_l_y_f.py::trim */
<span class="line-modified">294     inline bool remove_padding(unsigned int start_offset,</span>
<span class="line-modified">295                                unsigned int *end_offset) const</span>
296     {
<span class="line-modified">297       if (*end_offset - start_offset &lt; GlyphHeader::static_size)</span>
<span class="line-removed">298         return true;</span>
299 
300       const char *glyph = ((const char *) glyf_table) + start_offset;
301       const char * const glyph_end = glyph + (*end_offset - start_offset);
302       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
303       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
304 
305       if (num_contours &lt; 0)
306         /* Trimming for composites not implemented.
307          * If removing hints it falls out of that. */
308         return true;
309       else if (num_contours &gt; 0)
310       {
311         /* simple glyph w/contours, possibly trimmable */
312         glyph += GlyphHeader::static_size + 2 * num_contours;
313 
314         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<span class="line-modified">315         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph - 2, 0) + 1;</span>
<span class="line-modified">316         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt;(glyph, 0);</span>
317 
318         glyph += 2 + nInstructions;
319         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
320 
321         unsigned int coordBytes = 0;
322         unsigned int coordsWithFlags = 0;
323         while (glyph &lt; glyph_end)
324         {
325           uint8_t flag = (uint8_t) *glyph;
326           glyph++;
327 
328           unsigned int repeat = 1;
329           if (flag &amp; FLAG_REPEAT)
330           {
331             if (glyph &gt;= glyph_end)
332             {
333               DEBUG_MSG(SUBSET, nullptr, &quot;Bad flag&quot;);
334               return false;
335             }
336             repeat = ((uint8_t) *glyph) + 1;
337             glyph++;
338           }
339 
340           unsigned int xBytes, yBytes;
341           xBytes = yBytes = 0;
<span class="line-modified">342           if (flag &amp; FLAG_X_SHORT)</span>
<span class="line-modified">343             xBytes = 1;</span>
<span class="line-removed">344           else if ((flag &amp; FLAG_X_SAME) == 0)</span>
<span class="line-removed">345             xBytes = 2;</span>
346 
<span class="line-modified">347           if (flag &amp; FLAG_Y_SHORT)</span>
<span class="line-modified">348             yBytes = 1;</span>
<span class="line-removed">349           else if ((flag &amp; FLAG_Y_SAME) == 0)</span>
<span class="line-removed">350             yBytes = 2;</span>
351 
352           coordBytes += (xBytes + yBytes) * repeat;
353           coordsWithFlags += repeat;
354           if (coordsWithFlags &gt;= nCoordinates)
355             break;
356         }
357 
358         if (coordsWithFlags != nCoordinates)
359         {
360           DEBUG_MSG(SUBSET, nullptr, &quot;Expect %d coords to have flags, got flags for %d&quot;, nCoordinates, coordsWithFlags);
361           return false;
362         }
363         glyph += coordBytes;
364 
365         if (glyph &lt; glyph_end)
366           *end_offset -= glyph_end - glyph;
367       }
368       return true;
369     }
370 
<span class="line-modified">371     inline bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">372                              unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">373                              unsigned int   *end_offset   /* OUT */) const</span>
374     {
375       if (unlikely (glyph &gt;= num_glyphs))
376         return false;
377 
378       if (short_offset)
379       {
<span class="line-modified">380         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ;</span>
381         *start_offset = 2 * offsets[glyph];
382         *end_offset   = 2 * offsets[glyph + 1];
383       }
384       else
385       {
<span class="line-modified">386         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ;</span>
387 
388         *start_offset = offsets[glyph];
389         *end_offset   = offsets[glyph + 1];
390       }
391 
<span class="line-modified">392       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_len)</span>
393         return false;
394 
395       return true;
396     }
397 
<span class="line-modified">398     inline bool get_instruction_offsets(unsigned int start_offset,</span>
<span class="line-modified">399                                         unsigned int end_offset,</span>
<span class="line-modified">400                                         unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">401                                         unsigned int *instruction_end /* OUT */) const</span>
402     {
403       if (end_offset - start_offset &lt; GlyphHeader::static_size)
404       {
405         *instruction_start = 0;
406         *instruction_end = 0;
407         return true; /* Empty glyph; no instructions. */
408       }
409       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
410       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
411       if (num_contours &lt; 0)
412       {
413         CompositeGlyphHeader::Iterator composite_it;
414         if (unlikely (!CompositeGlyphHeader::get_iterator (
415             (const char*) this-&gt;glyf_table + start_offset,
416              end_offset - start_offset, &amp;composite_it))) return false;
417         const CompositeGlyphHeader *last;
418         do {
419           last = composite_it.current;
<span class="line-modified">420         } while (composite_it.move_to_next());</span>
421 
<span class="line-modified">422         if ( (uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">423           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ) + last-&gt;get_size();</span>
424         else
425           *instruction_start = end_offset;
426         *instruction_end = end_offset;
427         if (unlikely (*instruction_start &gt; *instruction_end))
428         {
429           DEBUG_MSG(SUBSET, nullptr, &quot;Invalid instruction offset, %d is outside [%d, %d]&quot;, *instruction_start, start_offset, end_offset);
430           return false;
431         }
432       }
433       else
434       {
435         unsigned int instruction_length_offset = start_offset + GlyphHeader::static_size + 2 * num_contours;
436         if (unlikely (instruction_length_offset + 2 &gt; end_offset))
437         {
438           DEBUG_MSG(SUBSET, nullptr, &quot;Glyph size is too short, missing field instructionLength.&quot;);
439           return false;
440         }
441 
442         const HBUINT16 &amp;instruction_length = StructAtOffset&lt;HBUINT16&gt; (glyf_table, instruction_length_offset);
443         unsigned int start = instruction_length_offset + 2;
444         unsigned int end = start + (uint16_t) instruction_length;
445         if (unlikely (end &gt; end_offset)) // Out of bounds of the current glyph
446         {
447           DEBUG_MSG(SUBSET, nullptr, &quot;The instructions array overruns the glyph&#39;s boundaries.&quot;);
448           return false;
449         }
450 
451         *instruction_start = start;
452         *instruction_end = end;
453       }
454       return true;
455     }
456 
<span class="line-modified">457     inline bool get_extents (hb_codepoint_t glyph,</span>
<span class="line-removed">458                              hb_glyph_extents_t *extents) const</span>
459     {
460       unsigned int start_offset, end_offset;
461       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
462         return false;
463 
464       if (end_offset - start_offset &lt; GlyphHeader::static_size)
465         return true; /* Empty glyph; zero extents. */
466 
467       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
468 
469       extents-&gt;x_bearing = MIN (glyph_header.xMin, glyph_header.xMax);
470       extents-&gt;y_bearing = MAX (glyph_header.yMin, glyph_header.yMax);
471       extents-&gt;width     = MAX (glyph_header.xMin, glyph_header.xMax) - extents-&gt;x_bearing;
472       extents-&gt;height    = MIN (glyph_header.yMin, glyph_header.yMax) - extents-&gt;y_bearing;
473 
474       return true;
475     }
476 
477     private:
478     bool short_offset;
479     unsigned int num_glyphs;
<span class="line-modified">480     const loca *loca_table;</span>
<span class="line-modified">481     const glyf *glyf_table;</span>
<span class="line-removed">482     hb_blob_t *loca_blob;</span>
<span class="line-removed">483     hb_blob_t *glyf_blob;</span>
<span class="line-removed">484     unsigned int glyf_len;</span>
485   };
486 
487   protected:
<span class="line-modified">488   HBUINT8               dataZ[VAR];             /* Glyphs data. */</span>
<span class="line-modified">489 </span>
<span class="line-modified">490   DEFINE_SIZE_ARRAY (0, dataZ);</span>


491 };
492 


493 } /* namespace OT */
494 
495 
496 #endif /* HB_OT_GLYF_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_GLYF_TABLE_HH
 28 #define HB_OT_GLYF_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
 31 #include &quot;hb-ot-head-table.hh&quot;
 32 #include &quot;hb-subset-glyf.hh&quot;


 33 
 34 namespace OT {
 35 
 36 
 37 /*
 38  * loca -- Index to Location
 39  * https://docs.microsoft.com/en-us/typography/opentype/spec/loca
 40  */
 41 #define HB_OT_TAG_loca HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;a&#39;)
 42 
 43 
 44 struct loca
 45 {
 46   friend struct glyf;
 47 
<span class="line-modified"> 48   static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;</span>
 49 
<span class="line-modified"> 50   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
 51   {
 52     TRACE_SANITIZE (this);
 53     return_trace (true);
 54   }
 55 
 56   protected:
<span class="line-modified"> 57   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Location data. */</span>
<span class="line-modified"> 58   public:</span>
<span class="line-added"> 59   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added"> 60                         * check the size externally, allow Null() object of it by</span>
<span class="line-added"> 61                         * defining it MIN() instead. */</span>
 62 };
 63 
 64 
 65 /*
 66  * glyf -- TrueType Glyph Data
 67  * https://docs.microsoft.com/en-us/typography/opentype/spec/glyf
 68  */
 69 #define HB_OT_TAG_glyf HB_TAG(&#39;g&#39;,&#39;l&#39;,&#39;y&#39;,&#39;f&#39;)
 70 
 71 
 72 struct glyf
 73 {
<span class="line-modified"> 74   static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;</span>
 75 
<span class="line-modified"> 76   bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const</span>
 77   {
 78     TRACE_SANITIZE (this);
 79     /* We don&#39;t check for anything specific here.  The users of the
 80      * struct do all the hard work... */
 81     return_trace (true);
 82   }
 83 
<span class="line-modified"> 84   bool subset (hb_subset_plan_t *plan) const</span>
 85   {
 86     hb_blob_t *glyf_prime = nullptr;
 87     hb_blob_t *loca_prime = nullptr;
 88 
 89     bool success = true;
 90     bool use_short_loca = false;
 91     if (hb_subset_glyf_and_loca (plan, &amp;use_short_loca, &amp;glyf_prime, &amp;loca_prime)) {
 92       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_glyf, glyf_prime);
 93       success = success &amp;&amp; plan-&gt;add_table (HB_OT_TAG_loca, loca_prime);
 94       success = success &amp;&amp; _add_head_and_set_loca_version (plan, use_short_loca);
 95     } else {
 96       success = false;
 97     }
 98     hb_blob_destroy (loca_prime);
 99     hb_blob_destroy (glyf_prime);
100 
101     return success;
102   }
103 
104   static bool
105   _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)
106   {
<span class="line-modified">107     hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table&lt;head&gt; (plan-&gt;source);</span>
108     hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);
109     hb_blob_destroy (head_blob);
110 
111     if (unlikely (!head_prime_blob))
112       return false;
113 
<span class="line-modified">114     head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);</span>
115     head_prime-&gt;indexToLocFormat.set (use_short_loca ? 0 : 1);
116     bool success = plan-&gt;add_table (HB_OT_TAG_head, head_prime_blob);
117 
118     hb_blob_destroy (head_prime_blob);
119     return success;
120   }
121 
122   struct GlyphHeader
123   {
124     HBINT16             numberOfContours;       /* If the number of contours is
125                                                  * greater than or equal to zero,
126                                                  * this is a simple glyph; if negative,
127                                                  * this is a composite glyph. */
128     FWORD               xMin;                   /* Minimum x for coordinate data. */
129     FWORD               yMin;                   /* Minimum y for coordinate data. */
130     FWORD               xMax;                   /* Maximum x for coordinate data. */
131     FWORD               yMax;                   /* Maximum y for coordinate data. */
132 
133     DEFINE_SIZE_STATIC (10);
134   };
135 
136   struct CompositeGlyphHeader
137   {
138     enum composite_glyph_flag_t {
139       ARG_1_AND_2_ARE_WORDS =      0x0001,
140       ARGS_ARE_XY_VALUES =         0x0002,
141       ROUND_XY_TO_GRID =           0x0004,
142       WE_HAVE_A_SCALE =            0x0008,
143       MORE_COMPONENTS =            0x0020,
144       WE_HAVE_AN_X_AND_Y_SCALE =   0x0040,
145       WE_HAVE_A_TWO_BY_TWO =       0x0080,
146       WE_HAVE_INSTRUCTIONS =       0x0100,
147       USE_MY_METRICS =             0x0200,
148       OVERLAP_COMPOUND =           0x0400,
149       SCALED_COMPONENT_OFFSET =    0x0800,
150       UNSCALED_COMPONENT_OFFSET =  0x1000
151     };
152 
153     HBUINT16 flags;
<span class="line-modified">154     GlyphID  glyphIndex;</span>
155 
<span class="line-modified">156     unsigned int get_size () const</span>
157     {
158       unsigned int size = min_size;
<span class="line-modified">159       // arg1 and 2 are int16</span>
<span class="line-modified">160       if (flags &amp; ARG_1_AND_2_ARE_WORDS) size += 4;</span>
<span class="line-modified">161       // arg1 and 2 are int8</span>
<span class="line-modified">162       else size += 2;</span>
<span class="line-modified">163 </span>
<span class="line-modified">164       // One x 16 bit (scale)</span>
<span class="line-modified">165       if (flags &amp; WE_HAVE_A_SCALE) size += 2;</span>
<span class="line-modified">166       // Two x 16 bit (xscale, yscale)</span>
<span class="line-modified">167       else if (flags &amp; WE_HAVE_AN_X_AND_Y_SCALE) size += 4;</span>
<span class="line-modified">168       // Four x 16 bit (xscale, scale01, scale10, yscale)</span>
<span class="line-modified">169       else if (flags &amp; WE_HAVE_A_TWO_BY_TWO) size += 8;</span>
<span class="line-modified">170 </span>





171       return size;
172     }
173 
174     struct Iterator
175     {
176       const char *glyph_start;
177       const char *glyph_end;
178       const CompositeGlyphHeader *current;
179 
<span class="line-modified">180       bool move_to_next ()</span>
181       {
182         if (current-&gt;flags &amp; CompositeGlyphHeader::MORE_COMPONENTS)
183         {
184           const CompositeGlyphHeader *possible =
185             &amp;StructAfter&lt;CompositeGlyphHeader, CompositeGlyphHeader&gt; (*current);
186           if (!in_range (possible))
187             return false;
188           current = possible;
189           return true;
190         }
191         return false;
192       }
193 
<span class="line-modified">194       bool in_range (const CompositeGlyphHeader *composite) const</span>
195       {
196         return (const char *) composite &gt;= glyph_start
197           &amp;&amp; ((const char *) composite + CompositeGlyphHeader::min_size) &lt;= glyph_end
<span class="line-modified">198           &amp;&amp; ((const char *) composite + composite-&gt;get_size ()) &lt;= glyph_end;</span>
199       }
200     };
201 
<span class="line-modified">202     static bool get_iterator (const char * glyph_data,</span>
<span class="line-modified">203                               unsigned int length,</span>
<span class="line-modified">204                               CompositeGlyphHeader::Iterator *iterator /* OUT */)</span>
205     {
206       if (length &lt; GlyphHeader::static_size)
207         return false; /* Empty glyph; zero extents. */
208 
209       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph_data, 0);
210       if (glyph_header.numberOfContours &lt; 0)
211       {
212         const CompositeGlyphHeader *possible =
213           &amp;StructAfter&lt;CompositeGlyphHeader, GlyphHeader&gt; (glyph_header);
214 
215         iterator-&gt;glyph_start = glyph_data;
216         iterator-&gt;glyph_end = (const char *) glyph_data + length;
217         if (!iterator-&gt;in_range (possible))
218           return false;
219         iterator-&gt;current = possible;
220         return true;
221       }
222 
223       return false;
224     }
225 
226     DEFINE_SIZE_MIN (4);
227   };
228 
229   struct accelerator_t
230   {
<span class="line-modified">231     void init (hb_face_t *face)</span>
232     {
233       memset (this, 0, sizeof (accelerator_t));
234 
<span class="line-modified">235       const OT::head &amp;head = *face-&gt;table.head;</span>
<span class="line-modified">236       if (head.indexToLocFormat &gt; 1 || head.glyphDataFormat != 0)</span>
<span class="line-modified">237         /* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. */</span>



238         return;
<span class="line-modified">239       short_offset = 0 == head.indexToLocFormat;</span>


240 
<span class="line-modified">241       loca_table = hb_sanitize_context_t ().reference_table&lt;loca&gt; (face);</span>
<span class="line-modified">242       glyf_table = hb_sanitize_context_t ().reference_table&lt;glyf&gt; (face);</span>


243 
<span class="line-modified">244       num_glyphs = MAX (1u, loca_table.get_length () / (short_offset ? 2 : 4)) - 1;</span>

245     }
246 
<span class="line-modified">247     void fini ()</span>
248     {
<span class="line-modified">249       loca_table.destroy ();</span>
<span class="line-modified">250       glyf_table.destroy ();</span>
251     }
252 
253     /*
254      * Returns true if the referenced glyph is a valid glyph and a composite glyph.
255      * If true is returned a pointer to the composite glyph will be written into
256      * composite.
257      */
<span class="line-modified">258     bool get_composite (hb_codepoint_t glyph,</span>
<span class="line-modified">259                         CompositeGlyphHeader::Iterator *composite /* OUT */) const</span>
260     {
<span class="line-modified">261       if (unlikely (!num_glyphs))</span>
262         return false;
263 
264       unsigned int start_offset, end_offset;
265       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
266         return false; /* glyph not found */
267 
<span class="line-modified">268       return CompositeGlyphHeader::get_iterator ((const char *) this-&gt;glyf_table + start_offset,</span>
269                                                  end_offset - start_offset,
270                                                  composite);
271     }
272 
273     enum simple_glyph_flag_t {
<span class="line-added">274       FLAG_ON_CURVE = 0x01,</span>
275       FLAG_X_SHORT = 0x02,
276       FLAG_Y_SHORT = 0x04,
277       FLAG_REPEAT = 0x08,
278       FLAG_X_SAME = 0x10,
<span class="line-modified">279       FLAG_Y_SAME = 0x20,</span>
<span class="line-added">280       FLAG_RESERVED1 = 0x40,</span>
<span class="line-added">281       FLAG_RESERVED2 = 0x80</span>
282     };
283 
284     /* based on FontTools _g_l_y_f.py::trim */
<span class="line-modified">285     bool remove_padding (unsigned int start_offset,</span>
<span class="line-modified">286                                 unsigned int *end_offset) const</span>
287     {
<span class="line-modified">288       if (*end_offset - start_offset &lt; GlyphHeader::static_size) return true;</span>

289 
290       const char *glyph = ((const char *) glyf_table) + start_offset;
291       const char * const glyph_end = glyph + (*end_offset - start_offset);
292       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyph, 0);
293       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
294 
295       if (num_contours &lt; 0)
296         /* Trimming for composites not implemented.
297          * If removing hints it falls out of that. */
298         return true;
299       else if (num_contours &gt; 0)
300       {
301         /* simple glyph w/contours, possibly trimmable */
302         glyph += GlyphHeader::static_size + 2 * num_contours;
303 
304         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
<span class="line-modified">305         uint16_t nCoordinates = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph - 2, 0) + 1;</span>
<span class="line-modified">306         uint16_t nInstructions = (uint16_t) StructAtOffset&lt;HBUINT16&gt; (glyph, 0);</span>
307 
308         glyph += 2 + nInstructions;
309         if (unlikely (glyph + 2 &gt;= glyph_end)) return false;
310 
311         unsigned int coordBytes = 0;
312         unsigned int coordsWithFlags = 0;
313         while (glyph &lt; glyph_end)
314         {
315           uint8_t flag = (uint8_t) *glyph;
316           glyph++;
317 
318           unsigned int repeat = 1;
319           if (flag &amp; FLAG_REPEAT)
320           {
321             if (glyph &gt;= glyph_end)
322             {
323               DEBUG_MSG(SUBSET, nullptr, &quot;Bad flag&quot;);
324               return false;
325             }
326             repeat = ((uint8_t) *glyph) + 1;
327             glyph++;
328           }
329 
330           unsigned int xBytes, yBytes;
331           xBytes = yBytes = 0;
<span class="line-modified">332           if (flag &amp; FLAG_X_SHORT) xBytes = 1;</span>
<span class="line-modified">333           else if ((flag &amp; FLAG_X_SAME) == 0) xBytes = 2;</span>


334 
<span class="line-modified">335           if (flag &amp; FLAG_Y_SHORT) yBytes = 1;</span>
<span class="line-modified">336           else if ((flag &amp; FLAG_Y_SAME) == 0) yBytes = 2;</span>


337 
338           coordBytes += (xBytes + yBytes) * repeat;
339           coordsWithFlags += repeat;
340           if (coordsWithFlags &gt;= nCoordinates)
341             break;
342         }
343 
344         if (coordsWithFlags != nCoordinates)
345         {
346           DEBUG_MSG(SUBSET, nullptr, &quot;Expect %d coords to have flags, got flags for %d&quot;, nCoordinates, coordsWithFlags);
347           return false;
348         }
349         glyph += coordBytes;
350 
351         if (glyph &lt; glyph_end)
352           *end_offset -= glyph_end - glyph;
353       }
354       return true;
355     }
356 
<span class="line-modified">357     bool get_offsets (hb_codepoint_t  glyph,</span>
<span class="line-modified">358                       unsigned int   *start_offset /* OUT */,</span>
<span class="line-modified">359                       unsigned int   *end_offset   /* OUT */) const</span>
360     {
361       if (unlikely (glyph &gt;= num_glyphs))
362         return false;
363 
364       if (short_offset)
365       {
<span class="line-modified">366         const HBUINT16 *offsets = (const HBUINT16 *) loca_table-&gt;dataZ.arrayZ;</span>
367         *start_offset = 2 * offsets[glyph];
368         *end_offset   = 2 * offsets[glyph + 1];
369       }
370       else
371       {
<span class="line-modified">372         const HBUINT32 *offsets = (const HBUINT32 *) loca_table-&gt;dataZ.arrayZ;</span>
373 
374         *start_offset = offsets[glyph];
375         *end_offset   = offsets[glyph + 1];
376       }
377 
<span class="line-modified">378       if (*start_offset &gt; *end_offset || *end_offset &gt; glyf_table.get_length ())</span>
379         return false;
380 
381       return true;
382     }
383 
<span class="line-modified">384     bool get_instruction_offsets (unsigned int start_offset,</span>
<span class="line-modified">385                                   unsigned int end_offset,</span>
<span class="line-modified">386                                   unsigned int *instruction_start /* OUT */,</span>
<span class="line-modified">387                                   unsigned int *instruction_end /* OUT */) const</span>
388     {
389       if (end_offset - start_offset &lt; GlyphHeader::static_size)
390       {
391         *instruction_start = 0;
392         *instruction_end = 0;
393         return true; /* Empty glyph; no instructions. */
394       }
395       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
396       int16_t num_contours = (int16_t) glyph_header.numberOfContours;
397       if (num_contours &lt; 0)
398       {
399         CompositeGlyphHeader::Iterator composite_it;
400         if (unlikely (!CompositeGlyphHeader::get_iterator (
401             (const char*) this-&gt;glyf_table + start_offset,
402              end_offset - start_offset, &amp;composite_it))) return false;
403         const CompositeGlyphHeader *last;
404         do {
405           last = composite_it.current;
<span class="line-modified">406         } while (composite_it.move_to_next ());</span>
407 
<span class="line-modified">408         if ((uint16_t) last-&gt;flags &amp; CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)</span>
<span class="line-modified">409           *instruction_start = ((char *) last - (char *) glyf_table-&gt;dataZ.arrayZ) + last-&gt;get_size ();</span>
410         else
411           *instruction_start = end_offset;
412         *instruction_end = end_offset;
413         if (unlikely (*instruction_start &gt; *instruction_end))
414         {
415           DEBUG_MSG(SUBSET, nullptr, &quot;Invalid instruction offset, %d is outside [%d, %d]&quot;, *instruction_start, start_offset, end_offset);
416           return false;
417         }
418       }
419       else
420       {
421         unsigned int instruction_length_offset = start_offset + GlyphHeader::static_size + 2 * num_contours;
422         if (unlikely (instruction_length_offset + 2 &gt; end_offset))
423         {
424           DEBUG_MSG(SUBSET, nullptr, &quot;Glyph size is too short, missing field instructionLength.&quot;);
425           return false;
426         }
427 
428         const HBUINT16 &amp;instruction_length = StructAtOffset&lt;HBUINT16&gt; (glyf_table, instruction_length_offset);
429         unsigned int start = instruction_length_offset + 2;
430         unsigned int end = start + (uint16_t) instruction_length;
431         if (unlikely (end &gt; end_offset)) // Out of bounds of the current glyph
432         {
433           DEBUG_MSG(SUBSET, nullptr, &quot;The instructions array overruns the glyph&#39;s boundaries.&quot;);
434           return false;
435         }
436 
437         *instruction_start = start;
438         *instruction_end = end;
439       }
440       return true;
441     }
442 
<span class="line-modified">443     bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>

444     {
445       unsigned int start_offset, end_offset;
446       if (!get_offsets (glyph, &amp;start_offset, &amp;end_offset))
447         return false;
448 
449       if (end_offset - start_offset &lt; GlyphHeader::static_size)
450         return true; /* Empty glyph; zero extents. */
451 
452       const GlyphHeader &amp;glyph_header = StructAtOffset&lt;GlyphHeader&gt; (glyf_table, start_offset);
453 
454       extents-&gt;x_bearing = MIN (glyph_header.xMin, glyph_header.xMax);
455       extents-&gt;y_bearing = MAX (glyph_header.yMin, glyph_header.yMax);
456       extents-&gt;width     = MAX (glyph_header.xMin, glyph_header.xMax) - extents-&gt;x_bearing;
457       extents-&gt;height    = MIN (glyph_header.yMin, glyph_header.yMax) - extents-&gt;y_bearing;
458 
459       return true;
460     }
461 
462     private:
463     bool short_offset;
464     unsigned int num_glyphs;
<span class="line-modified">465     hb_blob_ptr_t&lt;loca&gt; loca_table;</span>
<span class="line-modified">466     hb_blob_ptr_t&lt;glyf&gt; glyf_table;</span>



467   };
468 
469   protected:
<span class="line-modified">470   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;          /* Glyphs data. */</span>
<span class="line-modified">471   public:</span>
<span class="line-modified">472   DEFINE_SIZE_MIN (0); /* In reality, this is UNBOUNDED() type; but since we always</span>
<span class="line-added">473                         * check the size externally, allow Null() object of it by</span>
<span class="line-added">474                         * defining it MIN() instead. */</span>
475 };
476 
<span class="line-added">477 struct glyf_accelerator_t : glyf::accelerator_t {};</span>
<span class="line-added">478 </span>
479 } /* namespace OT */
480 
481 
482 #endif /* HB_OT_GLYF_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-font.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-head-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
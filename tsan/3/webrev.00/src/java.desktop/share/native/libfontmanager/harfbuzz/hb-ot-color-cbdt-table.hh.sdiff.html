<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-cmap-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-colr-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Seigo Nonaka
 25  */
 26 
 27 #ifndef HB_OT_COLOR_CBDT_TABLE_HH
 28 #define HB_OT_COLOR_CBDT_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 
 32 /*
 33  * CBLC -- Color Bitmap Location
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/cblc
 35  * https://docs.microsoft.com/en-us/typography/opentype/spec/eblc
 36  * CBDT -- Color Bitmap Data
 37  * https://docs.microsoft.com/en-us/typography/opentype/spec/cbdt
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/ebdt
 39  */
 40 #define HB_OT_TAG_CBLC HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;L&#39;,&#39;C&#39;)
 41 #define HB_OT_TAG_CBDT HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;D&#39;,&#39;T&#39;)
 42 
 43 
 44 namespace OT {
 45 
 46 struct SmallGlyphMetrics
 47 {
<span class="line-modified"> 48   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 49   {
 50     TRACE_SANITIZE (this);
 51     return_trace (c-&gt;check_struct (this));
 52   }
 53 
<span class="line-modified"> 54   inline void get_extents (hb_glyph_extents_t *extents) const</span>
 55   {
 56     extents-&gt;x_bearing = bearingX;
 57     extents-&gt;y_bearing = bearingY;
 58     extents-&gt;width = width;
<span class="line-modified"> 59     extents-&gt;height = -height;</span>
 60   }
 61 
 62   HBUINT8       height;
 63   HBUINT8       width;
 64   HBINT8        bearingX;
 65   HBINT8        bearingY;
 66   HBUINT8       advance;
 67   public:
 68   DEFINE_SIZE_STATIC(5);
 69 };
 70 
 71 struct BigGlyphMetrics : SmallGlyphMetrics
 72 {
 73   HBINT8        vertBearingX;
 74   HBINT8        vertBearingY;
 75   HBUINT8       vertAdvance;
 76   public:
 77   DEFINE_SIZE_STATIC(8);
 78 };
 79 
 80 struct SBitLineMetrics
 81 {
<span class="line-modified"> 82   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 83   {
 84     TRACE_SANITIZE (this);
 85     return_trace (c-&gt;check_struct (this));
 86   }
 87 
 88   HBINT8        ascender;
 89   HBINT8        decender;
 90   HBUINT8       widthMax;
 91   HBINT8        caretSlopeNumerator;
 92   HBINT8        caretSlopeDenominator;
 93   HBINT8        caretOffset;
 94   HBINT8        minOriginSB;
 95   HBINT8        minAdvanceSB;
 96   HBINT8        maxBeforeBL;
 97   HBINT8        minAfterBL;
 98   HBINT8        padding1;
 99   HBINT8        padding2;
100   public:
101   DEFINE_SIZE_STATIC(12);
102 };
103 
104 
105 /*
106  * Index Subtables.
107  */
108 
109 struct IndexSubtableHeader
110 {
<span class="line-modified">111   inline bool sanitize (hb_sanitize_context_t *c) const</span>
112   {
113     TRACE_SANITIZE (this);
114     return_trace (c-&gt;check_struct (this));
115   }
116 
117   HBUINT16      indexFormat;
118   HBUINT16      imageFormat;
119   HBUINT32      imageDataOffset;
120   public:
121   DEFINE_SIZE_STATIC(8);
122 };
123 
124 template &lt;typename OffsetType&gt;
125 struct IndexSubtableFormat1Or3
126 {
<span class="line-modified">127   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
128   {
129     TRACE_SANITIZE (this);
130     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified">131                   c-&gt;check_array (offsetArrayZ, offsetArrayZ[0].static_size, glyph_count + 1));</span>
132   }
133 
134   bool get_image_data (unsigned int idx,
135                        unsigned int *offset,
136                        unsigned int *length) const
137   {
138     if (unlikely (offsetArrayZ[idx + 1] &lt;= offsetArrayZ[idx]))
139       return false;
140 
141     *offset = header.imageDataOffset + offsetArrayZ[idx];
142     *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];
143     return true;
144   }
145 
146   IndexSubtableHeader   header;
<span class="line-modified">147   Offset&lt;OffsetType&gt;    offsetArrayZ[VAR];</span>

148   public:
149   DEFINE_SIZE_ARRAY(8, offsetArrayZ);
150 };
151 
152 struct IndexSubtableFormat1 : IndexSubtableFormat1Or3&lt;HBUINT32&gt; {};
153 struct IndexSubtableFormat3 : IndexSubtableFormat1Or3&lt;HBUINT16&gt; {};
154 
155 struct IndexSubtable
156 {
<span class="line-modified">157   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
158   {
159     TRACE_SANITIZE (this);
160     if (!u.header.sanitize (c)) return_trace (false);
161     switch (u.header.indexFormat) {
162     case 1: return_trace (u.format1.sanitize (c, glyph_count));
163     case 3: return_trace (u.format3.sanitize (c, glyph_count));
164     default:return_trace (true);
165     }
166   }
167 
<span class="line-modified">168   inline bool get_extents (hb_glyph_extents_t *extents) const</span>
169   {
170     switch (u.header.indexFormat) {
171     case 2: case 5: /* TODO */
172     case 1: case 3: case 4: /* Variable-metrics formats do not have metrics here. */
173     default:return (false);
174     }
175   }
176 
177   bool get_image_data (unsigned int idx,
178                        unsigned int *offset,
179                        unsigned int *length,
180                        unsigned int *format) const
181   {
182     *format = u.header.imageFormat;
183     switch (u.header.indexFormat) {
184     case 1: return u.format1.get_image_data (idx, offset, length);
185     case 3: return u.format3.get_image_data (idx, offset, length);
186     default: return false;
187     }
188   }
189 
190   protected:
191   union {
192   IndexSubtableHeader   header;
193   IndexSubtableFormat1  format1;
194   IndexSubtableFormat3  format3;
195   /* TODO: Format 2, 4, 5. */
196   } u;
197   public:
198   DEFINE_SIZE_UNION (8, header);
199 };
200 
201 struct IndexSubtableRecord
202 {
<span class="line-modified">203   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
204   {
205     TRACE_SANITIZE (this);
206     return_trace (c-&gt;check_struct (this) &amp;&amp;
207                   firstGlyphIndex &lt;= lastGlyphIndex &amp;&amp;
<span class="line-modified">208                   offsetToSubtable.sanitize (c, this, lastGlyphIndex - firstGlyphIndex + 1));</span>
209   }
210 
<span class="line-modified">211   inline bool get_extents (hb_glyph_extents_t *extents) const</span>

212   {
<span class="line-modified">213     return (this+offsetToSubtable).get_extents (extents);</span>
214   }
215 
<span class="line-modified">216   bool get_image_data (unsigned int gid,</span>

217                        unsigned int *offset,
218                        unsigned int *length,
219                        unsigned int *format) const
220   {
<span class="line-modified">221     if (gid &lt; firstGlyphIndex || gid &gt; lastGlyphIndex)</span>
<span class="line-modified">222     {</span>
<span class="line-removed">223       return false;</span>
<span class="line-removed">224     }</span>
<span class="line-removed">225     return (this+offsetToSubtable).get_image_data (gid - firstGlyphIndex,</span>
226                                                    offset, length, format);
227   }
228 
229   GlyphID                       firstGlyphIndex;
230   GlyphID                       lastGlyphIndex;
231   LOffsetTo&lt;IndexSubtable&gt;      offsetToSubtable;
232   public:
233   DEFINE_SIZE_STATIC(8);
234 };
235 
236 struct IndexSubtableArray
237 {
238   friend struct CBDT;
239 
<span class="line-modified">240   inline bool sanitize (hb_sanitize_context_t *c, unsigned int count) const</span>
241   {
242     TRACE_SANITIZE (this);
<span class="line-modified">243     if (unlikely (!c-&gt;check_array (&amp;indexSubtablesZ, indexSubtablesZ[0].static_size, count)))</span>
<span class="line-removed">244       return_trace (false);</span>
<span class="line-removed">245     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">246       if (unlikely (!indexSubtablesZ[i].sanitize (c, this)))</span>
<span class="line-removed">247         return_trace (false);</span>
<span class="line-removed">248     return_trace (true);</span>
249   }
250 
251   public:
252   const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const
253   {
254     for (unsigned int i = 0; i &lt; numTables; ++i)
255     {
256       unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;
257       unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;
<span class="line-modified">258       if (firstGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= lastGlyphIndex) {</span>
259         return &amp;indexSubtablesZ[i];
<span class="line-removed">260       }</span>
261     }
262     return nullptr;
263   }
264 
265   protected:
<span class="line-modified">266   IndexSubtableRecord   indexSubtablesZ[VAR];</span>
<span class="line-removed">267   public:</span>
<span class="line-removed">268   DEFINE_SIZE_ARRAY(0, indexSubtablesZ);</span>
269 };
270 
271 struct BitmapSizeTable
272 {
273   friend struct CBLC;
274   friend struct CBDT;
275 
<span class="line-modified">276   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
277   {
278     TRACE_SANITIZE (this);
279     return_trace (c-&gt;check_struct (this) &amp;&amp;
280                   indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &amp;&amp;
<span class="line-removed">281                   c-&gt;check_range (&amp;(base+indexSubtableArrayOffset), indexTablesSize) &amp;&amp;</span>
282                   horizontal.sanitize (c) &amp;&amp;
283                   vertical.sanitize (c));
284   }
285 
<span class="line-modified">286   const IndexSubtableRecord *find_table (hb_codepoint_t glyph, const void *base) const</span>


287   {

288     return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);
289   }
290 
291   protected:
<span class="line-modified">292   LOffsetTo&lt;IndexSubtableArray&gt;</span>
293                         indexSubtableArrayOffset;
294   HBUINT32              indexTablesSize;
295   HBUINT32              numberOfIndexSubtables;
296   HBUINT32              colorRef;
297   SBitLineMetrics       horizontal;
298   SBitLineMetrics       vertical;
299   GlyphID               startGlyphIndex;
300   GlyphID               endGlyphIndex;
301   HBUINT8               ppemX;
302   HBUINT8               ppemY;
303   HBUINT8               bitDepth;
304   HBINT8                flags;
305   public:
306   DEFINE_SIZE_STATIC(48);
307 };
308 
309 
310 /*
311  * Glyph Bitmap Data Formats.
312  */
</pre>
<hr />
<pre>
321 
322 struct GlyphBitmapDataFormat18
323 {
324   BigGlyphMetrics       glyphMetrics;
325   LArrayOf&lt;HBUINT8&gt;     data;
326   public:
327   DEFINE_SIZE_ARRAY(12, data);
328 };
329 
330 struct GlyphBitmapDataFormat19
331 {
332   LArrayOf&lt;HBUINT8&gt;     data;
333   public:
334   DEFINE_SIZE_ARRAY(4, data);
335 };
336 
337 struct CBLC
338 {
339   friend struct CBDT;
340 
<span class="line-modified">341   static const hb_tag_t tableTag = HB_OT_TAG_CBLC;</span>
342 
<span class="line-modified">343   inline bool sanitize (hb_sanitize_context_t *c) const</span>
344   {
345     TRACE_SANITIZE (this);
346     return_trace (c-&gt;check_struct (this) &amp;&amp;
347                   likely (version.major == 2 || version.major == 3) &amp;&amp;
348                   sizeTables.sanitize (c, this));
349   }
350 
351   protected:
<span class="line-modified">352   const IndexSubtableRecord *find_table (hb_codepoint_t glyph,</span>
<span class="line-removed">353                                          unsigned int *x_ppem, unsigned int *y_ppem) const</span>
354   {
<span class="line-modified">355     /* TODO: Make it possible to select strike. */</span>


356 
<span class="line-modified">357     unsigned int count = sizeTables.len;</span>
<span class="line-modified">358     for (uint32_t i = 0; i &lt; count; ++i)</span>





359     {
<span class="line-modified">360       unsigned int startGlyphIndex = sizeTables.arrayZ[i].startGlyphIndex;</span>
<span class="line-modified">361       unsigned int endGlyphIndex = sizeTables.arrayZ[i].endGlyphIndex;</span>
<span class="line-modified">362       if (startGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= endGlyphIndex)</span>
363       {
<span class="line-modified">364         *x_ppem = sizeTables[i].ppemX;</span>
<span class="line-modified">365         *y_ppem = sizeTables[i].ppemY;</span>
<span class="line-removed">366         return sizeTables[i].find_table (glyph, this);</span>
367       }
368     }
369 
<span class="line-modified">370     return nullptr;</span>
371   }
372 
373   protected:
374   FixedVersion&lt;&gt;                version;
375   LArrayOf&lt;BitmapSizeTable&gt;     sizeTables;
376   public:
377   DEFINE_SIZE_ARRAY(8, sizeTables);
378 };
379 
380 struct CBDT
381 {
<span class="line-modified">382   static const hb_tag_t tableTag = HB_OT_TAG_CBDT;</span>
<span class="line-removed">383 </span>
<span class="line-removed">384   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">385   {</span>
<span class="line-removed">386     TRACE_SANITIZE (this);</span>
<span class="line-removed">387     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed">388                   likely (version.major == 2 || version.major == 3));</span>
<span class="line-removed">389   }</span>
390 
391   struct accelerator_t
392   {
<span class="line-modified">393     inline void init (hb_face_t *face)</span>
394     {
<span class="line-modified">395       upem = hb_face_get_upem (face);</span>
<span class="line-modified">396 </span>
<span class="line-removed">397       cblc_blob = Sanitizer&lt;CBLC&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBLC));</span>
<span class="line-removed">398       cbdt_blob = Sanitizer&lt;CBDT&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBDT));</span>
<span class="line-removed">399       cbdt_len = hb_blob_get_length (cbdt_blob);</span>
<span class="line-removed">400 </span>
<span class="line-removed">401       if (hb_blob_get_length (cblc_blob) == 0) {</span>
<span class="line-removed">402         cblc = nullptr;</span>
<span class="line-removed">403         cbdt = nullptr;</span>
<span class="line-removed">404         return;  /* Not a bitmap font. */</span>
<span class="line-removed">405       }</span>
<span class="line-removed">406       cblc = cblc_blob-&gt;as&lt;CBLC&gt; ();</span>
<span class="line-removed">407       cbdt = cbdt_blob-&gt;as&lt;CBDT&gt; ();</span>
408 

409     }
410 
<span class="line-modified">411     inline void fini (void)</span>
412     {
<span class="line-modified">413       hb_blob_destroy (this-&gt;cblc_blob);</span>
<span class="line-modified">414       hb_blob_destroy (this-&gt;cbdt_blob);</span>
415     }
416 
<span class="line-modified">417     inline bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>

418     {
<span class="line-modified">419       unsigned int x_ppem = upem, y_ppem = upem; /* TODO Use font ppem if available. */</span>
<span class="line-modified">420 </span>
<span class="line-modified">421       if (!cblc)</span>
<span class="line-modified">422         return false;  // Not a color bitmap font.</span>
<span class="line-removed">423 </span>
<span class="line-removed">424       const IndexSubtableRecord *subtable_record = this-&gt;cblc-&gt;find_table(glyph, &amp;x_ppem, &amp;y_ppem);</span>
<span class="line-removed">425       if (!subtable_record || !x_ppem || !y_ppem)</span>
426         return false;
427 
<span class="line-modified">428       if (subtable_record-&gt;get_extents (extents))</span>
429         return true;
430 
431       unsigned int image_offset = 0, image_length = 0, image_format = 0;
<span class="line-modified">432       if (!subtable_record-&gt;get_image_data (glyph, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
433         return false;
434 
435       {

436         if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))
437           return false;
438 
439         switch (image_format)
440         {
441           case 17: {
442             if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))
443               return false;
<span class="line-removed">444 </span>
445             const GlyphBitmapDataFormat17&amp; glyphFormat17 =
446                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);
447             glyphFormat17.glyphMetrics.get_extents (extents);









448           }
<span class="line-removed">449           break;</span>
450           default:
451             // TODO: Support other image formats.
452             return false;
453         }
454       }
455 
<span class="line-modified">456       /* Convert to the font units. */</span>
<span class="line-modified">457       extents-&gt;x_bearing *= upem / (float) x_ppem;</span>
<span class="line-modified">458       extents-&gt;y_bearing *= upem / (float) y_ppem;</span>
<span class="line-modified">459       extents-&gt;width *= upem / (float) x_ppem;</span>
<span class="line-modified">460       extents-&gt;height *= upem / (float) y_ppem;</span>


461 
462       return true;
463     }
464 
<span class="line-modified">465     inline void dump (void (*callback) (const uint8_t* data, unsigned int length,</span>
<span class="line-modified">466         unsigned int group, unsigned int gid)) const</span>
467     {
<span class="line-modified">468       if (!cblc)</span>
<span class="line-modified">469         return;  // Not a color bitmap font.</span>







470 
<span class="line-removed">471       for (unsigned int i = 0; i &lt; cblc-&gt;sizeTables.len; ++i)</span>
472       {
<span class="line-modified">473         const BitmapSizeTable &amp;sizeTable = cblc-&gt;sizeTables[i];</span>
<span class="line-modified">474         const IndexSubtableArray &amp;subtable_array = cblc+sizeTable.indexSubtableArrayOffset;</span>
<span class="line-modified">475         for (unsigned int j = 0; j &lt; sizeTable.numberOfIndexSubtables; ++j)</span>


476         {
<span class="line-modified">477           const IndexSubtableRecord &amp;subtable_record = subtable_array.indexSubtablesZ[j];</span>
<span class="line-modified">478           for (unsigned int gid = subtable_record.firstGlyphIndex;</span>
<span class="line-modified">479                 gid &lt;= subtable_record.lastGlyphIndex; ++gid)</span>
<span class="line-modified">480           {</span>
<span class="line-modified">481             unsigned int image_offset = 0, image_length = 0, image_format = 0;</span>
<span class="line-modified">482 </span>
<span class="line-modified">483             if (!subtable_record.get_image_data (gid,</span>
<span class="line-modified">484                   &amp;image_offset, &amp;image_length, &amp;image_format))</span>
<span class="line-modified">485               continue;</span>
<span class="line-modified">486 </span>
<span class="line-modified">487             switch (image_format)</span>
<span class="line-modified">488             {</span>
<span class="line-modified">489             case 17: {</span>
<span class="line-modified">490               const GlyphBitmapDataFormat17&amp; glyphFormat17 =</span>
<span class="line-modified">491                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">492               callback ((const uint8_t *) &amp;glyphFormat17.data.arrayZ,</span>
<span class="line-modified">493                 glyphFormat17.data.len, i, gid);</span>
<span class="line-modified">494             }</span>
<span class="line-modified">495             break;</span>
<span class="line-modified">496             case 18: {</span>
<span class="line-modified">497               const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-modified">498                 StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">499               callback ((const uint8_t *) &amp;glyphFormat18.data.arrayZ,</span>
<span class="line-modified">500                 glyphFormat18.data.len, i, gid);</span>
<span class="line-modified">501             }</span>
<span class="line-modified">502             break;</span>
<span class="line-removed">503             case 19: {</span>
<span class="line-removed">504               const GlyphBitmapDataFormat19&amp; glyphFormat19 =</span>
<span class="line-removed">505                 StructAtOffset&lt;GlyphBitmapDataFormat19&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-removed">506               callback ((const uint8_t *) &amp;glyphFormat19.data.arrayZ,</span>
<span class="line-removed">507                 glyphFormat19.data.len, i, gid);</span>
<span class="line-removed">508             }</span>
<span class="line-removed">509             break;</span>
<span class="line-removed">510             default:</span>
<span class="line-removed">511               continue;</span>
<span class="line-removed">512             }</span>
513           }
514         }
515       }


516     }
517 


518     private:
<span class="line-modified">519     hb_blob_t *cblc_blob;</span>
<span class="line-modified">520     hb_blob_t *cbdt_blob;</span>
<span class="line-removed">521     const CBLC *cblc;</span>
<span class="line-removed">522     const CBDT *cbdt;</span>
523 
<span class="line-removed">524     unsigned int cbdt_len;</span>
525     unsigned int upem;
526   };
527 






528 
529   protected:
<span class="line-modified">530   FixedVersion&lt;&gt;        version;</span>
<span class="line-modified">531   HBUINT8               dataZ[VAR];</span>
532   public:
533   DEFINE_SIZE_ARRAY(4, dataZ);
534 };
535 


536 } /* namespace OT */
537 
538 #endif /* HB_OT_COLOR_CBDT_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Seigo Nonaka
 25  */
 26 
 27 #ifndef HB_OT_COLOR_CBDT_TABLE_HH
 28 #define HB_OT_COLOR_CBDT_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
 31 
 32 /*
 33  * CBLC -- Color Bitmap Location
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/cblc
 35  * https://docs.microsoft.com/en-us/typography/opentype/spec/eblc
 36  * CBDT -- Color Bitmap Data
 37  * https://docs.microsoft.com/en-us/typography/opentype/spec/cbdt
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/ebdt
 39  */
 40 #define HB_OT_TAG_CBLC HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;L&#39;,&#39;C&#39;)
 41 #define HB_OT_TAG_CBDT HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;D&#39;,&#39;T&#39;)
 42 
 43 
 44 namespace OT {
 45 
 46 struct SmallGlyphMetrics
 47 {
<span class="line-modified"> 48   bool sanitize (hb_sanitize_context_t *c) const</span>
 49   {
 50     TRACE_SANITIZE (this);
 51     return_trace (c-&gt;check_struct (this));
 52   }
 53 
<span class="line-modified"> 54   void get_extents (hb_glyph_extents_t *extents) const</span>
 55   {
 56     extents-&gt;x_bearing = bearingX;
 57     extents-&gt;y_bearing = bearingY;
 58     extents-&gt;width = width;
<span class="line-modified"> 59     extents-&gt;height = - (hb_position_t) height;</span>
 60   }
 61 
 62   HBUINT8       height;
 63   HBUINT8       width;
 64   HBINT8        bearingX;
 65   HBINT8        bearingY;
 66   HBUINT8       advance;
 67   public:
 68   DEFINE_SIZE_STATIC(5);
 69 };
 70 
 71 struct BigGlyphMetrics : SmallGlyphMetrics
 72 {
 73   HBINT8        vertBearingX;
 74   HBINT8        vertBearingY;
 75   HBUINT8       vertAdvance;
 76   public:
 77   DEFINE_SIZE_STATIC(8);
 78 };
 79 
 80 struct SBitLineMetrics
 81 {
<span class="line-modified"> 82   bool sanitize (hb_sanitize_context_t *c) const</span>
 83   {
 84     TRACE_SANITIZE (this);
 85     return_trace (c-&gt;check_struct (this));
 86   }
 87 
 88   HBINT8        ascender;
 89   HBINT8        decender;
 90   HBUINT8       widthMax;
 91   HBINT8        caretSlopeNumerator;
 92   HBINT8        caretSlopeDenominator;
 93   HBINT8        caretOffset;
 94   HBINT8        minOriginSB;
 95   HBINT8        minAdvanceSB;
 96   HBINT8        maxBeforeBL;
 97   HBINT8        minAfterBL;
 98   HBINT8        padding1;
 99   HBINT8        padding2;
100   public:
101   DEFINE_SIZE_STATIC(12);
102 };
103 
104 
105 /*
106  * Index Subtables.
107  */
108 
109 struct IndexSubtableHeader
110 {
<span class="line-modified">111   bool sanitize (hb_sanitize_context_t *c) const</span>
112   {
113     TRACE_SANITIZE (this);
114     return_trace (c-&gt;check_struct (this));
115   }
116 
117   HBUINT16      indexFormat;
118   HBUINT16      imageFormat;
119   HBUINT32      imageDataOffset;
120   public:
121   DEFINE_SIZE_STATIC(8);
122 };
123 
124 template &lt;typename OffsetType&gt;
125 struct IndexSubtableFormat1Or3
126 {
<span class="line-modified">127   bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
128   {
129     TRACE_SANITIZE (this);
130     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified">131                   offsetArrayZ.sanitize (c, glyph_count + 1));</span>
132   }
133 
134   bool get_image_data (unsigned int idx,
135                        unsigned int *offset,
136                        unsigned int *length) const
137   {
138     if (unlikely (offsetArrayZ[idx + 1] &lt;= offsetArrayZ[idx]))
139       return false;
140 
141     *offset = header.imageDataOffset + offsetArrayZ[idx];
142     *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];
143     return true;
144   }
145 
146   IndexSubtableHeader   header;
<span class="line-modified">147   UnsizedArrayOf&lt;Offset&lt;OffsetType&gt; &gt;</span>
<span class="line-added">148                         offsetArrayZ;</span>
149   public:
150   DEFINE_SIZE_ARRAY(8, offsetArrayZ);
151 };
152 
153 struct IndexSubtableFormat1 : IndexSubtableFormat1Or3&lt;HBUINT32&gt; {};
154 struct IndexSubtableFormat3 : IndexSubtableFormat1Or3&lt;HBUINT16&gt; {};
155 
156 struct IndexSubtable
157 {
<span class="line-modified">158   bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
159   {
160     TRACE_SANITIZE (this);
161     if (!u.header.sanitize (c)) return_trace (false);
162     switch (u.header.indexFormat) {
163     case 1: return_trace (u.format1.sanitize (c, glyph_count));
164     case 3: return_trace (u.format3.sanitize (c, glyph_count));
165     default:return_trace (true);
166     }
167   }
168 
<span class="line-modified">169   bool get_extents (hb_glyph_extents_t *extents HB_UNUSED) const</span>
170   {
171     switch (u.header.indexFormat) {
172     case 2: case 5: /* TODO */
173     case 1: case 3: case 4: /* Variable-metrics formats do not have metrics here. */
174     default:return (false);
175     }
176   }
177 
178   bool get_image_data (unsigned int idx,
179                        unsigned int *offset,
180                        unsigned int *length,
181                        unsigned int *format) const
182   {
183     *format = u.header.imageFormat;
184     switch (u.header.indexFormat) {
185     case 1: return u.format1.get_image_data (idx, offset, length);
186     case 3: return u.format3.get_image_data (idx, offset, length);
187     default: return false;
188     }
189   }
190 
191   protected:
192   union {
193   IndexSubtableHeader   header;
194   IndexSubtableFormat1  format1;
195   IndexSubtableFormat3  format3;
196   /* TODO: Format 2, 4, 5. */
197   } u;
198   public:
199   DEFINE_SIZE_UNION (8, header);
200 };
201 
202 struct IndexSubtableRecord
203 {
<span class="line-modified">204   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
205   {
206     TRACE_SANITIZE (this);
207     return_trace (c-&gt;check_struct (this) &amp;&amp;
208                   firstGlyphIndex &lt;= lastGlyphIndex &amp;&amp;
<span class="line-modified">209                   offsetToSubtable.sanitize (c, base, lastGlyphIndex - firstGlyphIndex + 1));</span>
210   }
211 
<span class="line-modified">212   bool get_extents (hb_glyph_extents_t *extents,</span>
<span class="line-added">213                     const void *base) const</span>
214   {
<span class="line-modified">215     return (base+offsetToSubtable).get_extents (extents);</span>
216   }
217 
<span class="line-modified">218   bool get_image_data (unsigned int  gid,</span>
<span class="line-added">219                        const void   *base,</span>
220                        unsigned int *offset,
221                        unsigned int *length,
222                        unsigned int *format) const
223   {
<span class="line-modified">224     if (gid &lt; firstGlyphIndex || gid &gt; lastGlyphIndex) return false;</span>
<span class="line-modified">225     return (base+offsetToSubtable).get_image_data (gid - firstGlyphIndex,</span>



226                                                    offset, length, format);
227   }
228 
229   GlyphID                       firstGlyphIndex;
230   GlyphID                       lastGlyphIndex;
231   LOffsetTo&lt;IndexSubtable&gt;      offsetToSubtable;
232   public:
233   DEFINE_SIZE_STATIC(8);
234 };
235 
236 struct IndexSubtableArray
237 {
238   friend struct CBDT;
239 
<span class="line-modified">240   bool sanitize (hb_sanitize_context_t *c, unsigned int count) const</span>
241   {
242     TRACE_SANITIZE (this);
<span class="line-modified">243     return_trace (indexSubtablesZ.sanitize (c, count, this));</span>





244   }
245 
246   public:
247   const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const
248   {
249     for (unsigned int i = 0; i &lt; numTables; ++i)
250     {
251       unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;
252       unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;
<span class="line-modified">253       if (firstGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= lastGlyphIndex)</span>
254         return &amp;indexSubtablesZ[i];

255     }
256     return nullptr;
257   }
258 
259   protected:
<span class="line-modified">260   UnsizedArrayOf&lt;IndexSubtableRecord&gt;   indexSubtablesZ;</span>


261 };
262 
263 struct BitmapSizeTable
264 {
265   friend struct CBLC;
266   friend struct CBDT;
267 
<span class="line-modified">268   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
269   {
270     TRACE_SANITIZE (this);
271     return_trace (c-&gt;check_struct (this) &amp;&amp;
272                   indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &amp;&amp;

273                   horizontal.sanitize (c) &amp;&amp;
274                   vertical.sanitize (c));
275   }
276 
<span class="line-modified">277   const IndexSubtableRecord *find_table (hb_codepoint_t glyph,</span>
<span class="line-added">278                                          const void *base,</span>
<span class="line-added">279                                          const void **out_base) const</span>
280   {
<span class="line-added">281     *out_base = &amp;(base+indexSubtableArrayOffset);</span>
282     return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);
283   }
284 
285   protected:
<span class="line-modified">286   LNNOffsetTo&lt;IndexSubtableArray&gt;</span>
287                         indexSubtableArrayOffset;
288   HBUINT32              indexTablesSize;
289   HBUINT32              numberOfIndexSubtables;
290   HBUINT32              colorRef;
291   SBitLineMetrics       horizontal;
292   SBitLineMetrics       vertical;
293   GlyphID               startGlyphIndex;
294   GlyphID               endGlyphIndex;
295   HBUINT8               ppemX;
296   HBUINT8               ppemY;
297   HBUINT8               bitDepth;
298   HBINT8                flags;
299   public:
300   DEFINE_SIZE_STATIC(48);
301 };
302 
303 
304 /*
305  * Glyph Bitmap Data Formats.
306  */
</pre>
<hr />
<pre>
315 
316 struct GlyphBitmapDataFormat18
317 {
318   BigGlyphMetrics       glyphMetrics;
319   LArrayOf&lt;HBUINT8&gt;     data;
320   public:
321   DEFINE_SIZE_ARRAY(12, data);
322 };
323 
324 struct GlyphBitmapDataFormat19
325 {
326   LArrayOf&lt;HBUINT8&gt;     data;
327   public:
328   DEFINE_SIZE_ARRAY(4, data);
329 };
330 
331 struct CBLC
332 {
333   friend struct CBDT;
334 
<span class="line-modified">335   static constexpr hb_tag_t tableTag = HB_OT_TAG_CBLC;</span>
336 
<span class="line-modified">337   bool sanitize (hb_sanitize_context_t *c) const</span>
338   {
339     TRACE_SANITIZE (this);
340     return_trace (c-&gt;check_struct (this) &amp;&amp;
341                   likely (version.major == 2 || version.major == 3) &amp;&amp;
342                   sizeTables.sanitize (c, this));
343   }
344 
345   protected:
<span class="line-modified">346   const BitmapSizeTable &amp;choose_strike (hb_font_t *font) const</span>

347   {
<span class="line-modified">348     unsigned count = sizeTables.len;</span>
<span class="line-added">349     if (unlikely (!count))</span>
<span class="line-added">350       return Null(BitmapSizeTable);</span>
351 
<span class="line-modified">352     unsigned int requested_ppem = MAX (font-&gt;x_ppem, font-&gt;y_ppem);</span>
<span class="line-modified">353     if (!requested_ppem)</span>
<span class="line-added">354       requested_ppem = 1&lt;&lt;30; /* Choose largest strike. */</span>
<span class="line-added">355     unsigned int best_i = 0;</span>
<span class="line-added">356     unsigned int best_ppem = MAX (sizeTables[0].ppemX, sizeTables[0].ppemY);</span>
<span class="line-added">357 </span>
<span class="line-added">358     for (unsigned int i = 1; i &lt; count; i++)</span>
359     {
<span class="line-modified">360       unsigned int ppem = MAX (sizeTables[i].ppemX, sizeTables[i].ppemY);</span>
<span class="line-modified">361       if ((requested_ppem &lt;= ppem &amp;&amp; ppem &lt; best_ppem) ||</span>
<span class="line-modified">362           (requested_ppem &gt; best_ppem &amp;&amp; ppem &gt; best_ppem))</span>
363       {
<span class="line-modified">364         best_i = i;</span>
<span class="line-modified">365         best_ppem = ppem;</span>

366       }
367     }
368 
<span class="line-modified">369     return sizeTables[best_i];</span>
370   }
371 
372   protected:
373   FixedVersion&lt;&gt;                version;
374   LArrayOf&lt;BitmapSizeTable&gt;     sizeTables;
375   public:
376   DEFINE_SIZE_ARRAY(8, sizeTables);
377 };
378 
379 struct CBDT
380 {
<span class="line-modified">381   static constexpr hb_tag_t tableTag = HB_OT_TAG_CBDT;</span>







382 
383   struct accelerator_t
384   {
<span class="line-modified">385     void init (hb_face_t *face)</span>
386     {
<span class="line-modified">387       cblc = hb_sanitize_context_t().reference_table&lt;CBLC&gt; (face);</span>
<span class="line-modified">388       cbdt = hb_sanitize_context_t().reference_table&lt;CBDT&gt; (face);</span>











389 
<span class="line-added">390       upem = hb_face_get_upem (face);</span>
391     }
392 
<span class="line-modified">393     void fini ()</span>
394     {
<span class="line-modified">395       this-&gt;cblc.destroy ();</span>
<span class="line-modified">396       this-&gt;cbdt.destroy ();</span>
397     }
398 
<span class="line-modified">399     bool get_extents (hb_font_t *font, hb_codepoint_t glyph,</span>
<span class="line-added">400                       hb_glyph_extents_t *extents) const</span>
401     {
<span class="line-modified">402       const void *base;</span>
<span class="line-modified">403       const BitmapSizeTable &amp;strike = this-&gt;cblc-&gt;choose_strike (font);</span>
<span class="line-modified">404       const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &amp;base);</span>
<span class="line-modified">405       if (!subtable_record || !strike.ppemX || !strike.ppemY)</span>



406         return false;
407 
<span class="line-modified">408       if (subtable_record-&gt;get_extents (extents, base))</span>
409         return true;
410 
411       unsigned int image_offset = 0, image_length = 0, image_format = 0;
<span class="line-modified">412       if (!subtable_record-&gt;get_image_data (glyph, base, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
413         return false;
414 
415       {
<span class="line-added">416         unsigned int cbdt_len = cbdt.get_length ();</span>
417         if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))
418           return false;
419 
420         switch (image_format)
421         {
422           case 17: {
423             if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))
424               return false;

425             const GlyphBitmapDataFormat17&amp; glyphFormat17 =
426                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);
427             glyphFormat17.glyphMetrics.get_extents (extents);
<span class="line-added">428             break;</span>
<span class="line-added">429           }</span>
<span class="line-added">430           case 18: {</span>
<span class="line-added">431             if (unlikely (image_length &lt; GlyphBitmapDataFormat18::min_size))</span>
<span class="line-added">432               return false;</span>
<span class="line-added">433             const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-added">434                 StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-added">435             glyphFormat18.glyphMetrics.get_extents (extents);</span>
<span class="line-added">436             break;</span>
437           }

438           default:
439             // TODO: Support other image formats.
440             return false;
441         }
442       }
443 
<span class="line-modified">444       /* Convert to font units. */</span>
<span class="line-modified">445       double x_scale = upem / (double) strike.ppemX;</span>
<span class="line-modified">446       double y_scale = upem / (double) strike.ppemY;</span>
<span class="line-modified">447       extents-&gt;x_bearing = round (extents-&gt;x_bearing * x_scale);</span>
<span class="line-modified">448       extents-&gt;y_bearing = round (extents-&gt;y_bearing * y_scale);</span>
<span class="line-added">449       extents-&gt;width = round (extents-&gt;width * x_scale);</span>
<span class="line-added">450       extents-&gt;height = round (extents-&gt;height * y_scale);</span>
451 
452       return true;
453     }
454 
<span class="line-modified">455     hb_blob_t* reference_png (hb_font_t      *font,</span>
<span class="line-modified">456                                      hb_codepoint_t  glyph) const</span>
457     {
<span class="line-modified">458       const void *base;</span>
<span class="line-modified">459       const BitmapSizeTable &amp;strike = this-&gt;cblc-&gt;choose_strike (font);</span>
<span class="line-added">460       const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &amp;base);</span>
<span class="line-added">461       if (!subtable_record || !strike.ppemX || !strike.ppemY)</span>
<span class="line-added">462         return hb_blob_get_empty ();</span>
<span class="line-added">463 </span>
<span class="line-added">464       unsigned int image_offset = 0, image_length = 0, image_format = 0;</span>
<span class="line-added">465       if (!subtable_record-&gt;get_image_data (glyph, base, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
<span class="line-added">466         return hb_blob_get_empty ();</span>
467 

468       {
<span class="line-modified">469         unsigned int cbdt_len = cbdt.get_length ();</span>
<span class="line-modified">470         if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))</span>
<span class="line-modified">471           return hb_blob_get_empty ();</span>
<span class="line-added">472 </span>
<span class="line-added">473         switch (image_format)</span>
474         {
<span class="line-modified">475           case 17: {</span>
<span class="line-modified">476             if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))</span>
<span class="line-modified">477               return hb_blob_get_empty ();</span>
<span class="line-modified">478             const GlyphBitmapDataFormat17&amp; glyphFormat17 =</span>
<span class="line-modified">479               StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">480             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">481                                             image_offset + GlyphBitmapDataFormat17::min_size,</span>
<span class="line-modified">482                                             glyphFormat17.data.len);</span>
<span class="line-modified">483           }</span>
<span class="line-modified">484           case 18: {</span>
<span class="line-modified">485             if (unlikely (image_length &lt; GlyphBitmapDataFormat18::min_size))</span>
<span class="line-modified">486               return hb_blob_get_empty ();</span>
<span class="line-modified">487             const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-modified">488               StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">489             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">490                                             image_offset + GlyphBitmapDataFormat18::min_size,</span>
<span class="line-modified">491                                             glyphFormat18.data.len);</span>
<span class="line-modified">492           }</span>
<span class="line-modified">493           case 19: {</span>
<span class="line-modified">494             if (unlikely (image_length &lt; GlyphBitmapDataFormat19::min_size))</span>
<span class="line-modified">495               return hb_blob_get_empty ();</span>
<span class="line-modified">496             const GlyphBitmapDataFormat19&amp; glyphFormat19 =</span>
<span class="line-modified">497               StructAtOffset&lt;GlyphBitmapDataFormat19&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">498             return hb_blob_create_sub_blob (cbdt.get_blob (),</span>
<span class="line-modified">499                                             image_offset + GlyphBitmapDataFormat19::min_size,</span>
<span class="line-modified">500                                             glyphFormat19.data.len);</span>










501           }
502         }
503       }
<span class="line-added">504 </span>
<span class="line-added">505       return hb_blob_get_empty ();</span>
506     }
507 
<span class="line-added">508     bool has_data () const { return cbdt.get_length (); }</span>
<span class="line-added">509 </span>
510     private:
<span class="line-modified">511     hb_blob_ptr_t&lt;CBLC&gt; cblc;</span>
<span class="line-modified">512     hb_blob_ptr_t&lt;CBDT&gt; cbdt;</span>


513 

514     unsigned int upem;
515   };
516 
<span class="line-added">517   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">518   {</span>
<span class="line-added">519     TRACE_SANITIZE (this);</span>
<span class="line-added">520     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">521                   likely (version.major == 2 || version.major == 3));</span>
<span class="line-added">522   }</span>
523 
524   protected:
<span class="line-modified">525   FixedVersion&lt;&gt;                version;</span>
<span class="line-modified">526   UnsizedArrayOf&lt;HBUINT8&gt;       dataZ;</span>
527   public:
528   DEFINE_SIZE_ARRAY(4, dataZ);
529 };
530 
<span class="line-added">531 struct CBDT_accelerator_t : CBDT::accelerator_t {};</span>
<span class="line-added">532 </span>
533 } /* namespace OT */
534 
535 #endif /* HB_OT_COLOR_CBDT_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-cmap-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-colr-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
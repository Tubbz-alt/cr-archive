<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-maxp-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_NAME_TABLE_HH
 28 #define HB_OT_NAME_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>


 31 
 32 
 33 namespace OT {
 34 
 35 




 36 /*
 37  * name -- Naming
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/name
 39  */
 40 #define HB_OT_TAG_name HB_TAG(&#39;n&#39;,&#39;a&#39;,&#39;m&#39;,&#39;e&#39;)
 41 

 42 
 43 struct NameRecord
 44 {
<span class="line-modified"> 45   static int cmp (const void *pa, const void *pb)</span>
 46   {
<span class="line-modified"> 47     const NameRecord *a = (const NameRecord *) pa;</span>
<span class="line-modified"> 48     const NameRecord *b = (const NameRecord *) pb;</span>
<span class="line-modified"> 49     int ret;</span>
<span class="line-modified"> 50     ret = b-&gt;platformID.cmp (a-&gt;platformID);</span>
<span class="line-modified"> 51     if (ret) return ret;</span>
<span class="line-modified"> 52     ret = b-&gt;encodingID.cmp (a-&gt;encodingID);</span>
<span class="line-modified"> 53     if (ret) return ret;</span>
<span class="line-modified"> 54     ret = b-&gt;languageID.cmp (a-&gt;languageID);</span>
<span class="line-modified"> 55     if (ret) return ret;</span>
<span class="line-modified"> 56     ret = b-&gt;nameID.cmp (a-&gt;nameID);</span>
<span class="line-modified"> 57     if (ret) return ret;</span>
<span class="line-modified"> 58     return 0;</span>

 59   }
 60 
<span class="line-modified"> 61   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>



























 62   {
 63     TRACE_SANITIZE (this);
 64     /* We can check from base all the way up to the end of string... */
 65     return_trace (c-&gt;check_struct (this) &amp;&amp; c-&gt;check_range ((char *) base, (unsigned int) length + offset));
 66   }
 67 
 68   HBUINT16      platformID;     /* Platform ID. */
 69   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 70   HBUINT16      languageID;     /* Language ID. */
 71   HBUINT16      nameID;         /* Name ID. */
 72   HBUINT16      length;         /* String length (in bytes). */
 73   HBUINT16      offset;         /* String offset from start of storage area (in bytes). */
 74   public:
 75   DEFINE_SIZE_STATIC (12);
 76 };
 77 







































 78 struct name
 79 {
<span class="line-modified"> 80   static const hb_tag_t tableTag        = HB_OT_TAG_name;</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82   inline unsigned int get_name (unsigned int platform_id,</span>
<span class="line-removed"> 83                                 unsigned int encoding_id,</span>
<span class="line-removed"> 84                                 unsigned int language_id,</span>
<span class="line-removed"> 85                                 unsigned int name_id,</span>
<span class="line-removed"> 86                                 void *buffer,</span>
<span class="line-removed"> 87                                 unsigned int buffer_length) const</span>
<span class="line-removed"> 88   {</span>
<span class="line-removed"> 89     NameRecord key;</span>
<span class="line-removed"> 90     key.platformID.set (platform_id);</span>
<span class="line-removed"> 91     key.encodingID.set (encoding_id);</span>
<span class="line-removed"> 92     key.languageID.set (language_id);</span>
<span class="line-removed"> 93     key.nameID.set (name_id);</span>
<span class="line-removed"> 94     NameRecord *match = (NameRecord *) bsearch (&amp;key, nameRecord, count, sizeof (nameRecord[0]), NameRecord::cmp);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96     if (!match)</span>
<span class="line-removed"> 97       return 0;</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99     unsigned int length = MIN (buffer_length, (unsigned int) match-&gt;length);</span>
<span class="line-removed">100     memcpy (buffer, (char *) this + stringOffset + match-&gt;offset, length);</span>
<span class="line-removed">101     return length;</span>
<span class="line-removed">102   }</span>
103 
<span class="line-modified">104   inline unsigned int get_size (void) const</span>
<span class="line-modified">105   { return min_size + count * nameRecord[0].min_size; }</span>
106 
<span class="line-modified">107   inline bool sanitize_records (hb_sanitize_context_t *c) const {</span>

108     TRACE_SANITIZE (this);
<span class="line-modified">109     char *string_pool = (char *) this + stringOffset;</span>
110     unsigned int _count = count;

111     for (unsigned int i = 0; i &lt; _count; i++)
<span class="line-modified">112       if (!nameRecord[i].sanitize (c, string_pool)) return_trace (false);</span>
113     return_trace (true);
114   }
115 
<span class="line-modified">116   inline bool sanitize (hb_sanitize_context_t *c) const</span>
117   {
118     TRACE_SANITIZE (this);
119     return_trace (c-&gt;check_struct (this) &amp;&amp;
120                   likely (format == 0 || format == 1) &amp;&amp;
<span class="line-modified">121                   c-&gt;check_array (nameRecord, nameRecord[0].static_size, count) &amp;&amp;</span>
<span class="line-modified">122                   sanitize_records (c));</span>
123   }
124 




















































































125   /* We only implement format 0 for now. */
126   HBUINT16      format;                 /* Format selector (=0/1). */
127   HBUINT16      count;                  /* Number of name records. */
<span class="line-modified">128   Offset16      stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="line-modified">129   NameRecord    nameRecord[VAR];        /* The name records where count is the number of records. */</span>


130   public:
<span class="line-modified">131   DEFINE_SIZE_ARRAY (6, nameRecord);</span>
132 };
133 

134 
135 } /* namespace OT */
136 
137 
138 #endif /* HB_OT_NAME_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_NAME_TABLE_HH
 28 #define HB_OT_NAME_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-added"> 31 #include &quot;hb-ot-name-language.hh&quot;</span>
<span class="line-added"> 32 #include &quot;hb-aat-layout.hh&quot;</span>
 33 
 34 
 35 namespace OT {
 36 
 37 
<span class="line-added"> 38 #define entry_score var.u16[0]</span>
<span class="line-added"> 39 #define entry_index var.u16[1]</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 </span>
 42 /*
 43  * name -- Naming
 44  * https://docs.microsoft.com/en-us/typography/opentype/spec/name
 45  */
 46 #define HB_OT_TAG_name HB_TAG(&#39;n&#39;,&#39;a&#39;,&#39;m&#39;,&#39;e&#39;)
 47 
<span class="line-added"> 48 #define UNSUPPORTED     42</span>
 49 
 50 struct NameRecord
 51 {
<span class="line-modified"> 52   hb_language_t language (hb_face_t *face) const</span>
 53   {
<span class="line-modified"> 54     unsigned int p = platformID;</span>
<span class="line-modified"> 55     unsigned int l = languageID;</span>
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57     if (p == 3)</span>
<span class="line-modified"> 58       return _hb_ot_name_language_for_ms_code (l);</span>
<span class="line-modified"> 59 </span>
<span class="line-modified"> 60     if (p == 1)</span>
<span class="line-modified"> 61       return _hb_ot_name_language_for_mac_code (l);</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63     if (p == 0)</span>
<span class="line-modified"> 64       return _hb_aat_language_get (face, l);</span>
<span class="line-modified"> 65 </span>
<span class="line-added"> 66     return HB_LANGUAGE_INVALID;</span>
 67   }
 68 
<span class="line-modified"> 69   uint16_t score () const</span>
<span class="line-added"> 70   {</span>
<span class="line-added"> 71     /* Same order as in cmap::find_best_subtable(). */</span>
<span class="line-added"> 72     unsigned int p = platformID;</span>
<span class="line-added"> 73     unsigned int e = encodingID;</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     /* 32-bit. */</span>
<span class="line-added"> 76     if (p == 3 &amp;&amp; e == 10) return 0;</span>
<span class="line-added"> 77     if (p == 0 &amp;&amp; e ==  6) return 1;</span>
<span class="line-added"> 78     if (p == 0 &amp;&amp; e ==  4) return 2;</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80     /* 16-bit. */</span>
<span class="line-added"> 81     if (p == 3 &amp;&amp; e ==  1) return 3;</span>
<span class="line-added"> 82     if (p == 0 &amp;&amp; e ==  3) return 4;</span>
<span class="line-added"> 83     if (p == 0 &amp;&amp; e ==  2) return 5;</span>
<span class="line-added"> 84     if (p == 0 &amp;&amp; e ==  1) return 6;</span>
<span class="line-added"> 85     if (p == 0 &amp;&amp; e ==  0) return 7;</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87     /* Symbol. */</span>
<span class="line-added"> 88     if (p == 3 &amp;&amp; e ==  0) return 8;</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90     /* We treat all Mac Latin names as ASCII only. */</span>
<span class="line-added"> 91     if (p == 1 &amp;&amp; e ==  0) return 10; /* 10 is magic number :| */</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     return UNSUPPORTED;</span>
<span class="line-added"> 94   }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 97   {
 98     TRACE_SANITIZE (this);
 99     /* We can check from base all the way up to the end of string... */
100     return_trace (c-&gt;check_struct (this) &amp;&amp; c-&gt;check_range ((char *) base, (unsigned int) length + offset));
101   }
102 
103   HBUINT16      platformID;     /* Platform ID. */
104   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
105   HBUINT16      languageID;     /* Language ID. */
106   HBUINT16      nameID;         /* Name ID. */
107   HBUINT16      length;         /* String length (in bytes). */
108   HBUINT16      offset;         /* String offset from start of storage area (in bytes). */
109   public:
110   DEFINE_SIZE_STATIC (12);
111 };
112 
<span class="line-added">113 static int</span>
<span class="line-added">114 _hb_ot_name_entry_cmp_key (const void *pa, const void *pb)</span>
<span class="line-added">115 {</span>
<span class="line-added">116   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="line-added">117   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="line-added">118 </span>
<span class="line-added">119   /* Compare by name_id, then language. */</span>
<span class="line-added">120 </span>
<span class="line-added">121   if (a-&gt;name_id != b-&gt;name_id)</span>
<span class="line-added">122     return a-&gt;name_id &lt; b-&gt;name_id ? -1 : +1;</span>
<span class="line-added">123 </span>
<span class="line-added">124   if (a-&gt;language == b-&gt;language) return 0;</span>
<span class="line-added">125   if (!a-&gt;language) return -1;</span>
<span class="line-added">126   if (!b-&gt;language) return +1;</span>
<span class="line-added">127   return strcmp (hb_language_to_string (a-&gt;language),</span>
<span class="line-added">128                  hb_language_to_string (b-&gt;language));</span>
<span class="line-added">129 }</span>
<span class="line-added">130 </span>
<span class="line-added">131 static int</span>
<span class="line-added">132 _hb_ot_name_entry_cmp (const void *pa, const void *pb)</span>
<span class="line-added">133 {</span>
<span class="line-added">134   /* Compare by name_id, then language, then score, then index. */</span>
<span class="line-added">135 </span>
<span class="line-added">136   int v = _hb_ot_name_entry_cmp_key (pa, pb);</span>
<span class="line-added">137   if (v)</span>
<span class="line-added">138     return v;</span>
<span class="line-added">139 </span>
<span class="line-added">140   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="line-added">141   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="line-added">142 </span>
<span class="line-added">143   if (a-&gt;entry_score != b-&gt;entry_score)</span>
<span class="line-added">144     return a-&gt;entry_score &lt; b-&gt;entry_score ? -1 : +1;</span>
<span class="line-added">145 </span>
<span class="line-added">146   if (a-&gt;entry_index != b-&gt;entry_index)</span>
<span class="line-added">147     return a-&gt;entry_index &lt; b-&gt;entry_index ? -1 : +1;</span>
<span class="line-added">148 </span>
<span class="line-added">149   return 0;</span>
<span class="line-added">150 }</span>
<span class="line-added">151 </span>
152 struct name
153 {
<span class="line-modified">154   static constexpr hb_tag_t tableTag = HB_OT_TAG_name;</span>






















155 
<span class="line-modified">156   unsigned int get_size () const</span>
<span class="line-modified">157   { return min_size + count * nameRecordZ.item_size; }</span>
158 
<span class="line-modified">159   bool sanitize_records (hb_sanitize_context_t *c) const</span>
<span class="line-added">160   {</span>
161     TRACE_SANITIZE (this);
<span class="line-modified">162     const void *string_pool = (this+stringOffset).arrayZ;</span>
163     unsigned int _count = count;
<span class="line-added">164     /* Move to run-time?! */</span>
165     for (unsigned int i = 0; i &lt; _count; i++)
<span class="line-modified">166       if (!nameRecordZ[i].sanitize (c, string_pool)) return_trace (false);</span>
167     return_trace (true);
168   }
169 
<span class="line-modified">170   bool sanitize (hb_sanitize_context_t *c) const</span>
171   {
172     TRACE_SANITIZE (this);
173     return_trace (c-&gt;check_struct (this) &amp;&amp;
174                   likely (format == 0 || format == 1) &amp;&amp;
<span class="line-modified">175                   c-&gt;check_array (nameRecordZ.arrayZ, count) &amp;&amp;</span>
<span class="line-modified">176                   c-&gt;check_range (this, stringOffset));</span>
177   }
178 
<span class="line-added">179   struct accelerator_t</span>
<span class="line-added">180   {</span>
<span class="line-added">181     void init (hb_face_t *face)</span>
<span class="line-added">182     {</span>
<span class="line-added">183       this-&gt;table = hb_sanitize_context_t().reference_table&lt;name&gt; (face);</span>
<span class="line-added">184       assert (this-&gt;table.get_length () &gt;= this-&gt;table-&gt;stringOffset);</span>
<span class="line-added">185       this-&gt;pool = (const char *) (const void *) (this-&gt;table+this-&gt;table-&gt;stringOffset);</span>
<span class="line-added">186       this-&gt;pool_len = this-&gt;table.get_length () - this-&gt;table-&gt;stringOffset;</span>
<span class="line-added">187       const hb_array_t&lt;const NameRecord&gt; all_names (this-&gt;table-&gt;nameRecordZ.arrayZ,</span>
<span class="line-added">188                                                     this-&gt;table-&gt;count);</span>
<span class="line-added">189 </span>
<span class="line-added">190       this-&gt;names.init ();</span>
<span class="line-added">191       this-&gt;names.alloc (all_names.length);</span>
<span class="line-added">192 </span>
<span class="line-added">193       for (unsigned int i = 0; i &lt; all_names.length; i++)</span>
<span class="line-added">194       {</span>
<span class="line-added">195         hb_ot_name_entry_t *entry = this-&gt;names.push ();</span>
<span class="line-added">196 </span>
<span class="line-added">197         entry-&gt;name_id = all_names[i].nameID;</span>
<span class="line-added">198         entry-&gt;language = all_names[i].language (face);</span>
<span class="line-added">199         entry-&gt;entry_score =  all_names[i].score ();</span>
<span class="line-added">200         entry-&gt;entry_index = i;</span>
<span class="line-added">201       }</span>
<span class="line-added">202 </span>
<span class="line-added">203       this-&gt;names.qsort (_hb_ot_name_entry_cmp);</span>
<span class="line-added">204       /* Walk and pick best only for each name_id,language pair,</span>
<span class="line-added">205        * while dropping unsupported encodings. */</span>
<span class="line-added">206       unsigned int j = 0;</span>
<span class="line-added">207       for (unsigned int i = 0; i &lt; this-&gt;names.length; i++)</span>
<span class="line-added">208       {</span>
<span class="line-added">209         if (this-&gt;names[i].entry_score == UNSUPPORTED ||</span>
<span class="line-added">210             this-&gt;names[i].language == HB_LANGUAGE_INVALID)</span>
<span class="line-added">211           continue;</span>
<span class="line-added">212         if (i &amp;&amp;</span>
<span class="line-added">213             this-&gt;names[i - 1].name_id  == this-&gt;names[i].name_id &amp;&amp;</span>
<span class="line-added">214             this-&gt;names[i - 1].language == this-&gt;names[i].language)</span>
<span class="line-added">215           continue;</span>
<span class="line-added">216         this-&gt;names[j++] = this-&gt;names[i];</span>
<span class="line-added">217       }</span>
<span class="line-added">218       this-&gt;names.resize (j);</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
<span class="line-added">221     void fini ()</span>
<span class="line-added">222     {</span>
<span class="line-added">223       this-&gt;names.fini ();</span>
<span class="line-added">224       this-&gt;table.destroy ();</span>
<span class="line-added">225     }</span>
<span class="line-added">226 </span>
<span class="line-added">227     int get_index (hb_ot_name_id_t   name_id,</span>
<span class="line-added">228                           hb_language_t     language,</span>
<span class="line-added">229                           unsigned int     *width=nullptr) const</span>
<span class="line-added">230     {</span>
<span class="line-added">231       const hb_ot_name_entry_t key = {name_id, {0}, language};</span>
<span class="line-added">232       const hb_ot_name_entry_t *entry = (const hb_ot_name_entry_t *)</span>
<span class="line-added">233                                         hb_bsearch (&amp;key,</span>
<span class="line-added">234                                                     (const hb_ot_name_entry_t *) this-&gt;names,</span>
<span class="line-added">235                                                     this-&gt;names.length,</span>
<span class="line-added">236                                                     sizeof (key),</span>
<span class="line-added">237                                                     _hb_ot_name_entry_cmp_key);</span>
<span class="line-added">238       if (!entry)</span>
<span class="line-added">239         return -1;</span>
<span class="line-added">240 </span>
<span class="line-added">241       if (width)</span>
<span class="line-added">242         *width = entry-&gt;entry_score &lt; 10 ? 2 : 1;</span>
<span class="line-added">243 </span>
<span class="line-added">244       return entry-&gt;entry_index;</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
<span class="line-added">247     hb_bytes_t get_name (unsigned int idx) const</span>
<span class="line-added">248     {</span>
<span class="line-added">249       const hb_array_t&lt;const NameRecord&gt; all_names (table-&gt;nameRecordZ.arrayZ, table-&gt;count);</span>
<span class="line-added">250       const NameRecord &amp;record = all_names[idx];</span>
<span class="line-added">251       const hb_bytes_t string_pool (pool, pool_len);</span>
<span class="line-added">252       return string_pool.sub_array (record.offset, record.length);</span>
<span class="line-added">253     }</span>
<span class="line-added">254 </span>
<span class="line-added">255     private:</span>
<span class="line-added">256     const char *pool;</span>
<span class="line-added">257     unsigned int pool_len;</span>
<span class="line-added">258     public:</span>
<span class="line-added">259     hb_blob_ptr_t&lt;name&gt; table;</span>
<span class="line-added">260     hb_vector_t&lt;hb_ot_name_entry_t&gt; names;</span>
<span class="line-added">261   };</span>
<span class="line-added">262 </span>
263   /* We only implement format 0 for now. */
264   HBUINT16      format;                 /* Format selector (=0/1). */
265   HBUINT16      count;                  /* Number of name records. */
<span class="line-modified">266   NNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT8&gt; &gt;</span>
<span class="line-modified">267                 stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="line-added">268   UnsizedArrayOf&lt;NameRecord&gt;</span>
<span class="line-added">269                 nameRecordZ;            /* The name records where count is the number of records. */</span>
270   public:
<span class="line-modified">271   DEFINE_SIZE_ARRAY (6, nameRecordZ);</span>
272 };
273 
<span class="line-added">274 struct name_accelerator_t : name::accelerator_t {};</span>
275 
276 } /* namespace OT */
277 
278 
279 #endif /* HB_OT_NAME_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-maxp-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
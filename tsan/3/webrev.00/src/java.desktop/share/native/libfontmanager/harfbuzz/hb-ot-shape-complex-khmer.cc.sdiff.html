<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-khmer-machine.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-myanmar-machine.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-khmer-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-layout-private.hh&quot;</span>
 29 
 30 
 31 /*
 32  * Khmer shaper.
 33  */
 34 
<span class="line-modified"> 35 struct feature_list_t {</span>
<span class="line-removed"> 36   hb_tag_t tag;</span>
<span class="line-removed"> 37   hb_ot_map_feature_flags_t flags;</span>
<span class="line-removed"> 38 };</span>
<span class="line-removed"> 39 </span>
<span class="line-removed"> 40 static const feature_list_t</span>
 41 khmer_features[] =
 42 {
 43   /*
 44    * Basic features.
<span class="line-modified"> 45    * These features are applied in order, one at a time, after initial_reordering.</span>
 46    */
<span class="line-modified"> 47   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 48   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 49   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 50   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 51   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_NONE},</span>
 52   /*
 53    * Other features.
<span class="line-modified"> 54    * These features are applied all at once, after final_reordering.</span>
<span class="line-modified"> 55    * Default Bengali font in Windows for example has intermixed</span>
<span class="line-modified"> 56    * lookups for init,pres,abvs,blws features.</span>






 57    */
<span class="line-removed"> 58   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 59   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 60   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 61   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed"> 62   /* Positioning features, though we don&#39;t care about the types. */</span>
 63   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 64   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 65   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 66 };
 67 
 68 /*
 69  * Must be in the same order as the khmer_features array.
 70  */
 71 enum {
 72   PREF,
 73   BLWF,
 74   ABVF,
 75   PSTF,
 76   CFAR,
 77 
 78   _PRES,
 79   _ABVS,
 80   _BLWS,
 81   _PSTS,

 82   _DIST,
 83   _ABVM,
 84   _BLWM,
 85 
 86   KHMER_NUM_FEATURES,
<span class="line-modified"> 87   KHMER_BASIC_FEATURES = _PRES /* Don&#39;t forget to update this! */</span>
 88 };
 89 
 90 static void
 91 setup_syllables (const hb_ot_shape_plan_t *plan,
 92                  hb_font_t *font,
 93                  hb_buffer_t *buffer);
 94 static void
<span class="line-modified"> 95 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 96                     hb_font_t *font,</span>
<span class="line-modified"> 97                     hb_buffer_t *buffer);</span>
<span class="line-removed"> 98 static void</span>
<span class="line-removed"> 99 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">100                   hb_font_t *font,</span>
<span class="line-removed">101                   hb_buffer_t *buffer);</span>
102 static void
103 clear_syllables (const hb_ot_shape_plan_t *plan,
104                  hb_font_t *font,
105                  hb_buffer_t *buffer);
106 
107 static void
108 collect_features_khmer (hb_ot_shape_planner_t *plan)
109 {
110   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
111 
112   /* Do this before any lookups have been applied. */
113   map-&gt;add_gsub_pause (setup_syllables);

114 
<span class="line-modified">115   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-modified">116   /* The Indic specs do not require ccmp, but we apply it here since if</span>
<span class="line-modified">117    * there is a use of it, it&#39;s typically at the beginning. */</span>
<span class="line-modified">118   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">119 </span>







120 
121   unsigned int i = 0;
<span class="line-modified">122   map-&gt;add_gsub_pause (initial_reordering);</span>
<span class="line-modified">123   for (; i &lt; KHMER_BASIC_FEATURES; i++) {</span>
<span class="line-removed">124     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">125     map-&gt;add_gsub_pause (nullptr);</span>
<span class="line-removed">126   }</span>
<span class="line-removed">127   map-&gt;add_gsub_pause (final_reordering);</span>
<span class="line-removed">128   for (; i &lt; KHMER_NUM_FEATURES; i++) {</span>
<span class="line-removed">129     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">130   }</span>
<span class="line-removed">131 </span>
<span class="line-removed">132   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-removed">133   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
134 
135   map-&gt;add_gsub_pause (clear_syllables);



136 }
137 
138 static void
139 override_features_khmer (hb_ot_shape_planner_t *plan)
140 {







141   /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
142   if (hb_options ().uniscribe_bug_compatible)
143   {
<span class="line-modified">144     plan-&gt;map.add_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), 0, F_GLOBAL);</span>
145   }
146 
<span class="line-modified">147   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
148 }
149 
150 
151 struct would_substitute_feature_t
152 {
<span class="line-modified">153   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
154   {
155     zero_context = zero_context_;
156     map-&gt;get_stage_lookups (0/*GSUB*/,
157                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
158                             &amp;lookups, &amp;count);
159   }
160 
<span class="line-modified">161   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">162                                 unsigned int          glyphs_count,</span>
<span class="line-modified">163                                 hb_face_t            *face) const</span>
164   {
165     for (unsigned int i = 0; i &lt; count; i++)
166       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
167         return true;
168     return false;
169   }
170 
171   private:
172   const hb_ot_map_t::lookup_map_t *lookups;
173   unsigned int count;
174   bool zero_context;
175 };
176 
177 struct khmer_shape_plan_t
178 {
<span class="line-modified">179   ASSERT_POD ();</span>
<span class="line-removed">180 </span>
<span class="line-removed">181   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
182   {
183     hb_codepoint_t glyph = virama_glyph;
184     if (unlikely (virama_glyph == (hb_codepoint_t) -1))
185     {
186       if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
187         glyph = 0;
188       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
189        * Maybe one day... */
190 
191       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
192        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */
193       virama_glyph = glyph;
194     }
195 
196     *pglyph = glyph;
197     return glyph != 0;
198   }
199 
200   mutable hb_codepoint_t virama_glyph;
201 
</pre>
<hr />
<pre>
226 data_destroy_khmer (void *data)
227 {
228   free (data);
229 }
230 
231 
232 enum syllable_type_t {
233   consonant_syllable,
234   broken_cluster,
235   non_khmer_cluster,
236 };
237 
238 #include &quot;hb-ot-shape-complex-khmer-machine.hh&quot;
239 
240 static void
241 setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,
242                    hb_buffer_t              *buffer,
243                    hb_font_t                *font HB_UNUSED)
244 {
245   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);
<span class="line-removed">246   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_position);</span>
247 
248   /* We cannot setup masks here.  We save information about characters
249    * and setup masks later on in a pause-callback. */
250 
251   unsigned int count = buffer-&gt;len;
252   hb_glyph_info_t *info = buffer-&gt;info;
253   for (unsigned int i = 0; i &lt; count; i++)
254     set_khmer_properties (info[i]);
255 }
256 
257 static void
258 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
259                  hb_font_t *font HB_UNUSED,
260                  hb_buffer_t *buffer)
261 {
262   find_syllables (buffer);
263   foreach_syllable (buffer, start, end)
264     buffer-&gt;unsafe_to_break (start, end);
265 }
266 
<span class="line-removed">267 static int</span>
<span class="line-removed">268 compare_khmer_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)</span>
<span class="line-removed">269 {</span>
<span class="line-removed">270   int a = pa-&gt;khmer_position();</span>
<span class="line-removed">271   int b = pb-&gt;khmer_position();</span>
<span class="line-removed">272 </span>
<span class="line-removed">273   return a &lt; b ? -1 : a == b ? 0 : +1;</span>
<span class="line-removed">274 }</span>
<span class="line-removed">275 </span>
276 
277 /* Rules from:
278  * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
279 
280 static void
<span class="line-modified">281 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">282                                        hb_face_t *face,</span>
<span class="line-modified">283                                        hb_buffer_t *buffer,</span>
<span class="line-modified">284                                        unsigned int start, unsigned int end)</span>
285 {
286   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
287   hb_glyph_info_t *info = buffer-&gt;info;
288 
<span class="line-modified">289   /* 1. Khmer shaping assumes that a syllable will begin with a Cons, IndV, or Number. */</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   /* The first consonant is always the base. */</span>
<span class="line-removed">292   unsigned int base = start;</span>
<span class="line-removed">293   info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">294 </span>
<span class="line-removed">295   /* Mark all subsequent consonants as below. */</span>
<span class="line-removed">296   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">297     if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">298       info[i].khmer_position() = POS_BELOW_C;</span>
<span class="line-removed">299 </span>
<span class="line-removed">300   /* Mark final consonants.  A final consonant is one appearing after a matra,</span>
<span class="line-removed">301    * like in Khmer. */</span>
<span class="line-removed">302   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">303     if (info[i].khmer_category() == OT_M) {</span>
<span class="line-removed">304       for (unsigned int j = i + 1; j &lt; end; j++)</span>
<span class="line-removed">305         if (is_consonant_or_vowel (info[j])) {</span>
<span class="line-removed">306           info[j].khmer_position() = POS_FINAL_C;</span>
<span class="line-removed">307           break;</span>
<span class="line-removed">308         }</span>
<span class="line-removed">309       break;</span>
<span class="line-removed">310     }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312   /* Attach misc marks to previous char to move with them. */</span>
<span class="line-removed">313   {</span>
<span class="line-removed">314     khmer_position_t last_pos = POS_START;</span>
<span class="line-removed">315     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">316     {</span>
<span class="line-removed">317       if ((FLAG_UNSAFE (info[i].khmer_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_Coeng))))</span>
<span class="line-removed">318       {</span>
<span class="line-removed">319         info[i].khmer_position() = last_pos;</span>
<span class="line-removed">320         if (unlikely (info[i].khmer_category() == OT_Coeng &amp;&amp;</span>
<span class="line-removed">321                       info[i].khmer_position() == POS_PRE_M))</span>
<span class="line-removed">322         {</span>
<span class="line-removed">323           /*</span>
<span class="line-removed">324            * Uniscribe doesn&#39;t move the Halant with Left Matra.</span>
<span class="line-removed">325            * TEST: U+092B,U+093F,U+094DE</span>
<span class="line-removed">326            * We follow.  This is important for the Sinhala</span>
<span class="line-removed">327            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA</span>
<span class="line-removed">328            * where U+0DD9 is a left matra and U+0DCA is the virama.</span>
<span class="line-removed">329            * We don&#39;t want to move the virama with the left matra.</span>
<span class="line-removed">330            * TEST: U+0D9A,U+0DDA</span>
<span class="line-removed">331            */</span>
<span class="line-removed">332           for (unsigned int j = i; j &gt; start; j--)</span>
<span class="line-removed">333             if (info[j - 1].khmer_position() != POS_PRE_M) {</span>
<span class="line-removed">334               info[i].khmer_position() = info[j - 1].khmer_position();</span>
<span class="line-removed">335               break;</span>
<span class="line-removed">336             }</span>
<span class="line-removed">337         }</span>
<span class="line-removed">338       } else if (info[i].khmer_position() != POS_SMVD) {</span>
<span class="line-removed">339         last_pos = (khmer_position_t) info[i].khmer_position();</span>
<span class="line-removed">340       }</span>
<span class="line-removed">341     }</span>
<span class="line-removed">342   }</span>
<span class="line-removed">343   /* For post-base consonants let them own anything before them</span>
<span class="line-removed">344    * since the last consonant or matra. */</span>
<span class="line-removed">345   {</span>
<span class="line-removed">346     unsigned int last = base;</span>
<span class="line-removed">347     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">348       if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">349       {</span>
<span class="line-removed">350         for (unsigned int j = last + 1; j &lt; i; j++)</span>
<span class="line-removed">351           if (info[j].khmer_position() &lt; POS_SMVD)</span>
<span class="line-removed">352             info[j].khmer_position() = info[i].khmer_position();</span>
<span class="line-removed">353         last = i;</span>
<span class="line-removed">354       } else if (info[i].khmer_category() == OT_M)</span>
<span class="line-removed">355         last = i;</span>
<span class="line-removed">356   }</span>
<span class="line-removed">357 </span>
358   {
<span class="line-removed">359     /* Use syllable() for sort accounting temporarily. */</span>
<span class="line-removed">360     unsigned int syllable = info[start].syllable();</span>
<span class="line-removed">361     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">362       info[i].syllable() = i - start;</span>
<span class="line-removed">363 </span>
<span class="line-removed">364     /* Sit tight, rock &#39;n roll! */</span>
<span class="line-removed">365     hb_stable_sort (info + start, end - start, compare_khmer_order);</span>
<span class="line-removed">366     /* Find base again */</span>
<span class="line-removed">367     base = end;</span>
<span class="line-removed">368     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">369       if (info[i].khmer_position() == POS_BASE_C)</span>
<span class="line-removed">370       {</span>
<span class="line-removed">371         base = i;</span>
<span class="line-removed">372         break;</span>
<span class="line-removed">373       }</span>
<span class="line-removed">374 </span>
<span class="line-removed">375     if (unlikely (end - start &gt;= 127))</span>
<span class="line-removed">376       buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">377     else</span>
<span class="line-removed">378       /* Note!  syllable() is a one-byte field. */</span>
<span class="line-removed">379       for (unsigned int i = base; i &lt; end; i++)</span>
<span class="line-removed">380         if (info[i].syllable() != 255)</span>
<span class="line-removed">381         {</span>
<span class="line-removed">382           unsigned int max = i;</span>
<span class="line-removed">383           unsigned int j = start + info[i].syllable();</span>
<span class="line-removed">384           while (j != i)</span>
<span class="line-removed">385           {</span>
<span class="line-removed">386             max = MAX (max, j);</span>
<span class="line-removed">387             unsigned int next = start + info[j].syllable();</span>
<span class="line-removed">388             info[j].syllable() = 255; /* So we don&#39;t process j later again. */</span>
<span class="line-removed">389             j = next;</span>
<span class="line-removed">390           }</span>
<span class="line-removed">391           if (i != max)</span>
<span class="line-removed">392             buffer-&gt;merge_clusters (i, max + 1);</span>
<span class="line-removed">393         }</span>
<span class="line-removed">394 </span>
<span class="line-removed">395     /* Put syllable back in. */</span>
<span class="line-removed">396     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">397       info[i].syllable() = syllable;</span>
<span class="line-removed">398   }</span>
<span class="line-removed">399 </span>
<span class="line-removed">400   /* Setup masks now */</span>
<span class="line-removed">401 </span>
<span class="line-removed">402   {</span>
<span class="line-removed">403     hb_mask_t mask;</span>
<span class="line-removed">404 </span>
405     /* Post-base */
<span class="line-modified">406     mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">407     for (unsigned int i = base + 1; i &lt; end; i++)</span>
408       info[i].mask  |= mask;
409   }
410 
<span class="line-modified">411   unsigned int pref_len = 2;</span>
<span class="line-modified">412   if (khmer_plan-&gt;mask_array[PREF] &amp;&amp; base + pref_len &lt; end)</span>
413   {
<span class="line-modified">414     /* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. */</span>
<span class="line-modified">415     for (unsigned int i = base + 1; i + pref_len - 1 &lt; end; i++) {</span>
<span class="line-modified">416       hb_codepoint_t glyphs[2];</span>
<span class="line-modified">417       for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">418         glyphs[j] = info[i + j].codepoint;</span>
<span class="line-modified">419       if (khmer_plan-&gt;pref.would_substitute (glyphs, pref_len, face))</span>











420       {
<span class="line-modified">421         for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">422           info[i++].mask |= khmer_plan-&gt;mask_array[PREF];</span>








423 
424         /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
425          * Read the feature spec.
426          * This allows distinguishing the following cases with MS Khmer fonts:
427          * U+1784,U+17D2,U+179A,U+17D2,U+1782
428          * U+1784,U+17D2,U+1782,U+17D2,U+179A
429          */
430         if (khmer_plan-&gt;mask_array[CFAR])
<span class="line-modified">431           for (; i &lt; end; i++)</span>
<span class="line-modified">432             info[i].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
433 
<span class="line-modified">434         break;</span>
435       }
436     }










437   }
438 }
439 
440 static void
441 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
442                              hb_face_t *face,
443                              hb_buffer_t *buffer,
444                              unsigned int start, unsigned int end)
445 {
446   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
447   switch (syllable_type)
448   {
449     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
450     case consonant_syllable:
<span class="line-modified">451      initial_reordering_consonant_syllable (plan, face, buffer, start, end);</span>
452      break;
453 
454     case non_khmer_cluster:
455       break;
456   }
457 }
458 
459 static inline void
460 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
461                        hb_font_t *font,
462                        hb_buffer_t *buffer)
463 {
464   /* Note: This loop is extra overhead, but should not be measurable. */
465   bool has_broken_syllables = false;
466   unsigned int count = buffer-&gt;len;
467   hb_glyph_info_t *info = buffer-&gt;info;
468   for (unsigned int i = 0; i &lt; count; i++)
469     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
470     {
471       has_broken_syllables = true;
</pre>
<hr />
<pre>
496     {
497       last_syllable = syllable;
498 
499       hb_glyph_info_t ginfo = dottedcircle;
500       ginfo.cluster = buffer-&gt;cur().cluster;
501       ginfo.mask = buffer-&gt;cur().mask;
502       ginfo.syllable() = buffer-&gt;cur().syllable();
503       /* TODO Set glyph_props? */
504 
505       /* Insert dottedcircle after possible Repha. */
506       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
507              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
508              buffer-&gt;cur().khmer_category() == OT_Repha)
509         buffer-&gt;next_glyph ();
510 
511       buffer-&gt;output_info (ginfo);
512     }
513     else
514       buffer-&gt;next_glyph ();
515   }
<span class="line-removed">516 </span>
517   buffer-&gt;swap_buffers ();
518 }
519 
520 static void
<span class="line-modified">521 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">522                     hb_font_t *font,</span>
<span class="line-modified">523                     hb_buffer_t *buffer)</span>
524 {
525   insert_dotted_circles (plan, font, buffer);
526 
527   foreach_syllable (buffer, start, end)
528     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<span class="line-removed">529 }</span>
<span class="line-removed">530 </span>
<span class="line-removed">531 static void</span>
<span class="line-removed">532 final_reordering_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">533                            hb_buffer_t *buffer,</span>
<span class="line-removed">534                            unsigned int start, unsigned int end)</span>
<span class="line-removed">535 {</span>
<span class="line-removed">536   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;</span>
<span class="line-removed">537   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">538 </span>
<span class="line-removed">539 </span>
<span class="line-removed">540   /* This function relies heavily on halant glyphs.  Lots of ligation</span>
<span class="line-removed">541    * and possibly multiple substitutions happened prior to this</span>
<span class="line-removed">542    * phase, and that might have messed up our properties.  Recover</span>
<span class="line-removed">543    * from a particular case of that where we&#39;re fairly sure that a</span>
<span class="line-removed">544    * class of OT_Coeng is desired but has been lost. */</span>
<span class="line-removed">545   if (khmer_plan-&gt;virama_glyph)</span>
<span class="line-removed">546   {</span>
<span class="line-removed">547     unsigned int virama_glyph = khmer_plan-&gt;virama_glyph;</span>
<span class="line-removed">548     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">549       if (info[i].codepoint == virama_glyph &amp;&amp;</span>
<span class="line-removed">550           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">551           _hb_glyph_info_multiplied (&amp;info[i]))</span>
<span class="line-removed">552       {</span>
<span class="line-removed">553         /* This will make sure that this glyph passes is_coeng() test. */</span>
<span class="line-removed">554         info[i].khmer_category() = OT_Coeng;</span>
<span class="line-removed">555         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);</span>
<span class="line-removed">556       }</span>
<span class="line-removed">557   }</span>
<span class="line-removed">558 </span>
<span class="line-removed">559 </span>
<span class="line-removed">560   /* 4. Final reordering:</span>
<span class="line-removed">561    *</span>
<span class="line-removed">562    * After the localized forms and basic shaping forms GSUB features have been</span>
<span class="line-removed">563    * applied (see below), the shaping engine performs some final glyph</span>
<span class="line-removed">564    * reordering before applying all the remaining font features to the entire</span>
<span class="line-removed">565    * syllable.</span>
<span class="line-removed">566    */</span>
<span class="line-removed">567 </span>
<span class="line-removed">568   bool try_pref = !!khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-removed">569 </span>
<span class="line-removed">570   /* Find base again */</span>
<span class="line-removed">571   unsigned int base;</span>
<span class="line-removed">572   for (base = start; base &lt; end; base++)</span>
<span class="line-removed">573     if (info[base].khmer_position() &gt;= POS_BASE_C)</span>
<span class="line-removed">574     {</span>
<span class="line-removed">575       if (try_pref &amp;&amp; base + 1 &lt; end)</span>
<span class="line-removed">576       {</span>
<span class="line-removed">577         for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">578           if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">579           {</span>
<span class="line-removed">580             if (!(_hb_glyph_info_substituted (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">581                   _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i])))</span>
<span class="line-removed">582             {</span>
<span class="line-removed">583               /* Ok, this was a &#39;pref&#39; candidate but didn&#39;t form any.</span>
<span class="line-removed">584                * Base is around here... */</span>
<span class="line-removed">585               base = i;</span>
<span class="line-removed">586               while (base &lt; end &amp;&amp; is_coeng (info[base]))</span>
<span class="line-removed">587                 base++;</span>
<span class="line-removed">588               info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">589 </span>
<span class="line-removed">590               try_pref = false;</span>
<span class="line-removed">591             }</span>
<span class="line-removed">592             break;</span>
<span class="line-removed">593           }</span>
<span class="line-removed">594       }</span>
<span class="line-removed">595 </span>
<span class="line-removed">596       if (start &lt; base &amp;&amp; info[base].khmer_position() &gt; POS_BASE_C)</span>
<span class="line-removed">597         base--;</span>
<span class="line-removed">598       break;</span>
<span class="line-removed">599     }</span>
<span class="line-removed">600   if (base == end &amp;&amp; start &lt; base &amp;&amp;</span>
<span class="line-removed">601       is_one_of (info[base - 1], FLAG (OT_ZWJ)))</span>
<span class="line-removed">602     base--;</span>
<span class="line-removed">603   if (base &lt; end)</span>
<span class="line-removed">604     while (start &lt; base &amp;&amp;</span>
<span class="line-removed">605            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_Coeng))))</span>
<span class="line-removed">606       base--;</span>
<span class="line-removed">607 </span>
<span class="line-removed">608 </span>
<span class="line-removed">609   /*   o Reorder matras:</span>
<span class="line-removed">610    *</span>
<span class="line-removed">611    *     If a pre-base matra character had been reordered before applying basic</span>
<span class="line-removed">612    *     features, the glyph can be moved closer to the main consonant based on</span>
<span class="line-removed">613    *     whether half-forms had been formed. Actual position for the matra is</span>
<span class="line-removed">614    *     defined as “after last standalone halant glyph, after initial matra</span>
<span class="line-removed">615    *     position and before the main consonant”. If ZWJ or ZWNJ follow this</span>
<span class="line-removed">616    *     halant, position is moved after it.</span>
<span class="line-removed">617    */</span>
<span class="line-removed">618 </span>
<span class="line-removed">619   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */</span>
<span class="line-removed">620   {</span>
<span class="line-removed">621     /* If we lost track of base, alas, position before last thingy. */</span>
<span class="line-removed">622     unsigned int new_pos = base == end ? base - 2 : base - 1;</span>
<span class="line-removed">623 </span>
<span class="line-removed">624     while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">625            !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_Coeng)))))</span>
<span class="line-removed">626       new_pos--;</span>
<span class="line-removed">627 </span>
<span class="line-removed">628     /* If we found no Halant we are done.</span>
<span class="line-removed">629      * Otherwise only proceed if the Halant does</span>
<span class="line-removed">630      * not belong to the Matra itself! */</span>
<span class="line-removed">631     if (is_coeng (info[new_pos]) &amp;&amp;</span>
<span class="line-removed">632         info[new_pos].khmer_position() != POS_PRE_M)</span>
<span class="line-removed">633     {</span>
<span class="line-removed">634       /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">635       if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))</span>
<span class="line-removed">636         new_pos++;</span>
<span class="line-removed">637     }</span>
<span class="line-removed">638     else</span>
<span class="line-removed">639       new_pos = start; /* No move. */</span>
<span class="line-removed">640 </span>
<span class="line-removed">641     if (start &lt; new_pos &amp;&amp; info[new_pos].khmer_position () != POS_PRE_M)</span>
<span class="line-removed">642     {</span>
<span class="line-removed">643       /* Now go see if there&#39;s actually any matras... */</span>
<span class="line-removed">644       for (unsigned int i = new_pos; i &gt; start; i--)</span>
<span class="line-removed">645         if (info[i - 1].khmer_position () == POS_PRE_M)</span>
<span class="line-removed">646         {</span>
<span class="line-removed">647           unsigned int old_pos = i - 1;</span>
<span class="line-removed">648           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */</span>
<span class="line-removed">649             base--;</span>
<span class="line-removed">650 </span>
<span class="line-removed">651           hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">652           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));</span>
<span class="line-removed">653           info[new_pos] = tmp;</span>
<span class="line-removed">654 </span>
<span class="line-removed">655           /* Note: this merge_clusters() is intentionally *after* the reordering.</span>
<span class="line-removed">656            * Indic matra reordering is special and tricky... */</span>
<span class="line-removed">657           buffer-&gt;merge_clusters (new_pos, MIN (end, base + 1));</span>
<span class="line-removed">658 </span>
<span class="line-removed">659           new_pos--;</span>
<span class="line-removed">660         }</span>
<span class="line-removed">661     } else {</span>
<span class="line-removed">662       for (unsigned int i = start; i &lt; base; i++)</span>
<span class="line-removed">663         if (info[i].khmer_position () == POS_PRE_M) {</span>
<span class="line-removed">664           buffer-&gt;merge_clusters (i, MIN (end, base + 1));</span>
<span class="line-removed">665           break;</span>
<span class="line-removed">666         }</span>
<span class="line-removed">667     }</span>
<span class="line-removed">668   }</span>
<span class="line-removed">669 </span>
<span class="line-removed">670 </span>
<span class="line-removed">671   /*   o Reorder pre-base-reordering consonants:</span>
<span class="line-removed">672    *</span>
<span class="line-removed">673    *     If a pre-base-reordering consonant is found, reorder it according to</span>
<span class="line-removed">674    *     the following rules:</span>
<span class="line-removed">675    */</span>
<span class="line-removed">676 </span>
<span class="line-removed">677   if (try_pref &amp;&amp; base + 1 &lt; end) /* Otherwise there can&#39;t be any pre-base-reordering Ra. */</span>
<span class="line-removed">678   {</span>
<span class="line-removed">679     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">680       if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">681       {</span>
<span class="line-removed">682         /*       1. Only reorder a glyph produced by substitution during application</span>
<span class="line-removed">683          *          of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with</span>
<span class="line-removed">684          *          the feature generally but block it in certain contexts.)</span>
<span class="line-removed">685          */</span>
<span class="line-removed">686         /* Note: We just check that something got substituted.  We don&#39;t check that</span>
<span class="line-removed">687          * the &lt;pref&gt; feature actually did it...</span>
<span class="line-removed">688          *</span>
<span class="line-removed">689          * Reorder pref only if it ligated. */</span>
<span class="line-removed">690         if (_hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i]))</span>
<span class="line-removed">691         {</span>
<span class="line-removed">692           /*</span>
<span class="line-removed">693            *       2. Try to find a target position the same way as for pre-base matra.</span>
<span class="line-removed">694            *          If it is found, reorder pre-base consonant glyph.</span>
<span class="line-removed">695            *</span>
<span class="line-removed">696            *       3. If position is not found, reorder immediately before main</span>
<span class="line-removed">697            *          consonant.</span>
<span class="line-removed">698            */</span>
<span class="line-removed">699 </span>
<span class="line-removed">700           unsigned int new_pos = base;</span>
<span class="line-removed">701           while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">702                  !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_Coeng))))</span>
<span class="line-removed">703             new_pos--;</span>
<span class="line-removed">704 </span>
<span class="line-removed">705           /* In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a</span>
<span class="line-removed">706            * split matra, it should be reordered to *before* the left part of such matra. */</span>
<span class="line-removed">707           if (new_pos &gt; start &amp;&amp; info[new_pos - 1].khmer_category() == OT_M)</span>
<span class="line-removed">708           {</span>
<span class="line-removed">709             unsigned int old_pos = i;</span>
<span class="line-removed">710             for (unsigned int j = base + 1; j &lt; old_pos; j++)</span>
<span class="line-removed">711               if (info[j].khmer_category() == OT_M)</span>
<span class="line-removed">712               {</span>
<span class="line-removed">713                 new_pos--;</span>
<span class="line-removed">714                 break;</span>
<span class="line-removed">715               }</span>
<span class="line-removed">716           }</span>
<span class="line-removed">717 </span>
<span class="line-removed">718           if (new_pos &gt; start &amp;&amp; is_coeng (info[new_pos - 1]))</span>
<span class="line-removed">719           {</span>
<span class="line-removed">720             /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">721             if (new_pos &lt; end &amp;&amp; is_joiner (info[new_pos]))</span>
<span class="line-removed">722               new_pos++;</span>
<span class="line-removed">723           }</span>
<span class="line-removed">724 </span>
<span class="line-removed">725           {</span>
<span class="line-removed">726             unsigned int old_pos = i;</span>
<span class="line-removed">727 </span>
<span class="line-removed">728             buffer-&gt;merge_clusters (new_pos, old_pos + 1);</span>
<span class="line-removed">729             hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">730             memmove (&amp;info[new_pos + 1], &amp;info[new_pos], (old_pos - new_pos) * sizeof (info[0]));</span>
<span class="line-removed">731             info[new_pos] = tmp;</span>
<span class="line-removed">732 </span>
<span class="line-removed">733             if (new_pos &lt;= base &amp;&amp; base &lt; old_pos)</span>
<span class="line-removed">734               base++;</span>
<span class="line-removed">735           }</span>
<span class="line-removed">736         }</span>
<span class="line-removed">737 </span>
<span class="line-removed">738         break;</span>
<span class="line-removed">739       }</span>
<span class="line-removed">740   }</span>
<span class="line-removed">741 </span>
<span class="line-removed">742 </span>
<span class="line-removed">743   /*</span>
<span class="line-removed">744    * Finish off the clusters and go home!</span>
<span class="line-removed">745    */</span>
<span class="line-removed">746   if (hb_options ().uniscribe_bug_compatible)</span>
<span class="line-removed">747   {</span>
<span class="line-removed">748     /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.</span>
<span class="line-removed">749      * This means, half forms are submerged into the main consonant&#39;s cluster.</span>
<span class="line-removed">750      * This is unnecessary, and makes cursor positioning harder, but that&#39;s what</span>
<span class="line-removed">751      * Uniscribe does. */</span>
<span class="line-removed">752     buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">753   }</span>
<span class="line-removed">754 }</span>
<span class="line-removed">755 </span>
<span class="line-removed">756 </span>
<span class="line-removed">757 static void</span>
<span class="line-removed">758 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">759                   hb_font_t *font HB_UNUSED,</span>
<span class="line-removed">760                   hb_buffer_t *buffer)</span>
<span class="line-removed">761 {</span>
<span class="line-removed">762   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">763   if (unlikely (!count)) return;</span>
<span class="line-removed">764 </span>
<span class="line-removed">765   foreach_syllable (buffer, start, end)</span>
<span class="line-removed">766     final_reordering_syllable (plan, buffer, start, end);</span>
767 
768   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);
<span class="line-removed">769   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_position);</span>
770 }
771 
<span class="line-removed">772 </span>
773 static void
774 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
775                  hb_font_t *font HB_UNUSED,
776                  hb_buffer_t *buffer)
777 {
778   hb_glyph_info_t *info = buffer-&gt;info;
779   unsigned int count = buffer-&gt;len;
780   for (unsigned int i = 0; i &lt; count; i++)
781     info[i].syllable() = 0;
782 }
783 
784 
785 static bool
786 decompose_khmer (const hb_ot_shape_normalize_context_t *c,
787                  hb_codepoint_t  ab,
788                  hb_codepoint_t *a,
789                  hb_codepoint_t *b)
790 {
791   switch (ab)
792   {
</pre>
<hr />
<pre>
814   /* Avoid recomposing split matras. */
815   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
816     return false;
817 
818   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
819 }
820 
821 
822 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =
823 {
824   collect_features_khmer,
825   override_features_khmer,
826   data_create_khmer,
827   data_destroy_khmer,
828   nullptr, /* preprocess_text */
829   nullptr, /* postprocess_glyphs */
830   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
831   decompose_khmer,
832   compose_khmer,
833   setup_masks_khmer,
<span class="line-modified">834   nullptr, /* disable_otl */</span>
835   nullptr, /* reorder_marks */
836   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
837   false, /* fallback_position */
838 };
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-khmer.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-layout.hh&quot;</span>
 29 
 30 
 31 /*
 32  * Khmer shaper.
 33  */
 34 
<span class="line-modified"> 35 static const hb_ot_map_feature_t</span>





 36 khmer_features[] =
 37 {
 38   /*
 39    * Basic features.
<span class="line-modified"> 40    * These features are applied in order, one at a time, after reordering.</span>
 41    */
<span class="line-modified"> 42   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 43   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 44   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 45   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 46   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_MANUAL_JOINERS},</span>
 47   /*
 48    * Other features.
<span class="line-modified"> 49    * These features are applied all at once after clearing syllables.</span>
<span class="line-modified"> 50    */</span>
<span class="line-modified"> 51   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 52   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 53   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 54   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 55   /*</span>
<span class="line-added"> 56    * Positioning features.</span>
<span class="line-added"> 57    * We don&#39;t care about the types.</span>
 58    */





 59   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 60   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 61   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 62 };
 63 
 64 /*
 65  * Must be in the same order as the khmer_features array.
 66  */
 67 enum {
 68   PREF,
 69   BLWF,
 70   ABVF,
 71   PSTF,
 72   CFAR,
 73 
 74   _PRES,
 75   _ABVS,
 76   _BLWS,
 77   _PSTS,
<span class="line-added"> 78 </span>
 79   _DIST,
 80   _ABVM,
 81   _BLWM,
 82 
 83   KHMER_NUM_FEATURES,
<span class="line-modified"> 84   KHMER_BASIC_FEATURES = _PRES, /* Don&#39;t forget to update this! */</span>
 85 };
 86 
 87 static void
 88 setup_syllables (const hb_ot_shape_plan_t *plan,
 89                  hb_font_t *font,
 90                  hb_buffer_t *buffer);
 91 static void
<span class="line-modified"> 92 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 93          hb_font_t *font,</span>
<span class="line-modified"> 94          hb_buffer_t *buffer);</span>




 95 static void
 96 clear_syllables (const hb_ot_shape_plan_t *plan,
 97                  hb_font_t *font,
 98                  hb_buffer_t *buffer);
 99 
100 static void
101 collect_features_khmer (hb_ot_shape_planner_t *plan)
102 {
103   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
104 
105   /* Do this before any lookups have been applied. */
106   map-&gt;add_gsub_pause (setup_syllables);
<span class="line-added">107   map-&gt;add_gsub_pause (reorder);</span>
108 
<span class="line-modified">109   /* Testing suggests that Uniscribe does NOT pause between basic</span>
<span class="line-modified">110    * features.  Test with KhmerUI.ttf and the following three</span>
<span class="line-modified">111    * sequences:</span>
<span class="line-modified">112    *</span>
<span class="line-modified">113    *   U+1789,U+17BC</span>
<span class="line-added">114    *   U+1789,U+17D2,U+1789</span>
<span class="line-added">115    *   U+1789,U+17D2,U+1789,U+17BC</span>
<span class="line-added">116    *</span>
<span class="line-added">117    * https://github.com/harfbuzz/harfbuzz/issues/974</span>
<span class="line-added">118    */</span>
<span class="line-added">119   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-added">120   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
121 
122   unsigned int i = 0;
<span class="line-modified">123   for (; i &lt; KHMER_BASIC_FEATURES; i++)</span>
<span class="line-modified">124     map-&gt;add_feature (khmer_features[i]);</span>










125 
126   map-&gt;add_gsub_pause (clear_syllables);
<span class="line-added">127 </span>
<span class="line-added">128   for (; i &lt; KHMER_NUM_FEATURES; i++)</span>
<span class="line-added">129     map-&gt;add_feature (khmer_features[i]);</span>
130 }
131 
132 static void
133 override_features_khmer (hb_ot_shape_planner_t *plan)
134 {
<span class="line-added">135   hb_ot_map_builder_t *map = &amp;plan-&gt;map;</span>
<span class="line-added">136 </span>
<span class="line-added">137   /* Khmer spec has &#39;clig&#39; as part of required shaping features:</span>
<span class="line-added">138    * &quot;Apply feature &#39;clig&#39; to form ligatures that are desired for</span>
<span class="line-added">139    * typographical correctness.&quot;, hence in overrides... */</span>
<span class="line-added">140   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
<span class="line-added">141 </span>
142   /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
143   if (hb_options ().uniscribe_bug_compatible)
144   {
<span class="line-modified">145     map-&gt;disable_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;));</span>
146   }
147 
<span class="line-modified">148   map-&gt;disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
149 }
150 
151 
152 struct would_substitute_feature_t
153 {
<span class="line-modified">154   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
155   {
156     zero_context = zero_context_;
157     map-&gt;get_stage_lookups (0/*GSUB*/,
158                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
159                             &amp;lookups, &amp;count);
160   }
161 
<span class="line-modified">162   bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">163                          unsigned int          glyphs_count,</span>
<span class="line-modified">164                          hb_face_t            *face) const</span>
165   {
166     for (unsigned int i = 0; i &lt; count; i++)
167       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
168         return true;
169     return false;
170   }
171 
172   private:
173   const hb_ot_map_t::lookup_map_t *lookups;
174   unsigned int count;
175   bool zero_context;
176 };
177 
178 struct khmer_shape_plan_t
179 {
<span class="line-modified">180   bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>


181   {
182     hb_codepoint_t glyph = virama_glyph;
183     if (unlikely (virama_glyph == (hb_codepoint_t) -1))
184     {
185       if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
186         glyph = 0;
187       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
188        * Maybe one day... */
189 
190       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
191        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */
192       virama_glyph = glyph;
193     }
194 
195     *pglyph = glyph;
196     return glyph != 0;
197   }
198 
199   mutable hb_codepoint_t virama_glyph;
200 
</pre>
<hr />
<pre>
225 data_destroy_khmer (void *data)
226 {
227   free (data);
228 }
229 
230 
231 enum syllable_type_t {
232   consonant_syllable,
233   broken_cluster,
234   non_khmer_cluster,
235 };
236 
237 #include &quot;hb-ot-shape-complex-khmer-machine.hh&quot;
238 
239 static void
240 setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,
241                    hb_buffer_t              *buffer,
242                    hb_font_t                *font HB_UNUSED)
243 {
244   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);

245 
246   /* We cannot setup masks here.  We save information about characters
247    * and setup masks later on in a pause-callback. */
248 
249   unsigned int count = buffer-&gt;len;
250   hb_glyph_info_t *info = buffer-&gt;info;
251   for (unsigned int i = 0; i &lt; count; i++)
252     set_khmer_properties (info[i]);
253 }
254 
255 static void
256 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
257                  hb_font_t *font HB_UNUSED,
258                  hb_buffer_t *buffer)
259 {
260   find_syllables (buffer);
261   foreach_syllable (buffer, start, end)
262     buffer-&gt;unsafe_to_break (start, end);
263 }
264 









265 
266 /* Rules from:
267  * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
268 
269 static void
<span class="line-modified">270 reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">271                             hb_face_t *face HB_UNUSED,</span>
<span class="line-modified">272                             hb_buffer_t *buffer,</span>
<span class="line-modified">273                             unsigned int start, unsigned int end)</span>
274 {
275   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
276   hb_glyph_info_t *info = buffer-&gt;info;
277 
<span class="line-modified">278   /* Setup masks. */</span>




































































279   {














































280     /* Post-base */
<span class="line-modified">281     hb_mask_t mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">282     for (unsigned int i = start + 1; i &lt; end; i++)</span>
283       info[i].mask  |= mask;
284   }
285 
<span class="line-modified">286   unsigned int num_coengs = 0;</span>
<span class="line-modified">287   for (unsigned int i = start + 1; i &lt; end; i++)</span>
288   {
<span class="line-modified">289     /* &quot;&quot;&quot;</span>
<span class="line-modified">290      * When a COENG + (Cons | IndV) combination are found (and subscript count</span>
<span class="line-modified">291      * is less than two) the character combination is handled according to the</span>
<span class="line-modified">292      * subscript type of the character following the COENG.</span>
<span class="line-modified">293      *</span>
<span class="line-modified">294      * ...</span>
<span class="line-added">295      *</span>
<span class="line-added">296      * Subscript Type 2 - The COENG + RO characters are reordered to immediately</span>
<span class="line-added">297      * before the base glyph. Then the COENG + RO characters are assigned to have</span>
<span class="line-added">298      * the &#39;pref&#39; OpenType feature applied to them.</span>
<span class="line-added">299      * &quot;&quot;&quot;</span>
<span class="line-added">300      */</span>
<span class="line-added">301     if (info[i].khmer_category() == OT_Coeng &amp;&amp; num_coengs &lt;= 2 &amp;&amp; i + 1 &lt; end)</span>
<span class="line-added">302     {</span>
<span class="line-added">303       num_coengs++;</span>
<span class="line-added">304 </span>
<span class="line-added">305       if (info[i + 1].khmer_category() == OT_Ra)</span>
306       {
<span class="line-modified">307         for (unsigned int j = 0; j &lt; 2; j++)</span>
<span class="line-modified">308           info[i + j].mask |= khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-added">309 </span>
<span class="line-added">310         /* Move the Coeng,Ro sequence to the start. */</span>
<span class="line-added">311         buffer-&gt;merge_clusters (start, i + 2);</span>
<span class="line-added">312         hb_glyph_info_t t0 = info[i];</span>
<span class="line-added">313         hb_glyph_info_t t1 = info[i + 1];</span>
<span class="line-added">314         memmove (&amp;info[start + 2], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">315         info[start] = t0;</span>
<span class="line-added">316         info[start + 1] = t1;</span>
317 
318         /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
319          * Read the feature spec.
320          * This allows distinguishing the following cases with MS Khmer fonts:
321          * U+1784,U+17D2,U+179A,U+17D2,U+1782
322          * U+1784,U+17D2,U+1782,U+17D2,U+179A
323          */
324         if (khmer_plan-&gt;mask_array[CFAR])
<span class="line-modified">325           for (unsigned int j = i + 2; j &lt; end; j++)</span>
<span class="line-modified">326             info[j].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
327 
<span class="line-modified">328         num_coengs = 2; /* Done. */</span>
329       }
330     }
<span class="line-added">331 </span>
<span class="line-added">332     /* Reorder left matra piece. */</span>
<span class="line-added">333     else if (info[i].khmer_category() == OT_VPre)</span>
<span class="line-added">334     {</span>
<span class="line-added">335       /* Move to the start. */</span>
<span class="line-added">336       buffer-&gt;merge_clusters (start, i + 1);</span>
<span class="line-added">337       hb_glyph_info_t t = info[i];</span>
<span class="line-added">338       memmove (&amp;info[start + 1], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">339       info[start] = t;</span>
<span class="line-added">340     }</span>
341   }
342 }
343 
344 static void
345 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
346                              hb_face_t *face,
347                              hb_buffer_t *buffer,
348                              unsigned int start, unsigned int end)
349 {
350   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
351   switch (syllable_type)
352   {
353     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
354     case consonant_syllable:
<span class="line-modified">355      reorder_consonant_syllable (plan, face, buffer, start, end);</span>
356      break;
357 
358     case non_khmer_cluster:
359       break;
360   }
361 }
362 
363 static inline void
364 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
365                        hb_font_t *font,
366                        hb_buffer_t *buffer)
367 {
368   /* Note: This loop is extra overhead, but should not be measurable. */
369   bool has_broken_syllables = false;
370   unsigned int count = buffer-&gt;len;
371   hb_glyph_info_t *info = buffer-&gt;info;
372   for (unsigned int i = 0; i &lt; count; i++)
373     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
374     {
375       has_broken_syllables = true;
</pre>
<hr />
<pre>
400     {
401       last_syllable = syllable;
402 
403       hb_glyph_info_t ginfo = dottedcircle;
404       ginfo.cluster = buffer-&gt;cur().cluster;
405       ginfo.mask = buffer-&gt;cur().mask;
406       ginfo.syllable() = buffer-&gt;cur().syllable();
407       /* TODO Set glyph_props? */
408 
409       /* Insert dottedcircle after possible Repha. */
410       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
411              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
412              buffer-&gt;cur().khmer_category() == OT_Repha)
413         buffer-&gt;next_glyph ();
414 
415       buffer-&gt;output_info (ginfo);
416     }
417     else
418       buffer-&gt;next_glyph ();
419   }

420   buffer-&gt;swap_buffers ();
421 }
422 
423 static void
<span class="line-modified">424 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">425          hb_font_t *font,</span>
<span class="line-modified">426          hb_buffer_t *buffer)</span>
427 {
428   insert_dotted_circles (plan, font, buffer);
429 
430   foreach_syllable (buffer, start, end)
431     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);














































































































































































































































432 
433   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);

434 }
435 

436 static void
437 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
438                  hb_font_t *font HB_UNUSED,
439                  hb_buffer_t *buffer)
440 {
441   hb_glyph_info_t *info = buffer-&gt;info;
442   unsigned int count = buffer-&gt;len;
443   for (unsigned int i = 0; i &lt; count; i++)
444     info[i].syllable() = 0;
445 }
446 
447 
448 static bool
449 decompose_khmer (const hb_ot_shape_normalize_context_t *c,
450                  hb_codepoint_t  ab,
451                  hb_codepoint_t *a,
452                  hb_codepoint_t *b)
453 {
454   switch (ab)
455   {
</pre>
<hr />
<pre>
477   /* Avoid recomposing split matras. */
478   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
479     return false;
480 
481   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
482 }
483 
484 
485 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =
486 {
487   collect_features_khmer,
488   override_features_khmer,
489   data_create_khmer,
490   data_destroy_khmer,
491   nullptr, /* preprocess_text */
492   nullptr, /* postprocess_glyphs */
493   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
494   decompose_khmer,
495   compose_khmer,
496   setup_masks_khmer,
<span class="line-modified">497   HB_TAG_NONE, /* gpos_tag */</span>
498   nullptr, /* reorder_marks */
499   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
500   false, /* fallback_position */
501 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-khmer-machine.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-myanmar-machine.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2009  Red Hat, Inc.
  3  * Copyright © 2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;hb-private.hh&quot;</span>






 30 
<a name="2" id="anc2"></a><span class="line-removed"> 31 #include &quot;hb-shaper-private.hh&quot;</span>
<span class="line-removed"> 32 #include &quot;hb-shape-plan-private.hh&quot;</span>
<span class="line-removed"> 33 #include &quot;hb-buffer-private.hh&quot;</span>
<span class="line-removed"> 34 #include &quot;hb-font-private.hh&quot;</span>
 35 
 36 /**
 37  * SECTION:hb-shape
<a name="3" id="anc3"></a><span class="line-modified"> 38  * @title: Shaping</span>
 39  * @short_description: Conversion of text strings into positioned glyphs
 40  * @include: hb.h
 41  *
 42  * Shaping is the central operation of HarfBuzz. Shaping operates on buffers,
 43  * which are sequences of Unicode characters that use the same font and have
<a name="4" id="anc4"></a><span class="line-modified"> 44  * the same text direction, script and language. After shaping the buffer</span>
 45  * contains the output glyphs and their positions.
 46  **/
 47 
<a name="5" id="anc5"></a><span class="line-removed"> 48 static const char **static_shaper_list;</span>
 49 
<a name="6" id="anc6"></a><span class="line-modified"> 50 #ifdef HB_USE_ATEXIT</span>
<span class="line-modified"> 51 static</span>
<span class="line-modified"> 52 void free_static_shaper_list (void)</span>





 53 {
<a name="7" id="anc7"></a><span class="line-modified"> 54 retry:</span>
<span class="line-modified"> 55   const char **shaper_list = (const char **) hb_atomic_ptr_get (&amp;static_shaper_list);</span>
<span class="line-modified"> 56   if (!hb_atomic_ptr_cmpexch (&amp;static_shaper_list, shaper_list, nullptr))</span>
<span class="line-modified"> 57     goto retry;</span>



















 58 
<a name="8" id="anc8"></a><span class="line-modified"> 59   free (shaper_list);</span>




 60 }
 61 #endif
 62 
<a name="9" id="anc9"></a>
 63 /**
 64  * hb_shape_list_shapers:
 65  *
 66  * Retrieves the list of shapers supported by HarfBuzz.
 67  *
 68  * Return value: (transfer none) (array zero-terminated=1): an array of
 69  *    constant strings
 70  *
 71  * Since: 0.9.2
 72  **/
 73 const char **
<a name="10" id="anc10"></a><span class="line-modified"> 74 hb_shape_list_shapers (void)</span>
 75 {
<a name="11" id="anc11"></a><span class="line-modified"> 76 retry:</span>
<span class="line-removed"> 77   const char **shaper_list = (const char **) hb_atomic_ptr_get (&amp;static_shaper_list);</span>
<span class="line-removed"> 78 </span>
<span class="line-removed"> 79   if (unlikely (!shaper_list))</span>
<span class="line-removed"> 80   {</span>
<span class="line-removed"> 81     /* Not found; allocate one. */</span>
<span class="line-removed"> 82     shaper_list = (const char **) calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));</span>
<span class="line-removed"> 83     if (unlikely (!shaper_list)) {</span>
<span class="line-removed"> 84       static const char *nil_shaper_list[] = {nullptr};</span>
<span class="line-removed"> 85       return nil_shaper_list;</span>
<span class="line-removed"> 86     }</span>
<span class="line-removed"> 87 </span>
<span class="line-removed"> 88     const hb_shaper_pair_t *shapers = _hb_shapers_get ();</span>
<span class="line-removed"> 89     unsigned int i;</span>
<span class="line-removed"> 90     for (i = 0; i &lt; HB_SHAPERS_COUNT; i++)</span>
<span class="line-removed"> 91       shaper_list[i] = shapers[i].name;</span>
<span class="line-removed"> 92     shaper_list[i] = nullptr;</span>
<span class="line-removed"> 93 </span>
<span class="line-removed"> 94     if (!hb_atomic_ptr_cmpexch (&amp;static_shaper_list, nullptr, shaper_list)) {</span>
<span class="line-removed"> 95       free (shaper_list);</span>
<span class="line-removed"> 96       goto retry;</span>
<span class="line-removed"> 97     }</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99 #ifdef HB_USE_ATEXIT</span>
<span class="line-removed">100     atexit (free_static_shaper_list); /* First person registers atexit() callback. */</span>
<span class="line-removed">101 #endif</span>
<span class="line-removed">102   }</span>
<span class="line-removed">103 </span>
<span class="line-removed">104   return shaper_list;</span>
105 }
106 
107 
108 /**
109  * hb_shape_full:
110  * @font: an #hb_font_t to use for shaping
111  * @buffer: an #hb_buffer_t to shape
112  * @features: (array length=num_features) (allow-none): an array of user
113  *    specified #hb_feature_t or %NULL
114  * @num_features: the length of @features array
115  * @shaper_list: (array zero-terminated=1) (allow-none): a %NULL-terminated
116  *    array of shapers to use or %NULL
117  *
118  * See hb_shape() for details. If @shaper_list is not %NULL, the specified
119  * shapers will be used in the given order, otherwise the default shapers list
120  * will be used.
121  *
122  * Return value: false if all shapers failed, true otherwise
123  *
124  * Since: 0.9.2
125  **/
126 hb_bool_t
127 hb_shape_full (hb_font_t          *font,
128                hb_buffer_t        *buffer,
129                const hb_feature_t *features,
130                unsigned int        num_features,
131                const char * const *shaper_list)
132 {
133   hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached2 (font-&gt;face, &amp;buffer-&gt;props,
134                                                               features, num_features,
135                                                               font-&gt;coords, font-&gt;num_coords,
136                                                               shaper_list);
137   hb_bool_t res = hb_shape_plan_execute (shape_plan, font, buffer, features, num_features);
138   hb_shape_plan_destroy (shape_plan);
139 
140   if (res)
141     buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
142   return res;
143 }
144 
145 /**
146  * hb_shape:
147  * @font: an #hb_font_t to use for shaping
148  * @buffer: an #hb_buffer_t to shape
149  * @features: (array length=num_features) (allow-none): an array of user
150  *    specified #hb_feature_t or %NULL
151  * @num_features: the length of @features array
152  *
153  * Shapes @buffer using @font turning its Unicode characters content to
154  * positioned glyphs. If @features is not %NULL, it will be used to control the
155  * features applied during shaping.
156  *
157  * Since: 0.9.2
158  **/
159 void
160 hb_shape (hb_font_t           *font,
161           hb_buffer_t         *buffer,
162           const hb_feature_t  *features,
163           unsigned int         num_features)
164 {
165   hb_shape_full (font, buffer, features, num_features, nullptr);
166 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-private.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2007,2008,2009  Red Hat, Inc.
  3  * Copyright © 2012,2013  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_PRIVATE_HH
 30 #define HB_OT_LAYOUT_PRIVATE_HH
 31 
 32 #include &quot;hb-private.hh&quot;
 33 
 34 #include &quot;hb-font-private.hh&quot;
 35 #include &quot;hb-buffer-private.hh&quot;
 36 #include &quot;hb-set-digest-private.hh&quot;
 37 #include &quot;hb-open-type-private.hh&quot;
 38 
 39 
 40 /* Private API corresponding to hb-ot-layout.h: */
 41 
 42 HB_INTERNAL hb_bool_t
 43 hb_ot_layout_table_find_feature (hb_face_t    *face,
 44                                  hb_tag_t      table_tag,
 45                                  hb_tag_t      feature_tag,
 46                                  unsigned int *feature_index);
 47 
 48 
 49 /*
 50  * GDEF
 51  */
 52 
 53 enum hb_ot_layout_glyph_props_flags_t
 54 {
 55   /* The following three match LookupFlags::Ignore* numbers. */
 56   HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH   = 0x02u,
 57   HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE     = 0x04u,
 58   HB_OT_LAYOUT_GLYPH_PROPS_MARK         = 0x08u,
 59 
 60   /* The following are used internally; not derived from GDEF. */
 61   HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED  = 0x10u,
 62   HB_OT_LAYOUT_GLYPH_PROPS_LIGATED      = 0x20u,
 63   HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED   = 0x40u,
 64 
 65   HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE     = HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED |
 66                                           HB_OT_LAYOUT_GLYPH_PROPS_LIGATED |
 67                                           HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED
 68 };
 69 HB_MARK_AS_FLAG_T (hb_ot_layout_glyph_props_flags_t);
 70 
 71 
 72 /*
 73  * GSUB/GPOS
 74  */
 75 
 76 HB_INTERNAL hb_bool_t
 77 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 78                                            unsigned int          lookup_index,
 79                                            const hb_codepoint_t *glyphs,
 80                                            unsigned int          glyphs_length,
 81                                            hb_bool_t             zero_context);
 82 
 83 
 84 /* Should be called before all the substitute_lookup&#39;s are done. */
 85 HB_INTERNAL void
 86 hb_ot_layout_substitute_start (hb_font_t    *font,
 87                                hb_buffer_t  *buffer);
 88 
 89 
 90 struct hb_ot_layout_lookup_accelerator_t;
 91 
 92 namespace OT {
 93   struct hb_ot_apply_context_t;
 94   struct SubstLookup;
 95 }
 96 
 97 HB_INTERNAL void
 98 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
 99                                 const OT::SubstLookup &amp;lookup,
100                                 const hb_ot_layout_lookup_accelerator_t &amp;accel);
101 
102 
103 /* Should be called before all the position_lookup&#39;s are done. */
104 HB_INTERNAL void
105 hb_ot_layout_position_start (hb_font_t    *font,
106                              hb_buffer_t  *buffer);
107 
108 /* Should be called after all the position_lookup&#39;s are done, to fini advances. */
109 HB_INTERNAL void
110 hb_ot_layout_position_finish_advances (hb_font_t    *font,
111                                        hb_buffer_t  *buffer);
112 
113 /* Should be called after hb_ot_layout_position_finish_advances, to fini offsets. */
114 HB_INTERNAL void
115 hb_ot_layout_position_finish_offsets (hb_font_t    *font,
116                                       hb_buffer_t  *buffer);
117 
118 
119 
120 /*
121  * hb_ot_layout_t
122  */
123 
124 namespace OT {
125   struct BASE;
126   struct COLR;
127   struct CPAL;
128   struct GDEF;
129   struct GSUB;
130   struct GPOS;
131   struct MATH;
132   struct fvar;
133   struct avar;
134 }
135 
136 namespace AAT {
137   struct ankr;
138   struct kerx;
139   struct morx;
140   struct trak;
141 }
142 
143 struct hb_ot_layout_lookup_accelerator_t
144 {
145   template &lt;typename TLookup&gt;
146   inline void init (const TLookup &amp;lookup)
147   {
148     digest.init ();
149     lookup.add_coverage (&amp;digest);
150   }
151 
152   inline void fini (void)
153   {
154   }
155 
156   inline bool may_have (hb_codepoint_t g) const {
157     return digest.may_have (g);
158   }
159 
160   private:
161   hb_set_digest_t digest;
162 };
163 
164 struct hb_ot_layout_t
165 {
166   hb_blob_t *gdef_blob;
167   hb_blob_t *gsub_blob;
168   hb_blob_t *gpos_blob;
169 
170   const struct OT::GDEF *gdef;
171   const struct OT::GSUB *gsub;
172   const struct OT::GPOS *gpos;
173 
174   /* TODO Move the following out of this struct. */
175   OT::hb_table_lazy_loader_t&lt;struct OT::BASE&gt; base;
176   OT::hb_table_lazy_loader_t&lt;struct OT::MATH&gt; math;
177   OT::hb_table_lazy_loader_t&lt;struct OT::fvar&gt; fvar;
178   OT::hb_table_lazy_loader_t&lt;struct OT::avar&gt; avar;
179 
180   unsigned int gsub_lookup_count;
181   unsigned int gpos_lookup_count;
182 
183   hb_ot_layout_lookup_accelerator_t *gsub_accels;
184   hb_ot_layout_lookup_accelerator_t *gpos_accels;
185 };
186 
187 
188 HB_INTERNAL hb_ot_layout_t *
189 _hb_ot_layout_create (hb_face_t *face);
190 
191 HB_INTERNAL void
192 _hb_ot_layout_destroy (hb_ot_layout_t *layout);
193 
194 
195 #define hb_ot_layout_from_face(face) ((hb_ot_layout_t *) face-&gt;shaper_data.ot)
196 
197 
198 /*
199  * Buffer var routines.
200  */
201 
202 /* buffer var allocations, used during the entire shaping process */
203 #define unicode_props()         var2.u16[0]
204 
205 /* buffer var allocations, used during the GSUB/GPOS processing */
206 #define glyph_props()           var1.u16[0] /* GDEF glyph properties */
207 #define lig_props()             var1.u8[2] /* GSUB/GPOS ligature tracking */
208 #define syllable()              var1.u8[3] /* GSUB/GPOS shaping boundaries */
209 
210 
211 /* Loop over syllables. Based on foreach_cluster(). */
212 #define foreach_syllable(buffer, start, end) \
213   for (unsigned int \
214        _count = buffer-&gt;len, \
215        start = 0, end = _count ? _next_syllable (buffer, 0) : 0; \
216        start &lt; _count; \
217        start = end, end = _next_syllable (buffer, start))
218 
219 static inline unsigned int
220 _next_syllable (hb_buffer_t *buffer, unsigned int start)
221 {
222   hb_glyph_info_t *info = buffer-&gt;info;
223   unsigned int count = buffer-&gt;len;
224 
225   unsigned int syllable = info[start].syllable();
226   while (++start &lt; count &amp;&amp; syllable == info[start].syllable())
227     ;
228 
229   return start;
230 }
231 
232 
233 /* unicode_props */
234 
235 /* Design:
236  * unicode_props() is a two-byte number.  The low byte includes:
237  * - General_Category: 5 bits.
238  * - A bit each for:
239  *   * Is it Default_Ignorable(); we have a modified Default_Ignorable().
240  *   * Whether it&#39;s one of the three Mongolian Free Variation Selectors,
241  *     CGJ, or other characters that are hidden but should not be ignored
242  *     like most other Default_Ignorable()s do during matching.
243  *   * One free bit right now.
244  *
245  * The high-byte has different meanings, switched by the Gen-Cat:
246  * - For Mn,Mc,Me: the modified Combining_Class.
247  * - For Cf: whether it&#39;s ZWJ, ZWNJ, or something else.
248  * - For Ws: index of which space character this is, if space fallback
249  *   is needed, ie. we don&#39;t set this by default, only if asked to.
250  */
251 
252 enum hb_unicode_props_flags_t {
253   UPROPS_MASK_GEN_CAT   = 0x001Fu,
254   UPROPS_MASK_IGNORABLE = 0x0020u,
255   UPROPS_MASK_HIDDEN    = 0x0040u, /* MONGOLIAN FREE VARIATION SELECTOR 1..3,
256                                     * or TAG characters */
257 
258   /* If GEN_CAT=FORMAT, top byte masks: */
259   UPROPS_MASK_Cf_ZWJ    = 0x0100u,
260   UPROPS_MASK_Cf_ZWNJ   = 0x0200u
261 };
262 HB_MARK_AS_FLAG_T (hb_unicode_props_flags_t);
263 
264 static inline void
265 _hb_glyph_info_set_unicode_props (hb_glyph_info_t *info, hb_buffer_t *buffer)
266 {
267   hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
268   unsigned int u = info-&gt;codepoint;
269   unsigned int gen_cat = (unsigned int) unicode-&gt;general_category (u);
270   unsigned int props = gen_cat;
271 
272   if (u &gt;= 0x80)
273   {
274     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII;
275     if (unlikely (unicode-&gt;is_default_ignorable (u)))
276     {
277       buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES;
278       props |=  UPROPS_MASK_IGNORABLE;
279       if (u == 0x200Cu) props |= UPROPS_MASK_Cf_ZWNJ;
280       else if (u == 0x200Du) props |= UPROPS_MASK_Cf_ZWJ;
281       /* Mongolian Free Variation Selectors need to be remembered
282        * because although we need to hide them like default-ignorables,
283        * they need to non-ignorable during shaping.  This is similar to
284        * what we do for joiners in Indic-like shapers, but since the
285        * FVSes are GC=Mn, we have use a separate bit to remember them.
286        * Fixes:
287        * https://github.com/harfbuzz/harfbuzz/issues/234 */
288       else if (unlikely (hb_in_range (u, 0x180Bu, 0x180Du))) props |= UPROPS_MASK_HIDDEN;
289       /* TAG characters need similar treatment. Fixes:
290        * https://github.com/harfbuzz/harfbuzz/issues/463 */
291       else if (unlikely (hb_in_range (u, 0xE0020u, 0xE007Fu))) props |= UPROPS_MASK_HIDDEN;
292       /* COMBINING GRAPHEME JOINER should not be skipped; at least some times.
293        * https://github.com/harfbuzz/harfbuzz/issues/554 */
294       else if (unlikely (u == 0x034Fu))
295       {
296         buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_CGJ;
297         props |= UPROPS_MASK_HIDDEN;
298       }
299     }
300     else if (unlikely (HB_UNICODE_GENERAL_CATEGORY_IS_NON_ENCLOSING_MARK_OR_MODIFIER_SYMBOL (gen_cat)))
301     {
302       /* The above check is just an optimization to let in only things we need further
303        * processing on. */
304 
305       /* Only Mn and Mc can have non-zero ccc:
306        * https://unicode.org/policies/stability_policy.html#Property_Value
307        * &quot;&quot;&quot;
308        * Canonical_Combining_Class, General_Category
309        * All characters other than those with General_Category property values
310        * Spacing_Mark (Mc) and Nonspacing_Mark (Mn) have the Canonical_Combining_Class
311        * property value 0.
312        * 1.1.5+
313        * &quot;&quot;&quot;
314        *
315        * Also, all Mn&#39;s that are Default_Ignorable, have ccc=0, hence
316        * the &quot;else if&quot;.
317        */
318       props |= unicode-&gt;modified_combining_class (info-&gt;codepoint)&lt;&lt;8;
319 
320       /* Recategorize emoji skin-tone modifiers as Unicode mark, so they
321        * behave correctly in non-native directionality.  They originally
322        * are MODIFIER_SYMBOL.  Fixes:
323        * https://github.com/harfbuzz/harfbuzz/issues/169
324        */
325       if (unlikely (hb_in_range (u, 0x1F3FBu, 0x1F3FFu)))
326       {
327         props = gen_cat = HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK;
328       }
329     }
330   }
331 
332   info-&gt;unicode_props() = props;
333 }
334 
335 static inline void
336 _hb_glyph_info_set_general_category (hb_glyph_info_t *info,
337                                      hb_unicode_general_category_t gen_cat)
338 {
339   /* Clears top-byte. */
340   info-&gt;unicode_props() = (unsigned int) gen_cat | (info-&gt;unicode_props() &amp; (0xFF &amp; ~UPROPS_MASK_GEN_CAT));
341 }
342 
343 static inline hb_unicode_general_category_t
344 _hb_glyph_info_get_general_category (const hb_glyph_info_t *info)
345 {
346   return (hb_unicode_general_category_t) (info-&gt;unicode_props() &amp; UPROPS_MASK_GEN_CAT);
347 }
348 
349 static inline bool
350 _hb_glyph_info_is_unicode_mark (const hb_glyph_info_t *info)
351 {
352   return HB_UNICODE_GENERAL_CATEGORY_IS_MARK (info-&gt;unicode_props() &amp; UPROPS_MASK_GEN_CAT);
353 }
354 static inline void
355 _hb_glyph_info_set_modified_combining_class (hb_glyph_info_t *info,
356                                              unsigned int modified_class)
357 {
358   if (unlikely (!_hb_glyph_info_is_unicode_mark (info)))
359     return;
360   info-&gt;unicode_props() = (modified_class&lt;&lt;8) | (info-&gt;unicode_props() &amp; 0xFF);
361 }
362 static inline unsigned int
363 _hb_glyph_info_get_modified_combining_class (const hb_glyph_info_t *info)
364 {
365   return _hb_glyph_info_is_unicode_mark (info) ? info-&gt;unicode_props()&gt;&gt;8 : 0;
366 }
367 
368 
369 /* Loop over grapheme. Based on foreach_cluster(). */
370 #define foreach_grapheme(buffer, start, end) \
371   for (unsigned int \
372        _count = buffer-&gt;len, \
373        start = 0, end = _count ? _next_grapheme (buffer, 0) : 0; \
374        start &lt; _count; \
375        start = end, end = _next_grapheme (buffer, start))
376 
377 static inline unsigned int
378 _next_grapheme (hb_buffer_t *buffer, unsigned int start)
379 {
380   hb_glyph_info_t *info = buffer-&gt;info;
381   unsigned int count = buffer-&gt;len;
382 
383   while (++start &lt; count &amp;&amp; _hb_glyph_info_is_unicode_mark (&amp;info[start]))
384     ;
385 
386   return start;
387 }
388 
389 
390 #define info_cc(info) (_hb_glyph_info_get_modified_combining_class (&amp;(info)))
391 
392 static inline bool
393 _hb_glyph_info_is_unicode_space (const hb_glyph_info_t *info)
394 {
395   return _hb_glyph_info_get_general_category (info) ==
396          HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR;
397 }
398 static inline void
399 _hb_glyph_info_set_unicode_space_fallback_type (hb_glyph_info_t *info, hb_unicode_funcs_t::space_t s)
400 {
401   if (unlikely (!_hb_glyph_info_is_unicode_space (info)))
402     return;
403   info-&gt;unicode_props() = (((unsigned int) s)&lt;&lt;8) | (info-&gt;unicode_props() &amp; 0xFF);
404 }
405 static inline hb_unicode_funcs_t::space_t
406 _hb_glyph_info_get_unicode_space_fallback_type (const hb_glyph_info_t *info)
407 {
408   return _hb_glyph_info_is_unicode_space (info) ?
409          (hb_unicode_funcs_t::space_t) (info-&gt;unicode_props()&gt;&gt;8) :
410          hb_unicode_funcs_t::NOT_SPACE;
411 }
412 
413 static inline bool _hb_glyph_info_ligated (const hb_glyph_info_t *info);
414 
415 static inline hb_bool_t
416 _hb_glyph_info_is_default_ignorable (const hb_glyph_info_t *info)
417 {
418   return (info-&gt;unicode_props() &amp; UPROPS_MASK_IGNORABLE) &amp;&amp;
419          !_hb_glyph_info_ligated (info);
420 }
421 static inline hb_bool_t
422 _hb_glyph_info_is_default_ignorable_and_not_hidden (const hb_glyph_info_t *info)
423 {
424   return ((info-&gt;unicode_props() &amp; (UPROPS_MASK_IGNORABLE|UPROPS_MASK_HIDDEN))
425           == UPROPS_MASK_IGNORABLE) &amp;&amp;
426          !_hb_glyph_info_ligated (info);
427 }
428 static inline void
429 _hb_glyph_info_unhide (hb_glyph_info_t *info)
430 {
431   info-&gt;unicode_props() &amp;= ~ UPROPS_MASK_HIDDEN;
432 }
433 
434 static inline bool
435 _hb_glyph_info_is_unicode_format (const hb_glyph_info_t *info)
436 {
437   return _hb_glyph_info_get_general_category (info) ==
438          HB_UNICODE_GENERAL_CATEGORY_FORMAT;
439 }
440 static inline hb_bool_t
441 _hb_glyph_info_is_zwnj (const hb_glyph_info_t *info)
442 {
443   return _hb_glyph_info_is_unicode_format (info) &amp;&amp; (info-&gt;unicode_props() &amp; UPROPS_MASK_Cf_ZWNJ);
444 }
445 static inline hb_bool_t
446 _hb_glyph_info_is_zwj (const hb_glyph_info_t *info)
447 {
448   return _hb_glyph_info_is_unicode_format (info) &amp;&amp; (info-&gt;unicode_props() &amp; UPROPS_MASK_Cf_ZWJ);
449 }
450 static inline hb_bool_t
451 _hb_glyph_info_is_joiner (const hb_glyph_info_t *info)
452 {
453   return _hb_glyph_info_is_unicode_format (info) &amp;&amp; (info-&gt;unicode_props() &amp; (UPROPS_MASK_Cf_ZWNJ|UPROPS_MASK_Cf_ZWJ));
454 }
455 static inline void
456 _hb_glyph_info_flip_joiners (hb_glyph_info_t *info)
457 {
458   if (!_hb_glyph_info_is_unicode_format (info))
459     return;
460   info-&gt;unicode_props() ^= UPROPS_MASK_Cf_ZWNJ | UPROPS_MASK_Cf_ZWJ;
461 }
462 
463 /* lig_props: aka lig_id / lig_comp
464  *
465  * When a ligature is formed:
466  *
467  *   - The ligature glyph and any marks in between all the same newly allocated
468  *     lig_id,
469  *   - The ligature glyph will get lig_num_comps set to the number of components
470  *   - The marks get lig_comp &gt; 0, reflecting which component of the ligature
471  *     they were applied to.
472  *   - This is used in GPOS to attach marks to the right component of a ligature
473  *     in MarkLigPos,
474  *   - Note that when marks are ligated together, much of the above is skipped
475  *     and the current lig_id reused.
476  *
477  * When a multiple-substitution is done:
478  *
479  *   - All resulting glyphs will have lig_id = 0,
480  *   - The resulting glyphs will have lig_comp = 0, 1, 2, ... respectively.
481  *   - This is used in GPOS to attach marks to the first component of a
482  *     multiple substitution in MarkBasePos.
483  *
484  * The numbers are also used in GPOS to do mark-to-mark positioning only
485  * to marks that belong to the same component of the same ligature.
486  */
487 
488 static inline void
489 _hb_glyph_info_clear_lig_props (hb_glyph_info_t *info)
490 {
491   info-&gt;lig_props() = 0;
492 }
493 
494 #define IS_LIG_BASE 0x10
495 
496 static inline void
497 _hb_glyph_info_set_lig_props_for_ligature (hb_glyph_info_t *info,
498                                            unsigned int lig_id,
499                                            unsigned int lig_num_comps)
500 {
501   info-&gt;lig_props() = (lig_id &lt;&lt; 5) | IS_LIG_BASE | (lig_num_comps &amp; 0x0F);
502 }
503 
504 static inline void
505 _hb_glyph_info_set_lig_props_for_mark (hb_glyph_info_t *info,
506                                        unsigned int lig_id,
507                                        unsigned int lig_comp)
508 {
509   info-&gt;lig_props() = (lig_id &lt;&lt; 5) | (lig_comp &amp; 0x0F);
510 }
511 
512 static inline void
513 _hb_glyph_info_set_lig_props_for_component (hb_glyph_info_t *info, unsigned int comp)
514 {
515   _hb_glyph_info_set_lig_props_for_mark (info, 0, comp);
516 }
517 
518 static inline unsigned int
519 _hb_glyph_info_get_lig_id (const hb_glyph_info_t *info)
520 {
521   return info-&gt;lig_props() &gt;&gt; 5;
522 }
523 
524 static inline bool
525 _hb_glyph_info_ligated_internal (const hb_glyph_info_t *info)
526 {
527   return !!(info-&gt;lig_props() &amp; IS_LIG_BASE);
528 }
529 
530 static inline unsigned int
531 _hb_glyph_info_get_lig_comp (const hb_glyph_info_t *info)
532 {
533   if (_hb_glyph_info_ligated_internal (info))
534     return 0;
535   else
536     return info-&gt;lig_props() &amp; 0x0F;
537 }
538 
539 static inline unsigned int
540 _hb_glyph_info_get_lig_num_comps (const hb_glyph_info_t *info)
541 {
542   if ((info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE) &amp;&amp;
543       _hb_glyph_info_ligated_internal (info))
544     return info-&gt;lig_props() &amp; 0x0F;
545   else
546     return 1;
547 }
548 
549 static inline uint8_t
550 _hb_allocate_lig_id (hb_buffer_t *buffer) {
551   uint8_t lig_id = buffer-&gt;next_serial () &amp; 0x07;
552   if (unlikely (!lig_id))
553     lig_id = _hb_allocate_lig_id (buffer); /* in case of overflow */
554   return lig_id;
555 }
556 
557 /* glyph_props: */
558 
559 static inline void
560 _hb_glyph_info_set_glyph_props (hb_glyph_info_t *info, unsigned int props)
561 {
562   info-&gt;glyph_props() = props;
563 }
564 
565 static inline unsigned int
566 _hb_glyph_info_get_glyph_props (const hb_glyph_info_t *info)
567 {
568   return info-&gt;glyph_props();
569 }
570 
571 static inline bool
572 _hb_glyph_info_is_base_glyph (const hb_glyph_info_t *info)
573 {
574   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH);
575 }
576 
577 static inline bool
578 _hb_glyph_info_is_ligature (const hb_glyph_info_t *info)
579 {
580   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE);
581 }
582 
583 static inline bool
584 _hb_glyph_info_is_mark (const hb_glyph_info_t *info)
585 {
586   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_MARK);
587 }
588 
589 static inline bool
590 _hb_glyph_info_substituted (const hb_glyph_info_t *info)
591 {
592   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED);
593 }
594 
595 static inline bool
596 _hb_glyph_info_ligated (const hb_glyph_info_t *info)
597 {
598   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_LIGATED);
599 }
600 
601 static inline bool
602 _hb_glyph_info_multiplied (const hb_glyph_info_t *info)
603 {
604   return !!(info-&gt;glyph_props() &amp; HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED);
605 }
606 
607 static inline bool
608 _hb_glyph_info_ligated_and_didnt_multiply (const hb_glyph_info_t *info)
609 {
610   return _hb_glyph_info_ligated (info) &amp;&amp; !_hb_glyph_info_multiplied (info);
611 }
612 
613 static inline void
614 _hb_glyph_info_clear_ligated_and_multiplied (hb_glyph_info_t *info)
615 {
616   info-&gt;glyph_props() &amp;= ~(HB_OT_LAYOUT_GLYPH_PROPS_LIGATED |
617                            HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED);
618 }
619 
620 static inline void
621 _hb_glyph_info_clear_substituted (hb_glyph_info_t *info)
622 {
623   info-&gt;glyph_props() &amp;= ~(HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED);
624 }
625 
626 
627 /* Allocation / deallocation. */
628 
629 static inline void
630 _hb_buffer_allocate_unicode_vars (hb_buffer_t *buffer)
631 {
632   HB_BUFFER_ALLOCATE_VAR (buffer, unicode_props);
633 }
634 
635 static inline void
636 _hb_buffer_deallocate_unicode_vars (hb_buffer_t *buffer)
637 {
638   HB_BUFFER_DEALLOCATE_VAR (buffer, unicode_props);
639 }
640 
641 static inline void
642 _hb_buffer_assert_unicode_vars (hb_buffer_t *buffer)
643 {
644   HB_BUFFER_ASSERT_VAR (buffer, unicode_props);
645 }
646 
647 static inline void
648 _hb_buffer_allocate_gsubgpos_vars (hb_buffer_t *buffer)
649 {
650   HB_BUFFER_ALLOCATE_VAR (buffer, glyph_props);
651   HB_BUFFER_ALLOCATE_VAR (buffer, lig_props);
652   HB_BUFFER_ALLOCATE_VAR (buffer, syllable);
653 }
654 
655 static inline void
656 _hb_buffer_deallocate_gsubgpos_vars (hb_buffer_t *buffer)
657 {
658   HB_BUFFER_DEALLOCATE_VAR (buffer, syllable);
659   HB_BUFFER_DEALLOCATE_VAR (buffer, lig_props);
660   HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_props);
661 }
662 
663 static inline void
664 _hb_buffer_assert_gsubgpos_vars (hb_buffer_t *buffer)
665 {
666   HB_BUFFER_ASSERT_VAR (buffer, glyph_props);
667   HB_BUFFER_ASSERT_VAR (buffer, lig_props);
668   HB_BUFFER_ASSERT_VAR (buffer, syllable);
669 }
670 
671 /* Make sure no one directly touches our props... */
672 #undef unicode_props0
673 #undef unicode_props1
674 #undef lig_props
675 #undef glyph_props
676 
677 #endif /* HB_OT_LAYOUT_PRIVATE_HH */
    </pre>
  </body>
</html>
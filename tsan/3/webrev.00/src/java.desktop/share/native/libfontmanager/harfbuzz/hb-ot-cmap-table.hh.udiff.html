<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-map.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cbdt-table.hh.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,36 +25,40 @@</span>
   */
  
  #ifndef HB_OT_CMAP_TABLE_HH
  #define HB_OT_CMAP_TABLE_HH
  
<span class="udiff-line-modified-removed">- #include &quot;hb-open-type-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-set-private.hh&quot;</span>
<span class="udiff-line-removed">- #include &quot;hb-subset-plan.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-open-type.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-set.hh&quot;</span>
  
  /*
   * cmap -- Character to Glyph Index Mapping
   * https://docs.microsoft.com/en-us/typography/opentype/spec/cmap
   */
  #define HB_OT_TAG_cmap HB_TAG(&#39;c&#39;,&#39;m&#39;,&#39;a&#39;,&#39;p&#39;)
  
<span class="udiff-line-removed">- </span>
  namespace OT {
  
  
  struct CmapSubtableFormat0
  {
<span class="udiff-line-modified-removed">-   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
    {
      hb_codepoint_t gid = codepoint &lt; 256 ? glyphIdArray[codepoint] : 0;
      if (!gid)
        return false;
      *glyph = gid;
      return true;
    }
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     for (unsigned int i = 0; i &lt; 256; i++)</span>
<span class="udiff-line-added">+       if (glyphIdArray[i])</span>
<span class="udiff-line-added">+         out-&gt;add (i);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -86,27 +90,27 @@</span>
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
  
      this-&gt;format.set (4);
      this-&gt;length.set (get_sub_table_size (segments));
  
<span class="udiff-line-modified-removed">-     this-&gt;segCountX2.set (segments.len * 2);</span>
<span class="udiff-line-modified-removed">-     this-&gt;entrySelector.set (MAX (1u, _hb_bit_storage (segments.len)) - 1);</span>
<span class="udiff-line-modified-added">+     this-&gt;segCountX2.set (segments.length * 2);</span>
<span class="udiff-line-modified-added">+     this-&gt;entrySelector.set (MAX (1u, hb_bit_storage (segments.length)) - 1);</span>
      this-&gt;searchRange.set (2 * (1u &lt;&lt; this-&gt;entrySelector));
<span class="udiff-line-modified-removed">-     this-&gt;rangeShift.set (segments.len * 2 &gt; this-&gt;searchRange</span>
<span class="udiff-line-modified-removed">-                           ? 2 * segments.len - this-&gt;searchRange</span>
<span class="udiff-line-modified-added">+     this-&gt;rangeShift.set (segments.length * 2 &gt; this-&gt;searchRange</span>
<span class="udiff-line-modified-added">+                           ? 2 * segments.length - this-&gt;searchRange</span>
                            : 0);
  
<span class="udiff-line-modified-removed">-     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="udiff-line-modified-added">+     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
      c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size); // 2 bytes of padding.
<span class="udiff-line-modified-removed">-     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="udiff-line-modified-removed">-     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="udiff-line-modified-removed">-     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="udiff-line-modified-added">+     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="udiff-line-modified-added">+     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="udiff-line-modified-added">+     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
  
      if (id_range_offset == nullptr)
        return_trace (false);
  
<span class="udiff-line-modified-removed">-     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
<span class="udiff-line-modified-added">+     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
      {
        end_count[i].set (segments[i].end_code);
        start_count[i].set (segments[i].start_code);
        if (segments[i].use_delta)
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -148,14 +152,14 @@</span>
      }
  
      return_trace (true);
    }
  
<span class="udiff-line-modified-removed">-   static inline size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
<span class="udiff-line-modified-added">+   static size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
    {
      size_t segment_size = 0;
<span class="udiff-line-modified-removed">-     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
<span class="udiff-line-modified-added">+     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
      {
        // Parallel array entries
        segment_size +=
              2  // end count
            + 2  // start count
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170,12 +174,12 @@</span>
      return min_size
          + 2 // Padding
          + segment_size;
    }
  
<span class="udiff-line-modified-removed">-   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-removed">-                                             hb_vector_t&lt;segment_plan&gt; *segments)</span>
<span class="udiff-line-modified-added">+   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-added">+                                      hb_vector_t&lt;segment_plan&gt; *segments)</span>
    {
      segment_plan *segment = nullptr;
      hb_codepoint_t last_gid = 0;
  
      hb_codepoint_t cp = HB_SET_VALUE_INVALID;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -185,17 +189,15 @@</span>
        {
          DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
          return false;
        }
  
<span class="udiff-line-modified-removed">-       if (cp &gt; 0xFFFF) {</span>
<span class="udiff-line-modified-removed">-         // We are now outside of unicode BMP, stop adding to this cmap.</span>
<span class="udiff-line-removed">-         break;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+       /* Stop adding to cmap if we are now outside of unicode BMP. */</span>
<span class="udiff-line-modified-added">+       if (cp &gt; 0xFFFF) break;</span>
  
<span class="udiff-line-modified-removed">-       if (!segment</span>
<span class="udiff-line-modified-removed">-           || cp != segment-&gt;end_code + 1u)</span>
<span class="udiff-line-modified-added">+       if (!segment ||</span>
<span class="udiff-line-modified-added">+           cp != segment-&gt;end_code + 1u)</span>
        {
          segment = segments-&gt;push ();
          segment-&gt;start_code.set (cp);
          segment-&gt;end_code.set (cp);
          segment-&gt;use_delta = true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -222,33 +224,36 @@</span>
      return true;
    }
  
    struct accelerator_t
    {
<span class="udiff-line-modified-removed">-     inline void init (const CmapSubtableFormat4 *subtable)</span>
<span class="udiff-line-modified-added">+     accelerator_t () {}</span>
<span class="udiff-line-added">+     accelerator_t (const CmapSubtableFormat4 *subtable) { init (subtable); }</span>
<span class="udiff-line-added">+     ~accelerator_t () { fini (); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void init (const CmapSubtableFormat4 *subtable)</span>
      {
        segCount = subtable-&gt;segCountX2 / 2;
<span class="udiff-line-modified-removed">-       endCount = subtable-&gt;values;</span>
<span class="udiff-line-modified-added">+       endCount = subtable-&gt;values.arrayZ;</span>
        startCount = endCount + segCount + 1;
        idDelta = startCount + segCount;
        idRangeOffset = idDelta + segCount;
        glyphIdArray = idRangeOffset + segCount;
        glyphIdArrayLength = (subtable-&gt;length - 16 - 8 * segCount) / 2;
      }
<span class="udiff-line-added">+     void fini () {}</span>
  
<span class="udiff-line-modified-removed">-     static inline bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
<span class="udiff-line-modified-added">+     bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
      {
<span class="udiff-line-removed">-       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="udiff-line-removed">- </span>
        /* Custom two-array bsearch. */
<span class="udiff-line-modified-removed">-       int min = 0, max = (int) thiz-&gt;segCount - 1;</span>
<span class="udiff-line-modified-removed">-       const HBUINT16 *startCount = thiz-&gt;startCount;</span>
<span class="udiff-line-modified-removed">-       const HBUINT16 *endCount = thiz-&gt;endCount;</span>
<span class="udiff-line-modified-added">+       int min = 0, max = (int) this-&gt;segCount - 1;</span>
<span class="udiff-line-modified-added">+       const HBUINT16 *startCount = this-&gt;startCount;</span>
<span class="udiff-line-modified-added">+       const HBUINT16 *endCount = this-&gt;endCount;</span>
        unsigned int i;
        while (min &lt;= max)
        {
<span class="udiff-line-modified-removed">-         int mid = (min + max) / 2;</span>
<span class="udiff-line-modified-added">+         int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
          if (codepoint &lt; startCount[mid])
            max = mid - 1;
          else if (codepoint &gt; endCount[mid])
            min = mid + 1;
          else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -259,37 +264,59 @@</span>
        }
        return false;
  
      found:
        hb_codepoint_t gid;
<span class="udiff-line-modified-removed">-       unsigned int rangeOffset = thiz-&gt;idRangeOffset[i];</span>
<span class="udiff-line-modified-added">+       unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
        if (rangeOffset == 0)
<span class="udiff-line-modified-removed">-         gid = codepoint + thiz-&gt;idDelta[i];</span>
<span class="udiff-line-modified-added">+         gid = codepoint + this-&gt;idDelta[i];</span>
        else
        {
          /* Somebody has been smoking... */
<span class="udiff-line-modified-removed">-         unsigned int index = rangeOffset / 2 + (codepoint - thiz-&gt;startCount[i]) + i - thiz-&gt;segCount;</span>
<span class="udiff-line-modified-removed">-         if (unlikely (index &gt;= thiz-&gt;glyphIdArrayLength))</span>
<span class="udiff-line-modified-added">+         unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="udiff-line-modified-added">+         if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
            return false;
<span class="udiff-line-modified-removed">-         gid = thiz-&gt;glyphIdArray[index];</span>
<span class="udiff-line-modified-added">+         gid = this-&gt;glyphIdArray[index];</span>
          if (unlikely (!gid))
            return false;
<span class="udiff-line-modified-removed">-         gid += thiz-&gt;idDelta[i];</span>
<span class="udiff-line-modified-added">+         gid += this-&gt;idDelta[i];</span>
        }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       *glyph = gid &amp; 0xFFFFu;</span>
<span class="udiff-line-modified-added">+       gid &amp;= 0xFFFFu;</span>
<span class="udiff-line-modified-added">+       if (!gid)</span>
<span class="udiff-line-added">+         return false;</span>
<span class="udiff-line-added">+       *glyph = gid;</span>
        return true;
      }
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     static inline void get_all_codepoints_func (const void *obj, hb_set_t *out)</span>
<span class="udiff-line-modified-added">+     static bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-added">+       return ((const accelerator_t *) obj)-&gt;get_glyph (codepoint, glyph);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     void collect_unicodes (hb_set_t *out) const</span>
      {
<span class="udiff-line-modified-removed">-       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="udiff-line-modified-removed">-       for (unsigned int i = 0; i &lt; thiz-&gt;segCount; i++)</span>
<span class="udiff-line-modified-added">+       unsigned int count = this-&gt;segCount;</span>
<span class="udiff-line-modified-added">+       if (count &amp;&amp; this-&gt;startCount[count - 1] == 0xFFFFu)</span>
<span class="udiff-line-added">+         count--; /* Skip sentinel segment. */</span>
<span class="udiff-line-added">+       for (unsigned int i = 0; i &lt; count; i++)</span>
        {
<span class="udiff-line-modified-removed">-         if (thiz-&gt;startCount[i] != 0xFFFFu</span>
<span class="udiff-line-modified-removed">-             || thiz-&gt;endCount[i] != 0xFFFFu) // Skip the last segment (0xFFFF)</span>
<span class="udiff-line-modified-removed">-           hb_set_add_range (out, thiz-&gt;startCount[i], thiz-&gt;endCount[i]);</span>
<span class="udiff-line-modified-added">+         unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
<span class="udiff-line-modified-added">+         if (rangeOffset == 0)</span>
<span class="udiff-line-modified-added">+           out-&gt;add_range (this-&gt;startCount[i], this-&gt;endCount[i]);</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           for (hb_codepoint_t codepoint = this-&gt;startCount[i];</span>
<span class="udiff-line-added">+                codepoint &lt;= this-&gt;endCount[i];</span>
<span class="udiff-line-added">+                codepoint++)</span>
<span class="udiff-line-added">+           {</span>
<span class="udiff-line-added">+             unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="udiff-line-added">+             if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
<span class="udiff-line-added">+               break;</span>
<span class="udiff-line-added">+             hb_codepoint_t gid = this-&gt;glyphIdArray[index];</span>
<span class="udiff-line-added">+             if (unlikely (!gid))</span>
<span class="udiff-line-added">+               continue;</span>
<span class="udiff-line-added">+             out-&gt;add (codepoint);</span>
<span class="udiff-line-added">+           }</span>
<span class="udiff-line-added">+         }</span>
        }
      }
  
      const HBUINT16 *endCount;
      const HBUINT16 *startCount;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -298,18 +325,22 @@</span>
      const HBUINT16 *glyphIdArray;
      unsigned int segCount;
      unsigned int glyphIdArrayLength;
    };
  
<span class="udiff-line-modified-removed">-   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
    {
<span class="udiff-line-modified-removed">-     accelerator_t accel;</span>
<span class="udiff-line-removed">-     accel.init (this);</span>
<span class="udiff-line-modified-added">+     accelerator_t accel (this);</span>
      return accel.get_glyph_func (&amp;accel, codepoint, glyph);
    }
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     accelerator_t accel (this);</span>
<span class="udiff-line-added">+     accel.collect_unicodes (out);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (unlikely (!c-&gt;check_struct (this)))
        return_trace (false);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -338,19 +369,21 @@</span>
    HBUINT16      segCountX2;     /* 2 x segCount. */
    HBUINT16      searchRange;    /* 2 * (2**floor(log2(segCount))) */
    HBUINT16      entrySelector;  /* log2(searchRange/2) */
    HBUINT16      rangeShift;     /* 2 x segCount - searchRange */
  
<span class="udiff-line-modified-removed">-   HBUINT16      values[VAR];</span>
<span class="udiff-line-modified-added">+   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="udiff-line-added">+                 values;</span>
  #if 0
    HBUINT16      endCount[segCount];     /* End characterCode for each segment,
                                           * last=0xFFFFu. */
    HBUINT16      reservedPad;            /* Set to 0. */
    HBUINT16      startCount[segCount];   /* Start character code for each segment. */
    HBINT16               idDelta[segCount];      /* Delta for all character codes in segment. */
    HBUINT16      idRangeOffset[segCount];/* Offsets into glyphIdArray or 0 */
<span class="udiff-line-modified-removed">-   HBUINT16      glyphIdArray[VAR];      /* Glyph index array (arbitrary length) */</span>
<span class="udiff-line-modified-added">+   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="udiff-line-added">+                 glyphIdArray;   /* Glyph index array (arbitrary length) */</span>
  #endif
  
    public:
    DEFINE_SIZE_ARRAY (14, values);
  };
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -368,39 +401,48 @@</span>
      if (codepoint &lt; startCharCode) return -1;
      if (codepoint &gt; endCharCode)   return +1;
      return 0;
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
    private:
    HBUINT32              startCharCode;  /* First character code in this group. */
    HBUINT32              endCharCode;    /* Last character code in this group. */
    HBUINT32              glyphID;        /* Glyph index; interpretation depends on
<span class="udiff-line-modified-removed">-                                  * subtable format. */</span>
<span class="udiff-line-modified-added">+                                          * subtable format. */</span>
    public:
    DEFINE_SIZE_STATIC (12);
  };
<span class="udiff-line-added">+ DECLARE_NULL_NAMESPACE_BYTES (OT, CmapSubtableLongGroup);</span>
  
  template &lt;typename UINT&gt;
  struct CmapSubtableTrimmed
  {
<span class="udiff-line-modified-removed">-   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
    {
      /* Rely on our implicit array bound-checking. */
      hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];
      if (!gid)
        return false;
      *glyph = gid;
      return true;
    }
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     hb_codepoint_t start = startCharCode;</span>
<span class="udiff-line-added">+     unsigned int count = glyphIdArray.len;</span>
<span class="udiff-line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-added">+       if (glyphIdArray[i])</span>
<span class="udiff-line-added">+         out-&gt;add (start + i);</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; glyphIdArray.sanitize (c));
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -422,41 +464,40 @@</span>
  template &lt;typename T&gt;
  struct CmapSubtableLongSegmented
  {
    friend struct cmap;
  
<span class="udiff-line-modified-removed">-   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
    {
<span class="udiff-line-modified-removed">-     int i = groups.bsearch (codepoint);</span>
<span class="udiff-line-modified-removed">-     if (i == -1)</span>
<span class="udiff-line-modified-added">+     hb_codepoint_t gid = T::group_get_glyph (groups.bsearch (codepoint), codepoint);</span>
<span class="udiff-line-modified-added">+     if (!gid)</span>
        return false;
<span class="udiff-line-modified-removed">-     *glyph = T::group_get_glyph (groups[i], codepoint);</span>
<span class="udiff-line-modified-added">+     *glyph = gid;</span>
      return true;
    }
  
<span class="udiff-line-modified-removed">-   inline void get_all_codepoints (hb_set_t *out) const</span>
<span class="udiff-line-modified-added">+   void collect_unicodes (hb_set_t *out) const</span>
    {
      for (unsigned int i = 0; i &lt; this-&gt;groups.len; i++) {
<span class="udiff-line-modified-removed">-       hb_set_add_range (out,</span>
<span class="udiff-line-modified-removed">-                         this-&gt;groups[i].startCharCode,</span>
<span class="udiff-line-modified-removed">-                         this-&gt;groups[i].endCharCode);</span>
<span class="udiff-line-modified-added">+       out-&gt;add_range (this-&gt;groups[i].startCharCode,</span>
<span class="udiff-line-modified-added">+                       MIN ((hb_codepoint_t) this-&gt;groups[i].endCharCode,</span>
<span class="udiff-line-modified-added">+                            (hb_codepoint_t) HB_UNICODE_MAX));</span>
      }
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp; groups.sanitize (c));
    }
  
<span class="udiff-line-modified-removed">-   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="udiff-line-modified-removed">-                          const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
<span class="udiff-line-modified-added">+   bool serialize (hb_serialize_context_t *c,</span>
<span class="udiff-line-modified-added">+                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
    {
      TRACE_SERIALIZE (this);
      if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="udiff-line-modified-removed">-     Supplier&lt;CmapSubtableLongGroup&gt; supplier (group_data.arrayZ, group_data.len);</span>
<span class="udiff-line-removed">-     if (unlikely (!groups.serialize (c, supplier, group_data.len))) return_trace (false);</span>
<span class="udiff-line-modified-added">+     if (unlikely (!groups.serialize (c, group_data.as_array ()))) return_trace (false);</span>
      return true;
    }
  
    protected:
    HBUINT16      format;         /* Subtable format; set to 12. */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -469,13 +510,14 @@</span>
    DEFINE_SIZE_ARRAY (16, groups);
  };
  
  struct CmapSubtableFormat12 : CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;
  {
<span class="udiff-line-modified-removed">-   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="udiff-line-modified-removed">-                                                 hb_codepoint_t u)</span>
<span class="udiff-line-modified-removed">-   { return group.glyphID + (u - group.startCharCode); }</span>
<span class="udiff-line-modified-added">+   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="udiff-line-modified-added">+                                          hb_codepoint_t u)</span>
<span class="udiff-line-modified-added">+   { return likely (group.startCharCode &lt;= group.endCharCode) ?</span>
<span class="udiff-line-added">+            group.glyphID + (u - group.startCharCode) : 0; }</span>
  
  
    bool serialize (hb_serialize_context_t *c,
                    const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -486,17 +528,17 @@</span>
      this-&gt;length.set (get_sub_table_size (groups));
  
      return CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;::serialize (c, groups);
    }
  
<span class="udiff-line-modified-removed">-   static inline size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
<span class="udiff-line-modified-added">+   static size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
    {
<span class="udiff-line-modified-removed">-     return 16 + 12 * groups.len;</span>
<span class="udiff-line-modified-added">+     return 16 + 12 * groups.length;</span>
    }
  
<span class="udiff-line-modified-removed">-   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-removed">-                                             hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
<span class="udiff-line-modified-added">+   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-added">+                                      hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
    {
      CmapSubtableLongGroup *group = nullptr;
  
      hb_codepoint_t cp = HB_SET_VALUE_INVALID;
      while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -511,40 +553,38 @@</span>
        {
          group = groups-&gt;push ();
          group-&gt;startCharCode.set (cp);
          group-&gt;endCharCode.set (cp);
          group-&gt;glyphID.set (new_gid);
<span class="udiff-line-removed">-       } else</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-removed">-         group-&gt;endCharCode.set (cp);</span>
        }
<span class="udiff-line-added">+       else group-&gt;endCharCode.set (cp);</span>
      }
  
      DEBUG_MSG(SUBSET, nullptr, &quot;cmap&quot;);
<span class="udiff-line-modified-removed">-     for (unsigned int i = 0; i &lt; groups-&gt;len; i++) {</span>
<span class="udiff-line-modified-added">+     for (unsigned int i = 0; i &lt; groups-&gt;length; i++) {</span>
        CmapSubtableLongGroup&amp; group = (*groups)[i];
        DEBUG_MSG(SUBSET, nullptr, &quot;  %d: U+%04X-U+%04X, gid %d-%d&quot;, i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));
      }
  
      return true;
    }
  
   private:
<span class="udiff-line-modified-removed">-   static inline bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="udiff-line-modified-removed">-                                           hb_codepoint_t cp,</span>
<span class="udiff-line-modified-removed">-                                           hb_codepoint_t new_gid)</span>
<span class="udiff-line-modified-added">+   static bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="udiff-line-modified-added">+                                    hb_codepoint_t cp,</span>
<span class="udiff-line-modified-added">+                                    hb_codepoint_t new_gid)</span>
    {
      return (cp - 1 == group-&gt;endCharCode) &amp;&amp;
          new_gid == group-&gt;glyphID + (cp - group-&gt;startCharCode);
    }
  
  };
  
  struct CmapSubtableFormat13 : CmapSubtableLongSegmented&lt;CmapSubtableFormat13&gt;
  {
<span class="udiff-line-modified-removed">-   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="udiff-line-modified-removed">-                                                 hb_codepoint_t u HB_UNUSED)</span>
<span class="udiff-line-modified-added">+   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="udiff-line-modified-added">+                                          hb_codepoint_t u HB_UNUSED)</span>
    { return group.glyphID; }
  };
  
  typedef enum
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -553,40 +593,56 @@</span>
    GLYPH_VARIANT_USE_DEFAULT = 2
  } glyph_variant_t;
  
  struct UnicodeValueRange
  {
<span class="udiff-line-modified-removed">-   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
<span class="udiff-line-modified-added">+   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
    {
      if (codepoint &lt; startUnicodeValue) return -1;
      if (codepoint &gt; startUnicodeValue + additionalCount) return +1;
      return 0;
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
    HBUINT24      startUnicodeValue;      /* First value in this range. */
<span class="udiff-line-modified-removed">-   HBUINT8               additionalCount;        /* Number of additional values in this</span>
<span class="udiff-line-modified-added">+   HBUINT8       additionalCount;        /* Number of additional values in this</span>
                                           * range. */
    public:
    DEFINE_SIZE_STATIC (4);
  };
  
<span class="udiff-line-modified-removed">- typedef SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt; DefaultUVS;</span>
<span class="udiff-line-modified-added">+ struct DefaultUVS : SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt;</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     unsigned int count = len;</span>
<span class="udiff-line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       hb_codepoint_t first = arrayZ[i].startUnicodeValue;</span>
<span class="udiff-line-added">+       hb_codepoint_t last = MIN ((hb_codepoint_t) (first + arrayZ[i].additionalCount),</span>
<span class="udiff-line-added">+                                  (hb_codepoint_t) HB_UNICODE_MAX);</span>
<span class="udiff-line-added">+       out-&gt;add_range (first, last);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="udiff-line-added">+ };</span>
  
  struct UVSMapping
  {
<span class="udiff-line-modified-removed">-   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
<span class="udiff-line-modified-added">+   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
    {
      return unicodeValue.cmp (codepoint);
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -594,65 +650,90 @@</span>
    GlyphID       glyphID;        /* Glyph ID of the UVS */
    public:
    DEFINE_SIZE_STATIC (5);
  };
  
<span class="udiff-line-modified-removed">- typedef SortedArrayOf&lt;UVSMapping, HBUINT32&gt; NonDefaultUVS;</span>
<span class="udiff-line-modified-added">+ struct NonDefaultUVS : SortedArrayOf&lt;UVSMapping, HBUINT32&gt;</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     unsigned int count = len;</span>
<span class="udiff-line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-added">+       out-&gt;add (arrayZ[i].glyphID);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="udiff-line-added">+ };</span>
  
  struct VariationSelectorRecord
  {
<span class="udiff-line-modified-removed">-   inline glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-removed">-                                     hb_codepoint_t *glyph,</span>
<span class="udiff-line-modified-removed">-                                     const void *base) const</span>
<span class="udiff-line-modified-added">+   glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-added">+                              hb_codepoint_t *glyph,</span>
<span class="udiff-line-modified-added">+                              const void *base) const</span>
    {
<span class="udiff-line-modified-removed">-     int i;</span>
<span class="udiff-line-removed">-     const DefaultUVS &amp;defaults = base+defaultUVS;</span>
<span class="udiff-line-removed">-     i = defaults.bsearch (codepoint);</span>
<span class="udiff-line-removed">-     if (i != -1)</span>
<span class="udiff-line-modified-added">+     if ((base+defaultUVS).bfind (codepoint))</span>
        return GLYPH_VARIANT_USE_DEFAULT;
<span class="udiff-line-modified-removed">-     const NonDefaultUVS &amp;nonDefaults = base+nonDefaultUVS;</span>
<span class="udiff-line-modified-removed">-     i = nonDefaults.bsearch (codepoint);</span>
<span class="udiff-line-removed">-     if (i != -1)</span>
<span class="udiff-line-modified-added">+     const UVSMapping &amp;nonDefault = (base+nonDefaultUVS).bsearch (codepoint);</span>
<span class="udiff-line-modified-added">+     if (nonDefault.glyphID)</span>
      {
<span class="udiff-line-modified-removed">-       *glyph = nonDefaults[i].glyphID;</span>
<span class="udiff-line-modified-added">+       *glyph = nonDefault.glyphID;</span>
         return GLYPH_VARIANT_FOUND;
      }
      return GLYPH_VARIANT_NOT_FOUND;
    }
  
<span class="udiff-line-modified-removed">-   inline int cmp (const hb_codepoint_t &amp;variation_selector) const</span>
<span class="udiff-line-modified-added">+   void collect_unicodes (hb_set_t *out, const void *base) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     (base+defaultUVS).collect_unicodes (out);</span>
<span class="udiff-line-added">+     (base+nonDefaultUVS).collect_unicodes (out);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int cmp (const hb_codepoint_t &amp;variation_selector) const</span>
    {
      return varSelector.cmp (variation_selector);
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    defaultUVS.sanitize (c, base) &amp;&amp;
                    nonDefaultUVS.sanitize (c, base));
    }
  
    HBUINT24      varSelector;    /* Variation selector. */
    LOffsetTo&lt;DefaultUVS&gt;
<span class="udiff-line-modified-removed">-                 defaultUVS;     /* Offset to Default UVS Table. May be 0. */</span>
<span class="udiff-line-modified-added">+                 defaultUVS;     /* Offset to Default UVS Table.  May be 0. */</span>
    LOffsetTo&lt;NonDefaultUVS&gt;
<span class="udiff-line-modified-removed">-                 nonDefaultUVS;  /* Offset to Non-Default UVS Table. May be 0. */</span>
<span class="udiff-line-modified-added">+                 nonDefaultUVS;  /* Offset to Non-Default UVS Table.  May be 0. */</span>
    public:
    DEFINE_SIZE_STATIC (11);
  };
  
  struct CmapSubtableFormat14
  {
<span class="udiff-line-modified-removed">-   inline glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-removed">-                                             hb_codepoint_t variation_selector,</span>
<span class="udiff-line-modified-removed">-                                             hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-added">+                                      hb_codepoint_t variation_selector,</span>
<span class="udiff-line-modified-added">+                                      hb_codepoint_t *glyph) const</span>
    {
<span class="udiff-line-modified-removed">-     return record[record.bsearch(variation_selector)].get_glyph (codepoint, glyph, this);</span>
<span class="udiff-line-modified-added">+     return record.bsearch (variation_selector).get_glyph (codepoint, glyph, this);</span>
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   void collect_variation_selectors (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     unsigned int count = record.len;</span>
<span class="udiff-line-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-added">+       out-&gt;add (record.arrayZ[i].varSelector);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+   void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="udiff-line-added">+                                    hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     record.bsearch (variation_selector).collect_unicodes (out, this);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    record.sanitize (c, this));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -669,12 +750,12 @@</span>
  
  struct CmapSubtable
  {
    /* Note: We intentionally do NOT implement subtable formats 2 and 8. */
  
<span class="udiff-line-modified-removed">-   inline bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-removed">-                          hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+   bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-added">+                   hb_codepoint_t *glyph) const</span>
    {
      switch (u.format) {
      case  0: return u.format0 .get_glyph (codepoint, glyph);
      case  4: return u.format4 .get_glyph (codepoint, glyph);
      case  6: return u.format6 .get_glyph (codepoint, glyph);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -683,12 +764,25 @@</span>
      case 13: return u.format13.get_glyph (codepoint, glyph);
      case 14:
      default: return false;
      }
    }
<span class="udiff-line-added">+   void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     switch (u.format) {</span>
<span class="udiff-line-added">+     case  0: u.format0 .collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case  4: u.format4 .collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case  6: u.format6 .collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case 10: u.format10.collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case 12: u.format12.collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case 13: u.format13.collect_unicodes (out); return;</span>
<span class="udiff-line-added">+     case 14:</span>
<span class="udiff-line-added">+     default: return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      if (!u.format.sanitize (c)) return_trace (false);
      switch (u.format) {
      case  0: return_trace (u.format0 .sanitize (c));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -718,21 +812,21 @@</span>
  };
  
  
  struct EncodingRecord
  {
<span class="udiff-line-modified-removed">-   inline int cmp (const EncodingRecord &amp;other) const</span>
<span class="udiff-line-modified-added">+   int cmp (const EncodingRecord &amp;other) const</span>
    {
      int ret;
      ret = platformID.cmp (other.platformID);
      if (ret) return ret;
      ret = encodingID.cmp (other.encodingID);
      if (ret) return ret;
      return 0;
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    subtable.sanitize (c, base));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -745,105 +839,84 @@</span>
    DEFINE_SIZE_STATIC (8);
  };
  
  struct cmap
  {
<span class="udiff-line-modified-removed">-   static const hb_tag_t tableTag        = HB_OT_TAG_cmap;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   struct subset_plan {</span>
<span class="udiff-line-removed">-     subset_plan(void)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       format4_segments.init();</span>
<span class="udiff-line-removed">-       format12_groups.init();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+   static constexpr hb_tag_t tableTag = HB_OT_TAG_cmap;</span>
  
<span class="udiff-line-modified-removed">-     ~subset_plan(void)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       format4_segments.fini();</span>
<span class="udiff-line-removed">-       format12_groups.fini();</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     inline size_t final_size() const</span>
<span class="udiff-line-modified-added">+   struct subset_plan</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     size_t final_size () const</span>
      {
        return 4 // header
            +  8 * 3 // 3 EncodingRecord
            +  CmapSubtableFormat4::get_sub_table_size (this-&gt;format4_segments)
            +  CmapSubtableFormat12::get_sub_table_size (this-&gt;format12_groups);
      }
  
<span class="udiff-line-removed">-     // Format 4</span>
      hb_vector_t&lt;CmapSubtableFormat4::segment_plan&gt; format4_segments;
<span class="udiff-line-removed">-     // Format 12</span>
      hb_vector_t&lt;CmapSubtableLongGroup&gt; format12_groups;
    };
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-removed">-     TRACE_SANITIZE (this);</span>
<span class="udiff-line-removed">-     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="udiff-line-removed">-                   likely (version == 0) &amp;&amp;</span>
<span class="udiff-line-removed">-                   encodingRecord.sanitize (c, this));</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-removed">-                             subset_plan *cmap_plan) const</span>
<span class="udiff-line-modified-added">+   bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-added">+                      subset_plan *cmap_plan) const</span>
    {
<span class="udiff-line-modified-removed">-     if (unlikely( !CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
<span class="udiff-line-modified-added">+     if (unlikely (!CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
        return false;
  
      return CmapSubtableFormat12::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format12_groups);
    }
  
<span class="udiff-line-modified-removed">-   inline bool _subset (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-removed">-                        const subset_plan &amp;cmap_subset_plan,</span>
<span class="udiff-line-modified-removed">-                        size_t dest_sz,</span>
<span class="udiff-line-modified-removed">-                        void *dest) const</span>
<span class="udiff-line-modified-added">+   bool _subset (const hb_subset_plan_t *plan,</span>
<span class="udiff-line-modified-added">+                 const subset_plan &amp;cmap_subset_plan,</span>
<span class="udiff-line-modified-added">+                 size_t dest_sz,</span>
<span class="udiff-line-modified-added">+                 void *dest) const</span>
    {
      hb_serialize_context_t c (dest, dest_sz);
  
<span class="udiff-line-modified-removed">-     OT::cmap *cmap = c.start_serialize&lt;OT::cmap&gt; ();</span>
<span class="udiff-line-modified-removed">-     if (unlikely (!c.extend_min (*cmap)))</span>
<span class="udiff-line-modified-added">+     cmap *table = c.start_serialize&lt;cmap&gt; ();</span>
<span class="udiff-line-modified-added">+     if (unlikely (!c.extend_min (*table)))</span>
      {
        return false;
      }
  
<span class="udiff-line-modified-removed">-     cmap-&gt;version.set (0);</span>
<span class="udiff-line-modified-added">+     table-&gt;version.set (0);</span>
  
<span class="udiff-line-modified-removed">-     if (unlikely (!cmap-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
<span class="udiff-line-modified-added">+     if (unlikely (!table-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
        return false;
  
      // TODO(grieger): Convert the below to a for loop
  
      // Format 4, Plat 0 Encoding Record
<span class="udiff-line-modified-removed">-     EncodingRecord &amp;format4_plat0_rec = cmap-&gt;encodingRecord[0];</span>
<span class="udiff-line-modified-added">+     EncodingRecord &amp;format4_plat0_rec = table-&gt;encodingRecord[0];</span>
      format4_plat0_rec.platformID.set (0); // Unicode
      format4_plat0_rec.encodingID.set (3);
  
      // Format 4, Plat 3 Encoding Record
<span class="udiff-line-modified-removed">-     EncodingRecord &amp;format4_plat3_rec = cmap-&gt;encodingRecord[1];</span>
<span class="udiff-line-modified-added">+     EncodingRecord &amp;format4_plat3_rec = table-&gt;encodingRecord[1];</span>
      format4_plat3_rec.platformID.set (3); // Windows
      format4_plat3_rec.encodingID.set (1); // Unicode BMP
  
      // Format 12 Encoding Record
<span class="udiff-line-modified-removed">-     EncodingRecord &amp;format12_rec = cmap-&gt;encodingRecord[2];</span>
<span class="udiff-line-modified-added">+     EncodingRecord &amp;format12_rec = table-&gt;encodingRecord[2];</span>
      format12_rec.platformID.set (3); // Windows
      format12_rec.encodingID.set (10); // Unicode UCS-4
  
      // Write out format 4 sub table
      {
<span class="udiff-line-modified-removed">-       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, cmap);</span>
<span class="udiff-line-modified-added">+       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, table);</span>
        format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);
        subtable.u.format.set (4);
  
        CmapSubtableFormat4 &amp;format4 = subtable.u.format4;
        if (unlikely (!format4.serialize (&amp;c, plan, cmap_subset_plan.format4_segments)))
          return false;
      }
  
      // Write out format 12 sub table.
      {
<span class="udiff-line-modified-removed">-       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, cmap);</span>
<span class="udiff-line-modified-added">+       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, table);</span>
        subtable.u.format.set (12);
  
        CmapSubtableFormat12 &amp;format12 = subtable.u.format12;
        if (unlikely (!format12.serialize (&amp;c, cmap_subset_plan.format12_groups)))
          return false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -852,22 +925,22 @@</span>
      c.end_serialize ();
  
      return true;
    }
  
<span class="udiff-line-modified-removed">-   inline bool subset (hb_subset_plan_t *plan) const</span>
<span class="udiff-line-modified-added">+   bool subset (hb_subset_plan_t *plan) const</span>
    {
      subset_plan cmap_subset_plan;
  
      if (unlikely (!_create_plan (plan, &amp;cmap_subset_plan)))
      {
        DEBUG_MSG(SUBSET, nullptr, &quot;Failed to generate a cmap subsetting plan.&quot;);
        return false;
      }
  
      // We now know how big our blob needs to be
<span class="udiff-line-modified-removed">-     size_t dest_sz = cmap_subset_plan.final_size();</span>
<span class="udiff-line-modified-added">+     size_t dest_sz = cmap_subset_plan.final_size ();</span>
      void *dest = malloc (dest_sz);
      if (unlikely (!dest)) {
        DEBUG_MSG(SUBSET, nullptr, &quot;Unable to alloc %lu for cmap subset output&quot;, (unsigned long) dest_sz);
        return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -878,151 +951,163 @@</span>
        free (dest);
        return false;
      }
  
      // all done, write the blob into dest
<span class="udiff-line-modified-removed">-     hb_blob_t *cmap_prime = hb_blob_create ((const char *)dest,</span>
<span class="udiff-line-modified-added">+     hb_blob_t *cmap_prime = hb_blob_create ((const char *) dest,</span>
                                              dest_sz,
                                              HB_MEMORY_MODE_READONLY,
                                              dest,
                                              free);
      bool result =  plan-&gt;add_table (HB_OT_TAG_cmap, cmap_prime);
      hb_blob_destroy (cmap_prime);
      return result;
    }
  
<span class="udiff-line-modified-removed">-   struct accelerator_t</span>
<span class="udiff-line-modified-added">+   const CmapSubtable *find_best_subtable (bool *symbol = nullptr) const</span>
    {
<span class="udiff-line-modified-removed">-     inline void init (hb_face_t *face)</span>
<span class="udiff-line-modified-added">+     if (symbol) *symbol = false;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     const CmapSubtable *subtable;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* 32-bit subtables. */</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (3, 10))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 6))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 4))) return subtable;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* 16-bit subtables. */</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (3, 1))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 3))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 2))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 1))) return subtable;</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (0, 0))) return subtable;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* Symbol subtable. */</span>
<span class="udiff-line-added">+     if ((subtable = this-&gt;find_subtable (3, 0)))</span>
      {
<span class="udiff-line-modified-removed">-       this-&gt;blob = OT::Sanitizer&lt;OT::cmap&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_cmap));</span>
<span class="udiff-line-modified-removed">-       const OT::cmap *cmap = this-&gt;blob-&gt;as&lt;OT::cmap&gt; ();</span>
<span class="udiff-line-modified-removed">-       const OT::CmapSubtable *subtable = nullptr;</span>
<span class="udiff-line-modified-removed">-       const OT::CmapSubtableFormat14 *subtable_uvs = nullptr;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       bool symbol = false;</span>
<span class="udiff-line-modified-removed">-       /* 32-bit subtables. */</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (3, 10);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 6);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 4);</span>
<span class="udiff-line-removed">-       /* 16-bit subtables. */</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (3, 1);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 3);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 2);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 1);</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = cmap-&gt;find_subtable (0, 0);</span>
<span class="udiff-line-removed">-       if (!subtable)</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-removed">-         subtable = cmap-&gt;find_subtable (3, 0);</span>
<span class="udiff-line-removed">-         if (subtable) symbol = true;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       /* Meh. */</span>
<span class="udiff-line-removed">-       if (!subtable) subtable = &amp;Null(OT::CmapSubtable);</span>
<span class="udiff-line-modified-added">+       if (symbol) *symbol = true;</span>
<span class="udiff-line-modified-added">+       return subtable;</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     /* Meh. */</span>
<span class="udiff-line-modified-added">+     return &amp;Null (CmapSubtable);</span>
<span class="udiff-line-modified-added">+   }</span>
  
<span class="udiff-line-modified-removed">-       /* UVS subtable. */</span>
<span class="udiff-line-modified-removed">-       if (!subtable_uvs)</span>
<span class="udiff-line-modified-added">+   struct accelerator_t</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-added">+     void init (hb_face_t *face)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       this-&gt;table = hb_sanitize_context_t ().reference_table&lt;cmap&gt; (face);</span>
<span class="udiff-line-added">+       bool symbol;</span>
<span class="udiff-line-added">+       this-&gt;subtable = table-&gt;find_best_subtable (&amp;symbol);</span>
<span class="udiff-line-added">+       this-&gt;subtable_uvs = &amp;Null (CmapSubtableFormat14);</span>
        {
<span class="udiff-line-modified-removed">-         const OT::CmapSubtable *st = cmap-&gt;find_subtable (0, 5);</span>
<span class="udiff-line-modified-added">+         const CmapSubtable *st = table-&gt;find_subtable (0, 5);</span>
          if (st &amp;&amp; st-&gt;u.format == 14)
            subtable_uvs = &amp;st-&gt;u.format14;
        }
<span class="udiff-line-removed">-       /* Meh. */</span>
<span class="udiff-line-removed">-       if (!subtable_uvs) subtable_uvs = &amp;Null(OT::CmapSubtableFormat14);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       this-&gt;uvs_table = subtable_uvs;</span>
  
        this-&gt;get_glyph_data = subtable;
        if (unlikely (symbol))
        {
<span class="udiff-line-modified-removed">-         this-&gt;get_glyph_func = get_glyph_from_symbol&lt;OT::CmapSubtable&gt;;</span>
<span class="udiff-line-removed">-         this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
<span class="udiff-line-modified-added">+         this-&gt;get_glyph_funcZ = get_glyph_from_symbol&lt;CmapSubtable&gt;;</span>
        } else {
          switch (subtable-&gt;u.format) {
          /* Accelerate format 4 and format 12. */
          default:
<span class="udiff-line-modified-removed">-           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtable&gt;;</span>
<span class="udiff-line-removed">-           this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
<span class="udiff-line-modified-added">+           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtable&gt;;</span>
            break;
          case 12:
<span class="udiff-line-modified-removed">-           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtableFormat12&gt;;</span>
<span class="udiff-line-removed">-           this-&gt;get_all_codepoints_func = get_all_codepoints_from&lt;OT::CmapSubtableFormat12&gt;;</span>
<span class="udiff-line-modified-added">+           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtableFormat12&gt;;</span>
            break;
          case  4:
            {
              this-&gt;format4_accel.init (&amp;subtable-&gt;u.format4);
              this-&gt;get_glyph_data = &amp;this-&gt;format4_accel;
<span class="udiff-line-modified-removed">-             this-&gt;get_glyph_func = this-&gt;format4_accel.get_glyph_func;</span>
<span class="udiff-line-removed">-             this-&gt;get_all_codepoints_func = this-&gt;format4_accel.get_all_codepoints_func;</span>
<span class="udiff-line-modified-added">+             this-&gt;get_glyph_funcZ = this-&gt;format4_accel.get_glyph_func;</span>
            }
            break;
          }
        }
      }
  
<span class="udiff-line-modified-removed">-     inline void fini (void)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       hb_blob_destroy (this-&gt;blob);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     void fini () { this-&gt;table.destroy (); }</span>
  
<span class="udiff-line-modified-removed">-     inline bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
<span class="udiff-line-modified-added">+     bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
                                     hb_codepoint_t *glyph) const
      {
<span class="udiff-line-modified-removed">-       return this-&gt;get_glyph_func (this-&gt;get_glyph_data, unicode, glyph);</span>
<span class="udiff-line-modified-added">+       if (unlikely (!this-&gt;get_glyph_funcZ)) return false;</span>
<span class="udiff-line-added">+       return this-&gt;get_glyph_funcZ (this-&gt;get_glyph_data, unicode, glyph);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     unsigned int get_nominal_glyphs (unsigned int count,</span>
<span class="udiff-line-added">+                                      const hb_codepoint_t *first_unicode,</span>
<span class="udiff-line-added">+                                      unsigned int unicode_stride,</span>
<span class="udiff-line-added">+                                      hb_codepoint_t *first_glyph,</span>
<span class="udiff-line-added">+                                      unsigned int glyph_stride) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       if (unlikely (!this-&gt;get_glyph_funcZ)) return 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       hb_cmap_get_glyph_func_t get_glyph_funcZ = this-&gt;get_glyph_funcZ;</span>
<span class="udiff-line-added">+       const void *get_glyph_data = this-&gt;get_glyph_data;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       unsigned int done;</span>
<span class="udiff-line-added">+       for (done = 0;</span>
<span class="udiff-line-added">+            done &lt; count &amp;&amp; get_glyph_funcZ (get_glyph_data, *first_unicode, first_glyph);</span>
<span class="udiff-line-added">+            done++)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         first_unicode = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_unicode, unicode_stride);</span>
<span class="udiff-line-added">+         first_glyph = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_glyph, glyph_stride);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       return done;</span>
      }
  
<span class="udiff-line-modified-removed">-     inline bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="udiff-line-modified-removed">-                                      hb_codepoint_t  variation_selector,</span>
<span class="udiff-line-modified-removed">-                                      hb_codepoint_t *glyph) const</span>
<span class="udiff-line-modified-added">+     bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="udiff-line-modified-added">+                               hb_codepoint_t  variation_selector,</span>
<span class="udiff-line-modified-added">+                               hb_codepoint_t *glyph) const</span>
      {
<span class="udiff-line-modified-removed">-       switch (this-&gt;uvs_table-&gt;get_glyph_variant (unicode,</span>
<span class="udiff-line-modified-removed">-                                                   variation_selector,</span>
<span class="udiff-line-modified-removed">-                                                   glyph))</span>
<span class="udiff-line-modified-added">+       switch (this-&gt;subtable_uvs-&gt;get_glyph_variant (unicode,</span>
<span class="udiff-line-modified-added">+                                                      variation_selector,</span>
<span class="udiff-line-modified-added">+                                                      glyph))</span>
        {
<span class="udiff-line-modified-removed">-         case OT::GLYPH_VARIANT_NOT_FOUND:               return false;</span>
<span class="udiff-line-modified-removed">-         case OT::GLYPH_VARIANT_FOUND:           return true;</span>
<span class="udiff-line-modified-removed">-         case OT::GLYPH_VARIANT_USE_DEFAULT:     break;</span>
<span class="udiff-line-modified-added">+         case GLYPH_VARIANT_NOT_FOUND:   return false;</span>
<span class="udiff-line-modified-added">+         case GLYPH_VARIANT_FOUND:       return true;</span>
<span class="udiff-line-modified-added">+         case GLYPH_VARIANT_USE_DEFAULT: break;</span>
        }
  
        return get_nominal_glyph (unicode, glyph);
      }
  
<span class="udiff-line-modified-removed">-     inline void get_all_codepoints (hb_set_t *out) const</span>
<span class="udiff-line-modified-added">+     void collect_unicodes (hb_set_t *out) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       subtable-&gt;collect_unicodes (out);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     void collect_variation_selectors (hb_set_t *out) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       subtable_uvs-&gt;collect_variation_selectors (out);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="udiff-line-added">+                                      hb_set_t *out) const</span>
      {
<span class="udiff-line-modified-removed">-       this-&gt;get_all_codepoints_func (get_glyph_data, out);</span>
<span class="udiff-line-modified-added">+       subtable_uvs-&gt;collect_variation_unicodes (variation_selector, out);</span>
      }
  
      protected:
      typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,
                                                hb_codepoint_t codepoint,
                                                hb_codepoint_t *glyph);
<span class="udiff-line-removed">-     typedef void (*hb_cmap_get_all_codepoints_func_t) (const void *obj,</span>
<span class="udiff-line-removed">-                                                        hb_set_t *out);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     static inline void null_get_all_codepoints_func (const void *obj, hb_set_t *out)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       // NOOP</span>
<span class="udiff-line-removed">-     }</span>
  
      template &lt;typename Type&gt;
<span class="udiff-line-modified-removed">-     static inline bool get_glyph_from (const void *obj,</span>
<span class="udiff-line-modified-removed">-                                        hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-removed">-                                        hb_codepoint_t *glyph)</span>
<span class="udiff-line-modified-added">+     static bool get_glyph_from (const void *obj,</span>
<span class="udiff-line-modified-added">+                                 hb_codepoint_t codepoint,</span>
<span class="udiff-line-modified-added">+                                 hb_codepoint_t *glyph)</span>
      {
        const Type *typed_obj = (const Type *) obj;
        return typed_obj-&gt;get_glyph (codepoint, glyph);
      }
  
      template &lt;typename Type&gt;
<span class="udiff-line-modified-removed">-     static inline void get_all_codepoints_from (const void *obj,</span>
<span class="udiff-line-removed">-                                                 hb_set_t *out)</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       const Type *typed_obj = (const Type *) obj;</span>
<span class="udiff-line-removed">-       typed_obj-&gt;get_all_codepoints (out);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     template &lt;typename Type&gt;</span>
<span class="udiff-line-removed">-     static inline bool get_glyph_from_symbol (const void *obj,</span>
<span class="udiff-line-modified-added">+     static bool get_glyph_from_symbol (const void *obj,</span>
                                                hb_codepoint_t codepoint,
                                                hb_codepoint_t *glyph)
      {
        const Type *typed_obj = (const Type *) obj;
        if (likely (typed_obj-&gt;get_glyph (codepoint, glyph)))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1040,47 +1125,56 @@</span>
  
        return false;
      }
  
      private:
<span class="udiff-line-modified-removed">-     hb_cmap_get_glyph_func_t get_glyph_func;</span>
<span class="udiff-line-modified-added">+     hb_nonnull_ptr_t&lt;const CmapSubtable&gt; subtable;</span>
<span class="udiff-line-added">+     hb_nonnull_ptr_t&lt;const CmapSubtableFormat14&gt; subtable_uvs;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     hb_cmap_get_glyph_func_t get_glyph_funcZ;</span>
      const void *get_glyph_data;
<span class="udiff-line-removed">-     hb_cmap_get_all_codepoints_func_t get_all_codepoints_func;</span>
  
<span class="udiff-line-modified-removed">-     OT::CmapSubtableFormat4::accelerator_t format4_accel;</span>
<span class="udiff-line-modified-added">+     CmapSubtableFormat4::accelerator_t format4_accel;</span>
  
<span class="udiff-line-modified-removed">-     const OT::CmapSubtableFormat14 *uvs_table;</span>
<span class="udiff-line-removed">-     hb_blob_t *blob;</span>
<span class="udiff-line-modified-added">+     hb_blob_ptr_t&lt;cmap&gt; table;</span>
    };
  
    protected:
  
<span class="udiff-line-modified-removed">-   inline const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="udiff-line-modified-removed">-                                             unsigned int encoding_id) const</span>
<span class="udiff-line-modified-added">+   const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="udiff-line-modified-added">+                                      unsigned int encoding_id) const</span>
    {
      EncodingRecord key;
      key.platformID.set (platform_id);
      key.encodingID.set (encoding_id);
  
<span class="udiff-line-modified-removed">-     /* Note: We can use bsearch, but since it has no performance</span>
<span class="udiff-line-modified-removed">-      * implications, we use lsearch and as such accept fonts with</span>
<span class="udiff-line-removed">-      * unsorted subtable list. */</span>
<span class="udiff-line-removed">-     int result = encodingRecord./*bsearch*/lsearch (key);</span>
<span class="udiff-line-removed">-     if (result == -1 || !encodingRecord[result].subtable)</span>
<span class="udiff-line-modified-added">+     const EncodingRecord &amp;result = encodingRecord.bsearch (key);</span>
<span class="udiff-line-modified-added">+     if (!result.subtable)</span>
        return nullptr;
  
<span class="udiff-line-modified-removed">-     return &amp;(this+encodingRecord[result].subtable);</span>
<span class="udiff-line-modified-added">+     return &amp;(this+result.subtable);</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   public:</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     TRACE_SANITIZE (this);</span>
<span class="udiff-line-added">+     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="udiff-line-added">+                   likely (version == 0) &amp;&amp;</span>
<span class="udiff-line-added">+                   encodingRecord.sanitize (c, this));</span>
    }
  
    protected:
    HBUINT16              version;        /* Table version number (0). */
    SortedArrayOf&lt;EncodingRecord&gt;
                          encodingRecord; /* Encoding tables. */
    public:
    DEFINE_SIZE_ARRAY (4, encodingRecord);
  };
  
<span class="udiff-line-added">+ struct cmap_accelerator_t : cmap::accelerator_t {};</span>
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_CMAP_TABLE_HH */
</pre>
<center><a href="hb-map.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cbdt-table.hh.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
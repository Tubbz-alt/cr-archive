<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright Â© 2011,2012  Google, Inc.
   3  *
   4  *  This is part of HarfBuzz, a text shaping library.
   5  *
   6  * Permission is hereby granted, without written agreement and without
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
<a name="1" id="anc1"></a><span class="line-modified">  27 #include &quot;hb-ot-shape-complex-indic-private.hh&quot;</span>
<span class="line-modified">  28 #include &quot;hb-ot-layout-private.hh&quot;</span>

  29 
  30 
  31 /*
  32  * Indic shaper.
  33  */
  34 
  35 
  36 /*
  37  * Indic configurations.  Note that we do not want to keep every single script-specific
  38  * behavior in these tables necessarily.  This should mainly be used for per-script
  39  * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and
  40  * only one script has an exception, that one script can be if&#39;ed directly in the code,
  41  * instead of adding a new flag in these structs.
  42  */
  43 
  44 enum base_position_t {
  45   BASE_POS_LAST_SINHALA,
  46   BASE_POS_LAST
  47 };
  48 enum reph_position_t {
  49   REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,
  50   REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,
  51   REPH_POS_AFTER_SUB   = POS_AFTER_SUB,
  52   REPH_POS_BEFORE_POST = POS_BEFORE_POST,
  53   REPH_POS_AFTER_POST  = POS_AFTER_POST
  54 };
  55 enum reph_mode_t {
  56   REPH_MODE_IMPLICIT,  /* Reph formed out of initial Ra,H sequence. */
  57   REPH_MODE_EXPLICIT,  /* Reph formed out of initial Ra,H,ZWJ sequence. */
  58   REPH_MODE_LOG_REPHA  /* Encoded Repha character, needs reordering. */
  59 };
  60 enum blwf_mode_t {
  61   BLWF_MODE_PRE_AND_POST, /* Below-forms feature applied to pre-base and post-base. */
  62   BLWF_MODE_POST_ONLY     /* Below-forms feature applied to post-base only. */
  63 };
  64 struct indic_config_t
  65 {
  66   hb_script_t     script;
  67   bool            has_old_spec;
  68   hb_codepoint_t  virama;
  69   base_position_t base_pos;
  70   reph_position_t reph_pos;
  71   reph_mode_t     reph_mode;
  72   blwf_mode_t     blwf_mode;
  73 };
  74 
  75 static const indic_config_t indic_configs[] =
  76 {
  77   /* Default.  Should be first. */
  78   {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  79   {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  80   {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  81   {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  82   {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  83   {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  84   {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  85   {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},
  86   {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},
  87   {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},
  88   {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,
  89                                                      REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},
  90 };
  91 
  92 
  93 
  94 /*
  95  * Indic shaper.
  96  */
  97 
<a name="2" id="anc2"></a><span class="line-modified">  98 struct feature_list_t {</span>
<span class="line-removed">  99   hb_tag_t tag;</span>
<span class="line-removed"> 100   hb_ot_map_feature_flags_t flags;</span>
<span class="line-removed"> 101 };</span>
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103 static const feature_list_t</span>
 104 indic_features[] =
 105 {
 106   /*
 107    * Basic features.
 108    * These features are applied in order, one at a time, after initial_reordering.
 109    */
<a name="3" id="anc3"></a><span class="line-modified"> 110   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-modified"> 111   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="line-modified"> 112   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 113   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL},</span>
<span class="line-modified"> 114   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 115   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 116   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 117   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 118   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 119   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL},</span>
<span class="line-modified"> 120   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL},</span>
 121   /*
 122    * Other features.
<a name="4" id="anc4"></a><span class="line-modified"> 123    * These features are applied all at once, after final_reordering.</span>

 124    * Default Bengali font in Windows for example has intermixed
 125    * lookups for init,pres,abvs,blws features.
 126    */
<a name="5" id="anc5"></a><span class="line-modified"> 127   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;), F_NONE},</span>
<span class="line-modified"> 128   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 129   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 130   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 131   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 132   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="line-modified"> 133   /* Positioning features, though we don&#39;t care about the types. */</span>



 134   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 135   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 136   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 137 };
 138 
 139 /*
 140  * Must be in the same order as the indic_features array.
 141  */
 142 enum {
 143   _NUKT,
 144   _AKHN,
 145   RPHF,
 146   _RKRF,
 147   PREF,
 148   BLWF,
 149   ABVF,
 150   HALF,
 151   PSTF,
 152   _VATU,
 153   _CJCT,
 154 
 155   INIT,
 156   _PRES,
 157   _ABVS,
 158   _BLWS,
 159   _PSTS,
 160   _HALN,
<a name="6" id="anc6"></a>
 161   _DIST,
 162   _ABVM,
 163   _BLWM,
 164 
 165   INDIC_NUM_FEATURES,
<a name="7" id="anc7"></a><span class="line-modified"> 166   INDIC_BASIC_FEATURES = INIT /* Don&#39;t forget to update this! */</span>
 167 };
 168 
 169 static void
 170 setup_syllables (const hb_ot_shape_plan_t *plan,
 171                  hb_font_t *font,
 172                  hb_buffer_t *buffer);
 173 static void
 174 initial_reordering (const hb_ot_shape_plan_t *plan,
 175                     hb_font_t *font,
 176                     hb_buffer_t *buffer);
 177 static void
 178 final_reordering (const hb_ot_shape_plan_t *plan,
 179                   hb_font_t *font,
 180                   hb_buffer_t *buffer);
 181 static void
 182 clear_syllables (const hb_ot_shape_plan_t *plan,
 183                  hb_font_t *font,
 184                  hb_buffer_t *buffer);
 185 
 186 static void
 187 collect_features_indic (hb_ot_shape_planner_t *plan)
 188 {
 189   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 190 
 191   /* Do this before any lookups have been applied. */
 192   map-&gt;add_gsub_pause (setup_syllables);
 193 
<a name="8" id="anc8"></a><span class="line-modified"> 194   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
 195   /* The Indic specs do not require ccmp, but we apply it here since if
 196    * there is a use of it, it&#39;s typically at the beginning. */
<a name="9" id="anc9"></a><span class="line-modified"> 197   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
 198 
 199 
 200   unsigned int i = 0;
 201   map-&gt;add_gsub_pause (initial_reordering);
<a name="10" id="anc10"></a>
 202   for (; i &lt; INDIC_BASIC_FEATURES; i++) {
<a name="11" id="anc11"></a><span class="line-modified"> 203     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
 204     map-&gt;add_gsub_pause (nullptr);
 205   }
<a name="12" id="anc12"></a>
 206   map-&gt;add_gsub_pause (final_reordering);
<a name="13" id="anc13"></a><span class="line-removed"> 207   for (; i &lt; INDIC_NUM_FEATURES; i++) {</span>
<span class="line-removed"> 208     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed"> 209   }</span>
 210 
<a name="14" id="anc14"></a><span class="line-modified"> 211   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-modified"> 212   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>



 213 
 214   map-&gt;add_gsub_pause (clear_syllables);
 215 }
 216 
 217 static void
 218 override_features_indic (hb_ot_shape_planner_t *plan)
 219 {
<a name="15" id="anc15"></a><span class="line-modified"> 220   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
 221 }
 222 
 223 
 224 struct would_substitute_feature_t
 225 {
<a name="16" id="anc16"></a><span class="line-modified"> 226   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
 227   {
 228     zero_context = zero_context_;
 229     map-&gt;get_stage_lookups (0/*GSUB*/,
 230                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
 231                             &amp;lookups, &amp;count);
 232   }
 233 
<a name="17" id="anc17"></a><span class="line-modified"> 234   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified"> 235                                 unsigned int          glyphs_count,</span>
<span class="line-modified"> 236                                 hb_face_t            *face) const</span>
 237   {
 238     for (unsigned int i = 0; i &lt; count; i++)
 239       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
 240         return true;
 241     return false;
 242   }
 243 
 244   private:
 245   const hb_ot_map_t::lookup_map_t *lookups;
 246   unsigned int count;
 247   bool zero_context;
 248 };
 249 
 250 struct indic_shape_plan_t
 251 {
<a name="18" id="anc18"></a><span class="line-modified"> 252   ASSERT_POD ();</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
 255   {
<a name="19" id="anc19"></a><span class="line-modified"> 256     hb_codepoint_t glyph = virama_glyph;</span>
<span class="line-modified"> 257     if (unlikely (virama_glyph == (hb_codepoint_t) -1))</span>
 258     {
 259       if (!config-&gt;virama || !font-&gt;get_nominal_glyph (config-&gt;virama, &amp;glyph))
 260         glyph = 0;
 261       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
 262        * Maybe one day... */
 263 
 264       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
<a name="20" id="anc20"></a><span class="line-modified"> 265        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */</span>
<span class="line-modified"> 266       virama_glyph = glyph;</span>
 267     }
 268 
 269     *pglyph = glyph;
 270     return glyph != 0;
 271   }
 272 
 273   const indic_config_t *config;
 274 
 275   bool is_old_spec;
<a name="21" id="anc21"></a><span class="line-modified"> 276   mutable hb_codepoint_t virama_glyph;</span>

 277 
 278   would_substitute_feature_t rphf;
 279   would_substitute_feature_t pref;
 280   would_substitute_feature_t blwf;
 281   would_substitute_feature_t pstf;
 282 
 283   hb_mask_t mask_array[INDIC_NUM_FEATURES];
 284 };
 285 
 286 static void *
 287 data_create_indic (const hb_ot_shape_plan_t *plan)
 288 {
 289   indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));
 290   if (unlikely (!indic_plan))
 291     return nullptr;
 292 
 293   indic_plan-&gt;config = &amp;indic_configs[0];
 294   for (unsigned int i = 1; i &lt; ARRAY_LENGTH (indic_configs); i++)
 295     if (plan-&gt;props.script == indic_configs[i].script) {
 296       indic_plan-&gt;config = &amp;indic_configs[i];
 297       break;
 298     }
 299 
 300   indic_plan-&gt;is_old_spec = indic_plan-&gt;config-&gt;has_old_spec &amp;&amp; ((plan-&gt;map.chosen_script[0] &amp; 0x000000FFu) != &#39;2&#39;);
<a name="22" id="anc22"></a><span class="line-modified"> 301   indic_plan-&gt;virama_glyph = (hb_codepoint_t) -1;</span>

 302 
 303   /* Use zero-context would_substitute() matching for new-spec of the main
 304    * Indic scripts, and scripts with one spec only, but not for old-specs.
 305    * The new-spec for all dual-spec scripts says zero-context matching happens.
 306    *
 307    * However, testing with Malayalam shows that old and new spec both allow
 308    * context.  Testing with Bengali new-spec however shows that it doesn&#39;t.
 309    * So, the heuristic here is the way it is.  It should *only* be changed,
 310    * as we discover more cases of what Windows does.  DON&#39;T TOUCH OTHERWISE.
 311    */
 312   bool zero_context = !indic_plan-&gt;is_old_spec &amp;&amp; plan-&gt;props.script != HB_SCRIPT_MALAYALAM;
 313   indic_plan-&gt;rphf.init (&amp;plan-&gt;map, HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), zero_context);
 314   indic_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), zero_context);
 315   indic_plan-&gt;blwf.init (&amp;plan-&gt;map, HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), zero_context);
 316   indic_plan-&gt;pstf.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), zero_context);
 317 
 318   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (indic_plan-&gt;mask_array); i++)
 319     indic_plan-&gt;mask_array[i] = (indic_features[i].flags &amp; F_GLOBAL) ?
 320                                  0 : plan-&gt;map.get_1_mask (indic_features[i].tag);
 321 
 322   return indic_plan;
 323 }
 324 
 325 static void
 326 data_destroy_indic (void *data)
 327 {
 328   free (data);
 329 }
 330 
 331 static indic_position_t
 332 consonant_position_from_face (const indic_shape_plan_t *indic_plan,
 333                               const hb_codepoint_t consonant,
 334                               const hb_codepoint_t virama,
 335                               hb_face_t *face)
 336 {
 337   /* For old-spec, the order of glyphs is Consonant,Virama,
 338    * whereas for new-spec, it&#39;s Virama,Consonant.  However,
 339    * some broken fonts (like Free Sans) simply copied lookups
 340    * from old-spec to new-spec without modification.
 341    * And oddly enough, Uniscribe seems to respect those lookups.
 342    * Eg. in the sequence U+0924,U+094D,U+0930, Uniscribe finds
 343    * base at 0.  The font however, only has lookups matching
 344    * 930,94D in &#39;blwf&#39;, not the expected 94D,930 (with new-spec
 345    * table).  As such, we simply match both sequences.  Seems
 346    * to work. */
 347   hb_codepoint_t glyphs[3] = {virama, consonant, virama};
 348   if (indic_plan-&gt;blwf.would_substitute (glyphs  , 2, face) ||
 349       indic_plan-&gt;blwf.would_substitute (glyphs+1, 2, face))
 350     return POS_BELOW_C;
 351   if (indic_plan-&gt;pstf.would_substitute (glyphs  , 2, face) ||
 352       indic_plan-&gt;pstf.would_substitute (glyphs+1, 2, face))
 353     return POS_POST_C;
 354   if (indic_plan-&gt;pref.would_substitute (glyphs  , 2, face) ||
 355       indic_plan-&gt;pref.would_substitute (glyphs+1, 2, face))
 356     return POS_POST_C;
 357   return POS_BASE_C;
 358 }
 359 
 360 
 361 enum syllable_type_t {
 362   consonant_syllable,
 363   vowel_syllable,
 364   standalone_cluster,
 365   symbol_cluster,
 366   broken_cluster,
 367   non_indic_cluster,
 368 };
 369 
 370 #include &quot;hb-ot-shape-complex-indic-machine.hh&quot;
 371 
 372 
 373 static void
 374 setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,
 375                    hb_buffer_t              *buffer,
 376                    hb_font_t                *font HB_UNUSED)
 377 {
 378   HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);
 379   HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);
 380 
 381   /* We cannot setup masks here.  We save information about characters
 382    * and setup masks later on in a pause-callback. */
 383 
 384   unsigned int count = buffer-&gt;len;
 385   hb_glyph_info_t *info = buffer-&gt;info;
 386   for (unsigned int i = 0; i &lt; count; i++)
 387     set_indic_properties (info[i]);
 388 }
 389 
 390 static void
 391 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
 392                  hb_font_t *font HB_UNUSED,
 393                  hb_buffer_t *buffer)
 394 {
 395   find_syllables (buffer);
 396   foreach_syllable (buffer, start, end)
 397     buffer-&gt;unsafe_to_break (start, end);
 398 }
 399 
 400 static int
 401 compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
 402 {
 403   int a = pa-&gt;indic_position();
 404   int b = pb-&gt;indic_position();
 405 
 406   return a &lt; b ? -1 : a == b ? 0 : +1;
 407 }
 408 
 409 
 410 
 411 static void
 412 update_consonant_positions (const hb_ot_shape_plan_t *plan,
 413                             hb_font_t         *font,
 414                             hb_buffer_t       *buffer)
 415 {
 416   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 417 
 418   if (indic_plan-&gt;config-&gt;base_pos != BASE_POS_LAST)
 419     return;
 420 
 421   hb_codepoint_t virama;
<a name="23" id="anc23"></a><span class="line-modified"> 422   if (indic_plan-&gt;get_virama_glyph (font, &amp;virama))</span>
 423   {
 424     hb_face_t *face = font-&gt;face;
 425     unsigned int count = buffer-&gt;len;
 426     hb_glyph_info_t *info = buffer-&gt;info;
 427     for (unsigned int i = 0; i &lt; count; i++)
 428       if (info[i].indic_position() == POS_BASE_C)
 429       {
 430         hb_codepoint_t consonant = info[i].codepoint;
 431         info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);
 432       }
 433   }
 434 }
 435 
 436 
 437 /* Rules from:
 438  * https://docs.microsqoft.com/en-us/typography/script-development/devanagari */
 439 
 440 static void
 441 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,
 442                                        hb_face_t *face,
 443                                        hb_buffer_t *buffer,
 444                                        unsigned int start, unsigned int end)
 445 {
 446   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 447   hb_glyph_info_t *info = buffer-&gt;info;
 448 
 449   /* https://github.com/harfbuzz/harfbuzz/issues/435#issuecomment-335560167
 450    * // For compatibility with legacy usage in Kannada,
 451    * // Ra+h+ZWJ must behave like Ra+ZWJ+h...
 452    */
 453   if (buffer-&gt;props.script == HB_SCRIPT_KANNADA &amp;&amp;
 454       start + 3 &lt;= end &amp;&amp;
 455       is_one_of (info[start  ], FLAG (OT_Ra)) &amp;&amp;
 456       is_one_of (info[start+1], FLAG (OT_H)) &amp;&amp;
 457       is_one_of (info[start+2], FLAG (OT_ZWJ)))
 458   {
 459     buffer-&gt;merge_clusters (start+1, start+3);
 460     hb_glyph_info_t tmp = info[start+1];
 461     info[start+1] = info[start+2];
 462     info[start+2] = tmp;
 463   }
 464 
 465   /* 1. Find base consonant:
 466    *
 467    * The shaping engine finds the base consonant of the syllable, using the
 468    * following algorithm: starting from the end of the syllable, move backwards
 469    * until a consonant is found that does not have a below-base or post-base
 470    * form (post-base forms have to follow below-base forms), or that is not a
 471    * pre-base-reordering Ra, or arrive at the first consonant. The consonant
 472    * stopped at will be the base.
 473    *
 474    *   o If the syllable starts with Ra + Halant (in a script that has Reph)
 475    *     and has more than one consonant, Ra is excluded from candidates for
 476    *     base consonants.
 477    */
 478 
 479   unsigned int base = end;
 480   bool has_reph = false;
 481 
 482   {
 483     /* -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)
 484      *    and has more than one consonant, Ra is excluded from candidates for
 485      *    base consonants. */
 486     unsigned int limit = start;
 487     if (indic_plan-&gt;mask_array[RPHF] &amp;&amp;
 488         start + 3 &lt;= end &amp;&amp;
 489         (
 490          (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_IMPLICIT &amp;&amp; !is_joiner (info[start + 2])) ||
 491          (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT &amp;&amp; info[start + 2].indic_category() == OT_ZWJ)
 492         ))
 493     {
 494       /* See if it matches the &#39;rphf&#39; feature. */
 495       hb_codepoint_t glyphs[3] = {info[start].codepoint,
 496                                   info[start + 1].codepoint,
 497                                   indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT ?
 498                                     info[start + 2].codepoint : 0};
 499       if (indic_plan-&gt;rphf.would_substitute (glyphs, 2, face) ||
 500           (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_EXPLICIT &amp;&amp;
 501            indic_plan-&gt;rphf.would_substitute (glyphs, 3, face)))
 502       {
 503         limit += 2;
 504         while (limit &lt; end &amp;&amp; is_joiner (info[limit]))
 505           limit++;
 506         base = start;
 507         has_reph = true;
 508       }
 509     } else if (indic_plan-&gt;config-&gt;reph_mode == REPH_MODE_LOG_REPHA &amp;&amp; info[start].indic_category() == OT_Repha)
 510     {
 511         limit += 1;
 512         while (limit &lt; end &amp;&amp; is_joiner (info[limit]))
 513           limit++;
 514         base = start;
 515         has_reph = true;
 516     }
 517 
 518     switch (indic_plan-&gt;config-&gt;base_pos)
 519     {
 520       case BASE_POS_LAST:
 521       {
 522         /* -&gt; starting from the end of the syllable, move backwards */
 523         unsigned int i = end;
 524         bool seen_below = false;
 525         do {
 526           i--;
 527           /* -&gt; until a consonant is found */
 528           if (is_consonant (info[i]))
 529           {
 530             /* -&gt; that does not have a below-base or post-base form
 531              * (post-base forms have to follow below-base forms), */
 532             if (info[i].indic_position() != POS_BELOW_C &amp;&amp;
 533                 (info[i].indic_position() != POS_POST_C || seen_below))
 534             {
 535               base = i;
 536               break;
 537             }
 538             if (info[i].indic_position() == POS_BELOW_C)
 539               seen_below = true;
 540 
 541             /* -&gt; or that is not a pre-base-reordering Ra,
 542              *
 543              * IMPLEMENTATION NOTES:
 544              *
 545              * Our pre-base-reordering Ra&#39;s are marked POS_POST_C, so will be skipped
 546              * by the logic above already.
 547              */
 548 
 549             /* -&gt; or arrive at the first consonant. The consonant stopped at will
 550              * be the base. */
 551             base = i;
 552           }
 553           else
 554           {
 555             /* A ZWJ after a Halant stops the base search, and requests an explicit
 556              * half form.
 557              * A ZWJ before a Halant, requests a subjoined form instead, and hence
 558              * search continues.  This is particularly important for Bengali
 559              * sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya. */
 560             if (start &lt; i &amp;&amp;
 561                 info[i].indic_category() == OT_ZWJ &amp;&amp;
 562                 info[i - 1].indic_category() == OT_H)
 563               break;
 564           }
 565         } while (i &gt; limit);
 566       }
 567       break;
 568 
 569       case BASE_POS_LAST_SINHALA:
 570       {
 571         /* Sinhala base positioning is slightly different from main Indic, in that:
 572          * 1. Its ZWJ behavior is different,
 573          * 2. We don&#39;t need to look into the font for consonant positions.
 574          */
 575 
 576         if (!has_reph)
 577           base = limit;
 578 
 579         /* Find the last base consonant that is not blocked by ZWJ.  If there is
 580          * a ZWJ right before a base consonant, that would request a subjoined form. */
 581         for (unsigned int i = limit; i &lt; end; i++)
 582           if (is_consonant (info[i]))
 583           {
 584             if (limit &lt; i &amp;&amp; info[i - 1].indic_category() == OT_ZWJ)
 585               break;
 586             else
 587               base = i;
 588           }
 589 
 590         /* Mark all subsequent consonants as below. */
 591         for (unsigned int i = base + 1; i &lt; end; i++)
 592           if (is_consonant (info[i]))
 593             info[i].indic_position() = POS_BELOW_C;
 594       }
 595       break;
 596     }
 597 
 598     /* -&gt; If the syllable starts with Ra + Halant (in a script that has Reph)
 599      *    and has more than one consonant, Ra is excluded from candidates for
 600      *    base consonants.
 601      *
 602      *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. */
 603     if (has_reph &amp;&amp; base == start &amp;&amp; limit - base &lt;= 2) {
 604       /* Have no other consonant, so Reph is not formed and Ra becomes base. */
 605       has_reph = false;
 606     }
 607   }
 608 
 609 
 610   /* 2. Decompose and reorder Matras:
 611    *
 612    * Each matra and any syllable modifier sign in the syllable are moved to the
 613    * appropriate position relative to the consonant(s) in the syllable. The
 614    * shaping engine decomposes two- or three-part matras into their constituent
 615    * parts before any repositioning. Matra characters are classified by which
 616    * consonant in a conjunct they have affinity for and are reordered to the
 617    * following positions:
 618    *
 619    *   o Before first half form in the syllable
 620    *   o After subjoined consonants
 621    *   o After post-form consonant
 622    *   o After main consonant (for above marks)
 623    *
 624    * IMPLEMENTATION NOTES:
 625    *
 626    * The normalize() routine has already decomposed matras for us, so we don&#39;t
 627    * need to worry about that.
 628    */
 629 
 630 
 631   /* 3.  Reorder marks to canonical order:
 632    *
 633    * Adjacent nukta and halant or nukta and vedic sign are always repositioned
 634    * if necessary, so that the nukta is first.
 635    *
 636    * IMPLEMENTATION NOTES:
 637    *
 638    * We don&#39;t need to do this: the normalize() routine already did this for us.
 639    */
 640 
 641 
 642   /* Reorder characters */
 643 
 644   for (unsigned int i = start; i &lt; base; i++)
 645     info[i].indic_position() = MIN (POS_PRE_C, (indic_position_t) info[i].indic_position());
 646 
 647   if (base &lt; end)
 648     info[base].indic_position() = POS_BASE_C;
 649 
 650   /* Mark final consonants.  A final consonant is one appearing after a matra.
 651    * Happens in Sinhala. */
 652   for (unsigned int i = base + 1; i &lt; end; i++)
 653     if (info[i].indic_category() == OT_M) {
 654       for (unsigned int j = i + 1; j &lt; end; j++)
 655         if (is_consonant (info[j])) {
 656          info[j].indic_position() = POS_FINAL_C;
 657          break;
 658        }
 659       break;
 660     }
 661 
 662   /* Handle beginning Ra */
 663   if (has_reph)
 664     info[start].indic_position() = POS_RA_TO_BECOME_REPH;
 665 
 666   /* For old-style Indic script tags, move the first post-base Halant after
 667    * last consonant.
 668    *
 669    * Reports suggest that in some scripts Uniscribe does this only if there
<a name="24" id="anc24"></a><span class="line-modified"> 670    * is *not* a Halant after last consonant already (eg. Kannada), while it</span>
<span class="line-modified"> 671    * does it unconditionally in other scripts (eg. Malayalam, Bengali).  We</span>
<span class="line-modified"> 672    * don&#39;t currently know about other scripts, so we whitelist Malayalam and</span>
<span class="line-modified"> 673    * Bengali for now.</span>
 674    *
 675    * Kannada test case:
 676    * U+0C9A,U+0CCD,U+0C9A,U+0CCD
 677    * With some versions of Lohit Kannada.
 678    * https://bugs.freedesktop.org/show_bug.cgi?id=59118
 679    *
 680    * Malayalam test case:
 681    * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D
 682    * With lohit-ttf-20121122/Lohit-Malayalam.ttf
 683    *
<a name="25" id="anc25"></a><span class="line-modified"> 684    * Bengali test case</span>
 685    * U+0998,U+09CD,U+09AF,U+09CD
 686    * With Windows XP vrinda.ttf
 687    * https://github.com/harfbuzz/harfbuzz/issues/1073
<a name="26" id="anc26"></a>




 688    */
 689   if (indic_plan-&gt;is_old_spec)
 690   {
<a name="27" id="anc27"></a><span class="line-modified"> 691     bool disallow_double_halants = buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp;</span>
<span class="line-removed"> 692                                    buffer-&gt;props.script != HB_SCRIPT_BENGALI;</span>
 693     for (unsigned int i = base + 1; i &lt; end; i++)
 694       if (info[i].indic_category() == OT_H)
 695       {
 696         unsigned int j;
 697         for (j = end - 1; j &gt; i; j--)
 698           if (is_consonant (info[j]) ||
 699               (disallow_double_halants &amp;&amp; info[j].indic_category() == OT_H))
 700             break;
 701         if (info[j].indic_category() != OT_H &amp;&amp; j &gt; i) {
 702           /* Move Halant to after last consonant. */
 703           hb_glyph_info_t t = info[i];
 704           memmove (&amp;info[i], &amp;info[i + 1], (j - i) * sizeof (info[0]));
 705           info[j] = t;
 706         }
 707         break;
 708       }
 709   }
 710 
 711   /* Attach misc marks to previous char to move with them. */
 712   {
 713     indic_position_t last_pos = POS_START;
 714     for (unsigned int i = start; i &lt; end; i++)
 715     {
<a name="28" id="anc28"></a><span class="line-modified"> 716       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_H))))</span>
 717       {
 718         info[i].indic_position() = last_pos;
 719         if (unlikely (info[i].indic_category() == OT_H &amp;&amp;
 720                       info[i].indic_position() == POS_PRE_M))
 721         {
 722           /*
 723            * Uniscribe doesn&#39;t move the Halant with Left Matra.
 724            * TEST: U+092B,U+093F,U+094DE
 725            * We follow.  This is important for the Sinhala
 726            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA
 727            * where U+0DD9 is a left matra and U+0DCA is the virama.
 728            * We don&#39;t want to move the virama with the left matra.
 729            * TEST: U+0D9A,U+0DDA
 730            */
 731           for (unsigned int j = i; j &gt; start; j--)
 732             if (info[j - 1].indic_position() != POS_PRE_M) {
 733               info[i].indic_position() = info[j - 1].indic_position();
 734               break;
 735             }
 736         }
 737       } else if (info[i].indic_position() != POS_SMVD) {
 738         last_pos = (indic_position_t) info[i].indic_position();
 739       }
 740     }
 741   }
 742   /* For post-base consonants let them own anything before them
 743    * since the last consonant or matra. */
 744   {
 745     unsigned int last = base;
 746     for (unsigned int i = base + 1; i &lt; end; i++)
 747       if (is_consonant (info[i]))
 748       {
 749         for (unsigned int j = last + 1; j &lt; i; j++)
 750           if (info[j].indic_position() &lt; POS_SMVD)
 751             info[j].indic_position() = info[i].indic_position();
 752         last = i;
 753       } else if (info[i].indic_category() == OT_M)
 754         last = i;
 755   }
 756 
 757 
 758   {
 759     /* Use syllable() for sort accounting temporarily. */
 760     unsigned int syllable = info[start].syllable();
 761     for (unsigned int i = start; i &lt; end; i++)
 762       info[i].syllable() = i - start;
 763 
 764     /* Sit tight, rock &#39;n roll! */
 765     hb_stable_sort (info + start, end - start, compare_indic_order);
 766     /* Find base again */
 767     base = end;
 768     for (unsigned int i = start; i &lt; end; i++)
 769       if (info[i].indic_position() == POS_BASE_C)
 770       {
 771         base = i;
 772         break;
 773       }
 774     /* Things are out-of-control for post base positions, they may shuffle
 775      * around like crazy.  In old-spec mode, we move halants around, so in
 776      * that case merge all clusters after base.  Otherwise, check the sort
 777      * order and merge as needed.
 778      * For pre-base stuff, we handle cluster issues in final reordering.
 779      *
 780      * We could use buffer-&gt;sort() for this, if there was no special
 781      * reordering of pre-base stuff happening later...
<a name="29" id="anc29"></a>

 782      */
<a name="30" id="anc30"></a><span class="line-modified"> 783     if (indic_plan-&gt;is_old_spec || end - base &gt; 127)</span>
 784       buffer-&gt;merge_clusters (base, end);
 785     else
 786     {
 787       /* Note!  syllable() is a one-byte field. */
 788       for (unsigned int i = base; i &lt; end; i++)
 789         if (info[i].syllable() != 255)
 790         {
 791           unsigned int max = i;
 792           unsigned int j = start + info[i].syllable();
 793           while (j != i)
 794           {
 795             max = MAX (max, j);
 796             unsigned int next = start + info[j].syllable();
 797             info[j].syllable() = 255; /* So we don&#39;t process j later again. */
 798             j = next;
 799           }
 800           if (i != max)
 801             buffer-&gt;merge_clusters (i, max + 1);
 802         }
 803     }
 804 
 805     /* Put syllable back in. */
 806     for (unsigned int i = start; i &lt; end; i++)
 807       info[i].syllable() = syllable;
 808   }
 809 
 810   /* Setup masks now */
 811 
 812   {
 813     hb_mask_t mask;
 814 
 815     /* Reph */
 816     for (unsigned int i = start; i &lt; end &amp;&amp; info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)
 817       info[i].mask |= indic_plan-&gt;mask_array[RPHF];
 818 
 819     /* Pre-base */
 820     mask = indic_plan-&gt;mask_array[HALF];
 821     if (!indic_plan-&gt;is_old_spec &amp;&amp;
 822         indic_plan-&gt;config-&gt;blwf_mode == BLWF_MODE_PRE_AND_POST)
 823       mask |= indic_plan-&gt;mask_array[BLWF];
 824     for (unsigned int i = start; i &lt; base; i++)
 825       info[i].mask  |= mask;
 826     /* Base */
 827     mask = 0;
 828     if (base &lt; end)
 829       info[base].mask |= mask;
 830     /* Post-base */
 831     mask = indic_plan-&gt;mask_array[BLWF] | indic_plan-&gt;mask_array[ABVF] | indic_plan-&gt;mask_array[PSTF];
 832     for (unsigned int i = base + 1; i &lt; end; i++)
 833       info[i].mask  |= mask;
 834   }
 835 
 836   if (indic_plan-&gt;is_old_spec &amp;&amp;
 837       buffer-&gt;props.script == HB_SCRIPT_DEVANAGARI)
 838   {
 839     /* Old-spec eye-lash Ra needs special handling.  From the
 840      * spec:
 841      *
 842      * &quot;The feature &#39;below-base form&#39; is applied to consonants
 843      * having below-base forms and following the base consonant.
 844      * The exception is vattu, which may appear below half forms
 845      * as well as below the base glyph. The feature &#39;below-base
 846      * form&#39; will be applied to all such occurrences of Ra as well.&quot;
 847      *
 848      * Test case: U+0924,U+094D,U+0930,U+094d,U+0915
 849      * with Sanskrit 2003 font.
 850      *
 851      * However, note that Ra,Halant,ZWJ is the correct way to
 852      * request eyelash form of Ra, so we wouldbn&#39;t inhibit it
 853      * in that sequence.
 854      *
 855      * Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915
 856      */
 857     for (unsigned int i = start; i + 1 &lt; base; i++)
 858       if (info[i  ].indic_category() == OT_Ra &amp;&amp;
 859           info[i+1].indic_category() == OT_H  &amp;&amp;
 860           (i + 2 == base ||
 861            info[i+2].indic_category() != OT_ZWJ))
 862       {
 863         info[i  ].mask |= indic_plan-&gt;mask_array[BLWF];
 864         info[i+1].mask |= indic_plan-&gt;mask_array[BLWF];
 865       }
 866   }
 867 
 868   unsigned int pref_len = 2;
 869   if (indic_plan-&gt;mask_array[PREF] &amp;&amp; base + pref_len &lt; end)
 870   {
 871     /* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. */
 872     for (unsigned int i = base + 1; i + pref_len - 1 &lt; end; i++) {
 873       hb_codepoint_t glyphs[2];
 874       for (unsigned int j = 0; j &lt; pref_len; j++)
 875         glyphs[j] = info[i + j].codepoint;
 876       if (indic_plan-&gt;pref.would_substitute (glyphs, pref_len, face))
 877       {
 878         for (unsigned int j = 0; j &lt; pref_len; j++)
 879           info[i++].mask |= indic_plan-&gt;mask_array[PREF];
 880         break;
 881       }
 882     }
 883   }
 884 
 885   /* Apply ZWJ/ZWNJ effects */
 886   for (unsigned int i = start + 1; i &lt; end; i++)
 887     if (is_joiner (info[i])) {
 888       bool non_joiner = info[i].indic_category() == OT_ZWNJ;
 889       unsigned int j = i;
 890 
 891       do {
 892         j--;
 893 
 894         /* ZWJ/ZWNJ should disable CJCT.  They do that by simply
 895          * being there, since we don&#39;t skip them for the CJCT
 896          * feature (ie. F_MANUAL_ZWJ) */
 897 
 898         /* A ZWNJ disables HALF. */
 899         if (non_joiner)
 900           info[j].mask &amp;= ~indic_plan-&gt;mask_array[HALF];
 901 
 902       } while (j &gt; start &amp;&amp; !is_consonant (info[j]));
 903     }
 904 }
 905 
 906 static void
 907 initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
 908                                        hb_face_t *face,
 909                                        hb_buffer_t *buffer,
 910                                        unsigned int start, unsigned int end)
 911 {
<a name="31" id="anc31"></a>

 912   /* We treat placeholder/dotted-circle as if they are consonants, so we
 913    * should just chain.  Only if not in compatibility mode that is... */
 914 
<a name="32" id="anc32"></a><span class="line-modified"> 915   if (hb_options ().uniscribe_bug_compatible)</span>
 916   {
 917     /* For dotted-circle, this is what Uniscribe does:
 918      * If dotted-circle is the last glyph, it just does nothing.
 919      * Ie. It doesn&#39;t form Reph. */
 920     if (buffer-&gt;info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
 921       return;
 922   }
 923 
 924   initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 925 }
 926 
 927 static void
 928 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
 929                              hb_face_t *face,
 930                              hb_buffer_t *buffer,
 931                              unsigned int start, unsigned int end)
 932 {
 933   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
 934   switch (syllable_type)
 935   {
 936     case vowel_syllable: /* We made the vowels look like consonants.  So let&#39;s call the consonant logic! */
 937     case consonant_syllable:
 938      initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 939      break;
 940 
 941     case broken_cluster: /* We already inserted dotted-circles, so just call the standalone_cluster. */
 942     case standalone_cluster:
 943      initial_reordering_standalone_cluster (plan, face, buffer, start, end);
 944      break;
 945 
 946     case symbol_cluster:
 947     case non_indic_cluster:
 948       break;
 949   }
 950 }
 951 
 952 static inline void
 953 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
 954                        hb_font_t *font,
 955                        hb_buffer_t *buffer)
 956 {
<a name="33" id="anc33"></a><span class="line-modified"> 957   /* Note: This loop is extra overhead, but should not be measurable. */</span>

 958   bool has_broken_syllables = false;
 959   unsigned int count = buffer-&gt;len;
 960   hb_glyph_info_t *info = buffer-&gt;info;
 961   for (unsigned int i = 0; i &lt; count; i++)
 962     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
 963     {
 964       has_broken_syllables = true;
 965       break;
 966     }
 967   if (likely (!has_broken_syllables))
 968     return;
 969 
 970 
 971   hb_codepoint_t dottedcircle_glyph;
 972   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
 973     return;
 974 
 975   hb_glyph_info_t dottedcircle = {0};
 976   dottedcircle.codepoint = 0x25CCu;
 977   set_indic_properties (dottedcircle);
 978   dottedcircle.codepoint = dottedcircle_glyph;
 979 
 980   buffer-&gt;clear_output ();
 981 
 982   buffer-&gt;idx = 0;
 983   unsigned int last_syllable = 0;
 984   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
 985   {
 986     unsigned int syllable = buffer-&gt;cur().syllable();
 987     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
 988     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
 989     {
 990       last_syllable = syllable;
 991 
 992       hb_glyph_info_t ginfo = dottedcircle;
 993       ginfo.cluster = buffer-&gt;cur().cluster;
 994       ginfo.mask = buffer-&gt;cur().mask;
 995       ginfo.syllable() = buffer-&gt;cur().syllable();
 996       /* TODO Set glyph_props? */
 997 
 998       /* Insert dottedcircle after possible Repha. */
 999       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
1000              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
1001              buffer-&gt;cur().indic_category() == OT_Repha)
1002         buffer-&gt;next_glyph ();
1003 
1004       buffer-&gt;output_info (ginfo);
1005     }
1006     else
1007       buffer-&gt;next_glyph ();
1008   }
<a name="34" id="anc34"></a><span class="line-removed">1009 </span>
1010   buffer-&gt;swap_buffers ();
1011 }
1012 
1013 static void
1014 initial_reordering (const hb_ot_shape_plan_t *plan,
1015                     hb_font_t *font,
1016                     hb_buffer_t *buffer)
1017 {
1018   update_consonant_positions (plan, font, buffer);
1019   insert_dotted_circles (plan, font, buffer);
1020 
1021   foreach_syllable (buffer, start, end)
1022     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
1023 }
1024 
1025 static void
1026 final_reordering_syllable (const hb_ot_shape_plan_t *plan,
1027                            hb_buffer_t *buffer,
1028                            unsigned int start, unsigned int end)
1029 {
1030   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
1031   hb_glyph_info_t *info = buffer-&gt;info;
1032 
1033 
1034   /* This function relies heavily on halant glyphs.  Lots of ligation
1035    * and possibly multiple substitutions happened prior to this
1036    * phase, and that might have messed up our properties.  Recover
1037    * from a particular case of that where we&#39;re fairly sure that a
1038    * class of OT_H is desired but has been lost. */
<a name="35" id="anc35"></a><span class="line-modified">1039   if (indic_plan-&gt;virama_glyph)</span>



1040   {
<a name="36" id="anc36"></a><span class="line-removed">1041     unsigned int virama_glyph = indic_plan-&gt;virama_glyph;</span>
1042     for (unsigned int i = start; i &lt; end; i++)
1043       if (info[i].codepoint == virama_glyph &amp;&amp;
1044           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;
1045           _hb_glyph_info_multiplied (&amp;info[i]))
1046       {
1047         /* This will make sure that this glyph passes is_halant() test. */
1048         info[i].indic_category() = OT_H;
1049         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);
1050       }
1051   }
1052 
1053 
1054   /* 4. Final reordering:
1055    *
1056    * After the localized forms and basic shaping forms GSUB features have been
1057    * applied (see below), the shaping engine performs some final glyph
1058    * reordering before applying all the remaining font features to the entire
1059    * syllable.
1060    */
1061 
1062   bool try_pref = !!indic_plan-&gt;mask_array[PREF];
1063 
1064   /* Find base again */
1065   unsigned int base;
1066   for (base = start; base &lt; end; base++)
1067     if (info[base].indic_position() &gt;= POS_BASE_C)
1068     {
1069       if (try_pref &amp;&amp; base + 1 &lt; end)
1070       {
1071         for (unsigned int i = base + 1; i &lt; end; i++)
1072           if ((info[i].mask &amp; indic_plan-&gt;mask_array[PREF]) != 0)
1073           {
1074             if (!(_hb_glyph_info_substituted (&amp;info[i]) &amp;&amp;
1075                   _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i])))
1076             {
1077               /* Ok, this was a &#39;pref&#39; candidate but didn&#39;t form any.
1078                * Base is around here... */
1079               base = i;
1080               while (base &lt; end &amp;&amp; is_halant (info[base]))
1081                 base++;
1082               info[base].indic_position() = POS_BASE_C;
1083 
1084               try_pref = false;
1085             }
1086             break;
1087           }
1088       }
1089       /* For Malayalam, skip over unformed below- (but NOT post-) forms. */
1090       if (buffer-&gt;props.script == HB_SCRIPT_MALAYALAM)
1091       {
1092         for (unsigned int i = base + 1; i &lt; end; i++)
1093         {
1094           while (i &lt; end &amp;&amp; is_joiner (info[i]))
1095             i++;
1096           if (i == end || !is_halant (info[i]))
1097             break;
1098           i++; /* Skip halant. */
1099           while (i &lt; end &amp;&amp; is_joiner (info[i]))
1100             i++;
1101           if (i &lt; end &amp;&amp; is_consonant (info[i]) &amp;&amp; info[i].indic_position() == POS_BELOW_C)
1102           {
1103             base = i;
1104             info[base].indic_position() = POS_BASE_C;
1105           }
1106         }
1107       }
1108 
1109       if (start &lt; base &amp;&amp; info[base].indic_position() &gt; POS_BASE_C)
1110         base--;
1111       break;
1112     }
1113   if (base == end &amp;&amp; start &lt; base &amp;&amp;
1114       is_one_of (info[base - 1], FLAG (OT_ZWJ)))
1115     base--;
1116   if (base &lt; end)
1117     while (start &lt; base &amp;&amp;
1118            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))
1119       base--;
1120 
1121 
1122   /*   o Reorder matras:
1123    *
1124    *     If a pre-base matra character had been reordered before applying basic
1125    *     features, the glyph can be moved closer to the main consonant based on
1126    *     whether half-forms had been formed. Actual position for the matra is
1127    *     defined as âafter last standalone halant glyph, after initial matra
1128    *     position and before the main consonantâ. If ZWJ or ZWNJ follow this
1129    *     halant, position is moved after it.
<a name="37" id="anc37"></a>

















1130    */
1131 
1132   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */
1133   {
1134     /* If we lost track of base, alas, position before last thingy. */
1135     unsigned int new_pos = base == end ? base - 2 : base - 1;
1136 
1137     /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1138      * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1139      * We want to position matra after them.
1140      */
1141     if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1142     {
<a name="38" id="anc38"></a>
1143       while (new_pos &gt; start &amp;&amp;
1144              !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))
1145         new_pos--;
1146 
1147       /* If we found no Halant we are done.
1148        * Otherwise only proceed if the Halant does
1149        * not belong to the Matra itself! */
1150       if (is_halant (info[new_pos]) &amp;&amp;
1151           info[new_pos].indic_position() != POS_PRE_M)
1152       {
<a name="39" id="anc39"></a>
1153         /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1154         if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))
1155           new_pos++;
<a name="40" id="anc40"></a>
















1156       }
1157       else
1158         new_pos = start; /* No move. */
1159     }
1160 
1161     if (start &lt; new_pos &amp;&amp; info[new_pos].indic_position () != POS_PRE_M)
1162     {
1163       /* Now go see if there&#39;s actually any matras... */
1164       for (unsigned int i = new_pos; i &gt; start; i--)
1165         if (info[i - 1].indic_position () == POS_PRE_M)
1166         {
1167           unsigned int old_pos = i - 1;
1168           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */
1169             base--;
1170 
1171           hb_glyph_info_t tmp = info[old_pos];
1172           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));
1173           info[new_pos] = tmp;
1174 
1175           /* Note: this merge_clusters() is intentionally *after* the reordering.
1176            * Indic matra reordering is special and tricky... */
1177           buffer-&gt;merge_clusters (new_pos, MIN (end, base + 1));
1178 
1179           new_pos--;
1180         }
1181     } else {
1182       for (unsigned int i = start; i &lt; base; i++)
1183         if (info[i].indic_position () == POS_PRE_M) {
1184           buffer-&gt;merge_clusters (i, MIN (end, base + 1));
1185           break;
1186         }
1187     }
1188   }
1189 
1190 
1191   /*   o Reorder reph:
1192    *
1193    *     Rephâs original position is always at the beginning of the syllable,
1194    *     (i.e. it is not reordered at the character reordering stage). However,
1195    *     it will be reordered according to the basic-forms shaping results.
1196    *     Possible positions for reph, depending on the script, are; after main,
1197    *     before post-base consonant forms, and after post-base consonant forms.
1198    */
1199 
1200   /* Two cases:
1201    *
1202    * - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then
1203    *   we should only move it if the sequence ligated to the repha form.
1204    *
1205    * - If repha is encoded separately and in the logical position, we should only
1206    *   move it if it did NOT ligate.  If it ligated, it&#39;s probably the font trying
1207    *   to make it work without the reordering.
1208    */
1209   if (start + 1 &lt; end &amp;&amp;
1210       info[start].indic_position() == POS_RA_TO_BECOME_REPH &amp;&amp;
1211       ((info[start].indic_category() == OT_Repha) ^
1212        _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[start])))
1213   {
1214     unsigned int new_reph_pos;
1215     reph_position_t reph_pos = indic_plan-&gt;config-&gt;reph_pos;
1216 
1217     /*       1. If reph should be positioned after post-base consonant forms,
1218      *          proceed to step 5.
1219      */
1220     if (reph_pos == REPH_POS_AFTER_POST)
1221     {
1222       goto reph_step_5;
1223     }
1224 
1225     /*       2. If the reph repositioning class is not after post-base: target
1226      *          position is after the first explicit halant glyph between the
1227      *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ
1228      *          are following this halant, position is moved after it. If such
1229      *          position is found, this is the target position. Otherwise,
1230      *          proceed to the next step.
1231      *
1232      *          Note: in old-implementation fonts, where classifications were
1233      *          fixed in shaping engine, there was no case where reph position
1234      *          will be found on this step.
1235      */
1236     {
1237       new_reph_pos = start + 1;
1238       while (new_reph_pos &lt; base &amp;&amp; !is_halant (info[new_reph_pos]))
1239         new_reph_pos++;
1240 
1241       if (new_reph_pos &lt; base &amp;&amp; is_halant (info[new_reph_pos]))
1242       {
1243         /* -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */
1244         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1245           new_reph_pos++;
1246         goto reph_move;
1247       }
1248     }
1249 
1250     /*       3. If reph should be repositioned after the main consonant: find the
1251      *          first consonant not ligated with main, or find the first
1252      *          consonant that is not a potential pre-base-reordering Ra.
1253      */
1254     if (reph_pos == REPH_POS_AFTER_MAIN)
1255     {
1256       new_reph_pos = base;
1257       while (new_reph_pos + 1 &lt; end &amp;&amp; info[new_reph_pos + 1].indic_position() &lt;= POS_AFTER_MAIN)
1258         new_reph_pos++;
1259       if (new_reph_pos &lt; end)
1260         goto reph_move;
1261     }
1262 
1263     /*       4. If reph should be positioned before post-base consonant, find
1264      *          first post-base classified consonant not ligated with main. If no
1265      *          consonant is found, the target position should be before the
1266      *          first matra, syllable modifier sign or vedic sign.
1267      */
1268     /* This is our take on what step 4 is trying to say (and failing, BADLY). */
1269     if (reph_pos == REPH_POS_AFTER_SUB)
1270     {
1271       new_reph_pos = base;
1272       while (new_reph_pos + 1 &lt; end &amp;&amp;
1273              !( FLAG_UNSAFE (info[new_reph_pos + 1].indic_position()) &amp; (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))
1274         new_reph_pos++;
1275       if (new_reph_pos &lt; end)
1276         goto reph_move;
1277     }
1278 
1279     /*       5. If no consonant is found in steps 3 or 4, move reph to a position
1280      *          immediately before the first post-base matra, syllable modifier
1281      *          sign or vedic sign that has a reordering class after the intended
1282      *          reph position. For example, if the reordering position for reph
1283      *          is post-main, it will skip above-base matras that also have a
1284      *          post-main position.
1285      */
1286     reph_step_5:
1287     {
1288       /* Copied from step 2. */
1289       new_reph_pos = start + 1;
1290       while (new_reph_pos &lt; base &amp;&amp; !is_halant (info[new_reph_pos]))
1291         new_reph_pos++;
1292 
1293       if (new_reph_pos &lt; base &amp;&amp; is_halant (info[new_reph_pos]))
1294       {
1295         /* -&gt;If ZWJ or ZWNJ are following this halant, position is moved after it. */
1296         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1297           new_reph_pos++;
1298         goto reph_move;
1299       }
1300     }
1301 
1302     /*       6. Otherwise, reorder reph to the end of the syllable.
1303      */
1304     {
1305       new_reph_pos = end - 1;
1306       while (new_reph_pos &gt; start &amp;&amp; info[new_reph_pos].indic_position() == POS_SMVD)
1307         new_reph_pos--;
1308 
1309       /*
1310        * If the Reph is to be ending up after a Matra,Halant sequence,
1311        * position it before that Halant so it can interact with the Matra.
1312        * However, if it&#39;s a plain Consonant,Halant we shouldn&#39;t do that.
1313        * Uniscribe doesn&#39;t do this.
1314        * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
1315        */
<a name="41" id="anc41"></a><span class="line-modified">1316       if (!hb_options ().uniscribe_bug_compatible &amp;&amp;</span>
1317           unlikely (is_halant (info[new_reph_pos]))) {
1318         for (unsigned int i = base + 1; i &lt; new_reph_pos; i++)
1319           if (info[i].indic_category() == OT_M) {
1320             /* Ok, got it. */
1321             new_reph_pos--;
1322           }
1323       }
1324       goto reph_move;
1325     }
1326 
1327     reph_move:
1328     {
1329       /* Move */
1330       buffer-&gt;merge_clusters (start, new_reph_pos + 1);
1331       hb_glyph_info_t reph = info[start];
1332       memmove (&amp;info[start], &amp;info[start + 1], (new_reph_pos - start) * sizeof (info[0]));
1333       info[new_reph_pos] = reph;
1334 
1335       if (start &lt; base &amp;&amp; base &lt;= new_reph_pos)
1336         base--;
1337     }
1338   }
1339 
1340 
1341   /*   o Reorder pre-base-reordering consonants:
1342    *
1343    *     If a pre-base-reordering consonant is found, reorder it according to
1344    *     the following rules:
1345    */
1346 
1347   if (try_pref &amp;&amp; base + 1 &lt; end) /* Otherwise there can&#39;t be any pre-base-reordering Ra. */
1348   {
1349     for (unsigned int i = base + 1; i &lt; end; i++)
1350       if ((info[i].mask &amp; indic_plan-&gt;mask_array[PREF]) != 0)
1351       {
1352         /*       1. Only reorder a glyph produced by substitution during application
1353          *          of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with
1354          *          the feature generally but block it in certain contexts.)
1355          */
1356         /* Note: We just check that something got substituted.  We don&#39;t check that
1357          * the &lt;pref&gt; feature actually did it...
1358          *
1359          * Reorder pref only if it ligated. */
1360         if (_hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i]))
1361         {
1362           /*
1363            *       2. Try to find a target position the same way as for pre-base matra.
1364            *          If it is found, reorder pre-base consonant glyph.
1365            *
1366            *       3. If position is not found, reorder immediately before main
1367            *          consonant.
1368            */
1369 
1370           unsigned int new_pos = base;
1371           /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1372            * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1373            * We want to position matra after them.
1374            */
1375           if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1376           {
1377             while (new_pos &gt; start &amp;&amp;
1378                    !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_H))))
1379               new_pos--;
1380           }
1381 
1382           if (new_pos &gt; start &amp;&amp; is_halant (info[new_pos - 1]))
1383           {
1384             /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1385             if (new_pos &lt; end &amp;&amp; is_joiner (info[new_pos]))
1386               new_pos++;
1387           }
1388 
1389           {
1390             unsigned int old_pos = i;
1391 
1392             buffer-&gt;merge_clusters (new_pos, old_pos + 1);
1393             hb_glyph_info_t tmp = info[old_pos];
1394             memmove (&amp;info[new_pos + 1], &amp;info[new_pos], (old_pos - new_pos) * sizeof (info[0]));
1395             info[new_pos] = tmp;
1396 
1397             if (new_pos &lt;= base &amp;&amp; base &lt; old_pos)
1398               base++;
1399           }
1400         }
1401 
1402         break;
1403       }
1404   }
1405 
1406 
1407   /* Apply &#39;init&#39; to the Left Matra if it&#39;s a word start. */
1408   if (info[start].indic_position () == POS_PRE_M)
1409   {
1410     if (!start ||
1411         !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&amp;info[start - 1])) &amp;
1412          FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
1413       info[start].mask |= indic_plan-&gt;mask_array[INIT];
1414     else
1415       buffer-&gt;unsafe_to_break (start - 1, start + 1);
1416   }
1417 
1418 
1419   /*
1420    * Finish off the clusters and go home!
1421    */
<a name="42" id="anc42"></a><span class="line-modified">1422   if (hb_options ().uniscribe_bug_compatible)</span>
1423   {
1424     switch ((hb_tag_t) plan-&gt;props.script)
1425     {
1426       case HB_SCRIPT_TAMIL:
1427       case HB_SCRIPT_SINHALA:
1428         break;
1429 
1430       default:
1431         /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.
1432          * This means, half forms are submerged into the main consonant&#39;s cluster.
1433          * This is unnecessary, and makes cursor positioning harder, but that&#39;s what
1434          * Uniscribe does. */
1435         buffer-&gt;merge_clusters (start, end);
1436         break;
1437     }
1438   }
1439 }
1440 
1441 
1442 static void
1443 final_reordering (const hb_ot_shape_plan_t *plan,
1444                   hb_font_t *font HB_UNUSED,
1445                   hb_buffer_t *buffer)
1446 {
1447   unsigned int count = buffer-&gt;len;
1448   if (unlikely (!count)) return;
1449 
1450   foreach_syllable (buffer, start, end)
1451     final_reordering_syllable (plan, buffer, start, end);
1452 
1453   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
1454   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
1455 }
1456 
1457 
1458 static void
1459 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
1460                  hb_font_t *font HB_UNUSED,
1461                  hb_buffer_t *buffer)
1462 {
1463   hb_glyph_info_t *info = buffer-&gt;info;
1464   unsigned int count = buffer-&gt;len;
1465   for (unsigned int i = 0; i &lt; count; i++)
1466     info[i].syllable() = 0;
1467 }
1468 
1469 
<a name="43" id="anc43"></a>







1470 static bool
1471 decompose_indic (const hb_ot_shape_normalize_context_t *c,
1472                  hb_codepoint_t  ab,
1473                  hb_codepoint_t *a,
1474                  hb_codepoint_t *b)
1475 {
1476   switch (ab)
1477   {
1478     /* Don&#39;t decompose these. */
1479     case 0x0931u  : return false; /* DEVANAGARI LETTER RRA */
1480     // https://github.com/harfbuzz/harfbuzz/issues/779
1481     case 0x09DCu  : return false; /* BENGALI LETTER RRA */
1482     case 0x09DDu  : return false; /* BENGALI LETTER RHA */
1483     case 0x0B94u  : return false; /* TAMIL LETTER AU */
1484 
1485 
1486     /*
1487      * Decompose split matras that don&#39;t have Unicode decompositions.
1488      */
1489 
1490 #if 0
1491     /* Gujarati */
1492     /* This one has no decomposition in Unicode, but needs no decomposition either. */
1493     /* case 0x0AC9u  : return false; */
1494 
1495     /* Oriya */
1496     case 0x0B57u  : *a = no decomp, -&gt; RIGHT; return true;
1497 #endif
1498   }
1499 
1500   if ((ab == 0x0DDAu || hb_in_range&lt;hb_codepoint_t&gt; (ab, 0x0DDCu, 0x0DDEu)))
1501   {
1502     /*
1503      * Sinhala split matras...  Let the fun begin.
1504      *
1505      * These four characters have Unicode decompositions.  However, Uniscribe
1506      * decomposes them &quot;Khmer-style&quot;, that is, it uses the character itself to
1507      * get the second half.  The first half of all four decompositions is always
1508      * U+0DD9.
1509      *
1510      * Now, there are buggy fonts, namely, the widely used lklug.ttf, that are
1511      * broken with Uniscribe.  But we need to support them.  As such, we only
1512      * do the Uniscribe-style decomposition if the character is transformed into
1513      * its &quot;sec.half&quot; form by the &#39;pstf&#39; feature.  Otherwise, we fall back to
1514      * Unicode decomposition.
1515      *
1516      * Note that we can&#39;t unconditionally use Unicode decomposition.  That would
1517      * break some other fonts, that are designed to work with Uniscribe, and
1518      * don&#39;t have positioning features for the Unicode-style decomposition.
1519      *
1520      * Argh...
1521      *
1522      * The Uniscribe behavior is now documented in the newly published Sinhala
1523      * spec in 2012:
1524      *
1525      *   https://docs.microsoft.com/en-us/typography/script-development/sinhala#shaping
1526      */
1527 
1528     const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) c-&gt;plan-&gt;data;
1529 
1530     hb_codepoint_t glyph;
1531 
1532     if (hb_options ().uniscribe_bug_compatible ||
1533         (c-&gt;font-&gt;get_nominal_glyph (ab, &amp;glyph) &amp;&amp;
1534          indic_plan-&gt;pstf.would_substitute (&amp;glyph, 1, c-&gt;font-&gt;face)))
1535     {
1536       /* Ok, safe to use Uniscribe-style decomposition. */
1537       *a = 0x0DD9u;
1538       *b = ab;
1539       return true;
1540     }
1541   }
1542 
1543   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);
1544 }
1545 
1546 static bool
1547 compose_indic (const hb_ot_shape_normalize_context_t *c,
1548                hb_codepoint_t  a,
1549                hb_codepoint_t  b,
1550                hb_codepoint_t *ab)
1551 {
1552   /* Avoid recomposing split matras. */
1553   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
1554     return false;
1555 
1556   /* Composition-exclusion exceptions that we want to recompose. */
1557   if (a == 0x09AFu &amp;&amp; b == 0x09BCu) { *ab = 0x09DFu; return true; }
1558 
1559   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
1560 }
1561 
1562 
1563 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =
1564 {
1565   collect_features_indic,
1566   override_features_indic,
1567   data_create_indic,
1568   data_destroy_indic,
<a name="44" id="anc44"></a><span class="line-modified">1569   nullptr, /* preprocess_text */</span>
1570   nullptr, /* postprocess_glyphs */
1571   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
1572   decompose_indic,
1573   compose_indic,
1574   setup_masks_indic,
<a name="45" id="anc45"></a><span class="line-modified">1575   nullptr, /* disable_otl */</span>
1576   nullptr, /* reorder_marks */
1577   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
1578   false, /* fallback_position */
1579 };
<a name="46" id="anc46"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="46" type="hidden" />
</body>
</html>
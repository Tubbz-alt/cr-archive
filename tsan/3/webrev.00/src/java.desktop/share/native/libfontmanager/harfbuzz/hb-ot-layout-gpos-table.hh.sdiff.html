<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-gdef-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gsub-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
  30 #define HB_OT_LAYOUT_GPOS_TABLE_HH
  31 
<span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 
  38 /* buffer **position** var allocations */
  39 #define attach_chain() var.i16[0] /* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. */
  40 #define attach_type() var.u8[2] /* attachment type */
  41 /* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. */
  42 
  43 enum attach_type_t {
  44   ATTACH_TYPE_NONE      = 0X00,
  45 
  46   /* Each attachment should be either a mark or a cursive; can&#39;t be both. */
  47   ATTACH_TYPE_MARK      = 0X01,
  48   ATTACH_TYPE_CURSIVE   = 0X02,
  49 };
  50 
  51 
  52 /* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
  53 
  54 typedef HBUINT16 Value;
  55 
<span class="line-modified">  56 typedef Value ValueRecord[VAR];</span>
  57 
  58 struct ValueFormat : HBUINT16
  59 {
  60   enum Flags {
  61     xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
  62     yPlacement  = 0x0002u,      /* Includes vertical adjustment for placement */
  63     xAdvance    = 0x0004u,      /* Includes horizontal adjustment for advance */
  64     yAdvance    = 0x0008u,      /* Includes vertical adjustment for advance */
  65     xPlaDevice  = 0x0010u,      /* Includes horizontal Device table for placement */
  66     yPlaDevice  = 0x0020u,      /* Includes vertical Device table for placement */
  67     xAdvDevice  = 0x0040u,      /* Includes horizontal Device table for advance */
  68     yAdvDevice  = 0x0080u,      /* Includes vertical Device table for advance */
  69     ignored     = 0x0F00u,      /* Was used in TrueType Open for MM fonts */
  70     reserved    = 0xF000u,      /* For future use */
  71 
  72     devices     = 0x00F0u       /* Mask for having any Device table */
  73   };
  74 
  75 /* All fields are options.  Only those available advance the value pointer. */
  76 #if 0
  77   HBINT16               xPlacement;             /* Horizontal adjustment for
  78                                          * placement--in design units */
  79   HBINT16               yPlacement;             /* Vertical adjustment for
  80                                          * placement--in design units */
  81   HBINT16               xAdvance;               /* Horizontal adjustment for
  82                                          * advance--in design units (only used
  83                                          * for horizontal writing) */
  84   HBINT16               yAdvance;               /* Vertical adjustment for advance--in
  85                                          * design units (only used for vertical
  86                                          * writing) */
<span class="line-modified">  87   Offset        xPlaDevice;             /* Offset to Device table for</span>
  88                                          * horizontal placement--measured from
  89                                          * beginning of PosTable (may be NULL) */
<span class="line-modified">  90   Offset        yPlaDevice;             /* Offset to Device table for vertical</span>
  91                                          * placement--measured from beginning
  92                                          * of PosTable (may be NULL) */
<span class="line-modified">  93   Offset        xAdvDevice;             /* Offset to Device table for</span>
  94                                          * horizontal advance--measured from
  95                                          * beginning of PosTable (may be NULL) */
<span class="line-modified">  96   Offset        yAdvDevice;             /* Offset to Device table for vertical</span>
  97                                          * advance--measured from beginning of
  98                                          * PosTable (may be NULL) */
  99 #endif
 100 
<span class="line-modified"> 101   inline unsigned int get_len (void) const</span>
<span class="line-modified"> 102   { return _hb_popcount ((unsigned int) *this); }</span>
<span class="line-removed"> 103   inline unsigned int get_size (void) const</span>
<span class="line-removed"> 104   { return get_len () * Value::static_size; }</span>
 105 
<span class="line-modified"> 106   void apply_value (hb_ot_apply_context_t   *c,</span>
 107                     const void           *base,
 108                     const Value          *values,
 109                     hb_glyph_position_t  &amp;glyph_pos) const
 110   {

 111     unsigned int format = *this;
<span class="line-modified"> 112     if (!format) return;</span>
 113 
 114     hb_font_t *font = c-&gt;font;
<span class="line-modified"> 115     hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction);</span>
 116 
<span class="line-modified"> 117     if (format &amp; xPlacement) glyph_pos.x_offset  += font-&gt;em_scale_x (get_short (values++));</span>
<span class="line-modified"> 118     if (format &amp; yPlacement) glyph_pos.y_offset  += font-&gt;em_scale_y (get_short (values++));</span>
 119     if (format &amp; xAdvance) {
<span class="line-modified"> 120       if (likely (horizontal)) glyph_pos.x_advance += font-&gt;em_scale_x (get_short (values));</span>
 121       values++;
 122     }
 123     /* y_advance values grow downward but font-space grows upward, hence negation */
 124     if (format &amp; yAdvance) {
<span class="line-modified"> 125       if (unlikely (!horizontal)) glyph_pos.y_advance -= font-&gt;em_scale_y (get_short (values));</span>
 126       values++;
 127     }
 128 
<span class="line-modified"> 129     if (!has_device ()) return;</span>
 130 
 131     bool use_x_device = font-&gt;x_ppem || font-&gt;num_coords;
 132     bool use_y_device = font-&gt;y_ppem || font-&gt;num_coords;
 133 
<span class="line-modified"> 134     if (!use_x_device &amp;&amp; !use_y_device) return;</span>
 135 
 136     const VariationStore &amp;store = c-&gt;var_store;
 137 
 138     /* pixel -&gt; fractional pixel */
 139     if (format &amp; xPlaDevice) {
<span class="line-modified"> 140       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values)).get_x_delta (font, store);</span>
 141       values++;
 142     }
 143     if (format &amp; yPlaDevice) {
<span class="line-modified"> 144       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values)).get_y_delta (font, store);</span>
 145       values++;
 146     }
 147     if (format &amp; xAdvDevice) {
<span class="line-modified"> 148       if (horizontal &amp;&amp; use_x_device) glyph_pos.x_advance += (base + get_device (values)).get_x_delta (font, store);</span>
 149       values++;
 150     }
 151     if (format &amp; yAdvDevice) {
 152       /* y_advance values grow downward but font-space grows upward, hence negation */
<span class="line-modified"> 153       if (!horizontal &amp;&amp; use_y_device) glyph_pos.y_advance -= (base + get_device (values)).get_y_delta (font, store);</span>
 154       values++;
 155     }

 156   }
 157 
 158   private:
<span class="line-modified"> 159   inline bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
 160   {
 161     unsigned int format = *this;
 162 
 163     if (format &amp; xPlacement) values++;
 164     if (format &amp; yPlacement) values++;
 165     if (format &amp; xAdvance)   values++;
 166     if (format &amp; yAdvance)   values++;
 167 
 168     if ((format &amp; xPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 169     if ((format &amp; yPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 170     if ((format &amp; xAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 171     if ((format &amp; yAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 172 
 173     return true;
 174   }
 175 
<span class="line-modified"> 176   static inline OffsetTo&lt;Device&gt;&amp; get_device (Value* value)</span>
<span class="line-removed"> 177   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }</span>
<span class="line-removed"> 178   static inline const OffsetTo&lt;Device&gt;&amp; get_device (const Value* value)</span>
 179   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }





 180 
<span class="line-modified"> 181   static inline const HBINT16&amp; get_short (const Value* value)</span>
<span class="line-modified"> 182   { return *CastP&lt;HBINT16&gt; (value); }</span>



 183 
 184   public:
 185 
<span class="line-modified"> 186   inline bool has_device (void) const {</span>

 187     unsigned int format = *this;
 188     return (format &amp; devices) != 0;
 189   }
 190 
<span class="line-modified"> 191   inline bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
 192   {
 193     TRACE_SANITIZE (this);
 194     return_trace (c-&gt;check_range (values, get_size ()) &amp;&amp; (!has_device () || sanitize_value_devices (c, base, values)));
 195   }
 196 
<span class="line-modified"> 197   inline bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const</span>
 198   {
 199     TRACE_SANITIZE (this);
 200     unsigned int len = get_len ();
 201 
<span class="line-modified"> 202     if (!c-&gt;check_array (values, get_size (), count)) return_trace (false);</span>
 203 
 204     if (!has_device ()) return_trace (true);
 205 
 206     for (unsigned int i = 0; i &lt; count; i++) {
 207       if (!sanitize_value_devices (c, base, values))
 208         return_trace (false);
 209       values += len;
 210     }
 211 
 212     return_trace (true);
 213   }
 214 
 215   /* Just sanitize referenced Device tables.  Doesn&#39;t check the values themselves. */
<span class="line-modified"> 216   inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const</span>
 217   {
 218     TRACE_SANITIZE (this);
 219 
 220     if (!has_device ()) return_trace (true);
 221 
 222     for (unsigned int i = 0; i &lt; count; i++) {
 223       if (!sanitize_value_devices (c, base, values))
 224         return_trace (false);
 225       values += stride;
 226     }
 227 
 228     return_trace (true);
 229   }
 230 };
 231 
 232 
 233 struct AnchorFormat1
 234 {
<span class="line-modified"> 235   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified"> 236                           float *x, float *y) const</span>
 237   {
 238     hb_font_t *font = c-&gt;font;
 239     *x = font-&gt;em_fscale_x (xCoordinate);
 240     *y = font-&gt;em_fscale_y (yCoordinate);
 241   }
 242 
<span class="line-modified"> 243   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 244   {
 245     TRACE_SANITIZE (this);
 246     return_trace (c-&gt;check_struct (this));
 247   }
 248 
 249   protected:
 250   HBUINT16      format;                 /* Format identifier--format = 1 */
 251   FWORD         xCoordinate;            /* Horizontal value--in design units */
 252   FWORD         yCoordinate;            /* Vertical value--in design units */
 253   public:
 254   DEFINE_SIZE_STATIC (6);
 255 };
 256 
 257 struct AnchorFormat2
 258 {
<span class="line-modified"> 259   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 260                           float *x, float *y) const</span>
 261   {
 262     hb_font_t *font = c-&gt;font;
 263     unsigned int x_ppem = font-&gt;x_ppem;
 264     unsigned int y_ppem = font-&gt;y_ppem;
 265     hb_position_t cx = 0, cy = 0;
<span class="line-modified"> 266     hb_bool_t ret;</span>
 267 
 268     ret = (x_ppem || y_ppem) &amp;&amp;
<span class="line-modified"> 269            font-&gt;get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &amp;cx, &amp;cy);</span>
 270     *x = ret &amp;&amp; x_ppem ? cx : font-&gt;em_fscale_x (xCoordinate);
 271     *y = ret &amp;&amp; y_ppem ? cy : font-&gt;em_fscale_y (yCoordinate);
 272   }
 273 
<span class="line-modified"> 274   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 275   {
 276     TRACE_SANITIZE (this);
 277     return_trace (c-&gt;check_struct (this));
 278   }
 279 
 280   protected:
 281   HBUINT16      format;                 /* Format identifier--format = 2 */
 282   FWORD         xCoordinate;            /* Horizontal value--in design units */
 283   FWORD         yCoordinate;            /* Vertical value--in design units */
 284   HBUINT16      anchorPoint;            /* Index to glyph contour point */
 285   public:
 286   DEFINE_SIZE_STATIC (8);
 287 };
 288 
 289 struct AnchorFormat3
 290 {
<span class="line-modified"> 291   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified"> 292                           float *x, float *y) const</span>
 293   {
 294     hb_font_t *font = c-&gt;font;
 295     *x = font-&gt;em_fscale_x (xCoordinate);
 296     *y = font-&gt;em_fscale_y (yCoordinate);
 297 
 298     if (font-&gt;x_ppem || font-&gt;num_coords)
 299       *x += (this+xDeviceTable).get_x_delta (font, c-&gt;var_store);
 300     if (font-&gt;y_ppem || font-&gt;num_coords)
 301       *y += (this+yDeviceTable).get_y_delta (font, c-&gt;var_store);
 302   }
 303 
<span class="line-modified"> 304   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 305   {
 306     TRACE_SANITIZE (this);
 307     return_trace (c-&gt;check_struct (this) &amp;&amp; xDeviceTable.sanitize (c, this) &amp;&amp; yDeviceTable.sanitize (c, this));
 308   }
 309 
 310   protected:
 311   HBUINT16      format;                 /* Format identifier--format = 3 */
 312   FWORD         xCoordinate;            /* Horizontal value--in design units */
 313   FWORD         yCoordinate;            /* Vertical value--in design units */
 314   OffsetTo&lt;Device&gt;
 315                 xDeviceTable;           /* Offset to Device table for X
 316                                          * coordinate-- from beginning of
 317                                          * Anchor table (may be NULL) */
 318   OffsetTo&lt;Device&gt;
 319                 yDeviceTable;           /* Offset to Device table for Y
 320                                          * coordinate-- from beginning of
 321                                          * Anchor table (may be NULL) */
 322   public:
 323   DEFINE_SIZE_STATIC (10);
 324 };
 325 
 326 struct Anchor
 327 {
<span class="line-modified"> 328   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 329                           float *x, float *y) const</span>
 330   {
 331     *x = *y = 0;
 332     switch (u.format) {
 333     case 1: u.format1.get_anchor (c, glyph_id, x, y); return;
 334     case 2: u.format2.get_anchor (c, glyph_id, x, y); return;
 335     case 3: u.format3.get_anchor (c, glyph_id, x, y); return;
 336     default:                                          return;
 337     }
 338   }
 339 
<span class="line-modified"> 340   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 341   {
 342     TRACE_SANITIZE (this);
 343     if (!u.format.sanitize (c)) return_trace (false);
 344     switch (u.format) {
 345     case 1: return_trace (u.format1.sanitize (c));
 346     case 2: return_trace (u.format2.sanitize (c));
 347     case 3: return_trace (u.format3.sanitize (c));
 348     default:return_trace (true);
 349     }
 350   }
 351 
 352   protected:
 353   union {
 354   HBUINT16              format;         /* Format identifier */
 355   AnchorFormat1         format1;
 356   AnchorFormat2         format2;
 357   AnchorFormat3         format3;
 358   } u;
 359   public:
 360   DEFINE_SIZE_UNION (2, format);
 361 };
 362 
 363 
 364 struct AnchorMatrix
 365 {
<span class="line-modified"> 366   inline const Anchor&amp; get_anchor (unsigned int row, unsigned int col, unsigned int cols, bool *found) const {</span>


 367     *found = false;
 368     if (unlikely (row &gt;= rows || col &gt;= cols)) return Null(Anchor);
 369     *found = !matrixZ[row * cols + col].is_null ();
 370     return this+matrixZ[row * cols + col];
 371   }
 372 
<span class="line-modified"> 373   inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const</span>
 374   {
 375     TRACE_SANITIZE (this);
 376     if (!c-&gt;check_struct (this)) return_trace (false);
<span class="line-modified"> 377     if (unlikely (_hb_unsigned_int_mul_overflows (rows, cols))) return_trace (false);</span>
 378     unsigned int count = rows * cols;
<span class="line-modified"> 379     if (!c-&gt;check_array (matrixZ, matrixZ[0].static_size, count)) return_trace (false);</span>
 380     for (unsigned int i = 0; i &lt; count; i++)
 381       if (!matrixZ[i].sanitize (c, this)) return_trace (false);
 382     return_trace (true);
 383   }
 384 
 385   HBUINT16      rows;                   /* Number of rows */
 386   protected:
<span class="line-modified"> 387   OffsetTo&lt;Anchor&gt;</span>
<span class="line-modified"> 388                 matrixZ[VAR];           /* Matrix of offsets to Anchor tables--</span>
 389                                          * from beginning of AnchorMatrix table */
 390   public:
 391   DEFINE_SIZE_ARRAY (2, matrixZ);
 392 };
 393 
 394 
 395 struct MarkRecord
 396 {
 397   friend struct MarkArray;
 398 
<span class="line-modified"> 399   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 400   {
 401     TRACE_SANITIZE (this);
 402     return_trace (c-&gt;check_struct (this) &amp;&amp; markAnchor.sanitize (c, base));
 403   }
 404 
 405   protected:
 406   HBUINT16      klass;                  /* Class defined for this mark */
 407   OffsetTo&lt;Anchor&gt;
 408                 markAnchor;             /* Offset to Anchor table--from
 409                                          * beginning of MarkArray table */
 410   public:
 411   DEFINE_SIZE_STATIC (4);
 412 };
 413 
 414 struct MarkArray : ArrayOf&lt;MarkRecord&gt;  /* Array of MarkRecords--in Coverage order */
 415 {
<span class="line-modified"> 416   inline bool apply (hb_ot_apply_context_t *c,</span>
<span class="line-modified"> 417                      unsigned int mark_index, unsigned int glyph_index,</span>
<span class="line-modified"> 418                      const AnchorMatrix &amp;anchors, unsigned int class_count,</span>
<span class="line-modified"> 419                      unsigned int glyph_pos) const</span>
 420   {
 421     TRACE_APPLY (this);
 422     hb_buffer_t *buffer = c-&gt;buffer;
 423     const MarkRecord &amp;record = ArrayOf&lt;MarkRecord&gt;::operator[](mark_index);
 424     unsigned int mark_class = record.klass;
 425 
 426     const Anchor&amp; mark_anchor = this + record.markAnchor;
 427     bool found;
 428     const Anchor&amp; glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &amp;found);
 429     /* If this subtable doesn&#39;t have an anchor for this base and this class,
 430      * return false such that the subsequent subtables have a chance at it. */
 431     if (unlikely (!found)) return_trace (false);
 432 
 433     float mark_x, mark_y, base_x, base_y;
 434 
 435     buffer-&gt;unsafe_to_break (glyph_pos, buffer-&gt;idx);
 436     mark_anchor.get_anchor (c, buffer-&gt;cur().codepoint, &amp;mark_x, &amp;mark_y);
 437     glyph_anchor.get_anchor (c, buffer-&gt;info[glyph_pos].codepoint, &amp;base_x, &amp;base_y);
 438 
 439     hb_glyph_position_t &amp;o = buffer-&gt;cur_pos();
 440     o.x_offset = round (base_x - mark_x);
 441     o.y_offset = round (base_y - mark_y);
 442     o.attach_type() = ATTACH_TYPE_MARK;
 443     o.attach_chain() = (int) glyph_pos - (int) buffer-&gt;idx;
 444     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
 445 
 446     buffer-&gt;idx++;
 447     return_trace (true);
 448   }
 449 
<span class="line-modified"> 450   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 451   {
 452     TRACE_SANITIZE (this);
 453     return_trace (ArrayOf&lt;MarkRecord&gt;::sanitize (c, this));
 454   }
 455 };
 456 
 457 
 458 /* Lookups */
 459 
 460 struct SinglePosFormat1
 461 {
<span class="line-modified"> 462   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 463   {</span>
<span class="line-removed"> 464     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 465     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed"> 466   }</span>
 467 
<span class="line-modified"> 468   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified"> 469   {</span>
<span class="line-modified"> 470     return this+coverage;</span>
<span class="line-modified"> 471   }</span>
 472 
<span class="line-modified"> 473   inline bool apply (hb_ot_apply_context_t *c) const</span>
 474   {
 475     TRACE_APPLY (this);
 476     hb_buffer_t *buffer = c-&gt;buffer;
 477     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 478     if (likely (index == NOT_COVERED)) return_trace (false);
 479 
 480     valueFormat.apply_value (c, this, values, buffer-&gt;cur_pos());
 481 
 482     buffer-&gt;idx++;
 483     return_trace (true);
 484   }
 485 
<span class="line-modified"> 486   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 487   {
 488     TRACE_SANITIZE (this);
 489     return_trace (c-&gt;check_struct (this) &amp;&amp;
 490                   coverage.sanitize (c, this) &amp;&amp;
 491                   valueFormat.sanitize_value (c, this, values));
 492   }
 493 
 494   protected:
 495   HBUINT16      format;                 /* Format identifier--format = 1 */
 496   OffsetTo&lt;Coverage&gt;
 497                 coverage;               /* Offset to Coverage table--from
 498                                          * beginning of subtable */
 499   ValueFormat   valueFormat;            /* Defines the types of data in the
 500                                          * ValueRecord */
 501   ValueRecord   values;                 /* Defines positioning
 502                                          * value(s)--applied to all glyphs in
 503                                          * the Coverage table */
 504   public:
 505   DEFINE_SIZE_ARRAY (6, values);
 506 };
 507 
 508 struct SinglePosFormat2
 509 {
<span class="line-modified"> 510   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 511   {</span>
<span class="line-removed"> 512     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 513     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed"> 514   }</span>
 515 
<span class="line-modified"> 516   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified"> 517   {</span>
<span class="line-modified"> 518     return this+coverage;</span>
<span class="line-modified"> 519   }</span>
 520 
<span class="line-modified"> 521   inline bool apply (hb_ot_apply_context_t *c) const</span>
 522   {
 523     TRACE_APPLY (this);
 524     hb_buffer_t *buffer = c-&gt;buffer;
 525     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 526     if (likely (index == NOT_COVERED)) return_trace (false);
 527 
 528     if (likely (index &gt;= valueCount)) return_trace (false);
 529 
 530     valueFormat.apply_value (c, this,
 531                              &amp;values[index * valueFormat.get_len ()],
 532                              buffer-&gt;cur_pos());
 533 
 534     buffer-&gt;idx++;
 535     return_trace (true);
 536   }
 537 
<span class="line-modified"> 538   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 539   {
 540     TRACE_SANITIZE (this);
 541     return_trace (c-&gt;check_struct (this) &amp;&amp;
 542                   coverage.sanitize (c, this) &amp;&amp;
 543                   valueFormat.sanitize_values (c, this, values, valueCount));
 544   }
 545 
 546   protected:
 547   HBUINT16      format;                 /* Format identifier--format = 2 */
 548   OffsetTo&lt;Coverage&gt;
 549                 coverage;               /* Offset to Coverage table--from
 550                                          * beginning of subtable */
 551   ValueFormat   valueFormat;            /* Defines the types of data in the
 552                                          * ValueRecord */
 553   HBUINT16      valueCount;             /* Number of ValueRecords */
 554   ValueRecord   values;                 /* Array of ValueRecords--positioning
 555                                          * values applied to glyphs */
 556   public:
 557   DEFINE_SIZE_ARRAY (8, values);
 558 };
 559 
 560 struct SinglePos
 561 {
 562   template &lt;typename context_t&gt;
<span class="line-modified"> 563   inline typename context_t::return_t dispatch (context_t *c) const</span>
 564   {
 565     TRACE_DISPATCH (this, u.format);
 566     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 567     switch (u.format) {
 568     case 1: return_trace (c-&gt;dispatch (u.format1));
 569     case 2: return_trace (c-&gt;dispatch (u.format2));
 570     default:return_trace (c-&gt;default_return_value ());
 571     }
 572   }
 573 
 574   protected:
 575   union {
 576   HBUINT16              format;         /* Format identifier */
 577   SinglePosFormat1      format1;
 578   SinglePosFormat2      format2;
 579   } u;
 580 };
 581 
 582 
 583 struct PairValueRecord
 584 {
 585   friend struct PairSet;
 586 
 587   protected:
 588   GlyphID       secondGlyph;            /* GlyphID of second glyph in the
 589                                          * pair--first glyph is listed in the
 590                                          * Coverage table */
 591   ValueRecord   values;                 /* Positioning data for the first glyph
 592                                          * followed by for second glyph */
 593   public:
 594   DEFINE_SIZE_ARRAY (2, values);
 595 };
 596 
 597 struct PairSet
 598 {
 599   friend struct PairPosFormat1;
 600 
<span class="line-modified"> 601   inline void collect_glyphs (hb_collect_glyphs_context_t *c,</span>


















 602                               const ValueFormat *valueFormats) const
 603   {
<span class="line-removed"> 604     TRACE_COLLECT_GLYPHS (this);</span>
 605     unsigned int len1 = valueFormats[0].get_len ();
 606     unsigned int len2 = valueFormats[1].get_len ();
 607     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 608 
<span class="line-modified"> 609     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
 610     c-&gt;input-&gt;add_array (&amp;record-&gt;secondGlyph, len, record_size);
 611   }
 612 
<span class="line-modified"> 613   inline bool apply (hb_ot_apply_context_t *c,</span>
 614                      const ValueFormat *valueFormats,
 615                      unsigned int pos) const
 616   {
 617     TRACE_APPLY (this);
 618     hb_buffer_t *buffer = c-&gt;buffer;
 619     unsigned int len1 = valueFormats[0].get_len ();
 620     unsigned int len2 = valueFormats[1].get_len ();
 621     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 622 
<span class="line-removed"> 623     const PairValueRecord *record_array = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
 624     unsigned int count = len;
 625 
 626     /* Hand-coded bsearch. */
 627     if (unlikely (!count))
 628       return_trace (false);
 629     hb_codepoint_t x = buffer-&gt;info[pos].codepoint;
 630     int min = 0, max = (int) count - 1;
 631     while (min &lt;= max)
 632     {
<span class="line-modified"> 633       int mid = (min + max) / 2;</span>
<span class="line-modified"> 634       const PairValueRecord *record = &amp;StructAtOffset&lt;PairValueRecord&gt; (record_array, record_size * mid);</span>
 635       hb_codepoint_t mid_x = record-&gt;secondGlyph;
 636       if (x &lt; mid_x)
 637         max = mid - 1;
 638       else if (x &gt; mid_x)
 639         min = mid + 1;
 640       else
 641       {
<span class="line-modified"> 642         buffer-&gt;unsafe_to_break (buffer-&gt;idx, pos + 1);</span>
<span class="line-modified"> 643         valueFormats[0].apply_value (c, this, &amp;record-&gt;values[0], buffer-&gt;cur_pos());</span>
<span class="line-modified"> 644         valueFormats[1].apply_value (c, this, &amp;record-&gt;values[len1], buffer-&gt;pos[pos]);</span>

 645         if (len2)
 646           pos++;
 647         buffer-&gt;idx = pos;
 648         return_trace (true);
 649       }
 650     }
 651 
 652     return_trace (false);
 653   }
 654 
<span class="line-modified"> 655   struct sanitize_closure_t {</span>

 656     const void *base;
 657     const ValueFormat *valueFormats;
 658     unsigned int len1; /* valueFormats[0].get_len() */
 659     unsigned int stride; /* 1 + len1 + len2 */
 660   };
 661 
<span class="line-modified"> 662   inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const</span>
 663   {
 664     TRACE_SANITIZE (this);
 665     if (!(c-&gt;check_struct (this)
<span class="line-modified"> 666        &amp;&amp; c-&gt;check_array (arrayZ, HBUINT16::static_size * closure-&gt;stride, len))) return_trace (false);</span>



 667 
 668     unsigned int count = len;
<span class="line-modified"> 669     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);</span>
 670     return_trace (closure-&gt;valueFormats[0].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[0], count, closure-&gt;stride) &amp;&amp;
 671                   closure-&gt;valueFormats[1].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[closure-&gt;len1], count, closure-&gt;stride));
 672   }
 673 
 674   protected:
<span class="line-modified"> 675   HBUINT16      len;                    /* Number of PairValueRecords */</span>
<span class="line-modified"> 676   HBUINT16      arrayZ[VAR];            /* Array of PairValueRecords--ordered</span>
<span class="line-modified"> 677                                          * by GlyphID of the second glyph */</span>

 678   public:
<span class="line-modified"> 679   DEFINE_SIZE_ARRAY (2, arrayZ);</span>
 680 };
 681 
 682 struct PairPosFormat1
 683 {
<span class="line-modified"> 684   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>














 685   {
<span class="line-removed"> 686     TRACE_COLLECT_GLYPHS (this);</span>
 687     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 688     unsigned int count = pairSet.len;
 689     for (unsigned int i = 0; i &lt; count; i++)
 690       (this+pairSet[i]).collect_glyphs (c, valueFormat);
 691   }
 692 
<span class="line-modified"> 693   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed"> 694   {</span>
<span class="line-removed"> 695     return this+coverage;</span>
<span class="line-removed"> 696   }</span>
 697 
<span class="line-modified"> 698   inline bool apply (hb_ot_apply_context_t *c) const</span>
 699   {
 700     TRACE_APPLY (this);
 701     hb_buffer_t *buffer = c-&gt;buffer;
 702     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 703     if (likely (index == NOT_COVERED)) return_trace (false);
 704 
 705     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 706     skippy_iter.reset (buffer-&gt;idx, 1);
 707     if (!skippy_iter.next ()) return_trace (false);
 708 
 709     return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
 710   }
 711 
<span class="line-modified"> 712   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 713   {
 714     TRACE_SANITIZE (this);
 715 
 716     if (!c-&gt;check_struct (this)) return_trace (false);
 717 
 718     unsigned int len1 = valueFormat[0].get_len ();
 719     unsigned int len2 = valueFormat[1].get_len ();
<span class="line-modified"> 720     PairSet::sanitize_closure_t closure = {</span>

 721       this,
 722       valueFormat,
 723       len1,
 724       1 + len1 + len2
 725     };
 726 
 727     return_trace (coverage.sanitize (c, this) &amp;&amp; pairSet.sanitize (c, this, &amp;closure));
 728   }
 729 
 730   protected:
 731   HBUINT16      format;                 /* Format identifier--format = 1 */
 732   OffsetTo&lt;Coverage&gt;
 733                 coverage;               /* Offset to Coverage table--from
 734                                          * beginning of subtable */
 735   ValueFormat   valueFormat[2];         /* [0] Defines the types of data in
 736                                          * ValueRecord1--for the first glyph
 737                                          * in the pair--may be zero (0) */
 738                                         /* [1] Defines the types of data in
 739                                          * ValueRecord2--for the second glyph
 740                                          * in the pair--may be zero (0) */
 741   OffsetArrayOf&lt;PairSet&gt;
 742                 pairSet;                /* Array of PairSet tables
 743                                          * ordered by Coverage Index */
 744   public:
 745   DEFINE_SIZE_ARRAY (10, pairSet);
 746 };
 747 
 748 struct PairPosFormat2
 749 {
<span class="line-modified"> 750   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 751   {
<span class="line-modified"> 752     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-modified"> 753     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed"> 754     if (unlikely (!(this+classDef2).add_coverage (c-&gt;input))) return;</span>
 755   }
 756 
<span class="line-modified"> 757   inline const Coverage &amp;get_coverage (void) const</span>
 758   {
<span class="line-modified"> 759     return this+coverage;</span>

 760   }
 761 
<span class="line-modified"> 762   inline bool apply (hb_ot_apply_context_t *c) const</span>


 763   {
 764     TRACE_APPLY (this);
 765     hb_buffer_t *buffer = c-&gt;buffer;
 766     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 767     if (likely (index == NOT_COVERED)) return_trace (false);
 768 
 769     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 770     skippy_iter.reset (buffer-&gt;idx, 1);
 771     if (!skippy_iter.next ()) return_trace (false);
 772 
 773     unsigned int len1 = valueFormat1.get_len ();
 774     unsigned int len2 = valueFormat2.get_len ();
 775     unsigned int record_len = len1 + len2;
 776 
 777     unsigned int klass1 = (this+classDef1).get_class (buffer-&gt;cur().codepoint);
 778     unsigned int klass2 = (this+classDef2).get_class (buffer-&gt;info[skippy_iter.idx].codepoint);
 779     if (unlikely (klass1 &gt;= class1Count || klass2 &gt;= class2Count)) return_trace (false);
 780 
<span class="line-removed"> 781     buffer-&gt;unsafe_to_break (buffer-&gt;idx, skippy_iter.idx + 1);</span>
 782     const Value *v = &amp;values[record_len * (klass1 * class2Count + klass2)];
<span class="line-modified"> 783     valueFormat1.apply_value (c, this, v, buffer-&gt;cur_pos());</span>
<span class="line-modified"> 784     valueFormat2.apply_value (c, this, v + len1, buffer-&gt;pos[skippy_iter.idx]);</span>


 785 
 786     buffer-&gt;idx = skippy_iter.idx;
 787     if (len2)
 788       buffer-&gt;idx++;
 789 
 790     return_trace (true);
 791   }
 792 
<span class="line-modified"> 793   inline bool sanitize (hb_sanitize_context_t *c) const</span>







 794   {
 795     TRACE_SANITIZE (this);
 796     if (!(c-&gt;check_struct (this)
 797        &amp;&amp; coverage.sanitize (c, this)
 798        &amp;&amp; classDef1.sanitize (c, this)
 799        &amp;&amp; classDef2.sanitize (c, this))) return_trace (false);
 800 
 801     unsigned int len1 = valueFormat1.get_len ();
 802     unsigned int len2 = valueFormat2.get_len ();
 803     unsigned int stride = len1 + len2;
 804     unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
 805     unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
<span class="line-modified"> 806     return_trace (c-&gt;check_array (values, record_size, count) &amp;&amp;</span>


 807                   valueFormat1.sanitize_values_stride_unsafe (c, this, &amp;values[0], count, stride) &amp;&amp;
 808                   valueFormat2.sanitize_values_stride_unsafe (c, this, &amp;values[len1], count, stride));
 809   }
 810 
 811   protected:
 812   HBUINT16      format;                 /* Format identifier--format = 2 */
 813   OffsetTo&lt;Coverage&gt;
 814                 coverage;               /* Offset to Coverage table--from
 815                                          * beginning of subtable */
 816   ValueFormat   valueFormat1;           /* ValueRecord definition--for the
 817                                          * first glyph of the pair--may be zero
 818                                          * (0) */
 819   ValueFormat   valueFormat2;           /* ValueRecord definition--for the
 820                                          * second glyph of the pair--may be
 821                                          * zero (0) */
 822   OffsetTo&lt;ClassDef&gt;
 823                 classDef1;              /* Offset to ClassDef table--from
 824                                          * beginning of PairPos subtable--for
 825                                          * the first glyph of the pair */
 826   OffsetTo&lt;ClassDef&gt;
 827                 classDef2;              /* Offset to ClassDef table--from
 828                                          * beginning of PairPos subtable--for
 829                                          * the second glyph of the pair */
 830   HBUINT16      class1Count;            /* Number of classes in ClassDef1
 831                                          * table--includes Class0 */
 832   HBUINT16      class2Count;            /* Number of classes in ClassDef2
 833                                          * table--includes Class0 */
 834   ValueRecord   values;                 /* Matrix of value pairs:
 835                                          * class1-major, class2-minor,
 836                                          * Each entry has value1 and value2 */
 837   public:
 838   DEFINE_SIZE_ARRAY (16, values);
 839 };
 840 
 841 struct PairPos
 842 {
 843   template &lt;typename context_t&gt;
<span class="line-modified"> 844   inline typename context_t::return_t dispatch (context_t *c) const</span>
 845   {
 846     TRACE_DISPATCH (this, u.format);
 847     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 848     switch (u.format) {
 849     case 1: return_trace (c-&gt;dispatch (u.format1));
 850     case 2: return_trace (c-&gt;dispatch (u.format2));
 851     default:return_trace (c-&gt;default_return_value ());
 852     }
 853   }
 854 
 855   protected:
 856   union {
 857   HBUINT16              format;         /* Format identifier */
 858   PairPosFormat1        format1;
 859   PairPosFormat2        format2;
 860   } u;
 861 };
 862 
 863 
 864 struct EntryExitRecord
 865 {
 866   friend struct CursivePosFormat1;
 867 
<span class="line-modified"> 868   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 869   {
 870     TRACE_SANITIZE (this);
 871     return_trace (entryAnchor.sanitize (c, base) &amp;&amp; exitAnchor.sanitize (c, base));
 872   }
 873 
 874   protected:
 875   OffsetTo&lt;Anchor&gt;
 876                 entryAnchor;            /* Offset to EntryAnchor table--from
 877                                          * beginning of CursivePos
 878                                          * subtable--may be NULL */
 879   OffsetTo&lt;Anchor&gt;
 880                 exitAnchor;             /* Offset to ExitAnchor table--from
 881                                          * beginning of CursivePos
 882                                          * subtable--may be NULL */
 883   public:
 884   DEFINE_SIZE_STATIC (4);
 885 };
 886 
 887 static void
 888 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);
 889 
 890 struct CursivePosFormat1
 891 {
<span class="line-modified"> 892   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 893   {</span>
<span class="line-removed"> 894     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-removed"> 895     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-removed"> 896   }</span>
 897 
<span class="line-modified"> 898   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-modified"> 899   {</span>
<span class="line-removed"> 900     return this+coverage;</span>
<span class="line-removed"> 901   }</span>
 902 
<span class="line-modified"> 903   inline bool apply (hb_ot_apply_context_t *c) const</span>


 904   {
 905     TRACE_APPLY (this);
 906     hb_buffer_t *buffer = c-&gt;buffer;
 907 
 908     const EntryExitRecord &amp;this_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;cur().codepoint)];
<span class="line-modified"> 909     if (!this_record.exitAnchor) return_trace (false);</span>
 910 
 911     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 912     skippy_iter.reset (buffer-&gt;idx, 1);
<span class="line-modified"> 913     if (!skippy_iter.next ()) return_trace (false);</span>
 914 
<span class="line-modified"> 915     const EntryExitRecord &amp;next_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint)];</span>
<span class="line-modified"> 916     if (!next_record.entryAnchor) return_trace (false);</span>
 917 
<span class="line-modified"> 918     unsigned int i = buffer-&gt;idx;</span>
<span class="line-modified"> 919     unsigned int j = skippy_iter.idx;</span>
 920 
 921     buffer-&gt;unsafe_to_break (i, j);
 922     float entry_x, entry_y, exit_x, exit_y;
<span class="line-modified"> 923     (this+this_record.exitAnchor).get_anchor (c, buffer-&gt;info[i].codepoint, &amp;exit_x, &amp;exit_y);</span>
<span class="line-modified"> 924     (this+next_record.entryAnchor).get_anchor (c, buffer-&gt;info[j].codepoint, &amp;entry_x, &amp;entry_y);</span>
 925 
 926     hb_glyph_position_t *pos = buffer-&gt;pos;
 927 
 928     hb_position_t d;
 929     /* Main-direction adjustment */
 930     switch (c-&gt;direction) {
 931       case HB_DIRECTION_LTR:
 932         pos[i].x_advance  = round (exit_x) + pos[i].x_offset;
 933 
 934         d = round (entry_x) + pos[j].x_offset;
 935         pos[j].x_advance -= d;
 936         pos[j].x_offset  -= d;
 937         break;
 938       case HB_DIRECTION_RTL:
 939         d = round (exit_x) + pos[i].x_offset;
 940         pos[i].x_advance -= d;
 941         pos[i].x_offset  -= d;
 942 
 943         pos[j].x_advance  = round (entry_x) + pos[j].x_offset;
 944         break;
</pre>
<hr />
<pre>
 951         break;
 952       case HB_DIRECTION_BTT:
 953         d = round (exit_y) + pos[i].y_offset;
 954         pos[i].y_advance -= d;
 955         pos[i].y_offset  -= d;
 956 
 957         pos[j].y_advance  = round (entry_y);
 958         break;
 959       case HB_DIRECTION_INVALID:
 960       default:
 961         break;
 962     }
 963 
 964     /* Cross-direction adjustment */
 965 
 966     /* We attach child to parent (think graph theory and rooted trees whereas
 967      * the root stays on baseline and each node aligns itself against its
 968      * parent.
 969      *
 970      * Optimize things for the case of RightToLeft, as that&#39;s most common in
<span class="line-modified"> 971      * Arabinc. */</span>
 972     unsigned int child  = i;
 973     unsigned int parent = j;
 974     hb_position_t x_offset = entry_x - exit_x;
 975     hb_position_t y_offset = entry_y - exit_y;
 976     if  (!(c-&gt;lookup_props &amp; LookupFlag::RightToLeft))
 977     {
 978       unsigned int k = child;
 979       child = parent;
 980       parent = k;
 981       x_offset = -x_offset;
 982       y_offset = -y_offset;
 983     }
 984 
 985     /* If child was already connected to someone else, walk through its old
 986      * chain and reverse the link direction, such that the whole tree of its
 987      * previous connection now attaches to new parent.  Watch out for case
 988      * where new parent is on the path from old chain...
 989      */
 990     reverse_cursive_minor_offset (pos, child, c-&gt;direction, parent);
 991 
 992     pos[child].attach_type() = ATTACH_TYPE_CURSIVE;
 993     pos[child].attach_chain() = (int) parent - (int) child;
 994     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
 995     if (likely (HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction)))
 996       pos[child].y_offset = y_offset;
 997     else
 998       pos[child].x_offset = x_offset;
 999 
<span class="line-modified">1000     buffer-&gt;idx = j;</span>
1001     return_trace (true);
1002   }
1003 
<span class="line-modified">1004   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1005   {
1006     TRACE_SANITIZE (this);
1007     return_trace (coverage.sanitize (c, this) &amp;&amp; entryExitRecord.sanitize (c, this));
1008   }
1009 
1010   protected:
1011   HBUINT16      format;                 /* Format identifier--format = 1 */
1012   OffsetTo&lt;Coverage&gt;
1013                 coverage;               /* Offset to Coverage table--from
1014                                          * beginning of subtable */
1015   ArrayOf&lt;EntryExitRecord&gt;
1016                 entryExitRecord;        /* Array of EntryExit records--in
1017                                          * Coverage Index order */
1018   public:
1019   DEFINE_SIZE_ARRAY (6, entryExitRecord);
1020 };
1021 
1022 struct CursivePos
1023 {
1024   template &lt;typename context_t&gt;
<span class="line-modified">1025   inline typename context_t::return_t dispatch (context_t *c) const</span>
1026   {
1027     TRACE_DISPATCH (this, u.format);
1028     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1029     switch (u.format) {
1030     case 1: return_trace (c-&gt;dispatch (u.format1));
1031     default:return_trace (c-&gt;default_return_value ());
1032     }
1033   }
1034 
1035   protected:
1036   union {
1037   HBUINT16              format;         /* Format identifier */
1038   CursivePosFormat1     format1;
1039   } u;
1040 };
1041 
1042 
1043 typedef AnchorMatrix BaseArray;         /* base-major--
1044                                          * in order of BaseCoverage Index--,
1045                                          * mark-minor--
1046                                          * ordered by class--zero-based. */
1047 
1048 struct MarkBasePosFormat1
1049 {
<span class="line-modified">1050   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>




1051   {
<span class="line-removed">1052     TRACE_COLLECT_GLYPHS (this);</span>
1053     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1054     if (unlikely (!(this+baseCoverage).add_coverage (c-&gt;input))) return;
1055   }
1056 
<span class="line-modified">1057   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">1058   {</span>
<span class="line-removed">1059     return this+markCoverage;</span>
<span class="line-removed">1060   }</span>
1061 
<span class="line-modified">1062   inline bool apply (hb_ot_apply_context_t *c) const</span>
1063   {
1064     TRACE_APPLY (this);
1065     hb_buffer_t *buffer = c-&gt;buffer;
1066     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1067     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1068 
1069     /* Now we search backwards for a non-mark glyph */
1070     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1071     skippy_iter.reset (buffer-&gt;idx, 1);
1072     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1073     do {
1074       if (!skippy_iter.prev ()) return_trace (false);
1075       /* We only want to attach to the first of a MultipleSubst sequence.
1076        * https://github.com/harfbuzz/harfbuzz/issues/740
1077        * Reject others...
1078        * ...but stop if we find a mark in the MultipleSubst sequence:
1079        * https://github.com/harfbuzz/harfbuzz/issues/1020 */
1080       if (!_hb_glyph_info_multiplied (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1081           0 == _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1082           (skippy_iter.idx == 0 ||
1083            _hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1084            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1085            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1086            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1087            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx - 1]) + 1
1088            ))
1089         break;
1090       skippy_iter.reject ();
<span class="line-modified">1091     } while (1);</span>
1092 
1093     /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */
1094     //if (!_hb_glyph_info_is_base_glyph (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1095 
1096     unsigned int base_index = (this+baseCoverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint);
1097     if (base_index == NOT_COVERED) return_trace (false);
1098 
1099     return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
1100   }
1101 
<span class="line-modified">1102   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1103   {
1104     TRACE_SANITIZE (this);
1105     return_trace (c-&gt;check_struct (this) &amp;&amp;
1106                   markCoverage.sanitize (c, this) &amp;&amp;
1107                   baseCoverage.sanitize (c, this) &amp;&amp;
1108                   markArray.sanitize (c, this) &amp;&amp;
1109                   baseArray.sanitize (c, this, (unsigned int) classCount));
1110   }
1111 
1112   protected:
1113   HBUINT16      format;                 /* Format identifier--format = 1 */
1114   OffsetTo&lt;Coverage&gt;
1115                 markCoverage;           /* Offset to MarkCoverage table--from
1116                                          * beginning of MarkBasePos subtable */
1117   OffsetTo&lt;Coverage&gt;
1118                 baseCoverage;           /* Offset to BaseCoverage table--from
1119                                          * beginning of MarkBasePos subtable */
1120   HBUINT16      classCount;             /* Number of classes defined for marks */
1121   OffsetTo&lt;MarkArray&gt;
1122                 markArray;              /* Offset to MarkArray table--from
1123                                          * beginning of MarkBasePos subtable */
1124   OffsetTo&lt;BaseArray&gt;
1125                 baseArray;              /* Offset to BaseArray table--from
1126                                          * beginning of MarkBasePos subtable */
1127   public:
1128   DEFINE_SIZE_STATIC (12);
1129 };
1130 
1131 struct MarkBasePos
1132 {
1133   template &lt;typename context_t&gt;
<span class="line-modified">1134   inline typename context_t::return_t dispatch (context_t *c) const</span>
1135   {
1136     TRACE_DISPATCH (this, u.format);
1137     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1138     switch (u.format) {
1139     case 1: return_trace (c-&gt;dispatch (u.format1));
1140     default:return_trace (c-&gt;default_return_value ());
1141     }
1142   }
1143 
1144   protected:
1145   union {
1146   HBUINT16              format;         /* Format identifier */
1147   MarkBasePosFormat1    format1;
1148   } u;
1149 };
1150 
1151 
1152 typedef AnchorMatrix LigatureAttach;    /* component-major--
1153                                          * in order of writing direction--,
1154                                          * mark-minor--
1155                                          * ordered by class--zero-based. */
1156 
1157 typedef OffsetListOf&lt;LigatureAttach&gt; LigatureArray;
1158                                         /* Array of LigatureAttach
1159                                          * tables ordered by
1160                                          * LigatureCoverage Index */
1161 
1162 struct MarkLigPosFormat1
1163 {
<span class="line-modified">1164   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>




1165   {
<span class="line-removed">1166     TRACE_COLLECT_GLYPHS (this);</span>
1167     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1168     if (unlikely (!(this+ligatureCoverage).add_coverage (c-&gt;input))) return;
1169   }
1170 
<span class="line-modified">1171   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">1172   {</span>
<span class="line-removed">1173     return this+markCoverage;</span>
<span class="line-removed">1174   }</span>
1175 
<span class="line-modified">1176   inline bool apply (hb_ot_apply_context_t *c) const</span>
1177   {
1178     TRACE_APPLY (this);
1179     hb_buffer_t *buffer = c-&gt;buffer;
1180     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1181     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1182 
1183     /* Now we search backwards for a non-mark glyph */
1184     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1185     skippy_iter.reset (buffer-&gt;idx, 1);
1186     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1187     if (!skippy_iter.prev ()) return_trace (false);
1188 
1189     /* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled */
1190     //if (!_hb_glyph_info_is_ligature (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1191 
1192     unsigned int j = skippy_iter.idx;
1193     unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer-&gt;info[j].codepoint);
1194     if (lig_index == NOT_COVERED) return_trace (false);
1195 
1196     const LigatureArray&amp; lig_array = this+ligatureArray;
</pre>
<hr />
<pre>
1199     /* Find component to attach to */
1200     unsigned int comp_count = lig_attach.rows;
1201     if (unlikely (!comp_count)) return_trace (false);
1202 
1203     /* We must now check whether the ligature ID of the current mark glyph
1204      * is identical to the ligature ID of the found ligature.  If yes, we
1205      * can directly use the component index.  If not, we attach the mark
1206      * glyph to the last component of the ligature. */
1207     unsigned int comp_index;
1208     unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1209     unsigned int mark_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1210     unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1211     if (lig_id &amp;&amp; lig_id == mark_id &amp;&amp; mark_comp &gt; 0)
1212       comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur())) - 1;
1213     else
1214       comp_index = comp_count - 1;
1215 
1216     return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
1217   }
1218 
<span class="line-modified">1219   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1220   {
1221     TRACE_SANITIZE (this);
1222     return_trace (c-&gt;check_struct (this) &amp;&amp;
1223                   markCoverage.sanitize (c, this) &amp;&amp;
1224                   ligatureCoverage.sanitize (c, this) &amp;&amp;
1225                   markArray.sanitize (c, this) &amp;&amp;
1226                   ligatureArray.sanitize (c, this, (unsigned int) classCount));
1227   }
1228 
1229   protected:
1230   HBUINT16      format;                 /* Format identifier--format = 1 */
1231   OffsetTo&lt;Coverage&gt;
1232                 markCoverage;           /* Offset to Mark Coverage table--from
1233                                          * beginning of MarkLigPos subtable */
1234   OffsetTo&lt;Coverage&gt;
1235                 ligatureCoverage;       /* Offset to Ligature Coverage
1236                                          * table--from beginning of MarkLigPos
1237                                          * subtable */
1238   HBUINT16      classCount;             /* Number of defined mark classes */
1239   OffsetTo&lt;MarkArray&gt;
1240                 markArray;              /* Offset to MarkArray table--from
1241                                          * beginning of MarkLigPos subtable */
1242   OffsetTo&lt;LigatureArray&gt;
1243                 ligatureArray;          /* Offset to LigatureArray table--from
1244                                          * beginning of MarkLigPos subtable */
1245   public:
1246   DEFINE_SIZE_STATIC (12);
1247 };
1248 
1249 struct MarkLigPos
1250 {
1251   template &lt;typename context_t&gt;
<span class="line-modified">1252   inline typename context_t::return_t dispatch (context_t *c) const</span>
1253   {
1254     TRACE_DISPATCH (this, u.format);
1255     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1256     switch (u.format) {
1257     case 1: return_trace (c-&gt;dispatch (u.format1));
1258     default:return_trace (c-&gt;default_return_value ());
1259     }
1260   }
1261 
1262   protected:
1263   union {
1264   HBUINT16              format;         /* Format identifier */
1265   MarkLigPosFormat1     format1;
1266   } u;
1267 };
1268 
1269 
1270 typedef AnchorMatrix Mark2Array;        /* mark2-major--
1271                                          * in order of Mark2Coverage Index--,
1272                                          * mark1-minor--
1273                                          * ordered by class--zero-based. */
1274 
1275 struct MarkMarkPosFormat1
1276 {
<span class="line-modified">1277   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>




1278   {
<span class="line-removed">1279     TRACE_COLLECT_GLYPHS (this);</span>
1280     if (unlikely (!(this+mark1Coverage).add_coverage (c-&gt;input))) return;
1281     if (unlikely (!(this+mark2Coverage).add_coverage (c-&gt;input))) return;
1282   }
1283 
<span class="line-modified">1284   inline const Coverage &amp;get_coverage (void) const</span>
<span class="line-removed">1285   {</span>
<span class="line-removed">1286     return this+mark1Coverage;</span>
<span class="line-removed">1287   }</span>
1288 
<span class="line-modified">1289   inline bool apply (hb_ot_apply_context_t *c) const</span>
1290   {
1291     TRACE_APPLY (this);
1292     hb_buffer_t *buffer = c-&gt;buffer;
1293     unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer-&gt;cur().codepoint);
1294     if (likely (mark1_index == NOT_COVERED)) return_trace (false);
1295 
1296     /* now we search backwards for a suitable mark glyph until a non-mark glyph */
1297     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1298     skippy_iter.reset (buffer-&gt;idx, 1);
1299     skippy_iter.set_lookup_props (c-&gt;lookup_props &amp; ~LookupFlag::IgnoreFlags);
1300     if (!skippy_iter.prev ()) return_trace (false);
1301 
1302     if (!_hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1303 
1304     unsigned int j = skippy_iter.idx;
1305 
1306     unsigned int id1 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1307     unsigned int id2 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1308     unsigned int comp1 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1309     unsigned int comp2 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[j]);
</pre>
<hr />
<pre>
1313         goto good;
1314       else if (comp1 == comp2) /* Marks belonging to the same ligature component. */
1315         goto good;
1316     } else {
1317       /* If ligature ids don&#39;t match, it may be the case that one of the marks
1318        * itself is a ligature.  In which case match. */
1319       if ((id1 &gt; 0 &amp;&amp; !comp1) || (id2 &gt; 0 &amp;&amp; !comp2))
1320         goto good;
1321     }
1322 
1323     /* Didn&#39;t match. */
1324     return_trace (false);
1325 
1326     good:
1327     unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer-&gt;info[j].codepoint);
1328     if (mark2_index == NOT_COVERED) return_trace (false);
1329 
1330     return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
1331   }
1332 
<span class="line-modified">1333   inline bool sanitize (hb_sanitize_context_t *c) const</span>







1334   {
1335     TRACE_SANITIZE (this);
1336     return_trace (c-&gt;check_struct (this) &amp;&amp;
1337                   mark1Coverage.sanitize (c, this) &amp;&amp;
1338                   mark2Coverage.sanitize (c, this) &amp;&amp;
1339                   mark1Array.sanitize (c, this) &amp;&amp;
1340                   mark2Array.sanitize (c, this, (unsigned int) classCount));
1341   }
1342 
1343   protected:
1344   HBUINT16      format;                 /* Format identifier--format = 1 */
1345   OffsetTo&lt;Coverage&gt;
1346                 mark1Coverage;          /* Offset to Combining Mark1 Coverage
1347                                          * table--from beginning of MarkMarkPos
1348                                          * subtable */
1349   OffsetTo&lt;Coverage&gt;
1350                 mark2Coverage;          /* Offset to Combining Mark2 Coverage
1351                                          * table--from beginning of MarkMarkPos
1352                                          * subtable */
1353   HBUINT16      classCount;             /* Number of defined mark classes */
1354   OffsetTo&lt;MarkArray&gt;
1355                 mark1Array;             /* Offset to Mark1Array table--from
1356                                          * beginning of MarkMarkPos subtable */
1357   OffsetTo&lt;Mark2Array&gt;
1358                 mark2Array;             /* Offset to Mark2Array table--from
1359                                          * beginning of MarkMarkPos subtable */
1360   public:
1361   DEFINE_SIZE_STATIC (12);
1362 };
1363 
1364 struct MarkMarkPos
1365 {
1366   template &lt;typename context_t&gt;
<span class="line-modified">1367   inline typename context_t::return_t dispatch (context_t *c) const</span>
1368   {
1369     TRACE_DISPATCH (this, u.format);
1370     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1371     switch (u.format) {
1372     case 1: return_trace (c-&gt;dispatch (u.format1));
1373     default:return_trace (c-&gt;default_return_value ());
1374     }
1375   }
1376 
1377   protected:
1378   union {
1379   HBUINT16              format;         /* Format identifier */
1380   MarkMarkPosFormat1    format1;
1381   } u;
1382 };
1383 
1384 
1385 struct ContextPos : Context {};
1386 
1387 struct ChainContextPos : ChainContext {};
1388 
1389 struct ExtensionPos : Extension&lt;ExtensionPos&gt;
1390 {
<span class="line-modified">1391   typedef struct PosLookupSubTable LookupSubTable;</span>
1392 };
1393 
1394 
1395 
1396 /*
1397  * PosLookup
1398  */
1399 
1400 
1401 struct PosLookupSubTable
1402 {

1403   friend struct PosLookup;
1404 
1405   enum Type {
1406     Single              = 1,
1407     Pair                = 2,
1408     Cursive             = 3,
1409     MarkBase            = 4,
1410     MarkLig             = 5,
1411     MarkMark            = 6,
1412     Context             = 7,
1413     ChainContext        = 8,
1414     Extension           = 9
1415   };
1416 
1417   template &lt;typename context_t&gt;
<span class="line-modified">1418   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1419   {
1420     TRACE_DISPATCH (this, lookup_type);
<span class="line-removed">1421     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());</span>
1422     switch (lookup_type) {
1423     case Single:                return_trace (u.single.dispatch (c));
1424     case Pair:                  return_trace (u.pair.dispatch (c));
1425     case Cursive:               return_trace (u.cursive.dispatch (c));
1426     case MarkBase:              return_trace (u.markBase.dispatch (c));
1427     case MarkLig:               return_trace (u.markLig.dispatch (c));
1428     case MarkMark:              return_trace (u.markMark.dispatch (c));
1429     case Context:               return_trace (u.context.dispatch (c));
1430     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1431     case Extension:             return_trace (u.extension.dispatch (c));
1432     default:                    return_trace (c-&gt;default_return_value ());
1433     }
1434   }
1435 
1436   protected:
1437   union {
<span class="line-removed">1438   HBUINT16              sub_format;</span>
1439   SinglePos             single;
1440   PairPos               pair;
1441   CursivePos            cursive;
1442   MarkBasePos           markBase;
1443   MarkLigPos            markLig;
1444   MarkMarkPos           markMark;
1445   ContextPos            context;
1446   ChainContextPos       chainContext;
1447   ExtensionPos          extension;
1448   } u;
1449   public:
<span class="line-modified">1450   DEFINE_SIZE_UNION (2, sub_format);</span>
1451 };
1452 
1453 
1454 struct PosLookup : Lookup
1455 {
<span class="line-modified">1456   inline const PosLookupSubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-modified">1457   { return Lookup::get_subtable&lt;PosLookupSubTable&gt; (i); }</span>


1458 
<span class="line-modified">1459   inline bool is_reverse (void) const</span>
1460   {
1461     return false;
1462   }
1463 
<span class="line-modified">1464   inline bool apply (hb_ot_apply_context_t *c) const</span>
1465   {
1466     TRACE_APPLY (this);
1467     return_trace (dispatch (c));
1468   }
1469 
<span class="line-modified">1470   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1471   {
<span class="line-modified">1472     TRACE_COLLECT_GLYPHS (this);</span>
<span class="line-modified">1473     return_trace (dispatch (c));</span>
1474   }
1475 



1476   template &lt;typename set_t&gt;
<span class="line-modified">1477   inline void add_coverage (set_t *glyphs) const</span>
1478   {
1479     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1480     dispatch (&amp;c);
1481   }
1482 
1483   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1484 
1485   template &lt;typename context_t&gt;
<span class="line-modified">1486   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1487 
1488   template &lt;typename context_t&gt;
<span class="line-modified">1489   inline typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1490   { return Lookup::dispatch&lt;PosLookupSubTable&gt; (c); }</span>
1491 
<span class="line-modified">1492   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1493   {</span>
<span class="line-removed">1494     TRACE_SANITIZE (this);</span>
<span class="line-removed">1495     if (unlikely (!Lookup::sanitize (c))) return_trace (false);</span>
<span class="line-removed">1496     return_trace (dispatch (c));</span>
<span class="line-removed">1497   }</span>
<span class="line-removed">1498 };</span>
1499 
<span class="line-modified">1500 typedef OffsetListOf&lt;PosLookup&gt; PosLookupList;</span>


1501 
1502 /*
1503  * GPOS -- Glyph Positioning
1504  * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
1505  */
1506 
1507 struct GPOS : GSUBGPOS
1508 {
<span class="line-modified">1509   static const hb_tag_t tableTag        = HB_OT_TAG_GPOS;</span>
1510 
<span class="line-modified">1511   inline const PosLookup&amp; get_lookup (unsigned int i) const</span>
1512   { return CastR&lt;PosLookup&gt; (GSUBGPOS::get_lookup (i)); }
1513 
1514   static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
1515   static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);
1516   static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);
1517 
<span class="line-modified">1518   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1519   {</span>
<span class="line-modified">1520     TRACE_SANITIZE (this);</span>
<span class="line-modified">1521     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);</span>
<span class="line-modified">1522     const OffsetTo&lt;PosLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;PosLookupList&gt; &gt; (lookupList);</span>
<span class="line-modified">1523     return_trace (list.sanitize (c, this));</span>
<span class="line-modified">1524   }</span>



1525 };
1526 
1527 
1528 static void
1529 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)
1530 {
1531   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1532   if (likely (!chain || 0 == (type &amp; ATTACH_TYPE_CURSIVE)))
1533     return;
1534 
1535   pos[i].attach_chain() = 0;
1536 
1537   unsigned int j = (int) i + chain;
1538 
1539   /* Stop if we see new parent in the chain. */
1540   if (j == new_parent)
1541     return;
1542 
1543   reverse_cursive_minor_offset (pos, j, direction, new_parent);
1544 
1545   if (HB_DIRECTION_IS_HORIZONTAL (direction))
1546     pos[j].y_offset = -pos[i].y_offset;
1547   else
1548     pos[j].x_offset = -pos[i].x_offset;
1549 
1550   pos[j].attach_chain() = -chain;
1551   pos[j].attach_type() = type;
1552 }
1553 static void
<span class="line-modified">1554 propagate_attachment_offsets (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)</span>



1555 {
1556   /* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate
1557    * offset of glyph they are attached to. */
1558   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1559   if (likely (!chain))
1560     return;
1561 


1562   unsigned int j = (int) i + chain;
1563 
<span class="line-modified">1564   pos[i].attach_chain() = 0;</span>

1565 
<span class="line-modified">1566   propagate_attachment_offsets (pos, j, direction);</span>
1567 
1568   assert (!!(type &amp; ATTACH_TYPE_MARK) ^ !!(type &amp; ATTACH_TYPE_CURSIVE));
1569 
1570   if (type &amp; ATTACH_TYPE_CURSIVE)
1571   {
1572     if (HB_DIRECTION_IS_HORIZONTAL (direction))
1573       pos[i].y_offset += pos[j].y_offset;
1574     else
1575       pos[i].x_offset += pos[j].x_offset;
1576   }
1577   else /*if (type &amp; ATTACH_TYPE_MARK)*/
1578   {
1579     pos[i].x_offset += pos[j].x_offset;
1580     pos[i].y_offset += pos[j].y_offset;
1581 
1582     assert (j &lt; i);
1583     if (HB_DIRECTION_IS_FORWARD (direction))
1584       for (unsigned int k = j; k &lt; i; k++) {
1585         pos[i].x_offset -= pos[k].x_advance;
1586         pos[i].y_offset -= pos[k].y_advance;
1587       }
1588     else
1589       for (unsigned int k = j + 1; k &lt; i + 1; k++) {
1590         pos[i].x_offset += pos[k].x_advance;
1591         pos[i].y_offset += pos[k].y_advance;
1592       }
1593   }
1594 }
1595 
1596 void
1597 GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1598 {
1599   unsigned int count = buffer-&gt;len;
1600   for (unsigned int i = 0; i &lt; count; i++)
1601     buffer-&gt;pos[i].attach_chain() = buffer-&gt;pos[i].attach_type() = 0;
1602 }
1603 
1604 void
<span class="line-modified">1605 GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)</span>
1606 {
1607   //_hb_buffer_assert_gsubgpos_vars (buffer);
1608 }
1609 
1610 void
1611 GPOS::position_finish_offsets (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1612 {
1613   _hb_buffer_assert_gsubgpos_vars (buffer);
1614 
1615   unsigned int len;
1616   hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &amp;len);
1617   hb_direction_t direction = buffer-&gt;props.direction;
1618 
1619   /* Handle attachments */
1620   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)
1621     for (unsigned int i = 0; i &lt; len; i++)
<span class="line-modified">1622       propagate_attachment_offsets (pos, i, direction);</span>
1623 }
1624 
1625 



1626 /* Out-of-class implementation for methods recursing */
1627 
1628 template &lt;typename context_t&gt;
1629 /*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1630 {
<span class="line-modified">1631   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);</span>
<span class="line-removed">1632   const PosLookup &amp;l = gpos.get_lookup (lookup_index);</span>
1633   return l.dispatch (c);
1634 }
1635 
1636 /*static*/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1637 {
<span class="line-modified">1638   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);</span>
<span class="line-removed">1639   const PosLookup &amp;l = gpos.get_lookup (lookup_index);</span>
1640   unsigned int saved_lookup_props = c-&gt;lookup_props;
1641   unsigned int saved_lookup_index = c-&gt;lookup_index;
1642   c-&gt;set_lookup_index (lookup_index);
1643   c-&gt;set_lookup_props (l.get_props ());
1644   bool ret = l.dispatch (c);
1645   c-&gt;set_lookup_index (saved_lookup_index);
1646   c-&gt;set_lookup_props (saved_lookup_props);
1647   return ret;
1648 }
1649 
1650 
<span class="line-removed">1651 #undef attach_chain</span>
<span class="line-removed">1652 #undef attach_type</span>
<span class="line-removed">1653 </span>
<span class="line-removed">1654 </span>
1655 } /* namespace OT */
1656 
1657 
1658 #endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
  30 #define HB_OT_LAYOUT_GPOS_TABLE_HH
  31 
<span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 
  38 /* buffer **position** var allocations */
  39 #define attach_chain() var.i16[0] /* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. */
  40 #define attach_type() var.u8[2] /* attachment type */
  41 /* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. */
  42 
  43 enum attach_type_t {
  44   ATTACH_TYPE_NONE      = 0X00,
  45 
  46   /* Each attachment should be either a mark or a cursive; can&#39;t be both. */
  47   ATTACH_TYPE_MARK      = 0X01,
  48   ATTACH_TYPE_CURSIVE   = 0X02,
  49 };
  50 
  51 
  52 /* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
  53 
  54 typedef HBUINT16 Value;
  55 
<span class="line-modified">  56 typedef UnsizedArrayOf&lt;Value&gt; ValueRecord;</span>
  57 
  58 struct ValueFormat : HBUINT16
  59 {
  60   enum Flags {
  61     xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
  62     yPlacement  = 0x0002u,      /* Includes vertical adjustment for placement */
  63     xAdvance    = 0x0004u,      /* Includes horizontal adjustment for advance */
  64     yAdvance    = 0x0008u,      /* Includes vertical adjustment for advance */
  65     xPlaDevice  = 0x0010u,      /* Includes horizontal Device table for placement */
  66     yPlaDevice  = 0x0020u,      /* Includes vertical Device table for placement */
  67     xAdvDevice  = 0x0040u,      /* Includes horizontal Device table for advance */
  68     yAdvDevice  = 0x0080u,      /* Includes vertical Device table for advance */
  69     ignored     = 0x0F00u,      /* Was used in TrueType Open for MM fonts */
  70     reserved    = 0xF000u,      /* For future use */
  71 
  72     devices     = 0x00F0u       /* Mask for having any Device table */
  73   };
  74 
  75 /* All fields are options.  Only those available advance the value pointer. */
  76 #if 0
  77   HBINT16               xPlacement;             /* Horizontal adjustment for
  78                                          * placement--in design units */
  79   HBINT16               yPlacement;             /* Vertical adjustment for
  80                                          * placement--in design units */
  81   HBINT16               xAdvance;               /* Horizontal adjustment for
  82                                          * advance--in design units (only used
  83                                          * for horizontal writing) */
  84   HBINT16               yAdvance;               /* Vertical adjustment for advance--in
  85                                          * design units (only used for vertical
  86                                          * writing) */
<span class="line-modified">  87   OffsetTo&lt;Device&gt;      xPlaDevice;     /* Offset to Device table for</span>
  88                                          * horizontal placement--measured from
  89                                          * beginning of PosTable (may be NULL) */
<span class="line-modified">  90   OffsetTo&lt;Device&gt;      yPlaDevice;     /* Offset to Device table for vertical</span>
  91                                          * placement--measured from beginning
  92                                          * of PosTable (may be NULL) */
<span class="line-modified">  93   OffsetTo&lt;Device&gt;      xAdvDevice;     /* Offset to Device table for</span>
  94                                          * horizontal advance--measured from
  95                                          * beginning of PosTable (may be NULL) */
<span class="line-modified">  96   OffsetTo&lt;Device&gt;      yAdvDevice;     /* Offset to Device table for vertical</span>
  97                                          * advance--measured from beginning of
  98                                          * PosTable (may be NULL) */
  99 #endif
 100 
<span class="line-modified"> 101   unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }</span>
<span class="line-modified"> 102   unsigned int get_size () const { return get_len () * Value::static_size; }</span>


 103 
<span class="line-modified"> 104   bool apply_value (hb_ot_apply_context_t   *c,</span>
 105                     const void           *base,
 106                     const Value          *values,
 107                     hb_glyph_position_t  &amp;glyph_pos) const
 108   {
<span class="line-added"> 109     bool ret = false;</span>
 110     unsigned int format = *this;
<span class="line-modified"> 111     if (!format) return ret;</span>
 112 
 113     hb_font_t *font = c-&gt;font;
<span class="line-modified"> 114     bool horizontal = HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction);</span>
 115 
<span class="line-modified"> 116     if (format &amp; xPlacement) glyph_pos.x_offset  += font-&gt;em_scale_x (get_short (values++, &amp;ret));</span>
<span class="line-modified"> 117     if (format &amp; yPlacement) glyph_pos.y_offset  += font-&gt;em_scale_y (get_short (values++, &amp;ret));</span>
 118     if (format &amp; xAdvance) {
<span class="line-modified"> 119       if (likely (horizontal)) glyph_pos.x_advance += font-&gt;em_scale_x (get_short (values, &amp;ret));</span>
 120       values++;
 121     }
 122     /* y_advance values grow downward but font-space grows upward, hence negation */
 123     if (format &amp; yAdvance) {
<span class="line-modified"> 124       if (unlikely (!horizontal)) glyph_pos.y_advance -= font-&gt;em_scale_y (get_short (values, &amp;ret));</span>
 125       values++;
 126     }
 127 
<span class="line-modified"> 128     if (!has_device ()) return ret;</span>
 129 
 130     bool use_x_device = font-&gt;x_ppem || font-&gt;num_coords;
 131     bool use_y_device = font-&gt;y_ppem || font-&gt;num_coords;
 132 
<span class="line-modified"> 133     if (!use_x_device &amp;&amp; !use_y_device) return ret;</span>
 134 
 135     const VariationStore &amp;store = c-&gt;var_store;
 136 
 137     /* pixel -&gt; fractional pixel */
 138     if (format &amp; xPlaDevice) {
<span class="line-modified"> 139       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &amp;ret)).get_x_delta (font, store);</span>
 140       values++;
 141     }
 142     if (format &amp; yPlaDevice) {
<span class="line-modified"> 143       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &amp;ret)).get_y_delta (font, store);</span>
 144       values++;
 145     }
 146     if (format &amp; xAdvDevice) {
<span class="line-modified"> 147       if (horizontal &amp;&amp; use_x_device) glyph_pos.x_advance += (base + get_device (values, &amp;ret)).get_x_delta (font, store);</span>
 148       values++;
 149     }
 150     if (format &amp; yAdvDevice) {
 151       /* y_advance values grow downward but font-space grows upward, hence negation */
<span class="line-modified"> 152       if (!horizontal &amp;&amp; use_y_device) glyph_pos.y_advance -= (base + get_device (values, &amp;ret)).get_y_delta (font, store);</span>
 153       values++;
 154     }
<span class="line-added"> 155     return ret;</span>
 156   }
 157 
 158   private:
<span class="line-modified"> 159   bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
 160   {
 161     unsigned int format = *this;
 162 
 163     if (format &amp; xPlacement) values++;
 164     if (format &amp; yPlacement) values++;
 165     if (format &amp; xAdvance)   values++;
 166     if (format &amp; yAdvance)   values++;
 167 
 168     if ((format &amp; xPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 169     if ((format &amp; yPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 170     if ((format &amp; xAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 171     if ((format &amp; yAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 172 
 173     return true;
 174   }
 175 
<span class="line-modified"> 176   static OffsetTo&lt;Device&gt;&amp; get_device (Value* value)</span>


 177   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }
<span class="line-added"> 178   static const OffsetTo&lt;Device&gt;&amp; get_device (const Value* value, bool *worked=nullptr)</span>
<span class="line-added"> 179   {</span>
<span class="line-added"> 180     if (worked) *worked |= bool (*value);</span>
<span class="line-added"> 181     return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value);</span>
<span class="line-added"> 182   }</span>
 183 
<span class="line-modified"> 184   static const HBINT16&amp; get_short (const Value* value, bool *worked=nullptr)</span>
<span class="line-modified"> 185   {</span>
<span class="line-added"> 186     if (worked) *worked |= bool (*value);</span>
<span class="line-added"> 187     return *CastP&lt;HBINT16&gt; (value);</span>
<span class="line-added"> 188   }</span>
 189 
 190   public:
 191 
<span class="line-modified"> 192   bool has_device () const</span>
<span class="line-added"> 193   {</span>
 194     unsigned int format = *this;
 195     return (format &amp; devices) != 0;
 196   }
 197 
<span class="line-modified"> 198   bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const</span>
 199   {
 200     TRACE_SANITIZE (this);
 201     return_trace (c-&gt;check_range (values, get_size ()) &amp;&amp; (!has_device () || sanitize_value_devices (c, base, values)));
 202   }
 203 
<span class="line-modified"> 204   bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const</span>
 205   {
 206     TRACE_SANITIZE (this);
 207     unsigned int len = get_len ();
 208 
<span class="line-modified"> 209     if (!c-&gt;check_range (values, count, get_size ())) return_trace (false);</span>
 210 
 211     if (!has_device ()) return_trace (true);
 212 
 213     for (unsigned int i = 0; i &lt; count; i++) {
 214       if (!sanitize_value_devices (c, base, values))
 215         return_trace (false);
 216       values += len;
 217     }
 218 
 219     return_trace (true);
 220   }
 221 
 222   /* Just sanitize referenced Device tables.  Doesn&#39;t check the values themselves. */
<span class="line-modified"> 223   bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const</span>
 224   {
 225     TRACE_SANITIZE (this);
 226 
 227     if (!has_device ()) return_trace (true);
 228 
 229     for (unsigned int i = 0; i &lt; count; i++) {
 230       if (!sanitize_value_devices (c, base, values))
 231         return_trace (false);
 232       values += stride;
 233     }
 234 
 235     return_trace (true);
 236   }
 237 };
 238 
 239 
 240 struct AnchorFormat1
 241 {
<span class="line-modified"> 242   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified"> 243                    float *x, float *y) const</span>
 244   {
 245     hb_font_t *font = c-&gt;font;
 246     *x = font-&gt;em_fscale_x (xCoordinate);
 247     *y = font-&gt;em_fscale_y (yCoordinate);
 248   }
 249 
<span class="line-modified"> 250   bool sanitize (hb_sanitize_context_t *c) const</span>
 251   {
 252     TRACE_SANITIZE (this);
 253     return_trace (c-&gt;check_struct (this));
 254   }
 255 
 256   protected:
 257   HBUINT16      format;                 /* Format identifier--format = 1 */
 258   FWORD         xCoordinate;            /* Horizontal value--in design units */
 259   FWORD         yCoordinate;            /* Vertical value--in design units */
 260   public:
 261   DEFINE_SIZE_STATIC (6);
 262 };
 263 
 264 struct AnchorFormat2
 265 {
<span class="line-modified"> 266   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 267                    float *x, float *y) const</span>
 268   {
 269     hb_font_t *font = c-&gt;font;
 270     unsigned int x_ppem = font-&gt;x_ppem;
 271     unsigned int y_ppem = font-&gt;y_ppem;
 272     hb_position_t cx = 0, cy = 0;
<span class="line-modified"> 273     bool ret;</span>
 274 
 275     ret = (x_ppem || y_ppem) &amp;&amp;
<span class="line-modified"> 276           font-&gt;get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &amp;cx, &amp;cy);</span>
 277     *x = ret &amp;&amp; x_ppem ? cx : font-&gt;em_fscale_x (xCoordinate);
 278     *y = ret &amp;&amp; y_ppem ? cy : font-&gt;em_fscale_y (yCoordinate);
 279   }
 280 
<span class="line-modified"> 281   bool sanitize (hb_sanitize_context_t *c) const</span>
 282   {
 283     TRACE_SANITIZE (this);
 284     return_trace (c-&gt;check_struct (this));
 285   }
 286 
 287   protected:
 288   HBUINT16      format;                 /* Format identifier--format = 2 */
 289   FWORD         xCoordinate;            /* Horizontal value--in design units */
 290   FWORD         yCoordinate;            /* Vertical value--in design units */
 291   HBUINT16      anchorPoint;            /* Index to glyph contour point */
 292   public:
 293   DEFINE_SIZE_STATIC (8);
 294 };
 295 
 296 struct AnchorFormat3
 297 {
<span class="line-modified"> 298   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,</span>
<span class="line-modified"> 299                    float *x, float *y) const</span>
 300   {
 301     hb_font_t *font = c-&gt;font;
 302     *x = font-&gt;em_fscale_x (xCoordinate);
 303     *y = font-&gt;em_fscale_y (yCoordinate);
 304 
 305     if (font-&gt;x_ppem || font-&gt;num_coords)
 306       *x += (this+xDeviceTable).get_x_delta (font, c-&gt;var_store);
 307     if (font-&gt;y_ppem || font-&gt;num_coords)
 308       *y += (this+yDeviceTable).get_y_delta (font, c-&gt;var_store);
 309   }
 310 
<span class="line-modified"> 311   bool sanitize (hb_sanitize_context_t *c) const</span>
 312   {
 313     TRACE_SANITIZE (this);
 314     return_trace (c-&gt;check_struct (this) &amp;&amp; xDeviceTable.sanitize (c, this) &amp;&amp; yDeviceTable.sanitize (c, this));
 315   }
 316 
 317   protected:
 318   HBUINT16      format;                 /* Format identifier--format = 3 */
 319   FWORD         xCoordinate;            /* Horizontal value--in design units */
 320   FWORD         yCoordinate;            /* Vertical value--in design units */
 321   OffsetTo&lt;Device&gt;
 322                 xDeviceTable;           /* Offset to Device table for X
 323                                          * coordinate-- from beginning of
 324                                          * Anchor table (may be NULL) */
 325   OffsetTo&lt;Device&gt;
 326                 yDeviceTable;           /* Offset to Device table for Y
 327                                          * coordinate-- from beginning of
 328                                          * Anchor table (may be NULL) */
 329   public:
 330   DEFINE_SIZE_STATIC (10);
 331 };
 332 
 333 struct Anchor
 334 {
<span class="line-modified"> 335   void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 336                    float *x, float *y) const</span>
 337   {
 338     *x = *y = 0;
 339     switch (u.format) {
 340     case 1: u.format1.get_anchor (c, glyph_id, x, y); return;
 341     case 2: u.format2.get_anchor (c, glyph_id, x, y); return;
 342     case 3: u.format3.get_anchor (c, glyph_id, x, y); return;
 343     default:                                          return;
 344     }
 345   }
 346 
<span class="line-modified"> 347   bool sanitize (hb_sanitize_context_t *c) const</span>
 348   {
 349     TRACE_SANITIZE (this);
 350     if (!u.format.sanitize (c)) return_trace (false);
 351     switch (u.format) {
 352     case 1: return_trace (u.format1.sanitize (c));
 353     case 2: return_trace (u.format2.sanitize (c));
 354     case 3: return_trace (u.format3.sanitize (c));
 355     default:return_trace (true);
 356     }
 357   }
 358 
 359   protected:
 360   union {
 361   HBUINT16              format;         /* Format identifier */
 362   AnchorFormat1         format1;
 363   AnchorFormat2         format2;
 364   AnchorFormat3         format3;
 365   } u;
 366   public:
 367   DEFINE_SIZE_UNION (2, format);
 368 };
 369 
 370 
 371 struct AnchorMatrix
 372 {
<span class="line-modified"> 373   const Anchor&amp; get_anchor (unsigned int row, unsigned int col,</span>
<span class="line-added"> 374                             unsigned int cols, bool *found) const</span>
<span class="line-added"> 375   {</span>
 376     *found = false;
 377     if (unlikely (row &gt;= rows || col &gt;= cols)) return Null(Anchor);
 378     *found = !matrixZ[row * cols + col].is_null ();
 379     return this+matrixZ[row * cols + col];
 380   }
 381 
<span class="line-modified"> 382   bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const</span>
 383   {
 384     TRACE_SANITIZE (this);
 385     if (!c-&gt;check_struct (this)) return_trace (false);
<span class="line-modified"> 386     if (unlikely (hb_unsigned_mul_overflows (rows, cols))) return_trace (false);</span>
 387     unsigned int count = rows * cols;
<span class="line-modified"> 388     if (!c-&gt;check_array (matrixZ.arrayZ, count)) return_trace (false);</span>
 389     for (unsigned int i = 0; i &lt; count; i++)
 390       if (!matrixZ[i].sanitize (c, this)) return_trace (false);
 391     return_trace (true);
 392   }
 393 
 394   HBUINT16      rows;                   /* Number of rows */
 395   protected:
<span class="line-modified"> 396   UnsizedArrayOf&lt;OffsetTo&lt;Anchor&gt; &gt;</span>
<span class="line-modified"> 397                 matrixZ;                /* Matrix of offsets to Anchor tables--</span>
 398                                          * from beginning of AnchorMatrix table */
 399   public:
 400   DEFINE_SIZE_ARRAY (2, matrixZ);
 401 };
 402 
 403 
 404 struct MarkRecord
 405 {
 406   friend struct MarkArray;
 407 
<span class="line-modified"> 408   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 409   {
 410     TRACE_SANITIZE (this);
 411     return_trace (c-&gt;check_struct (this) &amp;&amp; markAnchor.sanitize (c, base));
 412   }
 413 
 414   protected:
 415   HBUINT16      klass;                  /* Class defined for this mark */
 416   OffsetTo&lt;Anchor&gt;
 417                 markAnchor;             /* Offset to Anchor table--from
 418                                          * beginning of MarkArray table */
 419   public:
 420   DEFINE_SIZE_STATIC (4);
 421 };
 422 
 423 struct MarkArray : ArrayOf&lt;MarkRecord&gt;  /* Array of MarkRecords--in Coverage order */
 424 {
<span class="line-modified"> 425   bool apply (hb_ot_apply_context_t *c,</span>
<span class="line-modified"> 426               unsigned int mark_index, unsigned int glyph_index,</span>
<span class="line-modified"> 427               const AnchorMatrix &amp;anchors, unsigned int class_count,</span>
<span class="line-modified"> 428               unsigned int glyph_pos) const</span>
 429   {
 430     TRACE_APPLY (this);
 431     hb_buffer_t *buffer = c-&gt;buffer;
 432     const MarkRecord &amp;record = ArrayOf&lt;MarkRecord&gt;::operator[](mark_index);
 433     unsigned int mark_class = record.klass;
 434 
 435     const Anchor&amp; mark_anchor = this + record.markAnchor;
 436     bool found;
 437     const Anchor&amp; glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &amp;found);
 438     /* If this subtable doesn&#39;t have an anchor for this base and this class,
 439      * return false such that the subsequent subtables have a chance at it. */
 440     if (unlikely (!found)) return_trace (false);
 441 
 442     float mark_x, mark_y, base_x, base_y;
 443 
 444     buffer-&gt;unsafe_to_break (glyph_pos, buffer-&gt;idx);
 445     mark_anchor.get_anchor (c, buffer-&gt;cur().codepoint, &amp;mark_x, &amp;mark_y);
 446     glyph_anchor.get_anchor (c, buffer-&gt;info[glyph_pos].codepoint, &amp;base_x, &amp;base_y);
 447 
 448     hb_glyph_position_t &amp;o = buffer-&gt;cur_pos();
 449     o.x_offset = round (base_x - mark_x);
 450     o.y_offset = round (base_y - mark_y);
 451     o.attach_type() = ATTACH_TYPE_MARK;
 452     o.attach_chain() = (int) glyph_pos - (int) buffer-&gt;idx;
 453     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
 454 
 455     buffer-&gt;idx++;
 456     return_trace (true);
 457   }
 458 
<span class="line-modified"> 459   bool sanitize (hb_sanitize_context_t *c) const</span>
 460   {
 461     TRACE_SANITIZE (this);
 462     return_trace (ArrayOf&lt;MarkRecord&gt;::sanitize (c, this));
 463   }
 464 };
 465 
 466 
 467 /* Lookups */
 468 
 469 struct SinglePosFormat1
 470 {
<span class="line-modified"> 471   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified"> 472   { return (this+coverage).intersects (glyphs); }</span>



 473 
<span class="line-modified"> 474   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 475   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>
<span class="line-modified"> 476 </span>
<span class="line-modified"> 477   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
 478 
<span class="line-modified"> 479   bool apply (hb_ot_apply_context_t *c) const</span>
 480   {
 481     TRACE_APPLY (this);
 482     hb_buffer_t *buffer = c-&gt;buffer;
 483     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 484     if (likely (index == NOT_COVERED)) return_trace (false);
 485 
 486     valueFormat.apply_value (c, this, values, buffer-&gt;cur_pos());
 487 
 488     buffer-&gt;idx++;
 489     return_trace (true);
 490   }
 491 
<span class="line-modified"> 492   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 493   {</span>
<span class="line-added"> 494     TRACE_SUBSET (this);</span>
<span class="line-added"> 495     // TODO(subset)</span>
<span class="line-added"> 496     return_trace (false);</span>
<span class="line-added"> 497   }</span>
<span class="line-added"> 498 </span>
<span class="line-added"> 499   bool sanitize (hb_sanitize_context_t *c) const</span>
 500   {
 501     TRACE_SANITIZE (this);
 502     return_trace (c-&gt;check_struct (this) &amp;&amp;
 503                   coverage.sanitize (c, this) &amp;&amp;
 504                   valueFormat.sanitize_value (c, this, values));
 505   }
 506 
 507   protected:
 508   HBUINT16      format;                 /* Format identifier--format = 1 */
 509   OffsetTo&lt;Coverage&gt;
 510                 coverage;               /* Offset to Coverage table--from
 511                                          * beginning of subtable */
 512   ValueFormat   valueFormat;            /* Defines the types of data in the
 513                                          * ValueRecord */
 514   ValueRecord   values;                 /* Defines positioning
 515                                          * value(s)--applied to all glyphs in
 516                                          * the Coverage table */
 517   public:
 518   DEFINE_SIZE_ARRAY (6, values);
 519 };
 520 
 521 struct SinglePosFormat2
 522 {
<span class="line-modified"> 523   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified"> 524   { return (this+coverage).intersects (glyphs); }</span>



 525 
<span class="line-modified"> 526   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 527   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>
<span class="line-modified"> 528 </span>
<span class="line-modified"> 529   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
 530 
<span class="line-modified"> 531   bool apply (hb_ot_apply_context_t *c) const</span>
 532   {
 533     TRACE_APPLY (this);
 534     hb_buffer_t *buffer = c-&gt;buffer;
 535     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 536     if (likely (index == NOT_COVERED)) return_trace (false);
 537 
 538     if (likely (index &gt;= valueCount)) return_trace (false);
 539 
 540     valueFormat.apply_value (c, this,
 541                              &amp;values[index * valueFormat.get_len ()],
 542                              buffer-&gt;cur_pos());
 543 
 544     buffer-&gt;idx++;
 545     return_trace (true);
 546   }
 547 
<span class="line-modified"> 548   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 549   {</span>
<span class="line-added"> 550     TRACE_SUBSET (this);</span>
<span class="line-added"> 551     // TODO(subset)</span>
<span class="line-added"> 552     return_trace (false);</span>
<span class="line-added"> 553   }</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555   bool sanitize (hb_sanitize_context_t *c) const</span>
 556   {
 557     TRACE_SANITIZE (this);
 558     return_trace (c-&gt;check_struct (this) &amp;&amp;
 559                   coverage.sanitize (c, this) &amp;&amp;
 560                   valueFormat.sanitize_values (c, this, values, valueCount));
 561   }
 562 
 563   protected:
 564   HBUINT16      format;                 /* Format identifier--format = 2 */
 565   OffsetTo&lt;Coverage&gt;
 566                 coverage;               /* Offset to Coverage table--from
 567                                          * beginning of subtable */
 568   ValueFormat   valueFormat;            /* Defines the types of data in the
 569                                          * ValueRecord */
 570   HBUINT16      valueCount;             /* Number of ValueRecords */
 571   ValueRecord   values;                 /* Array of ValueRecords--positioning
 572                                          * values applied to glyphs */
 573   public:
 574   DEFINE_SIZE_ARRAY (8, values);
 575 };
 576 
 577 struct SinglePos
 578 {
 579   template &lt;typename context_t&gt;
<span class="line-modified"> 580   typename context_t::return_t dispatch (context_t *c) const</span>
 581   {
 582     TRACE_DISPATCH (this, u.format);
 583     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 584     switch (u.format) {
 585     case 1: return_trace (c-&gt;dispatch (u.format1));
 586     case 2: return_trace (c-&gt;dispatch (u.format2));
 587     default:return_trace (c-&gt;default_return_value ());
 588     }
 589   }
 590 
 591   protected:
 592   union {
 593   HBUINT16              format;         /* Format identifier */
 594   SinglePosFormat1      format1;
 595   SinglePosFormat2      format2;
 596   } u;
 597 };
 598 
 599 
 600 struct PairValueRecord
 601 {
 602   friend struct PairSet;
 603 
 604   protected:
 605   GlyphID       secondGlyph;            /* GlyphID of second glyph in the
 606                                          * pair--first glyph is listed in the
 607                                          * Coverage table */
 608   ValueRecord   values;                 /* Positioning data for the first glyph
 609                                          * followed by for second glyph */
 610   public:
 611   DEFINE_SIZE_ARRAY (2, values);
 612 };
 613 
 614 struct PairSet
 615 {
 616   friend struct PairPosFormat1;
 617 
<span class="line-modified"> 618   bool intersects (const hb_set_t *glyphs,</span>
<span class="line-added"> 619                           const ValueFormat *valueFormats) const</span>
<span class="line-added"> 620   {</span>
<span class="line-added"> 621     unsigned int len1 = valueFormats[0].get_len ();</span>
<span class="line-added"> 622     unsigned int len2 = valueFormats[1].get_len ();</span>
<span class="line-added"> 623     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
<span class="line-added"> 626     unsigned int count = len;</span>
<span class="line-added"> 627     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 628     {</span>
<span class="line-added"> 629       if (glyphs-&gt;has (record-&gt;secondGlyph))</span>
<span class="line-added"> 630         return true;</span>
<span class="line-added"> 631       record = &amp;StructAtOffset&lt;const PairValueRecord&gt; (record, record_size);</span>
<span class="line-added"> 632     }</span>
<span class="line-added"> 633     return false;</span>
<span class="line-added"> 634   }</span>
<span class="line-added"> 635 </span>
<span class="line-added"> 636   void collect_glyphs (hb_collect_glyphs_context_t *c,</span>
 637                               const ValueFormat *valueFormats) const
 638   {

 639     unsigned int len1 = valueFormats[0].get_len ();
 640     unsigned int len2 = valueFormats[1].get_len ();
 641     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 642 
<span class="line-modified"> 643     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
 644     c-&gt;input-&gt;add_array (&amp;record-&gt;secondGlyph, len, record_size);
 645   }
 646 
<span class="line-modified"> 647   bool apply (hb_ot_apply_context_t *c,</span>
 648                      const ValueFormat *valueFormats,
 649                      unsigned int pos) const
 650   {
 651     TRACE_APPLY (this);
 652     hb_buffer_t *buffer = c-&gt;buffer;
 653     unsigned int len1 = valueFormats[0].get_len ();
 654     unsigned int len2 = valueFormats[1].get_len ();
 655     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 656 

 657     unsigned int count = len;
 658 
 659     /* Hand-coded bsearch. */
 660     if (unlikely (!count))
 661       return_trace (false);
 662     hb_codepoint_t x = buffer-&gt;info[pos].codepoint;
 663     int min = 0, max = (int) count - 1;
 664     while (min &lt;= max)
 665     {
<span class="line-modified"> 666       int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
<span class="line-modified"> 667       const PairValueRecord *record = &amp;StructAtOffset&lt;PairValueRecord&gt; (&amp;firstPairValueRecord, record_size * mid);</span>
 668       hb_codepoint_t mid_x = record-&gt;secondGlyph;
 669       if (x &lt; mid_x)
 670         max = mid - 1;
 671       else if (x &gt; mid_x)
 672         min = mid + 1;
 673       else
 674       {
<span class="line-modified"> 675         /* Note the intentional use of &quot;|&quot; instead of short-circuit &quot;||&quot;. */</span>
<span class="line-modified"> 676         if (valueFormats[0].apply_value (c, this, &amp;record-&gt;values[0], buffer-&gt;cur_pos()) |</span>
<span class="line-modified"> 677             valueFormats[1].apply_value (c, this, &amp;record-&gt;values[len1], buffer-&gt;pos[pos]))</span>
<span class="line-added"> 678           buffer-&gt;unsafe_to_break (buffer-&gt;idx, pos + 1);</span>
 679         if (len2)
 680           pos++;
 681         buffer-&gt;idx = pos;
 682         return_trace (true);
 683       }
 684     }
 685 
 686     return_trace (false);
 687   }
 688 
<span class="line-modified"> 689   struct sanitize_closure_t</span>
<span class="line-added"> 690   {</span>
 691     const void *base;
 692     const ValueFormat *valueFormats;
 693     unsigned int len1; /* valueFormats[0].get_len() */
 694     unsigned int stride; /* 1 + len1 + len2 */
 695   };
 696 
<span class="line-modified"> 697   bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const</span>
 698   {
 699     TRACE_SANITIZE (this);
 700     if (!(c-&gt;check_struct (this)
<span class="line-modified"> 701        &amp;&amp; c-&gt;check_range (&amp;firstPairValueRecord,</span>
<span class="line-added"> 702                           len,</span>
<span class="line-added"> 703                           HBUINT16::static_size,</span>
<span class="line-added"> 704                           closure-&gt;stride))) return_trace (false);</span>
 705 
 706     unsigned int count = len;
<span class="line-modified"> 707     const PairValueRecord *record = &amp;firstPairValueRecord;</span>
 708     return_trace (closure-&gt;valueFormats[0].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[0], count, closure-&gt;stride) &amp;&amp;
 709                   closure-&gt;valueFormats[1].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[closure-&gt;len1], count, closure-&gt;stride));
 710   }
 711 
 712   protected:
<span class="line-modified"> 713   HBUINT16              len;    /* Number of PairValueRecords */</span>
<span class="line-modified"> 714   PairValueRecord       firstPairValueRecord;</span>
<span class="line-modified"> 715                                 /* Array of PairValueRecords--ordered</span>
<span class="line-added"> 716                                  * by GlyphID of the second glyph */</span>
 717   public:
<span class="line-modified"> 718   DEFINE_SIZE_MIN (2);</span>
 719 };
 720 
 721 struct PairPosFormat1
 722 {
<span class="line-modified"> 723   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 724   {</span>
<span class="line-added"> 725     unsigned int count = pairSet.len;</span>
<span class="line-added"> 726     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 727     {</span>
<span class="line-added"> 728       if (unlikely (iter.get_coverage () &gt;= count))</span>
<span class="line-added"> 729         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */</span>
<span class="line-added"> 730       if (glyphs-&gt;has (iter.get_glyph ()) &amp;&amp;</span>
<span class="line-added"> 731           (this+pairSet[iter.get_coverage ()]).intersects (glyphs, valueFormat))</span>
<span class="line-added"> 732         return true;</span>
<span class="line-added"> 733     }</span>
<span class="line-added"> 734     return false;</span>
<span class="line-added"> 735   }</span>
<span class="line-added"> 736 </span>
<span class="line-added"> 737   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 738   {

 739     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 740     unsigned int count = pairSet.len;
 741     for (unsigned int i = 0; i &lt; count; i++)
 742       (this+pairSet[i]).collect_glyphs (c, valueFormat);
 743   }
 744 
<span class="line-modified"> 745   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 746 
<span class="line-modified"> 747   bool apply (hb_ot_apply_context_t *c) const</span>
 748   {
 749     TRACE_APPLY (this);
 750     hb_buffer_t *buffer = c-&gt;buffer;
 751     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 752     if (likely (index == NOT_COVERED)) return_trace (false);
 753 
 754     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 755     skippy_iter.reset (buffer-&gt;idx, 1);
 756     if (!skippy_iter.next ()) return_trace (false);
 757 
 758     return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
 759   }
 760 
<span class="line-modified"> 761   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 762   {</span>
<span class="line-added"> 763     TRACE_SUBSET (this);</span>
<span class="line-added"> 764     // TODO(subset)</span>
<span class="line-added"> 765     return_trace (false);</span>
<span class="line-added"> 766   }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768   bool sanitize (hb_sanitize_context_t *c) const</span>
 769   {
 770     TRACE_SANITIZE (this);
 771 
 772     if (!c-&gt;check_struct (this)) return_trace (false);
 773 
 774     unsigned int len1 = valueFormat[0].get_len ();
 775     unsigned int len2 = valueFormat[1].get_len ();
<span class="line-modified"> 776     PairSet::sanitize_closure_t closure =</span>
<span class="line-added"> 777     {</span>
 778       this,
 779       valueFormat,
 780       len1,
 781       1 + len1 + len2
 782     };
 783 
 784     return_trace (coverage.sanitize (c, this) &amp;&amp; pairSet.sanitize (c, this, &amp;closure));
 785   }
 786 
 787   protected:
 788   HBUINT16      format;                 /* Format identifier--format = 1 */
 789   OffsetTo&lt;Coverage&gt;
 790                 coverage;               /* Offset to Coverage table--from
 791                                          * beginning of subtable */
 792   ValueFormat   valueFormat[2];         /* [0] Defines the types of data in
 793                                          * ValueRecord1--for the first glyph
 794                                          * in the pair--may be zero (0) */
 795                                         /* [1] Defines the types of data in
 796                                          * ValueRecord2--for the second glyph
 797                                          * in the pair--may be zero (0) */
 798   OffsetArrayOf&lt;PairSet&gt;
 799                 pairSet;                /* Array of PairSet tables
 800                                          * ordered by Coverage Index */
 801   public:
 802   DEFINE_SIZE_ARRAY (10, pairSet);
 803 };
 804 
 805 struct PairPosFormat2
 806 {
<span class="line-modified"> 807   bool intersects (const hb_set_t *glyphs) const</span>
 808   {
<span class="line-modified"> 809     return (this+coverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-modified"> 810            (this+classDef2).intersects (glyphs);</span>

 811   }
 812 
<span class="line-modified"> 813   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 814   {
<span class="line-modified"> 815     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;</span>
<span class="line-added"> 816     if (unlikely (!(this+classDef2).add_coverage (c-&gt;input))) return;</span>
 817   }
 818 
<span class="line-modified"> 819   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
<span class="line-added"> 820 </span>
<span class="line-added"> 821   bool apply (hb_ot_apply_context_t *c) const</span>
 822   {
 823     TRACE_APPLY (this);
 824     hb_buffer_t *buffer = c-&gt;buffer;
 825     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 826     if (likely (index == NOT_COVERED)) return_trace (false);
 827 
 828     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 829     skippy_iter.reset (buffer-&gt;idx, 1);
 830     if (!skippy_iter.next ()) return_trace (false);
 831 
 832     unsigned int len1 = valueFormat1.get_len ();
 833     unsigned int len2 = valueFormat2.get_len ();
 834     unsigned int record_len = len1 + len2;
 835 
 836     unsigned int klass1 = (this+classDef1).get_class (buffer-&gt;cur().codepoint);
 837     unsigned int klass2 = (this+classDef2).get_class (buffer-&gt;info[skippy_iter.idx].codepoint);
 838     if (unlikely (klass1 &gt;= class1Count || klass2 &gt;= class2Count)) return_trace (false);
 839 

 840     const Value *v = &amp;values[record_len * (klass1 * class2Count + klass2)];
<span class="line-modified"> 841     /* Note the intentional use of &quot;|&quot; instead of short-circuit &quot;||&quot;. */</span>
<span class="line-modified"> 842     if (valueFormat1.apply_value (c, this, v, buffer-&gt;cur_pos()) |</span>
<span class="line-added"> 843         valueFormat2.apply_value (c, this, v + len1, buffer-&gt;pos[skippy_iter.idx]))</span>
<span class="line-added"> 844       buffer-&gt;unsafe_to_break (buffer-&gt;idx, skippy_iter.idx + 1);</span>
 845 
 846     buffer-&gt;idx = skippy_iter.idx;
 847     if (len2)
 848       buffer-&gt;idx++;
 849 
 850     return_trace (true);
 851   }
 852 
<span class="line-modified"> 853   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 854   {</span>
<span class="line-added"> 855     TRACE_SUBSET (this);</span>
<span class="line-added"> 856     // TODO(subset)</span>
<span class="line-added"> 857     return_trace (false);</span>
<span class="line-added"> 858   }</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860   bool sanitize (hb_sanitize_context_t *c) const</span>
 861   {
 862     TRACE_SANITIZE (this);
 863     if (!(c-&gt;check_struct (this)
 864        &amp;&amp; coverage.sanitize (c, this)
 865        &amp;&amp; classDef1.sanitize (c, this)
 866        &amp;&amp; classDef2.sanitize (c, this))) return_trace (false);
 867 
 868     unsigned int len1 = valueFormat1.get_len ();
 869     unsigned int len2 = valueFormat2.get_len ();
 870     unsigned int stride = len1 + len2;
 871     unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
 872     unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
<span class="line-modified"> 873     return_trace (c-&gt;check_range ((const void *) values,</span>
<span class="line-added"> 874                                   count,</span>
<span class="line-added"> 875                                   record_size) &amp;&amp;</span>
 876                   valueFormat1.sanitize_values_stride_unsafe (c, this, &amp;values[0], count, stride) &amp;&amp;
 877                   valueFormat2.sanitize_values_stride_unsafe (c, this, &amp;values[len1], count, stride));
 878   }
 879 
 880   protected:
 881   HBUINT16      format;                 /* Format identifier--format = 2 */
 882   OffsetTo&lt;Coverage&gt;
 883                 coverage;               /* Offset to Coverage table--from
 884                                          * beginning of subtable */
 885   ValueFormat   valueFormat1;           /* ValueRecord definition--for the
 886                                          * first glyph of the pair--may be zero
 887                                          * (0) */
 888   ValueFormat   valueFormat2;           /* ValueRecord definition--for the
 889                                          * second glyph of the pair--may be
 890                                          * zero (0) */
 891   OffsetTo&lt;ClassDef&gt;
 892                 classDef1;              /* Offset to ClassDef table--from
 893                                          * beginning of PairPos subtable--for
 894                                          * the first glyph of the pair */
 895   OffsetTo&lt;ClassDef&gt;
 896                 classDef2;              /* Offset to ClassDef table--from
 897                                          * beginning of PairPos subtable--for
 898                                          * the second glyph of the pair */
 899   HBUINT16      class1Count;            /* Number of classes in ClassDef1
 900                                          * table--includes Class0 */
 901   HBUINT16      class2Count;            /* Number of classes in ClassDef2
 902                                          * table--includes Class0 */
 903   ValueRecord   values;                 /* Matrix of value pairs:
 904                                          * class1-major, class2-minor,
 905                                          * Each entry has value1 and value2 */
 906   public:
 907   DEFINE_SIZE_ARRAY (16, values);
 908 };
 909 
 910 struct PairPos
 911 {
 912   template &lt;typename context_t&gt;
<span class="line-modified"> 913   typename context_t::return_t dispatch (context_t *c) const</span>
 914   {
 915     TRACE_DISPATCH (this, u.format);
 916     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 917     switch (u.format) {
 918     case 1: return_trace (c-&gt;dispatch (u.format1));
 919     case 2: return_trace (c-&gt;dispatch (u.format2));
 920     default:return_trace (c-&gt;default_return_value ());
 921     }
 922   }
 923 
 924   protected:
 925   union {
 926   HBUINT16              format;         /* Format identifier */
 927   PairPosFormat1        format1;
 928   PairPosFormat2        format2;
 929   } u;
 930 };
 931 
 932 
 933 struct EntryExitRecord
 934 {
 935   friend struct CursivePosFormat1;
 936 
<span class="line-modified"> 937   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 938   {
 939     TRACE_SANITIZE (this);
 940     return_trace (entryAnchor.sanitize (c, base) &amp;&amp; exitAnchor.sanitize (c, base));
 941   }
 942 
 943   protected:
 944   OffsetTo&lt;Anchor&gt;
 945                 entryAnchor;            /* Offset to EntryAnchor table--from
 946                                          * beginning of CursivePos
 947                                          * subtable--may be NULL */
 948   OffsetTo&lt;Anchor&gt;
 949                 exitAnchor;             /* Offset to ExitAnchor table--from
 950                                          * beginning of CursivePos
 951                                          * subtable--may be NULL */
 952   public:
 953   DEFINE_SIZE_STATIC (4);
 954 };
 955 
 956 static void
 957 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);
 958 
 959 struct CursivePosFormat1
 960 {
<span class="line-modified"> 961   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-modified"> 962   { return (this+coverage).intersects (glyphs); }</span>



 963 
<span class="line-modified"> 964   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 965   { if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return; }</span>


 966 
<span class="line-modified"> 967   const Coverage &amp;get_coverage () const { return this+coverage; }</span>
<span class="line-added"> 968 </span>
<span class="line-added"> 969   bool apply (hb_ot_apply_context_t *c) const</span>
 970   {
 971     TRACE_APPLY (this);
 972     hb_buffer_t *buffer = c-&gt;buffer;
 973 
 974     const EntryExitRecord &amp;this_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;cur().codepoint)];
<span class="line-modified"> 975     if (!this_record.entryAnchor) return_trace (false);</span>
 976 
 977     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 978     skippy_iter.reset (buffer-&gt;idx, 1);
<span class="line-modified"> 979     if (!skippy_iter.prev ()) return_trace (false);</span>
 980 
<span class="line-modified"> 981     const EntryExitRecord &amp;prev_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint)];</span>
<span class="line-modified"> 982     if (!prev_record.exitAnchor) return_trace (false);</span>
 983 
<span class="line-modified"> 984     unsigned int i = skippy_iter.idx;</span>
<span class="line-modified"> 985     unsigned int j = buffer-&gt;idx;</span>
 986 
 987     buffer-&gt;unsafe_to_break (i, j);
 988     float entry_x, entry_y, exit_x, exit_y;
<span class="line-modified"> 989     (this+prev_record.exitAnchor).get_anchor (c, buffer-&gt;info[i].codepoint, &amp;exit_x, &amp;exit_y);</span>
<span class="line-modified"> 990     (this+this_record.entryAnchor).get_anchor (c, buffer-&gt;info[j].codepoint, &amp;entry_x, &amp;entry_y);</span>
 991 
 992     hb_glyph_position_t *pos = buffer-&gt;pos;
 993 
 994     hb_position_t d;
 995     /* Main-direction adjustment */
 996     switch (c-&gt;direction) {
 997       case HB_DIRECTION_LTR:
 998         pos[i].x_advance  = round (exit_x) + pos[i].x_offset;
 999 
1000         d = round (entry_x) + pos[j].x_offset;
1001         pos[j].x_advance -= d;
1002         pos[j].x_offset  -= d;
1003         break;
1004       case HB_DIRECTION_RTL:
1005         d = round (exit_x) + pos[i].x_offset;
1006         pos[i].x_advance -= d;
1007         pos[i].x_offset  -= d;
1008 
1009         pos[j].x_advance  = round (entry_x) + pos[j].x_offset;
1010         break;
</pre>
<hr />
<pre>
1017         break;
1018       case HB_DIRECTION_BTT:
1019         d = round (exit_y) + pos[i].y_offset;
1020         pos[i].y_advance -= d;
1021         pos[i].y_offset  -= d;
1022 
1023         pos[j].y_advance  = round (entry_y);
1024         break;
1025       case HB_DIRECTION_INVALID:
1026       default:
1027         break;
1028     }
1029 
1030     /* Cross-direction adjustment */
1031 
1032     /* We attach child to parent (think graph theory and rooted trees whereas
1033      * the root stays on baseline and each node aligns itself against its
1034      * parent.
1035      *
1036      * Optimize things for the case of RightToLeft, as that&#39;s most common in
<span class="line-modified">1037      * Arabic. */</span>
1038     unsigned int child  = i;
1039     unsigned int parent = j;
1040     hb_position_t x_offset = entry_x - exit_x;
1041     hb_position_t y_offset = entry_y - exit_y;
1042     if  (!(c-&gt;lookup_props &amp; LookupFlag::RightToLeft))
1043     {
1044       unsigned int k = child;
1045       child = parent;
1046       parent = k;
1047       x_offset = -x_offset;
1048       y_offset = -y_offset;
1049     }
1050 
1051     /* If child was already connected to someone else, walk through its old
1052      * chain and reverse the link direction, such that the whole tree of its
1053      * previous connection now attaches to new parent.  Watch out for case
1054      * where new parent is on the path from old chain...
1055      */
1056     reverse_cursive_minor_offset (pos, child, c-&gt;direction, parent);
1057 
1058     pos[child].attach_type() = ATTACH_TYPE_CURSIVE;
1059     pos[child].attach_chain() = (int) parent - (int) child;
1060     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
1061     if (likely (HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction)))
1062       pos[child].y_offset = y_offset;
1063     else
1064       pos[child].x_offset = x_offset;
1065 
<span class="line-modified">1066     buffer-&gt;idx++;</span>
1067     return_trace (true);
1068   }
1069 
<span class="line-modified">1070   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1071   {</span>
<span class="line-added">1072     TRACE_SUBSET (this);</span>
<span class="line-added">1073     // TODO(subset)</span>
<span class="line-added">1074     return_trace (false);</span>
<span class="line-added">1075   }</span>
<span class="line-added">1076 </span>
<span class="line-added">1077   bool sanitize (hb_sanitize_context_t *c) const</span>
1078   {
1079     TRACE_SANITIZE (this);
1080     return_trace (coverage.sanitize (c, this) &amp;&amp; entryExitRecord.sanitize (c, this));
1081   }
1082 
1083   protected:
1084   HBUINT16      format;                 /* Format identifier--format = 1 */
1085   OffsetTo&lt;Coverage&gt;
1086                 coverage;               /* Offset to Coverage table--from
1087                                          * beginning of subtable */
1088   ArrayOf&lt;EntryExitRecord&gt;
1089                 entryExitRecord;        /* Array of EntryExit records--in
1090                                          * Coverage Index order */
1091   public:
1092   DEFINE_SIZE_ARRAY (6, entryExitRecord);
1093 };
1094 
1095 struct CursivePos
1096 {
1097   template &lt;typename context_t&gt;
<span class="line-modified">1098   typename context_t::return_t dispatch (context_t *c) const</span>
1099   {
1100     TRACE_DISPATCH (this, u.format);
1101     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1102     switch (u.format) {
1103     case 1: return_trace (c-&gt;dispatch (u.format1));
1104     default:return_trace (c-&gt;default_return_value ());
1105     }
1106   }
1107 
1108   protected:
1109   union {
1110   HBUINT16              format;         /* Format identifier */
1111   CursivePosFormat1     format1;
1112   } u;
1113 };
1114 
1115 
1116 typedef AnchorMatrix BaseArray;         /* base-major--
1117                                          * in order of BaseCoverage Index--,
1118                                          * mark-minor--
1119                                          * ordered by class--zero-based. */
1120 
1121 struct MarkBasePosFormat1
1122 {
<span class="line-modified">1123   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1124   { return (this+markCoverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">1125            (this+baseCoverage).intersects (glyphs); }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1128   {

1129     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1130     if (unlikely (!(this+baseCoverage).add_coverage (c-&gt;input))) return;
1131   }
1132 
<span class="line-modified">1133   const Coverage &amp;get_coverage () const { return this+markCoverage; }</span>



1134 
<span class="line-modified">1135   bool apply (hb_ot_apply_context_t *c) const</span>
1136   {
1137     TRACE_APPLY (this);
1138     hb_buffer_t *buffer = c-&gt;buffer;
1139     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1140     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1141 
1142     /* Now we search backwards for a non-mark glyph */
1143     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1144     skippy_iter.reset (buffer-&gt;idx, 1);
1145     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1146     do {
1147       if (!skippy_iter.prev ()) return_trace (false);
1148       /* We only want to attach to the first of a MultipleSubst sequence.
1149        * https://github.com/harfbuzz/harfbuzz/issues/740
1150        * Reject others...
1151        * ...but stop if we find a mark in the MultipleSubst sequence:
1152        * https://github.com/harfbuzz/harfbuzz/issues/1020 */
1153       if (!_hb_glyph_info_multiplied (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1154           0 == _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1155           (skippy_iter.idx == 0 ||
1156            _hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1157            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1158            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1159            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1160            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx - 1]) + 1
1161            ))
1162         break;
1163       skippy_iter.reject ();
<span class="line-modified">1164     } while (true);</span>
1165 
1166     /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */
1167     //if (!_hb_glyph_info_is_base_glyph (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1168 
1169     unsigned int base_index = (this+baseCoverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint);
1170     if (base_index == NOT_COVERED) return_trace (false);
1171 
1172     return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
1173   }
1174 
<span class="line-modified">1175   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1176   {</span>
<span class="line-added">1177     TRACE_SUBSET (this);</span>
<span class="line-added">1178     // TODO(subset)</span>
<span class="line-added">1179     return_trace (false);</span>
<span class="line-added">1180   }</span>
<span class="line-added">1181 </span>
<span class="line-added">1182   bool sanitize (hb_sanitize_context_t *c) const</span>
1183   {
1184     TRACE_SANITIZE (this);
1185     return_trace (c-&gt;check_struct (this) &amp;&amp;
1186                   markCoverage.sanitize (c, this) &amp;&amp;
1187                   baseCoverage.sanitize (c, this) &amp;&amp;
1188                   markArray.sanitize (c, this) &amp;&amp;
1189                   baseArray.sanitize (c, this, (unsigned int) classCount));
1190   }
1191 
1192   protected:
1193   HBUINT16      format;                 /* Format identifier--format = 1 */
1194   OffsetTo&lt;Coverage&gt;
1195                 markCoverage;           /* Offset to MarkCoverage table--from
1196                                          * beginning of MarkBasePos subtable */
1197   OffsetTo&lt;Coverage&gt;
1198                 baseCoverage;           /* Offset to BaseCoverage table--from
1199                                          * beginning of MarkBasePos subtable */
1200   HBUINT16      classCount;             /* Number of classes defined for marks */
1201   OffsetTo&lt;MarkArray&gt;
1202                 markArray;              /* Offset to MarkArray table--from
1203                                          * beginning of MarkBasePos subtable */
1204   OffsetTo&lt;BaseArray&gt;
1205                 baseArray;              /* Offset to BaseArray table--from
1206                                          * beginning of MarkBasePos subtable */
1207   public:
1208   DEFINE_SIZE_STATIC (12);
1209 };
1210 
1211 struct MarkBasePos
1212 {
1213   template &lt;typename context_t&gt;
<span class="line-modified">1214   typename context_t::return_t dispatch (context_t *c) const</span>
1215   {
1216     TRACE_DISPATCH (this, u.format);
1217     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1218     switch (u.format) {
1219     case 1: return_trace (c-&gt;dispatch (u.format1));
1220     default:return_trace (c-&gt;default_return_value ());
1221     }
1222   }
1223 
1224   protected:
1225   union {
1226   HBUINT16              format;         /* Format identifier */
1227   MarkBasePosFormat1    format1;
1228   } u;
1229 };
1230 
1231 
1232 typedef AnchorMatrix LigatureAttach;    /* component-major--
1233                                          * in order of writing direction--,
1234                                          * mark-minor--
1235                                          * ordered by class--zero-based. */
1236 
1237 typedef OffsetListOf&lt;LigatureAttach&gt; LigatureArray;
1238                                         /* Array of LigatureAttach
1239                                          * tables ordered by
1240                                          * LigatureCoverage Index */
1241 
1242 struct MarkLigPosFormat1
1243 {
<span class="line-modified">1244   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1245   { return (this+markCoverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">1246            (this+ligatureCoverage).intersects (glyphs); }</span>
<span class="line-added">1247 </span>
<span class="line-added">1248   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1249   {

1250     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1251     if (unlikely (!(this+ligatureCoverage).add_coverage (c-&gt;input))) return;
1252   }
1253 
<span class="line-modified">1254   const Coverage &amp;get_coverage () const { return this+markCoverage; }</span>



1255 
<span class="line-modified">1256   bool apply (hb_ot_apply_context_t *c) const</span>
1257   {
1258     TRACE_APPLY (this);
1259     hb_buffer_t *buffer = c-&gt;buffer;
1260     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1261     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1262 
1263     /* Now we search backwards for a non-mark glyph */
1264     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1265     skippy_iter.reset (buffer-&gt;idx, 1);
1266     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1267     if (!skippy_iter.prev ()) return_trace (false);
1268 
1269     /* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled */
1270     //if (!_hb_glyph_info_is_ligature (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1271 
1272     unsigned int j = skippy_iter.idx;
1273     unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer-&gt;info[j].codepoint);
1274     if (lig_index == NOT_COVERED) return_trace (false);
1275 
1276     const LigatureArray&amp; lig_array = this+ligatureArray;
</pre>
<hr />
<pre>
1279     /* Find component to attach to */
1280     unsigned int comp_count = lig_attach.rows;
1281     if (unlikely (!comp_count)) return_trace (false);
1282 
1283     /* We must now check whether the ligature ID of the current mark glyph
1284      * is identical to the ligature ID of the found ligature.  If yes, we
1285      * can directly use the component index.  If not, we attach the mark
1286      * glyph to the last component of the ligature. */
1287     unsigned int comp_index;
1288     unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1289     unsigned int mark_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1290     unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1291     if (lig_id &amp;&amp; lig_id == mark_id &amp;&amp; mark_comp &gt; 0)
1292       comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur())) - 1;
1293     else
1294       comp_index = comp_count - 1;
1295 
1296     return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
1297   }
1298 
<span class="line-modified">1299   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1300   {</span>
<span class="line-added">1301     TRACE_SUBSET (this);</span>
<span class="line-added">1302     // TODO(subset)</span>
<span class="line-added">1303     return_trace (false);</span>
<span class="line-added">1304   }</span>
<span class="line-added">1305 </span>
<span class="line-added">1306   bool sanitize (hb_sanitize_context_t *c) const</span>
1307   {
1308     TRACE_SANITIZE (this);
1309     return_trace (c-&gt;check_struct (this) &amp;&amp;
1310                   markCoverage.sanitize (c, this) &amp;&amp;
1311                   ligatureCoverage.sanitize (c, this) &amp;&amp;
1312                   markArray.sanitize (c, this) &amp;&amp;
1313                   ligatureArray.sanitize (c, this, (unsigned int) classCount));
1314   }
1315 
1316   protected:
1317   HBUINT16      format;                 /* Format identifier--format = 1 */
1318   OffsetTo&lt;Coverage&gt;
1319                 markCoverage;           /* Offset to Mark Coverage table--from
1320                                          * beginning of MarkLigPos subtable */
1321   OffsetTo&lt;Coverage&gt;
1322                 ligatureCoverage;       /* Offset to Ligature Coverage
1323                                          * table--from beginning of MarkLigPos
1324                                          * subtable */
1325   HBUINT16      classCount;             /* Number of defined mark classes */
1326   OffsetTo&lt;MarkArray&gt;
1327                 markArray;              /* Offset to MarkArray table--from
1328                                          * beginning of MarkLigPos subtable */
1329   OffsetTo&lt;LigatureArray&gt;
1330                 ligatureArray;          /* Offset to LigatureArray table--from
1331                                          * beginning of MarkLigPos subtable */
1332   public:
1333   DEFINE_SIZE_STATIC (12);
1334 };
1335 
1336 struct MarkLigPos
1337 {
1338   template &lt;typename context_t&gt;
<span class="line-modified">1339   typename context_t::return_t dispatch (context_t *c) const</span>
1340   {
1341     TRACE_DISPATCH (this, u.format);
1342     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1343     switch (u.format) {
1344     case 1: return_trace (c-&gt;dispatch (u.format1));
1345     default:return_trace (c-&gt;default_return_value ());
1346     }
1347   }
1348 
1349   protected:
1350   union {
1351   HBUINT16              format;         /* Format identifier */
1352   MarkLigPosFormat1     format1;
1353   } u;
1354 };
1355 
1356 
1357 typedef AnchorMatrix Mark2Array;        /* mark2-major--
1358                                          * in order of Mark2Coverage Index--,
1359                                          * mark1-minor--
1360                                          * ordered by class--zero-based. */
1361 
1362 struct MarkMarkPosFormat1
1363 {
<span class="line-modified">1364   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1365   { return (this+mark1Coverage).intersects (glyphs) &amp;&amp;</span>
<span class="line-added">1366            (this+mark2Coverage).intersects (glyphs); }</span>
<span class="line-added">1367 </span>
<span class="line-added">1368   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1369   {

1370     if (unlikely (!(this+mark1Coverage).add_coverage (c-&gt;input))) return;
1371     if (unlikely (!(this+mark2Coverage).add_coverage (c-&gt;input))) return;
1372   }
1373 
<span class="line-modified">1374   const Coverage &amp;get_coverage () const { return this+mark1Coverage; }</span>



1375 
<span class="line-modified">1376   bool apply (hb_ot_apply_context_t *c) const</span>
1377   {
1378     TRACE_APPLY (this);
1379     hb_buffer_t *buffer = c-&gt;buffer;
1380     unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer-&gt;cur().codepoint);
1381     if (likely (mark1_index == NOT_COVERED)) return_trace (false);
1382 
1383     /* now we search backwards for a suitable mark glyph until a non-mark glyph */
1384     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1385     skippy_iter.reset (buffer-&gt;idx, 1);
1386     skippy_iter.set_lookup_props (c-&gt;lookup_props &amp; ~LookupFlag::IgnoreFlags);
1387     if (!skippy_iter.prev ()) return_trace (false);
1388 
1389     if (!_hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1390 
1391     unsigned int j = skippy_iter.idx;
1392 
1393     unsigned int id1 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1394     unsigned int id2 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1395     unsigned int comp1 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1396     unsigned int comp2 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[j]);
</pre>
<hr />
<pre>
1400         goto good;
1401       else if (comp1 == comp2) /* Marks belonging to the same ligature component. */
1402         goto good;
1403     } else {
1404       /* If ligature ids don&#39;t match, it may be the case that one of the marks
1405        * itself is a ligature.  In which case match. */
1406       if ((id1 &gt; 0 &amp;&amp; !comp1) || (id2 &gt; 0 &amp;&amp; !comp2))
1407         goto good;
1408     }
1409 
1410     /* Didn&#39;t match. */
1411     return_trace (false);
1412 
1413     good:
1414     unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer-&gt;info[j].codepoint);
1415     if (mark2_index == NOT_COVERED) return_trace (false);
1416 
1417     return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
1418   }
1419 
<span class="line-modified">1420   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1421   {</span>
<span class="line-added">1422     TRACE_SUBSET (this);</span>
<span class="line-added">1423     // TODO(subset)</span>
<span class="line-added">1424     return_trace (false);</span>
<span class="line-added">1425   }</span>
<span class="line-added">1426 </span>
<span class="line-added">1427   bool sanitize (hb_sanitize_context_t *c) const</span>
1428   {
1429     TRACE_SANITIZE (this);
1430     return_trace (c-&gt;check_struct (this) &amp;&amp;
1431                   mark1Coverage.sanitize (c, this) &amp;&amp;
1432                   mark2Coverage.sanitize (c, this) &amp;&amp;
1433                   mark1Array.sanitize (c, this) &amp;&amp;
1434                   mark2Array.sanitize (c, this, (unsigned int) classCount));
1435   }
1436 
1437   protected:
1438   HBUINT16      format;                 /* Format identifier--format = 1 */
1439   OffsetTo&lt;Coverage&gt;
1440                 mark1Coverage;          /* Offset to Combining Mark1 Coverage
1441                                          * table--from beginning of MarkMarkPos
1442                                          * subtable */
1443   OffsetTo&lt;Coverage&gt;
1444                 mark2Coverage;          /* Offset to Combining Mark2 Coverage
1445                                          * table--from beginning of MarkMarkPos
1446                                          * subtable */
1447   HBUINT16      classCount;             /* Number of defined mark classes */
1448   OffsetTo&lt;MarkArray&gt;
1449                 mark1Array;             /* Offset to Mark1Array table--from
1450                                          * beginning of MarkMarkPos subtable */
1451   OffsetTo&lt;Mark2Array&gt;
1452                 mark2Array;             /* Offset to Mark2Array table--from
1453                                          * beginning of MarkMarkPos subtable */
1454   public:
1455   DEFINE_SIZE_STATIC (12);
1456 };
1457 
1458 struct MarkMarkPos
1459 {
1460   template &lt;typename context_t&gt;
<span class="line-modified">1461   typename context_t::return_t dispatch (context_t *c) const</span>
1462   {
1463     TRACE_DISPATCH (this, u.format);
1464     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1465     switch (u.format) {
1466     case 1: return_trace (c-&gt;dispatch (u.format1));
1467     default:return_trace (c-&gt;default_return_value ());
1468     }
1469   }
1470 
1471   protected:
1472   union {
1473   HBUINT16              format;         /* Format identifier */
1474   MarkMarkPosFormat1    format1;
1475   } u;
1476 };
1477 
1478 
1479 struct ContextPos : Context {};
1480 
1481 struct ChainContextPos : ChainContext {};
1482 
1483 struct ExtensionPos : Extension&lt;ExtensionPos&gt;
1484 {
<span class="line-modified">1485   typedef struct PosLookupSubTable SubTable;</span>
1486 };
1487 
1488 
1489 
1490 /*
1491  * PosLookup
1492  */
1493 
1494 
1495 struct PosLookupSubTable
1496 {
<span class="line-added">1497   friend struct Lookup;</span>
1498   friend struct PosLookup;
1499 
1500   enum Type {
1501     Single              = 1,
1502     Pair                = 2,
1503     Cursive             = 3,
1504     MarkBase            = 4,
1505     MarkLig             = 5,
1506     MarkMark            = 6,
1507     Context             = 7,
1508     ChainContext        = 8,
1509     Extension           = 9
1510   };
1511 
1512   template &lt;typename context_t&gt;
<span class="line-modified">1513   typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1514   {
1515     TRACE_DISPATCH (this, lookup_type);

1516     switch (lookup_type) {
1517     case Single:                return_trace (u.single.dispatch (c));
1518     case Pair:                  return_trace (u.pair.dispatch (c));
1519     case Cursive:               return_trace (u.cursive.dispatch (c));
1520     case MarkBase:              return_trace (u.markBase.dispatch (c));
1521     case MarkLig:               return_trace (u.markLig.dispatch (c));
1522     case MarkMark:              return_trace (u.markMark.dispatch (c));
1523     case Context:               return_trace (u.context.dispatch (c));
1524     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1525     case Extension:             return_trace (u.extension.dispatch (c));
1526     default:                    return_trace (c-&gt;default_return_value ());
1527     }
1528   }
1529 
1530   protected:
1531   union {

1532   SinglePos             single;
1533   PairPos               pair;
1534   CursivePos            cursive;
1535   MarkBasePos           markBase;
1536   MarkLigPos            markLig;
1537   MarkMarkPos           markMark;
1538   ContextPos            context;
1539   ChainContextPos       chainContext;
1540   ExtensionPos          extension;
1541   } u;
1542   public:
<span class="line-modified">1543   DEFINE_SIZE_MIN (0);</span>
1544 };
1545 
1546 
1547 struct PosLookup : Lookup
1548 {
<span class="line-modified">1549   typedef struct PosLookupSubTable SubTable;</span>
<span class="line-modified">1550 </span>
<span class="line-added">1551   const SubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-added">1552   { return Lookup::get_subtable&lt;SubTable&gt; (i); }</span>
1553 
<span class="line-modified">1554   bool is_reverse () const</span>
1555   {
1556     return false;
1557   }
1558 
<span class="line-modified">1559   bool apply (hb_ot_apply_context_t *c) const</span>
1560   {
1561     TRACE_APPLY (this);
1562     return_trace (dispatch (c));
1563   }
1564 
<span class="line-modified">1565   bool intersects (const hb_set_t *glyphs) const</span>
1566   {
<span class="line-modified">1567     hb_intersects_context_t c (glyphs);</span>
<span class="line-modified">1568     return dispatch (&amp;c);</span>
1569   }
1570 
<span class="line-added">1571   hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-added">1572   { return dispatch (c); }</span>
<span class="line-added">1573 </span>
1574   template &lt;typename set_t&gt;
<span class="line-modified">1575   void add_coverage (set_t *glyphs) const</span>
1576   {
1577     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1578     dispatch (&amp;c);
1579   }
1580 
1581   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1582 
1583   template &lt;typename context_t&gt;
<span class="line-modified">1584   static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1585 
1586   template &lt;typename context_t&gt;
<span class="line-modified">1587   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1588   { return Lookup::dispatch&lt;SubTable&gt; (c); }</span>
1589 
<span class="line-modified">1590   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">1591   { return Lookup::subset&lt;SubTable&gt; (c); }</span>





1592 
<span class="line-modified">1593   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">1594   { return Lookup::sanitize&lt;SubTable&gt; (c); }</span>
<span class="line-added">1595 };</span>
1596 
1597 /*
1598  * GPOS -- Glyph Positioning
1599  * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
1600  */
1601 
1602 struct GPOS : GSUBGPOS
1603 {
<span class="line-modified">1604   static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;</span>
1605 
<span class="line-modified">1606   const PosLookup&amp; get_lookup (unsigned int i) const</span>
1607   { return CastR&lt;PosLookup&gt; (GSUBGPOS::get_lookup (i)); }
1608 
1609   static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
1610   static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);
1611   static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);
1612 
<span class="line-modified">1613   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">1614   { return GSUBGPOS::subset&lt;PosLookup&gt; (c); }</span>
<span class="line-modified">1615 </span>
<span class="line-modified">1616   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1617   { return GSUBGPOS::sanitize&lt;PosLookup&gt; (c); }</span>
<span class="line-modified">1618 </span>
<span class="line-modified">1619   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">1620                                    hb_face_t *face) const;</span>
<span class="line-added">1621 </span>
<span class="line-added">1622   typedef GSUBGPOS::accelerator_t&lt;GPOS&gt; accelerator_t;</span>
1623 };
1624 
1625 
1626 static void
1627 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)
1628 {
1629   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1630   if (likely (!chain || 0 == (type &amp; ATTACH_TYPE_CURSIVE)))
1631     return;
1632 
1633   pos[i].attach_chain() = 0;
1634 
1635   unsigned int j = (int) i + chain;
1636 
1637   /* Stop if we see new parent in the chain. */
1638   if (j == new_parent)
1639     return;
1640 
1641   reverse_cursive_minor_offset (pos, j, direction, new_parent);
1642 
1643   if (HB_DIRECTION_IS_HORIZONTAL (direction))
1644     pos[j].y_offset = -pos[i].y_offset;
1645   else
1646     pos[j].x_offset = -pos[i].x_offset;
1647 
1648   pos[j].attach_chain() = -chain;
1649   pos[j].attach_type() = type;
1650 }
1651 static void
<span class="line-modified">1652 propagate_attachment_offsets (hb_glyph_position_t *pos,</span>
<span class="line-added">1653                               unsigned int len,</span>
<span class="line-added">1654                               unsigned int i,</span>
<span class="line-added">1655                               hb_direction_t direction)</span>
1656 {
1657   /* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate
1658    * offset of glyph they are attached to. */
1659   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1660   if (likely (!chain))
1661     return;
1662 
<span class="line-added">1663   pos[i].attach_chain() = 0;</span>
<span class="line-added">1664 </span>
1665   unsigned int j = (int) i + chain;
1666 
<span class="line-modified">1667   if (unlikely (j &gt;= len))</span>
<span class="line-added">1668     return;</span>
1669 
<span class="line-modified">1670   propagate_attachment_offsets (pos, len, j, direction);</span>
1671 
1672   assert (!!(type &amp; ATTACH_TYPE_MARK) ^ !!(type &amp; ATTACH_TYPE_CURSIVE));
1673 
1674   if (type &amp; ATTACH_TYPE_CURSIVE)
1675   {
1676     if (HB_DIRECTION_IS_HORIZONTAL (direction))
1677       pos[i].y_offset += pos[j].y_offset;
1678     else
1679       pos[i].x_offset += pos[j].x_offset;
1680   }
1681   else /*if (type &amp; ATTACH_TYPE_MARK)*/
1682   {
1683     pos[i].x_offset += pos[j].x_offset;
1684     pos[i].y_offset += pos[j].y_offset;
1685 
1686     assert (j &lt; i);
1687     if (HB_DIRECTION_IS_FORWARD (direction))
1688       for (unsigned int k = j; k &lt; i; k++) {
1689         pos[i].x_offset -= pos[k].x_advance;
1690         pos[i].y_offset -= pos[k].y_advance;
1691       }
1692     else
1693       for (unsigned int k = j + 1; k &lt; i + 1; k++) {
1694         pos[i].x_offset += pos[k].x_advance;
1695         pos[i].y_offset += pos[k].y_advance;
1696       }
1697   }
1698 }
1699 
1700 void
1701 GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1702 {
1703   unsigned int count = buffer-&gt;len;
1704   for (unsigned int i = 0; i &lt; count; i++)
1705     buffer-&gt;pos[i].attach_chain() = buffer-&gt;pos[i].attach_type() = 0;
1706 }
1707 
1708 void
<span class="line-modified">1709 GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)</span>
1710 {
1711   //_hb_buffer_assert_gsubgpos_vars (buffer);
1712 }
1713 
1714 void
1715 GPOS::position_finish_offsets (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1716 {
1717   _hb_buffer_assert_gsubgpos_vars (buffer);
1718 
1719   unsigned int len;
1720   hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &amp;len);
1721   hb_direction_t direction = buffer-&gt;props.direction;
1722 
1723   /* Handle attachments */
1724   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)
1725     for (unsigned int i = 0; i &lt; len; i++)
<span class="line-modified">1726       propagate_attachment_offsets (pos, len, i, direction);</span>
1727 }
1728 
1729 
<span class="line-added">1730 struct GPOS_accelerator_t : GPOS::accelerator_t {};</span>
<span class="line-added">1731 </span>
<span class="line-added">1732 </span>
1733 /* Out-of-class implementation for methods recursing */
1734 
1735 template &lt;typename context_t&gt;
1736 /*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1737 {
<span class="line-modified">1738   const PosLookup &amp;l = c-&gt;face-&gt;table.GPOS.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1739   return l.dispatch (c);
1740 }
1741 
1742 /*static*/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1743 {
<span class="line-modified">1744   const PosLookup &amp;l = c-&gt;face-&gt;table.GPOS.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1745   unsigned int saved_lookup_props = c-&gt;lookup_props;
1746   unsigned int saved_lookup_index = c-&gt;lookup_index;
1747   c-&gt;set_lookup_index (lookup_index);
1748   c-&gt;set_lookup_props (l.get_props ());
1749   bool ret = l.dispatch (c);
1750   c-&gt;set_lookup_index (saved_lookup_index);
1751   c-&gt;set_lookup_props (saved_lookup_props);
1752   return ret;
1753 }
1754 
1755 




1756 } /* namespace OT */
1757 
1758 
1759 #endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-layout-gdef-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gsub-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
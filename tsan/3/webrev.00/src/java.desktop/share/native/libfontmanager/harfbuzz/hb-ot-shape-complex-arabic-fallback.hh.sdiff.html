<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-post-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-win1256.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic-fallback.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
 28 #define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-private.hh&quot;</span>
 31 
<span class="line-modified"> 32 #include &quot;hb-ot-shape-private.hh&quot;</span>
 33 #include &quot;hb-ot-layout-gsub-table.hh&quot;
 34 
 35 
 36 /* Features ordered the same as the entries in shaping_table rows,
 37  * followed by rlig.  Don&#39;t change. */
 38 static const hb_tag_t arabic_fallback_features[] =
 39 {
 40   HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;),
 41   HB_TAG(&#39;m&#39;,&#39;e&#39;,&#39;d&#39;,&#39;i&#39;),
 42   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;),
 43   HB_TAG(&#39;i&#39;,&#39;s&#39;,&#39;o&#39;,&#39;l&#39;),
 44   HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),
 45 };
 46 
 47 static OT::SubstLookup *
 48 arabic_fallback_synthesize_lookup_single (const hb_ot_shape_plan_t *plan HB_UNUSED,
 49                                           hb_font_t *font,
 50                                           unsigned int feature_index)
 51 {
 52   OT::GlyphID glyphs[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];
</pre>
<hr />
<pre>
 62     if (!s ||
 63         !hb_font_get_glyph (font, u, 0, &amp;u_glyph) ||
 64         !hb_font_get_glyph (font, s, 0, &amp;s_glyph) ||
 65         u_glyph == s_glyph ||
 66         u_glyph &gt; 0xFFFFu || s_glyph &gt; 0xFFFFu)
 67       continue;
 68 
 69     glyphs[num_glyphs].set (u_glyph);
 70     substitutes[num_glyphs].set (s_glyph);
 71 
 72     num_glyphs++;
 73   }
 74 
 75   if (!num_glyphs)
 76     return nullptr;
 77 
 78   /* Bubble-sort or something equally good!
 79    * May not be good-enough for presidential candidate interviews, but good-enough for us... */
 80   hb_stable_sort (&amp;glyphs[0], num_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &amp;substitutes[0]);
 81 
<span class="line-removed"> 82   OT::Supplier&lt;OT::GlyphID&gt; glyphs_supplier      (glyphs, num_glyphs);</span>
<span class="line-removed"> 83   OT::Supplier&lt;OT::GlyphID&gt; substitutes_supplier (substitutes, num_glyphs);</span>
 84 
 85   /* Each glyph takes four bytes max, and there&#39;s some overhead. */
 86   char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];
<span class="line-modified"> 87   OT::hb_serialize_context_t c (buf, sizeof (buf));</span>
 88   OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
 89   bool ret = lookup-&gt;serialize_single (&amp;c,
 90                                        OT::LookupFlag::IgnoreMarks,
<span class="line-modified"> 91                                        glyphs_supplier,</span>
<span class="line-modified"> 92                                        substitutes_supplier,</span>
<span class="line-removed"> 93                                        num_glyphs);</span>
 94   c.end_serialize ();
 95   /* TODO sanitize the results? */
 96 
 97   return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
 98 }
 99 
100 static OT::SubstLookup *
101 arabic_fallback_synthesize_lookup_ligature (const hb_ot_shape_plan_t *plan HB_UNUSED,
102                                             hb_font_t *font)
103 {
104   OT::GlyphID first_glyphs[ARRAY_LENGTH_CONST (ligature_table)];
105   unsigned int first_glyphs_indirection[ARRAY_LENGTH_CONST (ligature_table)];
106   unsigned int ligature_per_first_glyph_count_list[ARRAY_LENGTH_CONST (first_glyphs)];
107   unsigned int num_first_glyphs = 0;
108 
109   /* We know that all our ligatures are 2-component */
110   OT::GlyphID ligature_list[ARRAY_LENGTH_CONST (first_glyphs) * ARRAY_LENGTH_CONST(ligature_table[0].ligatures)];
111   unsigned int component_count_list[ARRAY_LENGTH_CONST (ligature_list)];
112   OT::GlyphID component_list[ARRAY_LENGTH_CONST (ligature_list) * 1/* One extra component per ligature */];
113   unsigned int num_ligatures = 0;
</pre>
<hr />
<pre>
138       hb_codepoint_t second_u   = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].second;
139       hb_codepoint_t ligature_u = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].ligature;
140       hb_codepoint_t second_glyph, ligature_glyph;
141       if (!second_u ||
142           !hb_font_get_glyph (font, second_u,   0, &amp;second_glyph) ||
143           !hb_font_get_glyph (font, ligature_u, 0, &amp;ligature_glyph))
144         continue;
145 
146       ligature_per_first_glyph_count_list[i]++;
147 
148       ligature_list[num_ligatures].set (ligature_glyph);
149       component_count_list[num_ligatures] = 2;
150       component_list[num_ligatures].set (second_glyph);
151       num_ligatures++;
152     }
153   }
154 
155   if (!num_ligatures)
156     return nullptr;
157 
<span class="line-removed">158   OT::Supplier&lt;OT::GlyphID&gt;   first_glyphs_supplier                      (first_glyphs, num_first_glyphs);</span>
<span class="line-removed">159   OT::Supplier&lt;unsigned int &gt; ligature_per_first_glyph_count_supplier    (ligature_per_first_glyph_count_list, num_first_glyphs);</span>
<span class="line-removed">160   OT::Supplier&lt;OT::GlyphID&gt;   ligatures_supplier                         (ligature_list, num_ligatures);</span>
<span class="line-removed">161   OT::Supplier&lt;unsigned int &gt; component_count_supplier                   (component_count_list, num_ligatures);</span>
<span class="line-removed">162   OT::Supplier&lt;OT::GlyphID&gt;   component_supplier                         (component_list, num_ligatures);</span>
163 
164   /* 16 bytes per ligature ought to be enough... */
165   char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];
<span class="line-modified">166   OT::hb_serialize_context_t c (buf, sizeof (buf));</span>
167   OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
168   bool ret = lookup-&gt;serialize_ligature (&amp;c,
169                                          OT::LookupFlag::IgnoreMarks,
<span class="line-modified">170                                          first_glyphs_supplier,</span>
<span class="line-modified">171                                          ligature_per_first_glyph_count_supplier,</span>
<span class="line-modified">172                                          num_first_glyphs,</span>
<span class="line-modified">173                                          ligatures_supplier,</span>
<span class="line-modified">174                                          component_count_supplier,</span>
<span class="line-removed">175                                          component_supplier);</span>
<span class="line-removed">176 </span>
177   c.end_serialize ();
178   /* TODO sanitize the results? */
179 
180   return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
181 }
182 
183 static OT::SubstLookup *
184 arabic_fallback_synthesize_lookup (const hb_ot_shape_plan_t *plan,
185                                    hb_font_t *font,
186                                    unsigned int feature_index)
187 {
188   if (feature_index &lt; 4)
189     return arabic_fallback_synthesize_lookup_single (plan, font, feature_index);
190   else
191     return arabic_fallback_synthesize_lookup_ligature (plan, font);
192 }
193 
194 #define ARABIC_FALLBACK_MAX_LOOKUPS 5
195 
196 struct arabic_fallback_plan_t
197 {
<span class="line-removed">198   ASSERT_POD ();</span>
<span class="line-removed">199 </span>
200   unsigned int num_lookups;
201   bool free_lookups;
202 
203   hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];
204   OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];
<span class="line-modified">205   hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];</span>
206 };
207 
<span class="line-modified">208 static const arabic_fallback_plan_t arabic_fallback_plan_nil = {};</span>
<span class="line-removed">209 </span>
<span class="line-removed">210 #if (defined(_WIN32) || defined(__CYGWIN__)) &amp;&amp; !defined(HB_NO_WIN1256)</span>
211 #define HB_WITH_WIN1256
212 #endif
213 
214 #ifdef HB_WITH_WIN1256
215 #include &quot;hb-ot-shape-complex-arabic-win1256.hh&quot;
216 #endif
217 
<span class="line-modified">218 struct ManifestLookup {</span>


219   OT::Tag tag;
220   OT::OffsetTo&lt;OT::SubstLookup&gt; lookupOffset;


221 };
222 typedef OT::ArrayOf&lt;ManifestLookup&gt; Manifest;
223 
224 static bool
<span class="line-modified">225 arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan,</span>
<span class="line-modified">226                                    const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">227                                    hb_font_t *font)</span>
228 {
229 #ifdef HB_WITH_WIN1256
230   /* Does this font look like it&#39;s Windows-1256-encoded? */
231   hb_codepoint_t g;
232   if (!(hb_font_get_glyph (font, 0x0627u, 0, &amp;g) &amp;&amp; g == 199 /* ALEF */ &amp;&amp;
233         hb_font_get_glyph (font, 0x0644u, 0, &amp;g) &amp;&amp; g == 225 /* LAM */ &amp;&amp;
234         hb_font_get_glyph (font, 0x0649u, 0, &amp;g) &amp;&amp; g == 236 /* ALEF MAKSURA */ &amp;&amp;
235         hb_font_get_glyph (font, 0x064Au, 0, &amp;g) &amp;&amp; g == 237 /* YEH */ &amp;&amp;
236         hb_font_get_glyph (font, 0x0652u, 0, &amp;g) &amp;&amp; g == 250 /* SUKUN */))
237     return false;
238 
239   const Manifest &amp;manifest = reinterpret_cast&lt;const Manifest&amp;&gt; (arabic_win1256_gsub_lookups.manifest);
240   static_assert (sizeof (arabic_win1256_gsub_lookups.manifestData) / sizeof (ManifestLookup)
241                  &lt;= ARABIC_FALLBACK_MAX_LOOKUPS, &quot;&quot;);
242   /* TODO sanitize the table? */
243 
244   unsigned j = 0;
245   unsigned int count = manifest.len;
246   for (unsigned int i = 0; i &lt; count; i++)
247   {
</pre>
<hr />
<pre>
282       if (fallback_plan-&gt;lookup_array[j])
283       {
284         fallback_plan-&gt;accel_array[j].init (*fallback_plan-&gt;lookup_array[j]);
285         j++;
286       }
287     }
288   }
289 
290   fallback_plan-&gt;num_lookups = j;
291   fallback_plan-&gt;free_lookups = true;
292 
293   return j &gt; 0;
294 }
295 
296 static arabic_fallback_plan_t *
297 arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,
298                              hb_font_t *font)
299 {
300   arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));
301   if (unlikely (!fallback_plan))
<span class="line-modified">302     return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;arabic_fallback_plan_nil);</span>
303 
304   fallback_plan-&gt;num_lookups = 0;
305   fallback_plan-&gt;free_lookups = false;
306 
307   /* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,
308    * in case the font has cmap entries for the presentation-forms characters. */
309   if (arabic_fallback_plan_init_unicode (fallback_plan, plan, font))
310     return fallback_plan;
311 
312   /* See if this looks like a Windows-1256-encoded font.  If it does, use a
313    * hand-coded GSUB table. */
314   if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))
315     return fallback_plan;
316 

317   free (fallback_plan);
<span class="line-modified">318   return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;arabic_fallback_plan_nil);</span>
319 }
320 
321 static void
322 arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)
323 {
<span class="line-modified">324   if (!fallback_plan || fallback_plan == &amp;arabic_fallback_plan_nil)</span>
325     return;
326 
327   for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
328     if (fallback_plan-&gt;lookup_array[i])
329     {
330       fallback_plan-&gt;accel_array[i].fini ();
331       if (fallback_plan-&gt;free_lookups)
332         free (fallback_plan-&gt;lookup_array[i]);
333     }
334 
335   free (fallback_plan);
336 }
337 
338 static void
339 arabic_fallback_plan_shape (arabic_fallback_plan_t *fallback_plan,
340                             hb_font_t *font,
341                             hb_buffer_t *buffer)
342 {
343   OT::hb_ot_apply_context_t c (0, font, buffer);
344   for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
 28 #define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH
 29 
<span class="line-modified"> 30 #include &quot;hb.hh&quot;</span>
 31 
<span class="line-modified"> 32 #include &quot;hb-ot-shape.hh&quot;</span>
 33 #include &quot;hb-ot-layout-gsub-table.hh&quot;
 34 
 35 
 36 /* Features ordered the same as the entries in shaping_table rows,
 37  * followed by rlig.  Don&#39;t change. */
 38 static const hb_tag_t arabic_fallback_features[] =
 39 {
 40   HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;),
 41   HB_TAG(&#39;m&#39;,&#39;e&#39;,&#39;d&#39;,&#39;i&#39;),
 42   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;),
 43   HB_TAG(&#39;i&#39;,&#39;s&#39;,&#39;o&#39;,&#39;l&#39;),
 44   HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),
 45 };
 46 
 47 static OT::SubstLookup *
 48 arabic_fallback_synthesize_lookup_single (const hb_ot_shape_plan_t *plan HB_UNUSED,
 49                                           hb_font_t *font,
 50                                           unsigned int feature_index)
 51 {
 52   OT::GlyphID glyphs[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];
</pre>
<hr />
<pre>
 62     if (!s ||
 63         !hb_font_get_glyph (font, u, 0, &amp;u_glyph) ||
 64         !hb_font_get_glyph (font, s, 0, &amp;s_glyph) ||
 65         u_glyph == s_glyph ||
 66         u_glyph &gt; 0xFFFFu || s_glyph &gt; 0xFFFFu)
 67       continue;
 68 
 69     glyphs[num_glyphs].set (u_glyph);
 70     substitutes[num_glyphs].set (s_glyph);
 71 
 72     num_glyphs++;
 73   }
 74 
 75   if (!num_glyphs)
 76     return nullptr;
 77 
 78   /* Bubble-sort or something equally good!
 79    * May not be good-enough for presidential candidate interviews, but good-enough for us... */
 80   hb_stable_sort (&amp;glyphs[0], num_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &amp;substitutes[0]);
 81 


 82 
 83   /* Each glyph takes four bytes max, and there&#39;s some overhead. */
 84   char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];
<span class="line-modified"> 85   hb_serialize_context_t c (buf, sizeof (buf));</span>
 86   OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
 87   bool ret = lookup-&gt;serialize_single (&amp;c,
 88                                        OT::LookupFlag::IgnoreMarks,
<span class="line-modified"> 89                                        hb_array (glyphs, num_glyphs),</span>
<span class="line-modified"> 90                                        hb_array (substitutes, num_glyphs));</span>

 91   c.end_serialize ();
 92   /* TODO sanitize the results? */
 93 
 94   return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
 95 }
 96 
 97 static OT::SubstLookup *
 98 arabic_fallback_synthesize_lookup_ligature (const hb_ot_shape_plan_t *plan HB_UNUSED,
 99                                             hb_font_t *font)
100 {
101   OT::GlyphID first_glyphs[ARRAY_LENGTH_CONST (ligature_table)];
102   unsigned int first_glyphs_indirection[ARRAY_LENGTH_CONST (ligature_table)];
103   unsigned int ligature_per_first_glyph_count_list[ARRAY_LENGTH_CONST (first_glyphs)];
104   unsigned int num_first_glyphs = 0;
105 
106   /* We know that all our ligatures are 2-component */
107   OT::GlyphID ligature_list[ARRAY_LENGTH_CONST (first_glyphs) * ARRAY_LENGTH_CONST(ligature_table[0].ligatures)];
108   unsigned int component_count_list[ARRAY_LENGTH_CONST (ligature_list)];
109   OT::GlyphID component_list[ARRAY_LENGTH_CONST (ligature_list) * 1/* One extra component per ligature */];
110   unsigned int num_ligatures = 0;
</pre>
<hr />
<pre>
135       hb_codepoint_t second_u   = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].second;
136       hb_codepoint_t ligature_u = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].ligature;
137       hb_codepoint_t second_glyph, ligature_glyph;
138       if (!second_u ||
139           !hb_font_get_glyph (font, second_u,   0, &amp;second_glyph) ||
140           !hb_font_get_glyph (font, ligature_u, 0, &amp;ligature_glyph))
141         continue;
142 
143       ligature_per_first_glyph_count_list[i]++;
144 
145       ligature_list[num_ligatures].set (ligature_glyph);
146       component_count_list[num_ligatures] = 2;
147       component_list[num_ligatures].set (second_glyph);
148       num_ligatures++;
149     }
150   }
151 
152   if (!num_ligatures)
153     return nullptr;
154 





155 
156   /* 16 bytes per ligature ought to be enough... */
157   char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];
<span class="line-modified">158   hb_serialize_context_t c (buf, sizeof (buf));</span>
159   OT::SubstLookup *lookup = c.start_serialize&lt;OT::SubstLookup&gt; ();
160   bool ret = lookup-&gt;serialize_ligature (&amp;c,
161                                          OT::LookupFlag::IgnoreMarks,
<span class="line-modified">162                                          hb_array (first_glyphs, num_first_glyphs),</span>
<span class="line-modified">163                                          hb_array (ligature_per_first_glyph_count_list, num_first_glyphs),</span>
<span class="line-modified">164                                          hb_array (ligature_list, num_ligatures),</span>
<span class="line-modified">165                                          hb_array (component_count_list, num_ligatures),</span>
<span class="line-modified">166                                          hb_array (component_list, num_ligatures));</span>


167   c.end_serialize ();
168   /* TODO sanitize the results? */
169 
170   return ret ? c.copy&lt;OT::SubstLookup&gt; () : nullptr;
171 }
172 
173 static OT::SubstLookup *
174 arabic_fallback_synthesize_lookup (const hb_ot_shape_plan_t *plan,
175                                    hb_font_t *font,
176                                    unsigned int feature_index)
177 {
178   if (feature_index &lt; 4)
179     return arabic_fallback_synthesize_lookup_single (plan, font, feature_index);
180   else
181     return arabic_fallback_synthesize_lookup_ligature (plan, font);
182 }
183 
184 #define ARABIC_FALLBACK_MAX_LOOKUPS 5
185 
186 struct arabic_fallback_plan_t
187 {


188   unsigned int num_lookups;
189   bool free_lookups;
190 
191   hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];
192   OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];
<span class="line-modified">193   OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];</span>
194 };
195 
<span class="line-modified">196 #if defined(_WIN32) &amp;&amp; !defined(HB_NO_WIN1256)</span>


197 #define HB_WITH_WIN1256
198 #endif
199 
200 #ifdef HB_WITH_WIN1256
201 #include &quot;hb-ot-shape-complex-arabic-win1256.hh&quot;
202 #endif
203 
<span class="line-modified">204 struct ManifestLookup</span>
<span class="line-added">205 {</span>
<span class="line-added">206   public:</span>
207   OT::Tag tag;
208   OT::OffsetTo&lt;OT::SubstLookup&gt; lookupOffset;
<span class="line-added">209   public:</span>
<span class="line-added">210   DEFINE_SIZE_STATIC (6);</span>
211 };
212 typedef OT::ArrayOf&lt;ManifestLookup&gt; Manifest;
213 
214 static bool
<span class="line-modified">215 arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan HB_UNUSED,</span>
<span class="line-modified">216                                    const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">217                                    hb_font_t *font HB_UNUSED)</span>
218 {
219 #ifdef HB_WITH_WIN1256
220   /* Does this font look like it&#39;s Windows-1256-encoded? */
221   hb_codepoint_t g;
222   if (!(hb_font_get_glyph (font, 0x0627u, 0, &amp;g) &amp;&amp; g == 199 /* ALEF */ &amp;&amp;
223         hb_font_get_glyph (font, 0x0644u, 0, &amp;g) &amp;&amp; g == 225 /* LAM */ &amp;&amp;
224         hb_font_get_glyph (font, 0x0649u, 0, &amp;g) &amp;&amp; g == 236 /* ALEF MAKSURA */ &amp;&amp;
225         hb_font_get_glyph (font, 0x064Au, 0, &amp;g) &amp;&amp; g == 237 /* YEH */ &amp;&amp;
226         hb_font_get_glyph (font, 0x0652u, 0, &amp;g) &amp;&amp; g == 250 /* SUKUN */))
227     return false;
228 
229   const Manifest &amp;manifest = reinterpret_cast&lt;const Manifest&amp;&gt; (arabic_win1256_gsub_lookups.manifest);
230   static_assert (sizeof (arabic_win1256_gsub_lookups.manifestData) / sizeof (ManifestLookup)
231                  &lt;= ARABIC_FALLBACK_MAX_LOOKUPS, &quot;&quot;);
232   /* TODO sanitize the table? */
233 
234   unsigned j = 0;
235   unsigned int count = manifest.len;
236   for (unsigned int i = 0; i &lt; count; i++)
237   {
</pre>
<hr />
<pre>
272       if (fallback_plan-&gt;lookup_array[j])
273       {
274         fallback_plan-&gt;accel_array[j].init (*fallback_plan-&gt;lookup_array[j]);
275         j++;
276       }
277     }
278   }
279 
280   fallback_plan-&gt;num_lookups = j;
281   fallback_plan-&gt;free_lookups = true;
282 
283   return j &gt; 0;
284 }
285 
286 static arabic_fallback_plan_t *
287 arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,
288                              hb_font_t *font)
289 {
290   arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));
291   if (unlikely (!fallback_plan))
<span class="line-modified">292     return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;Null(arabic_fallback_plan_t));</span>
293 
294   fallback_plan-&gt;num_lookups = 0;
295   fallback_plan-&gt;free_lookups = false;
296 
297   /* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,
298    * in case the font has cmap entries for the presentation-forms characters. */
299   if (arabic_fallback_plan_init_unicode (fallback_plan, plan, font))
300     return fallback_plan;
301 
302   /* See if this looks like a Windows-1256-encoded font.  If it does, use a
303    * hand-coded GSUB table. */
304   if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))
305     return fallback_plan;
306 
<span class="line-added">307   assert (fallback_plan-&gt;num_lookups == 0);</span>
308   free (fallback_plan);
<span class="line-modified">309   return const_cast&lt;arabic_fallback_plan_t *&gt; (&amp;Null(arabic_fallback_plan_t));</span>
310 }
311 
312 static void
313 arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)
314 {
<span class="line-modified">315   if (!fallback_plan || fallback_plan-&gt;num_lookups == 0)</span>
316     return;
317 
318   for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
319     if (fallback_plan-&gt;lookup_array[i])
320     {
321       fallback_plan-&gt;accel_array[i].fini ();
322       if (fallback_plan-&gt;free_lookups)
323         free (fallback_plan-&gt;lookup_array[i]);
324     }
325 
326   free (fallback_plan);
327 }
328 
329 static void
330 arabic_fallback_plan_shape (arabic_fallback_plan_t *fallback_plan,
331                             hb_font_t *font,
332                             hb_buffer_t *buffer)
333 {
334   OT::hb_ot_apply_context_t c (0, font, buffer);
335   for (unsigned int i = 0; i &lt; fallback_plan-&gt;num_lookups; i++)
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-post-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-win1256.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-color-colr-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-sbix-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Google Author(s): Sascha Brawer
 26  */
 27 
 28 #ifndef HB_OT_COLOR_CPAL_TABLE_HH
 29 #define HB_OT_COLOR_CPAL_TABLE_HH
 30 
<span class="line-modified"> 31 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 </span>
<span class="line-removed"> 34 /*</span>
<span class="line-removed"> 35  * Following parts to be moved to a public header.</span>
<span class="line-removed"> 36  */</span>
<span class="line-removed"> 37 </span>
<span class="line-removed"> 38 /**</span>
<span class="line-removed"> 39  * hb_ot_color_t:</span>
<span class="line-removed"> 40  * ARGB data type for holding color values.</span>
<span class="line-removed"> 41  *</span>
<span class="line-removed"> 42  * Since: REPLACEME</span>
<span class="line-removed"> 43  */</span>
<span class="line-removed"> 44 typedef uint32_t hb_ot_color_t;</span>
<span class="line-removed"> 45 </span>
<span class="line-removed"> 46 </span>
<span class="line-removed"> 47 /**</span>
<span class="line-removed"> 48  * hb_ot_color_palette_flags_t:</span>
<span class="line-removed"> 49  * @HB_OT_COLOR_PALETTE_FLAG_DEFAULT: default indicating that there is nothing special to note about a color palette.</span>
<span class="line-removed"> 50  * @HB_OT_COLOR_PALETTE_FLAG_FOR_LIGHT_BACKGROUND: flag indicating that the color palette is suitable for rendering text on light background.</span>
<span class="line-removed"> 51  * @HB_OT_COLOR_PALETTE_FLAG_FOR_DARK_BACKGROUND: flag indicating that the color palette is suitable for rendering text on dark background.</span>
<span class="line-removed"> 52  *</span>
<span class="line-removed"> 53  * Since: REPLACEME</span>
<span class="line-removed"> 54  */</span>
<span class="line-removed"> 55 typedef enum { /*&lt; flags &gt;*/</span>
<span class="line-removed"> 56   HB_OT_COLOR_PALETTE_FLAG_DEFAULT = 0x00000000u,</span>
<span class="line-removed"> 57   HB_OT_COLOR_PALETTE_FLAG_FOR_LIGHT_BACKGROUND = 0x00000001u,</span>
<span class="line-removed"> 58   HB_OT_COLOR_PALETTE_FLAG_FOR_DARK_BACKGROUND = 0x00000002u,</span>
<span class="line-removed"> 59 } hb_ot_color_palette_flags_t;</span>
<span class="line-removed"> 60 </span>
<span class="line-removed"> 61 // HB_EXTERN unsigned int</span>
<span class="line-removed"> 62 // hb_ot_color_get_palette_count (hb_face_t *face);</span>
<span class="line-removed"> 63 </span>
<span class="line-removed"> 64 // HB_EXTERN unsigned int</span>
<span class="line-removed"> 65 // hb_ot_color_get_palette_name_id (hb_face_t *face, unsigned int palette);</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67 // HB_EXTERN hb_ot_color_palette_flags_t</span>
<span class="line-removed"> 68 // hb_ot_color_get_palette_flags (hb_face_t *face, unsigned int palette);</span>
<span class="line-removed"> 69 </span>
<span class="line-removed"> 70 // HB_EXTERN unsigned int</span>
<span class="line-removed"> 71 // hb_ot_color_get_palette_colors (hb_face_t       *face,</span>
<span class="line-removed"> 72 //                              unsigned int     palette, /* default=0 */</span>
<span class="line-removed"> 73 //                              unsigned int     start_offset,</span>
<span class="line-removed"> 74 //                              unsigned int    *color_count /* IN/OUT */,</span>
<span class="line-removed"> 75 //                              hb_ot_color_t   *colors /* OUT */);</span>
<span class="line-removed"> 76 </span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 </span>
 79 
 80 
 81 /*
 82  * CPAL -- Color Palette
 83  * https://docs.microsoft.com/en-us/typography/opentype/spec/cpal
 84  */
 85 #define HB_OT_TAG_CPAL HB_TAG(&#39;C&#39;,&#39;P&#39;,&#39;A&#39;,&#39;L&#39;)
 86 
 87 
 88 namespace OT {
 89 
 90 
 91 struct CPALV1Tail
 92 {
 93   friend struct CPAL;
 94 
<span class="line-modified"> 95   inline bool</span>
<span class="line-modified"> 96   sanitize (hb_sanitize_context_t *c, const void *base, unsigned int palettes) const</span>


 97   {
<span class="line-modified"> 98     TRACE_SANITIZE (this);</span>
<span class="line-modified"> 99     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">100                   (base+paletteFlagsZ).sanitize (c, palettes) &amp;&amp;</span>
<span class="line-removed">101                   (base+paletteLabelZ).sanitize (c, palettes) &amp;&amp;</span>
<span class="line-removed">102                   (base+paletteEntryLabelZ).sanitize (c, palettes));</span>
103   }
104 
<span class="line-modified">105   private:</span>
<span class="line-modified">106   inline hb_ot_color_palette_flags_t</span>
<span class="line-modified">107   get_palette_flags (const void *base, unsigned int palette) const</span>
108   {
<span class="line-modified">109     // range checked at the CPAL caller</span>
<span class="line-modified">110     return (hb_ot_color_palette_flags_t) (uint32_t) (base+paletteFlagsZ)[palette];</span>
111   }
112 
<span class="line-modified">113   inline unsigned int</span>
<span class="line-modified">114   get_palette_name_id (const void *base, unsigned int palette) const</span>

115   {
<span class="line-modified">116     // range checked at the CPAL caller</span>
<span class="line-modified">117     return (base+paletteLabelZ)[palette];</span>













118   }
119 
120   protected:
<span class="line-modified">121   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT32&gt; &gt;</span>
122                 paletteFlagsZ;          /* Offset from the beginning of CPAL table to
123                                          * the Palette Type Array. Set to 0 if no array
124                                          * is provided. */
<span class="line-modified">125   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT16&gt; &gt;</span>
<span class="line-modified">126                 paletteLabelZ;          /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">127                                          * the Palette Labels Array. Set to 0 if no</span>
128                                          * array is provided. */
<span class="line-modified">129   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT16&gt; &gt;</span>
<span class="line-modified">130                 paletteEntryLabelZ;     /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">131                                          * the Palette Entry Label Array. Set to 0</span>
132                                          * if no array is provided. */
133   public:
134   DEFINE_SIZE_STATIC (12);
135 };
136 
137 typedef HBUINT32 BGRAColor;
138 
139 struct CPAL
140 {
<span class="line-modified">141   static const hb_tag_t tableTag = HB_OT_TAG_CPAL;</span>
142 
<span class="line-modified">143   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">144   {</span>
<span class="line-removed">145     TRACE_SANITIZE (this);</span>
<span class="line-removed">146     if (unlikely (!(c-&gt;check_struct (this) &amp;&amp;   // it checks colorRecordIndices also</span>
<span class="line-removed">147                                                 // see #get_size</span>
<span class="line-removed">148                     (this+colorRecordsZ).sanitize (c, numColorRecords))))</span>
<span class="line-removed">149       return_trace (false);</span>
<span class="line-removed">150 </span>
<span class="line-removed">151     // Check for indices sanity so no need for doing it runtime</span>
<span class="line-removed">152     for (unsigned int i = 0; i &lt; numPalettes; ++i)</span>
<span class="line-removed">153       if (unlikely (colorRecordIndicesZ[i] + numPaletteEntries &gt; numColorRecords))</span>
<span class="line-removed">154         return_trace (false);</span>
<span class="line-removed">155 </span>
<span class="line-removed">156     // If version is zero, we are done here; otherwise we need to check tail also</span>
<span class="line-removed">157     if (version == 0)</span>
<span class="line-removed">158       return_trace (true);</span>
<span class="line-removed">159 </span>
<span class="line-removed">160     const CPALV1Tail &amp;v1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-removed">161     return_trace (likely (v1.sanitize (c, this, numPalettes)));</span>
<span class="line-removed">162   }</span>
163 
<span class="line-modified">164   inline unsigned int get_size (void) const</span>
<span class="line-modified">165   {</span>
<span class="line-removed">166     return min_size + numPalettes * sizeof (HBUINT16);</span>
<span class="line-removed">167   }</span>
168 
<span class="line-modified">169   inline hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette) const</span>
<span class="line-modified">170   {</span>
<span class="line-removed">171     if (unlikely (version == 0 || palette &gt;= numPalettes))</span>
<span class="line-removed">172       return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;</span>
173 
<span class="line-modified">174     const CPALV1Tail&amp; cpal1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-modified">175     return cpal1.get_palette_flags (this, palette);</span>
<span class="line-removed">176   }</span>
177 
<span class="line-modified">178   inline unsigned int get_palette_name_id (unsigned int palette) const</span>
<span class="line-modified">179   {</span>
<span class="line-removed">180     if (unlikely (version == 0 || palette &gt;= numPalettes))</span>
<span class="line-removed">181       return 0xFFFF;</span>
182 
<span class="line-modified">183     const CPALV1Tail&amp; cpal1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-modified">184     return cpal1.get_palette_name_id (this, palette);</span>
<span class="line-removed">185   }</span>
186 
<span class="line-modified">187   inline unsigned int get_palette_count () const</span>



188   {
<span class="line-modified">189     return numPalettes;</span>


















190   }
191 
<span class="line-modified">192   inline hb_ot_color_t</span>
<span class="line-modified">193   get_color_record_argb (unsigned int color_index, unsigned int palette) const</span>
194   {
<span class="line-modified">195     if (unlikely (color_index &gt;= numPaletteEntries || palette &gt;= numPalettes))</span>
<span class="line-modified">196       return 0;</span>

197 
<span class="line-modified">198     // No need for more range check as it is already done on #sanitize</span>
<span class="line-modified">199     const UnsizedArrayOf&lt;BGRAColor&gt;&amp; color_records = this+colorRecordsZ;</span>
<span class="line-modified">200     return color_records[colorRecordIndicesZ[palette] + color_index];</span>





201   }
202 
203   protected:
204   HBUINT16      version;                /* Table version number */
205   /* Version 0 */
<span class="line-modified">206   HBUINT16      numPaletteEntries;      /* Number of palette entries in each palette. */</span>
207   HBUINT16      numPalettes;            /* Number of palettes in the table. */
208   HBUINT16      numColorRecords;        /* Total number of color records, combined for
209                                          * all palettes. */
<span class="line-modified">210   LOffsetTo&lt;UnsizedArrayOf&lt;BGRAColor&gt; &gt;</span>
211                 colorRecordsZ;          /* Offset from the beginning of CPAL table to
212                                          * the first ColorRecord. */
213   UnsizedArrayOf&lt;HBUINT16&gt;
214                 colorRecordIndicesZ;    /* Index of each palette’s first color record in
215                                          * the combined color record array. */
216 /*CPALV1Tail    v1;*/
217   public:
218   DEFINE_SIZE_ARRAY (12, colorRecordIndicesZ);
219 };
220 
221 } /* namespace OT */
222 
223 
224 #endif /* HB_OT_COLOR_CPAL_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Google Author(s): Sascha Brawer
 26  */
 27 
 28 #ifndef HB_OT_COLOR_CPAL_TABLE_HH
 29 #define HB_OT_COLOR_CPAL_TABLE_HH
 30 
<span class="line-modified"> 31 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified"> 32 #include &quot;hb-ot-color.h&quot;</span>
<span class="line-modified"> 33 #include &quot;hb-ot-name.h&quot;</span>













































 34 
 35 
 36 /*
 37  * CPAL -- Color Palette
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/cpal
 39  */
 40 #define HB_OT_TAG_CPAL HB_TAG(&#39;C&#39;,&#39;P&#39;,&#39;A&#39;,&#39;L&#39;)
 41 
 42 
 43 namespace OT {
 44 
 45 
 46 struct CPALV1Tail
 47 {
 48   friend struct CPAL;
 49 
<span class="line-modified"> 50   private:</span>
<span class="line-modified"> 51   hb_ot_color_palette_flags_t get_palette_flags (const void *base,</span>
<span class="line-added"> 52                                                  unsigned int palette_index,</span>
<span class="line-added"> 53                                                  unsigned int palette_count) const</span>
 54   {
<span class="line-modified"> 55     if (!paletteFlagsZ) return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;</span>
<span class="line-modified"> 56     return (hb_ot_color_palette_flags_t) (uint32_t)</span>
<span class="line-modified"> 57            (base+paletteFlagsZ).as_array (palette_count)[palette_index];</span>


 58   }
 59 
<span class="line-modified"> 60   hb_ot_name_id_t get_palette_name_id (const void *base,</span>
<span class="line-modified"> 61                                        unsigned int palette_index,</span>
<span class="line-modified"> 62                                        unsigned int palette_count) const</span>
 63   {
<span class="line-modified"> 64     if (!paletteLabelsZ) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified"> 65     return (base+paletteLabelsZ).as_array (palette_count)[palette_index];</span>
 66   }
 67 
<span class="line-modified"> 68   hb_ot_name_id_t get_color_name_id (const void *base,</span>
<span class="line-modified"> 69                                      unsigned int color_index,</span>
<span class="line-added"> 70                                      unsigned int color_count) const</span>
 71   {
<span class="line-modified"> 72     if (!colorLabelsZ) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified"> 73     return (base+colorLabelsZ).as_array (color_count)[color_index];</span>
<span class="line-added"> 74   }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76   public:</span>
<span class="line-added"> 77   bool sanitize (hb_sanitize_context_t *c,</span>
<span class="line-added"> 78                  const void *base,</span>
<span class="line-added"> 79                  unsigned int palette_count,</span>
<span class="line-added"> 80                  unsigned int color_count) const</span>
<span class="line-added"> 81   {</span>
<span class="line-added"> 82     TRACE_SANITIZE (this);</span>
<span class="line-added"> 83     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added"> 84                   (!paletteFlagsZ  || (base+paletteFlagsZ).sanitize (c, palette_count)) &amp;&amp;</span>
<span class="line-added"> 85                   (!paletteLabelsZ || (base+paletteLabelsZ).sanitize (c, palette_count)) &amp;&amp;</span>
<span class="line-added"> 86                   (!colorLabelsZ   || (base+colorLabelsZ).sanitize (c, color_count)));</span>
 87   }
 88 
 89   protected:
<span class="line-modified"> 90   LNNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT32&gt; &gt;</span>
 91                 paletteFlagsZ;          /* Offset from the beginning of CPAL table to
 92                                          * the Palette Type Array. Set to 0 if no array
 93                                          * is provided. */
<span class="line-modified"> 94   LNNOffsetTo&lt;UnsizedArrayOf&lt;NameID&gt; &gt;</span>
<span class="line-modified"> 95                 paletteLabelsZ;         /* Offset from the beginning of CPAL table to</span>
<span class="line-modified"> 96                                          * the palette labels array. Set to 0 if no</span>
 97                                          * array is provided. */
<span class="line-modified"> 98   LNNOffsetTo&lt;UnsizedArrayOf&lt;NameID&gt; &gt;</span>
<span class="line-modified"> 99                 colorLabelsZ;           /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">100                                          * the color labels array. Set to 0</span>
101                                          * if no array is provided. */
102   public:
103   DEFINE_SIZE_STATIC (12);
104 };
105 
106 typedef HBUINT32 BGRAColor;
107 
108 struct CPAL
109 {
<span class="line-modified">110   static constexpr hb_tag_t tableTag = HB_OT_TAG_CPAL;</span>
111 
<span class="line-modified">112   bool has_data () const { return numPalettes; }</span>



















113 
<span class="line-modified">114   unsigned int get_size () const</span>
<span class="line-modified">115   { return min_size + numPalettes * sizeof (colorRecordIndicesZ[0]); }</span>


116 
<span class="line-modified">117   unsigned int get_palette_count () const { return numPalettes; }</span>
<span class="line-modified">118   unsigned int get_color_count () const   { return numColors; }</span>


119 
<span class="line-modified">120   hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette_index) const</span>
<span class="line-modified">121   { return v1 ().get_palette_flags (this, palette_index, numPalettes); }</span>

122 
<span class="line-modified">123   hb_ot_name_id_t get_palette_name_id (unsigned int palette_index) const</span>
<span class="line-modified">124   { return v1 ().get_palette_name_id (this, palette_index, numPalettes); }</span>


125 
<span class="line-modified">126   hb_ot_name_id_t get_color_name_id (unsigned int color_index) const</span>
<span class="line-modified">127   { return v1 ().get_color_name_id (this, color_index, numColors); }</span>

128 
<span class="line-modified">129   unsigned int get_palette_colors (unsigned int  palette_index,</span>
<span class="line-added">130                                    unsigned int  start_offset,</span>
<span class="line-added">131                                    unsigned int *color_count, /* IN/OUT.  May be NULL. */</span>
<span class="line-added">132                                    hb_color_t   *colors       /* OUT.     May be NULL. */) const</span>
133   {
<span class="line-modified">134     if (unlikely (palette_index &gt;= numPalettes))</span>
<span class="line-added">135     {</span>
<span class="line-added">136       if (color_count) *color_count = 0;</span>
<span class="line-added">137       return 0;</span>
<span class="line-added">138     }</span>
<span class="line-added">139     unsigned int start_index = colorRecordIndicesZ[palette_index];</span>
<span class="line-added">140     hb_array_t&lt;const BGRAColor&gt; all_colors ((this+colorRecordsZ).arrayZ, numColorRecords);</span>
<span class="line-added">141     hb_array_t&lt;const BGRAColor&gt; palette_colors = all_colors.sub_array (start_index,</span>
<span class="line-added">142                                                                        numColors);</span>
<span class="line-added">143     if (color_count)</span>
<span class="line-added">144     {</span>
<span class="line-added">145       hb_array_t&lt;const BGRAColor&gt; segment_colors = palette_colors.sub_array (start_offset, *color_count);</span>
<span class="line-added">146       /* Always return numColors colors per palette even if it has out-of-bounds start index. */</span>
<span class="line-added">147       unsigned int count = MIN&lt;unsigned int&gt; (MAX&lt;int&gt; (numColors - start_offset, 0), *color_count);</span>
<span class="line-added">148       *color_count = count;</span>
<span class="line-added">149       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">150         colors[i] = segment_colors[i]; /* Bound-checked read. */</span>
<span class="line-added">151     }</span>
<span class="line-added">152     return numColors;</span>
153   }
154 
<span class="line-modified">155   private:</span>
<span class="line-modified">156   const CPALV1Tail&amp; v1 () const</span>
157   {
<span class="line-modified">158     if (version == 0) return Null(CPALV1Tail);</span>
<span class="line-modified">159     return StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-added">160   }</span>
161 
<span class="line-modified">162   public:</span>
<span class="line-modified">163   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">164   {</span>
<span class="line-added">165     TRACE_SANITIZE (this);</span>
<span class="line-added">166     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">167                   (this+colorRecordsZ).sanitize (c, numColorRecords) &amp;&amp;</span>
<span class="line-added">168                   colorRecordIndicesZ.sanitize (c, numPalettes) &amp;&amp;</span>
<span class="line-added">169                   (version == 0 || v1 ().sanitize (c, this, numPalettes, numColors)));</span>
170   }
171 
172   protected:
173   HBUINT16      version;                /* Table version number */
174   /* Version 0 */
<span class="line-modified">175   HBUINT16      numColors;              /* Number of colors in each palette. */</span>
176   HBUINT16      numPalettes;            /* Number of palettes in the table. */
177   HBUINT16      numColorRecords;        /* Total number of color records, combined for
178                                          * all palettes. */
<span class="line-modified">179   LNNOffsetTo&lt;UnsizedArrayOf&lt;BGRAColor&gt; &gt;</span>
180                 colorRecordsZ;          /* Offset from the beginning of CPAL table to
181                                          * the first ColorRecord. */
182   UnsizedArrayOf&lt;HBUINT16&gt;
183                 colorRecordIndicesZ;    /* Index of each palette’s first color record in
184                                          * the combined color record array. */
185 /*CPALV1Tail    v1;*/
186   public:
187   DEFINE_SIZE_ARRAY (12, colorRecordIndicesZ);
188 };
189 
190 } /* namespace OT */
191 
192 
193 #endif /* HB_OT_COLOR_CPAL_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-color-colr-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-sbix-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/hb-jdk-font.cc</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;hb.h&quot;
 27 #include &quot;hb-jdk.h&quot;
 28 #ifdef MACOSX
 29 #include &quot;hb-coretext.h&quot;
 30 #endif
 31 #include &lt;stdlib.h&gt;
 32 
 33 #if defined(__GNUC__) &amp;&amp;  __GNUC__ &gt;= 4
 34 #define HB_UNUSED       __attribute__((unused))
 35 #else
 36 #define HB_UNUSED
 37 #endif
 38 
 39 static hb_bool_t
 40 hb_jdk_get_glyph (hb_font_t *font HB_UNUSED,
 41 		 void *font_data,
 42 		 hb_codepoint_t unicode,
 43 		 hb_codepoint_t variation_selector,
 44 		 hb_codepoint_t *glyph,
 45 		 void *user_data HB_UNUSED)
 46 {
 47 
 48     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
 49     JNIEnv* env = jdkFontInfo-&gt;env;
 50     jobject font2D = jdkFontInfo-&gt;font2D;
 51     if (variation_selector == 0) {
 52         *glyph = (hb_codepoint_t)env-&gt;CallIntMethod(
 53                      font2D, sunFontIDs.f2dCharToGlyphMID, unicode);
 54     } else {
 55         *glyph = (hb_codepoint_t)env-&gt;CallIntMethod(
 56                      font2D, sunFontIDs.f2dCharToVariationGlyphMID, 
 57                      unicode, variation_selector);
 58     }
 59     if (env-&gt;ExceptionOccurred())
 60     {
 61         env-&gt;ExceptionClear();
 62     }
 63     if ((int)*glyph &lt; 0) {
 64         *glyph = 0;
 65     }
 66     return (*glyph != 0);
 67 }
 68 
 69 static hb_position_t
 70 hb_jdk_get_glyph_h_advance (hb_font_t *font HB_UNUSED,
 71 			   void *font_data,
 72 			   hb_codepoint_t glyph,
 73 			   void *user_data HB_UNUSED)
 74 {
 75 
 76     float fadv = 0.0f;
 77     if ((glyph &amp; 0xfffe) == 0xfffe) {
 78         return 0; // JDK uses this glyph code.
 79     }
 80 
 81     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
 82     JNIEnv* env = jdkFontInfo-&gt;env;
 83     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
 84     jobject pt = env-&gt;CallObjectMethod(fontStrike,
 85                                        sunFontIDs.getGlyphMetricsMID, glyph);
 86 
 87     if (pt == NULL) {
 88         return 0;
 89     }
 90     fadv = env-&gt;GetFloatField(pt, sunFontIDs.xFID);
 91     fadv *= jdkFontInfo-&gt;devScale;
 92     env-&gt;DeleteLocalRef(pt);
 93 
 94     return HBFloatToFixed(fadv);
 95 }
 96 
 97 static hb_position_t
 98 hb_jdk_get_glyph_v_advance (hb_font_t *font HB_UNUSED,
 99 			   void *font_data,
100 			   hb_codepoint_t glyph,
101 			   void *user_data HB_UNUSED)
102 {
103 
104     float fadv = 0.0f;
105     if ((glyph &amp; 0xfffe) == 0xfffe) {
106         return 0; // JDK uses this glyph code.
107     }
108 
109     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
110     JNIEnv* env = jdkFontInfo-&gt;env;
111     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
112     jobject pt = env-&gt;CallObjectMethod(fontStrike,
113                                        sunFontIDs.getGlyphMetricsMID, glyph);
114 
115     if (pt == NULL) {
116         return 0;
117     }
118     fadv = env-&gt;GetFloatField(pt, sunFontIDs.yFID);
119     env-&gt;DeleteLocalRef(pt);
120 
121     return HBFloatToFixed(fadv);
122 
123 }
124 
125 static hb_bool_t
126 hb_jdk_get_glyph_h_origin (hb_font_t *font HB_UNUSED,
127 			  void *font_data HB_UNUSED,
128 			  hb_codepoint_t glyph HB_UNUSED,
129 			  hb_position_t *x HB_UNUSED,
130 			  hb_position_t *y HB_UNUSED,
131 			  void *user_data HB_UNUSED)
132 {
133   /* We always work in the horizontal coordinates. */
134   return true;
135 }
136 
137 static hb_bool_t
138 hb_jdk_get_glyph_v_origin (hb_font_t *font HB_UNUSED,
139 			  void *font_data,
140 			  hb_codepoint_t glyph,
141 			  hb_position_t *x,
142 			  hb_position_t *y,
143 			  void *user_data HB_UNUSED)
144 {
145   return false;
146 }
147 
148 static hb_position_t
149 hb_jdk_get_glyph_h_kerning (hb_font_t *font,
150 			   void *font_data,
151 			   hb_codepoint_t lejdk_glyph,
152 			   hb_codepoint_t right_glyph,
153 			   void *user_data HB_UNUSED)
154 {
155   /* Not implemented. This seems to be in the HB API
156    * as a way to fall back to Freetype&#39;s kerning support
157    * which could be based on some on-the fly glyph analysis.
158    * But more likely it reads the kern table. That is easy
159    * enough code to add if we find a need to fall back
160    * to that instead of using gpos. It seems like if
161    * there is a gpos table at all, the practice is to
162    * use that and ignore kern, no matter that gpos does
163    * not implement the kern feature.
164    */
165   return 0;
166 }
167 
168 static hb_position_t
169 hb_jdk_get_glyph_v_kerning (hb_font_t *font HB_UNUSED,
170 			   void *font_data HB_UNUSED,
171 			   hb_codepoint_t top_glyph HB_UNUSED,
172 			   hb_codepoint_t bottom_glyph HB_UNUSED,
173 			   void *user_data HB_UNUSED)
174 {
175   /* OpenType doesn&#39;t have vertical-kerning other than GPOS. */
176   return 0;
177 }
178 
179 static hb_bool_t
180 hb_jdk_get_glyph_extents (hb_font_t *font HB_UNUSED,
181 			 void *font_data,
182 			 hb_codepoint_t glyph,
183 			 hb_glyph_extents_t *extents,
184 			 void *user_data HB_UNUSED)
185 {
186   /* TODO */
187   return false;
188 }
189 
190 static hb_bool_t
191 hb_jdk_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
192 			       void *font_data,
193 			       hb_codepoint_t glyph,
194 			       unsigned int point_index,
195 			       hb_position_t *x,
196 			       hb_position_t *y,
197 			       void *user_data HB_UNUSED)
198 {
199     if ((glyph &amp; 0xfffe) == 0xfffe) {
200         *x = 0; *y = 0;
201         return true;
202     }
203 
204     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
205     JNIEnv* env = jdkFontInfo-&gt;env;
206     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
207     jobject pt = env-&gt;CallObjectMethod(fontStrike,
208                                        sunFontIDs.getGlyphPointMID,
209                                        glyph, point_index);
210 
211     if (pt == NULL) {
212         *x = 0; *y = 0;
213         return true;
214     }
215     *x = HBFloatToFixed(env-&gt;GetFloatField(pt, sunFontIDs.xFID));
216     *y = HBFloatToFixed(env-&gt;GetFloatField(pt, sunFontIDs.yFID));
217     env-&gt;DeleteLocalRef(pt);
218 
219   return true;
220 }
221 
222 static hb_bool_t
223 hb_jdk_get_glyph_name (hb_font_t *font HB_UNUSED,
224 		      void *font_data,
225 		      hb_codepoint_t glyph,
226 		      char *name, unsigned int size,
227 		      void *user_data HB_UNUSED)
228 {
229   return false;
230 }
231 
232 static hb_bool_t
233 hb_jdk_get_glyph_from_name (hb_font_t *font HB_UNUSED,
234 			   void *font_data,
235 			   const char *name, int len,
236 			   hb_codepoint_t *glyph,
237 			   void *user_data HB_UNUSED)
238 {
239   return false;
240 }
241 
242 // remind : can we initialise this from the code we call
243 // from the class static method in Java to make it
244 // completely thread safe.
245 static hb_font_funcs_t *
246 _hb_jdk_get_font_funcs (void)
247 {
248   static hb_font_funcs_t *jdk_ffuncs = NULL;
249   hb_font_funcs_t *ff;
250 
251   if (!jdk_ffuncs) {
252       ff = hb_font_funcs_create();
253 
254       hb_font_funcs_set_glyph_func(ff, hb_jdk_get_glyph, NULL, NULL);
255       hb_font_funcs_set_glyph_h_advance_func(ff,
256                     hb_jdk_get_glyph_h_advance, NULL, NULL);
257       hb_font_funcs_set_glyph_v_advance_func(ff,
258                     hb_jdk_get_glyph_v_advance, NULL, NULL);
259       hb_font_funcs_set_glyph_h_origin_func(ff,
260                     hb_jdk_get_glyph_h_origin, NULL, NULL);
261       hb_font_funcs_set_glyph_v_origin_func(ff,
262                     hb_jdk_get_glyph_v_origin, NULL, NULL);
263       hb_font_funcs_set_glyph_h_kerning_func(ff,
264                     hb_jdk_get_glyph_h_kerning, NULL, NULL);
265       hb_font_funcs_set_glyph_v_kerning_func(ff,
266                     hb_jdk_get_glyph_v_kerning, NULL, NULL);
267       hb_font_funcs_set_glyph_extents_func(ff,
268                     hb_jdk_get_glyph_extents, NULL, NULL);
269       hb_font_funcs_set_glyph_contour_point_func(ff,
270                     hb_jdk_get_glyph_contour_point, NULL, NULL);
271       hb_font_funcs_set_glyph_name_func(ff,
272                     hb_jdk_get_glyph_name, NULL, NULL);
273       hb_font_funcs_set_glyph_from_name_func(ff,
274                     hb_jdk_get_glyph_from_name, NULL, NULL);
275       hb_font_funcs_make_immutable(ff); // done setting functions.
276       jdk_ffuncs = ff;
277   }
278   return jdk_ffuncs;
279 }
280 
281 static void _do_nothing(void) {
282 }
283 
284 static void _free_nothing(void*) {
285 }
286 
287 static hb_blob_t *
288 reference_table(hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data) {
289 
290   JDKFontInfo *jdkFontInfo = (JDKFontInfo*)user_data;
291   JNIEnv* env = jdkFontInfo-&gt;env;
292   jobject font2D = jdkFontInfo-&gt;font2D;
293   jsize length = 0;
294   void* buffer = NULL;
295   int cacheIdx = 0;
296 
297   // HB_TAG_NONE is 0 and is used to get the whole font file.
298   // It is not expected to be needed for JDK.
299   if (tag == 0 || jdkFontInfo-&gt;layoutTables == NULL) {
300       return NULL;
301   }
302 
303   for (cacheIdx=0; cacheIdx&lt;LAYOUTCACHE_ENTRIES; cacheIdx++) {
304     if (tag == jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].tag) break;
305   }
306 
307   if (cacheIdx &lt; LAYOUTCACHE_ENTRIES) { // if found
308       if (jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len != -1) {
309           length = jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len;
310           buffer = (void*)jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].ptr;
311       }
312   }
313 
314   if (buffer == NULL) {
315       jbyteArray tableBytes = (jbyteArray)
316          env-&gt;CallObjectMethod(font2D, sunFontIDs.getTableBytesMID, tag);
317       if (tableBytes == NULL) {
318           return NULL;
319       }
320       length = env-&gt;GetArrayLength(tableBytes);
321       buffer = calloc(length, sizeof(jbyte));
322       env-&gt;GetByteArrayRegion(tableBytes, 0, length, (jbyte*)buffer);
323 
324      if (cacheIdx &gt;= LAYOUTCACHE_ENTRIES) { // not a cacheable table
325           return hb_blob_create((const char *)buffer, length,
326                                  HB_MEMORY_MODE_WRITABLE,
327                                  buffer, free);
328       } else {
329         jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len = length;
330         jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].ptr = buffer;
331       }
332   }
333 
334   return hb_blob_create((const char *)buffer, length,
335                          HB_MEMORY_MODE_READONLY,
336                          NULL, _free_nothing);
337 }
338 
339 
340 
341 hb_face_t*
342 hb_jdk_face_create(JDKFontInfo *jdkFontInfo,
343                    hb_destroy_func_t destroy) {
344 
345     hb_face_t *face =
346          hb_face_create_for_tables(reference_table, jdkFontInfo, destroy);
347 
348     return face;
349 }
350 
351 static hb_font_t* _hb_jdk_font_create(JDKFontInfo *jdkFontInfo,
352                                       hb_destroy_func_t destroy) {
353 
354     hb_font_t *font;
355     hb_face_t *face;
356 
357     face = hb_jdk_face_create(jdkFontInfo, destroy);
358     font = hb_font_create(face);
359     hb_face_destroy (face);
360     hb_font_set_funcs (font,
361                        _hb_jdk_get_font_funcs (),
362                        jdkFontInfo, (hb_destroy_func_t) _do_nothing);
363     hb_font_set_scale (font,
364                       HBFloatToFixed(jdkFontInfo-&gt;ptSize*jdkFontInfo-&gt;devScale),
365                       HBFloatToFixed(jdkFontInfo-&gt;ptSize*jdkFontInfo-&gt;devScale));
366   return font;
367 }
368 
369 #ifdef MACOSX
370 static hb_font_t* _hb_jdk_ct_font_create(JDKFontInfo *jdkFontInfo) {
371 
372     hb_font_t *font = NULL;
373     hb_face_t *face = NULL;
374     if (jdkFontInfo-&gt;nativeFont == 0) {
375         return NULL;
376     }
377     face = hb_coretext_face_create((CGFontRef)(jdkFontInfo-&gt;nativeFont));
378     font = hb_font_create(face);
379     hb_face_destroy(face);
380 
381     hb_font_set_scale(font,
382                      HBFloatToFixed(jdkFontInfo-&gt;ptSize),
383                      HBFloatToFixed(jdkFontInfo-&gt;ptSize));
384     return font;
385 }
386 #endif
387 
388 hb_font_t* hb_jdk_font_create(JDKFontInfo *jdkFontInfo,
389                              hb_destroy_func_t destroy) {
390 
391    hb_font_t* font = NULL;
392 
393 #ifdef MACOSX
394      if (jdkFontInfo-&gt;aat) {
395          font = _hb_jdk_ct_font_create(jdkFontInfo);
396      }
397 #endif
398     if (font == NULL) {
399         font = _hb_jdk_font_create(jdkFontInfo, destroy);
400     }
401     return font;
402 }
    </pre>
  </body>
</html>
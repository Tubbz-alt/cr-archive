<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-object-private.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2007  Chris Wilson
  3  * Copyright © 2009,2010  Red Hat, Inc.
  4  * Copyright © 2011,2012  Google, Inc.
  5  *
  6  *  This is part of HarfBuzz, a text shaping library.
  7  *
  8  * Permission is hereby granted, without written agreement and without
  9  * license or royalty fees, to use, copy, modify, and distribute this
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Contributor(s):
 27  *      Chris Wilson &lt;chris@chris-wilson.co.uk&gt;
 28  * Red Hat Author(s): Behdad Esfahbod
 29  * Google Author(s): Behdad Esfahbod
 30  */
 31 
 32 #ifndef HB_OBJECT_PRIVATE_HH
 33 #define HB_OBJECT_PRIVATE_HH
 34 
 35 #include &quot;hb-private.hh&quot;
 36 #include &quot;hb-debug.hh&quot;
 37 
 38 #include &quot;hb-atomic-private.hh&quot;
 39 #include &quot;hb-mutex-private.hh&quot;
 40 
 41 
 42 /* reference_count */
 43 
 44 #define HB_REFERENCE_COUNT_INERT_VALUE 0
 45 #define HB_REFERENCE_COUNT_POISON_VALUE -0x0000DEAD
 46 #define HB_REFERENCE_COUNT_INIT {HB_ATOMIC_INT_INIT (HB_REFERENCE_COUNT_INERT_VALUE)}
 47 
 48 struct hb_reference_count_t
 49 {
 50   hb_atomic_int_t ref_count;
 51 
 52   inline void init (int v) { ref_count.set_unsafe (v); }
 53   inline int get_unsafe (void) const { return ref_count.get_unsafe (); }
 54   inline int inc (void) { return ref_count.inc (); }
 55   inline int dec (void) { return ref_count.dec (); }
 56   inline void fini (void) { ref_count.set_unsafe (HB_REFERENCE_COUNT_POISON_VALUE); }
 57 
 58   inline bool is_inert (void) const { return ref_count.get_unsafe () == HB_REFERENCE_COUNT_INERT_VALUE; }
 59   inline bool is_valid (void) const { return ref_count.get_unsafe () &gt; 0; }
 60 };
 61 
 62 
 63 /* user_data */
 64 
 65 struct hb_user_data_array_t
 66 {
 67   struct hb_user_data_item_t {
 68     hb_user_data_key_t *key;
 69     void *data;
 70     hb_destroy_func_t destroy;
 71 
 72     inline bool operator == (hb_user_data_key_t *other_key) const { return key == other_key; }
 73     inline bool operator == (hb_user_data_item_t &amp;other) const { return key == other.key; }
 74 
 75     void fini (void) { if (destroy) destroy (data); }
 76   };
 77 
 78   hb_mutex_t lock;
 79   hb_lockable_set_t&lt;hb_user_data_item_t, hb_mutex_t&gt; items;
 80 
 81   inline void init (void) { lock.init (); items.init (); }
 82 
 83   HB_INTERNAL bool set (hb_user_data_key_t *key,
 84                         void *              data,
 85                         hb_destroy_func_t   destroy,
 86                         hb_bool_t           replace);
 87 
 88   HB_INTERNAL void *get (hb_user_data_key_t *key);
 89 
 90   inline void fini (void) { items.fini (lock); lock.fini (); }
 91 };
 92 
 93 
 94 /* object_header */
 95 
 96 struct hb_object_header_t
 97 {
 98   hb_reference_count_t ref_count;
 99   hb_user_data_array_t *user_data;
100 
101 #define HB_OBJECT_HEADER_STATIC {HB_REFERENCE_COUNT_INIT, nullptr}
102 
103   private:
104   ASSERT_POD ();
105 };
106 
107 
108 /* object */
109 
110 template &lt;typename Type&gt;
111 static inline void hb_object_trace (const Type *obj, const char *function)
112 {
113   DEBUG_MSG (OBJECT, (void *) obj,
114              &quot;%s refcount=%d&quot;,
115              function,
116              obj ? obj-&gt;header.ref_count.get_unsafe () : 0);
117 }
118 
119 template &lt;typename Type&gt;
120 static inline Type *hb_object_create (void)
121 {
122   Type *obj = (Type *) calloc (1, sizeof (Type));
123 
124   if (unlikely (!obj))
125     return obj;
126 
127   hb_object_init (obj);
128   hb_object_trace (obj, HB_FUNC);
129   return obj;
130 }
131 template &lt;typename Type&gt;
132 static inline void hb_object_init (Type *obj)
133 {
134   obj-&gt;header.ref_count.init (1);
135   obj-&gt;header.user_data = nullptr;
136 }
137 template &lt;typename Type&gt;
138 static inline bool hb_object_is_inert (const Type *obj)
139 {
140   return unlikely (obj-&gt;header.ref_count.is_inert ());
141 }
142 template &lt;typename Type&gt;
143 static inline bool hb_object_is_valid (const Type *obj)
144 {
145   return likely (obj-&gt;header.ref_count.is_valid ());
146 }
147 template &lt;typename Type&gt;
148 static inline Type *hb_object_reference (Type *obj)
149 {
150   hb_object_trace (obj, HB_FUNC);
151   if (unlikely (!obj || hb_object_is_inert (obj)))
152     return obj;
153   assert (hb_object_is_valid (obj));
154   obj-&gt;header.ref_count.inc ();
155   return obj;
156 }
157 template &lt;typename Type&gt;
158 static inline bool hb_object_destroy (Type *obj)
159 {
160   hb_object_trace (obj, HB_FUNC);
161   if (unlikely (!obj || hb_object_is_inert (obj)))
162     return false;
163   assert (hb_object_is_valid (obj));
164   if (obj-&gt;header.ref_count.dec () != 1)
165     return false;
166 
167   hb_object_fini (obj);
168   return true;
169 }
170 template &lt;typename Type&gt;
171 static inline void hb_object_fini (Type *obj)
172 {
173   obj-&gt;header.ref_count.fini (); /* Do this before user_data */
174   if (obj-&gt;header.user_data)
175   {
176     obj-&gt;header.user_data-&gt;fini ();
177     free (obj-&gt;header.user_data);
178   }
179 }
180 template &lt;typename Type&gt;
181 static inline bool hb_object_set_user_data (Type               *obj,
182                                             hb_user_data_key_t *key,
183                                             void *              data,
184                                             hb_destroy_func_t   destroy,
185                                             hb_bool_t           replace)
186 {
187   if (unlikely (!obj || hb_object_is_inert (obj)))
188     return false;
189   assert (hb_object_is_valid (obj));
190 
191 retry:
192   hb_user_data_array_t *user_data = (hb_user_data_array_t *) hb_atomic_ptr_get (&amp;obj-&gt;header.user_data);
193   if (unlikely (!user_data))
194   {
195     user_data = (hb_user_data_array_t *) calloc (sizeof (hb_user_data_array_t), 1);
196     if (unlikely (!user_data))
197       return false;
198     user_data-&gt;init ();
199     if (unlikely (!hb_atomic_ptr_cmpexch (&amp;obj-&gt;header.user_data, nullptr, user_data)))
200     {
201       user_data-&gt;fini ();
202       free (user_data);
203       goto retry;
204     }
205   }
206 
207   return user_data-&gt;set (key, data, destroy, replace);
208 }
209 
210 template &lt;typename Type&gt;
211 static inline void *hb_object_get_user_data (Type               *obj,
212                                              hb_user_data_key_t *key)
213 {
214   if (unlikely (!obj || hb_object_is_inert (obj) || !obj-&gt;header.user_data))
215     return nullptr;
216   assert (hb_object_is_valid (obj));
217   return obj-&gt;header.user_data-&gt;get (key);
218 }
219 
220 
221 #endif /* HB_OBJECT_PRIVATE_HH */
    </pre>
  </body>
</html>
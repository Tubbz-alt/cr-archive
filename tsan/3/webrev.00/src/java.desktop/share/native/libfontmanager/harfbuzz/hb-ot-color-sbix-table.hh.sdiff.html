<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-sbix-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-color-cpal-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-svg-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-sbix-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  */
 24 
 25 #ifndef HB_OT_COLOR_SBIX_TABLE_HH
 26 #define HB_OT_COLOR_SBIX_TABLE_HH
 27 
<span class="line-modified"> 28 #include &quot;hb-open-type-private.hh&quot;</span>
 29 
 30 /*
 31  * sbix -- Standard Bitmap Graphics
 32  * https://docs.microsoft.com/en-us/typography/opentype/spec/sbix
 33  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6sbix.html
 34  */
 35 #define HB_OT_TAG_sbix HB_TAG(&#39;s&#39;,&#39;b&#39;,&#39;i&#39;,&#39;x&#39;)
 36 
 37 
 38 namespace OT {
 39 
 40 
 41 struct SBIXGlyph
 42 {
 43   HBINT16       xOffset;        /* The horizontal (x-axis) offset from the left
 44                                  * edge of the graphic to the glyph’s origin.
 45                                  * That is, the x-coordinate of the point on the
 46                                  * baseline at the left edge of the glyph. */
 47   HBINT16       yOffset;        /* The vertical (y-axis) offset from the bottom
 48                                  * edge of the graphic to the glyph’s origin.
 49                                  * That is, the y-coordinate of the point on the
 50                                  * baseline at the left edge of the glyph. */
 51   Tag           graphicType;    /* Indicates the format of the embedded graphic
 52                                  * data: one of &#39;jpg &#39;, &#39;png &#39; or &#39;tiff&#39;, or the
 53                                  * special format &#39;dupe&#39;. */
 54   UnsizedArrayOf&lt;HBUINT8&gt;
 55                 data;           /* The actual embedded graphic data. The total
 56                                  * length is inferred from sequential entries in
 57                                  * the glyphDataOffsets array and the fixed size
 58                                  * (8 bytes) of the preceding fields. */
 59   public:
 60   DEFINE_SIZE_ARRAY (8, data);
 61 };
 62 
 63 struct SBIXStrike
 64 {
<span class="line-modified"> 65   friend struct sbix;</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 68   {
 69     TRACE_SANITIZE (this);
 70     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified"> 71                   imageOffsetsZ.sanitize_shallow (c, c-&gt;num_glyphs + 1));</span>
 72   }
 73 
<span class="line-modified"> 74   protected:</span>















































 75   HBUINT16      ppem;           /* The PPEM size for which this strike was designed. */
 76   HBUINT16      resolution;     /* The device pixel density (in PPI) for which this
 77                                  * strike was designed. (E.g., 96 PPI, 192 PPI.) */

 78   UnsizedArrayOf&lt;LOffsetTo&lt;SBIXGlyph&gt; &gt;
 79                 imageOffsetsZ;  /* Offset from the beginning of the strike data header
 80                                  * to bitmap data for an individual glyph ID. */
 81   public:
 82   DEFINE_SIZE_STATIC (8);
 83 };
 84 
 85 struct sbix
 86 {
<span class="line-modified"> 87   static const hb_tag_t tableTag = HB_OT_TAG_sbix;</span>
 88 
<span class="line-modified"> 89   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified"> 90   {</span>
<span class="line-modified"> 91     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 92     return_trace (likely (c-&gt;check_struct (this) &amp;&amp; strikes.sanitize (c, this)));</span>
<span class="line-removed"> 93   }</span>
 94 
 95   struct accelerator_t
 96   {
<span class="line-modified"> 97     inline void init (hb_face_t *face)</span>
 98     {
<span class="line-modified"> 99       num_glyphs = hb_face_get_glyph_count (face);</span>





100 
<span class="line-modified">101       OT::Sanitizer&lt;OT::sbix&gt; sanitizer;</span>
<span class="line-modified">102       sanitizer.set_num_glyphs (num_glyphs);</span>
<span class="line-modified">103       sbix_blob = sanitizer.sanitize (face-&gt;reference_table (HB_OT_TAG_sbix));</span>
<span class="line-modified">104       sbix_len = hb_blob_get_length (sbix_blob);</span>
<span class="line-modified">105       sbix_table = sbix_blob-&gt;as&lt;OT::sbix&gt; ();</span>


106 










107     }
108 
<span class="line-modified">109     inline void fini (void)</span>


110     {
<span class="line-modified">111       hb_blob_destroy (sbix_blob);</span>






















112     }
113 
<span class="line-modified">114     inline void dump (void (*callback) (const uint8_t* data, unsigned int length,</span>
<span class="line-removed">115                                         unsigned int group, unsigned int gid)) const</span>
116     {
<span class="line-modified">117       for (unsigned group = 0; group &lt; sbix_table-&gt;strikes.len; ++group)</span>

118       {
<span class="line-modified">119         const SBIXStrike &amp;strike = sbix_table-&gt;strikes[group](sbix_table);</span>
<span class="line-modified">120         for (unsigned int glyph = 0; glyph &lt; num_glyphs; ++glyph)</span>
<span class="line-modified">121           if (strike.imageOffsetsZ[glyph + 1] - strike.imageOffsetsZ[glyph] &gt; 0)</span>
<span class="line-modified">122           {</span>
<span class="line-modified">123             const SBIXGlyph &amp;sbixGlyph = strike.imageOffsetsZ[glyph]((const void *) &amp;strike);</span>
<span class="line-modified">124             callback ((const uint8_t*) &amp;sbixGlyph.data,</span>
<span class="line-modified">125                       strike.imageOffsetsZ[glyph + 1] - strike.imageOffsetsZ[glyph] - 8,</span>
<span class="line-modified">126                       group, glyph);</span>
<span class="line-modified">127           }</span>





































128       }




129     }
130 
131     private:
<span class="line-modified">132     hb_blob_t *sbix_blob;</span>
<span class="line-removed">133     const sbix *sbix_table;</span>
134 
<span class="line-removed">135     unsigned int sbix_len;</span>
136     unsigned int num_glyphs;
<span class="line-removed">137 </span>
138   };
139 








140   protected:
141   HBUINT16      version;        /* Table version number — set to 1 */
142   HBUINT16      flags;          /* Bit 0: Set to 1. Bit 1: Draw outlines.
143                                  * Bits 2 to 15: reserved (set to 0). */
<span class="line-modified">144   LArrayOf&lt;LOffsetTo&lt;SBIXStrike&gt; &gt;</span>
145                 strikes;        /* Offsets from the beginning of the &#39;sbix&#39;
146                                  * table to data for each individual bitmap strike. */
147   public:
148   DEFINE_SIZE_ARRAY (8, strikes);
149 };
150 


151 } /* namespace OT */
152 
153 #endif /* HB_OT_COLOR_SBIX_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  */
 24 
 25 #ifndef HB_OT_COLOR_SBIX_TABLE_HH
 26 #define HB_OT_COLOR_SBIX_TABLE_HH
 27 
<span class="line-modified"> 28 #include &quot;hb-open-type.hh&quot;</span>
 29 
 30 /*
 31  * sbix -- Standard Bitmap Graphics
 32  * https://docs.microsoft.com/en-us/typography/opentype/spec/sbix
 33  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6sbix.html
 34  */
 35 #define HB_OT_TAG_sbix HB_TAG(&#39;s&#39;,&#39;b&#39;,&#39;i&#39;,&#39;x&#39;)
 36 
 37 
 38 namespace OT {
 39 
 40 
 41 struct SBIXGlyph
 42 {
 43   HBINT16       xOffset;        /* The horizontal (x-axis) offset from the left
 44                                  * edge of the graphic to the glyph’s origin.
 45                                  * That is, the x-coordinate of the point on the
 46                                  * baseline at the left edge of the glyph. */
 47   HBINT16       yOffset;        /* The vertical (y-axis) offset from the bottom
 48                                  * edge of the graphic to the glyph’s origin.
 49                                  * That is, the y-coordinate of the point on the
 50                                  * baseline at the left edge of the glyph. */
 51   Tag           graphicType;    /* Indicates the format of the embedded graphic
 52                                  * data: one of &#39;jpg &#39;, &#39;png &#39; or &#39;tiff&#39;, or the
 53                                  * special format &#39;dupe&#39;. */
 54   UnsizedArrayOf&lt;HBUINT8&gt;
 55                 data;           /* The actual embedded graphic data. The total
 56                                  * length is inferred from sequential entries in
 57                                  * the glyphDataOffsets array and the fixed size
 58                                  * (8 bytes) of the preceding fields. */
 59   public:
 60   DEFINE_SIZE_ARRAY (8, data);
 61 };
 62 
 63 struct SBIXStrike
 64 {
<span class="line-modified"> 65   bool sanitize (hb_sanitize_context_t *c) const</span>


 66   {
 67     TRACE_SANITIZE (this);
 68     return_trace (c-&gt;check_struct (this) &amp;&amp;
<span class="line-modified"> 69                   imageOffsetsZ.sanitize_shallow (c, c-&gt;get_num_glyphs () + 1));</span>
 70   }
 71 
<span class="line-modified"> 72   hb_blob_t *get_glyph_blob (unsigned int  glyph_id,</span>
<span class="line-added"> 73                              hb_blob_t    *sbix_blob,</span>
<span class="line-added"> 74                              hb_tag_t      file_type,</span>
<span class="line-added"> 75                              int          *x_offset,</span>
<span class="line-added"> 76                              int          *y_offset,</span>
<span class="line-added"> 77                              unsigned int  num_glyphs,</span>
<span class="line-added"> 78                              unsigned int *strike_ppem) const</span>
<span class="line-added"> 79   {</span>
<span class="line-added"> 80     if (unlikely (!ppem)) return hb_blob_get_empty (); /* To get Null() object out of the way. */</span>
<span class="line-added"> 81 </span>
<span class="line-added"> 82     unsigned int retry_count = 8;</span>
<span class="line-added"> 83     unsigned int sbix_len = sbix_blob-&gt;length;</span>
<span class="line-added"> 84     unsigned int strike_offset = (const char *) this - (const char *) sbix_blob-&gt;data;</span>
<span class="line-added"> 85     assert (strike_offset &lt; sbix_len);</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87   retry:</span>
<span class="line-added"> 88     if (unlikely (glyph_id &gt;= num_glyphs ||</span>
<span class="line-added"> 89                   imageOffsetsZ[glyph_id + 1] &lt;= imageOffsetsZ[glyph_id] ||</span>
<span class="line-added"> 90                   imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] &lt;= SBIXGlyph::min_size ||</span>
<span class="line-added"> 91                   (unsigned int) imageOffsetsZ[glyph_id + 1] &gt; sbix_len - strike_offset))</span>
<span class="line-added"> 92       return hb_blob_get_empty ();</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94     unsigned int glyph_offset = strike_offset + (unsigned int) imageOffsetsZ[glyph_id] + SBIXGlyph::min_size;</span>
<span class="line-added"> 95     unsigned int glyph_length = imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] - SBIXGlyph::min_size;</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97     const SBIXGlyph *glyph = &amp;(this+imageOffsetsZ[glyph_id]);</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99     if (glyph-&gt;graphicType == HB_TAG (&#39;d&#39;,&#39;u&#39;,&#39;p&#39;,&#39;e&#39;))</span>
<span class="line-added">100     {</span>
<span class="line-added">101       if (glyph_length &gt;= 2)</span>
<span class="line-added">102       {</span>
<span class="line-added">103         glyph_id = *((HBUINT16 *) &amp;glyph-&gt;data);</span>
<span class="line-added">104         if (retry_count--)</span>
<span class="line-added">105           goto retry;</span>
<span class="line-added">106       }</span>
<span class="line-added">107       return hb_blob_get_empty ();</span>
<span class="line-added">108     }</span>
<span class="line-added">109 </span>
<span class="line-added">110     if (unlikely (file_type != glyph-&gt;graphicType))</span>
<span class="line-added">111       return hb_blob_get_empty ();</span>
<span class="line-added">112 </span>
<span class="line-added">113     if (strike_ppem) *strike_ppem = ppem;</span>
<span class="line-added">114     if (x_offset) *x_offset = glyph-&gt;xOffset;</span>
<span class="line-added">115     if (y_offset) *y_offset = glyph-&gt;yOffset;</span>
<span class="line-added">116     return hb_blob_create_sub_blob (sbix_blob, glyph_offset, glyph_length);</span>
<span class="line-added">117   }</span>
<span class="line-added">118 </span>
<span class="line-added">119   public:</span>
120   HBUINT16      ppem;           /* The PPEM size for which this strike was designed. */
121   HBUINT16      resolution;     /* The device pixel density (in PPI) for which this
122                                  * strike was designed. (E.g., 96 PPI, 192 PPI.) */
<span class="line-added">123   protected:</span>
124   UnsizedArrayOf&lt;LOffsetTo&lt;SBIXGlyph&gt; &gt;
125                 imageOffsetsZ;  /* Offset from the beginning of the strike data header
126                                  * to bitmap data for an individual glyph ID. */
127   public:
128   DEFINE_SIZE_STATIC (8);
129 };
130 
131 struct sbix
132 {
<span class="line-modified">133   static constexpr hb_tag_t tableTag = HB_OT_TAG_sbix;</span>
134 
<span class="line-modified">135   bool has_data () const { return version; }</span>
<span class="line-modified">136 </span>
<span class="line-modified">137   const SBIXStrike &amp;get_strike (unsigned int i) const { return this+strikes[i]; }</span>


138 
139   struct accelerator_t
140   {
<span class="line-modified">141     void init (hb_face_t *face)</span>
142     {
<span class="line-modified">143       table = hb_sanitize_context_t().reference_table&lt;sbix&gt; (face);</span>
<span class="line-added">144       num_glyphs = face-&gt;get_num_glyphs ();</span>
<span class="line-added">145     }</span>
<span class="line-added">146     void fini () { table.destroy (); }</span>
<span class="line-added">147 </span>
<span class="line-added">148     bool has_data () const { return table-&gt;has_data (); }</span>
149 
<span class="line-modified">150     bool get_extents (hb_font_t          *font,</span>
<span class="line-modified">151                       hb_codepoint_t      glyph,</span>
<span class="line-modified">152                       hb_glyph_extents_t *extents) const</span>
<span class="line-modified">153     {</span>
<span class="line-modified">154       /* We only support PNG right now, and following function checks type. */</span>
<span class="line-added">155       return get_png_extents (font, glyph, extents);</span>
<span class="line-added">156     }</span>
157 
<span class="line-added">158     hb_blob_t *reference_png (hb_font_t      *font,</span>
<span class="line-added">159                               hb_codepoint_t  glyph_id,</span>
<span class="line-added">160                               int            *x_offset,</span>
<span class="line-added">161                               int            *y_offset,</span>
<span class="line-added">162                               unsigned int   *available_ppem) const</span>
<span class="line-added">163     {</span>
<span class="line-added">164       return choose_strike (font).get_glyph_blob (glyph_id, table.get_blob (),</span>
<span class="line-added">165                                                   HB_TAG (&#39;p&#39;,&#39;n&#39;,&#39;g&#39;,&#39; &#39;),</span>
<span class="line-added">166                                                   x_offset, y_offset,</span>
<span class="line-added">167                                                   num_glyphs, available_ppem);</span>
168     }
169 
<span class="line-modified">170     private:</span>
<span class="line-added">171 </span>
<span class="line-added">172     const SBIXStrike &amp;choose_strike (hb_font_t *font) const</span>
173     {
<span class="line-modified">174       unsigned count = table-&gt;strikes.len;</span>
<span class="line-added">175       if (unlikely (!count))</span>
<span class="line-added">176         return Null(SBIXStrike);</span>
<span class="line-added">177 </span>
<span class="line-added">178       unsigned int requested_ppem = MAX (font-&gt;x_ppem, font-&gt;y_ppem);</span>
<span class="line-added">179       if (!requested_ppem)</span>
<span class="line-added">180         requested_ppem = 1&lt;&lt;30; /* Choose largest strike. */</span>
<span class="line-added">181       /* TODO Add DPI sensitivity as well? */</span>
<span class="line-added">182       unsigned int best_i = 0;</span>
<span class="line-added">183       unsigned int best_ppem = table-&gt;get_strike (0).ppem;</span>
<span class="line-added">184 </span>
<span class="line-added">185       for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-added">186       {</span>
<span class="line-added">187         unsigned int ppem = (table-&gt;get_strike (i)).ppem;</span>
<span class="line-added">188         if ((requested_ppem &lt;= ppem &amp;&amp; ppem &lt; best_ppem) ||</span>
<span class="line-added">189             (requested_ppem &gt; best_ppem &amp;&amp; ppem &gt; best_ppem))</span>
<span class="line-added">190         {</span>
<span class="line-added">191           best_i = i;</span>
<span class="line-added">192           best_ppem = ppem;</span>
<span class="line-added">193         }</span>
<span class="line-added">194       }</span>
<span class="line-added">195 </span>
<span class="line-added">196       return table-&gt;get_strike (best_i);</span>
197     }
198 
<span class="line-modified">199     struct PNGHeader</span>

200     {
<span class="line-modified">201       HBUINT8   signature[8];</span>
<span class="line-added">202       struct</span>
203       {
<span class="line-modified">204         struct</span>
<span class="line-modified">205         {</span>
<span class="line-modified">206           HBUINT32      length;</span>
<span class="line-modified">207           Tag           type;</span>
<span class="line-modified">208         }               header;</span>
<span class="line-modified">209         HBUINT32        width;</span>
<span class="line-modified">210         HBUINT32        height;</span>
<span class="line-modified">211         HBUINT8         bitDepth;</span>
<span class="line-modified">212         HBUINT8         colorType;</span>
<span class="line-added">213         HBUINT8         compressionMethod;</span>
<span class="line-added">214         HBUINT8         filterMethod;</span>
<span class="line-added">215         HBUINT8         interlaceMethod;</span>
<span class="line-added">216       } IHDR;</span>
<span class="line-added">217 </span>
<span class="line-added">218       public:</span>
<span class="line-added">219       DEFINE_SIZE_STATIC (29);</span>
<span class="line-added">220     };</span>
<span class="line-added">221 </span>
<span class="line-added">222     bool get_png_extents (hb_font_t          *font,</span>
<span class="line-added">223                           hb_codepoint_t      glyph,</span>
<span class="line-added">224                           hb_glyph_extents_t *extents) const</span>
<span class="line-added">225     {</span>
<span class="line-added">226       /* Following code is safe to call even without data.</span>
<span class="line-added">227        * But faster to short-circuit. */</span>
<span class="line-added">228       if (!has_data ())</span>
<span class="line-added">229         return false;</span>
<span class="line-added">230 </span>
<span class="line-added">231       int x_offset = 0, y_offset = 0;</span>
<span class="line-added">232       unsigned int strike_ppem = 0;</span>
<span class="line-added">233       hb_blob_t *blob = reference_png (font, glyph, &amp;x_offset, &amp;y_offset, &amp;strike_ppem);</span>
<span class="line-added">234 </span>
<span class="line-added">235       const PNGHeader &amp;png = *blob-&gt;as&lt;PNGHeader&gt;();</span>
<span class="line-added">236 </span>
<span class="line-added">237       extents-&gt;x_bearing = x_offset;</span>
<span class="line-added">238       extents-&gt;y_bearing = y_offset;</span>
<span class="line-added">239       extents-&gt;width     = png.IHDR.width;</span>
<span class="line-added">240       extents-&gt;height    = png.IHDR.height;</span>
<span class="line-added">241 </span>
<span class="line-added">242       /* Convert to font units. */</span>
<span class="line-added">243       if (strike_ppem)</span>
<span class="line-added">244       {</span>
<span class="line-added">245         double scale = font-&gt;face-&gt;get_upem () / (double) strike_ppem;</span>
<span class="line-added">246         extents-&gt;x_bearing = round (extents-&gt;x_bearing * scale);</span>
<span class="line-added">247         extents-&gt;y_bearing = round (extents-&gt;y_bearing * scale);</span>
<span class="line-added">248         extents-&gt;width = round (extents-&gt;width * scale);</span>
<span class="line-added">249         extents-&gt;height = round (extents-&gt;height * scale);</span>
250       }
<span class="line-added">251 </span>
<span class="line-added">252       hb_blob_destroy (blob);</span>
<span class="line-added">253 </span>
<span class="line-added">254       return strike_ppem;</span>
255     }
256 
257     private:
<span class="line-modified">258     hb_blob_ptr_t&lt;sbix&gt; table;</span>

259 

260     unsigned int num_glyphs;

261   };
262 
<span class="line-added">263   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">264   {</span>
<span class="line-added">265     TRACE_SANITIZE (this);</span>
<span class="line-added">266     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">267                           version &gt;= 1 &amp;&amp;</span>
<span class="line-added">268                           strikes.sanitize (c, this)));</span>
<span class="line-added">269   }</span>
<span class="line-added">270 </span>
271   protected:
272   HBUINT16      version;        /* Table version number — set to 1 */
273   HBUINT16      flags;          /* Bit 0: Set to 1. Bit 1: Draw outlines.
274                                  * Bits 2 to 15: reserved (set to 0). */
<span class="line-modified">275   LOffsetLArrayOf&lt;SBIXStrike&gt;</span>
276                 strikes;        /* Offsets from the beginning of the &#39;sbix&#39;
277                                  * table to data for each individual bitmap strike. */
278   public:
279   DEFINE_SIZE_ARRAY (8, strikes);
280 };
281 
<span class="line-added">282 struct sbix_accelerator_t : sbix::accelerator_t {};</span>
<span class="line-added">283 </span>
284 } /* namespace OT */
285 
286 #endif /* HB_OT_COLOR_SBIX_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-color-cpal-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-svg-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
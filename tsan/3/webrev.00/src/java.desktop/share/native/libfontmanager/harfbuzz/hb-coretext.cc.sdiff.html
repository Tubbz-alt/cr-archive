<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-common.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-debug.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Mozilla Author(s): Jonathan Kew
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<span class="line-modified">  29 #define HB_SHAPER coretext</span>
<span class="line-modified">  30 </span>
<span class="line-removed">  31 #include &quot;hb-private.hh&quot;</span>
<span class="line-removed">  32 #include &quot;hb-debug.hh&quot;</span>
<span class="line-removed">  33 #include &quot;hb-shaper-impl-private.hh&quot;</span>
  34 
  35 #include &quot;hb-coretext.h&quot;

  36 #include &lt;math.h&gt;
  37 










  38 /* https://developer.apple.com/documentation/coretext/1508745-ctfontcreatewithgraphicsfont */
  39 #define HB_CORETEXT_DEFAULT_FONT_SIZE 12.f
  40 
  41 static CGFloat
  42 coretext_font_size_from_ptem (float ptem)
  43 {
  44   /* CoreText points are CSS pixels (96 per inch),
  45    * NOT typographic points (72 per inch).
  46    *
  47    * https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html
  48    */
  49   ptem *= 96.f / 72.f;
  50   return ptem &lt;= 0.f ? HB_CORETEXT_DEFAULT_FONT_SIZE : ptem;
  51 }
  52 static float
  53 coretext_font_size_to_ptem (CGFloat size)
  54 {
  55   size *= 72.f / 96.f;
  56   return size &lt;= 0.f ? 0 : size;
  57 }
</pre>
<hr />
<pre>
  74   const char *data = reinterpret_cast&lt;const char*&gt; (CFDataGetBytePtr (cf_data));
  75   const size_t length = CFDataGetLength (cf_data);
  76   if (!data || !length)
  77   {
  78     CFRelease (cf_data);
  79     return nullptr;
  80   }
  81 
  82   return hb_blob_create (data, length, HB_MEMORY_MODE_READONLY,
  83                          reinterpret_cast&lt;void *&gt; (const_cast&lt;__CFData *&gt; (cf_data)),
  84                          release_table_data);
  85 }
  86 
  87 static void
  88 _hb_cg_font_release (void *data)
  89 {
  90   CGFontRelease ((CGFontRef) data);
  91 }
  92 
  93 
<span class="line-removed">  94 HB_SHAPER_DATA_ENSURE_DEFINE(coretext, face)</span>
<span class="line-removed">  95 HB_SHAPER_DATA_ENSURE_DEFINE_WITH_CONDITION(coretext, font,</span>
<span class="line-removed">  96         fabs (CTFontGetSize((CTFontRef) data) - coretext_font_size_from_ptem (font-&gt;ptem)) &lt;= .5</span>
<span class="line-removed">  97 )</span>
<span class="line-removed">  98 </span>
  99 static CTFontDescriptorRef
<span class="line-modified"> 100 get_last_resort_font_desc (void)</span>
 101 {
 102   // TODO Handle allocation failures?
 103   CTFontDescriptorRef last_resort = CTFontDescriptorCreateWithNameAndSize (CFSTR(&quot;LastResort&quot;), 0);
 104   CFArrayRef cascade_list = CFArrayCreate (kCFAllocatorDefault,
 105                                            (const void **) &amp;last_resort,
 106                                            1,
 107                                            &amp;kCFTypeArrayCallBacks);
 108   CFRelease (last_resort);
 109   CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,
 110                                                    (const void **) &amp;kCTFontCascadeListAttribute,
 111                                                    (const void **) &amp;cascade_list,
 112                                                    1,
 113                                                    &amp;kCFTypeDictionaryKeyCallBacks,
 114                                                    &amp;kCFTypeDictionaryValueCallBacks);
 115   CFRelease (cascade_list);
 116 
 117   CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);
 118   CFRelease (attributes);
 119   return font_desc;
 120 }
</pre>
<hr />
<pre>
 194     DEBUG_MSG (CORETEXT, cg_font, &quot;Font CTFontCreateWithGraphicsFont() failed&quot;);
 195     return nullptr;
 196   }
 197 
 198   /* crbug.com/576941 and crbug.com/625902 and the investigation in the latter
 199    * bug indicate that the cascade list reconfiguration occasionally causes
 200    * crashes in CoreText on OS X 10.9, thus let&#39;s skip this step on older
 201    * operating system versions. Except for the emoji font, where _not_
 202    * reconfiguring the cascade list causes CoreText crashes. For details, see
 203    * crbug.com/549610 */
 204   // 0x00070000 stands for &quot;kCTVersionNumber10_10&quot;, see CoreText.h
 205   if (&amp;CTGetCoreTextVersion != nullptr &amp;&amp; CTGetCoreTextVersion() &lt; 0x00070000) {
 206     CFStringRef fontName = CTFontCopyPostScriptName (ct_font);
 207     bool isEmojiFont = CFStringCompare (fontName, CFSTR(&quot;AppleColorEmoji&quot;), 0) == kCFCompareEqualTo;
 208     CFRelease (fontName);
 209     if (!isEmojiFont)
 210       return ct_font;
 211   }
 212 
 213   CFURLRef original_url = nullptr;
<span class="line-modified"> 214 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 215   ATSFontRef atsFont;
 216   FSRef fsref;
 217   OSStatus status;
 218   atsFont = CTFontGetPlatformFont (ct_font, NULL);
 219   status = ATSFontGetFileReference (atsFont, &amp;fsref);
 220   if (status == noErr)
 221     original_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 222 #else
 223   original_url = (CFURLRef) CTFontCopyAttribute (ct_font, kCTFontURLAttribute);
 224 #endif
 225 
 226   /* Create font copy with cascade list that has LastResort first; this speeds up CoreText
 227    * font fallback which we don&#39;t need anyway. */
 228   {
 229     CTFontDescriptorRef last_resort_font_desc = get_last_resort_font_desc ();
 230     CTFontRef new_ct_font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, last_resort_font_desc);
 231     CFRelease (last_resort_font_desc);
 232     if (new_ct_font)
 233     {
 234       /* The CTFontCreateCopyWithAttributes call fails to stay on the same font
 235        * when reconfiguring the cascade list and may switch to a different font
 236        * when there are fonts that go by the same name, since the descriptor is
 237        * just name and size.
 238        *
 239        * Avoid reconfiguring the cascade lists if the new font is outside the
 240        * system locations that we cannot access from the sandboxed renderer
 241        * process in Blink. This can be detected by the new file URL location
 242        * that the newly found font points to. */
 243       CFURLRef new_url = nullptr;
<span class="line-modified"> 244 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 245       atsFont = CTFontGetPlatformFont (new_ct_font, NULL);
 246       status = ATSFontGetFileReference (atsFont, &amp;fsref);
 247       if (status == noErr)
 248         new_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 249 #else
 250       new_url = (CFURLRef) CTFontCopyAttribute (new_ct_font, kCTFontURLAttribute);
 251 #endif
 252       // Keep reconfigured font if URL cannot be retrieved (seems to be the case
 253       // on Mac OS 10.12 Sierra), speculative fix for crbug.com/625606
 254       if (!original_url || !new_url || CFEqual (original_url, new_url)) {
 255         CFRelease (ct_font);
 256         ct_font = new_ct_font;
 257       } else {
 258         CFRelease (new_ct_font);
 259         DEBUG_MSG (CORETEXT, ct_font, &quot;Discarding reconfigured CTFont, location changed.&quot;);
 260       }
 261       if (new_url)
 262         CFRelease (new_url);
 263     }
 264     else
 265       DEBUG_MSG (CORETEXT, ct_font, &quot;Font copy with empty cascade list failed&quot;);
 266   }
 267 
 268   if (original_url)
 269     CFRelease (original_url);
 270   return ct_font;
 271 }
 272 
<span class="line-modified"> 273 hb_coretext_shaper_face_data_t *</span>
 274 _hb_coretext_shaper_face_data_create (hb_face_t *face)
 275 {
 276   CGFontRef cg_font = create_cg_font (face);
 277 
 278   if (unlikely (!cg_font))
 279   {
 280     DEBUG_MSG (CORETEXT, face, &quot;CGFont creation failed..&quot;);
 281     return nullptr;
 282   }
 283 
<span class="line-modified"> 284   return (hb_coretext_shaper_face_data_t *) cg_font;</span>
 285 }
 286 
 287 void
<span class="line-modified"> 288 _hb_coretext_shaper_face_data_destroy (hb_coretext_shaper_face_data_t *data)</span>
 289 {
 290   CFRelease ((CGFontRef) data);
 291 }
 292 
 293 hb_face_t *
 294 hb_coretext_face_create (CGFontRef cg_font)
 295 {
 296   return hb_face_create_for_tables (reference_table, CGFontRetain (cg_font), _hb_cg_font_release);
 297 }
 298 
 299 /*
 300  * Since: 0.9.10
 301  */
 302 CGFontRef
 303 hb_coretext_face_get_cg_font (hb_face_t *face)
 304 {
<span class="line-modified"> 305   if (unlikely (!hb_coretext_shaper_face_data_ensure (face))) return nullptr;</span>
<span class="line-removed"> 306   return (CGFontRef) HB_SHAPER_DATA_GET (face);</span>
 307 }
 308 
 309 
<span class="line-modified"> 310 hb_coretext_shaper_font_data_t *</span>
 311 _hb_coretext_shaper_font_data_create (hb_font_t *font)
 312 {
 313   hb_face_t *face = font-&gt;face;
<span class="line-modified"> 314   if (unlikely (!hb_coretext_shaper_face_data_ensure (face))) return nullptr;</span>
<span class="line-modified"> 315   CGFontRef cg_font = (CGFontRef) HB_SHAPER_DATA_GET (face);</span>

 316 
 317   CTFontRef ct_font = create_ct_font (cg_font, coretext_font_size_from_ptem (font-&gt;ptem));
 318 
 319   if (unlikely (!ct_font))
 320   {
 321     DEBUG_MSG (CORETEXT, font, &quot;CGFont creation failed..&quot;);
 322     return nullptr;
 323   }
 324 
<span class="line-modified"> 325   return (hb_coretext_shaper_font_data_t *) ct_font;</span>
 326 }
 327 
 328 void
<span class="line-modified"> 329 _hb_coretext_shaper_font_data_destroy (hb_coretext_shaper_font_data_t *data)</span>
 330 {
 331   CFRelease ((CTFontRef) data);
 332 }
 333 
































 334 /*
 335  * Since: 1.7.2
 336  */
 337 hb_font_t *
 338 hb_coretext_font_create (CTFontRef ct_font)
 339 {
 340   CGFontRef cg_font = CTFontCopyGraphicsFont (ct_font, nullptr);
 341   hb_face_t *face = hb_coretext_face_create (cg_font);
 342   CFRelease (cg_font);
 343   hb_font_t *font = hb_font_create (face);
 344   hb_face_destroy (face);
 345 
<span class="line-modified"> 346   if (unlikely (hb_object_is_inert (font)))</span>
 347     return font;
 348 
 349   hb_font_set_ptem (font, coretext_font_size_to_ptem (CTFontGetSize(ct_font)));
 350 
 351   /* Let there be dragons here... */
<span class="line-modified"> 352   HB_SHAPER_DATA_GET (font) = (hb_coretext_shaper_font_data_t *) CFRetain (ct_font);</span>
 353 
 354   return font;
 355 }
 356 
 357 CTFontRef
 358 hb_coretext_font_get_ct_font (hb_font_t *font)
 359 {
<span class="line-modified"> 360   if (unlikely (!hb_coretext_shaper_font_data_ensure (font))) return nullptr;</span>
<span class="line-modified"> 361   return (CTFontRef) HB_SHAPER_DATA_GET (font);</span>
<span class="line-removed"> 362 }</span>
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366 /*</span>
<span class="line-removed"> 367  * shaper shape_plan data</span>
<span class="line-removed"> 368  */</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370 struct hb_coretext_shaper_shape_plan_data_t {};</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372 hb_coretext_shaper_shape_plan_data_t *</span>
<span class="line-removed"> 373 _hb_coretext_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan HB_UNUSED,</span>
<span class="line-removed"> 374                                              const hb_feature_t *user_features HB_UNUSED,</span>
<span class="line-removed"> 375                                              unsigned int        num_user_features HB_UNUSED,</span>
<span class="line-removed"> 376                                              const int          *coords HB_UNUSED,</span>
<span class="line-removed"> 377                                              unsigned int        num_coords HB_UNUSED)</span>
<span class="line-removed"> 378 {</span>
<span class="line-removed"> 379   return (hb_coretext_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
<span class="line-removed"> 380 }</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382 void</span>
<span class="line-removed"> 383 _hb_coretext_shaper_shape_plan_data_destroy (hb_coretext_shaper_shape_plan_data_t *data HB_UNUSED)</span>
<span class="line-removed"> 384 {</span>
 385 }
 386 
 387 
 388 /*
 389  * shaper
 390  */
 391 
 392 struct feature_record_t {
 393   unsigned int feature;
 394   unsigned int setting;
 395 };
 396 
 397 struct active_feature_t {
 398   feature_record_t rec;
 399   unsigned int order;
 400 
 401   static int cmp (const void *pa, const void *pb) {
 402     const active_feature_t *a = (const active_feature_t *) pa;
 403     const active_feature_t *b = (const active_feature_t *) pb;
 404     return a-&gt;rec.feature &lt; b-&gt;rec.feature ? -1 : a-&gt;rec.feature &gt; b-&gt;rec.feature ? 1 :
</pre>
<hr />
<pre>
 415   unsigned int index;
 416   bool start;
 417   active_feature_t feature;
 418 
 419   static int cmp (const void *pa, const void *pb) {
 420     const feature_event_t *a = (const feature_event_t *) pa;
 421     const feature_event_t *b = (const feature_event_t *) pb;
 422     return a-&gt;index &lt; b-&gt;index ? -1 : a-&gt;index &gt; b-&gt;index ? 1 :
 423            a-&gt;start &lt; b-&gt;start ? -1 : a-&gt;start &gt; b-&gt;start ? 1 :
 424            active_feature_t::cmp (&amp;a-&gt;feature, &amp;b-&gt;feature);
 425   }
 426 };
 427 
 428 struct range_record_t {
 429   CTFontRef font;
 430   unsigned int index_first; /* == start */
 431   unsigned int index_last;  /* == end - 1 */
 432 };
 433 
 434 
<span class="line-removed"> 435 /* The following enum members are added in OS X 10.8. */</span>
<span class="line-removed"> 436 #define kAltHalfWidthTextSelector               6</span>
<span class="line-removed"> 437 #define kAltProportionalTextSelector            5</span>
<span class="line-removed"> 438 #define kAlternateHorizKanaOffSelector          1</span>
<span class="line-removed"> 439 #define kAlternateHorizKanaOnSelector           0</span>
<span class="line-removed"> 440 #define kAlternateKanaType                      34</span>
<span class="line-removed"> 441 #define kAlternateVertKanaOffSelector           3</span>
<span class="line-removed"> 442 #define kAlternateVertKanaOnSelector            2</span>
<span class="line-removed"> 443 #define kCaseSensitiveLayoutOffSelector         1</span>
<span class="line-removed"> 444 #define kCaseSensitiveLayoutOnSelector          0</span>
<span class="line-removed"> 445 #define kCaseSensitiveLayoutType                33</span>
<span class="line-removed"> 446 #define kCaseSensitiveSpacingOffSelector        3</span>
<span class="line-removed"> 447 #define kCaseSensitiveSpacingOnSelector         2</span>
<span class="line-removed"> 448 #define kContextualAlternatesOffSelector        1</span>
<span class="line-removed"> 449 #define kContextualAlternatesOnSelector         0</span>
<span class="line-removed"> 450 #define kContextualAlternatesType               36</span>
<span class="line-removed"> 451 #define kContextualLigaturesOffSelector         19</span>
<span class="line-removed"> 452 #define kContextualLigaturesOnSelector          18</span>
<span class="line-removed"> 453 #define kContextualSwashAlternatesOffSelector   5</span>
<span class="line-removed"> 454 #define kContextualSwashAlternatesOnSelector    4</span>
<span class="line-removed"> 455 #define kDefaultLowerCaseSelector               0</span>
<span class="line-removed"> 456 #define kDefaultUpperCaseSelector               0</span>
<span class="line-removed"> 457 #define kHistoricalLigaturesOffSelector         21</span>
<span class="line-removed"> 458 #define kHistoricalLigaturesOnSelector          20</span>
<span class="line-removed"> 459 #define kHojoCharactersSelector                 12</span>
<span class="line-removed"> 460 #define kJIS2004CharactersSelector              11</span>
<span class="line-removed"> 461 #define kLowerCasePetiteCapsSelector            2</span>
<span class="line-removed"> 462 #define kLowerCaseSmallCapsSelector             1</span>
<span class="line-removed"> 463 #define kLowerCaseType                          37</span>
<span class="line-removed"> 464 #define kMathematicalGreekOffSelector           11</span>
<span class="line-removed"> 465 #define kMathematicalGreekOnSelector            10</span>
<span class="line-removed"> 466 #define kNLCCharactersSelector                  13</span>
<span class="line-removed"> 467 #define kQuarterWidthTextSelector               4</span>
<span class="line-removed"> 468 #define kScientificInferiorsSelector            4</span>
<span class="line-removed"> 469 #define kStylisticAltEightOffSelector           17</span>
<span class="line-removed"> 470 #define kStylisticAltEightOnSelector            16</span>
<span class="line-removed"> 471 #define kStylisticAltEighteenOffSelector        37</span>
<span class="line-removed"> 472 #define kStylisticAltEighteenOnSelector         36</span>
<span class="line-removed"> 473 #define kStylisticAltElevenOffSelector          23</span>
<span class="line-removed"> 474 #define kStylisticAltElevenOnSelector           22</span>
<span class="line-removed"> 475 #define kStylisticAltFifteenOffSelector         31</span>
<span class="line-removed"> 476 #define kStylisticAltFifteenOnSelector          30</span>
<span class="line-removed"> 477 #define kStylisticAltFiveOffSelector            11</span>
<span class="line-removed"> 478 #define kStylisticAltFiveOnSelector             10</span>
<span class="line-removed"> 479 #define kStylisticAltFourOffSelector            9</span>
<span class="line-removed"> 480 #define kStylisticAltFourOnSelector             8</span>
<span class="line-removed"> 481 #define kStylisticAltFourteenOffSelector        29</span>
<span class="line-removed"> 482 #define kStylisticAltFourteenOnSelector         28</span>
<span class="line-removed"> 483 #define kStylisticAltNineOffSelector            19</span>
<span class="line-removed"> 484 #define kStylisticAltNineOnSelector             18</span>
<span class="line-removed"> 485 #define kStylisticAltNineteenOffSelector        39</span>
<span class="line-removed"> 486 #define kStylisticAltNineteenOnSelector         38</span>
<span class="line-removed"> 487 #define kStylisticAltOneOffSelector             3</span>
<span class="line-removed"> 488 #define kStylisticAltOneOnSelector              2</span>
<span class="line-removed"> 489 #define kStylisticAltSevenOffSelector           15</span>
<span class="line-removed"> 490 #define kStylisticAltSevenOnSelector            14</span>
<span class="line-removed"> 491 #define kStylisticAltSeventeenOffSelector       35</span>
<span class="line-removed"> 492 #define kStylisticAltSeventeenOnSelector        34</span>
<span class="line-removed"> 493 #define kStylisticAltSixOffSelector             13</span>
<span class="line-removed"> 494 #define kStylisticAltSixOnSelector              12</span>
<span class="line-removed"> 495 #define kStylisticAltSixteenOffSelector         33</span>
<span class="line-removed"> 496 #define kStylisticAltSixteenOnSelector          32</span>
<span class="line-removed"> 497 #define kStylisticAltTenOffSelector             21</span>
<span class="line-removed"> 498 #define kStylisticAltTenOnSelector              20</span>
<span class="line-removed"> 499 #define kStylisticAltThirteenOffSelector        27</span>
<span class="line-removed"> 500 #define kStylisticAltThirteenOnSelector         26</span>
<span class="line-removed"> 501 #define kStylisticAltThreeOffSelector           7</span>
<span class="line-removed"> 502 #define kStylisticAltThreeOnSelector            6</span>
<span class="line-removed"> 503 #define kStylisticAltTwelveOffSelector          25</span>
<span class="line-removed"> 504 #define kStylisticAltTwelveOnSelector           24</span>
<span class="line-removed"> 505 #define kStylisticAltTwentyOffSelector          41</span>
<span class="line-removed"> 506 #define kStylisticAltTwentyOnSelector           40</span>
<span class="line-removed"> 507 #define kStylisticAltTwoOffSelector             5</span>
<span class="line-removed"> 508 #define kStylisticAltTwoOnSelector              4</span>
<span class="line-removed"> 509 #define kStylisticAlternativesType              35</span>
<span class="line-removed"> 510 #define kSwashAlternatesOffSelector             3</span>
<span class="line-removed"> 511 #define kSwashAlternatesOnSelector              2</span>
<span class="line-removed"> 512 #define kThirdWidthTextSelector                 3</span>
<span class="line-removed"> 513 #define kTraditionalNamesCharactersSelector     14</span>
<span class="line-removed"> 514 #define kUpperCasePetiteCapsSelector            2</span>
<span class="line-removed"> 515 #define kUpperCaseSmallCapsSelector             1</span>
<span class="line-removed"> 516 #define kUpperCaseType                          38</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518 /* Table data courtesy of Apple. */</span>
<span class="line-removed"> 519 static const struct feature_mapping_t {</span>
<span class="line-removed"> 520     FourCharCode otFeatureTag;</span>
<span class="line-removed"> 521     uint16_t aatFeatureType;</span>
<span class="line-removed"> 522     uint16_t selectorToEnable;</span>
<span class="line-removed"> 523     uint16_t selectorToDisable;</span>
<span class="line-removed"> 524 } feature_mappings[] = {</span>
<span class="line-removed"> 525     { &#39;c2pc&#39;,   kUpperCaseType,             kUpperCasePetiteCapsSelector,           kDefaultUpperCaseSelector },</span>
<span class="line-removed"> 526     { &#39;c2sc&#39;,   kUpperCaseType,             kUpperCaseSmallCapsSelector,            kDefaultUpperCaseSelector },</span>
<span class="line-removed"> 527     { &#39;calt&#39;,   kContextualAlternatesType,  kContextualAlternatesOnSelector,        kContextualAlternatesOffSelector },</span>
<span class="line-removed"> 528     { &#39;case&#39;,   kCaseSensitiveLayoutType,   kCaseSensitiveLayoutOnSelector,         kCaseSensitiveLayoutOffSelector },</span>
<span class="line-removed"> 529     { &#39;clig&#39;,   kLigaturesType,             kContextualLigaturesOnSelector,         kContextualLigaturesOffSelector },</span>
<span class="line-removed"> 530     { &#39;cpsp&#39;,   kCaseSensitiveLayoutType,   kCaseSensitiveSpacingOnSelector,        kCaseSensitiveSpacingOffSelector },</span>
<span class="line-removed"> 531     { &#39;cswh&#39;,   kContextualAlternatesType,  kContextualSwashAlternatesOnSelector,   kContextualSwashAlternatesOffSelector },</span>
<span class="line-removed"> 532     { &#39;dlig&#39;,   kLigaturesType,             kRareLigaturesOnSelector,               kRareLigaturesOffSelector },</span>
<span class="line-removed"> 533     { &#39;expt&#39;,   kCharacterShapeType,        kExpertCharactersSelector,              16 },</span>
<span class="line-removed"> 534     { &#39;frac&#39;,   kFractionsType,             kDiagonalFractionsSelector,             kNoFractionsSelector },</span>
<span class="line-removed"> 535     { &#39;fwid&#39;,   kTextSpacingType,           kMonospacedTextSelector,                7 },</span>
<span class="line-removed"> 536     { &#39;halt&#39;,   kTextSpacingType,           kAltHalfWidthTextSelector,              7 },</span>
<span class="line-removed"> 537     { &#39;hist&#39;,   kLigaturesType,             kHistoricalLigaturesOnSelector,         kHistoricalLigaturesOffSelector },</span>
<span class="line-removed"> 538     { &#39;hkna&#39;,   kAlternateKanaType,         kAlternateHorizKanaOnSelector,          kAlternateHorizKanaOffSelector, },</span>
<span class="line-removed"> 539     { &#39;hlig&#39;,   kLigaturesType,             kHistoricalLigaturesOnSelector,         kHistoricalLigaturesOffSelector },</span>
<span class="line-removed"> 540     { &#39;hngl&#39;,   kTransliterationType,       kHanjaToHangulSelector,                 kNoTransliterationSelector },</span>
<span class="line-removed"> 541     { &#39;hojo&#39;,   kCharacterShapeType,        kHojoCharactersSelector,                16 },</span>
<span class="line-removed"> 542     { &#39;hwid&#39;,   kTextSpacingType,           kHalfWidthTextSelector,                 7 },</span>
<span class="line-removed"> 543     { &#39;ital&#39;,   kItalicCJKRomanType,        kCJKItalicRomanOnSelector,              kCJKItalicRomanOffSelector },</span>
<span class="line-removed"> 544     { &#39;jp04&#39;,   kCharacterShapeType,        kJIS2004CharactersSelector,             16 },</span>
<span class="line-removed"> 545     { &#39;jp78&#39;,   kCharacterShapeType,        kJIS1978CharactersSelector,             16 },</span>
<span class="line-removed"> 546     { &#39;jp83&#39;,   kCharacterShapeType,        kJIS1983CharactersSelector,             16 },</span>
<span class="line-removed"> 547     { &#39;jp90&#39;,   kCharacterShapeType,        kJIS1990CharactersSelector,             16 },</span>
<span class="line-removed"> 548     { &#39;liga&#39;,   kLigaturesType,             kCommonLigaturesOnSelector,             kCommonLigaturesOffSelector },</span>
<span class="line-removed"> 549     { &#39;lnum&#39;,   kNumberCaseType,            kUpperCaseNumbersSelector,              2 },</span>
<span class="line-removed"> 550     { &#39;mgrk&#39;,   kMathematicalExtrasType,    kMathematicalGreekOnSelector,           kMathematicalGreekOffSelector },</span>
<span class="line-removed"> 551     { &#39;nlck&#39;,   kCharacterShapeType,        kNLCCharactersSelector,                 16 },</span>
<span class="line-removed"> 552     { &#39;onum&#39;,   kNumberCaseType,            kLowerCaseNumbersSelector,              2 },</span>
<span class="line-removed"> 553     { &#39;ordn&#39;,   kVerticalPositionType,      kOrdinalsSelector,                      kNormalPositionSelector },</span>
<span class="line-removed"> 554     { &#39;palt&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 555     { &#39;pcap&#39;,   kLowerCaseType,             kLowerCasePetiteCapsSelector,           kDefaultLowerCaseSelector },</span>
<span class="line-removed"> 556     { &#39;pkna&#39;,   kTextSpacingType,           kProportionalTextSelector,              7 },</span>
<span class="line-removed"> 557     { &#39;pnum&#39;,   kNumberSpacingType,         kProportionalNumbersSelector,           4 },</span>
<span class="line-removed"> 558     { &#39;pwid&#39;,   kTextSpacingType,           kProportionalTextSelector,              7 },</span>
<span class="line-removed"> 559     { &#39;qwid&#39;,   kTextSpacingType,           kQuarterWidthTextSelector,              7 },</span>
<span class="line-removed"> 560     { &#39;ruby&#39;,   kRubyKanaType,              kRubyKanaOnSelector,                    kRubyKanaOffSelector },</span>
<span class="line-removed"> 561     { &#39;sinf&#39;,   kVerticalPositionType,      kScientificInferiorsSelector,           kNormalPositionSelector },</span>
<span class="line-removed"> 562     { &#39;smcp&#39;,   kLowerCaseType,             kLowerCaseSmallCapsSelector,            kDefaultLowerCaseSelector },</span>
<span class="line-removed"> 563     { &#39;smpl&#39;,   kCharacterShapeType,        kSimplifiedCharactersSelector,          16 },</span>
<span class="line-removed"> 564     { &#39;ss01&#39;,   kStylisticAlternativesType, kStylisticAltOneOnSelector,             kStylisticAltOneOffSelector },</span>
<span class="line-removed"> 565     { &#39;ss02&#39;,   kStylisticAlternativesType, kStylisticAltTwoOnSelector,             kStylisticAltTwoOffSelector },</span>
<span class="line-removed"> 566     { &#39;ss03&#39;,   kStylisticAlternativesType, kStylisticAltThreeOnSelector,           kStylisticAltThreeOffSelector },</span>
<span class="line-removed"> 567     { &#39;ss04&#39;,   kStylisticAlternativesType, kStylisticAltFourOnSelector,            kStylisticAltFourOffSelector },</span>
<span class="line-removed"> 568     { &#39;ss05&#39;,   kStylisticAlternativesType, kStylisticAltFiveOnSelector,            kStylisticAltFiveOffSelector },</span>
<span class="line-removed"> 569     { &#39;ss06&#39;,   kStylisticAlternativesType, kStylisticAltSixOnSelector,             kStylisticAltSixOffSelector },</span>
<span class="line-removed"> 570     { &#39;ss07&#39;,   kStylisticAlternativesType, kStylisticAltSevenOnSelector,           kStylisticAltSevenOffSelector },</span>
<span class="line-removed"> 571     { &#39;ss08&#39;,   kStylisticAlternativesType, kStylisticAltEightOnSelector,           kStylisticAltEightOffSelector },</span>
<span class="line-removed"> 572     { &#39;ss09&#39;,   kStylisticAlternativesType, kStylisticAltNineOnSelector,            kStylisticAltNineOffSelector },</span>
<span class="line-removed"> 573     { &#39;ss10&#39;,   kStylisticAlternativesType, kStylisticAltTenOnSelector,             kStylisticAltTenOffSelector },</span>
<span class="line-removed"> 574     { &#39;ss11&#39;,   kStylisticAlternativesType, kStylisticAltElevenOnSelector,          kStylisticAltElevenOffSelector },</span>
<span class="line-removed"> 575     { &#39;ss12&#39;,   kStylisticAlternativesType, kStylisticAltTwelveOnSelector,          kStylisticAltTwelveOffSelector },</span>
<span class="line-removed"> 576     { &#39;ss13&#39;,   kStylisticAlternativesType, kStylisticAltThirteenOnSelector,        kStylisticAltThirteenOffSelector },</span>
<span class="line-removed"> 577     { &#39;ss14&#39;,   kStylisticAlternativesType, kStylisticAltFourteenOnSelector,        kStylisticAltFourteenOffSelector },</span>
<span class="line-removed"> 578     { &#39;ss15&#39;,   kStylisticAlternativesType, kStylisticAltFifteenOnSelector,         kStylisticAltFifteenOffSelector },</span>
<span class="line-removed"> 579     { &#39;ss16&#39;,   kStylisticAlternativesType, kStylisticAltSixteenOnSelector,         kStylisticAltSixteenOffSelector },</span>
<span class="line-removed"> 580     { &#39;ss17&#39;,   kStylisticAlternativesType, kStylisticAltSeventeenOnSelector,       kStylisticAltSeventeenOffSelector },</span>
<span class="line-removed"> 581     { &#39;ss18&#39;,   kStylisticAlternativesType, kStylisticAltEighteenOnSelector,        kStylisticAltEighteenOffSelector },</span>
<span class="line-removed"> 582     { &#39;ss19&#39;,   kStylisticAlternativesType, kStylisticAltNineteenOnSelector,        kStylisticAltNineteenOffSelector },</span>
<span class="line-removed"> 583     { &#39;ss20&#39;,   kStylisticAlternativesType, kStylisticAltTwentyOnSelector,          kStylisticAltTwentyOffSelector },</span>
<span class="line-removed"> 584     { &#39;subs&#39;,   kVerticalPositionType,      kInferiorsSelector,                     kNormalPositionSelector },</span>
<span class="line-removed"> 585     { &#39;sups&#39;,   kVerticalPositionType,      kSuperiorsSelector,                     kNormalPositionSelector },</span>
<span class="line-removed"> 586     { &#39;swsh&#39;,   kContextualAlternatesType,  kSwashAlternatesOnSelector,             kSwashAlternatesOffSelector },</span>
<span class="line-removed"> 587     { &#39;titl&#39;,   kStyleOptionsType,          kTitlingCapsSelector,                   kNoStyleOptionsSelector },</span>
<span class="line-removed"> 588     { &#39;tnam&#39;,   kCharacterShapeType,        kTraditionalNamesCharactersSelector,    16 },</span>
<span class="line-removed"> 589     { &#39;tnum&#39;,   kNumberSpacingType,         kMonospacedNumbersSelector,             4 },</span>
<span class="line-removed"> 590     { &#39;trad&#39;,   kCharacterShapeType,        kTraditionalCharactersSelector,         16 },</span>
<span class="line-removed"> 591     { &#39;twid&#39;,   kTextSpacingType,           kThirdWidthTextSelector,                7 },</span>
<span class="line-removed"> 592     { &#39;unic&#39;,   kLetterCaseType,            14,                                     15 },</span>
<span class="line-removed"> 593     { &#39;valt&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 594     { &#39;vert&#39;,   kVerticalSubstitutionType,  kSubstituteVerticalFormsOnSelector,     kSubstituteVerticalFormsOffSelector },</span>
<span class="line-removed"> 595     { &#39;vhal&#39;,   kTextSpacingType,           kAltHalfWidthTextSelector,              7 },</span>
<span class="line-removed"> 596     { &#39;vkna&#39;,   kAlternateKanaType,         kAlternateVertKanaOnSelector,           kAlternateVertKanaOffSelector },</span>
<span class="line-removed"> 597     { &#39;vpal&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 598     { &#39;vrt2&#39;,   kVerticalSubstitutionType,  kSubstituteVerticalFormsOnSelector,     kSubstituteVerticalFormsOffSelector },</span>
<span class="line-removed"> 599     { &#39;zero&#39;,   kTypographicExtrasType,     kSlashedZeroOnSelector,                 kSlashedZeroOffSelector },</span>
<span class="line-removed"> 600 };</span>
<span class="line-removed"> 601 </span>
<span class="line-removed"> 602 static int</span>
<span class="line-removed"> 603 _hb_feature_mapping_cmp (const void *key_, const void *entry_)</span>
<span class="line-removed"> 604 {</span>
<span class="line-removed"> 605   unsigned int key = * (unsigned int *) key_;</span>
<span class="line-removed"> 606   const feature_mapping_t * entry = (const feature_mapping_t *) entry_;</span>
<span class="line-removed"> 607   return key &lt; entry-&gt;otFeatureTag ? -1 :</span>
<span class="line-removed"> 608          key &gt; entry-&gt;otFeatureTag ? 1 :</span>
<span class="line-removed"> 609          0;</span>
<span class="line-removed"> 610 }</span>
<span class="line-removed"> 611 </span>
 612 hb_bool_t
 613 _hb_coretext_shape (hb_shape_plan_t    *shape_plan,
 614                     hb_font_t          *font,
 615                     hb_buffer_t        *buffer,
 616                     const hb_feature_t *features,
 617                     unsigned int        num_features)
 618 {
 619   hb_face_t *face = font-&gt;face;
<span class="line-modified"> 620   CGFontRef cg_font = (CGFontRef) HB_SHAPER_DATA_GET (face);</span>
<span class="line-modified"> 621   CTFontRef ct_font = (CTFontRef) HB_SHAPER_DATA_GET (font);</span>
 622 
 623   CGFloat ct_font_size = CTFontGetSize (ct_font);
 624   CGFloat x_mult = (CGFloat) font-&gt;x_scale / ct_font_size;
 625   CGFloat y_mult = (CGFloat) font-&gt;y_scale / ct_font_size;
 626 
 627   /* Attach marks to their bases, to match the &#39;ot&#39; shaper.
<span class="line-modified"> 628    * Adapted from hb-ot-shape:hb_form_clusters().</span>
 629    * Note that this only makes us be closer to the &#39;ot&#39; shaper,
 630    * but by no means the same.  For example, if there&#39;s
 631    * B1 M1 B2 M2, and B1-B2 form a ligature, M2&#39;s cluster will
 632    * continue pointing to B2 even though B2 was merged into B1&#39;s
 633    * cluster... */
 634   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
 635   {
 636     hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 637     unsigned int count = buffer-&gt;len;
 638     hb_glyph_info_t *info = buffer-&gt;info;
 639     for (unsigned int i = 1; i &lt; count; i++)
 640       if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (unicode-&gt;general_category (info[i].codepoint)))
 641         buffer-&gt;merge_clusters (i - 1, i + 1);
 642   }
 643 
<span class="line-modified"> 644   hb_auto_t&lt;hb_vector_t&lt;feature_record_t&gt; &gt; feature_records;</span>
<span class="line-modified"> 645   hb_auto_t&lt;hb_vector_t&lt;range_record_t&gt; &gt; range_records;</span>
 646 
 647   /*
 648    * Set up features.
 649    * (copied + modified from code from hb-uniscribe.cc)
 650    */
 651   if (num_features)
 652   {
 653     /* Sort features by start/end events. */
<span class="line-modified"> 654     hb_auto_t&lt;hb_vector_t&lt;feature_event_t&gt; &gt; feature_events;</span>
 655     for (unsigned int i = 0; i &lt; num_features; i++)
 656     {
<span class="line-modified"> 657       const feature_mapping_t * mapping = (const feature_mapping_t *) bsearch (&amp;features[i].tag,</span>
<span class="line-removed"> 658                                                                                feature_mappings,</span>
<span class="line-removed"> 659                                                                                ARRAY_LENGTH (feature_mappings),</span>
<span class="line-removed"> 660                                                                                sizeof (feature_mappings[0]),</span>
<span class="line-removed"> 661                                                                                _hb_feature_mapping_cmp);</span>
 662       if (!mapping)
 663         continue;
 664 
 665       active_feature_t feature;
 666       feature.rec.feature = mapping-&gt;aatFeatureType;
 667       feature.rec.setting = features[i].value ? mapping-&gt;selectorToEnable : mapping-&gt;selectorToDisable;
 668       feature.order = i;
 669 
 670       feature_event_t *event;
 671 
 672       event = feature_events.push ();
 673       event-&gt;index = features[i].start;
 674       event-&gt;start = true;
 675       event-&gt;feature = feature;
 676 
 677       event = feature_events.push ();
 678       event-&gt;index = features[i].end;
 679       event-&gt;start = false;
 680       event-&gt;feature = feature;
 681     }
 682     feature_events.qsort ();
 683     /* Add a strategic final event. */
 684     {
 685       active_feature_t feature;
 686       feature.rec.feature = HB_TAG_NONE;
 687       feature.rec.setting = 0;
 688       feature.order = num_features + 1;
 689 
 690       feature_event_t *event = feature_events.push ();
 691       event-&gt;index = 0; /* This value does magic. */
 692       event-&gt;start = false;
 693       event-&gt;feature = feature;
 694     }
 695 
 696     /* Scan events and save features for each range. */
<span class="line-modified"> 697     hb_auto_t&lt;hb_vector_t&lt;active_feature_t&gt; &gt; active_features;</span>
 698     unsigned int last_index = 0;
<span class="line-modified"> 699     for (unsigned int i = 0; i &lt; feature_events.len; i++)</span>
 700     {
 701       feature_event_t *event = &amp;feature_events[i];
 702 
 703       if (event-&gt;index != last_index)
 704       {
 705         /* Save a snapshot of active features and the range. */
 706         range_record_t *range = range_records.push ();
 707 
<span class="line-modified"> 708         if (active_features.len)</span>
 709         {
 710           CFMutableArrayRef features_array = CFArrayCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeArrayCallBacks);
 711 
 712           /* TODO sort and resolve conflicting features? */
 713           /* active_features.qsort (); */
<span class="line-modified"> 714           for (unsigned int j = 0; j &lt; active_features.len; j++)</span>
 715           {
 716             CFStringRef keys[] = {
 717               kCTFontFeatureTypeIdentifierKey,
 718               kCTFontFeatureSelectorIdentifierKey
 719             };
 720             CFNumberRef values[] = {
 721               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.feature),
 722               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.setting)
 723             };
 724             static_assert ((ARRAY_LENGTH_CONST (keys) == ARRAY_LENGTH_CONST (values)), &quot;&quot;);
 725             CFDictionaryRef dict = CFDictionaryCreate (kCFAllocatorDefault,
 726                                                        (const void **) keys,
 727                                                        (const void **) values,
 728                                                        ARRAY_LENGTH (keys),
 729                                                        &amp;kCFTypeDictionaryKeyCallBacks,
 730                                                        &amp;kCFTypeDictionaryValueCallBacks);
 731             for (unsigned int i = 0; i &lt; ARRAY_LENGTH (values); i++)
 732               CFRelease (values[i]);
 733 
 734             CFArrayAppendValue (features_array, dict);
</pre>
<hr />
<pre>
 750           range-&gt;font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, font_desc);
 751           CFRelease (font_desc);
 752         }
 753         else
 754         {
 755           range-&gt;font = nullptr;
 756         }
 757 
 758         range-&gt;index_first = last_index;
 759         range-&gt;index_last  = event-&gt;index - 1;
 760 
 761         last_index = event-&gt;index;
 762       }
 763 
 764       if (event-&gt;start)
 765       {
 766         active_features.push (event-&gt;feature);
 767       } else {
 768         active_feature_t *feature = active_features.find (&amp;event-&gt;feature);
 769         if (feature)
<span class="line-modified"> 770           active_features.remove (feature - active_features.arrayZ);</span>
 771       }
 772     }
 773   }
 774 
 775   unsigned int scratch_size;
 776   hb_buffer_t::scratch_buffer_t *scratch = buffer-&gt;get_scratch_buffer (&amp;scratch_size);
 777 
 778 #define ALLOCATE_ARRAY(Type, name, len, on_no_room) \
 779   Type *name = (Type *) scratch; \
 780   { \
 781     unsigned int _consumed = DIV_CEIL ((len) * sizeof (Type), sizeof (*scratch)); \
 782     if (unlikely (_consumed &gt; scratch_size)) \
 783     { \
 784       on_no_room; \
 785       assert (0); \
 786     } \
 787     scratch += _consumed; \
 788     scratch_size -= _consumed; \
 789   }
 790 
</pre>
<hr />
<pre>
 807   for (unsigned int i = 0; i &lt; buffer-&gt;len; i++)
 808   {
 809     hb_codepoint_t c = buffer-&gt;info[i].codepoint;
 810     unsigned int cluster = buffer-&gt;info[i].cluster;
 811     log_clusters[chars_len++] = cluster;
 812     if (hb_in_range (c, 0x10000u, 0x10FFFFu))
 813       log_clusters[chars_len++] = cluster; /* Surrogates. */
 814   }
 815 
 816 #define FAIL(...) \
 817   HB_STMT_START { \
 818     DEBUG_MSG (CORETEXT, nullptr, __VA_ARGS__); \
 819     ret = false; \
 820     goto fail; \
 821   } HB_STMT_END;
 822 
 823   bool ret = true;
 824   CFStringRef string_ref = nullptr;
 825   CTLineRef line = nullptr;
 826 
<span class="line-modified"> 827   if (0)</span>
 828   {
 829 resize_and_retry:
 830     DEBUG_MSG (CORETEXT, buffer, &quot;Buffer resize&quot;);
 831     /* string_ref uses the scratch-buffer for backing store, and line references
 832      * string_ref (via attr_string).  We must release those before resizing buffer. */
 833     assert (string_ref);
 834     assert (line);
 835     CFRelease (string_ref);
 836     CFRelease (line);
 837     string_ref = nullptr;
 838     line = nullptr;
 839 
 840     /* Get previous start-of-scratch-area, that we use later for readjusting
 841      * our existing scratch arrays. */
 842     unsigned int old_scratch_used;
 843     hb_buffer_t::scratch_buffer_t *old_scratch;
 844     old_scratch = buffer-&gt;get_scratch_buffer (&amp;old_scratch_used);
 845     old_scratch_used = scratch - old_scratch;
 846 
 847     if (unlikely (!buffer-&gt;ensure (buffer-&gt;allocated * 2)))
</pre>
<hr />
<pre>
 882  * At any rate, our fallback is safe and works fine. */
 883 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1090
 884 #  define kCTLanguageAttributeName CFSTR (&quot;NSLanguage&quot;)
 885 #endif
 886         CFStringRef lang = CFStringCreateWithCStringNoCopy (kCFAllocatorDefault,
 887                                                             hb_language_to_string (buffer-&gt;props.language),
 888                                                             kCFStringEncodingUTF8,
 889                                                             kCFAllocatorNull);
 890         if (unlikely (!lang))
 891         {
 892           CFRelease (attr_string);
 893           FAIL (&quot;CFStringCreateWithCStringNoCopy failed&quot;);
 894         }
 895         CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 896                                         kCTLanguageAttributeName, lang);
 897         CFRelease (lang);
 898       }
 899       CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 900                                       kCTFontAttributeName, ct_font);
 901 
<span class="line-modified"> 902       if (num_features &amp;&amp; range_records.len)</span>
 903       {
 904         unsigned int start = 0;
 905         range_record_t *last_range = &amp;range_records[0];
 906         for (unsigned int k = 0; k &lt; chars_len; k++)
 907         {
 908           range_record_t *range = last_range;
 909           while (log_clusters[k] &lt; range-&gt;index_first)
 910             range--;
 911           while (log_clusters[k] &gt; range-&gt;index_last)
 912             range++;
 913           if (range != last_range)
 914           {
 915             if (last_range-&gt;font)
 916               CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, k - start),
 917                                               kCTFontAttributeName, last_range-&gt;font);
 918 
 919             start = k;
 920           }
 921 
 922           last_range = range;
</pre>
<hr />
<pre>
1031          *
1032          * First, see if it uses any of our subfonts created to set font features...
1033          *
1034          * Next, compare the CGFont to the one we used to create our fonts.
1035          * Even this doesn&#39;t work all the time.
1036          *
1037          * Finally, we compare PS names, which I don&#39;t think are unique...
1038          *
1039          * Looks like if we really want to be sure here we have to modify the
1040          * font to change the name table, similar to what we do in the uniscribe
1041          * backend.
1042          *
1043          * However, even that wouldn&#39;t work if we were passed in the CGFont to
1044          * construct a hb_face to begin with.
1045          *
1046          * See: https://github.com/harfbuzz/harfbuzz/pull/36
1047          *
1048          * Also see: https://bugs.chromium.org/p/chromium/issues/detail?id=597098
1049          */
1050         bool matched = false;
<span class="line-modified">1051         for (unsigned int i = 0; i &lt; range_records.len; i++)</span>
1052           if (range_records[i].font &amp;&amp; CFEqual (run_ct_font, range_records[i].font))
1053           {
1054             matched = true;
1055             break;
1056           }
1057         if (!matched)
1058         {
1059           CGFontRef run_cg_font = CTFontCopyGraphicsFont (run_ct_font, nullptr);
1060           if (run_cg_font)
1061           {
1062             matched = CFEqual (run_cg_font, cg_font);
1063             CFRelease (run_cg_font);
1064           }
1065         }
1066         if (!matched)
1067         {
1068           CFStringRef font_ps_name = CTFontCopyName (ct_font, kCTFontPostScriptNameKey);
1069           CFStringRef run_ps_name = CTFontCopyName (run_ct_font, kCTFontPostScriptNameKey);
1070           CFComparisonResult result = CFStringCompare (run_ps_name, font_ps_name, 0);
1071           CFRelease (run_ps_name);
</pre>
<hr />
<pre>
1218           }
1219         }
1220         SCRATCH_RESTORE();
1221         advances_so_far += run_advance;
1222       }
1223 #undef SCRATCH_RESTORE
1224 #undef SCRATCH_SAVE
1225 #undef USE_PTR
1226 #undef ALLOCATE_ARRAY
1227 
1228       buffer-&gt;len += num_glyphs;
1229     }
1230 
1231     /* Mac OS 10.6 doesn&#39;t have kCTTypesetterOptionForcedEmbeddingLevel,
1232      * or if it does, it doesn&#39;t respect it.  So we get runs with wrong
1233      * directions.  As such, disable the assert...  It wouldn&#39;t crash, but
1234      * cursoring will be off...
1235      *
1236      * https://crbug.com/419769
1237      */
<span class="line-modified">1238     if (0)</span>
1239     {
1240       /* Make sure all runs had the expected direction. */
1241       bool backward = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);
1242       assert (bool (status_and &amp; kCTRunStatusRightToLeft) == backward);
1243       assert (bool (status_or  &amp; kCTRunStatusRightToLeft) == backward);
1244     }
1245 
1246     buffer-&gt;clear_positions ();
1247 
1248     unsigned int count = buffer-&gt;len;
1249     hb_glyph_info_t *info = buffer-&gt;info;
1250     hb_glyph_position_t *pos = buffer-&gt;pos;
1251     if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))
1252       for (unsigned int i = 0; i &lt; count; i++)
1253       {
1254         pos-&gt;x_advance = info-&gt;mask;
1255         pos-&gt;x_offset = info-&gt;var1.i32;
1256         pos-&gt;y_offset = info-&gt;var2.i32;
1257 
1258         info++, pos++;
</pre>
<hr />
<pre>
1294         unsigned int cluster = info[0].cluster;
1295         for (unsigned int i = 1; i &lt; count; i++)
1296         {
1297           cluster = MIN (cluster, info[i].cluster);
1298           info[i].cluster = cluster;
1299         }
1300       }
1301     }
1302   }
1303 
1304   buffer-&gt;unsafe_to_break_all ();
1305 
1306 #undef FAIL
1307 
1308 fail:
1309   if (string_ref)
1310     CFRelease (string_ref);
1311   if (line)
1312     CFRelease (line);
1313 
<span class="line-modified">1314   for (unsigned int i = 0; i &lt; range_records.len; i++)</span>
1315     if (range_records[i].font)
1316       CFRelease (range_records[i].font);
1317 
1318   return ret;
1319 }
1320 
1321 
1322 /*
1323  * AAT shaper
1324  */
1325 
<span class="line-removed">1326 HB_SHAPER_DATA_ENSURE_DEFINE(coretext_aat, face)</span>
<span class="line-removed">1327 HB_SHAPER_DATA_ENSURE_DEFINE(coretext_aat, font)</span>
<span class="line-removed">1328 </span>
1329 /*
1330  * shaper face data
1331  */
1332 
<span class="line-modified">1333 struct hb_coretext_aat_shaper_face_data_t {};</span>
1334 
<span class="line-modified">1335 hb_coretext_aat_shaper_face_data_t *</span>
1336 _hb_coretext_aat_shaper_face_data_create (hb_face_t *face)
1337 {
<span class="line-modified">1338   static const hb_tag_t tags[] = {HB_CORETEXT_TAG_MORX, HB_CORETEXT_TAG_MORT, HB_CORETEXT_TAG_KERX};</span>
<span class="line-modified">1339 </span>
<span class="line-removed">1340   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (tags); i++)</span>
<span class="line-removed">1341   {</span>
<span class="line-removed">1342     hb_blob_t *blob = face-&gt;reference_table (tags[i]);</span>
<span class="line-removed">1343     if (hb_blob_get_length (blob))</span>
<span class="line-removed">1344     {</span>
<span class="line-removed">1345       hb_blob_destroy (blob);</span>
<span class="line-removed">1346       return hb_coretext_shaper_face_data_ensure (face) ? (hb_coretext_aat_shaper_face_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>
<span class="line-removed">1347     }</span>
<span class="line-removed">1348     hb_blob_destroy (blob);</span>
<span class="line-removed">1349   }</span>
<span class="line-removed">1350 </span>
<span class="line-removed">1351   return nullptr;</span>
1352 }
1353 
1354 void
<span class="line-modified">1355 _hb_coretext_aat_shaper_face_data_destroy (hb_coretext_aat_shaper_face_data_t *data HB_UNUSED)</span>
1356 {
1357 }
1358 
1359 
1360 /*
1361  * shaper font data
1362  */
1363 
<span class="line-modified">1364 struct hb_coretext_aat_shaper_font_data_t {};</span>
1365 
<span class="line-modified">1366 hb_coretext_aat_shaper_font_data_t *</span>
1367 _hb_coretext_aat_shaper_font_data_create (hb_font_t *font)
1368 {
<span class="line-modified">1369   return hb_coretext_shaper_font_data_ensure (font) ? (hb_coretext_aat_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>
<span class="line-removed">1370 }</span>
<span class="line-removed">1371 </span>
<span class="line-removed">1372 void</span>
<span class="line-removed">1373 _hb_coretext_aat_shaper_font_data_destroy (hb_coretext_aat_shaper_font_data_t *data HB_UNUSED)</span>
<span class="line-removed">1374 {</span>
<span class="line-removed">1375 }</span>
<span class="line-removed">1376 </span>
<span class="line-removed">1377 </span>
<span class="line-removed">1378 /*</span>
<span class="line-removed">1379  * shaper shape_plan data</span>
<span class="line-removed">1380  */</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382 struct hb_coretext_aat_shaper_shape_plan_data_t {};</span>
<span class="line-removed">1383 </span>
<span class="line-removed">1384 hb_coretext_aat_shaper_shape_plan_data_t *</span>
<span class="line-removed">1385 _hb_coretext_aat_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan HB_UNUSED,</span>
<span class="line-removed">1386                                              const hb_feature_t *user_features HB_UNUSED,</span>
<span class="line-removed">1387                                              unsigned int        num_user_features HB_UNUSED,</span>
<span class="line-removed">1388                                              const int          *coords HB_UNUSED,</span>
<span class="line-removed">1389                                              unsigned int        num_coords HB_UNUSED)</span>
<span class="line-removed">1390 {</span>
<span class="line-removed">1391   return (hb_coretext_aat_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
1392 }
1393 
1394 void
<span class="line-modified">1395 _hb_coretext_aat_shaper_shape_plan_data_destroy (hb_coretext_aat_shaper_shape_plan_data_t *data HB_UNUSED)</span>
1396 {
1397 }
1398 
1399 
1400 /*
1401  * shaper
1402  */
1403 
1404 hb_bool_t
1405 _hb_coretext_aat_shape (hb_shape_plan_t    *shape_plan,
1406                         hb_font_t          *font,
1407                         hb_buffer_t        *buffer,
1408                         const hb_feature_t *features,
1409                         unsigned int        num_features)
1410 {
1411   return _hb_coretext_shape (shape_plan, font, buffer, features, num_features);
1412 }
</pre>
</td>
<td>
<hr />
<pre>
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Mozilla Author(s): Jonathan Kew
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<span class="line-modified">  29 #include &quot;hb.hh&quot;</span>
<span class="line-modified">  30 #include &quot;hb-shaper-impl.hh&quot;</span>



  31 
  32 #include &quot;hb-coretext.h&quot;
<span class="line-added">  33 #include &quot;hb-aat-layout.hh&quot;</span>
  34 #include &lt;math.h&gt;
  35 
<span class="line-added">  36 </span>
<span class="line-added">  37 /**</span>
<span class="line-added">  38  * SECTION:hb-coretext</span>
<span class="line-added">  39  * @title: hb-coretext</span>
<span class="line-added">  40  * @short_description: CoreText integration</span>
<span class="line-added">  41  * @include: hb-coretext.h</span>
<span class="line-added">  42  *</span>
<span class="line-added">  43  * Functions for using HarfBuzz with the CoreText fonts.</span>
<span class="line-added">  44  **/</span>
<span class="line-added">  45 </span>
  46 /* https://developer.apple.com/documentation/coretext/1508745-ctfontcreatewithgraphicsfont */
  47 #define HB_CORETEXT_DEFAULT_FONT_SIZE 12.f
  48 
  49 static CGFloat
  50 coretext_font_size_from_ptem (float ptem)
  51 {
  52   /* CoreText points are CSS pixels (96 per inch),
  53    * NOT typographic points (72 per inch).
  54    *
  55    * https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html
  56    */
  57   ptem *= 96.f / 72.f;
  58   return ptem &lt;= 0.f ? HB_CORETEXT_DEFAULT_FONT_SIZE : ptem;
  59 }
  60 static float
  61 coretext_font_size_to_ptem (CGFloat size)
  62 {
  63   size *= 72.f / 96.f;
  64   return size &lt;= 0.f ? 0 : size;
  65 }
</pre>
<hr />
<pre>
  82   const char *data = reinterpret_cast&lt;const char*&gt; (CFDataGetBytePtr (cf_data));
  83   const size_t length = CFDataGetLength (cf_data);
  84   if (!data || !length)
  85   {
  86     CFRelease (cf_data);
  87     return nullptr;
  88   }
  89 
  90   return hb_blob_create (data, length, HB_MEMORY_MODE_READONLY,
  91                          reinterpret_cast&lt;void *&gt; (const_cast&lt;__CFData *&gt; (cf_data)),
  92                          release_table_data);
  93 }
  94 
  95 static void
  96 _hb_cg_font_release (void *data)
  97 {
  98   CGFontRelease ((CGFontRef) data);
  99 }
 100 
 101 





 102 static CTFontDescriptorRef
<span class="line-modified"> 103 get_last_resort_font_desc ()</span>
 104 {
 105   // TODO Handle allocation failures?
 106   CTFontDescriptorRef last_resort = CTFontDescriptorCreateWithNameAndSize (CFSTR(&quot;LastResort&quot;), 0);
 107   CFArrayRef cascade_list = CFArrayCreate (kCFAllocatorDefault,
 108                                            (const void **) &amp;last_resort,
 109                                            1,
 110                                            &amp;kCFTypeArrayCallBacks);
 111   CFRelease (last_resort);
 112   CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,
 113                                                    (const void **) &amp;kCTFontCascadeListAttribute,
 114                                                    (const void **) &amp;cascade_list,
 115                                                    1,
 116                                                    &amp;kCFTypeDictionaryKeyCallBacks,
 117                                                    &amp;kCFTypeDictionaryValueCallBacks);
 118   CFRelease (cascade_list);
 119 
 120   CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);
 121   CFRelease (attributes);
 122   return font_desc;
 123 }
</pre>
<hr />
<pre>
 197     DEBUG_MSG (CORETEXT, cg_font, &quot;Font CTFontCreateWithGraphicsFont() failed&quot;);
 198     return nullptr;
 199   }
 200 
 201   /* crbug.com/576941 and crbug.com/625902 and the investigation in the latter
 202    * bug indicate that the cascade list reconfiguration occasionally causes
 203    * crashes in CoreText on OS X 10.9, thus let&#39;s skip this step on older
 204    * operating system versions. Except for the emoji font, where _not_
 205    * reconfiguring the cascade list causes CoreText crashes. For details, see
 206    * crbug.com/549610 */
 207   // 0x00070000 stands for &quot;kCTVersionNumber10_10&quot;, see CoreText.h
 208   if (&amp;CTGetCoreTextVersion != nullptr &amp;&amp; CTGetCoreTextVersion() &lt; 0x00070000) {
 209     CFStringRef fontName = CTFontCopyPostScriptName (ct_font);
 210     bool isEmojiFont = CFStringCompare (fontName, CFSTR(&quot;AppleColorEmoji&quot;), 0) == kCFCompareEqualTo;
 211     CFRelease (fontName);
 212     if (!isEmojiFont)
 213       return ct_font;
 214   }
 215 
 216   CFURLRef original_url = nullptr;
<span class="line-modified"> 217 #if TARGET_OS_OSX &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 218   ATSFontRef atsFont;
 219   FSRef fsref;
 220   OSStatus status;
 221   atsFont = CTFontGetPlatformFont (ct_font, NULL);
 222   status = ATSFontGetFileReference (atsFont, &amp;fsref);
 223   if (status == noErr)
 224     original_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 225 #else
 226   original_url = (CFURLRef) CTFontCopyAttribute (ct_font, kCTFontURLAttribute);
 227 #endif
 228 
 229   /* Create font copy with cascade list that has LastResort first; this speeds up CoreText
 230    * font fallback which we don&#39;t need anyway. */
 231   {
 232     CTFontDescriptorRef last_resort_font_desc = get_last_resort_font_desc ();
 233     CTFontRef new_ct_font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, last_resort_font_desc);
 234     CFRelease (last_resort_font_desc);
 235     if (new_ct_font)
 236     {
 237       /* The CTFontCreateCopyWithAttributes call fails to stay on the same font
 238        * when reconfiguring the cascade list and may switch to a different font
 239        * when there are fonts that go by the same name, since the descriptor is
 240        * just name and size.
 241        *
 242        * Avoid reconfiguring the cascade lists if the new font is outside the
 243        * system locations that we cannot access from the sandboxed renderer
 244        * process in Blink. This can be detected by the new file URL location
 245        * that the newly found font points to. */
 246       CFURLRef new_url = nullptr;
<span class="line-modified"> 247 #if TARGET_OS_OSX &amp;&amp; MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 248       atsFont = CTFontGetPlatformFont (new_ct_font, NULL);
 249       status = ATSFontGetFileReference (atsFont, &amp;fsref);
 250       if (status == noErr)
 251         new_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 252 #else
 253       new_url = (CFURLRef) CTFontCopyAttribute (new_ct_font, kCTFontURLAttribute);
 254 #endif
 255       // Keep reconfigured font if URL cannot be retrieved (seems to be the case
 256       // on Mac OS 10.12 Sierra), speculative fix for crbug.com/625606
 257       if (!original_url || !new_url || CFEqual (original_url, new_url)) {
 258         CFRelease (ct_font);
 259         ct_font = new_ct_font;
 260       } else {
 261         CFRelease (new_ct_font);
 262         DEBUG_MSG (CORETEXT, ct_font, &quot;Discarding reconfigured CTFont, location changed.&quot;);
 263       }
 264       if (new_url)
 265         CFRelease (new_url);
 266     }
 267     else
 268       DEBUG_MSG (CORETEXT, ct_font, &quot;Font copy with empty cascade list failed&quot;);
 269   }
 270 
 271   if (original_url)
 272     CFRelease (original_url);
 273   return ct_font;
 274 }
 275 
<span class="line-modified"> 276 hb_coretext_face_data_t *</span>
 277 _hb_coretext_shaper_face_data_create (hb_face_t *face)
 278 {
 279   CGFontRef cg_font = create_cg_font (face);
 280 
 281   if (unlikely (!cg_font))
 282   {
 283     DEBUG_MSG (CORETEXT, face, &quot;CGFont creation failed..&quot;);
 284     return nullptr;
 285   }
 286 
<span class="line-modified"> 287   return (hb_coretext_face_data_t *) cg_font;</span>
 288 }
 289 
 290 void
<span class="line-modified"> 291 _hb_coretext_shaper_face_data_destroy (hb_coretext_face_data_t *data)</span>
 292 {
 293   CFRelease ((CGFontRef) data);
 294 }
 295 
 296 hb_face_t *
 297 hb_coretext_face_create (CGFontRef cg_font)
 298 {
 299   return hb_face_create_for_tables (reference_table, CGFontRetain (cg_font), _hb_cg_font_release);
 300 }
 301 
 302 /*
 303  * Since: 0.9.10
 304  */
 305 CGFontRef
 306 hb_coretext_face_get_cg_font (hb_face_t *face)
 307 {
<span class="line-modified"> 308   return (CGFontRef) (const void *) face-&gt;data.coretext;</span>

 309 }
 310 
 311 
<span class="line-modified"> 312 hb_coretext_font_data_t *</span>
 313 _hb_coretext_shaper_font_data_create (hb_font_t *font)
 314 {
 315   hb_face_t *face = font-&gt;face;
<span class="line-modified"> 316   const hb_coretext_face_data_t *face_data = face-&gt;data.coretext;</span>
<span class="line-modified"> 317   if (unlikely (!face_data)) return nullptr;</span>
<span class="line-added"> 318   CGFontRef cg_font = (CGFontRef) (const void *) face-&gt;data.coretext;</span>
 319 
 320   CTFontRef ct_font = create_ct_font (cg_font, coretext_font_size_from_ptem (font-&gt;ptem));
 321 
 322   if (unlikely (!ct_font))
 323   {
 324     DEBUG_MSG (CORETEXT, font, &quot;CGFont creation failed..&quot;);
 325     return nullptr;
 326   }
 327 
<span class="line-modified"> 328   return (hb_coretext_font_data_t *) ct_font;</span>
 329 }
 330 
 331 void
<span class="line-modified"> 332 _hb_coretext_shaper_font_data_destroy (hb_coretext_font_data_t *data)</span>
 333 {
 334   CFRelease ((CTFontRef) data);
 335 }
 336 
<span class="line-added"> 337 static const hb_coretext_font_data_t *</span>
<span class="line-added"> 338 hb_coretext_font_data_sync (hb_font_t *font)</span>
<span class="line-added"> 339 {</span>
<span class="line-added"> 340 retry:</span>
<span class="line-added"> 341   const hb_coretext_font_data_t *data = font-&gt;data.coretext;</span>
<span class="line-added"> 342   if (unlikely (!data)) return nullptr;</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344   if (fabs (CTFontGetSize((CTFontRef) data) - coretext_font_size_from_ptem (font-&gt;ptem)) &gt; .5)</span>
<span class="line-added"> 345   {</span>
<span class="line-added"> 346     /* XXX-MT-bug</span>
<span class="line-added"> 347      * Note that evaluating condition above can be dangerous if another thread</span>
<span class="line-added"> 348      * got here first and destructed data.  That&#39;s, as always, bad use pattern.</span>
<span class="line-added"> 349      * If you modify the font (change font size), other threads must not be</span>
<span class="line-added"> 350      * using it at the same time.  However, since this check is delayed to</span>
<span class="line-added"> 351      * when one actually tries to shape something, this is a XXX race condition</span>
<span class="line-added"> 352      * (and the only one we have that I know of) right now.  Ie. you modify the</span>
<span class="line-added"> 353      * font size in one thread, then (supposedly safely) try to use it from two</span>
<span class="line-added"> 354      * or more threads and BOOM!  I&#39;m not sure how to fix this.  We want RCU.</span>
<span class="line-added"> 355      */</span>
<span class="line-added"> 356 </span>
<span class="line-added"> 357     /* Drop and recreate. */</span>
<span class="line-added"> 358     /* If someone dropped it in the mean time, throw it away and don&#39;t touch it.</span>
<span class="line-added"> 359      * Otherwise, destruct it. */</span>
<span class="line-added"> 360     if (likely (font-&gt;data.coretext.cmpexch (const_cast&lt;hb_coretext_font_data_t *&gt; (data), nullptr)))</span>
<span class="line-added"> 361       _hb_coretext_shaper_font_data_destroy (const_cast&lt;hb_coretext_font_data_t *&gt; (data));</span>
<span class="line-added"> 362     else</span>
<span class="line-added"> 363       goto retry;</span>
<span class="line-added"> 364   }</span>
<span class="line-added"> 365   return font-&gt;data.coretext;</span>
<span class="line-added"> 366 }</span>
<span class="line-added"> 367 </span>
<span class="line-added"> 368 </span>
 369 /*
 370  * Since: 1.7.2
 371  */
 372 hb_font_t *
 373 hb_coretext_font_create (CTFontRef ct_font)
 374 {
 375   CGFontRef cg_font = CTFontCopyGraphicsFont (ct_font, nullptr);
 376   hb_face_t *face = hb_coretext_face_create (cg_font);
 377   CFRelease (cg_font);
 378   hb_font_t *font = hb_font_create (face);
 379   hb_face_destroy (face);
 380 
<span class="line-modified"> 381   if (unlikely (hb_object_is_immutable (font)))</span>
 382     return font;
 383 
 384   hb_font_set_ptem (font, coretext_font_size_to_ptem (CTFontGetSize(ct_font)));
 385 
 386   /* Let there be dragons here... */
<span class="line-modified"> 387   font-&gt;data.coretext.cmpexch (nullptr, (hb_coretext_font_data_t *) CFRetain (ct_font));</span>
 388 
 389   return font;
 390 }
 391 
 392 CTFontRef
 393 hb_coretext_font_get_ct_font (hb_font_t *font)
 394 {
<span class="line-modified"> 395   const hb_coretext_font_data_t *data = hb_coretext_font_data_sync (font);</span>
<span class="line-modified"> 396   return data ? (CTFontRef) data : nullptr;</span>























 397 }
 398 
 399 
 400 /*
 401  * shaper
 402  */
 403 
 404 struct feature_record_t {
 405   unsigned int feature;
 406   unsigned int setting;
 407 };
 408 
 409 struct active_feature_t {
 410   feature_record_t rec;
 411   unsigned int order;
 412 
 413   static int cmp (const void *pa, const void *pb) {
 414     const active_feature_t *a = (const active_feature_t *) pa;
 415     const active_feature_t *b = (const active_feature_t *) pb;
 416     return a-&gt;rec.feature &lt; b-&gt;rec.feature ? -1 : a-&gt;rec.feature &gt; b-&gt;rec.feature ? 1 :
</pre>
<hr />
<pre>
 427   unsigned int index;
 428   bool start;
 429   active_feature_t feature;
 430 
 431   static int cmp (const void *pa, const void *pb) {
 432     const feature_event_t *a = (const feature_event_t *) pa;
 433     const feature_event_t *b = (const feature_event_t *) pb;
 434     return a-&gt;index &lt; b-&gt;index ? -1 : a-&gt;index &gt; b-&gt;index ? 1 :
 435            a-&gt;start &lt; b-&gt;start ? -1 : a-&gt;start &gt; b-&gt;start ? 1 :
 436            active_feature_t::cmp (&amp;a-&gt;feature, &amp;b-&gt;feature);
 437   }
 438 };
 439 
 440 struct range_record_t {
 441   CTFontRef font;
 442   unsigned int index_first; /* == start */
 443   unsigned int index_last;  /* == end - 1 */
 444 };
 445 
 446 

















































































































































































 447 hb_bool_t
 448 _hb_coretext_shape (hb_shape_plan_t    *shape_plan,
 449                     hb_font_t          *font,
 450                     hb_buffer_t        *buffer,
 451                     const hb_feature_t *features,
 452                     unsigned int        num_features)
 453 {
 454   hb_face_t *face = font-&gt;face;
<span class="line-modified"> 455   CGFontRef cg_font = (CGFontRef) (const void *) face-&gt;data.coretext;</span>
<span class="line-modified"> 456   CTFontRef ct_font = (CTFontRef) hb_coretext_font_data_sync (font);</span>
 457 
 458   CGFloat ct_font_size = CTFontGetSize (ct_font);
 459   CGFloat x_mult = (CGFloat) font-&gt;x_scale / ct_font_size;
 460   CGFloat y_mult = (CGFloat) font-&gt;y_scale / ct_font_size;
 461 
 462   /* Attach marks to their bases, to match the &#39;ot&#39; shaper.
<span class="line-modified"> 463    * Adapted from a very old version of hb-ot-shape:hb_form_clusters().</span>
 464    * Note that this only makes us be closer to the &#39;ot&#39; shaper,
 465    * but by no means the same.  For example, if there&#39;s
 466    * B1 M1 B2 M2, and B1-B2 form a ligature, M2&#39;s cluster will
 467    * continue pointing to B2 even though B2 was merged into B1&#39;s
 468    * cluster... */
 469   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
 470   {
 471     hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 472     unsigned int count = buffer-&gt;len;
 473     hb_glyph_info_t *info = buffer-&gt;info;
 474     for (unsigned int i = 1; i &lt; count; i++)
 475       if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (unicode-&gt;general_category (info[i].codepoint)))
 476         buffer-&gt;merge_clusters (i - 1, i + 1);
 477   }
 478 
<span class="line-modified"> 479   hb_vector_t&lt;feature_record_t&gt; feature_records;</span>
<span class="line-modified"> 480   hb_vector_t&lt;range_record_t&gt; range_records;</span>
 481 
 482   /*
 483    * Set up features.
 484    * (copied + modified from code from hb-uniscribe.cc)
 485    */
 486   if (num_features)
 487   {
 488     /* Sort features by start/end events. */
<span class="line-modified"> 489     hb_vector_t&lt;feature_event_t&gt; feature_events;</span>
 490     for (unsigned int i = 0; i &lt; num_features; i++)
 491     {
<span class="line-modified"> 492       const hb_aat_feature_mapping_t * mapping = hb_aat_layout_find_feature_mapping (features[i].tag);</span>




 493       if (!mapping)
 494         continue;
 495 
 496       active_feature_t feature;
 497       feature.rec.feature = mapping-&gt;aatFeatureType;
 498       feature.rec.setting = features[i].value ? mapping-&gt;selectorToEnable : mapping-&gt;selectorToDisable;
 499       feature.order = i;
 500 
 501       feature_event_t *event;
 502 
 503       event = feature_events.push ();
 504       event-&gt;index = features[i].start;
 505       event-&gt;start = true;
 506       event-&gt;feature = feature;
 507 
 508       event = feature_events.push ();
 509       event-&gt;index = features[i].end;
 510       event-&gt;start = false;
 511       event-&gt;feature = feature;
 512     }
 513     feature_events.qsort ();
 514     /* Add a strategic final event. */
 515     {
 516       active_feature_t feature;
 517       feature.rec.feature = HB_TAG_NONE;
 518       feature.rec.setting = 0;
 519       feature.order = num_features + 1;
 520 
 521       feature_event_t *event = feature_events.push ();
 522       event-&gt;index = 0; /* This value does magic. */
 523       event-&gt;start = false;
 524       event-&gt;feature = feature;
 525     }
 526 
 527     /* Scan events and save features for each range. */
<span class="line-modified"> 528     hb_vector_t&lt;active_feature_t&gt; active_features;</span>
 529     unsigned int last_index = 0;
<span class="line-modified"> 530     for (unsigned int i = 0; i &lt; feature_events.length; i++)</span>
 531     {
 532       feature_event_t *event = &amp;feature_events[i];
 533 
 534       if (event-&gt;index != last_index)
 535       {
 536         /* Save a snapshot of active features and the range. */
 537         range_record_t *range = range_records.push ();
 538 
<span class="line-modified"> 539         if (active_features.length)</span>
 540         {
 541           CFMutableArrayRef features_array = CFArrayCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeArrayCallBacks);
 542 
 543           /* TODO sort and resolve conflicting features? */
 544           /* active_features.qsort (); */
<span class="line-modified"> 545           for (unsigned int j = 0; j &lt; active_features.length; j++)</span>
 546           {
 547             CFStringRef keys[] = {
 548               kCTFontFeatureTypeIdentifierKey,
 549               kCTFontFeatureSelectorIdentifierKey
 550             };
 551             CFNumberRef values[] = {
 552               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.feature),
 553               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.setting)
 554             };
 555             static_assert ((ARRAY_LENGTH_CONST (keys) == ARRAY_LENGTH_CONST (values)), &quot;&quot;);
 556             CFDictionaryRef dict = CFDictionaryCreate (kCFAllocatorDefault,
 557                                                        (const void **) keys,
 558                                                        (const void **) values,
 559                                                        ARRAY_LENGTH (keys),
 560                                                        &amp;kCFTypeDictionaryKeyCallBacks,
 561                                                        &amp;kCFTypeDictionaryValueCallBacks);
 562             for (unsigned int i = 0; i &lt; ARRAY_LENGTH (values); i++)
 563               CFRelease (values[i]);
 564 
 565             CFArrayAppendValue (features_array, dict);
</pre>
<hr />
<pre>
 581           range-&gt;font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, font_desc);
 582           CFRelease (font_desc);
 583         }
 584         else
 585         {
 586           range-&gt;font = nullptr;
 587         }
 588 
 589         range-&gt;index_first = last_index;
 590         range-&gt;index_last  = event-&gt;index - 1;
 591 
 592         last_index = event-&gt;index;
 593       }
 594 
 595       if (event-&gt;start)
 596       {
 597         active_features.push (event-&gt;feature);
 598       } else {
 599         active_feature_t *feature = active_features.find (&amp;event-&gt;feature);
 600         if (feature)
<span class="line-modified"> 601           active_features.remove (feature - active_features.arrayZ ());</span>
 602       }
 603     }
 604   }
 605 
 606   unsigned int scratch_size;
 607   hb_buffer_t::scratch_buffer_t *scratch = buffer-&gt;get_scratch_buffer (&amp;scratch_size);
 608 
 609 #define ALLOCATE_ARRAY(Type, name, len, on_no_room) \
 610   Type *name = (Type *) scratch; \
 611   { \
 612     unsigned int _consumed = DIV_CEIL ((len) * sizeof (Type), sizeof (*scratch)); \
 613     if (unlikely (_consumed &gt; scratch_size)) \
 614     { \
 615       on_no_room; \
 616       assert (0); \
 617     } \
 618     scratch += _consumed; \
 619     scratch_size -= _consumed; \
 620   }
 621 
</pre>
<hr />
<pre>
 638   for (unsigned int i = 0; i &lt; buffer-&gt;len; i++)
 639   {
 640     hb_codepoint_t c = buffer-&gt;info[i].codepoint;
 641     unsigned int cluster = buffer-&gt;info[i].cluster;
 642     log_clusters[chars_len++] = cluster;
 643     if (hb_in_range (c, 0x10000u, 0x10FFFFu))
 644       log_clusters[chars_len++] = cluster; /* Surrogates. */
 645   }
 646 
 647 #define FAIL(...) \
 648   HB_STMT_START { \
 649     DEBUG_MSG (CORETEXT, nullptr, __VA_ARGS__); \
 650     ret = false; \
 651     goto fail; \
 652   } HB_STMT_END;
 653 
 654   bool ret = true;
 655   CFStringRef string_ref = nullptr;
 656   CTLineRef line = nullptr;
 657 
<span class="line-modified"> 658   if (false)</span>
 659   {
 660 resize_and_retry:
 661     DEBUG_MSG (CORETEXT, buffer, &quot;Buffer resize&quot;);
 662     /* string_ref uses the scratch-buffer for backing store, and line references
 663      * string_ref (via attr_string).  We must release those before resizing buffer. */
 664     assert (string_ref);
 665     assert (line);
 666     CFRelease (string_ref);
 667     CFRelease (line);
 668     string_ref = nullptr;
 669     line = nullptr;
 670 
 671     /* Get previous start-of-scratch-area, that we use later for readjusting
 672      * our existing scratch arrays. */
 673     unsigned int old_scratch_used;
 674     hb_buffer_t::scratch_buffer_t *old_scratch;
 675     old_scratch = buffer-&gt;get_scratch_buffer (&amp;old_scratch_used);
 676     old_scratch_used = scratch - old_scratch;
 677 
 678     if (unlikely (!buffer-&gt;ensure (buffer-&gt;allocated * 2)))
</pre>
<hr />
<pre>
 713  * At any rate, our fallback is safe and works fine. */
 714 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1090
 715 #  define kCTLanguageAttributeName CFSTR (&quot;NSLanguage&quot;)
 716 #endif
 717         CFStringRef lang = CFStringCreateWithCStringNoCopy (kCFAllocatorDefault,
 718                                                             hb_language_to_string (buffer-&gt;props.language),
 719                                                             kCFStringEncodingUTF8,
 720                                                             kCFAllocatorNull);
 721         if (unlikely (!lang))
 722         {
 723           CFRelease (attr_string);
 724           FAIL (&quot;CFStringCreateWithCStringNoCopy failed&quot;);
 725         }
 726         CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 727                                         kCTLanguageAttributeName, lang);
 728         CFRelease (lang);
 729       }
 730       CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 731                                       kCTFontAttributeName, ct_font);
 732 
<span class="line-modified"> 733       if (num_features &amp;&amp; range_records.length)</span>
 734       {
 735         unsigned int start = 0;
 736         range_record_t *last_range = &amp;range_records[0];
 737         for (unsigned int k = 0; k &lt; chars_len; k++)
 738         {
 739           range_record_t *range = last_range;
 740           while (log_clusters[k] &lt; range-&gt;index_first)
 741             range--;
 742           while (log_clusters[k] &gt; range-&gt;index_last)
 743             range++;
 744           if (range != last_range)
 745           {
 746             if (last_range-&gt;font)
 747               CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, k - start),
 748                                               kCTFontAttributeName, last_range-&gt;font);
 749 
 750             start = k;
 751           }
 752 
 753           last_range = range;
</pre>
<hr />
<pre>
 862          *
 863          * First, see if it uses any of our subfonts created to set font features...
 864          *
 865          * Next, compare the CGFont to the one we used to create our fonts.
 866          * Even this doesn&#39;t work all the time.
 867          *
 868          * Finally, we compare PS names, which I don&#39;t think are unique...
 869          *
 870          * Looks like if we really want to be sure here we have to modify the
 871          * font to change the name table, similar to what we do in the uniscribe
 872          * backend.
 873          *
 874          * However, even that wouldn&#39;t work if we were passed in the CGFont to
 875          * construct a hb_face to begin with.
 876          *
 877          * See: https://github.com/harfbuzz/harfbuzz/pull/36
 878          *
 879          * Also see: https://bugs.chromium.org/p/chromium/issues/detail?id=597098
 880          */
 881         bool matched = false;
<span class="line-modified"> 882         for (unsigned int i = 0; i &lt; range_records.length; i++)</span>
 883           if (range_records[i].font &amp;&amp; CFEqual (run_ct_font, range_records[i].font))
 884           {
 885             matched = true;
 886             break;
 887           }
 888         if (!matched)
 889         {
 890           CGFontRef run_cg_font = CTFontCopyGraphicsFont (run_ct_font, nullptr);
 891           if (run_cg_font)
 892           {
 893             matched = CFEqual (run_cg_font, cg_font);
 894             CFRelease (run_cg_font);
 895           }
 896         }
 897         if (!matched)
 898         {
 899           CFStringRef font_ps_name = CTFontCopyName (ct_font, kCTFontPostScriptNameKey);
 900           CFStringRef run_ps_name = CTFontCopyName (run_ct_font, kCTFontPostScriptNameKey);
 901           CFComparisonResult result = CFStringCompare (run_ps_name, font_ps_name, 0);
 902           CFRelease (run_ps_name);
</pre>
<hr />
<pre>
1049           }
1050         }
1051         SCRATCH_RESTORE();
1052         advances_so_far += run_advance;
1053       }
1054 #undef SCRATCH_RESTORE
1055 #undef SCRATCH_SAVE
1056 #undef USE_PTR
1057 #undef ALLOCATE_ARRAY
1058 
1059       buffer-&gt;len += num_glyphs;
1060     }
1061 
1062     /* Mac OS 10.6 doesn&#39;t have kCTTypesetterOptionForcedEmbeddingLevel,
1063      * or if it does, it doesn&#39;t respect it.  So we get runs with wrong
1064      * directions.  As such, disable the assert...  It wouldn&#39;t crash, but
1065      * cursoring will be off...
1066      *
1067      * https://crbug.com/419769
1068      */
<span class="line-modified">1069     if (false)</span>
1070     {
1071       /* Make sure all runs had the expected direction. */
1072       bool backward = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);
1073       assert (bool (status_and &amp; kCTRunStatusRightToLeft) == backward);
1074       assert (bool (status_or  &amp; kCTRunStatusRightToLeft) == backward);
1075     }
1076 
1077     buffer-&gt;clear_positions ();
1078 
1079     unsigned int count = buffer-&gt;len;
1080     hb_glyph_info_t *info = buffer-&gt;info;
1081     hb_glyph_position_t *pos = buffer-&gt;pos;
1082     if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))
1083       for (unsigned int i = 0; i &lt; count; i++)
1084       {
1085         pos-&gt;x_advance = info-&gt;mask;
1086         pos-&gt;x_offset = info-&gt;var1.i32;
1087         pos-&gt;y_offset = info-&gt;var2.i32;
1088 
1089         info++, pos++;
</pre>
<hr />
<pre>
1125         unsigned int cluster = info[0].cluster;
1126         for (unsigned int i = 1; i &lt; count; i++)
1127         {
1128           cluster = MIN (cluster, info[i].cluster);
1129           info[i].cluster = cluster;
1130         }
1131       }
1132     }
1133   }
1134 
1135   buffer-&gt;unsafe_to_break_all ();
1136 
1137 #undef FAIL
1138 
1139 fail:
1140   if (string_ref)
1141     CFRelease (string_ref);
1142   if (line)
1143     CFRelease (line);
1144 
<span class="line-modified">1145   for (unsigned int i = 0; i &lt; range_records.length; i++)</span>
1146     if (range_records[i].font)
1147       CFRelease (range_records[i].font);
1148 
1149   return ret;
1150 }
1151 
1152 
1153 /*
1154  * AAT shaper
1155  */
1156 



1157 /*
1158  * shaper face data
1159  */
1160 
<span class="line-modified">1161 struct hb_coretext_aat_face_data_t {};</span>
1162 
<span class="line-modified">1163 hb_coretext_aat_face_data_t *</span>
1164 _hb_coretext_aat_shaper_face_data_create (hb_face_t *face)
1165 {
<span class="line-modified">1166   return hb_aat_layout_has_substitution (face) || hb_aat_layout_has_positioning (face) ?</span>
<span class="line-modified">1167          (hb_coretext_aat_face_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>












1168 }
1169 
1170 void
<span class="line-modified">1171 _hb_coretext_aat_shaper_face_data_destroy (hb_coretext_aat_face_data_t *data HB_UNUSED)</span>
1172 {
1173 }
1174 
1175 
1176 /*
1177  * shaper font data
1178  */
1179 
<span class="line-modified">1180 struct hb_coretext_aat_font_data_t {};</span>
1181 
<span class="line-modified">1182 hb_coretext_aat_font_data_t *</span>
1183 _hb_coretext_aat_shaper_font_data_create (hb_font_t *font)
1184 {
<span class="line-modified">1185   return font-&gt;data.coretext ? (hb_coretext_aat_font_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>






















1186 }
1187 
1188 void
<span class="line-modified">1189 _hb_coretext_aat_shaper_font_data_destroy (hb_coretext_aat_font_data_t *data HB_UNUSED)</span>
1190 {
1191 }
1192 
1193 
1194 /*
1195  * shaper
1196  */
1197 
1198 hb_bool_t
1199 _hb_coretext_aat_shape (hb_shape_plan_t    *shape_plan,
1200                         hb_font_t          *font,
1201                         hb_buffer_t        *buffer,
1202                         const hb_feature_t *features,
1203                         unsigned int        num_features)
1204 {
1205   return _hb_coretext_shape (shape_plan, font, buffer, features, num_features);
1206 }
</pre>
</td>
</tr>
</table>
<center><a href="hb-common.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-debug.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright Â© 2014  Google, Inc.
   3  *
   4  *  This is part of HarfBuzz, a text shaping library.
   5  *
   6  * Permission is hereby granted, without written agreement and without
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #ifndef HB_OT_CMAP_TABLE_HH
  28 #define HB_OT_CMAP_TABLE_HH
  29 
<a name="1" id="anc1"></a><span class="line-modified">  30 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-set.hh&quot;</span>

  32 
  33 /*
  34  * cmap -- Character to Glyph Index Mapping
  35  * https://docs.microsoft.com/en-us/typography/opentype/spec/cmap
  36  */
  37 #define HB_OT_TAG_cmap HB_TAG(&#39;c&#39;,&#39;m&#39;,&#39;a&#39;,&#39;p&#39;)
  38 
<a name="2" id="anc2"></a>
  39 namespace OT {
  40 
  41 
  42 struct CmapSubtableFormat0
  43 {
<a name="3" id="anc3"></a><span class="line-modified">  44   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
  45   {
  46     hb_codepoint_t gid = codepoint &lt; 256 ? glyphIdArray[codepoint] : 0;
  47     if (!gid)
  48       return false;
  49     *glyph = gid;
  50     return true;
  51   }
<a name="4" id="anc4"></a><span class="line-added">  52   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added">  53   {</span>
<span class="line-added">  54     for (unsigned int i = 0; i &lt; 256; i++)</span>
<span class="line-added">  55       if (glyphIdArray[i])</span>
<span class="line-added">  56         out-&gt;add (i);</span>
<span class="line-added">  57   }</span>
  58 
<a name="5" id="anc5"></a><span class="line-modified">  59   bool sanitize (hb_sanitize_context_t *c) const</span>
  60   {
  61     TRACE_SANITIZE (this);
  62     return_trace (c-&gt;check_struct (this));
  63   }
  64 
  65   protected:
  66   HBUINT16      format;         /* Format number is set to 0. */
  67   HBUINT16      length;         /* Byte length of this subtable. */
  68   HBUINT16      language;       /* Ignore. */
  69   HBUINT8       glyphIdArray[256];/* An array that maps character
  70                                  * code to glyph index values. */
  71   public:
  72   DEFINE_SIZE_STATIC (6 + 256);
  73 };
  74 
  75 struct CmapSubtableFormat4
  76 {
  77   struct segment_plan
  78   {
  79     HBUINT16 start_code;
  80     HBUINT16 end_code;
  81     bool use_delta;
  82   };
  83 
  84   bool serialize (hb_serialize_context_t *c,
  85                   const hb_subset_plan_t *plan,
  86                   const hb_vector_t&lt;segment_plan&gt; &amp;segments)
  87   {
  88     TRACE_SERIALIZE (this);
  89 
  90     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
  91 
  92     this-&gt;format.set (4);
  93     this-&gt;length.set (get_sub_table_size (segments));
  94 
<a name="6" id="anc6"></a><span class="line-modified">  95     this-&gt;segCountX2.set (segments.length * 2);</span>
<span class="line-modified">  96     this-&gt;entrySelector.set (MAX (1u, hb_bit_storage (segments.length)) - 1);</span>
  97     this-&gt;searchRange.set (2 * (1u &lt;&lt; this-&gt;entrySelector));
<a name="7" id="anc7"></a><span class="line-modified">  98     this-&gt;rangeShift.set (segments.length * 2 &gt; this-&gt;searchRange</span>
<span class="line-modified">  99                           ? 2 * segments.length - this-&gt;searchRange</span>
 100                           : 0);
 101 
<a name="8" id="anc8"></a><span class="line-modified"> 102     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
 103     c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size); // 2 bytes of padding.
<a name="9" id="anc9"></a><span class="line-modified"> 104     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="line-modified"> 105     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="line-modified"> 106     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
 107 
 108     if (id_range_offset == nullptr)
 109       return_trace (false);
 110 
<a name="10" id="anc10"></a><span class="line-modified"> 111     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
 112     {
 113       end_count[i].set (segments[i].end_code);
 114       start_count[i].set (segments[i].start_code);
 115       if (segments[i].use_delta)
 116       {
 117         hb_codepoint_t cp = segments[i].start_code;
 118         hb_codepoint_t start_gid = 0;
 119         if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;start_gid) &amp;&amp; cp != 0xFFFF))
 120           return_trace (false);
 121         id_delta[i].set (start_gid - segments[i].start_code);
 122       } else {
 123         id_delta[i].set (0);
 124         unsigned int num_codepoints = segments[i].end_code - segments[i].start_code + 1;
 125         HBUINT16 *glyph_id_array = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * num_codepoints);
 126         if (glyph_id_array == nullptr)
 127           return_trace (false);
 128         // From the cmap spec:
 129         //
 130         // id_range_offset[i]/2
 131         // + (cp - segments[i].start_code)
 132         // + (id_range_offset + i)
 133         // =
 134         // glyph_id_array + (cp - segments[i].start_code)
 135         //
 136         // So, solve for id_range_offset[i]:
 137         //
 138         // id_range_offset[i]
 139         // =
 140         // 2 * (glyph_id_array - id_range_offset - i)
 141         id_range_offset[i].set (2 * (
 142             glyph_id_array - id_range_offset - i));
 143         for (unsigned int j = 0; j &lt; num_codepoints; j++)
 144         {
 145           hb_codepoint_t cp = segments[i].start_code + j;
 146           hb_codepoint_t new_gid;
 147           if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 148             return_trace (false);
 149           glyph_id_array[j].set (new_gid);
 150         }
 151       }
 152     }
 153 
 154     return_trace (true);
 155   }
 156 
<a name="11" id="anc11"></a><span class="line-modified"> 157   static size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
 158   {
 159     size_t segment_size = 0;
<a name="12" id="anc12"></a><span class="line-modified"> 160     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
 161     {
 162       // Parallel array entries
 163       segment_size +=
 164             2  // end count
 165           + 2  // start count
 166           + 2  // delta
 167           + 2; // range offset
 168 
 169       if (!segments[i].use_delta)
 170         // Add bytes for the glyph index array entries for this segment.
 171         segment_size += (segments[i].end_code - segments[i].start_code + 1) * 2;
 172     }
 173 
 174     return min_size
 175         + 2 // Padding
 176         + segment_size;
 177   }
 178 
<a name="13" id="anc13"></a><span class="line-modified"> 179   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 180                                      hb_vector_t&lt;segment_plan&gt; *segments)</span>
 181   {
 182     segment_plan *segment = nullptr;
 183     hb_codepoint_t last_gid = 0;
 184 
 185     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 186     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 187       hb_codepoint_t new_gid;
 188       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 189       {
 190         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 191         return false;
 192       }
 193 
<a name="14" id="anc14"></a><span class="line-modified"> 194       /* Stop adding to cmap if we are now outside of unicode BMP. */</span>
<span class="line-modified"> 195       if (cp &gt; 0xFFFF) break;</span>


 196 
<a name="15" id="anc15"></a><span class="line-modified"> 197       if (!segment ||</span>
<span class="line-modified"> 198           cp != segment-&gt;end_code + 1u)</span>
 199       {
 200         segment = segments-&gt;push ();
 201         segment-&gt;start_code.set (cp);
 202         segment-&gt;end_code.set (cp);
 203         segment-&gt;use_delta = true;
 204       } else {
 205         segment-&gt;end_code.set (cp);
 206         if (last_gid + 1u != new_gid)
 207           // gid&#39;s are not consecutive in this segment so delta
 208           // cannot be used.
 209           segment-&gt;use_delta = false;
 210       }
 211 
 212       last_gid = new_gid;
 213     }
 214 
 215     // There must be a final entry with end_code == 0xFFFF. Check if we need to add one.
 216     if (segment == nullptr || segment-&gt;end_code != 0xFFFF)
 217     {
 218       segment = segments-&gt;push ();
 219       segment-&gt;start_code.set (0xFFFF);
 220       segment-&gt;end_code.set (0xFFFF);
 221       segment-&gt;use_delta = true;
 222     }
 223 
 224     return true;
 225   }
 226 
 227   struct accelerator_t
 228   {
<a name="16" id="anc16"></a><span class="line-modified"> 229     accelerator_t () {}</span>
<span class="line-added"> 230     accelerator_t (const CmapSubtableFormat4 *subtable) { init (subtable); }</span>
<span class="line-added"> 231     ~accelerator_t () { fini (); }</span>
<span class="line-added"> 232 </span>
<span class="line-added"> 233     void init (const CmapSubtableFormat4 *subtable)</span>
 234     {
 235       segCount = subtable-&gt;segCountX2 / 2;
<a name="17" id="anc17"></a><span class="line-modified"> 236       endCount = subtable-&gt;values.arrayZ;</span>
 237       startCount = endCount + segCount + 1;
 238       idDelta = startCount + segCount;
 239       idRangeOffset = idDelta + segCount;
 240       glyphIdArray = idRangeOffset + segCount;
 241       glyphIdArrayLength = (subtable-&gt;length - 16 - 8 * segCount) / 2;
 242     }
<a name="18" id="anc18"></a><span class="line-added"> 243     void fini () {}</span>
 244 
<a name="19" id="anc19"></a><span class="line-modified"> 245     bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 246     {
<a name="20" id="anc20"></a>

 247       /* Custom two-array bsearch. */
<a name="21" id="anc21"></a><span class="line-modified"> 248       int min = 0, max = (int) this-&gt;segCount - 1;</span>
<span class="line-modified"> 249       const HBUINT16 *startCount = this-&gt;startCount;</span>
<span class="line-modified"> 250       const HBUINT16 *endCount = this-&gt;endCount;</span>
 251       unsigned int i;
 252       while (min &lt;= max)
 253       {
<a name="22" id="anc22"></a><span class="line-modified"> 254         int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
 255         if (codepoint &lt; startCount[mid])
 256           max = mid - 1;
 257         else if (codepoint &gt; endCount[mid])
 258           min = mid + 1;
 259         else
 260         {
 261           i = mid;
 262           goto found;
 263         }
 264       }
 265       return false;
 266 
 267     found:
 268       hb_codepoint_t gid;
<a name="23" id="anc23"></a><span class="line-modified"> 269       unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
 270       if (rangeOffset == 0)
<a name="24" id="anc24"></a><span class="line-modified"> 271         gid = codepoint + this-&gt;idDelta[i];</span>
 272       else
 273       {
 274         /* Somebody has been smoking... */
<a name="25" id="anc25"></a><span class="line-modified"> 275         unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="line-modified"> 276         if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
 277           return false;
<a name="26" id="anc26"></a><span class="line-modified"> 278         gid = this-&gt;glyphIdArray[index];</span>
 279         if (unlikely (!gid))
 280           return false;
<a name="27" id="anc27"></a><span class="line-modified"> 281         gid += this-&gt;idDelta[i];</span>
 282       }
<a name="28" id="anc28"></a><span class="line-modified"> 283       gid &amp;= 0xFFFFu;</span>
<span class="line-modified"> 284       if (!gid)</span>
<span class="line-added"> 285         return false;</span>
<span class="line-added"> 286       *glyph = gid;</span>
 287       return true;
 288     }
<a name="29" id="anc29"></a><span class="line-modified"> 289     static bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
<span class="line-modified"> 290     {</span>
<span class="line-added"> 291       return ((const accelerator_t *) obj)-&gt;get_glyph (codepoint, glyph);</span>
<span class="line-added"> 292     }</span>
<span class="line-added"> 293     void collect_unicodes (hb_set_t *out) const</span>
 294     {
<a name="30" id="anc30"></a><span class="line-modified"> 295       unsigned int count = this-&gt;segCount;</span>
<span class="line-modified"> 296       if (count &amp;&amp; this-&gt;startCount[count - 1] == 0xFFFFu)</span>
<span class="line-added"> 297         count--; /* Skip sentinel segment. */</span>
<span class="line-added"> 298       for (unsigned int i = 0; i &lt; count; i++)</span>
 299       {
<a name="31" id="anc31"></a><span class="line-modified"> 300         unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
<span class="line-modified"> 301         if (rangeOffset == 0)</span>
<span class="line-modified"> 302           out-&gt;add_range (this-&gt;startCount[i], this-&gt;endCount[i]);</span>
<span class="line-added"> 303         else</span>
<span class="line-added"> 304         {</span>
<span class="line-added"> 305           for (hb_codepoint_t codepoint = this-&gt;startCount[i];</span>
<span class="line-added"> 306                codepoint &lt;= this-&gt;endCount[i];</span>
<span class="line-added"> 307                codepoint++)</span>
<span class="line-added"> 308           {</span>
<span class="line-added"> 309             unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="line-added"> 310             if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
<span class="line-added"> 311               break;</span>
<span class="line-added"> 312             hb_codepoint_t gid = this-&gt;glyphIdArray[index];</span>
<span class="line-added"> 313             if (unlikely (!gid))</span>
<span class="line-added"> 314               continue;</span>
<span class="line-added"> 315             out-&gt;add (codepoint);</span>
<span class="line-added"> 316           }</span>
<span class="line-added"> 317         }</span>
 318       }
 319     }
 320 
 321     const HBUINT16 *endCount;
 322     const HBUINT16 *startCount;
 323     const HBUINT16 *idDelta;
 324     const HBUINT16 *idRangeOffset;
 325     const HBUINT16 *glyphIdArray;
 326     unsigned int segCount;
 327     unsigned int glyphIdArrayLength;
 328   };
 329 
<a name="32" id="anc32"></a><span class="line-modified"> 330   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 331   {
<a name="33" id="anc33"></a><span class="line-modified"> 332     accelerator_t accel (this);</span>

 333     return accel.get_glyph_func (&amp;accel, codepoint, glyph);
 334   }
<a name="34" id="anc34"></a><span class="line-added"> 335   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 336   {</span>
<span class="line-added"> 337     accelerator_t accel (this);</span>
<span class="line-added"> 338     accel.collect_unicodes (out);</span>
<span class="line-added"> 339   }</span>
 340 
<a name="35" id="anc35"></a><span class="line-modified"> 341   bool sanitize (hb_sanitize_context_t *c) const</span>
 342   {
 343     TRACE_SANITIZE (this);
 344     if (unlikely (!c-&gt;check_struct (this)))
 345       return_trace (false);
 346 
 347     if (unlikely (!c-&gt;check_range (this, length)))
 348     {
 349       /* Some broken fonts have too long of a &quot;length&quot; value.
 350        * If that is the case, just change the value to truncate
 351        * the subtable at the end of the blob. */
 352       uint16_t new_length = (uint16_t) MIN ((uintptr_t) 65535,
 353                                             (uintptr_t) (c-&gt;end -
 354                                                          (char *) this));
 355       if (!c-&gt;try_set (&amp;length, new_length))
 356         return_trace (false);
 357     }
 358 
 359     return_trace (16 + 4 * (unsigned int) segCountX2 &lt;= length);
 360   }
 361 
 362 
 363 
 364   protected:
 365   HBUINT16      format;         /* Format number is set to 4. */
 366   HBUINT16      length;         /* This is the length in bytes of the
 367                                  * subtable. */
 368   HBUINT16      language;       /* Ignore. */
 369   HBUINT16      segCountX2;     /* 2 x segCount. */
 370   HBUINT16      searchRange;    /* 2 * (2**floor(log2(segCount))) */
 371   HBUINT16      entrySelector;  /* log2(searchRange/2) */
 372   HBUINT16      rangeShift;     /* 2 x segCount - searchRange */
 373 
<a name="36" id="anc36"></a><span class="line-modified"> 374   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="line-added"> 375                 values;</span>
 376 #if 0
 377   HBUINT16      endCount[segCount];     /* End characterCode for each segment,
 378                                          * last=0xFFFFu. */
 379   HBUINT16      reservedPad;            /* Set to 0. */
 380   HBUINT16      startCount[segCount];   /* Start character code for each segment. */
 381   HBINT16               idDelta[segCount];      /* Delta for all character codes in segment. */
 382   HBUINT16      idRangeOffset[segCount];/* Offsets into glyphIdArray or 0 */
<a name="37" id="anc37"></a><span class="line-modified"> 383   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="line-added"> 384                 glyphIdArray;   /* Glyph index array (arbitrary length) */</span>
 385 #endif
 386 
 387   public:
 388   DEFINE_SIZE_ARRAY (14, values);
 389 };
 390 
 391 struct CmapSubtableLongGroup
 392 {
 393   friend struct CmapSubtableFormat12;
 394   friend struct CmapSubtableFormat13;
 395   template&lt;typename U&gt;
 396   friend struct CmapSubtableLongSegmented;
 397   friend struct cmap;
 398 
 399   int cmp (hb_codepoint_t codepoint) const
 400   {
 401     if (codepoint &lt; startCharCode) return -1;
 402     if (codepoint &gt; endCharCode)   return +1;
 403     return 0;
 404   }
 405 
<a name="38" id="anc38"></a><span class="line-modified"> 406   bool sanitize (hb_sanitize_context_t *c) const</span>
 407   {
 408     TRACE_SANITIZE (this);
 409     return_trace (c-&gt;check_struct (this));
 410   }
 411 
 412   private:
 413   HBUINT32              startCharCode;  /* First character code in this group. */
 414   HBUINT32              endCharCode;    /* Last character code in this group. */
 415   HBUINT32              glyphID;        /* Glyph index; interpretation depends on
<a name="39" id="anc39"></a><span class="line-modified"> 416                                          * subtable format. */</span>
 417   public:
 418   DEFINE_SIZE_STATIC (12);
 419 };
<a name="40" id="anc40"></a><span class="line-added"> 420 DECLARE_NULL_NAMESPACE_BYTES (OT, CmapSubtableLongGroup);</span>
 421 
 422 template &lt;typename UINT&gt;
 423 struct CmapSubtableTrimmed
 424 {
<a name="41" id="anc41"></a><span class="line-modified"> 425   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 426   {
 427     /* Rely on our implicit array bound-checking. */
 428     hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];
 429     if (!gid)
 430       return false;
 431     *glyph = gid;
 432     return true;
 433   }
<a name="42" id="anc42"></a><span class="line-added"> 434   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 435   {</span>
<span class="line-added"> 436     hb_codepoint_t start = startCharCode;</span>
<span class="line-added"> 437     unsigned int count = glyphIdArray.len;</span>
<span class="line-added"> 438     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 439       if (glyphIdArray[i])</span>
<span class="line-added"> 440         out-&gt;add (start + i);</span>
<span class="line-added"> 441   }</span>
 442 
<a name="43" id="anc43"></a><span class="line-modified"> 443   bool sanitize (hb_sanitize_context_t *c) const</span>
 444   {
 445     TRACE_SANITIZE (this);
 446     return_trace (c-&gt;check_struct (this) &amp;&amp; glyphIdArray.sanitize (c));
 447   }
 448 
 449   protected:
 450   UINT          formatReserved; /* Subtable format and (maybe) padding. */
 451   UINT          length;         /* Byte length of this subtable. */
 452   UINT          language;       /* Ignore. */
 453   UINT          startCharCode;  /* First character code covered. */
 454   ArrayOf&lt;GlyphID, UINT&gt;
 455                 glyphIdArray;   /* Array of glyph index values for character
 456                                  * codes in the range. */
 457   public:
 458   DEFINE_SIZE_ARRAY (5 * sizeof (UINT), glyphIdArray);
 459 };
 460 
 461 struct CmapSubtableFormat6  : CmapSubtableTrimmed&lt;HBUINT16&gt; {};
 462 struct CmapSubtableFormat10 : CmapSubtableTrimmed&lt;HBUINT32 &gt; {};
 463 
 464 template &lt;typename T&gt;
 465 struct CmapSubtableLongSegmented
 466 {
 467   friend struct cmap;
 468 
<a name="44" id="anc44"></a><span class="line-modified"> 469   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 470   {
<a name="45" id="anc45"></a><span class="line-modified"> 471     hb_codepoint_t gid = T::group_get_glyph (groups.bsearch (codepoint), codepoint);</span>
<span class="line-modified"> 472     if (!gid)</span>
 473       return false;
<a name="46" id="anc46"></a><span class="line-modified"> 474     *glyph = gid;</span>
 475     return true;
 476   }
 477 
<a name="47" id="anc47"></a><span class="line-modified"> 478   void collect_unicodes (hb_set_t *out) const</span>
 479   {
 480     for (unsigned int i = 0; i &lt; this-&gt;groups.len; i++) {
<a name="48" id="anc48"></a><span class="line-modified"> 481       out-&gt;add_range (this-&gt;groups[i].startCharCode,</span>
<span class="line-modified"> 482                       MIN ((hb_codepoint_t) this-&gt;groups[i].endCharCode,</span>
<span class="line-modified"> 483                            (hb_codepoint_t) HB_UNICODE_MAX));</span>
 484     }
 485   }
 486 
<a name="49" id="anc49"></a><span class="line-modified"> 487   bool sanitize (hb_sanitize_context_t *c) const</span>
 488   {
 489     TRACE_SANITIZE (this);
 490     return_trace (c-&gt;check_struct (this) &amp;&amp; groups.sanitize (c));
 491   }
 492 
<a name="50" id="anc50"></a><span class="line-modified"> 493   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 494                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
 495   {
 496     TRACE_SERIALIZE (this);
 497     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="51" id="anc51"></a><span class="line-modified"> 498     if (unlikely (!groups.serialize (c, group_data.as_array ()))) return_trace (false);</span>

 499     return true;
 500   }
 501 
 502   protected:
 503   HBUINT16      format;         /* Subtable format; set to 12. */
 504   HBUINT16      reserved;       /* Reserved; set to 0. */
 505   HBUINT32      length;         /* Byte length of this subtable. */
 506   HBUINT32      language;       /* Ignore. */
 507   SortedArrayOf&lt;CmapSubtableLongGroup, HBUINT32&gt;
 508                 groups;         /* Groupings. */
 509   public:
 510   DEFINE_SIZE_ARRAY (16, groups);
 511 };
 512 
 513 struct CmapSubtableFormat12 : CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;
 514 {
<a name="52" id="anc52"></a><span class="line-modified"> 515   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 516                                          hb_codepoint_t u)</span>
<span class="line-modified"> 517   { return likely (group.startCharCode &lt;= group.endCharCode) ?</span>
<span class="line-added"> 518            group.glyphID + (u - group.startCharCode) : 0; }</span>
 519 
 520 
 521   bool serialize (hb_serialize_context_t *c,
 522                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)
 523   {
 524     if (unlikely (!c-&gt;extend_min (*this))) return false;
 525 
 526     this-&gt;format.set (12);
 527     this-&gt;reserved.set (0);
 528     this-&gt;length.set (get_sub_table_size (groups));
 529 
 530     return CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;::serialize (c, groups);
 531   }
 532 
<a name="53" id="anc53"></a><span class="line-modified"> 533   static size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
 534   {
<a name="54" id="anc54"></a><span class="line-modified"> 535     return 16 + 12 * groups.length;</span>
 536   }
 537 
<a name="55" id="anc55"></a><span class="line-modified"> 538   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 539                                      hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
 540   {
 541     CmapSubtableLongGroup *group = nullptr;
 542 
 543     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 544     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 545       hb_codepoint_t new_gid;
 546       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 547       {
 548         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 549         return false;
 550       }
 551 
 552       if (!group || !_is_gid_consecutive (group, cp, new_gid))
 553       {
 554         group = groups-&gt;push ();
 555         group-&gt;startCharCode.set (cp);
 556         group-&gt;endCharCode.set (cp);
 557         group-&gt;glyphID.set (new_gid);
<a name="56" id="anc56"></a>


 558       }
<a name="57" id="anc57"></a><span class="line-added"> 559       else group-&gt;endCharCode.set (cp);</span>
 560     }
 561 
 562     DEBUG_MSG(SUBSET, nullptr, &quot;cmap&quot;);
<a name="58" id="anc58"></a><span class="line-modified"> 563     for (unsigned int i = 0; i &lt; groups-&gt;length; i++) {</span>
 564       CmapSubtableLongGroup&amp; group = (*groups)[i];
 565       DEBUG_MSG(SUBSET, nullptr, &quot;  %d: U+%04X-U+%04X, gid %d-%d&quot;, i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));
 566     }
 567 
 568     return true;
 569   }
 570 
 571  private:
<a name="59" id="anc59"></a><span class="line-modified"> 572   static bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="line-modified"> 573                                    hb_codepoint_t cp,</span>
<span class="line-modified"> 574                                    hb_codepoint_t new_gid)</span>
 575   {
 576     return (cp - 1 == group-&gt;endCharCode) &amp;&amp;
 577         new_gid == group-&gt;glyphID + (cp - group-&gt;startCharCode);
 578   }
 579 
 580 };
 581 
 582 struct CmapSubtableFormat13 : CmapSubtableLongSegmented&lt;CmapSubtableFormat13&gt;
 583 {
<a name="60" id="anc60"></a><span class="line-modified"> 584   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 585                                          hb_codepoint_t u HB_UNUSED)</span>
 586   { return group.glyphID; }
 587 };
 588 
 589 typedef enum
 590 {
 591   GLYPH_VARIANT_NOT_FOUND = 0,
 592   GLYPH_VARIANT_FOUND = 1,
 593   GLYPH_VARIANT_USE_DEFAULT = 2
 594 } glyph_variant_t;
 595 
 596 struct UnicodeValueRange
 597 {
<a name="61" id="anc61"></a><span class="line-modified"> 598   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 599   {
 600     if (codepoint &lt; startUnicodeValue) return -1;
 601     if (codepoint &gt; startUnicodeValue + additionalCount) return +1;
 602     return 0;
 603   }
 604 
<a name="62" id="anc62"></a><span class="line-modified"> 605   bool sanitize (hb_sanitize_context_t *c) const</span>
 606   {
 607     TRACE_SANITIZE (this);
 608     return_trace (c-&gt;check_struct (this));
 609   }
 610 
 611   HBUINT24      startUnicodeValue;      /* First value in this range. */
<a name="63" id="anc63"></a><span class="line-modified"> 612   HBUINT8       additionalCount;        /* Number of additional values in this</span>
 613                                          * range. */
 614   public:
 615   DEFINE_SIZE_STATIC (4);
 616 };
 617 
<a name="64" id="anc64"></a><span class="line-modified"> 618 struct DefaultUVS : SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt;</span>
<span class="line-added"> 619 {</span>
<span class="line-added"> 620   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 621   {</span>
<span class="line-added"> 622     unsigned int count = len;</span>
<span class="line-added"> 623     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 624     {</span>
<span class="line-added"> 625       hb_codepoint_t first = arrayZ[i].startUnicodeValue;</span>
<span class="line-added"> 626       hb_codepoint_t last = MIN ((hb_codepoint_t) (first + arrayZ[i].additionalCount),</span>
<span class="line-added"> 627                                  (hb_codepoint_t) HB_UNICODE_MAX);</span>
<span class="line-added"> 628       out-&gt;add_range (first, last);</span>
<span class="line-added"> 629     }</span>
<span class="line-added"> 630   }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632   public:</span>
<span class="line-added"> 633   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="line-added"> 634 };</span>
 635 
 636 struct UVSMapping
 637 {
<a name="65" id="anc65"></a><span class="line-modified"> 638   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 639   {
 640     return unicodeValue.cmp (codepoint);
 641   }
 642 
<a name="66" id="anc66"></a><span class="line-modified"> 643   bool sanitize (hb_sanitize_context_t *c) const</span>
 644   {
 645     TRACE_SANITIZE (this);
 646     return_trace (c-&gt;check_struct (this));
 647   }
 648 
 649   HBUINT24      unicodeValue;   /* Base Unicode value of the UVS */
 650   GlyphID       glyphID;        /* Glyph ID of the UVS */
 651   public:
 652   DEFINE_SIZE_STATIC (5);
 653 };
 654 
<a name="67" id="anc67"></a><span class="line-modified"> 655 struct NonDefaultUVS : SortedArrayOf&lt;UVSMapping, HBUINT32&gt;</span>
<span class="line-added"> 656 {</span>
<span class="line-added"> 657   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 658   {</span>
<span class="line-added"> 659     unsigned int count = len;</span>
<span class="line-added"> 660     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 661       out-&gt;add (arrayZ[i].glyphID);</span>
<span class="line-added"> 662   }</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664   public:</span>
<span class="line-added"> 665   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="line-added"> 666 };</span>
 667 
 668 struct VariationSelectorRecord
 669 {
<a name="68" id="anc68"></a><span class="line-modified"> 670   glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 671                              hb_codepoint_t *glyph,</span>
<span class="line-modified"> 672                              const void *base) const</span>
 673   {
<a name="69" id="anc69"></a><span class="line-modified"> 674     if ((base+defaultUVS).bfind (codepoint))</span>



 675       return GLYPH_VARIANT_USE_DEFAULT;
<a name="70" id="anc70"></a><span class="line-modified"> 676     const UVSMapping &amp;nonDefault = (base+nonDefaultUVS).bsearch (codepoint);</span>
<span class="line-modified"> 677     if (nonDefault.glyphID)</span>

 678     {
<a name="71" id="anc71"></a><span class="line-modified"> 679       *glyph = nonDefault.glyphID;</span>
 680        return GLYPH_VARIANT_FOUND;
 681     }
 682     return GLYPH_VARIANT_NOT_FOUND;
 683   }
 684 
<a name="72" id="anc72"></a><span class="line-modified"> 685   void collect_unicodes (hb_set_t *out, const void *base) const</span>
<span class="line-added"> 686   {</span>
<span class="line-added"> 687     (base+defaultUVS).collect_unicodes (out);</span>
<span class="line-added"> 688     (base+nonDefaultUVS).collect_unicodes (out);</span>
<span class="line-added"> 689   }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691   int cmp (const hb_codepoint_t &amp;variation_selector) const</span>
 692   {
 693     return varSelector.cmp (variation_selector);
 694   }
 695 
<a name="73" id="anc73"></a><span class="line-modified"> 696   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 697   {
 698     TRACE_SANITIZE (this);
 699     return_trace (c-&gt;check_struct (this) &amp;&amp;
 700                   defaultUVS.sanitize (c, base) &amp;&amp;
 701                   nonDefaultUVS.sanitize (c, base));
 702   }
 703 
 704   HBUINT24      varSelector;    /* Variation selector. */
 705   LOffsetTo&lt;DefaultUVS&gt;
<a name="74" id="anc74"></a><span class="line-modified"> 706                 defaultUVS;     /* Offset to Default UVS Table.  May be 0. */</span>
 707   LOffsetTo&lt;NonDefaultUVS&gt;
<a name="75" id="anc75"></a><span class="line-modified"> 708                 nonDefaultUVS;  /* Offset to Non-Default UVS Table.  May be 0. */</span>
 709   public:
 710   DEFINE_SIZE_STATIC (11);
 711 };
 712 
 713 struct CmapSubtableFormat14
 714 {
<a name="76" id="anc76"></a><span class="line-modified"> 715   glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 716                                      hb_codepoint_t variation_selector,</span>
<span class="line-modified"> 717                                      hb_codepoint_t *glyph) const</span>
 718   {
<a name="77" id="anc77"></a><span class="line-modified"> 719     return record.bsearch (variation_selector).get_glyph (codepoint, glyph, this);</span>
 720   }
 721 
<a name="78" id="anc78"></a><span class="line-modified"> 722   void collect_variation_selectors (hb_set_t *out) const</span>
<span class="line-added"> 723   {</span>
<span class="line-added"> 724     unsigned int count = record.len;</span>
<span class="line-added"> 725     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 726       out-&gt;add (record.arrayZ[i].varSelector);</span>
<span class="line-added"> 727   }</span>
<span class="line-added"> 728   void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="line-added"> 729                                    hb_set_t *out) const</span>
<span class="line-added"> 730   {</span>
<span class="line-added"> 731     record.bsearch (variation_selector).collect_unicodes (out, this);</span>
<span class="line-added"> 732   }</span>
<span class="line-added"> 733 </span>
<span class="line-added"> 734   bool sanitize (hb_sanitize_context_t *c) const</span>
 735   {
 736     TRACE_SANITIZE (this);
 737     return_trace (c-&gt;check_struct (this) &amp;&amp;
 738                   record.sanitize (c, this));
 739   }
 740 
 741   protected:
 742   HBUINT16      format;         /* Format number is set to 14. */
 743   HBUINT32      length;         /* Byte length of this subtable. */
 744   SortedArrayOf&lt;VariationSelectorRecord, HBUINT32&gt;
 745                 record;         /* Variation selector records; sorted
 746                                  * in increasing order of `varSelector&#39;. */
 747   public:
 748   DEFINE_SIZE_ARRAY (10, record);
 749 };
 750 
 751 struct CmapSubtable
 752 {
 753   /* Note: We intentionally do NOT implement subtable formats 2 and 8. */
 754 
<a name="79" id="anc79"></a><span class="line-modified"> 755   bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 756                   hb_codepoint_t *glyph) const</span>
 757   {
 758     switch (u.format) {
 759     case  0: return u.format0 .get_glyph (codepoint, glyph);
 760     case  4: return u.format4 .get_glyph (codepoint, glyph);
 761     case  6: return u.format6 .get_glyph (codepoint, glyph);
 762     case 10: return u.format10.get_glyph (codepoint, glyph);
 763     case 12: return u.format12.get_glyph (codepoint, glyph);
 764     case 13: return u.format13.get_glyph (codepoint, glyph);
 765     case 14:
 766     default: return false;
 767     }
 768   }
<a name="80" id="anc80"></a><span class="line-added"> 769   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 770   {</span>
<span class="line-added"> 771     switch (u.format) {</span>
<span class="line-added"> 772     case  0: u.format0 .collect_unicodes (out); return;</span>
<span class="line-added"> 773     case  4: u.format4 .collect_unicodes (out); return;</span>
<span class="line-added"> 774     case  6: u.format6 .collect_unicodes (out); return;</span>
<span class="line-added"> 775     case 10: u.format10.collect_unicodes (out); return;</span>
<span class="line-added"> 776     case 12: u.format12.collect_unicodes (out); return;</span>
<span class="line-added"> 777     case 13: u.format13.collect_unicodes (out); return;</span>
<span class="line-added"> 778     case 14:</span>
<span class="line-added"> 779     default: return;</span>
<span class="line-added"> 780     }</span>
<span class="line-added"> 781   }</span>
 782 
<a name="81" id="anc81"></a><span class="line-modified"> 783   bool sanitize (hb_sanitize_context_t *c) const</span>
 784   {
 785     TRACE_SANITIZE (this);
 786     if (!u.format.sanitize (c)) return_trace (false);
 787     switch (u.format) {
 788     case  0: return_trace (u.format0 .sanitize (c));
 789     case  4: return_trace (u.format4 .sanitize (c));
 790     case  6: return_trace (u.format6 .sanitize (c));
 791     case 10: return_trace (u.format10.sanitize (c));
 792     case 12: return_trace (u.format12.sanitize (c));
 793     case 13: return_trace (u.format13.sanitize (c));
 794     case 14: return_trace (u.format14.sanitize (c));
 795     default:return_trace (true);
 796     }
 797   }
 798 
 799   public:
 800   union {
 801   HBUINT16              format;         /* Format identifier */
 802   CmapSubtableFormat0   format0;
 803   CmapSubtableFormat4   format4;
 804   CmapSubtableFormat6   format6;
 805   CmapSubtableFormat10  format10;
 806   CmapSubtableFormat12  format12;
 807   CmapSubtableFormat13  format13;
 808   CmapSubtableFormat14  format14;
 809   } u;
 810   public:
 811   DEFINE_SIZE_UNION (2, format);
 812 };
 813 
 814 
 815 struct EncodingRecord
 816 {
<a name="82" id="anc82"></a><span class="line-modified"> 817   int cmp (const EncodingRecord &amp;other) const</span>
 818   {
 819     int ret;
 820     ret = platformID.cmp (other.platformID);
 821     if (ret) return ret;
 822     ret = encodingID.cmp (other.encodingID);
 823     if (ret) return ret;
 824     return 0;
 825   }
 826 
<a name="83" id="anc83"></a><span class="line-modified"> 827   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 828   {
 829     TRACE_SANITIZE (this);
 830     return_trace (c-&gt;check_struct (this) &amp;&amp;
 831                   subtable.sanitize (c, base));
 832   }
 833 
 834   HBUINT16      platformID;     /* Platform ID. */
 835   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 836   LOffsetTo&lt;CmapSubtable&gt;
 837                 subtable;       /* Byte offset from beginning of table to the subtable for this encoding. */
 838   public:
 839   DEFINE_SIZE_STATIC (8);
 840 };
 841 
 842 struct cmap
 843 {
<a name="84" id="anc84"></a><span class="line-modified"> 844   static constexpr hb_tag_t tableTag = HB_OT_TAG_cmap;</span>







 845 
<a name="85" id="anc85"></a><span class="line-modified"> 846   struct subset_plan</span>
<span class="line-modified"> 847   {</span>
<span class="line-modified"> 848     size_t final_size () const</span>




 849     {
 850       return 4 // header
 851           +  8 * 3 // 3 EncodingRecord
 852           +  CmapSubtableFormat4::get_sub_table_size (this-&gt;format4_segments)
 853           +  CmapSubtableFormat12::get_sub_table_size (this-&gt;format12_groups);
 854     }
 855 
<a name="86" id="anc86"></a>
 856     hb_vector_t&lt;CmapSubtableFormat4::segment_plan&gt; format4_segments;
<a name="87" id="anc87"></a>
 857     hb_vector_t&lt;CmapSubtableLongGroup&gt; format12_groups;
 858   };
 859 
<a name="88" id="anc88"></a><span class="line-modified"> 860   bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 861                      subset_plan *cmap_plan) const</span>








 862   {
<a name="89" id="anc89"></a><span class="line-modified"> 863     if (unlikely (!CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
 864       return false;
 865 
 866     return CmapSubtableFormat12::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format12_groups);
 867   }
 868 
<a name="90" id="anc90"></a><span class="line-modified"> 869   bool _subset (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 870                 const subset_plan &amp;cmap_subset_plan,</span>
<span class="line-modified"> 871                 size_t dest_sz,</span>
<span class="line-modified"> 872                 void *dest) const</span>
 873   {
 874     hb_serialize_context_t c (dest, dest_sz);
 875 
<a name="91" id="anc91"></a><span class="line-modified"> 876     cmap *table = c.start_serialize&lt;cmap&gt; ();</span>
<span class="line-modified"> 877     if (unlikely (!c.extend_min (*table)))</span>
 878     {
 879       return false;
 880     }
 881 
<a name="92" id="anc92"></a><span class="line-modified"> 882     table-&gt;version.set (0);</span>
 883 
<a name="93" id="anc93"></a><span class="line-modified"> 884     if (unlikely (!table-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
 885       return false;
 886 
 887     // TODO(grieger): Convert the below to a for loop
 888 
 889     // Format 4, Plat 0 Encoding Record
<a name="94" id="anc94"></a><span class="line-modified"> 890     EncodingRecord &amp;format4_plat0_rec = table-&gt;encodingRecord[0];</span>
 891     format4_plat0_rec.platformID.set (0); // Unicode
 892     format4_plat0_rec.encodingID.set (3);
 893 
 894     // Format 4, Plat 3 Encoding Record
<a name="95" id="anc95"></a><span class="line-modified"> 895     EncodingRecord &amp;format4_plat3_rec = table-&gt;encodingRecord[1];</span>
 896     format4_plat3_rec.platformID.set (3); // Windows
 897     format4_plat3_rec.encodingID.set (1); // Unicode BMP
 898 
 899     // Format 12 Encoding Record
<a name="96" id="anc96"></a><span class="line-modified"> 900     EncodingRecord &amp;format12_rec = table-&gt;encodingRecord[2];</span>
 901     format12_rec.platformID.set (3); // Windows
 902     format12_rec.encodingID.set (10); // Unicode UCS-4
 903 
 904     // Write out format 4 sub table
 905     {
<a name="97" id="anc97"></a><span class="line-modified"> 906       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, table);</span>
 907       format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);
 908       subtable.u.format.set (4);
 909 
 910       CmapSubtableFormat4 &amp;format4 = subtable.u.format4;
 911       if (unlikely (!format4.serialize (&amp;c, plan, cmap_subset_plan.format4_segments)))
 912         return false;
 913     }
 914 
 915     // Write out format 12 sub table.
 916     {
<a name="98" id="anc98"></a><span class="line-modified"> 917       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, table);</span>
 918       subtable.u.format.set (12);
 919 
 920       CmapSubtableFormat12 &amp;format12 = subtable.u.format12;
 921       if (unlikely (!format12.serialize (&amp;c, cmap_subset_plan.format12_groups)))
 922         return false;
 923     }
 924 
 925     c.end_serialize ();
 926 
 927     return true;
 928   }
 929 
<a name="99" id="anc99"></a><span class="line-modified"> 930   bool subset (hb_subset_plan_t *plan) const</span>
 931   {
 932     subset_plan cmap_subset_plan;
 933 
 934     if (unlikely (!_create_plan (plan, &amp;cmap_subset_plan)))
 935     {
 936       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to generate a cmap subsetting plan.&quot;);
 937       return false;
 938     }
 939 
 940     // We now know how big our blob needs to be
<a name="100" id="anc100"></a><span class="line-modified"> 941     size_t dest_sz = cmap_subset_plan.final_size ();</span>
 942     void *dest = malloc (dest_sz);
 943     if (unlikely (!dest)) {
 944       DEBUG_MSG(SUBSET, nullptr, &quot;Unable to alloc %lu for cmap subset output&quot;, (unsigned long) dest_sz);
 945       return false;
 946     }
 947 
 948     if (unlikely (!_subset (plan, cmap_subset_plan, dest_sz, dest)))
 949     {
 950       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to perform subsetting of cmap.&quot;);
 951       free (dest);
 952       return false;
 953     }
 954 
 955     // all done, write the blob into dest
<a name="101" id="anc101"></a><span class="line-modified"> 956     hb_blob_t *cmap_prime = hb_blob_create ((const char *) dest,</span>
 957                                             dest_sz,
 958                                             HB_MEMORY_MODE_READONLY,
 959                                             dest,
 960                                             free);
 961     bool result =  plan-&gt;add_table (HB_OT_TAG_cmap, cmap_prime);
 962     hb_blob_destroy (cmap_prime);
 963     return result;
 964   }
 965 
<a name="102" id="anc102"></a><span class="line-modified"> 966   const CmapSubtable *find_best_subtable (bool *symbol = nullptr) const</span>
 967   {
<a name="103" id="anc103"></a><span class="line-modified"> 968     if (symbol) *symbol = false;</span>
<span class="line-added"> 969 </span>
<span class="line-added"> 970     const CmapSubtable *subtable;</span>
<span class="line-added"> 971 </span>
<span class="line-added"> 972     /* 32-bit subtables. */</span>
<span class="line-added"> 973     if ((subtable = this-&gt;find_subtable (3, 10))) return subtable;</span>
<span class="line-added"> 974     if ((subtable = this-&gt;find_subtable (0, 6))) return subtable;</span>
<span class="line-added"> 975     if ((subtable = this-&gt;find_subtable (0, 4))) return subtable;</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977     /* 16-bit subtables. */</span>
<span class="line-added"> 978     if ((subtable = this-&gt;find_subtable (3, 1))) return subtable;</span>
<span class="line-added"> 979     if ((subtable = this-&gt;find_subtable (0, 3))) return subtable;</span>
<span class="line-added"> 980     if ((subtable = this-&gt;find_subtable (0, 2))) return subtable;</span>
<span class="line-added"> 981     if ((subtable = this-&gt;find_subtable (0, 1))) return subtable;</span>
<span class="line-added"> 982     if ((subtable = this-&gt;find_subtable (0, 0))) return subtable;</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984     /* Symbol subtable. */</span>
<span class="line-added"> 985     if ((subtable = this-&gt;find_subtable (3, 0)))</span>
 986     {
<a name="104" id="anc104"></a><span class="line-modified"> 987       if (symbol) *symbol = true;</span>
<span class="line-modified"> 988       return subtable;</span>
<span class="line-modified"> 989     }</span>
<span class="line-modified"> 990 </span>
<span class="line-modified"> 991     /* Meh. */</span>
<span class="line-modified"> 992     return &amp;Null (CmapSubtable);</span>
<span class="line-modified"> 993   }</span>
















 994 
<a name="105" id="anc105"></a><span class="line-modified"> 995   struct accelerator_t</span>
<span class="line-modified"> 996   {</span>
<span class="line-added"> 997     void init (hb_face_t *face)</span>
<span class="line-added"> 998     {</span>
<span class="line-added"> 999       this-&gt;table = hb_sanitize_context_t ().reference_table&lt;cmap&gt; (face);</span>
<span class="line-added">1000       bool symbol;</span>
<span class="line-added">1001       this-&gt;subtable = table-&gt;find_best_subtable (&amp;symbol);</span>
<span class="line-added">1002       this-&gt;subtable_uvs = &amp;Null (CmapSubtableFormat14);</span>
1003       {
<a name="106" id="anc106"></a><span class="line-modified">1004         const CmapSubtable *st = table-&gt;find_subtable (0, 5);</span>
1005         if (st &amp;&amp; st-&gt;u.format == 14)
1006           subtable_uvs = &amp;st-&gt;u.format14;
1007       }
<a name="107" id="anc107"></a>



1008 
1009       this-&gt;get_glyph_data = subtable;
1010       if (unlikely (symbol))
1011       {
<a name="108" id="anc108"></a><span class="line-modified">1012         this-&gt;get_glyph_funcZ = get_glyph_from_symbol&lt;CmapSubtable&gt;;</span>

1013       } else {
1014         switch (subtable-&gt;u.format) {
1015         /* Accelerate format 4 and format 12. */
1016         default:
<a name="109" id="anc109"></a><span class="line-modified">1017           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtable&gt;;</span>

1018           break;
1019         case 12:
<a name="110" id="anc110"></a><span class="line-modified">1020           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtableFormat12&gt;;</span>

1021           break;
1022         case  4:
1023           {
1024             this-&gt;format4_accel.init (&amp;subtable-&gt;u.format4);
1025             this-&gt;get_glyph_data = &amp;this-&gt;format4_accel;
<a name="111" id="anc111"></a><span class="line-modified">1026             this-&gt;get_glyph_funcZ = this-&gt;format4_accel.get_glyph_func;</span>

1027           }
1028           break;
1029         }
1030       }
1031     }
1032 
<a name="112" id="anc112"></a><span class="line-modified">1033     void fini () { this-&gt;table.destroy (); }</span>



1034 
<a name="113" id="anc113"></a><span class="line-modified">1035     bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
1036                                    hb_codepoint_t *glyph) const
1037     {
<a name="114" id="anc114"></a><span class="line-modified">1038       if (unlikely (!this-&gt;get_glyph_funcZ)) return false;</span>
<span class="line-added">1039       return this-&gt;get_glyph_funcZ (this-&gt;get_glyph_data, unicode, glyph);</span>
<span class="line-added">1040     }</span>
<span class="line-added">1041     unsigned int get_nominal_glyphs (unsigned int count,</span>
<span class="line-added">1042                                      const hb_codepoint_t *first_unicode,</span>
<span class="line-added">1043                                      unsigned int unicode_stride,</span>
<span class="line-added">1044                                      hb_codepoint_t *first_glyph,</span>
<span class="line-added">1045                                      unsigned int glyph_stride) const</span>
<span class="line-added">1046     {</span>
<span class="line-added">1047       if (unlikely (!this-&gt;get_glyph_funcZ)) return 0;</span>
<span class="line-added">1048 </span>
<span class="line-added">1049       hb_cmap_get_glyph_func_t get_glyph_funcZ = this-&gt;get_glyph_funcZ;</span>
<span class="line-added">1050       const void *get_glyph_data = this-&gt;get_glyph_data;</span>
<span class="line-added">1051 </span>
<span class="line-added">1052       unsigned int done;</span>
<span class="line-added">1053       for (done = 0;</span>
<span class="line-added">1054            done &lt; count &amp;&amp; get_glyph_funcZ (get_glyph_data, *first_unicode, first_glyph);</span>
<span class="line-added">1055            done++)</span>
<span class="line-added">1056       {</span>
<span class="line-added">1057         first_unicode = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_unicode, unicode_stride);</span>
<span class="line-added">1058         first_glyph = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_glyph, glyph_stride);</span>
<span class="line-added">1059       }</span>
<span class="line-added">1060       return done;</span>
1061     }
1062 
<a name="115" id="anc115"></a><span class="line-modified">1063     bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="line-modified">1064                               hb_codepoint_t  variation_selector,</span>
<span class="line-modified">1065                               hb_codepoint_t *glyph) const</span>
1066     {
<a name="116" id="anc116"></a><span class="line-modified">1067       switch (this-&gt;subtable_uvs-&gt;get_glyph_variant (unicode,</span>
<span class="line-modified">1068                                                      variation_selector,</span>
<span class="line-modified">1069                                                      glyph))</span>
1070       {
<a name="117" id="anc117"></a><span class="line-modified">1071         case GLYPH_VARIANT_NOT_FOUND:   return false;</span>
<span class="line-modified">1072         case GLYPH_VARIANT_FOUND:       return true;</span>
<span class="line-modified">1073         case GLYPH_VARIANT_USE_DEFAULT: break;</span>
1074       }
1075 
1076       return get_nominal_glyph (unicode, glyph);
1077     }
1078 
<a name="118" id="anc118"></a><span class="line-modified">1079     void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added">1080     {</span>
<span class="line-added">1081       subtable-&gt;collect_unicodes (out);</span>
<span class="line-added">1082     }</span>
<span class="line-added">1083     void collect_variation_selectors (hb_set_t *out) const</span>
<span class="line-added">1084     {</span>
<span class="line-added">1085       subtable_uvs-&gt;collect_variation_selectors (out);</span>
<span class="line-added">1086     }</span>
<span class="line-added">1087     void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="line-added">1088                                      hb_set_t *out) const</span>
1089     {
<a name="119" id="anc119"></a><span class="line-modified">1090       subtable_uvs-&gt;collect_variation_unicodes (variation_selector, out);</span>
1091     }
1092 
1093     protected:
1094     typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,
1095                                               hb_codepoint_t codepoint,
1096                                               hb_codepoint_t *glyph);
<a name="120" id="anc120"></a>






1097 
1098     template &lt;typename Type&gt;
<a name="121" id="anc121"></a><span class="line-modified">1099     static bool get_glyph_from (const void *obj,</span>
<span class="line-modified">1100                                 hb_codepoint_t codepoint,</span>
<span class="line-modified">1101                                 hb_codepoint_t *glyph)</span>
1102     {
1103       const Type *typed_obj = (const Type *) obj;
1104       return typed_obj-&gt;get_glyph (codepoint, glyph);
1105     }
1106 
1107     template &lt;typename Type&gt;
<a name="122" id="anc122"></a><span class="line-modified">1108     static bool get_glyph_from_symbol (const void *obj,</span>








1109                                               hb_codepoint_t codepoint,
1110                                               hb_codepoint_t *glyph)
1111     {
1112       const Type *typed_obj = (const Type *) obj;
1113       if (likely (typed_obj-&gt;get_glyph (codepoint, glyph)))
1114         return true;
1115 
1116       if (codepoint &lt;= 0x00FFu)
1117       {
1118         /* For symbol-encoded OpenType fonts, we duplicate the
1119          * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
1120          * Windows seems to do, and that&#39;s hinted about at:
1121          * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
1122          * under &quot;Non-Standard (Symbol) Fonts&quot;. */
1123         return typed_obj-&gt;get_glyph (0xF000u + codepoint, glyph);
1124       }
1125 
1126       return false;
1127     }
1128 
1129     private:
<a name="123" id="anc123"></a><span class="line-modified">1130     hb_nonnull_ptr_t&lt;const CmapSubtable&gt; subtable;</span>
<span class="line-added">1131     hb_nonnull_ptr_t&lt;const CmapSubtableFormat14&gt; subtable_uvs;</span>
<span class="line-added">1132 </span>
<span class="line-added">1133     hb_cmap_get_glyph_func_t get_glyph_funcZ;</span>
1134     const void *get_glyph_data;
<a name="124" id="anc124"></a>
1135 
<a name="125" id="anc125"></a><span class="line-modified">1136     CmapSubtableFormat4::accelerator_t format4_accel;</span>
1137 
<a name="126" id="anc126"></a><span class="line-modified">1138     hb_blob_ptr_t&lt;cmap&gt; table;</span>

1139   };
1140 
1141   protected:
1142 
<a name="127" id="anc127"></a><span class="line-modified">1143   const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="line-modified">1144                                      unsigned int encoding_id) const</span>
1145   {
1146     EncodingRecord key;
1147     key.platformID.set (platform_id);
1148     key.encodingID.set (encoding_id);
1149 
<a name="128" id="anc128"></a><span class="line-modified">1150     const EncodingRecord &amp;result = encodingRecord.bsearch (key);</span>
<span class="line-modified">1151     if (!result.subtable)</span>



1152       return nullptr;
1153 
<a name="129" id="anc129"></a><span class="line-modified">1154     return &amp;(this+result.subtable);</span>
<span class="line-added">1155   }</span>
<span class="line-added">1156 </span>
<span class="line-added">1157   public:</span>
<span class="line-added">1158 </span>
<span class="line-added">1159   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">1160   {</span>
<span class="line-added">1161     TRACE_SANITIZE (this);</span>
<span class="line-added">1162     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">1163                   likely (version == 0) &amp;&amp;</span>
<span class="line-added">1164                   encodingRecord.sanitize (c, this));</span>
1165   }
1166 
1167   protected:
1168   HBUINT16              version;        /* Table version number (0). */
1169   SortedArrayOf&lt;EncodingRecord&gt;
1170                         encodingRecord; /* Encoding tables. */
1171   public:
1172   DEFINE_SIZE_ARRAY (4, encodingRecord);
1173 };
1174 
<a name="130" id="anc130"></a><span class="line-added">1175 struct cmap_accelerator_t : cmap::accelerator_t {};</span>
1176 
1177 } /* namespace OT */
1178 
1179 
1180 #endif /* HB_OT_CMAP_TABLE_HH */
<a name="131" id="anc131"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="131" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-buffer-serialize.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,24 +25,25 @@</span>
   *
   * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="udiff-line-modified-removed">- #include &quot;hb-buffer-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-utf-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-buffer.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-utf.hh&quot;</span>
  
  
  /**
   * SECTION: hb-buffer
<span class="udiff-line-modified-removed">-  * @title: Buffers</span>
<span class="udiff-line-modified-added">+  * @title: hb-buffer</span>
   * @short_description: Input and output buffers
   * @include: hb.h
   *
   * Buffers serve dual role in HarfBuzz; they hold the input characters that are
<span class="udiff-line-modified-removed">-  * passed hb_shape(), and after shaping they hold the output glyphs.</span>
<span class="udiff-line-modified-added">+  * passed to hb_shape(), and after shaping they hold the output glyphs.</span>
   **/
  
<span class="udiff-line-added">+ </span>
  /**
   * hb_segment_properties_equal:
   * @a: first #hb_segment_properties_t to compare.
   * @b: second #hb_segment_properties_t to compare.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -122,18 +123,18 @@</span>
    unsigned int new_allocated = allocated;
    hb_glyph_position_t *new_pos = nullptr;
    hb_glyph_info_t *new_info = nullptr;
    bool separate_out = out_info != info;
  
<span class="udiff-line-modified-removed">-   if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))</span>
      goto done;
  
    while (size &gt;= new_allocated)
      new_allocated += (new_allocated &gt;&gt; 1) + 32;
  
    static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
<span class="udiff-line-modified-removed">-   if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))</span>
      goto done;
  
    new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
    new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -180,11 +181,15 @@</span>
  
    memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
    if (idx + count &gt; len)
    {
      /* Under memory failure we might expose this area.  At least
<span class="udiff-line-modified-removed">-      * clean it up.  Oh well... */</span>
<span class="udiff-line-modified-added">+      * clean it up.  Oh well...</span>
<span class="udiff-line-added">+      *</span>
<span class="udiff-line-added">+      * Ideally, we should at least set Default_Ignorable bits on</span>
<span class="udiff-line-added">+      * these, as well as consistent cluster values.  But the former</span>
<span class="udiff-line-added">+      * is layering violation... */</span>
      memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
    }
    len += count;
    idx += count;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -208,27 +213,28 @@</span>
  
  
  /* HarfBuzz-Internal API */
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::reset (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::reset ()</span>
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (this)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    hb_unicode_funcs_destroy (unicode);
<span class="udiff-line-modified-removed">-   unicode = hb_unicode_funcs_get_default ();</span>
<span class="udiff-line-modified-added">+   unicode = hb_unicode_funcs_reference (hb_unicode_funcs_get_default ());</span>
    flags = HB_BUFFER_FLAG_DEFAULT;
    replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;
<span class="udiff-line-added">+   invisible = 0;</span>
  
    clear ();
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::clear (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::clear ()</span>
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (this)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
    props = default_props;
    scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,39 +285,39 @@</span>
    len++;
  }
  
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::remove_output (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::remove_output ()</span>
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (this)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = false;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::clear_output (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::clear_output ()</span>
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (this)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = true;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::clear_positions (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::clear_positions ()</span>
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (this)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = false;
    have_positions = true;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -320,11 +326,11 @@</span>
  
    memset (pos, 0, sizeof (pos[0]) * len);
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::swap_buffers (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::swap_buffers ()</span>
  {
    if (unlikely (!successful)) return;
  
    assert (have_output);
    have_output = false;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,10 +358,12 @@</span>
                               unsigned int num_out,
                               const uint32_t *glyph_data)
  {
    if (unlikely (!make_room_for (num_in, num_out))) return;
  
<span class="udiff-line-added">+   assert (idx + num_in &lt;= len);</span>
<span class="udiff-line-added">+ </span>
    merge_clusters (idx, idx + num_in);
  
    hb_glyph_info_t orig_info = info[idx];
    hb_glyph_info_t *pinfo = &amp;out_info[out_len];
    for (unsigned int i = 0; i &lt; num_out; i++)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -367,41 +375,10 @@</span>
  
    idx  += num_in;
    out_len += num_out;
  }
  
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_info[out_len] = info[idx];</span>
<span class="udiff-line-removed">-   out_info[out_len].codepoint = glyph_index;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_len++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- hb_buffer_t::output_info (const hb_glyph_info_t &amp;glyph_info)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_info[out_len] = glyph_info;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_len++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- hb_buffer_t::copy_glyph (void)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_info[out_len] = info[idx];</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   out_len++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  bool
  hb_buffer_t::move_to (unsigned int i)
  {
    if (!have_output)
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -427,12 +404,18 @@</span>
    {
      /* Tricky part: rewinding... */
      unsigned int count = out_len - i;
  
      /* This will blow in our face if memory allocation fails later
<span class="udiff-line-modified-removed">-      * in this same lookup... */</span>
<span class="udiff-line-modified-removed">-     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 32))) return false;</span>
<span class="udiff-line-modified-added">+      * in this same lookup...</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-added">+      * We used to shift with extra 32 items, instead of the 0 below.</span>
<span class="udiff-line-added">+      * But that would leave empty slots in the buffer in case of allocation</span>
<span class="udiff-line-added">+      * failures.  Setting to zero for now to avoid other problems (see</span>
<span class="udiff-line-added">+      * comments in shift_forward().  This can cause O(N^2) behavior more</span>
<span class="udiff-line-added">+      * severely than adding 32 empty slots can... */</span>
<span class="udiff-line-added">+     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 0))) return false;</span>
  
      assert (idx &gt;= count);
  
      idx -= count;
      out_len -= count;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -440,23 +423,10 @@</span>
    }
  
    return true;
  }
  
<span class="udiff-line-removed">- void</span>
<span class="udiff-line-removed">- hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (unlikely (out_info != info || out_len != idx)) {</span>
<span class="udiff-line-removed">-     if (unlikely (!make_room_for (1, 1))) return;</span>
<span class="udiff-line-removed">-     out_info[out_len] = info[idx];</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   out_info[out_len].codepoint = glyph_index;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   idx++;</span>
<span class="udiff-line-removed">-   out_len++;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  
  void
  hb_buffer_t::set_masks (hb_mask_t    value,
                          hb_mask_t    mask,
                          unsigned int cluster_start,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -508,20 +478,20 @@</span>
      }
    }
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::reverse (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::reverse ()</span>
  {
    if (unlikely (!len))
      return;
  
    reverse_range (0, len);
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::reverse_clusters (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::reverse_clusters ()</span>
  {
    unsigned int i, start, count, last_cluster;
  
    if (unlikely (!len))
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -664,11 +634,11 @@</span>
    _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
    _unsafe_to_break_set_mask (info, idx, end, cluster);
  }
  
  void
<span class="udiff-line-modified-removed">- hb_buffer_t::guess_segment_properties (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_t::guess_segment_properties ()</span>
  {
    assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
    /* If script is set to INVALID, guess from buffer contents */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -699,10 +669,33 @@</span>
  }
  
  
  /* Public API */
  
<span class="udiff-line-added">+ DEFINE_NULL_INSTANCE (hb_buffer_t) =</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   HB_OBJECT_HEADER_STATIC,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_Null_hb_unicode_funcs_t),</span>
<span class="udiff-line-added">+   HB_BUFFER_FLAG_DEFAULT,</span>
<span class="udiff-line-added">+   HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="udiff-line-added">+   HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="udiff-line-added">+   0, /* invisible */</span>
<span class="udiff-line-added">+   HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="udiff-line-added">+   HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="udiff-line-added">+   HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="udiff-line-added">+   HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="udiff-line-added">+   false, /* successful */</span>
<span class="udiff-line-added">+   true, /* have_output */</span>
<span class="udiff-line-added">+   true  /* have_positions */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Zero is good enough for everything else. */</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /**
   * hb_buffer_create: (Xconstructor)
   *
   * Creates a new #hb_buffer_t with all properties to defaults.
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -714,11 +707,11 @@</span>
   * hb_buffer_allocation_successful() returns %false.
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="udiff-line-modified-removed">- hb_buffer_create (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_create ()</span>
  {
    hb_buffer_t *buffer;
  
    if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
      return hb_buffer_get_empty ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,33 +732,13 @@</span>
   * Return value: (transfer full):
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="udiff-line-modified-removed">- hb_buffer_get_empty (void)</span>
<span class="udiff-line-modified-added">+ hb_buffer_get_empty ()</span>
  {
<span class="udiff-line-modified-removed">-   static const hb_buffer_t _hb_buffer_nil = {</span>
<span class="udiff-line-removed">-     HB_OBJECT_HEADER_STATIC,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_unicode_funcs_nil),</span>
<span class="udiff-line-removed">-     HB_BUFFER_FLAG_DEFAULT,</span>
<span class="udiff-line-removed">-     HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="udiff-line-removed">-     HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="udiff-line-removed">-     HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="udiff-line-removed">-     HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="udiff-line-removed">-     HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="udiff-line-removed">-     HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="udiff-line-removed">-     false, /* successful */</span>
<span class="udiff-line-removed">-     true, /* have_output */</span>
<span class="udiff-line-removed">-     true  /* have_positions */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* Zero is good enough for everything else. */</span>
<span class="udiff-line-removed">-   };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   return const_cast&lt;hb_buffer_t *&gt; (&amp;_hb_buffer_nil);</span>
<span class="udiff-line-modified-added">+   return const_cast&lt;hb_buffer_t *&gt; (&amp;Null(hb_buffer_t));</span>
  }
  
  /**
   * hb_buffer_reference: (skip)
   * @buffer: an #hb_buffer_t.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -898,17 +871,16 @@</span>
   **/
  void
  hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
                               hb_unicode_funcs_t *unicode_funcs)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    if (!unicode_funcs)
      unicode_funcs = hb_unicode_funcs_get_default ();
  
<span class="udiff-line-removed">- </span>
    hb_unicode_funcs_reference (unicode_funcs);
    hb_unicode_funcs_destroy (buffer-&gt;unicode);
    buffer-&gt;unicode = unicode_funcs;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,11 +918,11 @@</span>
  void
  hb_buffer_set_direction (hb_buffer_t    *buffer,
                           hb_direction_t  direction)
  
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.direction = direction;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -990,11 +962,11 @@</span>
   **/
  void
  hb_buffer_set_script (hb_buffer_t *buffer,
                        hb_script_t  script)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.script = script;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1025,20 +997,20 @@</span>
   * Languages are crucial for selecting which OpenType feature to apply to the
   * buffer which can result in applying language-specific behaviour. Languages
   * are orthogonal to the scripts, and though they are related, they are
   * different concepts and should not be confused with each other.
   *
<span class="udiff-line-modified-removed">-  * Use hb_language_from_string() to convert from ISO 639 language codes to</span>
<span class="udiff-line-modified-added">+  * Use hb_language_from_string() to convert from BCP 47 language tags to</span>
   * #hb_language_t.
   *
   * Since: 0.9.2
   **/
  void
  hb_buffer_set_language (hb_buffer_t   *buffer,
                          hb_language_t  language)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.language = language;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1072,11 +1044,11 @@</span>
   **/
  void
  hb_buffer_set_segment_properties (hb_buffer_t *buffer,
                                    const hb_segment_properties_t *props)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props = *props;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1108,11 +1080,11 @@</span>
   **/
  void
  hb_buffer_set_flags (hb_buffer_t       *buffer,
                       hb_buffer_flags_t  flags)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;flags = flags;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1144,11 +1116,11 @@</span>
   **/
  void
  hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
                       hb_buffer_cluster_level_t  cluster_level)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;cluster_level = cluster_level;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1183,11 +1155,11 @@</span>
   **/
  void
  hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
                                       hb_codepoint_t  replacement)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;replacement = replacement;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1207,10 +1179,50 @@</span>
  {
    return buffer-&gt;replacement;
  }
  
  
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * hb_buffer_set_invisible_glyph:</span>
<span class="udiff-line-added">+  * @buffer: an #hb_buffer_t.</span>
<span class="udiff-line-added">+  * @invisible: the invisible #hb_codepoint_t</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Sets the #hb_codepoint_t that replaces invisible characters in</span>
<span class="udiff-line-added">+  * the shaping result.  If set to zero (default), the glyph for the</span>
<span class="udiff-line-added">+  * U+0020 SPACE character is used.  Otherwise, this value is used</span>
<span class="udiff-line-added">+  * verbatim.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 2.0.0</span>
<span class="udiff-line-added">+  **/</span>
<span class="udiff-line-added">+ void</span>
<span class="udiff-line-added">+ hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,</span>
<span class="udiff-line-added">+                                hb_codepoint_t  invisible)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   buffer-&gt;invisible = invisible;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * hb_buffer_get_invisible_glyph:</span>
<span class="udiff-line-added">+  * @buffer: an #hb_buffer_t.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * See hb_buffer_set_invisible_glyph().</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Return value:</span>
<span class="udiff-line-added">+  * The @buffer invisible #hb_codepoint_t.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 2.0.0</span>
<span class="udiff-line-added">+  **/</span>
<span class="udiff-line-added">+ hb_codepoint_t</span>
<span class="udiff-line-added">+ hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   return buffer-&gt;invisible;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /**
   * hb_buffer_reset:
   * @buffer: an #hb_buffer_t.
   *
   * Resets the buffer to its initial status, as if it was just newly created
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1315,11 +1327,11 @@</span>
   **/
  hb_bool_t
  hb_buffer_set_length (hb_buffer_t  *buffer,
                        unsigned int  length)
  {
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return length == 0;
  
    if (!buffer-&gt;ensure (length))
      return false;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1496,10 +1508,12 @@</span>
   *
   * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
   * it will be set to the process&#39;s default language as returned by
   * hb_language_get_default().  This may change in the future by
   * taking buffer script into consideration when choosing a language.
<span class="udiff-line-added">+  * Note that hb_language_get_default() is NOT threadsafe the first time</span>
<span class="udiff-line-added">+  * it is called.  See documentation for that function for details.</span>
   *
   * Since: 0.9.7
   **/
  void
  hb_buffer_guess_segment_properties (hb_buffer_t *buffer)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1519,11 +1533,11 @@</span>
    const hb_codepoint_t replacement = buffer-&gt;replacement;
  
    assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
<span class="udiff-line-modified-removed">-   if (unlikely (hb_object_is_inert (buffer)))</span>
<span class="udiff-line-modified-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    if (text_length == -1)
      text_length = utf_t::strlen (text);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1650,11 +1664,11 @@</span>
                       const uint32_t *text,
                       int             text_length,
                       unsigned int    item_offset,
                       int             item_length)
  {
<span class="udiff-line-modified-removed">-   hb_buffer_add_utf&lt;hb_utf32_t&lt;&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
<span class="udiff-line-modified-added">+   hb_buffer_add_utf&lt;hb_utf32_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  /**
   * hb_buffer_add_latin1:
   * @buffer: an #hb_buffer_t.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1711,11 +1725,11 @@</span>
                            const hb_codepoint_t *text,
                            int                   text_length,
                            unsigned int          item_offset,
                            int                   item_length)
  {
<span class="udiff-line-modified-removed">-   hb_buffer_add_utf&lt;hb_utf32_t&lt;false&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
<span class="udiff-line-modified-added">+   hb_buffer_add_utf&lt;hb_utf32_novalidate_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  
  /**
   * hb_buffer_append:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1884,10 +1898,14 @@</span>
   * Comparing buffers.
   */
  
  /**
   * hb_buffer_diff:
<span class="udiff-line-added">+  * @buffer: a buffer.</span>
<span class="udiff-line-added">+  * @reference: other buffer to compare to.</span>
<span class="udiff-line-added">+  * @dottedcircle_glyph: glyph id of U+25CC DOTTED CIRCLE, or (hb_codepont_t) -1.</span>
<span class="udiff-line-added">+  * @position_fuzz: allowed absolute difference in position values.</span>
   *
   * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
   * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
   * callers if just comparing two buffers is needed.
   *
</pre>
<center><a href="hb-buffer-serialize.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
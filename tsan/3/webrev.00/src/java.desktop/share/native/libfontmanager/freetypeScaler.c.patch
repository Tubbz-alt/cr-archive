diff a/src/java.desktop/share/native/libfontmanager/freetypeScaler.c b/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
--- a/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
+++ b/src/java.desktop/share/native/libfontmanager/freetypeScaler.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -27,20 +27,24 @@
 #include "jni_util.h"
 #include "jlong.h"
 #include "sunfontids.h"
 #include "sun_font_FreetypeFontScaler.h"
 
-#include<stdlib.h>
+#include <stdlib.h>
+#if !defined(_WIN32) && !defined(__APPLE_)
+#include <dlfcn.h>
+#endif
 #include <math.h>
 #include "ft2build.h"
 #include FT_FREETYPE_H
 #include FT_GLYPH_H
 #include FT_BBOX_H
 #include FT_SIZES_H
 #include FT_OUTLINE_H
 #include FT_SYNTHESIS_H
 #include FT_LCD_FILTER_H
+#include FT_MODULE_H
 
 #include "fontscaler.h"
 
 #define  ftFixed1  (FT_Fixed) (1 << 16)
 #define  FloatToFTFixed(f) (FT_Fixed)((f) * (float)(ftFixed1))
@@ -67,11 +71,10 @@
 
     unsigned char* fontData;
     unsigned fontDataOffset;
     unsigned fontDataLength;
     unsigned fileSize;
-    TTLayoutTableCache* layoutTables;
 } FTScalerInfo;
 
 typedef struct FTScalerContext {
     FT_Matrix  transform;     /* glyph transform, including device transform */
     jboolean   useSbits;      /* sbit usage enabled? */
@@ -149,21 +152,49 @@
     FTScalerInfo *scalerInfo = (FTScalerInfo *) stream->pathname.pointer;
     JNIEnv* env = scalerInfo->env;
     jobject bBuffer;
     int bread = 0;
 
-    if (numBytes == 0) return 0;
+    /* A call with numBytes == 0 is a seek. It should return 0 if the
+     * seek position is within the file and non-zero otherwise.
+     * For all other cases, ie numBytes !=0, return the number of bytes
+     * actually read. This applies to truncated reads and also failed reads.
+     */
+
+    if (numBytes == 0) {
+        if (offset > scalerInfo->fileSize) {
+            return -1;
+        } else {
+            return 0;
+       }
+    }
+
+    if (offset + numBytes < offset) {
+        return 0; // ft should not do this, but just in case.
+    }
+
+    if (offset >= scalerInfo->fileSize) {
+        return 0;
+    }
+
+    if (offset + numBytes > scalerInfo->fileSize) {
+        numBytes = scalerInfo->fileSize - offset;
+    }
 
     /* Large reads will bypass the cache and data copying */
     if (numBytes > FILEDATACACHESIZE) {
         bBuffer = (*env)->NewDirectByteBuffer(env, destBuffer, numBytes);
         if (bBuffer != NULL) {
             bread = (*env)->CallIntMethod(env,
                                           scalerInfo->font2D,
                                           sunFontIDs.ttReadBlockMID,
                                           bBuffer, offset, numBytes);
-            return bread;
+            if (bread < 0) {
+                return 0;
+            } else {
+               return bread;
+            }
         } else {
             /* We probably hit bug 4845371. For reasons that
              * are currently unclear, the call stacks after the initial
              * createScaler call that read large amounts of data seem to
              * be OK and can create the byte buffer above, but this code
@@ -174,13 +205,22 @@
              */
             jbyteArray byteArray = (jbyteArray)
             (*env)->CallObjectMethod(env, scalerInfo->font2D,
                                      sunFontIDs.ttReadBytesMID,
                                      offset, numBytes);
-            (*env)->GetByteArrayRegion(env, byteArray,
-                                       0, numBytes, (jbyte*)destBuffer);
-            return numBytes;
+            /* If there's an OutofMemoryError then byteArray will be null */
+            if (byteArray == NULL) {
+                return 0;
+            } else {
+                jsize len = (*env)->GetArrayLength(env, byteArray);
+                if (len < numBytes) {
+                    numBytes = len; // don't get more bytes than there are ..
+                }
+                (*env)->GetByteArrayRegion(env, byteArray,
+                                           0, numBytes, (jbyte*)destBuffer);
+                return numBytes;
+            }
         }
     } /* Do we have a cache hit? */
       else if (scalerInfo->fontDataOffset <= offset &&
         scalerInfo->fontDataOffset + scalerInfo->fontDataLength >=
                                                          offset + numBytes)
@@ -198,15 +238,66 @@
         bBuffer = scalerInfo->directBuffer;
         bread = (*env)->CallIntMethod(env, scalerInfo->font2D,
                                       sunFontIDs.ttReadBlockMID,
                                       bBuffer, offset,
                                       scalerInfo->fontDataLength);
+        if (bread <= 0) {
+            return 0;
+        } else if (bread < numBytes) {
+           numBytes = bread;
+        }
         memcpy(destBuffer, scalerInfo->fontData, numBytes);
         return numBytes;
     }
 }
 
+typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,
+                                     const FT_String*  module_name,
+                                     const FT_String*  property_name,
+                                     const void*       value );
+
+/**
+ * Prefer the older v35 freetype byte code interpreter.
+ */
+static void setInterpreterVersion(FT_Library library) {
+
+    char* props = getenv("FREETYPE_PROPERTIES");
+    int version = 35;
+    const char* module = "truetype";
+    const char* property = "interpreter-version";
+
+    /* If some one is setting this, don't override it */
+    if (props != NULL && strstr(property, props)) {
+        return;
+    }
+    /*
+     * FT_Property_Set was introduced in 2.4.11.
+     * Some older supported Linux OSes may not include it so look
+     * this up dynamically.
+     * And if its not available it doesn't matter, since the reason
+     * we need it dates from 2.7.
+     * On Windows & Mac the library is always bundled so it is safe
+     * to use directly in those cases.
+     */
+#if defined(_WIN32) || defined(__APPLE__)
+    FT_Property_Set(library, module, property, (void*)(&version));
+#else
+    void *lib = dlopen("libfreetype.so", RTLD_LOCAL|RTLD_LAZY);
+    if (lib == NULL) {
+        lib = dlopen("libfreetype.so.6", RTLD_LOCAL|RTLD_LAZY);
+        if (lib == NULL) {
+            return;
+        }
+    }
+    FT_Prop_Set_Func func = (FT_Prop_Set_Func)dlsym(lib, "FT_Property_Set");
+    if (func != NULL) {
+        func(library, module, property, (void*)(&version));
+    }
+    dlclose(lib);
+#endif
+}
+
 /*
  * Class:     sun_font_FreetypeFontScaler
  * Method:    initNativeScaler
  * Signature: (Lsun/font/Font2D;IIZI)J
  */
@@ -242,18 +333,18 @@
     error = FT_Init_FreeType(&scalerInfo->library);
     if (error) {
         free(scalerInfo);
         return 0;
     }
+    setInterpreterVersion(scalerInfo->library);
 
 #define TYPE1_FROM_JAVA        2
 
     error = 1; /* triggers memory freeing unless we clear it */
     if (type == TYPE1_FROM_JAVA) { /* TYPE1 */
         scalerInfo->fontData = (unsigned char*) malloc(filesize);
         scalerInfo->directBuffer = NULL;
-        scalerInfo->layoutTables = NULL;
         scalerInfo->fontDataLength = filesize;
 
         if (scalerInfo->fontData != NULL) {
             bBuffer = (*env)->NewDirectByteBuffer(env,
                                               scalerInfo->fontData,
@@ -379,21 +470,45 @@
         context->useSbits = 1;
     }
     return ptr_to_jlong(context);
 }
 
+// values used by FreeType (as of version 2.10.1) for italics transformation matrix in FT_GlyphSlot_Oblique
+#define FT_MATRIX_ONE 0x10000
+#define FT_MATRIX_OBLIQUE_XY 0x0366A
+
+static void setupTransform(FT_Matrix* target, FTScalerContext *context) {
+    FT_Matrix* transform = &context->transform;
+    if (context->doItalize) {
+        // we cannot use FT_GlyphSlot_Oblique as it doesn't work well with arbitrary transforms,
+        // so we add corresponding shear transform to the requested glyph transformation
+        target->xx = FT_MATRIX_ONE;
+        target->xy = FT_MATRIX_OBLIQUE_XY;
+        target->yx = 0;
+        target->yy = FT_MATRIX_ONE;
+        FT_Matrix_Multiply(transform, target);
+    } else {
+        target->xx = transform->xx;
+        target->xy = transform->xy;
+        target->yx = transform->yx;
+        target->yy = transform->yy;
+    }
+}
+
 static int setupFTContext(JNIEnv *env,
                           jobject font2D,
                           FTScalerInfo *scalerInfo,
                           FTScalerContext *context) {
+    FT_Matrix matrix;
     int errCode = 0;
 
     scalerInfo->env = env;
     scalerInfo->font2D = font2D;
 
     if (context != NULL) {
-        FT_Set_Transform(scalerInfo->face, &context->transform, NULL);
+        setupTransform(&matrix, context);
+        FT_Set_Transform(scalerInfo->face, &matrix, NULL);
 
         errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, 72, 72);
 
         if (errCode == 0) {
             errCode = FT_Activate_Size(scalerInfo->face->size);
@@ -403,14 +518,19 @@
     }
 
     return errCode;
 }
 
-/* ftsynth.c uses (0x10000, 0x06000, 0x0, 0x10000) matrix to get oblique
-   outline.  Therefore x coordinate will change by 0x06000*y.
-   Note that y coordinate does not change. */
-#define OBLIQUE_MODIFIER(y)  (context->doItalize ? ((y)*6/16) : 0)
+// using same values as for the transformation matrix
+#define OBLIQUE_MODIFIER(y)  (context->doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY/FT_MATRIX_ONE) : 0)
+
+/* FT_GlyphSlot_Embolden (ftsynth.c) uses FT_MulFix(units_per_EM, y_scale) / 24
+ * strength value when glyph format is FT_GLYPH_FORMAT_OUTLINE. This value has
+ * been taken from libfreetype version 2.6 and remain valid at least up to
+ * 2.9.1. */
+#define BOLD_MODIFIER(units_per_EM, y_scale) \
+    (context->doBold ? FT_MulFix(units_per_EM, y_scale) / 24 : 0)
 
 /*
  * Class:     sun_font_FreetypeFontScaler
  * Method:    getFontMetricsNative
  * Signature: (Lsun/font/Font2D;J)Lsun/font/StrikeMetrics;
@@ -493,11 +613,13 @@
                       (jlong) scalerInfo->face->size->metrics.y_scale))
                   + ay - dy;
     /* max advance */
     mx = (jfloat) FT26Dot6ToFloat(
                      scalerInfo->face->size->metrics.max_advance +
-                     OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height));
+                     OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +
+                     BOLD_MODIFIER(scalerInfo->face->units_per_EM,
+                             scalerInfo->face->size->metrics.y_scale));
     my = 0;
 
     metrics = (*env)->NewObject(env,
         sunFontIDs.strikeMetricsClass,
         sunFontIDs.strikeMetricsCtr,
@@ -508,10 +630,16 @@
         contextAwareMetricsX(mx, my), contextAwareMetricsY(mx, my));
 
     return metrics;
 }
 
+static jlong
+    getGlyphImageNativeInternal(
+        JNIEnv *env, jobject scaler, jobject font2D,
+        jlong pScalerContext, jlong pScaler, jint glyphCode,
+        jboolean renderImage);
+
 /*
  * Class:     sun_font_FreetypeFontScaler
  * Method:    getGlyphAdvanceNative
  * Signature: (Lsun/font/Font2D;JI)F
  */
@@ -519,33 +647,33 @@
 Java_sun_font_FreetypeFontScaler_getGlyphAdvanceNative(
         JNIEnv *env, jobject scaler, jobject font2D,
         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 
    /* This method is rarely used because requests for metrics are usually
-      coupled with request for bitmap and to large extend work can be reused
-      (to find out metrics we need to hint glyph).
-      So, we typically go through getGlyphImage code path.
-
-      For initial freetype implementation we delegate
-      all work to getGlyphImage but drop result image.
-      This is waste of work related to scan conversion and conversion from
-      freetype format to our format but for now this seems to be ok.
-
-      NB: investigate performance benefits of refactoring code
-      to avoid unnecesary work with bitmaps. */
+    * coupled with a request for the bitmap and to a large extent the
+    * work can be reused (to find out metrics we may need to hint the glyph).
+    * So, we typically go through the getGlyphImage code path.
+    * When we do get here, we need to pass a parameter which indicates
+    * that we don't need freetype to render the bitmap, and consequently
+    * don't need to allocate our own storage either.
+    * This is also important when enter here requesting metrics for sizes
+    * of text which a large size would be rejected for a bitmap but we
+    * still need the metrics.
+    */
 
     GlyphInfo *info;
-    jfloat advance;
+    jfloat advance = 0.0f;
     jlong image;
 
-    image = Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
-                 env, scaler, font2D, pScalerContext, pScaler, glyphCode);
+    image = getGlyphImageNativeInternal(
+          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);
     info = (GlyphInfo*) jlong_to_ptr(image);
 
-    advance = info->advanceX;
-
-    free(info);
+    if (info != NULL) {
+        advance = info->advanceX;
+        free(info);
+    }
 
     return advance;
 }
 
 /*
@@ -556,27 +684,26 @@
 JNIEXPORT void JNICALL
 Java_sun_font_FreetypeFontScaler_getGlyphMetricsNative(
         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
         jlong pScaler, jint glyphCode, jobject metrics) {
 
-     /* As initial implementation we delegate all work to getGlyphImage
-        but drop result image. This is clearly waste of resorces.
-
-        TODO: investigate performance benefits of refactoring code
-              by avoiding bitmap generation and conversion from FT
-              bitmap format. */
+     /* See the comments in getGlyphMetricsNative. They apply here too. */
      GlyphInfo *info;
 
-     jlong image = Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
+     jlong image = getGlyphImageNativeInternal(
                                  env, scaler, font2D,
-                                 pScalerContext, pScaler, glyphCode);
+                                 pScalerContext, pScaler, glyphCode, JNI_FALSE);
      info = (GlyphInfo*) jlong_to_ptr(image);
 
-     (*env)->SetFloatField(env, metrics, sunFontIDs.xFID, info->advanceX);
-     (*env)->SetFloatField(env, metrics, sunFontIDs.yFID, info->advanceY);
-
-     free(info);
+     if (info != NULL) {
+         (*env)->SetFloatField(env, metrics, sunFontIDs.xFID, info->advanceX);
+         (*env)->SetFloatField(env, metrics, sunFontIDs.yFID, info->advanceY);
+         free(info);
+     } else {
+         (*env)->SetFloatField(env, metrics, sunFontIDs.xFID, 0.0f);
+         (*env)->SetFloatField(env, metrics, sunFontIDs.yFID, 0.0f);
+     }
 }
 
 
 static GlyphInfo* getNullGlyphImage() {
     GlyphInfo *glyphInfo =  (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
@@ -679,20 +806,38 @@
         height -= 3;
     }
 }
 
 
+/* JDK does not use glyph images for fonts with a
+ * pixel size > 100 (see THRESHOLD in OutlineTextRenderer.java)
+ * so if the glyph bitmap image dimension is > 1024 pixels,
+ * something is up.
+ */
+#define MAX_GLYPH_DIM 1024
+
 /*
  * Class:     sun_font_FreetypeFontScaler
  * Method:    getGlyphImageNative
  * Signature: (Lsun/font/Font2D;JI)J
  */
 JNIEXPORT jlong JNICALL
 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
         JNIEnv *env, jobject scaler, jobject font2D,
         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 
+    return getGlyphImageNativeInternal(
+        env, scaler, font2D,
+        pScalerContext, pScaler, glyphCode, JNI_TRUE);
+}
+
+static jlong
+     getGlyphImageNativeInternal(
+        JNIEnv *env, jobject scaler, jobject font2D,
+        jlong pScalerContext, jlong pScaler, jint glyphCode,
+        jboolean renderImage) {
+
     int error, imageSize;
     UInt16 width, height;
     GlyphInfo *glyphInfo;
     int renderFlags = FT_LOAD_DEFAULT, target;
     FT_GlyphSlot ftglyph;
@@ -710,10 +855,21 @@
     if (error) {
         invalidateJavaScaler(env, scaler, scalerInfo);
         return ptr_to_jlong(getNullGlyphImage());
     }
 
+    /*
+     * When using Fractional metrics (linearly scaling advances) and
+     * greyscale antialiasing, disable hinting so that the glyph shapes
+     * are constant as size increases. This is good for animation as well
+     * as being compatible with what happened in earlier JDK versions
+     * which did not use freetype.
+     */
+    if (context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) {
+         renderFlags |= FT_LOAD_NO_HINTING;
+     }
+
     if (!context->useSbits) {
         renderFlags |= FT_LOAD_NO_BITMAP;
     }
 
     /* NB: in case of non identity transform
@@ -745,25 +901,40 @@
 
     /* apply styles */
     if (context->doBold) { /* if bold style */
         FT_GlyphSlot_Embolden(ftglyph);
     }
-    if (context->doItalize) { /* if oblique */
-        FT_GlyphSlot_Oblique(ftglyph);
-    }
 
     /* generate bitmap if it is not done yet
      e.g. if algorithmic styling is performed and style was added to outline */
-    if (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE) {
+    if (renderImage && (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE)) {
+        FT_BBox bbox;
+        FT_Outline_Get_CBox(&(ftglyph->outline), &bbox);
+        int w = (int)((bbox.xMax>>6)-(bbox.xMin>>6));
+        int h = (int)((bbox.yMax>>6)-(bbox.yMin>>6));
+        if (w > MAX_GLYPH_DIM || h > MAX_GLYPH_DIM) {
+            glyphInfo = getNullGlyphImage();
+            return ptr_to_jlong(glyphInfo);
+        }
         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
         if (error != 0) {
             return ptr_to_jlong(getNullGlyphImage());
         }
     }
 
-    width  = (UInt16) ftglyph->bitmap.width;
-    height = (UInt16) ftglyph->bitmap.rows;
+    if (renderImage) {
+        width  = (UInt16) ftglyph->bitmap.width;
+        height = (UInt16) ftglyph->bitmap.rows;
+            if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {
+              glyphInfo = getNullGlyphImage();
+              return ptr_to_jlong(glyphInfo);
+            }
+     } else {
+        width = 0;
+        height = 0;
+     }
+
 
     imageSize = width*height;
     glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);
     if (glyphInfo == NULL) {
         glyphInfo = getNullGlyphImage();
@@ -772,25 +943,28 @@
     glyphInfo->cellInfo  = NULL;
     glyphInfo->managed   = UNMANAGED_GLYPH;
     glyphInfo->rowBytes  = width;
     glyphInfo->width     = width;
     glyphInfo->height    = height;
-    glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;
-    glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;
 
-    if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
-        glyphInfo->width = width/3;
-    } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
-        glyphInfo->height = glyphInfo->height/3;
+    if (renderImage) {
+        glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;
+        glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;
+
+        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {
+            glyphInfo->width = width/3;
+        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
+            glyphInfo->height = glyphInfo->height/3;
+        }
     }
 
     if (context->fmType == TEXT_FM_ON) {
-        double advh = FTFixedToFloat(ftglyph->linearHoriAdvance);
+        float advh = FTFixedToFloat(ftglyph->linearHoriAdvance);
         glyphInfo->advanceX =
             (float) (advh * FTFixedToFloat(context->transform.xx));
         glyphInfo->advanceY =
-            (float) (advh * FTFixedToFloat(context->transform.xy));
+            (float) - (advh * FTFixedToFloat(context->transform.yx));
     } else {
         if (!ftglyph->advance.y) {
             glyphInfo->advanceX =
                 (float) FT26Dot6ToInt(ftglyph->advance.x);
             glyphInfo->advanceY = 0;
@@ -854,36 +1028,10 @@
     }
 
     return ptr_to_jlong(glyphInfo);
 }
 
-
-/*
- * Class:     sun_font_FreetypeFontScaler
- * Method:    getLayoutTableCacheNative
- * Signature: (J)J
- */
-JNIEXPORT jlong JNICALL
-Java_sun_font_FreetypeFontScaler_getLayoutTableCacheNative(
-        JNIEnv *env, jobject scaler, jlong pScaler) {
-    FTScalerInfo *scalerInfo = (FTScalerInfo*) jlong_to_ptr(pScaler);
-
-    if (scalerInfo == NULL) {
-        invalidateJavaScaler(env, scaler, scalerInfo);
-        return 0L;
-    }
-
-    // init layout table cache in font
-    // we're assuming the font is a file font and moreover it is Truetype font
-    // otherwise we shouldn't be able to get here...
-    if (scalerInfo->layoutTables == NULL) {
-        scalerInfo->layoutTables = newLayoutTableCache();
-    }
-
-    return ptr_to_jlong(scalerInfo->layoutTables);
-}
-
 /*
  * Class:     sun_font_FreetypeFontScaler
  * Method:    disposeNativeScaler
  * Signature: (J)V
  */
@@ -997,13 +1145,10 @@
 
     /* apply styles */
     if (context->doBold) { /* if bold style */
         FT_GlyphSlot_Embolden(ftglyph);
     }
-    if (context->doItalize) { /* if oblique */
-        FT_GlyphSlot_Oblique(ftglyph);
-    }
 
     FT_Outline_Translate(&ftglyph->outline,
                          FloatToF26Dot6(xpos),
                          -FloatToF26Dot6(ypos));
 

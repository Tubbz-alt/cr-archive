<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-color-cbdt-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cpal-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-colr-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  */
 24 
 25 #ifndef HB_OT_COLOR_COLR_TABLE_HH
 26 #define HB_OT_COLOR_COLR_TABLE_HH
 27 
<span class="line-modified"> 28 #include &quot;hb-open-type-private.hh&quot;</span>
 29 
 30 /*
 31  * COLR -- Color
 32  * https://docs.microsoft.com/en-us/typography/opentype/spec/colr
 33  */
 34 #define HB_OT_TAG_COLR HB_TAG(&#39;C&#39;,&#39;O&#39;,&#39;L&#39;,&#39;R&#39;)
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 struct LayerRecord
 41 {
<span class="line-modified"> 42   friend struct COLR;</span>
<span class="line-removed"> 43 </span>
<span class="line-removed"> 44   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 45   {
 46     TRACE_SANITIZE (this);
 47     return_trace (c-&gt;check_struct (this));
 48   }
 49 
<span class="line-modified"> 50   protected:</span>
<span class="line-modified"> 51   GlyphID       glyphid;        /* Glyph ID of layer glyph */</span>
<span class="line-modified"> 52   HBUINT16      colorIdx;       /* Index value to use with a selected color palette */</span>









 53   public:
 54   DEFINE_SIZE_STATIC (4);
 55 };
 56 
 57 struct BaseGlyphRecord
 58 {
<span class="line-modified"> 59   friend struct COLR;</span>

 60 
<span class="line-modified"> 61   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 62   {
 63     TRACE_SANITIZE (this);
 64     return_trace (likely (c-&gt;check_struct (this)));
 65   }
 66 
<span class="line-modified"> 67   inline int cmp (hb_codepoint_t g) const {</span>
<span class="line-modified"> 68     return g &lt; glyphid ? -1 : g &gt; glyphid ? 1 : 0;</span>
<span class="line-modified"> 69   }</span>
<span class="line-modified"> 70 </span>
<span class="line-modified"> 71   protected:</span>
<span class="line-modified"> 72   GlyphID       glyphid;        /* Glyph ID of reference glyph */</span>
<span class="line-modified"> 73   HBUINT16      firstLayerIdx;  /* Index to the layer record */</span>
<span class="line-modified"> 74   HBUINT16      numLayers;      /* Number of color layers associated with this glyph */</span>

 75   public:
 76   DEFINE_SIZE_STATIC (6);
 77 };
 78 
<span class="line-removed"> 79 static int compare_bgr (const void *pa, const void *pb)</span>
<span class="line-removed"> 80 {</span>
<span class="line-removed"> 81   const hb_codepoint_t *a = (const hb_codepoint_t *) pa;</span>
<span class="line-removed"> 82   const BaseGlyphRecord *b = (const BaseGlyphRecord *) pb;</span>
<span class="line-removed"> 83   return b-&gt;cmp (*a);</span>
<span class="line-removed"> 84 }</span>
<span class="line-removed"> 85 </span>
 86 struct COLR
 87 {
<span class="line-modified"> 88   static const hb_tag_t tableTag = HB_OT_TAG_COLR;</span>
 89 
<span class="line-modified"> 90   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed"> 91   {</span>
<span class="line-removed"> 92     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 93     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed"> 94                           (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &amp;&amp;</span>
<span class="line-removed"> 95                           (this+layersZ).sanitize (c, numLayers)));</span>
<span class="line-removed"> 96   }</span>
 97 
<span class="line-modified"> 98   inline bool get_base_glyph_record (hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 99                                      unsigned int *first_layer /* OUT */,</span>
<span class="line-modified">100                                      unsigned int *num_layers /* OUT */) const</span>

101   {
<span class="line-modified">102     const BaseGlyphRecord* record;</span>
<span class="line-removed">103     record = (BaseGlyphRecord *) bsearch (&amp;glyph_id, &amp;(this+baseGlyphsZ), numBaseGlyphs,</span>
<span class="line-removed">104                                           sizeof (BaseGlyphRecord), compare_bgr);</span>
<span class="line-removed">105     if (unlikely (!record))</span>
<span class="line-removed">106       return false;</span>
<span class="line-removed">107 </span>
<span class="line-removed">108     *first_layer = record-&gt;firstLayerIdx;</span>
<span class="line-removed">109     *num_layers = record-&gt;numLayers;</span>
<span class="line-removed">110     return true;</span>
<span class="line-removed">111   }</span>
112 
<span class="line-modified">113   inline bool get_layer_record (unsigned int record,</span>
<span class="line-modified">114                                 hb_codepoint_t *glyph_id /* OUT */,</span>
<span class="line-modified">115                                 unsigned int *palette_index /* OUT */) const</span>
<span class="line-modified">116   {</span>
<span class="line-removed">117     if (unlikely (record &gt;= numLayers))</span>
118     {
<span class="line-modified">119       *glyph_id = 0;</span>
<span class="line-modified">120       *palette_index = 0xFFFF;</span>
<span class="line-modified">121       return false;</span>




122     }
<span class="line-modified">123     const LayerRecord &amp;layer = (this+layersZ)[record];</span>
<span class="line-modified">124     *glyph_id = layer.glyphid;</span>
<span class="line-modified">125     *palette_index = layer.colorIdx;</span>
<span class="line-modified">126     return true;</span>





127   }
128 
129   protected:
<span class="line-modified">130   HBUINT16      version;        /* Table version number */</span>
<span class="line-modified">131   HBUINT16      numBaseGlyphs;  /* Number of Base Glyph Records */</span>
<span class="line-modified">132   LOffsetTo&lt;UnsizedArrayOf&lt;BaseGlyphRecord&gt; &gt;</span>
133                 baseGlyphsZ;    /* Offset to Base Glyph records. */
<span class="line-modified">134   LOffsetTo&lt;UnsizedArrayOf&lt;LayerRecord&gt; &gt;</span>
<span class="line-modified">135                 layersZ;        /* Offset to Layer Records */</span>
<span class="line-modified">136   HBUINT16      numLayers;      /* Number of Layer Records */</span>
137   public:
138   DEFINE_SIZE_STATIC (14);
139 };
140 
141 } /* namespace OT */
142 
143 
144 #endif /* HB_OT_COLOR_COLR_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  */
 24 
 25 #ifndef HB_OT_COLOR_COLR_TABLE_HH
 26 #define HB_OT_COLOR_COLR_TABLE_HH
 27 
<span class="line-modified"> 28 #include &quot;hb-open-type.hh&quot;</span>
 29 
 30 /*
 31  * COLR -- Color
 32  * https://docs.microsoft.com/en-us/typography/opentype/spec/colr
 33  */
 34 #define HB_OT_TAG_COLR HB_TAG(&#39;C&#39;,&#39;O&#39;,&#39;L&#39;,&#39;R&#39;)
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 struct LayerRecord
 41 {
<span class="line-modified"> 42   bool sanitize (hb_sanitize_context_t *c) const</span>


 43   {
 44     TRACE_SANITIZE (this);
 45     return_trace (c-&gt;check_struct (this));
 46   }
 47 
<span class="line-modified"> 48   public:</span>
<span class="line-modified"> 49   GlyphID       glyphId;        /* Glyph ID of layer glyph */</span>
<span class="line-modified"> 50   Index         colorIdx;       /* Index value to use with a</span>
<span class="line-added"> 51                                  * selected color palette.</span>
<span class="line-added"> 52                                  * An index value of 0xFFFF</span>
<span class="line-added"> 53                                  * is a special case indicating</span>
<span class="line-added"> 54                                  * that the text foreground</span>
<span class="line-added"> 55                                  * color (defined by a</span>
<span class="line-added"> 56                                  * higher-level client) should</span>
<span class="line-added"> 57                                  * be used and shall not be</span>
<span class="line-added"> 58                                  * treated as actual index</span>
<span class="line-added"> 59                                  * into CPAL ColorRecord array. */</span>
 60   public:
 61   DEFINE_SIZE_STATIC (4);
 62 };
 63 
 64 struct BaseGlyphRecord
 65 {
<span class="line-modified"> 66   int cmp (hb_codepoint_t g) const</span>
<span class="line-added"> 67   { return g &lt; glyphId ? -1 : g &gt; glyphId ? 1 : 0; }</span>
 68 
<span class="line-modified"> 69   bool sanitize (hb_sanitize_context_t *c) const</span>
 70   {
 71     TRACE_SANITIZE (this);
 72     return_trace (likely (c-&gt;check_struct (this)));
 73   }
 74 
<span class="line-modified"> 75   public:</span>
<span class="line-modified"> 76   GlyphID       glyphId;        /* Glyph ID of reference glyph */</span>
<span class="line-modified"> 77   HBUINT16      firstLayerIdx;  /* Index (from beginning of</span>
<span class="line-modified"> 78                                  * the Layer Records) to the</span>
<span class="line-modified"> 79                                  * layer record. There will be</span>
<span class="line-modified"> 80                                  * numLayers consecutive entries</span>
<span class="line-modified"> 81                                  * for this base glyph. */</span>
<span class="line-modified"> 82   HBUINT16      numLayers;      /* Number of color layers</span>
<span class="line-added"> 83                                  * associated with this glyph */</span>
 84   public:
 85   DEFINE_SIZE_STATIC (6);
 86 };
 87 







 88 struct COLR
 89 {
<span class="line-modified"> 90   static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;</span>
 91 
<span class="line-modified"> 92   bool has_data () const { return numBaseGlyphs; }</span>






 93 
<span class="line-modified"> 94   unsigned int get_glyph_layers (hb_codepoint_t       glyph,</span>
<span class="line-modified"> 95                                  unsigned int         start_offset,</span>
<span class="line-modified"> 96                                  unsigned int        *count, /* IN/OUT.  May be NULL. */</span>
<span class="line-added"> 97                                  hb_ot_color_layer_t *layers /* OUT.     May be NULL. */) const</span>
 98   {
<span class="line-modified"> 99     const BaseGlyphRecord &amp;record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);</span>









100 
<span class="line-modified">101     hb_array_t&lt;const LayerRecord&gt; all_layers ((this+layersZ).arrayZ, numLayers);</span>
<span class="line-modified">102     hb_array_t&lt;const LayerRecord&gt; glyph_layers = all_layers.sub_array (record.firstLayerIdx,</span>
<span class="line-modified">103                                                                        record.numLayers);</span>
<span class="line-modified">104     if (count)</span>

105     {
<span class="line-modified">106       hb_array_t&lt;const LayerRecord&gt; segment_layers = glyph_layers.sub_array (start_offset, *count);</span>
<span class="line-modified">107       *count = segment_layers.length;</span>
<span class="line-modified">108       for (unsigned int i = 0; i &lt; segment_layers.length; i++)</span>
<span class="line-added">109       {</span>
<span class="line-added">110         layers[i].glyph = segment_layers.arrayZ[i].glyphId;</span>
<span class="line-added">111         layers[i].color_index = segment_layers.arrayZ[i].colorIdx;</span>
<span class="line-added">112       }</span>
113     }
<span class="line-modified">114     return glyph_layers.length;</span>
<span class="line-modified">115   }</span>
<span class="line-modified">116 </span>
<span class="line-modified">117   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">118   {</span>
<span class="line-added">119     TRACE_SANITIZE (this);</span>
<span class="line-added">120     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">121                           (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &amp;&amp;</span>
<span class="line-added">122                           (this+layersZ).sanitize (c, numLayers)));</span>
123   }
124 
125   protected:
<span class="line-modified">126   HBUINT16      version;        /* Table version number (starts at 0). */</span>
<span class="line-modified">127   HBUINT16      numBaseGlyphs;  /* Number of Base Glyph Records. */</span>
<span class="line-modified">128   LNNOffsetTo&lt;SortedUnsizedArrayOf&lt;BaseGlyphRecord&gt; &gt;</span>
129                 baseGlyphsZ;    /* Offset to Base Glyph records. */
<span class="line-modified">130   LNNOffsetTo&lt;UnsizedArrayOf&lt;LayerRecord&gt; &gt;</span>
<span class="line-modified">131                 layersZ;        /* Offset to Layer Records. */</span>
<span class="line-modified">132   HBUINT16      numLayers;      /* Number of Layer Records. */</span>
133   public:
134   DEFINE_SIZE_STATIC (14);
135 };
136 
137 } /* namespace OT */
138 
139 
140 #endif /* HB_OT_COLOR_COLR_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-color-cbdt-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cpal-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012,2013  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-myanmar.hh&quot;</span>
 28 
 29 
 30 /*
 31  * Myanmar shaper.
 32  */
 33 
 34 static const hb_tag_t
 35 basic_features[] =
 36 {
 37   /*
 38    * Basic features.
<a name="2" id="anc2"></a><span class="line-modified"> 39    * These features are applied in order, one at a time, after reordering.</span>
 40    */
 41   HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),
 42   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),
 43   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),
 44   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),
 45 };
 46 static const hb_tag_t
 47 other_features[] =
 48 {
 49   /*
 50    * Other features.
<a name="3" id="anc3"></a><span class="line-modified"> 51    * These features are applied all at once, after clearing syllables.</span>
 52    */
 53   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;),
 54   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;),
 55   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;),
 56   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;),
<a name="4" id="anc4"></a><span class="line-modified"> 57 };</span>
<span class="line-added"> 58 static const hb_tag_t</span>
<span class="line-added"> 59 positioning_features[] =</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61   /*</span>
<span class="line-added"> 62    * Positioning features.</span>
<span class="line-added"> 63    * We don&#39;t care about the types.</span>
<span class="line-added"> 64    */</span>
 65   HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;),
 66   /* Pre-release version of Windows 8 Myanmar font had abvm,blwm
 67    * features.  The released Windows 8 version of the font (as well
 68    * as the released spec) used &#39;mark&#39; instead.  The Windows 8
 69    * shaper however didn&#39;t apply &#39;mark&#39; but did apply &#39;mkmk&#39;.
 70    * Perhaps it applied abvm/blwm.  This was fixed in a Windows 8
 71    * update, so now it applies mark/mkmk.  We are guessing that
 72    * it still applies abvm/blwm too.
 73    */
 74   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;),
 75   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;),
 76 };
 77 
 78 static void
 79 setup_syllables (const hb_ot_shape_plan_t *plan,
 80                  hb_font_t *font,
 81                  hb_buffer_t *buffer);
 82 static void
<a name="5" id="anc5"></a><span class="line-modified"> 83 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 84          hb_font_t *font,</span>
<span class="line-modified"> 85          hb_buffer_t *buffer);</span>
 86 static void
<a name="6" id="anc6"></a><span class="line-modified"> 87 clear_syllables (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 88                  hb_font_t *font,</span>
<span class="line-modified"> 89                  hb_buffer_t *buffer);</span>
 90 
 91 static void
 92 collect_features_myanmar (hb_ot_shape_planner_t *plan)
 93 {
 94   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 95 
 96   /* Do this before any lookups have been applied. */
 97   map-&gt;add_gsub_pause (setup_syllables);
 98 
<a name="7" id="anc7"></a><span class="line-modified"> 99   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
100   /* The Indic specs do not require ccmp, but we apply it here since if
101    * there is a use of it, it&#39;s typically at the beginning. */
<a name="8" id="anc8"></a><span class="line-modified">102   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-added">103 </span>
104 
<a name="9" id="anc9"></a><span class="line-added">105   map-&gt;add_gsub_pause (reorder);</span>
106 
<a name="10" id="anc10"></a>
107   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (basic_features); i++)
108   {
<a name="11" id="anc11"></a><span class="line-modified">109     map-&gt;enable_feature (basic_features[i], F_MANUAL_ZWJ);</span>
110     map-&gt;add_gsub_pause (nullptr);
111   }
<a name="12" id="anc12"></a><span class="line-modified">112 </span>
<span class="line-added">113   map-&gt;add_gsub_pause (clear_syllables);</span>
<span class="line-added">114 </span>
115   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (other_features); i++)
<a name="13" id="anc13"></a><span class="line-modified">116     map-&gt;enable_feature (other_features[i], F_MANUAL_ZWJ);</span>
<span class="line-added">117 </span>
<span class="line-added">118   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (positioning_features); i++)</span>
<span class="line-added">119     map-&gt;enable_feature (positioning_features[i]);</span>
120 }
121 
122 static void
123 override_features_myanmar (hb_ot_shape_planner_t *plan)
124 {
<a name="14" id="anc14"></a><span class="line-modified">125   plan-&gt;map.disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
126 }
127 
128 
129 enum syllable_type_t {
130   consonant_syllable,
131   punctuation_cluster,
132   broken_cluster,
133   non_myanmar_cluster,
134 };
135 
136 #include &quot;hb-ot-shape-complex-myanmar-machine.hh&quot;
137 
138 
139 static void
140 setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,
141                    hb_buffer_t              *buffer,
142                    hb_font_t                *font HB_UNUSED)
143 {
144   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);
145   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);
146 
147   /* We cannot setup masks here.  We save information about characters
148    * and setup masks later on in a pause-callback. */
149 
150   unsigned int count = buffer-&gt;len;
151   hb_glyph_info_t *info = buffer-&gt;info;
152   for (unsigned int i = 0; i &lt; count; i++)
153     set_myanmar_properties (info[i]);
154 }
155 
156 static void
157 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
158                  hb_font_t *font HB_UNUSED,
159                  hb_buffer_t *buffer)
160 {
161   find_syllables (buffer);
162   foreach_syllable (buffer, start, end)
163     buffer-&gt;unsafe_to_break (start, end);
164 }
165 
166 static int
167 compare_myanmar_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
168 {
169   int a = pa-&gt;myanmar_position();
170   int b = pb-&gt;myanmar_position();
171 
172   return a &lt; b ? -1 : a == b ? 0 : +1;
173 }
174 
175 
176 /* Rules from:
177  * https://docs.microsoft.com/en-us/typography/script-development/myanmar */
178 
179 static void
180 initial_reordering_consonant_syllable (hb_buffer_t *buffer,
181                                        unsigned int start, unsigned int end)
182 {
183   hb_glyph_info_t *info = buffer-&gt;info;
184 
185   unsigned int base = end;
186   bool has_reph = false;
187 
188   {
189     unsigned int limit = start;
190     if (start + 3 &lt;= end &amp;&amp;
191         info[start  ].myanmar_category() == OT_Ra &amp;&amp;
192         info[start+1].myanmar_category() == OT_As &amp;&amp;
193         info[start+2].myanmar_category() == OT_H)
194     {
195       limit += 3;
196       base = start;
197       has_reph = true;
198     }
199 
200     {
201       if (!has_reph)
202         base = limit;
203 
204       for (unsigned int i = limit; i &lt; end; i++)
205         if (is_consonant (info[i]))
206         {
207           base = i;
208           break;
209         }
210     }
211   }
212 
213   /* Reorder! */
214   {
215     unsigned int i = start;
216     for (; i &lt; start + (has_reph ? 3 : 0); i++)
217       info[i].myanmar_position() = POS_AFTER_MAIN;
218     for (; i &lt; base; i++)
219       info[i].myanmar_position() = POS_PRE_C;
220     if (i &lt; end)
221     {
222       info[i].myanmar_position() = POS_BASE_C;
223       i++;
224     }
225     indic_position_t pos = POS_AFTER_MAIN;
226     /* The following loop may be ugly, but it implements all of
227      * Myanmar reordering! */
228     for (; i &lt; end; i++)
229     {
230       if (info[i].myanmar_category() == OT_MR) /* Pre-base reordering */
231       {
232         info[i].myanmar_position() = POS_PRE_C;
233         continue;
234       }
235       if (info[i].myanmar_position() &lt; POS_BASE_C) /* Left matra */
236       {
237         continue;
238       }
239       if (info[i].myanmar_category() == OT_VS)
240       {
241         info[i].myanmar_position() = info[i - 1].myanmar_position();
242         continue;
243       }
244 
245       if (pos == POS_AFTER_MAIN &amp;&amp; info[i].myanmar_category() == OT_VBlw)
246       {
247         pos = POS_BELOW_C;
248         info[i].myanmar_position() = pos;
249         continue;
250       }
251 
252       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() == OT_A)
253       {
254         info[i].myanmar_position() = POS_BEFORE_SUB;
255         continue;
256       }
257       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() == OT_VBlw)
258       {
259         info[i].myanmar_position() = pos;
260         continue;
261       }
262       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() != OT_A)
263       {
264         pos = POS_AFTER_SUB;
265         info[i].myanmar_position() = pos;
266         continue;
267       }
268       info[i].myanmar_position() = pos;
269     }
270   }
271 
272   /* Sit tight, rock &#39;n roll! */
273   buffer-&gt;sort (start, end, compare_myanmar_order);
274 }
275 
276 static void
<a name="15" id="anc15"></a><span class="line-modified">277 initial_reordering_syllable (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">278                              hb_face_t *face HB_UNUSED,</span>
279                              hb_buffer_t *buffer,
280                              unsigned int start, unsigned int end)
281 {
282   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
283   switch (syllable_type) {
284 
285     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
286     case consonant_syllable:
287       initial_reordering_consonant_syllable  (buffer, start, end);
288       break;
289 
290     case punctuation_cluster:
291     case non_myanmar_cluster:
292       break;
293   }
294 }
295 
296 static inline void
297 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
298                        hb_font_t *font,
299                        hb_buffer_t *buffer)
300 {
301   /* Note: This loop is extra overhead, but should not be measurable. */
302   bool has_broken_syllables = false;
303   unsigned int count = buffer-&gt;len;
304   hb_glyph_info_t *info = buffer-&gt;info;
305   for (unsigned int i = 0; i &lt; count; i++)
306     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
307     {
308       has_broken_syllables = true;
309       break;
310     }
311   if (likely (!has_broken_syllables))
312     return;
313 
314 
315   hb_codepoint_t dottedcircle_glyph;
316   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
317     return;
318 
319   hb_glyph_info_t dottedcircle = {0};
320   dottedcircle.codepoint = 0x25CCu;
321   set_myanmar_properties (dottedcircle);
322   dottedcircle.codepoint = dottedcircle_glyph;
323 
324   buffer-&gt;clear_output ();
325 
326   buffer-&gt;idx = 0;
327   unsigned int last_syllable = 0;
328   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
329   {
330     unsigned int syllable = buffer-&gt;cur().syllable();
331     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
332     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
333     {
334       last_syllable = syllable;
335 
336       hb_glyph_info_t ginfo = dottedcircle;
337       ginfo.cluster = buffer-&gt;cur().cluster;
338       ginfo.mask = buffer-&gt;cur().mask;
339       ginfo.syllable() = buffer-&gt;cur().syllable();
340 
341       buffer-&gt;output_info (ginfo);
342     }
343     else
344       buffer-&gt;next_glyph ();
345   }
<a name="16" id="anc16"></a>
346   buffer-&gt;swap_buffers ();
347 }
348 
349 static void
<a name="17" id="anc17"></a><span class="line-modified">350 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">351          hb_font_t *font,</span>
<span class="line-modified">352          hb_buffer_t *buffer)</span>
353 {
354   insert_dotted_circles (plan, font, buffer);
355 
356   foreach_syllable (buffer, start, end)
357     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<a name="18" id="anc18"></a><span class="line-added">358 </span>
<span class="line-added">359   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);</span>
<span class="line-added">360   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);</span>
361 }
362 
363 static void
<a name="19" id="anc19"></a><span class="line-modified">364 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">365                  hb_font_t *font HB_UNUSED,</span>
<span class="line-modified">366                  hb_buffer_t *buffer)</span>
367 {
368   hb_glyph_info_t *info = buffer-&gt;info;
369   unsigned int count = buffer-&gt;len;
<a name="20" id="anc20"></a>

370   for (unsigned int i = 0; i &lt; count; i++)
371     info[i].syllable() = 0;
<a name="21" id="anc21"></a>


372 }
373 
374 
<a name="22" id="anc22"></a><span class="line-modified">375 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar =</span>


376 {
<a name="23" id="anc23"></a><span class="line-modified">377   collect_features_myanmar,</span>
<span class="line-modified">378   override_features_myanmar,</span>
379   nullptr, /* data_create */
380   nullptr, /* data_destroy */
381   nullptr, /* preprocess_text */
382   nullptr, /* postprocess_glyphs */
<a name="24" id="anc24"></a><span class="line-modified">383   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,</span>
384   nullptr, /* decompose */
385   nullptr, /* compose */
<a name="25" id="anc25"></a><span class="line-modified">386   setup_masks_myanmar,</span>
<span class="line-modified">387   HB_TAG_NONE, /* gpos_tag */</span>
388   nullptr, /* reorder_marks */
<a name="26" id="anc26"></a><span class="line-modified">389   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,</span>
<span class="line-modified">390   false, /* fallback_position */</span>
391 };
392 
<a name="27" id="anc27"></a><span class="line-modified">393 </span>
<span class="line-added">394 /* Ugly Zawgyi encoding.</span>
<span class="line-added">395  * Disable all auto processing.</span>
<span class="line-added">396  * https://github.com/harfbuzz/harfbuzz/issues/1162 */</span>
<span class="line-added">397 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar_zawgyi =</span>
398 {
<a name="28" id="anc28"></a><span class="line-modified">399   nullptr, /* collect_features */</span>
<span class="line-modified">400   nullptr, /* override_features */</span>
401   nullptr, /* data_create */
402   nullptr, /* data_destroy */
403   nullptr, /* preprocess_text */
404   nullptr, /* postprocess_glyphs */
<a name="29" id="anc29"></a><span class="line-modified">405   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,</span>
406   nullptr, /* decompose */
407   nullptr, /* compose */
<a name="30" id="anc30"></a><span class="line-modified">408   nullptr, /* setup_masks */</span>
<span class="line-modified">409   HB_TAG_NONE, /* gpos_tag */</span>
410   nullptr, /* reorder_marks */
<a name="31" id="anc31"></a><span class="line-modified">411   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,</span>
412   false, /* fallback_position */
413 };
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 1998-2004  David Turner and Werner Lemberg
  3  * Copyright © 2004,2007,2009  Red Hat, Inc.
  4  * Copyright © 2011,2012  Google, Inc.
  5  *
  6  *  This is part of HarfBuzz, a text shaping library.
  7  *
  8  * Permission is hereby granted, without written agreement and without
  9  * license or royalty fees, to use, copy, modify, and distribute this
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
 27  * Google Author(s): Behdad Esfahbod
 28  */
 29 
 30 #ifndef HB_H_IN
 31 #error &quot;Include &lt;hb.h&gt; instead.&quot;
 32 #endif
 33 
 34 #ifndef HB_BUFFER_H
 35 #define HB_BUFFER_H
 36 
 37 #include &quot;hb-common.h&quot;
 38 #include &quot;hb-unicode.h&quot;
 39 #include &quot;hb-font.h&quot;
 40 
 41 HB_BEGIN_DECLS
 42 
 43 /**
 44  * hb_glyph_info_t:
 45  * @codepoint: either a Unicode code point (before shaping) or a glyph index
 46  *             (after shaping).
<a name="1" id="anc1"></a><span class="line-removed"> 47  * @mask:</span>
 48  * @cluster: the index of the character in the original text that corresponds
 49  *           to this #hb_glyph_info_t, or whatever the client passes to
 50  *           hb_buffer_add(). More than one #hb_glyph_info_t can have the same
 51  *           @cluster value, if they resulted from the same character (e.g. one
 52  *           to many glyph substitution), and when more than one character gets
 53  *           merged in the same glyph (e.g. many to one glyph substitution) the
 54  *           #hb_glyph_info_t will have the smallest cluster value of them.
 55  *           By default some characters are merged into the same cluster
 56  *           (e.g. combining marks have the same cluster as their bases)
 57  *           even if they are separate glyphs, hb_buffer_set_cluster_level()
 58  *           allow selecting more fine-grained cluster handling.
 59  *
 60  * The #hb_glyph_info_t is the structure that holds information about the
 61  * glyphs and their relation to input text.
<a name="2" id="anc2"></a><span class="line-removed"> 62  *</span>
 63  */
<a name="3" id="anc3"></a><span class="line-modified"> 64 typedef struct hb_glyph_info_t {</span>

 65   hb_codepoint_t codepoint;
<a name="4" id="anc4"></a><span class="line-modified"> 66   hb_mask_t      mask; /* Holds hb_glyph_flags_t after hb_shape(), plus other things. */</span>


 67   uint32_t       cluster;
 68 
 69   /*&lt; private &gt;*/
 70   hb_var_int_t   var1;
 71   hb_var_int_t   var2;
 72 } hb_glyph_info_t;
 73 
 74 /**
 75  * hb_glyph_flags_t:
 76  * @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the
 77  *                                 beginning of the cluster this glyph is part of,
 78  *                                 then both sides need to be re-shaped, as the
 79  *                                 result might be different.  On the flip side,
 80  *                                 it means that when this flag is not present,
 81  *                                 then it&#39;s safe to break the glyph-run at the
 82  *                                 beginning of this cluster, and the two sides
 83  *                                 represent the exact same result one would get
 84  *                                 if breaking input text at the beginning of
 85  *                                 this cluster and shaping the two sides
 86  *                                 separately.  This can be used to optimize
 87  *                                 paragraph layout, by avoiding re-shaping
 88  *                                 of each line after line-breaking, or limiting
 89  *                                 the reshaping to a small piece around the
 90  *                                 breaking point only.
<a name="5" id="anc5"></a>


 91  */
 92 typedef enum { /*&lt; flags &gt;*/
 93   HB_GLYPH_FLAG_UNSAFE_TO_BREAK         = 0x00000001,
 94 
 95   HB_GLYPH_FLAG_DEFINED                 = 0x00000001 /* OR of all defined flags */
 96 } hb_glyph_flags_t;
 97 
 98 HB_EXTERN hb_glyph_flags_t
 99 hb_glyph_info_get_glyph_flags (const hb_glyph_info_t *info);
100 
101 #define hb_glyph_info_get_glyph_flags(info) \
102         ((hb_glyph_flags_t) ((unsigned int) (info)-&gt;mask &amp; HB_GLYPH_FLAG_DEFINED))
103 
104 
105 /**
106  * hb_glyph_position_t:
107  * @x_advance: how much the line advances after drawing this glyph when setting
108  *             text in horizontal direction.
109  * @y_advance: how much the line advances after drawing this glyph when setting
110  *             text in vertical direction.
111  * @x_offset: how much the glyph moves on the X-axis before drawing it, this
112  *            should not affect how much the line advances.
113  * @y_offset: how much the glyph moves on the Y-axis before drawing it, this
114  *            should not affect how much the line advances.
115  *
116  * The #hb_glyph_position_t is the structure that holds the positions of the
117  * glyph in both horizontal and vertical directions. All positions in
118  * #hb_glyph_position_t are relative to the current point.
119  *
120  */
121 typedef struct hb_glyph_position_t {
122   hb_position_t  x_advance;
123   hb_position_t  y_advance;
124   hb_position_t  x_offset;
125   hb_position_t  y_offset;
126 
127   /*&lt; private &gt;*/
128   hb_var_int_t   var;
129 } hb_glyph_position_t;
130 
131 /**
132  * hb_segment_properties_t:
133  * @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction().
134  * @script: the #hb_script_t of the buffer, see hb_buffer_set_script().
135  * @language: the #hb_language_t of the buffer, see hb_buffer_set_language().
136  *
137  * The structure that holds various text properties of an #hb_buffer_t. Can be
138  * set and retrieved using hb_buffer_set_segment_properties() and
139  * hb_buffer_get_segment_properties(), respectively.
140  */
141 typedef struct hb_segment_properties_t {
142   hb_direction_t  direction;
143   hb_script_t     script;
144   hb_language_t   language;
145   /*&lt; private &gt;*/
146   void           *reserved1;
147   void           *reserved2;
148 } hb_segment_properties_t;
149 
150 #define HB_SEGMENT_PROPERTIES_DEFAULT {HB_DIRECTION_INVALID, \
151                                        HB_SCRIPT_INVALID, \
152                                        HB_LANGUAGE_INVALID, \
153                                        (void *) 0, \
154                                        (void *) 0}
155 
156 HB_EXTERN hb_bool_t
157 hb_segment_properties_equal (const hb_segment_properties_t *a,
158                              const hb_segment_properties_t *b);
159 
160 HB_EXTERN unsigned int
161 hb_segment_properties_hash (const hb_segment_properties_t *p);
162 
163 
164 
165 /**
166  * hb_buffer_t:
167  *
168  * The main structure holding the input text and its properties before shaping,
169  * and output glyphs and their information after shaping.
170  */
171 
172 typedef struct hb_buffer_t hb_buffer_t;
173 
174 HB_EXTERN hb_buffer_t *
175 hb_buffer_create (void);
176 
177 HB_EXTERN hb_buffer_t *
178 hb_buffer_get_empty (void);
179 
180 HB_EXTERN hb_buffer_t *
181 hb_buffer_reference (hb_buffer_t *buffer);
182 
183 HB_EXTERN void
184 hb_buffer_destroy (hb_buffer_t *buffer);
185 
186 HB_EXTERN hb_bool_t
187 hb_buffer_set_user_data (hb_buffer_t        *buffer,
188                          hb_user_data_key_t *key,
189                          void *              data,
190                          hb_destroy_func_t   destroy,
191                          hb_bool_t           replace);
192 
193 HB_EXTERN void *
194 hb_buffer_get_user_data (hb_buffer_t        *buffer,
195                          hb_user_data_key_t *key);
196 
197 
198 /**
199  * hb_buffer_content_type_t:
200  * @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer.
201  * @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping).
202  * @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping).
203  */
204 typedef enum {
205   HB_BUFFER_CONTENT_TYPE_INVALID = 0,
206   HB_BUFFER_CONTENT_TYPE_UNICODE,
207   HB_BUFFER_CONTENT_TYPE_GLYPHS
208 } hb_buffer_content_type_t;
209 
210 HB_EXTERN void
211 hb_buffer_set_content_type (hb_buffer_t              *buffer,
212                             hb_buffer_content_type_t  content_type);
213 
214 HB_EXTERN hb_buffer_content_type_t
215 hb_buffer_get_content_type (hb_buffer_t *buffer);
216 
217 
218 HB_EXTERN void
219 hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
220                              hb_unicode_funcs_t *unicode_funcs);
221 
222 HB_EXTERN hb_unicode_funcs_t *
223 hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer);
224 
225 HB_EXTERN void
226 hb_buffer_set_direction (hb_buffer_t    *buffer,
227                          hb_direction_t  direction);
228 
229 HB_EXTERN hb_direction_t
230 hb_buffer_get_direction (hb_buffer_t *buffer);
231 
232 HB_EXTERN void
233 hb_buffer_set_script (hb_buffer_t *buffer,
234                       hb_script_t  script);
235 
236 HB_EXTERN hb_script_t
237 hb_buffer_get_script (hb_buffer_t *buffer);
238 
239 HB_EXTERN void
240 hb_buffer_set_language (hb_buffer_t   *buffer,
241                         hb_language_t  language);
242 
243 
244 HB_EXTERN hb_language_t
245 hb_buffer_get_language (hb_buffer_t *buffer);
246 
247 HB_EXTERN void
248 hb_buffer_set_segment_properties (hb_buffer_t *buffer,
249                                   const hb_segment_properties_t *props);
250 
251 HB_EXTERN void
252 hb_buffer_get_segment_properties (hb_buffer_t *buffer,
253                                   hb_segment_properties_t *props);
254 
255 HB_EXTERN void
256 hb_buffer_guess_segment_properties (hb_buffer_t *buffer);
257 
258 
259 /**
260  * hb_buffer_flags_t:
261  * @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.
262  * @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning
263  *                      of text paragraph can be applied to this buffer. Should usually
264  *                      be set, unless you are passing to the buffer only part
265  *                      of the text without the full context.
266  * @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text
267  *                      paragraph can be applied to this buffer, similar to
268  *                      @HB_BUFFER_FLAG_BOT.
269  * @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:
270  *                      flag indication that character with Default_Ignorable
271  *                      Unicode property should use the corresponding glyph
272  *                      from the font, instead of hiding them (done by
273  *                      replacing them with the space glyph and zeroing the
274  *                      advance width.)  This flag takes precedence over
275  *                      @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES.
276  * @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES:
277  *                      flag indication that character with Default_Ignorable
278  *                      Unicode property should be removed from glyph string
279  *                      instead of hiding them (done by replacing them with the
280  *                      space glyph and zeroing the advance width.)
281  *                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes
282  *                      precedence over this flag. Since: 1.8.0
283  *
284  * Since: 0.9.20
285  */
286 typedef enum { /*&lt; flags &gt;*/
287   HB_BUFFER_FLAG_DEFAULT                        = 0x00000000u,
288   HB_BUFFER_FLAG_BOT                            = 0x00000001u, /* Beginning-of-text */
289   HB_BUFFER_FLAG_EOT                            = 0x00000002u, /* End-of-text */
290   HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES    = 0x00000004u,
291   HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES      = 0x00000008u
292 } hb_buffer_flags_t;
293 
294 HB_EXTERN void
295 hb_buffer_set_flags (hb_buffer_t       *buffer,
296                      hb_buffer_flags_t  flags);
297 
298 HB_EXTERN hb_buffer_flags_t
299 hb_buffer_get_flags (hb_buffer_t *buffer);
300 
<a name="6" id="anc6"></a><span class="line-modified">301 /*</span>








302  * Since: 0.9.42
303  */
304 typedef enum {
305   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES    = 0,
306   HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS   = 1,
307   HB_BUFFER_CLUSTER_LEVEL_CHARACTERS            = 2,
308   HB_BUFFER_CLUSTER_LEVEL_DEFAULT = HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES
309 } hb_buffer_cluster_level_t;
310 
311 HB_EXTERN void
312 hb_buffer_set_cluster_level (hb_buffer_t               *buffer,
313                              hb_buffer_cluster_level_t  cluster_level);
314 
315 HB_EXTERN hb_buffer_cluster_level_t
316 hb_buffer_get_cluster_level (hb_buffer_t *buffer);
317 
318 /**
319  * HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT:
320  *
321  * The default code point for replacing invalid characters in a given encoding.
322  * Set to U+FFFD REPLACEMENT CHARACTER.
323  *
324  * Since: 0.9.31
325  */
326 #define HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT 0xFFFDu
327 
328 HB_EXTERN void
329 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
330                                      hb_codepoint_t  replacement);
331 
332 HB_EXTERN hb_codepoint_t
333 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer);
334 
<a name="7" id="anc7"></a>






335 
336 HB_EXTERN void
337 hb_buffer_reset (hb_buffer_t *buffer);
338 
339 HB_EXTERN void
340 hb_buffer_clear_contents (hb_buffer_t *buffer);
341 
342 HB_EXTERN hb_bool_t
343 hb_buffer_pre_allocate (hb_buffer_t  *buffer,
344                         unsigned int  size);
345 
346 
347 HB_EXTERN hb_bool_t
348 hb_buffer_allocation_successful (hb_buffer_t  *buffer);
349 
350 HB_EXTERN void
351 hb_buffer_reverse (hb_buffer_t *buffer);
352 
353 HB_EXTERN void
354 hb_buffer_reverse_range (hb_buffer_t *buffer,
355                          unsigned int start, unsigned int end);
356 
357 HB_EXTERN void
358 hb_buffer_reverse_clusters (hb_buffer_t *buffer);
359 
360 
361 /* Filling the buffer in */
362 
363 HB_EXTERN void
364 hb_buffer_add (hb_buffer_t    *buffer,
365                hb_codepoint_t  codepoint,
366                unsigned int    cluster);
367 
368 HB_EXTERN void
369 hb_buffer_add_utf8 (hb_buffer_t  *buffer,
370                     const char   *text,
371                     int           text_length,
372                     unsigned int  item_offset,
373                     int           item_length);
374 
375 HB_EXTERN void
376 hb_buffer_add_utf16 (hb_buffer_t    *buffer,
377                      const uint16_t *text,
378                      int             text_length,
379                      unsigned int    item_offset,
380                      int             item_length);
381 
382 HB_EXTERN void
383 hb_buffer_add_utf32 (hb_buffer_t    *buffer,
384                      const uint32_t *text,
385                      int             text_length,
386                      unsigned int    item_offset,
387                      int             item_length);
388 
389 HB_EXTERN void
390 hb_buffer_add_latin1 (hb_buffer_t   *buffer,
391                       const uint8_t *text,
392                       int            text_length,
393                       unsigned int   item_offset,
394                       int            item_length);
395 
396 HB_EXTERN void
397 hb_buffer_add_codepoints (hb_buffer_t          *buffer,
398                           const hb_codepoint_t *text,
399                           int                   text_length,
400                           unsigned int          item_offset,
401                           int                   item_length);
402 
403 HB_EXTERN void
404 hb_buffer_append (hb_buffer_t *buffer,
405                   hb_buffer_t *source,
406                   unsigned int start,
407                   unsigned int end);
408 
409 HB_EXTERN hb_bool_t
410 hb_buffer_set_length (hb_buffer_t  *buffer,
411                       unsigned int  length);
412 
413 HB_EXTERN unsigned int
414 hb_buffer_get_length (hb_buffer_t *buffer);
415 
416 /* Getting glyphs out of the buffer */
417 
418 HB_EXTERN hb_glyph_info_t *
419 hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,
420                            unsigned int *length);
421 
422 HB_EXTERN hb_glyph_position_t *
423 hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,
424                                unsigned int *length);
425 
426 
427 HB_EXTERN void
428 hb_buffer_normalize_glyphs (hb_buffer_t *buffer);
429 
430 
431 /*
432  * Serialize
433  */
434 
435 /**
436  * hb_buffer_serialize_flags_t:
437  * @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.
438  * @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.
439  * @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.
440  * @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.
441  * @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.
442  * @HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: serialize glyph flags. Since: 1.5.0
443  * @HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: do not serialize glyph advances,
444  *  glyph offsets will reflect absolute glyph positions. Since: 1.8.0
445  *
446  * Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().
447  *
448  * Since: 0.9.20
449  */
450 typedef enum { /*&lt; flags &gt;*/
451   HB_BUFFER_SERIALIZE_FLAG_DEFAULT              = 0x00000000u,
452   HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS          = 0x00000001u,
453   HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS         = 0x00000002u,
454   HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES       = 0x00000004u,
455   HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS        = 0x00000008u,
456   HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS          = 0x00000010u,
457   HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES          = 0x00000020u
458 } hb_buffer_serialize_flags_t;
459 
460 /**
461  * hb_buffer_serialize_format_t:
462  * @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format.
463  * @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format.
464  * @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format.
465  *
466  * The buffer serialization and de-serialization format used in
467  * hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().
468  *
469  * Since: 0.9.2
470  */
471 typedef enum {
472   HB_BUFFER_SERIALIZE_FORMAT_TEXT       = HB_TAG(&#39;T&#39;,&#39;E&#39;,&#39;X&#39;,&#39;T&#39;),
473   HB_BUFFER_SERIALIZE_FORMAT_JSON       = HB_TAG(&#39;J&#39;,&#39;S&#39;,&#39;O&#39;,&#39;N&#39;),
474   HB_BUFFER_SERIALIZE_FORMAT_INVALID    = HB_TAG_NONE
475 } hb_buffer_serialize_format_t;
476 
477 HB_EXTERN hb_buffer_serialize_format_t
478 hb_buffer_serialize_format_from_string (const char *str, int len);
479 
480 HB_EXTERN const char *
481 hb_buffer_serialize_format_to_string (hb_buffer_serialize_format_t format);
482 
483 HB_EXTERN const char **
484 hb_buffer_serialize_list_formats (void);
485 
486 HB_EXTERN unsigned int
487 hb_buffer_serialize_glyphs (hb_buffer_t *buffer,
488                             unsigned int start,
489                             unsigned int end,
490                             char *buf,
491                             unsigned int buf_size,
492                             unsigned int *buf_consumed,
493                             hb_font_t *font,
494                             hb_buffer_serialize_format_t format,
495                             hb_buffer_serialize_flags_t flags);
496 
497 HB_EXTERN hb_bool_t
498 hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,
499                               const char *buf,
500                               int buf_len,
501                               const char **end_ptr,
502                               hb_font_t *font,
503                               hb_buffer_serialize_format_t format);
504 
505 
506 /*
507  * Compare buffers
508  */
509 
510 typedef enum { /*&lt; flags &gt;*/
511   HB_BUFFER_DIFF_FLAG_EQUAL                     = 0x0000,
512 
513   /* Buffers with different content_type cannot be meaningfully compared
514    * in any further detail. */
515   HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH     = 0x0001,
516 
517   /* For buffers with differing length, the per-glyph comparison is not
518    * attempted, though we do still scan reference for dottedcircle / .notdef
519    * glyphs. */
520   HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH           = 0x0002,
521 
522   /* We want to know if dottedcircle / .notdef glyphs are present in the
523    * reference, as we may not care so much about other differences in this
524    * case. */
525   HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT            = 0x0004,
526   HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT     = 0x0008,
527 
528   /* If the buffers have the same length, we compare them glyph-by-glyph
529    * and report which aspect(s) of the glyph info/position are different. */
530   HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH        = 0x0010,
531   HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH          = 0x0020,
532   HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH      = 0x0040,
533   HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH         = 0x0080
534 
535 } hb_buffer_diff_flags_t;
536 
537 /* Compare the contents of two buffers, report types of differences. */
538 HB_EXTERN hb_buffer_diff_flags_t
539 hb_buffer_diff (hb_buffer_t *buffer,
540                 hb_buffer_t *reference,
541                 hb_codepoint_t dottedcircle_glyph,
542                 unsigned int position_fuzz);
543 
544 
545 /*
546  * Debugging.
547  */
548 
549 typedef hb_bool_t       (*hb_buffer_message_func_t)     (hb_buffer_t *buffer,
550                                                          hb_font_t   *font,
551                                                          const char  *message,
552                                                          void        *user_data);
553 
554 HB_EXTERN void
555 hb_buffer_set_message_func (hb_buffer_t *buffer,
556                             hb_buffer_message_func_t func,
557                             void *user_data, hb_destroy_func_t destroy);
558 
559 
560 HB_END_DECLS
561 
562 #endif /* HB_BUFFER_H */
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-khmer-machine.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-myanmar-machine.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,46 ***</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-ot-shape-complex-khmer-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout-private.hh&quot;</span>
  
  
  /*
   * Khmer shaper.
   */
  
<span class="line-modified">! struct feature_list_t {</span>
<span class="line-removed">-   hb_tag_t tag;</span>
<span class="line-removed">-   hb_ot_map_feature_flags_t flags;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- static const feature_list_t</span>
  khmer_features[] =
  {
    /*
     * Basic features.
<span class="line-modified">!    * These features are applied in order, one at a time, after initial_reordering.</span>
     */
<span class="line-modified">!   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified">!   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified">!   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified">!   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified">!   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_NONE},</span>
    /*
     * Other features.
<span class="line-modified">!    * These features are applied all at once, after final_reordering.</span>
<span class="line-modified">!    * Default Bengali font in Windows for example has intermixed</span>
<span class="line-modified">!    * lookups for init,pres,abvs,blws features.</span>
     */
<span class="line-removed">-   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed">-   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed">-   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed">-   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-removed">-   /* Positioning features, though we don&#39;t care about the types. */</span>
    {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
    {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
    {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
  };
  
<span class="line-new-header">--- 22,42 ---</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-ot-shape-complex-khmer.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout.hh&quot;</span>
  
  
  /*
   * Khmer shaper.
   */
  
<span class="line-modified">! static const hb_ot_map_feature_t</span>
  khmer_features[] =
  {
    /*
     * Basic features.
<span class="line-modified">!    * These features are applied in order, one at a time, after reordering.</span>
     */
<span class="line-modified">!   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified">!   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified">!   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified">!   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified">!   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_MANUAL_JOINERS},</span>
    /*
     * Other features.
<span class="line-modified">!    * These features are applied all at once after clearing syllables.</span>
<span class="line-modified">!    */</span>
<span class="line-modified">!   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * Positioning features.</span>
<span class="line-added">+    * We don&#39;t care about the types.</span>
     */
    {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
    {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
    {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,30 ***</span>
  
    _PRES,
    _ABVS,
    _BLWS,
    _PSTS,
    _DIST,
    _ABVM,
    _BLWM,
  
    KHMER_NUM_FEATURES,
<span class="line-modified">!   KHMER_BASIC_FEATURES = _PRES /* Don&#39;t forget to update this! */</span>
  };
  
  static void
  setup_syllables (const hb_ot_shape_plan_t *plan,
                   hb_font_t *font,
                   hb_buffer_t *buffer);
  static void
<span class="line-modified">! initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!                     hb_font_t *font,</span>
<span class="line-modified">!                     hb_buffer_t *buffer);</span>
<span class="line-removed">- static void</span>
<span class="line-removed">- final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">-                   hb_font_t *font,</span>
<span class="line-removed">-                   hb_buffer_t *buffer);</span>
  static void
  clear_syllables (const hb_ot_shape_plan_t *plan,
                   hb_font_t *font,
                   hb_buffer_t *buffer);
  
<span class="line-new-header">--- 73,27 ---</span>
  
    _PRES,
    _ABVS,
    _BLWS,
    _PSTS,
<span class="line-added">+ </span>
    _DIST,
    _ABVM,
    _BLWM,
  
    KHMER_NUM_FEATURES,
<span class="line-modified">!   KHMER_BASIC_FEATURES = _PRES, /* Don&#39;t forget to update this! */</span>
  };
  
  static void
  setup_syllables (const hb_ot_shape_plan_t *plan,
                   hb_font_t *font,
                   hb_buffer_t *buffer);
  static void
<span class="line-modified">! reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!          hb_font_t *font,</span>
<span class="line-modified">!          hb_buffer_t *buffer);</span>
  static void
  clear_syllables (const hb_ot_shape_plan_t *plan,
                   hb_font_t *font,
                   hb_buffer_t *buffer);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,60 ***</span>
  {
    hb_ot_map_builder_t *map = &amp;plan-&gt;map;
  
    /* Do this before any lookups have been applied. */
    map-&gt;add_gsub_pause (setup_syllables);
  
<span class="line-modified">!   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-modified">!   /* The Indic specs do not require ccmp, but we apply it here since if</span>
<span class="line-modified">!    * there is a use of it, it&#39;s typically at the beginning. */</span>
<span class="line-modified">!   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">! </span>
  
    unsigned int i = 0;
<span class="line-modified">!   map-&gt;add_gsub_pause (initial_reordering);</span>
<span class="line-modified">!   for (; i &lt; KHMER_BASIC_FEATURES; i++) {</span>
<span class="line-removed">-     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">-     map-&gt;add_gsub_pause (nullptr);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   map-&gt;add_gsub_pause (final_reordering);</span>
<span class="line-removed">-   for (; i &lt; KHMER_NUM_FEATURES; i++) {</span>
<span class="line-removed">-     map-&gt;add_feature (khmer_features[i].tag, 1, khmer_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
  
    map-&gt;add_gsub_pause (clear_syllables);
  }
  
  static void
  override_features_khmer (hb_ot_shape_planner_t *plan)
  {
    /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
    if (hb_options ().uniscribe_bug_compatible)
    {
<span class="line-modified">!     plan-&gt;map.add_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), 0, F_GLOBAL);</span>
    }
  
<span class="line-modified">!   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
  }
  
  
  struct would_substitute_feature_t
  {
<span class="line-modified">!   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
    {
      zero_context = zero_context_;
      map-&gt;get_stage_lookups (0/*GSUB*/,
                              map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
                              &amp;lookups, &amp;count);
    }
  
<span class="line-modified">!   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">!                                 unsigned int          glyphs_count,</span>
<span class="line-modified">!                                 hb_face_t            *face) const</span>
    {
      for (unsigned int i = 0; i &lt; count; i++)
        if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
          return true;
      return false;
<span class="line-new-header">--- 102,68 ---</span>
  {
    hb_ot_map_builder_t *map = &amp;plan-&gt;map;
  
    /* Do this before any lookups have been applied. */
    map-&gt;add_gsub_pause (setup_syllables);
<span class="line-added">+   map-&gt;add_gsub_pause (reorder);</span>
  
<span class="line-modified">!   /* Testing suggests that Uniscribe does NOT pause between basic</span>
<span class="line-modified">!    * features.  Test with KhmerUI.ttf and the following three</span>
<span class="line-modified">!    * sequences:</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   U+1789,U+17BC</span>
<span class="line-added">+    *   U+1789,U+17D2,U+1789</span>
<span class="line-added">+    *   U+1789,U+17D2,U+1789,U+17BC</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/974</span>
<span class="line-added">+    */</span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
  
    unsigned int i = 0;
<span class="line-modified">!   for (; i &lt; KHMER_BASIC_FEATURES; i++)</span>
<span class="line-modified">!     map-&gt;add_feature (khmer_features[i]);</span>
  
    map-&gt;add_gsub_pause (clear_syllables);
<span class="line-added">+ </span>
<span class="line-added">+   for (; i &lt; KHMER_NUM_FEATURES; i++)</span>
<span class="line-added">+     map-&gt;add_feature (khmer_features[i]);</span>
  }
  
  static void
  override_features_khmer (hb_ot_shape_planner_t *plan)
  {
<span class="line-added">+   hb_ot_map_builder_t *map = &amp;plan-&gt;map;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Khmer spec has &#39;clig&#39; as part of required shaping features:</span>
<span class="line-added">+    * &quot;Apply feature &#39;clig&#39; to form ligatures that are desired for</span>
<span class="line-added">+    * typographical correctness.&quot;, hence in overrides... */</span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
<span class="line-added">+ </span>
    /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
    if (hb_options ().uniscribe_bug_compatible)
    {
<span class="line-modified">!     map-&gt;disable_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;));</span>
    }
  
<span class="line-modified">!   map-&gt;disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
  }
  
  
  struct would_substitute_feature_t
  {
<span class="line-modified">!   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
    {
      zero_context = zero_context_;
      map-&gt;get_stage_lookups (0/*GSUB*/,
                              map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
                              &amp;lookups, &amp;count);
    }
  
<span class="line-modified">!   bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">!                          unsigned int          glyphs_count,</span>
<span class="line-modified">!                          hb_face_t            *face) const</span>
    {
      for (unsigned int i = 0; i &lt; count; i++)
        if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
          return true;
      return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,13 ***</span>
    bool zero_context;
  };
  
  struct khmer_shape_plan_t
  {
<span class="line-modified">!   ASSERT_POD ();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
    {
      hb_codepoint_t glyph = virama_glyph;
      if (unlikely (virama_glyph == (hb_codepoint_t) -1))
      {
        if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
<span class="line-new-header">--- 175,11 ---</span>
    bool zero_context;
  };
  
  struct khmer_shape_plan_t
  {
<span class="line-modified">!   bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
    {
      hb_codepoint_t glyph = virama_glyph;
      if (unlikely (virama_glyph == (hb_codepoint_t) -1))
      {
        if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,11 ***</span>
  setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,
                     hb_buffer_t              *buffer,
                     hb_font_t                *font HB_UNUSED)
  {
    HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);
<span class="line-removed">-   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_position);</span>
  
    /* We cannot setup masks here.  We save information about characters
     * and setup masks later on in a pause-callback. */
  
    unsigned int count = buffer-&gt;len;
<span class="line-new-header">--- 240,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 262,180 ***</span>
    find_syllables (buffer);
    foreach_syllable (buffer, start, end)
      buffer-&gt;unsafe_to_break (start, end);
  }
  
<span class="line-removed">- static int</span>
<span class="line-removed">- compare_khmer_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   int a = pa-&gt;khmer_position();</span>
<span class="line-removed">-   int b = pb-&gt;khmer_position();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return a &lt; b ? -1 : a == b ? 0 : +1;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  
  /* Rules from:
   * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
  
  static void
<span class="line-modified">! initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!                                        hb_face_t *face,</span>
<span class="line-modified">!                                        hb_buffer_t *buffer,</span>
<span class="line-modified">!                                        unsigned int start, unsigned int end)</span>
  {
    const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
    hb_glyph_info_t *info = buffer-&gt;info;
  
<span class="line-modified">!   /* 1. Khmer shaping assumes that a syllable will begin with a Cons, IndV, or Number. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* The first consonant is always the base. */</span>
<span class="line-removed">-   unsigned int base = start;</span>
<span class="line-removed">-   info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Mark all subsequent consonants as below. */</span>
<span class="line-removed">-   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">-     if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">-       info[i].khmer_position() = POS_BELOW_C;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Mark final consonants.  A final consonant is one appearing after a matra,</span>
<span class="line-removed">-    * like in Khmer. */</span>
<span class="line-removed">-   for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">-     if (info[i].khmer_category() == OT_M) {</span>
<span class="line-removed">-       for (unsigned int j = i + 1; j &lt; end; j++)</span>
<span class="line-removed">-         if (is_consonant_or_vowel (info[j])) {</span>
<span class="line-removed">-           info[j].khmer_position() = POS_FINAL_C;</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Attach misc marks to previous char to move with them. */</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     khmer_position_t last_pos = POS_START;</span>
<span class="line-removed">-     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if ((FLAG_UNSAFE (info[i].khmer_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_Coeng))))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         info[i].khmer_position() = last_pos;</span>
<span class="line-removed">-         if (unlikely (info[i].khmer_category() == OT_Coeng &amp;&amp;</span>
<span class="line-removed">-                       info[i].khmer_position() == POS_PRE_M))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           /*</span>
<span class="line-removed">-            * Uniscribe doesn&#39;t move the Halant with Left Matra.</span>
<span class="line-removed">-            * TEST: U+092B,U+093F,U+094DE</span>
<span class="line-removed">-            * We follow.  This is important for the Sinhala</span>
<span class="line-removed">-            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA</span>
<span class="line-removed">-            * where U+0DD9 is a left matra and U+0DCA is the virama.</span>
<span class="line-removed">-            * We don&#39;t want to move the virama with the left matra.</span>
<span class="line-removed">-            * TEST: U+0D9A,U+0DDA</span>
<span class="line-removed">-            */</span>
<span class="line-removed">-           for (unsigned int j = i; j &gt; start; j--)</span>
<span class="line-removed">-             if (info[j - 1].khmer_position() != POS_PRE_M) {</span>
<span class="line-removed">-               info[i].khmer_position() = info[j - 1].khmer_position();</span>
<span class="line-removed">-               break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       } else if (info[i].khmer_position() != POS_SMVD) {</span>
<span class="line-removed">-         last_pos = (khmer_position_t) info[i].khmer_position();</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   /* For post-base consonants let them own anything before them</span>
<span class="line-removed">-    * since the last consonant or matra. */</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     unsigned int last = base;</span>
<span class="line-removed">-     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">-       if (is_consonant_or_vowel (info[i]))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         for (unsigned int j = last + 1; j &lt; i; j++)</span>
<span class="line-removed">-           if (info[j].khmer_position() &lt; POS_SMVD)</span>
<span class="line-removed">-             info[j].khmer_position() = info[i].khmer_position();</span>
<span class="line-removed">-         last = i;</span>
<span class="line-removed">-       } else if (info[i].khmer_category() == OT_M)</span>
<span class="line-removed">-         last = i;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
    {
<span class="line-removed">-     /* Use syllable() for sort accounting temporarily. */</span>
<span class="line-removed">-     unsigned int syllable = info[start].syllable();</span>
<span class="line-removed">-     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">-       info[i].syllable() = i - start;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Sit tight, rock &#39;n roll! */</span>
<span class="line-removed">-     hb_stable_sort (info + start, end - start, compare_khmer_order);</span>
<span class="line-removed">-     /* Find base again */</span>
<span class="line-removed">-     base = end;</span>
<span class="line-removed">-     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">-       if (info[i].khmer_position() == POS_BASE_C)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         base = i;</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (unlikely (end - start &gt;= 127))</span>
<span class="line-removed">-       buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-       /* Note!  syllable() is a one-byte field. */</span>
<span class="line-removed">-       for (unsigned int i = base; i &lt; end; i++)</span>
<span class="line-removed">-         if (info[i].syllable() != 255)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           unsigned int max = i;</span>
<span class="line-removed">-           unsigned int j = start + info[i].syllable();</span>
<span class="line-removed">-           while (j != i)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             max = MAX (max, j);</span>
<span class="line-removed">-             unsigned int next = start + info[j].syllable();</span>
<span class="line-removed">-             info[j].syllable() = 255; /* So we don&#39;t process j later again. */</span>
<span class="line-removed">-             j = next;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           if (i != max)</span>
<span class="line-removed">-             buffer-&gt;merge_clusters (i, max + 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Put syllable back in. */</span>
<span class="line-removed">-     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">-       info[i].syllable() = syllable;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Setup masks now */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     hb_mask_t mask;</span>
<span class="line-removed">- </span>
      /* Post-base */
<span class="line-modified">!     mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">!     for (unsigned int i = base + 1; i &lt; end; i++)</span>
        info[i].mask  |= mask;
    }
  
<span class="line-modified">!   unsigned int pref_len = 2;</span>
<span class="line-modified">!   if (khmer_plan-&gt;mask_array[PREF] &amp;&amp; base + pref_len &lt; end)</span>
    {
<span class="line-modified">!     /* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. */</span>
<span class="line-modified">!     for (unsigned int i = base + 1; i + pref_len - 1 &lt; end; i++) {</span>
<span class="line-modified">!       hb_codepoint_t glyphs[2];</span>
<span class="line-modified">!       for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">!         glyphs[j] = info[i + j].codepoint;</span>
<span class="line-modified">!       if (khmer_plan-&gt;pref.would_substitute (glyphs, pref_len, face))</span>
        {
<span class="line-modified">!         for (unsigned int j = 0; j &lt; pref_len; j++)</span>
<span class="line-modified">!           info[i++].mask |= khmer_plan-&gt;mask_array[PREF];</span>
  
          /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
           * Read the feature spec.
           * This allows distinguishing the following cases with MS Khmer fonts:
           * U+1784,U+17D2,U+179A,U+17D2,U+1782
           * U+1784,U+17D2,U+1782,U+17D2,U+179A
           */
          if (khmer_plan-&gt;mask_array[CFAR])
<span class="line-modified">!           for (; i &lt; end; i++)</span>
<span class="line-modified">!             info[i].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
  
<span class="line-modified">!         break;</span>
        }
      }
    }
  }
  
  static void
  initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
<span class="line-new-header">--- 260,86 ---</span>
    find_syllables (buffer);
    foreach_syllable (buffer, start, end)
      buffer-&gt;unsafe_to_break (start, end);
  }
  
  
  /* Rules from:
   * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
  
  static void
<span class="line-modified">! reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!                             hb_face_t *face HB_UNUSED,</span>
<span class="line-modified">!                             hb_buffer_t *buffer,</span>
<span class="line-modified">!                             unsigned int start, unsigned int end)</span>
  {
    const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
    hb_glyph_info_t *info = buffer-&gt;info;
  
<span class="line-modified">!   /* Setup masks. */</span>
    {
      /* Post-base */
<span class="line-modified">!     hb_mask_t mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">!     for (unsigned int i = start + 1; i &lt; end; i++)</span>
        info[i].mask  |= mask;
    }
  
<span class="line-modified">!   unsigned int num_coengs = 0;</span>
<span class="line-modified">!   for (unsigned int i = start + 1; i &lt; end; i++)</span>
    {
<span class="line-modified">!     /* &quot;&quot;&quot;</span>
<span class="line-modified">!      * When a COENG + (Cons | IndV) combination are found (and subscript count</span>
<span class="line-modified">!      * is less than two) the character combination is handled according to the</span>
<span class="line-modified">!      * subscript type of the character following the COENG.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * ...</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Subscript Type 2 - The COENG + RO characters are reordered to immediately</span>
<span class="line-added">+      * before the base glyph. Then the COENG + RO characters are assigned to have</span>
<span class="line-added">+      * the &#39;pref&#39; OpenType feature applied to them.</span>
<span class="line-added">+      * &quot;&quot;&quot;</span>
<span class="line-added">+      */</span>
<span class="line-added">+     if (info[i].khmer_category() == OT_Coeng &amp;&amp; num_coengs &lt;= 2 &amp;&amp; i + 1 &lt; end)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       num_coengs++;</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (info[i + 1].khmer_category() == OT_Ra)</span>
        {
<span class="line-modified">!         for (unsigned int j = 0; j &lt; 2; j++)</span>
<span class="line-modified">!           info[i + j].mask |= khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-added">+ </span>
<span class="line-added">+         /* Move the Coeng,Ro sequence to the start. */</span>
<span class="line-added">+         buffer-&gt;merge_clusters (start, i + 2);</span>
<span class="line-added">+         hb_glyph_info_t t0 = info[i];</span>
<span class="line-added">+         hb_glyph_info_t t1 = info[i + 1];</span>
<span class="line-added">+         memmove (&amp;info[start + 2], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">+         info[start] = t0;</span>
<span class="line-added">+         info[start + 1] = t1;</span>
  
          /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
           * Read the feature spec.
           * This allows distinguishing the following cases with MS Khmer fonts:
           * U+1784,U+17D2,U+179A,U+17D2,U+1782
           * U+1784,U+17D2,U+1782,U+17D2,U+179A
           */
          if (khmer_plan-&gt;mask_array[CFAR])
<span class="line-modified">!           for (unsigned int j = i + 2; j &lt; end; j++)</span>
<span class="line-modified">!             info[j].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
  
<span class="line-modified">!         num_coengs = 2; /* Done. */</span>
        }
      }
<span class="line-added">+ </span>
<span class="line-added">+     /* Reorder left matra piece. */</span>
<span class="line-added">+     else if (info[i].khmer_category() == OT_VPre)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       /* Move to the start. */</span>
<span class="line-added">+       buffer-&gt;merge_clusters (start, i + 1);</span>
<span class="line-added">+       hb_glyph_info_t t = info[i];</span>
<span class="line-added">+       memmove (&amp;info[start + 1], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">+       info[start] = t;</span>
<span class="line-added">+     }</span>
    }
  }
  
  static void
  initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 446,11 ***</span>
    syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
    switch (syllable_type)
    {
      case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
      case consonant_syllable:
<span class="line-modified">!      initial_reordering_consonant_syllable (plan, face, buffer, start, end);</span>
       break;
  
      case non_khmer_cluster:
        break;
    }
<span class="line-new-header">--- 350,11 ---</span>
    syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
    switch (syllable_type)
    {
      case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
      case consonant_syllable:
<span class="line-modified">!      reorder_consonant_syllable (plan, face, buffer, start, end);</span>
       break;
  
      case non_khmer_cluster:
        break;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 511,267 ***</span>
        buffer-&gt;output_info (ginfo);
      }
      else
        buffer-&gt;next_glyph ();
    }
<span class="line-removed">- </span>
    buffer-&gt;swap_buffers ();
  }
  
  static void
<span class="line-modified">! initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!                     hb_font_t *font,</span>
<span class="line-modified">!                     hb_buffer_t *buffer)</span>
  {
    insert_dotted_circles (plan, font, buffer);
  
    foreach_syllable (buffer, start, end)
      initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static void</span>
<span class="line-removed">- final_reordering_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">-                            hb_buffer_t *buffer,</span>
<span class="line-removed">-                            unsigned int start, unsigned int end)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;</span>
<span class="line-removed">-   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* This function relies heavily on halant glyphs.  Lots of ligation</span>
<span class="line-removed">-    * and possibly multiple substitutions happened prior to this</span>
<span class="line-removed">-    * phase, and that might have messed up our properties.  Recover</span>
<span class="line-removed">-    * from a particular case of that where we&#39;re fairly sure that a</span>
<span class="line-removed">-    * class of OT_Coeng is desired but has been lost. */</span>
<span class="line-removed">-   if (khmer_plan-&gt;virama_glyph)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     unsigned int virama_glyph = khmer_plan-&gt;virama_glyph;</span>
<span class="line-removed">-     for (unsigned int i = start; i &lt; end; i++)</span>
<span class="line-removed">-       if (info[i].codepoint == virama_glyph &amp;&amp;</span>
<span class="line-removed">-           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">-           _hb_glyph_info_multiplied (&amp;info[i]))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         /* This will make sure that this glyph passes is_coeng() test. */</span>
<span class="line-removed">-         info[i].khmer_category() = OT_Coeng;</span>
<span class="line-removed">-         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* 4. Final reordering:</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    * After the localized forms and basic shaping forms GSUB features have been</span>
<span class="line-removed">-    * applied (see below), the shaping engine performs some final glyph</span>
<span class="line-removed">-    * reordering before applying all the remaining font features to the entire</span>
<span class="line-removed">-    * syllable.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool try_pref = !!khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Find base again */</span>
<span class="line-removed">-   unsigned int base;</span>
<span class="line-removed">-   for (base = start; base &lt; end; base++)</span>
<span class="line-removed">-     if (info[base].khmer_position() &gt;= POS_BASE_C)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (try_pref &amp;&amp; base + 1 &lt; end)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">-           if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             if (!(_hb_glyph_info_substituted (&amp;info[i]) &amp;&amp;</span>
<span class="line-removed">-                   _hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i])))</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-               /* Ok, this was a &#39;pref&#39; candidate but didn&#39;t form any.</span>
<span class="line-removed">-                * Base is around here... */</span>
<span class="line-removed">-               base = i;</span>
<span class="line-removed">-               while (base &lt; end &amp;&amp; is_coeng (info[base]))</span>
<span class="line-removed">-                 base++;</span>
<span class="line-removed">-               info[base].khmer_position() = POS_BASE_C;</span>
<span class="line-removed">- </span>
<span class="line-removed">-               try_pref = false;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (start &lt; base &amp;&amp; info[base].khmer_position() &gt; POS_BASE_C)</span>
<span class="line-removed">-         base--;</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   if (base == end &amp;&amp; start &lt; base &amp;&amp;</span>
<span class="line-removed">-       is_one_of (info[base - 1], FLAG (OT_ZWJ)))</span>
<span class="line-removed">-     base--;</span>
<span class="line-removed">-   if (base &lt; end)</span>
<span class="line-removed">-     while (start &lt; base &amp;&amp;</span>
<span class="line-removed">-            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_Coeng))))</span>
<span class="line-removed">-       base--;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   /*   o Reorder matras:</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    *     If a pre-base matra character had been reordered before applying basic</span>
<span class="line-removed">-    *     features, the glyph can be moved closer to the main consonant based on</span>
<span class="line-removed">-    *     whether half-forms had been formed. Actual position for the matra is</span>
<span class="line-removed">-    *     defined as “after last standalone halant glyph, after initial matra</span>
<span class="line-removed">-    *     position and before the main consonant”. If ZWJ or ZWNJ follow this</span>
<span class="line-removed">-    *     halant, position is moved after it.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     /* If we lost track of base, alas, position before last thingy. */</span>
<span class="line-removed">-     unsigned int new_pos = base == end ? base - 2 : base - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">-            !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_Coeng)))))</span>
<span class="line-removed">-       new_pos--;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* If we found no Halant we are done.</span>
<span class="line-removed">-      * Otherwise only proceed if the Halant does</span>
<span class="line-removed">-      * not belong to the Matra itself! */</span>
<span class="line-removed">-     if (is_coeng (info[new_pos]) &amp;&amp;</span>
<span class="line-removed">-         info[new_pos].khmer_position() != POS_PRE_M)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">-       if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))</span>
<span class="line-removed">-         new_pos++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-       new_pos = start; /* No move. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (start &lt; new_pos &amp;&amp; info[new_pos].khmer_position () != POS_PRE_M)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       /* Now go see if there&#39;s actually any matras... */</span>
<span class="line-removed">-       for (unsigned int i = new_pos; i &gt; start; i--)</span>
<span class="line-removed">-         if (info[i - 1].khmer_position () == POS_PRE_M)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           unsigned int old_pos = i - 1;</span>
<span class="line-removed">-           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */</span>
<span class="line-removed">-             base--;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">-           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));</span>
<span class="line-removed">-           info[new_pos] = tmp;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           /* Note: this merge_clusters() is intentionally *after* the reordering.</span>
<span class="line-removed">-            * Indic matra reordering is special and tricky... */</span>
<span class="line-removed">-           buffer-&gt;merge_clusters (new_pos, MIN (end, base + 1));</span>
<span class="line-removed">- </span>
<span class="line-removed">-           new_pos--;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       for (unsigned int i = start; i &lt; base; i++)</span>
<span class="line-removed">-         if (info[i].khmer_position () == POS_PRE_M) {</span>
<span class="line-removed">-           buffer-&gt;merge_clusters (i, MIN (end, base + 1));</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   /*   o Reorder pre-base-reordering consonants:</span>
<span class="line-removed">-    *</span>
<span class="line-removed">-    *     If a pre-base-reordering consonant is found, reorder it according to</span>
<span class="line-removed">-    *     the following rules:</span>
<span class="line-removed">-    */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (try_pref &amp;&amp; base + 1 &lt; end) /* Otherwise there can&#39;t be any pre-base-reordering Ra. */</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     for (unsigned int i = base + 1; i &lt; end; i++)</span>
<span class="line-removed">-       if ((info[i].mask &amp; khmer_plan-&gt;mask_array[PREF]) != 0)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         /*       1. Only reorder a glyph produced by substitution during application</span>
<span class="line-removed">-          *          of the &lt;pref&gt; feature. (Note that a font may shape a Ra consonant with</span>
<span class="line-removed">-          *          the feature generally but block it in certain contexts.)</span>
<span class="line-removed">-          */</span>
<span class="line-removed">-         /* Note: We just check that something got substituted.  We don&#39;t check that</span>
<span class="line-removed">-          * the &lt;pref&gt; feature actually did it...</span>
<span class="line-removed">-          *</span>
<span class="line-removed">-          * Reorder pref only if it ligated. */</span>
<span class="line-removed">-         if (_hb_glyph_info_ligated_and_didnt_multiply (&amp;info[i]))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           /*</span>
<span class="line-removed">-            *       2. Try to find a target position the same way as for pre-base matra.</span>
<span class="line-removed">-            *          If it is found, reorder pre-base consonant glyph.</span>
<span class="line-removed">-            *</span>
<span class="line-removed">-            *       3. If position is not found, reorder immediately before main</span>
<span class="line-removed">-            *          consonant.</span>
<span class="line-removed">-            */</span>
<span class="line-removed">- </span>
<span class="line-removed">-           unsigned int new_pos = base;</span>
<span class="line-removed">-           while (new_pos &gt; start &amp;&amp;</span>
<span class="line-removed">-                  !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_Coeng))))</span>
<span class="line-removed">-             new_pos--;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           /* In Khmer coeng model, a H,Ra can go *after* matras.  If it goes after a</span>
<span class="line-removed">-            * split matra, it should be reordered to *before* the left part of such matra. */</span>
<span class="line-removed">-           if (new_pos &gt; start &amp;&amp; info[new_pos - 1].khmer_category() == OT_M)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             unsigned int old_pos = i;</span>
<span class="line-removed">-             for (unsigned int j = base + 1; j &lt; old_pos; j++)</span>
<span class="line-removed">-               if (info[j].khmer_category() == OT_M)</span>
<span class="line-removed">-               {</span>
<span class="line-removed">-                 new_pos--;</span>
<span class="line-removed">-                 break;</span>
<span class="line-removed">-               }</span>
<span class="line-removed">-           }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (new_pos &gt; start &amp;&amp; is_coeng (info[new_pos - 1]))</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */</span>
<span class="line-removed">-             if (new_pos &lt; end &amp;&amp; is_joiner (info[new_pos]))</span>
<span class="line-removed">-               new_pos++;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             unsigned int old_pos = i;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             buffer-&gt;merge_clusters (new_pos, old_pos + 1);</span>
<span class="line-removed">-             hb_glyph_info_t tmp = info[old_pos];</span>
<span class="line-removed">-             memmove (&amp;info[new_pos + 1], &amp;info[new_pos], (old_pos - new_pos) * sizeof (info[0]));</span>
<span class="line-removed">-             info[new_pos] = tmp;</span>
<span class="line-removed">- </span>
<span class="line-removed">-             if (new_pos &lt;= base &amp;&amp; base &lt; old_pos)</span>
<span class="line-removed">-               base++;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-   /*</span>
<span class="line-removed">-    * Finish off the clusters and go home!</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   if (hb_options ().uniscribe_bug_compatible)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.</span>
<span class="line-removed">-      * This means, half forms are submerged into the main consonant&#39;s cluster.</span>
<span class="line-removed">-      * This is unnecessary, and makes cursor positioning harder, but that&#39;s what</span>
<span class="line-removed">-      * Uniscribe does. */</span>
<span class="line-removed">-     buffer-&gt;merge_clusters (start, end);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- static void</span>
<span class="line-removed">- final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-removed">-                   hb_font_t *font HB_UNUSED,</span>
<span class="line-removed">-                   hb_buffer_t *buffer)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">-   if (unlikely (!count)) return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   foreach_syllable (buffer, start, end)</span>
<span class="line-removed">-     final_reordering_syllable (plan, buffer, start, end);</span>
  
    HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);
<span class="line-removed">-   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_position);</span>
  }
  
<span class="line-removed">- </span>
  static void
  clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
                   hb_font_t *font HB_UNUSED,
                   hb_buffer_t *buffer)
  {
<span class="line-new-header">--- 415,26 ---</span>
        buffer-&gt;output_info (ginfo);
      }
      else
        buffer-&gt;next_glyph ();
    }
    buffer-&gt;swap_buffers ();
  }
  
  static void
<span class="line-modified">! reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">!          hb_font_t *font,</span>
<span class="line-modified">!          hb_buffer_t *buffer)</span>
  {
    insert_dotted_circles (plan, font, buffer);
  
    foreach_syllable (buffer, start, end)
      initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
  
    HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);
  }
  
  static void
  clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
                   hb_font_t *font HB_UNUSED,
                   hb_buffer_t *buffer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,10 ***</span>
    nullptr, /* postprocess_glyphs */
    HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
    decompose_khmer,
    compose_khmer,
    setup_masks_khmer,
<span class="line-modified">!   nullptr, /* disable_otl */</span>
    nullptr, /* reorder_marks */
    HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
    false, /* fallback_position */
  };
<span class="line-new-header">--- 492,10 ---</span>
    nullptr, /* postprocess_glyphs */
    HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
    decompose_khmer,
    compose_khmer,
    setup_masks_khmer,
<span class="line-modified">!   HB_TAG_NONE, /* gpos_tag */</span>
    nullptr, /* reorder_marks */
    HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
    false, /* fallback_position */
  };
</pre>
<center><a href="hb-ot-shape-complex-khmer-machine.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-myanmar-machine.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/freetypeScaler.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="HBShaper.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="harfbuzz/hb-blob.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/freetypeScaler.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2013, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;jni.h&quot;
  27 #include &quot;jni_util.h&quot;
  28 #include &quot;jlong.h&quot;
  29 #include &quot;sunfontids.h&quot;
  30 #include &quot;sun_font_FreetypeFontScaler.h&quot;
  31 
<span class="line-modified">  32 #include&lt;stdlib.h&gt;</span>



  33 #include &lt;math.h&gt;
  34 #include &quot;ft2build.h&quot;
  35 #include FT_FREETYPE_H
  36 #include FT_GLYPH_H
  37 #include FT_BBOX_H
  38 #include FT_SIZES_H
  39 #include FT_OUTLINE_H
  40 #include FT_SYNTHESIS_H
  41 #include FT_LCD_FILTER_H

  42 
  43 #include &quot;fontscaler.h&quot;
  44 
  45 #define  ftFixed1  (FT_Fixed) (1 &lt;&lt; 16)
  46 #define  FloatToFTFixed(f) (FT_Fixed)((f) * (float)(ftFixed1))
  47 #define  FTFixedToFloat(x) ((x) / (float)(ftFixed1))
  48 #define  FT26Dot6ToFloat(x)  ((x) / ((float) (1&lt;&lt;6)))
  49 #define  FT26Dot6ToInt(x) (((int)(x)) &gt;&gt; 6)
  50 
  51 typedef struct {
  52     /* Important note:
  53          JNI forbids sharing same env between different threads.
  54          We are safe, because pointer is overwritten every time we get into
  55          JNI call (see setupFTContext).
  56 
  57          Pointer is used by font data reading callbacks
  58          such as ReadTTFontFileFunc.
  59 
  60          NB: We may consider switching to JNI_GetEnv. */
  61     JNIEnv* env;
  62     FT_Library library;
  63     FT_Face face;
  64     FT_Stream faceStream;
  65     jobject font2D;
  66     jobject directBuffer;
  67 
  68     unsigned char* fontData;
  69     unsigned fontDataOffset;
  70     unsigned fontDataLength;
  71     unsigned fileSize;
<span class="line-removed">  72     TTLayoutTableCache* layoutTables;</span>
  73 } FTScalerInfo;
  74 
  75 typedef struct FTScalerContext {
  76     FT_Matrix  transform;     /* glyph transform, including device transform */
  77     jboolean   useSbits;      /* sbit usage enabled? */
  78     jint       aaType;        /* antialiasing mode (off/on/grey/lcd) */
  79     jint       fmType;        /* fractional metrics - on/off */
  80     jboolean   doBold;        /* perform algorithmic bolding? */
  81     jboolean   doItalize;     /* perform algorithmic italicizing? */
  82     int        renderFlags;   /* configuration specific to particular engine */
  83     int        pathType;
  84     int        ptsz;          /* size in points */
  85 } FTScalerContext;
  86 
  87 #ifdef DEBUG
  88 /* These are referenced in the freetype sources if DEBUG macro is defined.
  89    To simplify work with debuging version of freetype we define
  90    them here. */
  91 int z_verbose;
  92 void z_error(char *s) {}
</pre>
<hr />
<pre>
 134                                  jobject scaler,
 135                                  FTScalerInfo* scalerInfo) {
 136     freeNativeResources(env, scalerInfo);
 137     (*env)-&gt;CallVoidMethod(env, scaler, invalidateScalerMID);
 138 }
 139 
 140 /******************* I/O handlers ***************************/
 141 
 142 #define FILEDATACACHESIZE 1024
 143 
 144 static unsigned long ReadTTFontFileFunc(FT_Stream stream,
 145                                         unsigned long offset,
 146                                         unsigned char* destBuffer,
 147                                         unsigned long numBytes)
 148 {
 149     FTScalerInfo *scalerInfo = (FTScalerInfo *) stream-&gt;pathname.pointer;
 150     JNIEnv* env = scalerInfo-&gt;env;
 151     jobject bBuffer;
 152     int bread = 0;
 153 
<span class="line-modified"> 154     if (numBytes == 0) return 0;</span>
























 155 
 156     /* Large reads will bypass the cache and data copying */
 157     if (numBytes &gt; FILEDATACACHESIZE) {
 158         bBuffer = (*env)-&gt;NewDirectByteBuffer(env, destBuffer, numBytes);
 159         if (bBuffer != NULL) {
 160             bread = (*env)-&gt;CallIntMethod(env,
 161                                           scalerInfo-&gt;font2D,
 162                                           sunFontIDs.ttReadBlockMID,
 163                                           bBuffer, offset, numBytes);
<span class="line-modified"> 164             return bread;</span>




 165         } else {
 166             /* We probably hit bug 4845371. For reasons that
 167              * are currently unclear, the call stacks after the initial
 168              * createScaler call that read large amounts of data seem to
 169              * be OK and can create the byte buffer above, but this code
 170              * is here just in case.
 171              * 4845371 is fixed now so I don&#39;t expect this code path to
 172              * ever get called but its harmless to leave it here on the
 173              * small chance its needed.
 174              */
 175             jbyteArray byteArray = (jbyteArray)
 176             (*env)-&gt;CallObjectMethod(env, scalerInfo-&gt;font2D,
 177                                      sunFontIDs.ttReadBytesMID,
 178                                      offset, numBytes);
<span class="line-modified"> 179             (*env)-&gt;GetByteArrayRegion(env, byteArray,</span>
<span class="line-modified"> 180                                        0, numBytes, (jbyte*)destBuffer);</span>
<span class="line-modified"> 181             return numBytes;</span>









 182         }
 183     } /* Do we have a cache hit? */
 184       else if (scalerInfo-&gt;fontDataOffset &lt;= offset &amp;&amp;
 185         scalerInfo-&gt;fontDataOffset + scalerInfo-&gt;fontDataLength &gt;=
 186                                                          offset + numBytes)
 187     {
 188         unsigned cacheOffset = offset - scalerInfo-&gt;fontDataOffset;
 189 
 190         memcpy(destBuffer, scalerInfo-&gt;fontData+(size_t)cacheOffset, numBytes);
 191         return numBytes;
 192     } else {
 193         /* Must fill the cache */
 194         scalerInfo-&gt;fontDataOffset = offset;
 195         scalerInfo-&gt;fontDataLength =
 196                  (offset + FILEDATACACHESIZE &gt; scalerInfo-&gt;fileSize) ?
 197                  scalerInfo-&gt;fileSize - offset : FILEDATACACHESIZE;
 198         bBuffer = scalerInfo-&gt;directBuffer;
 199         bread = (*env)-&gt;CallIntMethod(env, scalerInfo-&gt;font2D,
 200                                       sunFontIDs.ttReadBlockMID,
 201                                       bBuffer, offset,
 202                                       scalerInfo-&gt;fontDataLength);





 203         memcpy(destBuffer, scalerInfo-&gt;fontData, numBytes);
 204         return numBytes;
 205     }
 206 }
 207 














































 208 /*
 209  * Class:     sun_font_FreetypeFontScaler
 210  * Method:    initNativeScaler
 211  * Signature: (Lsun/font/Font2D;IIZI)J
 212  */
 213 JNIEXPORT jlong JNICALL
 214 Java_sun_font_FreetypeFontScaler_initNativeScaler(
 215         JNIEnv *env, jobject scaler, jobject font2D, jint type,
 216         jint indexInCollection, jboolean supportsCJK, jint filesize) {
 217     FTScalerInfo* scalerInfo = NULL;
 218     FT_Open_Args ft_open_args;
 219     int error;
 220     jobject bBuffer;
 221     scalerInfo = (FTScalerInfo*) calloc(1, sizeof(FTScalerInfo));
 222 
 223     if (scalerInfo == NULL)
 224         return 0;
 225 
 226     scalerInfo-&gt;env = env;
 227     scalerInfo-&gt;font2D = font2D;
 228     scalerInfo-&gt;fontDataOffset = 0;
 229     scalerInfo-&gt;fontDataLength = 0;
 230     scalerInfo-&gt;fileSize = filesize;
 231 
 232     /*
 233        We can consider sharing freetype library between different
 234        scalers. However, Freetype docs suggest to use different libraries
 235        for different threads. Also, our architecture implies that single
 236        FontScaler object is shared for different sizes/transforms/styles
 237        of the same font.
 238 
 239        On other hand these methods can not be concurrently executed
 240        becaused they are &quot;synchronized&quot; in java.
 241     */
 242     error = FT_Init_FreeType(&amp;scalerInfo-&gt;library);
 243     if (error) {
 244         free(scalerInfo);
 245         return 0;
 246     }

 247 
 248 #define TYPE1_FROM_JAVA        2
 249 
 250     error = 1; /* triggers memory freeing unless we clear it */
 251     if (type == TYPE1_FROM_JAVA) { /* TYPE1 */
 252         scalerInfo-&gt;fontData = (unsigned char*) malloc(filesize);
 253         scalerInfo-&gt;directBuffer = NULL;
<span class="line-removed"> 254         scalerInfo-&gt;layoutTables = NULL;</span>
 255         scalerInfo-&gt;fontDataLength = filesize;
 256 
 257         if (scalerInfo-&gt;fontData != NULL) {
 258             bBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 259                                               scalerInfo-&gt;fontData,
 260                                               scalerInfo-&gt;fontDataLength);
 261             if (bBuffer != NULL) {
 262                 (*env)-&gt;CallVoidMethod(env, font2D,
 263                                    sunFontIDs.readFileMID, bBuffer);
 264 
 265                 error = FT_New_Memory_Face(scalerInfo-&gt;library,
 266                                    scalerInfo-&gt;fontData,
 267                                    scalerInfo-&gt;fontDataLength,
 268                                    indexInCollection,
 269                                    &amp;scalerInfo-&gt;face);
 270             }
 271         }
 272     } else { /* Truetype */
 273         scalerInfo-&gt;fontData = (unsigned char*) malloc(FILEDATACACHESIZE);
 274 
</pre>
<hr />
<pre>
 364      */
 365     context-&gt;doBold = (boldness != 1.0);
 366     context-&gt;doItalize = (italic != 0);
 367 
 368     /* freetype is very keen to use embedded bitmaps, even if it knows
 369      * there is a rotation or you asked for antialiasing.
 370      * In the rendering path we will check useSBits and disable
 371      * bitmaps unless it is set. And here we set it only if none
 372      * of the conditions invalidate using it.
 373      * Note that we allow embedded bitmaps for the LCD case.
 374      */
 375     if ((aa != TEXT_AA_ON) &amp;&amp; (fm != TEXT_FM_ON) &amp;&amp;
 376         !context-&gt;doBold &amp;&amp; !context-&gt;doItalize &amp;&amp;
 377         (context-&gt;transform.yx == 0) &amp;&amp; (context-&gt;transform.xy == 0))
 378     {
 379         context-&gt;useSbits = 1;
 380     }
 381     return ptr_to_jlong(context);
 382 }
 383 






















 384 static int setupFTContext(JNIEnv *env,
 385                           jobject font2D,
 386                           FTScalerInfo *scalerInfo,
 387                           FTScalerContext *context) {

 388     int errCode = 0;
 389 
 390     scalerInfo-&gt;env = env;
 391     scalerInfo-&gt;font2D = font2D;
 392 
 393     if (context != NULL) {
<span class="line-modified"> 394         FT_Set_Transform(scalerInfo-&gt;face, &amp;context-&gt;transform, NULL);</span>

 395 
 396         errCode = FT_Set_Char_Size(scalerInfo-&gt;face, 0, context-&gt;ptsz, 72, 72);
 397 
 398         if (errCode == 0) {
 399             errCode = FT_Activate_Size(scalerInfo-&gt;face-&gt;size);
 400         }
 401 
 402         FT_Library_SetLcdFilter(scalerInfo-&gt;library, FT_LCD_FILTER_DEFAULT);
 403     }
 404 
 405     return errCode;
 406 }
 407 
<span class="line-modified"> 408 /* ftsynth.c uses (0x10000, 0x06000, 0x0, 0x10000) matrix to get oblique</span>
<span class="line-modified"> 409    outline.  Therefore x coordinate will change by 0x06000*y.</span>
<span class="line-modified"> 410    Note that y coordinate does not change. */</span>
<span class="line-modified"> 411 #define OBLIQUE_MODIFIER(y)  (context-&gt;doItalize ? ((y)*6/16) : 0)</span>





 412 
 413 /*
 414  * Class:     sun_font_FreetypeFontScaler
 415  * Method:    getFontMetricsNative
 416  * Signature: (Lsun/font/Font2D;J)Lsun/font/StrikeMetrics;
 417  */
 418 JNIEXPORT jobject JNICALL
 419 Java_sun_font_FreetypeFontScaler_getFontMetricsNative(
 420         JNIEnv *env, jobject scaler, jobject font2D,
 421         jlong pScalerContext, jlong pScaler) {
 422 
 423     jobject metrics;
 424     jfloat ax, ay, dx, dy, bx, by, lx, ly, mx, my;
 425     jfloat f0 = 0.0;
 426     FTScalerContext *context =
 427         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 428     FTScalerInfo *scalerInfo =
 429              (FTScalerInfo*) jlong_to_ptr(pScaler);
 430 
 431     int errCode;
</pre>
<hr />
<pre>
 478     ay = -(jfloat) (FT_MulFixFloatShift6(
 479                        ((jlong) scalerInfo-&gt;face-&gt;ascender),
 480                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 481     /* descent */
 482     dx = 0;
 483     dy = -(jfloat) (FT_MulFixFloatShift6(
 484                        ((jlong) scalerInfo-&gt;face-&gt;descender),
 485                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 486     /* baseline */
 487     bx = by = 0;
 488 
 489     /* leading */
 490     lx = 0;
 491     ly = (jfloat) (FT_MulFixFloatShift6(
 492                       (jlong) scalerInfo-&gt;face-&gt;height,
 493                       (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale))
 494                   + ay - dy;
 495     /* max advance */
 496     mx = (jfloat) FT26Dot6ToFloat(
 497                      scalerInfo-&gt;face-&gt;size-&gt;metrics.max_advance +
<span class="line-modified"> 498                      OBLIQUE_MODIFIER(scalerInfo-&gt;face-&gt;size-&gt;metrics.height));</span>


 499     my = 0;
 500 
 501     metrics = (*env)-&gt;NewObject(env,
 502         sunFontIDs.strikeMetricsClass,
 503         sunFontIDs.strikeMetricsCtr,
 504         contextAwareMetricsX(ax, ay), contextAwareMetricsY(ax, ay),
 505         contextAwareMetricsX(dx, dy), contextAwareMetricsY(dx, dy),
 506         bx, by,
 507         contextAwareMetricsX(lx, ly), contextAwareMetricsY(lx, ly),
 508         contextAwareMetricsX(mx, my), contextAwareMetricsY(mx, my));
 509 
 510     return metrics;
 511 }
 512 






 513 /*
 514  * Class:     sun_font_FreetypeFontScaler
 515  * Method:    getGlyphAdvanceNative
 516  * Signature: (Lsun/font/Font2D;JI)F
 517  */
 518 JNIEXPORT jfloat JNICALL
 519 Java_sun_font_FreetypeFontScaler_getGlyphAdvanceNative(
 520         JNIEnv *env, jobject scaler, jobject font2D,
 521         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 522 
 523    /* This method is rarely used because requests for metrics are usually
<span class="line-modified"> 524       coupled with request for bitmap and to large extend work can be reused</span>
<span class="line-modified"> 525       (to find out metrics we need to hint glyph).</span>
<span class="line-modified"> 526       So, we typically go through getGlyphImage code path.</span>
<span class="line-modified"> 527 </span>
<span class="line-modified"> 528       For initial freetype implementation we delegate</span>
<span class="line-modified"> 529       all work to getGlyphImage but drop result image.</span>
<span class="line-modified"> 530       This is waste of work related to scan conversion and conversion from</span>
<span class="line-modified"> 531       freetype format to our format but for now this seems to be ok.</span>
<span class="line-modified"> 532 </span>
<span class="line-modified"> 533       NB: investigate performance benefits of refactoring code</span>
<span class="line-removed"> 534       to avoid unnecesary work with bitmaps. */</span>
 535 
 536     GlyphInfo *info;
<span class="line-modified"> 537     jfloat advance;</span>
 538     jlong image;
 539 
<span class="line-modified"> 540     image = Java_sun_font_FreetypeFontScaler_getGlyphImageNative(</span>
<span class="line-modified"> 541                  env, scaler, font2D, pScalerContext, pScaler, glyphCode);</span>
 542     info = (GlyphInfo*) jlong_to_ptr(image);
 543 
<span class="line-modified"> 544     advance = info-&gt;advanceX;</span>
<span class="line-modified"> 545 </span>
<span class="line-modified"> 546     free(info);</span>

 547 
 548     return advance;
 549 }
 550 
 551 /*
 552  * Class:     sun_font_FreetypeFontScaler
 553  * Method:    getGlyphMetricsNative
 554  * Signature: (Lsun/font/Font2D;JILjava/awt/geom/Point2D/Float;)V
 555  */
 556 JNIEXPORT void JNICALL
 557 Java_sun_font_FreetypeFontScaler_getGlyphMetricsNative(
 558         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
 559         jlong pScaler, jint glyphCode, jobject metrics) {
 560 
<span class="line-modified"> 561      /* As initial implementation we delegate all work to getGlyphImage</span>
<span class="line-removed"> 562         but drop result image. This is clearly waste of resorces.</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564         TODO: investigate performance benefits of refactoring code</span>
<span class="line-removed"> 565               by avoiding bitmap generation and conversion from FT</span>
<span class="line-removed"> 566               bitmap format. */</span>
 567      GlyphInfo *info;
 568 
<span class="line-modified"> 569      jlong image = Java_sun_font_FreetypeFontScaler_getGlyphImageNative(</span>
 570                                  env, scaler, font2D,
<span class="line-modified"> 571                                  pScalerContext, pScaler, glyphCode);</span>
 572      info = (GlyphInfo*) jlong_to_ptr(image);
 573 
<span class="line-modified"> 574      (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, info-&gt;advanceX);</span>
<span class="line-modified"> 575      (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, info-&gt;advanceY);</span>
<span class="line-modified"> 576 </span>
<span class="line-modified"> 577      free(info);</span>




 578 }
 579 
 580 
 581 static GlyphInfo* getNullGlyphImage() {
 582     GlyphInfo *glyphInfo =  (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
 583     return glyphInfo;
 584 }
 585 
 586 static void CopyBW2Grey8(const void* srcImage, int srcRowBytes,
 587                          void* dstImage, int dstRowBytes,
 588                          int width, int height) {
 589     const UInt8* srcRow = (UInt8*)srcImage;
 590     UInt8* dstRow = (UInt8*)dstImage;
 591     int wholeByteCount = width &gt;&gt; 3;
 592     int remainingBitsCount = width &amp; 7;
 593     int i, j;
 594 
 595     while (height--) {
 596         const UInt8* src8 = srcRow;
 597         UInt8* dstByte = dstRow;
</pre>
<hr />
<pre>
 664     unsigned char *srcRow = (unsigned char *) srcImage, *srcByte;
 665     unsigned char *dstRow = (unsigned char *) dstImage, *dstByte;
 666     int i;
 667 
 668     while (height &gt; 0) {
 669         srcByte = srcRow;
 670         dstByte = dstRow;
 671         for (i = 0; i &lt; width; i++) {
 672             *dstByte++ = *srcByte;
 673             *dstByte++ = *(srcByte + srcRowBytes);
 674             *dstByte++ = *(srcByte + 2*srcRowBytes);
 675             srcByte++;
 676         }
 677         srcRow += 3*srcRowBytes;
 678         dstRow += dstRowBytes;
 679         height -= 3;
 680     }
 681 }
 682 
 683 







 684 /*
 685  * Class:     sun_font_FreetypeFontScaler
 686  * Method:    getGlyphImageNative
 687  * Signature: (Lsun/font/Font2D;JI)J
 688  */
 689 JNIEXPORT jlong JNICALL
 690 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 691         JNIEnv *env, jobject scaler, jobject font2D,
 692         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 693 











 694     int error, imageSize;
 695     UInt16 width, height;
 696     GlyphInfo *glyphInfo;
 697     int renderFlags = FT_LOAD_DEFAULT, target;
 698     FT_GlyphSlot ftglyph;
 699 
 700     FTScalerContext* context =
 701         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 702     FTScalerInfo *scalerInfo =
 703              (FTScalerInfo*) jlong_to_ptr(pScaler);
 704 
 705     if (isNullScalerContext(context) || scalerInfo == NULL) {
 706         return ptr_to_jlong(getNullGlyphImage());
 707     }
 708 
 709     error = setupFTContext(env, font2D, scalerInfo, context);
 710     if (error) {
 711         invalidateJavaScaler(env, scaler, scalerInfo);
 712         return ptr_to_jlong(getNullGlyphImage());
 713     }
 714 











 715     if (!context-&gt;useSbits) {
 716         renderFlags |= FT_LOAD_NO_BITMAP;
 717     }
 718 
 719     /* NB: in case of non identity transform
 720      we might also prefer to disable transform before hinting,
 721      and apply it explicitly after hinting is performed.
 722      Or we can disable hinting. */
 723 
 724     /* select appropriate hinting mode */
 725     if (context-&gt;aaType == TEXT_AA_OFF) {
 726         target = FT_LOAD_TARGET_MONO;
 727     } else if (context-&gt;aaType == TEXT_AA_ON) {
 728         target = FT_LOAD_TARGET_NORMAL;
 729     } else if (context-&gt;aaType == TEXT_AA_LCD_HRGB ||
 730                context-&gt;aaType == TEXT_AA_LCD_HBGR) {
 731         target = FT_LOAD_TARGET_LCD;
 732     } else {
 733         target = FT_LOAD_TARGET_LCD_V;
 734     }
 735     renderFlags |= target;
 736 
 737     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
 738     if (error) {
 739         //do not destroy scaler yet.
 740         //this can be problem of particular context (e.g. with bad transform)
 741         return ptr_to_jlong(getNullGlyphImage());
 742     }
 743 
 744     ftglyph = scalerInfo-&gt;face-&gt;glyph;
 745 
 746     /* apply styles */
 747     if (context-&gt;doBold) { /* if bold style */
 748         FT_GlyphSlot_Embolden(ftglyph);
 749     }
<span class="line-removed"> 750     if (context-&gt;doItalize) { /* if oblique */</span>
<span class="line-removed"> 751         FT_GlyphSlot_Oblique(ftglyph);</span>
<span class="line-removed"> 752     }</span>
 753 
 754     /* generate bitmap if it is not done yet
 755      e.g. if algorithmic styling is performed and style was added to outline */
<span class="line-modified"> 756     if (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE) {</span>








 757         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 758         if (error != 0) {
 759             return ptr_to_jlong(getNullGlyphImage());
 760         }
 761     }
 762 
<span class="line-modified"> 763     width  = (UInt16) ftglyph-&gt;bitmap.width;</span>
<span class="line-modified"> 764     height = (UInt16) ftglyph-&gt;bitmap.rows;</span>










 765 
 766     imageSize = width*height;
 767     glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);
 768     if (glyphInfo == NULL) {
 769         glyphInfo = getNullGlyphImage();
 770         return ptr_to_jlong(glyphInfo);
 771     }
 772     glyphInfo-&gt;cellInfo  = NULL;
 773     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
 774     glyphInfo-&gt;rowBytes  = width;
 775     glyphInfo-&gt;width     = width;
 776     glyphInfo-&gt;height    = height;
<span class="line-removed"> 777     glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;</span>
<span class="line-removed"> 778     glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;</span>
 779 
<span class="line-modified"> 780     if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {</span>
<span class="line-modified"> 781         glyphInfo-&gt;width = width/3;</span>
<span class="line-modified"> 782     } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {</span>
<span class="line-modified"> 783         glyphInfo-&gt;height = glyphInfo-&gt;height/3;</span>





 784     }
 785 
 786     if (context-&gt;fmType == TEXT_FM_ON) {
<span class="line-modified"> 787         double advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);</span>
 788         glyphInfo-&gt;advanceX =
 789             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 790         glyphInfo-&gt;advanceY =
<span class="line-modified"> 791             (float) (advh * FTFixedToFloat(context-&gt;transform.xy));</span>
 792     } else {
 793         if (!ftglyph-&gt;advance.y) {
 794             glyphInfo-&gt;advanceX =
 795                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 796             glyphInfo-&gt;advanceY = 0;
 797         } else if (!ftglyph-&gt;advance.x) {
 798             glyphInfo-&gt;advanceX = 0;
 799             glyphInfo-&gt;advanceY =
 800                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
 801         } else {
 802             glyphInfo-&gt;advanceX = FT26Dot6ToFloat(ftglyph-&gt;advance.x);
 803             glyphInfo-&gt;advanceY = FT26Dot6ToFloat(-ftglyph-&gt;advance.y);
 804         }
 805     }
 806 
 807     if (imageSize == 0) {
 808         glyphInfo-&gt;image = NULL;
 809     } else {
 810         glyphInfo-&gt;image = (unsigned char*) glyphInfo + sizeof(GlyphInfo);
 811         //convert result to output format
</pre>
<hr />
<pre>
 839                                      width,
 840                                      height);
 841         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
 842             /* 3 bytes per pixel to 3 bytes per pixel */
 843             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
 844                                       ftglyph-&gt;bitmap.pitch,
 845                                       (void *) glyphInfo-&gt;image,
 846                                       width*3,
 847                                       width,
 848                                       height);
 849             glyphInfo-&gt;rowBytes *=3;
 850         } else {
 851             free(glyphInfo);
 852             glyphInfo = getNullGlyphImage();
 853         }
 854     }
 855 
 856     return ptr_to_jlong(glyphInfo);
 857 }
 858 
<span class="line-removed"> 859 </span>
<span class="line-removed"> 860 /*</span>
<span class="line-removed"> 861  * Class:     sun_font_FreetypeFontScaler</span>
<span class="line-removed"> 862  * Method:    getLayoutTableCacheNative</span>
<span class="line-removed"> 863  * Signature: (J)J</span>
<span class="line-removed"> 864  */</span>
<span class="line-removed"> 865 JNIEXPORT jlong JNICALL</span>
<span class="line-removed"> 866 Java_sun_font_FreetypeFontScaler_getLayoutTableCacheNative(</span>
<span class="line-removed"> 867         JNIEnv *env, jobject scaler, jlong pScaler) {</span>
<span class="line-removed"> 868     FTScalerInfo *scalerInfo = (FTScalerInfo*) jlong_to_ptr(pScaler);</span>
<span class="line-removed"> 869 </span>
<span class="line-removed"> 870     if (scalerInfo == NULL) {</span>
<span class="line-removed"> 871         invalidateJavaScaler(env, scaler, scalerInfo);</span>
<span class="line-removed"> 872         return 0L;</span>
<span class="line-removed"> 873     }</span>
<span class="line-removed"> 874 </span>
<span class="line-removed"> 875     // init layout table cache in font</span>
<span class="line-removed"> 876     // we&#39;re assuming the font is a file font and moreover it is Truetype font</span>
<span class="line-removed"> 877     // otherwise we shouldn&#39;t be able to get here...</span>
<span class="line-removed"> 878     if (scalerInfo-&gt;layoutTables == NULL) {</span>
<span class="line-removed"> 879         scalerInfo-&gt;layoutTables = newLayoutTableCache();</span>
<span class="line-removed"> 880     }</span>
<span class="line-removed"> 881 </span>
<span class="line-removed"> 882     return ptr_to_jlong(scalerInfo-&gt;layoutTables);</span>
<span class="line-removed"> 883 }</span>
<span class="line-removed"> 884 </span>
 885 /*
 886  * Class:     sun_font_FreetypeFontScaler
 887  * Method:    disposeNativeScaler
 888  * Signature: (J)V
 889  */
 890 JNIEXPORT void JNICALL
 891 Java_sun_font_FreetypeFontScaler_disposeNativeScaler(
 892         JNIEnv *env, jobject scaler, jobject font2D, jlong pScaler) {
 893     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
 894 
 895     /* Freetype functions *may* cause callback to java
 896        that can use cached values. Make sure our cache is up to date.
 897        NB: scaler context is not important at this point, can use NULL. */
 898     int errCode = setupFTContext(env, font2D, scalerInfo, NULL);
 899     if (errCode) {
 900         return;
 901     }
 902 
 903     freeNativeResources(env, scalerInfo);
 904 }
</pre>
<hr />
<pre>
 982     }
 983 
 984     error = setupFTContext(env, font2D, scalerInfo, context);
 985     if (error) {
 986         return NULL;
 987     }
 988 
 989     renderFlags = FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
 990 
 991     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
 992     if (error) {
 993         return NULL;
 994     }
 995 
 996     ftglyph = scalerInfo-&gt;face-&gt;glyph;
 997 
 998     /* apply styles */
 999     if (context-&gt;doBold) { /* if bold style */
1000         FT_GlyphSlot_Embolden(ftglyph);
1001     }
<span class="line-removed">1002     if (context-&gt;doItalize) { /* if oblique */</span>
<span class="line-removed">1003         FT_GlyphSlot_Oblique(ftglyph);</span>
<span class="line-removed">1004     }</span>
1005 
1006     FT_Outline_Translate(&amp;ftglyph-&gt;outline,
1007                          FloatToF26Dot6(xpos),
1008                          -FloatToF26Dot6(ypos));
1009 
1010     return &amp;ftglyph-&gt;outline;
1011 }
1012 
1013 #define F26Dot6ToFloat(n) (((float)(n))/((float) 64))
1014 
1015 /* Types of GeneralPath segments.
1016    TODO: pull constants from other place? */
1017 
1018 #define SEG_UNKNOWN -1
1019 #define SEG_MOVETO   0
1020 #define SEG_LINETO   1
1021 #define SEG_QUADTO   2
1022 #define SEG_CUBICTO  3
1023 #define SEG_CLOSE    4
1024 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2007, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;jni.h&quot;
  27 #include &quot;jni_util.h&quot;
  28 #include &quot;jlong.h&quot;
  29 #include &quot;sunfontids.h&quot;
  30 #include &quot;sun_font_FreetypeFontScaler.h&quot;
  31 
<span class="line-modified">  32 #include &lt;stdlib.h&gt;</span>
<span class="line-added">  33 #if !defined(_WIN32) &amp;&amp; !defined(__APPLE_)</span>
<span class="line-added">  34 #include &lt;dlfcn.h&gt;</span>
<span class="line-added">  35 #endif</span>
  36 #include &lt;math.h&gt;
  37 #include &quot;ft2build.h&quot;
  38 #include FT_FREETYPE_H
  39 #include FT_GLYPH_H
  40 #include FT_BBOX_H
  41 #include FT_SIZES_H
  42 #include FT_OUTLINE_H
  43 #include FT_SYNTHESIS_H
  44 #include FT_LCD_FILTER_H
<span class="line-added">  45 #include FT_MODULE_H</span>
  46 
  47 #include &quot;fontscaler.h&quot;
  48 
  49 #define  ftFixed1  (FT_Fixed) (1 &lt;&lt; 16)
  50 #define  FloatToFTFixed(f) (FT_Fixed)((f) * (float)(ftFixed1))
  51 #define  FTFixedToFloat(x) ((x) / (float)(ftFixed1))
  52 #define  FT26Dot6ToFloat(x)  ((x) / ((float) (1&lt;&lt;6)))
  53 #define  FT26Dot6ToInt(x) (((int)(x)) &gt;&gt; 6)
  54 
  55 typedef struct {
  56     /* Important note:
  57          JNI forbids sharing same env between different threads.
  58          We are safe, because pointer is overwritten every time we get into
  59          JNI call (see setupFTContext).
  60 
  61          Pointer is used by font data reading callbacks
  62          such as ReadTTFontFileFunc.
  63 
  64          NB: We may consider switching to JNI_GetEnv. */
  65     JNIEnv* env;
  66     FT_Library library;
  67     FT_Face face;
  68     FT_Stream faceStream;
  69     jobject font2D;
  70     jobject directBuffer;
  71 
  72     unsigned char* fontData;
  73     unsigned fontDataOffset;
  74     unsigned fontDataLength;
  75     unsigned fileSize;

  76 } FTScalerInfo;
  77 
  78 typedef struct FTScalerContext {
  79     FT_Matrix  transform;     /* glyph transform, including device transform */
  80     jboolean   useSbits;      /* sbit usage enabled? */
  81     jint       aaType;        /* antialiasing mode (off/on/grey/lcd) */
  82     jint       fmType;        /* fractional metrics - on/off */
  83     jboolean   doBold;        /* perform algorithmic bolding? */
  84     jboolean   doItalize;     /* perform algorithmic italicizing? */
  85     int        renderFlags;   /* configuration specific to particular engine */
  86     int        pathType;
  87     int        ptsz;          /* size in points */
  88 } FTScalerContext;
  89 
  90 #ifdef DEBUG
  91 /* These are referenced in the freetype sources if DEBUG macro is defined.
  92    To simplify work with debuging version of freetype we define
  93    them here. */
  94 int z_verbose;
  95 void z_error(char *s) {}
</pre>
<hr />
<pre>
 137                                  jobject scaler,
 138                                  FTScalerInfo* scalerInfo) {
 139     freeNativeResources(env, scalerInfo);
 140     (*env)-&gt;CallVoidMethod(env, scaler, invalidateScalerMID);
 141 }
 142 
 143 /******************* I/O handlers ***************************/
 144 
 145 #define FILEDATACACHESIZE 1024
 146 
 147 static unsigned long ReadTTFontFileFunc(FT_Stream stream,
 148                                         unsigned long offset,
 149                                         unsigned char* destBuffer,
 150                                         unsigned long numBytes)
 151 {
 152     FTScalerInfo *scalerInfo = (FTScalerInfo *) stream-&gt;pathname.pointer;
 153     JNIEnv* env = scalerInfo-&gt;env;
 154     jobject bBuffer;
 155     int bread = 0;
 156 
<span class="line-modified"> 157     /* A call with numBytes == 0 is a seek. It should return 0 if the</span>
<span class="line-added"> 158      * seek position is within the file and non-zero otherwise.</span>
<span class="line-added"> 159      * For all other cases, ie numBytes !=0, return the number of bytes</span>
<span class="line-added"> 160      * actually read. This applies to truncated reads and also failed reads.</span>
<span class="line-added"> 161      */</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163     if (numBytes == 0) {</span>
<span class="line-added"> 164         if (offset &gt; scalerInfo-&gt;fileSize) {</span>
<span class="line-added"> 165             return -1;</span>
<span class="line-added"> 166         } else {</span>
<span class="line-added"> 167             return 0;</span>
<span class="line-added"> 168        }</span>
<span class="line-added"> 169     }</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171     if (offset + numBytes &lt; offset) {</span>
<span class="line-added"> 172         return 0; // ft should not do this, but just in case.</span>
<span class="line-added"> 173     }</span>
<span class="line-added"> 174 </span>
<span class="line-added"> 175     if (offset &gt;= scalerInfo-&gt;fileSize) {</span>
<span class="line-added"> 176         return 0;</span>
<span class="line-added"> 177     }</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179     if (offset + numBytes &gt; scalerInfo-&gt;fileSize) {</span>
<span class="line-added"> 180         numBytes = scalerInfo-&gt;fileSize - offset;</span>
<span class="line-added"> 181     }</span>
 182 
 183     /* Large reads will bypass the cache and data copying */
 184     if (numBytes &gt; FILEDATACACHESIZE) {
 185         bBuffer = (*env)-&gt;NewDirectByteBuffer(env, destBuffer, numBytes);
 186         if (bBuffer != NULL) {
 187             bread = (*env)-&gt;CallIntMethod(env,
 188                                           scalerInfo-&gt;font2D,
 189                                           sunFontIDs.ttReadBlockMID,
 190                                           bBuffer, offset, numBytes);
<span class="line-modified"> 191             if (bread &lt; 0) {</span>
<span class="line-added"> 192                 return 0;</span>
<span class="line-added"> 193             } else {</span>
<span class="line-added"> 194                return bread;</span>
<span class="line-added"> 195             }</span>
 196         } else {
 197             /* We probably hit bug 4845371. For reasons that
 198              * are currently unclear, the call stacks after the initial
 199              * createScaler call that read large amounts of data seem to
 200              * be OK and can create the byte buffer above, but this code
 201              * is here just in case.
 202              * 4845371 is fixed now so I don&#39;t expect this code path to
 203              * ever get called but its harmless to leave it here on the
 204              * small chance its needed.
 205              */
 206             jbyteArray byteArray = (jbyteArray)
 207             (*env)-&gt;CallObjectMethod(env, scalerInfo-&gt;font2D,
 208                                      sunFontIDs.ttReadBytesMID,
 209                                      offset, numBytes);
<span class="line-modified"> 210             /* If there&#39;s an OutofMemoryError then byteArray will be null */</span>
<span class="line-modified"> 211             if (byteArray == NULL) {</span>
<span class="line-modified"> 212                 return 0;</span>
<span class="line-added"> 213             } else {</span>
<span class="line-added"> 214                 jsize len = (*env)-&gt;GetArrayLength(env, byteArray);</span>
<span class="line-added"> 215                 if (len &lt; numBytes) {</span>
<span class="line-added"> 216                     numBytes = len; // don&#39;t get more bytes than there are ..</span>
<span class="line-added"> 217                 }</span>
<span class="line-added"> 218                 (*env)-&gt;GetByteArrayRegion(env, byteArray,</span>
<span class="line-added"> 219                                            0, numBytes, (jbyte*)destBuffer);</span>
<span class="line-added"> 220                 return numBytes;</span>
<span class="line-added"> 221             }</span>
 222         }
 223     } /* Do we have a cache hit? */
 224       else if (scalerInfo-&gt;fontDataOffset &lt;= offset &amp;&amp;
 225         scalerInfo-&gt;fontDataOffset + scalerInfo-&gt;fontDataLength &gt;=
 226                                                          offset + numBytes)
 227     {
 228         unsigned cacheOffset = offset - scalerInfo-&gt;fontDataOffset;
 229 
 230         memcpy(destBuffer, scalerInfo-&gt;fontData+(size_t)cacheOffset, numBytes);
 231         return numBytes;
 232     } else {
 233         /* Must fill the cache */
 234         scalerInfo-&gt;fontDataOffset = offset;
 235         scalerInfo-&gt;fontDataLength =
 236                  (offset + FILEDATACACHESIZE &gt; scalerInfo-&gt;fileSize) ?
 237                  scalerInfo-&gt;fileSize - offset : FILEDATACACHESIZE;
 238         bBuffer = scalerInfo-&gt;directBuffer;
 239         bread = (*env)-&gt;CallIntMethod(env, scalerInfo-&gt;font2D,
 240                                       sunFontIDs.ttReadBlockMID,
 241                                       bBuffer, offset,
 242                                       scalerInfo-&gt;fontDataLength);
<span class="line-added"> 243         if (bread &lt;= 0) {</span>
<span class="line-added"> 244             return 0;</span>
<span class="line-added"> 245         } else if (bread &lt; numBytes) {</span>
<span class="line-added"> 246            numBytes = bread;</span>
<span class="line-added"> 247         }</span>
 248         memcpy(destBuffer, scalerInfo-&gt;fontData, numBytes);
 249         return numBytes;
 250     }
 251 }
 252 
<span class="line-added"> 253 typedef FT_Error (*FT_Prop_Set_Func)(FT_Library library,</span>
<span class="line-added"> 254                                      const FT_String*  module_name,</span>
<span class="line-added"> 255                                      const FT_String*  property_name,</span>
<span class="line-added"> 256                                      const void*       value );</span>
<span class="line-added"> 257 </span>
<span class="line-added"> 258 /**</span>
<span class="line-added"> 259  * Prefer the older v35 freetype byte code interpreter.</span>
<span class="line-added"> 260  */</span>
<span class="line-added"> 261 static void setInterpreterVersion(FT_Library library) {</span>
<span class="line-added"> 262 </span>
<span class="line-added"> 263     char* props = getenv(&quot;FREETYPE_PROPERTIES&quot;);</span>
<span class="line-added"> 264     int version = 35;</span>
<span class="line-added"> 265     const char* module = &quot;truetype&quot;;</span>
<span class="line-added"> 266     const char* property = &quot;interpreter-version&quot;;</span>
<span class="line-added"> 267 </span>
<span class="line-added"> 268     /* If some one is setting this, don&#39;t override it */</span>
<span class="line-added"> 269     if (props != NULL &amp;&amp; strstr(property, props)) {</span>
<span class="line-added"> 270         return;</span>
<span class="line-added"> 271     }</span>
<span class="line-added"> 272     /*</span>
<span class="line-added"> 273      * FT_Property_Set was introduced in 2.4.11.</span>
<span class="line-added"> 274      * Some older supported Linux OSes may not include it so look</span>
<span class="line-added"> 275      * this up dynamically.</span>
<span class="line-added"> 276      * And if its not available it doesn&#39;t matter, since the reason</span>
<span class="line-added"> 277      * we need it dates from 2.7.</span>
<span class="line-added"> 278      * On Windows &amp; Mac the library is always bundled so it is safe</span>
<span class="line-added"> 279      * to use directly in those cases.</span>
<span class="line-added"> 280      */</span>
<span class="line-added"> 281 #if defined(_WIN32) || defined(__APPLE__)</span>
<span class="line-added"> 282     FT_Property_Set(library, module, property, (void*)(&amp;version));</span>
<span class="line-added"> 283 #else</span>
<span class="line-added"> 284     void *lib = dlopen(&quot;libfreetype.so&quot;, RTLD_LOCAL|RTLD_LAZY);</span>
<span class="line-added"> 285     if (lib == NULL) {</span>
<span class="line-added"> 286         lib = dlopen(&quot;libfreetype.so.6&quot;, RTLD_LOCAL|RTLD_LAZY);</span>
<span class="line-added"> 287         if (lib == NULL) {</span>
<span class="line-added"> 288             return;</span>
<span class="line-added"> 289         }</span>
<span class="line-added"> 290     }</span>
<span class="line-added"> 291     FT_Prop_Set_Func func = (FT_Prop_Set_Func)dlsym(lib, &quot;FT_Property_Set&quot;);</span>
<span class="line-added"> 292     if (func != NULL) {</span>
<span class="line-added"> 293         func(library, module, property, (void*)(&amp;version));</span>
<span class="line-added"> 294     }</span>
<span class="line-added"> 295     dlclose(lib);</span>
<span class="line-added"> 296 #endif</span>
<span class="line-added"> 297 }</span>
<span class="line-added"> 298 </span>
 299 /*
 300  * Class:     sun_font_FreetypeFontScaler
 301  * Method:    initNativeScaler
 302  * Signature: (Lsun/font/Font2D;IIZI)J
 303  */
 304 JNIEXPORT jlong JNICALL
 305 Java_sun_font_FreetypeFontScaler_initNativeScaler(
 306         JNIEnv *env, jobject scaler, jobject font2D, jint type,
 307         jint indexInCollection, jboolean supportsCJK, jint filesize) {
 308     FTScalerInfo* scalerInfo = NULL;
 309     FT_Open_Args ft_open_args;
 310     int error;
 311     jobject bBuffer;
 312     scalerInfo = (FTScalerInfo*) calloc(1, sizeof(FTScalerInfo));
 313 
 314     if (scalerInfo == NULL)
 315         return 0;
 316 
 317     scalerInfo-&gt;env = env;
 318     scalerInfo-&gt;font2D = font2D;
 319     scalerInfo-&gt;fontDataOffset = 0;
 320     scalerInfo-&gt;fontDataLength = 0;
 321     scalerInfo-&gt;fileSize = filesize;
 322 
 323     /*
 324        We can consider sharing freetype library between different
 325        scalers. However, Freetype docs suggest to use different libraries
 326        for different threads. Also, our architecture implies that single
 327        FontScaler object is shared for different sizes/transforms/styles
 328        of the same font.
 329 
 330        On other hand these methods can not be concurrently executed
 331        becaused they are &quot;synchronized&quot; in java.
 332     */
 333     error = FT_Init_FreeType(&amp;scalerInfo-&gt;library);
 334     if (error) {
 335         free(scalerInfo);
 336         return 0;
 337     }
<span class="line-added"> 338     setInterpreterVersion(scalerInfo-&gt;library);</span>
 339 
 340 #define TYPE1_FROM_JAVA        2
 341 
 342     error = 1; /* triggers memory freeing unless we clear it */
 343     if (type == TYPE1_FROM_JAVA) { /* TYPE1 */
 344         scalerInfo-&gt;fontData = (unsigned char*) malloc(filesize);
 345         scalerInfo-&gt;directBuffer = NULL;

 346         scalerInfo-&gt;fontDataLength = filesize;
 347 
 348         if (scalerInfo-&gt;fontData != NULL) {
 349             bBuffer = (*env)-&gt;NewDirectByteBuffer(env,
 350                                               scalerInfo-&gt;fontData,
 351                                               scalerInfo-&gt;fontDataLength);
 352             if (bBuffer != NULL) {
 353                 (*env)-&gt;CallVoidMethod(env, font2D,
 354                                    sunFontIDs.readFileMID, bBuffer);
 355 
 356                 error = FT_New_Memory_Face(scalerInfo-&gt;library,
 357                                    scalerInfo-&gt;fontData,
 358                                    scalerInfo-&gt;fontDataLength,
 359                                    indexInCollection,
 360                                    &amp;scalerInfo-&gt;face);
 361             }
 362         }
 363     } else { /* Truetype */
 364         scalerInfo-&gt;fontData = (unsigned char*) malloc(FILEDATACACHESIZE);
 365 
</pre>
<hr />
<pre>
 455      */
 456     context-&gt;doBold = (boldness != 1.0);
 457     context-&gt;doItalize = (italic != 0);
 458 
 459     /* freetype is very keen to use embedded bitmaps, even if it knows
 460      * there is a rotation or you asked for antialiasing.
 461      * In the rendering path we will check useSBits and disable
 462      * bitmaps unless it is set. And here we set it only if none
 463      * of the conditions invalidate using it.
 464      * Note that we allow embedded bitmaps for the LCD case.
 465      */
 466     if ((aa != TEXT_AA_ON) &amp;&amp; (fm != TEXT_FM_ON) &amp;&amp;
 467         !context-&gt;doBold &amp;&amp; !context-&gt;doItalize &amp;&amp;
 468         (context-&gt;transform.yx == 0) &amp;&amp; (context-&gt;transform.xy == 0))
 469     {
 470         context-&gt;useSbits = 1;
 471     }
 472     return ptr_to_jlong(context);
 473 }
 474 
<span class="line-added"> 475 // values used by FreeType (as of version 2.10.1) for italics transformation matrix in FT_GlyphSlot_Oblique</span>
<span class="line-added"> 476 #define FT_MATRIX_ONE 0x10000</span>
<span class="line-added"> 477 #define FT_MATRIX_OBLIQUE_XY 0x0366A</span>
<span class="line-added"> 478 </span>
<span class="line-added"> 479 static void setupTransform(FT_Matrix* target, FTScalerContext *context) {</span>
<span class="line-added"> 480     FT_Matrix* transform = &amp;context-&gt;transform;</span>
<span class="line-added"> 481     if (context-&gt;doItalize) {</span>
<span class="line-added"> 482         // we cannot use FT_GlyphSlot_Oblique as it doesn&#39;t work well with arbitrary transforms,</span>
<span class="line-added"> 483         // so we add corresponding shear transform to the requested glyph transformation</span>
<span class="line-added"> 484         target-&gt;xx = FT_MATRIX_ONE;</span>
<span class="line-added"> 485         target-&gt;xy = FT_MATRIX_OBLIQUE_XY;</span>
<span class="line-added"> 486         target-&gt;yx = 0;</span>
<span class="line-added"> 487         target-&gt;yy = FT_MATRIX_ONE;</span>
<span class="line-added"> 488         FT_Matrix_Multiply(transform, target);</span>
<span class="line-added"> 489     } else {</span>
<span class="line-added"> 490         target-&gt;xx = transform-&gt;xx;</span>
<span class="line-added"> 491         target-&gt;xy = transform-&gt;xy;</span>
<span class="line-added"> 492         target-&gt;yx = transform-&gt;yx;</span>
<span class="line-added"> 493         target-&gt;yy = transform-&gt;yy;</span>
<span class="line-added"> 494     }</span>
<span class="line-added"> 495 }</span>
<span class="line-added"> 496 </span>
 497 static int setupFTContext(JNIEnv *env,
 498                           jobject font2D,
 499                           FTScalerInfo *scalerInfo,
 500                           FTScalerContext *context) {
<span class="line-added"> 501     FT_Matrix matrix;</span>
 502     int errCode = 0;
 503 
 504     scalerInfo-&gt;env = env;
 505     scalerInfo-&gt;font2D = font2D;
 506 
 507     if (context != NULL) {
<span class="line-modified"> 508         setupTransform(&amp;matrix, context);</span>
<span class="line-added"> 509         FT_Set_Transform(scalerInfo-&gt;face, &amp;matrix, NULL);</span>
 510 
 511         errCode = FT_Set_Char_Size(scalerInfo-&gt;face, 0, context-&gt;ptsz, 72, 72);
 512 
 513         if (errCode == 0) {
 514             errCode = FT_Activate_Size(scalerInfo-&gt;face-&gt;size);
 515         }
 516 
 517         FT_Library_SetLcdFilter(scalerInfo-&gt;library, FT_LCD_FILTER_DEFAULT);
 518     }
 519 
 520     return errCode;
 521 }
 522 
<span class="line-modified"> 523 // using same values as for the transformation matrix</span>
<span class="line-modified"> 524 #define OBLIQUE_MODIFIER(y)  (context-&gt;doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY/FT_MATRIX_ONE) : 0)</span>
<span class="line-modified"> 525 </span>
<span class="line-modified"> 526 /* FT_GlyphSlot_Embolden (ftsynth.c) uses FT_MulFix(units_per_EM, y_scale) / 24</span>
<span class="line-added"> 527  * strength value when glyph format is FT_GLYPH_FORMAT_OUTLINE. This value has</span>
<span class="line-added"> 528  * been taken from libfreetype version 2.6 and remain valid at least up to</span>
<span class="line-added"> 529  * 2.9.1. */</span>
<span class="line-added"> 530 #define BOLD_MODIFIER(units_per_EM, y_scale) \</span>
<span class="line-added"> 531     (context-&gt;doBold ? FT_MulFix(units_per_EM, y_scale) / 24 : 0)</span>
 532 
 533 /*
 534  * Class:     sun_font_FreetypeFontScaler
 535  * Method:    getFontMetricsNative
 536  * Signature: (Lsun/font/Font2D;J)Lsun/font/StrikeMetrics;
 537  */
 538 JNIEXPORT jobject JNICALL
 539 Java_sun_font_FreetypeFontScaler_getFontMetricsNative(
 540         JNIEnv *env, jobject scaler, jobject font2D,
 541         jlong pScalerContext, jlong pScaler) {
 542 
 543     jobject metrics;
 544     jfloat ax, ay, dx, dy, bx, by, lx, ly, mx, my;
 545     jfloat f0 = 0.0;
 546     FTScalerContext *context =
 547         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 548     FTScalerInfo *scalerInfo =
 549              (FTScalerInfo*) jlong_to_ptr(pScaler);
 550 
 551     int errCode;
</pre>
<hr />
<pre>
 598     ay = -(jfloat) (FT_MulFixFloatShift6(
 599                        ((jlong) scalerInfo-&gt;face-&gt;ascender),
 600                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 601     /* descent */
 602     dx = 0;
 603     dy = -(jfloat) (FT_MulFixFloatShift6(
 604                        ((jlong) scalerInfo-&gt;face-&gt;descender),
 605                        (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));
 606     /* baseline */
 607     bx = by = 0;
 608 
 609     /* leading */
 610     lx = 0;
 611     ly = (jfloat) (FT_MulFixFloatShift6(
 612                       (jlong) scalerInfo-&gt;face-&gt;height,
 613                       (jlong) scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale))
 614                   + ay - dy;
 615     /* max advance */
 616     mx = (jfloat) FT26Dot6ToFloat(
 617                      scalerInfo-&gt;face-&gt;size-&gt;metrics.max_advance +
<span class="line-modified"> 618                      OBLIQUE_MODIFIER(scalerInfo-&gt;face-&gt;size-&gt;metrics.height) +</span>
<span class="line-added"> 619                      BOLD_MODIFIER(scalerInfo-&gt;face-&gt;units_per_EM,</span>
<span class="line-added"> 620                              scalerInfo-&gt;face-&gt;size-&gt;metrics.y_scale));</span>
 621     my = 0;
 622 
 623     metrics = (*env)-&gt;NewObject(env,
 624         sunFontIDs.strikeMetricsClass,
 625         sunFontIDs.strikeMetricsCtr,
 626         contextAwareMetricsX(ax, ay), contextAwareMetricsY(ax, ay),
 627         contextAwareMetricsX(dx, dy), contextAwareMetricsY(dx, dy),
 628         bx, by,
 629         contextAwareMetricsX(lx, ly), contextAwareMetricsY(lx, ly),
 630         contextAwareMetricsX(mx, my), contextAwareMetricsY(mx, my));
 631 
 632     return metrics;
 633 }
 634 
<span class="line-added"> 635 static jlong</span>
<span class="line-added"> 636     getGlyphImageNativeInternal(</span>
<span class="line-added"> 637         JNIEnv *env, jobject scaler, jobject font2D,</span>
<span class="line-added"> 638         jlong pScalerContext, jlong pScaler, jint glyphCode,</span>
<span class="line-added"> 639         jboolean renderImage);</span>
<span class="line-added"> 640 </span>
 641 /*
 642  * Class:     sun_font_FreetypeFontScaler
 643  * Method:    getGlyphAdvanceNative
 644  * Signature: (Lsun/font/Font2D;JI)F
 645  */
 646 JNIEXPORT jfloat JNICALL
 647 Java_sun_font_FreetypeFontScaler_getGlyphAdvanceNative(
 648         JNIEnv *env, jobject scaler, jobject font2D,
 649         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 650 
 651    /* This method is rarely used because requests for metrics are usually
<span class="line-modified"> 652     * coupled with a request for the bitmap and to a large extent the</span>
<span class="line-modified"> 653     * work can be reused (to find out metrics we may need to hint the glyph).</span>
<span class="line-modified"> 654     * So, we typically go through the getGlyphImage code path.</span>
<span class="line-modified"> 655     * When we do get here, we need to pass a parameter which indicates</span>
<span class="line-modified"> 656     * that we don&#39;t need freetype to render the bitmap, and consequently</span>
<span class="line-modified"> 657     * don&#39;t need to allocate our own storage either.</span>
<span class="line-modified"> 658     * This is also important when enter here requesting metrics for sizes</span>
<span class="line-modified"> 659     * of text which a large size would be rejected for a bitmap but we</span>
<span class="line-modified"> 660     * still need the metrics.</span>
<span class="line-modified"> 661     */</span>

 662 
 663     GlyphInfo *info;
<span class="line-modified"> 664     jfloat advance = 0.0f;</span>
 665     jlong image;
 666 
<span class="line-modified"> 667     image = getGlyphImageNativeInternal(</span>
<span class="line-modified"> 668           env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);</span>
 669     info = (GlyphInfo*) jlong_to_ptr(image);
 670 
<span class="line-modified"> 671     if (info != NULL) {</span>
<span class="line-modified"> 672         advance = info-&gt;advanceX;</span>
<span class="line-modified"> 673         free(info);</span>
<span class="line-added"> 674     }</span>
 675 
 676     return advance;
 677 }
 678 
 679 /*
 680  * Class:     sun_font_FreetypeFontScaler
 681  * Method:    getGlyphMetricsNative
 682  * Signature: (Lsun/font/Font2D;JILjava/awt/geom/Point2D/Float;)V
 683  */
 684 JNIEXPORT void JNICALL
 685 Java_sun_font_FreetypeFontScaler_getGlyphMetricsNative(
 686         JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,
 687         jlong pScaler, jint glyphCode, jobject metrics) {
 688 
<span class="line-modified"> 689      /* See the comments in getGlyphMetricsNative. They apply here too. */</span>





 690      GlyphInfo *info;
 691 
<span class="line-modified"> 692      jlong image = getGlyphImageNativeInternal(</span>
 693                                  env, scaler, font2D,
<span class="line-modified"> 694                                  pScalerContext, pScaler, glyphCode, JNI_FALSE);</span>
 695      info = (GlyphInfo*) jlong_to_ptr(image);
 696 
<span class="line-modified"> 697      if (info != NULL) {</span>
<span class="line-modified"> 698          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, info-&gt;advanceX);</span>
<span class="line-modified"> 699          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, info-&gt;advanceY);</span>
<span class="line-modified"> 700          free(info);</span>
<span class="line-added"> 701      } else {</span>
<span class="line-added"> 702          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.xFID, 0.0f);</span>
<span class="line-added"> 703          (*env)-&gt;SetFloatField(env, metrics, sunFontIDs.yFID, 0.0f);</span>
<span class="line-added"> 704      }</span>
 705 }
 706 
 707 
 708 static GlyphInfo* getNullGlyphImage() {
 709     GlyphInfo *glyphInfo =  (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
 710     return glyphInfo;
 711 }
 712 
 713 static void CopyBW2Grey8(const void* srcImage, int srcRowBytes,
 714                          void* dstImage, int dstRowBytes,
 715                          int width, int height) {
 716     const UInt8* srcRow = (UInt8*)srcImage;
 717     UInt8* dstRow = (UInt8*)dstImage;
 718     int wholeByteCount = width &gt;&gt; 3;
 719     int remainingBitsCount = width &amp; 7;
 720     int i, j;
 721 
 722     while (height--) {
 723         const UInt8* src8 = srcRow;
 724         UInt8* dstByte = dstRow;
</pre>
<hr />
<pre>
 791     unsigned char *srcRow = (unsigned char *) srcImage, *srcByte;
 792     unsigned char *dstRow = (unsigned char *) dstImage, *dstByte;
 793     int i;
 794 
 795     while (height &gt; 0) {
 796         srcByte = srcRow;
 797         dstByte = dstRow;
 798         for (i = 0; i &lt; width; i++) {
 799             *dstByte++ = *srcByte;
 800             *dstByte++ = *(srcByte + srcRowBytes);
 801             *dstByte++ = *(srcByte + 2*srcRowBytes);
 802             srcByte++;
 803         }
 804         srcRow += 3*srcRowBytes;
 805         dstRow += dstRowBytes;
 806         height -= 3;
 807     }
 808 }
 809 
 810 
<span class="line-added"> 811 /* JDK does not use glyph images for fonts with a</span>
<span class="line-added"> 812  * pixel size &gt; 100 (see THRESHOLD in OutlineTextRenderer.java)</span>
<span class="line-added"> 813  * so if the glyph bitmap image dimension is &gt; 1024 pixels,</span>
<span class="line-added"> 814  * something is up.</span>
<span class="line-added"> 815  */</span>
<span class="line-added"> 816 #define MAX_GLYPH_DIM 1024</span>
<span class="line-added"> 817 </span>
 818 /*
 819  * Class:     sun_font_FreetypeFontScaler
 820  * Method:    getGlyphImageNative
 821  * Signature: (Lsun/font/Font2D;JI)J
 822  */
 823 JNIEXPORT jlong JNICALL
 824 Java_sun_font_FreetypeFontScaler_getGlyphImageNative(
 825         JNIEnv *env, jobject scaler, jobject font2D,
 826         jlong pScalerContext, jlong pScaler, jint glyphCode) {
 827 
<span class="line-added"> 828     return getGlyphImageNativeInternal(</span>
<span class="line-added"> 829         env, scaler, font2D,</span>
<span class="line-added"> 830         pScalerContext, pScaler, glyphCode, JNI_TRUE);</span>
<span class="line-added"> 831 }</span>
<span class="line-added"> 832 </span>
<span class="line-added"> 833 static jlong</span>
<span class="line-added"> 834      getGlyphImageNativeInternal(</span>
<span class="line-added"> 835         JNIEnv *env, jobject scaler, jobject font2D,</span>
<span class="line-added"> 836         jlong pScalerContext, jlong pScaler, jint glyphCode,</span>
<span class="line-added"> 837         jboolean renderImage) {</span>
<span class="line-added"> 838 </span>
 839     int error, imageSize;
 840     UInt16 width, height;
 841     GlyphInfo *glyphInfo;
 842     int renderFlags = FT_LOAD_DEFAULT, target;
 843     FT_GlyphSlot ftglyph;
 844 
 845     FTScalerContext* context =
 846         (FTScalerContext*) jlong_to_ptr(pScalerContext);
 847     FTScalerInfo *scalerInfo =
 848              (FTScalerInfo*) jlong_to_ptr(pScaler);
 849 
 850     if (isNullScalerContext(context) || scalerInfo == NULL) {
 851         return ptr_to_jlong(getNullGlyphImage());
 852     }
 853 
 854     error = setupFTContext(env, font2D, scalerInfo, context);
 855     if (error) {
 856         invalidateJavaScaler(env, scaler, scalerInfo);
 857         return ptr_to_jlong(getNullGlyphImage());
 858     }
 859 
<span class="line-added"> 860     /*</span>
<span class="line-added"> 861      * When using Fractional metrics (linearly scaling advances) and</span>
<span class="line-added"> 862      * greyscale antialiasing, disable hinting so that the glyph shapes</span>
<span class="line-added"> 863      * are constant as size increases. This is good for animation as well</span>
<span class="line-added"> 864      * as being compatible with what happened in earlier JDK versions</span>
<span class="line-added"> 865      * which did not use freetype.</span>
<span class="line-added"> 866      */</span>
<span class="line-added"> 867     if (context-&gt;aaType == TEXT_AA_ON &amp;&amp; context-&gt;fmType == TEXT_FM_ON) {</span>
<span class="line-added"> 868          renderFlags |= FT_LOAD_NO_HINTING;</span>
<span class="line-added"> 869      }</span>
<span class="line-added"> 870 </span>
 871     if (!context-&gt;useSbits) {
 872         renderFlags |= FT_LOAD_NO_BITMAP;
 873     }
 874 
 875     /* NB: in case of non identity transform
 876      we might also prefer to disable transform before hinting,
 877      and apply it explicitly after hinting is performed.
 878      Or we can disable hinting. */
 879 
 880     /* select appropriate hinting mode */
 881     if (context-&gt;aaType == TEXT_AA_OFF) {
 882         target = FT_LOAD_TARGET_MONO;
 883     } else if (context-&gt;aaType == TEXT_AA_ON) {
 884         target = FT_LOAD_TARGET_NORMAL;
 885     } else if (context-&gt;aaType == TEXT_AA_LCD_HRGB ||
 886                context-&gt;aaType == TEXT_AA_LCD_HBGR) {
 887         target = FT_LOAD_TARGET_LCD;
 888     } else {
 889         target = FT_LOAD_TARGET_LCD_V;
 890     }
 891     renderFlags |= target;
 892 
 893     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
 894     if (error) {
 895         //do not destroy scaler yet.
 896         //this can be problem of particular context (e.g. with bad transform)
 897         return ptr_to_jlong(getNullGlyphImage());
 898     }
 899 
 900     ftglyph = scalerInfo-&gt;face-&gt;glyph;
 901 
 902     /* apply styles */
 903     if (context-&gt;doBold) { /* if bold style */
 904         FT_GlyphSlot_Embolden(ftglyph);
 905     }



 906 
 907     /* generate bitmap if it is not done yet
 908      e.g. if algorithmic styling is performed and style was added to outline */
<span class="line-modified"> 909     if (renderImage &amp;&amp; (ftglyph-&gt;format == FT_GLYPH_FORMAT_OUTLINE)) {</span>
<span class="line-added"> 910         FT_BBox bbox;</span>
<span class="line-added"> 911         FT_Outline_Get_CBox(&amp;(ftglyph-&gt;outline), &amp;bbox);</span>
<span class="line-added"> 912         int w = (int)((bbox.xMax&gt;&gt;6)-(bbox.xMin&gt;&gt;6));</span>
<span class="line-added"> 913         int h = (int)((bbox.yMax&gt;&gt;6)-(bbox.yMin&gt;&gt;6));</span>
<span class="line-added"> 914         if (w &gt; MAX_GLYPH_DIM || h &gt; MAX_GLYPH_DIM) {</span>
<span class="line-added"> 915             glyphInfo = getNullGlyphImage();</span>
<span class="line-added"> 916             return ptr_to_jlong(glyphInfo);</span>
<span class="line-added"> 917         }</span>
 918         error = FT_Render_Glyph(ftglyph, FT_LOAD_TARGET_MODE(target));
 919         if (error != 0) {
 920             return ptr_to_jlong(getNullGlyphImage());
 921         }
 922     }
 923 
<span class="line-modified"> 924     if (renderImage) {</span>
<span class="line-modified"> 925         width  = (UInt16) ftglyph-&gt;bitmap.width;</span>
<span class="line-added"> 926         height = (UInt16) ftglyph-&gt;bitmap.rows;</span>
<span class="line-added"> 927             if (width &gt; MAX_GLYPH_DIM || height &gt; MAX_GLYPH_DIM) {</span>
<span class="line-added"> 928               glyphInfo = getNullGlyphImage();</span>
<span class="line-added"> 929               return ptr_to_jlong(glyphInfo);</span>
<span class="line-added"> 930             }</span>
<span class="line-added"> 931      } else {</span>
<span class="line-added"> 932         width = 0;</span>
<span class="line-added"> 933         height = 0;</span>
<span class="line-added"> 934      }</span>
<span class="line-added"> 935 </span>
 936 
 937     imageSize = width*height;
 938     glyphInfo = (GlyphInfo*) malloc(sizeof(GlyphInfo) + imageSize);
 939     if (glyphInfo == NULL) {
 940         glyphInfo = getNullGlyphImage();
 941         return ptr_to_jlong(glyphInfo);
 942     }
 943     glyphInfo-&gt;cellInfo  = NULL;
 944     glyphInfo-&gt;managed   = UNMANAGED_GLYPH;
 945     glyphInfo-&gt;rowBytes  = width;
 946     glyphInfo-&gt;width     = width;
 947     glyphInfo-&gt;height    = height;


 948 
<span class="line-modified"> 949     if (renderImage) {</span>
<span class="line-modified"> 950         glyphInfo-&gt;topLeftX  = (float)  ftglyph-&gt;bitmap_left;</span>
<span class="line-modified"> 951         glyphInfo-&gt;topLeftY  = (float) -ftglyph-&gt;bitmap_top;</span>
<span class="line-modified"> 952 </span>
<span class="line-added"> 953         if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {</span>
<span class="line-added"> 954             glyphInfo-&gt;width = width/3;</span>
<span class="line-added"> 955         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {</span>
<span class="line-added"> 956             glyphInfo-&gt;height = glyphInfo-&gt;height/3;</span>
<span class="line-added"> 957         }</span>
 958     }
 959 
 960     if (context-&gt;fmType == TEXT_FM_ON) {
<span class="line-modified"> 961         float advh = FTFixedToFloat(ftglyph-&gt;linearHoriAdvance);</span>
 962         glyphInfo-&gt;advanceX =
 963             (float) (advh * FTFixedToFloat(context-&gt;transform.xx));
 964         glyphInfo-&gt;advanceY =
<span class="line-modified"> 965             (float) - (advh * FTFixedToFloat(context-&gt;transform.yx));</span>
 966     } else {
 967         if (!ftglyph-&gt;advance.y) {
 968             glyphInfo-&gt;advanceX =
 969                 (float) FT26Dot6ToInt(ftglyph-&gt;advance.x);
 970             glyphInfo-&gt;advanceY = 0;
 971         } else if (!ftglyph-&gt;advance.x) {
 972             glyphInfo-&gt;advanceX = 0;
 973             glyphInfo-&gt;advanceY =
 974                 (float) FT26Dot6ToInt(-ftglyph-&gt;advance.y);
 975         } else {
 976             glyphInfo-&gt;advanceX = FT26Dot6ToFloat(ftglyph-&gt;advance.x);
 977             glyphInfo-&gt;advanceY = FT26Dot6ToFloat(-ftglyph-&gt;advance.y);
 978         }
 979     }
 980 
 981     if (imageSize == 0) {
 982         glyphInfo-&gt;image = NULL;
 983     } else {
 984         glyphInfo-&gt;image = (unsigned char*) glyphInfo + sizeof(GlyphInfo);
 985         //convert result to output format
</pre>
<hr />
<pre>
1013                                      width,
1014                                      height);
1015         } else if (ftglyph-&gt;bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {
1016             /* 3 bytes per pixel to 3 bytes per pixel */
1017             CopyFTSubpixelVToSubpixel(ftglyph-&gt;bitmap.buffer,
1018                                       ftglyph-&gt;bitmap.pitch,
1019                                       (void *) glyphInfo-&gt;image,
1020                                       width*3,
1021                                       width,
1022                                       height);
1023             glyphInfo-&gt;rowBytes *=3;
1024         } else {
1025             free(glyphInfo);
1026             glyphInfo = getNullGlyphImage();
1027         }
1028     }
1029 
1030     return ptr_to_jlong(glyphInfo);
1031 }
1032 


























1033 /*
1034  * Class:     sun_font_FreetypeFontScaler
1035  * Method:    disposeNativeScaler
1036  * Signature: (J)V
1037  */
1038 JNIEXPORT void JNICALL
1039 Java_sun_font_FreetypeFontScaler_disposeNativeScaler(
1040         JNIEnv *env, jobject scaler, jobject font2D, jlong pScaler) {
1041     FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);
1042 
1043     /* Freetype functions *may* cause callback to java
1044        that can use cached values. Make sure our cache is up to date.
1045        NB: scaler context is not important at this point, can use NULL. */
1046     int errCode = setupFTContext(env, font2D, scalerInfo, NULL);
1047     if (errCode) {
1048         return;
1049     }
1050 
1051     freeNativeResources(env, scalerInfo);
1052 }
</pre>
<hr />
<pre>
1130     }
1131 
1132     error = setupFTContext(env, font2D, scalerInfo, context);
1133     if (error) {
1134         return NULL;
1135     }
1136 
1137     renderFlags = FT_LOAD_NO_HINTING | FT_LOAD_NO_BITMAP;
1138 
1139     error = FT_Load_Glyph(scalerInfo-&gt;face, glyphCode, renderFlags);
1140     if (error) {
1141         return NULL;
1142     }
1143 
1144     ftglyph = scalerInfo-&gt;face-&gt;glyph;
1145 
1146     /* apply styles */
1147     if (context-&gt;doBold) { /* if bold style */
1148         FT_GlyphSlot_Embolden(ftglyph);
1149     }



1150 
1151     FT_Outline_Translate(&amp;ftglyph-&gt;outline,
1152                          FloatToF26Dot6(xpos),
1153                          -FloatToF26Dot6(ypos));
1154 
1155     return &amp;ftglyph-&gt;outline;
1156 }
1157 
1158 #define F26Dot6ToFloat(n) (((float)(n))/((float) 64))
1159 
1160 /* Types of GeneralPath segments.
1161    TODO: pull constants from other place? */
1162 
1163 #define SEG_UNKNOWN -1
1164 #define SEG_MOVETO   0
1165 #define SEG_LINETO   1
1166 #define SEG_QUADTO   2
1167 #define SEG_CUBICTO  3
1168 #define SEG_CLOSE    4
1169 
</pre>
</td>
</tr>
</table>
<center><a href="HBShaper.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="harfbuzz/hb-blob.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
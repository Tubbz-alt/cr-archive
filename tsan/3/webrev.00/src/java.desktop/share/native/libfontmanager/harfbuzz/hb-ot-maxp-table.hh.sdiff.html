<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-maxp-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-map.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-name-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-maxp-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_MAXP_TABLE_HH
 28 #define HB_OT_MAXP_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-removed"> 31 #include &quot;hb-subset-plan.hh&quot;</span>
 32 
 33 namespace OT {
 34 
 35 
 36 /*
 37  * maxp -- Maximum Profile
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/maxp
 39  */
 40 
 41 #define HB_OT_TAG_maxp HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;x&#39;,&#39;p&#39;)
 42 
 43 struct maxpV1Tail
 44 {
<span class="line-modified"> 45   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 46   {
 47     TRACE_SANITIZE (this);
 48     return_trace (c-&gt;check_struct (this));
 49   }
 50 
 51   HBUINT16 maxPoints;             /* Maximum points in a non-composite glyph. */
 52   HBUINT16 maxContours;           /* Maximum contours in a non-composite glyph. */
 53   HBUINT16 maxCompositePoints;    /* Maximum points in a composite glyph. */
 54   HBUINT16 maxCompositeContours;  /* Maximum contours in a composite glyph. */
 55   HBUINT16 maxZones;              /* 1 if instructions do not use the twilight zone (Z0),
 56                                    * or 2 if instructions do use Z0; should be set to 2 in
 57                                    * most cases. */
 58   HBUINT16 maxTwilightPoints;     /* Maximum points used in Z0. */
 59   HBUINT16 maxStorage;            /* Number of Storage Area locations. */
 60   HBUINT16 maxFunctionDefs;       /* Number of FDEFs, equal to the highest function number + 1. */
 61   HBUINT16 maxInstructionDefs;    /* Number of IDEFs. */
 62   HBUINT16 maxStackElements;      /* Maximum stack depth. (This includes Font and CVT
 63                                    * Programs, as well as the instructions for each glyph.) */
 64   HBUINT16 maxSizeOfInstructions; /* Maximum byte count for glyph instructions. */
 65   HBUINT16 maxComponentElements;  /* Maximum number of components referenced at
 66                                    * &quot;top level&quot; for any composite glyph. */
 67   HBUINT16 maxComponentDepth;     /* Maximum levels of recursion; 1 for simple components. */
 68  public:
 69   DEFINE_SIZE_STATIC (26);
 70 };
 71 
 72 
 73 struct maxp
 74 {
<span class="line-modified"> 75   static const hb_tag_t tableTag = HB_OT_TAG_maxp;</span>
 76 
<span class="line-modified"> 77   inline unsigned int get_num_glyphs (void) const</span>
<span class="line-removed"> 78   {</span>
<span class="line-removed"> 79     return numGlyphs;</span>
<span class="line-removed"> 80   }</span>
 81 
<span class="line-modified"> 82   inline void set_num_glyphs (unsigned int count)</span>
 83   {
 84     numGlyphs.set (count);
 85   }
 86 
<span class="line-modified"> 87   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 88   {
 89     TRACE_SANITIZE (this);
 90     if (unlikely (!c-&gt;check_struct (this)))
 91       return_trace (false);
 92 
 93     if (version.major == 1)
 94     {
 95       const maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*this);
<span class="line-modified"> 96       return v1.sanitize (c);</span>
 97     }
 98     return_trace (likely (version.major == 0 &amp;&amp; version.minor == 0x5000u));
 99   }
100 
<span class="line-modified">101   inline bool subset (hb_subset_plan_t *plan) const</span>
102   {
<span class="line-modified">103     hb_blob_t *maxp_blob = OT::Sanitizer&lt;OT::maxp&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_maxp));</span>
104     hb_blob_t *maxp_prime_blob = hb_blob_copy_writable_or_fail (maxp_blob);
105     hb_blob_destroy (maxp_blob);
106 
107     if (unlikely (!maxp_prime_blob)) {
108       return false;
109     }
<span class="line-modified">110     OT::maxp *maxp_prime = (OT::maxp *) hb_blob_get_data (maxp_prime_blob, nullptr);</span>
111 
<span class="line-modified">112     maxp_prime-&gt;set_num_glyphs (plan-&gt;glyphs.len);</span>
113     if (plan-&gt;drop_hints)
114       drop_hint_fields (plan, maxp_prime);
115 
116     bool result = plan-&gt;add_table (HB_OT_TAG_maxp, maxp_prime_blob);
117     hb_blob_destroy (maxp_prime_blob);
118     return result;
119   }
120 
<span class="line-modified">121   static inline void drop_hint_fields (hb_subset_plan_t *plan, OT::maxp *maxp_prime)</span>
122   {
123     if (maxp_prime-&gt;version.major == 1)
124     {
125       maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*maxp_prime);
126       v1.maxZones.set (1);
127       v1.maxTwilightPoints.set (0);
128       v1.maxStorage.set (0);
129       v1.maxFunctionDefs.set (0);
130       v1.maxInstructionDefs.set (0);
131       v1.maxStackElements.set (0);
132       v1.maxSizeOfInstructions.set (0);
133     }
134   }
135 
136   protected:
137   FixedVersion&lt;&gt;version;                /* Version of the maxp table (0.5 or 1.0),
138                                          * 0x00005000u or 0x00010000u. */
139   HBUINT16      numGlyphs;              /* The number of glyphs in the font. */
<span class="line-modified">140 /*maxpV1Tail v1Tail[VAR]; */</span>
141   public:
142   DEFINE_SIZE_STATIC (6);
143 };
144 
145 
146 } /* namespace OT */
147 
148 
149 #endif /* HB_OT_MAXP_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_MAXP_TABLE_HH
 28 #define HB_OT_MAXP_TABLE_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>

 31 
 32 namespace OT {
 33 
 34 
 35 /*
 36  * maxp -- Maximum Profile
 37  * https://docs.microsoft.com/en-us/typography/opentype/spec/maxp
 38  */
 39 
 40 #define HB_OT_TAG_maxp HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;x&#39;,&#39;p&#39;)
 41 
 42 struct maxpV1Tail
 43 {
<span class="line-modified"> 44   bool sanitize (hb_sanitize_context_t *c) const</span>
 45   {
 46     TRACE_SANITIZE (this);
 47     return_trace (c-&gt;check_struct (this));
 48   }
 49 
 50   HBUINT16 maxPoints;             /* Maximum points in a non-composite glyph. */
 51   HBUINT16 maxContours;           /* Maximum contours in a non-composite glyph. */
 52   HBUINT16 maxCompositePoints;    /* Maximum points in a composite glyph. */
 53   HBUINT16 maxCompositeContours;  /* Maximum contours in a composite glyph. */
 54   HBUINT16 maxZones;              /* 1 if instructions do not use the twilight zone (Z0),
 55                                    * or 2 if instructions do use Z0; should be set to 2 in
 56                                    * most cases. */
 57   HBUINT16 maxTwilightPoints;     /* Maximum points used in Z0. */
 58   HBUINT16 maxStorage;            /* Number of Storage Area locations. */
 59   HBUINT16 maxFunctionDefs;       /* Number of FDEFs, equal to the highest function number + 1. */
 60   HBUINT16 maxInstructionDefs;    /* Number of IDEFs. */
 61   HBUINT16 maxStackElements;      /* Maximum stack depth. (This includes Font and CVT
 62                                    * Programs, as well as the instructions for each glyph.) */
 63   HBUINT16 maxSizeOfInstructions; /* Maximum byte count for glyph instructions. */
 64   HBUINT16 maxComponentElements;  /* Maximum number of components referenced at
 65                                    * &quot;top level&quot; for any composite glyph. */
 66   HBUINT16 maxComponentDepth;     /* Maximum levels of recursion; 1 for simple components. */
 67  public:
 68   DEFINE_SIZE_STATIC (26);
 69 };
 70 
 71 
 72 struct maxp
 73 {
<span class="line-modified"> 74   static constexpr hb_tag_t tableTag = HB_OT_TAG_maxp;</span>
 75 
<span class="line-modified"> 76   unsigned int get_num_glyphs () const { return numGlyphs; }</span>



 77 
<span class="line-modified"> 78   void set_num_glyphs (unsigned int count)</span>
 79   {
 80     numGlyphs.set (count);
 81   }
 82 
<span class="line-modified"> 83   bool sanitize (hb_sanitize_context_t *c) const</span>
 84   {
 85     TRACE_SANITIZE (this);
 86     if (unlikely (!c-&gt;check_struct (this)))
 87       return_trace (false);
 88 
 89     if (version.major == 1)
 90     {
 91       const maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*this);
<span class="line-modified"> 92       return_trace (v1.sanitize (c));</span>
 93     }
 94     return_trace (likely (version.major == 0 &amp;&amp; version.minor == 0x5000u));
 95   }
 96 
<span class="line-modified"> 97   bool subset (hb_subset_plan_t *plan) const</span>
 98   {
<span class="line-modified"> 99     hb_blob_t *maxp_blob = hb_sanitize_context_t().reference_table&lt;maxp&gt; (plan-&gt;source);</span>
100     hb_blob_t *maxp_prime_blob = hb_blob_copy_writable_or_fail (maxp_blob);
101     hb_blob_destroy (maxp_blob);
102 
103     if (unlikely (!maxp_prime_blob)) {
104       return false;
105     }
<span class="line-modified">106     maxp *maxp_prime = (maxp *) hb_blob_get_data (maxp_prime_blob, nullptr);</span>
107 
<span class="line-modified">108     maxp_prime-&gt;set_num_glyphs (plan-&gt;glyphs.length);</span>
109     if (plan-&gt;drop_hints)
110       drop_hint_fields (plan, maxp_prime);
111 
112     bool result = plan-&gt;add_table (HB_OT_TAG_maxp, maxp_prime_blob);
113     hb_blob_destroy (maxp_prime_blob);
114     return result;
115   }
116 
<span class="line-modified">117   static void drop_hint_fields (hb_subset_plan_t *plan HB_UNUSED, maxp *maxp_prime)</span>
118   {
119     if (maxp_prime-&gt;version.major == 1)
120     {
121       maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*maxp_prime);
122       v1.maxZones.set (1);
123       v1.maxTwilightPoints.set (0);
124       v1.maxStorage.set (0);
125       v1.maxFunctionDefs.set (0);
126       v1.maxInstructionDefs.set (0);
127       v1.maxStackElements.set (0);
128       v1.maxSizeOfInstructions.set (0);
129     }
130   }
131 
132   protected:
133   FixedVersion&lt;&gt;version;                /* Version of the maxp table (0.5 or 1.0),
134                                          * 0x00005000u or 0x00010000u. */
135   HBUINT16      numGlyphs;              /* The number of glyphs in the font. */
<span class="line-modified">136 /*maxpV1Tail    v1Tail[VAR]; */</span>
137   public:
138   DEFINE_SIZE_STATIC (6);
139 };
140 
141 
142 } /* namespace OT */
143 
144 
145 #endif /* HB_OT_MAXP_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-map.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-name-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
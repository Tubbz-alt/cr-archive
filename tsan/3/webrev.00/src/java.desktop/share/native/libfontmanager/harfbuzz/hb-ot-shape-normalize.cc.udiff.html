<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-fallback.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape.cc.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-normalize.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,13 +22,13 @@</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-normalize.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-complex.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape.hh&quot;</span>
  
  
  /*
   * HIGHLEVEL DESIGN:
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -211,21 +211,23 @@</span>
  
    next_char (buffer, glyph); /* glyph is initialized in earlier branches. */
  }
  
  static inline void
<span class="udiff-line-modified-removed">- handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)</span>
<span class="udiff-line-modified-added">+ handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c,</span>
<span class="udiff-line-added">+                                    unsigned int end,</span>
<span class="udiff-line-added">+                                    bool short_circuit HB_UNUSED)</span>
  {
    /* TODO Currently if there&#39;s a variation-selector we give-up, it&#39;s just too hard. */
    hb_buffer_t * const buffer = c-&gt;buffer;
    hb_font_t * const font = c-&gt;font;
    for (; buffer-&gt;idx &lt; end - 1 &amp;&amp; buffer-&gt;successful;) {
      if (unlikely (buffer-&gt;unicode-&gt;is_variation_selector (buffer-&gt;cur(+1).codepoint))) {
<span class="udiff-line-removed">-       /* The next two lines are some ugly lines... But work. */</span>
        if (font-&gt;get_variation_glyph (buffer-&gt;cur().codepoint, buffer-&gt;cur(+1).codepoint, &amp;buffer-&gt;cur().glyph_index()))
        {
<span class="udiff-line-modified-removed">-         buffer-&gt;replace_glyphs (2, 1, &amp;buffer-&gt;cur().codepoint);</span>
<span class="udiff-line-modified-added">+         hb_codepoint_t unicode = buffer-&gt;cur().codepoint;</span>
<span class="udiff-line-added">+         buffer-&gt;replace_glyphs (2, 1, &amp;unicode);</span>
        }
        else
        {
          /* Just pass on the two characters separately, let GSUB do its magic. */
          set_glyph (buffer-&gt;cur(), font);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -262,19 +264,10 @@</span>
  
    while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)
      decompose_current_character (c, short_circuit);
  }
  
<span class="udiff-line-removed">- static inline void</span>
<span class="udiff-line-removed">- decompose_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool might_short_circuit, bool always_short_circuit)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (likely (c-&gt;buffer-&gt;idx + 1 == end))</span>
<span class="udiff-line-removed">-     decompose_current_character (c, might_short_circuit);</span>
<span class="udiff-line-removed">-   else</span>
<span class="udiff-line-removed">-     decompose_multi_char_cluster (c, end, always_short_circuit);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  
  static int
  compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)
  {
    unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -292,10 +285,20 @@</span>
    if (unlikely (!buffer-&gt;len)) return;
  
    _hb_buffer_assert_unicode_vars (buffer);
  
    hb_ot_shape_normalization_mode_t mode = plan-&gt;shaper-&gt;normalization_preference;
<span class="udiff-line-added">+   if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_AUTO)</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     if (plan-&gt;has_gpos_mark)</span>
<span class="udiff-line-added">+       // https://github.com/harfbuzz/harfbuzz/issues/653#issuecomment-423905920</span>
<span class="udiff-line-added">+       //mode = HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;</span>
<span class="udiff-line-added">+       mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+       mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
    const hb_ot_shape_normalize_context_t c = {
      plan,
      buffer,
      font,
      buffer-&gt;unicode,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -316,109 +319,85 @@</span>
     * this way. */
  
  
    /* First round, decompose */
  
<span class="udiff-line-modified-removed">-   buffer-&gt;clear_output ();</span>
<span class="udiff-line-removed">-   count = buffer-&gt;len;</span>
<span class="udiff-line-removed">-   for (buffer-&gt;idx = 0; buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful;)</span>
<span class="udiff-line-modified-added">+   bool all_simple = true;</span>
    {
<span class="udiff-line-modified-removed">-     unsigned int end;</span>
<span class="udiff-line-modified-removed">-     for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="udiff-line-modified-removed">-       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end]))))</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     decompose_cluster (&amp;c, end, might_short_circuit, always_short_circuit);</span>
<span class="udiff-line-modified-removed">-   }</span>
<span class="udiff-line-modified-removed">-   buffer-&gt;swap_buffers ();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-added">+     buffer-&gt;clear_output ();</span>
<span class="udiff-line-modified-added">+     count = buffer-&gt;len;</span>
<span class="udiff-line-modified-added">+     buffer-&gt;idx = 0;</span>
<span class="udiff-line-modified-added">+     do</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       unsigned int end;</span>
<span class="udiff-line-modified-added">+       for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="udiff-line-modified-added">+         if (unlikely (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end]))))</span>
<span class="udiff-line-modified-added">+           break;</span>
  
<span class="udiff-line-modified-removed">-   /* Second round, reorder (inplace) */</span>
<span class="udiff-line-modified-added">+       if (end &lt; count)</span>
<span class="udiff-line-added">+         end--; /* Leave one base for the marks to cluster with. */</span>
  
<span class="udiff-line-modified-removed">-   count = buffer-&gt;len;</span>
<span class="udiff-line-modified-removed">-   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-modified-removed">-   {</span>
<span class="udiff-line-modified-removed">-     if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[i]) == 0)</span>
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-added">+       /* From idx to end are simple clusters. */</span>
<span class="udiff-line-modified-added">+       if (might_short_circuit)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         unsigned int done = font-&gt;get_nominal_glyphs (end - buffer-&gt;idx,</span>
<span class="udiff-line-modified-added">+                                                       &amp;buffer-&gt;cur().codepoint,</span>
<span class="udiff-line-added">+                                                       sizeof (buffer-&gt;info[0]),</span>
<span class="udiff-line-added">+                                                       &amp;buffer-&gt;cur().glyph_index(),</span>
<span class="udiff-line-added">+                                                       sizeof (buffer-&gt;info[0]));</span>
<span class="udiff-line-added">+         buffer-&gt;next_glyphs (done);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       while (buffer-&gt;idx &lt; end &amp;&amp; buffer-&gt;successful)</span>
<span class="udiff-line-added">+         decompose_current_character (&amp;c, might_short_circuit);</span>
  
<span class="udiff-line-modified-removed">-     unsigned int end;</span>
<span class="udiff-line-removed">-     for (end = i + 1; end &lt; count; end++)</span>
<span class="udiff-line-removed">-       if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[end]) == 0)</span>
<span class="udiff-line-modified-added">+       if (buffer-&gt;idx == count || !buffer-&gt;successful)</span>
          break;
  
<span class="udiff-line-modified-removed">-     /* We are going to do a O(n^2).  Only do this if the sequence is short. */</span>
<span class="udiff-line-removed">-     if (end - i &gt; HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {</span>
<span class="udiff-line-removed">-       i = end;</span>
<span class="udiff-line-removed">-       continue;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     buffer-&gt;sort (i, end, compare_combining_class);</span>
<span class="udiff-line-modified-added">+       all_simple = false;</span>
  
<span class="udiff-line-modified-removed">-     if (plan-&gt;shaper-&gt;reorder_marks)</span>
<span class="udiff-line-modified-removed">-       plan-&gt;shaper-&gt;reorder_marks (plan, buffer, i, end);</span>
<span class="udiff-line-modified-added">+       /* Find all the marks now. */</span>
<span class="udiff-line-modified-added">+       for (end = buffer-&gt;idx + 1; end &lt; count; end++)</span>
<span class="udiff-line-added">+         if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;info[end])))</span>
<span class="udiff-line-added">+           break;</span>
  
<span class="udiff-line-modified-removed">-     i = end;</span>
<span class="udiff-line-modified-added">+       /* idx to end is one non-simple cluster. */</span>
<span class="udiff-line-added">+       decompose_multi_char_cluster (&amp;c, end, always_short_circuit);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful);</span>
<span class="udiff-line-added">+     buffer-&gt;swap_buffers ();</span>
    }
  
  
<span class="udiff-line-modified-removed">-   if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE ||</span>
<span class="udiff-line-removed">-       mode == HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED)</span>
<span class="udiff-line-removed">-     return;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* Third round, recompose */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /* As noted in the comment earlier, we don&#39;t try to combine</span>
<span class="udiff-line-removed">-    * ccc=0 chars with their previous Starter. */</span>
<span class="udiff-line-modified-added">+   /* Second round, reorder (inplace) */</span>
  
<span class="udiff-line-modified-removed">-   buffer-&gt;clear_output ();</span>
<span class="udiff-line-removed">-   count = buffer-&gt;len;</span>
<span class="udiff-line-removed">-   unsigned int starter = 0;</span>
<span class="udiff-line-removed">-   buffer-&gt;next_glyph ();</span>
<span class="udiff-line-removed">-   while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful)</span>
<span class="udiff-line-modified-added">+   if (!all_simple)</span>
    {
<span class="udiff-line-modified-removed">-     hb_codepoint_t composed, glyph;</span>
<span class="udiff-line-modified-removed">-     if (/* We don&#39;t try to compose a non-mark character with it&#39;s preceding starter.</span>
<span class="udiff-line-removed">-          * This is both an optimization to avoid trying to compose every two neighboring</span>
<span class="udiff-line-removed">-          * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul</span>
<span class="udiff-line-removed">-          * fonts are not designed to mix-and-match pre-composed syllables and Jamo. */</span>
<span class="udiff-line-removed">-         HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;cur())))</span>
<span class="udiff-line-modified-added">+     count = buffer-&gt;len;</span>
<span class="udiff-line-modified-added">+     for (unsigned int i = 0; i &lt; count; i++)</span>
      {
<span class="udiff-line-modified-removed">-       if (/* If there&#39;s anything between the starter and this char, they should have CCC</span>
<span class="udiff-line-modified-removed">-            * smaller than this character&#39;s. */</span>
<span class="udiff-line-modified-removed">-           (starter == buffer-&gt;out_len - 1 ||</span>
<span class="udiff-line-modified-removed">-            info_cc (buffer-&gt;prev()) &lt; info_cc (buffer-&gt;cur())) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           /* And compose. */</span>
<span class="udiff-line-modified-removed">-           c.compose (&amp;c,</span>
<span class="udiff-line-modified-removed">-                      buffer-&gt;out_info[starter].codepoint,</span>
<span class="udiff-line-removed">-                      buffer-&gt;cur().codepoint,</span>
<span class="udiff-line-removed">-                      &amp;composed) &amp;&amp;</span>
<span class="udiff-line-removed">-           /* And the font has glyph for the composite. */</span>
<span class="udiff-line-removed">-           font-&gt;get_nominal_glyph (composed, &amp;glyph))</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-removed">-         /* Composes. */</span>
<span class="udiff-line-removed">-         buffer-&gt;next_glyph (); /* Copy to out-buffer. */</span>
<span class="udiff-line-removed">-         if (unlikely (!buffer-&gt;successful))</span>
<span class="udiff-line-removed">-           return;</span>
<span class="udiff-line-removed">-         buffer-&gt;merge_out_clusters (starter, buffer-&gt;out_len);</span>
<span class="udiff-line-removed">-         buffer-&gt;out_len--; /* Remove the second composable. */</span>
<span class="udiff-line-removed">-         /* Modify starter and carry on. */</span>
<span class="udiff-line-removed">-         buffer-&gt;out_info[starter].codepoint = composed;</span>
<span class="udiff-line-removed">-         buffer-&gt;out_info[starter].glyph_index() = glyph;</span>
<span class="udiff-line-removed">-         _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;out_info[starter], buffer);</span>
<span class="udiff-line-modified-added">+       if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[i]) == 0)</span>
<span class="udiff-line-modified-added">+         continue;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+       unsigned int end;</span>
<span class="udiff-line-modified-added">+       for (end = i + 1; end &lt; count; end++)</span>
<span class="udiff-line-modified-added">+         if (_hb_glyph_info_get_modified_combining_class (&amp;buffer-&gt;info[end]) == 0)</span>
<span class="udiff-line-modified-added">+           break;</span>
  
<span class="udiff-line-added">+       /* We are going to do a O(n^2).  Only do this if the sequence is short. */</span>
<span class="udiff-line-added">+       if (end - i &gt; HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {</span>
<span class="udiff-line-added">+         i = end;</span>
          continue;
        }
<span class="udiff-line-removed">-     }</span>
  
<span class="udiff-line-modified-removed">-     /* Blocked, or doesn&#39;t compose. */</span>
<span class="udiff-line-removed">-     buffer-&gt;next_glyph ();</span>
<span class="udiff-line-modified-added">+       buffer-&gt;sort (i, end, compare_combining_class);</span>
  
<span class="udiff-line-modified-removed">-     if (info_cc (buffer-&gt;prev()) == 0)</span>
<span class="udiff-line-modified-removed">-       starter = buffer-&gt;out_len - 1;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">-   buffer-&gt;swap_buffers ();</span>
<span class="udiff-line-modified-added">+       if (plan-&gt;shaper-&gt;reorder_marks)</span>
<span class="udiff-line-modified-added">+         plan-&gt;shaper-&gt;reorder_marks (plan, buffer, i, end);</span>
  
<span class="udiff-line-added">+       i = end;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+   }</span>
    if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_CGJ)
    {
      /* For all CGJ, check if it prevented any reordering at all.
       * If it did NOT, then make it skippable.
       * https://github.com/harfbuzz/harfbuzz/issues/554
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -428,6 +407,65 @@</span>
            info_cc(buffer-&gt;info[i-1]) &lt;= info_cc(buffer-&gt;info[i+1]))
        {
          _hb_glyph_info_unhide (&amp;buffer-&gt;info[i]);
        }
    }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Third round, recompose */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (!all_simple &amp;&amp;</span>
<span class="udiff-line-added">+       (mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS ||</span>
<span class="udiff-line-added">+        mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT))</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     /* As noted in the comment earlier, we don&#39;t try to combine</span>
<span class="udiff-line-added">+      * ccc=0 chars with their previous Starter. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     buffer-&gt;clear_output ();</span>
<span class="udiff-line-added">+     count = buffer-&gt;len;</span>
<span class="udiff-line-added">+     unsigned int starter = 0;</span>
<span class="udiff-line-added">+     buffer-&gt;next_glyph ();</span>
<span class="udiff-line-added">+     while (buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       hb_codepoint_t composed, glyph;</span>
<span class="udiff-line-added">+       if (/* We don&#39;t try to compose a non-mark character with it&#39;s preceding starter.</span>
<span class="udiff-line-added">+            * This is both an optimization to avoid trying to compose every two neighboring</span>
<span class="udiff-line-added">+            * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul</span>
<span class="udiff-line-added">+            * fonts are not designed to mix-and-match pre-composed syllables and Jamo. */</span>
<span class="udiff-line-added">+           HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;buffer-&gt;cur())))</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         if (/* If there&#39;s anything between the starter and this char, they should have CCC</span>
<span class="udiff-line-added">+              * smaller than this character&#39;s. */</span>
<span class="udiff-line-added">+             (starter == buffer-&gt;out_len - 1 ||</span>
<span class="udiff-line-added">+              info_cc (buffer-&gt;prev()) &lt; info_cc (buffer-&gt;cur())) &amp;&amp;</span>
<span class="udiff-line-added">+             /* And compose. */</span>
<span class="udiff-line-added">+             c.compose (&amp;c,</span>
<span class="udiff-line-added">+                        buffer-&gt;out_info[starter].codepoint,</span>
<span class="udiff-line-added">+                        buffer-&gt;cur().codepoint,</span>
<span class="udiff-line-added">+                        &amp;composed) &amp;&amp;</span>
<span class="udiff-line-added">+             /* And the font has glyph for the composite. */</span>
<span class="udiff-line-added">+             font-&gt;get_nominal_glyph (composed, &amp;glyph))</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           /* Composes. */</span>
<span class="udiff-line-added">+           buffer-&gt;next_glyph (); /* Copy to out-buffer. */</span>
<span class="udiff-line-added">+           if (unlikely (!buffer-&gt;successful))</span>
<span class="udiff-line-added">+             return;</span>
<span class="udiff-line-added">+           buffer-&gt;merge_out_clusters (starter, buffer-&gt;out_len);</span>
<span class="udiff-line-added">+           buffer-&gt;out_len--; /* Remove the second composable. */</span>
<span class="udiff-line-added">+           /* Modify starter and carry on. */</span>
<span class="udiff-line-added">+           buffer-&gt;out_info[starter].codepoint = composed;</span>
<span class="udiff-line-added">+           buffer-&gt;out_info[starter].glyph_index() = glyph;</span>
<span class="udiff-line-added">+           _hb_glyph_info_set_unicode_props (&amp;buffer-&gt;out_info[starter], buffer);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+           continue;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       /* Blocked, or doesn&#39;t compose. */</span>
<span class="udiff-line-added">+       buffer-&gt;next_glyph ();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (info_cc (buffer-&gt;prev()) == 0)</span>
<span class="udiff-line-added">+         starter = buffer-&gt;out_len - 1;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     buffer-&gt;swap_buffers ();</span>
<span class="udiff-line-added">+   }</span>
  }
</pre>
<center><a href="hb-ot-shape-fallback.cc.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape.cc.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-set.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-shape.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-debug.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-shape-plan-private.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-shaper-private.hh&quot;</span>
<span class="line-modified"> 31 #include &quot;hb-font-private.hh&quot;</span>
<span class="line-modified"> 32 #include &quot;hb-buffer-private.hh&quot;</span>
<span class="line-modified"> 33 </span>
<span class="line-modified"> 34 </span>
<span class="line-modified"> 35 static void</span>
<span class="line-modified"> 36 hb_shape_plan_plan (hb_shape_plan_t    *shape_plan,</span>
<span class="line-modified"> 37                     const hb_feature_t *user_features,</span>
<span class="line-modified"> 38                     unsigned int        num_user_features,</span>
<span class="line-modified"> 39                     const int          *coords,</span>
<span class="line-modified"> 40                     unsigned int        num_coords,</span>
<span class="line-modified"> 41                     const char * const *shaper_list)</span>


















 42 {
<span class="line-modified"> 43   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,</span>
<span class="line-modified"> 44                   &quot;num_features=%d num_coords=%d shaper_list=%p&quot;,</span>
<span class="line-modified"> 45                   num_user_features,</span>
<span class="line-modified"> 46                   num_coords,</span>
<span class="line-modified"> 47                   shaper_list);</span>

















 48 
<span class="line-modified"> 49   const hb_shaper_pair_t *shapers = _hb_shapers_get ();</span>


 50 
 51 #define HB_SHAPER_PLAN(shaper) \
 52         HB_STMT_START { \
<span class="line-modified"> 53           if (hb_##shaper##_shaper_face_data_ensure (shape_plan-&gt;face_unsafe)) { \</span>
<span class="line-modified"> 54             HB_SHAPER_DATA (shaper, shape_plan) = \</span>
<span class="line-modified"> 55               HB_SHAPER_DATA_CREATE_FUNC (shaper, shape_plan) (shape_plan, \</span>
<span class="line-modified"> 56                                                                user_features, num_user_features, \</span>
<span class="line-modified"> 57                                                                coords, num_coords); \</span>
<span class="line-removed"> 58             shape_plan-&gt;shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-removed"> 59             shape_plan-&gt;shaper_name = #shaper; \</span>
<span class="line-removed"> 60             return; \</span>
 61           } \
 62         } HB_STMT_END
 63 
<span class="line-modified"> 64   if (likely (!shaper_list)) {</span>
<span class="line-modified"> 65     for (unsigned int i = 0; i &lt; HB_SHAPERS_COUNT; i++)</span>
<span class="line-modified"> 66       if (0)</span>

 67         ;
 68 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified"> 69       else if (shapers[i].func == _hb_##shaper##_shape) \</span>
 70         HB_SHAPER_PLAN (shaper);
 71 #include &quot;hb-shaper-list.hh&quot;
 72 #undef HB_SHAPER_IMPLEMENT
<span class="line-modified"> 73   } else {</span>
<span class="line-modified"> 74     for (; *shaper_list; shaper_list++)</span>
<span class="line-modified"> 75       if (0)</span>



 76         ;
 77 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified"> 78       else if (0 == strcmp (*shaper_list, #shaper)) \</span>
 79         HB_SHAPER_PLAN (shaper);
 80 #include &quot;hb-shaper-list.hh&quot;
 81 #undef HB_SHAPER_IMPLEMENT
 82   }
<span class="line-removed"> 83 </span>
 84 #undef HB_SHAPER_PLAN































 85 }
 86 
 87 
 88 /*
 89  * hb_shape_plan_t
 90  */
 91 

 92 /**
 93  * hb_shape_plan_create: (Xconstructor)
 94  * @face:
 95  * @props:
 96  * @user_features: (array length=num_user_features):
 97  * @num_user_features:
 98  * @shaper_list: (array zero-terminated=1):
 99  *
100  *
101  *
102  * Return value: (transfer full):
103  *
104  * Since: 0.9.7
105  **/
106 hb_shape_plan_t *
107 hb_shape_plan_create (hb_face_t                     *face,
108                       const hb_segment_properties_t *props,
109                       const hb_feature_t            *user_features,
110                       unsigned int                   num_user_features,
111                       const char * const            *shaper_list)
112 {
113   return hb_shape_plan_create2 (face, props,
114                                 user_features, num_user_features,
115                                 nullptr, 0,
116                                 shaper_list);
117 }
118 
119 hb_shape_plan_t *
120 hb_shape_plan_create2 (hb_face_t                     *face,
121                        const hb_segment_properties_t *props,
122                        const hb_feature_t            *user_features,
123                        unsigned int                   num_user_features,
<span class="line-modified">124                        const int                     *orig_coords,</span>
125                        unsigned int                   num_coords,
126                        const char * const            *shaper_list)
127 {
128   DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
129                   &quot;face=%p num_features=%d num_coords=%d shaper_list=%p&quot;,
130                   face,
131                   num_user_features,
132                   num_coords,
133                   shaper_list);
134 


135   hb_shape_plan_t *shape_plan;
<span class="line-removed">136   hb_feature_t *features = nullptr;</span>
<span class="line-removed">137   int *coords = nullptr;</span>
138 
<span class="line-removed">139   if (unlikely (!face))</span>
<span class="line-removed">140     face = hb_face_get_empty ();</span>
141   if (unlikely (!props))
<span class="line-modified">142     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">143   if (num_user_features &amp;&amp; !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))</span>
<span class="line-removed">144     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">145   if (num_coords &amp;&amp; !(coords = (int *) calloc (num_coords, sizeof (int))))</span>
<span class="line-removed">146   {</span>
<span class="line-removed">147     free (features);</span>
<span class="line-removed">148     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">149   }</span>
150   if (!(shape_plan = hb_object_create&lt;hb_shape_plan_t&gt; ()))
<span class="line-modified">151   {</span>
<span class="line-removed">152     free (coords);</span>
<span class="line-removed">153     free (features);</span>
<span class="line-removed">154     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">155   }</span>
<span class="line-removed">156 </span>
<span class="line-removed">157   assert (props-&gt;direction != HB_DIRECTION_INVALID);</span>
158 


159   hb_face_make_immutable (face);
<span class="line-removed">160   shape_plan-&gt;default_shaper_list = !shaper_list;</span>
161   shape_plan-&gt;face_unsafe = face;
<span class="line-removed">162   shape_plan-&gt;props = *props;</span>
<span class="line-removed">163   shape_plan-&gt;num_user_features = num_user_features;</span>
<span class="line-removed">164   shape_plan-&gt;user_features = features;</span>
<span class="line-removed">165   if (num_user_features)</span>
<span class="line-removed">166     memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));</span>
<span class="line-removed">167   shape_plan-&gt;num_coords = num_coords;</span>
<span class="line-removed">168   shape_plan-&gt;coords = coords;</span>
<span class="line-removed">169   if (num_coords)</span>
<span class="line-removed">170     memcpy (coords, orig_coords, num_coords * sizeof (int));</span>
171 
<span class="line-modified">172   hb_shape_plan_plan (shape_plan,</span>
<span class="line-modified">173                       user_features, num_user_features,</span>
<span class="line-modified">174                       coords, num_coords,</span>
<span class="line-modified">175                       shaper_list);</span>







176 
177   return shape_plan;







178 }
179 
180 /**
181  * hb_shape_plan_get_empty:
182  *
183  *
184  *
185  * Return value: (transfer full):
186  *
187  * Since: 0.9.7
188  **/
189 hb_shape_plan_t *
<span class="line-modified">190 hb_shape_plan_get_empty (void)</span>
191 {
<span class="line-modified">192   static const hb_shape_plan_t _hb_shape_plan_nil = {</span>
<span class="line-removed">193     HB_OBJECT_HEADER_STATIC,</span>
<span class="line-removed">194 </span>
<span class="line-removed">195     true, /* default_shaper_list */</span>
<span class="line-removed">196     nullptr, /* face */</span>
<span class="line-removed">197     HB_SEGMENT_PROPERTIES_DEFAULT, /* props */</span>
<span class="line-removed">198 </span>
<span class="line-removed">199     nullptr, /* shaper_func */</span>
<span class="line-removed">200     nullptr, /* shaper_name */</span>
<span class="line-removed">201 </span>
<span class="line-removed">202     nullptr, /* user_features */</span>
<span class="line-removed">203     0,    /* num_user_featurs */</span>
<span class="line-removed">204 </span>
<span class="line-removed">205     nullptr, /* coords */</span>
<span class="line-removed">206     0,    /* num_coords */</span>
<span class="line-removed">207 </span>
<span class="line-removed">208     {</span>
<span class="line-removed">209 #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,</span>
<span class="line-removed">210 #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">211 #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">212     }</span>
<span class="line-removed">213   };</span>
<span class="line-removed">214 </span>
<span class="line-removed">215   return const_cast&lt;hb_shape_plan_t *&gt; (&amp;_hb_shape_plan_nil);</span>
216 }
217 
218 /**
219  * hb_shape_plan_reference: (skip)
220  * @shape_plan: a shape plan.
221  *
222  *
223  *
224  * Return value: (transfer full):
225  *
226  * Since: 0.9.7
227  **/
228 hb_shape_plan_t *
229 hb_shape_plan_reference (hb_shape_plan_t *shape_plan)
230 {
231   return hb_object_reference (shape_plan);
232 }
233 
234 /**
235  * hb_shape_plan_destroy: (skip)
236  * @shape_plan: a shape plan.
237  *
238  *
239  *
240  * Since: 0.9.7
241  **/
242 void
243 hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)
244 {
245   if (!hb_object_destroy (shape_plan)) return;
246 
<span class="line-modified">247 #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, shape_plan);</span>
<span class="line-modified">248 #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">249 #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">250 </span>
<span class="line-removed">251   free (shape_plan-&gt;user_features);</span>
<span class="line-removed">252   free (shape_plan-&gt;coords);</span>
<span class="line-removed">253 </span>
254   free (shape_plan);
255 }
256 
257 /**
258  * hb_shape_plan_set_user_data: (skip)
259  * @shape_plan: a shape plan.
260  * @key:
261  * @data:
262  * @destroy:
263  * @replace:
264  *
265  *
266  *
267  * Return value:
268  *
269  * Since: 0.9.7
270  **/
271 hb_bool_t
272 hb_shape_plan_set_user_data (hb_shape_plan_t    *shape_plan,
273                              hb_user_data_key_t *key,
</pre>
<hr />
<pre>
279 }
280 
281 /**
282  * hb_shape_plan_get_user_data: (skip)
283  * @shape_plan: a shape plan.
284  * @key:
285  *
286  *
287  *
288  * Return value: (transfer none):
289  *
290  * Since: 0.9.7
291  **/
292 void *
293 hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,
294                              hb_user_data_key_t *key)
295 {
296   return hb_object_get_user_data (shape_plan, key);
297 }
298 
















299 
300 /**
301  * hb_shape_plan_execute:
302  * @shape_plan: a shape plan.
303  * @font: a font.
304  * @buffer: a buffer.
305  * @features: (array length=num_features):
306  * @num_features:
307  *
308  *
309  *
310  * Return value:
311  *
312  * Since: 0.9.7
313  **/
314 hb_bool_t
315 hb_shape_plan_execute (hb_shape_plan_t    *shape_plan,
316                        hb_font_t          *font,
317                        hb_buffer_t        *buffer,
318                        const hb_feature_t *features,
319                        unsigned int        num_features)
320 {
321   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,
322                   &quot;num_features=%d shaper_func=%p, shaper_name=%s&quot;,
323                   num_features,
<span class="line-modified">324                   shape_plan-&gt;shaper_func,</span>
<span class="line-modified">325                   shape_plan-&gt;shaper_name);</span>
326 
327   if (unlikely (!buffer-&gt;len))
328     return true;
329 
<span class="line-modified">330   assert (!hb_object_is_inert (buffer));</span>
331   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE);
332 
333   if (unlikely (hb_object_is_inert (shape_plan)))
334     return false;
335 
336   assert (shape_plan-&gt;face_unsafe == font-&gt;face);
<span class="line-modified">337   assert (hb_segment_properties_equal (&amp;shape_plan-&gt;props, &amp;buffer-&gt;props));</span>
338 
339 #define HB_SHAPER_EXECUTE(shaper) \
340         HB_STMT_START { \
<span class="line-modified">341           return HB_SHAPER_DATA (shaper, shape_plan) &amp;&amp; \</span>
<span class="line-removed">342                  hb_##shaper##_shaper_font_data_ensure (font) &amp;&amp; \</span>
343                  _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
344         } HB_STMT_END
345 
<span class="line-modified">346   if (0)</span>
347     ;
348 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">349   else if (shape_plan-&gt;shaper_func == _hb_##shaper##_shape) \</span>
350     HB_SHAPER_EXECUTE (shaper);
351 #include &quot;hb-shaper-list.hh&quot;
352 #undef HB_SHAPER_IMPLEMENT
353 
354 #undef HB_SHAPER_EXECUTE
355 
356   return false;
357 }
358 
359 
360 /*
<span class="line-modified">361  * caching</span>
<span class="line-removed">362  */</span>
<span class="line-removed">363 </span>
<span class="line-removed">364 #if 0</span>
<span class="line-removed">365 static unsigned int</span>
<span class="line-removed">366 hb_shape_plan_hash (const hb_shape_plan_t *shape_plan)</span>
<span class="line-removed">367 {</span>
<span class="line-removed">368   return hb_segment_properties_hash (&amp;shape_plan-&gt;props) +</span>
<span class="line-removed">369          shape_plan-&gt;default_shaper_list ? 0 : (intptr_t) shape_plan-&gt;shaper_func;</span>
<span class="line-removed">370 }</span>
<span class="line-removed">371 #endif</span>
<span class="line-removed">372 </span>
<span class="line-removed">373 /* User-feature caching is currently somewhat dumb:</span>
<span class="line-removed">374  * it only finds matches where the feature array is identical,</span>
<span class="line-removed">375  * not cases where the feature lists would be compatible for plan purposes</span>
<span class="line-removed">376  * but have different ranges, for example.</span>
377  */
<span class="line-removed">378 struct hb_shape_plan_proposal_t</span>
<span class="line-removed">379 {</span>
<span class="line-removed">380   const hb_segment_properties_t  props;</span>
<span class="line-removed">381   const char * const            *shaper_list;</span>
<span class="line-removed">382   const hb_feature_t            *user_features;</span>
<span class="line-removed">383   unsigned int                   num_user_features;</span>
<span class="line-removed">384   const int                     *coords;</span>
<span class="line-removed">385   unsigned int                   num_coords;</span>
<span class="line-removed">386   hb_shape_func_t               *shaper_func;</span>
<span class="line-removed">387 };</span>
<span class="line-removed">388 </span>
<span class="line-removed">389 static inline hb_bool_t</span>
<span class="line-removed">390 hb_shape_plan_user_features_match (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">391                                    const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">392 {</span>
<span class="line-removed">393   if (proposal-&gt;num_user_features != shape_plan-&gt;num_user_features)</span>
<span class="line-removed">394     return false;</span>
<span class="line-removed">395   for (unsigned int i = 0, n = proposal-&gt;num_user_features; i &lt; n; i++)</span>
<span class="line-removed">396     if (proposal-&gt;user_features[i].tag   != shape_plan-&gt;user_features[i].tag   ||</span>
<span class="line-removed">397         proposal-&gt;user_features[i].value != shape_plan-&gt;user_features[i].value ||</span>
<span class="line-removed">398         proposal-&gt;user_features[i].start != shape_plan-&gt;user_features[i].start ||</span>
<span class="line-removed">399         proposal-&gt;user_features[i].end   != shape_plan-&gt;user_features[i].end)</span>
<span class="line-removed">400       return false;</span>
<span class="line-removed">401   return true;</span>
<span class="line-removed">402 }</span>
<span class="line-removed">403 </span>
<span class="line-removed">404 static inline hb_bool_t</span>
<span class="line-removed">405 hb_shape_plan_coords_match (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">406                             const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">407 {</span>
<span class="line-removed">408   if (proposal-&gt;num_coords != shape_plan-&gt;num_coords)</span>
<span class="line-removed">409     return false;</span>
<span class="line-removed">410   for (unsigned int i = 0, n = proposal-&gt;num_coords; i &lt; n; i++)</span>
<span class="line-removed">411     if (proposal-&gt;coords[i] != shape_plan-&gt;coords[i])</span>
<span class="line-removed">412       return false;</span>
<span class="line-removed">413   return true;</span>
<span class="line-removed">414 }</span>
<span class="line-removed">415 </span>
<span class="line-removed">416 static hb_bool_t</span>
<span class="line-removed">417 hb_shape_plan_matches (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">418                        const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">419 {</span>
<span class="line-removed">420   return hb_segment_properties_equal (&amp;shape_plan-&gt;props, &amp;proposal-&gt;props) &amp;&amp;</span>
<span class="line-removed">421          hb_shape_plan_user_features_match (shape_plan, proposal) &amp;&amp;</span>
<span class="line-removed">422          hb_shape_plan_coords_match (shape_plan, proposal) &amp;&amp;</span>
<span class="line-removed">423          ((shape_plan-&gt;default_shaper_list &amp;&amp; !proposal-&gt;shaper_list) ||</span>
<span class="line-removed">424           (shape_plan-&gt;shaper_func == proposal-&gt;shaper_func));</span>
<span class="line-removed">425 }</span>
<span class="line-removed">426 </span>
<span class="line-removed">427 static inline hb_bool_t</span>
<span class="line-removed">428 hb_non_global_user_features_present (const hb_feature_t *user_features,</span>
<span class="line-removed">429                                      unsigned int        num_user_features)</span>
<span class="line-removed">430 {</span>
<span class="line-removed">431   while (num_user_features) {</span>
<span class="line-removed">432     if (user_features-&gt;start != 0 || user_features-&gt;end != (unsigned int) -1)</span>
<span class="line-removed">433       return true;</span>
<span class="line-removed">434     num_user_features--;</span>
<span class="line-removed">435     user_features++;</span>
<span class="line-removed">436   }</span>
<span class="line-removed">437   return false;</span>
<span class="line-removed">438 }</span>
<span class="line-removed">439 </span>
<span class="line-removed">440 static inline hb_bool_t</span>
<span class="line-removed">441 hb_coords_present (const int *coords,</span>
<span class="line-removed">442                    unsigned int num_coords)</span>
<span class="line-removed">443 {</span>
<span class="line-removed">444   return num_coords != 0;</span>
<span class="line-removed">445 }</span>
446 
447 /**
448  * hb_shape_plan_create_cached:
449  * @face:
450  * @props:
451  * @user_features: (array length=num_user_features):
452  * @num_user_features:
453  * @shaper_list: (array zero-terminated=1):
454  *
455  *
456  *
457  * Return value: (transfer full):
458  *
459  * Since: 0.9.7
460  **/
461 hb_shape_plan_t *
462 hb_shape_plan_create_cached (hb_face_t                     *face,
463                              const hb_segment_properties_t *props,
464                              const hb_feature_t            *user_features,
465                              unsigned int                   num_user_features,
</pre>
<hr />
<pre>
469                                        user_features, num_user_features,
470                                        nullptr, 0,
471                                        shaper_list);
472 }
473 
474 hb_shape_plan_t *
475 hb_shape_plan_create_cached2 (hb_face_t                     *face,
476                               const hb_segment_properties_t *props,
477                               const hb_feature_t            *user_features,
478                               unsigned int                   num_user_features,
479                               const int                     *coords,
480                               unsigned int                   num_coords,
481                               const char * const            *shaper_list)
482 {
483   DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
484                   &quot;face=%p num_features=%d shaper_list=%p&quot;,
485                   face,
486                   num_user_features,
487                   shaper_list);
488 
<span class="line-modified">489   hb_shape_plan_proposal_t proposal = {</span>
<span class="line-modified">490     *props,</span>
<span class="line-removed">491     shaper_list,</span>
<span class="line-removed">492     user_features,</span>
<span class="line-removed">493     num_user_features,</span>
<span class="line-removed">494     nullptr</span>
<span class="line-removed">495   };</span>
<span class="line-removed">496 </span>
<span class="line-removed">497   if (shaper_list) {</span>
<span class="line-removed">498     /* Choose shaper.  Adapted from hb_shape_plan_plan().</span>
<span class="line-removed">499      * Must choose shaper exactly the same way as that function. */</span>
<span class="line-removed">500     for (const char * const *shaper_item = shaper_list; *shaper_item; shaper_item++)</span>
<span class="line-removed">501       if (0)</span>
<span class="line-removed">502         ;</span>
<span class="line-removed">503 #define HB_SHAPER_IMPLEMENT(shaper) \</span>
<span class="line-removed">504       else if (0 == strcmp (*shaper_item, #shaper) &amp;&amp; \</span>
<span class="line-removed">505                hb_##shaper##_shaper_face_data_ensure (face)) \</span>
<span class="line-removed">506       { \</span>
<span class="line-removed">507         proposal.shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-removed">508         break; \</span>
<span class="line-removed">509       }</span>
<span class="line-removed">510 #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">511 #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">512 </span>
<span class="line-removed">513     if (unlikely (!proposal.shaper_func))</span>
<span class="line-removed">514       return hb_shape_plan_get_empty ();</span>
<span class="line-removed">515   }</span>
516 

517 
<span class="line-modified">518 retry:</span>
<span class="line-modified">519   hb_face_t::plan_node_t *cached_plan_nodes = (hb_face_t::plan_node_t *) hb_atomic_ptr_get (&amp;face-&gt;shape_plans);</span>










520 
<span class="line-removed">521   /* Don&#39;t look for plan in the cache if there were variation coordinates XXX Fix me. */</span>
<span class="line-removed">522   if (!hb_coords_present (coords, num_coords))</span>
523     for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node-&gt;next)
<span class="line-modified">524       if (hb_shape_plan_matches (node-&gt;shape_plan, &amp;proposal))</span>
525       {
526         DEBUG_MSG_FUNC (SHAPE_PLAN, node-&gt;shape_plan, &quot;fulfilled from cache&quot;);
527         return hb_shape_plan_reference (node-&gt;shape_plan);
528       }

529 
<span class="line-removed">530   /* Not found. */</span>
531   hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,
532                                                        user_features, num_user_features,
533                                                        coords, num_coords,
534                                                        shaper_list);
535 
<span class="line-modified">536   /* Don&#39;t add to the cache if face is inert. */</span>
<span class="line-removed">537   if (unlikely (hb_object_is_inert (face)))</span>
<span class="line-removed">538     return shape_plan;</span>
<span class="line-removed">539 </span>
<span class="line-removed">540   /* Don&#39;t add the plan to the cache if there were user features with non-global ranges */</span>
<span class="line-removed">541   if (hb_non_global_user_features_present (user_features, num_user_features))</span>
<span class="line-removed">542     return shape_plan;</span>
<span class="line-removed">543   /* Don&#39;t add the plan to the cache if there were variation coordinates XXX Fix me. */</span>
<span class="line-removed">544   if (hb_coords_present (coords, num_coords))</span>
545     return shape_plan;
546 
547   hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));
548   if (unlikely (!node))
549     return shape_plan;
550 
551   node-&gt;shape_plan = shape_plan;
552   node-&gt;next = cached_plan_nodes;
553 
<span class="line-modified">554   if (!hb_atomic_ptr_cmpexch (&amp;face-&gt;shape_plans, cached_plan_nodes, node)) {</span>

555     hb_shape_plan_destroy (shape_plan);
556     free (node);
557     goto retry;
558   }
559   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, &quot;inserted into cache&quot;);
560 
561   return hb_shape_plan_reference (shape_plan);
562 }
<span class="line-removed">563 </span>
<span class="line-removed">564 /**</span>
<span class="line-removed">565  * hb_shape_plan_get_shaper:</span>
<span class="line-removed">566  * @shape_plan: a shape plan.</span>
<span class="line-removed">567  *</span>
<span class="line-removed">568  *</span>
<span class="line-removed">569  *</span>
<span class="line-removed">570  * Return value: (transfer none):</span>
<span class="line-removed">571  *</span>
<span class="line-removed">572  * Since: 0.9.7</span>
<span class="line-removed">573  **/</span>
<span class="line-removed">574 const char *</span>
<span class="line-removed">575 hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan)</span>
<span class="line-removed">576 {</span>
<span class="line-removed">577   return shape_plan-&gt;shaper_name;</span>
<span class="line-removed">578 }</span>
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-shape-plan.hh&quot;</span>
<span class="line-modified"> 29 #include &quot;hb-shaper.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-font.hh&quot;</span>
<span class="line-modified"> 31 #include &quot;hb-buffer.hh&quot;</span>
<span class="line-modified"> 32 </span>
<span class="line-modified"> 33 </span>
<span class="line-modified"> 34 /**</span>
<span class="line-modified"> 35  * SECTION:hb-shape-plan</span>
<span class="line-modified"> 36  * @title: hb-shape-plan</span>
<span class="line-modified"> 37  * @short_description: Object representing a shaping plan</span>
<span class="line-modified"> 38  * @include: hb.h</span>
<span class="line-modified"> 39  *</span>
<span class="line-modified"> 40  * Shape plans are not used for shaping directly, but can be access to query</span>
<span class="line-modified"> 41  * certain information about how shaping will perform given a set of input</span>
<span class="line-added"> 42  * parameters (script, language, direction, features, etc.)</span>
<span class="line-added"> 43  * Most client would not need to deal with shape plans directly.</span>
<span class="line-added"> 44  **/</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 /*</span>
<span class="line-added"> 48  * hb_shape_plan_key_t</span>
<span class="line-added"> 49  */</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 bool</span>
<span class="line-added"> 52 hb_shape_plan_key_t::init (bool                           copy,</span>
<span class="line-added"> 53                            hb_face_t                     *face,</span>
<span class="line-added"> 54                            const hb_segment_properties_t *props,</span>
<span class="line-added"> 55                            const hb_feature_t            *user_features,</span>
<span class="line-added"> 56                            unsigned int                   num_user_features,</span>
<span class="line-added"> 57                            const int                     *coords,</span>
<span class="line-added"> 58                            unsigned int                   num_coords,</span>
<span class="line-added"> 59                            const char * const            *shaper_list)</span>
 60 {
<span class="line-modified"> 61   hb_feature_t *features = nullptr;</span>
<span class="line-modified"> 62   if (copy &amp;&amp; num_user_features &amp;&amp; !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))</span>
<span class="line-modified"> 63     goto bail;</span>
<span class="line-modified"> 64 </span>
<span class="line-modified"> 65   this-&gt;props = *props;</span>
<span class="line-added"> 66   this-&gt;num_user_features = num_user_features;</span>
<span class="line-added"> 67   this-&gt;user_features = copy ? features : user_features;</span>
<span class="line-added"> 68   if (copy &amp;&amp; num_user_features)</span>
<span class="line-added"> 69   {</span>
<span class="line-added"> 70     memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));</span>
<span class="line-added"> 71     /* Make start/end uniform to easier catch bugs. */</span>
<span class="line-added"> 72     for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added"> 73     {</span>
<span class="line-added"> 74       if (features[0].start != HB_FEATURE_GLOBAL_START)</span>
<span class="line-added"> 75         features[0].start = 1;</span>
<span class="line-added"> 76       if (features[0].end   != HB_FEATURE_GLOBAL_END)</span>
<span class="line-added"> 77         features[0].end   = 2;</span>
<span class="line-added"> 78     }</span>
<span class="line-added"> 79   }</span>
<span class="line-added"> 80   this-&gt;shaper_func = nullptr;</span>
<span class="line-added"> 81   this-&gt;shaper_name = nullptr;</span>
<span class="line-added"> 82   this-&gt;ot.init (face, coords, num_coords);</span>
 83 
<span class="line-modified"> 84   /*</span>
<span class="line-added"> 85    * Choose shaper.</span>
<span class="line-added"> 86    */</span>
 87 
 88 #define HB_SHAPER_PLAN(shaper) \
 89         HB_STMT_START { \
<span class="line-modified"> 90           if (face-&gt;data.shaper) \</span>
<span class="line-modified"> 91           { \</span>
<span class="line-modified"> 92             this-&gt;shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-modified"> 93             this-&gt;shaper_name = #shaper; \</span>
<span class="line-modified"> 94             return true; \</span>



 95           } \
 96         } HB_STMT_END
 97 
<span class="line-modified"> 98   if (unlikely (shaper_list))</span>
<span class="line-modified"> 99   {</span>
<span class="line-modified">100     for (; *shaper_list; shaper_list++)</span>
<span class="line-added">101       if (false)</span>
102         ;
103 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">104       else if (0 == strcmp (*shaper_list, #shaper)) \</span>
105         HB_SHAPER_PLAN (shaper);
106 #include &quot;hb-shaper-list.hh&quot;
107 #undef HB_SHAPER_IMPLEMENT
<span class="line-modified">108   }</span>
<span class="line-modified">109   else</span>
<span class="line-modified">110   {</span>
<span class="line-added">111     const hb_shaper_entry_t *shapers = _hb_shapers_get ();</span>
<span class="line-added">112     for (unsigned int i = 0; i &lt; HB_SHAPERS_COUNT; i++)</span>
<span class="line-added">113       if (false)</span>
114         ;
115 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">116       else if (shapers[i].func == _hb_##shaper##_shape) \</span>
117         HB_SHAPER_PLAN (shaper);
118 #include &quot;hb-shaper-list.hh&quot;
119 #undef HB_SHAPER_IMPLEMENT
120   }

121 #undef HB_SHAPER_PLAN
<span class="line-added">122 </span>
<span class="line-added">123 bail:</span>
<span class="line-added">124   ::free (features);</span>
<span class="line-added">125   return false;</span>
<span class="line-added">126 }</span>
<span class="line-added">127 </span>
<span class="line-added">128 bool</span>
<span class="line-added">129 hb_shape_plan_key_t::user_features_match (const hb_shape_plan_key_t *other)</span>
<span class="line-added">130 {</span>
<span class="line-added">131   if (this-&gt;num_user_features != other-&gt;num_user_features)</span>
<span class="line-added">132     return false;</span>
<span class="line-added">133   for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added">134   {</span>
<span class="line-added">135     if (this-&gt;user_features[i].tag   != other-&gt;user_features[i].tag   ||</span>
<span class="line-added">136         this-&gt;user_features[i].value != other-&gt;user_features[i].value ||</span>
<span class="line-added">137         (this-&gt;user_features[i].start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-added">138          this-&gt;user_features[i].end   == HB_FEATURE_GLOBAL_END) !=</span>
<span class="line-added">139         (other-&gt;user_features[i].start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-added">140          other-&gt;user_features[i].end   == HB_FEATURE_GLOBAL_END))</span>
<span class="line-added">141       return false;</span>
<span class="line-added">142   }</span>
<span class="line-added">143   return true;</span>
<span class="line-added">144 }</span>
<span class="line-added">145 </span>
<span class="line-added">146 bool</span>
<span class="line-added">147 hb_shape_plan_key_t::equal (const hb_shape_plan_key_t *other)</span>
<span class="line-added">148 {</span>
<span class="line-added">149   return hb_segment_properties_equal (&amp;this-&gt;props, &amp;other-&gt;props) &amp;&amp;</span>
<span class="line-added">150          this-&gt;user_features_match (other) &amp;&amp;</span>
<span class="line-added">151          this-&gt;ot.equal (&amp;other-&gt;ot) &amp;&amp;</span>
<span class="line-added">152          this-&gt;shaper_func == other-&gt;shaper_func;</span>
153 }
154 
155 
156 /*
157  * hb_shape_plan_t
158  */
159 
<span class="line-added">160 </span>
161 /**
162  * hb_shape_plan_create: (Xconstructor)
163  * @face:
164  * @props:
165  * @user_features: (array length=num_user_features):
166  * @num_user_features:
167  * @shaper_list: (array zero-terminated=1):
168  *
169  *
170  *
171  * Return value: (transfer full):
172  *
173  * Since: 0.9.7
174  **/
175 hb_shape_plan_t *
176 hb_shape_plan_create (hb_face_t                     *face,
177                       const hb_segment_properties_t *props,
178                       const hb_feature_t            *user_features,
179                       unsigned int                   num_user_features,
180                       const char * const            *shaper_list)
181 {
182   return hb_shape_plan_create2 (face, props,
183                                 user_features, num_user_features,
184                                 nullptr, 0,
185                                 shaper_list);
186 }
187 
188 hb_shape_plan_t *
189 hb_shape_plan_create2 (hb_face_t                     *face,
190                        const hb_segment_properties_t *props,
191                        const hb_feature_t            *user_features,
192                        unsigned int                   num_user_features,
<span class="line-modified">193                        const int                     *coords,</span>
194                        unsigned int                   num_coords,
195                        const char * const            *shaper_list)
196 {
197   DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
198                   &quot;face=%p num_features=%d num_coords=%d shaper_list=%p&quot;,
199                   face,
200                   num_user_features,
201                   num_coords,
202                   shaper_list);
203 
<span class="line-added">204   assert (props-&gt;direction != HB_DIRECTION_INVALID);</span>
<span class="line-added">205 </span>
206   hb_shape_plan_t *shape_plan;


207 


208   if (unlikely (!props))
<span class="line-modified">209     goto bail;</span>







210   if (!(shape_plan = hb_object_create&lt;hb_shape_plan_t&gt; ()))
<span class="line-modified">211     goto bail;</span>






212 
<span class="line-added">213   if (unlikely (!face))</span>
<span class="line-added">214     face = hb_face_get_empty ();</span>
215   hb_face_make_immutable (face);

216   shape_plan-&gt;face_unsafe = face;









217 
<span class="line-modified">218   if (unlikely (!shape_plan-&gt;key.init (true,</span>
<span class="line-modified">219                                        face,</span>
<span class="line-modified">220                                        props,</span>
<span class="line-modified">221                                        user_features,</span>
<span class="line-added">222                                        num_user_features,</span>
<span class="line-added">223                                        coords,</span>
<span class="line-added">224                                        num_coords,</span>
<span class="line-added">225                                        shaper_list)))</span>
<span class="line-added">226     goto bail2;</span>
<span class="line-added">227   if (unlikely (!shape_plan-&gt;ot.init0 (face, &amp;shape_plan-&gt;key)))</span>
<span class="line-added">228     goto bail3;</span>
229 
230   return shape_plan;
<span class="line-added">231 </span>
<span class="line-added">232 bail3:</span>
<span class="line-added">233   shape_plan-&gt;key.free ();</span>
<span class="line-added">234 bail2:</span>
<span class="line-added">235   free (shape_plan);</span>
<span class="line-added">236 bail:</span>
<span class="line-added">237   return hb_shape_plan_get_empty ();</span>
238 }
239 
240 /**
241  * hb_shape_plan_get_empty:
242  *
243  *
244  *
245  * Return value: (transfer full):
246  *
247  * Since: 0.9.7
248  **/
249 hb_shape_plan_t *
<span class="line-modified">250 hb_shape_plan_get_empty ()</span>
251 {
<span class="line-modified">252   return const_cast&lt;hb_shape_plan_t *&gt; (&amp;Null(hb_shape_plan_t));</span>























253 }
254 
255 /**
256  * hb_shape_plan_reference: (skip)
257  * @shape_plan: a shape plan.
258  *
259  *
260  *
261  * Return value: (transfer full):
262  *
263  * Since: 0.9.7
264  **/
265 hb_shape_plan_t *
266 hb_shape_plan_reference (hb_shape_plan_t *shape_plan)
267 {
268   return hb_object_reference (shape_plan);
269 }
270 
271 /**
272  * hb_shape_plan_destroy: (skip)
273  * @shape_plan: a shape plan.
274  *
275  *
276  *
277  * Since: 0.9.7
278  **/
279 void
280 hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)
281 {
282   if (!hb_object_destroy (shape_plan)) return;
283 
<span class="line-modified">284   shape_plan-&gt;ot.fini ();</span>
<span class="line-modified">285   shape_plan-&gt;key.free ();</span>





286   free (shape_plan);
287 }
288 
289 /**
290  * hb_shape_plan_set_user_data: (skip)
291  * @shape_plan: a shape plan.
292  * @key:
293  * @data:
294  * @destroy:
295  * @replace:
296  *
297  *
298  *
299  * Return value:
300  *
301  * Since: 0.9.7
302  **/
303 hb_bool_t
304 hb_shape_plan_set_user_data (hb_shape_plan_t    *shape_plan,
305                              hb_user_data_key_t *key,
</pre>
<hr />
<pre>
311 }
312 
313 /**
314  * hb_shape_plan_get_user_data: (skip)
315  * @shape_plan: a shape plan.
316  * @key:
317  *
318  *
319  *
320  * Return value: (transfer none):
321  *
322  * Since: 0.9.7
323  **/
324 void *
325 hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,
326                              hb_user_data_key_t *key)
327 {
328   return hb_object_get_user_data (shape_plan, key);
329 }
330 
<span class="line-added">331 /**</span>
<span class="line-added">332  * hb_shape_plan_get_shaper:</span>
<span class="line-added">333  * @shape_plan: a shape plan.</span>
<span class="line-added">334  *</span>
<span class="line-added">335  *</span>
<span class="line-added">336  *</span>
<span class="line-added">337  * Return value: (transfer none):</span>
<span class="line-added">338  *</span>
<span class="line-added">339  * Since: 0.9.7</span>
<span class="line-added">340  **/</span>
<span class="line-added">341 const char *</span>
<span class="line-added">342 hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan)</span>
<span class="line-added">343 {</span>
<span class="line-added">344   return shape_plan-&gt;key.shaper_name;</span>
<span class="line-added">345 }</span>
<span class="line-added">346 </span>
347 
348 /**
349  * hb_shape_plan_execute:
350  * @shape_plan: a shape plan.
351  * @font: a font.
352  * @buffer: a buffer.
353  * @features: (array length=num_features):
354  * @num_features:
355  *
356  *
357  *
358  * Return value:
359  *
360  * Since: 0.9.7
361  **/
362 hb_bool_t
363 hb_shape_plan_execute (hb_shape_plan_t    *shape_plan,
364                        hb_font_t          *font,
365                        hb_buffer_t        *buffer,
366                        const hb_feature_t *features,
367                        unsigned int        num_features)
368 {
369   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,
370                   &quot;num_features=%d shaper_func=%p, shaper_name=%s&quot;,
371                   num_features,
<span class="line-modified">372                   shape_plan-&gt;key.shaper_func,</span>
<span class="line-modified">373                   shape_plan-&gt;key.shaper_name);</span>
374 
375   if (unlikely (!buffer-&gt;len))
376     return true;
377 
<span class="line-modified">378   assert (!hb_object_is_immutable (buffer));</span>
379   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE);
380 
381   if (unlikely (hb_object_is_inert (shape_plan)))
382     return false;
383 
384   assert (shape_plan-&gt;face_unsafe == font-&gt;face);
<span class="line-modified">385   assert (hb_segment_properties_equal (&amp;shape_plan-&gt;key.props, &amp;buffer-&gt;props));</span>
386 
387 #define HB_SHAPER_EXECUTE(shaper) \
388         HB_STMT_START { \
<span class="line-modified">389           return font-&gt;data.shaper &amp;&amp; \</span>

390                  _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
391         } HB_STMT_END
392 
<span class="line-modified">393   if (false)</span>
394     ;
395 #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">396   else if (shape_plan-&gt;key.shaper_func == _hb_##shaper##_shape) \</span>
397     HB_SHAPER_EXECUTE (shaper);
398 #include &quot;hb-shaper-list.hh&quot;
399 #undef HB_SHAPER_IMPLEMENT
400 
401 #undef HB_SHAPER_EXECUTE
402 
403   return false;
404 }
405 
406 
407 /*
<span class="line-modified">408  * Caching</span>















409  */




































































410 
411 /**
412  * hb_shape_plan_create_cached:
413  * @face:
414  * @props:
415  * @user_features: (array length=num_user_features):
416  * @num_user_features:
417  * @shaper_list: (array zero-terminated=1):
418  *
419  *
420  *
421  * Return value: (transfer full):
422  *
423  * Since: 0.9.7
424  **/
425 hb_shape_plan_t *
426 hb_shape_plan_create_cached (hb_face_t                     *face,
427                              const hb_segment_properties_t *props,
428                              const hb_feature_t            *user_features,
429                              unsigned int                   num_user_features,
</pre>
<hr />
<pre>
433                                        user_features, num_user_features,
434                                        nullptr, 0,
435                                        shaper_list);
436 }
437 
438 hb_shape_plan_t *
439 hb_shape_plan_create_cached2 (hb_face_t                     *face,
440                               const hb_segment_properties_t *props,
441                               const hb_feature_t            *user_features,
442                               unsigned int                   num_user_features,
443                               const int                     *coords,
444                               unsigned int                   num_coords,
445                               const char * const            *shaper_list)
446 {
447   DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
448                   &quot;face=%p num_features=%d shaper_list=%p&quot;,
449                   face,
450                   num_user_features,
451                   shaper_list);
452 
<span class="line-modified">453 retry:</span>
<span class="line-modified">454   hb_face_t::plan_node_t *cached_plan_nodes = face-&gt;shape_plans;</span>

























455 
<span class="line-added">456   bool dont_cache = hb_object_is_inert (face);</span>
457 
<span class="line-modified">458   if (likely (!dont_cache))</span>
<span class="line-modified">459   {</span>
<span class="line-added">460     hb_shape_plan_key_t key;</span>
<span class="line-added">461     if (!key.init (false,</span>
<span class="line-added">462                    face,</span>
<span class="line-added">463                    props,</span>
<span class="line-added">464                    user_features,</span>
<span class="line-added">465                    num_user_features,</span>
<span class="line-added">466                    coords,</span>
<span class="line-added">467                    num_coords,</span>
<span class="line-added">468                    shaper_list))</span>
<span class="line-added">469       return hb_shape_plan_get_empty ();</span>
470 


471     for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node-&gt;next)
<span class="line-modified">472       if (node-&gt;shape_plan-&gt;key.equal (&amp;key))</span>
473       {
474         DEBUG_MSG_FUNC (SHAPE_PLAN, node-&gt;shape_plan, &quot;fulfilled from cache&quot;);
475         return hb_shape_plan_reference (node-&gt;shape_plan);
476       }
<span class="line-added">477   }</span>
478 

479   hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,
480                                                        user_features, num_user_features,
481                                                        coords, num_coords,
482                                                        shaper_list);
483 
<span class="line-modified">484   if (unlikely (dont_cache))</span>








485     return shape_plan;
486 
487   hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));
488   if (unlikely (!node))
489     return shape_plan;
490 
491   node-&gt;shape_plan = shape_plan;
492   node-&gt;next = cached_plan_nodes;
493 
<span class="line-modified">494   if (unlikely (!face-&gt;shape_plans.cmpexch (cached_plan_nodes, node)))</span>
<span class="line-added">495   {</span>
496     hb_shape_plan_destroy (shape_plan);
497     free (node);
498     goto retry;
499   }
500   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, &quot;inserted into cache&quot;);
501 
502   return hb_shape_plan_reference (shape_plan);
503 }
















</pre>
</td>
</tr>
</table>
<center><a href="hb-set.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-shape.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-set.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-shape.cc.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-shape-plan.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 22,75 ***</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-debug.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-shape-plan-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-shaper-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-font-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-buffer-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! static void</span>
<span class="line-modified">! hb_shape_plan_plan (hb_shape_plan_t    *shape_plan,</span>
<span class="line-modified">!                     const hb_feature_t *user_features,</span>
<span class="line-modified">!                     unsigned int        num_user_features,</span>
<span class="line-modified">!                     const int          *coords,</span>
<span class="line-modified">!                     unsigned int        num_coords,</span>
<span class="line-modified">!                     const char * const *shaper_list)</span>
  {
<span class="line-modified">!   DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,</span>
<span class="line-modified">!                   &quot;num_features=%d num_coords=%d shaper_list=%p&quot;,</span>
<span class="line-modified">!                   num_user_features,</span>
<span class="line-modified">!                   num_coords,</span>
<span class="line-modified">!                   shaper_list);</span>
  
<span class="line-modified">!   const hb_shaper_pair_t *shapers = _hb_shapers_get ();</span>
  
  #define HB_SHAPER_PLAN(shaper) \
          HB_STMT_START { \
<span class="line-modified">!           if (hb_##shaper##_shaper_face_data_ensure (shape_plan-&gt;face_unsafe)) { \</span>
<span class="line-modified">!             HB_SHAPER_DATA (shaper, shape_plan) = \</span>
<span class="line-modified">!               HB_SHAPER_DATA_CREATE_FUNC (shaper, shape_plan) (shape_plan, \</span>
<span class="line-modified">!                                                                user_features, num_user_features, \</span>
<span class="line-modified">!                                                                coords, num_coords); \</span>
<span class="line-removed">-             shape_plan-&gt;shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-removed">-             shape_plan-&gt;shaper_name = #shaper; \</span>
<span class="line-removed">-             return; \</span>
            } \
          } HB_STMT_END
  
<span class="line-modified">!   if (likely (!shaper_list)) {</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; HB_SHAPERS_COUNT; i++)</span>
<span class="line-modified">!       if (0)</span>
          ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!       else if (shapers[i].func == _hb_##shaper##_shape) \</span>
          HB_SHAPER_PLAN (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
<span class="line-modified">!   } else {</span>
<span class="line-modified">!     for (; *shaper_list; shaper_list++)</span>
<span class="line-modified">!       if (0)</span>
          ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!       else if (0 == strcmp (*shaper_list, #shaper)) \</span>
          HB_SHAPER_PLAN (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
    }
<span class="line-removed">- </span>
  #undef HB_SHAPER_PLAN
  }
  
  
  /*
   * hb_shape_plan_t
   */
  
  /**
   * hb_shape_plan_create: (Xconstructor)
   * @face:
   * @props:
   * @user_features: (array length=num_user_features):
<span class="line-new-header">--- 22,144 ---</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-shape-plan.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-shaper.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-font.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-buffer.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! /**</span>
<span class="line-modified">!  * SECTION:hb-shape-plan</span>
<span class="line-modified">!  * @title: hb-shape-plan</span>
<span class="line-modified">!  * @short_description: Object representing a shaping plan</span>
<span class="line-modified">!  * @include: hb.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Shape plans are not used for shaping directly, but can be access to query</span>
<span class="line-modified">!  * certain information about how shaping will perform given a set of input</span>
<span class="line-added">+  * parameters (script, language, direction, features, etc.)</span>
<span class="line-added">+  * Most client would not need to deal with shape plans directly.</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * hb_shape_plan_key_t</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool</span>
<span class="line-added">+ hb_shape_plan_key_t::init (bool                           copy,</span>
<span class="line-added">+                            hb_face_t                     *face,</span>
<span class="line-added">+                            const hb_segment_properties_t *props,</span>
<span class="line-added">+                            const hb_feature_t            *user_features,</span>
<span class="line-added">+                            unsigned int                   num_user_features,</span>
<span class="line-added">+                            const int                     *coords,</span>
<span class="line-added">+                            unsigned int                   num_coords,</span>
<span class="line-added">+                            const char * const            *shaper_list)</span>
  {
<span class="line-modified">!   hb_feature_t *features = nullptr;</span>
<span class="line-modified">!   if (copy &amp;&amp; num_user_features &amp;&amp; !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))</span>
<span class="line-modified">!     goto bail;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   this-&gt;props = *props;</span>
<span class="line-added">+   this-&gt;num_user_features = num_user_features;</span>
<span class="line-added">+   this-&gt;user_features = copy ? features : user_features;</span>
<span class="line-added">+   if (copy &amp;&amp; num_user_features)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));</span>
<span class="line-added">+     /* Make start/end uniform to easier catch bugs. */</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (features[0].start != HB_FEATURE_GLOBAL_START)</span>
<span class="line-added">+         features[0].start = 1;</span>
<span class="line-added">+       if (features[0].end   != HB_FEATURE_GLOBAL_END)</span>
<span class="line-added">+         features[0].end   = 2;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   this-&gt;shaper_func = nullptr;</span>
<span class="line-added">+   this-&gt;shaper_name = nullptr;</span>
<span class="line-added">+   this-&gt;ot.init (face, coords, num_coords);</span>
  
<span class="line-modified">!   /*</span>
<span class="line-added">+    * Choose shaper.</span>
<span class="line-added">+    */</span>
  
  #define HB_SHAPER_PLAN(shaper) \
          HB_STMT_START { \
<span class="line-modified">!           if (face-&gt;data.shaper) \</span>
<span class="line-modified">!           { \</span>
<span class="line-modified">!             this-&gt;shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-modified">!             this-&gt;shaper_name = #shaper; \</span>
<span class="line-modified">!             return true; \</span>
            } \
          } HB_STMT_END
  
<span class="line-modified">!   if (unlikely (shaper_list))</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     for (; *shaper_list; shaper_list++)</span>
<span class="line-added">+       if (false)</span>
          ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!       else if (0 == strcmp (*shaper_list, #shaper)) \</span>
          HB_SHAPER_PLAN (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
<span class="line-modified">!   }</span>
<span class="line-modified">!   else</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     const hb_shaper_entry_t *shapers = _hb_shapers_get ();</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; HB_SHAPERS_COUNT; i++)</span>
<span class="line-added">+       if (false)</span>
          ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!       else if (shapers[i].func == _hb_##shaper##_shape) \</span>
          HB_SHAPER_PLAN (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
    }
  #undef HB_SHAPER_PLAN
<span class="line-added">+ </span>
<span class="line-added">+ bail:</span>
<span class="line-added">+   ::free (features);</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool</span>
<span class="line-added">+ hb_shape_plan_key_t::user_features_match (const hb_shape_plan_key_t *other)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (this-&gt;num_user_features != other-&gt;num_user_features)</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     if (this-&gt;user_features[i].tag   != other-&gt;user_features[i].tag   ||</span>
<span class="line-added">+         this-&gt;user_features[i].value != other-&gt;user_features[i].value ||</span>
<span class="line-added">+         (this-&gt;user_features[i].start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-added">+          this-&gt;user_features[i].end   == HB_FEATURE_GLOBAL_END) !=</span>
<span class="line-added">+         (other-&gt;user_features[i].start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-added">+          other-&gt;user_features[i].end   == HB_FEATURE_GLOBAL_END))</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool</span>
<span class="line-added">+ hb_shape_plan_key_t::equal (const hb_shape_plan_key_t *other)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return hb_segment_properties_equal (&amp;this-&gt;props, &amp;other-&gt;props) &amp;&amp;</span>
<span class="line-added">+          this-&gt;user_features_match (other) &amp;&amp;</span>
<span class="line-added">+          this-&gt;ot.equal (&amp;other-&gt;ot) &amp;&amp;</span>
<span class="line-added">+          this-&gt;shaper_func == other-&gt;shaper_func;</span>
  }
  
  
  /*
   * hb_shape_plan_t
   */
  
<span class="line-added">+ </span>
  /**
   * hb_shape_plan_create: (Xconstructor)
   * @face:
   * @props:
   * @user_features: (array length=num_user_features):
</pre>
<hr />
<pre>
<span class="line-old-header">*** 119,64 ***</span>
  hb_shape_plan_t *
  hb_shape_plan_create2 (hb_face_t                     *face,
                         const hb_segment_properties_t *props,
                         const hb_feature_t            *user_features,
                         unsigned int                   num_user_features,
<span class="line-modified">!                        const int                     *orig_coords,</span>
                         unsigned int                   num_coords,
                         const char * const            *shaper_list)
  {
    DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
                    &quot;face=%p num_features=%d num_coords=%d shaper_list=%p&quot;,
                    face,
                    num_user_features,
                    num_coords,
                    shaper_list);
  
    hb_shape_plan_t *shape_plan;
<span class="line-removed">-   hb_feature_t *features = nullptr;</span>
<span class="line-removed">-   int *coords = nullptr;</span>
  
<span class="line-removed">-   if (unlikely (!face))</span>
<span class="line-removed">-     face = hb_face_get_empty ();</span>
    if (unlikely (!props))
<span class="line-modified">!     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">-   if (num_user_features &amp;&amp; !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))</span>
<span class="line-removed">-     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">-   if (num_coords &amp;&amp; !(coords = (int *) calloc (num_coords, sizeof (int))))</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     free (features);</span>
<span class="line-removed">-     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">-   }</span>
    if (!(shape_plan = hb_object_create&lt;hb_shape_plan_t&gt; ()))
<span class="line-modified">!   {</span>
<span class="line-removed">-     free (coords);</span>
<span class="line-removed">-     free (features);</span>
<span class="line-removed">-     return hb_shape_plan_get_empty ();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   assert (props-&gt;direction != HB_DIRECTION_INVALID);</span>
  
    hb_face_make_immutable (face);
<span class="line-removed">-   shape_plan-&gt;default_shaper_list = !shaper_list;</span>
    shape_plan-&gt;face_unsafe = face;
<span class="line-removed">-   shape_plan-&gt;props = *props;</span>
<span class="line-removed">-   shape_plan-&gt;num_user_features = num_user_features;</span>
<span class="line-removed">-   shape_plan-&gt;user_features = features;</span>
<span class="line-removed">-   if (num_user_features)</span>
<span class="line-removed">-     memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));</span>
<span class="line-removed">-   shape_plan-&gt;num_coords = num_coords;</span>
<span class="line-removed">-   shape_plan-&gt;coords = coords;</span>
<span class="line-removed">-   if (num_coords)</span>
<span class="line-removed">-     memcpy (coords, orig_coords, num_coords * sizeof (int));</span>
  
<span class="line-modified">!   hb_shape_plan_plan (shape_plan,</span>
<span class="line-modified">!                       user_features, num_user_features,</span>
<span class="line-modified">!                       coords, num_coords,</span>
<span class="line-modified">!                       shaper_list);</span>
  
    return shape_plan;
  }
  
  /**
   * hb_shape_plan_get_empty:
   *
<span class="line-new-header">--- 188,55 ---</span>
  hb_shape_plan_t *
  hb_shape_plan_create2 (hb_face_t                     *face,
                         const hb_segment_properties_t *props,
                         const hb_feature_t            *user_features,
                         unsigned int                   num_user_features,
<span class="line-modified">!                        const int                     *coords,</span>
                         unsigned int                   num_coords,
                         const char * const            *shaper_list)
  {
    DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,
                    &quot;face=%p num_features=%d num_coords=%d shaper_list=%p&quot;,
                    face,
                    num_user_features,
                    num_coords,
                    shaper_list);
  
<span class="line-added">+   assert (props-&gt;direction != HB_DIRECTION_INVALID);</span>
<span class="line-added">+ </span>
    hb_shape_plan_t *shape_plan;
  
    if (unlikely (!props))
<span class="line-modified">!     goto bail;</span>
    if (!(shape_plan = hb_object_create&lt;hb_shape_plan_t&gt; ()))
<span class="line-modified">!     goto bail;</span>
  
<span class="line-added">+   if (unlikely (!face))</span>
<span class="line-added">+     face = hb_face_get_empty ();</span>
    hb_face_make_immutable (face);
    shape_plan-&gt;face_unsafe = face;
  
<span class="line-modified">!   if (unlikely (!shape_plan-&gt;key.init (true,</span>
<span class="line-modified">!                                        face,</span>
<span class="line-modified">!                                        props,</span>
<span class="line-modified">!                                        user_features,</span>
<span class="line-added">+                                        num_user_features,</span>
<span class="line-added">+                                        coords,</span>
<span class="line-added">+                                        num_coords,</span>
<span class="line-added">+                                        shaper_list)))</span>
<span class="line-added">+     goto bail2;</span>
<span class="line-added">+   if (unlikely (!shape_plan-&gt;ot.init0 (face, &amp;shape_plan-&gt;key)))</span>
<span class="line-added">+     goto bail3;</span>
  
    return shape_plan;
<span class="line-added">+ </span>
<span class="line-added">+ bail3:</span>
<span class="line-added">+   shape_plan-&gt;key.free ();</span>
<span class="line-added">+ bail2:</span>
<span class="line-added">+   free (shape_plan);</span>
<span class="line-added">+ bail:</span>
<span class="line-added">+   return hb_shape_plan_get_empty ();</span>
  }
  
  /**
   * hb_shape_plan_get_empty:
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,36 ***</span>
   * Return value: (transfer full):
   *
   * Since: 0.9.7
   **/
  hb_shape_plan_t *
<span class="line-modified">! hb_shape_plan_get_empty (void)</span>
  {
<span class="line-modified">!   static const hb_shape_plan_t _hb_shape_plan_nil = {</span>
<span class="line-removed">-     HB_OBJECT_HEADER_STATIC,</span>
<span class="line-removed">- </span>
<span class="line-removed">-     true, /* default_shaper_list */</span>
<span class="line-removed">-     nullptr, /* face */</span>
<span class="line-removed">-     HB_SEGMENT_PROPERTIES_DEFAULT, /* props */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     nullptr, /* shaper_func */</span>
<span class="line-removed">-     nullptr, /* shaper_name */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     nullptr, /* user_features */</span>
<span class="line-removed">-     0,    /* num_user_featurs */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     nullptr, /* coords */</span>
<span class="line-removed">-     0,    /* num_coords */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     {</span>
<span class="line-removed">- #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,</span>
<span class="line-removed">- #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">- #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return const_cast&lt;hb_shape_plan_t *&gt; (&amp;_hb_shape_plan_nil);</span>
  }
  
  /**
   * hb_shape_plan_reference: (skip)
   * @shape_plan: a shape plan.
<span class="line-new-header">--- 245,13 ---</span>
   * Return value: (transfer full):
   *
   * Since: 0.9.7
   **/
  hb_shape_plan_t *
<span class="line-modified">! hb_shape_plan_get_empty ()</span>
  {
<span class="line-modified">!   return const_cast&lt;hb_shape_plan_t *&gt; (&amp;Null(hb_shape_plan_t));</span>
  }
  
  /**
   * hb_shape_plan_reference: (skip)
   * @shape_plan: a shape plan.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 242,17 ***</span>
  void
  hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)
  {
    if (!hb_object_destroy (shape_plan)) return;
  
<span class="line-modified">! #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, shape_plan);</span>
<span class="line-modified">! #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">- #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">- </span>
<span class="line-removed">-   free (shape_plan-&gt;user_features);</span>
<span class="line-removed">-   free (shape_plan-&gt;coords);</span>
<span class="line-removed">- </span>
    free (shape_plan);
  }
  
  /**
   * hb_shape_plan_set_user_data: (skip)
<span class="line-new-header">--- 279,12 ---</span>
  void
  hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)
  {
    if (!hb_object_destroy (shape_plan)) return;
  
<span class="line-modified">!   shape_plan-&gt;ot.fini ();</span>
<span class="line-modified">!   shape_plan-&gt;key.free ();</span>
    free (shape_plan);
  }
  
  /**
   * hb_shape_plan_set_user_data: (skip)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,10 ***</span>
<span class="line-new-header">--- 326,26 ---</span>
                               hb_user_data_key_t *key)
  {
    return hb_object_get_user_data (shape_plan, key);
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_shape_plan_get_shaper:</span>
<span class="line-added">+  * @shape_plan: a shape plan.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Return value: (transfer none):</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 0.9.7</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ const char *</span>
<span class="line-added">+ hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return shape_plan-&gt;key.shaper_name;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  
  /**
   * hb_shape_plan_execute:
   * @shape_plan: a shape plan.
   * @font: a font.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,36 ***</span>
                         unsigned int        num_features)
  {
    DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,
                    &quot;num_features=%d shaper_func=%p, shaper_name=%s&quot;,
                    num_features,
<span class="line-modified">!                   shape_plan-&gt;shaper_func,</span>
<span class="line-modified">!                   shape_plan-&gt;shaper_name);</span>
  
    if (unlikely (!buffer-&gt;len))
      return true;
  
<span class="line-modified">!   assert (!hb_object_is_inert (buffer));</span>
    assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE);
  
    if (unlikely (hb_object_is_inert (shape_plan)))
      return false;
  
    assert (shape_plan-&gt;face_unsafe == font-&gt;face);
<span class="line-modified">!   assert (hb_segment_properties_equal (&amp;shape_plan-&gt;props, &amp;buffer-&gt;props));</span>
  
  #define HB_SHAPER_EXECUTE(shaper) \
          HB_STMT_START { \
<span class="line-modified">!           return HB_SHAPER_DATA (shaper, shape_plan) &amp;&amp; \</span>
<span class="line-removed">-                  hb_##shaper##_shaper_font_data_ensure (font) &amp;&amp; \</span>
                   _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
          } HB_STMT_END
  
<span class="line-modified">!   if (0)</span>
      ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!   else if (shape_plan-&gt;shaper_func == _hb_##shaper##_shape) \</span>
      HB_SHAPER_EXECUTE (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
  
  #undef HB_SHAPER_EXECUTE
<span class="line-new-header">--- 367,35 ---</span>
                         unsigned int        num_features)
  {
    DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,
                    &quot;num_features=%d shaper_func=%p, shaper_name=%s&quot;,
                    num_features,
<span class="line-modified">!                   shape_plan-&gt;key.shaper_func,</span>
<span class="line-modified">!                   shape_plan-&gt;key.shaper_name);</span>
  
    if (unlikely (!buffer-&gt;len))
      return true;
  
<span class="line-modified">!   assert (!hb_object_is_immutable (buffer));</span>
    assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE);
  
    if (unlikely (hb_object_is_inert (shape_plan)))
      return false;
  
    assert (shape_plan-&gt;face_unsafe == font-&gt;face);
<span class="line-modified">!   assert (hb_segment_properties_equal (&amp;shape_plan-&gt;key.props, &amp;buffer-&gt;props));</span>
  
  #define HB_SHAPER_EXECUTE(shaper) \
          HB_STMT_START { \
<span class="line-modified">!           return font-&gt;data.shaper &amp;&amp; \</span>
                   _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \
          } HB_STMT_END
  
<span class="line-modified">!   if (false)</span>
      ;
  #define HB_SHAPER_IMPLEMENT(shaper) \
<span class="line-modified">!   else if (shape_plan-&gt;key.shaper_func == _hb_##shaper##_shape) \</span>
      HB_SHAPER_EXECUTE (shaper);
  #include &quot;hb-shaper-list.hh&quot;
  #undef HB_SHAPER_IMPLEMENT
  
  #undef HB_SHAPER_EXECUTE
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,95 ***</span>
    return false;
  }
  
  
  /*
<span class="line-modified">!  * caching</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if 0</span>
<span class="line-removed">- static unsigned int</span>
<span class="line-removed">- hb_shape_plan_hash (const hb_shape_plan_t *shape_plan)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   return hb_segment_properties_hash (&amp;shape_plan-&gt;props) +</span>
<span class="line-removed">-          shape_plan-&gt;default_shaper_list ? 0 : (intptr_t) shape_plan-&gt;shaper_func;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- /* User-feature caching is currently somewhat dumb:</span>
<span class="line-removed">-  * it only finds matches where the feature array is identical,</span>
<span class="line-removed">-  * not cases where the feature lists would be compatible for plan purposes</span>
<span class="line-removed">-  * but have different ranges, for example.</span>
   */
<span class="line-removed">- struct hb_shape_plan_proposal_t</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   const hb_segment_properties_t  props;</span>
<span class="line-removed">-   const char * const            *shaper_list;</span>
<span class="line-removed">-   const hb_feature_t            *user_features;</span>
<span class="line-removed">-   unsigned int                   num_user_features;</span>
<span class="line-removed">-   const int                     *coords;</span>
<span class="line-removed">-   unsigned int                   num_coords;</span>
<span class="line-removed">-   hb_shape_func_t               *shaper_func;</span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline hb_bool_t</span>
<span class="line-removed">- hb_shape_plan_user_features_match (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">-                                    const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (proposal-&gt;num_user_features != shape_plan-&gt;num_user_features)</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   for (unsigned int i = 0, n = proposal-&gt;num_user_features; i &lt; n; i++)</span>
<span class="line-removed">-     if (proposal-&gt;user_features[i].tag   != shape_plan-&gt;user_features[i].tag   ||</span>
<span class="line-removed">-         proposal-&gt;user_features[i].value != shape_plan-&gt;user_features[i].value ||</span>
<span class="line-removed">-         proposal-&gt;user_features[i].start != shape_plan-&gt;user_features[i].start ||</span>
<span class="line-removed">-         proposal-&gt;user_features[i].end   != shape_plan-&gt;user_features[i].end)</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline hb_bool_t</span>
<span class="line-removed">- hb_shape_plan_coords_match (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">-                             const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (proposal-&gt;num_coords != shape_plan-&gt;num_coords)</span>
<span class="line-removed">-     return false;</span>
<span class="line-removed">-   for (unsigned int i = 0, n = proposal-&gt;num_coords; i &lt; n; i++)</span>
<span class="line-removed">-     if (proposal-&gt;coords[i] != shape_plan-&gt;coords[i])</span>
<span class="line-removed">-       return false;</span>
<span class="line-removed">-   return true;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static hb_bool_t</span>
<span class="line-removed">- hb_shape_plan_matches (const hb_shape_plan_t          *shape_plan,</span>
<span class="line-removed">-                        const hb_shape_plan_proposal_t *proposal)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   return hb_segment_properties_equal (&amp;shape_plan-&gt;props, &amp;proposal-&gt;props) &amp;&amp;</span>
<span class="line-removed">-          hb_shape_plan_user_features_match (shape_plan, proposal) &amp;&amp;</span>
<span class="line-removed">-          hb_shape_plan_coords_match (shape_plan, proposal) &amp;&amp;</span>
<span class="line-removed">-          ((shape_plan-&gt;default_shaper_list &amp;&amp; !proposal-&gt;shaper_list) ||</span>
<span class="line-removed">-           (shape_plan-&gt;shaper_func == proposal-&gt;shaper_func));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline hb_bool_t</span>
<span class="line-removed">- hb_non_global_user_features_present (const hb_feature_t *user_features,</span>
<span class="line-removed">-                                      unsigned int        num_user_features)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   while (num_user_features) {</span>
<span class="line-removed">-     if (user_features-&gt;start != 0 || user_features-&gt;end != (unsigned int) -1)</span>
<span class="line-removed">-       return true;</span>
<span class="line-removed">-     num_user_features--;</span>
<span class="line-removed">-     user_features++;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return false;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline hb_bool_t</span>
<span class="line-removed">- hb_coords_present (const int *coords,</span>
<span class="line-removed">-                    unsigned int num_coords)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   return num_coords != 0;</span>
<span class="line-removed">- }</span>
  
  /**
   * hb_shape_plan_create_cached:
   * @face:
   * @props:
<span class="line-new-header">--- 403,12 ---</span>
    return false;
  }
  
  
  /*
<span class="line-modified">!  * Caching</span>
   */
  
  /**
   * hb_shape_plan_create_cached:
   * @face:
   * @props:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 484,95 ***</span>
                    &quot;face=%p num_features=%d shaper_list=%p&quot;,
                    face,
                    num_user_features,
                    shaper_list);
  
<span class="line-modified">!   hb_shape_plan_proposal_t proposal = {</span>
<span class="line-modified">!     *props,</span>
<span class="line-removed">-     shaper_list,</span>
<span class="line-removed">-     user_features,</span>
<span class="line-removed">-     num_user_features,</span>
<span class="line-removed">-     nullptr</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (shaper_list) {</span>
<span class="line-removed">-     /* Choose shaper.  Adapted from hb_shape_plan_plan().</span>
<span class="line-removed">-      * Must choose shaper exactly the same way as that function. */</span>
<span class="line-removed">-     for (const char * const *shaper_item = shaper_list; *shaper_item; shaper_item++)</span>
<span class="line-removed">-       if (0)</span>
<span class="line-removed">-         ;</span>
<span class="line-removed">- #define HB_SHAPER_IMPLEMENT(shaper) \</span>
<span class="line-removed">-       else if (0 == strcmp (*shaper_item, #shaper) &amp;&amp; \</span>
<span class="line-removed">-                hb_##shaper##_shaper_face_data_ensure (face)) \</span>
<span class="line-removed">-       { \</span>
<span class="line-removed">-         proposal.shaper_func = _hb_##shaper##_shape; \</span>
<span class="line-removed">-         break; \</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">- #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (unlikely (!proposal.shaper_func))</span>
<span class="line-removed">-       return hb_shape_plan_get_empty ();</span>
<span class="line-removed">-   }</span>
  
  
<span class="line-modified">! retry:</span>
<span class="line-modified">!   hb_face_t::plan_node_t *cached_plan_nodes = (hb_face_t::plan_node_t *) hb_atomic_ptr_get (&amp;face-&gt;shape_plans);</span>
  
<span class="line-removed">-   /* Don&#39;t look for plan in the cache if there were variation coordinates XXX Fix me. */</span>
<span class="line-removed">-   if (!hb_coords_present (coords, num_coords))</span>
      for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node-&gt;next)
<span class="line-modified">!       if (hb_shape_plan_matches (node-&gt;shape_plan, &amp;proposal))</span>
        {
          DEBUG_MSG_FUNC (SHAPE_PLAN, node-&gt;shape_plan, &quot;fulfilled from cache&quot;);
          return hb_shape_plan_reference (node-&gt;shape_plan);
        }
  
<span class="line-removed">-   /* Not found. */</span>
    hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,
                                                         user_features, num_user_features,
                                                         coords, num_coords,
                                                         shaper_list);
  
<span class="line-modified">!   /* Don&#39;t add to the cache if face is inert. */</span>
<span class="line-removed">-   if (unlikely (hb_object_is_inert (face)))</span>
<span class="line-removed">-     return shape_plan;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Don&#39;t add the plan to the cache if there were user features with non-global ranges */</span>
<span class="line-removed">-   if (hb_non_global_user_features_present (user_features, num_user_features))</span>
<span class="line-removed">-     return shape_plan;</span>
<span class="line-removed">-   /* Don&#39;t add the plan to the cache if there were variation coordinates XXX Fix me. */</span>
<span class="line-removed">-   if (hb_coords_present (coords, num_coords))</span>
      return shape_plan;
  
    hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));
    if (unlikely (!node))
      return shape_plan;
  
    node-&gt;shape_plan = shape_plan;
    node-&gt;next = cached_plan_nodes;
  
<span class="line-modified">!   if (!hb_atomic_ptr_cmpexch (&amp;face-&gt;shape_plans, cached_plan_nodes, node)) {</span>
      hb_shape_plan_destroy (shape_plan);
      free (node);
      goto retry;
    }
    DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, &quot;inserted into cache&quot;);
  
    return hb_shape_plan_reference (shape_plan);
  }
<span class="line-removed">- </span>
<span class="line-removed">- /**</span>
<span class="line-removed">-  * hb_shape_plan_get_shaper:</span>
<span class="line-removed">-  * @shape_plan: a shape plan.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Return value: (transfer none):</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Since: 0.9.7</span>
<span class="line-removed">-  **/</span>
<span class="line-removed">- const char *</span>
<span class="line-removed">- hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   return shape_plan-&gt;shaper_name;</span>
<span class="line-removed">- }</span>
<span class="line-new-header">--- 448,56 ---</span>
                    &quot;face=%p num_features=%d shaper_list=%p&quot;,
                    face,
                    num_user_features,
                    shaper_list);
  
<span class="line-modified">! retry:</span>
<span class="line-modified">!   hb_face_t::plan_node_t *cached_plan_nodes = face-&gt;shape_plans;</span>
  
<span class="line-added">+   bool dont_cache = hb_object_is_inert (face);</span>
  
<span class="line-modified">!   if (likely (!dont_cache))</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     hb_shape_plan_key_t key;</span>
<span class="line-added">+     if (!key.init (false,</span>
<span class="line-added">+                    face,</span>
<span class="line-added">+                    props,</span>
<span class="line-added">+                    user_features,</span>
<span class="line-added">+                    num_user_features,</span>
<span class="line-added">+                    coords,</span>
<span class="line-added">+                    num_coords,</span>
<span class="line-added">+                    shaper_list))</span>
<span class="line-added">+       return hb_shape_plan_get_empty ();</span>
  
      for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node-&gt;next)
<span class="line-modified">!       if (node-&gt;shape_plan-&gt;key.equal (&amp;key))</span>
        {
          DEBUG_MSG_FUNC (SHAPE_PLAN, node-&gt;shape_plan, &quot;fulfilled from cache&quot;);
          return hb_shape_plan_reference (node-&gt;shape_plan);
        }
<span class="line-added">+   }</span>
  
    hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,
                                                         user_features, num_user_features,
                                                         coords, num_coords,
                                                         shaper_list);
  
<span class="line-modified">!   if (unlikely (dont_cache))</span>
      return shape_plan;
  
    hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));
    if (unlikely (!node))
      return shape_plan;
  
    node-&gt;shape_plan = shape_plan;
    node-&gt;next = cached_plan_nodes;
  
<span class="line-modified">!   if (unlikely (!face-&gt;shape_plans.cmpexch (cached_plan_nodes, node)))</span>
<span class="line-added">+   {</span>
      hb_shape_plan_destroy (shape_plan);
      free (node);
      goto retry;
    }
    DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, &quot;inserted into cache&quot;);
  
    return hb_shape_plan_reference (shape_plan);
  }
</pre>
<center><a href="hb-set.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-shape.cc.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
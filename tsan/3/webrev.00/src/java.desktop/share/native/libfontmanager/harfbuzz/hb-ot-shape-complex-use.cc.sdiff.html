<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-use-table.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-fallback.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-use.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Mozilla Author(s): Jonathan Kew
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb-ot-shape-complex-use-private.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-ot-shape-complex-arabic-private.hh&quot;</span>

 31 
 32 /* buffer var allocations */
 33 #define use_category() complex_var_u8_0()
 34 
 35 
 36 /*
 37  * Universal Shaping Engine.
 38  * https://docs.microsoft.com/en-us/typography/script-development/use
 39  */
 40 
 41 static const hb_tag_t
 42 basic_features[] =
 43 {
 44   /*
 45    * Basic features.
 46    * These features are applied all at once, before reordering.
 47    */
 48   HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;),
 49   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;),
 50   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),
</pre>
<hr />
<pre>
 62   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;),
 63   /* The spec doesn&#39;t specify these but we apply anyway, since our Arabic shaper
 64    * does.  These are only used in Syriac spec. */
 65   HB_TAG(&#39;m&#39;,&#39;e&#39;,&#39;d&#39;,&#39;2&#39;),
 66   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;2&#39;),
 67   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;3&#39;),
 68 };
 69 /* Same order as arabic_features.  Don&#39;t need Syriac stuff.*/
 70 enum joining_form_t {
 71   ISOL,
 72   INIT,
 73   MEDI,
 74   FINA,
 75   _NONE
 76 };
 77 static const hb_tag_t
 78 other_features[] =
 79 {
 80   /*
 81    * Other features.
<span class="line-modified"> 82    * These features are applied all at once, after reordering.</span>

 83    */
 84   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;),
 85   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;),
 86   HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;),
 87   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;),
 88   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;),
<span class="line-modified"> 89   /* Positioning features, though we don&#39;t care about the types. */</span>







 90   HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;),
 91   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;),
 92   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;),
 93 };
 94 
 95 static void
 96 setup_syllables (const hb_ot_shape_plan_t *plan,
 97                  hb_font_t *font,
 98                  hb_buffer_t *buffer);
 99 static void
100 clear_substitution_flags (const hb_ot_shape_plan_t *plan,
101                           hb_font_t *font,
102                           hb_buffer_t *buffer);
103 static void
104 record_rphf (const hb_ot_shape_plan_t *plan,
105              hb_font_t *font,
106              hb_buffer_t *buffer);
107 static void
108 record_pref (const hb_ot_shape_plan_t *plan,
109              hb_font_t *font,
110              hb_buffer_t *buffer);
111 static void
112 reorder (const hb_ot_shape_plan_t *plan,
113          hb_font_t *font,
114          hb_buffer_t *buffer);




115 
116 static void
117 collect_features_use (hb_ot_shape_planner_t *plan)
118 {
119   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
120 
121   /* Do this before any lookups have been applied. */
122   map-&gt;add_gsub_pause (setup_syllables);
123 
124   /* &quot;Default glyph pre-processing group&quot; */
<span class="line-modified">125   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-modified">126   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">127   map-&gt;add_global_bool_feature (HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;));</span>
<span class="line-modified">128   map-&gt;add_global_bool_feature (HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;));</span>
129 
130   /* &quot;Reordering group&quot; */
131   map-&gt;add_gsub_pause (clear_substitution_flags);
<span class="line-modified">132   map-&gt;add_feature (HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), 1, F_MANUAL_ZWJ);</span>
133   map-&gt;add_gsub_pause (record_rphf);
134   map-&gt;add_gsub_pause (clear_substitution_flags);
<span class="line-modified">135   map-&gt;add_feature (HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), 1, F_GLOBAL | F_MANUAL_ZWJ);</span>
136   map-&gt;add_gsub_pause (record_pref);
137 
138   /* &quot;Orthographic unit shaping group&quot; */
139   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (basic_features); i++)
<span class="line-modified">140     map-&gt;add_feature (basic_features[i], 1, F_GLOBAL | F_MANUAL_ZWJ);</span>
141 
142   map-&gt;add_gsub_pause (reorder);

143 
144   /* &quot;Topographical features&quot; */
145   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (arabic_features); i++)
<span class="line-modified">146     map-&gt;add_feature (arabic_features[i], 1, F_NONE);</span>
147   map-&gt;add_gsub_pause (nullptr);
148 
<span class="line-modified">149   /* &quot;Standard typographic presentation&quot; and &quot;Positional feature application&quot; */</span>
150   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (other_features); i++)
<span class="line-modified">151     map-&gt;add_feature (other_features[i], 1, F_GLOBAL | F_MANUAL_ZWJ);</span>




152 }
153 
154 struct use_shape_plan_t
155 {
<span class="line-removed">156   ASSERT_POD ();</span>
<span class="line-removed">157 </span>
158   hb_mask_t rphf_mask;
159 
160   arabic_shape_plan_t *arabic_plan;
161 };
162 
163 static bool
164 has_arabic_joining (hb_script_t script)
165 {
166   /* List of scripts that have data in arabic-table. */
167   switch ((int) script)
168   {
169     /* Unicode-1.1 additions */
170     case HB_SCRIPT_ARABIC:
171 
172     /* Unicode-3.0 additions */
173     case HB_SCRIPT_MONGOLIAN:
174     case HB_SCRIPT_SYRIAC:
175 
176     /* Unicode-5.0 additions */
177     case HB_SCRIPT_NKO:
</pre>
<hr />
<pre>
344         break;
345     }
346 
347     last_start = start;
348   }
349 }
350 
351 static void
352 setup_syllables (const hb_ot_shape_plan_t *plan,
353                  hb_font_t *font HB_UNUSED,
354                  hb_buffer_t *buffer)
355 {
356   find_syllables (buffer);
357   foreach_syllable (buffer, start, end)
358     buffer-&gt;unsafe_to_break (start, end);
359   setup_rphf_mask (plan, buffer);
360   setup_topographical_masks (plan, buffer);
361 }
362 
363 static void
<span class="line-modified">364 clear_substitution_flags (const hb_ot_shape_plan_t *plan,</span>
365                           hb_font_t *font HB_UNUSED,
366                           hb_buffer_t *buffer)
367 {
368   hb_glyph_info_t *info = buffer-&gt;info;
369   unsigned int count = buffer-&gt;len;
370   for (unsigned int i = 0; i &lt; count; i++)
371     _hb_glyph_info_clear_substituted (&amp;info[i]);
372 }
373 
374 static void
375 record_rphf (const hb_ot_shape_plan_t *plan,
<span class="line-modified">376              hb_font_t *font,</span>
377              hb_buffer_t *buffer)
378 {
379   const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan-&gt;data;
380 
381   hb_mask_t mask = use_plan-&gt;rphf_mask;
382   if (!mask) return;
383   hb_glyph_info_t *info = buffer-&gt;info;
384 
385   foreach_syllable (buffer, start, end)
386   {
387     /* Mark a substituted repha as USE_R. */
388     for (unsigned int i = start; i &lt; end &amp;&amp; (info[i].mask &amp; mask); i++)
389       if (_hb_glyph_info_substituted (&amp;info[i]))
390       {
391         info[i].use_category() = USE_R;
392         break;
393       }
394   }
395 }
396 
397 static void
<span class="line-modified">398 record_pref (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">399              hb_font_t *font,</span>
400              hb_buffer_t *buffer)
401 {
402   hb_glyph_info_t *info = buffer-&gt;info;
403 
404   foreach_syllable (buffer, start, end)
405   {
406     /* Mark a substituted pref as VPre, as they behave the same way. */
407     for (unsigned int i = start; i &lt; end; i++)
408       if (_hb_glyph_info_substituted (&amp;info[i]))
409       {
410         info[i].use_category() = USE_VPre;
411         break;
412       }
413   }
414 }
415 
416 static inline bool
417 is_halant (const hb_glyph_info_t &amp;info)
418 {
<span class="line-modified">419   return info.use_category() == USE_H &amp;&amp; !_hb_glyph_info_ligated (&amp;info);</span>

420 }
421 
422 static void
423 reorder_syllable (hb_buffer_t *buffer, unsigned int start, unsigned int end)
424 {
425   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
426   /* Only a few syllable types need reordering. */
427   if (unlikely (!(FLAG_UNSAFE (syllable_type) &amp;
428                   (FLAG (virama_terminated_cluster) |
429                    FLAG (standard_cluster) |
430                    FLAG (broken_cluster) |
431                    0))))
432     return;
433 
434   hb_glyph_info_t *info = buffer-&gt;info;
435 
<span class="line-modified">436 #define BASE_FLAGS (FLAG (USE_B) | FLAG (USE_GB))</span>















437 
438   /* Move things forward. */
439   if (info[start].use_category() == USE_R &amp;&amp; end - start &gt; 1)
440   {
<span class="line-modified">441     /* Got a repha.  Reorder it to after first base, before first halant. */</span>

442     for (unsigned int i = start + 1; i &lt; end; i++)
<span class="line-modified">443       if ((FLAG_UNSAFE (info[i].use_category()) &amp; (BASE_FLAGS)) || is_halant (info[i]))</span>



444       {
<span class="line-modified">445         /* If we hit a halant, move before it; otherwise it&#39;s a base: move to it&#39;s</span>
<span class="line-modified">446          * place, and shift things in between backward. */</span>
447 
<span class="line-modified">448         if (is_halant (info[i]))</span>
449           i--;
450 
451         buffer-&gt;merge_clusters (start, i + 1);
452         hb_glyph_info_t t = info[start];
453         memmove (&amp;info[start], &amp;info[start + 1], (i - start) * sizeof (info[0]));
454         info[i] = t;
455 
456         break;
457       }

458   }
459 
460   /* Move things back. */
<span class="line-modified">461   unsigned int j = end;</span>
462   for (unsigned int i = start; i &lt; end; i++)
463   {
464     uint32_t flag = FLAG_UNSAFE (info[i].use_category());
<span class="line-modified">465     if ((flag &amp; (BASE_FLAGS)) || is_halant (info[i]))</span>
466     {
<span class="line-modified">467       /* If we hit a halant, move after it; otherwise it&#39;s a base: move to it&#39;s</span>
<span class="line-modified">468        * place, and shift things in between backward. */</span>
<span class="line-modified">469       if (is_halant (info[i]))</span>
<span class="line-removed">470         j = i + 1;</span>
<span class="line-removed">471       else</span>
<span class="line-removed">472         j = i;</span>
473     }
474     else if (((flag) &amp; (FLAG (USE_VPre) | FLAG (USE_VMPre))) &amp;&amp;
475              /* Only move the first component of a MultipleSubst. */
476              0 == _hb_glyph_info_get_lig_comp (&amp;info[i]) &amp;&amp;
477              j &lt; i)
478     {
479       buffer-&gt;merge_clusters (j, i + 1);
480       hb_glyph_info_t t = info[i];
481       memmove (&amp;info[j + 1], &amp;info[j], (i - j) * sizeof (info[0]));
482       info[j] = t;
483     }
484   }
485 }
486 
487 static inline void
488 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
489                        hb_font_t *font,
490                        hb_buffer_t *buffer)
491 {
492   /* Note: This loop is extra overhead, but should not be measurable. */
</pre>
<hr />
<pre>
519     {
520       last_syllable = syllable;
521 
522       hb_glyph_info_t ginfo = dottedcircle;
523       ginfo.cluster = buffer-&gt;cur().cluster;
524       ginfo.mask = buffer-&gt;cur().mask;
525       ginfo.syllable() = buffer-&gt;cur().syllable();
526       /* TODO Set glyph_props? */
527 
528       /* Insert dottedcircle after possible Repha. */
529       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
530              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
531              buffer-&gt;cur().use_category() == USE_R)
532         buffer-&gt;next_glyph ();
533 
534       buffer-&gt;output_info (ginfo);
535     }
536     else
537       buffer-&gt;next_glyph ();
538   }
<span class="line-removed">539 </span>
540   buffer-&gt;swap_buffers ();
541 }
542 
543 static void
544 reorder (const hb_ot_shape_plan_t *plan,
545          hb_font_t *font,
546          hb_buffer_t *buffer)
547 {
548   insert_dotted_circles (plan, font, buffer);
549 
<span class="line-removed">550   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">551 </span>
552   foreach_syllable (buffer, start, end)
553     reorder_syllable (buffer, start, end);
554 
<span class="line-modified">555   /* Zero syllables now... */</span>








556   unsigned int count = buffer-&gt;len;
557   for (unsigned int i = 0; i &lt; count; i++)
558     info[i].syllable() = 0;
<span class="line-removed">559 </span>
<span class="line-removed">560   HB_BUFFER_DEALLOCATE_VAR (buffer, use_category);</span>
561 }
562 
<span class="line-removed">563 static bool</span>
<span class="line-removed">564 decompose_use (const hb_ot_shape_normalize_context_t *c,</span>
<span class="line-removed">565                 hb_codepoint_t  ab,</span>
<span class="line-removed">566                 hb_codepoint_t *a,</span>
<span class="line-removed">567                 hb_codepoint_t *b)</span>
<span class="line-removed">568 {</span>
<span class="line-removed">569   switch (ab)</span>
<span class="line-removed">570   {</span>
<span class="line-removed">571     /* Chakma:</span>
<span class="line-removed">572      * Special case where the Unicode decomp gives matras in the wrong order</span>
<span class="line-removed">573      * for cluster validation.</span>
<span class="line-removed">574      */</span>
<span class="line-removed">575     case 0x1112Eu : *a = 0x11127u; *b= 0x11131u; return true;</span>
<span class="line-removed">576     case 0x1112Fu : *a = 0x11127u; *b= 0x11132u; return true;</span>
<span class="line-removed">577   }</span>
578 
<span class="line-modified">579   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);</span>





580 }
581 
582 static bool
583 compose_use (const hb_ot_shape_normalize_context_t *c,
584              hb_codepoint_t  a,
585              hb_codepoint_t  b,
586              hb_codepoint_t *ab)
587 {
588   /* Avoid recomposing split matras. */
589   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
590     return false;
591 
592   return (bool)c-&gt;unicode-&gt;compose (a, b, ab);
593 }
594 
595 
596 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_use =
597 {
598   collect_features_use,
599   nullptr, /* override_features */
600   data_create_use,
601   data_destroy_use,
<span class="line-modified">602   nullptr, /* preprocess_text */</span>
603   nullptr, /* postprocess_glyphs */
604   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
<span class="line-modified">605   decompose_use,</span>
606   compose_use,
607   setup_masks_use,
<span class="line-modified">608   nullptr, /* disable_otl */</span>
609   nullptr, /* reorder_marks */
610   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,
611   false, /* fallback_position */
612 };
</pre>
</td>
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Mozilla Author(s): Jonathan Kew
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb-ot-shape-complex-use.hh&quot;</span>
<span class="line-modified"> 30 #include &quot;hb-ot-shape-complex-arabic.hh&quot;</span>
<span class="line-added"> 31 #include &quot;hb-ot-shape-complex-vowel-constraints.hh&quot;</span>
 32 
 33 /* buffer var allocations */
 34 #define use_category() complex_var_u8_0()
 35 
 36 
 37 /*
 38  * Universal Shaping Engine.
 39  * https://docs.microsoft.com/en-us/typography/script-development/use
 40  */
 41 
 42 static const hb_tag_t
 43 basic_features[] =
 44 {
 45   /*
 46    * Basic features.
 47    * These features are applied all at once, before reordering.
 48    */
 49   HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;),
 50   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;),
 51   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),
</pre>
<hr />
<pre>
 63   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;),
 64   /* The spec doesn&#39;t specify these but we apply anyway, since our Arabic shaper
 65    * does.  These are only used in Syriac spec. */
 66   HB_TAG(&#39;m&#39;,&#39;e&#39;,&#39;d&#39;,&#39;2&#39;),
 67   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;2&#39;),
 68   HB_TAG(&#39;f&#39;,&#39;i&#39;,&#39;n&#39;,&#39;3&#39;),
 69 };
 70 /* Same order as arabic_features.  Don&#39;t need Syriac stuff.*/
 71 enum joining_form_t {
 72   ISOL,
 73   INIT,
 74   MEDI,
 75   FINA,
 76   _NONE
 77 };
 78 static const hb_tag_t
 79 other_features[] =
 80 {
 81   /*
 82    * Other features.
<span class="line-modified"> 83    * These features are applied all at once, after reordering and</span>
<span class="line-added"> 84    * clearing syllables.</span>
 85    */
 86   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;),
 87   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;),
 88   HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;),
 89   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;),
 90   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;),
<span class="line-modified"> 91 };</span>
<span class="line-added"> 92 static const hb_tag_t</span>
<span class="line-added"> 93 positioning_features[] =</span>
<span class="line-added"> 94 {</span>
<span class="line-added"> 95   /*</span>
<span class="line-added"> 96    * Positioning features.</span>
<span class="line-added"> 97    * We don&#39;t care about the types.</span>
<span class="line-added"> 98    */</span>
 99   HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;),
100   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;),
101   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;),
102 };
103 
104 static void
105 setup_syllables (const hb_ot_shape_plan_t *plan,
106                  hb_font_t *font,
107                  hb_buffer_t *buffer);
108 static void
109 clear_substitution_flags (const hb_ot_shape_plan_t *plan,
110                           hb_font_t *font,
111                           hb_buffer_t *buffer);
112 static void
113 record_rphf (const hb_ot_shape_plan_t *plan,
114              hb_font_t *font,
115              hb_buffer_t *buffer);
116 static void
117 record_pref (const hb_ot_shape_plan_t *plan,
118              hb_font_t *font,
119              hb_buffer_t *buffer);
120 static void
121 reorder (const hb_ot_shape_plan_t *plan,
122          hb_font_t *font,
123          hb_buffer_t *buffer);
<span class="line-added">124 static void</span>
<span class="line-added">125 clear_syllables (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">126                  hb_font_t *font,</span>
<span class="line-added">127                  hb_buffer_t *buffer);</span>
128 
129 static void
130 collect_features_use (hb_ot_shape_planner_t *plan)
131 {
132   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
133 
134   /* Do this before any lookups have been applied. */
135   map-&gt;add_gsub_pause (setup_syllables);
136 
137   /* &quot;Default glyph pre-processing group&quot; */
<span class="line-modified">138   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-modified">139   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-modified">140   map-&gt;enable_feature (HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;));</span>
<span class="line-modified">141   map-&gt;enable_feature (HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_MANUAL_ZWJ);</span>
142 
143   /* &quot;Reordering group&quot; */
144   map-&gt;add_gsub_pause (clear_substitution_flags);
<span class="line-modified">145   map-&gt;add_feature (HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), F_MANUAL_ZWJ);</span>
146   map-&gt;add_gsub_pause (record_rphf);
147   map-&gt;add_gsub_pause (clear_substitution_flags);
<span class="line-modified">148   map-&gt;enable_feature (HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_MANUAL_ZWJ);</span>
149   map-&gt;add_gsub_pause (record_pref);
150 
151   /* &quot;Orthographic unit shaping group&quot; */
152   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (basic_features); i++)
<span class="line-modified">153     map-&gt;enable_feature (basic_features[i], F_MANUAL_ZWJ);</span>
154 
155   map-&gt;add_gsub_pause (reorder);
<span class="line-added">156   map-&gt;add_gsub_pause (clear_syllables);</span>
157 
158   /* &quot;Topographical features&quot; */
159   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (arabic_features); i++)
<span class="line-modified">160     map-&gt;add_feature (arabic_features[i]);</span>
161   map-&gt;add_gsub_pause (nullptr);
162 
<span class="line-modified">163   /* &quot;Standard typographic presentation&quot; */</span>
164   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (other_features); i++)
<span class="line-modified">165     map-&gt;enable_feature (other_features[i], F_MANUAL_ZWJ);</span>
<span class="line-added">166 </span>
<span class="line-added">167   /* &quot;Positional feature application&quot; */</span>
<span class="line-added">168   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (positioning_features); i++)</span>
<span class="line-added">169     map-&gt;enable_feature (positioning_features[i]);</span>
170 }
171 
172 struct use_shape_plan_t
173 {


174   hb_mask_t rphf_mask;
175 
176   arabic_shape_plan_t *arabic_plan;
177 };
178 
179 static bool
180 has_arabic_joining (hb_script_t script)
181 {
182   /* List of scripts that have data in arabic-table. */
183   switch ((int) script)
184   {
185     /* Unicode-1.1 additions */
186     case HB_SCRIPT_ARABIC:
187 
188     /* Unicode-3.0 additions */
189     case HB_SCRIPT_MONGOLIAN:
190     case HB_SCRIPT_SYRIAC:
191 
192     /* Unicode-5.0 additions */
193     case HB_SCRIPT_NKO:
</pre>
<hr />
<pre>
360         break;
361     }
362 
363     last_start = start;
364   }
365 }
366 
367 static void
368 setup_syllables (const hb_ot_shape_plan_t *plan,
369                  hb_font_t *font HB_UNUSED,
370                  hb_buffer_t *buffer)
371 {
372   find_syllables (buffer);
373   foreach_syllable (buffer, start, end)
374     buffer-&gt;unsafe_to_break (start, end);
375   setup_rphf_mask (plan, buffer);
376   setup_topographical_masks (plan, buffer);
377 }
378 
379 static void
<span class="line-modified">380 clear_substitution_flags (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
381                           hb_font_t *font HB_UNUSED,
382                           hb_buffer_t *buffer)
383 {
384   hb_glyph_info_t *info = buffer-&gt;info;
385   unsigned int count = buffer-&gt;len;
386   for (unsigned int i = 0; i &lt; count; i++)
387     _hb_glyph_info_clear_substituted (&amp;info[i]);
388 }
389 
390 static void
391 record_rphf (const hb_ot_shape_plan_t *plan,
<span class="line-modified">392              hb_font_t *font HB_UNUSED,</span>
393              hb_buffer_t *buffer)
394 {
395   const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan-&gt;data;
396 
397   hb_mask_t mask = use_plan-&gt;rphf_mask;
398   if (!mask) return;
399   hb_glyph_info_t *info = buffer-&gt;info;
400 
401   foreach_syllable (buffer, start, end)
402   {
403     /* Mark a substituted repha as USE_R. */
404     for (unsigned int i = start; i &lt; end &amp;&amp; (info[i].mask &amp; mask); i++)
405       if (_hb_glyph_info_substituted (&amp;info[i]))
406       {
407         info[i].use_category() = USE_R;
408         break;
409       }
410   }
411 }
412 
413 static void
<span class="line-modified">414 record_pref (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">415              hb_font_t *font HB_UNUSED,</span>
416              hb_buffer_t *buffer)
417 {
418   hb_glyph_info_t *info = buffer-&gt;info;
419 
420   foreach_syllable (buffer, start, end)
421   {
422     /* Mark a substituted pref as VPre, as they behave the same way. */
423     for (unsigned int i = start; i &lt; end; i++)
424       if (_hb_glyph_info_substituted (&amp;info[i]))
425       {
426         info[i].use_category() = USE_VPre;
427         break;
428       }
429   }
430 }
431 
432 static inline bool
433 is_halant (const hb_glyph_info_t &amp;info)
434 {
<span class="line-modified">435   return (info.use_category() == USE_H || info.use_category() == USE_HVM) &amp;&amp;</span>
<span class="line-added">436          !_hb_glyph_info_ligated (&amp;info);</span>
437 }
438 
439 static void
440 reorder_syllable (hb_buffer_t *buffer, unsigned int start, unsigned int end)
441 {
442   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
443   /* Only a few syllable types need reordering. */
444   if (unlikely (!(FLAG_UNSAFE (syllable_type) &amp;
445                   (FLAG (virama_terminated_cluster) |
446                    FLAG (standard_cluster) |
447                    FLAG (broken_cluster) |
448                    0))))
449     return;
450 
451   hb_glyph_info_t *info = buffer-&gt;info;
452 
<span class="line-modified">453 #define POST_BASE_FLAGS64 (FLAG64 (USE_FM) | \</span>
<span class="line-added">454                            FLAG64 (USE_FAbv) | \</span>
<span class="line-added">455                            FLAG64 (USE_FBlw) | \</span>
<span class="line-added">456                            FLAG64 (USE_FPst) | \</span>
<span class="line-added">457                            FLAG64 (USE_MAbv) | \</span>
<span class="line-added">458                            FLAG64 (USE_MBlw) | \</span>
<span class="line-added">459                            FLAG64 (USE_MPst) | \</span>
<span class="line-added">460                            FLAG64 (USE_MPre) | \</span>
<span class="line-added">461                            FLAG64 (USE_VAbv) | \</span>
<span class="line-added">462                            FLAG64 (USE_VBlw) | \</span>
<span class="line-added">463                            FLAG64 (USE_VPst) | \</span>
<span class="line-added">464                            FLAG64 (USE_VPre) | \</span>
<span class="line-added">465                            FLAG64 (USE_VMAbv) | \</span>
<span class="line-added">466                            FLAG64 (USE_VMBlw) | \</span>
<span class="line-added">467                            FLAG64 (USE_VMPst) | \</span>
<span class="line-added">468                            FLAG64 (USE_VMPre))</span>
469 
470   /* Move things forward. */
471   if (info[start].use_category() == USE_R &amp;&amp; end - start &gt; 1)
472   {
<span class="line-modified">473     /* Got a repha.  Reorder it towards the end, but before the first post-base</span>
<span class="line-added">474      * glyph. */</span>
475     for (unsigned int i = start + 1; i &lt; end; i++)
<span class="line-modified">476     {</span>
<span class="line-added">477       bool is_post_base_glyph = (FLAG64_UNSAFE (info[i].use_category()) &amp; POST_BASE_FLAGS64) ||</span>
<span class="line-added">478                                 is_halant (info[i]);</span>
<span class="line-added">479       if (is_post_base_glyph || i == end - 1)</span>
480       {
<span class="line-modified">481         /* If we hit a post-base glyph, move before it; otherwise move to the</span>
<span class="line-modified">482          * end. Shift things in between backward. */</span>
483 
<span class="line-modified">484         if (is_post_base_glyph)</span>
485           i--;
486 
487         buffer-&gt;merge_clusters (start, i + 1);
488         hb_glyph_info_t t = info[start];
489         memmove (&amp;info[start], &amp;info[start + 1], (i - start) * sizeof (info[0]));
490         info[i] = t;
491 
492         break;
493       }
<span class="line-added">494     }</span>
495   }
496 
497   /* Move things back. */
<span class="line-modified">498   unsigned int j = start;</span>
499   for (unsigned int i = start; i &lt; end; i++)
500   {
501     uint32_t flag = FLAG_UNSAFE (info[i].use_category());
<span class="line-modified">502     if (is_halant (info[i]))</span>
503     {
<span class="line-modified">504       /* If we hit a halant, move after it; otherwise move to the beginning, and</span>
<span class="line-modified">505        * shift things in between forward. */</span>
<span class="line-modified">506       j = i + 1;</span>



507     }
508     else if (((flag) &amp; (FLAG (USE_VPre) | FLAG (USE_VMPre))) &amp;&amp;
509              /* Only move the first component of a MultipleSubst. */
510              0 == _hb_glyph_info_get_lig_comp (&amp;info[i]) &amp;&amp;
511              j &lt; i)
512     {
513       buffer-&gt;merge_clusters (j, i + 1);
514       hb_glyph_info_t t = info[i];
515       memmove (&amp;info[j + 1], &amp;info[j], (i - j) * sizeof (info[0]));
516       info[j] = t;
517     }
518   }
519 }
520 
521 static inline void
522 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
523                        hb_font_t *font,
524                        hb_buffer_t *buffer)
525 {
526   /* Note: This loop is extra overhead, but should not be measurable. */
</pre>
<hr />
<pre>
553     {
554       last_syllable = syllable;
555 
556       hb_glyph_info_t ginfo = dottedcircle;
557       ginfo.cluster = buffer-&gt;cur().cluster;
558       ginfo.mask = buffer-&gt;cur().mask;
559       ginfo.syllable() = buffer-&gt;cur().syllable();
560       /* TODO Set glyph_props? */
561 
562       /* Insert dottedcircle after possible Repha. */
563       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
564              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
565              buffer-&gt;cur().use_category() == USE_R)
566         buffer-&gt;next_glyph ();
567 
568       buffer-&gt;output_info (ginfo);
569     }
570     else
571       buffer-&gt;next_glyph ();
572   }

573   buffer-&gt;swap_buffers ();
574 }
575 
576 static void
577 reorder (const hb_ot_shape_plan_t *plan,
578          hb_font_t *font,
579          hb_buffer_t *buffer)
580 {
581   insert_dotted_circles (plan, font, buffer);
582 


583   foreach_syllable (buffer, start, end)
584     reorder_syllable (buffer, start, end);
585 
<span class="line-modified">586   HB_BUFFER_DEALLOCATE_VAR (buffer, use_category);</span>
<span class="line-added">587 }</span>
<span class="line-added">588 </span>
<span class="line-added">589 static void</span>
<span class="line-added">590 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-added">591                  hb_font_t *font HB_UNUSED,</span>
<span class="line-added">592                  hb_buffer_t *buffer)</span>
<span class="line-added">593 {</span>
<span class="line-added">594   hb_glyph_info_t *info = buffer-&gt;info;</span>
595   unsigned int count = buffer-&gt;len;
596   for (unsigned int i = 0; i &lt; count; i++)
597     info[i].syllable() = 0;


598 }
599 















600 
<span class="line-modified">601 static void</span>
<span class="line-added">602 preprocess_text_use (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">603                      hb_buffer_t              *buffer,</span>
<span class="line-added">604                      hb_font_t                *font)</span>
<span class="line-added">605 {</span>
<span class="line-added">606   _hb_preprocess_text_vowel_constraints (plan, buffer, font);</span>
607 }
608 
609 static bool
610 compose_use (const hb_ot_shape_normalize_context_t *c,
611              hb_codepoint_t  a,
612              hb_codepoint_t  b,
613              hb_codepoint_t *ab)
614 {
615   /* Avoid recomposing split matras. */
616   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
617     return false;
618 
619   return (bool)c-&gt;unicode-&gt;compose (a, b, ab);
620 }
621 
622 
623 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_use =
624 {
625   collect_features_use,
626   nullptr, /* override_features */
627   data_create_use,
628   data_destroy_use,
<span class="line-modified">629   preprocess_text_use,</span>
630   nullptr, /* postprocess_glyphs */
631   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
<span class="line-modified">632   nullptr, /* decompose */</span>
633   compose_use,
634   setup_masks_use,
<span class="line-modified">635   HB_TAG_NONE, /* gpos_tag */</span>
636   nullptr, /* reorder_marks */
637   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,
638   false, /* fallback_position */
639 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-use-table.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-fallback.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
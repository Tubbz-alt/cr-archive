<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2016 Elie Roux &lt;elie.roux@telecom-bretagne.eu&gt;
  3  * Copyright © 2018  Google, Inc.
<a name="1" id="anc1"></a><span class="line-added">  4  * Copyright © 2018  Ebrahim Byagowi</span>
  5  *
  6  *  This is part of HarfBuzz, a text shaping library.
  7  *
  8  * Permission is hereby granted, without written agreement and without
  9  * license or royalty fees, to use, copy, modify, and distribute this
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_BASE_TABLE_HH
 30 #define HB_OT_LAYOUT_BASE_TABLE_HH
 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified"> 33 #include &quot;hb-ot-layout-common.hh&quot;</span>
 34 
<a name="3" id="anc3"></a><span class="line-modified"> 35 /* To be removed */</span>
<span class="line-added"> 36 typedef hb_tag_t hb_ot_layout_baseline_t;</span>
 37 
<a name="4" id="anc4"></a><span class="line-modified"> 38 namespace OT {</span>
 39 
 40 /*
 41  * BASE -- Baseline
 42  * https://docs.microsoft.com/en-us/typography/opentype/spec/base
 43  */
 44 
 45 struct BaseCoordFormat1
 46 {
<a name="5" id="anc5"></a><span class="line-modified"> 47   hb_position_t get_coord () const { return coordinate; }</span>
 48 
<a name="6" id="anc6"></a><span class="line-modified"> 49   bool sanitize (hb_sanitize_context_t *c) const</span>
 50   {
 51     TRACE_SANITIZE (this);
<a name="7" id="anc7"></a><span class="line-modified"> 52     return_trace (likely (c-&gt;check_struct (this)));</span>
 53   }
 54 
 55   protected:
 56   HBUINT16      format;         /* Format identifier--format = 1 */
<a name="8" id="anc8"></a><span class="line-modified"> 57   FWORD         coordinate;     /* X or Y value, in design units */</span>
 58   public:
 59   DEFINE_SIZE_STATIC (4);
 60 };
 61 
 62 struct BaseCoordFormat2
 63 {
<a name="9" id="anc9"></a><span class="line-modified"> 64   hb_position_t get_coord () const</span>
 65   {
 66     /* TODO */
 67     return coordinate;
 68   }
 69 
<a name="10" id="anc10"></a><span class="line-modified"> 70   bool sanitize (hb_sanitize_context_t *c) const</span>
 71   {
 72     TRACE_SANITIZE (this);
 73     return_trace (c-&gt;check_struct (this));
 74   }
 75 
 76   protected:
 77   HBUINT16      format;         /* Format identifier--format = 2 */
<a name="11" id="anc11"></a><span class="line-modified"> 78   FWORD         coordinate;     /* X or Y value, in design units */</span>
 79   GlyphID       referenceGlyph; /* Glyph ID of control glyph */
 80   HBUINT16      coordPoint;     /* Index of contour point on the
 81                                  * reference glyph */
 82   public:
 83   DEFINE_SIZE_STATIC (8);
 84 };
 85 
 86 struct BaseCoordFormat3
 87 {
<a name="12" id="anc12"></a><span class="line-modified"> 88   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added"> 89                            const VariationStore &amp;var_store,</span>
<span class="line-added"> 90                            hb_direction_t direction) const</span>
 91   {
<a name="13" id="anc13"></a><span class="line-modified"> 92     const Device &amp;device = this+deviceTable;</span>
<span class="line-modified"> 93     return coordinate + (HB_DIRECTION_IS_VERTICAL (direction) ?</span>
<span class="line-added"> 94                          device.get_y_delta (font, var_store) :</span>
<span class="line-added"> 95                          device.get_x_delta (font, var_store));</span>
 96   }
 97 
<a name="14" id="anc14"></a><span class="line-modified"> 98 </span>
<span class="line-added"> 99   bool sanitize (hb_sanitize_context_t *c) const</span>
100   {
101     TRACE_SANITIZE (this);
<a name="15" id="anc15"></a><span class="line-modified">102     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">103                           deviceTable.sanitize (c, this)));</span>
104   }
105 
106   protected:
<a name="16" id="anc16"></a><span class="line-modified">107   HBUINT16      format;         /* Format identifier--format = 3 */</span>
<span class="line-modified">108   FWORD         coordinate;     /* X or Y value, in design units */</span>
<span class="line-modified">109   OffsetTo&lt;Device&gt;</span>
<span class="line-modified">110                 deviceTable;    /* Offset to Device table for X or</span>
<span class="line-modified">111                                  * Y value, from beginning of</span>
<span class="line-added">112                                  * BaseCoord table (may be NULL). */</span>
113   public:
114   DEFINE_SIZE_STATIC (6);
115 };
116 
117 struct BaseCoord
118 {
<a name="17" id="anc17"></a><span class="line-modified">119   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added">120                            const VariationStore &amp;var_store,</span>
<span class="line-added">121                            hb_direction_t direction) const</span>
122   {
123     switch (u.format) {
124     case 1: return u.format1.get_coord ();
125     case 2: return u.format2.get_coord ();
<a name="18" id="anc18"></a><span class="line-modified">126     case 3: return u.format3.get_coord (font, var_store, direction);</span>
127     default:return 0;
128     }
129   }
130 
<a name="19" id="anc19"></a><span class="line-modified">131   bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
<a name="20" id="anc20"></a><span class="line-modified">134     if (unlikely (!u.format.sanitize (c))) return_trace (false);</span>
135     switch (u.format) {
136     case 1: return_trace (u.format1.sanitize (c));
137     case 2: return_trace (u.format2.sanitize (c));
138     case 3: return_trace (u.format3.sanitize (c));
139     default:return_trace (false);
140     }
141   }
142 
143   protected:
144   union {
145     HBUINT16            format;
146     BaseCoordFormat1    format1;
147     BaseCoordFormat2    format2;
148     BaseCoordFormat3    format3;
149   } u;
150   public:
151   DEFINE_SIZE_UNION (2, format);
152 };
153 
154 struct FeatMinMaxRecord
155 {
<a name="21" id="anc21"></a><span class="line-modified">156   static int cmp (const void *key_, const void *entry_)</span>
<span class="line-modified">157   {</span>
<span class="line-modified">158     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">159     const FeatMinMaxRecord &amp;entry = * (const FeatMinMaxRecord *) entry_;</span>
<span class="line-modified">160     return key &lt; (unsigned int) entry.tag ? -1 :</span>
<span class="line-added">161            key &gt; (unsigned int) entry.tag ? 1 :</span>
<span class="line-added">162            0;</span>
<span class="line-added">163   }</span>
164 
<a name="22" id="anc22"></a><span class="line-modified">165   void get_min_max (const BaseCoord **min, const BaseCoord **max) const</span>
<span class="line-modified">166   {</span>
<span class="line-added">167     if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-added">168     if (likely (max)) *max = &amp;(this+maxCoord);</span>
<span class="line-added">169   }</span>
170 
<a name="23" id="anc23"></a><span class="line-modified">171   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
172   {
173     TRACE_SANITIZE (this);
<a name="24" id="anc24"></a><span class="line-modified">174     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">175                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">176                           maxCoord.sanitize (c, this)));</span>
177   }
178 
179   protected:
<a name="25" id="anc25"></a><span class="line-modified">180   Tag           tag;            /* 4-byte feature identification tag--must</span>
<span class="line-modified">181                                  * match feature tag in FeatureList */</span>
<span class="line-modified">182   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">183                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">184                                  * the minimum extent value, from beginning</span>
<span class="line-modified">185                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">186   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">187                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-added">188                                  * the maximum extent value, from beginning</span>
<span class="line-added">189                                  * of MinMax table (may be NULL) */</span>
190   public:
191   DEFINE_SIZE_STATIC (8);
192 
193 };
194 
195 struct MinMax
196 {
<a name="26" id="anc26"></a><span class="line-modified">197   void get_min_max (hb_tag_t          feature_tag,</span>
<span class="line-modified">198                            const BaseCoord **min,</span>
<span class="line-modified">199                            const BaseCoord **max) const</span>
<span class="line-modified">200   {</span>
<span class="line-modified">201     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">202     const FeatMinMaxRecord *minMaxCoord = (const FeatMinMaxRecord *)</span>
<span class="line-added">203                                           hb_bsearch (&amp;feature_tag, featMinMaxRecords.arrayZ,</span>
<span class="line-added">204                                                       featMinMaxRecords.len,</span>
<span class="line-added">205                                                       FeatMinMaxRecord::static_size,</span>
<span class="line-added">206                                                       FeatMinMaxRecord::cmp);</span>
<span class="line-added">207     if (minMaxCoord)</span>
<span class="line-added">208       minMaxCoord-&gt;get_min_max (min, max);</span>
<span class="line-added">209     else</span>
210     {
<a name="27" id="anc27"></a><span class="line-modified">211       if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-modified">212       if (likely (max)) *max = &amp;(this+maxCoord);</span>


213     }
<a name="28" id="anc28"></a>














214   }
215 
<a name="29" id="anc29"></a><span class="line-modified">216   bool sanitize (hb_sanitize_context_t *c) const</span>
217   {
218     TRACE_SANITIZE (this);
<a name="30" id="anc30"></a><span class="line-modified">219     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">220                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">221                           maxCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">222                           featMinMaxRecords.sanitize (c, this)));</span>
223   }
224 
225   protected:
<a name="31" id="anc31"></a><span class="line-modified">226   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">227                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">228                                  * minimum extent value, from the beginning</span>
<span class="line-modified">229                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">230   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">231                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">232                                  * maximum extent value, from the beginning</span>
<span class="line-modified">233                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">234   SortedArrayOf&lt;FeatMinMaxRecord&gt;</span>
<span class="line-added">235                 featMinMaxRecords;</span>
<span class="line-added">236                                 /* Array of FeatMinMaxRecords, in alphabetical</span>
<span class="line-added">237                                  * order by featureTableTag */</span>
238   public:
239   DEFINE_SIZE_ARRAY (6, featMinMaxRecords);
240 };
241 
<a name="32" id="anc32"></a>





























242 struct BaseValues
243 {
<a name="33" id="anc33"></a><span class="line-modified">244   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>



245   {
<a name="34" id="anc34"></a><span class="line-modified">246     if (baseline_tag_index == -1) baseline_tag_index = defaultIndex;</span>
<span class="line-added">247     return this+baseCoords[baseline_tag_index];</span>
248   }
249 
<a name="35" id="anc35"></a><span class="line-modified">250   bool sanitize (hb_sanitize_context_t *c) const</span>
251   {
252     TRACE_SANITIZE (this);
<a name="36" id="anc36"></a><span class="line-modified">253     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">254                           baseCoords.sanitize (c, this)));</span>

255   }
256 
257   protected:
<a name="37" id="anc37"></a><span class="line-modified">258   Index         defaultIndex;   /* Index number of default baseline for this</span>
<span class="line-modified">259                                  * script — equals index position of baseline tag</span>
<span class="line-modified">260                                  * in baselineTags array of the BaseTagList */</span>
<span class="line-added">261   OffsetArrayOf&lt;BaseCoord&gt;</span>
<span class="line-added">262                 baseCoords;     /* Number of BaseCoord tables defined — should equal</span>
<span class="line-added">263                                  * baseTagCount in the BaseTagList</span>
<span class="line-added">264                                  *</span>
<span class="line-added">265                                  * Array of offsets to BaseCoord tables, from beginning of</span>
<span class="line-added">266                                  * BaseValues table — order matches baselineTags array in</span>
<span class="line-added">267                                  * the BaseTagList */</span>
268   public:
<a name="38" id="anc38"></a><span class="line-modified">269   DEFINE_SIZE_ARRAY (4, baseCoords);</span>

270 };
271 
<a name="39" id="anc39"></a><span class="line-modified">272 struct BaseLangSysRecord</span>
<span class="line-modified">273 {</span>
<span class="line-modified">274   static int cmp (const void *key_, const void *entry_)</span>































275   {
<a name="40" id="anc40"></a><span class="line-modified">276     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">277     const BaseLangSysRecord &amp;entry = * (const BaseLangSysRecord *) entry_;</span>
<span class="line-modified">278     return key &lt; (unsigned int) entry.baseLangSysTag ? -1 :</span>
<span class="line-added">279            key &gt; (unsigned int) entry.baseLangSysTag ? 1 :</span>
<span class="line-added">280            0;</span>
281   }
282 
<a name="41" id="anc41"></a><span class="line-modified">283   const MinMax &amp;get_min_max () const</span>
<span class="line-modified">284   { return this+minMax; }</span>
285 
<a name="42" id="anc42"></a><span class="line-modified">286   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>



287   {
288     TRACE_SANITIZE (this);
<a name="43" id="anc43"></a><span class="line-modified">289     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">290                           minMax.sanitize (c, this)));</span>


291   }
292 
293   protected:
<a name="44" id="anc44"></a><span class="line-modified">294   Tag           baseLangSysTag; /* 4-byte language system identification tag */</span>
<span class="line-modified">295   OffsetTo&lt;MinMax&gt;</span>
<span class="line-modified">296                 minMax;         /* Offset to MinMax table, from beginning</span>
<span class="line-modified">297                                  * of BaseScript table */</span>

298   public:
<a name="45" id="anc45"></a><span class="line-modified">299   DEFINE_SIZE_STATIC (6);</span>
300 };
301 
<a name="46" id="anc46"></a><span class="line-added">302 struct BaseScript</span>
<span class="line-added">303 {</span>
<span class="line-added">304   const MinMax &amp;get_min_max (hb_tag_t language_tag) const</span>
<span class="line-added">305   {</span>
<span class="line-added">306     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">307     const BaseLangSysRecord* record = (const BaseLangSysRecord *)</span>
<span class="line-added">308                                       hb_bsearch (&amp;language_tag, baseLangSysRecords.arrayZ,</span>
<span class="line-added">309                                                   baseLangSysRecords.len,</span>
<span class="line-added">310                                                   BaseLangSysRecord::static_size,</span>
<span class="line-added">311                                                   BaseLangSysRecord::cmp);</span>
<span class="line-added">312     return record ? record-&gt;get_min_max () : this+defaultMinMax;</span>
<span class="line-added">313   }</span>
314 
<a name="47" id="anc47"></a><span class="line-modified">315   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>
<span class="line-modified">316   { return (this+baseValues).get_base_coord (baseline_tag_index); }</span>

















317 
<a name="48" id="anc48"></a><span class="line-modified">318   bool is_empty () const { return !baseValues; }</span>

319 
<a name="49" id="anc49"></a><span class="line-modified">320   bool sanitize (hb_sanitize_context_t *c) const</span>
321   {
322     TRACE_SANITIZE (this);
<a name="50" id="anc50"></a><span class="line-modified">323     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">324                           baseValues.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">325                           defaultMinMax.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">326                           baseLangSysRecords.sanitize (c, this)));</span>
327   }
328 
329   protected:
<a name="51" id="anc51"></a><span class="line-modified">330   OffsetTo&lt;BaseValues&gt;</span>
<span class="line-modified">331                 baseValues;     /* Offset to BaseValues table, from beginning</span>
<span class="line-added">332                                  * of BaseScript table (may be NULL) */</span>
<span class="line-added">333   OffsetTo&lt;MinMax&gt;</span>
<span class="line-added">334                 defaultMinMax;  /* Offset to MinMax table, from beginning of</span>
<span class="line-added">335                                  * BaseScript table (may be NULL) */</span>
<span class="line-added">336   SortedArrayOf&lt;BaseLangSysRecord&gt;</span>
<span class="line-added">337                 baseLangSysRecords;</span>
<span class="line-added">338                                 /* Number of BaseLangSysRecords</span>
<span class="line-added">339                                  * defined — may be zero (0) */</span>
340 
341   public:
<a name="52" id="anc52"></a><span class="line-modified">342   DEFINE_SIZE_ARRAY (6, baseLangSysRecords);</span>
343 };
344 
<a name="53" id="anc53"></a><span class="line-modified">345 struct BaseScriptList;</span>
<span class="line-modified">346 struct BaseScriptRecord</span>
<span class="line-modified">347 {</span>
<span class="line-modified">348   static int cmp (const void *key_, const void *entry_)</span>






























349   {
<a name="54" id="anc54"></a><span class="line-modified">350     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-added">351     const BaseScriptRecord &amp;entry = * (const BaseScriptRecord *) entry_;</span>
<span class="line-added">352     return key &lt; (unsigned int) entry.baseScriptTag ? -1 :</span>
<span class="line-added">353            key &gt; (unsigned int) entry.baseScriptTag ? 1 :</span>
<span class="line-added">354            0;</span>
355   }
356 
<a name="55" id="anc55"></a><span class="line-modified">357   const BaseScript &amp;get_base_script (const BaseScriptList *list) const</span>
<span class="line-modified">358   { return list+baseScript; }</span>


359 
<a name="56" id="anc56"></a><span class="line-modified">360   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
361   {
362     TRACE_SANITIZE (this);
<a name="57" id="anc57"></a><span class="line-modified">363     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">364                           baseScript.sanitize (c, base)));</span>
365   }
366 
367   protected:
<a name="58" id="anc58"></a><span class="line-modified">368   Tag           baseScriptTag;  /* 4-byte script identification tag */</span>
<span class="line-modified">369   OffsetTo&lt;BaseScript&gt;</span>
<span class="line-added">370                 baseScript;     /* Offset to BaseScript table, from beginning</span>
<span class="line-added">371                                  * of BaseScriptList */</span>
372 
373   public:
<a name="59" id="anc59"></a><span class="line-modified">374   DEFINE_SIZE_STATIC (6);</span>

375 };
376 
<a name="60" id="anc60"></a><span class="line-modified">377 struct BaseScriptList</span>
378 {
<a name="61" id="anc61"></a><span class="line-added">379   const BaseScriptRecord *find_record (hb_tag_t script) const</span>
<span class="line-added">380   {</span>
<span class="line-added">381     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">382     return (const BaseScriptRecord *) hb_bsearch (&amp;script, baseScriptRecords.arrayZ,</span>
<span class="line-added">383                                                   baseScriptRecords.len,</span>
<span class="line-added">384                                                   BaseScriptRecord::static_size,</span>
<span class="line-added">385                                                   BaseScriptRecord::cmp);</span>
<span class="line-added">386   }</span>
387 
<a name="62" id="anc62"></a><span class="line-modified">388   /* TODO: Or client should handle fallback? */</span>
<span class="line-added">389   const BaseScript &amp;get_base_script (hb_tag_t script) const</span>
390   {
<a name="63" id="anc63"></a><span class="line-modified">391     const BaseScriptRecord *record = find_record (script);</span>
<span class="line-modified">392     if (!record) record = find_record ((hb_script_t) HB_TAG (&#39;D&#39;,&#39;F&#39;,&#39;L&#39;,&#39;T&#39;));</span>
<span class="line-modified">393 </span>
<span class="line-modified">394     return record ? record-&gt;get_base_script (this) : Null (BaseScript);</span>
395   }
396 
<a name="64" id="anc64"></a><span class="line-modified">397   bool sanitize (hb_sanitize_context_t *c) const</span>
398   {
399     TRACE_SANITIZE (this);
<a name="65" id="anc65"></a><span class="line-modified">400     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">401                   baseScriptRecords.sanitize (c, this));</span>
402   }
403 
404   protected:
<a name="66" id="anc66"></a><span class="line-modified">405   SortedArrayOf&lt;BaseScriptRecord&gt;</span>
<span class="line-modified">406                         baseScriptRecords;</span>
407 
408   public:
<a name="67" id="anc67"></a><span class="line-modified">409   DEFINE_SIZE_ARRAY (2, baseScriptRecords);</span>
410 };
411 
412 struct Axis
413 {
<a name="68" id="anc68"></a><span class="line-modified">414   bool get_baseline (hb_ot_layout_baseline_t   baseline,</span>
<span class="line-modified">415                             hb_tag_t                  script_tag,</span>
<span class="line-added">416                             hb_tag_t                  language_tag,</span>
<span class="line-added">417                             const BaseCoord         **coord) const</span>
418   {
<a name="69" id="anc69"></a><span class="line-modified">419     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">420     if (base_script.is_empty ()) return false;</span>

421 
<a name="70" id="anc70"></a><span class="line-modified">422     if (likely (coord)) *coord = &amp;base_script.get_base_coord ((this+baseTagList).bsearch (baseline));</span>









423 
<a name="71" id="anc71"></a><span class="line-modified">424     return true;</span>



425   }
426 
<a name="72" id="anc72"></a><span class="line-modified">427   bool get_min_max (hb_tag_t          script_tag,</span>
<span class="line-added">428                     hb_tag_t          language_tag,</span>
<span class="line-added">429                     hb_tag_t          feature_tag,</span>
<span class="line-added">430                     const BaseCoord **min_coord,</span>
<span class="line-added">431                     const BaseCoord **max_coord) const</span>
432   {
<a name="73" id="anc73"></a><span class="line-modified">433     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">434     if (base_script.is_empty ()) return false;</span>

435 
<a name="74" id="anc74"></a><span class="line-modified">436     base_script.get_min_max (language_tag).get_min_max (feature_tag, min_coord, max_coord);</span>



437 
<a name="75" id="anc75"></a><span class="line-modified">438     return true;</span>


439   }
440 
<a name="76" id="anc76"></a><span class="line-modified">441   bool sanitize (hb_sanitize_context_t *c) const</span>
442   {
443     TRACE_SANITIZE (this);
<a name="77" id="anc77"></a><span class="line-modified">444     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">445                           (this+baseTagList).sanitize (c) &amp;&amp;</span>
<span class="line-modified">446                           (this+baseScriptList).sanitize (c)));</span>
447   }
448 
449   protected:
<a name="78" id="anc78"></a><span class="line-modified">450   OffsetTo&lt;SortedArrayOf&lt;Tag&gt; &gt;</span>
<span class="line-modified">451                 baseTagList;    /* Offset to BaseTagList table, from beginning</span>
<span class="line-added">452                                  * of Axis table (may be NULL)</span>
<span class="line-added">453                                  * Array of 4-byte baseline identification tags — must</span>
<span class="line-added">454                                  * be in alphabetical order */</span>
<span class="line-added">455   OffsetTo&lt;BaseScriptList&gt;</span>
<span class="line-added">456                 baseScriptList; /* Offset to BaseScriptList table, from beginning</span>
<span class="line-added">457                                  * of Axis table</span>
<span class="line-added">458                                  * Array of BaseScriptRecords, in alphabetical order</span>
<span class="line-added">459                                  * by baseScriptTag */</span>
460 
461   public:
462   DEFINE_SIZE_STATIC (4);
463 };
464 
465 struct BASE
466 {
<a name="79" id="anc79"></a><span class="line-modified">467   static constexpr hb_tag_t tableTag = HB_OT_TAG_BASE;</span>



468 
<a name="80" id="anc80"></a><span class="line-modified">469   const Axis &amp;get_axis (hb_direction_t direction) const</span>
<span class="line-modified">470   { return HB_DIRECTION_IS_VERTICAL (direction) ? this+vAxis : this+hAxis; }</span>
471 
<a name="81" id="anc81"></a><span class="line-modified">472   const VariationStore &amp;get_var_store () const</span>
<span class="line-added">473   { return version.to_int () &lt; 0x00010001u ? Null (VariationStore) : this+varStore; }</span>
474 
<a name="82" id="anc82"></a><span class="line-modified">475   bool get_baseline (hb_font_t               *font,</span>
<span class="line-added">476                      hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">477                      hb_direction_t           direction,</span>
<span class="line-added">478                      hb_tag_t                 script_tag,</span>
<span class="line-added">479                      hb_tag_t                 language_tag,</span>
<span class="line-added">480                      hb_position_t           *base) const</span>
481   {
<a name="83" id="anc83"></a><span class="line-modified">482     const BaseCoord *base_coord;</span>
<span class="line-modified">483     if (!get_axis (direction).get_baseline (baseline, script_tag, language_tag, &amp;base_coord))</span>
<span class="line-modified">484       return false;</span>
485 
<a name="84" id="anc84"></a><span class="line-modified">486     if (likely (base &amp;&amp; base_coord)) *base = base_coord-&gt;get_coord (font,</span>
<span class="line-modified">487                                                                     get_var_store (),</span>
<span class="line-modified">488                                                                     direction);</span>
<span class="line-modified">489     return true;</span>
490   }
491 
<a name="85" id="anc85"></a><span class="line-modified">492   /* TODO: Expose this separately sometime? */</span>
<span class="line-added">493   bool get_min_max (hb_font_t      *font,</span>
<span class="line-added">494                     hb_direction_t  direction,</span>
<span class="line-added">495                     hb_tag_t        script_tag,</span>
<span class="line-added">496                     hb_tag_t        language_tag,</span>
<span class="line-added">497                     hb_tag_t        feature_tag,</span>
<span class="line-added">498                     hb_position_t  *min,</span>
<span class="line-added">499                     hb_position_t  *max)</span>
500   {
<a name="86" id="anc86"></a><span class="line-modified">501     const BaseCoord *min_coord, *max_coord;</span>
<span class="line-modified">502     if (!get_axis (direction).get_min_max (script_tag, language_tag, feature_tag,</span>
<span class="line-modified">503                                            &amp;min_coord, &amp;max_coord))</span>
<span class="line-modified">504       return false;</span>































505 
<a name="87" id="anc87"></a><span class="line-modified">506     const VariationStore &amp;var_store = get_var_store ();</span>
<span class="line-modified">507     if (likely (min &amp;&amp; min_coord)) *min = min_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">508     if (likely (max &amp;&amp; max_coord)) *max = max_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">509     return true;</span>























510   }
511 
<a name="88" id="anc88"></a><span class="line-modified">512   bool sanitize (hb_sanitize_context_t *c) const</span>





513   {
514     TRACE_SANITIZE (this);
<a name="89" id="anc89"></a><span class="line-modified">515     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">516                           likely (version.major == 1) &amp;&amp;</span>
<span class="line-modified">517                           hAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">518                           vAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">519                           (version.to_int () &lt; 0x00010001u || varStore.sanitize (c, this))));</span>
520   }
521 
522   protected:
<a name="90" id="anc90"></a><span class="line-modified">523   FixedVersion&lt;&gt;version;        /* Version of the BASE table */</span>
<span class="line-modified">524   OffsetTo&lt;Axis&gt;hAxis;          /* Offset to horizontal Axis table, from beginning</span>
<span class="line-modified">525                                  * of BASE table (may be NULL) */</span>
<span class="line-added">526   OffsetTo&lt;Axis&gt;vAxis;          /* Offset to vertical Axis table, from beginning</span>
<span class="line-added">527                                  * of BASE table (may be NULL) */</span>
528   LOffsetTo&lt;VariationStore&gt;
<a name="91" id="anc91"></a><span class="line-modified">529                 varStore;       /* Offset to the table of Item Variation</span>
<span class="line-modified">530                                  * Store--from beginning of BASE</span>
<span class="line-modified">531                                  * header (may be NULL).  Introduced</span>
<span class="line-modified">532                                  * in version 0x00010001. */</span>
533   public:
534   DEFINE_SIZE_MIN (8);
535 };
536 
537 
538 } /* namespace OT */
539 
540 
541 #endif /* HB_OT_LAYOUT_BASE_TABLE_HH */
<a name="92" id="anc92"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="92" type="hidden" />
</body>
</html>
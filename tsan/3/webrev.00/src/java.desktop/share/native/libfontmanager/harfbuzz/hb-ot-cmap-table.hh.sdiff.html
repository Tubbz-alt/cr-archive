<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-map.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cbdt-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-cmap-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #ifndef HB_OT_CMAP_TABLE_HH
  28 #define HB_OT_CMAP_TABLE_HH
  29 
<span class="line-modified">  30 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-set-private.hh&quot;</span>
<span class="line-removed">  32 #include &quot;hb-subset-plan.hh&quot;</span>
  33 
  34 /*
  35  * cmap -- Character to Glyph Index Mapping
  36  * https://docs.microsoft.com/en-us/typography/opentype/spec/cmap
  37  */
  38 #define HB_OT_TAG_cmap HB_TAG(&#39;c&#39;,&#39;m&#39;,&#39;a&#39;,&#39;p&#39;)
  39 
<span class="line-removed">  40 </span>
  41 namespace OT {
  42 
  43 
  44 struct CmapSubtableFormat0
  45 {
<span class="line-modified">  46   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
  47   {
  48     hb_codepoint_t gid = codepoint &lt; 256 ? glyphIdArray[codepoint] : 0;
  49     if (!gid)
  50       return false;
  51     *glyph = gid;
  52     return true;
  53   }






  54 
<span class="line-modified">  55   inline bool sanitize (hb_sanitize_context_t *c) const</span>
  56   {
  57     TRACE_SANITIZE (this);
  58     return_trace (c-&gt;check_struct (this));
  59   }
  60 
  61   protected:
  62   HBUINT16      format;         /* Format number is set to 0. */
  63   HBUINT16      length;         /* Byte length of this subtable. */
  64   HBUINT16      language;       /* Ignore. */
  65   HBUINT8       glyphIdArray[256];/* An array that maps character
  66                                  * code to glyph index values. */
  67   public:
  68   DEFINE_SIZE_STATIC (6 + 256);
  69 };
  70 
  71 struct CmapSubtableFormat4
  72 {
  73   struct segment_plan
  74   {
  75     HBUINT16 start_code;
  76     HBUINT16 end_code;
  77     bool use_delta;
  78   };
  79 
  80   bool serialize (hb_serialize_context_t *c,
  81                   const hb_subset_plan_t *plan,
  82                   const hb_vector_t&lt;segment_plan&gt; &amp;segments)
  83   {
  84     TRACE_SERIALIZE (this);
  85 
  86     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
  87 
  88     this-&gt;format.set (4);
  89     this-&gt;length.set (get_sub_table_size (segments));
  90 
<span class="line-modified">  91     this-&gt;segCountX2.set (segments.len * 2);</span>
<span class="line-modified">  92     this-&gt;entrySelector.set (MAX (1u, _hb_bit_storage (segments.len)) - 1);</span>
  93     this-&gt;searchRange.set (2 * (1u &lt;&lt; this-&gt;entrySelector));
<span class="line-modified">  94     this-&gt;rangeShift.set (segments.len * 2 &gt; this-&gt;searchRange</span>
<span class="line-modified">  95                           ? 2 * segments.len - this-&gt;searchRange</span>
  96                           : 0);
  97 
<span class="line-modified">  98     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
  99     c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size); // 2 bytes of padding.
<span class="line-modified"> 100     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="line-modified"> 101     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.len);</span>
<span class="line-modified"> 102     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.len);</span>
 103 
 104     if (id_range_offset == nullptr)
 105       return_trace (false);
 106 
<span class="line-modified"> 107     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
 108     {
 109       end_count[i].set (segments[i].end_code);
 110       start_count[i].set (segments[i].start_code);
 111       if (segments[i].use_delta)
 112       {
 113         hb_codepoint_t cp = segments[i].start_code;
 114         hb_codepoint_t start_gid = 0;
 115         if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;start_gid) &amp;&amp; cp != 0xFFFF))
 116           return_trace (false);
 117         id_delta[i].set (start_gid - segments[i].start_code);
 118       } else {
 119         id_delta[i].set (0);
 120         unsigned int num_codepoints = segments[i].end_code - segments[i].start_code + 1;
 121         HBUINT16 *glyph_id_array = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * num_codepoints);
 122         if (glyph_id_array == nullptr)
 123           return_trace (false);
 124         // From the cmap spec:
 125         //
 126         // id_range_offset[i]/2
 127         // + (cp - segments[i].start_code)
</pre>
<hr />
<pre>
 133         //
 134         // id_range_offset[i]
 135         // =
 136         // 2 * (glyph_id_array - id_range_offset - i)
 137         id_range_offset[i].set (2 * (
 138             glyph_id_array - id_range_offset - i));
 139         for (unsigned int j = 0; j &lt; num_codepoints; j++)
 140         {
 141           hb_codepoint_t cp = segments[i].start_code + j;
 142           hb_codepoint_t new_gid;
 143           if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 144             return_trace (false);
 145           glyph_id_array[j].set (new_gid);
 146         }
 147       }
 148     }
 149 
 150     return_trace (true);
 151   }
 152 
<span class="line-modified"> 153   static inline size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
 154   {
 155     size_t segment_size = 0;
<span class="line-modified"> 156     for (unsigned int i = 0; i &lt; segments.len; i++)</span>
 157     {
 158       // Parallel array entries
 159       segment_size +=
 160             2  // end count
 161           + 2  // start count
 162           + 2  // delta
 163           + 2; // range offset
 164 
 165       if (!segments[i].use_delta)
 166         // Add bytes for the glyph index array entries for this segment.
 167         segment_size += (segments[i].end_code - segments[i].start_code + 1) * 2;
 168     }
 169 
 170     return min_size
 171         + 2 // Padding
 172         + segment_size;
 173   }
 174 
<span class="line-modified"> 175   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 176                                             hb_vector_t&lt;segment_plan&gt; *segments)</span>
 177   {
 178     segment_plan *segment = nullptr;
 179     hb_codepoint_t last_gid = 0;
 180 
 181     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 182     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 183       hb_codepoint_t new_gid;
 184       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 185       {
 186         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 187         return false;
 188       }
 189 
<span class="line-modified"> 190       if (cp &gt; 0xFFFF) {</span>
<span class="line-modified"> 191         // We are now outside of unicode BMP, stop adding to this cmap.</span>
<span class="line-removed"> 192         break;</span>
<span class="line-removed"> 193       }</span>
 194 
<span class="line-modified"> 195       if (!segment</span>
<span class="line-modified"> 196           || cp != segment-&gt;end_code + 1u)</span>
 197       {
 198         segment = segments-&gt;push ();
 199         segment-&gt;start_code.set (cp);
 200         segment-&gt;end_code.set (cp);
 201         segment-&gt;use_delta = true;
 202       } else {
 203         segment-&gt;end_code.set (cp);
 204         if (last_gid + 1u != new_gid)
 205           // gid&#39;s are not consecutive in this segment so delta
 206           // cannot be used.
 207           segment-&gt;use_delta = false;
 208       }
 209 
 210       last_gid = new_gid;
 211     }
 212 
 213     // There must be a final entry with end_code == 0xFFFF. Check if we need to add one.
 214     if (segment == nullptr || segment-&gt;end_code != 0xFFFF)
 215     {
 216       segment = segments-&gt;push ();
 217       segment-&gt;start_code.set (0xFFFF);
 218       segment-&gt;end_code.set (0xFFFF);
 219       segment-&gt;use_delta = true;
 220     }
 221 
 222     return true;
 223   }
 224 
 225   struct accelerator_t
 226   {
<span class="line-modified"> 227     inline void init (const CmapSubtableFormat4 *subtable)</span>




 228     {
 229       segCount = subtable-&gt;segCountX2 / 2;
<span class="line-modified"> 230       endCount = subtable-&gt;values;</span>
 231       startCount = endCount + segCount + 1;
 232       idDelta = startCount + segCount;
 233       idRangeOffset = idDelta + segCount;
 234       glyphIdArray = idRangeOffset + segCount;
 235       glyphIdArrayLength = (subtable-&gt;length - 16 - 8 * segCount) / 2;
 236     }

 237 
<span class="line-modified"> 238     static inline bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
 239     {
<span class="line-removed"> 240       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="line-removed"> 241 </span>
 242       /* Custom two-array bsearch. */
<span class="line-modified"> 243       int min = 0, max = (int) thiz-&gt;segCount - 1;</span>
<span class="line-modified"> 244       const HBUINT16 *startCount = thiz-&gt;startCount;</span>
<span class="line-modified"> 245       const HBUINT16 *endCount = thiz-&gt;endCount;</span>
 246       unsigned int i;
 247       while (min &lt;= max)
 248       {
<span class="line-modified"> 249         int mid = (min + max) / 2;</span>
 250         if (codepoint &lt; startCount[mid])
 251           max = mid - 1;
 252         else if (codepoint &gt; endCount[mid])
 253           min = mid + 1;
 254         else
 255         {
 256           i = mid;
 257           goto found;
 258         }
 259       }
 260       return false;
 261 
 262     found:
 263       hb_codepoint_t gid;
<span class="line-modified"> 264       unsigned int rangeOffset = thiz-&gt;idRangeOffset[i];</span>
 265       if (rangeOffset == 0)
<span class="line-modified"> 266         gid = codepoint + thiz-&gt;idDelta[i];</span>
 267       else
 268       {
 269         /* Somebody has been smoking... */
<span class="line-modified"> 270         unsigned int index = rangeOffset / 2 + (codepoint - thiz-&gt;startCount[i]) + i - thiz-&gt;segCount;</span>
<span class="line-modified"> 271         if (unlikely (index &gt;= thiz-&gt;glyphIdArrayLength))</span>
 272           return false;
<span class="line-modified"> 273         gid = thiz-&gt;glyphIdArray[index];</span>
 274         if (unlikely (!gid))
 275           return false;
<span class="line-modified"> 276         gid += thiz-&gt;idDelta[i];</span>
 277       }
<span class="line-modified"> 278 </span>
<span class="line-modified"> 279       *glyph = gid &amp; 0xFFFFu;</span>


 280       return true;
 281     }
<span class="line-modified"> 282 </span>
<span class="line-modified"> 283     static inline void get_all_codepoints_func (const void *obj, hb_set_t *out)</span>



 284     {
<span class="line-modified"> 285       const accelerator_t *thiz = (const accelerator_t *) obj;</span>
<span class="line-modified"> 286       for (unsigned int i = 0; i &lt; thiz-&gt;segCount; i++)</span>


 287       {
<span class="line-modified"> 288         if (thiz-&gt;startCount[i] != 0xFFFFu</span>
<span class="line-modified"> 289             || thiz-&gt;endCount[i] != 0xFFFFu) // Skip the last segment (0xFFFF)</span>
<span class="line-modified"> 290           hb_set_add_range (out, thiz-&gt;startCount[i], thiz-&gt;endCount[i]);</span>















 291       }
 292     }
 293 
 294     const HBUINT16 *endCount;
 295     const HBUINT16 *startCount;
 296     const HBUINT16 *idDelta;
 297     const HBUINT16 *idRangeOffset;
 298     const HBUINT16 *glyphIdArray;
 299     unsigned int segCount;
 300     unsigned int glyphIdArrayLength;
 301   };
 302 
<span class="line-modified"> 303   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 304   {
<span class="line-modified"> 305     accelerator_t accel;</span>
<span class="line-removed"> 306     accel.init (this);</span>
 307     return accel.get_glyph_func (&amp;accel, codepoint, glyph);
 308   }





 309 
<span class="line-modified"> 310   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 311   {
 312     TRACE_SANITIZE (this);
 313     if (unlikely (!c-&gt;check_struct (this)))
 314       return_trace (false);
 315 
 316     if (unlikely (!c-&gt;check_range (this, length)))
 317     {
 318       /* Some broken fonts have too long of a &quot;length&quot; value.
 319        * If that is the case, just change the value to truncate
 320        * the subtable at the end of the blob. */
 321       uint16_t new_length = (uint16_t) MIN ((uintptr_t) 65535,
 322                                             (uintptr_t) (c-&gt;end -
 323                                                          (char *) this));
 324       if (!c-&gt;try_set (&amp;length, new_length))
 325         return_trace (false);
 326     }
 327 
 328     return_trace (16 + 4 * (unsigned int) segCountX2 &lt;= length);
 329   }
 330 
 331 
 332 
 333   protected:
 334   HBUINT16      format;         /* Format number is set to 4. */
 335   HBUINT16      length;         /* This is the length in bytes of the
 336                                  * subtable. */
 337   HBUINT16      language;       /* Ignore. */
 338   HBUINT16      segCountX2;     /* 2 x segCount. */
 339   HBUINT16      searchRange;    /* 2 * (2**floor(log2(segCount))) */
 340   HBUINT16      entrySelector;  /* log2(searchRange/2) */
 341   HBUINT16      rangeShift;     /* 2 x segCount - searchRange */
 342 
<span class="line-modified"> 343   HBUINT16      values[VAR];</span>

 344 #if 0
 345   HBUINT16      endCount[segCount];     /* End characterCode for each segment,
 346                                          * last=0xFFFFu. */
 347   HBUINT16      reservedPad;            /* Set to 0. */
 348   HBUINT16      startCount[segCount];   /* Start character code for each segment. */
 349   HBINT16               idDelta[segCount];      /* Delta for all character codes in segment. */
 350   HBUINT16      idRangeOffset[segCount];/* Offsets into glyphIdArray or 0 */
<span class="line-modified"> 351   HBUINT16      glyphIdArray[VAR];      /* Glyph index array (arbitrary length) */</span>

 352 #endif
 353 
 354   public:
 355   DEFINE_SIZE_ARRAY (14, values);
 356 };
 357 
 358 struct CmapSubtableLongGroup
 359 {
 360   friend struct CmapSubtableFormat12;
 361   friend struct CmapSubtableFormat13;
 362   template&lt;typename U&gt;
 363   friend struct CmapSubtableLongSegmented;
 364   friend struct cmap;
 365 
 366   int cmp (hb_codepoint_t codepoint) const
 367   {
 368     if (codepoint &lt; startCharCode) return -1;
 369     if (codepoint &gt; endCharCode)   return +1;
 370     return 0;
 371   }
 372 
<span class="line-modified"> 373   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 374   {
 375     TRACE_SANITIZE (this);
 376     return_trace (c-&gt;check_struct (this));
 377   }
 378 
 379   private:
 380   HBUINT32              startCharCode;  /* First character code in this group. */
 381   HBUINT32              endCharCode;    /* Last character code in this group. */
 382   HBUINT32              glyphID;        /* Glyph index; interpretation depends on
<span class="line-modified"> 383                                  * subtable format. */</span>
 384   public:
 385   DEFINE_SIZE_STATIC (12);
 386 };

 387 
 388 template &lt;typename UINT&gt;
 389 struct CmapSubtableTrimmed
 390 {
<span class="line-modified"> 391   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 392   {
 393     /* Rely on our implicit array bound-checking. */
 394     hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];
 395     if (!gid)
 396       return false;
 397     *glyph = gid;
 398     return true;
 399   }








 400 
<span class="line-modified"> 401   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 402   {
 403     TRACE_SANITIZE (this);
 404     return_trace (c-&gt;check_struct (this) &amp;&amp; glyphIdArray.sanitize (c));
 405   }
 406 
 407   protected:
 408   UINT          formatReserved; /* Subtable format and (maybe) padding. */
 409   UINT          length;         /* Byte length of this subtable. */
 410   UINT          language;       /* Ignore. */
 411   UINT          startCharCode;  /* First character code covered. */
 412   ArrayOf&lt;GlyphID, UINT&gt;
 413                 glyphIdArray;   /* Array of glyph index values for character
 414                                  * codes in the range. */
 415   public:
 416   DEFINE_SIZE_ARRAY (5 * sizeof (UINT), glyphIdArray);
 417 };
 418 
 419 struct CmapSubtableFormat6  : CmapSubtableTrimmed&lt;HBUINT16&gt; {};
 420 struct CmapSubtableFormat10 : CmapSubtableTrimmed&lt;HBUINT32 &gt; {};
 421 
 422 template &lt;typename T&gt;
 423 struct CmapSubtableLongSegmented
 424 {
 425   friend struct cmap;
 426 
<span class="line-modified"> 427   inline bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 428   {
<span class="line-modified"> 429     int i = groups.bsearch (codepoint);</span>
<span class="line-modified"> 430     if (i == -1)</span>
 431       return false;
<span class="line-modified"> 432     *glyph = T::group_get_glyph (groups[i], codepoint);</span>
 433     return true;
 434   }
 435 
<span class="line-modified"> 436   inline void get_all_codepoints (hb_set_t *out) const</span>
 437   {
 438     for (unsigned int i = 0; i &lt; this-&gt;groups.len; i++) {
<span class="line-modified"> 439       hb_set_add_range (out,</span>
<span class="line-modified"> 440                         this-&gt;groups[i].startCharCode,</span>
<span class="line-modified"> 441                         this-&gt;groups[i].endCharCode);</span>
 442     }
 443   }
 444 
<span class="line-modified"> 445   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 446   {
 447     TRACE_SANITIZE (this);
 448     return_trace (c-&gt;check_struct (this) &amp;&amp; groups.sanitize (c));
 449   }
 450 
<span class="line-modified"> 451   inline bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 452                          const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
 453   {
 454     TRACE_SERIALIZE (this);
 455     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 456     Supplier&lt;CmapSubtableLongGroup&gt; supplier (group_data.arrayZ, group_data.len);</span>
<span class="line-removed"> 457     if (unlikely (!groups.serialize (c, supplier, group_data.len))) return_trace (false);</span>
 458     return true;
 459   }
 460 
 461   protected:
 462   HBUINT16      format;         /* Subtable format; set to 12. */
 463   HBUINT16      reserved;       /* Reserved; set to 0. */
 464   HBUINT32      length;         /* Byte length of this subtable. */
 465   HBUINT32      language;       /* Ignore. */
 466   SortedArrayOf&lt;CmapSubtableLongGroup, HBUINT32&gt;
 467                 groups;         /* Groupings. */
 468   public:
 469   DEFINE_SIZE_ARRAY (16, groups);
 470 };
 471 
 472 struct CmapSubtableFormat12 : CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;
 473 {
<span class="line-modified"> 474   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 475                                                 hb_codepoint_t u)</span>
<span class="line-modified"> 476   { return group.glyphID + (u - group.startCharCode); }</span>

 477 
 478 
 479   bool serialize (hb_serialize_context_t *c,
 480                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)
 481   {
 482     if (unlikely (!c-&gt;extend_min (*this))) return false;
 483 
 484     this-&gt;format.set (12);
 485     this-&gt;reserved.set (0);
 486     this-&gt;length.set (get_sub_table_size (groups));
 487 
 488     return CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;::serialize (c, groups);
 489   }
 490 
<span class="line-modified"> 491   static inline size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
 492   {
<span class="line-modified"> 493     return 16 + 12 * groups.len;</span>
 494   }
 495 
<span class="line-modified"> 496   static inline bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 497                                             hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
 498   {
 499     CmapSubtableLongGroup *group = nullptr;
 500 
 501     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 502     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 503       hb_codepoint_t new_gid;
 504       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 505       {
 506         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 507         return false;
 508       }
 509 
 510       if (!group || !_is_gid_consecutive (group, cp, new_gid))
 511       {
 512         group = groups-&gt;push ();
 513         group-&gt;startCharCode.set (cp);
 514         group-&gt;endCharCode.set (cp);
 515         group-&gt;glyphID.set (new_gid);
<span class="line-removed"> 516       } else</span>
<span class="line-removed"> 517       {</span>
<span class="line-removed"> 518         group-&gt;endCharCode.set (cp);</span>
 519       }

 520     }
 521 
 522     DEBUG_MSG(SUBSET, nullptr, &quot;cmap&quot;);
<span class="line-modified"> 523     for (unsigned int i = 0; i &lt; groups-&gt;len; i++) {</span>
 524       CmapSubtableLongGroup&amp; group = (*groups)[i];
 525       DEBUG_MSG(SUBSET, nullptr, &quot;  %d: U+%04X-U+%04X, gid %d-%d&quot;, i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));
 526     }
 527 
 528     return true;
 529   }
 530 
 531  private:
<span class="line-modified"> 532   static inline bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="line-modified"> 533                                           hb_codepoint_t cp,</span>
<span class="line-modified"> 534                                           hb_codepoint_t new_gid)</span>
 535   {
 536     return (cp - 1 == group-&gt;endCharCode) &amp;&amp;
 537         new_gid == group-&gt;glyphID + (cp - group-&gt;startCharCode);
 538   }
 539 
 540 };
 541 
 542 struct CmapSubtableFormat13 : CmapSubtableLongSegmented&lt;CmapSubtableFormat13&gt;
 543 {
<span class="line-modified"> 544   static inline hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 545                                                 hb_codepoint_t u HB_UNUSED)</span>
 546   { return group.glyphID; }
 547 };
 548 
 549 typedef enum
 550 {
 551   GLYPH_VARIANT_NOT_FOUND = 0,
 552   GLYPH_VARIANT_FOUND = 1,
 553   GLYPH_VARIANT_USE_DEFAULT = 2
 554 } glyph_variant_t;
 555 
 556 struct UnicodeValueRange
 557 {
<span class="line-modified"> 558   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 559   {
 560     if (codepoint &lt; startUnicodeValue) return -1;
 561     if (codepoint &gt; startUnicodeValue + additionalCount) return +1;
 562     return 0;
 563   }
 564 
<span class="line-modified"> 565   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 566   {
 567     TRACE_SANITIZE (this);
 568     return_trace (c-&gt;check_struct (this));
 569   }
 570 
 571   HBUINT24      startUnicodeValue;      /* First value in this range. */
<span class="line-modified"> 572   HBUINT8               additionalCount;        /* Number of additional values in this</span>
 573                                          * range. */
 574   public:
 575   DEFINE_SIZE_STATIC (4);
 576 };
 577 
<span class="line-modified"> 578 typedef SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt; DefaultUVS;</span>
















 579 
 580 struct UVSMapping
 581 {
<span class="line-modified"> 582   inline int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 583   {
 584     return unicodeValue.cmp (codepoint);
 585   }
 586 
<span class="line-modified"> 587   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 588   {
 589     TRACE_SANITIZE (this);
 590     return_trace (c-&gt;check_struct (this));
 591   }
 592 
 593   HBUINT24      unicodeValue;   /* Base Unicode value of the UVS */
 594   GlyphID       glyphID;        /* Glyph ID of the UVS */
 595   public:
 596   DEFINE_SIZE_STATIC (5);
 597 };
 598 
<span class="line-modified"> 599 typedef SortedArrayOf&lt;UVSMapping, HBUINT32&gt; NonDefaultUVS;</span>











 600 
 601 struct VariationSelectorRecord
 602 {
<span class="line-modified"> 603   inline glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 604                                     hb_codepoint_t *glyph,</span>
<span class="line-modified"> 605                                     const void *base) const</span>
 606   {
<span class="line-modified"> 607     int i;</span>
<span class="line-removed"> 608     const DefaultUVS &amp;defaults = base+defaultUVS;</span>
<span class="line-removed"> 609     i = defaults.bsearch (codepoint);</span>
<span class="line-removed"> 610     if (i != -1)</span>
 611       return GLYPH_VARIANT_USE_DEFAULT;
<span class="line-modified"> 612     const NonDefaultUVS &amp;nonDefaults = base+nonDefaultUVS;</span>
<span class="line-modified"> 613     i = nonDefaults.bsearch (codepoint);</span>
<span class="line-removed"> 614     if (i != -1)</span>
 615     {
<span class="line-modified"> 616       *glyph = nonDefaults[i].glyphID;</span>
 617        return GLYPH_VARIANT_FOUND;
 618     }
 619     return GLYPH_VARIANT_NOT_FOUND;
 620   }
 621 
<span class="line-modified"> 622   inline int cmp (const hb_codepoint_t &amp;variation_selector) const</span>






 623   {
 624     return varSelector.cmp (variation_selector);
 625   }
 626 
<span class="line-modified"> 627   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 628   {
 629     TRACE_SANITIZE (this);
 630     return_trace (c-&gt;check_struct (this) &amp;&amp;
 631                   defaultUVS.sanitize (c, base) &amp;&amp;
 632                   nonDefaultUVS.sanitize (c, base));
 633   }
 634 
 635   HBUINT24      varSelector;    /* Variation selector. */
 636   LOffsetTo&lt;DefaultUVS&gt;
<span class="line-modified"> 637                 defaultUVS;     /* Offset to Default UVS Table. May be 0. */</span>
 638   LOffsetTo&lt;NonDefaultUVS&gt;
<span class="line-modified"> 639                 nonDefaultUVS;  /* Offset to Non-Default UVS Table. May be 0. */</span>
 640   public:
 641   DEFINE_SIZE_STATIC (11);
 642 };
 643 
 644 struct CmapSubtableFormat14
 645 {
<span class="line-modified"> 646   inline glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 647                                             hb_codepoint_t variation_selector,</span>
<span class="line-modified"> 648                                             hb_codepoint_t *glyph) const</span>
 649   {
<span class="line-modified"> 650     return record[record.bsearch(variation_selector)].get_glyph (codepoint, glyph, this);</span>
 651   }
 652 
<span class="line-modified"> 653   inline bool sanitize (hb_sanitize_context_t *c) const</span>












 654   {
 655     TRACE_SANITIZE (this);
 656     return_trace (c-&gt;check_struct (this) &amp;&amp;
 657                   record.sanitize (c, this));
 658   }
 659 
 660   protected:
 661   HBUINT16      format;         /* Format number is set to 14. */
 662   HBUINT32      length;         /* Byte length of this subtable. */
 663   SortedArrayOf&lt;VariationSelectorRecord, HBUINT32&gt;
 664                 record;         /* Variation selector records; sorted
 665                                  * in increasing order of `varSelector&#39;. */
 666   public:
 667   DEFINE_SIZE_ARRAY (10, record);
 668 };
 669 
 670 struct CmapSubtable
 671 {
 672   /* Note: We intentionally do NOT implement subtable formats 2 and 8. */
 673 
<span class="line-modified"> 674   inline bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 675                          hb_codepoint_t *glyph) const</span>
 676   {
 677     switch (u.format) {
 678     case  0: return u.format0 .get_glyph (codepoint, glyph);
 679     case  4: return u.format4 .get_glyph (codepoint, glyph);
 680     case  6: return u.format6 .get_glyph (codepoint, glyph);
 681     case 10: return u.format10.get_glyph (codepoint, glyph);
 682     case 12: return u.format12.get_glyph (codepoint, glyph);
 683     case 13: return u.format13.get_glyph (codepoint, glyph);
 684     case 14:
 685     default: return false;
 686     }
 687   }













 688 
<span class="line-modified"> 689   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 690   {
 691     TRACE_SANITIZE (this);
 692     if (!u.format.sanitize (c)) return_trace (false);
 693     switch (u.format) {
 694     case  0: return_trace (u.format0 .sanitize (c));
 695     case  4: return_trace (u.format4 .sanitize (c));
 696     case  6: return_trace (u.format6 .sanitize (c));
 697     case 10: return_trace (u.format10.sanitize (c));
 698     case 12: return_trace (u.format12.sanitize (c));
 699     case 13: return_trace (u.format13.sanitize (c));
 700     case 14: return_trace (u.format14.sanitize (c));
 701     default:return_trace (true);
 702     }
 703   }
 704 
 705   public:
 706   union {
 707   HBUINT16              format;         /* Format identifier */
 708   CmapSubtableFormat0   format0;
 709   CmapSubtableFormat4   format4;
 710   CmapSubtableFormat6   format6;
 711   CmapSubtableFormat10  format10;
 712   CmapSubtableFormat12  format12;
 713   CmapSubtableFormat13  format13;
 714   CmapSubtableFormat14  format14;
 715   } u;
 716   public:
 717   DEFINE_SIZE_UNION (2, format);
 718 };
 719 
 720 
 721 struct EncodingRecord
 722 {
<span class="line-modified"> 723   inline int cmp (const EncodingRecord &amp;other) const</span>
 724   {
 725     int ret;
 726     ret = platformID.cmp (other.platformID);
 727     if (ret) return ret;
 728     ret = encodingID.cmp (other.encodingID);
 729     if (ret) return ret;
 730     return 0;
 731   }
 732 
<span class="line-modified"> 733   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 734   {
 735     TRACE_SANITIZE (this);
 736     return_trace (c-&gt;check_struct (this) &amp;&amp;
 737                   subtable.sanitize (c, base));
 738   }
 739 
 740   HBUINT16      platformID;     /* Platform ID. */
 741   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 742   LOffsetTo&lt;CmapSubtable&gt;
 743                 subtable;       /* Byte offset from beginning of table to the subtable for this encoding. */
 744   public:
 745   DEFINE_SIZE_STATIC (8);
 746 };
 747 
 748 struct cmap
 749 {
<span class="line-modified"> 750   static const hb_tag_t tableTag        = HB_OT_TAG_cmap;</span>
<span class="line-removed"> 751 </span>
<span class="line-removed"> 752   struct subset_plan {</span>
<span class="line-removed"> 753     subset_plan(void)</span>
<span class="line-removed"> 754     {</span>
<span class="line-removed"> 755       format4_segments.init();</span>
<span class="line-removed"> 756       format12_groups.init();</span>
<span class="line-removed"> 757     }</span>
 758 
<span class="line-modified"> 759     ~subset_plan(void)</span>
<span class="line-modified"> 760     {</span>
<span class="line-modified"> 761       format4_segments.fini();</span>
<span class="line-removed"> 762       format12_groups.fini();</span>
<span class="line-removed"> 763     }</span>
<span class="line-removed"> 764 </span>
<span class="line-removed"> 765     inline size_t final_size() const</span>
 766     {
 767       return 4 // header
 768           +  8 * 3 // 3 EncodingRecord
 769           +  CmapSubtableFormat4::get_sub_table_size (this-&gt;format4_segments)
 770           +  CmapSubtableFormat12::get_sub_table_size (this-&gt;format12_groups);
 771     }
 772 
<span class="line-removed"> 773     // Format 4</span>
 774     hb_vector_t&lt;CmapSubtableFormat4::segment_plan&gt; format4_segments;
<span class="line-removed"> 775     // Format 12</span>
 776     hb_vector_t&lt;CmapSubtableLongGroup&gt; format12_groups;
 777   };
 778 
<span class="line-modified"> 779   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified"> 780   {</span>
<span class="line-removed"> 781     TRACE_SANITIZE (this);</span>
<span class="line-removed"> 782     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed"> 783                   likely (version == 0) &amp;&amp;</span>
<span class="line-removed"> 784                   encodingRecord.sanitize (c, this));</span>
<span class="line-removed"> 785   }</span>
<span class="line-removed"> 786 </span>
<span class="line-removed"> 787   inline bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="line-removed"> 788                             subset_plan *cmap_plan) const</span>
 789   {
<span class="line-modified"> 790     if (unlikely( !CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
 791       return false;
 792 
 793     return CmapSubtableFormat12::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format12_groups);
 794   }
 795 
<span class="line-modified"> 796   inline bool _subset (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 797                        const subset_plan &amp;cmap_subset_plan,</span>
<span class="line-modified"> 798                        size_t dest_sz,</span>
<span class="line-modified"> 799                        void *dest) const</span>
 800   {
 801     hb_serialize_context_t c (dest, dest_sz);
 802 
<span class="line-modified"> 803     OT::cmap *cmap = c.start_serialize&lt;OT::cmap&gt; ();</span>
<span class="line-modified"> 804     if (unlikely (!c.extend_min (*cmap)))</span>
 805     {
 806       return false;
 807     }
 808 
<span class="line-modified"> 809     cmap-&gt;version.set (0);</span>
 810 
<span class="line-modified"> 811     if (unlikely (!cmap-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
 812       return false;
 813 
 814     // TODO(grieger): Convert the below to a for loop
 815 
 816     // Format 4, Plat 0 Encoding Record
<span class="line-modified"> 817     EncodingRecord &amp;format4_plat0_rec = cmap-&gt;encodingRecord[0];</span>
 818     format4_plat0_rec.platformID.set (0); // Unicode
 819     format4_plat0_rec.encodingID.set (3);
 820 
 821     // Format 4, Plat 3 Encoding Record
<span class="line-modified"> 822     EncodingRecord &amp;format4_plat3_rec = cmap-&gt;encodingRecord[1];</span>
 823     format4_plat3_rec.platformID.set (3); // Windows
 824     format4_plat3_rec.encodingID.set (1); // Unicode BMP
 825 
 826     // Format 12 Encoding Record
<span class="line-modified"> 827     EncodingRecord &amp;format12_rec = cmap-&gt;encodingRecord[2];</span>
 828     format12_rec.platformID.set (3); // Windows
 829     format12_rec.encodingID.set (10); // Unicode UCS-4
 830 
 831     // Write out format 4 sub table
 832     {
<span class="line-modified"> 833       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, cmap);</span>
 834       format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);
 835       subtable.u.format.set (4);
 836 
 837       CmapSubtableFormat4 &amp;format4 = subtable.u.format4;
 838       if (unlikely (!format4.serialize (&amp;c, plan, cmap_subset_plan.format4_segments)))
 839         return false;
 840     }
 841 
 842     // Write out format 12 sub table.
 843     {
<span class="line-modified"> 844       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, cmap);</span>
 845       subtable.u.format.set (12);
 846 
 847       CmapSubtableFormat12 &amp;format12 = subtable.u.format12;
 848       if (unlikely (!format12.serialize (&amp;c, cmap_subset_plan.format12_groups)))
 849         return false;
 850     }
 851 
 852     c.end_serialize ();
 853 
 854     return true;
 855   }
 856 
<span class="line-modified"> 857   inline bool subset (hb_subset_plan_t *plan) const</span>
 858   {
 859     subset_plan cmap_subset_plan;
 860 
 861     if (unlikely (!_create_plan (plan, &amp;cmap_subset_plan)))
 862     {
 863       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to generate a cmap subsetting plan.&quot;);
 864       return false;
 865     }
 866 
 867     // We now know how big our blob needs to be
<span class="line-modified"> 868     size_t dest_sz = cmap_subset_plan.final_size();</span>
 869     void *dest = malloc (dest_sz);
 870     if (unlikely (!dest)) {
 871       DEBUG_MSG(SUBSET, nullptr, &quot;Unable to alloc %lu for cmap subset output&quot;, (unsigned long) dest_sz);
 872       return false;
 873     }
 874 
 875     if (unlikely (!_subset (plan, cmap_subset_plan, dest_sz, dest)))
 876     {
 877       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to perform subsetting of cmap.&quot;);
 878       free (dest);
 879       return false;
 880     }
 881 
 882     // all done, write the blob into dest
<span class="line-modified"> 883     hb_blob_t *cmap_prime = hb_blob_create ((const char *)dest,</span>
 884                                             dest_sz,
 885                                             HB_MEMORY_MODE_READONLY,
 886                                             dest,
 887                                             free);
 888     bool result =  plan-&gt;add_table (HB_OT_TAG_cmap, cmap_prime);
 889     hb_blob_destroy (cmap_prime);
 890     return result;
 891   }
 892 
<span class="line-modified"> 893   struct accelerator_t</span>
 894   {
<span class="line-modified"> 895     inline void init (hb_face_t *face)</span>

















 896     {
<span class="line-modified"> 897       this-&gt;blob = OT::Sanitizer&lt;OT::cmap&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_cmap));</span>
<span class="line-modified"> 898       const OT::cmap *cmap = this-&gt;blob-&gt;as&lt;OT::cmap&gt; ();</span>
<span class="line-modified"> 899       const OT::CmapSubtable *subtable = nullptr;</span>
<span class="line-modified"> 900       const OT::CmapSubtableFormat14 *subtable_uvs = nullptr;</span>
<span class="line-modified"> 901 </span>
<span class="line-modified"> 902       bool symbol = false;</span>
<span class="line-modified"> 903       /* 32-bit subtables. */</span>
<span class="line-removed"> 904       if (!subtable) subtable = cmap-&gt;find_subtable (3, 10);</span>
<span class="line-removed"> 905       if (!subtable) subtable = cmap-&gt;find_subtable (0, 6);</span>
<span class="line-removed"> 906       if (!subtable) subtable = cmap-&gt;find_subtable (0, 4);</span>
<span class="line-removed"> 907       /* 16-bit subtables. */</span>
<span class="line-removed"> 908       if (!subtable) subtable = cmap-&gt;find_subtable (3, 1);</span>
<span class="line-removed"> 909       if (!subtable) subtable = cmap-&gt;find_subtable (0, 3);</span>
<span class="line-removed"> 910       if (!subtable) subtable = cmap-&gt;find_subtable (0, 2);</span>
<span class="line-removed"> 911       if (!subtable) subtable = cmap-&gt;find_subtable (0, 1);</span>
<span class="line-removed"> 912       if (!subtable) subtable = cmap-&gt;find_subtable (0, 0);</span>
<span class="line-removed"> 913       if (!subtable)</span>
<span class="line-removed"> 914       {</span>
<span class="line-removed"> 915         subtable = cmap-&gt;find_subtable (3, 0);</span>
<span class="line-removed"> 916         if (subtable) symbol = true;</span>
<span class="line-removed"> 917       }</span>
<span class="line-removed"> 918       /* Meh. */</span>
<span class="line-removed"> 919       if (!subtable) subtable = &amp;Null(OT::CmapSubtable);</span>
 920 
<span class="line-modified"> 921       /* UVS subtable. */</span>
<span class="line-modified"> 922       if (!subtable_uvs)</span>






 923       {
<span class="line-modified"> 924         const OT::CmapSubtable *st = cmap-&gt;find_subtable (0, 5);</span>
 925         if (st &amp;&amp; st-&gt;u.format == 14)
 926           subtable_uvs = &amp;st-&gt;u.format14;
 927       }
<span class="line-removed"> 928       /* Meh. */</span>
<span class="line-removed"> 929       if (!subtable_uvs) subtable_uvs = &amp;Null(OT::CmapSubtableFormat14);</span>
<span class="line-removed"> 930 </span>
<span class="line-removed"> 931       this-&gt;uvs_table = subtable_uvs;</span>
 932 
 933       this-&gt;get_glyph_data = subtable;
 934       if (unlikely (symbol))
 935       {
<span class="line-modified"> 936         this-&gt;get_glyph_func = get_glyph_from_symbol&lt;OT::CmapSubtable&gt;;</span>
<span class="line-removed"> 937         this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
 938       } else {
 939         switch (subtable-&gt;u.format) {
 940         /* Accelerate format 4 and format 12. */
 941         default:
<span class="line-modified"> 942           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtable&gt;;</span>
<span class="line-removed"> 943           this-&gt;get_all_codepoints_func = null_get_all_codepoints_func;</span>
 944           break;
 945         case 12:
<span class="line-modified"> 946           this-&gt;get_glyph_func = get_glyph_from&lt;OT::CmapSubtableFormat12&gt;;</span>
<span class="line-removed"> 947           this-&gt;get_all_codepoints_func = get_all_codepoints_from&lt;OT::CmapSubtableFormat12&gt;;</span>
 948           break;
 949         case  4:
 950           {
 951             this-&gt;format4_accel.init (&amp;subtable-&gt;u.format4);
 952             this-&gt;get_glyph_data = &amp;this-&gt;format4_accel;
<span class="line-modified"> 953             this-&gt;get_glyph_func = this-&gt;format4_accel.get_glyph_func;</span>
<span class="line-removed"> 954             this-&gt;get_all_codepoints_func = this-&gt;format4_accel.get_all_codepoints_func;</span>
 955           }
 956           break;
 957         }
 958       }
 959     }
 960 
<span class="line-modified"> 961     inline void fini (void)</span>
<span class="line-removed"> 962     {</span>
<span class="line-removed"> 963       hb_blob_destroy (this-&gt;blob);</span>
<span class="line-removed"> 964     }</span>
 965 
<span class="line-modified"> 966     inline bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
 967                                    hb_codepoint_t *glyph) const
 968     {
<span class="line-modified"> 969       return this-&gt;get_glyph_func (this-&gt;get_glyph_data, unicode, glyph);</span>






















 970     }
 971 
<span class="line-modified"> 972     inline bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="line-modified"> 973                                      hb_codepoint_t  variation_selector,</span>
<span class="line-modified"> 974                                      hb_codepoint_t *glyph) const</span>
 975     {
<span class="line-modified"> 976       switch (this-&gt;uvs_table-&gt;get_glyph_variant (unicode,</span>
<span class="line-modified"> 977                                                   variation_selector,</span>
<span class="line-modified"> 978                                                   glyph))</span>
 979       {
<span class="line-modified"> 980         case OT::GLYPH_VARIANT_NOT_FOUND:               return false;</span>
<span class="line-modified"> 981         case OT::GLYPH_VARIANT_FOUND:           return true;</span>
<span class="line-modified"> 982         case OT::GLYPH_VARIANT_USE_DEFAULT:     break;</span>
 983       }
 984 
 985       return get_nominal_glyph (unicode, glyph);
 986     }
 987 
<span class="line-modified"> 988     inline void get_all_codepoints (hb_set_t *out) const</span>









 989     {
<span class="line-modified"> 990       this-&gt;get_all_codepoints_func (get_glyph_data, out);</span>
 991     }
 992 
 993     protected:
 994     typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,
 995                                               hb_codepoint_t codepoint,
 996                                               hb_codepoint_t *glyph);
<span class="line-removed"> 997     typedef void (*hb_cmap_get_all_codepoints_func_t) (const void *obj,</span>
<span class="line-removed"> 998                                                        hb_set_t *out);</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000     static inline void null_get_all_codepoints_func (const void *obj, hb_set_t *out)</span>
<span class="line-removed">1001     {</span>
<span class="line-removed">1002       // NOOP</span>
<span class="line-removed">1003     }</span>
1004 
1005     template &lt;typename Type&gt;
<span class="line-modified">1006     static inline bool get_glyph_from (const void *obj,</span>
<span class="line-modified">1007                                        hb_codepoint_t codepoint,</span>
<span class="line-modified">1008                                        hb_codepoint_t *glyph)</span>
1009     {
1010       const Type *typed_obj = (const Type *) obj;
1011       return typed_obj-&gt;get_glyph (codepoint, glyph);
1012     }
1013 
1014     template &lt;typename Type&gt;
<span class="line-modified">1015     static inline void get_all_codepoints_from (const void *obj,</span>
<span class="line-removed">1016                                                 hb_set_t *out)</span>
<span class="line-removed">1017     {</span>
<span class="line-removed">1018       const Type *typed_obj = (const Type *) obj;</span>
<span class="line-removed">1019       typed_obj-&gt;get_all_codepoints (out);</span>
<span class="line-removed">1020     }</span>
<span class="line-removed">1021 </span>
<span class="line-removed">1022     template &lt;typename Type&gt;</span>
<span class="line-removed">1023     static inline bool get_glyph_from_symbol (const void *obj,</span>
1024                                               hb_codepoint_t codepoint,
1025                                               hb_codepoint_t *glyph)
1026     {
1027       const Type *typed_obj = (const Type *) obj;
1028       if (likely (typed_obj-&gt;get_glyph (codepoint, glyph)))
1029         return true;
1030 
1031       if (codepoint &lt;= 0x00FFu)
1032       {
1033         /* For symbol-encoded OpenType fonts, we duplicate the
1034          * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
1035          * Windows seems to do, and that&#39;s hinted about at:
1036          * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
1037          * under &quot;Non-Standard (Symbol) Fonts&quot;. */
1038         return typed_obj-&gt;get_glyph (0xF000u + codepoint, glyph);
1039       }
1040 
1041       return false;
1042     }
1043 
1044     private:
<span class="line-modified">1045     hb_cmap_get_glyph_func_t get_glyph_func;</span>



1046     const void *get_glyph_data;
<span class="line-removed">1047     hb_cmap_get_all_codepoints_func_t get_all_codepoints_func;</span>
1048 
<span class="line-modified">1049     OT::CmapSubtableFormat4::accelerator_t format4_accel;</span>
1050 
<span class="line-modified">1051     const OT::CmapSubtableFormat14 *uvs_table;</span>
<span class="line-removed">1052     hb_blob_t *blob;</span>
1053   };
1054 
1055   protected:
1056 
<span class="line-modified">1057   inline const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="line-modified">1058                                             unsigned int encoding_id) const</span>
1059   {
1060     EncodingRecord key;
1061     key.platformID.set (platform_id);
1062     key.encodingID.set (encoding_id);
1063 
<span class="line-modified">1064     /* Note: We can use bsearch, but since it has no performance</span>
<span class="line-modified">1065      * implications, we use lsearch and as such accept fonts with</span>
<span class="line-removed">1066      * unsorted subtable list. */</span>
<span class="line-removed">1067     int result = encodingRecord./*bsearch*/lsearch (key);</span>
<span class="line-removed">1068     if (result == -1 || !encodingRecord[result].subtable)</span>
1069       return nullptr;
1070 
<span class="line-modified">1071     return &amp;(this+encodingRecord[result].subtable);</span>










1072   }
1073 
1074   protected:
1075   HBUINT16              version;        /* Table version number (0). */
1076   SortedArrayOf&lt;EncodingRecord&gt;
1077                         encodingRecord; /* Encoding tables. */
1078   public:
1079   DEFINE_SIZE_ARRAY (4, encodingRecord);
1080 };
1081 

1082 
1083 } /* namespace OT */
1084 
1085 
1086 #endif /* HB_OT_CMAP_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
  27 #ifndef HB_OT_CMAP_TABLE_HH
  28 #define HB_OT_CMAP_TABLE_HH
  29 
<span class="line-modified">  30 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">  31 #include &quot;hb-set.hh&quot;</span>

  32 
  33 /*
  34  * cmap -- Character to Glyph Index Mapping
  35  * https://docs.microsoft.com/en-us/typography/opentype/spec/cmap
  36  */
  37 #define HB_OT_TAG_cmap HB_TAG(&#39;c&#39;,&#39;m&#39;,&#39;a&#39;,&#39;p&#39;)
  38 

  39 namespace OT {
  40 
  41 
  42 struct CmapSubtableFormat0
  43 {
<span class="line-modified">  44   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
  45   {
  46     hb_codepoint_t gid = codepoint &lt; 256 ? glyphIdArray[codepoint] : 0;
  47     if (!gid)
  48       return false;
  49     *glyph = gid;
  50     return true;
  51   }
<span class="line-added">  52   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added">  53   {</span>
<span class="line-added">  54     for (unsigned int i = 0; i &lt; 256; i++)</span>
<span class="line-added">  55       if (glyphIdArray[i])</span>
<span class="line-added">  56         out-&gt;add (i);</span>
<span class="line-added">  57   }</span>
  58 
<span class="line-modified">  59   bool sanitize (hb_sanitize_context_t *c) const</span>
  60   {
  61     TRACE_SANITIZE (this);
  62     return_trace (c-&gt;check_struct (this));
  63   }
  64 
  65   protected:
  66   HBUINT16      format;         /* Format number is set to 0. */
  67   HBUINT16      length;         /* Byte length of this subtable. */
  68   HBUINT16      language;       /* Ignore. */
  69   HBUINT8       glyphIdArray[256];/* An array that maps character
  70                                  * code to glyph index values. */
  71   public:
  72   DEFINE_SIZE_STATIC (6 + 256);
  73 };
  74 
  75 struct CmapSubtableFormat4
  76 {
  77   struct segment_plan
  78   {
  79     HBUINT16 start_code;
  80     HBUINT16 end_code;
  81     bool use_delta;
  82   };
  83 
  84   bool serialize (hb_serialize_context_t *c,
  85                   const hb_subset_plan_t *plan,
  86                   const hb_vector_t&lt;segment_plan&gt; &amp;segments)
  87   {
  88     TRACE_SERIALIZE (this);
  89 
  90     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
  91 
  92     this-&gt;format.set (4);
  93     this-&gt;length.set (get_sub_table_size (segments));
  94 
<span class="line-modified">  95     this-&gt;segCountX2.set (segments.length * 2);</span>
<span class="line-modified">  96     this-&gt;entrySelector.set (MAX (1u, hb_bit_storage (segments.length)) - 1);</span>
  97     this-&gt;searchRange.set (2 * (1u &lt;&lt; this-&gt;entrySelector));
<span class="line-modified">  98     this-&gt;rangeShift.set (segments.length * 2 &gt; this-&gt;searchRange</span>
<span class="line-modified">  99                           ? 2 * segments.length - this-&gt;searchRange</span>
 100                           : 0);
 101 
<span class="line-modified"> 102     HBUINT16 *end_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
 103     c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size); // 2 bytes of padding.
<span class="line-modified"> 104     HBUINT16 *start_count = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="line-modified"> 105     HBINT16 *id_delta = c-&gt;allocate_size&lt;HBINT16&gt; (HBUINT16::static_size * segments.length);</span>
<span class="line-modified"> 106     HBUINT16 *id_range_offset = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * segments.length);</span>
 107 
 108     if (id_range_offset == nullptr)
 109       return_trace (false);
 110 
<span class="line-modified"> 111     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
 112     {
 113       end_count[i].set (segments[i].end_code);
 114       start_count[i].set (segments[i].start_code);
 115       if (segments[i].use_delta)
 116       {
 117         hb_codepoint_t cp = segments[i].start_code;
 118         hb_codepoint_t start_gid = 0;
 119         if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;start_gid) &amp;&amp; cp != 0xFFFF))
 120           return_trace (false);
 121         id_delta[i].set (start_gid - segments[i].start_code);
 122       } else {
 123         id_delta[i].set (0);
 124         unsigned int num_codepoints = segments[i].end_code - segments[i].start_code + 1;
 125         HBUINT16 *glyph_id_array = c-&gt;allocate_size&lt;HBUINT16&gt; (HBUINT16::static_size * num_codepoints);
 126         if (glyph_id_array == nullptr)
 127           return_trace (false);
 128         // From the cmap spec:
 129         //
 130         // id_range_offset[i]/2
 131         // + (cp - segments[i].start_code)
</pre>
<hr />
<pre>
 137         //
 138         // id_range_offset[i]
 139         // =
 140         // 2 * (glyph_id_array - id_range_offset - i)
 141         id_range_offset[i].set (2 * (
 142             glyph_id_array - id_range_offset - i));
 143         for (unsigned int j = 0; j &lt; num_codepoints; j++)
 144         {
 145           hb_codepoint_t cp = segments[i].start_code + j;
 146           hb_codepoint_t new_gid;
 147           if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 148             return_trace (false);
 149           glyph_id_array[j].set (new_gid);
 150         }
 151       }
 152     }
 153 
 154     return_trace (true);
 155   }
 156 
<span class="line-modified"> 157   static size_t get_sub_table_size (const hb_vector_t&lt;segment_plan&gt; &amp;segments)</span>
 158   {
 159     size_t segment_size = 0;
<span class="line-modified"> 160     for (unsigned int i = 0; i &lt; segments.length; i++)</span>
 161     {
 162       // Parallel array entries
 163       segment_size +=
 164             2  // end count
 165           + 2  // start count
 166           + 2  // delta
 167           + 2; // range offset
 168 
 169       if (!segments[i].use_delta)
 170         // Add bytes for the glyph index array entries for this segment.
 171         segment_size += (segments[i].end_code - segments[i].start_code + 1) * 2;
 172     }
 173 
 174     return min_size
 175         + 2 // Padding
 176         + segment_size;
 177   }
 178 
<span class="line-modified"> 179   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 180                                      hb_vector_t&lt;segment_plan&gt; *segments)</span>
 181   {
 182     segment_plan *segment = nullptr;
 183     hb_codepoint_t last_gid = 0;
 184 
 185     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 186     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 187       hb_codepoint_t new_gid;
 188       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 189       {
 190         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 191         return false;
 192       }
 193 
<span class="line-modified"> 194       /* Stop adding to cmap if we are now outside of unicode BMP. */</span>
<span class="line-modified"> 195       if (cp &gt; 0xFFFF) break;</span>


 196 
<span class="line-modified"> 197       if (!segment ||</span>
<span class="line-modified"> 198           cp != segment-&gt;end_code + 1u)</span>
 199       {
 200         segment = segments-&gt;push ();
 201         segment-&gt;start_code.set (cp);
 202         segment-&gt;end_code.set (cp);
 203         segment-&gt;use_delta = true;
 204       } else {
 205         segment-&gt;end_code.set (cp);
 206         if (last_gid + 1u != new_gid)
 207           // gid&#39;s are not consecutive in this segment so delta
 208           // cannot be used.
 209           segment-&gt;use_delta = false;
 210       }
 211 
 212       last_gid = new_gid;
 213     }
 214 
 215     // There must be a final entry with end_code == 0xFFFF. Check if we need to add one.
 216     if (segment == nullptr || segment-&gt;end_code != 0xFFFF)
 217     {
 218       segment = segments-&gt;push ();
 219       segment-&gt;start_code.set (0xFFFF);
 220       segment-&gt;end_code.set (0xFFFF);
 221       segment-&gt;use_delta = true;
 222     }
 223 
 224     return true;
 225   }
 226 
 227   struct accelerator_t
 228   {
<span class="line-modified"> 229     accelerator_t () {}</span>
<span class="line-added"> 230     accelerator_t (const CmapSubtableFormat4 *subtable) { init (subtable); }</span>
<span class="line-added"> 231     ~accelerator_t () { fini (); }</span>
<span class="line-added"> 232 </span>
<span class="line-added"> 233     void init (const CmapSubtableFormat4 *subtable)</span>
 234     {
 235       segCount = subtable-&gt;segCountX2 / 2;
<span class="line-modified"> 236       endCount = subtable-&gt;values.arrayZ;</span>
 237       startCount = endCount + segCount + 1;
 238       idDelta = startCount + segCount;
 239       idRangeOffset = idDelta + segCount;
 240       glyphIdArray = idRangeOffset + segCount;
 241       glyphIdArrayLength = (subtable-&gt;length - 16 - 8 * segCount) / 2;
 242     }
<span class="line-added"> 243     void fini () {}</span>
 244 
<span class="line-modified"> 245     bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 246     {


 247       /* Custom two-array bsearch. */
<span class="line-modified"> 248       int min = 0, max = (int) this-&gt;segCount - 1;</span>
<span class="line-modified"> 249       const HBUINT16 *startCount = this-&gt;startCount;</span>
<span class="line-modified"> 250       const HBUINT16 *endCount = this-&gt;endCount;</span>
 251       unsigned int i;
 252       while (min &lt;= max)
 253       {
<span class="line-modified"> 254         int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
 255         if (codepoint &lt; startCount[mid])
 256           max = mid - 1;
 257         else if (codepoint &gt; endCount[mid])
 258           min = mid + 1;
 259         else
 260         {
 261           i = mid;
 262           goto found;
 263         }
 264       }
 265       return false;
 266 
 267     found:
 268       hb_codepoint_t gid;
<span class="line-modified"> 269       unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
 270       if (rangeOffset == 0)
<span class="line-modified"> 271         gid = codepoint + this-&gt;idDelta[i];</span>
 272       else
 273       {
 274         /* Somebody has been smoking... */
<span class="line-modified"> 275         unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="line-modified"> 276         if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
 277           return false;
<span class="line-modified"> 278         gid = this-&gt;glyphIdArray[index];</span>
 279         if (unlikely (!gid))
 280           return false;
<span class="line-modified"> 281         gid += this-&gt;idDelta[i];</span>
 282       }
<span class="line-modified"> 283       gid &amp;= 0xFFFFu;</span>
<span class="line-modified"> 284       if (!gid)</span>
<span class="line-added"> 285         return false;</span>
<span class="line-added"> 286       *glyph = gid;</span>
 287       return true;
 288     }
<span class="line-modified"> 289     static bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)</span>
<span class="line-modified"> 290     {</span>
<span class="line-added"> 291       return ((const accelerator_t *) obj)-&gt;get_glyph (codepoint, glyph);</span>
<span class="line-added"> 292     }</span>
<span class="line-added"> 293     void collect_unicodes (hb_set_t *out) const</span>
 294     {
<span class="line-modified"> 295       unsigned int count = this-&gt;segCount;</span>
<span class="line-modified"> 296       if (count &amp;&amp; this-&gt;startCount[count - 1] == 0xFFFFu)</span>
<span class="line-added"> 297         count--; /* Skip sentinel segment. */</span>
<span class="line-added"> 298       for (unsigned int i = 0; i &lt; count; i++)</span>
 299       {
<span class="line-modified"> 300         unsigned int rangeOffset = this-&gt;idRangeOffset[i];</span>
<span class="line-modified"> 301         if (rangeOffset == 0)</span>
<span class="line-modified"> 302           out-&gt;add_range (this-&gt;startCount[i], this-&gt;endCount[i]);</span>
<span class="line-added"> 303         else</span>
<span class="line-added"> 304         {</span>
<span class="line-added"> 305           for (hb_codepoint_t codepoint = this-&gt;startCount[i];</span>
<span class="line-added"> 306                codepoint &lt;= this-&gt;endCount[i];</span>
<span class="line-added"> 307                codepoint++)</span>
<span class="line-added"> 308           {</span>
<span class="line-added"> 309             unsigned int index = rangeOffset / 2 + (codepoint - this-&gt;startCount[i]) + i - this-&gt;segCount;</span>
<span class="line-added"> 310             if (unlikely (index &gt;= this-&gt;glyphIdArrayLength))</span>
<span class="line-added"> 311               break;</span>
<span class="line-added"> 312             hb_codepoint_t gid = this-&gt;glyphIdArray[index];</span>
<span class="line-added"> 313             if (unlikely (!gid))</span>
<span class="line-added"> 314               continue;</span>
<span class="line-added"> 315             out-&gt;add (codepoint);</span>
<span class="line-added"> 316           }</span>
<span class="line-added"> 317         }</span>
 318       }
 319     }
 320 
 321     const HBUINT16 *endCount;
 322     const HBUINT16 *startCount;
 323     const HBUINT16 *idDelta;
 324     const HBUINT16 *idRangeOffset;
 325     const HBUINT16 *glyphIdArray;
 326     unsigned int segCount;
 327     unsigned int glyphIdArrayLength;
 328   };
 329 
<span class="line-modified"> 330   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 331   {
<span class="line-modified"> 332     accelerator_t accel (this);</span>

 333     return accel.get_glyph_func (&amp;accel, codepoint, glyph);
 334   }
<span class="line-added"> 335   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 336   {</span>
<span class="line-added"> 337     accelerator_t accel (this);</span>
<span class="line-added"> 338     accel.collect_unicodes (out);</span>
<span class="line-added"> 339   }</span>
 340 
<span class="line-modified"> 341   bool sanitize (hb_sanitize_context_t *c) const</span>
 342   {
 343     TRACE_SANITIZE (this);
 344     if (unlikely (!c-&gt;check_struct (this)))
 345       return_trace (false);
 346 
 347     if (unlikely (!c-&gt;check_range (this, length)))
 348     {
 349       /* Some broken fonts have too long of a &quot;length&quot; value.
 350        * If that is the case, just change the value to truncate
 351        * the subtable at the end of the blob. */
 352       uint16_t new_length = (uint16_t) MIN ((uintptr_t) 65535,
 353                                             (uintptr_t) (c-&gt;end -
 354                                                          (char *) this));
 355       if (!c-&gt;try_set (&amp;length, new_length))
 356         return_trace (false);
 357     }
 358 
 359     return_trace (16 + 4 * (unsigned int) segCountX2 &lt;= length);
 360   }
 361 
 362 
 363 
 364   protected:
 365   HBUINT16      format;         /* Format number is set to 4. */
 366   HBUINT16      length;         /* This is the length in bytes of the
 367                                  * subtable. */
 368   HBUINT16      language;       /* Ignore. */
 369   HBUINT16      segCountX2;     /* 2 x segCount. */
 370   HBUINT16      searchRange;    /* 2 * (2**floor(log2(segCount))) */
 371   HBUINT16      entrySelector;  /* log2(searchRange/2) */
 372   HBUINT16      rangeShift;     /* 2 x segCount - searchRange */
 373 
<span class="line-modified"> 374   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="line-added"> 375                 values;</span>
 376 #if 0
 377   HBUINT16      endCount[segCount];     /* End characterCode for each segment,
 378                                          * last=0xFFFFu. */
 379   HBUINT16      reservedPad;            /* Set to 0. */
 380   HBUINT16      startCount[segCount];   /* Start character code for each segment. */
 381   HBINT16               idDelta[segCount];      /* Delta for all character codes in segment. */
 382   HBUINT16      idRangeOffset[segCount];/* Offsets into glyphIdArray or 0 */
<span class="line-modified"> 383   UnsizedArrayOf&lt;HBUINT16&gt;</span>
<span class="line-added"> 384                 glyphIdArray;   /* Glyph index array (arbitrary length) */</span>
 385 #endif
 386 
 387   public:
 388   DEFINE_SIZE_ARRAY (14, values);
 389 };
 390 
 391 struct CmapSubtableLongGroup
 392 {
 393   friend struct CmapSubtableFormat12;
 394   friend struct CmapSubtableFormat13;
 395   template&lt;typename U&gt;
 396   friend struct CmapSubtableLongSegmented;
 397   friend struct cmap;
 398 
 399   int cmp (hb_codepoint_t codepoint) const
 400   {
 401     if (codepoint &lt; startCharCode) return -1;
 402     if (codepoint &gt; endCharCode)   return +1;
 403     return 0;
 404   }
 405 
<span class="line-modified"> 406   bool sanitize (hb_sanitize_context_t *c) const</span>
 407   {
 408     TRACE_SANITIZE (this);
 409     return_trace (c-&gt;check_struct (this));
 410   }
 411 
 412   private:
 413   HBUINT32              startCharCode;  /* First character code in this group. */
 414   HBUINT32              endCharCode;    /* Last character code in this group. */
 415   HBUINT32              glyphID;        /* Glyph index; interpretation depends on
<span class="line-modified"> 416                                          * subtable format. */</span>
 417   public:
 418   DEFINE_SIZE_STATIC (12);
 419 };
<span class="line-added"> 420 DECLARE_NULL_NAMESPACE_BYTES (OT, CmapSubtableLongGroup);</span>
 421 
 422 template &lt;typename UINT&gt;
 423 struct CmapSubtableTrimmed
 424 {
<span class="line-modified"> 425   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 426   {
 427     /* Rely on our implicit array bound-checking. */
 428     hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];
 429     if (!gid)
 430       return false;
 431     *glyph = gid;
 432     return true;
 433   }
<span class="line-added"> 434   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 435   {</span>
<span class="line-added"> 436     hb_codepoint_t start = startCharCode;</span>
<span class="line-added"> 437     unsigned int count = glyphIdArray.len;</span>
<span class="line-added"> 438     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 439       if (glyphIdArray[i])</span>
<span class="line-added"> 440         out-&gt;add (start + i);</span>
<span class="line-added"> 441   }</span>
 442 
<span class="line-modified"> 443   bool sanitize (hb_sanitize_context_t *c) const</span>
 444   {
 445     TRACE_SANITIZE (this);
 446     return_trace (c-&gt;check_struct (this) &amp;&amp; glyphIdArray.sanitize (c));
 447   }
 448 
 449   protected:
 450   UINT          formatReserved; /* Subtable format and (maybe) padding. */
 451   UINT          length;         /* Byte length of this subtable. */
 452   UINT          language;       /* Ignore. */
 453   UINT          startCharCode;  /* First character code covered. */
 454   ArrayOf&lt;GlyphID, UINT&gt;
 455                 glyphIdArray;   /* Array of glyph index values for character
 456                                  * codes in the range. */
 457   public:
 458   DEFINE_SIZE_ARRAY (5 * sizeof (UINT), glyphIdArray);
 459 };
 460 
 461 struct CmapSubtableFormat6  : CmapSubtableTrimmed&lt;HBUINT16&gt; {};
 462 struct CmapSubtableFormat10 : CmapSubtableTrimmed&lt;HBUINT32 &gt; {};
 463 
 464 template &lt;typename T&gt;
 465 struct CmapSubtableLongSegmented
 466 {
 467   friend struct cmap;
 468 
<span class="line-modified"> 469   bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const</span>
 470   {
<span class="line-modified"> 471     hb_codepoint_t gid = T::group_get_glyph (groups.bsearch (codepoint), codepoint);</span>
<span class="line-modified"> 472     if (!gid)</span>
 473       return false;
<span class="line-modified"> 474     *glyph = gid;</span>
 475     return true;
 476   }
 477 
<span class="line-modified"> 478   void collect_unicodes (hb_set_t *out) const</span>
 479   {
 480     for (unsigned int i = 0; i &lt; this-&gt;groups.len; i++) {
<span class="line-modified"> 481       out-&gt;add_range (this-&gt;groups[i].startCharCode,</span>
<span class="line-modified"> 482                       MIN ((hb_codepoint_t) this-&gt;groups[i].endCharCode,</span>
<span class="line-modified"> 483                            (hb_codepoint_t) HB_UNICODE_MAX));</span>
 484     }
 485   }
 486 
<span class="line-modified"> 487   bool sanitize (hb_sanitize_context_t *c) const</span>
 488   {
 489     TRACE_SANITIZE (this);
 490     return_trace (c-&gt;check_struct (this) &amp;&amp; groups.sanitize (c));
 491   }
 492 
<span class="line-modified"> 493   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 494                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;group_data)</span>
 495   {
 496     TRACE_SERIALIZE (this);
 497     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<span class="line-modified"> 498     if (unlikely (!groups.serialize (c, group_data.as_array ()))) return_trace (false);</span>

 499     return true;
 500   }
 501 
 502   protected:
 503   HBUINT16      format;         /* Subtable format; set to 12. */
 504   HBUINT16      reserved;       /* Reserved; set to 0. */
 505   HBUINT32      length;         /* Byte length of this subtable. */
 506   HBUINT32      language;       /* Ignore. */
 507   SortedArrayOf&lt;CmapSubtableLongGroup, HBUINT32&gt;
 508                 groups;         /* Groupings. */
 509   public:
 510   DEFINE_SIZE_ARRAY (16, groups);
 511 };
 512 
 513 struct CmapSubtableFormat12 : CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;
 514 {
<span class="line-modified"> 515   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 516                                          hb_codepoint_t u)</span>
<span class="line-modified"> 517   { return likely (group.startCharCode &lt;= group.endCharCode) ?</span>
<span class="line-added"> 518            group.glyphID + (u - group.startCharCode) : 0; }</span>
 519 
 520 
 521   bool serialize (hb_serialize_context_t *c,
 522                   const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)
 523   {
 524     if (unlikely (!c-&gt;extend_min (*this))) return false;
 525 
 526     this-&gt;format.set (12);
 527     this-&gt;reserved.set (0);
 528     this-&gt;length.set (get_sub_table_size (groups));
 529 
 530     return CmapSubtableLongSegmented&lt;CmapSubtableFormat12&gt;::serialize (c, groups);
 531   }
 532 
<span class="line-modified"> 533   static size_t get_sub_table_size (const hb_vector_t&lt;CmapSubtableLongGroup&gt; &amp;groups)</span>
 534   {
<span class="line-modified"> 535     return 16 + 12 * groups.length;</span>
 536   }
 537 
<span class="line-modified"> 538   static bool create_sub_table_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 539                                      hb_vector_t&lt;CmapSubtableLongGroup&gt; *groups)</span>
 540   {
 541     CmapSubtableLongGroup *group = nullptr;
 542 
 543     hb_codepoint_t cp = HB_SET_VALUE_INVALID;
 544     while (plan-&gt;unicodes-&gt;next (&amp;cp)) {
 545       hb_codepoint_t new_gid;
 546       if (unlikely (!plan-&gt;new_gid_for_codepoint (cp, &amp;new_gid)))
 547       {
 548         DEBUG_MSG(SUBSET, nullptr, &quot;Unable to find new gid for %04x&quot;, cp);
 549         return false;
 550       }
 551 
 552       if (!group || !_is_gid_consecutive (group, cp, new_gid))
 553       {
 554         group = groups-&gt;push ();
 555         group-&gt;startCharCode.set (cp);
 556         group-&gt;endCharCode.set (cp);
 557         group-&gt;glyphID.set (new_gid);



 558       }
<span class="line-added"> 559       else group-&gt;endCharCode.set (cp);</span>
 560     }
 561 
 562     DEBUG_MSG(SUBSET, nullptr, &quot;cmap&quot;);
<span class="line-modified"> 563     for (unsigned int i = 0; i &lt; groups-&gt;length; i++) {</span>
 564       CmapSubtableLongGroup&amp; group = (*groups)[i];
 565       DEBUG_MSG(SUBSET, nullptr, &quot;  %d: U+%04X-U+%04X, gid %d-%d&quot;, i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));
 566     }
 567 
 568     return true;
 569   }
 570 
 571  private:
<span class="line-modified"> 572   static bool _is_gid_consecutive (CmapSubtableLongGroup *group,</span>
<span class="line-modified"> 573                                    hb_codepoint_t cp,</span>
<span class="line-modified"> 574                                    hb_codepoint_t new_gid)</span>
 575   {
 576     return (cp - 1 == group-&gt;endCharCode) &amp;&amp;
 577         new_gid == group-&gt;glyphID + (cp - group-&gt;startCharCode);
 578   }
 579 
 580 };
 581 
 582 struct CmapSubtableFormat13 : CmapSubtableLongSegmented&lt;CmapSubtableFormat13&gt;
 583 {
<span class="line-modified"> 584   static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &amp;group,</span>
<span class="line-modified"> 585                                          hb_codepoint_t u HB_UNUSED)</span>
 586   { return group.glyphID; }
 587 };
 588 
 589 typedef enum
 590 {
 591   GLYPH_VARIANT_NOT_FOUND = 0,
 592   GLYPH_VARIANT_FOUND = 1,
 593   GLYPH_VARIANT_USE_DEFAULT = 2
 594 } glyph_variant_t;
 595 
 596 struct UnicodeValueRange
 597 {
<span class="line-modified"> 598   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 599   {
 600     if (codepoint &lt; startUnicodeValue) return -1;
 601     if (codepoint &gt; startUnicodeValue + additionalCount) return +1;
 602     return 0;
 603   }
 604 
<span class="line-modified"> 605   bool sanitize (hb_sanitize_context_t *c) const</span>
 606   {
 607     TRACE_SANITIZE (this);
 608     return_trace (c-&gt;check_struct (this));
 609   }
 610 
 611   HBUINT24      startUnicodeValue;      /* First value in this range. */
<span class="line-modified"> 612   HBUINT8       additionalCount;        /* Number of additional values in this</span>
 613                                          * range. */
 614   public:
 615   DEFINE_SIZE_STATIC (4);
 616 };
 617 
<span class="line-modified"> 618 struct DefaultUVS : SortedArrayOf&lt;UnicodeValueRange, HBUINT32&gt;</span>
<span class="line-added"> 619 {</span>
<span class="line-added"> 620   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 621   {</span>
<span class="line-added"> 622     unsigned int count = len;</span>
<span class="line-added"> 623     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 624     {</span>
<span class="line-added"> 625       hb_codepoint_t first = arrayZ[i].startUnicodeValue;</span>
<span class="line-added"> 626       hb_codepoint_t last = MIN ((hb_codepoint_t) (first + arrayZ[i].additionalCount),</span>
<span class="line-added"> 627                                  (hb_codepoint_t) HB_UNICODE_MAX);</span>
<span class="line-added"> 628       out-&gt;add_range (first, last);</span>
<span class="line-added"> 629     }</span>
<span class="line-added"> 630   }</span>
<span class="line-added"> 631 </span>
<span class="line-added"> 632   public:</span>
<span class="line-added"> 633   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="line-added"> 634 };</span>
 635 
 636 struct UVSMapping
 637 {
<span class="line-modified"> 638   int cmp (const hb_codepoint_t &amp;codepoint) const</span>
 639   {
 640     return unicodeValue.cmp (codepoint);
 641   }
 642 
<span class="line-modified"> 643   bool sanitize (hb_sanitize_context_t *c) const</span>
 644   {
 645     TRACE_SANITIZE (this);
 646     return_trace (c-&gt;check_struct (this));
 647   }
 648 
 649   HBUINT24      unicodeValue;   /* Base Unicode value of the UVS */
 650   GlyphID       glyphID;        /* Glyph ID of the UVS */
 651   public:
 652   DEFINE_SIZE_STATIC (5);
 653 };
 654 
<span class="line-modified"> 655 struct NonDefaultUVS : SortedArrayOf&lt;UVSMapping, HBUINT32&gt;</span>
<span class="line-added"> 656 {</span>
<span class="line-added"> 657   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 658   {</span>
<span class="line-added"> 659     unsigned int count = len;</span>
<span class="line-added"> 660     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 661       out-&gt;add (arrayZ[i].glyphID);</span>
<span class="line-added"> 662   }</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664   public:</span>
<span class="line-added"> 665   DEFINE_SIZE_ARRAY (4, *this);</span>
<span class="line-added"> 666 };</span>
 667 
 668 struct VariationSelectorRecord
 669 {
<span class="line-modified"> 670   glyph_variant_t get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 671                              hb_codepoint_t *glyph,</span>
<span class="line-modified"> 672                              const void *base) const</span>
 673   {
<span class="line-modified"> 674     if ((base+defaultUVS).bfind (codepoint))</span>



 675       return GLYPH_VARIANT_USE_DEFAULT;
<span class="line-modified"> 676     const UVSMapping &amp;nonDefault = (base+nonDefaultUVS).bsearch (codepoint);</span>
<span class="line-modified"> 677     if (nonDefault.glyphID)</span>

 678     {
<span class="line-modified"> 679       *glyph = nonDefault.glyphID;</span>
 680        return GLYPH_VARIANT_FOUND;
 681     }
 682     return GLYPH_VARIANT_NOT_FOUND;
 683   }
 684 
<span class="line-modified"> 685   void collect_unicodes (hb_set_t *out, const void *base) const</span>
<span class="line-added"> 686   {</span>
<span class="line-added"> 687     (base+defaultUVS).collect_unicodes (out);</span>
<span class="line-added"> 688     (base+nonDefaultUVS).collect_unicodes (out);</span>
<span class="line-added"> 689   }</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691   int cmp (const hb_codepoint_t &amp;variation_selector) const</span>
 692   {
 693     return varSelector.cmp (variation_selector);
 694   }
 695 
<span class="line-modified"> 696   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 697   {
 698     TRACE_SANITIZE (this);
 699     return_trace (c-&gt;check_struct (this) &amp;&amp;
 700                   defaultUVS.sanitize (c, base) &amp;&amp;
 701                   nonDefaultUVS.sanitize (c, base));
 702   }
 703 
 704   HBUINT24      varSelector;    /* Variation selector. */
 705   LOffsetTo&lt;DefaultUVS&gt;
<span class="line-modified"> 706                 defaultUVS;     /* Offset to Default UVS Table.  May be 0. */</span>
 707   LOffsetTo&lt;NonDefaultUVS&gt;
<span class="line-modified"> 708                 nonDefaultUVS;  /* Offset to Non-Default UVS Table.  May be 0. */</span>
 709   public:
 710   DEFINE_SIZE_STATIC (11);
 711 };
 712 
 713 struct CmapSubtableFormat14
 714 {
<span class="line-modified"> 715   glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 716                                      hb_codepoint_t variation_selector,</span>
<span class="line-modified"> 717                                      hb_codepoint_t *glyph) const</span>
 718   {
<span class="line-modified"> 719     return record.bsearch (variation_selector).get_glyph (codepoint, glyph, this);</span>
 720   }
 721 
<span class="line-modified"> 722   void collect_variation_selectors (hb_set_t *out) const</span>
<span class="line-added"> 723   {</span>
<span class="line-added"> 724     unsigned int count = record.len;</span>
<span class="line-added"> 725     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 726       out-&gt;add (record.arrayZ[i].varSelector);</span>
<span class="line-added"> 727   }</span>
<span class="line-added"> 728   void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="line-added"> 729                                    hb_set_t *out) const</span>
<span class="line-added"> 730   {</span>
<span class="line-added"> 731     record.bsearch (variation_selector).collect_unicodes (out, this);</span>
<span class="line-added"> 732   }</span>
<span class="line-added"> 733 </span>
<span class="line-added"> 734   bool sanitize (hb_sanitize_context_t *c) const</span>
 735   {
 736     TRACE_SANITIZE (this);
 737     return_trace (c-&gt;check_struct (this) &amp;&amp;
 738                   record.sanitize (c, this));
 739   }
 740 
 741   protected:
 742   HBUINT16      format;         /* Format number is set to 14. */
 743   HBUINT32      length;         /* Byte length of this subtable. */
 744   SortedArrayOf&lt;VariationSelectorRecord, HBUINT32&gt;
 745                 record;         /* Variation selector records; sorted
 746                                  * in increasing order of `varSelector&#39;. */
 747   public:
 748   DEFINE_SIZE_ARRAY (10, record);
 749 };
 750 
 751 struct CmapSubtable
 752 {
 753   /* Note: We intentionally do NOT implement subtable formats 2 and 8. */
 754 
<span class="line-modified"> 755   bool get_glyph (hb_codepoint_t codepoint,</span>
<span class="line-modified"> 756                   hb_codepoint_t *glyph) const</span>
 757   {
 758     switch (u.format) {
 759     case  0: return u.format0 .get_glyph (codepoint, glyph);
 760     case  4: return u.format4 .get_glyph (codepoint, glyph);
 761     case  6: return u.format6 .get_glyph (codepoint, glyph);
 762     case 10: return u.format10.get_glyph (codepoint, glyph);
 763     case 12: return u.format12.get_glyph (codepoint, glyph);
 764     case 13: return u.format13.get_glyph (codepoint, glyph);
 765     case 14:
 766     default: return false;
 767     }
 768   }
<span class="line-added"> 769   void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added"> 770   {</span>
<span class="line-added"> 771     switch (u.format) {</span>
<span class="line-added"> 772     case  0: u.format0 .collect_unicodes (out); return;</span>
<span class="line-added"> 773     case  4: u.format4 .collect_unicodes (out); return;</span>
<span class="line-added"> 774     case  6: u.format6 .collect_unicodes (out); return;</span>
<span class="line-added"> 775     case 10: u.format10.collect_unicodes (out); return;</span>
<span class="line-added"> 776     case 12: u.format12.collect_unicodes (out); return;</span>
<span class="line-added"> 777     case 13: u.format13.collect_unicodes (out); return;</span>
<span class="line-added"> 778     case 14:</span>
<span class="line-added"> 779     default: return;</span>
<span class="line-added"> 780     }</span>
<span class="line-added"> 781   }</span>
 782 
<span class="line-modified"> 783   bool sanitize (hb_sanitize_context_t *c) const</span>
 784   {
 785     TRACE_SANITIZE (this);
 786     if (!u.format.sanitize (c)) return_trace (false);
 787     switch (u.format) {
 788     case  0: return_trace (u.format0 .sanitize (c));
 789     case  4: return_trace (u.format4 .sanitize (c));
 790     case  6: return_trace (u.format6 .sanitize (c));
 791     case 10: return_trace (u.format10.sanitize (c));
 792     case 12: return_trace (u.format12.sanitize (c));
 793     case 13: return_trace (u.format13.sanitize (c));
 794     case 14: return_trace (u.format14.sanitize (c));
 795     default:return_trace (true);
 796     }
 797   }
 798 
 799   public:
 800   union {
 801   HBUINT16              format;         /* Format identifier */
 802   CmapSubtableFormat0   format0;
 803   CmapSubtableFormat4   format4;
 804   CmapSubtableFormat6   format6;
 805   CmapSubtableFormat10  format10;
 806   CmapSubtableFormat12  format12;
 807   CmapSubtableFormat13  format13;
 808   CmapSubtableFormat14  format14;
 809   } u;
 810   public:
 811   DEFINE_SIZE_UNION (2, format);
 812 };
 813 
 814 
 815 struct EncodingRecord
 816 {
<span class="line-modified"> 817   int cmp (const EncodingRecord &amp;other) const</span>
 818   {
 819     int ret;
 820     ret = platformID.cmp (other.platformID);
 821     if (ret) return ret;
 822     ret = encodingID.cmp (other.encodingID);
 823     if (ret) return ret;
 824     return 0;
 825   }
 826 
<span class="line-modified"> 827   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 828   {
 829     TRACE_SANITIZE (this);
 830     return_trace (c-&gt;check_struct (this) &amp;&amp;
 831                   subtable.sanitize (c, base));
 832   }
 833 
 834   HBUINT16      platformID;     /* Platform ID. */
 835   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 836   LOffsetTo&lt;CmapSubtable&gt;
 837                 subtable;       /* Byte offset from beginning of table to the subtable for this encoding. */
 838   public:
 839   DEFINE_SIZE_STATIC (8);
 840 };
 841 
 842 struct cmap
 843 {
<span class="line-modified"> 844   static constexpr hb_tag_t tableTag = HB_OT_TAG_cmap;</span>







 845 
<span class="line-modified"> 846   struct subset_plan</span>
<span class="line-modified"> 847   {</span>
<span class="line-modified"> 848     size_t final_size () const</span>




 849     {
 850       return 4 // header
 851           +  8 * 3 // 3 EncodingRecord
 852           +  CmapSubtableFormat4::get_sub_table_size (this-&gt;format4_segments)
 853           +  CmapSubtableFormat12::get_sub_table_size (this-&gt;format12_groups);
 854     }
 855 

 856     hb_vector_t&lt;CmapSubtableFormat4::segment_plan&gt; format4_segments;

 857     hb_vector_t&lt;CmapSubtableLongGroup&gt; format12_groups;
 858   };
 859 
<span class="line-modified"> 860   bool _create_plan (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 861                      subset_plan *cmap_plan) const</span>








 862   {
<span class="line-modified"> 863     if (unlikely (!CmapSubtableFormat4::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format4_segments)))</span>
 864       return false;
 865 
 866     return CmapSubtableFormat12::create_sub_table_plan (plan, &amp;cmap_plan-&gt;format12_groups);
 867   }
 868 
<span class="line-modified"> 869   bool _subset (const hb_subset_plan_t *plan,</span>
<span class="line-modified"> 870                 const subset_plan &amp;cmap_subset_plan,</span>
<span class="line-modified"> 871                 size_t dest_sz,</span>
<span class="line-modified"> 872                 void *dest) const</span>
 873   {
 874     hb_serialize_context_t c (dest, dest_sz);
 875 
<span class="line-modified"> 876     cmap *table = c.start_serialize&lt;cmap&gt; ();</span>
<span class="line-modified"> 877     if (unlikely (!c.extend_min (*table)))</span>
 878     {
 879       return false;
 880     }
 881 
<span class="line-modified"> 882     table-&gt;version.set (0);</span>
 883 
<span class="line-modified"> 884     if (unlikely (!table-&gt;encodingRecord.serialize (&amp;c, /* numTables */ 3)))</span>
 885       return false;
 886 
 887     // TODO(grieger): Convert the below to a for loop
 888 
 889     // Format 4, Plat 0 Encoding Record
<span class="line-modified"> 890     EncodingRecord &amp;format4_plat0_rec = table-&gt;encodingRecord[0];</span>
 891     format4_plat0_rec.platformID.set (0); // Unicode
 892     format4_plat0_rec.encodingID.set (3);
 893 
 894     // Format 4, Plat 3 Encoding Record
<span class="line-modified"> 895     EncodingRecord &amp;format4_plat3_rec = table-&gt;encodingRecord[1];</span>
 896     format4_plat3_rec.platformID.set (3); // Windows
 897     format4_plat3_rec.encodingID.set (1); // Unicode BMP
 898 
 899     // Format 12 Encoding Record
<span class="line-modified"> 900     EncodingRecord &amp;format12_rec = table-&gt;encodingRecord[2];</span>
 901     format12_rec.platformID.set (3); // Windows
 902     format12_rec.encodingID.set (10); // Unicode UCS-4
 903 
 904     // Write out format 4 sub table
 905     {
<span class="line-modified"> 906       CmapSubtable &amp;subtable = format4_plat0_rec.subtable.serialize (&amp;c, table);</span>
 907       format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);
 908       subtable.u.format.set (4);
 909 
 910       CmapSubtableFormat4 &amp;format4 = subtable.u.format4;
 911       if (unlikely (!format4.serialize (&amp;c, plan, cmap_subset_plan.format4_segments)))
 912         return false;
 913     }
 914 
 915     // Write out format 12 sub table.
 916     {
<span class="line-modified"> 917       CmapSubtable &amp;subtable = format12_rec.subtable.serialize (&amp;c, table);</span>
 918       subtable.u.format.set (12);
 919 
 920       CmapSubtableFormat12 &amp;format12 = subtable.u.format12;
 921       if (unlikely (!format12.serialize (&amp;c, cmap_subset_plan.format12_groups)))
 922         return false;
 923     }
 924 
 925     c.end_serialize ();
 926 
 927     return true;
 928   }
 929 
<span class="line-modified"> 930   bool subset (hb_subset_plan_t *plan) const</span>
 931   {
 932     subset_plan cmap_subset_plan;
 933 
 934     if (unlikely (!_create_plan (plan, &amp;cmap_subset_plan)))
 935     {
 936       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to generate a cmap subsetting plan.&quot;);
 937       return false;
 938     }
 939 
 940     // We now know how big our blob needs to be
<span class="line-modified"> 941     size_t dest_sz = cmap_subset_plan.final_size ();</span>
 942     void *dest = malloc (dest_sz);
 943     if (unlikely (!dest)) {
 944       DEBUG_MSG(SUBSET, nullptr, &quot;Unable to alloc %lu for cmap subset output&quot;, (unsigned long) dest_sz);
 945       return false;
 946     }
 947 
 948     if (unlikely (!_subset (plan, cmap_subset_plan, dest_sz, dest)))
 949     {
 950       DEBUG_MSG(SUBSET, nullptr, &quot;Failed to perform subsetting of cmap.&quot;);
 951       free (dest);
 952       return false;
 953     }
 954 
 955     // all done, write the blob into dest
<span class="line-modified"> 956     hb_blob_t *cmap_prime = hb_blob_create ((const char *) dest,</span>
 957                                             dest_sz,
 958                                             HB_MEMORY_MODE_READONLY,
 959                                             dest,
 960                                             free);
 961     bool result =  plan-&gt;add_table (HB_OT_TAG_cmap, cmap_prime);
 962     hb_blob_destroy (cmap_prime);
 963     return result;
 964   }
 965 
<span class="line-modified"> 966   const CmapSubtable *find_best_subtable (bool *symbol = nullptr) const</span>
 967   {
<span class="line-modified"> 968     if (symbol) *symbol = false;</span>
<span class="line-added"> 969 </span>
<span class="line-added"> 970     const CmapSubtable *subtable;</span>
<span class="line-added"> 971 </span>
<span class="line-added"> 972     /* 32-bit subtables. */</span>
<span class="line-added"> 973     if ((subtable = this-&gt;find_subtable (3, 10))) return subtable;</span>
<span class="line-added"> 974     if ((subtable = this-&gt;find_subtable (0, 6))) return subtable;</span>
<span class="line-added"> 975     if ((subtable = this-&gt;find_subtable (0, 4))) return subtable;</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977     /* 16-bit subtables. */</span>
<span class="line-added"> 978     if ((subtable = this-&gt;find_subtable (3, 1))) return subtable;</span>
<span class="line-added"> 979     if ((subtable = this-&gt;find_subtable (0, 3))) return subtable;</span>
<span class="line-added"> 980     if ((subtable = this-&gt;find_subtable (0, 2))) return subtable;</span>
<span class="line-added"> 981     if ((subtable = this-&gt;find_subtable (0, 1))) return subtable;</span>
<span class="line-added"> 982     if ((subtable = this-&gt;find_subtable (0, 0))) return subtable;</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984     /* Symbol subtable. */</span>
<span class="line-added"> 985     if ((subtable = this-&gt;find_subtable (3, 0)))</span>
 986     {
<span class="line-modified"> 987       if (symbol) *symbol = true;</span>
<span class="line-modified"> 988       return subtable;</span>
<span class="line-modified"> 989     }</span>
<span class="line-modified"> 990 </span>
<span class="line-modified"> 991     /* Meh. */</span>
<span class="line-modified"> 992     return &amp;Null (CmapSubtable);</span>
<span class="line-modified"> 993   }</span>
















 994 
<span class="line-modified"> 995   struct accelerator_t</span>
<span class="line-modified"> 996   {</span>
<span class="line-added"> 997     void init (hb_face_t *face)</span>
<span class="line-added"> 998     {</span>
<span class="line-added"> 999       this-&gt;table = hb_sanitize_context_t ().reference_table&lt;cmap&gt; (face);</span>
<span class="line-added">1000       bool symbol;</span>
<span class="line-added">1001       this-&gt;subtable = table-&gt;find_best_subtable (&amp;symbol);</span>
<span class="line-added">1002       this-&gt;subtable_uvs = &amp;Null (CmapSubtableFormat14);</span>
1003       {
<span class="line-modified">1004         const CmapSubtable *st = table-&gt;find_subtable (0, 5);</span>
1005         if (st &amp;&amp; st-&gt;u.format == 14)
1006           subtable_uvs = &amp;st-&gt;u.format14;
1007       }




1008 
1009       this-&gt;get_glyph_data = subtable;
1010       if (unlikely (symbol))
1011       {
<span class="line-modified">1012         this-&gt;get_glyph_funcZ = get_glyph_from_symbol&lt;CmapSubtable&gt;;</span>

1013       } else {
1014         switch (subtable-&gt;u.format) {
1015         /* Accelerate format 4 and format 12. */
1016         default:
<span class="line-modified">1017           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtable&gt;;</span>

1018           break;
1019         case 12:
<span class="line-modified">1020           this-&gt;get_glyph_funcZ = get_glyph_from&lt;CmapSubtableFormat12&gt;;</span>

1021           break;
1022         case  4:
1023           {
1024             this-&gt;format4_accel.init (&amp;subtable-&gt;u.format4);
1025             this-&gt;get_glyph_data = &amp;this-&gt;format4_accel;
<span class="line-modified">1026             this-&gt;get_glyph_funcZ = this-&gt;format4_accel.get_glyph_func;</span>

1027           }
1028           break;
1029         }
1030       }
1031     }
1032 
<span class="line-modified">1033     void fini () { this-&gt;table.destroy (); }</span>



1034 
<span class="line-modified">1035     bool get_nominal_glyph (hb_codepoint_t  unicode,</span>
1036                                    hb_codepoint_t *glyph) const
1037     {
<span class="line-modified">1038       if (unlikely (!this-&gt;get_glyph_funcZ)) return false;</span>
<span class="line-added">1039       return this-&gt;get_glyph_funcZ (this-&gt;get_glyph_data, unicode, glyph);</span>
<span class="line-added">1040     }</span>
<span class="line-added">1041     unsigned int get_nominal_glyphs (unsigned int count,</span>
<span class="line-added">1042                                      const hb_codepoint_t *first_unicode,</span>
<span class="line-added">1043                                      unsigned int unicode_stride,</span>
<span class="line-added">1044                                      hb_codepoint_t *first_glyph,</span>
<span class="line-added">1045                                      unsigned int glyph_stride) const</span>
<span class="line-added">1046     {</span>
<span class="line-added">1047       if (unlikely (!this-&gt;get_glyph_funcZ)) return 0;</span>
<span class="line-added">1048 </span>
<span class="line-added">1049       hb_cmap_get_glyph_func_t get_glyph_funcZ = this-&gt;get_glyph_funcZ;</span>
<span class="line-added">1050       const void *get_glyph_data = this-&gt;get_glyph_data;</span>
<span class="line-added">1051 </span>
<span class="line-added">1052       unsigned int done;</span>
<span class="line-added">1053       for (done = 0;</span>
<span class="line-added">1054            done &lt; count &amp;&amp; get_glyph_funcZ (get_glyph_data, *first_unicode, first_glyph);</span>
<span class="line-added">1055            done++)</span>
<span class="line-added">1056       {</span>
<span class="line-added">1057         first_unicode = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_unicode, unicode_stride);</span>
<span class="line-added">1058         first_glyph = &amp;StructAtOffsetUnaligned&lt;hb_codepoint_t&gt; (first_glyph, glyph_stride);</span>
<span class="line-added">1059       }</span>
<span class="line-added">1060       return done;</span>
1061     }
1062 
<span class="line-modified">1063     bool get_variation_glyph (hb_codepoint_t  unicode,</span>
<span class="line-modified">1064                               hb_codepoint_t  variation_selector,</span>
<span class="line-modified">1065                               hb_codepoint_t *glyph) const</span>
1066     {
<span class="line-modified">1067       switch (this-&gt;subtable_uvs-&gt;get_glyph_variant (unicode,</span>
<span class="line-modified">1068                                                      variation_selector,</span>
<span class="line-modified">1069                                                      glyph))</span>
1070       {
<span class="line-modified">1071         case GLYPH_VARIANT_NOT_FOUND:   return false;</span>
<span class="line-modified">1072         case GLYPH_VARIANT_FOUND:       return true;</span>
<span class="line-modified">1073         case GLYPH_VARIANT_USE_DEFAULT: break;</span>
1074       }
1075 
1076       return get_nominal_glyph (unicode, glyph);
1077     }
1078 
<span class="line-modified">1079     void collect_unicodes (hb_set_t *out) const</span>
<span class="line-added">1080     {</span>
<span class="line-added">1081       subtable-&gt;collect_unicodes (out);</span>
<span class="line-added">1082     }</span>
<span class="line-added">1083     void collect_variation_selectors (hb_set_t *out) const</span>
<span class="line-added">1084     {</span>
<span class="line-added">1085       subtable_uvs-&gt;collect_variation_selectors (out);</span>
<span class="line-added">1086     }</span>
<span class="line-added">1087     void collect_variation_unicodes (hb_codepoint_t variation_selector,</span>
<span class="line-added">1088                                      hb_set_t *out) const</span>
1089     {
<span class="line-modified">1090       subtable_uvs-&gt;collect_variation_unicodes (variation_selector, out);</span>
1091     }
1092 
1093     protected:
1094     typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,
1095                                               hb_codepoint_t codepoint,
1096                                               hb_codepoint_t *glyph);







1097 
1098     template &lt;typename Type&gt;
<span class="line-modified">1099     static bool get_glyph_from (const void *obj,</span>
<span class="line-modified">1100                                 hb_codepoint_t codepoint,</span>
<span class="line-modified">1101                                 hb_codepoint_t *glyph)</span>
1102     {
1103       const Type *typed_obj = (const Type *) obj;
1104       return typed_obj-&gt;get_glyph (codepoint, glyph);
1105     }
1106 
1107     template &lt;typename Type&gt;
<span class="line-modified">1108     static bool get_glyph_from_symbol (const void *obj,</span>








1109                                               hb_codepoint_t codepoint,
1110                                               hb_codepoint_t *glyph)
1111     {
1112       const Type *typed_obj = (const Type *) obj;
1113       if (likely (typed_obj-&gt;get_glyph (codepoint, glyph)))
1114         return true;
1115 
1116       if (codepoint &lt;= 0x00FFu)
1117       {
1118         /* For symbol-encoded OpenType fonts, we duplicate the
1119          * U+F000..F0FF range at U+0000..U+00FF.  That&#39;s what
1120          * Windows seems to do, and that&#39;s hinted about at:
1121          * https://docs.microsoft.com/en-us/typography/opentype/spec/recom
1122          * under &quot;Non-Standard (Symbol) Fonts&quot;. */
1123         return typed_obj-&gt;get_glyph (0xF000u + codepoint, glyph);
1124       }
1125 
1126       return false;
1127     }
1128 
1129     private:
<span class="line-modified">1130     hb_nonnull_ptr_t&lt;const CmapSubtable&gt; subtable;</span>
<span class="line-added">1131     hb_nonnull_ptr_t&lt;const CmapSubtableFormat14&gt; subtable_uvs;</span>
<span class="line-added">1132 </span>
<span class="line-added">1133     hb_cmap_get_glyph_func_t get_glyph_funcZ;</span>
1134     const void *get_glyph_data;

1135 
<span class="line-modified">1136     CmapSubtableFormat4::accelerator_t format4_accel;</span>
1137 
<span class="line-modified">1138     hb_blob_ptr_t&lt;cmap&gt; table;</span>

1139   };
1140 
1141   protected:
1142 
<span class="line-modified">1143   const CmapSubtable *find_subtable (unsigned int platform_id,</span>
<span class="line-modified">1144                                      unsigned int encoding_id) const</span>
1145   {
1146     EncodingRecord key;
1147     key.platformID.set (platform_id);
1148     key.encodingID.set (encoding_id);
1149 
<span class="line-modified">1150     const EncodingRecord &amp;result = encodingRecord.bsearch (key);</span>
<span class="line-modified">1151     if (!result.subtable)</span>



1152       return nullptr;
1153 
<span class="line-modified">1154     return &amp;(this+result.subtable);</span>
<span class="line-added">1155   }</span>
<span class="line-added">1156 </span>
<span class="line-added">1157   public:</span>
<span class="line-added">1158 </span>
<span class="line-added">1159   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">1160   {</span>
<span class="line-added">1161     TRACE_SANITIZE (this);</span>
<span class="line-added">1162     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">1163                   likely (version == 0) &amp;&amp;</span>
<span class="line-added">1164                   encodingRecord.sanitize (c, this));</span>
1165   }
1166 
1167   protected:
1168   HBUINT16              version;        /* Table version number (0). */
1169   SortedArrayOf&lt;EncodingRecord&gt;
1170                         encodingRecord; /* Encoding tables. */
1171   public:
1172   DEFINE_SIZE_ARRAY (4, encodingRecord);
1173 };
1174 
<span class="line-added">1175 struct cmap_accelerator_t : cmap::accelerator_t {};</span>
1176 
1177 } /* namespace OT */
1178 
1179 
1180 #endif /* HB_OT_CMAP_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-map.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-cbdt-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-use.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-normalize.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-fallback.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-fallback-private.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
 29 
 30 static unsigned int
 31 recategorize_combining_class (hb_codepoint_t u,
 32                               unsigned int klass)
 33 {
 34   if (klass &gt;= 200)
 35     return klass;
 36 
 37   /* Thai / Lao need some per-character work. */
 38   if ((u &amp; ~0xFF) == 0x0E00u)
 39   {
 40     if (unlikely (klass == 0))
 41     {
 42       switch (u)
 43       {
 44         case 0x0E31u:
 45         case 0x0E34u:
 46         case 0x0E35u:
 47         case 0x0E36u:
 48         case 0x0E37u:
</pre>
<hr />
<pre>
145       return HB_UNICODE_COMBINING_CLASS_ABOVE;
146 
147 
148     /* Tibetan */
149 
150     case HB_MODIFIED_COMBINING_CLASS_CCC129: /* sign aa */
151       return HB_UNICODE_COMBINING_CLASS_BELOW;
152 
153     case HB_MODIFIED_COMBINING_CLASS_CCC130: /* sign i*/
154       return HB_UNICODE_COMBINING_CLASS_ABOVE;
155 
156     case HB_MODIFIED_COMBINING_CLASS_CCC132: /* sign u */
157       return HB_UNICODE_COMBINING_CLASS_BELOW;
158 
159   }
160 
161   return klass;
162 }
163 
164 void
<span class="line-modified">165 _hb_ot_shape_fallback_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">166                                                    hb_font_t *font HB_UNUSED,</span>
<span class="line-modified">167                                                    hb_buffer_t  *buffer)</span>
168 {
169   unsigned int count = buffer-&gt;len;
170   hb_glyph_info_t *info = buffer-&gt;info;
171   for (unsigned int i = 0; i &lt; count; i++)
172     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
173       unsigned int combining_class = _hb_glyph_info_get_modified_combining_class (&amp;info[i]);
174       combining_class = recategorize_combining_class (info[i].codepoint, combining_class);
175       _hb_glyph_info_set_modified_combining_class (&amp;info[i], combining_class);
176     }
177 }
178 
179 
180 static void
181 zero_mark_advances (hb_buffer_t *buffer,
182                     unsigned int start,
<span class="line-modified">183                     unsigned int end)</span>

184 {
185   hb_glyph_info_t *info = buffer-&gt;info;
186   for (unsigned int i = start; i &lt; end; i++)
187     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
188     {





189       buffer-&gt;pos[i].x_advance = 0;
190       buffer-&gt;pos[i].y_advance = 0;
191     }
192 }
193 
194 static inline void
<span class="line-modified">195 position_mark (const hb_ot_shape_plan_t *plan,</span>
196                hb_font_t *font,
197                hb_buffer_t  *buffer,
198                hb_glyph_extents_t &amp;base_extents,
199                unsigned int i,
200                unsigned int combining_class)
201 {
202   hb_glyph_extents_t mark_extents;
203   if (!font-&gt;get_glyph_extents (buffer-&gt;info[i].codepoint, &amp;mark_extents))
204     return;
205 
206   hb_position_t y_gap = font-&gt;y_scale / 16;
207 
208   hb_glyph_position_t &amp;pos = buffer-&gt;pos[i];
209   pos.x_offset = pos.y_offset = 0;
210 
211 
212   /* We don&#39;t position LEFT and RIGHT marks. */
213 
214   /* X positioning */
215   switch (combining_class)
</pre>
<hr />
<pre>
286       pos.y_offset = base_extents.y_bearing - (mark_extents.y_bearing + mark_extents.height);
287       /* Don&#39;t shift down &quot;above&quot; marks too much. */
288       if ((y_gap &gt; 0) != (pos.y_offset &gt; 0))
289       {
290         unsigned int correction = -pos.y_offset / 2;
291         base_extents.y_bearing += correction;
292         base_extents.height -= correction;
293         pos.y_offset += correction;
294       }
295       base_extents.y_bearing -= mark_extents.height;
296       base_extents.height += mark_extents.height;
297       break;
298   }
299 }
300 
301 static inline void
302 position_around_base (const hb_ot_shape_plan_t *plan,
303                       hb_font_t *font,
304                       hb_buffer_t  *buffer,
305                       unsigned int base,
<span class="line-modified">306                       unsigned int end)</span>

307 {
308   hb_direction_t horiz_dir = HB_DIRECTION_INVALID;
309 
310   buffer-&gt;unsafe_to_break (base, end);
311 
312   hb_glyph_extents_t base_extents;
313   if (!font-&gt;get_glyph_extents (buffer-&gt;info[base].codepoint,
314                                 &amp;base_extents))
315   {
316     /* If extents don&#39;t work, zero marks and go home. */
<span class="line-modified">317     zero_mark_advances (buffer, base + 1, end);</span>
318     return;
319   }
<span class="line-removed">320   base_extents.x_bearing += buffer-&gt;pos[base].x_offset;</span>
321   base_extents.y_bearing += buffer-&gt;pos[base].y_offset;





322 
323   unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[base]);
324   /* Use integer for num_lig_components such that it doesn&#39;t convert to unsigned
325    * when we divide or multiply by it. */
326   int num_lig_components = _hb_glyph_info_get_lig_num_comps (&amp;buffer-&gt;info[base]);
327 
328   hb_position_t x_offset = 0, y_offset = 0;
329   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
330     x_offset -= buffer-&gt;pos[base].x_advance;
331     y_offset -= buffer-&gt;pos[base].y_advance;
332   }
333 
334   hb_glyph_extents_t component_extents = base_extents;
335   int last_lig_component = -1;
336   unsigned int last_combining_class = 255;
337   hb_glyph_extents_t cluster_extents = base_extents; /* Initialization is just to shut gcc up. */
338   hb_glyph_info_t *info = buffer-&gt;info;
339   for (unsigned int i = base + 1; i &lt; end; i++)
340     if (_hb_glyph_info_get_modified_combining_class (&amp;info[i]))
341     {
</pre>
<hr />
<pre>
377       buffer-&gt;pos[i].y_advance = 0;
378       buffer-&gt;pos[i].x_offset += x_offset;
379       buffer-&gt;pos[i].y_offset += y_offset;
380 
381     } else {
382       if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
383         x_offset -= buffer-&gt;pos[i].x_advance;
384         y_offset -= buffer-&gt;pos[i].y_advance;
385       } else {
386         x_offset += buffer-&gt;pos[i].x_advance;
387         y_offset += buffer-&gt;pos[i].y_advance;
388       }
389     }
390 }
391 
392 static inline void
393 position_cluster (const hb_ot_shape_plan_t *plan,
394                   hb_font_t *font,
395                   hb_buffer_t  *buffer,
396                   unsigned int start,
<span class="line-modified">397                   unsigned int end)</span>

398 {
399   if (end - start &lt; 2)
400     return;
401 
402   /* Find the base glyph */
403   hb_glyph_info_t *info = buffer-&gt;info;
404   for (unsigned int i = start; i &lt; end; i++)
405     if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))
406     {
407       /* Find mark glyphs */
408       unsigned int j;
409       for (j = i + 1; j &lt; end; j++)
410         if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[j])))
411           break;
412 
<span class="line-modified">413       position_around_base (plan, font, buffer, i, j);</span>
414 
415       i = j - 1;
416     }
417 }
418 
419 void
<span class="line-modified">420 _hb_ot_shape_fallback_position (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">421                                 hb_font_t *font,</span>
<span class="line-modified">422                                 hb_buffer_t  *buffer)</span>

423 {
424   _hb_buffer_assert_gsubgpos_vars (buffer);
425 
426   unsigned int start = 0;
427   unsigned int count = buffer-&gt;len;
428   hb_glyph_info_t *info = buffer-&gt;info;
429   for (unsigned int i = 1; i &lt; count; i++)
430     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))) {
<span class="line-modified">431       position_cluster (plan, font, buffer, start, i);</span>
432       start = i;
433     }
<span class="line-modified">434   position_cluster (plan, font, buffer, start, count);</span>
435 }
436 
437 
<span class="line-modified">438 /* Performs old-style TrueType kerning. */</span>



















439 void
440 _hb_ot_shape_fallback_kern (const hb_ot_shape_plan_t *plan,
441                             hb_font_t *font,
<span class="line-modified">442                             hb_buffer_t  *buffer)</span>
443 {
<span class="line-modified">444   if (!plan-&gt;has_kern) return;</span>
<span class="line-modified">445 </span>
<span class="line-modified">446   OT::hb_ot_apply_context_t c (1, font, buffer);</span>
<span class="line-modified">447   c.set_lookup_mask (plan-&gt;kern_mask);</span>
<span class="line-removed">448   c.set_lookup_props (OT::LookupFlag::IgnoreMarks);</span>
<span class="line-removed">449   OT::hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c.iter_input;</span>
<span class="line-removed">450   skippy_iter.init (&amp;c);</span>
<span class="line-removed">451 </span>
<span class="line-removed">452   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">453   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">454   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-removed">455   for (unsigned int idx = 0; idx &lt; count;)</span>
<span class="line-removed">456   {</span>
<span class="line-removed">457     skippy_iter.reset (idx, 1);</span>
<span class="line-removed">458     if (!skippy_iter.next ())</span>
<span class="line-removed">459     {</span>
<span class="line-removed">460       idx++;</span>
<span class="line-removed">461       continue;</span>
<span class="line-removed">462     }</span>
463 
<span class="line-modified">464     hb_position_t x_kern, y_kern;</span>
<span class="line-removed">465     font-&gt;get_glyph_kerning_for_direction (info[idx].codepoint,</span>
<span class="line-removed">466                                            info[skippy_iter.idx].codepoint,</span>
<span class="line-removed">467                                            buffer-&gt;props.direction,</span>
<span class="line-removed">468                                            &amp;x_kern, &amp;y_kern);</span>
469 
<span class="line-modified">470     if (x_kern)</span>
<span class="line-modified">471     {</span>
<span class="line-removed">472       hb_position_t kern1 = x_kern &gt;&gt; 1;</span>
<span class="line-removed">473       hb_position_t kern2 = x_kern - kern1;</span>
<span class="line-removed">474       pos[idx].x_advance += kern1;</span>
<span class="line-removed">475       pos[skippy_iter.idx].x_advance += kern2;</span>
<span class="line-removed">476       pos[skippy_iter.idx].x_offset += kern2;</span>
<span class="line-removed">477       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);</span>
<span class="line-removed">478     }</span>
479 
<span class="line-modified">480     if (y_kern)</span>
<span class="line-modified">481     {</span>
<span class="line-modified">482       hb_position_t kern1 = y_kern &gt;&gt; 1;</span>
<span class="line-removed">483       hb_position_t kern2 = y_kern - kern1;</span>
<span class="line-removed">484       pos[idx].y_advance += kern1;</span>
<span class="line-removed">485       pos[skippy_iter.idx].y_advance += kern2;</span>
<span class="line-removed">486       pos[skippy_iter.idx].y_offset += kern2;</span>
<span class="line-removed">487       buffer-&gt;unsafe_to_break (idx, skippy_iter.idx + 1);</span>
<span class="line-removed">488     }</span>
489 
<span class="line-modified">490     idx = skippy_iter.idx;</span>
<span class="line-modified">491   }</span>
492 }
493 
494 
495 /* Adjusts width of various spaces. */
496 void
<span class="line-modified">497 _hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan,</span>
498                               hb_font_t *font,
499                               hb_buffer_t  *buffer)
500 {
<span class="line-removed">501   if (!HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))</span>
<span class="line-removed">502     return;</span>
<span class="line-removed">503 </span>
504   hb_glyph_info_t *info = buffer-&gt;info;
505   hb_glyph_position_t *pos = buffer-&gt;pos;

506   unsigned int count = buffer-&gt;len;
507   for (unsigned int i = 0; i &lt; count; i++)
508     if (_hb_glyph_info_is_unicode_space (&amp;info[i]) &amp;&amp; !_hb_glyph_info_ligated (&amp;info[i]))
509     {
510       hb_unicode_funcs_t::space_t space_type = _hb_glyph_info_get_unicode_space_fallback_type (&amp;info[i]);
511       hb_codepoint_t glyph;
512       typedef hb_unicode_funcs_t t;
513       switch (space_type)
514       {
515         case t::NOT_SPACE: /* Shouldn&#39;t happen. */
516         case t::SPACE:
517           break;
518 
519         case t::SPACE_EM:
520         case t::SPACE_EM_2:
521         case t::SPACE_EM_3:
522         case t::SPACE_EM_4:
523         case t::SPACE_EM_5:
524         case t::SPACE_EM_6:
525         case t::SPACE_EM_16:
<span class="line-modified">526           pos[i].x_advance = (font-&gt;x_scale + ((int) space_type)/2) / (int) space_type;</span>



527           break;
528 
529         case t::SPACE_4_EM_18:
<span class="line-modified">530           pos[i].x_advance = (int64_t) font-&gt;x_scale * 4 / 18;</span>



531           break;
532 
533         case t::SPACE_FIGURE:
534           for (char u = &#39;0&#39;; u &lt;= &#39;9&#39;; u++)
535             if (font-&gt;get_nominal_glyph (u, &amp;glyph))
536             {
<span class="line-modified">537               pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>



538               break;
539             }
540           break;
541 
542         case t::SPACE_PUNCTUATION:
<span class="line-modified">543           if (font-&gt;get_nominal_glyph (&#39;.&#39;, &amp;glyph))</span>
<span class="line-modified">544             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="line-modified">545           else if (font-&gt;get_nominal_glyph (&#39;,&#39;, &amp;glyph))</span>
<span class="line-modified">546             pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>




547           break;
548 
549         case t::SPACE_NARROW:
550           /* Half-space?
551            * Unicode doc https://unicode.org/charts/PDF/U2000.pdf says ~1/4 or 1/5 of EM.
552            * However, in my testing, many fonts have their regular space being about that
553            * size.  To me, a percentage of the space width makes more sense.  Half is as
554            * good as any. */
<span class="line-modified">555           pos[i].x_advance /= 2;</span>



556           break;
557       }
558     }
559 }
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-fallback.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-kern.hh&quot;</span>
 29 
 30 static unsigned int
 31 recategorize_combining_class (hb_codepoint_t u,
 32                               unsigned int klass)
 33 {
 34   if (klass &gt;= 200)
 35     return klass;
 36 
 37   /* Thai / Lao need some per-character work. */
 38   if ((u &amp; ~0xFF) == 0x0E00u)
 39   {
 40     if (unlikely (klass == 0))
 41     {
 42       switch (u)
 43       {
 44         case 0x0E31u:
 45         case 0x0E34u:
 46         case 0x0E35u:
 47         case 0x0E36u:
 48         case 0x0E37u:
</pre>
<hr />
<pre>
145       return HB_UNICODE_COMBINING_CLASS_ABOVE;
146 
147 
148     /* Tibetan */
149 
150     case HB_MODIFIED_COMBINING_CLASS_CCC129: /* sign aa */
151       return HB_UNICODE_COMBINING_CLASS_BELOW;
152 
153     case HB_MODIFIED_COMBINING_CLASS_CCC130: /* sign i*/
154       return HB_UNICODE_COMBINING_CLASS_ABOVE;
155 
156     case HB_MODIFIED_COMBINING_CLASS_CCC132: /* sign u */
157       return HB_UNICODE_COMBINING_CLASS_BELOW;
158 
159   }
160 
161   return klass;
162 }
163 
164 void
<span class="line-modified">165 _hb_ot_shape_fallback_mark_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">166                                                         hb_font_t *font HB_UNUSED,</span>
<span class="line-modified">167                                                         hb_buffer_t  *buffer)</span>
168 {
169   unsigned int count = buffer-&gt;len;
170   hb_glyph_info_t *info = buffer-&gt;info;
171   for (unsigned int i = 0; i &lt; count; i++)
172     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {
173       unsigned int combining_class = _hb_glyph_info_get_modified_combining_class (&amp;info[i]);
174       combining_class = recategorize_combining_class (info[i].codepoint, combining_class);
175       _hb_glyph_info_set_modified_combining_class (&amp;info[i], combining_class);
176     }
177 }
178 
179 
180 static void
181 zero_mark_advances (hb_buffer_t *buffer,
182                     unsigned int start,
<span class="line-modified">183                     unsigned int end,</span>
<span class="line-added">184                     bool adjust_offsets_when_zeroing)</span>
185 {
186   hb_glyph_info_t *info = buffer-&gt;info;
187   for (unsigned int i = start; i &lt; end; i++)
188     if (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)
189     {
<span class="line-added">190       if (adjust_offsets_when_zeroing)</span>
<span class="line-added">191       {</span>
<span class="line-added">192         buffer-&gt;pos[i].x_offset -= buffer-&gt;pos[i].x_advance;</span>
<span class="line-added">193         buffer-&gt;pos[i].y_offset -= buffer-&gt;pos[i].y_advance;</span>
<span class="line-added">194       }</span>
195       buffer-&gt;pos[i].x_advance = 0;
196       buffer-&gt;pos[i].y_advance = 0;
197     }
198 }
199 
200 static inline void
<span class="line-modified">201 position_mark (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
202                hb_font_t *font,
203                hb_buffer_t  *buffer,
204                hb_glyph_extents_t &amp;base_extents,
205                unsigned int i,
206                unsigned int combining_class)
207 {
208   hb_glyph_extents_t mark_extents;
209   if (!font-&gt;get_glyph_extents (buffer-&gt;info[i].codepoint, &amp;mark_extents))
210     return;
211 
212   hb_position_t y_gap = font-&gt;y_scale / 16;
213 
214   hb_glyph_position_t &amp;pos = buffer-&gt;pos[i];
215   pos.x_offset = pos.y_offset = 0;
216 
217 
218   /* We don&#39;t position LEFT and RIGHT marks. */
219 
220   /* X positioning */
221   switch (combining_class)
</pre>
<hr />
<pre>
292       pos.y_offset = base_extents.y_bearing - (mark_extents.y_bearing + mark_extents.height);
293       /* Don&#39;t shift down &quot;above&quot; marks too much. */
294       if ((y_gap &gt; 0) != (pos.y_offset &gt; 0))
295       {
296         unsigned int correction = -pos.y_offset / 2;
297         base_extents.y_bearing += correction;
298         base_extents.height -= correction;
299         pos.y_offset += correction;
300       }
301       base_extents.y_bearing -= mark_extents.height;
302       base_extents.height += mark_extents.height;
303       break;
304   }
305 }
306 
307 static inline void
308 position_around_base (const hb_ot_shape_plan_t *plan,
309                       hb_font_t *font,
310                       hb_buffer_t  *buffer,
311                       unsigned int base,
<span class="line-modified">312                       unsigned int end,</span>
<span class="line-added">313                       bool adjust_offsets_when_zeroing)</span>
314 {
315   hb_direction_t horiz_dir = HB_DIRECTION_INVALID;
316 
317   buffer-&gt;unsafe_to_break (base, end);
318 
319   hb_glyph_extents_t base_extents;
320   if (!font-&gt;get_glyph_extents (buffer-&gt;info[base].codepoint,
321                                 &amp;base_extents))
322   {
323     /* If extents don&#39;t work, zero marks and go home. */
<span class="line-modified">324     zero_mark_advances (buffer, base + 1, end, adjust_offsets_when_zeroing);</span>
325     return;
326   }

327   base_extents.y_bearing += buffer-&gt;pos[base].y_offset;
<span class="line-added">328   /* Use horizontal advance for horizontal positioning.</span>
<span class="line-added">329    * Generally a better idea.  Also works for zero-ink glyphs.  See:</span>
<span class="line-added">330    * https://github.com/harfbuzz/harfbuzz/issues/1532 */</span>
<span class="line-added">331   base_extents.x_bearing = 0;</span>
<span class="line-added">332   base_extents.width = font-&gt;get_glyph_h_advance (buffer-&gt;info[base].codepoint);</span>
333 
334   unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[base]);
335   /* Use integer for num_lig_components such that it doesn&#39;t convert to unsigned
336    * when we divide or multiply by it. */
337   int num_lig_components = _hb_glyph_info_get_lig_num_comps (&amp;buffer-&gt;info[base]);
338 
339   hb_position_t x_offset = 0, y_offset = 0;
340   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
341     x_offset -= buffer-&gt;pos[base].x_advance;
342     y_offset -= buffer-&gt;pos[base].y_advance;
343   }
344 
345   hb_glyph_extents_t component_extents = base_extents;
346   int last_lig_component = -1;
347   unsigned int last_combining_class = 255;
348   hb_glyph_extents_t cluster_extents = base_extents; /* Initialization is just to shut gcc up. */
349   hb_glyph_info_t *info = buffer-&gt;info;
350   for (unsigned int i = base + 1; i &lt; end; i++)
351     if (_hb_glyph_info_get_modified_combining_class (&amp;info[i]))
352     {
</pre>
<hr />
<pre>
388       buffer-&gt;pos[i].y_advance = 0;
389       buffer-&gt;pos[i].x_offset += x_offset;
390       buffer-&gt;pos[i].y_offset += y_offset;
391 
392     } else {
393       if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction)) {
394         x_offset -= buffer-&gt;pos[i].x_advance;
395         y_offset -= buffer-&gt;pos[i].y_advance;
396       } else {
397         x_offset += buffer-&gt;pos[i].x_advance;
398         y_offset += buffer-&gt;pos[i].y_advance;
399       }
400     }
401 }
402 
403 static inline void
404 position_cluster (const hb_ot_shape_plan_t *plan,
405                   hb_font_t *font,
406                   hb_buffer_t  *buffer,
407                   unsigned int start,
<span class="line-modified">408                   unsigned int end,</span>
<span class="line-added">409                   bool adjust_offsets_when_zeroing)</span>
410 {
411   if (end - start &lt; 2)
412     return;
413 
414   /* Find the base glyph */
415   hb_glyph_info_t *info = buffer-&gt;info;
416   for (unsigned int i = start; i &lt; end; i++)
417     if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))
418     {
419       /* Find mark glyphs */
420       unsigned int j;
421       for (j = i + 1; j &lt; end; j++)
422         if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[j])))
423           break;
424 
<span class="line-modified">425       position_around_base (plan, font, buffer, i, j, adjust_offsets_when_zeroing);</span>
426 
427       i = j - 1;
428     }
429 }
430 
431 void
<span class="line-modified">432 _hb_ot_shape_fallback_mark_position (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">433                                      hb_font_t *font,</span>
<span class="line-modified">434                                      hb_buffer_t  *buffer,</span>
<span class="line-added">435                                      bool adjust_offsets_when_zeroing)</span>
436 {
437   _hb_buffer_assert_gsubgpos_vars (buffer);
438 
439   unsigned int start = 0;
440   unsigned int count = buffer-&gt;len;
441   hb_glyph_info_t *info = buffer-&gt;info;
442   for (unsigned int i = 1; i &lt; count; i++)
443     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])))) {
<span class="line-modified">444       position_cluster (plan, font, buffer, start, i, adjust_offsets_when_zeroing);</span>
445       start = i;
446     }
<span class="line-modified">447   position_cluster (plan, font, buffer, start, count, adjust_offsets_when_zeroing);</span>
448 }
449 
450 
<span class="line-modified">451 struct hb_ot_shape_fallback_kern_driver_t</span>
<span class="line-added">452 {</span>
<span class="line-added">453   hb_ot_shape_fallback_kern_driver_t (hb_font_t   *font_,</span>
<span class="line-added">454                                       hb_buffer_t *buffer) :</span>
<span class="line-added">455     font (font_), direction (buffer-&gt;props.direction) {}</span>
<span class="line-added">456 </span>
<span class="line-added">457   hb_position_t get_kerning (hb_codepoint_t first, hb_codepoint_t second) const</span>
<span class="line-added">458   {</span>
<span class="line-added">459     hb_position_t kern = 0;</span>
<span class="line-added">460     font-&gt;get_glyph_kerning_for_direction (first, second,</span>
<span class="line-added">461                                            direction,</span>
<span class="line-added">462                                            &amp;kern, &amp;kern);</span>
<span class="line-added">463     return kern;</span>
<span class="line-added">464   }</span>
<span class="line-added">465 </span>
<span class="line-added">466   hb_font_t *font;</span>
<span class="line-added">467   hb_direction_t direction;</span>
<span class="line-added">468 };</span>
<span class="line-added">469 </span>
<span class="line-added">470 /* Performs font-assisted kerning. */</span>
471 void
472 _hb_ot_shape_fallback_kern (const hb_ot_shape_plan_t *plan,
473                             hb_font_t *font,
<span class="line-modified">474                             hb_buffer_t *buffer)</span>
475 {
<span class="line-modified">476   if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction) ?</span>
<span class="line-modified">477       !font-&gt;has_glyph_h_kerning_func () :</span>
<span class="line-modified">478       !font-&gt;has_glyph_v_kerning_func ())</span>
<span class="line-modified">479     return;</span>















480 
<span class="line-modified">481   bool reverse = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);</span>




482 
<span class="line-modified">483   if (reverse)</span>
<span class="line-modified">484     buffer-&gt;reverse ();</span>







485 
<span class="line-modified">486   hb_ot_shape_fallback_kern_driver_t driver (font, buffer);</span>
<span class="line-modified">487   OT::hb_kern_machine_t&lt;hb_ot_shape_fallback_kern_driver_t&gt; machine (driver);</span>
<span class="line-modified">488   machine.kern (font, buffer, plan-&gt;kern_mask, false);</span>






489 
<span class="line-modified">490   if (reverse)</span>
<span class="line-modified">491     buffer-&gt;reverse ();</span>
492 }
493 
494 
495 /* Adjusts width of various spaces. */
496 void
<span class="line-modified">497 _hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
498                               hb_font_t *font,
499                               hb_buffer_t  *buffer)
500 {



501   hb_glyph_info_t *info = buffer-&gt;info;
502   hb_glyph_position_t *pos = buffer-&gt;pos;
<span class="line-added">503   bool horizontal = HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction);</span>
504   unsigned int count = buffer-&gt;len;
505   for (unsigned int i = 0; i &lt; count; i++)
506     if (_hb_glyph_info_is_unicode_space (&amp;info[i]) &amp;&amp; !_hb_glyph_info_ligated (&amp;info[i]))
507     {
508       hb_unicode_funcs_t::space_t space_type = _hb_glyph_info_get_unicode_space_fallback_type (&amp;info[i]);
509       hb_codepoint_t glyph;
510       typedef hb_unicode_funcs_t t;
511       switch (space_type)
512       {
513         case t::NOT_SPACE: /* Shouldn&#39;t happen. */
514         case t::SPACE:
515           break;
516 
517         case t::SPACE_EM:
518         case t::SPACE_EM_2:
519         case t::SPACE_EM_3:
520         case t::SPACE_EM_4:
521         case t::SPACE_EM_5:
522         case t::SPACE_EM_6:
523         case t::SPACE_EM_16:
<span class="line-modified">524           if (horizontal)</span>
<span class="line-added">525             pos[i].x_advance = +(font-&gt;x_scale + ((int) space_type)/2) / (int) space_type;</span>
<span class="line-added">526           else</span>
<span class="line-added">527             pos[i].y_advance = -(font-&gt;y_scale + ((int) space_type)/2) / (int) space_type;</span>
528           break;
529 
530         case t::SPACE_4_EM_18:
<span class="line-modified">531           if (horizontal)</span>
<span class="line-added">532             pos[i].x_advance = (int64_t) +font-&gt;x_scale * 4 / 18;</span>
<span class="line-added">533           else</span>
<span class="line-added">534             pos[i].y_advance = (int64_t) -font-&gt;y_scale * 4 / 18;</span>
535           break;
536 
537         case t::SPACE_FIGURE:
538           for (char u = &#39;0&#39;; u &lt;= &#39;9&#39;; u++)
539             if (font-&gt;get_nominal_glyph (u, &amp;glyph))
540             {
<span class="line-modified">541               if (horizontal)</span>
<span class="line-added">542                 pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="line-added">543               else</span>
<span class="line-added">544                 pos[i].y_advance = font-&gt;get_glyph_v_advance (glyph);</span>
545               break;
546             }
547           break;
548 
549         case t::SPACE_PUNCTUATION:
<span class="line-modified">550           if (font-&gt;get_nominal_glyph (&#39;.&#39;, &amp;glyph) ||</span>
<span class="line-modified">551               font-&gt;get_nominal_glyph (&#39;,&#39;, &amp;glyph))</span>
<span class="line-modified">552           {</span>
<span class="line-modified">553             if (horizontal)</span>
<span class="line-added">554               pos[i].x_advance = font-&gt;get_glyph_h_advance (glyph);</span>
<span class="line-added">555             else</span>
<span class="line-added">556               pos[i].y_advance = font-&gt;get_glyph_v_advance (glyph);</span>
<span class="line-added">557           }</span>
558           break;
559 
560         case t::SPACE_NARROW:
561           /* Half-space?
562            * Unicode doc https://unicode.org/charts/PDF/U2000.pdf says ~1/4 or 1/5 of EM.
563            * However, in my testing, many fonts have their regular space being about that
564            * size.  To me, a percentage of the space width makes more sense.  Half is as
565            * good as any. */
<span class="line-modified">566           if (horizontal)</span>
<span class="line-added">567             pos[i].x_advance /= 2;</span>
<span class="line-added">568           else</span>
<span class="line-added">569             pos[i].y_advance /= 2;</span>
570           break;
571       }
572     }
573 }
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-use.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-normalize.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
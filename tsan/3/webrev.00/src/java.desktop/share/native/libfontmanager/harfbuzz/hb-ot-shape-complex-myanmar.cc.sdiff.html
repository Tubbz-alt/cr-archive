<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-myanmar-machine.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-thai.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-myanmar.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-myanmar-private.hh&quot;</span>
 28 
 29 
 30 /*
 31  * Myanmar shaper.
 32  */
 33 
 34 static const hb_tag_t
 35 basic_features[] =
 36 {
 37   /*
 38    * Basic features.
<span class="line-modified"> 39    * These features are applied in order, one at a time, after initial_reordering.</span>
 40    */
 41   HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),
 42   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),
 43   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),
 44   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),
 45 };
 46 static const hb_tag_t
 47 other_features[] =
 48 {
 49   /*
 50    * Other features.
<span class="line-modified"> 51    * These features are applied all at once, after final_reordering.</span>
 52    */
 53   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;),
 54   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;),
 55   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;),
 56   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;),
<span class="line-modified"> 57   /* Positioning features, though we don&#39;t care about the types. */</span>







 58   HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;),
 59   /* Pre-release version of Windows 8 Myanmar font had abvm,blwm
 60    * features.  The released Windows 8 version of the font (as well
 61    * as the released spec) used &#39;mark&#39; instead.  The Windows 8
 62    * shaper however didn&#39;t apply &#39;mark&#39; but did apply &#39;mkmk&#39;.
 63    * Perhaps it applied abvm/blwm.  This was fixed in a Windows 8
 64    * update, so now it applies mark/mkmk.  We are guessing that
 65    * it still applies abvm/blwm too.
 66    */
 67   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;),
 68   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;),
 69 };
 70 
 71 static void
 72 setup_syllables (const hb_ot_shape_plan_t *plan,
 73                  hb_font_t *font,
 74                  hb_buffer_t *buffer);
 75 static void
<span class="line-modified"> 76 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 77                     hb_font_t *font,</span>
<span class="line-modified"> 78                     hb_buffer_t *buffer);</span>
 79 static void
<span class="line-modified"> 80 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 81                   hb_font_t *font,</span>
<span class="line-modified"> 82                   hb_buffer_t *buffer);</span>
 83 
 84 static void
 85 collect_features_myanmar (hb_ot_shape_planner_t *plan)
 86 {
 87   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 88 
 89   /* Do this before any lookups have been applied. */
 90   map-&gt;add_gsub_pause (setup_syllables);
 91 
<span class="line-modified"> 92   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
 93   /* The Indic specs do not require ccmp, but we apply it here since if
 94    * there is a use of it, it&#39;s typically at the beginning. */
<span class="line-modified"> 95   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>

 96 

 97 
<span class="line-removed"> 98   map-&gt;add_gsub_pause (initial_reordering);</span>
 99   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (basic_features); i++)
100   {
<span class="line-modified">101     map-&gt;add_feature (basic_features[i], 1, F_GLOBAL | F_MANUAL_ZWJ);</span>
102     map-&gt;add_gsub_pause (nullptr);
103   }
<span class="line-modified">104   map-&gt;add_gsub_pause (final_reordering);</span>


105   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (other_features); i++)
<span class="line-modified">106     map-&gt;add_feature (other_features[i], 1, F_GLOBAL | F_MANUAL_ZWJ);</span>



107 }
108 
109 static void
110 override_features_myanmar (hb_ot_shape_planner_t *plan)
111 {
<span class="line-modified">112   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
113 }
114 
115 
116 enum syllable_type_t {
117   consonant_syllable,
118   punctuation_cluster,
119   broken_cluster,
120   non_myanmar_cluster,
121 };
122 
123 #include &quot;hb-ot-shape-complex-myanmar-machine.hh&quot;
124 
125 
126 static void
127 setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,
128                    hb_buffer_t              *buffer,
129                    hb_font_t                *font HB_UNUSED)
130 {
131   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);
132   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);
</pre>
<hr />
<pre>
244       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() == OT_VBlw)
245       {
246         info[i].myanmar_position() = pos;
247         continue;
248       }
249       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() != OT_A)
250       {
251         pos = POS_AFTER_SUB;
252         info[i].myanmar_position() = pos;
253         continue;
254       }
255       info[i].myanmar_position() = pos;
256     }
257   }
258 
259   /* Sit tight, rock &#39;n roll! */
260   buffer-&gt;sort (start, end, compare_myanmar_order);
261 }
262 
263 static void
<span class="line-modified">264 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">265                              hb_face_t *face,</span>
266                              hb_buffer_t *buffer,
267                              unsigned int start, unsigned int end)
268 {
269   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
270   switch (syllable_type) {
271 
272     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
273     case consonant_syllable:
274       initial_reordering_consonant_syllable  (buffer, start, end);
275       break;
276 
277     case punctuation_cluster:
278     case non_myanmar_cluster:
279       break;
280   }
281 }
282 
283 static inline void
284 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
285                        hb_font_t *font,
</pre>
<hr />
<pre>
313   buffer-&gt;idx = 0;
314   unsigned int last_syllable = 0;
315   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
316   {
317     unsigned int syllable = buffer-&gt;cur().syllable();
318     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
319     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
320     {
321       last_syllable = syllable;
322 
323       hb_glyph_info_t ginfo = dottedcircle;
324       ginfo.cluster = buffer-&gt;cur().cluster;
325       ginfo.mask = buffer-&gt;cur().mask;
326       ginfo.syllable() = buffer-&gt;cur().syllable();
327 
328       buffer-&gt;output_info (ginfo);
329     }
330     else
331       buffer-&gt;next_glyph ();
332   }
<span class="line-removed">333 </span>
334   buffer-&gt;swap_buffers ();
335 }
336 
337 static void
<span class="line-modified">338 initial_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">339                     hb_font_t *font,</span>
<span class="line-modified">340                     hb_buffer_t *buffer)</span>
341 {
342   insert_dotted_circles (plan, font, buffer);
343 
344   foreach_syllable (buffer, start, end)
345     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);



346 }
347 
348 static void
<span class="line-modified">349 final_reordering (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">350                   hb_font_t *font HB_UNUSED,</span>
<span class="line-modified">351                   hb_buffer_t *buffer)</span>
352 {
353   hb_glyph_info_t *info = buffer-&gt;info;
354   unsigned int count = buffer-&gt;len;
<span class="line-removed">355 </span>
<span class="line-removed">356   /* Zero syllables now... */</span>
357   for (unsigned int i = 0; i &lt; count; i++)
358     info[i].syllable() = 0;
<span class="line-removed">359 </span>
<span class="line-removed">360   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);</span>
<span class="line-removed">361   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);</span>
362 }
363 
364 
<span class="line-modified">365 /* Uniscribe seems to have a shaper for &#39;mymr&#39; that is like the</span>
<span class="line-removed">366  * generic shaper, except that it zeros mark advances GDEF_LATE. */</span>
<span class="line-removed">367 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar_old =</span>
368 {
<span class="line-modified">369   nullptr, /* collect_features */</span>
<span class="line-modified">370   nullptr, /* override_features */</span>
371   nullptr, /* data_create */
372   nullptr, /* data_destroy */
373   nullptr, /* preprocess_text */
374   nullptr, /* postprocess_glyphs */
<span class="line-modified">375   HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,</span>
376   nullptr, /* decompose */
377   nullptr, /* compose */
<span class="line-modified">378   nullptr, /* setup_masks */</span>
<span class="line-modified">379   nullptr, /* disable_otl */</span>
380   nullptr, /* reorder_marks */
<span class="line-modified">381   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,</span>
<span class="line-modified">382   true, /* fallback_position */</span>
383 };
384 
<span class="line-modified">385 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar =</span>




386 {
<span class="line-modified">387   collect_features_myanmar,</span>
<span class="line-modified">388   override_features_myanmar,</span>
389   nullptr, /* data_create */
390   nullptr, /* data_destroy */
391   nullptr, /* preprocess_text */
392   nullptr, /* postprocess_glyphs */
<span class="line-modified">393   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,</span>
394   nullptr, /* decompose */
395   nullptr, /* compose */
<span class="line-modified">396   setup_masks_myanmar,</span>
<span class="line-modified">397   nullptr, /* disable_otl */</span>
398   nullptr, /* reorder_marks */
<span class="line-modified">399   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,</span>
400   false, /* fallback_position */
401 };
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-myanmar.hh&quot;</span>
 28 
 29 
 30 /*
 31  * Myanmar shaper.
 32  */
 33 
 34 static const hb_tag_t
 35 basic_features[] =
 36 {
 37   /*
 38    * Basic features.
<span class="line-modified"> 39    * These features are applied in order, one at a time, after reordering.</span>
 40    */
 41   HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),
 42   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),
 43   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),
 44   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),
 45 };
 46 static const hb_tag_t
 47 other_features[] =
 48 {
 49   /*
 50    * Other features.
<span class="line-modified"> 51    * These features are applied all at once, after clearing syllables.</span>
 52    */
 53   HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;),
 54   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;),
 55   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;),
 56   HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;),
<span class="line-modified"> 57 };</span>
<span class="line-added"> 58 static const hb_tag_t</span>
<span class="line-added"> 59 positioning_features[] =</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61   /*</span>
<span class="line-added"> 62    * Positioning features.</span>
<span class="line-added"> 63    * We don&#39;t care about the types.</span>
<span class="line-added"> 64    */</span>
 65   HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;),
 66   /* Pre-release version of Windows 8 Myanmar font had abvm,blwm
 67    * features.  The released Windows 8 version of the font (as well
 68    * as the released spec) used &#39;mark&#39; instead.  The Windows 8
 69    * shaper however didn&#39;t apply &#39;mark&#39; but did apply &#39;mkmk&#39;.
 70    * Perhaps it applied abvm/blwm.  This was fixed in a Windows 8
 71    * update, so now it applies mark/mkmk.  We are guessing that
 72    * it still applies abvm/blwm too.
 73    */
 74   HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;),
 75   HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;),
 76 };
 77 
 78 static void
 79 setup_syllables (const hb_ot_shape_plan_t *plan,
 80                  hb_font_t *font,
 81                  hb_buffer_t *buffer);
 82 static void
<span class="line-modified"> 83 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 84          hb_font_t *font,</span>
<span class="line-modified"> 85          hb_buffer_t *buffer);</span>
 86 static void
<span class="line-modified"> 87 clear_syllables (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 88                  hb_font_t *font,</span>
<span class="line-modified"> 89                  hb_buffer_t *buffer);</span>
 90 
 91 static void
 92 collect_features_myanmar (hb_ot_shape_planner_t *plan)
 93 {
 94   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 95 
 96   /* Do this before any lookups have been applied. */
 97   map-&gt;add_gsub_pause (setup_syllables);
 98 
<span class="line-modified"> 99   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
100   /* The Indic specs do not require ccmp, but we apply it here since if
101    * there is a use of it, it&#39;s typically at the beginning. */
<span class="line-modified">102   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="line-added">103 </span>
104 
<span class="line-added">105   map-&gt;add_gsub_pause (reorder);</span>
106 

107   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (basic_features); i++)
108   {
<span class="line-modified">109     map-&gt;enable_feature (basic_features[i], F_MANUAL_ZWJ);</span>
110     map-&gt;add_gsub_pause (nullptr);
111   }
<span class="line-modified">112 </span>
<span class="line-added">113   map-&gt;add_gsub_pause (clear_syllables);</span>
<span class="line-added">114 </span>
115   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (other_features); i++)
<span class="line-modified">116     map-&gt;enable_feature (other_features[i], F_MANUAL_ZWJ);</span>
<span class="line-added">117 </span>
<span class="line-added">118   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (positioning_features); i++)</span>
<span class="line-added">119     map-&gt;enable_feature (positioning_features[i]);</span>
120 }
121 
122 static void
123 override_features_myanmar (hb_ot_shape_planner_t *plan)
124 {
<span class="line-modified">125   plan-&gt;map.disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
126 }
127 
128 
129 enum syllable_type_t {
130   consonant_syllable,
131   punctuation_cluster,
132   broken_cluster,
133   non_myanmar_cluster,
134 };
135 
136 #include &quot;hb-ot-shape-complex-myanmar-machine.hh&quot;
137 
138 
139 static void
140 setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,
141                    hb_buffer_t              *buffer,
142                    hb_font_t                *font HB_UNUSED)
143 {
144   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);
145   HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);
</pre>
<hr />
<pre>
257       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() == OT_VBlw)
258       {
259         info[i].myanmar_position() = pos;
260         continue;
261       }
262       if (pos == POS_BELOW_C &amp;&amp; info[i].myanmar_category() != OT_A)
263       {
264         pos = POS_AFTER_SUB;
265         info[i].myanmar_position() = pos;
266         continue;
267       }
268       info[i].myanmar_position() = pos;
269     }
270   }
271 
272   /* Sit tight, rock &#39;n roll! */
273   buffer-&gt;sort (start, end, compare_myanmar_order);
274 }
275 
276 static void
<span class="line-modified">277 initial_reordering_syllable (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">278                              hb_face_t *face HB_UNUSED,</span>
279                              hb_buffer_t *buffer,
280                              unsigned int start, unsigned int end)
281 {
282   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
283   switch (syllable_type) {
284 
285     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
286     case consonant_syllable:
287       initial_reordering_consonant_syllable  (buffer, start, end);
288       break;
289 
290     case punctuation_cluster:
291     case non_myanmar_cluster:
292       break;
293   }
294 }
295 
296 static inline void
297 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
298                        hb_font_t *font,
</pre>
<hr />
<pre>
326   buffer-&gt;idx = 0;
327   unsigned int last_syllable = 0;
328   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
329   {
330     unsigned int syllable = buffer-&gt;cur().syllable();
331     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
332     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
333     {
334       last_syllable = syllable;
335 
336       hb_glyph_info_t ginfo = dottedcircle;
337       ginfo.cluster = buffer-&gt;cur().cluster;
338       ginfo.mask = buffer-&gt;cur().mask;
339       ginfo.syllable() = buffer-&gt;cur().syllable();
340 
341       buffer-&gt;output_info (ginfo);
342     }
343     else
344       buffer-&gt;next_glyph ();
345   }

346   buffer-&gt;swap_buffers ();
347 }
348 
349 static void
<span class="line-modified">350 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">351          hb_font_t *font,</span>
<span class="line-modified">352          hb_buffer_t *buffer)</span>
353 {
354   insert_dotted_circles (plan, font, buffer);
355 
356   foreach_syllable (buffer, start, end)
357     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<span class="line-added">358 </span>
<span class="line-added">359   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);</span>
<span class="line-added">360   HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);</span>
361 }
362 
363 static void
<span class="line-modified">364 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="line-modified">365                  hb_font_t *font HB_UNUSED,</span>
<span class="line-modified">366                  hb_buffer_t *buffer)</span>
367 {
368   hb_glyph_info_t *info = buffer-&gt;info;
369   unsigned int count = buffer-&gt;len;


370   for (unsigned int i = 0; i &lt; count; i++)
371     info[i].syllable() = 0;



372 }
373 
374 
<span class="line-modified">375 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar =</span>


376 {
<span class="line-modified">377   collect_features_myanmar,</span>
<span class="line-modified">378   override_features_myanmar,</span>
379   nullptr, /* data_create */
380   nullptr, /* data_destroy */
381   nullptr, /* preprocess_text */
382   nullptr, /* postprocess_glyphs */
<span class="line-modified">383   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,</span>
384   nullptr, /* decompose */
385   nullptr, /* compose */
<span class="line-modified">386   setup_masks_myanmar,</span>
<span class="line-modified">387   HB_TAG_NONE, /* gpos_tag */</span>
388   nullptr, /* reorder_marks */
<span class="line-modified">389   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,</span>
<span class="line-modified">390   false, /* fallback_position */</span>
391 };
392 
<span class="line-modified">393 </span>
<span class="line-added">394 /* Ugly Zawgyi encoding.</span>
<span class="line-added">395  * Disable all auto processing.</span>
<span class="line-added">396  * https://github.com/harfbuzz/harfbuzz/issues/1162 */</span>
<span class="line-added">397 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar_zawgyi =</span>
398 {
<span class="line-modified">399   nullptr, /* collect_features */</span>
<span class="line-modified">400   nullptr, /* override_features */</span>
401   nullptr, /* data_create */
402   nullptr, /* data_destroy */
403   nullptr, /* preprocess_text */
404   nullptr, /* postprocess_glyphs */
<span class="line-modified">405   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,</span>
406   nullptr, /* decompose */
407   nullptr, /* compose */
<span class="line-modified">408   nullptr, /* setup_masks */</span>
<span class="line-modified">409   HB_TAG_NONE, /* gpos_tag */</span>
410   nullptr, /* reorder_marks */
<span class="line-modified">411   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,</span>
412   false, /* fallback_position */
413 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-myanmar-machine.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-thai.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfontmanager/sunFont.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2007, 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;stdlib.h&quot;
 27 #include &quot;string.h&quot;
 28 #include &quot;gdefs.h&quot;
 29 #include &quot;jlong.h&quot;
 30 #include &quot;jni_util.h&quot;
 31 #include &quot;sunfontids.h&quot;
 32 #include &quot;fontscalerdefs.h&quot;
 33 #include &quot;sun_font_SunFontManager.h&quot;
 34 #include &quot;sun_font_NullFontScaler.h&quot;
 35 #include &quot;sun_font_StrikeCache.h&quot;
 36 
 37 static void *theNullScalerContext = NULL;
 38 extern void AccelGlyphCache_RemoveAllCellInfos(GlyphInfo *glyph);
 39 
 40 /*
 41  * Declare library specific JNI_Onload entry if static build
 42  */
 43 DEF_STATIC_JNI_OnLoad
 44 
 45 JNIEXPORT jlong JNICALL
 46 Java_sun_font_NullFontScaler_getNullScalerContext
 47     (JNIEnv *env, jclass scalerClass) {
 48 
 49     if (theNullScalerContext == NULL) {
 50         theNullScalerContext = malloc(1);
 51     }
 52     return ptr_to_jlong(theNullScalerContext);
 53 }
 54 
 55 int isNullScalerContext(void *context) {
 56     return theNullScalerContext == context;
 57 }
 58 
 59 /* Eventually we may rework it to be a singleton.
 60  * This will require additional checks in freeLongMemory/freeIntMemory
 61  * and on other hand malformed fonts (main source of null glyph images)
 62  * are supposed to be collected fast.
 63  * But perhaps it is still right thing to do.
 64  * Even better is to eliminate the need to have this native method
 65  * but for this it is necessary to rework Strike and drawing logic
 66  * to be able to live with NULL pointers without performance hit.
 67  */
 68 JNIEXPORT jlong JNICALL Java_sun_font_NullFontScaler_getGlyphImage
 69   (JNIEnv *env, jobject scaler, jlong pContext, jint glyphCode) {
 70     void *nullscaler = calloc(sizeof(GlyphInfo), 1);
 71     return ptr_to_jlong(nullscaler);
 72 }
 73 
 74 
 75 
 76 void initLCDGammaTables();
 77 
 78 /* placeholder for extern variable */
 79 static int initialisedFontIDs = 0;
 80 FontManagerNativeIDs sunFontIDs;
 81 
 82 static void initFontIDs(JNIEnv *env) {
 83 
 84      jclass tmpClass;
 85 
 86      if (initialisedFontIDs) {
 87         return;
 88      }
 89      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/TrueTypeFont&quot;));
 90      CHECK_NULL(sunFontIDs.ttReadBlockMID =
 91          (*env)-&gt;GetMethodID(env, tmpClass, &quot;readBlock&quot;,
 92                              &quot;(Ljava/nio/ByteBuffer;II)I&quot;));
 93      CHECK_NULL(sunFontIDs.ttReadBytesMID =
 94          (*env)-&gt;GetMethodID(env, tmpClass, &quot;readBytes&quot;, &quot;(II)[B&quot;));
 95 
 96      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/Type1Font&quot;));
 97      CHECK_NULL(sunFontIDs.readFileMID =
 98          (*env)-&gt;GetMethodID(env, tmpClass,
 99                              &quot;readFile&quot;, &quot;(Ljava/nio/ByteBuffer;)V&quot;));
100 
101      CHECK_NULL(tmpClass =
102          (*env)-&gt;FindClass(env, &quot;java/awt/geom/Point2D$Float&quot;));
103      sunFontIDs.pt2DFloatClass = (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
104      CHECK_NULL(sunFontIDs.pt2DFloatCtr =
105          (*env)-&gt;GetMethodID(env, sunFontIDs.pt2DFloatClass, &quot;&lt;init&gt;&quot;,&quot;(FF)V&quot;));
106 
107      CHECK_NULL(sunFontIDs.xFID =
108          (*env)-&gt;GetFieldID(env, sunFontIDs.pt2DFloatClass, &quot;x&quot;, &quot;F&quot;));
109      CHECK_NULL(sunFontIDs.yFID =
110          (*env)-&gt;GetFieldID(env, sunFontIDs.pt2DFloatClass, &quot;y&quot;, &quot;F&quot;));
111 
112      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/StrikeMetrics&quot;));
113      CHECK_NULL(sunFontIDs.strikeMetricsClass =
114          (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass));
115 
116      CHECK_NULL(sunFontIDs.strikeMetricsCtr =
117          (*env)-&gt;GetMethodID(env, sunFontIDs.strikeMetricsClass,
118                              &quot;&lt;init&gt;&quot;, &quot;(FFFFFFFFFF)V&quot;));
119 
120      CHECK_NULL(tmpClass =
121          (*env)-&gt;FindClass(env, &quot;java/awt/geom/Rectangle2D$Float&quot;));
122      sunFontIDs.rect2DFloatClass = (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
123      CHECK_NULL(sunFontIDs.rect2DFloatCtr =
124          (*env)-&gt;GetMethodID(env, sunFontIDs.rect2DFloatClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;));
125      CHECK_NULL(sunFontIDs.rect2DFloatCtr4 =
126          (*env)-&gt;GetMethodID(env, sunFontIDs.rect2DFloatClass,
127                             &quot;&lt;init&gt;&quot;, &quot;(FFFF)V&quot;));
128      CHECK_NULL(sunFontIDs.rectF2DX =
129          (*env)-&gt;GetFieldID(env, sunFontIDs.rect2DFloatClass, &quot;x&quot;, &quot;F&quot;));
130      CHECK_NULL(sunFontIDs.rectF2DY =
131          (*env)-&gt;GetFieldID(env, sunFontIDs.rect2DFloatClass, &quot;y&quot;, &quot;F&quot;));
132      CHECK_NULL(sunFontIDs.rectF2DWidth =
133          (*env)-&gt;GetFieldID(env, sunFontIDs.rect2DFloatClass, &quot;width&quot;, &quot;F&quot;));
134      CHECK_NULL(sunFontIDs.rectF2DHeight =
135          (*env)-&gt;GetFieldID(env, sunFontIDs.rect2DFloatClass, &quot;height&quot;, &quot;F&quot;));
136 
137      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;java/awt/geom/GeneralPath&quot;));
138      sunFontIDs.gpClass = (jclass)(*env)-&gt;NewGlobalRef(env, tmpClass);
139      CHECK_NULL(sunFontIDs.gpCtr =
140          (*env)-&gt;GetMethodID(env, sunFontIDs.gpClass, &quot;&lt;init&gt;&quot;, &quot;(I[BI[FI)V&quot;));
141      CHECK_NULL(sunFontIDs.gpCtrEmpty =
142          (*env)-&gt;GetMethodID(env, sunFontIDs.gpClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;));
143 
144      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/Font2D&quot;));
145      CHECK_NULL(sunFontIDs.f2dCharToGlyphMID =
146          (*env)-&gt;GetMethodID(env, tmpClass, &quot;charToGlyph&quot;, &quot;(I)I&quot;));
147      CHECK_NULL(sunFontIDs.f2dCharToVariationGlyphMID =
148          (*env)-&gt;GetMethodID(env, tmpClass, &quot;charToVariationGlyph&quot;, &quot;(II)I&quot;));
149      CHECK_NULL(sunFontIDs.getMapperMID =
150          (*env)-&gt;GetMethodID(env, tmpClass, &quot;getMapper&quot;,
151                              &quot;()Lsun/font/CharToGlyphMapper;&quot;));
152      CHECK_NULL(sunFontIDs.getTableBytesMID =
153          (*env)-&gt;GetMethodID(env, tmpClass, &quot;getTableBytes&quot;, &quot;(I)[B&quot;));
154      CHECK_NULL(sunFontIDs.canDisplayMID =
155          (*env)-&gt;GetMethodID(env, tmpClass, &quot;canDisplay&quot;, &quot;(C)Z&quot;));
156 
157      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/CharToGlyphMapper&quot;));
158      CHECK_NULL(sunFontIDs.charToGlyphMID =
159         (*env)-&gt;GetMethodID(env, tmpClass, &quot;charToGlyph&quot;, &quot;(I)I&quot;));
160 
161      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/PhysicalStrike&quot;));
162      CHECK_NULL(sunFontIDs.getGlyphMetricsMID =
163          (*env)-&gt;GetMethodID(env, tmpClass, &quot;getGlyphMetrics&quot;,
164                              &quot;(I)Ljava/awt/geom/Point2D$Float;&quot;));
165      CHECK_NULL(sunFontIDs.getGlyphPointMID =
166          (*env)-&gt;GetMethodID(env, tmpClass, &quot;getGlyphPoint&quot;,
167                              &quot;(II)Ljava/awt/geom/Point2D$Float;&quot;));
168      CHECK_NULL(sunFontIDs.adjustPointMID =
169          (*env)-&gt;GetMethodID(env, tmpClass, &quot;adjustPoint&quot;,
170                              &quot;(Ljava/awt/geom/Point2D$Float;)V&quot;));
171      CHECK_NULL(sunFontIDs.pScalerContextFID =
172          (*env)-&gt;GetFieldID(env, tmpClass, &quot;pScalerContext&quot;, &quot;J&quot;));
173 
174      CHECK_NULL(tmpClass = (*env)-&gt;FindClass(env, &quot;sun/font/GlyphList&quot;));
175      CHECK_NULL(sunFontIDs.glyphListX =
176          (*env)-&gt;GetFieldID(env, tmpClass, &quot;x&quot;, &quot;F&quot;));
177      CHECK_NULL(sunFontIDs.glyphListY =
178          (*env)-&gt;GetFieldID(env, tmpClass, &quot;y&quot;, &quot;F&quot;));
179      CHECK_NULL(sunFontIDs.glyphListLen =
180          (*env)-&gt;GetFieldID(env, tmpClass, &quot;len&quot;, &quot;I&quot;));
181      CHECK_NULL(sunFontIDs.glyphImages =
182          (*env)-&gt;GetFieldID(env, tmpClass, &quot;images&quot;, &quot;[J&quot;));
183      CHECK_NULL(sunFontIDs.glyphListUsePos =
184          (*env)-&gt;GetFieldID(env, tmpClass, &quot;usePositions&quot;, &quot;Z&quot;));
185      CHECK_NULL(sunFontIDs.glyphListPos =
186          (*env)-&gt;GetFieldID(env, tmpClass, &quot;positions&quot;, &quot;[F&quot;));
187      CHECK_NULL(sunFontIDs.lcdRGBOrder =
188          (*env)-&gt;GetFieldID(env, tmpClass, &quot;lcdRGBOrder&quot;, &quot;Z&quot;));
189      CHECK_NULL(sunFontIDs.lcdSubPixPos =
190          (*env)-&gt;GetFieldID(env, tmpClass, &quot;lcdSubPixPos&quot;, &quot;Z&quot;));
191 
192      initLCDGammaTables();
193 
194      initialisedFontIDs = 1;
195 }
196 
197 JNIEXPORT void JNICALL
198 Java_sun_font_SunFontManager_initIDs
199     (JNIEnv *env, jclass cls) {
200 
201     initFontIDs(env);
202 }
203 
204 JNIEXPORT FontManagerNativeIDs getSunFontIDs(JNIEnv *env) {
205 
206     initFontIDs(env);
207     return sunFontIDs;
208 }
209 
210 /*
211  * Class:     sun_font_StrikeCache
212  * Method:    freeIntPointer
213  * Signature: (I)V
214  */
215 JNIEXPORT void JNICALL Java_sun_font_StrikeCache_freeIntPointer
216     (JNIEnv *env, jclass cacheClass, jint ptr) {
217 
218     /* Note this is used for freeing a glyph which was allocated
219      * but never placed into the glyph cache. The caller holds the
220      * only reference, therefore it is unnecessary to invalidate any
221      * accelerated glyph cache cells as we do in freeInt/LongMemory().
222      */
223     if (ptr != 0) {
224         free((void*)((intptr_t)ptr));
225     }
226 }
227 
228 /*
229  * Class:     sun_font_StrikeCache
230  * Method:    freeLongPointer
231  * Signature: (J)V
232  */
233 JNIEXPORT void JNICALL Java_sun_font_StrikeCache_freeLongPointer
234     (JNIEnv *env, jclass cacheClass, jlong ptr) {
235 
236     /* Note this is used for freeing a glyph which was allocated
237      * but never placed into the glyph cache. The caller holds the
238      * only reference, therefore it is unnecessary to invalidate any
239      * accelerated glyph cache cells as we do in freeInt/LongMemory().
240      */
241     if (ptr != 0L) {
242         free(jlong_to_ptr(ptr));
243     }
244 }
245 
246 /*
247  * Class:     sun_font_StrikeCache
248  * Method:    freeIntMemory
249  * Signature: ([I)V
250  */
251 JNIEXPORT void JNICALL Java_sun_font_StrikeCache_freeIntMemory
252     (JNIEnv *env, jclass cacheClass, jintArray jmemArray, jlong pContext) {
253 
254     int len = (*env)-&gt;GetArrayLength(env, jmemArray);
255     jint* ptrs =
256         (jint*)(*env)-&gt;GetPrimitiveArrayCritical(env, jmemArray, NULL);
257     int i;
258 
259     if (ptrs) {
260         for (i=0; i&lt; len; i++) {
261             if (ptrs[i] != 0) {
262                 GlyphInfo *ginfo = (GlyphInfo *)((intptr_t)ptrs[i]);
263                 if (ginfo-&gt;cellInfo != NULL &amp;&amp;
264                     ginfo-&gt;managed == MANAGED_GLYPH) {
265                     // invalidate this glyph&#39;s accelerated cache cell
266                     AccelGlyphCache_RemoveAllCellInfos(ginfo);
267                 }
268                 free(ginfo);
269             }
270         }
271         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jmemArray, ptrs, JNI_ABORT);
272     }
273     if (!isNullScalerContext(jlong_to_ptr(pContext))) {
274         free(jlong_to_ptr(pContext));
275     }
276 }
277 
278 /*
279  * Class:     sun_font_StrikeCache
280  * Method:    freeLongMemory
281  * Signature: ([J)V
282  */
283 JNIEXPORT void JNICALL Java_sun_font_StrikeCache_freeLongMemory
284     (JNIEnv *env, jclass cacheClass, jlongArray jmemArray, jlong pContext) {
285 
286     int len = (*env)-&gt;GetArrayLength(env, jmemArray);
287     jlong* ptrs =
288         (jlong*)(*env)-&gt;GetPrimitiveArrayCritical(env, jmemArray, NULL);
289     int i;
290 
291     if (ptrs) {
292         for (i=0; i&lt; len; i++) {
293             if (ptrs[i] != 0L) {
294                 GlyphInfo *ginfo = (GlyphInfo *) jlong_to_ptr(ptrs[i]);
295                 if (ginfo-&gt;cellInfo != NULL &amp;&amp;
296                     ginfo-&gt;managed == MANAGED_GLYPH) {
297                     AccelGlyphCache_RemoveAllCellInfos(ginfo);
298                 }
299                 free((void*)ginfo);
300             }
301         }
302         (*env)-&gt;ReleasePrimitiveArrayCritical(env, jmemArray, ptrs, JNI_ABORT);
303     }
304     if (!isNullScalerContext(jlong_to_ptr(pContext))) {
305         free(jlong_to_ptr(pContext));
306     }
307 }
308 
309 JNIEXPORT void JNICALL
310 Java_sun_font_StrikeCache_getGlyphCacheDescription
311   (JNIEnv *env, jclass cls, jlongArray results) {
312 
313     jlong* nresults;
314     GlyphInfo *info;
315     size_t baseAddr;
316 
317     if ((*env)-&gt;GetArrayLength(env, results) &lt; 13) {
318         return;
319     }
320 
321     nresults = (jlong*)(*env)-&gt;GetPrimitiveArrayCritical(env, results, NULL);
322     if (nresults == NULL) {
323         return;
324     }
325     info = (GlyphInfo*) calloc(1, sizeof(GlyphInfo));
326     if (info == NULL) {
327         (*env)-&gt;ReleasePrimitiveArrayCritical(env, results, nresults, 0);
328         return;
329     }
330     baseAddr = (size_t)info;
331     nresults[0] = sizeof(void*);
332     nresults[1] = sizeof(GlyphInfo);
333     nresults[2] = 0;
334     nresults[3] = (size_t)&amp;(info-&gt;advanceY)-baseAddr;
335     nresults[4] = (size_t)&amp;(info-&gt;width)-baseAddr;
336     nresults[5] = (size_t)&amp;(info-&gt;height)-baseAddr;
337     nresults[6] = (size_t)&amp;(info-&gt;rowBytes)-baseAddr;
338     nresults[7] = (size_t)&amp;(info-&gt;topLeftX)-baseAddr;
339     nresults[8] = (size_t)&amp;(info-&gt;topLeftY)-baseAddr;
340     nresults[9] = (size_t)&amp;(info-&gt;image)-baseAddr;
341     nresults[10] = (jlong)(uintptr_t)info; /* invisible glyph */
342     nresults[11] = (size_t)&amp;(info-&gt;cellInfo)-baseAddr;
343     nresults[12] = (size_t)&amp;(info-&gt;managed)-baseAddr;
344 
345     (*env)-&gt;ReleasePrimitiveArrayCritical(env, results, nresults, 0);
346 }
    </pre>
  </body>
</html>
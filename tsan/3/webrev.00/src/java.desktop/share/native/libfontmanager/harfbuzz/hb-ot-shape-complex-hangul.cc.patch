diff a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc
--- a/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc
+++ b/src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc
@@ -22,11 +22,11 @@
  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  *
  * Google Author(s): Behdad Esfahbod
  */
 
-#include "hb-ot-shape-complex-private.hh"
+#include "hb-ot-shape-complex.hh"
 
 
 /* Hangul shaper */
 
 
@@ -54,26 +54,24 @@
 collect_features_hangul (hb_ot_shape_planner_t *plan)
 {
   hb_ot_map_builder_t *map = &plan->map;
 
   for (unsigned int i = FIRST_HANGUL_FEATURE; i < HANGUL_FEATURE_COUNT; i++)
-    map->add_feature (hangul_features[i], 1, F_NONE);
+    map->add_feature (hangul_features[i]);
 }
 
 static void
 override_features_hangul (hb_ot_shape_planner_t *plan)
 {
   /* Uniscribe does not apply 'calt' for Hangul, and certain fonts
    * (Noto Sans CJK, Source Sans Han, etc) apply all of jamo lookups
    * in calt, which is not desirable. */
-  plan->map.add_feature (HB_TAG('c','a','l','t'), 0, F_GLOBAL);
+  plan->map.disable_feature (HB_TAG('c','a','l','t'));
 }
 
 struct hangul_shape_plan_t
 {
-  ASSERT_POD ();
-
   hb_mask_t mask_array[HANGUL_FEATURE_COUNT];
 };
 
 static void *
 data_create_hangul (const hb_ot_shape_plan_t *plan)
@@ -126,11 +124,11 @@
   hb_codepoint_t glyph;
   return hb_font_get_glyph (font, unicode, 0, &glyph) && hb_font_get_glyph_h_advance (font, glyph) == 0;
 }
 
 static void
-preprocess_text_hangul (const hb_ot_shape_plan_t *plan,
+preprocess_text_hangul (const hb_ot_shape_plan_t *plan HB_UNUSED,
                         hb_buffer_t              *buffer,
                         hb_font_t                *font)
 {
   HB_BUFFER_ALLOCATE_VAR (buffer, hangul_shaping_feature);
 
@@ -343,33 +341,35 @@
             font->has_glyph (decomposed[1]) &&
             (!tindex || font->has_glyph (decomposed[2])))
         {
           unsigned int s_len = tindex ? 3 : 2;
           buffer->replace_glyphs (1, s_len, decomposed);
-          if (unlikely (!buffer->successful))
-            return;
-
-          /* We decomposed S: apply jamo features to the individual glyphs
-           * that are now in buffer->out_info.
-           */
-          hb_glyph_info_t *info = buffer->out_info;
 
           /* If we decomposed an LV because of a non-combining T following,
            * we want to include this T in the syllable.
            */
           if (has_glyph && !tindex)
           {
             buffer->next_glyph ();
             s_len++;
           }
+
+          if (unlikely (!buffer->successful))
+            return;
+
+          /* We decomposed S: apply jamo features to the individual glyphs
+           * that are now in buffer->out_info.
+           */
+          hb_glyph_info_t *info = buffer->out_info;
           end = start + s_len;
 
           unsigned int i = start;
           info[i++].hangul_shaping_feature() = LJMO;
           info[i++].hangul_shaping_feature() = VJMO;
           if (i < end)
             info[i++].hangul_shaping_feature() = TJMO;
+
           if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
             buffer->merge_out_clusters (start, end);
           continue;
         }
         else if ((!tindex && buffer->idx + 1 < count && isT (buffer->cur(+1).codepoint)))
@@ -422,10 +422,10 @@
   nullptr, /* postprocess_glyphs */
   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,
   nullptr, /* decompose */
   nullptr, /* compose */
   setup_masks_hangul,
-  nullptr, /* disable_otl */
+  HB_TAG_NONE, /* gpos_tag */
   nullptr, /* reorder_marks */
   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
   false, /* fallback_position */
 };

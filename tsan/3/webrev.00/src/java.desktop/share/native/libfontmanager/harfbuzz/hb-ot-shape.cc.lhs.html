<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2009,2010  Red Hat, Inc.
  3  * Copyright © 2010,2011,2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #define HB_SHAPER ot</span>
<span class="line-modified"> 30 #define hb_ot_shaper_face_data_t hb_ot_layout_t</span>
<span class="line-modified"> 31 #define hb_ot_shaper_shape_plan_data_t hb_ot_shape_plan_t</span>
<span class="line-modified"> 32 #include &quot;hb-shaper-impl-private.hh&quot;</span>
<span class="line-modified"> 33 </span>
<span class="line-modified"> 34 #include &quot;hb-ot-shape-private.hh&quot;</span>
<span class="line-modified"> 35 #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="line-modified"> 36 #include &quot;hb-ot-shape-fallback-private.hh&quot;</span>
<span class="line-modified"> 37 #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="line-modified"> 38 </span>
<span class="line-modified"> 39 #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified"> 40 #include &quot;hb-unicode-private.hh&quot;</span>
<span class="line-modified"> 41 #include &quot;hb-set-private.hh&quot;</span>
<span class="line-modified"> 42 </span>
<span class="line-modified"> 43 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
<span class="line-modified"> 44 //#include &quot;hb-aat-layout-private.hh&quot;</span>
<span class="line-modified"> 45 </span>
<span class="line-modified"> 46 static hb_tag_t common_features[] = {</span>
<span class="line-modified"> 47   HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;),</span>
<span class="line-modified"> 48   HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;),</span>
<span class="line-modified"> 49   HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;),</span>
<span class="line-modified"> 50   HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;),</span>
<span class="line-modified"> 51   HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified"> 52 };</span>










































































































































































 53 
<a name="2" id="anc2"></a>


 54 
<a name="3" id="anc3"></a><span class="line-modified"> 55 static hb_tag_t horizontal_features[] = {</span>
<span class="line-modified"> 56   HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;),</span>
<span class="line-modified"> 57   HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified"> 58   HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;),</span>
<span class="line-modified"> 59   HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;),</span>
<span class="line-modified"> 60   HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;),</span>
<span class="line-modified"> 61   HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;),</span>


 62 };
 63 
 64 
<a name="4" id="anc4"></a>









 65 
 66 static void
 67 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
<a name="5" id="anc5"></a><span class="line-removed"> 68                               const hb_segment_properties_t  *props,</span>
 69                               const hb_feature_t             *user_features,
 70                               unsigned int                    num_user_features)
 71 {
 72   hb_ot_map_builder_t *map = &amp;planner-&gt;map;
 73 
<a name="6" id="anc6"></a><span class="line-modified"> 74   map-&gt;add_global_bool_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
 75   map-&gt;add_gsub_pause (nullptr);
 76 
<a name="7" id="anc7"></a><span class="line-modified"> 77   switch (props-&gt;direction) {</span>
 78     case HB_DIRECTION_LTR:
<a name="8" id="anc8"></a><span class="line-modified"> 79       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 80       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
 81       break;
 82     case HB_DIRECTION_RTL:
<a name="9" id="anc9"></a><span class="line-modified"> 83       map-&gt;add_global_bool_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 84       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;), 1, F_NONE);</span>
 85       break;
 86     case HB_DIRECTION_TTB:
 87     case HB_DIRECTION_BTT:
 88     case HB_DIRECTION_INVALID:
 89     default:
 90       break;
 91   }
 92 
<a name="10" id="anc10"></a><span class="line-modified"> 93   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;), 1, F_NONE);</span>
<span class="line-modified"> 94   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;), 1, F_NONE);</span>
<span class="line-modified"> 95   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;), 1, F_NONE);</span>











 96 
 97   if (planner-&gt;shaper-&gt;collect_features)
 98     planner-&gt;shaper-&gt;collect_features (planner);
 99 
<a name="11" id="anc11"></a>

100   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<a name="12" id="anc12"></a><span class="line-modified">101     map-&gt;add_global_bool_feature (common_features[i]);</span>
102 
<a name="13" id="anc13"></a><span class="line-modified">103   if (HB_DIRECTION_IS_HORIZONTAL (props-&gt;direction))</span>
104     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<a name="14" id="anc14"></a><span class="line-modified">105       map-&gt;add_feature (horizontal_features[i], 1, F_GLOBAL |</span>
<span class="line-removed">106                         (horizontal_features[i] == HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) ?</span>
<span class="line-removed">107                          F_HAS_FALLBACK : F_NONE));</span>
108   else
109   {
110     /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
111      * matter which script/langsys it is listed (or not) under.
112      * See various bugs referenced from:
113      * https://github.com/harfbuzz/harfbuzz/issues/63 */
<a name="15" id="anc15"></a><span class="line-modified">114     map-&gt;add_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), 1, F_GLOBAL | F_GLOBAL_SEARCH);</span>
115   }
116 
<a name="16" id="anc16"></a><span class="line-modified">117   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-modified">118     planner-&gt;shaper-&gt;override_features (planner);</span>
<span class="line-removed">119 </span>
<span class="line-removed">120   for (unsigned int i = 0; i &lt; num_user_features; i++) {</span>
121     const hb_feature_t *feature = &amp;user_features[i];
<a name="17" id="anc17"></a><span class="line-modified">122     map-&gt;add_feature (feature-&gt;tag, feature-&gt;value,</span>
<span class="line-modified">123                       (feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int) -1) ?</span>
<span class="line-modified">124                        F_GLOBAL : F_NONE);</span>

125   }
<a name="18" id="anc18"></a>












126 }
127 
128 
129 /*
130  * shaper face data
131  */
132 
<a name="19" id="anc19"></a><span class="line-modified">133 HB_SHAPER_DATA_ENSURE_DEFINE(ot, face)</span>
134 
<a name="20" id="anc20"></a><span class="line-modified">135 hb_ot_shaper_face_data_t *</span>
136 _hb_ot_shaper_face_data_create (hb_face_t *face)
137 {
<a name="21" id="anc21"></a><span class="line-modified">138   return _hb_ot_layout_create (face);</span>
139 }
140 
141 void
<a name="22" id="anc22"></a><span class="line-modified">142 _hb_ot_shaper_face_data_destroy (hb_ot_shaper_face_data_t *data)</span>
143 {
<a name="23" id="anc23"></a><span class="line-removed">144   _hb_ot_layout_destroy (data);</span>
145 }
146 
147 
148 /*
149  * shaper font data
150  */
151 
<a name="24" id="anc24"></a><span class="line-modified">152 HB_SHAPER_DATA_ENSURE_DEFINE(ot, font)</span>
<span class="line-removed">153 </span>
<span class="line-removed">154 struct hb_ot_shaper_font_data_t {};</span>
155 
<a name="25" id="anc25"></a><span class="line-modified">156 hb_ot_shaper_font_data_t *</span>
157 _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
158 {
<a name="26" id="anc26"></a><span class="line-modified">159   return (hb_ot_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
<span class="line-removed">160 }</span>
<span class="line-removed">161 </span>
<span class="line-removed">162 void</span>
<span class="line-removed">163 _hb_ot_shaper_font_data_destroy (hb_ot_shaper_font_data_t *data)</span>
<span class="line-removed">164 {</span>
<span class="line-removed">165 }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167 </span>
<span class="line-removed">168 /*</span>
<span class="line-removed">169  * shaper shape_plan data</span>
<span class="line-removed">170  */</span>
<span class="line-removed">171 </span>
<span class="line-removed">172 hb_ot_shaper_shape_plan_data_t *</span>
<span class="line-removed">173 _hb_ot_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,</span>
<span class="line-removed">174                                       const hb_feature_t *user_features,</span>
<span class="line-removed">175                                       unsigned int        num_user_features,</span>
<span class="line-removed">176                                       const int          *coords,</span>
<span class="line-removed">177                                       unsigned int        num_coords)</span>
<span class="line-removed">178 {</span>
<span class="line-removed">179   hb_ot_shape_plan_t *plan = (hb_ot_shape_plan_t *) calloc (1, sizeof (hb_ot_shape_plan_t));</span>
<span class="line-removed">180   if (unlikely (!plan))</span>
<span class="line-removed">181     return nullptr;</span>
<span class="line-removed">182 </span>
<span class="line-removed">183   plan-&gt;init ();</span>
<span class="line-removed">184 </span>
<span class="line-removed">185   hb_ot_shape_planner_t planner (shape_plan);</span>
<span class="line-removed">186 </span>
<span class="line-removed">187   planner.shaper = hb_ot_shape_complex_categorize (&amp;planner);</span>
<span class="line-removed">188 </span>
<span class="line-removed">189   hb_ot_shape_collect_features (&amp;planner, &amp;shape_plan-&gt;props,</span>
<span class="line-removed">190                                 user_features, num_user_features);</span>
<span class="line-removed">191 </span>
<span class="line-removed">192   planner.compile (*plan, coords, num_coords);</span>
<span class="line-removed">193 </span>
<span class="line-removed">194   if (plan-&gt;shaper-&gt;data_create) {</span>
<span class="line-removed">195     plan-&gt;data = plan-&gt;shaper-&gt;data_create (plan);</span>
<span class="line-removed">196     if (unlikely (!plan-&gt;data)) {</span>
<span class="line-removed">197       free(plan);</span>
<span class="line-removed">198       return nullptr;</span>
<span class="line-removed">199     }</span>
<span class="line-removed">200   }</span>
<span class="line-removed">201 </span>
<span class="line-removed">202   return plan;</span>
203 }
204 
205 void
<a name="27" id="anc27"></a><span class="line-modified">206 _hb_ot_shaper_shape_plan_data_destroy (hb_ot_shaper_shape_plan_data_t *plan)</span>
207 {
<a name="28" id="anc28"></a><span class="line-removed">208   if (plan-&gt;shaper-&gt;data_destroy)</span>
<span class="line-removed">209     plan-&gt;shaper-&gt;data_destroy (const_cast&lt;void *&gt; (plan-&gt;data));</span>
<span class="line-removed">210 </span>
<span class="line-removed">211   plan-&gt;fini ();</span>
<span class="line-removed">212 </span>
<span class="line-removed">213   free (plan);</span>
214 }
215 
216 
217 /*
218  * shaper
219  */
220 
221 struct hb_ot_shape_context_t
222 {
223   hb_ot_shape_plan_t *plan;
224   hb_font_t *font;
225   hb_face_t *face;
226   hb_buffer_t  *buffer;
227   const hb_feature_t *user_features;
228   unsigned int        num_user_features;
229 
230   /* Transient stuff */
<a name="29" id="anc29"></a><span class="line-removed">231   bool fallback_positioning;</span>
<span class="line-removed">232   bool fallback_glyph_classes;</span>
233   hb_direction_t target_direction;
234 };
235 
236 
237 
238 /* Main shaper */
239 
240 
241 /* Prepare */
242 
243 static void
244 hb_set_unicode_props (hb_buffer_t *buffer)
245 {
<a name="30" id="anc30"></a>







246   unsigned int count = buffer-&gt;len;
247   hb_glyph_info_t *info = buffer-&gt;info;
248   for (unsigned int i = 0; i &lt; count; i++)
<a name="31" id="anc31"></a>
249     _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);
<a name="32" id="anc32"></a>

































250 }
251 
252 static void
253 hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
254 {
255   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
256       buffer-&gt;context_len[0] ||
<a name="33" id="anc33"></a><span class="line-modified">257       _hb_glyph_info_get_general_category (&amp;buffer-&gt;info[0]) !=</span>
<span class="line-removed">258       HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)</span>
259     return;
260 
261   if (!font-&gt;has_glyph (0x25CCu))
262     return;
263 
264   hb_glyph_info_t dottedcircle = {0};
265   dottedcircle.codepoint = 0x25CCu;
266   _hb_glyph_info_set_unicode_props (&amp;dottedcircle, buffer);
267 
268   buffer-&gt;clear_output ();
269 
270   buffer-&gt;idx = 0;
271   hb_glyph_info_t info = dottedcircle;
272   info.cluster = buffer-&gt;cur().cluster;
273   info.mask = buffer-&gt;cur().mask;
274   buffer-&gt;output_info (info);
275   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
276     buffer-&gt;next_glyph ();
<a name="34" id="anc34"></a><span class="line-removed">277 </span>
278   buffer-&gt;swap_buffers ();
279 }
280 
281 static void
282 hb_form_clusters (hb_buffer_t *buffer)
283 {
284   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
285     return;
286 
<a name="35" id="anc35"></a><span class="line-removed">287   /* Loop duplicated in hb_ensure_native_direction(), and in _hb-coretext.cc */</span>
<span class="line-removed">288   unsigned int base = 0;</span>
<span class="line-removed">289   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">290   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">291   for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">292   {</span>
<span class="line-removed">293     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])) &amp;&amp;</span>
<span class="line-removed">294                 !_hb_glyph_info_is_joiner (&amp;info[i])))</span>
<span class="line-removed">295     {</span>
<span class="line-removed">296       if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)</span>
<span class="line-removed">297         buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed">298       else</span>
<span class="line-removed">299         buffer-&gt;unsafe_to_break (base, i);</span>
<span class="line-removed">300       base = i;</span>
<span class="line-removed">301     }</span>
<span class="line-removed">302   }</span>
303   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<a name="36" id="anc36"></a><span class="line-modified">304     buffer-&gt;merge_clusters (base, count);</span>

305   else
<a name="37" id="anc37"></a><span class="line-modified">306     buffer-&gt;unsafe_to_break (base, count);</span>

307 }
308 
309 static void
310 hb_ensure_native_direction (hb_buffer_t *buffer)
311 {
312   hb_direction_t direction = buffer-&gt;props.direction;
313   hb_direction_t horiz_dir = hb_script_get_horizontal_direction (buffer-&gt;props.script);
314 
315   /* TODO vertical:
316    * The only BTT vertical script is Ogham, but it&#39;s not clear to me whether OpenType
317    * Ogham fonts are supposed to be implemented BTT or not.  Need to research that
318    * first. */
319   if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
320        direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
321       (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
322        direction != HB_DIRECTION_TTB))
323   {
<a name="38" id="anc38"></a><span class="line-removed">324     /* Same loop as hb_form_clusters().</span>
<span class="line-removed">325      * Since form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-removed">326     unsigned int base = 0;</span>
<span class="line-removed">327     unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">328     hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">329     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">330     {</span>
<span class="line-removed">331       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i]))))</span>
<span class="line-removed">332       {</span>
<span class="line-removed">333         if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)</span>
<span class="line-removed">334           buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed">335         buffer-&gt;reverse_range (base, i);</span>
336 
<a name="39" id="anc39"></a><span class="line-removed">337         base = i;</span>
<span class="line-removed">338       }</span>
<span class="line-removed">339     }</span>
340     if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<a name="40" id="anc40"></a><span class="line-modified">341       buffer-&gt;merge_clusters (base, count);</span>
<span class="line-modified">342     buffer-&gt;reverse_range (base, count);</span>







343 
344     buffer-&gt;reverse ();
345 
346     buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
347   }
348 }
349 
350 
<a name="41" id="anc41"></a><span class="line-modified">351 /* Substitute */</span>


352 
353 static inline void
<a name="42" id="anc42"></a><span class="line-modified">354 hb_ot_mirror_chars (hb_ot_shape_context_t *c)</span>
355 {
356   if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
357     return;
358 
359   hb_buffer_t *buffer = c-&gt;buffer;
360   hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
361   hb_mask_t rtlm_mask = c-&gt;plan-&gt;rtlm_mask;
362 
363   unsigned int count = buffer-&gt;len;
364   hb_glyph_info_t *info = buffer-&gt;info;
365   for (unsigned int i = 0; i &lt; count; i++) {
366     hb_codepoint_t codepoint = unicode-&gt;mirroring (info[i].codepoint);
367     if (likely (codepoint == info[i].codepoint || !c-&gt;font-&gt;has_glyph (codepoint)))
368       info[i].mask |= rtlm_mask;
369     else
370       info[i].codepoint = codepoint;
371   }
372 }
373 
374 static inline void
<a name="43" id="anc43"></a><span class="line-modified">375 hb_ot_shape_setup_masks_fraction (hb_ot_shape_context_t *c)</span>
376 {
377   if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
378       !c-&gt;plan-&gt;has_frac)
379     return;
380 
381   hb_buffer_t *buffer = c-&gt;buffer;
382 
383   hb_mask_t pre_mask, post_mask;
384   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction))
385   {
386     pre_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
387     post_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
388   }
389   else
390   {
391     pre_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
392     post_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
393   }
394 
395   unsigned int count = buffer-&gt;len;
396   hb_glyph_info_t *info = buffer-&gt;info;
397   for (unsigned int i = 0; i &lt; count; i++)
398   {
399     if (info[i].codepoint == 0x2044u) /* FRACTION SLASH */
400     {
401       unsigned int start = i, end = i + 1;
402       while (start &amp;&amp;
403              _hb_glyph_info_get_general_category (&amp;info[start - 1]) ==
404              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
405         start--;
406       while (end &lt; count &amp;&amp;
407              _hb_glyph_info_get_general_category (&amp;info[end]) ==
408              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
409         end++;
410 
411       buffer-&gt;unsafe_to_break (start, end);
412 
413       for (unsigned int j = start; j &lt; i; j++)
414         info[j].mask |= pre_mask;
415       info[i].mask |= c-&gt;plan-&gt;frac_mask;
416       for (unsigned int j = i + 1; j &lt; end; j++)
417         info[j].mask |= post_mask;
418 
419       i = end - 1;
420     }
421   }
422 }
423 
424 static inline void
<a name="44" id="anc44"></a><span class="line-modified">425 hb_ot_shape_initialize_masks (hb_ot_shape_context_t *c)</span>
426 {
427   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
428   hb_buffer_t *buffer = c-&gt;buffer;
429 
430   hb_mask_t global_mask = map-&gt;get_global_mask ();
431   buffer-&gt;reset_masks (global_mask);
432 }
433 
434 static inline void
<a name="45" id="anc45"></a><span class="line-modified">435 hb_ot_shape_setup_masks (hb_ot_shape_context_t *c)</span>
436 {
437   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
438   hb_buffer_t *buffer = c-&gt;buffer;
439 
440   hb_ot_shape_setup_masks_fraction (c);
441 
442   if (c-&gt;plan-&gt;shaper-&gt;setup_masks)
443     c-&gt;plan-&gt;shaper-&gt;setup_masks (c-&gt;plan, buffer, c-&gt;font);
444 
445   for (unsigned int i = 0; i &lt; c-&gt;num_user_features; i++)
446   {
447     const hb_feature_t *feature = &amp;c-&gt;user_features[i];
448     if (!(feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int)-1)) {
449       unsigned int shift;
450       hb_mask_t mask = map-&gt;get_mask (feature-&gt;tag, &amp;shift);
451       buffer-&gt;set_masks (feature-&gt;value &lt;&lt; shift, mask, feature-&gt;start, feature-&gt;end);
452     }
453   }
454 }
455 
456 static void
<a name="46" id="anc46"></a><span class="line-modified">457 hb_ot_zero_width_default_ignorables (hb_ot_shape_context_t *c)</span>
458 {
<a name="47" id="anc47"></a><span class="line-removed">459   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed">460 </span>
461   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
462       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
463       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
464     return;
465 
466   unsigned int count = buffer-&gt;len;
467   hb_glyph_info_t *info = buffer-&gt;info;
468   hb_glyph_position_t *pos = buffer-&gt;pos;
469   unsigned int i = 0;
470   for (i = 0; i &lt; count; i++)
471     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
472       pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
473 }
474 
475 static void
<a name="48" id="anc48"></a><span class="line-modified">476 hb_ot_hide_default_ignorables (hb_ot_shape_context_t *c)</span>

477 {
<a name="49" id="anc49"></a><span class="line-removed">478   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed">479 </span>
480   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
481       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
482     return;
483 
484   unsigned int count = buffer-&gt;len;
485   hb_glyph_info_t *info = buffer-&gt;info;
<a name="50" id="anc50"></a><span class="line-removed">486   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-removed">487   unsigned int i = 0;</span>
<span class="line-removed">488   for (i = 0; i &lt; count; i++)</span>
<span class="line-removed">489   {</span>
<span class="line-removed">490     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))</span>
<span class="line-removed">491       break;</span>
<span class="line-removed">492   }</span>
<span class="line-removed">493 </span>
<span class="line-removed">494   /* No default-ignorables found; return. */</span>
<span class="line-removed">495   if (i == count)</span>
<span class="line-removed">496     return;</span>
497 
<a name="51" id="anc51"></a><span class="line-modified">498   hb_codepoint_t space;</span>
499   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<a name="52" id="anc52"></a><span class="line-modified">500       c-&gt;font-&gt;get_nominal_glyph (&#39; &#39;, &amp;space))</span>
501   {
<a name="53" id="anc53"></a><span class="line-modified">502     /* Replace default-ignorables with a zero-advance space glyph. */</span>
<span class="line-modified">503     for (/*continue*/; i &lt; count; i++)</span>
504     {
505       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<a name="54" id="anc54"></a><span class="line-modified">506         info[i].codepoint = space;</span>
507     }
508   }
509   else
<a name="55" id="anc55"></a><span class="line-modified">510   {</span>
<span class="line-removed">511     /* Merge clusters and delete default-ignorables.</span>
<span class="line-removed">512      * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-removed">513     unsigned int j = i;</span>
<span class="line-removed">514     for (; i &lt; count; i++)</span>
<span class="line-removed">515     {</span>
<span class="line-removed">516       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))</span>
<span class="line-removed">517       {</span>
<span class="line-removed">518         /* Merge clusters.</span>
<span class="line-removed">519          * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-removed">520 </span>
<span class="line-removed">521         unsigned int cluster = info[i].cluster;</span>
<span class="line-removed">522         if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-removed">523           continue; /* Cluster survives; do nothing. */</span>
<span class="line-removed">524 </span>
<span class="line-removed">525         if (j)</span>
<span class="line-removed">526         {</span>
<span class="line-removed">527           /* Merge cluster backward. */</span>
<span class="line-removed">528           if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-removed">529           {</span>
<span class="line-removed">530             unsigned int mask = info[i].mask;</span>
<span class="line-removed">531             unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-removed">532             for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-removed">533               buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-removed">534           }</span>
<span class="line-removed">535           continue;</span>
<span class="line-removed">536         }</span>
<span class="line-removed">537 </span>
<span class="line-removed">538         if (i + 1 &lt; count)</span>
<span class="line-removed">539           buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-removed">540 </span>
<span class="line-removed">541         continue;</span>
<span class="line-removed">542       }</span>
<span class="line-removed">543 </span>
<span class="line-removed">544       if (j != i)</span>
<span class="line-removed">545       {</span>
<span class="line-removed">546         info[j] = info[i];</span>
<span class="line-removed">547         pos[j] = pos[i];</span>
<span class="line-removed">548       }</span>
<span class="line-removed">549       j++;</span>
<span class="line-removed">550     }</span>
<span class="line-removed">551     buffer-&gt;len = j;</span>
<span class="line-removed">552   }</span>
553 }
554 
555 
556 static inline void
557 hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
558 {
559   /* Normalization process sets up glyph_index(), we just copy it. */
560   unsigned int count = buffer-&gt;len;
561   hb_glyph_info_t *info = buffer-&gt;info;
562   for (unsigned int i = 0; i &lt; count; i++)
563     info[i].codepoint = info[i].glyph_index();
564 
565   buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
566 }
567 
568 static inline void
<a name="56" id="anc56"></a><span class="line-modified">569 hb_synthesize_glyph_classes (hb_ot_shape_context_t *c)</span>
570 {
<a name="57" id="anc57"></a><span class="line-modified">571   unsigned int count = c-&gt;buffer-&gt;len;</span>
<span class="line-modified">572   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;</span>
573   for (unsigned int i = 0; i &lt; count; i++)
574   {
575     hb_ot_layout_glyph_props_flags_t klass;
576 
577     /* Never mark default-ignorables as marks.
578      * They won&#39;t get in the way of lookups anyway,
579      * but having them as mark will cause them to be skipped
580      * over if the lookup-flag says so, but at least for the
581      * Mongolian variation selectors, looks like Uniscribe
582      * marks them as non-mark.  Some Mongolian fonts without
583      * GDEF rely on this.  Another notable character that
584      * this applies to is COMBINING GRAPHEME JOINER. */
585     klass = (_hb_glyph_info_get_general_category (&amp;info[i]) !=
586              HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ||
587              _hb_glyph_info_is_default_ignorable (&amp;info[i])) ?
588             HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH :
589             HB_OT_LAYOUT_GLYPH_PROPS_MARK;
590     _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
591   }
592 }
593 
594 static inline void
<a name="58" id="anc58"></a><span class="line-modified">595 hb_ot_substitute_default (hb_ot_shape_context_t *c)</span>
596 {
597   hb_buffer_t *buffer = c-&gt;buffer;
598 
599   hb_ot_mirror_chars (c);
600 
601   HB_BUFFER_ALLOCATE_VAR (buffer, glyph_index);
602 
603   _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
604 
605   hb_ot_shape_setup_masks (c);
606 
607   /* This is unfortunate to go here, but necessary... */
<a name="59" id="anc59"></a><span class="line-modified">608   if (c-&gt;fallback_positioning)</span>
<span class="line-modified">609     _hb_ot_shape_fallback_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
610 
611   hb_ot_map_glyphs_fast (buffer);
612 
613   HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
614 }
615 
616 static inline void
<a name="60" id="anc60"></a><span class="line-modified">617 hb_ot_substitute_complex (hb_ot_shape_context_t *c)</span>
618 {
619   hb_buffer_t *buffer = c-&gt;buffer;
620 
621   hb_ot_layout_substitute_start (c-&gt;font, buffer);
622 
<a name="61" id="anc61"></a><span class="line-modified">623   if (!hb_ot_layout_has_glyph_classes (c-&gt;face))</span>
<span class="line-modified">624     hb_synthesize_glyph_classes (c);</span>
625 
626   c-&gt;plan-&gt;substitute (c-&gt;font, buffer);
<a name="62" id="anc62"></a><span class="line-removed">627 </span>
<span class="line-removed">628   /* XXX Call morx instead. */</span>
<span class="line-removed">629   //hb_aat_layout_substitute (c-&gt;font, c-&gt;buffer);</span>
630 }
631 
632 static inline void
<a name="63" id="anc63"></a><span class="line-modified">633 hb_ot_substitute (hb_ot_shape_context_t *c)</span>
634 {
635   hb_ot_substitute_default (c);
636 
637   _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
638 
639   hb_ot_substitute_complex (c);
640 }
641 
<a name="64" id="anc64"></a><span class="line-modified">642 /* Position */</span>














643 
644 static inline void
645 adjust_mark_offsets (hb_glyph_position_t *pos)
646 {
647   pos-&gt;x_offset -= pos-&gt;x_advance;
648   pos-&gt;y_offset -= pos-&gt;y_advance;
649 }
650 
651 static inline void
652 zero_mark_width (hb_glyph_position_t *pos)
653 {
654   pos-&gt;x_advance = 0;
655   pos-&gt;y_advance = 0;
656 }
657 
658 static inline void
659 zero_mark_widths_by_gdef (hb_buffer_t *buffer, bool adjust_offsets)
660 {
661   unsigned int count = buffer-&gt;len;
662   hb_glyph_info_t *info = buffer-&gt;info;
663   for (unsigned int i = 0; i &lt; count; i++)
664     if (_hb_glyph_info_is_mark (&amp;info[i]))
665     {
666       if (adjust_offsets)
667         adjust_mark_offsets (&amp;buffer-&gt;pos[i]);
668       zero_mark_width (&amp;buffer-&gt;pos[i]);
669     }
670 }
671 
672 static inline void
<a name="65" id="anc65"></a><span class="line-modified">673 hb_ot_position_default (hb_ot_shape_context_t *c)</span>
674 {
675   hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
676   unsigned int count = c-&gt;buffer-&gt;len;
677   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
678   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
679 
680   if (HB_DIRECTION_IS_HORIZONTAL (direction))
681   {
<a name="66" id="anc66"></a><span class="line-modified">682     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified">683       pos[i].x_advance = c-&gt;font-&gt;get_glyph_h_advance (info[i].codepoint);</span>
684     /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
685     if (c-&gt;font-&gt;has_glyph_h_origin_func ())
686       for (unsigned int i = 0; i &lt; count; i++)
687         c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
688                                           &amp;pos[i].x_offset,
689                                           &amp;pos[i].y_offset);
690   }
691   else
692   {
<a name="67" id="anc67"></a>

693     for (unsigned int i = 0; i &lt; count; i++)
694     {
<a name="68" id="anc68"></a><span class="line-removed">695       pos[i].y_advance = c-&gt;font-&gt;get_glyph_v_advance (info[i].codepoint);</span>
696       c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
697                                         &amp;pos[i].x_offset,
698                                         &amp;pos[i].y_offset);
699     }
700   }
701   if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
702     _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
703 }
704 
705 static inline void
<a name="69" id="anc69"></a><span class="line-modified">706 hb_ot_position_complex (hb_ot_shape_context_t *c)</span>
707 {
708   unsigned int count = c-&gt;buffer-&gt;len;
709   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
710   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
711 
<a name="70" id="anc70"></a><span class="line-modified">712   /* If the font has no GPOS, AND, no fallback positioning will</span>
<span class="line-modified">713    * happen, AND, direction is forward, then when zeroing mark</span>
<span class="line-modified">714    * widths, we shift the mark with it, such that the mark</span>
<span class="line-removed">715    * is positioned hanging over the previous glyph.  When</span>
716    * direction is backward we don&#39;t shift and it will end up
717    * hanging over the next glyph after the final reordering.
<a name="71" id="anc71"></a><span class="line-modified">718    * If fallback positinoing happens or GPOS is present, we don&#39;t</span>
<span class="line-modified">719    * care.</span>

720    */
<a name="72" id="anc72"></a><span class="line-modified">721   bool adjust_offsets_when_zeroing = c-&gt;fallback_positioning &amp;&amp;</span>
<span class="line-removed">722                                      !c-&gt;plan-&gt;shaper-&gt;fallback_position &amp;&amp;</span>
723                                      HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
724 
725   /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
726 
727   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
728   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
729     for (unsigned int i = 0; i &lt; count; i++)
730       c-&gt;font-&gt;add_glyph_h_origin (info[i].codepoint,
731                                    &amp;pos[i].x_offset,
732                                    &amp;pos[i].y_offset);
733 
734   hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
735 
<a name="73" id="anc73"></a><span class="line-modified">736   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified">737   {</span>
<span class="line-modified">738     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified">739       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified">740       break;</span>
<span class="line-modified">741 </span>
<span class="line-modified">742     default:</span>
<span class="line-modified">743     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified">744     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified">745       break;</span>
<span class="line-modified">746   }</span>
<span class="line-modified">747 </span>
<span class="line-removed">748   if (likely (!c-&gt;fallback_positioning))</span>
<span class="line-removed">749     c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>
750 
<a name="74" id="anc74"></a><span class="line-modified">751   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-removed">752   {</span>
<span class="line-removed">753     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-removed">754       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-removed">755       break;</span>
756 
<a name="75" id="anc75"></a><span class="line-modified">757     default:</span>
<span class="line-modified">758     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified">759     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified">760       break;</span>
<span class="line-modified">761   }</span>







762 
<a name="76" id="anc76"></a><span class="line-modified">763   /* Finishing off GPOS has to follow a certain order. */</span>
764   hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<a name="77" id="anc77"></a><span class="line-modified">765   hb_ot_zero_width_default_ignorables (c);</span>


766   hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
767 
768   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
769   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
770     for (unsigned int i = 0; i &lt; count; i++)
771       c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
772                                         &amp;pos[i].x_offset,
773                                         &amp;pos[i].y_offset);
<a name="78" id="anc78"></a>



774 }
775 
776 static inline void
<a name="79" id="anc79"></a><span class="line-modified">777 hb_ot_position (hb_ot_shape_context_t *c)</span>
778 {
779   c-&gt;buffer-&gt;clear_positions ();
780 
781   hb_ot_position_default (c);
782 
783   hb_ot_position_complex (c);
784 
<a name="80" id="anc80"></a><span class="line-removed">785   if (c-&gt;fallback_positioning &amp;&amp; c-&gt;plan-&gt;shaper-&gt;fallback_position)</span>
<span class="line-removed">786     _hb_ot_shape_fallback_position (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed">787 </span>
788   if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
789     hb_buffer_reverse (c-&gt;buffer);
790 
<a name="81" id="anc81"></a><span class="line-removed">791   /* Visual fallback goes here. */</span>
<span class="line-removed">792 </span>
<span class="line-removed">793   if (c-&gt;fallback_positioning)</span>
<span class="line-removed">794     _hb_ot_shape_fallback_kern (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed">795 </span>
796   _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);
<a name="82" id="anc82"></a><span class="line-removed">797 </span>
<span class="line-removed">798   //hb_aat_layout_position (c-&gt;font, c-&gt;buffer);</span>
799 }
800 
801 static inline void
802 hb_propagate_flags (hb_buffer_t *buffer)
803 {
804   /* Propagate cluster-level glyph flags to be the same on all cluster glyphs.
805    * Simplifies using them. */
806 
807   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))
808     return;
809 
810   hb_glyph_info_t *info = buffer-&gt;info;
811 
812   foreach_cluster (buffer, start, end)
813   {
814     unsigned int mask = 0;
815     for (unsigned int i = start; i &lt; end; i++)
816       if (info[i].mask &amp; HB_GLYPH_FLAG_UNSAFE_TO_BREAK)
817       {
818          mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
819          break;
820       }
821     if (mask)
822       for (unsigned int i = start; i &lt; end; i++)
823         info[i].mask |= mask;
824   }
825 }
826 
827 /* Pull it all together! */
828 
829 static void
830 hb_ot_shape_internal (hb_ot_shape_context_t *c)
831 {
832   c-&gt;buffer-&gt;deallocate_var_all ();
833   c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<a name="83" id="anc83"></a><span class="line-modified">834   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
835   {
836     c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
837                               (unsigned) HB_BUFFER_MAX_LEN_MIN);
838   }
<a name="84" id="anc84"></a><span class="line-modified">839   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
840   {
841     c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
842                               (unsigned) HB_BUFFER_MAX_OPS_MIN);
843   }
844 
<a name="85" id="anc85"></a><span class="line-removed">845   bool disable_otl = c-&gt;plan-&gt;shaper-&gt;disable_otl &amp;&amp; c-&gt;plan-&gt;shaper-&gt;disable_otl (c-&gt;plan);</span>
<span class="line-removed">846   //c-&gt;fallback_substitute     = disable_otl || !hb_ot_layout_has_substitution (c-&gt;face);</span>
<span class="line-removed">847   c-&gt;fallback_positioning    = disable_otl || !hb_ot_layout_has_positioning (c-&gt;face);</span>
<span class="line-removed">848   c-&gt;fallback_glyph_classes  = disable_otl || !hb_ot_layout_has_glyph_classes (c-&gt;face);</span>
<span class="line-removed">849 </span>
850   /* Save the original direction, we use it later. */
851   c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
852 
853   _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
854 
855   c-&gt;buffer-&gt;clear_output ();
856 
857   hb_ot_shape_initialize_masks (c);
858   hb_set_unicode_props (c-&gt;buffer);
859   hb_insert_dotted_circle (c-&gt;buffer, c-&gt;font);
860 
861   hb_form_clusters (c-&gt;buffer);
862 
863   hb_ensure_native_direction (c-&gt;buffer);
864 
865   if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
866     c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
867 
<a name="86" id="anc86"></a><span class="line-modified">868   hb_ot_substitute (c);</span>
869   hb_ot_position (c);
<a name="87" id="anc87"></a><span class="line-modified">870 </span>
<span class="line-removed">871   hb_ot_hide_default_ignorables (c);</span>
<span class="line-removed">872 </span>
<span class="line-removed">873   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-removed">874     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
875 
876   hb_propagate_flags (c-&gt;buffer);
877 
878   _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
879 
880   c-&gt;buffer-&gt;props.direction = c-&gt;target_direction;
881 
882   c-&gt;buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
883   c-&gt;buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
884   c-&gt;buffer-&gt;deallocate_var_all ();
885 }
886 
887 
888 hb_bool_t
889 _hb_ot_shape (hb_shape_plan_t    *shape_plan,
890               hb_font_t          *font,
891               hb_buffer_t        *buffer,
892               const hb_feature_t *features,
893               unsigned int        num_features)
894 {
<a name="88" id="anc88"></a><span class="line-modified">895   hb_ot_shape_context_t c = {HB_SHAPER_DATA_GET (shape_plan), font, font-&gt;face, buffer, features, num_features};</span>
896   hb_ot_shape_internal (&amp;c);
897 
898   return true;
899 }
900 
901 
902 /**
903  * hb_ot_shape_plan_collect_lookups:
904  *
905  * Since: 0.9.7
906  **/
907 void
908 hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
909                                   hb_tag_t         table_tag,
910                                   hb_set_t        *lookup_indexes /* OUT */)
911 {
<a name="89" id="anc89"></a><span class="line-modified">912   /* XXX Does the first part always succeed? */</span>
<span class="line-removed">913   HB_SHAPER_DATA_GET (shape_plan)-&gt;collect_lookups (table_tag, lookup_indexes);</span>
914 }
915 
916 
917 /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
918 static void
919 add_char (hb_font_t          *font,
920           hb_unicode_funcs_t *unicode,
921           hb_bool_t           mirror,
922           hb_codepoint_t      u,
923           hb_set_t           *glyphs)
924 {
925   hb_codepoint_t glyph;
926   if (font-&gt;get_nominal_glyph (u, &amp;glyph))
927     glyphs-&gt;add (glyph);
928   if (mirror)
929   {
930     hb_codepoint_t m = unicode-&gt;mirroring (u);
931     if (m != u &amp;&amp; font-&gt;get_nominal_glyph (m, &amp;glyph))
932       glyphs-&gt;add (glyph);
933   }
934 }
935 
936 
937 /**
938  * hb_ot_shape_glyphs_closure:
939  *
940  * Since: 0.9.2
941  **/
942 void
943 hb_ot_shape_glyphs_closure (hb_font_t          *font,
944                             hb_buffer_t        *buffer,
945                             const hb_feature_t *features,
946                             unsigned int        num_features,
947                             hb_set_t           *glyphs)
948 {
949   const char *shapers[] = {&quot;ot&quot;, nullptr};
950   hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached (font-&gt;face, &amp;buffer-&gt;props,
951                                                              features, num_features, shapers);
952 
953   bool mirror = hb_script_get_horizontal_direction (buffer-&gt;props.script) == HB_DIRECTION_RTL;
954 
955   unsigned int count = buffer-&gt;len;
956   hb_glyph_info_t *info = buffer-&gt;info;
957   for (unsigned int i = 0; i &lt; count; i++)
958     add_char (font, buffer-&gt;unicode, mirror, info[i].codepoint, glyphs);
959 
960   hb_set_t *lookups = hb_set_create ();
961   hb_ot_shape_plan_collect_lookups (shape_plan, HB_OT_TAG_GSUB, lookups);
962   hb_ot_layout_lookups_substitute_closure (font-&gt;face, lookups, glyphs);
963 
964   hb_set_destroy (lookups);
965 
966   hb_shape_plan_destroy (shape_plan);
967 }
<a name="90" id="anc90"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="90" type="hidden" />
</body>
</html>
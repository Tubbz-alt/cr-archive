<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_NAME_TABLE_HH
 28 #define HB_OT_NAME_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-added"> 31 #include &quot;hb-ot-name-language.hh&quot;</span>
<span class="line-added"> 32 #include &quot;hb-aat-layout.hh&quot;</span>
 33 
 34 
 35 namespace OT {
 36 
 37 
<a name="2" id="anc2"></a><span class="line-added"> 38 #define entry_score var.u16[0]</span>
<span class="line-added"> 39 #define entry_index var.u16[1]</span>
<span class="line-added"> 40 </span>
<span class="line-added"> 41 </span>
 42 /*
 43  * name -- Naming
 44  * https://docs.microsoft.com/en-us/typography/opentype/spec/name
 45  */
 46 #define HB_OT_TAG_name HB_TAG(&#39;n&#39;,&#39;a&#39;,&#39;m&#39;,&#39;e&#39;)
 47 
<a name="3" id="anc3"></a><span class="line-added"> 48 #define UNSUPPORTED     42</span>
 49 
 50 struct NameRecord
 51 {
<a name="4" id="anc4"></a><span class="line-modified"> 52   hb_language_t language (hb_face_t *face) const</span>
 53   {
<a name="5" id="anc5"></a><span class="line-modified"> 54     unsigned int p = platformID;</span>
<span class="line-modified"> 55     unsigned int l = languageID;</span>
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57     if (p == 3)</span>
<span class="line-modified"> 58       return _hb_ot_name_language_for_ms_code (l);</span>
<span class="line-modified"> 59 </span>
<span class="line-modified"> 60     if (p == 1)</span>
<span class="line-modified"> 61       return _hb_ot_name_language_for_mac_code (l);</span>
<span class="line-modified"> 62 </span>
<span class="line-modified"> 63     if (p == 0)</span>
<span class="line-modified"> 64       return _hb_aat_language_get (face, l);</span>
<span class="line-modified"> 65 </span>
<span class="line-added"> 66     return HB_LANGUAGE_INVALID;</span>
 67   }
 68 
<a name="6" id="anc6"></a><span class="line-modified"> 69   uint16_t score () const</span>
<span class="line-added"> 70   {</span>
<span class="line-added"> 71     /* Same order as in cmap::find_best_subtable(). */</span>
<span class="line-added"> 72     unsigned int p = platformID;</span>
<span class="line-added"> 73     unsigned int e = encodingID;</span>
<span class="line-added"> 74 </span>
<span class="line-added"> 75     /* 32-bit. */</span>
<span class="line-added"> 76     if (p == 3 &amp;&amp; e == 10) return 0;</span>
<span class="line-added"> 77     if (p == 0 &amp;&amp; e ==  6) return 1;</span>
<span class="line-added"> 78     if (p == 0 &amp;&amp; e ==  4) return 2;</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80     /* 16-bit. */</span>
<span class="line-added"> 81     if (p == 3 &amp;&amp; e ==  1) return 3;</span>
<span class="line-added"> 82     if (p == 0 &amp;&amp; e ==  3) return 4;</span>
<span class="line-added"> 83     if (p == 0 &amp;&amp; e ==  2) return 5;</span>
<span class="line-added"> 84     if (p == 0 &amp;&amp; e ==  1) return 6;</span>
<span class="line-added"> 85     if (p == 0 &amp;&amp; e ==  0) return 7;</span>
<span class="line-added"> 86 </span>
<span class="line-added"> 87     /* Symbol. */</span>
<span class="line-added"> 88     if (p == 3 &amp;&amp; e ==  0) return 8;</span>
<span class="line-added"> 89 </span>
<span class="line-added"> 90     /* We treat all Mac Latin names as ASCII only. */</span>
<span class="line-added"> 91     if (p == 1 &amp;&amp; e ==  0) return 10; /* 10 is magic number :| */</span>
<span class="line-added"> 92 </span>
<span class="line-added"> 93     return UNSUPPORTED;</span>
<span class="line-added"> 94   }</span>
<span class="line-added"> 95 </span>
<span class="line-added"> 96   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
 97   {
 98     TRACE_SANITIZE (this);
 99     /* We can check from base all the way up to the end of string... */
100     return_trace (c-&gt;check_struct (this) &amp;&amp; c-&gt;check_range ((char *) base, (unsigned int) length + offset));
101   }
102 
103   HBUINT16      platformID;     /* Platform ID. */
104   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
105   HBUINT16      languageID;     /* Language ID. */
106   HBUINT16      nameID;         /* Name ID. */
107   HBUINT16      length;         /* String length (in bytes). */
108   HBUINT16      offset;         /* String offset from start of storage area (in bytes). */
109   public:
110   DEFINE_SIZE_STATIC (12);
111 };
112 
<a name="7" id="anc7"></a><span class="line-added">113 static int</span>
<span class="line-added">114 _hb_ot_name_entry_cmp_key (const void *pa, const void *pb)</span>
<span class="line-added">115 {</span>
<span class="line-added">116   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="line-added">117   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="line-added">118 </span>
<span class="line-added">119   /* Compare by name_id, then language. */</span>
<span class="line-added">120 </span>
<span class="line-added">121   if (a-&gt;name_id != b-&gt;name_id)</span>
<span class="line-added">122     return a-&gt;name_id &lt; b-&gt;name_id ? -1 : +1;</span>
<span class="line-added">123 </span>
<span class="line-added">124   if (a-&gt;language == b-&gt;language) return 0;</span>
<span class="line-added">125   if (!a-&gt;language) return -1;</span>
<span class="line-added">126   if (!b-&gt;language) return +1;</span>
<span class="line-added">127   return strcmp (hb_language_to_string (a-&gt;language),</span>
<span class="line-added">128                  hb_language_to_string (b-&gt;language));</span>
<span class="line-added">129 }</span>
<span class="line-added">130 </span>
<span class="line-added">131 static int</span>
<span class="line-added">132 _hb_ot_name_entry_cmp (const void *pa, const void *pb)</span>
<span class="line-added">133 {</span>
<span class="line-added">134   /* Compare by name_id, then language, then score, then index. */</span>
<span class="line-added">135 </span>
<span class="line-added">136   int v = _hb_ot_name_entry_cmp_key (pa, pb);</span>
<span class="line-added">137   if (v)</span>
<span class="line-added">138     return v;</span>
<span class="line-added">139 </span>
<span class="line-added">140   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="line-added">141   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="line-added">142 </span>
<span class="line-added">143   if (a-&gt;entry_score != b-&gt;entry_score)</span>
<span class="line-added">144     return a-&gt;entry_score &lt; b-&gt;entry_score ? -1 : +1;</span>
<span class="line-added">145 </span>
<span class="line-added">146   if (a-&gt;entry_index != b-&gt;entry_index)</span>
<span class="line-added">147     return a-&gt;entry_index &lt; b-&gt;entry_index ? -1 : +1;</span>
<span class="line-added">148 </span>
<span class="line-added">149   return 0;</span>
<span class="line-added">150 }</span>
<span class="line-added">151 </span>
152 struct name
153 {
<a name="8" id="anc8"></a><span class="line-modified">154   static constexpr hb_tag_t tableTag = HB_OT_TAG_name;</span>






















155 
<a name="9" id="anc9"></a><span class="line-modified">156   unsigned int get_size () const</span>
<span class="line-modified">157   { return min_size + count * nameRecordZ.item_size; }</span>
158 
<a name="10" id="anc10"></a><span class="line-modified">159   bool sanitize_records (hb_sanitize_context_t *c) const</span>
<span class="line-added">160   {</span>
161     TRACE_SANITIZE (this);
<a name="11" id="anc11"></a><span class="line-modified">162     const void *string_pool = (this+stringOffset).arrayZ;</span>
163     unsigned int _count = count;
<a name="12" id="anc12"></a><span class="line-added">164     /* Move to run-time?! */</span>
165     for (unsigned int i = 0; i &lt; _count; i++)
<a name="13" id="anc13"></a><span class="line-modified">166       if (!nameRecordZ[i].sanitize (c, string_pool)) return_trace (false);</span>
167     return_trace (true);
168   }
169 
<a name="14" id="anc14"></a><span class="line-modified">170   bool sanitize (hb_sanitize_context_t *c) const</span>
171   {
172     TRACE_SANITIZE (this);
173     return_trace (c-&gt;check_struct (this) &amp;&amp;
174                   likely (format == 0 || format == 1) &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified">175                   c-&gt;check_array (nameRecordZ.arrayZ, count) &amp;&amp;</span>
<span class="line-modified">176                   c-&gt;check_range (this, stringOffset));</span>
177   }
178 
<a name="16" id="anc16"></a><span class="line-added">179   struct accelerator_t</span>
<span class="line-added">180   {</span>
<span class="line-added">181     void init (hb_face_t *face)</span>
<span class="line-added">182     {</span>
<span class="line-added">183       this-&gt;table = hb_sanitize_context_t().reference_table&lt;name&gt; (face);</span>
<span class="line-added">184       assert (this-&gt;table.get_length () &gt;= this-&gt;table-&gt;stringOffset);</span>
<span class="line-added">185       this-&gt;pool = (const char *) (const void *) (this-&gt;table+this-&gt;table-&gt;stringOffset);</span>
<span class="line-added">186       this-&gt;pool_len = this-&gt;table.get_length () - this-&gt;table-&gt;stringOffset;</span>
<span class="line-added">187       const hb_array_t&lt;const NameRecord&gt; all_names (this-&gt;table-&gt;nameRecordZ.arrayZ,</span>
<span class="line-added">188                                                     this-&gt;table-&gt;count);</span>
<span class="line-added">189 </span>
<span class="line-added">190       this-&gt;names.init ();</span>
<span class="line-added">191       this-&gt;names.alloc (all_names.length);</span>
<span class="line-added">192 </span>
<span class="line-added">193       for (unsigned int i = 0; i &lt; all_names.length; i++)</span>
<span class="line-added">194       {</span>
<span class="line-added">195         hb_ot_name_entry_t *entry = this-&gt;names.push ();</span>
<span class="line-added">196 </span>
<span class="line-added">197         entry-&gt;name_id = all_names[i].nameID;</span>
<span class="line-added">198         entry-&gt;language = all_names[i].language (face);</span>
<span class="line-added">199         entry-&gt;entry_score =  all_names[i].score ();</span>
<span class="line-added">200         entry-&gt;entry_index = i;</span>
<span class="line-added">201       }</span>
<span class="line-added">202 </span>
<span class="line-added">203       this-&gt;names.qsort (_hb_ot_name_entry_cmp);</span>
<span class="line-added">204       /* Walk and pick best only for each name_id,language pair,</span>
<span class="line-added">205        * while dropping unsupported encodings. */</span>
<span class="line-added">206       unsigned int j = 0;</span>
<span class="line-added">207       for (unsigned int i = 0; i &lt; this-&gt;names.length; i++)</span>
<span class="line-added">208       {</span>
<span class="line-added">209         if (this-&gt;names[i].entry_score == UNSUPPORTED ||</span>
<span class="line-added">210             this-&gt;names[i].language == HB_LANGUAGE_INVALID)</span>
<span class="line-added">211           continue;</span>
<span class="line-added">212         if (i &amp;&amp;</span>
<span class="line-added">213             this-&gt;names[i - 1].name_id  == this-&gt;names[i].name_id &amp;&amp;</span>
<span class="line-added">214             this-&gt;names[i - 1].language == this-&gt;names[i].language)</span>
<span class="line-added">215           continue;</span>
<span class="line-added">216         this-&gt;names[j++] = this-&gt;names[i];</span>
<span class="line-added">217       }</span>
<span class="line-added">218       this-&gt;names.resize (j);</span>
<span class="line-added">219     }</span>
<span class="line-added">220 </span>
<span class="line-added">221     void fini ()</span>
<span class="line-added">222     {</span>
<span class="line-added">223       this-&gt;names.fini ();</span>
<span class="line-added">224       this-&gt;table.destroy ();</span>
<span class="line-added">225     }</span>
<span class="line-added">226 </span>
<span class="line-added">227     int get_index (hb_ot_name_id_t   name_id,</span>
<span class="line-added">228                           hb_language_t     language,</span>
<span class="line-added">229                           unsigned int     *width=nullptr) const</span>
<span class="line-added">230     {</span>
<span class="line-added">231       const hb_ot_name_entry_t key = {name_id, {0}, language};</span>
<span class="line-added">232       const hb_ot_name_entry_t *entry = (const hb_ot_name_entry_t *)</span>
<span class="line-added">233                                         hb_bsearch (&amp;key,</span>
<span class="line-added">234                                                     (const hb_ot_name_entry_t *) this-&gt;names,</span>
<span class="line-added">235                                                     this-&gt;names.length,</span>
<span class="line-added">236                                                     sizeof (key),</span>
<span class="line-added">237                                                     _hb_ot_name_entry_cmp_key);</span>
<span class="line-added">238       if (!entry)</span>
<span class="line-added">239         return -1;</span>
<span class="line-added">240 </span>
<span class="line-added">241       if (width)</span>
<span class="line-added">242         *width = entry-&gt;entry_score &lt; 10 ? 2 : 1;</span>
<span class="line-added">243 </span>
<span class="line-added">244       return entry-&gt;entry_index;</span>
<span class="line-added">245     }</span>
<span class="line-added">246 </span>
<span class="line-added">247     hb_bytes_t get_name (unsigned int idx) const</span>
<span class="line-added">248     {</span>
<span class="line-added">249       const hb_array_t&lt;const NameRecord&gt; all_names (table-&gt;nameRecordZ.arrayZ, table-&gt;count);</span>
<span class="line-added">250       const NameRecord &amp;record = all_names[idx];</span>
<span class="line-added">251       const hb_bytes_t string_pool (pool, pool_len);</span>
<span class="line-added">252       return string_pool.sub_array (record.offset, record.length);</span>
<span class="line-added">253     }</span>
<span class="line-added">254 </span>
<span class="line-added">255     private:</span>
<span class="line-added">256     const char *pool;</span>
<span class="line-added">257     unsigned int pool_len;</span>
<span class="line-added">258     public:</span>
<span class="line-added">259     hb_blob_ptr_t&lt;name&gt; table;</span>
<span class="line-added">260     hb_vector_t&lt;hb_ot_name_entry_t&gt; names;</span>
<span class="line-added">261   };</span>
<span class="line-added">262 </span>
263   /* We only implement format 0 for now. */
264   HBUINT16      format;                 /* Format selector (=0/1). */
265   HBUINT16      count;                  /* Number of name records. */
<a name="17" id="anc17"></a><span class="line-modified">266   NNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT8&gt; &gt;</span>
<span class="line-modified">267                 stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="line-added">268   UnsizedArrayOf&lt;NameRecord&gt;</span>
<span class="line-added">269                 nameRecordZ;            /* The name records where count is the number of records. */</span>
270   public:
<a name="18" id="anc18"></a><span class="line-modified">271   DEFINE_SIZE_ARRAY (6, nameRecordZ);</span>
272 };
273 
<a name="19" id="anc19"></a><span class="line-added">274 struct name_accelerator_t : name::accelerator_t {};</span>
275 
276 } /* namespace OT */
277 
278 
279 #endif /* HB_OT_NAME_TABLE_HH */
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
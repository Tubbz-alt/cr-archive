<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-debug.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2017  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_DEBUG_HH
 28 #define HB_DEBUG_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-private.hh&quot;</span>


 31 
 32 
 33 #ifndef HB_DEBUG
 34 #define HB_DEBUG 0
 35 #endif
 36 
<a name="2" id="anc2"></a>












































 37 static inline bool
 38 _hb_debug (unsigned int level,
 39            unsigned int max_level)
 40 {
 41   return level &lt; max_level;
 42 }
 43 
 44 #define DEBUG_LEVEL_ENABLED(WHAT, LEVEL) (_hb_debug ((LEVEL), HB_DEBUG_##WHAT))
 45 #define DEBUG_ENABLED(WHAT) (DEBUG_LEVEL_ENABLED (WHAT, 0))
 46 
 47 static inline void
 48 _hb_print_func (const char *func)
 49 {
 50   if (func)
 51   {
 52     unsigned int func_len = strlen (func);
 53     /* Skip &quot;static&quot; */
 54     if (0 == strncmp (func, &quot;static &quot;, 7))
 55       func += 7;
 56     /* Skip &quot;typename&quot; */
 57     if (0 == strncmp (func, &quot;typename &quot;, 9))
 58       func += 9;
 59     /* Skip return type */
 60     const char *space = strchr (func, &#39; &#39;);
 61     if (space)
 62       func = space + 1;
 63     /* Skip parameter list */
 64     const char *paren = strchr (func, &#39;(&#39;);
 65     if (paren)
 66       func_len = paren - func;
 67     fprintf (stderr, &quot;%.*s&quot;, func_len, func);
 68   }
 69 }
 70 
 71 template &lt;int max_level&gt; static inline void
 72 _hb_debug_msg_va (const char *what,
 73                   const void *obj,
 74                   const char *func,
 75                   bool indented,
 76                   unsigned int level,
 77                   int level_dir,
 78                   const char *message,
 79                   va_list ap) HB_PRINTF_FUNC(7, 0);
 80 template &lt;int max_level&gt; static inline void
 81 _hb_debug_msg_va (const char *what,
 82                   const void *obj,
 83                   const char *func,
 84                   bool indented,
 85                   unsigned int level,
 86                   int level_dir,
 87                   const char *message,
 88                   va_list ap)
 89 {
 90   if (!_hb_debug (level, max_level))
 91     return;
 92 
 93   fprintf (stderr, &quot;%-10s&quot;, what ? what : &quot;&quot;);
 94 
 95   if (obj)
 96     fprintf (stderr, &quot;(%*p) &quot;, (unsigned int) (2 * sizeof (void *)), obj);
 97   else
 98     fprintf (stderr, &quot; %*s  &quot;, (unsigned int) (2 * sizeof (void *)), &quot;&quot;);
 99 
100   if (indented) {
101 #define VBAR    &quot;\342\224\202&quot;  /* U+2502 BOX DRAWINGS LIGHT VERTICAL */
102 #define VRBAR   &quot;\342\224\234&quot;  /* U+251C BOX DRAWINGS LIGHT VERTICAL AND RIGHT */
103 #define DLBAR   &quot;\342\225\256&quot;  /* U+256E BOX DRAWINGS LIGHT ARC DOWN AND LEFT */
104 #define ULBAR   &quot;\342\225\257&quot;  /* U+256F BOX DRAWINGS LIGHT ARC UP AND LEFT */
105 #define LBAR    &quot;\342\225\264&quot;  /* U+2574 BOX DRAWINGS LIGHT LEFT */
106     static const char bars[] =
107       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
108       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
109       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
110       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
111       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR;
112     fprintf (stderr, &quot;%2u %s&quot; VRBAR &quot;%s&quot;,
113              level,
114              bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars) - 1, (unsigned int) (sizeof (VBAR) - 1) * level),
115              level_dir ? (level_dir &gt; 0 ? DLBAR : ULBAR) : LBAR);
116   } else
117     fprintf (stderr, &quot;   &quot; VRBAR LBAR);
118 
119   _hb_print_func (func);
120 
121   if (message)
122   {
123     fprintf (stderr, &quot;: &quot;);
124     vfprintf (stderr, message, ap);
125   }
126 
127   fprintf (stderr, &quot;\n&quot;);
128 }
<a name="3" id="anc3"></a><span class="line-modified">129 template &lt;&gt; inline void</span>
130 _hb_debug_msg_va&lt;0&gt; (const char *what HB_UNUSED,
131                      const void *obj HB_UNUSED,
132                      const char *func HB_UNUSED,
133                      bool indented HB_UNUSED,
134                      unsigned int level HB_UNUSED,
135                      int level_dir HB_UNUSED,
136                      const char *message HB_UNUSED,
137                      va_list ap HB_UNUSED) {}
138 
139 template &lt;int max_level&gt; static inline void
140 _hb_debug_msg (const char *what,
141                const void *obj,
142                const char *func,
143                bool indented,
144                unsigned int level,
145                int level_dir,
146                const char *message,
147                ...) HB_PRINTF_FUNC(7, 8);
<a name="4" id="anc4"></a><span class="line-modified">148 template &lt;int max_level&gt; static inline void</span>
149 _hb_debug_msg (const char *what,
150                const void *obj,
151                const char *func,
152                bool indented,
153                unsigned int level,
154                int level_dir,
155                const char *message,
156                ...)
157 {
158   va_list ap;
159   va_start (ap, message);
160   _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, indented, level, level_dir, message, ap);
161   va_end (ap);
162 }
163 template &lt;&gt; inline void
164 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
165                   const void *obj HB_UNUSED,
166                   const char *func HB_UNUSED,
167                   bool indented HB_UNUSED,
168                   unsigned int level HB_UNUSED,
169                   int level_dir HB_UNUSED,
170                   const char *message HB_UNUSED,
171                   ...) HB_PRINTF_FUNC(7, 8);
<a name="5" id="anc5"></a><span class="line-modified">172 template &lt;&gt; inline void</span>
173 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
174                   const void *obj HB_UNUSED,
175                   const char *func HB_UNUSED,
176                   bool indented HB_UNUSED,
177                   unsigned int level HB_UNUSED,
178                   int level_dir HB_UNUSED,
179                   const char *message HB_UNUSED,
180                   ...) {}
181 
182 #define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)       _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    true, (LEVEL), (LEVEL_DIR), __VA_ARGS__)
183 #define DEBUG_MSG(WHAT, OBJ, ...)                               _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    false, 0, 0, __VA_ARGS__)
184 #define DEBUG_MSG_FUNC(WHAT, OBJ, ...)                          _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), HB_FUNC, false, 0, 0, __VA_ARGS__)
185 
186 
187 /*
188  * Printer
189  */
190 
191 template &lt;typename T&gt;
192 struct hb_printer_t {
193   const char *print (const T&amp;) { return &quot;something&quot;; }
194 };
195 
196 template &lt;&gt;
197 struct hb_printer_t&lt;bool&gt; {
198   const char *print (bool v) { return v ? &quot;true&quot; : &quot;false&quot;; }
199 };
200 
201 template &lt;&gt;
202 struct hb_printer_t&lt;hb_void_t&gt; {
203   const char *print (hb_void_t) { return &quot;&quot;; }
204 };
205 
206 
207 /*
208  * Trace
209  */
210 
211 template &lt;typename T&gt;
212 static inline void _hb_warn_no_return (bool returned)
213 {
214   if (unlikely (!returned)) {
215     fprintf (stderr, &quot;OUCH, returned with no call to return_trace().  This is a bug, please report.\n&quot;);
216   }
217 }
218 template &lt;&gt;
219 /*static*/ inline void _hb_warn_no_return&lt;hb_void_t&gt; (bool returned HB_UNUSED)
220 {}
221 
222 template &lt;int max_level, typename ret_t&gt;
223 struct hb_auto_trace_t
224 {
225   explicit inline hb_auto_trace_t (unsigned int *plevel_,
226                                    const char *what_,
227                                    const void *obj_,
228                                    const char *func,
229                                    const char *message,
230                                    ...) HB_PRINTF_FUNC(6, 7)
231                                    : plevel (plevel_), what (what_), obj (obj_), returned (false)
232   {
233     if (plevel) ++*plevel;
234 
235     va_list ap;
236     va_start (ap, message);
237     _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, true, plevel ? *plevel : 0, +1, message, ap);
238     va_end (ap);
239   }
<a name="6" id="anc6"></a><span class="line-modified">240   inline ~hb_auto_trace_t (void)</span>
241   {
242     _hb_warn_no_return&lt;ret_t&gt; (returned);
243     if (!returned) {
244       _hb_debug_msg&lt;max_level&gt; (what, obj, nullptr, true, plevel ? *plevel : 1, -1, &quot; &quot;);
245     }
246     if (plevel) --*plevel;
247   }
248 
<a name="7" id="anc7"></a><span class="line-modified">249   inline ret_t ret (ret_t v, unsigned int line = 0)</span>


250   {
251     if (unlikely (returned)) {
252       fprintf (stderr, &quot;OUCH, double calls to return_trace().  This is a bug, please report.\n&quot;);
253       return v;
254     }
255 
<a name="8" id="anc8"></a><span class="line-modified">256     _hb_debug_msg&lt;max_level&gt; (what, obj, nullptr, true, plevel ? *plevel : 1, -1,</span>
257                               &quot;return %s (line %d)&quot;,
258                               hb_printer_t&lt;ret_t&gt;().print (v), line);
259     if (plevel) --*plevel;
260     plevel = nullptr;
261     returned = true;
262     return v;
263   }
264 
265   private:
266   unsigned int *plevel;
267   const char *what;
268   const void *obj;
269   bool returned;
270 };
271 template &lt;typename ret_t&gt; /* Make sure we don&#39;t use hb_auto_trace_t when not tracing. */
272 struct hb_auto_trace_t&lt;0, ret_t&gt;
273 {
274   explicit inline hb_auto_trace_t (unsigned int *plevel_,
275                                    const char *what_,
276                                    const void *obj_,
277                                    const char *func,
278                                    const char *message,
279                                    ...) HB_PRINTF_FUNC(6, 7) {}
280 
<a name="9" id="anc9"></a><span class="line-modified">281   inline ret_t ret (ret_t v, unsigned int line HB_UNUSED = 0) { return v; }</span>


282 };
283 
284 /* For disabled tracing; optimize out everything.
285  * https://github.com/harfbuzz/harfbuzz/pull/605 */
286 template &lt;typename ret_t&gt;
287 struct hb_no_trace_t {
<a name="10" id="anc10"></a><span class="line-modified">288   inline ret_t ret (ret_t v, unsigned int line HB_UNUSED = 0) { return v; }</span>


289 };
290 
<a name="11" id="anc11"></a><span class="line-modified">291 #define return_trace(RET) return trace.ret (RET, __LINE__)</span>
292 
293 
294 /*
295  * Instances.
296  */
297 
298 #ifndef HB_DEBUG_ARABIC
299 #define HB_DEBUG_ARABIC (HB_DEBUG+0)
300 #endif
301 
302 #ifndef HB_DEBUG_BLOB
303 #define HB_DEBUG_BLOB (HB_DEBUG+0)
304 #endif
305 
306 #ifndef HB_DEBUG_CORETEXT
307 #define HB_DEBUG_CORETEXT (HB_DEBUG+0)
308 #endif
309 
310 #ifndef HB_DEBUG_DIRECTWRITE
311 #define HB_DEBUG_DIRECTWRITE (HB_DEBUG+0)
312 #endif
313 
314 #ifndef HB_DEBUG_FT
315 #define HB_DEBUG_FT (HB_DEBUG+0)
316 #endif
317 
318 #ifndef HB_DEBUG_GET_COVERAGE
319 #define HB_DEBUG_GET_COVERAGE (HB_DEBUG+0)
320 #endif
321 
322 #ifndef HB_DEBUG_OBJECT
323 #define HB_DEBUG_OBJECT (HB_DEBUG+0)
324 #endif
325 
326 #ifndef HB_DEBUG_SHAPE_PLAN
327 #define HB_DEBUG_SHAPE_PLAN (HB_DEBUG+0)
328 #endif
329 
330 #ifndef HB_DEBUG_UNISCRIBE
331 #define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)
332 #endif
333 
334 /*
335  * With tracing.
336  */
337 
338 #ifndef HB_DEBUG_APPLY
339 #define HB_DEBUG_APPLY (HB_DEBUG+0)
340 #endif
341 #if HB_DEBUG_APPLY
342 #define TRACE_APPLY(this) \
343         hb_auto_trace_t&lt;HB_DEBUG_APPLY, bool&gt; trace \
344         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
345          &quot;idx %d gid %u lookup %d&quot;, \
346          c-&gt;buffer-&gt;idx, c-&gt;buffer-&gt;cur().codepoint, (int) c-&gt;lookup_index)
347 #else
348 #define TRACE_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
349 #endif
350 
<a name="12" id="anc12"></a><span class="line-removed">351 #ifndef HB_DEBUG_CLOSURE</span>
<span class="line-removed">352 #define HB_DEBUG_CLOSURE (HB_DEBUG+0)</span>
<span class="line-removed">353 #endif</span>
<span class="line-removed">354 #if HB_DEBUG_CLOSURE</span>
<span class="line-removed">355 #define TRACE_CLOSURE(this) \</span>
<span class="line-removed">356         hb_auto_trace_t&lt;HB_DEBUG_CLOSURE, hb_void_t&gt; trace \</span>
<span class="line-removed">357         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \</span>
<span class="line-removed">358          &quot; &quot;)</span>
<span class="line-removed">359 #else</span>
<span class="line-removed">360 #define TRACE_CLOSURE(this) hb_no_trace_t&lt;hb_void_t&gt; trace HB_UNUSED</span>
<span class="line-removed">361 #endif</span>
<span class="line-removed">362 </span>
<span class="line-removed">363 #ifndef HB_DEBUG_COLLECT_GLYPHS</span>
<span class="line-removed">364 #define HB_DEBUG_COLLECT_GLYPHS (HB_DEBUG+0)</span>
<span class="line-removed">365 #endif</span>
<span class="line-removed">366 #if HB_DEBUG_COLLECT_GLYPHS</span>
<span class="line-removed">367 #define TRACE_COLLECT_GLYPHS(this) \</span>
<span class="line-removed">368         hb_auto_trace_t&lt;HB_DEBUG_COLLECT_GLYPHS, hb_void_t&gt; trace \</span>
<span class="line-removed">369         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \</span>
<span class="line-removed">370          &quot; &quot;)</span>
<span class="line-removed">371 #else</span>
<span class="line-removed">372 #define TRACE_COLLECT_GLYPHS(this) hb_no_trace_t&lt;hb_void_t&gt; trace HB_UNUSED</span>
<span class="line-removed">373 #endif</span>
<span class="line-removed">374 </span>
375 #ifndef HB_DEBUG_SANITIZE
376 #define HB_DEBUG_SANITIZE (HB_DEBUG+0)
377 #endif
378 #if HB_DEBUG_SANITIZE
379 #define TRACE_SANITIZE(this) \
380         hb_auto_trace_t&lt;HB_DEBUG_SANITIZE, bool&gt; trace \
381         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
382          &quot; &quot;);
383 #else
384 #define TRACE_SANITIZE(this) hb_no_trace_t&lt;bool&gt; trace
385 #endif
386 
387 #ifndef HB_DEBUG_SERIALIZE
388 #define HB_DEBUG_SERIALIZE (HB_DEBUG+0)
389 #endif
390 #if HB_DEBUG_SERIALIZE
391 #define TRACE_SERIALIZE(this) \
392         hb_auto_trace_t&lt;HB_DEBUG_SERIALIZE, bool&gt; trace \
393         (&amp;c-&gt;debug_depth, &quot;SERIALIZE&quot;, c, HB_FUNC, \
394          &quot; &quot;);
395 #else
396 #define TRACE_SERIALIZE(this) hb_no_trace_t&lt;bool&gt; trace
397 #endif
398 
399 #ifndef HB_DEBUG_SUBSET
400 #define HB_DEBUG_SUBSET (HB_DEBUG+0)
401 #endif
402 #if HB_DEBUG_SUBSET
403 #define TRACE_SUBSET(this) \
404   hb_auto_trace_t&lt;HB_DEBUG_SUBSET, bool&gt; trace \
405   (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
406    &quot; &quot;);
407 #else
408 #define TRACE_SUBSET(this) hb_no_trace_t&lt;bool&gt; trace
409 #endif
410 
411 #ifndef HB_DEBUG_WOULD_APPLY
412 #define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)
413 #endif
414 #if HB_DEBUG_WOULD_APPLY
415 #define TRACE_WOULD_APPLY(this) \
416         hb_auto_trace_t&lt;HB_DEBUG_WOULD_APPLY, bool&gt; trace \
417         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
418          &quot;%d glyphs&quot;, c-&gt;len);
419 #else
420 #define TRACE_WOULD_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
421 #endif
422 
423 #ifndef HB_DEBUG_DISPATCH
424 #define HB_DEBUG_DISPATCH ( \
425         HB_DEBUG_APPLY + \
<a name="13" id="anc13"></a><span class="line-removed">426         HB_DEBUG_CLOSURE + \</span>
<span class="line-removed">427         HB_DEBUG_COLLECT_GLYPHS + \</span>
428         HB_DEBUG_SANITIZE + \
429         HB_DEBUG_SERIALIZE + \
430   HB_DEBUG_SUBSET + \
431         HB_DEBUG_WOULD_APPLY + \
432         0)
433 #endif
434 #if HB_DEBUG_DISPATCH
435 #define TRACE_DISPATCH(this, format) \
436         hb_auto_trace_t&lt;context_t::max_debug_depth, typename context_t::return_t&gt; trace \
437         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
438          &quot;format %d&quot;, (int) format);
439 #else
440 #define TRACE_DISPATCH(this, format) hb_no_trace_t&lt;typename context_t::return_t&gt; trace
441 #endif
442 
443 
444 #endif /* HB_DEBUG_HH */
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
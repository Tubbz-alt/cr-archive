<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2016  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_POST_TABLE_HH
 28 #define HB_OT_POST_TABLE_HH
 29 
 30 #include &quot;hb-open-type-private.hh&quot;
 31 #include &quot;hb-dsalgs.hh&quot;
 32 #include &quot;hb-subset-plan.hh&quot;
 33 
 34 #define HB_STRING_ARRAY_NAME format1_names
 35 #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
 36 #include &quot;hb-string-array.hh&quot;
 37 #undef HB_STRING_ARRAY_LIST
 38 #undef HB_STRING_ARRAY_NAME
 39 
 40 #define NUM_FORMAT1_NAMES 258
 41 
 42 /*
 43  * post -- PostScript
 44  * https://docs.microsoft.com/en-us/typography/opentype/spec/post
 45  */
 46 #define HB_OT_TAG_post HB_TAG(&#39;p&#39;,&#39;o&#39;,&#39;s&#39;,&#39;t&#39;)
 47 
 48 
 49 namespace OT {
 50 
 51 
 52 struct postV2Tail
 53 {
 54   inline bool sanitize (hb_sanitize_context_t *c) const
 55   {
 56     TRACE_SANITIZE (this);
 57     return_trace (glyphNameIndex.sanitize (c));
 58   }
 59 
 60   ArrayOf&lt;HBUINT16&gt;glyphNameIndex;      /* This is not an offset, but is the
 61                                          * ordinal number of the glyph in &#39;post&#39;
 62                                          * string tables. */
 63   HBUINT8               namesX[VAR];            /* Glyph names with length bytes [variable]
 64                                          * (a Pascal string). */
 65 
 66   DEFINE_SIZE_ARRAY2 (2, glyphNameIndex, namesX);
 67 };
 68 
 69 struct post
 70 {
 71   static const hb_tag_t tableTag = HB_OT_TAG_post;
 72 
 73   inline bool sanitize (hb_sanitize_context_t *c) const
 74   {
 75     TRACE_SANITIZE (this);
 76     if (unlikely (!c-&gt;check_struct (this)))
 77       return_trace (false);
 78     if (version.to_int () == 0x00020000)
 79     {
 80       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*this);
 81       return_trace (v2.sanitize (c));
 82     }
 83     return_trace (true);
 84   }
 85 
 86   inline bool subset (hb_subset_plan_t *plan) const
 87   {
 88     unsigned int post_prime_length;
 89     hb_blob_t *post_blob = OT::Sanitizer&lt;post&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_post));
 90     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::static_size);
 91     post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
 92     hb_blob_destroy (post_blob);
 93 
 94     if (unlikely (!post_prime || post_prime_length != post::static_size))
 95     {
 96       hb_blob_destroy (post_prime_blob);
 97       DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
 98       return false;
 99     }
100 
101     post_prime-&gt;version.major.set (3); // Version 3 does not have any glyph names.
102     bool result = plan-&gt;add_table (HB_OT_TAG_post, post_prime_blob);
103     hb_blob_destroy (post_prime_blob);
104 
105     return result;
106   }
107 
108   struct accelerator_t
109   {
110     inline void init (hb_face_t *face)
111     {
112       index_to_offset.init ();
113 
114       blob = Sanitizer&lt;post&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_post));
115       const post *table = blob-&gt;as&lt;post&gt; ();
116       unsigned int table_length = blob-&gt;length;
117 
118       version = table-&gt;version.to_int ();
119       if (version != 0x00020000)
120         return;
121 
122       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*table);
123 
124       glyphNameIndex = &amp;v2.glyphNameIndex;
125       pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
126 
127       const uint8_t *end = (uint8_t *) table + table_length;
128       for (const uint8_t *data = pool; data &lt; end &amp;&amp; data + *data &lt;= end; data += 1 + *data)
129         index_to_offset.push (data - pool);
130     }
131     inline void fini (void)
132     {
133       index_to_offset.fini ();
134       free (gids_sorted_by_name);
135     }
136 
137     inline bool get_glyph_name (hb_codepoint_t glyph,
138                                 char *buf, unsigned int buf_len) const
139     {
140       hb_bytes_t s = find_glyph_name (glyph);
141       if (!s.len)
142         return false;
143       if (!buf_len)
144         return true;
145       if (buf_len &lt;= s.len) /* What to do with truncation? Returning false for now. */
146         return false;
147       strncpy (buf, s.bytes, s.len);
148       buf[s.len] = &#39;\0&#39;;
149       return true;
150     }
151 
152     inline bool get_glyph_from_name (const char *name, int len,
153                                      hb_codepoint_t *glyph) const
154     {
155       unsigned int count = get_glyph_count ();
156       if (unlikely (!count))
157         return false;
158 
159       if (len &lt; 0)
160         len = strlen (name);
161 
162       if (unlikely (!len))
163         return false;
164 
165     retry:
166       uint16_t *gids = (uint16_t *) hb_atomic_ptr_get (&amp;gids_sorted_by_name);
167 
168       if (unlikely (!gids))
169       {
170         gids = (uint16_t *) malloc (count * sizeof (gids[0]));
171         if (unlikely (!gids))
172           return false; /* Anything better?! */
173 
174         for (unsigned int i = 0; i &lt; count; i++)
175           gids[i] = i;
176         hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
177 
178         if (!hb_atomic_ptr_cmpexch (&amp;gids_sorted_by_name, nullptr, gids)) {
179           free (gids);
180           goto retry;
181         }
182       }
183 
184       hb_bytes_t st (name, len);
185       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (&amp;st, gids, count, sizeof (gids[0]), cmp_key, (void *) this);
186       if (gid)
187       {
188         *glyph = *gid;
189         return true;
190       }
191 
192       return false;
193     }
194 
195     protected:
196 
197     inline unsigned int get_glyph_count (void) const
198     {
199       if (version == 0x00010000)
200         return NUM_FORMAT1_NAMES;
201 
202       if (version == 0x00020000)
203         return glyphNameIndex-&gt;len;
204 
205       return 0;
206     }
207 
208     static inline int cmp_gids (const void *pa, const void *pb, void *arg)
209     {
210       const accelerator_t *thiz = (const accelerator_t *) arg;
211       uint16_t a = * (const uint16_t *) pa;
212       uint16_t b = * (const uint16_t *) pb;
213       return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
214     }
215 
216     static inline int cmp_key (const void *pk, const void *po, void *arg)
217     {
218       const accelerator_t *thiz = (const accelerator_t *) arg;
219       const hb_bytes_t *key = (const hb_bytes_t *) pk;
220       uint16_t o = * (const uint16_t *) po;
221       return thiz-&gt;find_glyph_name (o).cmp (*key);
222     }
223 
224     inline hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const
225     {
226       if (version == 0x00010000)
227       {
228         if (glyph &gt;= NUM_FORMAT1_NAMES)
229           return hb_bytes_t ();
230 
231         return format1_names (glyph);
232       }
233 
234       if (version != 0x00020000 || glyph &gt;= glyphNameIndex-&gt;len)
235         return hb_bytes_t ();
236 
237       unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
238       if (index &lt; NUM_FORMAT1_NAMES)
239         return format1_names (index);
240       index -= NUM_FORMAT1_NAMES;
241 
242       if (index &gt;= index_to_offset.len)
243         return hb_bytes_t ();
244       unsigned int offset = index_to_offset.arrayZ[index];
245 
246       const uint8_t *data = pool + offset;
247       unsigned int name_length = *data;
248       data++;
249 
250       return hb_bytes_t ((const char *) data, name_length);
251     }
252 
253     private:
254     hb_blob_t *blob;
255     uint32_t version;
256     const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
257     hb_vector_t&lt;uint32_t, 1&gt; index_to_offset;
258     const uint8_t *pool;
259     mutable uint16_t *gids_sorted_by_name;
260   };
261 
262   public:
263   FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
264                                          * 0x00020000 for version 2.0
265                                          * 0x00025000 for version 2.5 (deprecated)
266                                          * 0x00030000 for version 3.0 */
267   Fixed         italicAngle;            /* Italic angle in counter-clockwise degrees
268                                          * from the vertical. Zero for upright text,
269                                          * negative for text that leans to the right
270                                          * (forward). */
271   FWORD         underlinePosition;      /* This is the suggested distance of the top
272                                          * of the underline from the baseline
273                                          * (negative values indicate below baseline).
274                                          * The PostScript definition of this FontInfo
275                                          * dictionary key (the y coordinate of the
276                                          * center of the stroke) is not used for
277                                          * historical reasons. The value of the
278                                          * PostScript key may be calculated by
279                                          * subtracting half the underlineThickness
280                                          * from the value of this field. */
281   FWORD         underlineThickness;     /* Suggested values for the underline
282                                            thickness. */
283   HBUINT32      isFixedPitch;           /* Set to 0 if the font is proportionally
284                                          * spaced, non-zero if the font is not
285                                          * proportionally spaced (i.e. monospaced). */
286   HBUINT32      minMemType42;           /* Minimum memory usage when an OpenType font
287                                          * is downloaded. */
288   HBUINT32      maxMemType42;           /* Maximum memory usage when an OpenType font
289                                          * is downloaded. */
290   HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
291                                          * is downloaded as a Type 1 font. */
292   HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
293                                          * is downloaded as a Type 1 font. */
294 /*postV2Tail    v2[VAR];*/
295   DEFINE_SIZE_STATIC (32);
296 };
297 
298 } /* namespace OT */
299 
300 
301 #endif /* HB_OT_POST_TABLE_HH */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod, Roderick Sheeter
 25  */
 26 
 27 #ifndef HB_OT_HMTX_TABLE_HH
 28 #define HB_OT_HMTX_TABLE_HH
 29 
 30 #include &quot;hb-open-type-private.hh&quot;
 31 #include &quot;hb-ot-hhea-table.hh&quot;
 32 #include &quot;hb-ot-os2-table.hh&quot;
 33 #include &quot;hb-ot-var-hvar-table.hh&quot;
 34 #include &quot;hb-subset-plan.hh&quot;
 35 
 36 /*
 37  * hmtx -- Horizontal Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx
 39  * vmtx -- Vertical Metrics
 40  * https://docs.microsoft.com/en-us/typography/opentype/spec/vmtx
 41  */
 42 #define HB_OT_TAG_hmtx HB_TAG(&#39;h&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 43 #define HB_OT_TAG_vmtx HB_TAG(&#39;v&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 44 
 45 
 46 namespace OT {
 47 
 48 
 49 struct LongMetric
 50 {
 51   UFWORD        advance; /* Advance width/height. */
 52   FWORD         lsb; /* Leading (left/top) side bearing. */
 53   public:
 54   DEFINE_SIZE_STATIC (4);
 55 };
 56 
 57 template &lt;typename T, typename H&gt;
 58 struct hmtxvmtx
 59 {
 60   inline bool sanitize (hb_sanitize_context_t *c) const
 61   {
 62     TRACE_SANITIZE (this);
 63     /* We don&#39;t check for anything specific here.  The users of the
 64      * struct do all the hard work... */
 65     return_trace (true);
 66   }
 67 
 68 
 69   inline bool subset_update_header (hb_subset_plan_t *plan,
 70                                     unsigned int num_hmetrics) const
 71   {
 72     hb_blob_t *src_blob = OT::Sanitizer&lt;H&gt; ().sanitize (plan-&gt;source-&gt;reference_table (H::tableTag));
 73     hb_blob_t *dest_blob = hb_blob_copy_writable_or_fail(src_blob);
 74     hb_blob_destroy (src_blob);
 75 
 76     if (unlikely (!dest_blob)) {
 77       return false;
 78     }
 79 
 80     unsigned int length;
 81     H *table = (H *) hb_blob_get_data (dest_blob, &amp;length);
 82     table-&gt;numberOfLongMetrics.set (num_hmetrics);
 83 
 84     bool result = plan-&gt;add_table (H::tableTag, dest_blob);
 85     hb_blob_destroy (dest_blob);
 86 
 87     return result;
 88   }
 89 
 90   inline bool subset (hb_subset_plan_t *plan) const
 91   {
 92     typename T::accelerator_t _mtx;
 93     _mtx.init (plan-&gt;source);
 94 
 95     /* All the trailing glyphs with the same advance can use one LongMetric
 96      * and just keep LSB */
 97     hb_vector_t&lt;hb_codepoint_t&gt; &amp;gids = plan-&gt;glyphs;
 98     unsigned int num_advances = gids.len;
 99     unsigned int last_advance = _mtx.get_advance (gids[num_advances - 1]);
100     while (num_advances &gt; 1
101         &amp;&amp; last_advance == _mtx.get_advance (gids[num_advances - 2]))
102     {
103       num_advances--;
104     }
105 
106     /* alloc the new table */
107     size_t dest_sz = num_advances * 4
108                   + (gids.len - num_advances) * 2;
109     void *dest = (void *) malloc (dest_sz);
110     if (unlikely (!dest))
111     {
112       return false;
113     }
114     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in src has %d advances, %d lsbs&quot;, HB_UNTAG(T::tableTag), _mtx.num_advances, _mtx.num_metrics - _mtx.num_advances);
115     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in dest has %d advances, %d lsbs, %u bytes&quot;, HB_UNTAG(T::tableTag), num_advances, gids.len - num_advances, (unsigned int) dest_sz);
116 
117     const char *source_table = hb_blob_get_data (_mtx.blob, nullptr);
118     // Copy everything over
119     LongMetric * old_metrics = (LongMetric *) source_table;
120     FWORD *lsbs = (FWORD *) (old_metrics + _mtx.num_advances);
121     char * dest_pos = (char *) dest;
122 
123     bool failed = false;
124     for (unsigned int i = 0; i &lt; gids.len; i++)
125     {
126       /* the last metric or the one for gids[i] */
127       LongMetric *src_metric = old_metrics + MIN ((hb_codepoint_t) _mtx.num_advances - 1, gids[i]);
128       if (gids[i] &lt; _mtx.num_advances)
129       {
130         /* src is a LongMetric */
131         if (i &lt; num_advances)
132         {
133           /* dest is a LongMetric, copy it */
134           *((LongMetric *) dest_pos) = *src_metric;
135         }
136         else
137         {
138           /* dest just lsb */
139           *((FWORD *) dest_pos) = src_metric-&gt;lsb;
140         }
141       }
142       else
143       {
144         if (gids[i] &gt;= _mtx.num_metrics)
145         {
146           DEBUG_MSG(SUBSET, nullptr, &quot;gid %d is &gt;= number of source metrics %d&quot;,
147                     gids[i], _mtx.num_metrics);
148           failed = true;
149           break;
150         }
151         FWORD src_lsb = *(lsbs + gids[i] - _mtx.num_advances);
152         if (i &lt; num_advances)
153         {
154           /* dest needs a full LongMetric */
155           LongMetric *metric = (LongMetric *)dest_pos;
156           metric-&gt;advance = src_metric-&gt;advance;
157           metric-&gt;lsb = src_lsb;
158         }
159         else
160         {
161           /* dest just needs an lsb */
162           *((FWORD *) dest_pos) = src_lsb;
163         }
164       }
165       dest_pos += (i &lt; num_advances ? 4 : 2);
166     }
167     _mtx.fini ();
168 
169     // Amend header num hmetrics
170     if (failed || unlikely (!subset_update_header (plan, num_advances)))
171     {
172       free (dest);
173       return false;
174     }
175 
176     hb_blob_t *result = hb_blob_create ((const char *)dest,
177                                         dest_sz,
178                                         HB_MEMORY_MODE_READONLY,
179                                         dest,
180                                         free);
181     bool success = plan-&gt;add_table (T::tableTag, result);
182     hb_blob_destroy (result);
183     return success;
184   }
185 
186   struct accelerator_t
187   {
188     friend struct hmtxvmtx;
189 
190     inline void init (hb_face_t *face,
191                       unsigned int default_advance_ = 0)
192     {
193       default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);
194 
195       bool got_font_extents = false;
196       if (T::os2Tag)
197       {
198         hb_blob_t *os2_blob = Sanitizer&lt;os2&gt; ().sanitize (face-&gt;reference_table (T::os2Tag));
199         const os2 *os2_table = os2_blob-&gt;as&lt;os2&gt; ();
200 #define USE_TYPO_METRICS (1u&lt;&lt;7)
201         if (0 != (os2_table-&gt;fsSelection &amp; USE_TYPO_METRICS))
202         {
203           ascender = os2_table-&gt;sTypoAscender;
204           descender = os2_table-&gt;sTypoDescender;
205           line_gap = os2_table-&gt;sTypoLineGap;
206           got_font_extents = (ascender | descender) != 0;
207         }
208         hb_blob_destroy (os2_blob);
209       }
210 
211       hb_blob_t *_hea_blob = Sanitizer&lt;H&gt; ().sanitize (face-&gt;reference_table (H::tableTag));
212       const H *_hea_table = _hea_blob-&gt;as&lt;H&gt; ();
213       num_advances = _hea_table-&gt;numberOfLongMetrics;
214       if (!got_font_extents)
215       {
216         ascender = _hea_table-&gt;ascender;
217         descender = _hea_table-&gt;descender;
218         line_gap = _hea_table-&gt;lineGap;
219         got_font_extents = (ascender | descender) != 0;
220       }
221       hb_blob_destroy (_hea_blob);
222 
223       has_font_extents = got_font_extents;
224 
225       blob = Sanitizer&lt;hmtxvmtx&gt; ().sanitize (face-&gt;reference_table (T::tableTag));
226 
227       /* Cap num_metrics() and num_advances() based on table length. */
228       unsigned int len = hb_blob_get_length (blob);
229       if (unlikely (num_advances * 4 &gt; len))
230         num_advances = len / 4;
231       num_metrics = num_advances + (len - 4 * num_advances) / 2;
232 
233       /* We MUST set num_metrics to zero if num_advances is zero.
234        * Our get_advance() depends on that. */
235       if (unlikely (!num_advances))
236       {
237         num_metrics = num_advances = 0;
238         hb_blob_destroy (blob);
239         blob = hb_blob_get_empty ();
240       }
241       table = blob-&gt;as&lt;hmtxvmtx&gt; ();
242 
243       var_blob = Sanitizer&lt;HVARVVAR&gt; ().sanitize (face-&gt;reference_table (T::variationsTag));
244       var_table = var_blob-&gt;as&lt;HVARVVAR&gt; ();
245     }
246 
247     inline void fini (void)
248     {
249       hb_blob_destroy (blob);
250       hb_blob_destroy (var_blob);
251     }
252 
253     inline unsigned int get_advance (hb_codepoint_t  glyph) const
254     {
255       if (unlikely (glyph &gt;= num_metrics))
256       {
257         /* If num_metrics is zero, it means we don&#39;t have the metrics table
258          * for this direction: return default advance.  Otherwise, it means that the
259          * glyph index is out of bound: return zero. */
260         if (num_metrics)
261           return 0;
262         else
263           return default_advance;
264       }
265 
266       return table-&gt;longMetric[MIN (glyph, (uint32_t) num_advances - 1)].advance;
267     }
268 
269     inline unsigned int get_advance (hb_codepoint_t  glyph,
270                                      hb_font_t      *font) const
271     {
272       unsigned int advance = get_advance (glyph);
273       if (likely(glyph &lt; num_metrics))
274       {
275         advance += (font-&gt;num_coords ? var_table-&gt;get_advance_var (glyph, font-&gt;coords, font-&gt;num_coords) : 0); // TODO Optimize?!
276       }
277       return advance;
278     }
279 
280     public:
281     bool has_font_extents;
282     unsigned short ascender;
283     unsigned short descender;
284     unsigned short line_gap;
285 
286     protected:
287     unsigned int num_metrics;
288     unsigned int num_advances;
289     unsigned int default_advance;
290 
291     private:
292     const hmtxvmtx *table;
293     hb_blob_t *blob;
294     const HVARVVAR *var_table;
295     hb_blob_t *var_blob;
296   };
297 
298   protected:
299   LongMetric    longMetric[VAR];        /* Paired advance width and leading
300                                          * bearing values for each glyph. The
301                                          * value numOfHMetrics comes from
302                                          * the &#39;hhea&#39; table. If the font is
303                                          * monospaced, only one entry need
304                                          * be in the array, but that entry is
305                                          * required. The last entry applies to
306                                          * all subsequent glyphs. */
307 /*FWORD         leadingBearingX[VAR];*/ /* Here the advance is assumed
308                                          * to be the same as the advance
309                                          * for the last entry above. The
310                                          * number of entries in this array is
311                                          * derived from numGlyphs (from &#39;maxp&#39;
312                                          * table) minus numberOfLongMetrics.
313                                          * This generally is used with a run
314                                          * of monospaced glyphs (e.g., Kanji
315                                          * fonts or Courier fonts). Only one
316                                          * run is allowed and it must be at
317                                          * the end. This allows a monospaced
318                                          * font to vary the side bearing
319                                          * values for each glyph. */
320   public:
321   DEFINE_SIZE_ARRAY (0, longMetric);
322 };
323 
324 struct hmtx : hmtxvmtx&lt;hmtx, hhea&gt; {
325   static const hb_tag_t tableTag        = HB_OT_TAG_hmtx;
326   static const hb_tag_t variationsTag   = HB_OT_TAG_HVAR;
327   static const hb_tag_t os2Tag          = HB_OT_TAG_os2;
328 };
329 struct vmtx : hmtxvmtx&lt;vmtx, vhea&gt; {
330   static const hb_tag_t tableTag        = HB_OT_TAG_vmtx;
331   static const hb_tag_t variationsTag   = HB_OT_TAG_VVAR;
332   static const hb_tag_t os2Tag          = HB_TAG_NONE;
333 };
334 
335 } /* namespace OT */
336 
337 
338 #endif /* HB_OT_HMTX_TABLE_HH */
    </pre>
  </body>
</html>
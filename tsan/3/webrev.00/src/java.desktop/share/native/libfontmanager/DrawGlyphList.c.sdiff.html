<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/DrawGlyphList.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libawt/java2d/loops/LoopMacros.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HBShaper.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/DrawGlyphList.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
515     if (imagePtrs == NULL) {
516         free(gbv);
517         return (GlyphBlitVector*)NULL;
518     }
519 
520     /* The position of the start of the text is adjusted up so
521      * that we can round it to an integral pixel position for a
522      * bitmap glyph or non-subpixel positioning, and round it to an
523      * integral subpixel position for that case, hence 0.5/3 = 0.166667
524      * Presently subPixPos means FM, and FM disables embedded bitmaps
525      * Therefore if subPixPos is true we should never get embedded bitmaps
526      * and the glyphlist will be homogenous. This test and the position
527      * adjustments will need to be per glyph once this case becomes
528      * heterogenous.
529      * Also set subPixPos=false if detect a B&amp;W bitmap as we only
530      * need to test that on a per glyph basis once the list becomes
531      * heterogenous
532      */
533     if (subPixPos &amp;&amp; len &gt; 0) {
534         ginfo = (GlyphInfo*)imagePtrs[0];






535         /* rowBytes==width tests if its a B&amp;W or LCD glyph */
536         if (ginfo-&gt;width == ginfo-&gt;rowBytes) {
537             subPixPos = JNI_FALSE;
538         }
539     }
540     if (subPixPos) {
541         x += 0.1666667f;
542         y += 0.1666667f;
543     } else {
544         x += 0.5f;
545         y += 0.5f;
546     }
547 
548      if (glyphPositions) {
549         int n = -1;
550 
551         positions =
552           (*env)-&gt;GetPrimitiveArrayCritical(env, glyphPositions, NULL);
553         if (positions == NULL) {
554             (*env)-&gt;ReleasePrimitiveArrayCritical(env, glyphImages,
555                                                   imagePtrs, JNI_ABORT);
556             free(gbv);
557             return (GlyphBlitVector*)NULL;
558         }
559 
560         for (g=0; g&lt;len; g++) {
561             jfloat px, py;
562 
563             ginfo = (GlyphInfo*)imagePtrs[g];






564             gbv-&gt;glyphs[g].glyphInfo = ginfo;
565             gbv-&gt;glyphs[g].pixels = ginfo-&gt;image;
566             gbv-&gt;glyphs[g].width = ginfo-&gt;width;
567             gbv-&gt;glyphs[g].rowBytes = ginfo-&gt;rowBytes;
568             gbv-&gt;glyphs[g].height = ginfo-&gt;height;
569 
570             px = x + positions[++n];
571             py = y + positions[++n];
572 
573             /*
574              * Subpixel positioning may be requested for LCD text.
575              *
576              * Subpixel positioning can take place only in the direction in
577              * which the subpixels increase the resolution.
578              * So this is useful for the typical case of vertical stripes
579              * increasing the resolution in the direction of the glyph
580              * advances - ie typical horizontally laid out text.
581              * If the subpixel stripes are horizontal, subpixel positioning
582              * can take place only in the vertical direction, which isn&#39;t
583              * as useful - you would have to be drawing rotated text on
</pre>
<hr />
<pre>
619                      * which the glyph will be positioned by one pixel to the
620                      * left and adjust the position in the glyph image row
621                      * from which to extract the data
622                      * Every glyph image row has 2 bytes padding
623                      * on the right to account for this.
624                      */
625                     gbv-&gt;glyphs[g].rowBytesOffset = 3-frac;
626                     gbv-&gt;glyphs[g].x += 1;
627                 }
628             } else {
629                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, px + ginfo-&gt;topLeftX);
630                 gbv-&gt;glyphs[g].rowBytesOffset = 0;
631             }
632             FLOOR_ASSIGN(gbv-&gt;glyphs[g].y, py + ginfo-&gt;topLeftY);
633         }
634         (*env)-&gt;ReleasePrimitiveArrayCritical(env,glyphPositions,
635                                               positions, JNI_ABORT);
636     } else {
637         for (g=0; g&lt;len; g++) {
638             ginfo = (GlyphInfo*)imagePtrs[g];






639             gbv-&gt;glyphs[g].glyphInfo = ginfo;
640             gbv-&gt;glyphs[g].pixels = ginfo-&gt;image;
641             gbv-&gt;glyphs[g].width = ginfo-&gt;width;
642             gbv-&gt;glyphs[g].rowBytes = ginfo-&gt;rowBytes;
643             gbv-&gt;glyphs[g].height = ginfo-&gt;height;
644 
645             if (subPixPos) {
646                 int frac;
647                 float pos = x + ginfo-&gt;topLeftX;
648                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, pos);
649                 frac = (int)((pos - gbv-&gt;glyphs[g].x)*3);
650                 if (frac == 0) {
651                     gbv-&gt;glyphs[g].rowBytesOffset = 0;
652                 } else {
653                     gbv-&gt;glyphs[g].rowBytesOffset = 3-frac;
654                     gbv-&gt;glyphs[g].x += 1;
655                 }
656             } else {
657                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, x + ginfo-&gt;topLeftX);
658                 gbv-&gt;glyphs[g].rowBytesOffset = 0;
</pre>
</td>
<td>
<hr />
<pre>
515     if (imagePtrs == NULL) {
516         free(gbv);
517         return (GlyphBlitVector*)NULL;
518     }
519 
520     /* The position of the start of the text is adjusted up so
521      * that we can round it to an integral pixel position for a
522      * bitmap glyph or non-subpixel positioning, and round it to an
523      * integral subpixel position for that case, hence 0.5/3 = 0.166667
524      * Presently subPixPos means FM, and FM disables embedded bitmaps
525      * Therefore if subPixPos is true we should never get embedded bitmaps
526      * and the glyphlist will be homogenous. This test and the position
527      * adjustments will need to be per glyph once this case becomes
528      * heterogenous.
529      * Also set subPixPos=false if detect a B&amp;W bitmap as we only
530      * need to test that on a per glyph basis once the list becomes
531      * heterogenous
532      */
533     if (subPixPos &amp;&amp; len &gt; 0) {
534         ginfo = (GlyphInfo*)imagePtrs[0];
<span class="line-added">535         if (ginfo == NULL) {</span>
<span class="line-added">536             (*env)-&gt;ReleasePrimitiveArrayCritical(env, glyphImages,</span>
<span class="line-added">537                                                   imagePtrs, JNI_ABORT);</span>
<span class="line-added">538             free(gbv);</span>
<span class="line-added">539             return (GlyphBlitVector*)NULL;</span>
<span class="line-added">540         }</span>
541         /* rowBytes==width tests if its a B&amp;W or LCD glyph */
542         if (ginfo-&gt;width == ginfo-&gt;rowBytes) {
543             subPixPos = JNI_FALSE;
544         }
545     }
546     if (subPixPos) {
547         x += 0.1666667f;
548         y += 0.1666667f;
549     } else {
550         x += 0.5f;
551         y += 0.5f;
552     }
553 
554      if (glyphPositions) {
555         int n = -1;
556 
557         positions =
558           (*env)-&gt;GetPrimitiveArrayCritical(env, glyphPositions, NULL);
559         if (positions == NULL) {
560             (*env)-&gt;ReleasePrimitiveArrayCritical(env, glyphImages,
561                                                   imagePtrs, JNI_ABORT);
562             free(gbv);
563             return (GlyphBlitVector*)NULL;
564         }
565 
566         for (g=0; g&lt;len; g++) {
567             jfloat px, py;
568 
569             ginfo = (GlyphInfo*)imagePtrs[g];
<span class="line-added">570             if (ginfo == NULL) {</span>
<span class="line-added">571                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, glyphImages,</span>
<span class="line-added">572                                                   imagePtrs, JNI_ABORT);</span>
<span class="line-added">573                 free(gbv);</span>
<span class="line-added">574                 return (GlyphBlitVector*)NULL;</span>
<span class="line-added">575             }</span>
576             gbv-&gt;glyphs[g].glyphInfo = ginfo;
577             gbv-&gt;glyphs[g].pixels = ginfo-&gt;image;
578             gbv-&gt;glyphs[g].width = ginfo-&gt;width;
579             gbv-&gt;glyphs[g].rowBytes = ginfo-&gt;rowBytes;
580             gbv-&gt;glyphs[g].height = ginfo-&gt;height;
581 
582             px = x + positions[++n];
583             py = y + positions[++n];
584 
585             /*
586              * Subpixel positioning may be requested for LCD text.
587              *
588              * Subpixel positioning can take place only in the direction in
589              * which the subpixels increase the resolution.
590              * So this is useful for the typical case of vertical stripes
591              * increasing the resolution in the direction of the glyph
592              * advances - ie typical horizontally laid out text.
593              * If the subpixel stripes are horizontal, subpixel positioning
594              * can take place only in the vertical direction, which isn&#39;t
595              * as useful - you would have to be drawing rotated text on
</pre>
<hr />
<pre>
631                      * which the glyph will be positioned by one pixel to the
632                      * left and adjust the position in the glyph image row
633                      * from which to extract the data
634                      * Every glyph image row has 2 bytes padding
635                      * on the right to account for this.
636                      */
637                     gbv-&gt;glyphs[g].rowBytesOffset = 3-frac;
638                     gbv-&gt;glyphs[g].x += 1;
639                 }
640             } else {
641                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, px + ginfo-&gt;topLeftX);
642                 gbv-&gt;glyphs[g].rowBytesOffset = 0;
643             }
644             FLOOR_ASSIGN(gbv-&gt;glyphs[g].y, py + ginfo-&gt;topLeftY);
645         }
646         (*env)-&gt;ReleasePrimitiveArrayCritical(env,glyphPositions,
647                                               positions, JNI_ABORT);
648     } else {
649         for (g=0; g&lt;len; g++) {
650             ginfo = (GlyphInfo*)imagePtrs[g];
<span class="line-added">651             if (ginfo == NULL) {</span>
<span class="line-added">652                 (*env)-&gt;ReleasePrimitiveArrayCritical(env, glyphImages,</span>
<span class="line-added">653                                                   imagePtrs, JNI_ABORT);</span>
<span class="line-added">654                 free(gbv);</span>
<span class="line-added">655                 return (GlyphBlitVector*)NULL;</span>
<span class="line-added">656             }</span>
657             gbv-&gt;glyphs[g].glyphInfo = ginfo;
658             gbv-&gt;glyphs[g].pixels = ginfo-&gt;image;
659             gbv-&gt;glyphs[g].width = ginfo-&gt;width;
660             gbv-&gt;glyphs[g].rowBytes = ginfo-&gt;rowBytes;
661             gbv-&gt;glyphs[g].height = ginfo-&gt;height;
662 
663             if (subPixPos) {
664                 int frac;
665                 float pos = x + ginfo-&gt;topLeftX;
666                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, pos);
667                 frac = (int)((pos - gbv-&gt;glyphs[g].x)*3);
668                 if (frac == 0) {
669                     gbv-&gt;glyphs[g].rowBytesOffset = 0;
670                 } else {
671                     gbv-&gt;glyphs[g].rowBytesOffset = 3-frac;
672                     gbv-&gt;glyphs[g].x += 1;
673                 }
674             } else {
675                 FLOOR_ASSIGN(gbv-&gt;glyphs[g].x, x + ginfo-&gt;topLeftX);
676                 gbv-&gt;glyphs[g].rowBytesOffset = 0;
</pre>
</td>
</tr>
</table>
<center><a href="../libawt/java2d/loops/LoopMacros.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="HBShaper.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-map.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2009,2010  Red Hat, Inc.
  3  * Copyright © 2010,2011,2013  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #include &quot;hb-ot-map-private.hh&quot;</span>
<span class="line-modified"> 30 </span>
<span class="line-modified"> 31 #include &quot;hb-ot-layout-private.hh&quot;</span>
 32 
 33 
 34 void hb_ot_map_t::collect_lookups (unsigned int table_index, hb_set_t *lookups_out) const
 35 {
<a name="2" id="anc2"></a><span class="line-modified"> 36   for (unsigned int i = 0; i &lt; lookups[table_index].len; i++)</span>
 37     hb_set_add (lookups_out, lookups[table_index][i].index);
 38 }
 39 
 40 
 41 hb_ot_map_builder_t::hb_ot_map_builder_t (hb_face_t *face_,
 42                                           const hb_segment_properties_t *props_)
 43 {
 44   memset (this, 0, sizeof (*this));
 45 
 46   feature_infos.init ();
 47   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 48     stages[table_index].init ();
 49 
 50   face = face_;
 51   props = *props_;
 52 
 53 
 54   /* Fetch script/language indices for GSUB/GPOS.  We need these later to skip
 55    * features not available in either table and not waste precious bits for them. */
 56 
<a name="3" id="anc3"></a><span class="line-modified"> 57   hb_tag_t script_tags[3] = {HB_TAG_NONE, HB_TAG_NONE, HB_TAG_NONE};</span>
<span class="line-modified"> 58   hb_tag_t language_tag;</span>


 59 
<a name="4" id="anc4"></a><span class="line-modified"> 60   hb_ot_tags_from_script (props.script, &amp;script_tags[0], &amp;script_tags[1]);</span>
<span class="line-removed"> 61   language_tag = hb_ot_tag_from_language (props.language);</span>
 62 
 63   for (unsigned int table_index = 0; table_index &lt; 2; table_index++) {
 64     hb_tag_t table_tag = table_tags[table_index];
<a name="5" id="anc5"></a><span class="line-modified"> 65     found_script[table_index] = (bool) hb_ot_layout_table_choose_script (face, table_tag, script_tags, &amp;script_index[table_index], &amp;chosen_script[table_index]);</span>
<span class="line-modified"> 66     hb_ot_layout_script_find_language (face, table_tag, script_index[table_index], language_tag, &amp;language_index[table_index]);</span>
 67   }
 68 }
 69 
<a name="6" id="anc6"></a><span class="line-modified"> 70 hb_ot_map_builder_t::~hb_ot_map_builder_t (void)</span>
 71 {
 72   feature_infos.fini ();
 73   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
 74     stages[table_index].fini ();
 75 }
 76 
<a name="7" id="anc7"></a><span class="line-modified"> 77 void hb_ot_map_builder_t::add_feature (hb_tag_t tag, unsigned int value,</span>
<span class="line-modified"> 78                                        hb_ot_map_feature_flags_t flags)</span>

 79 {
<a name="8" id="anc8"></a><span class="line-removed"> 80   feature_info_t *info = feature_infos.push();</span>
 81   if (unlikely (!tag)) return;
<a name="9" id="anc9"></a>
 82   info-&gt;tag = tag;
<a name="10" id="anc10"></a><span class="line-modified"> 83   info-&gt;seq = feature_infos.len;</span>
 84   info-&gt;max_value = value;
 85   info-&gt;flags = flags;
 86   info-&gt;default_value = (flags &amp; F_GLOBAL) ? value : 0;
 87   info-&gt;stage[0] = current_stage[0];
 88   info-&gt;stage[1] = current_stage[1];
 89 }
 90 
 91 void
 92 hb_ot_map_builder_t::add_lookups (hb_ot_map_t  &amp;m,
 93                                   unsigned int  table_index,
 94                                   unsigned int  feature_index,
 95                                   unsigned int  variations_index,
 96                                   hb_mask_t     mask,
 97                                   bool          auto_zwnj,
<a name="11" id="anc11"></a><span class="line-modified"> 98                                   bool          auto_zwj)</span>

 99 {
100   unsigned int lookup_indices[32];
101   unsigned int offset, len;
102   unsigned int table_lookup_count;
103 
104   table_lookup_count = hb_ot_layout_table_get_lookup_count (face, table_tags[table_index]);
105 
106   offset = 0;
107   do {
108     len = ARRAY_LENGTH (lookup_indices);
109     hb_ot_layout_feature_with_variations_get_lookups (face,
110                                                       table_tags[table_index],
111                                                       feature_index,
112                                                       variations_index,
113                                                       offset, &amp;len,
114                                                       lookup_indices);
115 
116     for (unsigned int i = 0; i &lt; len; i++)
117     {
118       if (lookup_indices[i] &gt;= table_lookup_count)
119         continue;
120       hb_ot_map_t::lookup_map_t *lookup = m.lookups[table_index].push ();
121       lookup-&gt;mask = mask;
122       lookup-&gt;index = lookup_indices[i];
123       lookup-&gt;auto_zwnj = auto_zwnj;
124       lookup-&gt;auto_zwj = auto_zwj;
<a name="12" id="anc12"></a>
125     }
126 
127     offset += len;
128   } while (len == ARRAY_LENGTH (lookup_indices));
129 }
130 
131 
132 void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)
133 {
134   stage_info_t *s = stages[table_index].push ();
135   s-&gt;index = current_stage[table_index];
136   s-&gt;pause_func = pause_func;
137 
138   current_stage[table_index]++;
139 }
140 
141 void
<a name="13" id="anc13"></a><span class="line-modified">142 hb_ot_map_builder_t::compile (hb_ot_map_t  &amp;m,</span>
<span class="line-modified">143                               const int    *coords,</span>
<span class="line-removed">144                               unsigned int  num_coords)</span>
145 {
146   static_assert ((!(HB_GLYPH_FLAG_DEFINED &amp; (HB_GLYPH_FLAG_DEFINED + 1))), &quot;&quot;);
147   unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;
<a name="14" id="anc14"></a><span class="line-modified">148   unsigned int global_bit_shift = _hb_popcount (HB_GLYPH_FLAG_DEFINED);</span>
149 
150   m.global_mask = global_bit_mask;
151 
152   unsigned int required_feature_index[2];
153   hb_tag_t required_feature_tag[2];
154   /* We default to applying required feature in stage 0.  If the required
155    * feature has a tag that is known to the shaper, we apply required feature
156    * in the stage for that tag.
157    */
158   unsigned int required_feature_stage[2] = {0, 0};
159 
160   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
161   {
162     m.chosen_script[table_index] = chosen_script[table_index];
163     m.found_script[table_index] = found_script[table_index];
164 
165     hb_ot_layout_language_get_required_feature (face,
166                                                 table_tags[table_index],
167                                                 script_index[table_index],
168                                                 language_index[table_index],
169                                                 &amp;required_feature_index[table_index],
170                                                 &amp;required_feature_tag[table_index]);
171   }
172 
173   /* Sort features and merge duplicates */
<a name="15" id="anc15"></a>
174   {
175     feature_infos.qsort ();
176     unsigned int j = 0;
<a name="16" id="anc16"></a><span class="line-modified">177     for (unsigned int i = 1; i &lt; feature_infos.len; i++)</span>
178       if (feature_infos[i].tag != feature_infos[j].tag)
179         feature_infos[++j] = feature_infos[i];
180       else {
181         if (feature_infos[i].flags &amp; F_GLOBAL) {
182           feature_infos[j].flags |= F_GLOBAL;
183           feature_infos[j].max_value = feature_infos[i].max_value;
184           feature_infos[j].default_value = feature_infos[i].default_value;
185         } else {
186           feature_infos[j].flags &amp;= ~F_GLOBAL;
187           feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);
188           /* Inherit default_value from j */
189         }
190         feature_infos[j].flags |= (feature_infos[i].flags &amp; F_HAS_FALLBACK);
191         feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);
192         feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);
193       }
194     feature_infos.shrink (j + 1);
195   }
196 
197 
198   /* Allocate bits now */
199   unsigned int next_bit = global_bit_shift + 1;
200 
<a name="17" id="anc17"></a><span class="line-modified">201   for (unsigned int i = 0; i &lt; feature_infos.len; i++)</span>
202   {
203     const feature_info_t *info = &amp;feature_infos[i];
204 
205     unsigned int bits_needed;
206 
207     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1)
208       /* Uses the global bit */
209       bits_needed = 0;
210     else
<a name="18" id="anc18"></a><span class="line-modified">211       /* Limit to 8 bits per feature. */</span>
<span class="line-modified">212       bits_needed = MIN(8u, _hb_bit_storage (info-&gt;max_value));</span>
213 
214     if (!info-&gt;max_value || next_bit + bits_needed &gt; 8 * sizeof (hb_mask_t))
215       continue; /* Feature disabled, or not enough bits. */
216 
217 
218     hb_bool_t found = false;
219     unsigned int feature_index[2];
220     for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
221     {
222       if (required_feature_tag[table_index] == info-&gt;tag)
223         required_feature_stage[table_index] = info-&gt;stage[table_index];
224 
225       found |= hb_ot_layout_language_find_feature (face,
226                                                    table_tags[table_index],
227                                                    script_index[table_index],
228                                                    language_index[table_index],
229                                                    info-&gt;tag,
230                                                    &amp;feature_index[table_index]);
231     }
232     if (!found &amp;&amp; (info-&gt;flags &amp; F_GLOBAL_SEARCH))
233     {
234       for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
235       {
236         found |= hb_ot_layout_table_find_feature (face,
237                                                   table_tags[table_index],
238                                                   info-&gt;tag,
239                                                   &amp;feature_index[table_index]);
240       }
241     }
242     if (!found &amp;&amp; !(info-&gt;flags &amp; F_HAS_FALLBACK))
243       continue;
244 
245 
246     hb_ot_map_t::feature_map_t *map = m.features.push ();
247 
248     map-&gt;tag = info-&gt;tag;
249     map-&gt;index[0] = feature_index[0];
250     map-&gt;index[1] = feature_index[1];
251     map-&gt;stage[0] = info-&gt;stage[0];
252     map-&gt;stage[1] = info-&gt;stage[1];
253     map-&gt;auto_zwnj = !(info-&gt;flags &amp; F_MANUAL_ZWNJ);
254     map-&gt;auto_zwj = !(info-&gt;flags &amp; F_MANUAL_ZWJ);
<a name="19" id="anc19"></a>
255     if ((info-&gt;flags &amp; F_GLOBAL) &amp;&amp; info-&gt;max_value == 1) {
256       /* Uses the global bit */
257       map-&gt;shift = global_bit_shift;
258       map-&gt;mask = global_bit_mask;
259     } else {
260       map-&gt;shift = next_bit;
261       map-&gt;mask = (1u &lt;&lt; (next_bit + bits_needed)) - (1u &lt;&lt; next_bit);
262       next_bit += bits_needed;
263       m.global_mask |= (info-&gt;default_value &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
264     }
265     map-&gt;_1_mask = (1u &lt;&lt; map-&gt;shift) &amp; map-&gt;mask;
266     map-&gt;needs_fallback = !found;
267 
268   }
269   feature_infos.shrink (0); /* Done with these */
270 
271 
272   add_gsub_pause (nullptr);
273   add_gpos_pause (nullptr);
274 
275   for (unsigned int table_index = 0; table_index &lt; 2; table_index++)
276   {
277     /* Collect lookup indices for features */
278 
<a name="20" id="anc20"></a><span class="line-removed">279     unsigned int variations_index;</span>
<span class="line-removed">280     hb_ot_layout_table_find_feature_variations (face,</span>
<span class="line-removed">281                                                 table_tags[table_index],</span>
<span class="line-removed">282                                                 coords,</span>
<span class="line-removed">283                                                 num_coords,</span>
<span class="line-removed">284                                                 &amp;variations_index);</span>
<span class="line-removed">285 </span>
286     unsigned int stage_index = 0;
287     unsigned int last_num_lookups = 0;
288     for (unsigned stage = 0; stage &lt; current_stage[table_index]; stage++)
289     {
290       if (required_feature_index[table_index] != HB_OT_LAYOUT_NO_FEATURE_INDEX &amp;&amp;
291           required_feature_stage[table_index] == stage)
292         add_lookups (m, table_index,
293                      required_feature_index[table_index],
<a name="21" id="anc21"></a><span class="line-modified">294                      variations_index,</span>
295                      global_bit_mask);
296 
<a name="22" id="anc22"></a><span class="line-modified">297       for (unsigned i = 0; i &lt; m.features.len; i++)</span>
298         if (m.features[i].stage[table_index] == stage)
299           add_lookups (m, table_index,
300                        m.features[i].index[table_index],
<a name="23" id="anc23"></a><span class="line-modified">301                        variations_index,</span>
302                        m.features[i].mask,
303                        m.features[i].auto_zwnj,
<a name="24" id="anc24"></a><span class="line-modified">304                        m.features[i].auto_zwj);</span>

305 
306       /* Sort lookups and merge duplicates */
<a name="25" id="anc25"></a><span class="line-modified">307       if (last_num_lookups &lt; m.lookups[table_index].len)</span>
308       {
<a name="26" id="anc26"></a><span class="line-modified">309         m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].len);</span>
310 
311         unsigned int j = last_num_lookups;
<a name="27" id="anc27"></a><span class="line-modified">312         for (unsigned int i = j + 1; i &lt; m.lookups[table_index].len; i++)</span>
313           if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)
314             m.lookups[table_index][++j] = m.lookups[table_index][i];
315           else
316           {
317             m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;
318             m.lookups[table_index][j].auto_zwnj &amp;= m.lookups[table_index][i].auto_zwnj;
319             m.lookups[table_index][j].auto_zwj &amp;= m.lookups[table_index][i].auto_zwj;
320           }
321         m.lookups[table_index].shrink (j + 1);
322       }
323 
<a name="28" id="anc28"></a><span class="line-modified">324       last_num_lookups = m.lookups[table_index].len;</span>
325 
<a name="29" id="anc29"></a><span class="line-modified">326       if (stage_index &lt; stages[table_index].len &amp;&amp; stages[table_index][stage_index].index == stage) {</span>
327         hb_ot_map_t::stage_map_t *stage_map = m.stages[table_index].push ();
328         stage_map-&gt;last_lookup = last_num_lookups;
329         stage_map-&gt;pause_func = stages[table_index][stage_index].pause_func;
330 
331         stage_index++;
332       }
333     }
334   }
335 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
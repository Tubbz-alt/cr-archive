<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-var-fvar-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2017  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_VAR_FVAR_TABLE_HH
 28 #define HB_OT_VAR_FVAR_TABLE_HH
 29 
 30 #include &quot;hb-open-type-private.hh&quot;
 31 
 32 /*
 33  * fvar -- Font Variations
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/fvar
 35  */
 36 
 37 #define HB_OT_TAG_fvar HB_TAG(&#39;f&#39;,&#39;v&#39;,&#39;a&#39;,&#39;r&#39;)
 38 
 39 
 40 namespace OT {
 41 
 42 
 43 struct InstanceRecord
 44 {
 45   inline bool sanitize (hb_sanitize_context_t *c, unsigned int axis_count) const
 46   {
 47     TRACE_SANITIZE (this);
 48     return_trace (c-&gt;check_struct (this) &amp;&amp;
 49                   c-&gt;check_array (coordinates, coordinates[0].static_size, axis_count));
 50   }
 51 
 52   protected:
 53   NameID        subfamilyNameID;/* The name ID for entries in the &#39;name&#39; table
 54                                  * that provide subfamily names for this instance. */
 55   HBUINT16      reserved;       /* Reserved for future use — set to 0. */
 56   Fixed         coordinates[VAR];/* The coordinates array for this instance. */
 57   //NameID      postScriptNameIDX;/*Optional. The name ID for entries in the &#39;name&#39;
 58   //                              * table that provide PostScript names for this
 59   //                              * instance. */
 60 
 61   public:
 62   DEFINE_SIZE_ARRAY (4, coordinates);
 63 };
 64 
 65 struct AxisRecord
 66 {
 67   inline bool sanitize (hb_sanitize_context_t *c) const
 68   {
 69     TRACE_SANITIZE (this);
 70     return_trace (c-&gt;check_struct (this));
 71   }
 72 
 73   public:
 74   Tag           axisTag;        /* Tag identifying the design variation for the axis. */
 75   Fixed         minValue;       /* The minimum coordinate value for the axis. */
 76   Fixed         defaultValue;   /* The default coordinate value for the axis. */
 77   Fixed         maxValue;       /* The maximum coordinate value for the axis. */
 78   HBUINT16      reserved;       /* Reserved for future use — set to 0. */
 79   NameID        axisNameID;     /* The name ID for entries in the &#39;name&#39; table that
 80                                  * provide a display name for this axis. */
 81 
 82   public:
 83   DEFINE_SIZE_STATIC (20);
 84 };
 85 
 86 struct fvar
 87 {
 88   static const hb_tag_t tableTag        = HB_OT_TAG_fvar;
 89 
 90   inline bool sanitize (hb_sanitize_context_t *c) const
 91   {
 92     TRACE_SANITIZE (this);
 93     return_trace (version.sanitize (c) &amp;&amp;
 94                   likely (version.major == 1) &amp;&amp;
 95                   c-&gt;check_struct (this) &amp;&amp;
 96                   instanceSize &gt;= axisCount * 4 + 4 &amp;&amp;
 97                   axisSize &lt;= 1024 &amp;&amp; /* Arbitrary, just to simplify overflow checks. */
 98                   instanceSize &lt;= 1024 &amp;&amp; /* Arbitrary, just to simplify overflow checks. */
 99                   c-&gt;check_range (this, things) &amp;&amp;
100                   c-&gt;check_range (&amp;StructAtOffset&lt;char&gt; (this, things),
101                                   axisCount * axisSize + instanceCount * instanceSize));
102   }
103 
104   inline unsigned int get_axis_count (void) const
105   { return axisCount; }
106 
107   inline bool get_axis (unsigned int index, hb_ot_var_axis_t *info) const
108   {
109     if (unlikely (index &gt;= axisCount))
110       return false;
111 
112     if (info)
113     {
114       const AxisRecord &amp;axis = get_axes ()[index];
115       info-&gt;tag = axis.axisTag;
116       info-&gt;name_id =  axis.axisNameID;
117       info-&gt;default_value = axis.defaultValue / 65536.;
118       /* Ensure order, to simplify client math. */
119       info-&gt;min_value = MIN&lt;float&gt; (info-&gt;default_value, axis.minValue / 65536.);
120       info-&gt;max_value = MAX&lt;float&gt; (info-&gt;default_value, axis.maxValue / 65536.);
121     }
122 
123     return true;
124   }
125 
126   inline unsigned int get_axis_infos (unsigned int      start_offset,
127                                       unsigned int     *axes_count /* IN/OUT */,
128                                       hb_ot_var_axis_t *axes_array /* OUT */) const
129   {
130     if (axes_count)
131     {
132       unsigned int count = axisCount;
133       start_offset = MIN (start_offset, count);
134 
135       count -= start_offset;
136       axes_array += start_offset;
137 
138       count = MIN (count, *axes_count);
139       *axes_count = count;
140 
141       for (unsigned int i = 0; i &lt; count; i++)
142         get_axis (start_offset + i, axes_array + i);
143     }
144     return axisCount;
145   }
146 
147   inline bool find_axis (hb_tag_t tag, unsigned int *index, hb_ot_var_axis_t *info) const
148   {
149     const AxisRecord *axes = get_axes ();
150     unsigned int count = get_axis_count ();
151     for (unsigned int i = 0; i &lt; count; i++)
152       if (axes[i].axisTag == tag)
153       {
154         if (index)
155           *index = i;
156         return get_axis (i, info);
157       }
158     if (index)
159       *index = HB_OT_VAR_NO_AXIS_INDEX;
160     return false;
161   }
162 
163   inline int normalize_axis_value (unsigned int axis_index, float v) const
164   {
165     hb_ot_var_axis_t axis;
166     if (!get_axis (axis_index, &amp;axis))
167       return 0;
168 
169     v = MAX (MIN (v, axis.max_value), axis.min_value); /* Clamp. */
170 
171     if (v == axis.default_value)
172       return 0;
173     else if (v &lt; axis.default_value)
174       v = (v - axis.default_value) / (axis.default_value - axis.min_value);
175     else
176       v = (v - axis.default_value) / (axis.max_value - axis.default_value);
177     return (int) (v * 16384. + (v &gt;= 0. ? .5 : -.5));
178   }
179 
180   protected:
181   inline const AxisRecord * get_axes (void) const
182   { return &amp;StructAtOffset&lt;AxisRecord&gt; (this, things); }
183 
184   inline const InstanceRecord * get_instances (void) const
185   { return &amp;StructAtOffset&lt;InstanceRecord&gt; (get_axes () + axisCount, 0); }
186 
187   protected:
188   FixedVersion&lt;&gt;version;        /* Version of the fvar table
189                                  * initially set to 0x00010000u */
190   Offset16      things;         /* Offset in bytes from the beginning of the table
191                                  * to the start of the AxisRecord array. */
192   HBUINT16      reserved;       /* This field is permanently reserved. Set to 2. */
193   HBUINT16      axisCount;      /* The number of variation axes in the font (the
194                                  * number of records in the axes array). */
195   HBUINT16      axisSize;       /* The size in bytes of each VariationAxisRecord —
196                                  * set to 20 (0x0014) for this version. */
197   HBUINT16      instanceCount;  /* The number of named instances defined in the font
198                                  * (the number of records in the instances array). */
199   HBUINT16      instanceSize;   /* The size in bytes of each InstanceRecord — set
200                                  * to either axisCount * sizeof(Fixed) + 4, or to
201                                  * axisCount * sizeof(Fixed) + 6. */
202 
203   public:
204   DEFINE_SIZE_STATIC (16);
205 };
206 
207 } /* namespace OT */
208 
209 
210 #endif /* HB_OT_VAR_FVAR_TABLE_HH */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-kern-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gdef-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
<span class="line-new-header">--- 1,9 ---</span>
  /*
   * Copyright © 2016 Elie Roux &lt;elie.roux@telecom-bretagne.eu&gt;
   * Copyright © 2018  Google, Inc.
<span class="line-added">+  * Copyright © 2018  Ebrahim Byagowi</span>
   *
   *  This is part of HarfBuzz, a text shaping library.
   *
   * Permission is hereby granted, without written agreement and without
   * license or royalty fees, to use, copy, modify, and distribute this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,103 ***</span>
   */
  
  #ifndef HB_OT_LAYOUT_BASE_TABLE_HH
  #define HB_OT_LAYOUT_BASE_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout-common-private.hh&quot;</span>
  
<span class="line-modified">! namespace OT {</span>
  
<span class="line-modified">! #define NOT_INDEXED   ((unsigned int) -1)</span>
  
  /*
   * BASE -- Baseline
   * https://docs.microsoft.com/en-us/typography/opentype/spec/base
   */
  
  struct BaseCoordFormat1
  {
<span class="line-modified">!   inline int get_coord (void) const { return coordinate; }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this));</span>
    }
  
    protected:
    HBUINT16      format;         /* Format identifier--format = 1 */
<span class="line-modified">!   HBINT16       coordinate;     /* X or Y value, in design units */</span>
    public:
    DEFINE_SIZE_STATIC (4);
  };
  
  struct BaseCoordFormat2
  {
<span class="line-modified">!   inline int get_coord (void) const</span>
    {
      /* TODO */
      return coordinate;
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
    protected:
    HBUINT16      format;         /* Format identifier--format = 2 */
<span class="line-modified">!   HBINT16       coordinate;     /* X or Y value, in design units */</span>
    GlyphID       referenceGlyph; /* Glyph ID of control glyph */
    HBUINT16      coordPoint;     /* Index of contour point on the
                                   * reference glyph */
    public:
    DEFINE_SIZE_STATIC (8);
  };
  
  struct BaseCoordFormat3
  {
<span class="line-modified">!   inline int get_coord (void) const</span>
    {
<span class="line-modified">!     /* TODO */</span>
<span class="line-modified">!     return coordinate;</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   HBUINT16              format;         /* Format identifier--format = 3 */</span>
<span class="line-modified">!   HBINT16               coordinate;     /* X or Y value, in design units */</span>
<span class="line-modified">!   OffsetTo&lt;Device&gt;      deviceTable;    /* Offset to Device table for X or</span>
<span class="line-modified">!                                          * Y value, from beginning of</span>
<span class="line-modified">!                                          * BaseCoord table (may be NULL). */</span>
    public:
    DEFINE_SIZE_STATIC (6);
  };
  
  struct BaseCoord
  {
<span class="line-modified">!   inline int get_coord (void) const</span>
    {
      switch (u.format) {
      case 1: return u.format1.get_coord ();
      case 2: return u.format2.get_coord ();
<span class="line-modified">!     case 3: return u.format3.get_coord ();</span>
      default:return 0;
      }
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     if (!u.format.sanitize (c)) return_trace (false);</span>
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
      case 2: return_trace (u.format2.sanitize (c));
      case 3: return_trace (u.format3.sanitize (c));
      default:return_trace (false);
<span class="line-new-header">--- 27,113 ---</span>
   */
  
  #ifndef HB_OT_LAYOUT_BASE_TABLE_HH
  #define HB_OT_LAYOUT_BASE_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-layout-common.hh&quot;</span>
  
<span class="line-modified">! /* To be removed */</span>
<span class="line-added">+ typedef hb_tag_t hb_ot_layout_baseline_t;</span>
  
<span class="line-modified">! namespace OT {</span>
  
  /*
   * BASE -- Baseline
   * https://docs.microsoft.com/en-us/typography/opentype/spec/base
   */
  
  struct BaseCoordFormat1
  {
<span class="line-modified">!   hb_position_t get_coord () const { return coordinate; }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this)));</span>
    }
  
    protected:
    HBUINT16      format;         /* Format identifier--format = 1 */
<span class="line-modified">!   FWORD         coordinate;     /* X or Y value, in design units */</span>
    public:
    DEFINE_SIZE_STATIC (4);
  };
  
  struct BaseCoordFormat2
  {
<span class="line-modified">!   hb_position_t get_coord () const</span>
    {
      /* TODO */
      return coordinate;
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this));
    }
  
    protected:
    HBUINT16      format;         /* Format identifier--format = 2 */
<span class="line-modified">!   FWORD         coordinate;     /* X or Y value, in design units */</span>
    GlyphID       referenceGlyph; /* Glyph ID of control glyph */
    HBUINT16      coordPoint;     /* Index of contour point on the
                                   * reference glyph */
    public:
    DEFINE_SIZE_STATIC (8);
  };
  
  struct BaseCoordFormat3
  {
<span class="line-modified">!   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added">+                            const VariationStore &amp;var_store,</span>
<span class="line-added">+                            hb_direction_t direction) const</span>
    {
<span class="line-modified">!     const Device &amp;device = this+deviceTable;</span>
<span class="line-modified">!     return coordinate + (HB_DIRECTION_IS_VERTICAL (direction) ?</span>
<span class="line-added">+                          device.get_y_delta (font, var_store) :</span>
<span class="line-added">+                          device.get_x_delta (font, var_store));</span>
    }
  
<span class="line-modified">! </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                           deviceTable.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   HBUINT16      format;         /* Format identifier--format = 3 */</span>
<span class="line-modified">!   FWORD         coordinate;     /* X or Y value, in design units */</span>
<span class="line-modified">!   OffsetTo&lt;Device&gt;</span>
<span class="line-modified">!                 deviceTable;    /* Offset to Device table for X or</span>
<span class="line-modified">!                                  * Y value, from beginning of</span>
<span class="line-added">+                                  * BaseCoord table (may be NULL). */</span>
    public:
    DEFINE_SIZE_STATIC (6);
  };
  
  struct BaseCoord
  {
<span class="line-modified">!   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added">+                            const VariationStore &amp;var_store,</span>
<span class="line-added">+                            hb_direction_t direction) const</span>
    {
      switch (u.format) {
      case 1: return u.format1.get_coord ();
      case 2: return u.format2.get_coord ();
<span class="line-modified">!     case 3: return u.format3.get_coord (font, var_store, direction);</span>
      default:return 0;
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     if (unlikely (!u.format.sanitize (c))) return_trace (false);</span>
      switch (u.format) {
      case 1: return_trace (u.format1.sanitize (c));
      case 2: return_trace (u.format2.sanitize (c));
      case 3: return_trace (u.format3.sanitize (c));
      default:return_trace (false);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 140,513 ***</span>
    DEFINE_SIZE_UNION (2, format);
  };
  
  struct FeatMinMaxRecord
  {
<span class="line-modified">!   inline int get_min_value (void) const</span>
<span class="line-modified">!   { return (this+minCoord).get_coord(); }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   inline int get_max_value (void) const</span>
<span class="line-modified">!   { return (this+maxCoord).get_coord(); }</span>
  
<span class="line-modified">!   inline const Tag &amp;get_tag () const</span>
<span class="line-modified">!   { return tag; }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                   minCoord.sanitize (c, base) &amp;&amp;</span>
<span class="line-modified">!                   maxCoord.sanitize (c, base));</span>
    }
  
    protected:
<span class="line-modified">!   Tag                   tag;            /* 4-byte feature identification tag--must</span>
<span class="line-modified">!                                          * match feature tag in FeatureList */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;   minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                          * the minimum extent value, from beginning</span>
<span class="line-modified">!                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;   maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                          * the maximum extent value, from beginning</span>
<span class="line-modified">!                                          * of MinMax table (may be NULL) */</span>
    public:
    DEFINE_SIZE_STATIC (8);
  
  };
  
  struct MinMax
  {
<span class="line-modified">!   inline unsigned int get_feature_tag_index (Tag featureTableTag) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* TODO bsearch */</span>
<span class="line-modified">!     unsigned int count = featMinMaxRecords.len;</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; count; i++)</span>
      {
<span class="line-modified">!       Tag tag = featMinMaxRecords[i].get_tag();</span>
<span class="line-modified">!       int cmp = tag.cmp(featureTableTag);</span>
<span class="line-removed">-       if (cmp == 0) return i;</span>
<span class="line-removed">-       if (cmp &gt; 0)  return NOT_INDEXED;</span>
      }
<span class="line-removed">-     return NOT_INDEXED;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_min_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (featureTableTagIndex == NOT_INDEXED)</span>
<span class="line-removed">-       return (this+minCoord).get_coord();</span>
<span class="line-removed">-     return featMinMaxRecords[featureTableTagIndex].get_min_value();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_max_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (featureTableTagIndex == NOT_INDEXED)</span>
<span class="line-removed">-       return (this+maxCoord).get_coord();</span>
<span class="line-removed">-     return featMinMaxRecords[featureTableTagIndex].get_max_value();</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                   minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   maxCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   featMinMaxRecords.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;   minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                          * minimum extent value, from the beginning</span>
<span class="line-modified">!                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;   maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                          * maximum extent value, from the beginning</span>
<span class="line-modified">!                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   ArrayOf&lt;FeatMinMaxRecord&gt;</span>
<span class="line-modified">!                 featMinMaxRecords;      /* Array of FeatMinMaxRecords, in alphabetical</span>
<span class="line-modified">!                                          * order by featureTableTag */</span>
    public:
    DEFINE_SIZE_ARRAY (6, featMinMaxRecords);
  };
  
<span class="line-removed">- /* TODO... */</span>
<span class="line-removed">- struct BaseLangSysRecord</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   inline const Tag&amp; get_tag(void) const</span>
<span class="line-removed">-   { return baseLangSysTag; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_feature_tag_index (Tag featureTableTag) const</span>
<span class="line-removed">-   { return (this+minMax).get_feature_tag_index(featureTableTag); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_min_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   { return (this+minMax).get_min_value(featureTableTagIndex); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_max_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   { return (this+minMax).get_max_value(featureTableTagIndex); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed">-                   minMax.sanitize (c, base));</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   protected:</span>
<span class="line-removed">-   Tag                   baseLangSysTag;</span>
<span class="line-removed">-   OffsetTo&lt;MinMax&gt;      minMax;</span>
<span class="line-removed">-   public:</span>
<span class="line-removed">-   DEFINE_SIZE_STATIC (6);</span>
<span class="line-removed">- </span>
<span class="line-removed">- };</span>
<span class="line-removed">- </span>
  struct BaseValues
  {
<span class="line-modified">!   inline unsigned int get_default_base_tag_index (void) const</span>
<span class="line-removed">-   { return defaultIndex; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_base_coord (unsigned int baselineTagIndex) const</span>
    {
<span class="line-modified">!     return (this+baseCoords[baselineTagIndex]).get_coord();</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!       defaultIndex &lt;= baseCoordCount &amp;&amp;</span>
<span class="line-removed">-       baseCoords.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   Index                         defaultIndex;</span>
<span class="line-modified">!   HBUINT16                      baseCoordCount;</span>
<span class="line-modified">!   OffsetArrayOf&lt;BaseCoord&gt;      baseCoords;</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (6, baseCoords);</span>
<span class="line-removed">- </span>
  };
  
<span class="line-modified">! struct BaseScript {</span>
<span class="line-modified">! </span>
<span class="line-modified">!   inline unsigned int get_lang_tag_index (Tag baseLangSysTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     Tag tag;</span>
<span class="line-removed">-     int cmp;</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; baseLangSysCount; i++) {</span>
<span class="line-removed">-       tag = baseLangSysRecords[i].get_tag();</span>
<span class="line-removed">-       // taking advantage of alphabetical order</span>
<span class="line-removed">-       cmp = tag.cmp(baseLangSysTag);</span>
<span class="line-removed">-       if (cmp == 0) return i;</span>
<span class="line-removed">-       if (cmp &gt; 0)  return NOT_INDEXED;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return NOT_INDEXED;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_feature_tag_index (unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (baseLangSysIndex == NOT_INDEXED) {</span>
<span class="line-removed">-       if (unlikely(defaultMinMax)) return NOT_INDEXED;</span>
<span class="line-removed">-       return (this+defaultMinMax).get_feature_tag_index(featureTableTag);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     if (unlikely(baseLangSysIndex &gt;= baseLangSysCount)) return NOT_INDEXED;</span>
<span class="line-removed">-     return baseLangSysRecords[baseLangSysIndex].get_feature_tag_index(featureTableTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_min_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (baseLangSysIndex == NOT_INDEXED)</span>
<span class="line-removed">-       return (this+defaultMinMax).get_min_value(featureTableTagIndex);</span>
<span class="line-removed">-     return baseLangSysRecords[baseLangSysIndex].get_max_value(featureTableTagIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_max_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
    {
<span class="line-modified">!     if (baseLangSysIndex == NOT_INDEXED)</span>
<span class="line-modified">!       return (this+defaultMinMax).get_min_value(featureTableTagIndex);</span>
<span class="line-modified">!     return baseLangSysRecords[baseLangSysIndex].get_max_value(featureTableTagIndex);</span>
    }
  
<span class="line-modified">!   inline unsigned int get_default_base_tag_index (void) const</span>
<span class="line-modified">!   { return (this+baseValues).get_default_base_tag_index(); }</span>
  
<span class="line-modified">!   inline int get_base_coord (unsigned int baselineTagIndex) const</span>
<span class="line-removed">-   { return (this+baseValues).get_base_coord(baselineTagIndex); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!       baseValues.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-       defaultMinMax.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">-       baseLangSysRecords.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;BaseValues&gt;        baseValues;</span>
<span class="line-modified">!   OffsetTo&lt;MinMax&gt;            defaultMinMax;</span>
<span class="line-modified">!   HBUINT16                      baseLangSysCount;</span>
<span class="line-modified">!   ArrayOf&lt;BaseLangSysRecord&gt;  baseLangSysRecords;</span>
<span class="line-removed">- </span>
    public:
<span class="line-modified">!     DEFINE_SIZE_ARRAY (8, baseLangSysRecords);</span>
  };
  
  
<span class="line-modified">! struct BaseScriptRecord {</span>
<span class="line-modified">! </span>
<span class="line-removed">-   inline const Tag&amp; get_tag (void) const</span>
<span class="line-removed">-   { return baseScriptTag; }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_default_base_tag_index(void) const</span>
<span class="line-removed">-   { return (this+baseScript).get_default_base_tag_index(); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_base_coord(unsigned int baselineTagIndex) const</span>
<span class="line-removed">-   { return (this+baseScript).get_base_coord(baselineTagIndex); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_lang_tag_index (Tag baseLangSysTag) const</span>
<span class="line-removed">-   { return (this+baseScript).get_lang_tag_index(baseLangSysTag); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_feature_tag_index (unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">-   { return (this+baseScript).get_feature_tag_index(baseLangSysIndex, featureTableTag); }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_max_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   { return (this+baseScript).get_max_value(baseLangSysIndex, featureTableTagIndex); }</span>
  
<span class="line-modified">!   inline int get_min_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   { return (this+baseScript).get_min_value(baseLangSysIndex, featureTableTagIndex); }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!       baseScript != Null(OffsetTo&lt;BaseScript&gt;) &amp;&amp;</span>
<span class="line-modified">!       baseScript.sanitize (c, base));</span>
    }
  
    protected:
<span class="line-modified">!   Tag                   baseScriptTag;</span>
<span class="line-modified">!   OffsetTo&lt;BaseScript&gt;  baseScript;</span>
  
    public:
<span class="line-modified">!     DEFINE_SIZE_STATIC (6);</span>
  };
  
<span class="line-modified">! struct BaseScriptList {</span>
<span class="line-modified">! </span>
<span class="line-modified">!   inline unsigned int get_base_script_index (Tag baseScriptTag) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; baseScriptCount; i++)</span>
<span class="line-removed">-       if (baseScriptRecords[i].get_tag() == baseScriptTag)</span>
<span class="line-removed">-         return i;</span>
<span class="line-removed">-     return NOT_INDEXED;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_default_base_tag_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">-     return baseScriptRecords[baseScriptIndex].get_default_base_tag_index();</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return baseScriptRecords[baseScriptIndex].get_base_coord(baselineTagIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">-     return baseScriptRecords[baseScriptIndex].get_lang_tag_index(baseLangSysTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">-     return baseScriptRecords[baseScriptIndex].get_feature_tag_index(baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
    {
<span class="line-modified">!     return baseScriptRecords[baseScriptIndex].get_max_value(baseLangSysIndex, featureTableTagIndex);</span>
    }
  
<span class="line-modified">!   inline int get_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     return baseScriptRecords[baseScriptIndex].get_min_value(baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!       baseScriptRecords.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   HBUINT16                    baseScriptCount;</span>
<span class="line-modified">!   ArrayOf&lt;BaseScriptRecord&gt; baseScriptRecords;</span>
  
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (4, baseScriptRecords);</span>
<span class="line-removed">- </span>
  };
  
<span class="line-modified">! struct BaseTagList</span>
  {
  
<span class="line-modified">!   inline unsigned int get_tag_index(Tag baselineTag) const</span>
    {
<span class="line-modified">!     for (unsigned int i = 0; i &lt; baseTagCount; i++)</span>
<span class="line-modified">!       if (baselineTags[i] == baselineTag)</span>
<span class="line-modified">!         return i;</span>
<span class="line-modified">!     return NOT_INDEXED;</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this));</span>
    }
  
    protected:
<span class="line-modified">!   HBUINT16        baseTagCount;</span>
<span class="line-modified">!   SortedArrayOf&lt;Tag&gt;  baselineTags;</span>
  
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (4, baselineTags);</span>
  };
  
  struct Axis
  {
<span class="line-modified">! </span>
<span class="line-modified">!   inline unsigned int get_base_tag_index(Tag baselineTag) const</span>
    {
<span class="line-modified">!     if (unlikely(baseTagList == Null(OffsetTo&lt;BaseTagList&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">!     return (this+baseTagList).get_tag_index(baselineTag);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline unsigned int get_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+baseScriptList).get_default_base_tag_index(baseScriptIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+baseScriptList).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline unsigned int get_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+baseScriptList).get_lang_tag_index(baseScriptIndex, baseLangSysTag);</span>
    }
  
<span class="line-modified">!   inline unsigned int get_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
    {
<span class="line-modified">!     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">!     return (this+baseScriptList).get_feature_tag_index(baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline int get_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+baseScriptList).get_max_value(baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline int get_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+baseScriptList).get_min_value(baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
    }
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!       baseTagList.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!       baseScriptList.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;BaseTagList&gt;     baseTagList;</span>
<span class="line-modified">!   OffsetTo&lt;BaseScriptList&gt;  baseScriptList;</span>
  
    public:
    DEFINE_SIZE_STATIC (4);
  };
  
  struct BASE
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_BASE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool has_vert_axis(void)</span>
<span class="line-removed">-   { return vertAxis != Null(OffsetTo&lt;Axis&gt;); }</span>
  
<span class="line-modified">!   inline bool has_horiz_axis(void)</span>
<span class="line-modified">!   { return horizAxis != Null(OffsetTo&lt;Axis&gt;); }</span>
  
<span class="line-modified">!   // horizontal axis base coords:</span>
  
<span class="line-modified">!   inline unsigned int get_horiz_base_tag_index(Tag baselineTag) const</span>
    {
<span class="line-modified">!     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">!     return (this+horizAxis).get_base_tag_index(baselineTag);</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   inline unsigned int get_horiz_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">!     return (this+horizAxis).get_default_base_tag_index_for_script_index(baseScriptIndex);</span>
    }
  
<span class="line-modified">!   inline int get_horiz_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
    {
<span class="line-modified">!     return (this+horizAxis).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!   // vertical axis base coords:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_vert_base_tag_index(Tag baselineTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+vertAxis).get_base_tag_index(baselineTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_vert_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+vertAxis).get_default_base_tag_index_for_script_index(baseScriptIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_vert_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+vertAxis).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // horizontal axis min/max coords:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_horiz_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+horizAxis).get_lang_tag_index (baseScriptIndex, baseLangSysTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_horiz_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+horizAxis).get_feature_tag_index (baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline int get_horiz_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     return (this+horizAxis).get_max_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-modified">!   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_horiz_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+horizAxis).get_min_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // vertical axis min/max coords:</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_vert_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+vertAxis).get_lang_tag_index (baseScriptIndex, baseLangSysTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline unsigned int get_vert_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">-     return (this+vertAxis).get_feature_tag_index (baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline int get_vert_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+vertAxis).get_max_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
    }
  
<span class="line-modified">!   inline int get_vert_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     return (this+vertAxis).get_min_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-modified">!                   horizAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   vertAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                   (version.to_int () &lt; 0x00010001u || varStore.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   FixedVersion&lt;&gt;  version;</span>
<span class="line-modified">!   OffsetTo&lt;Axis&gt;  horizAxis;</span>
<span class="line-modified">!   OffsetTo&lt;Axis&gt;  vertAxis;</span>
    LOffsetTo&lt;VariationStore&gt;
<span class="line-modified">!                 varStore;               /* Offset to the table of Item Variation</span>
<span class="line-modified">!                                          * Store--from beginning of BASE</span>
<span class="line-modified">!                                          * header (may be NULL).  Introduced</span>
<span class="line-modified">!                                          * in version 0x00010001. */</span>
    public:
    DEFINE_SIZE_MIN (8);
  };
  
  
<span class="line-new-header">--- 151,387 ---</span>
    DEFINE_SIZE_UNION (2, format);
  };
  
  struct FeatMinMaxRecord
  {
<span class="line-modified">!   static int cmp (const void *key_, const void *entry_)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">!     const FeatMinMaxRecord &amp;entry = * (const FeatMinMaxRecord *) entry_;</span>
<span class="line-modified">!     return key &lt; (unsigned int) entry.tag ? -1 :</span>
<span class="line-added">+            key &gt; (unsigned int) entry.tag ? 1 :</span>
<span class="line-added">+            0;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   void get_min_max (const BaseCoord **min, const BaseCoord **max) const</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-added">+     if (likely (max)) *max = &amp;(this+maxCoord);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           maxCoord.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   Tag           tag;            /* 4-byte feature identification tag--must</span>
<span class="line-modified">!                                  * match feature tag in FeatureList */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">!                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                  * the minimum extent value, from beginning</span>
<span class="line-modified">!                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">!                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-added">+                                  * the maximum extent value, from beginning</span>
<span class="line-added">+                                  * of MinMax table (may be NULL) */</span>
    public:
    DEFINE_SIZE_STATIC (8);
  
  };
  
  struct MinMax
  {
<span class="line-modified">!   void get_min_max (hb_tag_t          feature_tag,</span>
<span class="line-modified">!                            const BaseCoord **min,</span>
<span class="line-modified">!                            const BaseCoord **max) const</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">+     const FeatMinMaxRecord *minMaxCoord = (const FeatMinMaxRecord *)</span>
<span class="line-added">+                                           hb_bsearch (&amp;feature_tag, featMinMaxRecords.arrayZ,</span>
<span class="line-added">+                                                       featMinMaxRecords.len,</span>
<span class="line-added">+                                                       FeatMinMaxRecord::static_size,</span>
<span class="line-added">+                                                       FeatMinMaxRecord::cmp);</span>
<span class="line-added">+     if (minMaxCoord)</span>
<span class="line-added">+       minMaxCoord-&gt;get_min_max (min, max);</span>
<span class="line-added">+     else</span>
      {
<span class="line-modified">!       if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-modified">!       if (likely (max)) *max = &amp;(this+maxCoord);</span>
      }
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           maxCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           featMinMaxRecords.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">!                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                  * minimum extent value, from the beginning</span>
<span class="line-modified">!                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">!                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">!                                  * maximum extent value, from the beginning</span>
<span class="line-modified">!                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">!   SortedArrayOf&lt;FeatMinMaxRecord&gt;</span>
<span class="line-added">+                 featMinMaxRecords;</span>
<span class="line-added">+                                 /* Array of FeatMinMaxRecords, in alphabetical</span>
<span class="line-added">+                                  * order by featureTableTag */</span>
    public:
    DEFINE_SIZE_ARRAY (6, featMinMaxRecords);
  };
  
  struct BaseValues
  {
<span class="line-modified">!   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>
    {
<span class="line-modified">!     if (baseline_tag_index == -1) baseline_tag_index = defaultIndex;</span>
<span class="line-added">+     return this+baseCoords[baseline_tag_index];</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           baseCoords.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   Index         defaultIndex;   /* Index number of default baseline for this</span>
<span class="line-modified">!                                  * script — equals index position of baseline tag</span>
<span class="line-modified">!                                  * in baselineTags array of the BaseTagList */</span>
<span class="line-added">+   OffsetArrayOf&lt;BaseCoord&gt;</span>
<span class="line-added">+                 baseCoords;     /* Number of BaseCoord tables defined — should equal</span>
<span class="line-added">+                                  * baseTagCount in the BaseTagList</span>
<span class="line-added">+                                  *</span>
<span class="line-added">+                                  * Array of offsets to BaseCoord tables, from beginning of</span>
<span class="line-added">+                                  * BaseValues table — order matches baselineTags array in</span>
<span class="line-added">+                                  * the BaseTagList */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (4, baseCoords);</span>
  };
  
<span class="line-modified">! struct BaseLangSysRecord</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   static int cmp (const void *key_, const void *entry_)</span>
    {
<span class="line-modified">!     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">!     const BaseLangSysRecord &amp;entry = * (const BaseLangSysRecord *) entry_;</span>
<span class="line-modified">!     return key &lt; (unsigned int) entry.baseLangSysTag ? -1 :</span>
<span class="line-added">+            key &gt; (unsigned int) entry.baseLangSysTag ? 1 :</span>
<span class="line-added">+            0;</span>
    }
  
<span class="line-modified">!   const MinMax &amp;get_min_max () const</span>
<span class="line-modified">!   { return this+minMax; }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           minMax.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   Tag           baseLangSysTag; /* 4-byte language system identification tag */</span>
<span class="line-modified">!   OffsetTo&lt;MinMax&gt;</span>
<span class="line-modified">!                 minMax;         /* Offset to MinMax table, from beginning</span>
<span class="line-modified">!                                  * of BaseScript table */</span>
    public:
<span class="line-modified">!   DEFINE_SIZE_STATIC (6);</span>
  };
  
<span class="line-added">+ struct BaseScript</span>
<span class="line-added">+ {</span>
<span class="line-added">+   const MinMax &amp;get_min_max (hb_tag_t language_tag) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">+     const BaseLangSysRecord* record = (const BaseLangSysRecord *)</span>
<span class="line-added">+                                       hb_bsearch (&amp;language_tag, baseLangSysRecords.arrayZ,</span>
<span class="line-added">+                                                   baseLangSysRecords.len,</span>
<span class="line-added">+                                                   BaseLangSysRecord::static_size,</span>
<span class="line-added">+                                                   BaseLangSysRecord::cmp);</span>
<span class="line-added">+     return record ? record-&gt;get_min_max () : this+defaultMinMax;</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>
<span class="line-modified">!   { return (this+baseValues).get_base_coord (baseline_tag_index); }</span>
  
<span class="line-modified">!   bool is_empty () const { return !baseValues; }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           baseValues.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           defaultMinMax.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">+                           baseLangSysRecords.sanitize (c, this)));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;BaseValues&gt;</span>
<span class="line-modified">!                 baseValues;     /* Offset to BaseValues table, from beginning</span>
<span class="line-added">+                                  * of BaseScript table (may be NULL) */</span>
<span class="line-added">+   OffsetTo&lt;MinMax&gt;</span>
<span class="line-added">+                 defaultMinMax;  /* Offset to MinMax table, from beginning of</span>
<span class="line-added">+                                  * BaseScript table (may be NULL) */</span>
<span class="line-added">+   SortedArrayOf&lt;BaseLangSysRecord&gt;</span>
<span class="line-added">+                 baseLangSysRecords;</span>
<span class="line-added">+                                 /* Number of BaseLangSysRecords</span>
<span class="line-added">+                                  * defined — may be zero (0) */</span>
  
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (6, baseLangSysRecords);</span>
  };
  
<span class="line-modified">! struct BaseScriptList;</span>
<span class="line-modified">! struct BaseScriptRecord</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   static int cmp (const void *key_, const void *entry_)</span>
    {
<span class="line-modified">!     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-added">+     const BaseScriptRecord &amp;entry = * (const BaseScriptRecord *) entry_;</span>
<span class="line-added">+     return key &lt; (unsigned int) entry.baseScriptTag ? -1 :</span>
<span class="line-added">+            key &gt; (unsigned int) entry.baseScriptTag ? 1 :</span>
<span class="line-added">+            0;</span>
    }
  
<span class="line-modified">!   const BaseScript &amp;get_base_script (const BaseScriptList *list) const</span>
<span class="line-modified">!   { return list+baseScript; }</span>
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           baseScript.sanitize (c, base)));</span>
    }
  
    protected:
<span class="line-modified">!   Tag           baseScriptTag;  /* 4-byte script identification tag */</span>
<span class="line-modified">!   OffsetTo&lt;BaseScript&gt;</span>
<span class="line-added">+                 baseScript;     /* Offset to BaseScript table, from beginning</span>
<span class="line-added">+                                  * of BaseScriptList */</span>
  
    public:
<span class="line-modified">!   DEFINE_SIZE_STATIC (6);</span>
  };
  
<span class="line-modified">! struct BaseScriptList</span>
  {
<span class="line-added">+   const BaseScriptRecord *find_record (hb_tag_t script) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">+     return (const BaseScriptRecord *) hb_bsearch (&amp;script, baseScriptRecords.arrayZ,</span>
<span class="line-added">+                                                   baseScriptRecords.len,</span>
<span class="line-added">+                                                   BaseScriptRecord::static_size,</span>
<span class="line-added">+                                                   BaseScriptRecord::cmp);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   /* TODO: Or client should handle fallback? */</span>
<span class="line-added">+   const BaseScript &amp;get_base_script (hb_tag_t script) const</span>
    {
<span class="line-modified">!     const BaseScriptRecord *record = find_record (script);</span>
<span class="line-modified">!     if (!record) record = find_record ((hb_script_t) HB_TAG (&#39;D&#39;,&#39;F&#39;,&#39;L&#39;,&#39;T&#39;));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return record ? record-&gt;get_base_script (this) : Null (BaseScript);</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                   baseScriptRecords.sanitize (c, this));</span>
    }
  
    protected:
<span class="line-modified">!   SortedArrayOf&lt;BaseScriptRecord&gt;</span>
<span class="line-modified">!                         baseScriptRecords;</span>
  
    public:
<span class="line-modified">!   DEFINE_SIZE_ARRAY (2, baseScriptRecords);</span>
  };
  
  struct Axis
  {
<span class="line-modified">!   bool get_baseline (hb_ot_layout_baseline_t   baseline,</span>
<span class="line-modified">!                             hb_tag_t                  script_tag,</span>
<span class="line-added">+                             hb_tag_t                  language_tag,</span>
<span class="line-added">+                             const BaseCoord         **coord) const</span>
    {
<span class="line-modified">!     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">!     if (base_script.is_empty ()) return false;</span>
  
<span class="line-modified">!     if (likely (coord)) *coord = &amp;base_script.get_base_coord ((this+baseTagList).bsearch (baseline));</span>
  
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   bool get_min_max (hb_tag_t          script_tag,</span>
<span class="line-added">+                     hb_tag_t          language_tag,</span>
<span class="line-added">+                     hb_tag_t          feature_tag,</span>
<span class="line-added">+                     const BaseCoord **min_coord,</span>
<span class="line-added">+                     const BaseCoord **max_coord) const</span>
    {
<span class="line-modified">!     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">!     if (base_script.is_empty ()) return false;</span>
  
<span class="line-modified">!     base_script.get_min_max (language_tag).get_min_max (feature_tag, min_coord, max_coord);</span>
  
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           (this+baseTagList).sanitize (c) &amp;&amp;</span>
<span class="line-modified">!                           (this+baseScriptList).sanitize (c)));</span>
    }
  
    protected:
<span class="line-modified">!   OffsetTo&lt;SortedArrayOf&lt;Tag&gt; &gt;</span>
<span class="line-modified">!                 baseTagList;    /* Offset to BaseTagList table, from beginning</span>
<span class="line-added">+                                  * of Axis table (may be NULL)</span>
<span class="line-added">+                                  * Array of 4-byte baseline identification tags — must</span>
<span class="line-added">+                                  * be in alphabetical order */</span>
<span class="line-added">+   OffsetTo&lt;BaseScriptList&gt;</span>
<span class="line-added">+                 baseScriptList; /* Offset to BaseScriptList table, from beginning</span>
<span class="line-added">+                                  * of Axis table</span>
<span class="line-added">+                                  * Array of BaseScriptRecords, in alphabetical order</span>
<span class="line-added">+                                  * by baseScriptTag */</span>
  
    public:
    DEFINE_SIZE_STATIC (4);
  };
  
  struct BASE
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_BASE;</span>
  
<span class="line-modified">!   const Axis &amp;get_axis (hb_direction_t direction) const</span>
<span class="line-modified">!   { return HB_DIRECTION_IS_VERTICAL (direction) ? this+vAxis : this+hAxis; }</span>
  
<span class="line-modified">!   const VariationStore &amp;get_var_store () const</span>
<span class="line-added">+   { return version.to_int () &lt; 0x00010001u ? Null (VariationStore) : this+varStore; }</span>
  
<span class="line-modified">!   bool get_baseline (hb_font_t               *font,</span>
<span class="line-added">+                      hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">+                      hb_direction_t           direction,</span>
<span class="line-added">+                      hb_tag_t                 script_tag,</span>
<span class="line-added">+                      hb_tag_t                 language_tag,</span>
<span class="line-added">+                      hb_position_t           *base) const</span>
    {
<span class="line-modified">!     const BaseCoord *base_coord;</span>
<span class="line-modified">!     if (!get_axis (direction).get_baseline (baseline, script_tag, language_tag, &amp;base_coord))</span>
<span class="line-modified">!       return false;</span>
  
<span class="line-modified">!     if (likely (base &amp;&amp; base_coord)) *base = base_coord-&gt;get_coord (font,</span>
<span class="line-modified">!                                                                     get_var_store (),</span>
<span class="line-modified">!                                                                     direction);</span>
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   /* TODO: Expose this separately sometime? */</span>
<span class="line-added">+   bool get_min_max (hb_font_t      *font,</span>
<span class="line-added">+                     hb_direction_t  direction,</span>
<span class="line-added">+                     hb_tag_t        script_tag,</span>
<span class="line-added">+                     hb_tag_t        language_tag,</span>
<span class="line-added">+                     hb_tag_t        feature_tag,</span>
<span class="line-added">+                     hb_position_t  *min,</span>
<span class="line-added">+                     hb_position_t  *max)</span>
    {
<span class="line-modified">!     const BaseCoord *min_coord, *max_coord;</span>
<span class="line-modified">!     if (!get_axis (direction).get_min_max (script_tag, language_tag, feature_tag,</span>
<span class="line-modified">!                                            &amp;min_coord, &amp;max_coord))</span>
<span class="line-modified">!       return false;</span>
  
<span class="line-modified">!     const VariationStore &amp;var_store = get_var_store ();</span>
<span class="line-modified">!     if (likely (min &amp;&amp; min_coord)) *min = min_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">!     if (likely (max &amp;&amp; max_coord)) *max = max_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">!     return true;</span>
    }
  
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
<span class="line-modified">!     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                           likely (version.major == 1) &amp;&amp;</span>
<span class="line-modified">!                           hAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           vAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">!                           (version.to_int () &lt; 0x00010001u || varStore.sanitize (c, this))));</span>
    }
  
    protected:
<span class="line-modified">!   FixedVersion&lt;&gt;version;        /* Version of the BASE table */</span>
<span class="line-modified">!   OffsetTo&lt;Axis&gt;hAxis;          /* Offset to horizontal Axis table, from beginning</span>
<span class="line-modified">!                                  * of BASE table (may be NULL) */</span>
<span class="line-added">+   OffsetTo&lt;Axis&gt;vAxis;          /* Offset to vertical Axis table, from beginning</span>
<span class="line-added">+                                  * of BASE table (may be NULL) */</span>
    LOffsetTo&lt;VariationStore&gt;
<span class="line-modified">!                 varStore;       /* Offset to the table of Item Variation</span>
<span class="line-modified">!                                  * Store--from beginning of BASE</span>
<span class="line-modified">!                                  * header (may be NULL).  Introduced</span>
<span class="line-modified">!                                  * in version 0x00010001. */</span>
    public:
    DEFINE_SIZE_MIN (8);
  };
  
  
</pre>
<center><a href="hb-ot-kern-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gdef-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
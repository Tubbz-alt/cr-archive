<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-dsalgs.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-face.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb-private.hh&quot;</span>
 30 
<span class="line-modified"> 31 #include &quot;hb-face-private.hh&quot;</span>
<span class="line-modified"> 32 #include &quot;hb-blob-private.hh&quot;</span>
<span class="line-modified"> 33 #include &quot;hb-open-file-private.hh&quot;</span>
<span class="line-modified"> 34 #include &quot;hb-ot-head-table.hh&quot;</span>
<span class="line-modified"> 35 #include &quot;hb-ot-maxp-table.hh&quot;</span>
 36 
 37 












 38 
 39 /**
<span class="line-modified"> 40  * hb_face_count: Get number of faces on the blob</span>
<span class="line-modified"> 41  * @blob:</span>
 42  *

 43  *
<span class="line-modified"> 44  *</span>
<span class="line-removed"> 45  * Return value: Number of faces on the blob</span>
 46  *
 47  * Since: 1.7.7
 48  **/
 49 unsigned int
 50 hb_face_count (hb_blob_t *blob)
 51 {
 52   if (unlikely (!blob))
 53     return 0;
 54 
<span class="line-modified"> 55   hb_blob_t *sanitized = OT::Sanitizer&lt;OT::OpenTypeFontFile&gt; ().sanitize (blob);</span>


 56   const OT::OpenTypeFontFile&amp; ot = *sanitized-&gt;as&lt;OT::OpenTypeFontFile&gt; ();


 57 
<span class="line-modified"> 58   return ot.get_face_count ();</span>
 59 }
 60 
 61 /*
 62  * hb_face_t
 63  */
 64 
<span class="line-modified"> 65 const hb_face_t _hb_face_nil = {</span>

 66   HB_OBJECT_HEADER_STATIC,
 67 
<span class="line-removed"> 68   true, /* immutable */</span>
<span class="line-removed"> 69 </span>
 70   nullptr, /* reference_table_func */
 71   nullptr, /* user_data */
 72   nullptr, /* destroy */
 73 
 74   0,    /* index */
<span class="line-modified"> 75   1000, /* upem */</span>
<span class="line-modified"> 76   0,    /* num_glyphs */</span>
 77 
<span class="line-modified"> 78   {</span>
<span class="line-removed"> 79 #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INVALID,</span>
<span class="line-removed"> 80 #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed"> 81 #undef HB_SHAPER_IMPLEMENT</span>
<span class="line-removed"> 82   },</span>
<span class="line-removed"> 83 </span>
<span class="line-removed"> 84   nullptr, /* shape_plans */</span>
 85 };
 86 
 87 
 88 /**
 89  * hb_face_create_for_tables:
 90  * @reference_table_func: (closure user_data) (destroy destroy) (scope notified):
 91  * @user_data:
 92  * @destroy:
 93  *
 94  *
 95  *
 96  * Return value: (transfer full)
 97  *
 98  * Since: 0.9.2
 99  **/
100 hb_face_t *
101 hb_face_create_for_tables (hb_reference_table_func_t  reference_table_func,
102                            void                      *user_data,
103                            hb_destroy_func_t          destroy)
104 {
105   hb_face_t *face;
106 
107   if (!reference_table_func || !(face = hb_object_create&lt;hb_face_t&gt; ())) {
108     if (destroy)
109       destroy (user_data);
110     return hb_face_get_empty ();
111   }
112 
113   face-&gt;reference_table_func = reference_table_func;
114   face-&gt;user_data = user_data;
115   face-&gt;destroy = destroy;
116 
<span class="line-modified">117   face-&gt;upem = 0;</span>
<span class="line-modified">118   face-&gt;num_glyphs = (unsigned int) -1;</span>


119 
120   return face;
121 }
122 
123 
124 typedef struct hb_face_for_data_closure_t {
125   hb_blob_t *blob;
126   unsigned int  index;
127 } hb_face_for_data_closure_t;
128 
129 static hb_face_for_data_closure_t *
130 _hb_face_for_data_closure_create (hb_blob_t *blob, unsigned int index)
131 {
132   hb_face_for_data_closure_t *closure;
133 
134   closure = (hb_face_for_data_closure_t *) calloc (1, sizeof (hb_face_for_data_closure_t));
135   if (unlikely (!closure))
136     return nullptr;
137 
138   closure-&gt;blob = blob;
</pre>
<hr />
<pre>
142 }
143 
144 static void
145 _hb_face_for_data_closure_destroy (void *data)
146 {
147   hb_face_for_data_closure_t *closure = (hb_face_for_data_closure_t *) data;
148 
149   hb_blob_destroy (closure-&gt;blob);
150   free (closure);
151 }
152 
153 static hb_blob_t *
154 _hb_face_for_data_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
155 {
156   hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) user_data;
157 
158   if (tag == HB_TAG_NONE)
159     return hb_blob_reference (data-&gt;blob);
160 
161   const OT::OpenTypeFontFile &amp;ot_file = *data-&gt;blob-&gt;as&lt;OT::OpenTypeFontFile&gt; ();
<span class="line-modified">162   const OT::OpenTypeFontFace &amp;ot_face = ot_file.get_face (data-&gt;index);</span>

163 
164   const OT::OpenTypeTable &amp;table = ot_face.get_table_by_tag (tag);
165 
<span class="line-modified">166   hb_blob_t *blob = hb_blob_create_sub_blob (data-&gt;blob, table.offset, table.length);</span>
167 
168   return blob;
169 }
170 
171 /**
172  * hb_face_create: (Xconstructor)
173  * @blob:
174  * @index:
175  *
176  *
177  *
178  * Return value: (transfer full):
179  *
180  * Since: 0.9.2
181  **/
182 hb_face_t *
183 hb_face_create (hb_blob_t    *blob,
184                 unsigned int  index)
185 {
186   hb_face_t *face;
187 
188   if (unlikely (!blob))
189     blob = hb_blob_get_empty ();
190 
<span class="line-modified">191   hb_face_for_data_closure_t *closure = _hb_face_for_data_closure_create (OT::Sanitizer&lt;OT::OpenTypeFontFile&gt;().sanitize (hb_blob_reference (blob)), index);</span>
192 
193   if (unlikely (!closure))
194     return hb_face_get_empty ();
195 
196   face = hb_face_create_for_tables (_hb_face_for_data_reference_table,
197                                     closure,
198                                     _hb_face_for_data_closure_destroy);
199 
200   face-&gt;index = index;
201 
202   return face;
203 }
204 
205 /**
206  * hb_face_get_empty:
207  *
208  *
209  *
210  * Return value: (transfer full)
211  *
212  * Since: 0.9.2
213  **/
214 hb_face_t *
<span class="line-modified">215 hb_face_get_empty (void)</span>
216 {
<span class="line-modified">217   return const_cast&lt;hb_face_t *&gt; (&amp;_hb_face_nil);</span>
218 }
219 
220 
221 /**
222  * hb_face_reference: (skip)
223  * @face: a face.
224  *
225  *
226  *
227  * Return value:
228  *
229  * Since: 0.9.2
230  **/
231 hb_face_t *
232 hb_face_reference (hb_face_t *face)
233 {
234   return hb_object_reference (face);
235 }
236 
237 /**
238  * hb_face_destroy: (skip)
239  * @face: a face.
240  *
241  *
242  *
243  * Since: 0.9.2
244  **/
245 void
246 hb_face_destroy (hb_face_t *face)
247 {
248   if (!hb_object_destroy (face)) return;
249 
250   for (hb_face_t::plan_node_t *node = face-&gt;shape_plans; node; )
251   {
252     hb_face_t::plan_node_t *next = node-&gt;next;
253     hb_shape_plan_destroy (node-&gt;shape_plan);
254     free (node);
255     node = next;
256   }
257 
<span class="line-modified">258 #define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_DESTROY(shaper, face);</span>
<span class="line-modified">259 #include &quot;hb-shaper-list.hh&quot;</span>
<span class="line-removed">260 #undef HB_SHAPER_IMPLEMENT</span>
261 
262   if (face-&gt;destroy)
263     face-&gt;destroy (face-&gt;user_data);
264 
265   free (face);
266 }
267 
268 /**
269  * hb_face_set_user_data: (skip)
270  * @face: a face.
271  * @key:
272  * @data:
273  * @destroy:
274  * @replace:
275  *
276  *
277  *
278  * Return value:
279  *
280  * Since: 0.9.2
</pre>
<hr />
<pre>
284                        hb_user_data_key_t *key,
285                        void *              data,
286                        hb_destroy_func_t   destroy,
287                        hb_bool_t           replace)
288 {
289   return hb_object_set_user_data (face, key, data, destroy, replace);
290 }
291 
292 /**
293  * hb_face_get_user_data: (skip)
294  * @face: a face.
295  * @key:
296  *
297  *
298  *
299  * Return value: (transfer none):
300  *
301  * Since: 0.9.2
302  **/
303 void *
<span class="line-modified">304 hb_face_get_user_data (hb_face_t          *face,</span>
305                        hb_user_data_key_t *key)
306 {
307   return hb_object_get_user_data (face, key);
308 }
309 
310 /**
311  * hb_face_make_immutable:
312  * @face: a face.
313  *
314  *
315  *
316  * Since: 0.9.2
317  **/
318 void
319 hb_face_make_immutable (hb_face_t *face)
320 {
<span class="line-modified">321   if (unlikely (hb_object_is_inert (face)))</span>
322     return;
323 
<span class="line-modified">324   face-&gt;immutable = true;</span>
325 }
326 
327 /**
328  * hb_face_is_immutable:
329  * @face: a face.
330  *
331  *
332  *
333  * Return value:
334  *
335  * Since: 0.9.2
336  **/
337 hb_bool_t
<span class="line-modified">338 hb_face_is_immutable (hb_face_t *face)</span>
339 {
<span class="line-modified">340   return face-&gt;immutable;</span>
341 }
342 
343 
344 /**
345  * hb_face_reference_table:
346  * @face: a face.
347  * @tag:
348  *
349  *
350  *
351  * Return value: (transfer full):
352  *
353  * Since: 0.9.2
354  **/
355 hb_blob_t *
<span class="line-modified">356 hb_face_reference_table (hb_face_t *face,</span>
<span class="line-modified">357                          hb_tag_t   tag)</span>
358 {
359   return face-&gt;reference_table (tag);
360 }
361 
362 /**
363  * hb_face_reference_blob:
364  * @face: a face.
365  *
366  *
367  *
368  * Return value: (transfer full):
369  *
370  * Since: 0.9.2
371  **/
372 hb_blob_t *
373 hb_face_reference_blob (hb_face_t *face)
374 {
375   return face-&gt;reference_table (HB_TAG_NONE);
376 }
377 
378 /**
379  * hb_face_set_index:
380  * @face: a face.
381  * @index:
382  *
383  *
384  *
385  * Since: 0.9.2
386  **/
387 void
388 hb_face_set_index (hb_face_t    *face,
389                    unsigned int  index)
390 {
<span class="line-modified">391   if (face-&gt;immutable)</span>
392     return;
393 
394   face-&gt;index = index;
395 }
396 
397 /**
398  * hb_face_get_index:
399  * @face: a face.
400  *
401  *
402  *
403  * Return value:
404  *
405  * Since: 0.9.2
406  **/
407 unsigned int
<span class="line-modified">408 hb_face_get_index (hb_face_t    *face)</span>
409 {
410   return face-&gt;index;
411 }
412 
413 /**
414  * hb_face_set_upem:
415  * @face: a face.
416  * @upem:
417  *
418  *
419  *
420  * Since: 0.9.2
421  **/
422 void
423 hb_face_set_upem (hb_face_t    *face,
424                   unsigned int  upem)
425 {
<span class="line-modified">426   if (face-&gt;immutable)</span>
427     return;
428 
<span class="line-modified">429   face-&gt;upem = upem;</span>
430 }
431 
432 /**
433  * hb_face_get_upem:
434  * @face: a face.
435  *
436  *
437  *
438  * Return value:
439  *
440  * Since: 0.9.2
441  **/
442 unsigned int
<span class="line-modified">443 hb_face_get_upem (hb_face_t *face)</span>
444 {
445   return face-&gt;get_upem ();
446 }
447 
<span class="line-removed">448 void</span>
<span class="line-removed">449 hb_face_t::load_upem (void) const</span>
<span class="line-removed">450 {</span>
<span class="line-removed">451   hb_blob_t *head_blob = OT::Sanitizer&lt;OT::head&gt;().sanitize (reference_table (HB_OT_TAG_head));</span>
<span class="line-removed">452   const OT::head *head_table = head_blob-&gt;as&lt;OT::head&gt; ();</span>
<span class="line-removed">453   upem = head_table-&gt;get_upem ();</span>
<span class="line-removed">454   hb_blob_destroy (head_blob);</span>
<span class="line-removed">455 }</span>
<span class="line-removed">456 </span>
457 /**
458  * hb_face_set_glyph_count:
459  * @face: a face.
460  * @glyph_count:
461  *
462  *
463  *
464  * Since: 0.9.7
465  **/
466 void
467 hb_face_set_glyph_count (hb_face_t    *face,
468                          unsigned int  glyph_count)
469 {
<span class="line-modified">470   if (face-&gt;immutable)</span>
471     return;
472 
<span class="line-modified">473   face-&gt;num_glyphs = glyph_count;</span>
474 }
475 
476 /**
477  * hb_face_get_glyph_count:
478  * @face: a face.
479  *
480  *
481  *
482  * Return value:
483  *
484  * Since: 0.9.7
485  **/
486 unsigned int
<span class="line-modified">487 hb_face_get_glyph_count (hb_face_t *face)</span>
488 {
489   return face-&gt;get_num_glyphs ();
490 }
491 
<span class="line-removed">492 void</span>
<span class="line-removed">493 hb_face_t::load_num_glyphs (void) const</span>
<span class="line-removed">494 {</span>
<span class="line-removed">495   hb_blob_t *maxp_blob = OT::Sanitizer&lt;OT::maxp&gt;().sanitize (reference_table (HB_OT_TAG_maxp));</span>
<span class="line-removed">496   const OT::maxp *maxp_table = maxp_blob-&gt;as&lt;OT::maxp&gt; ();</span>
<span class="line-removed">497   num_glyphs = maxp_table-&gt;get_num_glyphs ();</span>
<span class="line-removed">498   hb_blob_destroy (maxp_blob);</span>
<span class="line-removed">499 }</span>
<span class="line-removed">500 </span>
501 /**
502  * hb_face_get_table_tags:
503  * @face: a face.



504  *
505  * Retrieves table tags for a face, if possible.
506  *
507  * Return value: total number of tables, or 0 if not possible to list.
508  *
509  * Since: 1.6.0
510  **/
511 unsigned int
<span class="line-modified">512 hb_face_get_table_tags (hb_face_t    *face,</span>
513                         unsigned int  start_offset,
514                         unsigned int *table_count, /* IN/OUT */
515                         hb_tag_t     *table_tags /* OUT */)
516 {
517   if (face-&gt;destroy != (hb_destroy_func_t) _hb_face_for_data_closure_destroy)
518   {
519     if (table_count)
520       *table_count = 0;
521     return 0;
522   }
523 
524   hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) face-&gt;user_data;
525 
526   const OT::OpenTypeFontFile &amp;ot_file = *data-&gt;blob-&gt;as&lt;OT::OpenTypeFontFile&gt; ();
527   const OT::OpenTypeFontFace &amp;ot_face = ot_file.get_face (data-&gt;index);
528 
529   return ot_face.get_table_tags (start_offset, table_count, table_tags);
530 }





































































































































































































</pre>
</td>
<td>
<hr />
<pre>
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
<span class="line-modified"> 29 #include &quot;hb.hh&quot;</span>
 30 
<span class="line-modified"> 31 #include &quot;hb-face.hh&quot;</span>
<span class="line-modified"> 32 #include &quot;hb-blob.hh&quot;</span>
<span class="line-modified"> 33 #include &quot;hb-open-file.hh&quot;</span>
<span class="line-modified"> 34 #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified"> 35 #include &quot;hb-ot-cmap-table.hh&quot;</span>
 36 
 37 
<span class="line-added"> 38 /**</span>
<span class="line-added"> 39  * SECTION:hb-face</span>
<span class="line-added"> 40  * @title: hb-face</span>
<span class="line-added"> 41  * @short_description: Font face objects</span>
<span class="line-added"> 42  * @include: hb.h</span>
<span class="line-added"> 43  *</span>
<span class="line-added"> 44  * Font face is objects represent a single face in a font family.</span>
<span class="line-added"> 45  * More exactly, a font face represents a single face in a binary font file.</span>
<span class="line-added"> 46  * Font faces are typically built from a binary blob and a face index.</span>
<span class="line-added"> 47  * Font faces are used to create fonts.</span>
<span class="line-added"> 48  **/</span>
<span class="line-added"> 49 </span>
 50 
 51 /**
<span class="line-modified"> 52  * hb_face_count:</span>
<span class="line-modified"> 53  * @blob: a blob.</span>
 54  *
<span class="line-added"> 55  * Get number of faces in a blob.</span>
 56  *
<span class="line-modified"> 57  * Return value: Number of faces in @blob</span>

 58  *
 59  * Since: 1.7.7
 60  **/
 61 unsigned int
 62 hb_face_count (hb_blob_t *blob)
 63 {
 64   if (unlikely (!blob))
 65     return 0;
 66 
<span class="line-modified"> 67   /* TODO We shouldn&#39;t be sanitizing blob.  Port to run sanitizer and return if not sane. */</span>
<span class="line-added"> 68   /* Make API signature const after. */</span>
<span class="line-added"> 69   hb_blob_t *sanitized = hb_sanitize_context_t ().sanitize_blob&lt;OT::OpenTypeFontFile&gt; (hb_blob_reference (blob));</span>
 70   const OT::OpenTypeFontFile&amp; ot = *sanitized-&gt;as&lt;OT::OpenTypeFontFile&gt; ();
<span class="line-added"> 71   unsigned int ret = ot.get_face_count ();</span>
<span class="line-added"> 72   hb_blob_destroy (sanitized);</span>
 73 
<span class="line-modified"> 74   return ret;</span>
 75 }
 76 
 77 /*
 78  * hb_face_t
 79  */
 80 
<span class="line-modified"> 81 DEFINE_NULL_INSTANCE (hb_face_t) =</span>
<span class="line-added"> 82 {</span>
 83   HB_OBJECT_HEADER_STATIC,
 84 


 85   nullptr, /* reference_table_func */
 86   nullptr, /* user_data */
 87   nullptr, /* destroy */
 88 
 89   0,    /* index */
<span class="line-modified"> 90   HB_ATOMIC_INT_INIT (1000), /* upem */</span>
<span class="line-modified"> 91   HB_ATOMIC_INT_INIT (0),    /* num_glyphs */</span>
 92 
<span class="line-modified"> 93   /* Zero for the rest is fine. */</span>






 94 };
 95 
 96 
 97 /**
 98  * hb_face_create_for_tables:
 99  * @reference_table_func: (closure user_data) (destroy destroy) (scope notified):
100  * @user_data:
101  * @destroy:
102  *
103  *
104  *
105  * Return value: (transfer full)
106  *
107  * Since: 0.9.2
108  **/
109 hb_face_t *
110 hb_face_create_for_tables (hb_reference_table_func_t  reference_table_func,
111                            void                      *user_data,
112                            hb_destroy_func_t          destroy)
113 {
114   hb_face_t *face;
115 
116   if (!reference_table_func || !(face = hb_object_create&lt;hb_face_t&gt; ())) {
117     if (destroy)
118       destroy (user_data);
119     return hb_face_get_empty ();
120   }
121 
122   face-&gt;reference_table_func = reference_table_func;
123   face-&gt;user_data = user_data;
124   face-&gt;destroy = destroy;
125 
<span class="line-modified">126   face-&gt;num_glyphs.set_relaxed (-1);</span>
<span class="line-modified">127 </span>
<span class="line-added">128   face-&gt;data.init0 (face);</span>
<span class="line-added">129   face-&gt;table.init0 (face);</span>
130 
131   return face;
132 }
133 
134 
135 typedef struct hb_face_for_data_closure_t {
136   hb_blob_t *blob;
137   unsigned int  index;
138 } hb_face_for_data_closure_t;
139 
140 static hb_face_for_data_closure_t *
141 _hb_face_for_data_closure_create (hb_blob_t *blob, unsigned int index)
142 {
143   hb_face_for_data_closure_t *closure;
144 
145   closure = (hb_face_for_data_closure_t *) calloc (1, sizeof (hb_face_for_data_closure_t));
146   if (unlikely (!closure))
147     return nullptr;
148 
149   closure-&gt;blob = blob;
</pre>
<hr />
<pre>
153 }
154 
155 static void
156 _hb_face_for_data_closure_destroy (void *data)
157 {
158   hb_face_for_data_closure_t *closure = (hb_face_for_data_closure_t *) data;
159 
160   hb_blob_destroy (closure-&gt;blob);
161   free (closure);
162 }
163 
164 static hb_blob_t *
165 _hb_face_for_data_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
166 {
167   hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) user_data;
168 
169   if (tag == HB_TAG_NONE)
170     return hb_blob_reference (data-&gt;blob);
171 
172   const OT::OpenTypeFontFile &amp;ot_file = *data-&gt;blob-&gt;as&lt;OT::OpenTypeFontFile&gt; ();
<span class="line-modified">173   unsigned int base_offset;</span>
<span class="line-added">174   const OT::OpenTypeFontFace &amp;ot_face = ot_file.get_face (data-&gt;index, &amp;base_offset);</span>
175 
176   const OT::OpenTypeTable &amp;table = ot_face.get_table_by_tag (tag);
177 
<span class="line-modified">178   hb_blob_t *blob = hb_blob_create_sub_blob (data-&gt;blob, base_offset + table.offset, table.length);</span>
179 
180   return blob;
181 }
182 
183 /**
184  * hb_face_create: (Xconstructor)
185  * @blob:
186  * @index:
187  *
188  *
189  *
190  * Return value: (transfer full):
191  *
192  * Since: 0.9.2
193  **/
194 hb_face_t *
195 hb_face_create (hb_blob_t    *blob,
196                 unsigned int  index)
197 {
198   hb_face_t *face;
199 
200   if (unlikely (!blob))
201     blob = hb_blob_get_empty ();
202 
<span class="line-modified">203   hb_face_for_data_closure_t *closure = _hb_face_for_data_closure_create (hb_sanitize_context_t ().sanitize_blob&lt;OT::OpenTypeFontFile&gt; (hb_blob_reference (blob)), index);</span>
204 
205   if (unlikely (!closure))
206     return hb_face_get_empty ();
207 
208   face = hb_face_create_for_tables (_hb_face_for_data_reference_table,
209                                     closure,
210                                     _hb_face_for_data_closure_destroy);
211 
212   face-&gt;index = index;
213 
214   return face;
215 }
216 
217 /**
218  * hb_face_get_empty:
219  *
220  *
221  *
222  * Return value: (transfer full)
223  *
224  * Since: 0.9.2
225  **/
226 hb_face_t *
<span class="line-modified">227 hb_face_get_empty ()</span>
228 {
<span class="line-modified">229   return const_cast&lt;hb_face_t *&gt; (&amp;Null(hb_face_t));</span>
230 }
231 
232 
233 /**
234  * hb_face_reference: (skip)
235  * @face: a face.
236  *
237  *
238  *
239  * Return value:
240  *
241  * Since: 0.9.2
242  **/
243 hb_face_t *
244 hb_face_reference (hb_face_t *face)
245 {
246   return hb_object_reference (face);
247 }
248 
249 /**
250  * hb_face_destroy: (skip)
251  * @face: a face.
252  *
253  *
254  *
255  * Since: 0.9.2
256  **/
257 void
258 hb_face_destroy (hb_face_t *face)
259 {
260   if (!hb_object_destroy (face)) return;
261 
262   for (hb_face_t::plan_node_t *node = face-&gt;shape_plans; node; )
263   {
264     hb_face_t::plan_node_t *next = node-&gt;next;
265     hb_shape_plan_destroy (node-&gt;shape_plan);
266     free (node);
267     node = next;
268   }
269 
<span class="line-modified">270   face-&gt;data.fini ();</span>
<span class="line-modified">271   face-&gt;table.fini ();</span>

272 
273   if (face-&gt;destroy)
274     face-&gt;destroy (face-&gt;user_data);
275 
276   free (face);
277 }
278 
279 /**
280  * hb_face_set_user_data: (skip)
281  * @face: a face.
282  * @key:
283  * @data:
284  * @destroy:
285  * @replace:
286  *
287  *
288  *
289  * Return value:
290  *
291  * Since: 0.9.2
</pre>
<hr />
<pre>
295                        hb_user_data_key_t *key,
296                        void *              data,
297                        hb_destroy_func_t   destroy,
298                        hb_bool_t           replace)
299 {
300   return hb_object_set_user_data (face, key, data, destroy, replace);
301 }
302 
303 /**
304  * hb_face_get_user_data: (skip)
305  * @face: a face.
306  * @key:
307  *
308  *
309  *
310  * Return value: (transfer none):
311  *
312  * Since: 0.9.2
313  **/
314 void *
<span class="line-modified">315 hb_face_get_user_data (const hb_face_t    *face,</span>
316                        hb_user_data_key_t *key)
317 {
318   return hb_object_get_user_data (face, key);
319 }
320 
321 /**
322  * hb_face_make_immutable:
323  * @face: a face.
324  *
325  *
326  *
327  * Since: 0.9.2
328  **/
329 void
330 hb_face_make_immutable (hb_face_t *face)
331 {
<span class="line-modified">332   if (hb_object_is_immutable (face))</span>
333     return;
334 
<span class="line-modified">335   hb_object_make_immutable (face);</span>
336 }
337 
338 /**
339  * hb_face_is_immutable:
340  * @face: a face.
341  *
342  *
343  *
344  * Return value:
345  *
346  * Since: 0.9.2
347  **/
348 hb_bool_t
<span class="line-modified">349 hb_face_is_immutable (const hb_face_t *face)</span>
350 {
<span class="line-modified">351   return hb_object_is_immutable (face);</span>
352 }
353 
354 
355 /**
356  * hb_face_reference_table:
357  * @face: a face.
358  * @tag:
359  *
360  *
361  *
362  * Return value: (transfer full):
363  *
364  * Since: 0.9.2
365  **/
366 hb_blob_t *
<span class="line-modified">367 hb_face_reference_table (const hb_face_t *face,</span>
<span class="line-modified">368                          hb_tag_t tag)</span>
369 {
370   return face-&gt;reference_table (tag);
371 }
372 
373 /**
374  * hb_face_reference_blob:
375  * @face: a face.
376  *
377  *
378  *
379  * Return value: (transfer full):
380  *
381  * Since: 0.9.2
382  **/
383 hb_blob_t *
384 hb_face_reference_blob (hb_face_t *face)
385 {
386   return face-&gt;reference_table (HB_TAG_NONE);
387 }
388 
389 /**
390  * hb_face_set_index:
391  * @face: a face.
392  * @index:
393  *
394  *
395  *
396  * Since: 0.9.2
397  **/
398 void
399 hb_face_set_index (hb_face_t    *face,
400                    unsigned int  index)
401 {
<span class="line-modified">402   if (hb_object_is_immutable (face))</span>
403     return;
404 
405   face-&gt;index = index;
406 }
407 
408 /**
409  * hb_face_get_index:
410  * @face: a face.
411  *
412  *
413  *
414  * Return value:
415  *
416  * Since: 0.9.2
417  **/
418 unsigned int
<span class="line-modified">419 hb_face_get_index (const hb_face_t *face)</span>
420 {
421   return face-&gt;index;
422 }
423 
424 /**
425  * hb_face_set_upem:
426  * @face: a face.
427  * @upem:
428  *
429  *
430  *
431  * Since: 0.9.2
432  **/
433 void
434 hb_face_set_upem (hb_face_t    *face,
435                   unsigned int  upem)
436 {
<span class="line-modified">437   if (hb_object_is_immutable (face))</span>
438     return;
439 
<span class="line-modified">440   face-&gt;upem.set_relaxed (upem);</span>
441 }
442 
443 /**
444  * hb_face_get_upem:
445  * @face: a face.
446  *
447  *
448  *
449  * Return value:
450  *
451  * Since: 0.9.2
452  **/
453 unsigned int
<span class="line-modified">454 hb_face_get_upem (const hb_face_t *face)</span>
455 {
456   return face-&gt;get_upem ();
457 }
458 









459 /**
460  * hb_face_set_glyph_count:
461  * @face: a face.
462  * @glyph_count:
463  *
464  *
465  *
466  * Since: 0.9.7
467  **/
468 void
469 hb_face_set_glyph_count (hb_face_t    *face,
470                          unsigned int  glyph_count)
471 {
<span class="line-modified">472   if (hb_object_is_immutable (face))</span>
473     return;
474 
<span class="line-modified">475   face-&gt;num_glyphs.set_relaxed (glyph_count);</span>
476 }
477 
478 /**
479  * hb_face_get_glyph_count:
480  * @face: a face.
481  *
482  *
483  *
484  * Return value:
485  *
486  * Since: 0.9.7
487  **/
488 unsigned int
<span class="line-modified">489 hb_face_get_glyph_count (const hb_face_t *face)</span>
490 {
491   return face-&gt;get_num_glyphs ();
492 }
493 









494 /**
495  * hb_face_get_table_tags:
496  * @face: a face.
<span class="line-added">497  * @start_offset: index of first tag to return.</span>
<span class="line-added">498  * @table_count: input length of @table_tags array, output number of items written.</span>
<span class="line-added">499  * @table_tags: array to write tags into.</span>
500  *
501  * Retrieves table tags for a face, if possible.
502  *
503  * Return value: total number of tables, or 0 if not possible to list.
504  *
505  * Since: 1.6.0
506  **/
507 unsigned int
<span class="line-modified">508 hb_face_get_table_tags (const hb_face_t *face,</span>
509                         unsigned int  start_offset,
510                         unsigned int *table_count, /* IN/OUT */
511                         hb_tag_t     *table_tags /* OUT */)
512 {
513   if (face-&gt;destroy != (hb_destroy_func_t) _hb_face_for_data_closure_destroy)
514   {
515     if (table_count)
516       *table_count = 0;
517     return 0;
518   }
519 
520   hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) face-&gt;user_data;
521 
522   const OT::OpenTypeFontFile &amp;ot_file = *data-&gt;blob-&gt;as&lt;OT::OpenTypeFontFile&gt; ();
523   const OT::OpenTypeFontFace &amp;ot_face = ot_file.get_face (data-&gt;index);
524 
525   return ot_face.get_table_tags (start_offset, table_count, table_tags);
526 }
<span class="line-added">527 </span>
<span class="line-added">528 </span>
<span class="line-added">529 /*</span>
<span class="line-added">530  * Character set.</span>
<span class="line-added">531  */</span>
<span class="line-added">532 </span>
<span class="line-added">533 </span>
<span class="line-added">534 /**</span>
<span class="line-added">535  * hb_face_collect_unicodes:</span>
<span class="line-added">536  * @face: font face.</span>
<span class="line-added">537  * @out: set to add Unicode characters covered by @face to.</span>
<span class="line-added">538  *</span>
<span class="line-added">539  * Since: 1.9.0</span>
<span class="line-added">540  */</span>
<span class="line-added">541 void</span>
<span class="line-added">542 hb_face_collect_unicodes (hb_face_t *face,</span>
<span class="line-added">543                           hb_set_t  *out)</span>
<span class="line-added">544 {</span>
<span class="line-added">545   face-&gt;table.cmap-&gt;collect_unicodes (out);</span>
<span class="line-added">546 }</span>
<span class="line-added">547 </span>
<span class="line-added">548 /**</span>
<span class="line-added">549  * hb_face_collect_variation_selectors:</span>
<span class="line-added">550  * @face: font face.</span>
<span class="line-added">551  * @out: set to add Variation Selector characters covered by @face to.</span>
<span class="line-added">552  *</span>
<span class="line-added">553  *</span>
<span class="line-added">554  *</span>
<span class="line-added">555  * Since: 1.9.0</span>
<span class="line-added">556  */</span>
<span class="line-added">557 void</span>
<span class="line-added">558 hb_face_collect_variation_selectors (hb_face_t *face,</span>
<span class="line-added">559                                      hb_set_t  *out)</span>
<span class="line-added">560 {</span>
<span class="line-added">561   face-&gt;table.cmap-&gt;collect_variation_selectors (out);</span>
<span class="line-added">562 }</span>
<span class="line-added">563 </span>
<span class="line-added">564 /**</span>
<span class="line-added">565  * hb_face_collect_variation_unicodes:</span>
<span class="line-added">566  * @face: font face.</span>
<span class="line-added">567  * @out: set to add Unicode characters for @variation_selector covered by @face to.</span>
<span class="line-added">568  *</span>
<span class="line-added">569  *</span>
<span class="line-added">570  *</span>
<span class="line-added">571  * Since: 1.9.0</span>
<span class="line-added">572  */</span>
<span class="line-added">573 void</span>
<span class="line-added">574 hb_face_collect_variation_unicodes (hb_face_t *face,</span>
<span class="line-added">575                                     hb_codepoint_t variation_selector,</span>
<span class="line-added">576                                     hb_set_t  *out)</span>
<span class="line-added">577 {</span>
<span class="line-added">578   face-&gt;table.cmap-&gt;collect_variation_unicodes (variation_selector, out);</span>
<span class="line-added">579 }</span>
<span class="line-added">580 </span>
<span class="line-added">581 </span>
<span class="line-added">582 </span>
<span class="line-added">583 /*</span>
<span class="line-added">584  * face-builder: A face that has add_table().</span>
<span class="line-added">585  */</span>
<span class="line-added">586 </span>
<span class="line-added">587 struct hb_face_builder_data_t</span>
<span class="line-added">588 {</span>
<span class="line-added">589   struct table_entry_t</span>
<span class="line-added">590   {</span>
<span class="line-added">591     int cmp (hb_tag_t t) const</span>
<span class="line-added">592     {</span>
<span class="line-added">593       if (t &lt; tag) return -1;</span>
<span class="line-added">594       if (t &gt; tag) return -1;</span>
<span class="line-added">595       return 0;</span>
<span class="line-added">596     }</span>
<span class="line-added">597 </span>
<span class="line-added">598     hb_tag_t   tag;</span>
<span class="line-added">599     hb_blob_t *blob;</span>
<span class="line-added">600   };</span>
<span class="line-added">601 </span>
<span class="line-added">602   hb_vector_t&lt;table_entry_t&gt; tables;</span>
<span class="line-added">603 };</span>
<span class="line-added">604 </span>
<span class="line-added">605 static hb_face_builder_data_t *</span>
<span class="line-added">606 _hb_face_builder_data_create ()</span>
<span class="line-added">607 {</span>
<span class="line-added">608   hb_face_builder_data_t *data = (hb_face_builder_data_t *) calloc (1, sizeof (hb_face_builder_data_t));</span>
<span class="line-added">609   if (unlikely (!data))</span>
<span class="line-added">610     return nullptr;</span>
<span class="line-added">611 </span>
<span class="line-added">612   data-&gt;tables.init ();</span>
<span class="line-added">613 </span>
<span class="line-added">614   return data;</span>
<span class="line-added">615 }</span>
<span class="line-added">616 </span>
<span class="line-added">617 static void</span>
<span class="line-added">618 _hb_face_builder_data_destroy (void *user_data)</span>
<span class="line-added">619 {</span>
<span class="line-added">620   hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;</span>
<span class="line-added">621 </span>
<span class="line-added">622   for (unsigned int i = 0; i &lt; data-&gt;tables.length; i++)</span>
<span class="line-added">623     hb_blob_destroy (data-&gt;tables[i].blob);</span>
<span class="line-added">624 </span>
<span class="line-added">625   data-&gt;tables.fini ();</span>
<span class="line-added">626 </span>
<span class="line-added">627   free (data);</span>
<span class="line-added">628 }</span>
<span class="line-added">629 </span>
<span class="line-added">630 static hb_blob_t *</span>
<span class="line-added">631 _hb_face_builder_data_reference_blob (hb_face_builder_data_t *data)</span>
<span class="line-added">632 {</span>
<span class="line-added">633 </span>
<span class="line-added">634   unsigned int table_count = data-&gt;tables.length;</span>
<span class="line-added">635   unsigned int face_length = table_count * 16 + 12;</span>
<span class="line-added">636 </span>
<span class="line-added">637   for (unsigned int i = 0; i &lt; table_count; i++)</span>
<span class="line-added">638     face_length += hb_ceil_to_4 (hb_blob_get_length (data-&gt;tables[i].blob));</span>
<span class="line-added">639 </span>
<span class="line-added">640   char *buf = (char *) malloc (face_length);</span>
<span class="line-added">641   if (unlikely (!buf))</span>
<span class="line-added">642     return nullptr;</span>
<span class="line-added">643 </span>
<span class="line-added">644   hb_serialize_context_t c (buf, face_length);</span>
<span class="line-added">645   c.propagate_error (data-&gt;tables);</span>
<span class="line-added">646   OT::OpenTypeFontFile *f = c.start_serialize&lt;OT::OpenTypeFontFile&gt; ();</span>
<span class="line-added">647 </span>
<span class="line-added">648   bool is_cff = data-&gt;tables.lsearch (HB_TAG (&#39;C&#39;,&#39;F&#39;,&#39;F&#39;,&#39; &#39;)) || data-&gt;tables.lsearch (HB_TAG (&#39;C&#39;,&#39;F&#39;,&#39;F&#39;,&#39;2&#39;));</span>
<span class="line-added">649   hb_tag_t sfnt_tag = is_cff ? OT::OpenTypeFontFile::CFFTag : OT::OpenTypeFontFile::TrueTypeTag;</span>
<span class="line-added">650 </span>
<span class="line-added">651   bool ret = f-&gt;serialize_single (&amp;c, sfnt_tag, data-&gt;tables.as_array ());</span>
<span class="line-added">652 </span>
<span class="line-added">653   c.end_serialize ();</span>
<span class="line-added">654 </span>
<span class="line-added">655   if (unlikely (!ret))</span>
<span class="line-added">656   {</span>
<span class="line-added">657     free (buf);</span>
<span class="line-added">658     return nullptr;</span>
<span class="line-added">659   }</span>
<span class="line-added">660 </span>
<span class="line-added">661   return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, free);</span>
<span class="line-added">662 }</span>
<span class="line-added">663 </span>
<span class="line-added">664 static hb_blob_t *</span>
<span class="line-added">665 _hb_face_builder_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)</span>
<span class="line-added">666 {</span>
<span class="line-added">667   hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;</span>
<span class="line-added">668 </span>
<span class="line-added">669   if (!tag)</span>
<span class="line-added">670     return _hb_face_builder_data_reference_blob (data);</span>
<span class="line-added">671 </span>
<span class="line-added">672   hb_face_builder_data_t::table_entry_t *entry = data-&gt;tables.lsearch (tag);</span>
<span class="line-added">673   if (entry)</span>
<span class="line-added">674     return hb_blob_reference (entry-&gt;blob);</span>
<span class="line-added">675 </span>
<span class="line-added">676   return nullptr;</span>
<span class="line-added">677 }</span>
<span class="line-added">678 </span>
<span class="line-added">679 </span>
<span class="line-added">680 /**</span>
<span class="line-added">681  * hb_face_builder_create:</span>
<span class="line-added">682  *</span>
<span class="line-added">683  * Creates a #hb_face_t that can be used with hb_face_builder_add_table().</span>
<span class="line-added">684  * After tables are added to the face, it can be compiled to a binary</span>
<span class="line-added">685  * font file by calling hb_face_reference_blob().</span>
<span class="line-added">686  *</span>
<span class="line-added">687  * Return value: (transfer full): New face.</span>
<span class="line-added">688  *</span>
<span class="line-added">689  * Since: 1.9.0</span>
<span class="line-added">690  **/</span>
<span class="line-added">691 hb_face_t *</span>
<span class="line-added">692 hb_face_builder_create ()</span>
<span class="line-added">693 {</span>
<span class="line-added">694   hb_face_builder_data_t *data = _hb_face_builder_data_create ();</span>
<span class="line-added">695   if (unlikely (!data)) return hb_face_get_empty ();</span>
<span class="line-added">696 </span>
<span class="line-added">697   return hb_face_create_for_tables (_hb_face_builder_reference_table,</span>
<span class="line-added">698                                     data,</span>
<span class="line-added">699                                     _hb_face_builder_data_destroy);</span>
<span class="line-added">700 }</span>
<span class="line-added">701 </span>
<span class="line-added">702 /**</span>
<span class="line-added">703  * hb_face_builder_add_table:</span>
<span class="line-added">704  *</span>
<span class="line-added">705  * Add table for @tag with data provided by @blob to the face.  @face must</span>
<span class="line-added">706  * be created using hb_face_builder_create().</span>
<span class="line-added">707  *</span>
<span class="line-added">708  * Since: 1.9.0</span>
<span class="line-added">709  **/</span>
<span class="line-added">710 hb_bool_t</span>
<span class="line-added">711 hb_face_builder_add_table (hb_face_t *face, hb_tag_t tag, hb_blob_t *blob)</span>
<span class="line-added">712 {</span>
<span class="line-added">713   if (unlikely (face-&gt;destroy != (hb_destroy_func_t) _hb_face_builder_data_destroy))</span>
<span class="line-added">714     return false;</span>
<span class="line-added">715 </span>
<span class="line-added">716   hb_face_builder_data_t *data = (hb_face_builder_data_t *) face-&gt;user_data;</span>
<span class="line-added">717   hb_face_builder_data_t::table_entry_t *entry = data-&gt;tables.push ();</span>
<span class="line-added">718 </span>
<span class="line-added">719   entry-&gt;tag = tag;</span>
<span class="line-added">720   entry-&gt;blob = hb_blob_reference (blob);</span>
<span class="line-added">721 </span>
<span class="line-added">722   return true;</span>
<span class="line-added">723 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="hb-dsalgs.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
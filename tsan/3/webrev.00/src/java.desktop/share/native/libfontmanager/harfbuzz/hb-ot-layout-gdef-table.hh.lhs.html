<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright © 2007,2008,2009  Red Hat, Inc.
  3  * Copyright © 2010,2011,2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
 30 #define HB_OT_LAYOUT_GDEF_TABLE_HH
 31 
<a name="1" id="anc1"></a><span class="line-modified"> 32 #include &quot;hb-ot-layout-common-private.hh&quot;</span>
 33 
<a name="2" id="anc2"></a><span class="line-modified"> 34 #include &quot;hb-font-private.hh&quot;</span>
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 /*
 41  * Attachment List Table
 42  */
 43 
 44 typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
 45                                          * increasing numerical order */
 46 
 47 struct AttachList
 48 {
<a name="3" id="anc3"></a><span class="line-modified"> 49   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 50                                          unsigned int start_offset,</span>
<span class="line-modified"> 51                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified"> 52                                          unsigned int *point_array /* OUT */) const</span>
 53   {
 54     unsigned int index = (this+coverage).get_coverage (glyph_id);
 55     if (index == NOT_COVERED)
 56     {
 57       if (point_count)
 58         *point_count = 0;
 59       return 0;
 60     }
 61 
 62     const AttachPoint &amp;points = this+attachPoint[index];
 63 
<a name="4" id="anc4"></a><span class="line-modified"> 64     if (point_count) {</span>
<span class="line-modified"> 65       const HBUINT16 *array = points.sub_array (start_offset, point_count);</span>
<span class="line-modified"> 66       unsigned int count = *point_count;</span>

 67       for (unsigned int i = 0; i &lt; count; i++)
 68         point_array[i] = array[i];
 69     }
 70 
 71     return points.len;
 72   }
 73 
<a name="5" id="anc5"></a><span class="line-modified"> 74   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 75   {
 76     TRACE_SANITIZE (this);
 77     return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
 78   }
 79 
 80   protected:
 81   OffsetTo&lt;Coverage&gt;
 82                 coverage;               /* Offset to Coverage table -- from
 83                                          * beginning of AttachList table */
 84   OffsetArrayOf&lt;AttachPoint&gt;
 85                 attachPoint;            /* Array of AttachPoint tables
 86                                          * in Coverage Index order */
 87   public:
 88   DEFINE_SIZE_ARRAY (4, attachPoint);
 89 };
 90 
 91 /*
 92  * Ligature Caret Table
 93  */
 94 
 95 struct CaretValueFormat1
 96 {
 97   friend struct CaretValue;
 98 
 99   private:
<a name="6" id="anc6"></a><span class="line-modified">100   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
101   {
102     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
103   }
104 
<a name="7" id="anc7"></a><span class="line-modified">105   inline bool sanitize (hb_sanitize_context_t *c) const</span>
106   {
107     TRACE_SANITIZE (this);
108     return_trace (c-&gt;check_struct (this));
109   }
110 
111   protected:
112   HBUINT16      caretValueFormat;       /* Format identifier--format = 1 */
113   FWORD         coordinate;             /* X or Y value, in design units */
114   public:
115   DEFINE_SIZE_STATIC (4);
116 };
117 
118 struct CaretValueFormat2
119 {
120   friend struct CaretValue;
121 
122   private:
<a name="8" id="anc8"></a><span class="line-modified">123   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
124   {
125     hb_position_t x, y;
<a name="9" id="anc9"></a><span class="line-modified">126     if (font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y))</span>
<span class="line-modified">127       return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>
<span class="line-removed">128     else</span>
<span class="line-removed">129       return 0;</span>
130   }
131 
<a name="10" id="anc10"></a><span class="line-modified">132   inline bool sanitize (hb_sanitize_context_t *c) const</span>
133   {
134     TRACE_SANITIZE (this);
135     return_trace (c-&gt;check_struct (this));
136   }
137 
138   protected:
139   HBUINT16      caretValueFormat;       /* Format identifier--format = 2 */
140   HBUINT16      caretValuePoint;        /* Contour point index on glyph */
141   public:
142   DEFINE_SIZE_STATIC (4);
143 };
144 
145 struct CaretValueFormat3
146 {
147   friend struct CaretValue;
148 
<a name="11" id="anc11"></a><span class="line-modified">149   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, const VariationStore &amp;var_store) const</span>

150   {
151     return HB_DIRECTION_IS_HORIZONTAL (direction) ?
152            font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
153            font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
154   }
155 
<a name="12" id="anc12"></a><span class="line-modified">156   inline bool sanitize (hb_sanitize_context_t *c) const</span>
157   {
158     TRACE_SANITIZE (this);
159     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
160   }
161 
162   protected:
163   HBUINT16      caretValueFormat;       /* Format identifier--format = 3 */
164   FWORD         coordinate;             /* X or Y value, in design units */
165   OffsetTo&lt;Device&gt;
166                 deviceTable;            /* Offset to Device table for X or Y
167                                          * value--from beginning of CaretValue
168                                          * table */
169   public:
170   DEFINE_SIZE_STATIC (6);
171 };
172 
173 struct CaretValue
174 {
<a name="13" id="anc13"></a><span class="line-modified">175   inline hb_position_t get_caret_value (hb_font_t *font,</span>
176                                         hb_direction_t direction,
177                                         hb_codepoint_t glyph_id,
178                                         const VariationStore &amp;var_store) const
179   {
180     switch (u.format) {
181     case 1: return u.format1.get_caret_value (font, direction);
182     case 2: return u.format2.get_caret_value (font, direction, glyph_id);
183     case 3: return u.format3.get_caret_value (font, direction, var_store);
184     default:return 0;
185     }
186   }
187 
<a name="14" id="anc14"></a><span class="line-modified">188   inline bool sanitize (hb_sanitize_context_t *c) const</span>
189   {
190     TRACE_SANITIZE (this);
191     if (!u.format.sanitize (c)) return_trace (false);
192     switch (u.format) {
193     case 1: return_trace (u.format1.sanitize (c));
194     case 2: return_trace (u.format2.sanitize (c));
195     case 3: return_trace (u.format3.sanitize (c));
196     default:return_trace (true);
197     }
198   }
199 
200   protected:
201   union {
202   HBUINT16              format;         /* Format identifier */
203   CaretValueFormat1     format1;
204   CaretValueFormat2     format2;
205   CaretValueFormat3     format3;
206   } u;
207   public:
208   DEFINE_SIZE_UNION (2, format);
209 };
210 
211 struct LigGlyph
212 {
<a name="15" id="anc15"></a><span class="line-modified">213   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">214                                       hb_direction_t direction,</span>
<span class="line-modified">215                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">216                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">217                                       unsigned int start_offset,</span>
<span class="line-modified">218                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">219                                       hb_position_t *caret_array /* OUT */) const</span>
220   {
<a name="16" id="anc16"></a><span class="line-modified">221     if (caret_count) {</span>
<span class="line-modified">222       const OffsetTo&lt;CaretValue&gt; *array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-modified">223       unsigned int count = *caret_count;</span>

224       for (unsigned int i = 0; i &lt; count; i++)
225         caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
226     }
227 
228     return carets.len;
229   }
230 
<a name="17" id="anc17"></a><span class="line-modified">231   inline bool sanitize (hb_sanitize_context_t *c) const</span>
232   {
233     TRACE_SANITIZE (this);
234     return_trace (carets.sanitize (c, this));
235   }
236 
237   protected:
238   OffsetArrayOf&lt;CaretValue&gt;
239                 carets;                 /* Offset array of CaretValue tables
240                                          * --from beginning of LigGlyph table
241                                          * --in increasing coordinate order */
242   public:
243   DEFINE_SIZE_ARRAY (2, carets);
244 };
245 
246 struct LigCaretList
247 {
<a name="18" id="anc18"></a><span class="line-modified">248   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">249                                       hb_direction_t direction,</span>
<span class="line-modified">250                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">251                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">252                                       unsigned int start_offset,</span>
<span class="line-modified">253                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">254                                       hb_position_t *caret_array /* OUT */) const</span>
255   {
256     unsigned int index = (this+coverage).get_coverage (glyph_id);
257     if (index == NOT_COVERED)
258     {
259       if (caret_count)
260         *caret_count = 0;
261       return 0;
262     }
263     const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
264     return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
265   }
266 
<a name="19" id="anc19"></a><span class="line-modified">267   inline bool sanitize (hb_sanitize_context_t *c) const</span>
268   {
269     TRACE_SANITIZE (this);
270     return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
271   }
272 
273   protected:
274   OffsetTo&lt;Coverage&gt;
275                 coverage;               /* Offset to Coverage table--from
276                                          * beginning of LigCaretList table */
277   OffsetArrayOf&lt;LigGlyph&gt;
278                 ligGlyph;               /* Array of LigGlyph tables
279                                          * in Coverage Index order */
280   public:
281   DEFINE_SIZE_ARRAY (4, ligGlyph);
282 };
283 
284 
285 struct MarkGlyphSetsFormat1
286 {
<a name="20" id="anc20"></a><span class="line-modified">287   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
288   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
289 
<a name="21" id="anc21"></a><span class="line-modified">290   inline bool sanitize (hb_sanitize_context_t *c) const</span>
291   {
292     TRACE_SANITIZE (this);
293     return_trace (coverage.sanitize (c, this));
294   }
295 
296   protected:
297   HBUINT16      format;                 /* Format identifier--format = 1 */
298   ArrayOf&lt;LOffsetTo&lt;Coverage&gt; &gt;
299                 coverage;               /* Array of long offsets to mark set
300                                          * coverage tables */
301   public:
302   DEFINE_SIZE_ARRAY (4, coverage);
303 };
304 
305 struct MarkGlyphSets
306 {
<a name="22" id="anc22"></a><span class="line-modified">307   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
308   {
309     switch (u.format) {
310     case 1: return u.format1.covers (set_index, glyph_id);
311     default:return false;
312     }
313   }
314 
<a name="23" id="anc23"></a><span class="line-modified">315   inline bool sanitize (hb_sanitize_context_t *c) const</span>
316   {
317     TRACE_SANITIZE (this);
318     if (!u.format.sanitize (c)) return_trace (false);
319     switch (u.format) {
320     case 1: return_trace (u.format1.sanitize (c));
321     default:return_trace (true);
322     }
323   }
324 
325   protected:
326   union {
327   HBUINT16              format;         /* Format identifier */
328   MarkGlyphSetsFormat1  format1;
329   } u;
330   public:
331   DEFINE_SIZE_UNION (2, format);
332 };
333 
334 
335 /*
336  * GDEF -- Glyph Definition
337  * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
338  */
339 
<a name="24" id="anc24"></a>
340 struct GDEF
341 {
<a name="25" id="anc25"></a><span class="line-modified">342   static const hb_tag_t tableTag        = HB_OT_TAG_GDEF;</span>
343 
344   enum GlyphClasses {
345     UnclassifiedGlyph   = 0,
346     BaseGlyph           = 1,
347     LigatureGlyph       = 2,
348     MarkGlyph           = 3,
349     ComponentGlyph      = 4
350   };
351 
<a name="26" id="anc26"></a><span class="line-modified">352   inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }</span>
<span class="line-modified">353   inline unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>

354   { return (this+glyphClassDef).get_class (glyph); }
<a name="27" id="anc27"></a><span class="line-modified">355   inline void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
356   { (this+glyphClassDef).add_class (glyphs, klass); }
357 
<a name="28" id="anc28"></a><span class="line-modified">358   inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }</span>
<span class="line-modified">359   inline unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
360   { return (this+markAttachClassDef).get_class (glyph); }
361 
<a name="29" id="anc29"></a><span class="line-modified">362   inline bool has_attach_points (void) const { return attachList != 0; }</span>
<span class="line-modified">363   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">364                                          unsigned int start_offset,</span>
<span class="line-modified">365                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">366                                          unsigned int *point_array /* OUT */) const</span>
367   { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
368 
<a name="30" id="anc30"></a><span class="line-modified">369   inline bool has_lig_carets (void) const { return ligCaretList != 0; }</span>
<span class="line-modified">370   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">371                                       hb_direction_t direction,</span>
<span class="line-modified">372                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">373                                       unsigned int start_offset,</span>
<span class="line-modified">374                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">375                                       hb_position_t *caret_array /* OUT */) const</span>
376   { return (this+ligCaretList).get_lig_carets (font,
377                                                direction, glyph_id, get_var_store(),
378                                                start_offset, caret_count, caret_array); }
379 
<a name="31" id="anc31"></a><span class="line-modified">380   inline bool has_mark_sets (void) const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">381   inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
382   { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
383 
<a name="32" id="anc32"></a><span class="line-modified">384   inline bool has_var_store (void) const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">385   inline const VariationStore &amp;get_var_store (void) const</span>
386   { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
387 
<a name="33" id="anc33"></a><span class="line-removed">388   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">389   {</span>
<span class="line-removed">390     TRACE_SANITIZE (this);</span>
<span class="line-removed">391     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-removed">392                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-removed">393                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">394                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">395                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">396                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">397                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-removed">398                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-removed">399   }</span>
<span class="line-removed">400 </span>
401   /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<a name="34" id="anc34"></a><span class="line-modified">402    * glyph class and other bits, and high 8-bit gthe mark attachment type (if any).</span>
403    * Not to be confused with lookup_props which is very similar. */
<a name="35" id="anc35"></a><span class="line-modified">404   inline unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
405   {
406     unsigned int klass = get_glyph_class (glyph);
407 
408     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
409     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
410     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), &quot;&quot;);
411 
412     switch (klass) {
413     default:                    return 0;
414     case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;
415     case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;
416     case MarkGlyph:
417           klass = get_mark_attachment_type (glyph);
418           return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
419     }
420   }
421 
<a name="36" id="anc36"></a>


























































422 
423   protected:
424   FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
425                                          * 0x00010003u */
426   OffsetTo&lt;ClassDef&gt;
427                 glyphClassDef;          /* Offset to class definition table
428                                          * for glyph type--from beginning of
429                                          * GDEF header (may be Null) */
430   OffsetTo&lt;AttachList&gt;
431                 attachList;             /* Offset to list of glyphs with
432                                          * attachment points--from beginning
433                                          * of GDEF header (may be Null) */
434   OffsetTo&lt;LigCaretList&gt;
435                 ligCaretList;           /* Offset to list of positioning points
436                                          * for ligature carets--from beginning
437                                          * of GDEF header (may be Null) */
438   OffsetTo&lt;ClassDef&gt;
439                 markAttachClassDef;     /* Offset to class definition table for
440                                          * mark attachment type--from beginning
441                                          * of GDEF header (may be Null) */
442   OffsetTo&lt;MarkGlyphSets&gt;
443                 markGlyphSetsDef;       /* Offset to the table of mark set
444                                          * definitions--from beginning of GDEF
445                                          * header (may be NULL).  Introduced
446                                          * in version 0x00010002. */
447   LOffsetTo&lt;VariationStore&gt;
448                 varStore;               /* Offset to the table of Item Variation
449                                          * Store--from beginning of GDEF
450                                          * header (may be NULL).  Introduced
451                                          * in version 0x00010003. */
452   public:
453   DEFINE_SIZE_MIN (12);
454 };
455 
<a name="37" id="anc37"></a>
456 
457 } /* namespace OT */
458 
459 
460 #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
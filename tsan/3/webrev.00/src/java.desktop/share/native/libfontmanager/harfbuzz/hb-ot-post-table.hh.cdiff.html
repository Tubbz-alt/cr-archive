<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-post-macroman.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-fallback.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-post-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,13 ***</span>
   */
  
  #ifndef HB_OT_POST_TABLE_HH
  #define HB_OT_POST_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-dsalgs.hh&quot;</span>
<span class="line-removed">- #include &quot;hb-subset-plan.hh&quot;</span>
  
  #define HB_STRING_ARRAY_NAME format1_names
  #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
  #include &quot;hb-string-array.hh&quot;
  #undef HB_STRING_ARRAY_LIST
<span class="line-new-header">--- 25,11 ---</span>
   */
  
  #ifndef HB_OT_POST_TABLE_HH
  #define HB_OT_POST_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
  
  #define HB_STRING_ARRAY_NAME format1_names
  #define HB_STRING_ARRAY_LIST &quot;hb-ot-post-macroman.hh&quot;
  #include &quot;hb-string-array.hh&quot;
  #undef HB_STRING_ARRAY_LIST
</pre>
<hr />
<pre>
<span class="line-old-header">*** 49,51 ***</span>
  namespace OT {
  
  
  struct postV2Tail
  {
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (glyphNameIndex.sanitize (c));
    }
  
<span class="line-modified">!   ArrayOf&lt;HBUINT16&gt;glyphNameIndex;      /* This is not an offset, but is the</span>
                                           * ordinal number of the glyph in &#39;post&#39;
                                           * string tables. */
<span class="line-modified">!   HBUINT8               namesX[VAR];            /* Glyph names with length bytes [variable]</span>
                                           * (a Pascal string). */
  
<span class="line-modified">!   DEFINE_SIZE_ARRAY2 (2, glyphNameIndex, namesX);</span>
  };
  
  struct post
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_post;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!c-&gt;check_struct (this)))</span>
<span class="line-removed">-       return_trace (false);</span>
<span class="line-removed">-     if (version.to_int () == 0x00020000)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*this);</span>
<span class="line-removed">-       return_trace (v2.sanitize (c));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     return_trace (true);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline bool subset (hb_subset_plan_t *plan) const</span>
    {
      unsigned int post_prime_length;
<span class="line-modified">!     hb_blob_t *post_blob = OT::Sanitizer&lt;post&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_post));</span>
<span class="line-modified">!     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::static_size);</span>
      post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
      hb_blob_destroy (post_blob);
  
<span class="line-modified">!     if (unlikely (!post_prime || post_prime_length != post::static_size))</span>
      {
        hb_blob_destroy (post_prime_blob);
        DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
        return false;
      }
<span class="line-new-header">--- 47,43 ---</span>
  namespace OT {
  
  
  struct postV2Tail
  {
<span class="line-modified">!   friend struct post;</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (glyphNameIndex.sanitize (c));
    }
  
<span class="line-modified">!   protected:</span>
<span class="line-added">+   ArrayOf&lt;HBUINT16&gt;     glyphNameIndex; /* This is not an offset, but is the</span>
                                           * ordinal number of the glyph in &#39;post&#39;
                                           * string tables. */
<span class="line-modified">! /*UnsizedArrayOf&lt;HBUINT8&gt;</span>
<span class="line-added">+                         namesX;*/       /* Glyph names with length bytes [variable]</span>
                                           * (a Pascal string). */
  
<span class="line-modified">!   public:</span>
<span class="line-added">+   DEFINE_SIZE_ARRAY (2, glyphNameIndex);</span>
  };
  
  struct post
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_post;</span>
  
<span class="line-modified">!   bool subset (hb_subset_plan_t *plan) const</span>
    {
      unsigned int post_prime_length;
<span class="line-modified">!     hb_blob_t *post_blob = hb_sanitize_context_t ().reference_table&lt;post&gt;(plan-&gt;source);</span>
<span class="line-modified">!     hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::min_size);</span>
      post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &amp;post_prime_length);
      hb_blob_destroy (post_blob);
  
<span class="line-modified">!     if (unlikely (!post_prime || post_prime_length != post::min_size))</span>
      {
        hb_blob_destroy (post_prime_blob);
        DEBUG_MSG(SUBSET, nullptr, &quot;Invalid source post table with length %d.&quot;, post_prime_length);
        return false;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,67 ***</span>
      return result;
    }
  
    struct accelerator_t
    {
<span class="line-modified">!     inline void init (hb_face_t *face)</span>
      {
        index_to_offset.init ();
  
<span class="line-modified">!       blob = Sanitizer&lt;post&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_post));</span>
<span class="line-modified">!       const post *table = blob-&gt;as&lt;post&gt; ();</span>
<span class="line-removed">-       unsigned int table_length = blob-&gt;length;</span>
  
        version = table-&gt;version.to_int ();
<span class="line-modified">!       if (version != 0x00020000)</span>
<span class="line-removed">-         return;</span>
  
<span class="line-modified">!       const postV2Tail &amp;v2 = StructAfter&lt;postV2Tail&gt; (*table);</span>
  
        glyphNameIndex = &amp;v2.glyphNameIndex;
        pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
  
<span class="line-modified">!       const uint8_t *end = (uint8_t *) table + table_length;</span>
<span class="line-modified">!       for (const uint8_t *data = pool; data &lt; end &amp;&amp; data + *data &lt;= end; data += 1 + *data)</span>
          index_to_offset.push (data - pool);
      }
<span class="line-modified">!     inline void fini (void)</span>
      {
        index_to_offset.fini ();
<span class="line-modified">!       free (gids_sorted_by_name);</span>
      }
  
<span class="line-modified">!     inline bool get_glyph_name (hb_codepoint_t glyph,</span>
<span class="line-modified">!                                 char *buf, unsigned int buf_len) const</span>
      {
        hb_bytes_t s = find_glyph_name (glyph);
<span class="line-modified">!       if (!s.len)</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!       if (!buf_len)</span>
<span class="line-modified">!         return true;</span>
<span class="line-modified">!       if (buf_len &lt;= s.len) /* What to do with truncation? Returning false for now. */</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       strncpy (buf, s.bytes, s.len);</span>
<span class="line-removed">-       buf[s.len] = &#39;\0&#39;;</span>
        return true;
      }
  
<span class="line-modified">!     inline bool get_glyph_from_name (const char *name, int len,</span>
<span class="line-modified">!                                      hb_codepoint_t *glyph) const</span>
      {
        unsigned int count = get_glyph_count ();
<span class="line-modified">!       if (unlikely (!count))</span>
<span class="line-removed">-         return false;</span>
  
<span class="line-modified">!       if (len &lt; 0)</span>
<span class="line-removed">-         len = strlen (name);</span>
  
<span class="line-modified">!       if (unlikely (!len))</span>
<span class="line-removed">-         return false;</span>
  
      retry:
<span class="line-modified">!       uint16_t *gids = (uint16_t *) hb_atomic_ptr_get (&amp;gids_sorted_by_name);</span>
  
        if (unlikely (!gids))
        {
          gids = (uint16_t *) malloc (count * sizeof (gids[0]));
          if (unlikely (!gids))
<span class="line-new-header">--- 95,62 ---</span>
      return result;
    }
  
    struct accelerator_t
    {
<span class="line-modified">!     void init (hb_face_t *face)</span>
      {
        index_to_offset.init ();
  
<span class="line-modified">!       table = hb_sanitize_context_t ().reference_table&lt;post&gt; (face);</span>
<span class="line-modified">!       unsigned int table_length = table.get_length ();</span>
  
        version = table-&gt;version.to_int ();
<span class="line-modified">!       if (version != 0x00020000) return;</span>
  
<span class="line-modified">!       const postV2Tail &amp;v2 = table-&gt;v2X;</span>
  
        glyphNameIndex = &amp;v2.glyphNameIndex;
        pool = &amp;StructAfter&lt;uint8_t&gt; (v2.glyphNameIndex);
  
<span class="line-modified">!       const uint8_t *end = (const uint8_t *) (const void *) table + table_length;</span>
<span class="line-modified">!       for (const uint8_t *data = pool;</span>
<span class="line-added">+            index_to_offset.length &lt; 65535 &amp;&amp; data &lt; end &amp;&amp; data + *data &lt; end;</span>
<span class="line-added">+            data += 1 + *data)</span>
          index_to_offset.push (data - pool);
      }
<span class="line-modified">!     void fini ()</span>
      {
        index_to_offset.fini ();
<span class="line-modified">!       free (gids_sorted_by_name.get ());</span>
<span class="line-added">+       table.destroy ();</span>
      }
  
<span class="line-modified">!     bool get_glyph_name (hb_codepoint_t glyph,</span>
<span class="line-modified">!                          char *buf, unsigned int buf_len) const</span>
      {
        hb_bytes_t s = find_glyph_name (glyph);
<span class="line-modified">!       if (!s.length) return false;</span>
<span class="line-modified">!       if (!buf_len) return true;</span>
<span class="line-modified">!       unsigned int len = MIN (buf_len - 1, s.length);</span>
<span class="line-modified">!       strncpy (buf, s.arrayZ, len);</span>
<span class="line-modified">!       buf[len] = &#39;\0&#39;;</span>
        return true;
      }
  
<span class="line-modified">!     bool get_glyph_from_name (const char *name, int len,</span>
<span class="line-modified">!                               hb_codepoint_t *glyph) const</span>
      {
        unsigned int count = get_glyph_count ();
<span class="line-modified">!       if (unlikely (!count)) return false;</span>
  
<span class="line-modified">!       if (len &lt; 0) len = strlen (name);</span>
  
<span class="line-modified">!       if (unlikely (!len)) return false;</span>
  
      retry:
<span class="line-modified">!       uint16_t *gids = gids_sorted_by_name.get ();</span>
  
        if (unlikely (!gids))
        {
          gids = (uint16_t *) malloc (count * sizeof (gids[0]));
          if (unlikely (!gids))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,18 ***</span>
  
          for (unsigned int i = 0; i &lt; count; i++)
            gids[i] = i;
          hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
  
<span class="line-modified">!         if (!hb_atomic_ptr_cmpexch (&amp;gids_sorted_by_name, nullptr, gids)) {</span>
            free (gids);
            goto retry;
          }
        }
  
        hb_bytes_t st (name, len);
<span class="line-modified">!       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (&amp;st, gids, count, sizeof (gids[0]), cmp_key, (void *) this);</span>
        if (gid)
        {
          *glyph = *gid;
          return true;
        }
<span class="line-new-header">--- 158,20 ---</span>
  
          for (unsigned int i = 0; i &lt; count; i++)
            gids[i] = i;
          hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);
  
<span class="line-modified">!         if (unlikely (!gids_sorted_by_name.cmpexch (nullptr, gids)))</span>
<span class="line-added">+         {</span>
            free (gids);
            goto retry;
          }
        }
  
        hb_bytes_t st (name, len);
<span class="line-modified">!       const uint16_t *gid = (const uint16_t *) hb_bsearch_r (hb_addressof (st), gids, count,</span>
<span class="line-added">+                                                              sizeof (gids[0]), cmp_key, (void *) this);</span>
        if (gid)
        {
          *glyph = *gid;
          return true;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,38 ***</span>
        return false;
      }
  
      protected:
  
<span class="line-modified">!     inline unsigned int get_glyph_count (void) const</span>
      {
        if (version == 0x00010000)
          return NUM_FORMAT1_NAMES;
  
        if (version == 0x00020000)
          return glyphNameIndex-&gt;len;
  
        return 0;
      }
  
<span class="line-modified">!     static inline int cmp_gids (const void *pa, const void *pb, void *arg)</span>
      {
        const accelerator_t *thiz = (const accelerator_t *) arg;
        uint16_t a = * (const uint16_t *) pa;
        uint16_t b = * (const uint16_t *) pb;
        return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
      }
  
<span class="line-modified">!     static inline int cmp_key (const void *pk, const void *po, void *arg)</span>
      {
        const accelerator_t *thiz = (const accelerator_t *) arg;
        const hb_bytes_t *key = (const hb_bytes_t *) pk;
        uint16_t o = * (const uint16_t *) po;
        return thiz-&gt;find_glyph_name (o).cmp (*key);
      }
  
<span class="line-modified">!     inline hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const</span>
      {
        if (version == 0x00010000)
        {
          if (glyph &gt;= NUM_FORMAT1_NAMES)
            return hb_bytes_t ();
<span class="line-new-header">--- 179,38 ---</span>
        return false;
      }
  
      protected:
  
<span class="line-modified">!     unsigned int get_glyph_count () const</span>
      {
        if (version == 0x00010000)
          return NUM_FORMAT1_NAMES;
  
        if (version == 0x00020000)
          return glyphNameIndex-&gt;len;
  
        return 0;
      }
  
<span class="line-modified">!     static int cmp_gids (const void *pa, const void *pb, void *arg)</span>
      {
        const accelerator_t *thiz = (const accelerator_t *) arg;
        uint16_t a = * (const uint16_t *) pa;
        uint16_t b = * (const uint16_t *) pb;
        return thiz-&gt;find_glyph_name (b).cmp (thiz-&gt;find_glyph_name (a));
      }
  
<span class="line-modified">!     static int cmp_key (const void *pk, const void *po, void *arg)</span>
      {
        const accelerator_t *thiz = (const accelerator_t *) arg;
        const hb_bytes_t *key = (const hb_bytes_t *) pk;
        uint16_t o = * (const uint16_t *) po;
        return thiz-&gt;find_glyph_name (o).cmp (*key);
      }
  
<span class="line-modified">!     hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const</span>
      {
        if (version == 0x00010000)
        {
          if (glyph &gt;= NUM_FORMAT1_NAMES)
            return hb_bytes_t ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,30 ***</span>
        unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
        if (index &lt; NUM_FORMAT1_NAMES)
          return format1_names (index);
        index -= NUM_FORMAT1_NAMES;
  
<span class="line-modified">!       if (index &gt;= index_to_offset.len)</span>
          return hb_bytes_t ();
<span class="line-modified">!       unsigned int offset = index_to_offset.arrayZ[index];</span>
  
        const uint8_t *data = pool + offset;
        unsigned int name_length = *data;
        data++;
  
        return hb_bytes_t ((const char *) data, name_length);
      }
  
      private:
<span class="line-modified">!     hb_blob_t *blob;</span>
      uint32_t version;
      const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
<span class="line-modified">!     hb_vector_t&lt;uint32_t, 1&gt; index_to_offset;</span>
      const uint8_t *pool;
<span class="line-modified">!     mutable uint16_t *gids_sorted_by_name;</span>
    };
  
    public:
    FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
                                           * 0x00020000 for version 2.0
                                           * 0x00025000 for version 2.5 (deprecated)
                                           * 0x00030000 for version 3.0 */
<span class="line-new-header">--- 224,39 ---</span>
        unsigned int index = glyphNameIndex-&gt;arrayZ[glyph];
        if (index &lt; NUM_FORMAT1_NAMES)
          return format1_names (index);
        index -= NUM_FORMAT1_NAMES;
  
<span class="line-modified">!       if (index &gt;= index_to_offset.length)</span>
          return hb_bytes_t ();
<span class="line-modified">!       unsigned int offset = index_to_offset[index];</span>
  
        const uint8_t *data = pool + offset;
        unsigned int name_length = *data;
        data++;
  
        return hb_bytes_t ((const char *) data, name_length);
      }
  
      private:
<span class="line-modified">!     hb_blob_ptr_t&lt;post&gt; table;</span>
      uint32_t version;
      const ArrayOf&lt;HBUINT16&gt; *glyphNameIndex;
<span class="line-modified">!     hb_vector_t&lt;uint32_t&gt; index_to_offset;</span>
      const uint8_t *pool;
<span class="line-modified">!     hb_atomic_ptr_t&lt;uint16_t *&gt; gids_sorted_by_name;</span>
    };
  
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                           (version.to_int () == 0x00010000 ||</span>
<span class="line-added">+                            (version.to_int () == 0x00020000 &amp;&amp; v2X.sanitize (c)) ||</span>
<span class="line-added">+                            version.to_int () == 0x00030000)));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    public:
    FixedVersion&lt;&gt;version;                /* 0x00010000 for version 1.0
                                           * 0x00020000 for version 2.0
                                           * 0x00025000 for version 2.5 (deprecated)
                                           * 0x00030000 for version 3.0 */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,13 ***</span>
                                           * is downloaded. */
    HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
                                           * is downloaded as a Type 1 font. */
    HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
                                           * is downloaded as a Type 1 font. */
<span class="line-modified">! /*postV2Tail    v2[VAR];*/</span>
<span class="line-modified">!   DEFINE_SIZE_STATIC (32);</span>
  };
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_POST_TABLE_HH */
<span class="line-new-header">--- 285,15 ---</span>
                                           * is downloaded. */
    HBUINT32      minMemType1;            /* Minimum memory usage when an OpenType font
                                           * is downloaded as a Type 1 font. */
    HBUINT32      maxMemType1;            /* Maximum memory usage when an OpenType font
                                           * is downloaded as a Type 1 font. */
<span class="line-modified">!   postV2Tail    v2X;</span>
<span class="line-modified">!   DEFINE_SIZE_MIN (32);</span>
  };
  
<span class="line-added">+ struct post_accelerator_t : post::accelerator_t {};</span>
<span class="line-added">+ </span>
  } /* namespace OT */
  
  
  #endif /* HB_OT_POST_TABLE_HH */
</pre>
<center><a href="hb-ot-post-macroman.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-arabic-fallback.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-color-colr-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-sbix-table.hh.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cpal-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,58 ***</span>
   */
  
  #ifndef HB_OT_COLOR_CPAL_TABLE_HH
  #define HB_OT_COLOR_CPAL_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-removed">- /*</span>
<span class="line-removed">-  * Following parts to be moved to a public header.</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- </span>
<span class="line-removed">- /**</span>
<span class="line-removed">-  * hb_ot_color_t:</span>
<span class="line-removed">-  * ARGB data type for holding color values.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Since: REPLACEME</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- typedef uint32_t hb_ot_color_t;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- /**</span>
<span class="line-removed">-  * hb_ot_color_palette_flags_t:</span>
<span class="line-removed">-  * @HB_OT_COLOR_PALETTE_FLAG_DEFAULT: default indicating that there is nothing special to note about a color palette.</span>
<span class="line-removed">-  * @HB_OT_COLOR_PALETTE_FLAG_FOR_LIGHT_BACKGROUND: flag indicating that the color palette is suitable for rendering text on light background.</span>
<span class="line-removed">-  * @HB_OT_COLOR_PALETTE_FLAG_FOR_DARK_BACKGROUND: flag indicating that the color palette is suitable for rendering text on dark background.</span>
<span class="line-removed">-  *</span>
<span class="line-removed">-  * Since: REPLACEME</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- typedef enum { /*&lt; flags &gt;*/</span>
<span class="line-removed">-   HB_OT_COLOR_PALETTE_FLAG_DEFAULT = 0x00000000u,</span>
<span class="line-removed">-   HB_OT_COLOR_PALETTE_FLAG_FOR_LIGHT_BACKGROUND = 0x00000001u,</span>
<span class="line-removed">-   HB_OT_COLOR_PALETTE_FLAG_FOR_DARK_BACKGROUND = 0x00000002u,</span>
<span class="line-removed">- } hb_ot_color_palette_flags_t;</span>
<span class="line-removed">- </span>
<span class="line-removed">- // HB_EXTERN unsigned int</span>
<span class="line-removed">- // hb_ot_color_get_palette_count (hb_face_t *face);</span>
<span class="line-removed">- </span>
<span class="line-removed">- // HB_EXTERN unsigned int</span>
<span class="line-removed">- // hb_ot_color_get_palette_name_id (hb_face_t *face, unsigned int palette);</span>
<span class="line-removed">- </span>
<span class="line-removed">- // HB_EXTERN hb_ot_color_palette_flags_t</span>
<span class="line-removed">- // hb_ot_color_get_palette_flags (hb_face_t *face, unsigned int palette);</span>
<span class="line-removed">- </span>
<span class="line-removed">- // HB_EXTERN unsigned int</span>
<span class="line-removed">- // hb_ot_color_get_palette_colors (hb_face_t       *face,</span>
<span class="line-removed">- //                              unsigned int     palette, /* default=0 */</span>
<span class="line-removed">- //                              unsigned int     start_offset,</span>
<span class="line-removed">- //                              unsigned int    *color_count /* IN/OUT */,</span>
<span class="line-removed">- //                              hb_ot_color_t   *colors /* OUT */);</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  
  
  /*
   * CPAL -- Color Palette
   * https://docs.microsoft.com/en-us/typography/opentype/spec/cpal
<span class="line-new-header">--- 26,13 ---</span>
   */
  
  #ifndef HB_OT_COLOR_CPAL_TABLE_HH
  #define HB_OT_COLOR_CPAL_TABLE_HH
  
<span class="line-modified">! #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-color.h&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-name.h&quot;</span>
  
  
  /*
   * CPAL -- Color Palette
   * https://docs.microsoft.com/en-us/typography/opentype/spec/cpal
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,126 ***</span>
  
  struct CPALV1Tail
  {
    friend struct CPAL;
  
<span class="line-modified">!   inline bool</span>
<span class="line-modified">!   sanitize (hb_sanitize_context_t *c, const void *base, unsigned int palettes) const</span>
    {
<span class="line-modified">!     TRACE_SANITIZE (this);</span>
<span class="line-modified">!     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">!                   (base+paletteFlagsZ).sanitize (c, palettes) &amp;&amp;</span>
<span class="line-removed">-                   (base+paletteLabelZ).sanitize (c, palettes) &amp;&amp;</span>
<span class="line-removed">-                   (base+paletteEntryLabelZ).sanitize (c, palettes));</span>
    }
  
<span class="line-modified">!   private:</span>
<span class="line-modified">!   inline hb_ot_color_palette_flags_t</span>
<span class="line-modified">!   get_palette_flags (const void *base, unsigned int palette) const</span>
    {
<span class="line-modified">!     // range checked at the CPAL caller</span>
<span class="line-modified">!     return (hb_ot_color_palette_flags_t) (uint32_t) (base+paletteFlagsZ)[palette];</span>
    }
  
<span class="line-modified">!   inline unsigned int</span>
<span class="line-modified">!   get_palette_name_id (const void *base, unsigned int palette) const</span>
    {
<span class="line-modified">!     // range checked at the CPAL caller</span>
<span class="line-modified">!     return (base+paletteLabelZ)[palette];</span>
    }
  
    protected:
<span class="line-modified">!   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT32&gt; &gt;</span>
                  paletteFlagsZ;          /* Offset from the beginning of CPAL table to
                                           * the Palette Type Array. Set to 0 if no array
                                           * is provided. */
<span class="line-modified">!   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT16&gt; &gt;</span>
<span class="line-modified">!                 paletteLabelZ;          /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">!                                          * the Palette Labels Array. Set to 0 if no</span>
                                           * array is provided. */
<span class="line-modified">!   LOffsetTo&lt;UnsizedArrayOf&lt;HBUINT16&gt; &gt;</span>
<span class="line-modified">!                 paletteEntryLabelZ;     /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">!                                          * the Palette Entry Label Array. Set to 0</span>
                                           * if no array is provided. */
    public:
    DEFINE_SIZE_STATIC (12);
  };
  
  typedef HBUINT32 BGRAColor;
  
  struct CPAL
  {
<span class="line-modified">!   static const hb_tag_t tableTag = HB_OT_TAG_CPAL;</span>
  
<span class="line-modified">!   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TRACE_SANITIZE (this);</span>
<span class="line-removed">-     if (unlikely (!(c-&gt;check_struct (this) &amp;&amp;   // it checks colorRecordIndices also</span>
<span class="line-removed">-                                                 // see #get_size</span>
<span class="line-removed">-                     (this+colorRecordsZ).sanitize (c, numColorRecords))))</span>
<span class="line-removed">-       return_trace (false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Check for indices sanity so no need for doing it runtime</span>
<span class="line-removed">-     for (unsigned int i = 0; i &lt; numPalettes; ++i)</span>
<span class="line-removed">-       if (unlikely (colorRecordIndicesZ[i] + numPaletteEntries &gt; numColorRecords))</span>
<span class="line-removed">-         return_trace (false);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // If version is zero, we are done here; otherwise we need to check tail also</span>
<span class="line-removed">-     if (version == 0)</span>
<span class="line-removed">-       return_trace (true);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const CPALV1Tail &amp;v1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-removed">-     return_trace (likely (v1.sanitize (c, this, numPalettes)));</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline unsigned int get_size (void) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     return min_size + numPalettes * sizeof (HBUINT16);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     if (unlikely (version == 0 || palette &gt;= numPalettes))</span>
<span class="line-removed">-       return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;</span>
  
<span class="line-modified">!     const CPALV1Tail&amp; cpal1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-modified">!     return cpal1.get_palette_flags (this, palette);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline unsigned int get_palette_name_id (unsigned int palette) const</span>
<span class="line-modified">!   {</span>
<span class="line-removed">-     if (unlikely (version == 0 || palette &gt;= numPalettes))</span>
<span class="line-removed">-       return 0xFFFF;</span>
  
<span class="line-modified">!     const CPALV1Tail&amp; cpal1 = StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-modified">!     return cpal1.get_palette_name_id (this, palette);</span>
<span class="line-removed">-   }</span>
  
<span class="line-modified">!   inline unsigned int get_palette_count () const</span>
    {
<span class="line-modified">!     return numPalettes;</span>
    }
  
<span class="line-modified">!   inline hb_ot_color_t</span>
<span class="line-modified">!   get_color_record_argb (unsigned int color_index, unsigned int palette) const</span>
    {
<span class="line-modified">!     if (unlikely (color_index &gt;= numPaletteEntries || palette &gt;= numPalettes))</span>
<span class="line-modified">!       return 0;</span>
  
<span class="line-modified">!     // No need for more range check as it is already done on #sanitize</span>
<span class="line-modified">!     const UnsizedArrayOf&lt;BGRAColor&gt;&amp; color_records = this+colorRecordsZ;</span>
<span class="line-modified">!     return color_records[colorRecordIndicesZ[palette] + color_index];</span>
    }
  
    protected:
    HBUINT16      version;                /* Table version number */
    /* Version 0 */
<span class="line-modified">!   HBUINT16      numPaletteEntries;      /* Number of palette entries in each palette. */</span>
    HBUINT16      numPalettes;            /* Number of palettes in the table. */
    HBUINT16      numColorRecords;        /* Total number of color records, combined for
                                           * all palettes. */
<span class="line-modified">!   LOffsetTo&lt;UnsizedArrayOf&lt;BGRAColor&gt; &gt;</span>
                  colorRecordsZ;          /* Offset from the beginning of CPAL table to
                                           * the first ColorRecord. */
    UnsizedArrayOf&lt;HBUINT16&gt;
                  colorRecordIndicesZ;    /* Index of each palette’s first color record in
                                           * the combined color record array. */
<span class="line-new-header">--- 45,140 ---</span>
  
  struct CPALV1Tail
  {
    friend struct CPAL;
  
<span class="line-modified">!   private:</span>
<span class="line-modified">!   hb_ot_color_palette_flags_t get_palette_flags (const void *base,</span>
<span class="line-added">+                                                  unsigned int palette_index,</span>
<span class="line-added">+                                                  unsigned int palette_count) const</span>
    {
<span class="line-modified">!     if (!paletteFlagsZ) return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;</span>
<span class="line-modified">!     return (hb_ot_color_palette_flags_t) (uint32_t)</span>
<span class="line-modified">!            (base+paletteFlagsZ).as_array (palette_count)[palette_index];</span>
    }
  
<span class="line-modified">!   hb_ot_name_id_t get_palette_name_id (const void *base,</span>
<span class="line-modified">!                                        unsigned int palette_index,</span>
<span class="line-modified">!                                        unsigned int palette_count) const</span>
    {
<span class="line-modified">!     if (!paletteLabelsZ) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified">!     return (base+paletteLabelsZ).as_array (palette_count)[palette_index];</span>
    }
  
<span class="line-modified">!   hb_ot_name_id_t get_color_name_id (const void *base,</span>
<span class="line-modified">!                                      unsigned int color_index,</span>
<span class="line-added">+                                      unsigned int color_count) const</span>
    {
<span class="line-modified">!     if (!colorLabelsZ) return HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified">!     return (base+colorLabelsZ).as_array (color_count)[color_index];</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   public:</span>
<span class="line-added">+   bool sanitize (hb_sanitize_context_t *c,</span>
<span class="line-added">+                  const void *base,</span>
<span class="line-added">+                  unsigned int palette_count,</span>
<span class="line-added">+                  unsigned int color_count) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                   (!paletteFlagsZ  || (base+paletteFlagsZ).sanitize (c, palette_count)) &amp;&amp;</span>
<span class="line-added">+                   (!paletteLabelsZ || (base+paletteLabelsZ).sanitize (c, palette_count)) &amp;&amp;</span>
<span class="line-added">+                   (!colorLabelsZ   || (base+colorLabelsZ).sanitize (c, color_count)));</span>
    }
  
    protected:
<span class="line-modified">!   LNNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT32&gt; &gt;</span>
                  paletteFlagsZ;          /* Offset from the beginning of CPAL table to
                                           * the Palette Type Array. Set to 0 if no array
                                           * is provided. */
<span class="line-modified">!   LNNOffsetTo&lt;UnsizedArrayOf&lt;NameID&gt; &gt;</span>
<span class="line-modified">!                 paletteLabelsZ;         /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">!                                          * the palette labels array. Set to 0 if no</span>
                                           * array is provided. */
<span class="line-modified">!   LNNOffsetTo&lt;UnsizedArrayOf&lt;NameID&gt; &gt;</span>
<span class="line-modified">!                 colorLabelsZ;           /* Offset from the beginning of CPAL table to</span>
<span class="line-modified">!                                          * the color labels array. Set to 0</span>
                                           * if no array is provided. */
    public:
    DEFINE_SIZE_STATIC (12);
  };
  
  typedef HBUINT32 BGRAColor;
  
  struct CPAL
  {
<span class="line-modified">!   static constexpr hb_tag_t tableTag = HB_OT_TAG_CPAL;</span>
  
<span class="line-modified">!   bool has_data () const { return numPalettes; }</span>
  
<span class="line-modified">!   unsigned int get_size () const</span>
<span class="line-modified">!   { return min_size + numPalettes * sizeof (colorRecordIndicesZ[0]); }</span>
  
<span class="line-modified">!   unsigned int get_palette_count () const { return numPalettes; }</span>
<span class="line-modified">!   unsigned int get_color_count () const   { return numColors; }</span>
  
<span class="line-modified">!   hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette_index) const</span>
<span class="line-modified">!   { return v1 ().get_palette_flags (this, palette_index, numPalettes); }</span>
  
<span class="line-modified">!   hb_ot_name_id_t get_palette_name_id (unsigned int palette_index) const</span>
<span class="line-modified">!   { return v1 ().get_palette_name_id (this, palette_index, numPalettes); }</span>
  
<span class="line-modified">!   hb_ot_name_id_t get_color_name_id (unsigned int color_index) const</span>
<span class="line-modified">!   { return v1 ().get_color_name_id (this, color_index, numColors); }</span>
  
<span class="line-modified">!   unsigned int get_palette_colors (unsigned int  palette_index,</span>
<span class="line-added">+                                    unsigned int  start_offset,</span>
<span class="line-added">+                                    unsigned int *color_count, /* IN/OUT.  May be NULL. */</span>
<span class="line-added">+                                    hb_color_t   *colors       /* OUT.     May be NULL. */) const</span>
    {
<span class="line-modified">!     if (unlikely (palette_index &gt;= numPalettes))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (color_count) *color_count = 0;</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     unsigned int start_index = colorRecordIndicesZ[palette_index];</span>
<span class="line-added">+     hb_array_t&lt;const BGRAColor&gt; all_colors ((this+colorRecordsZ).arrayZ, numColorRecords);</span>
<span class="line-added">+     hb_array_t&lt;const BGRAColor&gt; palette_colors = all_colors.sub_array (start_index,</span>
<span class="line-added">+                                                                        numColors);</span>
<span class="line-added">+     if (color_count)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       hb_array_t&lt;const BGRAColor&gt; segment_colors = palette_colors.sub_array (start_offset, *color_count);</span>
<span class="line-added">+       /* Always return numColors colors per palette even if it has out-of-bounds start index. */</span>
<span class="line-added">+       unsigned int count = MIN&lt;unsigned int&gt; (MAX&lt;int&gt; (numColors - start_offset, 0), *color_count);</span>
<span class="line-added">+       *color_count = count;</span>
<span class="line-added">+       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">+         colors[i] = segment_colors[i]; /* Bound-checked read. */</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return numColors;</span>
    }
  
<span class="line-modified">!   private:</span>
<span class="line-modified">!   const CPALV1Tail&amp; v1 () const</span>
    {
<span class="line-modified">!     if (version == 0) return Null(CPALV1Tail);</span>
<span class="line-modified">!     return StructAfter&lt;CPALV1Tail&gt; (*this);</span>
<span class="line-added">+   }</span>
  
<span class="line-modified">!   public:</span>
<span class="line-modified">!   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">!   {</span>
<span class="line-added">+     TRACE_SANITIZE (this);</span>
<span class="line-added">+     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">+                   (this+colorRecordsZ).sanitize (c, numColorRecords) &amp;&amp;</span>
<span class="line-added">+                   colorRecordIndicesZ.sanitize (c, numPalettes) &amp;&amp;</span>
<span class="line-added">+                   (version == 0 || v1 ().sanitize (c, this, numPalettes, numColors)));</span>
    }
  
    protected:
    HBUINT16      version;                /* Table version number */
    /* Version 0 */
<span class="line-modified">!   HBUINT16      numColors;              /* Number of colors in each palette. */</span>
    HBUINT16      numPalettes;            /* Number of palettes in the table. */
    HBUINT16      numColorRecords;        /* Total number of color records, combined for
                                           * all palettes. */
<span class="line-modified">!   LNNOffsetTo&lt;UnsizedArrayOf&lt;BGRAColor&gt; &gt;</span>
                  colorRecordsZ;          /* Offset from the beginning of CPAL table to
                                           * the first ColorRecord. */
    UnsizedArrayOf&lt;HBUINT16&gt;
                  colorRecordIndicesZ;    /* Index of each palette’s first color record in
                                           * the combined color record array. */
</pre>
<center><a href="hb-ot-color-colr-table.hh.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-color-sbix-table.hh.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 2009,2010  Red Hat, Inc.
   3  * Copyright © 2010,2011,2012  Google, Inc.
   4  *
   5  *  This is part of HarfBuzz, a text shaping library.
   6  *
   7  * Permission is hereby granted, without written agreement and without
   8  * license or royalty fees, to use, copy, modify, and distribute this
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<a name="1" id="anc1"></a><span class="line-modified">  29 #include &quot;hb-shaper-impl.hh&quot;</span>
<span class="line-modified">  30 </span>
<span class="line-modified">  31 #include &quot;hb-ot-shape.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-shape-complex.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-shape-fallback.hh&quot;</span>
<span class="line-modified">  34 #include &quot;hb-ot-shape-normalize.hh&quot;</span>
<span class="line-modified">  35 </span>
<span class="line-modified">  36 #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">  37 </span>
<span class="line-modified">  38 #include &quot;hb-set.hh&quot;</span>
<span class="line-modified">  39 </span>
<span class="line-modified">  40 #include &quot;hb-aat-layout.hh&quot;</span>
<span class="line-modified">  41 </span>
<span class="line-modified">  42 </span>
<span class="line-modified">  43 /**</span>
<span class="line-modified">  44  * SECTION:hb-ot-shape</span>
<span class="line-modified">  45  * @title: hb-ot-shape</span>
<span class="line-modified">  46  * @short_description: OpenType shaping support</span>
<span class="line-modified">  47  * @include: hb-ot.h</span>
<span class="line-modified">  48  *</span>
<span class="line-modified">  49  * Support functions for OpenType shaping related queries.</span>
<span class="line-modified">  50  **/</span>
<span class="line-modified">  51 </span>
<span class="line-modified">  52 </span>
<span class="line-added">  53 static void</span>
<span class="line-added">  54 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,</span>
<span class="line-added">  55                               const hb_feature_t             *user_features,</span>
<span class="line-added">  56                               unsigned int                    num_user_features);</span>
<span class="line-added">  57 </span>
<span class="line-added">  58 static bool</span>
<span class="line-added">  59 _hb_apply_morx (hb_face_t *face)</span>
<span class="line-added">  60 {</span>
<span class="line-added">  61   if (hb_options ().aat &amp;&amp;</span>
<span class="line-added">  62       hb_aat_layout_has_substitution (face))</span>
<span class="line-added">  63     return true;</span>
<span class="line-added">  64 </span>
<span class="line-added">  65   /* Ignore empty GSUB tables. */</span>
<span class="line-added">  66   return (!hb_ot_layout_has_substitution (face) ||</span>
<span class="line-added">  67           !hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-added">  68                                                HB_OT_TAG_GSUB,</span>
<span class="line-added">  69                                                0, nullptr, nullptr)) &amp;&amp;</span>
<span class="line-added">  70          hb_aat_layout_has_substitution (face);</span>
<span class="line-added">  71 }</span>
<span class="line-added">  72 </span>
<span class="line-added">  73 hb_ot_shape_planner_t::hb_ot_shape_planner_t (hb_face_t                     *face,</span>
<span class="line-added">  74                                               const hb_segment_properties_t *props) :</span>
<span class="line-added">  75                                                 face (face),</span>
<span class="line-added">  76                                                 props (*props),</span>
<span class="line-added">  77                                                 map (face, props),</span>
<span class="line-added">  78                                                 aat_map (face, props),</span>
<span class="line-added">  79                                                 apply_morx (_hb_apply_morx (face))</span>
<span class="line-added">  80 {</span>
<span class="line-added">  81   shaper = hb_ot_shape_complex_categorize (this);</span>
<span class="line-added">  82 </span>
<span class="line-added">  83   script_zero_marks = shaper-&gt;zero_width_marks != HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE;</span>
<span class="line-added">  84   script_fallback_mark_positioning = shaper-&gt;fallback_position;</span>
<span class="line-added">  85 </span>
<span class="line-added">  86   if (apply_morx)</span>
<span class="line-added">  87     shaper = &amp;_hb_ot_complex_shaper_default;</span>
<span class="line-added">  88 }</span>
<span class="line-added">  89 </span>
<span class="line-added">  90 void</span>
<span class="line-added">  91 hb_ot_shape_planner_t::compile (hb_ot_shape_plan_t           &amp;plan,</span>
<span class="line-added">  92                                 const hb_ot_shape_plan_key_t &amp;key)</span>
<span class="line-added">  93 {</span>
<span class="line-added">  94   plan.props = props;</span>
<span class="line-added">  95   plan.shaper = shaper;</span>
<span class="line-added">  96   map.compile (plan.map, key);</span>
<span class="line-added">  97   if (apply_morx)</span>
<span class="line-added">  98     aat_map.compile (plan.aat_map);</span>
<span class="line-added">  99 </span>
<span class="line-added"> 100   plan.frac_mask = plan.map.get_1_mask (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-added"> 101   plan.numr_mask = plan.map.get_1_mask (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added"> 102   plan.dnom_mask = plan.map.get_1_mask (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added"> 103   plan.has_frac = plan.frac_mask || (plan.numr_mask &amp;&amp; plan.dnom_mask);</span>
<span class="line-added"> 104   plan.rtlm_mask = plan.map.get_1_mask (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
<span class="line-added"> 105   hb_tag_t kern_tag = HB_DIRECTION_IS_HORIZONTAL (props.direction) ?</span>
<span class="line-added"> 106                       HB_TAG (&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) : HB_TAG (&#39;v&#39;,&#39;k&#39;,&#39;r&#39;,&#39;n&#39;);</span>
<span class="line-added"> 107   plan.kern_mask = plan.map.get_mask (kern_tag);</span>
<span class="line-added"> 108   plan.trak_mask = plan.map.get_mask (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;));</span>
<span class="line-added"> 109 </span>
<span class="line-added"> 110   plan.requested_kerning = !!plan.kern_mask;</span>
<span class="line-added"> 111   plan.requested_tracking = !!plan.trak_mask;</span>
<span class="line-added"> 112   bool has_gpos_kern = plan.map.get_feature_index (1, kern_tag) != HB_OT_LAYOUT_NO_FEATURE_INDEX;</span>
<span class="line-added"> 113   bool disable_gpos = plan.shaper-&gt;gpos_tag &amp;&amp;</span>
<span class="line-added"> 114                       plan.shaper-&gt;gpos_tag != plan.map.chosen_script[1];</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116   /*</span>
<span class="line-added"> 117    * Decide who provides glyph classes. GDEF or Unicode.</span>
<span class="line-added"> 118    */</span>
<span class="line-added"> 119 </span>
<span class="line-added"> 120   if (!hb_ot_layout_has_glyph_classes (face))</span>
<span class="line-added"> 121     plan.fallback_glyph_classes = true;</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123   /*</span>
<span class="line-added"> 124    * Decide who does substitutions. GSUB, morx, or fallback.</span>
<span class="line-added"> 125    */</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   plan.apply_morx = apply_morx;</span>
<span class="line-added"> 128 </span>
<span class="line-added"> 129   /*</span>
<span class="line-added"> 130    * Decide who does positioning. GPOS, kerx, kern, or fallback.</span>
<span class="line-added"> 131    */</span>
<span class="line-added"> 132 </span>
<span class="line-added"> 133   if (hb_options ().aat &amp;&amp; hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 134     plan.apply_kerx = true;</span>
<span class="line-added"> 135   else if (!apply_morx &amp;&amp; !disable_gpos &amp;&amp; hb_ot_layout_has_positioning (face))</span>
<span class="line-added"> 136     plan.apply_gpos = true;</span>
<span class="line-added"> 137   else if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 138     plan.apply_kerx = true;</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   if (!plan.apply_kerx &amp;&amp; !has_gpos_kern)</span>
<span class="line-added"> 141   {</span>
<span class="line-added"> 142     /* Apparently Apple applies kerx if GPOS kern was not applied. */</span>
<span class="line-added"> 143     if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added"> 144       plan.apply_kerx = true;</span>
<span class="line-added"> 145     else if (hb_ot_layout_has_kerning (face))</span>
<span class="line-added"> 146       plan.apply_kern = true;</span>
<span class="line-added"> 147   }</span>
<span class="line-added"> 148 </span>
<span class="line-added"> 149   plan.zero_marks = script_zero_marks &amp;&amp;</span>
<span class="line-added"> 150                     !plan.apply_kerx &amp;&amp;</span>
<span class="line-added"> 151                     (!plan.apply_kern || !hb_ot_layout_has_machine_kerning (face));</span>
<span class="line-added"> 152   plan.has_gpos_mark = !!plan.map.get_1_mask (HB_TAG (&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;));</span>
<span class="line-added"> 153 </span>
<span class="line-added"> 154   plan.adjust_mark_positioning_when_zeroing = !plan.apply_gpos &amp;&amp;</span>
<span class="line-added"> 155                                               !plan.apply_kerx &amp;&amp;</span>
<span class="line-added"> 156                                               (!plan.apply_kern || !hb_ot_layout_has_cross_kerning (face));</span>
<span class="line-added"> 157 </span>
<span class="line-added"> 158   plan.fallback_mark_positioning = plan.adjust_mark_positioning_when_zeroing &amp;&amp;</span>
<span class="line-added"> 159                                    script_fallback_mark_positioning;</span>
<span class="line-added"> 160 </span>
<span class="line-added"> 161   /* Currently we always apply trak. */</span>
<span class="line-added"> 162   plan.apply_trak = plan.requested_tracking &amp;&amp; hb_aat_layout_has_tracking (face);</span>
<span class="line-added"> 163 }</span>
<span class="line-added"> 164 </span>
<span class="line-added"> 165 bool</span>
<span class="line-added"> 166 hb_ot_shape_plan_t::init0 (hb_face_t                     *face,</span>
<span class="line-added"> 167                            const hb_shape_plan_key_t     *key)</span>
<span class="line-added"> 168 {</span>
<span class="line-added"> 169   map.init ();</span>
<span class="line-added"> 170   aat_map.init ();</span>
<span class="line-added"> 171 </span>
<span class="line-added"> 172   hb_ot_shape_planner_t planner (face,</span>
<span class="line-added"> 173                                  &amp;key-&gt;props);</span>
<span class="line-added"> 174 </span>
<span class="line-added"> 175   hb_ot_shape_collect_features (&amp;planner,</span>
<span class="line-added"> 176                                 key-&gt;user_features,</span>
<span class="line-added"> 177                                 key-&gt;num_user_features);</span>
<span class="line-added"> 178 </span>
<span class="line-added"> 179   planner.compile (*this, key-&gt;ot);</span>
<span class="line-added"> 180 </span>
<span class="line-added"> 181   if (shaper-&gt;data_create)</span>
<span class="line-added"> 182   {</span>
<span class="line-added"> 183     data = shaper-&gt;data_create (this);</span>
<span class="line-added"> 184     if (unlikely (!data))</span>
<span class="line-added"> 185       return false;</span>
<span class="line-added"> 186   }</span>
<span class="line-added"> 187 </span>
<span class="line-added"> 188   return true;</span>
<span class="line-added"> 189 }</span>
<span class="line-added"> 190 </span>
<span class="line-added"> 191 void</span>
<span class="line-added"> 192 hb_ot_shape_plan_t::fini ()</span>
<span class="line-added"> 193 {</span>
<span class="line-added"> 194   if (shaper-&gt;data_destroy)</span>
<span class="line-added"> 195     shaper-&gt;data_destroy (const_cast&lt;void *&gt; (data));</span>
<span class="line-added"> 196 </span>
<span class="line-added"> 197   map.fini ();</span>
<span class="line-added"> 198   aat_map.fini ();</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 </span>
<span class="line-added"> 201 void</span>
<span class="line-added"> 202 hb_ot_shape_plan_t::substitute (hb_font_t   *font,</span>
<span class="line-added"> 203                                 hb_buffer_t *buffer) const</span>
<span class="line-added"> 204 {</span>
<span class="line-added"> 205   if (unlikely (apply_morx))</span>
<span class="line-added"> 206     hb_aat_layout_substitute (this, font, buffer);</span>
<span class="line-added"> 207   else</span>
<span class="line-added"> 208     map.substitute (this, font, buffer);</span>
<span class="line-added"> 209 }</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211 void</span>
<span class="line-added"> 212 hb_ot_shape_plan_t::position (hb_font_t   *font,</span>
<span class="line-added"> 213                               hb_buffer_t *buffer) const</span>
<span class="line-added"> 214 {</span>
<span class="line-added"> 215   if (this-&gt;apply_gpos)</span>
<span class="line-added"> 216     map.position (this, font, buffer);</span>
<span class="line-added"> 217   else if (this-&gt;apply_kerx)</span>
<span class="line-added"> 218     hb_aat_layout_position (this, font, buffer);</span>
<span class="line-added"> 219   else if (this-&gt;apply_kern)</span>
<span class="line-added"> 220     hb_ot_layout_kern (this, font, buffer);</span>
<span class="line-added"> 221   else</span>
<span class="line-added"> 222     _hb_ot_shape_fallback_kern (this, font, buffer);</span>
 223 
<a name="2" id="anc2"></a><span class="line-added"> 224   if (this-&gt;apply_trak)</span>
<span class="line-added"> 225     hb_aat_layout_track (this, font, buffer);</span>
<span class="line-added"> 226 }</span>
 227 
<a name="3" id="anc3"></a><span class="line-modified"> 228 </span>
<span class="line-modified"> 229 static const hb_ot_map_feature_t</span>
<span class="line-modified"> 230 common_features[] =</span>
<span class="line-modified"> 231 {</span>
<span class="line-modified"> 232   {HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;), F_GLOBAL},</span>
<span class="line-modified"> 233   {HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;), F_GLOBAL},</span>
<span class="line-modified"> 234   {HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 235   {HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 236   {HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
 237 };
 238 
 239 
<a name="4" id="anc4"></a><span class="line-added"> 240 static const hb_ot_map_feature_t</span>
<span class="line-added"> 241 horizontal_features[] =</span>
<span class="line-added"> 242 {</span>
<span class="line-added"> 243   {HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added"> 244   {HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
<span class="line-added"> 245   {HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-added"> 246   {HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), F_GLOBAL_HAS_FALLBACK},</span>
<span class="line-added"> 247   {HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), F_GLOBAL},</span>
<span class="line-added"> 248   {HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added"> 249 };</span>
 250 
 251 static void
 252 hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
<a name="5" id="anc5"></a>
 253                               const hb_feature_t             *user_features,
 254                               unsigned int                    num_user_features)
 255 {
 256   hb_ot_map_builder_t *map = &amp;planner-&gt;map;
 257 
<a name="6" id="anc6"></a><span class="line-modified"> 258   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
 259   map-&gt;add_gsub_pause (nullptr);
 260 
<a name="7" id="anc7"></a><span class="line-modified"> 261   switch (planner-&gt;props.direction) {</span>
 262     case HB_DIRECTION_LTR:
<a name="8" id="anc8"></a><span class="line-modified"> 263       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 264       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
 265       break;
 266     case HB_DIRECTION_RTL:
<a name="9" id="anc9"></a><span class="line-modified"> 267       map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified"> 268       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
 269       break;
 270     case HB_DIRECTION_TTB:
 271     case HB_DIRECTION_BTT:
 272     case HB_DIRECTION_INVALID:
 273     default:
 274       break;
 275   }
 276 
<a name="10" id="anc10"></a><span class="line-modified"> 277   /* Automatic fractions. */</span>
<span class="line-modified"> 278   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-modified"> 279   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added"> 280   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282   /* Random! */</span>
<span class="line-added"> 283   map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), F_RANDOM, HB_OT_MAP_MAX_VALUE);</span>
<span class="line-added"> 284 </span>
<span class="line-added"> 285   /* Tracking.  We enable dummy feature here just to allow disabling</span>
<span class="line-added"> 286    * AAT &#39;trak&#39; table using features.</span>
<span class="line-added"> 287    * https://github.com/harfbuzz/harfbuzz/issues/1303 */</span>
<span class="line-added"> 288   map-&gt;enable_feature (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;), F_HAS_FALLBACK);</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290   map-&gt;enable_feature (HB_TAG (&#39;H&#39;,&#39;A&#39;,&#39;R&#39;,&#39;F&#39;));</span>
 291 
 292   if (planner-&gt;shaper-&gt;collect_features)
 293     planner-&gt;shaper-&gt;collect_features (planner);
 294 
<a name="11" id="anc11"></a><span class="line-added"> 295   map-&gt;enable_feature (HB_TAG (&#39;B&#39;,&#39;U&#39;,&#39;Z&#39;,&#39;Z&#39;));</span>
<span class="line-added"> 296 </span>
 297   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<a name="12" id="anc12"></a><span class="line-modified"> 298     map-&gt;add_feature (common_features[i]);</span>
 299 
<a name="13" id="anc13"></a><span class="line-modified"> 300   if (HB_DIRECTION_IS_HORIZONTAL (planner-&gt;props.direction))</span>
 301     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<a name="14" id="anc14"></a><span class="line-modified"> 302       map-&gt;add_feature (horizontal_features[i]);</span>


 303   else
 304   {
 305     /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
 306      * matter which script/langsys it is listed (or not) under.
 307      * See various bugs referenced from:
 308      * https://github.com/harfbuzz/harfbuzz/issues/63 */
<a name="15" id="anc15"></a><span class="line-modified"> 309     map-&gt;enable_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), F_GLOBAL_SEARCH);</span>
 310   }
 311 
<a name="16" id="anc16"></a><span class="line-modified"> 312   for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-modified"> 313   {</span>


 314     const hb_feature_t *feature = &amp;user_features[i];
<a name="17" id="anc17"></a><span class="line-modified"> 315     map-&gt;add_feature (feature-&gt;tag,</span>
<span class="line-modified"> 316                       (feature-&gt;start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-modified"> 317                        feature-&gt;end == HB_FEATURE_GLOBAL_END) ?  F_GLOBAL : F_NONE,</span>
<span class="line-added"> 318                       feature-&gt;value);</span>
 319   }
<a name="18" id="anc18"></a><span class="line-added"> 320 </span>
<span class="line-added"> 321   if (planner-&gt;apply_morx)</span>
<span class="line-added"> 322   {</span>
<span class="line-added"> 323     hb_aat_map_builder_t *aat_map = &amp;planner-&gt;aat_map;</span>
<span class="line-added"> 324     for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added"> 325     {</span>
<span class="line-added"> 326       const hb_feature_t *feature = &amp;user_features[i];</span>
<span class="line-added"> 327       aat_map-&gt;add_feature (feature-&gt;tag, feature-&gt;value);</span>
<span class="line-added"> 328     }</span>
<span class="line-added"> 329   }</span>
<span class="line-added"> 330 </span>
<span class="line-added"> 331   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-added"> 332     planner-&gt;shaper-&gt;override_features (planner);</span>
 333 }
 334 
 335 
 336 /*
 337  * shaper face data
 338  */
 339 
<a name="19" id="anc19"></a><span class="line-modified"> 340 struct hb_ot_face_data_t {};</span>
 341 
<a name="20" id="anc20"></a><span class="line-modified"> 342 hb_ot_face_data_t *</span>
 343 _hb_ot_shaper_face_data_create (hb_face_t *face)
 344 {
<a name="21" id="anc21"></a><span class="line-modified"> 345   return (hb_ot_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
 346 }
 347 
 348 void
<a name="22" id="anc22"></a><span class="line-modified"> 349 _hb_ot_shaper_face_data_destroy (hb_ot_face_data_t *data)</span>
 350 {
<a name="23" id="anc23"></a>
 351 }
 352 
 353 
 354 /*
 355  * shaper font data
 356  */
 357 
<a name="24" id="anc24"></a><span class="line-modified"> 358 struct hb_ot_font_data_t {};</span>


 359 
<a name="25" id="anc25"></a><span class="line-modified"> 360 hb_ot_font_data_t *</span>
 361 _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
 362 {
<a name="26" id="anc26"></a><span class="line-modified"> 363   return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>











































 364 }
 365 
 366 void
<a name="27" id="anc27"></a><span class="line-modified"> 367 _hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data HB_UNUSED)</span>
 368 {
<a name="28" id="anc28"></a>





 369 }
 370 
 371 
 372 /*
 373  * shaper
 374  */
 375 
 376 struct hb_ot_shape_context_t
 377 {
 378   hb_ot_shape_plan_t *plan;
 379   hb_font_t *font;
 380   hb_face_t *face;
 381   hb_buffer_t  *buffer;
 382   const hb_feature_t *user_features;
 383   unsigned int        num_user_features;
 384 
 385   /* Transient stuff */
<a name="29" id="anc29"></a>

 386   hb_direction_t target_direction;
 387 };
 388 
 389 
 390 
 391 /* Main shaper */
 392 
 393 
 394 /* Prepare */
 395 
 396 static void
 397 hb_set_unicode_props (hb_buffer_t *buffer)
 398 {
<a name="30" id="anc30"></a><span class="line-added"> 399   /* Implement enough of Unicode Graphemes here that shaping</span>
<span class="line-added"> 400    * in reverse-direction wouldn&#39;t break graphemes.  Namely,</span>
<span class="line-added"> 401    * we mark all marks and ZWJ and ZWJ,Extended_Pictographic</span>
<span class="line-added"> 402    * sequences as continuations.  The foreach_grapheme()</span>
<span class="line-added"> 403    * macro uses this bit.</span>
<span class="line-added"> 404    *</span>
<span class="line-added"> 405    * https://www.unicode.org/reports/tr29/#Regex_Definitions</span>
<span class="line-added"> 406    */</span>
 407   unsigned int count = buffer-&gt;len;
 408   hb_glyph_info_t *info = buffer-&gt;info;
 409   for (unsigned int i = 0; i &lt; count; i++)
<a name="31" id="anc31"></a><span class="line-added"> 410   {</span>
 411     _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);
<a name="32" id="anc32"></a><span class="line-added"> 412 </span>
<span class="line-added"> 413     /* Marks are already set as continuation by the above line.</span>
<span class="line-added"> 414      * Handle Emoji_Modifier and ZWJ-continuation. */</span>
<span class="line-added"> 415     if (unlikely (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL &amp;&amp;</span>
<span class="line-added"> 416                   hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0x1F3FBu, 0x1F3FFu)))</span>
<span class="line-added"> 417     {</span>
<span class="line-added"> 418         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 419     }</span>
<span class="line-added"> 420     else if (unlikely (_hb_glyph_info_is_zwj (&amp;info[i])))</span>
<span class="line-added"> 421     {</span>
<span class="line-added"> 422       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 423       if (i + 1 &lt; count &amp;&amp;</span>
<span class="line-added"> 424           _hb_unicode_is_emoji_Extended_Pictographic (info[i + 1].codepoint))</span>
<span class="line-added"> 425       {</span>
<span class="line-added"> 426         i++;</span>
<span class="line-added"> 427         _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);</span>
<span class="line-added"> 428         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 429       }</span>
<span class="line-added"> 430     }</span>
<span class="line-added"> 431     /* Or part of the Other_Grapheme_Extend that is not marks.</span>
<span class="line-added"> 432      * As of Unicode 11 that is just:</span>
<span class="line-added"> 433      *</span>
<span class="line-added"> 434      * 200C          ; Other_Grapheme_Extend # Cf       ZERO WIDTH NON-JOINER</span>
<span class="line-added"> 435      * FF9E..FF9F    ; Other_Grapheme_Extend # Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK</span>
<span class="line-added"> 436      * E0020..E007F  ; Other_Grapheme_Extend # Cf  [96] TAG SPACE..CANCEL TAG</span>
<span class="line-added"> 437      *</span>
<span class="line-added"> 438      * ZWNJ is special, we don&#39;t want to merge it as there&#39;s no need, and keeping</span>
<span class="line-added"> 439      * it separate results in more granular clusters.  Ignore Katakana for now.</span>
<span class="line-added"> 440      * Tags are used for Emoji sub-region flag sequences:</span>
<span class="line-added"> 441      * https://github.com/harfbuzz/harfbuzz/issues/1556</span>
<span class="line-added"> 442      */</span>
<span class="line-added"> 443     else if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0xE0020u, 0xE007Fu)))</span>
<span class="line-added"> 444       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added"> 445   }</span>
 446 }
 447 
 448 static void
 449 hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
 450 {
 451   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
 452       buffer-&gt;context_len[0] ||
<a name="33" id="anc33"></a><span class="line-modified"> 453       !_hb_glyph_info_is_unicode_mark (&amp;buffer-&gt;info[0]))</span>

 454     return;
 455 
 456   if (!font-&gt;has_glyph (0x25CCu))
 457     return;
 458 
 459   hb_glyph_info_t dottedcircle = {0};
 460   dottedcircle.codepoint = 0x25CCu;
 461   _hb_glyph_info_set_unicode_props (&amp;dottedcircle, buffer);
 462 
 463   buffer-&gt;clear_output ();
 464 
 465   buffer-&gt;idx = 0;
 466   hb_glyph_info_t info = dottedcircle;
 467   info.cluster = buffer-&gt;cur().cluster;
 468   info.mask = buffer-&gt;cur().mask;
 469   buffer-&gt;output_info (info);
 470   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
 471     buffer-&gt;next_glyph ();
<a name="34" id="anc34"></a>
 472   buffer-&gt;swap_buffers ();
 473 }
 474 
 475 static void
 476 hb_form_clusters (hb_buffer_t *buffer)
 477 {
 478   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
 479     return;
 480 
<a name="35" id="anc35"></a>















 481   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<a name="36" id="anc36"></a><span class="line-modified"> 482     foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 483       buffer-&gt;merge_clusters (start, end);</span>
 484   else
<a name="37" id="anc37"></a><span class="line-modified"> 485     foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 486       buffer-&gt;unsafe_to_break (start, end);</span>
 487 }
 488 
 489 static void
 490 hb_ensure_native_direction (hb_buffer_t *buffer)
 491 {
 492   hb_direction_t direction = buffer-&gt;props.direction;
 493   hb_direction_t horiz_dir = hb_script_get_horizontal_direction (buffer-&gt;props.script);
 494 
 495   /* TODO vertical:
 496    * The only BTT vertical script is Ogham, but it&#39;s not clear to me whether OpenType
 497    * Ogham fonts are supposed to be implemented BTT or not.  Need to research that
 498    * first. */
 499   if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
 500        direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
 501       (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
 502        direction != HB_DIRECTION_TTB))
 503   {
<a name="38" id="anc38"></a>











 504 
<a name="39" id="anc39"></a>


 505     if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<a name="40" id="anc40"></a><span class="line-modified"> 506       foreach_grapheme (buffer, start, end)</span>
<span class="line-modified"> 507       {</span>
<span class="line-added"> 508         buffer-&gt;merge_clusters (start, end);</span>
<span class="line-added"> 509         buffer-&gt;reverse_range (start, end);</span>
<span class="line-added"> 510       }</span>
<span class="line-added"> 511     else</span>
<span class="line-added"> 512       foreach_grapheme (buffer, start, end)</span>
<span class="line-added"> 513         /* form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-added"> 514         buffer-&gt;reverse_range (start, end);</span>
 515 
 516     buffer-&gt;reverse ();
 517 
 518     buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
 519   }
 520 }
 521 
 522 
<a name="41" id="anc41"></a><span class="line-modified"> 523 /*</span>
<span class="line-added"> 524  * Substitute</span>
<span class="line-added"> 525  */</span>
 526 
 527 static inline void
<a name="42" id="anc42"></a><span class="line-modified"> 528 hb_ot_mirror_chars (const hb_ot_shape_context_t *c)</span>
 529 {
 530   if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
 531     return;
 532 
 533   hb_buffer_t *buffer = c-&gt;buffer;
 534   hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 535   hb_mask_t rtlm_mask = c-&gt;plan-&gt;rtlm_mask;
 536 
 537   unsigned int count = buffer-&gt;len;
 538   hb_glyph_info_t *info = buffer-&gt;info;
 539   for (unsigned int i = 0; i &lt; count; i++) {
 540     hb_codepoint_t codepoint = unicode-&gt;mirroring (info[i].codepoint);
 541     if (likely (codepoint == info[i].codepoint || !c-&gt;font-&gt;has_glyph (codepoint)))
 542       info[i].mask |= rtlm_mask;
 543     else
 544       info[i].codepoint = codepoint;
 545   }
 546 }
 547 
 548 static inline void
<a name="43" id="anc43"></a><span class="line-modified"> 549 hb_ot_shape_setup_masks_fraction (const hb_ot_shape_context_t *c)</span>
 550 {
 551   if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
 552       !c-&gt;plan-&gt;has_frac)
 553     return;
 554 
 555   hb_buffer_t *buffer = c-&gt;buffer;
 556 
 557   hb_mask_t pre_mask, post_mask;
 558   if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction))
 559   {
 560     pre_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 561     post_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 562   }
 563   else
 564   {
 565     pre_mask = c-&gt;plan-&gt;frac_mask | c-&gt;plan-&gt;dnom_mask;
 566     post_mask = c-&gt;plan-&gt;numr_mask | c-&gt;plan-&gt;frac_mask;
 567   }
 568 
 569   unsigned int count = buffer-&gt;len;
 570   hb_glyph_info_t *info = buffer-&gt;info;
 571   for (unsigned int i = 0; i &lt; count; i++)
 572   {
 573     if (info[i].codepoint == 0x2044u) /* FRACTION SLASH */
 574     {
 575       unsigned int start = i, end = i + 1;
 576       while (start &amp;&amp;
 577              _hb_glyph_info_get_general_category (&amp;info[start - 1]) ==
 578              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
 579         start--;
 580       while (end &lt; count &amp;&amp;
 581              _hb_glyph_info_get_general_category (&amp;info[end]) ==
 582              HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)
 583         end++;
 584 
 585       buffer-&gt;unsafe_to_break (start, end);
 586 
 587       for (unsigned int j = start; j &lt; i; j++)
 588         info[j].mask |= pre_mask;
 589       info[i].mask |= c-&gt;plan-&gt;frac_mask;
 590       for (unsigned int j = i + 1; j &lt; end; j++)
 591         info[j].mask |= post_mask;
 592 
 593       i = end - 1;
 594     }
 595   }
 596 }
 597 
 598 static inline void
<a name="44" id="anc44"></a><span class="line-modified"> 599 hb_ot_shape_initialize_masks (const hb_ot_shape_context_t *c)</span>
 600 {
 601   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 602   hb_buffer_t *buffer = c-&gt;buffer;
 603 
 604   hb_mask_t global_mask = map-&gt;get_global_mask ();
 605   buffer-&gt;reset_masks (global_mask);
 606 }
 607 
 608 static inline void
<a name="45" id="anc45"></a><span class="line-modified"> 609 hb_ot_shape_setup_masks (const hb_ot_shape_context_t *c)</span>
 610 {
 611   hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
 612   hb_buffer_t *buffer = c-&gt;buffer;
 613 
 614   hb_ot_shape_setup_masks_fraction (c);
 615 
 616   if (c-&gt;plan-&gt;shaper-&gt;setup_masks)
 617     c-&gt;plan-&gt;shaper-&gt;setup_masks (c-&gt;plan, buffer, c-&gt;font);
 618 
 619   for (unsigned int i = 0; i &lt; c-&gt;num_user_features; i++)
 620   {
 621     const hb_feature_t *feature = &amp;c-&gt;user_features[i];
 622     if (!(feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int)-1)) {
 623       unsigned int shift;
 624       hb_mask_t mask = map-&gt;get_mask (feature-&gt;tag, &amp;shift);
 625       buffer-&gt;set_masks (feature-&gt;value &lt;&lt; shift, mask, feature-&gt;start, feature-&gt;end);
 626     }
 627   }
 628 }
 629 
 630 static void
<a name="46" id="anc46"></a><span class="line-modified"> 631 hb_ot_zero_width_default_ignorables (const hb_buffer_t *buffer)</span>
 632 {
<a name="47" id="anc47"></a>

 633   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 634       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
 635       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
 636     return;
 637 
 638   unsigned int count = buffer-&gt;len;
 639   hb_glyph_info_t *info = buffer-&gt;info;
 640   hb_glyph_position_t *pos = buffer-&gt;pos;
 641   unsigned int i = 0;
 642   for (i = 0; i &lt; count; i++)
 643     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
 644       pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
 645 }
 646 
 647 static void
<a name="48" id="anc48"></a><span class="line-modified"> 648 hb_ot_hide_default_ignorables (hb_buffer_t *buffer,</span>
<span class="line-added"> 649                                hb_font_t   *font)</span>
 650 {
<a name="49" id="anc49"></a>

 651   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
 652       (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
 653     return;
 654 
 655   unsigned int count = buffer-&gt;len;
 656   hb_glyph_info_t *info = buffer-&gt;info;
<a name="50" id="anc50"></a>










 657 
<a name="51" id="anc51"></a><span class="line-modified"> 658   hb_codepoint_t invisible = buffer-&gt;invisible;</span>
 659   if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<a name="52" id="anc52"></a><span class="line-modified"> 660       (invisible || font-&gt;get_nominal_glyph (&#39; &#39;, &amp;invisible)))</span>
 661   {
<a name="53" id="anc53"></a><span class="line-modified"> 662     /* Replace default-ignorables with a zero-advance invisible glyph. */</span>
<span class="line-modified"> 663     for (unsigned int i = 0; i &lt; count; i++)</span>
 664     {
 665       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<a name="54" id="anc54"></a><span class="line-modified"> 666         info[i].codepoint = invisible;</span>
 667     }
 668   }
 669   else
<a name="55" id="anc55"></a><span class="line-modified"> 670     hb_ot_layout_delete_glyphs_inplace (buffer, _hb_glyph_info_is_default_ignorable);</span>










































 671 }
 672 
 673 
 674 static inline void
 675 hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
 676 {
 677   /* Normalization process sets up glyph_index(), we just copy it. */
 678   unsigned int count = buffer-&gt;len;
 679   hb_glyph_info_t *info = buffer-&gt;info;
 680   for (unsigned int i = 0; i &lt; count; i++)
 681     info[i].codepoint = info[i].glyph_index();
 682 
 683   buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
 684 }
 685 
 686 static inline void
<a name="56" id="anc56"></a><span class="line-modified"> 687 hb_synthesize_glyph_classes (hb_buffer_t *buffer)</span>
 688 {
<a name="57" id="anc57"></a><span class="line-modified"> 689   unsigned int count = buffer-&gt;len;</span>
<span class="line-modified"> 690   hb_glyph_info_t *info = buffer-&gt;info;</span>
 691   for (unsigned int i = 0; i &lt; count; i++)
 692   {
 693     hb_ot_layout_glyph_props_flags_t klass;
 694 
 695     /* Never mark default-ignorables as marks.
 696      * They won&#39;t get in the way of lookups anyway,
 697      * but having them as mark will cause them to be skipped
 698      * over if the lookup-flag says so, but at least for the
 699      * Mongolian variation selectors, looks like Uniscribe
 700      * marks them as non-mark.  Some Mongolian fonts without
 701      * GDEF rely on this.  Another notable character that
 702      * this applies to is COMBINING GRAPHEME JOINER. */
 703     klass = (_hb_glyph_info_get_general_category (&amp;info[i]) !=
 704              HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ||
 705              _hb_glyph_info_is_default_ignorable (&amp;info[i])) ?
 706             HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH :
 707             HB_OT_LAYOUT_GLYPH_PROPS_MARK;
 708     _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
 709   }
 710 }
 711 
 712 static inline void
<a name="58" id="anc58"></a><span class="line-modified"> 713 hb_ot_substitute_default (const hb_ot_shape_context_t *c)</span>
 714 {
 715   hb_buffer_t *buffer = c-&gt;buffer;
 716 
 717   hb_ot_mirror_chars (c);
 718 
 719   HB_BUFFER_ALLOCATE_VAR (buffer, glyph_index);
 720 
 721   _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
 722 
 723   hb_ot_shape_setup_masks (c);
 724 
 725   /* This is unfortunate to go here, but necessary... */
<a name="59" id="anc59"></a><span class="line-modified"> 726   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-modified"> 727     _hb_ot_shape_fallback_mark_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
 728 
 729   hb_ot_map_glyphs_fast (buffer);
 730 
 731   HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
 732 }
 733 
 734 static inline void
<a name="60" id="anc60"></a><span class="line-modified"> 735 hb_ot_substitute_complex (const hb_ot_shape_context_t *c)</span>
 736 {
 737   hb_buffer_t *buffer = c-&gt;buffer;
 738 
 739   hb_ot_layout_substitute_start (c-&gt;font, buffer);
 740 
<a name="61" id="anc61"></a><span class="line-modified"> 741   if (c-&gt;plan-&gt;fallback_glyph_classes)</span>
<span class="line-modified"> 742     hb_synthesize_glyph_classes (c-&gt;buffer);</span>
 743 
 744   c-&gt;plan-&gt;substitute (c-&gt;font, buffer);
<a name="62" id="anc62"></a>


 745 }
 746 
 747 static inline void
<a name="63" id="anc63"></a><span class="line-modified"> 748 hb_ot_substitute_pre (const hb_ot_shape_context_t *c)</span>
 749 {
 750   hb_ot_substitute_default (c);
 751 
 752   _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
 753 
 754   hb_ot_substitute_complex (c);
 755 }
 756 
<a name="64" id="anc64"></a><span class="line-modified"> 757 static inline void</span>
<span class="line-added"> 758 hb_ot_substitute_post (const hb_ot_shape_context_t *c)</span>
<span class="line-added"> 759 {</span>
<span class="line-added"> 760   hb_ot_hide_default_ignorables (c-&gt;buffer, c-&gt;font);</span>
<span class="line-added"> 761   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added"> 762     hb_aat_layout_remove_deleted_glyphs (c-&gt;buffer);</span>
<span class="line-added"> 763 </span>
<span class="line-added"> 764   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-added"> 765     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
<span class="line-added"> 766 }</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768 </span>
<span class="line-added"> 769 /*</span>
<span class="line-added"> 770  * Position</span>
<span class="line-added"> 771  */</span>
 772 
 773 static inline void
 774 adjust_mark_offsets (hb_glyph_position_t *pos)
 775 {
 776   pos-&gt;x_offset -= pos-&gt;x_advance;
 777   pos-&gt;y_offset -= pos-&gt;y_advance;
 778 }
 779 
 780 static inline void
 781 zero_mark_width (hb_glyph_position_t *pos)
 782 {
 783   pos-&gt;x_advance = 0;
 784   pos-&gt;y_advance = 0;
 785 }
 786 
 787 static inline void
 788 zero_mark_widths_by_gdef (hb_buffer_t *buffer, bool adjust_offsets)
 789 {
 790   unsigned int count = buffer-&gt;len;
 791   hb_glyph_info_t *info = buffer-&gt;info;
 792   for (unsigned int i = 0; i &lt; count; i++)
 793     if (_hb_glyph_info_is_mark (&amp;info[i]))
 794     {
 795       if (adjust_offsets)
 796         adjust_mark_offsets (&amp;buffer-&gt;pos[i]);
 797       zero_mark_width (&amp;buffer-&gt;pos[i]);
 798     }
 799 }
 800 
 801 static inline void
<a name="65" id="anc65"></a><span class="line-modified"> 802 hb_ot_position_default (const hb_ot_shape_context_t *c)</span>
 803 {
 804   hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
 805   unsigned int count = c-&gt;buffer-&gt;len;
 806   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 807   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 808 
 809   if (HB_DIRECTION_IS_HORIZONTAL (direction))
 810   {
<a name="66" id="anc66"></a><span class="line-modified"> 811     c-&gt;font-&gt;get_glyph_h_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-modified"> 812                                    &amp;pos[0].x_advance, sizeof(pos[0]));</span>
 813     /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 814     if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 815       for (unsigned int i = 0; i &lt; count; i++)
 816         c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 817                                           &amp;pos[i].x_offset,
 818                                           &amp;pos[i].y_offset);
 819   }
 820   else
 821   {
<a name="67" id="anc67"></a><span class="line-added"> 822     c-&gt;font-&gt;get_glyph_v_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-added"> 823                                    &amp;pos[0].y_advance, sizeof(pos[0]));</span>
 824     for (unsigned int i = 0; i &lt; count; i++)
 825     {
<a name="68" id="anc68"></a>
 826       c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
 827                                         &amp;pos[i].x_offset,
 828                                         &amp;pos[i].y_offset);
 829     }
 830   }
 831   if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
 832     _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
 833 }
 834 
 835 static inline void
<a name="69" id="anc69"></a><span class="line-modified"> 836 hb_ot_position_complex (const hb_ot_shape_context_t *c)</span>
 837 {
 838   unsigned int count = c-&gt;buffer-&gt;len;
 839   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
 840   hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
 841 
<a name="70" id="anc70"></a><span class="line-modified"> 842   /* If the font has no GPOS and direction is forward, then when</span>
<span class="line-modified"> 843    * zeroing mark widths, we shift the mark with it, such that the</span>
<span class="line-modified"> 844    * mark is positioned hanging over the previous glyph.  When</span>

 845    * direction is backward we don&#39;t shift and it will end up
 846    * hanging over the next glyph after the final reordering.
<a name="71" id="anc71"></a><span class="line-modified"> 847    *</span>
<span class="line-modified"> 848    * Note: If fallback positinoing happens, we don&#39;t care about</span>
<span class="line-added"> 849    * this as it will be overriden.</span>
 850    */
<a name="72" id="anc72"></a><span class="line-modified"> 851   bool adjust_offsets_when_zeroing = c-&gt;plan-&gt;adjust_mark_positioning_when_zeroing &amp;&amp;</span>

 852                                      HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
 853 
 854   /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
 855 
 856   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 857   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 858     for (unsigned int i = 0; i &lt; count; i++)
 859       c-&gt;font-&gt;add_glyph_h_origin (info[i].codepoint,
 860                                    &amp;pos[i].x_offset,
 861                                    &amp;pos[i].y_offset);
 862 
 863   hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
 864 
<a name="73" id="anc73"></a><span class="line-modified"> 865   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified"> 866     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified"> 867     {</span>
<span class="line-modified"> 868       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified"> 869         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified"> 870         break;</span>
<span class="line-modified"> 871 </span>
<span class="line-modified"> 872       default:</span>
<span class="line-modified"> 873       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified"> 874       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified"> 875         break;</span>
<span class="line-modified"> 876     }</span>


 877 
<a name="74" id="anc74"></a><span class="line-modified"> 878   c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>




 879 
<a name="75" id="anc75"></a><span class="line-modified"> 880   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified"> 881     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified"> 882     {</span>
<span class="line-modified"> 883       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified"> 884         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-added"> 885         break;</span>
<span class="line-added"> 886 </span>
<span class="line-added"> 887       default:</span>
<span class="line-added"> 888       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-added"> 889       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-added"> 890         break;</span>
<span class="line-added"> 891     }</span>
 892 
<a name="76" id="anc76"></a><span class="line-modified"> 893   /* Finish off.  Has to follow a certain order. */</span>
 894   hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<a name="77" id="anc77"></a><span class="line-modified"> 895   hb_ot_zero_width_default_ignorables (c-&gt;buffer);</span>
<span class="line-added"> 896   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added"> 897     hb_aat_layout_zero_width_deleted_glyphs (c-&gt;buffer);</span>
 898   hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
 899 
 900   /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
 901   if (c-&gt;font-&gt;has_glyph_h_origin_func ())
 902     for (unsigned int i = 0; i &lt; count; i++)
 903       c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
 904                                         &amp;pos[i].x_offset,
 905                                         &amp;pos[i].y_offset);
<a name="78" id="anc78"></a><span class="line-added"> 906 </span>
<span class="line-added"> 907   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-added"> 908     _hb_ot_shape_fallback_mark_position (c-&gt;plan, c-&gt;font, c-&gt;buffer,</span>
<span class="line-added"> 909                                          adjust_offsets_when_zeroing);</span>
 910 }
 911 
 912 static inline void
<a name="79" id="anc79"></a><span class="line-modified"> 913 hb_ot_position (const hb_ot_shape_context_t *c)</span>
 914 {
 915   c-&gt;buffer-&gt;clear_positions ();
 916 
 917   hb_ot_position_default (c);
 918 
 919   hb_ot_position_complex (c);
 920 
<a name="80" id="anc80"></a>


 921   if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
 922     hb_buffer_reverse (c-&gt;buffer);
 923 
<a name="81" id="anc81"></a>




 924   _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);
<a name="82" id="anc82"></a>

 925 }
 926 
 927 static inline void
 928 hb_propagate_flags (hb_buffer_t *buffer)
 929 {
 930   /* Propagate cluster-level glyph flags to be the same on all cluster glyphs.
 931    * Simplifies using them. */
 932 
 933   if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))
 934     return;
 935 
 936   hb_glyph_info_t *info = buffer-&gt;info;
 937 
 938   foreach_cluster (buffer, start, end)
 939   {
 940     unsigned int mask = 0;
 941     for (unsigned int i = start; i &lt; end; i++)
 942       if (info[i].mask &amp; HB_GLYPH_FLAG_UNSAFE_TO_BREAK)
 943       {
 944          mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;
 945          break;
 946       }
 947     if (mask)
 948       for (unsigned int i = start; i &lt; end; i++)
 949         info[i].mask |= mask;
 950   }
 951 }
 952 
 953 /* Pull it all together! */
 954 
 955 static void
 956 hb_ot_shape_internal (hb_ot_shape_context_t *c)
 957 {
 958   c-&gt;buffer-&gt;deallocate_var_all ();
 959   c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<a name="83" id="anc83"></a><span class="line-modified"> 960   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
 961   {
 962     c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
 963                               (unsigned) HB_BUFFER_MAX_LEN_MIN);
 964   }
<a name="84" id="anc84"></a><span class="line-modified"> 965   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
 966   {
 967     c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
 968                               (unsigned) HB_BUFFER_MAX_OPS_MIN);
 969   }
 970 
<a name="85" id="anc85"></a>




 971   /* Save the original direction, we use it later. */
 972   c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
 973 
 974   _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
 975 
 976   c-&gt;buffer-&gt;clear_output ();
 977 
 978   hb_ot_shape_initialize_masks (c);
 979   hb_set_unicode_props (c-&gt;buffer);
 980   hb_insert_dotted_circle (c-&gt;buffer, c-&gt;font);
 981 
 982   hb_form_clusters (c-&gt;buffer);
 983 
 984   hb_ensure_native_direction (c-&gt;buffer);
 985 
 986   if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
 987     c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
 988 
<a name="86" id="anc86"></a><span class="line-modified"> 989   hb_ot_substitute_pre (c);</span>
 990   hb_ot_position (c);
<a name="87" id="anc87"></a><span class="line-modified"> 991   hb_ot_substitute_post (c);</span>




 992 
 993   hb_propagate_flags (c-&gt;buffer);
 994 
 995   _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
 996 
 997   c-&gt;buffer-&gt;props.direction = c-&gt;target_direction;
 998 
 999   c-&gt;buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
1000   c-&gt;buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
1001   c-&gt;buffer-&gt;deallocate_var_all ();
1002 }
1003 
1004 
1005 hb_bool_t
1006 _hb_ot_shape (hb_shape_plan_t    *shape_plan,
1007               hb_font_t          *font,
1008               hb_buffer_t        *buffer,
1009               const hb_feature_t *features,
1010               unsigned int        num_features)
1011 {
<a name="88" id="anc88"></a><span class="line-modified">1012   hb_ot_shape_context_t c = {&amp;shape_plan-&gt;ot, font, font-&gt;face, buffer, features, num_features};</span>
1013   hb_ot_shape_internal (&amp;c);
1014 
1015   return true;
1016 }
1017 
1018 
1019 /**
1020  * hb_ot_shape_plan_collect_lookups:
1021  *
1022  * Since: 0.9.7
1023  **/
1024 void
1025 hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
1026                                   hb_tag_t         table_tag,
1027                                   hb_set_t        *lookup_indexes /* OUT */)
1028 {
<a name="89" id="anc89"></a><span class="line-modified">1029   shape_plan-&gt;ot.collect_lookups (table_tag, lookup_indexes);</span>

1030 }
1031 
1032 
1033 /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
1034 static void
1035 add_char (hb_font_t          *font,
1036           hb_unicode_funcs_t *unicode,
1037           hb_bool_t           mirror,
1038           hb_codepoint_t      u,
1039           hb_set_t           *glyphs)
1040 {
1041   hb_codepoint_t glyph;
1042   if (font-&gt;get_nominal_glyph (u, &amp;glyph))
1043     glyphs-&gt;add (glyph);
1044   if (mirror)
1045   {
1046     hb_codepoint_t m = unicode-&gt;mirroring (u);
1047     if (m != u &amp;&amp; font-&gt;get_nominal_glyph (m, &amp;glyph))
1048       glyphs-&gt;add (glyph);
1049   }
1050 }
1051 
1052 
1053 /**
1054  * hb_ot_shape_glyphs_closure:
1055  *
1056  * Since: 0.9.2
1057  **/
1058 void
1059 hb_ot_shape_glyphs_closure (hb_font_t          *font,
1060                             hb_buffer_t        *buffer,
1061                             const hb_feature_t *features,
1062                             unsigned int        num_features,
1063                             hb_set_t           *glyphs)
1064 {
1065   const char *shapers[] = {&quot;ot&quot;, nullptr};
1066   hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached (font-&gt;face, &amp;buffer-&gt;props,
1067                                                              features, num_features, shapers);
1068 
1069   bool mirror = hb_script_get_horizontal_direction (buffer-&gt;props.script) == HB_DIRECTION_RTL;
1070 
1071   unsigned int count = buffer-&gt;len;
1072   hb_glyph_info_t *info = buffer-&gt;info;
1073   for (unsigned int i = 0; i &lt; count; i++)
1074     add_char (font, buffer-&gt;unicode, mirror, info[i].codepoint, glyphs);
1075 
1076   hb_set_t *lookups = hb_set_create ();
1077   hb_ot_shape_plan_collect_lookups (shape_plan, HB_OT_TAG_GSUB, lookups);
1078   hb_ot_layout_lookups_substitute_closure (font-&gt;face, lookups, glyphs);
1079 
1080   hb_set_destroy (lookups);
1081 
1082   hb_shape_plan_destroy (shape_plan);
1083 }
<a name="90" id="anc90"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="90" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-debug.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-coretext.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-deprecated.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-debug.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_DEBUG_HH
 28 #define HB_DEBUG_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-private.hh&quot;</span>


 31 
 32 
 33 #ifndef HB_DEBUG
 34 #define HB_DEBUG 0
 35 #endif
 36 













































 37 static inline bool
 38 _hb_debug (unsigned int level,
 39            unsigned int max_level)
 40 {
 41   return level &lt; max_level;
 42 }
 43 
 44 #define DEBUG_LEVEL_ENABLED(WHAT, LEVEL) (_hb_debug ((LEVEL), HB_DEBUG_##WHAT))
 45 #define DEBUG_ENABLED(WHAT) (DEBUG_LEVEL_ENABLED (WHAT, 0))
 46 
 47 static inline void
 48 _hb_print_func (const char *func)
 49 {
 50   if (func)
 51   {
 52     unsigned int func_len = strlen (func);
 53     /* Skip &quot;static&quot; */
 54     if (0 == strncmp (func, &quot;static &quot;, 7))
 55       func += 7;
 56     /* Skip &quot;typename&quot; */
</pre>
<hr />
<pre>
109       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
110       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
111       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR;
112     fprintf (stderr, &quot;%2u %s&quot; VRBAR &quot;%s&quot;,
113              level,
114              bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars) - 1, (unsigned int) (sizeof (VBAR) - 1) * level),
115              level_dir ? (level_dir &gt; 0 ? DLBAR : ULBAR) : LBAR);
116   } else
117     fprintf (stderr, &quot;   &quot; VRBAR LBAR);
118 
119   _hb_print_func (func);
120 
121   if (message)
122   {
123     fprintf (stderr, &quot;: &quot;);
124     vfprintf (stderr, message, ap);
125   }
126 
127   fprintf (stderr, &quot;\n&quot;);
128 }
<span class="line-modified">129 template &lt;&gt; inline void</span>
130 _hb_debug_msg_va&lt;0&gt; (const char *what HB_UNUSED,
131                      const void *obj HB_UNUSED,
132                      const char *func HB_UNUSED,
133                      bool indented HB_UNUSED,
134                      unsigned int level HB_UNUSED,
135                      int level_dir HB_UNUSED,
136                      const char *message HB_UNUSED,
137                      va_list ap HB_UNUSED) {}
138 
139 template &lt;int max_level&gt; static inline void
140 _hb_debug_msg (const char *what,
141                const void *obj,
142                const char *func,
143                bool indented,
144                unsigned int level,
145                int level_dir,
146                const char *message,
147                ...) HB_PRINTF_FUNC(7, 8);
<span class="line-modified">148 template &lt;int max_level&gt; static inline void</span>
149 _hb_debug_msg (const char *what,
150                const void *obj,
151                const char *func,
152                bool indented,
153                unsigned int level,
154                int level_dir,
155                const char *message,
156                ...)
157 {
158   va_list ap;
159   va_start (ap, message);
160   _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, indented, level, level_dir, message, ap);
161   va_end (ap);
162 }
163 template &lt;&gt; inline void
164 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
165                   const void *obj HB_UNUSED,
166                   const char *func HB_UNUSED,
167                   bool indented HB_UNUSED,
168                   unsigned int level HB_UNUSED,
169                   int level_dir HB_UNUSED,
170                   const char *message HB_UNUSED,
171                   ...) HB_PRINTF_FUNC(7, 8);
<span class="line-modified">172 template &lt;&gt; inline void</span>
173 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
174                   const void *obj HB_UNUSED,
175                   const char *func HB_UNUSED,
176                   bool indented HB_UNUSED,
177                   unsigned int level HB_UNUSED,
178                   int level_dir HB_UNUSED,
179                   const char *message HB_UNUSED,
180                   ...) {}
181 
182 #define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)       _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    true, (LEVEL), (LEVEL_DIR), __VA_ARGS__)
183 #define DEBUG_MSG(WHAT, OBJ, ...)                               _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    false, 0, 0, __VA_ARGS__)
184 #define DEBUG_MSG_FUNC(WHAT, OBJ, ...)                          _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), HB_FUNC, false, 0, 0, __VA_ARGS__)
185 
186 
187 /*
188  * Printer
189  */
190 
191 template &lt;typename T&gt;
192 struct hb_printer_t {
</pre>
<hr />
<pre>
220 {}
221 
222 template &lt;int max_level, typename ret_t&gt;
223 struct hb_auto_trace_t
224 {
225   explicit inline hb_auto_trace_t (unsigned int *plevel_,
226                                    const char *what_,
227                                    const void *obj_,
228                                    const char *func,
229                                    const char *message,
230                                    ...) HB_PRINTF_FUNC(6, 7)
231                                    : plevel (plevel_), what (what_), obj (obj_), returned (false)
232   {
233     if (plevel) ++*plevel;
234 
235     va_list ap;
236     va_start (ap, message);
237     _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, true, plevel ? *plevel : 0, +1, message, ap);
238     va_end (ap);
239   }
<span class="line-modified">240   inline ~hb_auto_trace_t (void)</span>
241   {
242     _hb_warn_no_return&lt;ret_t&gt; (returned);
243     if (!returned) {
244       _hb_debug_msg&lt;max_level&gt; (what, obj, nullptr, true, plevel ? *plevel : 1, -1, &quot; &quot;);
245     }
246     if (plevel) --*plevel;
247   }
248 
<span class="line-modified">249   inline ret_t ret (ret_t v, unsigned int line = 0)</span>


250   {
251     if (unlikely (returned)) {
252       fprintf (stderr, &quot;OUCH, double calls to return_trace().  This is a bug, please report.\n&quot;);
253       return v;
254     }
255 
<span class="line-modified">256     _hb_debug_msg&lt;max_level&gt; (what, obj, nullptr, true, plevel ? *plevel : 1, -1,</span>
257                               &quot;return %s (line %d)&quot;,
258                               hb_printer_t&lt;ret_t&gt;().print (v), line);
259     if (plevel) --*plevel;
260     plevel = nullptr;
261     returned = true;
262     return v;
263   }
264 
265   private:
266   unsigned int *plevel;
267   const char *what;
268   const void *obj;
269   bool returned;
270 };
271 template &lt;typename ret_t&gt; /* Make sure we don&#39;t use hb_auto_trace_t when not tracing. */
272 struct hb_auto_trace_t&lt;0, ret_t&gt;
273 {
274   explicit inline hb_auto_trace_t (unsigned int *plevel_,
275                                    const char *what_,
276                                    const void *obj_,
277                                    const char *func,
278                                    const char *message,
279                                    ...) HB_PRINTF_FUNC(6, 7) {}
280 
<span class="line-modified">281   inline ret_t ret (ret_t v, unsigned int line HB_UNUSED = 0) { return v; }</span>


282 };
283 
284 /* For disabled tracing; optimize out everything.
285  * https://github.com/harfbuzz/harfbuzz/pull/605 */
286 template &lt;typename ret_t&gt;
287 struct hb_no_trace_t {
<span class="line-modified">288   inline ret_t ret (ret_t v, unsigned int line HB_UNUSED = 0) { return v; }</span>


289 };
290 
<span class="line-modified">291 #define return_trace(RET) return trace.ret (RET, __LINE__)</span>
292 
293 
294 /*
295  * Instances.
296  */
297 
298 #ifndef HB_DEBUG_ARABIC
299 #define HB_DEBUG_ARABIC (HB_DEBUG+0)
300 #endif
301 
302 #ifndef HB_DEBUG_BLOB
303 #define HB_DEBUG_BLOB (HB_DEBUG+0)
304 #endif
305 
306 #ifndef HB_DEBUG_CORETEXT
307 #define HB_DEBUG_CORETEXT (HB_DEBUG+0)
308 #endif
309 
310 #ifndef HB_DEBUG_DIRECTWRITE
311 #define HB_DEBUG_DIRECTWRITE (HB_DEBUG+0)
</pre>
<hr />
<pre>
331 #define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)
332 #endif
333 
334 /*
335  * With tracing.
336  */
337 
338 #ifndef HB_DEBUG_APPLY
339 #define HB_DEBUG_APPLY (HB_DEBUG+0)
340 #endif
341 #if HB_DEBUG_APPLY
342 #define TRACE_APPLY(this) \
343         hb_auto_trace_t&lt;HB_DEBUG_APPLY, bool&gt; trace \
344         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
345          &quot;idx %d gid %u lookup %d&quot;, \
346          c-&gt;buffer-&gt;idx, c-&gt;buffer-&gt;cur().codepoint, (int) c-&gt;lookup_index)
347 #else
348 #define TRACE_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
349 #endif
350 
<span class="line-removed">351 #ifndef HB_DEBUG_CLOSURE</span>
<span class="line-removed">352 #define HB_DEBUG_CLOSURE (HB_DEBUG+0)</span>
<span class="line-removed">353 #endif</span>
<span class="line-removed">354 #if HB_DEBUG_CLOSURE</span>
<span class="line-removed">355 #define TRACE_CLOSURE(this) \</span>
<span class="line-removed">356         hb_auto_trace_t&lt;HB_DEBUG_CLOSURE, hb_void_t&gt; trace \</span>
<span class="line-removed">357         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \</span>
<span class="line-removed">358          &quot; &quot;)</span>
<span class="line-removed">359 #else</span>
<span class="line-removed">360 #define TRACE_CLOSURE(this) hb_no_trace_t&lt;hb_void_t&gt; trace HB_UNUSED</span>
<span class="line-removed">361 #endif</span>
<span class="line-removed">362 </span>
<span class="line-removed">363 #ifndef HB_DEBUG_COLLECT_GLYPHS</span>
<span class="line-removed">364 #define HB_DEBUG_COLLECT_GLYPHS (HB_DEBUG+0)</span>
<span class="line-removed">365 #endif</span>
<span class="line-removed">366 #if HB_DEBUG_COLLECT_GLYPHS</span>
<span class="line-removed">367 #define TRACE_COLLECT_GLYPHS(this) \</span>
<span class="line-removed">368         hb_auto_trace_t&lt;HB_DEBUG_COLLECT_GLYPHS, hb_void_t&gt; trace \</span>
<span class="line-removed">369         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \</span>
<span class="line-removed">370          &quot; &quot;)</span>
<span class="line-removed">371 #else</span>
<span class="line-removed">372 #define TRACE_COLLECT_GLYPHS(this) hb_no_trace_t&lt;hb_void_t&gt; trace HB_UNUSED</span>
<span class="line-removed">373 #endif</span>
<span class="line-removed">374 </span>
375 #ifndef HB_DEBUG_SANITIZE
376 #define HB_DEBUG_SANITIZE (HB_DEBUG+0)
377 #endif
378 #if HB_DEBUG_SANITIZE
379 #define TRACE_SANITIZE(this) \
380         hb_auto_trace_t&lt;HB_DEBUG_SANITIZE, bool&gt; trace \
381         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
382          &quot; &quot;);
383 #else
384 #define TRACE_SANITIZE(this) hb_no_trace_t&lt;bool&gt; trace
385 #endif
386 
387 #ifndef HB_DEBUG_SERIALIZE
388 #define HB_DEBUG_SERIALIZE (HB_DEBUG+0)
389 #endif
390 #if HB_DEBUG_SERIALIZE
391 #define TRACE_SERIALIZE(this) \
392         hb_auto_trace_t&lt;HB_DEBUG_SERIALIZE, bool&gt; trace \
393         (&amp;c-&gt;debug_depth, &quot;SERIALIZE&quot;, c, HB_FUNC, \
394          &quot; &quot;);
</pre>
<hr />
<pre>
406    &quot; &quot;);
407 #else
408 #define TRACE_SUBSET(this) hb_no_trace_t&lt;bool&gt; trace
409 #endif
410 
411 #ifndef HB_DEBUG_WOULD_APPLY
412 #define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)
413 #endif
414 #if HB_DEBUG_WOULD_APPLY
415 #define TRACE_WOULD_APPLY(this) \
416         hb_auto_trace_t&lt;HB_DEBUG_WOULD_APPLY, bool&gt; trace \
417         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
418          &quot;%d glyphs&quot;, c-&gt;len);
419 #else
420 #define TRACE_WOULD_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
421 #endif
422 
423 #ifndef HB_DEBUG_DISPATCH
424 #define HB_DEBUG_DISPATCH ( \
425         HB_DEBUG_APPLY + \
<span class="line-removed">426         HB_DEBUG_CLOSURE + \</span>
<span class="line-removed">427         HB_DEBUG_COLLECT_GLYPHS + \</span>
428         HB_DEBUG_SANITIZE + \
429         HB_DEBUG_SERIALIZE + \
430   HB_DEBUG_SUBSET + \
431         HB_DEBUG_WOULD_APPLY + \
432         0)
433 #endif
434 #if HB_DEBUG_DISPATCH
435 #define TRACE_DISPATCH(this, format) \
436         hb_auto_trace_t&lt;context_t::max_debug_depth, typename context_t::return_t&gt; trace \
437         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
438          &quot;format %d&quot;, (int) format);
439 #else
440 #define TRACE_DISPATCH(this, format) hb_no_trace_t&lt;typename context_t::return_t&gt; trace
441 #endif
442 
443 
444 #endif /* HB_DEBUG_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_DEBUG_HH
 28 #define HB_DEBUG_HH
 29 
<span class="line-modified"> 30 #include &quot;hb.hh&quot;</span>
<span class="line-added"> 31 #include &quot;hb-atomic.hh&quot;</span>
<span class="line-added"> 32 #include &quot;hb-dsalgs.hh&quot;</span>
 33 
 34 
 35 #ifndef HB_DEBUG
 36 #define HB_DEBUG 0
 37 #endif
 38 
<span class="line-added"> 39 </span>
<span class="line-added"> 40 /*</span>
<span class="line-added"> 41  * Global runtime options.</span>
<span class="line-added"> 42  */</span>
<span class="line-added"> 43 </span>
<span class="line-added"> 44 struct hb_options_t</span>
<span class="line-added"> 45 {</span>
<span class="line-added"> 46   bool unused : 1; /* In-case sign bit is here. */</span>
<span class="line-added"> 47   bool initialized : 1;</span>
<span class="line-added"> 48   bool uniscribe_bug_compatible : 1;</span>
<span class="line-added"> 49   bool aat : 1;</span>
<span class="line-added"> 50 };</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52 union hb_options_union_t {</span>
<span class="line-added"> 53   int i;</span>
<span class="line-added"> 54   hb_options_t opts;</span>
<span class="line-added"> 55 };</span>
<span class="line-added"> 56 static_assert ((sizeof (hb_atomic_int_t) &gt;= sizeof (hb_options_union_t)), &quot;&quot;);</span>
<span class="line-added"> 57 </span>
<span class="line-added"> 58 HB_INTERNAL void</span>
<span class="line-added"> 59 _hb_options_init ();</span>
<span class="line-added"> 60 </span>
<span class="line-added"> 61 extern HB_INTERNAL hb_atomic_int_t _hb_options;</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 static inline hb_options_t</span>
<span class="line-added"> 64 hb_options ()</span>
<span class="line-added"> 65 {</span>
<span class="line-added"> 66   /* Make a local copy, so we can access bitfield threadsafely. */</span>
<span class="line-added"> 67   hb_options_union_t u;</span>
<span class="line-added"> 68   u.i = _hb_options.get_relaxed ();</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70   if (unlikely (!u.i))</span>
<span class="line-added"> 71   {</span>
<span class="line-added"> 72     _hb_options_init ();</span>
<span class="line-added"> 73     u.i = _hb_options.get_relaxed ();</span>
<span class="line-added"> 74   }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76   return u.opts;</span>
<span class="line-added"> 77 }</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80 /*</span>
<span class="line-added"> 81  * Debug output (needs enabling at compile time.)</span>
<span class="line-added"> 82  */</span>
<span class="line-added"> 83 </span>
 84 static inline bool
 85 _hb_debug (unsigned int level,
 86            unsigned int max_level)
 87 {
 88   return level &lt; max_level;
 89 }
 90 
 91 #define DEBUG_LEVEL_ENABLED(WHAT, LEVEL) (_hb_debug ((LEVEL), HB_DEBUG_##WHAT))
 92 #define DEBUG_ENABLED(WHAT) (DEBUG_LEVEL_ENABLED (WHAT, 0))
 93 
 94 static inline void
 95 _hb_print_func (const char *func)
 96 {
 97   if (func)
 98   {
 99     unsigned int func_len = strlen (func);
100     /* Skip &quot;static&quot; */
101     if (0 == strncmp (func, &quot;static &quot;, 7))
102       func += 7;
103     /* Skip &quot;typename&quot; */
</pre>
<hr />
<pre>
156       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
157       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR
158       VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR;
159     fprintf (stderr, &quot;%2u %s&quot; VRBAR &quot;%s&quot;,
160              level,
161              bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars) - 1, (unsigned int) (sizeof (VBAR) - 1) * level),
162              level_dir ? (level_dir &gt; 0 ? DLBAR : ULBAR) : LBAR);
163   } else
164     fprintf (stderr, &quot;   &quot; VRBAR LBAR);
165 
166   _hb_print_func (func);
167 
168   if (message)
169   {
170     fprintf (stderr, &quot;: &quot;);
171     vfprintf (stderr, message, ap);
172   }
173 
174   fprintf (stderr, &quot;\n&quot;);
175 }
<span class="line-modified">176 template &lt;&gt; inline void HB_PRINTF_FUNC(7, 0)</span>
177 _hb_debug_msg_va&lt;0&gt; (const char *what HB_UNUSED,
178                      const void *obj HB_UNUSED,
179                      const char *func HB_UNUSED,
180                      bool indented HB_UNUSED,
181                      unsigned int level HB_UNUSED,
182                      int level_dir HB_UNUSED,
183                      const char *message HB_UNUSED,
184                      va_list ap HB_UNUSED) {}
185 
186 template &lt;int max_level&gt; static inline void
187 _hb_debug_msg (const char *what,
188                const void *obj,
189                const char *func,
190                bool indented,
191                unsigned int level,
192                int level_dir,
193                const char *message,
194                ...) HB_PRINTF_FUNC(7, 8);
<span class="line-modified">195 template &lt;int max_level&gt; static inline void HB_PRINTF_FUNC(7, 8)</span>
196 _hb_debug_msg (const char *what,
197                const void *obj,
198                const char *func,
199                bool indented,
200                unsigned int level,
201                int level_dir,
202                const char *message,
203                ...)
204 {
205   va_list ap;
206   va_start (ap, message);
207   _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, indented, level, level_dir, message, ap);
208   va_end (ap);
209 }
210 template &lt;&gt; inline void
211 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
212                   const void *obj HB_UNUSED,
213                   const char *func HB_UNUSED,
214                   bool indented HB_UNUSED,
215                   unsigned int level HB_UNUSED,
216                   int level_dir HB_UNUSED,
217                   const char *message HB_UNUSED,
218                   ...) HB_PRINTF_FUNC(7, 8);
<span class="line-modified">219 template &lt;&gt; inline void HB_PRINTF_FUNC(7, 8)</span>
220 _hb_debug_msg&lt;0&gt; (const char *what HB_UNUSED,
221                   const void *obj HB_UNUSED,
222                   const char *func HB_UNUSED,
223                   bool indented HB_UNUSED,
224                   unsigned int level HB_UNUSED,
225                   int level_dir HB_UNUSED,
226                   const char *message HB_UNUSED,
227                   ...) {}
228 
229 #define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)       _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    true, (LEVEL), (LEVEL_DIR), __VA_ARGS__)
230 #define DEBUG_MSG(WHAT, OBJ, ...)                               _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), nullptr,    false, 0, 0, __VA_ARGS__)
231 #define DEBUG_MSG_FUNC(WHAT, OBJ, ...)                          _hb_debug_msg&lt;HB_DEBUG_##WHAT&gt; (#WHAT, (OBJ), HB_FUNC, false, 0, 0, __VA_ARGS__)
232 
233 
234 /*
235  * Printer
236  */
237 
238 template &lt;typename T&gt;
239 struct hb_printer_t {
</pre>
<hr />
<pre>
267 {}
268 
269 template &lt;int max_level, typename ret_t&gt;
270 struct hb_auto_trace_t
271 {
272   explicit inline hb_auto_trace_t (unsigned int *plevel_,
273                                    const char *what_,
274                                    const void *obj_,
275                                    const char *func,
276                                    const char *message,
277                                    ...) HB_PRINTF_FUNC(6, 7)
278                                    : plevel (plevel_), what (what_), obj (obj_), returned (false)
279   {
280     if (plevel) ++*plevel;
281 
282     va_list ap;
283     va_start (ap, message);
284     _hb_debug_msg_va&lt;max_level&gt; (what, obj, func, true, plevel ? *plevel : 0, +1, message, ap);
285     va_end (ap);
286   }
<span class="line-modified">287   ~hb_auto_trace_t ()</span>
288   {
289     _hb_warn_no_return&lt;ret_t&gt; (returned);
290     if (!returned) {
291       _hb_debug_msg&lt;max_level&gt; (what, obj, nullptr, true, plevel ? *plevel : 1, -1, &quot; &quot;);
292     }
293     if (plevel) --*plevel;
294   }
295 
<span class="line-modified">296   ret_t ret (ret_t v,</span>
<span class="line-added">297              const char *func = &quot;&quot;,</span>
<span class="line-added">298              unsigned int line = 0)</span>
299   {
300     if (unlikely (returned)) {
301       fprintf (stderr, &quot;OUCH, double calls to return_trace().  This is a bug, please report.\n&quot;);
302       return v;
303     }
304 
<span class="line-modified">305     _hb_debug_msg&lt;max_level&gt; (what, obj, func, true, plevel ? *plevel : 1, -1,</span>
306                               &quot;return %s (line %d)&quot;,
307                               hb_printer_t&lt;ret_t&gt;().print (v), line);
308     if (plevel) --*plevel;
309     plevel = nullptr;
310     returned = true;
311     return v;
312   }
313 
314   private:
315   unsigned int *plevel;
316   const char *what;
317   const void *obj;
318   bool returned;
319 };
320 template &lt;typename ret_t&gt; /* Make sure we don&#39;t use hb_auto_trace_t when not tracing. */
321 struct hb_auto_trace_t&lt;0, ret_t&gt;
322 {
323   explicit inline hb_auto_trace_t (unsigned int *plevel_,
324                                    const char *what_,
325                                    const void *obj_,
326                                    const char *func,
327                                    const char *message,
328                                    ...) HB_PRINTF_FUNC(6, 7) {}
329 
<span class="line-modified">330   ret_t ret (ret_t v,</span>
<span class="line-added">331              const char *func HB_UNUSED = nullptr,</span>
<span class="line-added">332              unsigned int line HB_UNUSED = 0) { return v; }</span>
333 };
334 
335 /* For disabled tracing; optimize out everything.
336  * https://github.com/harfbuzz/harfbuzz/pull/605 */
337 template &lt;typename ret_t&gt;
338 struct hb_no_trace_t {
<span class="line-modified">339   ret_t ret (ret_t v,</span>
<span class="line-added">340              const char *func HB_UNUSED = &quot;&quot;,</span>
<span class="line-added">341              unsigned int line HB_UNUSED = 0) { return v; }</span>
342 };
343 
<span class="line-modified">344 #define return_trace(RET) return trace.ret (RET, HB_FUNC, __LINE__)</span>
345 
346 
347 /*
348  * Instances.
349  */
350 
351 #ifndef HB_DEBUG_ARABIC
352 #define HB_DEBUG_ARABIC (HB_DEBUG+0)
353 #endif
354 
355 #ifndef HB_DEBUG_BLOB
356 #define HB_DEBUG_BLOB (HB_DEBUG+0)
357 #endif
358 
359 #ifndef HB_DEBUG_CORETEXT
360 #define HB_DEBUG_CORETEXT (HB_DEBUG+0)
361 #endif
362 
363 #ifndef HB_DEBUG_DIRECTWRITE
364 #define HB_DEBUG_DIRECTWRITE (HB_DEBUG+0)
</pre>
<hr />
<pre>
384 #define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)
385 #endif
386 
387 /*
388  * With tracing.
389  */
390 
391 #ifndef HB_DEBUG_APPLY
392 #define HB_DEBUG_APPLY (HB_DEBUG+0)
393 #endif
394 #if HB_DEBUG_APPLY
395 #define TRACE_APPLY(this) \
396         hb_auto_trace_t&lt;HB_DEBUG_APPLY, bool&gt; trace \
397         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
398          &quot;idx %d gid %u lookup %d&quot;, \
399          c-&gt;buffer-&gt;idx, c-&gt;buffer-&gt;cur().codepoint, (int) c-&gt;lookup_index)
400 #else
401 #define TRACE_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
402 #endif
403 
























404 #ifndef HB_DEBUG_SANITIZE
405 #define HB_DEBUG_SANITIZE (HB_DEBUG+0)
406 #endif
407 #if HB_DEBUG_SANITIZE
408 #define TRACE_SANITIZE(this) \
409         hb_auto_trace_t&lt;HB_DEBUG_SANITIZE, bool&gt; trace \
410         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
411          &quot; &quot;);
412 #else
413 #define TRACE_SANITIZE(this) hb_no_trace_t&lt;bool&gt; trace
414 #endif
415 
416 #ifndef HB_DEBUG_SERIALIZE
417 #define HB_DEBUG_SERIALIZE (HB_DEBUG+0)
418 #endif
419 #if HB_DEBUG_SERIALIZE
420 #define TRACE_SERIALIZE(this) \
421         hb_auto_trace_t&lt;HB_DEBUG_SERIALIZE, bool&gt; trace \
422         (&amp;c-&gt;debug_depth, &quot;SERIALIZE&quot;, c, HB_FUNC, \
423          &quot; &quot;);
</pre>
<hr />
<pre>
435    &quot; &quot;);
436 #else
437 #define TRACE_SUBSET(this) hb_no_trace_t&lt;bool&gt; trace
438 #endif
439 
440 #ifndef HB_DEBUG_WOULD_APPLY
441 #define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)
442 #endif
443 #if HB_DEBUG_WOULD_APPLY
444 #define TRACE_WOULD_APPLY(this) \
445         hb_auto_trace_t&lt;HB_DEBUG_WOULD_APPLY, bool&gt; trace \
446         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
447          &quot;%d glyphs&quot;, c-&gt;len);
448 #else
449 #define TRACE_WOULD_APPLY(this) hb_no_trace_t&lt;bool&gt; trace
450 #endif
451 
452 #ifndef HB_DEBUG_DISPATCH
453 #define HB_DEBUG_DISPATCH ( \
454         HB_DEBUG_APPLY + \


455         HB_DEBUG_SANITIZE + \
456         HB_DEBUG_SERIALIZE + \
457   HB_DEBUG_SUBSET + \
458         HB_DEBUG_WOULD_APPLY + \
459         0)
460 #endif
461 #if HB_DEBUG_DISPATCH
462 #define TRACE_DISPATCH(this, format) \
463         hb_auto_trace_t&lt;context_t::max_debug_depth, typename context_t::return_t&gt; trace \
464         (&amp;c-&gt;debug_depth, c-&gt;get_name (), this, HB_FUNC, \
465          &quot;format %d&quot;, (int) format);
466 #else
467 #define TRACE_DISPATCH(this, format) hb_no_trace_t&lt;typename context_t::return_t&gt; trace
468 #endif
469 
470 
471 #endif /* HB_DEBUG_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-coretext.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-deprecated.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
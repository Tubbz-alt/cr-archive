<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-khmer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<a name="1" id="anc1"></a><span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-khmer.hh&quot;</span>
<span class="line-modified"> 28 #include &quot;hb-ot-layout.hh&quot;</span>
 29 
 30 
 31 /*
 32  * Khmer shaper.
 33  */
 34 
<a name="2" id="anc2"></a><span class="line-modified"> 35 static const hb_ot_map_feature_t</span>





 36 khmer_features[] =
 37 {
 38   /*
 39    * Basic features.
<a name="3" id="anc3"></a><span class="line-modified"> 40    * These features are applied in order, one at a time, after reordering.</span>
 41    */
<a name="4" id="anc4"></a><span class="line-modified"> 42   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 43   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 44   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 45   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_MANUAL_JOINERS},</span>
<span class="line-modified"> 46   {HB_TAG(&#39;c&#39;,&#39;f&#39;,&#39;a&#39;,&#39;r&#39;), F_MANUAL_JOINERS},</span>
 47   /*
 48    * Other features.
<a name="5" id="anc5"></a><span class="line-modified"> 49    * These features are applied all at once after clearing syllables.</span>
<span class="line-modified"> 50    */</span>
<span class="line-modified"> 51   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 52   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 53   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 54   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added"> 55   /*</span>
<span class="line-added"> 56    * Positioning features.</span>
<span class="line-added"> 57    * We don&#39;t care about the types.</span>
 58    */
<a name="6" id="anc6"></a>




 59   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 60   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 61   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 62 };
 63 
 64 /*
 65  * Must be in the same order as the khmer_features array.
 66  */
 67 enum {
 68   PREF,
 69   BLWF,
 70   ABVF,
 71   PSTF,
 72   CFAR,
 73 
 74   _PRES,
 75   _ABVS,
 76   _BLWS,
 77   _PSTS,
<a name="7" id="anc7"></a><span class="line-added"> 78 </span>
 79   _DIST,
 80   _ABVM,
 81   _BLWM,
 82 
 83   KHMER_NUM_FEATURES,
<a name="8" id="anc8"></a><span class="line-modified"> 84   KHMER_BASIC_FEATURES = _PRES, /* Don&#39;t forget to update this! */</span>
 85 };
 86 
 87 static void
 88 setup_syllables (const hb_ot_shape_plan_t *plan,
 89                  hb_font_t *font,
 90                  hb_buffer_t *buffer);
 91 static void
<a name="9" id="anc9"></a><span class="line-modified"> 92 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified"> 93          hb_font_t *font,</span>
<span class="line-modified"> 94          hb_buffer_t *buffer);</span>




 95 static void
 96 clear_syllables (const hb_ot_shape_plan_t *plan,
 97                  hb_font_t *font,
 98                  hb_buffer_t *buffer);
 99 
100 static void
101 collect_features_khmer (hb_ot_shape_planner_t *plan)
102 {
103   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
104 
105   /* Do this before any lookups have been applied. */
106   map-&gt;add_gsub_pause (setup_syllables);
<a name="10" id="anc10"></a><span class="line-added">107   map-&gt;add_gsub_pause (reorder);</span>
108 
<a name="11" id="anc11"></a><span class="line-modified">109   /* Testing suggests that Uniscribe does NOT pause between basic</span>
<span class="line-modified">110    * features.  Test with KhmerUI.ttf and the following three</span>
<span class="line-modified">111    * sequences:</span>
<span class="line-modified">112    *</span>
<span class="line-modified">113    *   U+1789,U+17BC</span>
<span class="line-added">114    *   U+1789,U+17D2,U+1789</span>
<span class="line-added">115    *   U+1789,U+17D2,U+1789,U+17BC</span>
<span class="line-added">116    *</span>
<span class="line-added">117    * https://github.com/harfbuzz/harfbuzz/issues/974</span>
<span class="line-added">118    */</span>
<span class="line-added">119   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="line-added">120   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
121 
122   unsigned int i = 0;
<a name="12" id="anc12"></a><span class="line-modified">123   for (; i &lt; KHMER_BASIC_FEATURES; i++)</span>
<span class="line-modified">124     map-&gt;add_feature (khmer_features[i]);</span>










125 
126   map-&gt;add_gsub_pause (clear_syllables);
<a name="13" id="anc13"></a><span class="line-added">127 </span>
<span class="line-added">128   for (; i &lt; KHMER_NUM_FEATURES; i++)</span>
<span class="line-added">129     map-&gt;add_feature (khmer_features[i]);</span>
130 }
131 
132 static void
133 override_features_khmer (hb_ot_shape_planner_t *plan)
134 {
<a name="14" id="anc14"></a><span class="line-added">135   hb_ot_map_builder_t *map = &amp;plan-&gt;map;</span>
<span class="line-added">136 </span>
<span class="line-added">137   /* Khmer spec has &#39;clig&#39; as part of required shaping features:</span>
<span class="line-added">138    * &quot;Apply feature &#39;clig&#39; to form ligatures that are desired for</span>
<span class="line-added">139    * typographical correctness.&quot;, hence in overrides... */</span>
<span class="line-added">140   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
<span class="line-added">141 </span>
142   /* Uniscribe does not apply &#39;kern&#39; in Khmer. */
143   if (hb_options ().uniscribe_bug_compatible)
144   {
<a name="15" id="anc15"></a><span class="line-modified">145     map-&gt;disable_feature (HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;));</span>
146   }
147 
<a name="16" id="anc16"></a><span class="line-modified">148   map-&gt;disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
149 }
150 
151 
152 struct would_substitute_feature_t
153 {
<a name="17" id="anc17"></a><span class="line-modified">154   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
155   {
156     zero_context = zero_context_;
157     map-&gt;get_stage_lookups (0/*GSUB*/,
158                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
159                             &amp;lookups, &amp;count);
160   }
161 
<a name="18" id="anc18"></a><span class="line-modified">162   bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified">163                          unsigned int          glyphs_count,</span>
<span class="line-modified">164                          hb_face_t            *face) const</span>
165   {
166     for (unsigned int i = 0; i &lt; count; i++)
167       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
168         return true;
169     return false;
170   }
171 
172   private:
173   const hb_ot_map_t::lookup_map_t *lookups;
174   unsigned int count;
175   bool zero_context;
176 };
177 
178 struct khmer_shape_plan_t
179 {
<a name="19" id="anc19"></a><span class="line-modified">180   bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>


181   {
182     hb_codepoint_t glyph = virama_glyph;
183     if (unlikely (virama_glyph == (hb_codepoint_t) -1))
184     {
185       if (!font-&gt;get_nominal_glyph (0x17D2u, &amp;glyph))
186         glyph = 0;
187       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
188        * Maybe one day... */
189 
190       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
191        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */
192       virama_glyph = glyph;
193     }
194 
195     *pglyph = glyph;
196     return glyph != 0;
197   }
198 
199   mutable hb_codepoint_t virama_glyph;
200 
201   would_substitute_feature_t pref;
202 
203   hb_mask_t mask_array[KHMER_NUM_FEATURES];
204 };
205 
206 static void *
207 data_create_khmer (const hb_ot_shape_plan_t *plan)
208 {
209   khmer_shape_plan_t *khmer_plan = (khmer_shape_plan_t *) calloc (1, sizeof (khmer_shape_plan_t));
210   if (unlikely (!khmer_plan))
211     return nullptr;
212 
213   khmer_plan-&gt;virama_glyph = (hb_codepoint_t) -1;
214 
215   khmer_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), true);
216 
217   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (khmer_plan-&gt;mask_array); i++)
218     khmer_plan-&gt;mask_array[i] = (khmer_features[i].flags &amp; F_GLOBAL) ?
219                                  0 : plan-&gt;map.get_1_mask (khmer_features[i].tag);
220 
221   return khmer_plan;
222 }
223 
224 static void
225 data_destroy_khmer (void *data)
226 {
227   free (data);
228 }
229 
230 
231 enum syllable_type_t {
232   consonant_syllable,
233   broken_cluster,
234   non_khmer_cluster,
235 };
236 
237 #include &quot;hb-ot-shape-complex-khmer-machine.hh&quot;
238 
239 static void
240 setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,
241                    hb_buffer_t              *buffer,
242                    hb_font_t                *font HB_UNUSED)
243 {
244   HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);
<a name="20" id="anc20"></a>
245 
246   /* We cannot setup masks here.  We save information about characters
247    * and setup masks later on in a pause-callback. */
248 
249   unsigned int count = buffer-&gt;len;
250   hb_glyph_info_t *info = buffer-&gt;info;
251   for (unsigned int i = 0; i &lt; count; i++)
252     set_khmer_properties (info[i]);
253 }
254 
255 static void
256 setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
257                  hb_font_t *font HB_UNUSED,
258                  hb_buffer_t *buffer)
259 {
260   find_syllables (buffer);
261   foreach_syllable (buffer, start, end)
262     buffer-&gt;unsafe_to_break (start, end);
263 }
264 
<a name="21" id="anc21"></a>








265 
266 /* Rules from:
267  * https://docs.microsoft.com/en-us/typography/script-development/devanagari */
268 
269 static void
<a name="22" id="anc22"></a><span class="line-modified">270 reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">271                             hb_face_t *face HB_UNUSED,</span>
<span class="line-modified">272                             hb_buffer_t *buffer,</span>
<span class="line-modified">273                             unsigned int start, unsigned int end)</span>
274 {
275   const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan-&gt;data;
276   hb_glyph_info_t *info = buffer-&gt;info;
277 
<a name="23" id="anc23"></a><span class="line-modified">278   /* Setup masks. */</span>




































































279   {
<a name="24" id="anc24"></a>













































280     /* Post-base */
<a name="25" id="anc25"></a><span class="line-modified">281     hb_mask_t mask = khmer_plan-&gt;mask_array[BLWF] | khmer_plan-&gt;mask_array[ABVF] | khmer_plan-&gt;mask_array[PSTF];</span>
<span class="line-modified">282     for (unsigned int i = start + 1; i &lt; end; i++)</span>
283       info[i].mask  |= mask;
284   }
285 
<a name="26" id="anc26"></a><span class="line-modified">286   unsigned int num_coengs = 0;</span>
<span class="line-modified">287   for (unsigned int i = start + 1; i &lt; end; i++)</span>
288   {
<a name="27" id="anc27"></a><span class="line-modified">289     /* &quot;&quot;&quot;</span>
<span class="line-modified">290      * When a COENG + (Cons | IndV) combination are found (and subscript count</span>
<span class="line-modified">291      * is less than two) the character combination is handled according to the</span>
<span class="line-modified">292      * subscript type of the character following the COENG.</span>
<span class="line-modified">293      *</span>
<span class="line-modified">294      * ...</span>
<span class="line-added">295      *</span>
<span class="line-added">296      * Subscript Type 2 - The COENG + RO characters are reordered to immediately</span>
<span class="line-added">297      * before the base glyph. Then the COENG + RO characters are assigned to have</span>
<span class="line-added">298      * the &#39;pref&#39; OpenType feature applied to them.</span>
<span class="line-added">299      * &quot;&quot;&quot;</span>
<span class="line-added">300      */</span>
<span class="line-added">301     if (info[i].khmer_category() == OT_Coeng &amp;&amp; num_coengs &lt;= 2 &amp;&amp; i + 1 &lt; end)</span>
<span class="line-added">302     {</span>
<span class="line-added">303       num_coengs++;</span>
<span class="line-added">304 </span>
<span class="line-added">305       if (info[i + 1].khmer_category() == OT_Ra)</span>
306       {
<a name="28" id="anc28"></a><span class="line-modified">307         for (unsigned int j = 0; j &lt; 2; j++)</span>
<span class="line-modified">308           info[i + j].mask |= khmer_plan-&gt;mask_array[PREF];</span>
<span class="line-added">309 </span>
<span class="line-added">310         /* Move the Coeng,Ro sequence to the start. */</span>
<span class="line-added">311         buffer-&gt;merge_clusters (start, i + 2);</span>
<span class="line-added">312         hb_glyph_info_t t0 = info[i];</span>
<span class="line-added">313         hb_glyph_info_t t1 = info[i + 1];</span>
<span class="line-added">314         memmove (&amp;info[start + 2], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">315         info[start] = t0;</span>
<span class="line-added">316         info[start + 1] = t1;</span>
317 
318         /* Mark the subsequent stuff with &#39;cfar&#39;.  Used in Khmer.
319          * Read the feature spec.
320          * This allows distinguishing the following cases with MS Khmer fonts:
321          * U+1784,U+17D2,U+179A,U+17D2,U+1782
322          * U+1784,U+17D2,U+1782,U+17D2,U+179A
323          */
324         if (khmer_plan-&gt;mask_array[CFAR])
<a name="29" id="anc29"></a><span class="line-modified">325           for (unsigned int j = i + 2; j &lt; end; j++)</span>
<span class="line-modified">326             info[j].mask |= khmer_plan-&gt;mask_array[CFAR];</span>
327 
<a name="30" id="anc30"></a><span class="line-modified">328         num_coengs = 2; /* Done. */</span>
329       }
330     }
<a name="31" id="anc31"></a><span class="line-added">331 </span>
<span class="line-added">332     /* Reorder left matra piece. */</span>
<span class="line-added">333     else if (info[i].khmer_category() == OT_VPre)</span>
<span class="line-added">334     {</span>
<span class="line-added">335       /* Move to the start. */</span>
<span class="line-added">336       buffer-&gt;merge_clusters (start, i + 1);</span>
<span class="line-added">337       hb_glyph_info_t t = info[i];</span>
<span class="line-added">338       memmove (&amp;info[start + 1], &amp;info[start], (i - start) * sizeof (info[0]));</span>
<span class="line-added">339       info[start] = t;</span>
<span class="line-added">340     }</span>
341   }
342 }
343 
344 static void
345 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
346                              hb_face_t *face,
347                              hb_buffer_t *buffer,
348                              unsigned int start, unsigned int end)
349 {
350   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
351   switch (syllable_type)
352   {
353     case broken_cluster: /* We already inserted dotted-circles, so just call the consonant_syllable. */
354     case consonant_syllable:
<a name="32" id="anc32"></a><span class="line-modified">355      reorder_consonant_syllable (plan, face, buffer, start, end);</span>
356      break;
357 
358     case non_khmer_cluster:
359       break;
360   }
361 }
362 
363 static inline void
364 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
365                        hb_font_t *font,
366                        hb_buffer_t *buffer)
367 {
368   /* Note: This loop is extra overhead, but should not be measurable. */
369   bool has_broken_syllables = false;
370   unsigned int count = buffer-&gt;len;
371   hb_glyph_info_t *info = buffer-&gt;info;
372   for (unsigned int i = 0; i &lt; count; i++)
373     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
374     {
375       has_broken_syllables = true;
376       break;
377     }
378   if (likely (!has_broken_syllables))
379     return;
380 
381 
382   hb_codepoint_t dottedcircle_glyph;
383   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
384     return;
385 
386   hb_glyph_info_t dottedcircle = {0};
387   dottedcircle.codepoint = 0x25CCu;
388   set_khmer_properties (dottedcircle);
389   dottedcircle.codepoint = dottedcircle_glyph;
390 
391   buffer-&gt;clear_output ();
392 
393   buffer-&gt;idx = 0;
394   unsigned int last_syllable = 0;
395   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
396   {
397     unsigned int syllable = buffer-&gt;cur().syllable();
398     syllable_type_t syllable_type = (syllable_type_t) (syllable &amp; 0x0F);
399     if (unlikely (last_syllable != syllable &amp;&amp; syllable_type == broken_cluster))
400     {
401       last_syllable = syllable;
402 
403       hb_glyph_info_t ginfo = dottedcircle;
404       ginfo.cluster = buffer-&gt;cur().cluster;
405       ginfo.mask = buffer-&gt;cur().mask;
406       ginfo.syllable() = buffer-&gt;cur().syllable();
407       /* TODO Set glyph_props? */
408 
409       /* Insert dottedcircle after possible Repha. */
410       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
411              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
412              buffer-&gt;cur().khmer_category() == OT_Repha)
413         buffer-&gt;next_glyph ();
414 
415       buffer-&gt;output_info (ginfo);
416     }
417     else
418       buffer-&gt;next_glyph ();
419   }
<a name="33" id="anc33"></a>
420   buffer-&gt;swap_buffers ();
421 }
422 
423 static void
<a name="34" id="anc34"></a><span class="line-modified">424 reorder (const hb_ot_shape_plan_t *plan,</span>
<span class="line-modified">425          hb_font_t *font,</span>
<span class="line-modified">426          hb_buffer_t *buffer)</span>
427 {
428   insert_dotted_circles (plan, font, buffer);
429 
430   foreach_syllable (buffer, start, end)
431     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
<a name="35" id="anc35"></a>













































































































































































































































432 
433   HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);
<a name="36" id="anc36"></a>
434 }
435 
<a name="37" id="anc37"></a>
436 static void
437 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
438                  hb_font_t *font HB_UNUSED,
439                  hb_buffer_t *buffer)
440 {
441   hb_glyph_info_t *info = buffer-&gt;info;
442   unsigned int count = buffer-&gt;len;
443   for (unsigned int i = 0; i &lt; count; i++)
444     info[i].syllable() = 0;
445 }
446 
447 
448 static bool
449 decompose_khmer (const hb_ot_shape_normalize_context_t *c,
450                  hb_codepoint_t  ab,
451                  hb_codepoint_t *a,
452                  hb_codepoint_t *b)
453 {
454   switch (ab)
455   {
456     /*
457      * Decompose split matras that don&#39;t have Unicode decompositions.
458      */
459 
460     /* Khmer */
461     case 0x17BEu  : *a = 0x17C1u; *b= 0x17BEu; return true;
462     case 0x17BFu  : *a = 0x17C1u; *b= 0x17BFu; return true;
463     case 0x17C0u  : *a = 0x17C1u; *b= 0x17C0u; return true;
464     case 0x17C4u  : *a = 0x17C1u; *b= 0x17C4u; return true;
465     case 0x17C5u  : *a = 0x17C1u; *b= 0x17C5u; return true;
466   }
467 
468   return (bool) c-&gt;unicode-&gt;decompose (ab, a, b);
469 }
470 
471 static bool
472 compose_khmer (const hb_ot_shape_normalize_context_t *c,
473                hb_codepoint_t  a,
474                hb_codepoint_t  b,
475                hb_codepoint_t *ab)
476 {
477   /* Avoid recomposing split matras. */
478   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
479     return false;
480 
481   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
482 }
483 
484 
485 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =
486 {
487   collect_features_khmer,
488   override_features_khmer,
489   data_create_khmer,
490   data_destroy_khmer,
491   nullptr, /* preprocess_text */
492   nullptr, /* postprocess_glyphs */
493   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
494   decompose_khmer,
495   compose_khmer,
496   setup_masks_khmer,
<a name="38" id="anc38"></a><span class="line-modified">497   HB_TAG_NONE, /* gpos_tag */</span>
498   nullptr, /* reorder_marks */
499   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
500   false, /* fallback_position */
501 };
<a name="39" id="anc39"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="39" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-deprecated.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_DSALGS_HH
 28 #define HB_DSALGS_HH
 29 
<span class="line-modified"> 30 #include &quot;hb-private.hh&quot;</span>

 31 
 32 









































































































































































































































































































































 33 static inline void *
 34 hb_bsearch_r (const void *key, const void *base,
 35               size_t nmemb, size_t size,
 36               int (*compar)(const void *_key, const void *_item, void *_arg),
 37               void *arg)
 38 {
 39   int min = 0, max = (int) nmemb - 1;
 40   while (min &lt;= max)
 41   {
<span class="line-modified"> 42     int mid = (min + max) / 2;</span>
 43     const void *p = (const void *) (((const char *) base) + (mid * size));
 44     int c = compar (key, p, arg);
 45     if (c &lt; 0)
 46       max = mid - 1;
 47     else if (c &gt; 0)
 48       min = mid + 1;
 49     else
 50       return (void *) p;
 51   }
 52   return nullptr;
 53 }
 54 
 55 
<span class="line-modified"> 56 </span>
<span class="line-modified"> 57 /* From https://github.com/noporpoise/sort_r */</span>




 58 
 59 /* Isaac Turner 29 April 2014 Public Domain */
 60 
 61 /*
 62 
 63 hb_sort_r function to be exported.
 64 
 65 Parameters:
 66   base is the array to be sorted
 67   nel is the number of elements in the array
 68   width is the size in bytes of each element of the array
 69   compar is the comparison function
 70   arg is a pointer to be passed to the comparison function
 71 
 72 void hb_sort_r(void *base, size_t nel, size_t width,
 73                int (*compar)(const void *_a, const void *_b, void *_arg),
 74                void *arg);
 75 */
 76 
 77 
</pre>
<hr />
<pre>
 93 /* Note: quicksort is not stable, equivalent values may be swapped */
 94 static inline void sort_r_simple(void *base, size_t nel, size_t w,
 95                                  int (*compar)(const void *_a, const void *_b,
 96                                                void *_arg),
 97                                  void *arg)
 98 {
 99   char *b = (char *)base, *end = b + nel*w;
100   if(nel &lt; 7) {
101     /* Insertion sort for arbitrarily small inputs */
102     char *pi, *pj;
103     for(pi = b+w; pi &lt; end; pi += w) {
104       for(pj = pi; pj &gt; b &amp;&amp; sort_r_cmpswap(pj-w,pj,w,compar,arg); pj -= w) {}
105     }
106   }
107   else
108   {
109     /* nel &gt; 6; Quicksort */
110 
111     /* Use median of first, middle and last items as pivot */
112     char *x, *y, *xend, ch;
<span class="line-modified">113     char *pl, *pr;</span>
114     char *last = b+w*(nel-1), *tmp;
115     char *l[3];
116     l[0] = b;
117     l[1] = b+w*(nel/2);
118     l[2] = last;
119 
120     if(compar(l[0],l[1],arg) &gt; 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }
121     if(compar(l[1],l[2],arg) &gt; 0) {
122       tmp=l[1]; l[1]=l[2]; l[2]=tmp; /* swap(l[1],l[2]) */
123       if(compar(l[0],l[1],arg) &gt; 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }
124     }
125 
126     /* swap l[id], l[2] to put pivot as last element */
127     for(x = l[1], y = last, xend = x+w; x&lt;xend; x++, y++) {
128       ch = *x; *x = *y; *y = ch;
129     }
130 
131     pl = b;
132     pr = last;
133 
134     while(pl &lt; pr) {
<span class="line-modified">135       for(; pl &lt; pr; pl += w) {</span>

136         if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
137           pr -= w; /* pivot now at pl */
138           break;
139         }
140       }
<span class="line-modified">141       for(; pl &lt; pr; pr -= w) {</span>

142         if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
143           pl += w; /* pivot now at pr */
144           break;
145         }
146       }
147     }
148 
149     sort_r_simple(b, (pl-b)/w, w, compar, arg);
150     sort_r_simple(pl+w, (end-(pl+w))/w, w, compar, arg);
151   }
152 }
153 
154 static inline void hb_sort_r(void *base, size_t nel, size_t width,
155                              int (*compar)(const void *_a, const void *_b, void *_arg),
156                              void *arg)
157 {
158     sort_r_simple(base, nel, width, compar, arg);
159 }
160 







































































































































161 #endif /* HB_DSALGS_HH */
</pre>
</td>
<td>
<hr />
<pre>
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_DSALGS_HH
 28 #define HB_DSALGS_HH
 29 
<span class="line-modified"> 30 #include &quot;hb.hh&quot;</span>
<span class="line-added"> 31 #include &quot;hb-null.hh&quot;</span>
 32 
 33 
<span class="line-added"> 34 /* Void! For when we need a expression-type of void. */</span>
<span class="line-added"> 35 typedef const struct _hb_void_t *hb_void_t;</span>
<span class="line-added"> 36 #define HB_VOID ((const _hb_void_t *) nullptr)</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38 </span>
<span class="line-added"> 39 /*</span>
<span class="line-added"> 40  * Bithacks.</span>
<span class="line-added"> 41  */</span>
<span class="line-added"> 42 </span>
<span class="line-added"> 43 /* Return the number of 1 bits in v. */</span>
<span class="line-added"> 44 template &lt;typename T&gt;</span>
<span class="line-added"> 45 static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added"> 46 hb_popcount (T v)</span>
<span class="line-added"> 47 {</span>
<span class="line-added"> 48 #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added"> 49   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added"> 50     return __builtin_popcount (v);</span>
<span class="line-added"> 51 </span>
<span class="line-added"> 52   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added"> 53     return __builtin_popcountl (v);</span>
<span class="line-added"> 54 </span>
<span class="line-added"> 55   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added"> 56     return __builtin_popcountll (v);</span>
<span class="line-added"> 57 #endif</span>
<span class="line-added"> 58 </span>
<span class="line-added"> 59   if (sizeof (T) &lt;= 4)</span>
<span class="line-added"> 60   {</span>
<span class="line-added"> 61     /* &quot;HACKMEM 169&quot; */</span>
<span class="line-added"> 62     uint32_t y;</span>
<span class="line-added"> 63     y = (v &gt;&gt; 1) &amp;033333333333;</span>
<span class="line-added"> 64     y = v - y - ((y &gt;&gt;1) &amp; 033333333333);</span>
<span class="line-added"> 65     return (((y + (y &gt;&gt; 3)) &amp; 030707070707) % 077);</span>
<span class="line-added"> 66   }</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68   if (sizeof (T) == 8)</span>
<span class="line-added"> 69   {</span>
<span class="line-added"> 70     unsigned int shift = 32;</span>
<span class="line-added"> 71     return hb_popcount&lt;uint32_t&gt; ((uint32_t) v) + hb_popcount ((uint32_t) (v &gt;&gt; shift));</span>
<span class="line-added"> 72   }</span>
<span class="line-added"> 73 </span>
<span class="line-added"> 74   if (sizeof (T) == 16)</span>
<span class="line-added"> 75   {</span>
<span class="line-added"> 76     unsigned int shift = 64;</span>
<span class="line-added"> 77     return hb_popcount&lt;uint64_t&gt; ((uint64_t) v) + hb_popcount ((uint64_t) (v &gt;&gt; shift));</span>
<span class="line-added"> 78   }</span>
<span class="line-added"> 79 </span>
<span class="line-added"> 80   assert (0);</span>
<span class="line-added"> 81   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added"> 82 }</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 /* Returns the number of bits needed to store number */</span>
<span class="line-added"> 85 template &lt;typename T&gt;</span>
<span class="line-added"> 86 static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added"> 87 hb_bit_storage (T v)</span>
<span class="line-added"> 88 {</span>
<span class="line-added"> 89   if (unlikely (!v)) return 0;</span>
<span class="line-added"> 90 </span>
<span class="line-added"> 91 #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added"> 92   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added"> 93     return sizeof (unsigned int) * 8 - __builtin_clz (v);</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added"> 96     return sizeof (unsigned long) * 8 - __builtin_clzl (v);</span>
<span class="line-added"> 97 </span>
<span class="line-added"> 98   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added"> 99     return sizeof (unsigned long long) * 8 - __builtin_clzll (v);</span>
<span class="line-added">100 #endif</span>
<span class="line-added">101 </span>
<span class="line-added">102 #if (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1500) || defined(__MINGW32__)</span>
<span class="line-added">103   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">104   {</span>
<span class="line-added">105     unsigned long where;</span>
<span class="line-added">106     _BitScanReverse (&amp;where, v);</span>
<span class="line-added">107     return 1 + where;</span>
<span class="line-added">108   }</span>
<span class="line-added">109 # if defined(_WIN64)</span>
<span class="line-added">110   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">111   {</span>
<span class="line-added">112     unsigned long where;</span>
<span class="line-added">113     _BitScanReverse64 (&amp;where, v);</span>
<span class="line-added">114     return 1 + where;</span>
<span class="line-added">115   }</span>
<span class="line-added">116 # endif</span>
<span class="line-added">117 #endif</span>
<span class="line-added">118 </span>
<span class="line-added">119   if (sizeof (T) &lt;= 4)</span>
<span class="line-added">120   {</span>
<span class="line-added">121     /* &quot;bithacks&quot; */</span>
<span class="line-added">122     const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};</span>
<span class="line-added">123     const unsigned int S[] = {1, 2, 4, 8, 16};</span>
<span class="line-added">124     unsigned int r = 0;</span>
<span class="line-added">125     for (int i = 4; i &gt;= 0; i--)</span>
<span class="line-added">126       if (v &amp; b[i])</span>
<span class="line-added">127       {</span>
<span class="line-added">128         v &gt;&gt;= S[i];</span>
<span class="line-added">129         r |= S[i];</span>
<span class="line-added">130       }</span>
<span class="line-added">131     return r + 1;</span>
<span class="line-added">132   }</span>
<span class="line-added">133   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">134   {</span>
<span class="line-added">135     /* &quot;bithacks&quot; */</span>
<span class="line-added">136     const uint64_t b[] = {0x2ULL, 0xCULL, 0xF0ULL, 0xFF00ULL, 0xFFFF0000ULL, 0xFFFFFFFF00000000ULL};</span>
<span class="line-added">137     const unsigned int S[] = {1, 2, 4, 8, 16, 32};</span>
<span class="line-added">138     unsigned int r = 0;</span>
<span class="line-added">139     for (int i = 5; i &gt;= 0; i--)</span>
<span class="line-added">140       if (v &amp; b[i])</span>
<span class="line-added">141       {</span>
<span class="line-added">142         v &gt;&gt;= S[i];</span>
<span class="line-added">143         r |= S[i];</span>
<span class="line-added">144       }</span>
<span class="line-added">145     return r + 1;</span>
<span class="line-added">146   }</span>
<span class="line-added">147   if (sizeof (T) == 16)</span>
<span class="line-added">148   {</span>
<span class="line-added">149     unsigned int shift = 64;</span>
<span class="line-added">150     return (v &gt;&gt; shift) ? hb_bit_storage&lt;uint64_t&gt; ((uint64_t) (v &gt;&gt; shift)) + shift :</span>
<span class="line-added">151                           hb_bit_storage&lt;uint64_t&gt; ((uint64_t) v);</span>
<span class="line-added">152   }</span>
<span class="line-added">153 </span>
<span class="line-added">154   assert (0);</span>
<span class="line-added">155   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added">156 }</span>
<span class="line-added">157 </span>
<span class="line-added">158 /* Returns the number of zero bits in the least significant side of v */</span>
<span class="line-added">159 template &lt;typename T&gt;</span>
<span class="line-added">160 static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added">161 hb_ctz (T v)</span>
<span class="line-added">162 {</span>
<span class="line-added">163   if (unlikely (!v)) return 0;</span>
<span class="line-added">164 </span>
<span class="line-added">165 #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added">166   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">167     return __builtin_ctz (v);</span>
<span class="line-added">168 </span>
<span class="line-added">169   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added">170     return __builtin_ctzl (v);</span>
<span class="line-added">171 </span>
<span class="line-added">172   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added">173     return __builtin_ctzll (v);</span>
<span class="line-added">174 #endif</span>
<span class="line-added">175 </span>
<span class="line-added">176 #if (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1500) || defined(__MINGW32__)</span>
<span class="line-added">177   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">178   {</span>
<span class="line-added">179     unsigned long where;</span>
<span class="line-added">180     _BitScanForward (&amp;where, v);</span>
<span class="line-added">181     return where;</span>
<span class="line-added">182   }</span>
<span class="line-added">183 # if defined(_WIN64)</span>
<span class="line-added">184   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">185   {</span>
<span class="line-added">186     unsigned long where;</span>
<span class="line-added">187     _BitScanForward64 (&amp;where, v);</span>
<span class="line-added">188     return where;</span>
<span class="line-added">189   }</span>
<span class="line-added">190 # endif</span>
<span class="line-added">191 #endif</span>
<span class="line-added">192 </span>
<span class="line-added">193   if (sizeof (T) &lt;= 4)</span>
<span class="line-added">194   {</span>
<span class="line-added">195     /* &quot;bithacks&quot; */</span>
<span class="line-added">196     unsigned int c = 32;</span>
<span class="line-added">197     v &amp;= - (int32_t) v;</span>
<span class="line-added">198     if (v) c--;</span>
<span class="line-added">199     if (v &amp; 0x0000FFFF) c -= 16;</span>
<span class="line-added">200     if (v &amp; 0x00FF00FF) c -= 8;</span>
<span class="line-added">201     if (v &amp; 0x0F0F0F0F) c -= 4;</span>
<span class="line-added">202     if (v &amp; 0x33333333) c -= 2;</span>
<span class="line-added">203     if (v &amp; 0x55555555) c -= 1;</span>
<span class="line-added">204     return c;</span>
<span class="line-added">205   }</span>
<span class="line-added">206   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">207   {</span>
<span class="line-added">208     /* &quot;bithacks&quot; */</span>
<span class="line-added">209     unsigned int c = 64;</span>
<span class="line-added">210     v &amp;= - (int64_t) (v);</span>
<span class="line-added">211     if (v) c--;</span>
<span class="line-added">212     if (v &amp; 0x00000000FFFFFFFFULL) c -= 32;</span>
<span class="line-added">213     if (v &amp; 0x0000FFFF0000FFFFULL) c -= 16;</span>
<span class="line-added">214     if (v &amp; 0x00FF00FF00FF00FFULL) c -= 8;</span>
<span class="line-added">215     if (v &amp; 0x0F0F0F0F0F0F0F0FULL) c -= 4;</span>
<span class="line-added">216     if (v &amp; 0x3333333333333333ULL) c -= 2;</span>
<span class="line-added">217     if (v &amp; 0x5555555555555555ULL) c -= 1;</span>
<span class="line-added">218     return c;</span>
<span class="line-added">219   }</span>
<span class="line-added">220   if (sizeof (T) == 16)</span>
<span class="line-added">221   {</span>
<span class="line-added">222     unsigned int shift = 64;</span>
<span class="line-added">223     return (uint64_t) v ? hb_bit_storage&lt;uint64_t&gt; ((uint64_t) v) :</span>
<span class="line-added">224                           hb_bit_storage&lt;uint64_t&gt; ((uint64_t) (v &gt;&gt; shift)) + shift;</span>
<span class="line-added">225   }</span>
<span class="line-added">226 </span>
<span class="line-added">227   assert (0);</span>
<span class="line-added">228   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added">229 }</span>
<span class="line-added">230 </span>
<span class="line-added">231 </span>
<span class="line-added">232 /*</span>
<span class="line-added">233  * Tiny stuff.</span>
<span class="line-added">234  */</span>
<span class="line-added">235 </span>
<span class="line-added">236 template &lt;typename T&gt;</span>
<span class="line-added">237 static inline T* hb_addressof (T&amp; arg)</span>
<span class="line-added">238 {</span>
<span class="line-added">239 #pragma GCC diagnostic push</span>
<span class="line-added">240 #pragma GCC diagnostic ignored &quot;-Wcast-align&quot;</span>
<span class="line-added">241   /* https://en.cppreference.com/w/cpp/memory/addressof */</span>
<span class="line-added">242   return reinterpret_cast&lt;T*&gt;(</span>
<span class="line-added">243            &amp;const_cast&lt;char&amp;&gt;(</span>
<span class="line-added">244               reinterpret_cast&lt;const volatile char&amp;&gt;(arg)));</span>
<span class="line-added">245 #pragma GCC diagnostic pop</span>
<span class="line-added">246 }</span>
<span class="line-added">247 </span>
<span class="line-added">248 /* ASCII tag/character handling */</span>
<span class="line-added">249 static inline bool ISALPHA (unsigned char c)</span>
<span class="line-added">250 { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;); }</span>
<span class="line-added">251 static inline bool ISALNUM (unsigned char c)</span>
<span class="line-added">252 { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;); }</span>
<span class="line-added">253 static inline bool ISSPACE (unsigned char c)</span>
<span class="line-added">254 { return c == &#39; &#39; || c ==&#39;\f&#39;|| c ==&#39;\n&#39;|| c ==&#39;\r&#39;|| c ==&#39;\t&#39;|| c ==&#39;\v&#39;; }</span>
<span class="line-added">255 static inline unsigned char TOUPPER (unsigned char c)</span>
<span class="line-added">256 { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ? c - &#39;a&#39; + &#39;A&#39; : c; }</span>
<span class="line-added">257 static inline unsigned char TOLOWER (unsigned char c)</span>
<span class="line-added">258 { return (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? c - &#39;A&#39; + &#39;a&#39; : c; }</span>
<span class="line-added">259 </span>
<span class="line-added">260 #undef MIN</span>
<span class="line-added">261 template &lt;typename Type&gt;</span>
<span class="line-added">262 static inline Type MIN (const Type &amp;a, const Type &amp;b) { return a &lt; b ? a : b; }</span>
<span class="line-added">263 </span>
<span class="line-added">264 #undef MAX</span>
<span class="line-added">265 template &lt;typename Type&gt;</span>
<span class="line-added">266 static inline Type MAX (const Type &amp;a, const Type &amp;b) { return a &gt; b ? a : b; }</span>
<span class="line-added">267 </span>
<span class="line-added">268 static inline unsigned int DIV_CEIL (const unsigned int a, unsigned int b)</span>
<span class="line-added">269 { return (a + (b - 1)) / b; }</span>
<span class="line-added">270 </span>
<span class="line-added">271 </span>
<span class="line-added">272 #undef  ARRAY_LENGTH</span>
<span class="line-added">273 template &lt;typename Type, unsigned int n&gt;</span>
<span class="line-added">274 static inline unsigned int ARRAY_LENGTH (const Type (&amp;)[n]) { return n; }</span>
<span class="line-added">275 /* A const version, but does not detect erratically being called on pointers. */</span>
<span class="line-added">276 #define ARRAY_LENGTH_CONST(__array) ((signed int) (sizeof (__array) / sizeof (__array[0])))</span>
<span class="line-added">277 </span>
<span class="line-added">278 </span>
<span class="line-added">279 static inline int</span>
<span class="line-added">280 hb_memcmp (const void *a, const void *b, unsigned int len)</span>
<span class="line-added">281 {</span>
<span class="line-added">282   /* It&#39;s illegal to pass NULL to memcmp(), even if len is zero.</span>
<span class="line-added">283    * So, wrap it.</span>
<span class="line-added">284    * https://sourceware.org/bugzilla/show_bug.cgi?id=23878 */</span>
<span class="line-added">285   if (!len) return 0;</span>
<span class="line-added">286   return memcmp (a, b, len);</span>
<span class="line-added">287 }</span>
<span class="line-added">288 </span>
<span class="line-added">289 static inline bool</span>
<span class="line-added">290 hb_unsigned_mul_overflows (unsigned int count, unsigned int size)</span>
<span class="line-added">291 {</span>
<span class="line-added">292   return (size &gt; 0) &amp;&amp; (count &gt;= ((unsigned int) -1) / size);</span>
<span class="line-added">293 }</span>
<span class="line-added">294 </span>
<span class="line-added">295 static inline unsigned int</span>
<span class="line-added">296 hb_ceil_to_4 (unsigned int v)</span>
<span class="line-added">297 {</span>
<span class="line-added">298   return ((v - 1) | 3) + 1;</span>
<span class="line-added">299 }</span>
<span class="line-added">300 </span>
<span class="line-added">301 template &lt;typename T&gt; struct hb_is_signed;</span>
<span class="line-added">302 /* https://github.com/harfbuzz/harfbuzz/issues/1535 */</span>
<span class="line-added">303 template &lt;&gt; struct hb_is_signed&lt;int8_t&gt; { enum { value = true }; };</span>
<span class="line-added">304 template &lt;&gt; struct hb_is_signed&lt;int16_t&gt; { enum { value = true }; };</span>
<span class="line-added">305 template &lt;&gt; struct hb_is_signed&lt;int32_t&gt; { enum { value = true }; };</span>
<span class="line-added">306 template &lt;&gt; struct hb_is_signed&lt;int64_t&gt; { enum { value = true }; };</span>
<span class="line-added">307 template &lt;&gt; struct hb_is_signed&lt;uint8_t&gt; { enum { value = false }; };</span>
<span class="line-added">308 template &lt;&gt; struct hb_is_signed&lt;uint16_t&gt; { enum { value = false }; };</span>
<span class="line-added">309 template &lt;&gt; struct hb_is_signed&lt;uint32_t&gt; { enum { value = false }; };</span>
<span class="line-added">310 template &lt;&gt; struct hb_is_signed&lt;uint64_t&gt; { enum { value = false }; };</span>
<span class="line-added">311 </span>
<span class="line-added">312 template &lt;typename T&gt; static inline bool</span>
<span class="line-added">313 hb_in_range (T u, T lo, T hi)</span>
<span class="line-added">314 {</span>
<span class="line-added">315   /* The sizeof() is here to force template instantiation.</span>
<span class="line-added">316    * I&#39;m sure there are better ways to do this but can&#39;t think of</span>
<span class="line-added">317    * one right now.  Declaring a variable won&#39;t work as HB_UNUSED</span>
<span class="line-added">318    * is unusable on some platforms and unused types are less likely</span>
<span class="line-added">319    * to generate a warning than unused variables. */</span>
<span class="line-added">320   static_assert (!hb_is_signed&lt;T&gt;::value, &quot;&quot;);</span>
<span class="line-added">321 </span>
<span class="line-added">322   /* The casts below are important as if T is smaller than int,</span>
<span class="line-added">323    * the subtract results will become a signed int! */</span>
<span class="line-added">324   return (T)(u - lo) &lt;= (T)(hi - lo);</span>
<span class="line-added">325 }</span>
<span class="line-added">326 template &lt;typename T&gt; static inline bool</span>
<span class="line-added">327 hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2)</span>
<span class="line-added">328 {</span>
<span class="line-added">329   return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2);</span>
<span class="line-added">330 }</span>
<span class="line-added">331 template &lt;typename T&gt; static inline bool</span>
<span class="line-added">332 hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3)</span>
<span class="line-added">333 {</span>
<span class="line-added">334   return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3);</span>
<span class="line-added">335 }</span>
<span class="line-added">336 </span>
<span class="line-added">337 </span>
<span class="line-added">338 /*</span>
<span class="line-added">339  * Sort and search.</span>
<span class="line-added">340  */</span>
<span class="line-added">341 </span>
<span class="line-added">342 static inline void *</span>
<span class="line-added">343 hb_bsearch (const void *key, const void *base,</span>
<span class="line-added">344             size_t nmemb, size_t size,</span>
<span class="line-added">345             int (*compar)(const void *_key, const void *_item))</span>
<span class="line-added">346 {</span>
<span class="line-added">347   int min = 0, max = (int) nmemb - 1;</span>
<span class="line-added">348   while (min &lt;= max)</span>
<span class="line-added">349   {</span>
<span class="line-added">350     int mid = (min + max) / 2;</span>
<span class="line-added">351     const void *p = (const void *) (((const char *) base) + (mid * size));</span>
<span class="line-added">352     int c = compar (key, p);</span>
<span class="line-added">353     if (c &lt; 0)</span>
<span class="line-added">354       max = mid - 1;</span>
<span class="line-added">355     else if (c &gt; 0)</span>
<span class="line-added">356       min = mid + 1;</span>
<span class="line-added">357     else</span>
<span class="line-added">358       return (void *) p;</span>
<span class="line-added">359   }</span>
<span class="line-added">360   return nullptr;</span>
<span class="line-added">361 }</span>
<span class="line-added">362 </span>
363 static inline void *
364 hb_bsearch_r (const void *key, const void *base,
365               size_t nmemb, size_t size,
366               int (*compar)(const void *_key, const void *_item, void *_arg),
367               void *arg)
368 {
369   int min = 0, max = (int) nmemb - 1;
370   while (min &lt;= max)
371   {
<span class="line-modified">372     int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
373     const void *p = (const void *) (((const char *) base) + (mid * size));
374     int c = compar (key, p, arg);
375     if (c &lt; 0)
376       max = mid - 1;
377     else if (c &gt; 0)
378       min = mid + 1;
379     else
380       return (void *) p;
381   }
382   return nullptr;
383 }
384 
385 
<span class="line-modified">386 /* From https://github.com/noporpoise/sort_r</span>
<span class="line-modified">387  * With following modifications:</span>
<span class="line-added">388  *</span>
<span class="line-added">389  * 10 November 2018:</span>
<span class="line-added">390  * https://github.com/noporpoise/sort_r/issues/7</span>
<span class="line-added">391  */</span>
392 
393 /* Isaac Turner 29 April 2014 Public Domain */
394 
395 /*
396 
397 hb_sort_r function to be exported.
398 
399 Parameters:
400   base is the array to be sorted
401   nel is the number of elements in the array
402   width is the size in bytes of each element of the array
403   compar is the comparison function
404   arg is a pointer to be passed to the comparison function
405 
406 void hb_sort_r(void *base, size_t nel, size_t width,
407                int (*compar)(const void *_a, const void *_b, void *_arg),
408                void *arg);
409 */
410 
411 
</pre>
<hr />
<pre>
427 /* Note: quicksort is not stable, equivalent values may be swapped */
428 static inline void sort_r_simple(void *base, size_t nel, size_t w,
429                                  int (*compar)(const void *_a, const void *_b,
430                                                void *_arg),
431                                  void *arg)
432 {
433   char *b = (char *)base, *end = b + nel*w;
434   if(nel &lt; 7) {
435     /* Insertion sort for arbitrarily small inputs */
436     char *pi, *pj;
437     for(pi = b+w; pi &lt; end; pi += w) {
438       for(pj = pi; pj &gt; b &amp;&amp; sort_r_cmpswap(pj-w,pj,w,compar,arg); pj -= w) {}
439     }
440   }
441   else
442   {
443     /* nel &gt; 6; Quicksort */
444 
445     /* Use median of first, middle and last items as pivot */
446     char *x, *y, *xend, ch;
<span class="line-modified">447     char *pl, *pm, *pr;</span>
448     char *last = b+w*(nel-1), *tmp;
449     char *l[3];
450     l[0] = b;
451     l[1] = b+w*(nel/2);
452     l[2] = last;
453 
454     if(compar(l[0],l[1],arg) &gt; 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }
455     if(compar(l[1],l[2],arg) &gt; 0) {
456       tmp=l[1]; l[1]=l[2]; l[2]=tmp; /* swap(l[1],l[2]) */
457       if(compar(l[0],l[1],arg) &gt; 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }
458     }
459 
460     /* swap l[id], l[2] to put pivot as last element */
461     for(x = l[1], y = last, xend = x+w; x&lt;xend; x++, y++) {
462       ch = *x; *x = *y; *y = ch;
463     }
464 
465     pl = b;
466     pr = last;
467 
468     while(pl &lt; pr) {
<span class="line-modified">469       pm = pl+((pr-pl+1)&gt;&gt;1);</span>
<span class="line-added">470       for(; pl &lt; pm; pl += w) {</span>
471         if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
472           pr -= w; /* pivot now at pl */
473           break;
474         }
475       }
<span class="line-modified">476       pm = pl+((pr-pl)&gt;&gt;1);</span>
<span class="line-added">477       for(; pm &lt; pr; pr -= w) {</span>
478         if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
479           pl += w; /* pivot now at pr */
480           break;
481         }
482       }
483     }
484 
485     sort_r_simple(b, (pl-b)/w, w, compar, arg);
486     sort_r_simple(pl+w, (end-(pl+w))/w, w, compar, arg);
487   }
488 }
489 
490 static inline void hb_sort_r(void *base, size_t nel, size_t width,
491                              int (*compar)(const void *_a, const void *_b, void *_arg),
492                              void *arg)
493 {
494     sort_r_simple(base, nel, width, compar, arg);
495 }
496 
<span class="line-added">497 </span>
<span class="line-added">498 template &lt;typename T, typename T2&gt; static inline void</span>
<span class="line-added">499 hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *), T2 *array2)</span>
<span class="line-added">500 {</span>
<span class="line-added">501   for (unsigned int i = 1; i &lt; len; i++)</span>
<span class="line-added">502   {</span>
<span class="line-added">503     unsigned int j = i;</span>
<span class="line-added">504     while (j &amp;&amp; compar (&amp;array[j - 1], &amp;array[i]) &gt; 0)</span>
<span class="line-added">505       j--;</span>
<span class="line-added">506     if (i == j)</span>
<span class="line-added">507       continue;</span>
<span class="line-added">508     /* Move item i to occupy place for item j, shift what&#39;s in between. */</span>
<span class="line-added">509     {</span>
<span class="line-added">510       T t = array[i];</span>
<span class="line-added">511       memmove (&amp;array[j + 1], &amp;array[j], (i - j) * sizeof (T));</span>
<span class="line-added">512       array[j] = t;</span>
<span class="line-added">513     }</span>
<span class="line-added">514     if (array2)</span>
<span class="line-added">515     {</span>
<span class="line-added">516       T2 t = array2[i];</span>
<span class="line-added">517       memmove (&amp;array2[j + 1], &amp;array2[j], (i - j) * sizeof (T2));</span>
<span class="line-added">518       array2[j] = t;</span>
<span class="line-added">519     }</span>
<span class="line-added">520   }</span>
<span class="line-added">521 }</span>
<span class="line-added">522 </span>
<span class="line-added">523 template &lt;typename T&gt; static inline void</span>
<span class="line-added">524 hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))</span>
<span class="line-added">525 {</span>
<span class="line-added">526   hb_stable_sort (array, len, compar, (int *) nullptr);</span>
<span class="line-added">527 }</span>
<span class="line-added">528 </span>
<span class="line-added">529 static inline hb_bool_t</span>
<span class="line-added">530 hb_codepoint_parse (const char *s, unsigned int len, int base, hb_codepoint_t *out)</span>
<span class="line-added">531 {</span>
<span class="line-added">532   /* Pain because we don&#39;t know whether s is nul-terminated. */</span>
<span class="line-added">533   char buf[64];</span>
<span class="line-added">534   len = MIN (ARRAY_LENGTH (buf) - 1, len);</span>
<span class="line-added">535   strncpy (buf, s, len);</span>
<span class="line-added">536   buf[len] = &#39;\0&#39;;</span>
<span class="line-added">537 </span>
<span class="line-added">538   char *end;</span>
<span class="line-added">539   errno = 0;</span>
<span class="line-added">540   unsigned long v = strtoul (buf, &amp;end, base);</span>
<span class="line-added">541   if (errno) return false;</span>
<span class="line-added">542   if (*end) return false;</span>
<span class="line-added">543   *out = v;</span>
<span class="line-added">544   return true;</span>
<span class="line-added">545 }</span>
<span class="line-added">546 </span>
<span class="line-added">547 </span>
<span class="line-added">548 struct HbOpOr</span>
<span class="line-added">549 {</span>
<span class="line-added">550   static constexpr bool passthru_left = true;</span>
<span class="line-added">551   static constexpr bool passthru_right = true;</span>
<span class="line-added">552   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a | b; }</span>
<span class="line-added">553 };</span>
<span class="line-added">554 struct HbOpAnd</span>
<span class="line-added">555 {</span>
<span class="line-added">556   static constexpr bool passthru_left = false;</span>
<span class="line-added">557   static constexpr bool passthru_right = false;</span>
<span class="line-added">558   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a &amp; b; }</span>
<span class="line-added">559 };</span>
<span class="line-added">560 struct HbOpMinus</span>
<span class="line-added">561 {</span>
<span class="line-added">562   static constexpr bool passthru_left = true;</span>
<span class="line-added">563   static constexpr bool passthru_right = false;</span>
<span class="line-added">564   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a &amp; ~b; }</span>
<span class="line-added">565 };</span>
<span class="line-added">566 struct HbOpXor</span>
<span class="line-added">567 {</span>
<span class="line-added">568   static constexpr bool passthru_left = true;</span>
<span class="line-added">569   static constexpr bool passthru_right = true;</span>
<span class="line-added">570   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a ^ b; }</span>
<span class="line-added">571 };</span>
<span class="line-added">572 </span>
<span class="line-added">573 </span>
<span class="line-added">574 /* Compiler-assisted vectorization. */</span>
<span class="line-added">575 </span>
<span class="line-added">576 /* Type behaving similar to vectorized vars defined using __attribute__((vector_size(...))),</span>
<span class="line-added">577  * using vectorized operations if HB_VECTOR_SIZE is set to **bit** numbers (eg 128).</span>
<span class="line-added">578  * Define that to 0 to disable. */</span>
<span class="line-added">579 template &lt;typename elt_t, unsigned int byte_size&gt;</span>
<span class="line-added">580 struct hb_vector_size_t</span>
<span class="line-added">581 {</span>
<span class="line-added">582   elt_t&amp; operator [] (unsigned int i) { return u.v[i]; }</span>
<span class="line-added">583   const elt_t&amp; operator [] (unsigned int i) const { return u.v[i]; }</span>
<span class="line-added">584 </span>
<span class="line-added">585   void clear (unsigned char v = 0) { memset (this, v, sizeof (*this)); }</span>
<span class="line-added">586 </span>
<span class="line-added">587   template &lt;class Op&gt;</span>
<span class="line-added">588   hb_vector_size_t process (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">589   {</span>
<span class="line-added">590     hb_vector_size_t r;</span>
<span class="line-added">591 #if HB_VECTOR_SIZE</span>
<span class="line-added">592     if (HB_VECTOR_SIZE &amp;&amp; 0 == (byte_size * 8) % HB_VECTOR_SIZE)</span>
<span class="line-added">593       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.vec); i++)</span>
<span class="line-added">594         Op::process (r.u.vec[i], u.vec[i], o.u.vec[i]);</span>
<span class="line-added">595     else</span>
<span class="line-added">596 #endif</span>
<span class="line-added">597       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.v); i++)</span>
<span class="line-added">598         Op::process (r.u.v[i], u.v[i], o.u.v[i]);</span>
<span class="line-added">599     return r;</span>
<span class="line-added">600   }</span>
<span class="line-added">601   hb_vector_size_t operator | (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">602   { return process&lt;HbOpOr&gt; (o); }</span>
<span class="line-added">603   hb_vector_size_t operator &amp; (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">604   { return process&lt;HbOpAnd&gt; (o); }</span>
<span class="line-added">605   hb_vector_size_t operator ^ (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">606   { return process&lt;HbOpXor&gt; (o); }</span>
<span class="line-added">607   hb_vector_size_t operator ~ () const</span>
<span class="line-added">608   {</span>
<span class="line-added">609     hb_vector_size_t r;</span>
<span class="line-added">610 #if HB_VECTOR_SIZE &amp;&amp; 0</span>
<span class="line-added">611     if (HB_VECTOR_SIZE &amp;&amp; 0 == (byte_size * 8) % HB_VECTOR_SIZE)</span>
<span class="line-added">612       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.vec); i++)</span>
<span class="line-added">613         r.u.vec[i] = ~u.vec[i];</span>
<span class="line-added">614     else</span>
<span class="line-added">615 #endif</span>
<span class="line-added">616     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.v); i++)</span>
<span class="line-added">617       r.u.v[i] = ~u.v[i];</span>
<span class="line-added">618     return r;</span>
<span class="line-added">619   }</span>
<span class="line-added">620 </span>
<span class="line-added">621   private:</span>
<span class="line-added">622   static_assert (byte_size / sizeof (elt_t) * sizeof (elt_t) == byte_size, &quot;&quot;);</span>
<span class="line-added">623   union {</span>
<span class="line-added">624     elt_t v[byte_size / sizeof (elt_t)];</span>
<span class="line-added">625 #if HB_VECTOR_SIZE</span>
<span class="line-added">626     hb_vector_size_impl_t vec[byte_size / sizeof (hb_vector_size_impl_t)];</span>
<span class="line-added">627 #endif</span>
<span class="line-added">628   } u;</span>
<span class="line-added">629 };</span>
<span class="line-added">630 </span>
<span class="line-added">631 </span>
632 #endif /* HB_DSALGS_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-deprecated.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
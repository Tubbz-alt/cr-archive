<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-private.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2010,2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_SHAPE_COMPLEX_PRIVATE_HH
 28 #define HB_OT_SHAPE_COMPLEX_PRIVATE_HH
 29 
 30 #include &quot;hb-private.hh&quot;
 31 
 32 #include &quot;hb-ot-shape-private.hh&quot;
 33 #include &quot;hb-ot-shape-normalize-private.hh&quot;
 34 
 35 
 36 
 37 /* buffer var allocations, used by complex shapers */
 38 #define complex_var_u8_0()      var2.u8[2]
 39 #define complex_var_u8_1()      var2.u8[3]
 40 
 41 
 42 #define HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS 32
 43 
 44 enum hb_ot_shape_zero_width_marks_type_t {
 45   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
 46   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,
 47   HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE
 48 };
 49 
 50 
 51 /* Master OT shaper list */
 52 #define HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS \
 53   HB_COMPLEX_SHAPER_IMPLEMENT (default) /* should be first */ \
 54   HB_COMPLEX_SHAPER_IMPLEMENT (arabic) \
 55   HB_COMPLEX_SHAPER_IMPLEMENT (hangul) \
 56   HB_COMPLEX_SHAPER_IMPLEMENT (hebrew) \
 57   HB_COMPLEX_SHAPER_IMPLEMENT (indic) \
 58   HB_COMPLEX_SHAPER_IMPLEMENT (khmer) \
 59   HB_COMPLEX_SHAPER_IMPLEMENT (myanmar) \
 60   HB_COMPLEX_SHAPER_IMPLEMENT (myanmar_old) \
 61   HB_COMPLEX_SHAPER_IMPLEMENT (thai) \
 62   HB_COMPLEX_SHAPER_IMPLEMENT (tibetan) \
 63   HB_COMPLEX_SHAPER_IMPLEMENT (use) \
 64   /* ^--- Add new shapers here */
 65 
 66 
 67 struct hb_ot_complex_shaper_t
 68 {
 69   /* collect_features()
 70    * Called during shape_plan().
 71    * Shapers should use plan-&gt;map to add their features and callbacks.
 72    * May be nullptr.
 73    */
 74   void (*collect_features) (hb_ot_shape_planner_t *plan);
 75 
 76   /* override_features()
 77    * Called during shape_plan().
 78    * Shapers should use plan-&gt;map to override features and add callbacks after
 79    * common features are added.
 80    * May be nullptr.
 81    */
 82   void (*override_features) (hb_ot_shape_planner_t *plan);
 83 
 84 
 85   /* data_create()
 86    * Called at the end of shape_plan().
 87    * Whatever shapers return will be accessible through plan-&gt;data later.
 88    * If nullptr is returned, means a plan failure.
 89    */
 90   void *(*data_create) (const hb_ot_shape_plan_t *plan);
 91 
 92   /* data_destroy()
 93    * Called when the shape_plan is being destroyed.
 94    * plan-&gt;data is passed here for destruction.
 95    * If nullptr is returned, means a plan failure.
 96    * May be nullptr.
 97    */
 98   void (*data_destroy) (void *data);
 99 
100 
101   /* preprocess_text()
102    * Called during shape().
103    * Shapers can use to modify text before shaping starts.
104    * May be nullptr.
105    */
106   void (*preprocess_text) (const hb_ot_shape_plan_t *plan,
107                            hb_buffer_t              *buffer,
108                            hb_font_t                *font);
109 
110   /* postprocess_glyphs()
111    * Called during shape().
112    * Shapers can use to modify glyphs after shaping ends.
113    * May be nullptr.
114    */
115   void (*postprocess_glyphs) (const hb_ot_shape_plan_t *plan,
116                               hb_buffer_t              *buffer,
117                               hb_font_t                *font);
118 
119 
120   hb_ot_shape_normalization_mode_t normalization_preference;
121 
122   /* decompose()
123    * Called during shape()&#39;s normalization.
124    * May be nullptr.
125    */
126   bool (*decompose) (const hb_ot_shape_normalize_context_t *c,
127                      hb_codepoint_t  ab,
128                      hb_codepoint_t *a,
129                      hb_codepoint_t *b);
130 
131   /* compose()
132    * Called during shape()&#39;s normalization.
133    * May be nullptr.
134    */
135   bool (*compose) (const hb_ot_shape_normalize_context_t *c,
136                    hb_codepoint_t  a,
137                    hb_codepoint_t  b,
138                    hb_codepoint_t *ab);
139 
140   /* setup_masks()
141    * Called during shape().
142    * Shapers should use map to get feature masks and set on buffer.
143    * Shapers may NOT modify characters.
144    * May be nullptr.
145    */
146   void (*setup_masks) (const hb_ot_shape_plan_t *plan,
147                        hb_buffer_t              *buffer,
148                        hb_font_t                *font);
149 
150   /* disable_otl()
151    * Called during shape().
152    * If set and returns true, GDEF/GSUB/GPOS of the font are ignored
153    * and fallback operations used.
154    * May be nullptr.
155    */
156   bool (*disable_otl) (const hb_ot_shape_plan_t *plan);
157 
158   /* reorder_marks()
159    * Called during shape().
160    * Shapers can use to modify ordering of combining marks.
161    * May be nullptr.
162    */
163   void (*reorder_marks) (const hb_ot_shape_plan_t *plan,
164                          hb_buffer_t              *buffer,
165                          unsigned int              start,
166                          unsigned int              end);
167 
168   hb_ot_shape_zero_width_marks_type_t zero_width_marks;
169 
170   bool fallback_position;
171 };
172 
173 #define HB_COMPLEX_SHAPER_IMPLEMENT(name) extern HB_INTERNAL const hb_ot_complex_shaper_t _hb_ot_complex_shaper_##name;
174 HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS
175 #undef HB_COMPLEX_SHAPER_IMPLEMENT
176 
177 
178 static inline const hb_ot_complex_shaper_t *
179 hb_ot_shape_complex_categorize (const hb_ot_shape_planner_t *planner)
180 {
181   switch ((hb_tag_t) planner-&gt;props.script)
182   {
183     default:
184       return &amp;_hb_ot_complex_shaper_default;
185 
186 
187     /* Unicode-1.1 additions */
188     case HB_SCRIPT_ARABIC:
189 
190     /* Unicode-3.0 additions */
191     case HB_SCRIPT_MONGOLIAN:
192     case HB_SCRIPT_SYRIAC:
193 
194     /* Unicode-5.0 additions */
195     case HB_SCRIPT_NKO:
196     case HB_SCRIPT_PHAGS_PA:
197 
198     /* Unicode-6.0 additions */
199     case HB_SCRIPT_MANDAIC:
200 
201     /* Unicode-7.0 additions */
202     case HB_SCRIPT_MANICHAEAN:
203     case HB_SCRIPT_PSALTER_PAHLAVI:
204 
205     /* Unicode-9.0 additions */
206     case HB_SCRIPT_ADLAM:
207 
208     /* Unicode-11.0 additions */
209     case HB_SCRIPT_HANIFI_ROHINGYA:
210     case HB_SCRIPT_SOGDIAN:
211 
212       /* For Arabic script, use the Arabic shaper even if no OT script tag was found.
213        * This is because we do fallback shaping for Arabic script (and not others).
214        * But note that Arabic shaping is applicable only to horizontal layout; for
215        * vertical text, just use the generic shaper instead. */
216       if ((planner-&gt;map.chosen_script[0] != HB_OT_TAG_DEFAULT_SCRIPT ||
217            planner-&gt;props.script == HB_SCRIPT_ARABIC) &amp;&amp;
218           HB_DIRECTION_IS_HORIZONTAL(planner-&gt;props.direction))
219         return &amp;_hb_ot_complex_shaper_arabic;
220       else
221         return &amp;_hb_ot_complex_shaper_default;
222 
223 
224     /* Unicode-1.1 additions */
225     case HB_SCRIPT_THAI:
226     case HB_SCRIPT_LAO:
227 
228       return &amp;_hb_ot_complex_shaper_thai;
229 
230 
231     /* Unicode-1.1 additions */
232     case HB_SCRIPT_HANGUL:
233 
234       return &amp;_hb_ot_complex_shaper_hangul;
235 
236 
237     /* Unicode-2.0 additions */
238     case HB_SCRIPT_TIBETAN:
239 
240       return &amp;_hb_ot_complex_shaper_tibetan;
241 
242 
243     /* Unicode-1.1 additions */
244     case HB_SCRIPT_HEBREW:
245 
246       return &amp;_hb_ot_complex_shaper_hebrew;
247 
248 
249     /* ^--- Add new shapers here */
250 
251 #if 0
252     /* Unicode-4.1 additions */
253     case HB_SCRIPT_NEW_TAI_LUE:
254 #endif
255 
256     /* Unicode-1.1 additions */
257     case HB_SCRIPT_BENGALI:
258     case HB_SCRIPT_DEVANAGARI:
259     case HB_SCRIPT_GUJARATI:
260     case HB_SCRIPT_GURMUKHI:
261     case HB_SCRIPT_KANNADA:
262     case HB_SCRIPT_MALAYALAM:
263     case HB_SCRIPT_ORIYA:
264     case HB_SCRIPT_TAMIL:
265     case HB_SCRIPT_TELUGU:
266 
267     /* Unicode-3.0 additions */
268     case HB_SCRIPT_SINHALA:
269 
270       /* If the designer designed the font for the &#39;DFLT&#39; script,
271        * (or we ended up arbitrarily pick &#39;latn&#39;), use the default shaper.
272        * Otherwise, use the specific shaper.
273        * Note that for some simple scripts, there may not be *any*
274        * GSUB/GPOS needed, so there may be no scripts found! */
275       if (planner-&gt;map.chosen_script[0] == HB_TAG (&#39;D&#39;,&#39;F&#39;,&#39;L&#39;,&#39;T&#39;) ||
276           planner-&gt;map.chosen_script[0] == HB_TAG (&#39;l&#39;,&#39;a&#39;,&#39;t&#39;,&#39;n&#39;))
277         return &amp;_hb_ot_complex_shaper_default;
278       else
279         return &amp;_hb_ot_complex_shaper_indic;
280 
281     case HB_SCRIPT_KHMER:
282       /* A number of Khmer fonts in the wild don&#39;t have a &#39;pref&#39; feature,
283        * and as such won&#39;t shape properly via the Indic shaper;
284        * however, they typically have &#39;liga&#39; / &#39;clig&#39; features that implement
285        * the necessary &quot;reordering&quot; by means of ligature substitutions.
286        * So we send such pref-less fonts through the generic shaper instead. */
287       if (planner-&gt;map.found_script[0] &amp;&amp;
288           hb_ot_layout_language_find_feature (planner-&gt;face, HB_OT_TAG_GSUB,
289                                               planner-&gt;map.script_index[0],
290                                               planner-&gt;map.language_index[0],
291                                               HB_TAG (&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),
292                                               nullptr))
293         return &amp;_hb_ot_complex_shaper_khmer;
294       else
295         return &amp;_hb_ot_complex_shaper_default;
296 
297     case HB_SCRIPT_MYANMAR:
298       if (planner-&gt;map.chosen_script[0] == HB_TAG (&#39;m&#39;,&#39;y&#39;,&#39;m&#39;,&#39;2&#39;))
299         return &amp;_hb_ot_complex_shaper_myanmar;
300       else if (planner-&gt;map.chosen_script[0] == HB_TAG (&#39;m&#39;,&#39;y&#39;,&#39;m&#39;,&#39;r&#39;))
301         return &amp;_hb_ot_complex_shaper_myanmar_old;
302       else
303         return &amp;_hb_ot_complex_shaper_default;
304 
305 
306     /* Unicode-2.0 additions */
307     //case HB_SCRIPT_TIBETAN:
308 
309     /* Unicode-3.0 additions */
310     //case HB_SCRIPT_MONGOLIAN:
311     //case HB_SCRIPT_SINHALA:
312 
313     /* Unicode-3.2 additions */
314     case HB_SCRIPT_BUHID:
315     case HB_SCRIPT_HANUNOO:
316     case HB_SCRIPT_TAGALOG:
317     case HB_SCRIPT_TAGBANWA:
318 
319     /* Unicode-4.0 additions */
320     case HB_SCRIPT_LIMBU:
321     case HB_SCRIPT_TAI_LE:
322 
323     /* Unicode-4.1 additions */
324     case HB_SCRIPT_BUGINESE:
325     case HB_SCRIPT_KHAROSHTHI:
326     case HB_SCRIPT_SYLOTI_NAGRI:
327     case HB_SCRIPT_TIFINAGH:
328 
329     /* Unicode-5.0 additions */
330     case HB_SCRIPT_BALINESE:
331     //case HB_SCRIPT_NKO:
332     //case HB_SCRIPT_PHAGS_PA:
333 
334     /* Unicode-5.1 additions */
335     case HB_SCRIPT_CHAM:
336     case HB_SCRIPT_KAYAH_LI:
337     case HB_SCRIPT_LEPCHA:
338     case HB_SCRIPT_REJANG:
339     case HB_SCRIPT_SAURASHTRA:
340     case HB_SCRIPT_SUNDANESE:
341 
342     /* Unicode-5.2 additions */
343     case HB_SCRIPT_EGYPTIAN_HIEROGLYPHS:
344     case HB_SCRIPT_JAVANESE:
345     case HB_SCRIPT_KAITHI:
346     case HB_SCRIPT_MEETEI_MAYEK:
347     case HB_SCRIPT_TAI_THAM:
348     case HB_SCRIPT_TAI_VIET:
349 
350     /* Unicode-6.0 additions */
351     case HB_SCRIPT_BATAK:
352     case HB_SCRIPT_BRAHMI:
353     //case HB_SCRIPT_MANDAIC:
354 
355     /* Unicode-6.1 additions */
356     case HB_SCRIPT_CHAKMA:
357     case HB_SCRIPT_SHARADA:
358     case HB_SCRIPT_TAKRI:
359 
360     /* Unicode-7.0 additions */
361     case HB_SCRIPT_DUPLOYAN:
362     case HB_SCRIPT_GRANTHA:
363     case HB_SCRIPT_KHOJKI:
364     case HB_SCRIPT_KHUDAWADI:
365     case HB_SCRIPT_MAHAJANI:
366     //case HB_SCRIPT_MANICHAEAN:
367     case HB_SCRIPT_MODI:
368     case HB_SCRIPT_PAHAWH_HMONG:
369     //case HB_SCRIPT_PSALTER_PAHLAVI:
370     case HB_SCRIPT_SIDDHAM:
371     case HB_SCRIPT_TIRHUTA:
372 
373     /* Unicode-8.0 additions */
374     case HB_SCRIPT_AHOM:
375     //case HB_SCRIPT_MULTANI:
376 
377     /* Unicode-9.0 additions */
378     case HB_SCRIPT_BHAIKSUKI:
379     case HB_SCRIPT_MARCHEN:
380     case HB_SCRIPT_NEWA:
381 
382     /* Unicode-10.0 additions */
383     case HB_SCRIPT_MASARAM_GONDI:
384     case HB_SCRIPT_SOYOMBO:
385     case HB_SCRIPT_ZANABAZAR_SQUARE:
386 
387     /* Unicode-11.0 additions */
388     case HB_SCRIPT_DOGRA:
389     case HB_SCRIPT_GUNJALA_GONDI:
390     case HB_SCRIPT_MAKASAR:
391 
392       /* If the designer designed the font for the &#39;DFLT&#39; script,
393        * (or we ended up arbitrarily pick &#39;latn&#39;), use the default shaper.
394        * Otherwise, use the specific shaper.
395        * Note that for some simple scripts, there may not be *any*
396        * GSUB/GPOS needed, so there may be no scripts found! */
397       if (planner-&gt;map.chosen_script[0] == HB_TAG (&#39;D&#39;,&#39;F&#39;,&#39;L&#39;,&#39;T&#39;) ||
398           planner-&gt;map.chosen_script[0] == HB_TAG (&#39;l&#39;,&#39;a&#39;,&#39;t&#39;,&#39;n&#39;))
399         return &amp;_hb_ot_complex_shaper_default;
400       else
401         return &amp;_hb_ot_complex_shaper_use;
402   }
403 }
404 
405 
406 #endif /* HB_OT_SHAPE_COMPLEX_PRIVATE_HH */
    </pre>
  </body>
</html>
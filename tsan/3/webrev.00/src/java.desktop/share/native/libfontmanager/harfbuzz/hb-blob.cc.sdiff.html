<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../freetypeScaler.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer-deserialize-json.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-blob.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  */
 27 
<span class="line-modified"> 28 /* http://www.oracle.com/technetwork/articles/servers-storage-dev/standardheaderfiles-453865.html */</span>




 29 #ifndef _POSIX_C_SOURCE


 30 #define _POSIX_C_SOURCE 200809L

 31 #endif
 32 
<span class="line-modified"> 33 #include &quot;hb-private.hh&quot;</span>
<span class="line-modified"> 34 #include &quot;hb-debug.hh&quot;</span>
<span class="line-removed"> 35 #include &quot;hb-blob-private.hh&quot;</span>
 36 
 37 #ifdef HAVE_SYS_MMAN_H
 38 #ifdef HAVE_UNISTD_H
 39 #include &lt;unistd.h&gt;
 40 #endif /* HAVE_UNISTD_H */
 41 #include &lt;sys/mman.h&gt;
 42 #endif /* HAVE_SYS_MMAN_H */
 43 
 44 #include &lt;stdio.h&gt;
 45 #include &lt;errno.h&gt;
 46 #include &lt;stdlib.h&gt;
 47 
 48 













 49 /**
 50  * hb_blob_create: (skip)
 51  * @data: Pointer to blob data.
 52  * @length: Length of @data in bytes.
 53  * @mode: Memory mode for @data.
 54  * @user_data: Data parameter to pass to @destroy.
 55  * @destroy: Callback to call when @data is not needed anymore.
 56  *
 57  * Creates a new &quot;blob&quot; object wrapping @data.  The @mode parameter is used
 58  * to negotiate ownership and lifecycle of @data.
 59  *
 60  * Return value: New blob, or the empty blob if something failed or if @length is
 61  * zero.  Destroy with hb_blob_destroy().
 62  *
 63  * Since: 0.9.2
 64  **/
 65 hb_blob_t *
 66 hb_blob_create (const char        *data,
 67                 unsigned int       length,
 68                 hb_memory_mode_t   mode,
</pre>
<hr />
<pre>
113  * blob is always created with %HB_MEMORY_MODE_READONLY, meaning that it
114  * will never modify data in the parent blob.  The parent data is not
115  * expected to be modified, and will result in undefined behavior if it
116  * is.
117  *
118  * Makes @parent immutable.
119  *
120  * Return value: New blob, or the empty blob if something failed or if
121  * @length is zero or @offset is beyond the end of @parent&#39;s data.  Destroy
122  * with hb_blob_destroy().
123  *
124  * Since: 0.9.2
125  **/
126 hb_blob_t *
127 hb_blob_create_sub_blob (hb_blob_t    *parent,
128                          unsigned int  offset,
129                          unsigned int  length)
130 {
131   hb_blob_t *blob;
132 
<span class="line-modified">133   if (!length || offset &gt;= parent-&gt;length)</span>
134     return hb_blob_get_empty ();
135 
136   hb_blob_make_immutable (parent);
137 
138   blob = hb_blob_create (parent-&gt;data + offset,
139                          MIN (length, parent-&gt;length - offset),
140                          HB_MEMORY_MODE_READONLY,
141                          hb_blob_reference (parent),
142                          _hb_blob_destroy);
143 
144   return blob;
145 }
146 
147 /**
148  * hb_blob_copy_writable_or_fail:
149  * @blob: A blob.
150  *
151  * Makes a writable copy of @blob.
152  *
153  * Return value: New blob, or nullptr if allocation failed.
</pre>
<hr />
<pre>
164                          nullptr);
165 
166   if (unlikely (blob == hb_blob_get_empty ()))
167     blob = nullptr;
168 
169   return blob;
170 }
171 
172 /**
173  * hb_blob_get_empty:
174  *
175  * Returns the singleton empty blob.
176  *
177  * See TODO:link object types for more information.
178  *
179  * Return value: (transfer full): the empty blob.
180  *
181  * Since: 0.9.2
182  **/
183 hb_blob_t *
<span class="line-modified">184 hb_blob_get_empty (void)</span>
185 {
<span class="line-modified">186   static const hb_blob_t _hb_blob_nil = {</span>
<span class="line-removed">187     HB_OBJECT_HEADER_STATIC,</span>
<span class="line-removed">188 </span>
<span class="line-removed">189     true, /* immutable */</span>
<span class="line-removed">190 </span>
<span class="line-removed">191     nullptr, /* data */</span>
<span class="line-removed">192     0, /* length */</span>
<span class="line-removed">193     HB_MEMORY_MODE_READONLY, /* mode */</span>
<span class="line-removed">194 </span>
<span class="line-removed">195     nullptr, /* user_data */</span>
<span class="line-removed">196     nullptr  /* destroy */</span>
<span class="line-removed">197   };</span>
<span class="line-removed">198 </span>
<span class="line-removed">199   return const_cast&lt;hb_blob_t *&gt; (&amp;_hb_blob_nil);</span>
200 }
201 
202 /**
203  * hb_blob_reference: (skip)
204  * @blob: a blob.
205  *
206  * Increases the reference count on @blob.
207  *
208  * See TODO:link object types for more information.
209  *
210  * Return value: @blob.
211  *
212  * Since: 0.9.2
213  **/
214 hb_blob_t *
215 hb_blob_reference (hb_blob_t *blob)
216 {
217   return hb_object_reference (blob);
218 }
219 
</pre>
<hr />
<pre>
274  **/
275 void *
276 hb_blob_get_user_data (hb_blob_t          *blob,
277                        hb_user_data_key_t *key)
278 {
279   return hb_object_get_user_data (blob, key);
280 }
281 
282 
283 /**
284  * hb_blob_make_immutable:
285  * @blob: a blob.
286  *
287  *
288  *
289  * Since: 0.9.2
290  **/
291 void
292 hb_blob_make_immutable (hb_blob_t *blob)
293 {
<span class="line-modified">294   if (hb_object_is_inert (blob))</span>
295     return;
296 
<span class="line-modified">297   blob-&gt;immutable = true;</span>
298 }
299 
300 /**
301  * hb_blob_is_immutable:
302  * @blob: a blob.
303  *
304  *
305  *
306  * Return value: TODO
307  *
308  * Since: 0.9.2
309  **/
310 hb_bool_t
311 hb_blob_is_immutable (hb_blob_t *blob)
312 {
<span class="line-modified">313   return blob-&gt;immutable;</span>
314 }
315 
316 
317 /**
318  * hb_blob_get_length:
319  * @blob: a blob.
320  *
321  *
322  *
323  * Return value: the length of blob data in bytes.
324  *
325  * Since: 0.9.2
326  **/
327 unsigned int
328 hb_blob_get_length (hb_blob_t *blob)
329 {
330   return blob-&gt;length;
331 }
332 
333 /**
</pre>
<hr />
<pre>
367  * Since: 0.9.2
368  **/
369 char *
370 hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length)
371 {
372   if (!blob-&gt;try_make_writable ()) {
373     if (length)
374       *length = 0;
375 
376     return nullptr;
377   }
378 
379   if (length)
380     *length = blob-&gt;length;
381 
382   return const_cast&lt;char *&gt; (blob-&gt;data);
383 }
384 
385 
386 bool
<span class="line-modified">387 hb_blob_t::try_make_writable_inplace_unix (void)</span>
388 {
389 #if defined(HAVE_SYS_MMAN_H) &amp;&amp; defined(HAVE_MPROTECT)
390   uintptr_t pagesize = -1, mask, length;
391   const char *addr;
392 
393 #if defined(HAVE_SYSCONF) &amp;&amp; defined(_SC_PAGE_SIZE)
394   pagesize = (uintptr_t) sysconf (_SC_PAGE_SIZE);
395 #elif defined(HAVE_SYSCONF) &amp;&amp; defined(_SC_PAGESIZE)
396   pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);
397 #elif defined(HAVE_GETPAGESIZE)
398   pagesize = (uintptr_t) getpagesize ();
399 #endif
400 
401   if ((uintptr_t) -1L == pagesize) {
402     DEBUG_MSG_FUNC (BLOB, this, &quot;failed to get pagesize: %s&quot;, strerror (errno));
403     return false;
404   }
405   DEBUG_MSG_FUNC (BLOB, this, &quot;pagesize is %lu&quot;, (unsigned long) pagesize);
406 
407   mask = ~(pagesize-1);
</pre>
<hr />
<pre>
410   DEBUG_MSG_FUNC (BLOB, this,
411                   &quot;calling mprotect on [%p..%p] (%lu bytes)&quot;,
412                   addr, addr+length, (unsigned long) length);
413   if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {
414     DEBUG_MSG_FUNC (BLOB, this, &quot;mprotect failed: %s&quot;, strerror (errno));
415     return false;
416   }
417 
418   this-&gt;mode = HB_MEMORY_MODE_WRITABLE;
419 
420   DEBUG_MSG_FUNC (BLOB, this,
421                   &quot;successfully made [%p..%p] (%lu bytes) writable\n&quot;,
422                   addr, addr+length, (unsigned long) length);
423   return true;
424 #else
425   return false;
426 #endif
427 }
428 
429 bool
<span class="line-modified">430 hb_blob_t::try_make_writable_inplace (void)</span>
431 {
432   DEBUG_MSG_FUNC (BLOB, this, &quot;making writable inplace\n&quot;);
433 
434   if (this-&gt;try_make_writable_inplace_unix ())
435     return true;
436 
437   DEBUG_MSG_FUNC (BLOB, this, &quot;making writable -&gt; FAILED\n&quot;);
438 
439   /* Failed to make writable inplace, mark that */
440   this-&gt;mode = HB_MEMORY_MODE_READONLY;
441   return false;
442 }
443 
444 bool
<span class="line-modified">445 hb_blob_t::try_make_writable (void)</span>
446 {
<span class="line-modified">447   if (this-&gt;immutable)</span>
448     return false;
449 
450   if (this-&gt;mode == HB_MEMORY_MODE_WRITABLE)
451     return true;
452 
453   if (this-&gt;mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE &amp;&amp; this-&gt;try_make_writable_inplace ())
454     return true;
455 
456   if (this-&gt;mode == HB_MEMORY_MODE_WRITABLE)
457     return true;
458 
459 
460   DEBUG_MSG_FUNC (BLOB, this, &quot;current data is -&gt; %p\n&quot;, this-&gt;data);
461 
462   char *new_data;
463 
464   new_data = (char *) malloc (this-&gt;length);
465   if (unlikely (!new_data))
466     return false;
467 
</pre>
<hr />
<pre>
470   memcpy (new_data, this-&gt;data, this-&gt;length);
471   this-&gt;destroy_user_data ();
472   this-&gt;mode = HB_MEMORY_MODE_WRITABLE;
473   this-&gt;data = new_data;
474   this-&gt;user_data = new_data;
475   this-&gt;destroy = free;
476 
477   return true;
478 }
479 
480 /*
481  * Mmap
482  */
483 
484 #ifdef HAVE_MMAP
485 # include &lt;sys/types.h&gt;
486 # include &lt;sys/stat.h&gt;
487 # include &lt;fcntl.h&gt;
488 #endif
489 
<span class="line-modified">490 #if defined(_WIN32) || defined(__CYGWIN__)</span>
491 # include &lt;windows.h&gt;
492 #else
<span class="line-modified">493 # ifndef _O_BINARY</span>
<span class="line-modified">494 #  define _O_BINARY 0</span>
495 # endif
496 #endif
497 
498 #ifndef MAP_NORESERVE
499 # define MAP_NORESERVE 0
500 #endif
501 
502 struct hb_mapped_file_t
503 {
504   char *contents;
505   unsigned long length;
<span class="line-modified">506 #if defined(_WIN32) || defined(__CYGWIN__)</span>
507   HANDLE mapping;
508 #endif
509 };
510 

511 static void
<span class="line-modified">512 _hb_mapped_file_destroy (hb_mapped_file_t *file)</span>
513 {

514 #ifdef HAVE_MMAP
515   munmap (file-&gt;contents, file-&gt;length);
<span class="line-modified">516 #elif defined(_WIN32) || defined(__CYGWIN__)</span>
517   UnmapViewOfFile (file-&gt;contents);
518   CloseHandle (file-&gt;mapping);
519 #else
520   assert (0); // If we don&#39;t have mmap we shouldn&#39;t reach here
521 #endif
522 
523   free (file);
524 }

525 
526 /**
527  * hb_blob_create_from_file:
528  * @file_name: font filename.
529  *
530  * Returns: A hb_blob_t pointer with the content of the file
531  *
532  * Since: 1.7.7
533  **/
534 hb_blob_t *
535 hb_blob_create_from_file (const char *file_name)
536 {
537   /* Adopted from glib&#39;s gmappedfile.c with Matthias Clasen and
538      Allison Lortie permission but changed a lot to suit our need. */
539 #if defined(HAVE_MMAP) &amp;&amp; !defined(HB_NO_MMAP)
540   hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));
541   if (unlikely (!file)) return hb_blob_get_empty ();
542 
<span class="line-modified">543   int fd = open (file_name, O_RDONLY | _O_BINARY, 0);</span>
544   if (unlikely (fd == -1)) goto fail_without_close;
545 
546   struct stat st;
547   if (unlikely (fstat (fd, &amp;st) == -1)) goto fail;
548 
549   file-&gt;length = (unsigned long) st.st_size;
550   file-&gt;contents = (char *) mmap (nullptr, file-&gt;length, PROT_READ,
551                                   MAP_PRIVATE | MAP_NORESERVE, fd, 0);
552 
553   if (unlikely (file-&gt;contents == MAP_FAILED)) goto fail;
554 
555   close (fd);
556 
557   return hb_blob_create (file-&gt;contents, file-&gt;length,
558                          HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,
559                          (hb_destroy_func_t) _hb_mapped_file_destroy);
560 
561 fail:
562   close (fd);
563 fail_without_close:
564   free (file);
565 
<span class="line-modified">566 #elif (defined(_WIN32) || defined(__CYGWIN__)) &amp;&amp; !defined(HB_NO_MMAP)</span>
567   hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));
568   if (unlikely (!file)) return hb_blob_get_empty ();
569 
<span class="line-modified">570   HANDLE fd = CreateFile (file_name, GENERIC_READ, FILE_SHARE_READ, nullptr,</span>
<span class="line-modified">571                           OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED,</span>
<span class="line-modified">572                           nullptr);</span>




















573 
574   if (unlikely (fd == INVALID_HANDLE_VALUE)) goto fail_without_close;
575 








576   file-&gt;length = (unsigned long) GetFileSize (fd, nullptr);
577   file-&gt;mapping = CreateFileMapping (fd, nullptr, PAGE_READONLY, 0, 0, nullptr);

578   if (unlikely (file-&gt;mapping == nullptr)) goto fail;
579 



580   file-&gt;contents = (char *) MapViewOfFile (file-&gt;mapping, FILE_MAP_READ, 0, 0, 0);

581   if (unlikely (file-&gt;contents == nullptr)) goto fail;
582 
583   CloseHandle (fd);
584   return hb_blob_create (file-&gt;contents, file-&gt;length,
585                          HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,
586                          (hb_destroy_func_t) _hb_mapped_file_destroy);
587 
588 fail:
589   CloseHandle (fd);
590 fail_without_close:
591   free (file);
592 
593 #endif
594 
595   /* The following tries to read a file without knowing its size beforehand
596      It&#39;s used as a fallback for systems without mmap or to read from pipes */
597   unsigned long len = 0, allocated = BUFSIZ * 16;
598   char *data = (char *) malloc (allocated);
599   if (unlikely (data == nullptr)) return hb_blob_get_empty ();
600 
</pre>
</td>
<td>
<hr />
<pre>
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  */
 27 
<span class="line-modified"> 28 </span>
<span class="line-added"> 29 /* https://github.com/harfbuzz/harfbuzz/issues/1308</span>
<span class="line-added"> 30  * http://www.gnu.org/software/libc/manual/html_node/Feature-Test-Macros.html</span>
<span class="line-added"> 31  * https://www.oracle.com/technetwork/articles/servers-storage-dev/standardheaderfiles-453865.html</span>
<span class="line-added"> 32  */</span>
 33 #ifndef _POSIX_C_SOURCE
<span class="line-added"> 34 #pragma GCC diagnostic push</span>
<span class="line-added"> 35 #pragma GCC diagnostic ignored &quot;-Wunused-macros&quot;</span>
 36 #define _POSIX_C_SOURCE 200809L
<span class="line-added"> 37 #pragma GCC diagnostic pop</span>
 38 #endif
 39 
<span class="line-modified"> 40 #include &quot;hb.hh&quot;</span>
<span class="line-modified"> 41 #include &quot;hb-blob.hh&quot;</span>

 42 
 43 #ifdef HAVE_SYS_MMAN_H
 44 #ifdef HAVE_UNISTD_H
 45 #include &lt;unistd.h&gt;
 46 #endif /* HAVE_UNISTD_H */
 47 #include &lt;sys/mman.h&gt;
 48 #endif /* HAVE_SYS_MMAN_H */
 49 
 50 #include &lt;stdio.h&gt;
 51 #include &lt;errno.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 
 54 
<span class="line-added"> 55 /**</span>
<span class="line-added"> 56  * SECTION: hb-blob</span>
<span class="line-added"> 57  * @title: hb-blob</span>
<span class="line-added"> 58  * @short_description: Binary data containers</span>
<span class="line-added"> 59  * @include: hb.h</span>
<span class="line-added"> 60  *</span>
<span class="line-added"> 61  * Blobs wrap a chunk of binary data to handle lifecycle management of data</span>
<span class="line-added"> 62  * while it is passed between client and HarfBuzz.  Blobs are primarily used</span>
<span class="line-added"> 63  * to create font faces, but also to access font face tables, as well as</span>
<span class="line-added"> 64  * pass around other binary data.</span>
<span class="line-added"> 65  **/</span>
<span class="line-added"> 66 </span>
<span class="line-added"> 67 </span>
 68 /**
 69  * hb_blob_create: (skip)
 70  * @data: Pointer to blob data.
 71  * @length: Length of @data in bytes.
 72  * @mode: Memory mode for @data.
 73  * @user_data: Data parameter to pass to @destroy.
 74  * @destroy: Callback to call when @data is not needed anymore.
 75  *
 76  * Creates a new &quot;blob&quot; object wrapping @data.  The @mode parameter is used
 77  * to negotiate ownership and lifecycle of @data.
 78  *
 79  * Return value: New blob, or the empty blob if something failed or if @length is
 80  * zero.  Destroy with hb_blob_destroy().
 81  *
 82  * Since: 0.9.2
 83  **/
 84 hb_blob_t *
 85 hb_blob_create (const char        *data,
 86                 unsigned int       length,
 87                 hb_memory_mode_t   mode,
</pre>
<hr />
<pre>
132  * blob is always created with %HB_MEMORY_MODE_READONLY, meaning that it
133  * will never modify data in the parent blob.  The parent data is not
134  * expected to be modified, and will result in undefined behavior if it
135  * is.
136  *
137  * Makes @parent immutable.
138  *
139  * Return value: New blob, or the empty blob if something failed or if
140  * @length is zero or @offset is beyond the end of @parent&#39;s data.  Destroy
141  * with hb_blob_destroy().
142  *
143  * Since: 0.9.2
144  **/
145 hb_blob_t *
146 hb_blob_create_sub_blob (hb_blob_t    *parent,
147                          unsigned int  offset,
148                          unsigned int  length)
149 {
150   hb_blob_t *blob;
151 
<span class="line-modified">152   if (!length || !parent || offset &gt;= parent-&gt;length)</span>
153     return hb_blob_get_empty ();
154 
155   hb_blob_make_immutable (parent);
156 
157   blob = hb_blob_create (parent-&gt;data + offset,
158                          MIN (length, parent-&gt;length - offset),
159                          HB_MEMORY_MODE_READONLY,
160                          hb_blob_reference (parent),
161                          _hb_blob_destroy);
162 
163   return blob;
164 }
165 
166 /**
167  * hb_blob_copy_writable_or_fail:
168  * @blob: A blob.
169  *
170  * Makes a writable copy of @blob.
171  *
172  * Return value: New blob, or nullptr if allocation failed.
</pre>
<hr />
<pre>
183                          nullptr);
184 
185   if (unlikely (blob == hb_blob_get_empty ()))
186     blob = nullptr;
187 
188   return blob;
189 }
190 
191 /**
192  * hb_blob_get_empty:
193  *
194  * Returns the singleton empty blob.
195  *
196  * See TODO:link object types for more information.
197  *
198  * Return value: (transfer full): the empty blob.
199  *
200  * Since: 0.9.2
201  **/
202 hb_blob_t *
<span class="line-modified">203 hb_blob_get_empty ()</span>
204 {
<span class="line-modified">205   return const_cast&lt;hb_blob_t *&gt; (&amp;Null(hb_blob_t));</span>













206 }
207 
208 /**
209  * hb_blob_reference: (skip)
210  * @blob: a blob.
211  *
212  * Increases the reference count on @blob.
213  *
214  * See TODO:link object types for more information.
215  *
216  * Return value: @blob.
217  *
218  * Since: 0.9.2
219  **/
220 hb_blob_t *
221 hb_blob_reference (hb_blob_t *blob)
222 {
223   return hb_object_reference (blob);
224 }
225 
</pre>
<hr />
<pre>
280  **/
281 void *
282 hb_blob_get_user_data (hb_blob_t          *blob,
283                        hb_user_data_key_t *key)
284 {
285   return hb_object_get_user_data (blob, key);
286 }
287 
288 
289 /**
290  * hb_blob_make_immutable:
291  * @blob: a blob.
292  *
293  *
294  *
295  * Since: 0.9.2
296  **/
297 void
298 hb_blob_make_immutable (hb_blob_t *blob)
299 {
<span class="line-modified">300   if (hb_object_is_immutable (blob))</span>
301     return;
302 
<span class="line-modified">303   hb_object_make_immutable (blob);</span>
304 }
305 
306 /**
307  * hb_blob_is_immutable:
308  * @blob: a blob.
309  *
310  *
311  *
312  * Return value: TODO
313  *
314  * Since: 0.9.2
315  **/
316 hb_bool_t
317 hb_blob_is_immutable (hb_blob_t *blob)
318 {
<span class="line-modified">319   return hb_object_is_immutable (blob);</span>
320 }
321 
322 
323 /**
324  * hb_blob_get_length:
325  * @blob: a blob.
326  *
327  *
328  *
329  * Return value: the length of blob data in bytes.
330  *
331  * Since: 0.9.2
332  **/
333 unsigned int
334 hb_blob_get_length (hb_blob_t *blob)
335 {
336   return blob-&gt;length;
337 }
338 
339 /**
</pre>
<hr />
<pre>
373  * Since: 0.9.2
374  **/
375 char *
376 hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length)
377 {
378   if (!blob-&gt;try_make_writable ()) {
379     if (length)
380       *length = 0;
381 
382     return nullptr;
383   }
384 
385   if (length)
386     *length = blob-&gt;length;
387 
388   return const_cast&lt;char *&gt; (blob-&gt;data);
389 }
390 
391 
392 bool
<span class="line-modified">393 hb_blob_t::try_make_writable_inplace_unix ()</span>
394 {
395 #if defined(HAVE_SYS_MMAN_H) &amp;&amp; defined(HAVE_MPROTECT)
396   uintptr_t pagesize = -1, mask, length;
397   const char *addr;
398 
399 #if defined(HAVE_SYSCONF) &amp;&amp; defined(_SC_PAGE_SIZE)
400   pagesize = (uintptr_t) sysconf (_SC_PAGE_SIZE);
401 #elif defined(HAVE_SYSCONF) &amp;&amp; defined(_SC_PAGESIZE)
402   pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);
403 #elif defined(HAVE_GETPAGESIZE)
404   pagesize = (uintptr_t) getpagesize ();
405 #endif
406 
407   if ((uintptr_t) -1L == pagesize) {
408     DEBUG_MSG_FUNC (BLOB, this, &quot;failed to get pagesize: %s&quot;, strerror (errno));
409     return false;
410   }
411   DEBUG_MSG_FUNC (BLOB, this, &quot;pagesize is %lu&quot;, (unsigned long) pagesize);
412 
413   mask = ~(pagesize-1);
</pre>
<hr />
<pre>
416   DEBUG_MSG_FUNC (BLOB, this,
417                   &quot;calling mprotect on [%p..%p] (%lu bytes)&quot;,
418                   addr, addr+length, (unsigned long) length);
419   if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {
420     DEBUG_MSG_FUNC (BLOB, this, &quot;mprotect failed: %s&quot;, strerror (errno));
421     return false;
422   }
423 
424   this-&gt;mode = HB_MEMORY_MODE_WRITABLE;
425 
426   DEBUG_MSG_FUNC (BLOB, this,
427                   &quot;successfully made [%p..%p] (%lu bytes) writable\n&quot;,
428                   addr, addr+length, (unsigned long) length);
429   return true;
430 #else
431   return false;
432 #endif
433 }
434 
435 bool
<span class="line-modified">436 hb_blob_t::try_make_writable_inplace ()</span>
437 {
438   DEBUG_MSG_FUNC (BLOB, this, &quot;making writable inplace\n&quot;);
439 
440   if (this-&gt;try_make_writable_inplace_unix ())
441     return true;
442 
443   DEBUG_MSG_FUNC (BLOB, this, &quot;making writable -&gt; FAILED\n&quot;);
444 
445   /* Failed to make writable inplace, mark that */
446   this-&gt;mode = HB_MEMORY_MODE_READONLY;
447   return false;
448 }
449 
450 bool
<span class="line-modified">451 hb_blob_t::try_make_writable ()</span>
452 {
<span class="line-modified">453   if (hb_object_is_immutable (this))</span>
454     return false;
455 
456   if (this-&gt;mode == HB_MEMORY_MODE_WRITABLE)
457     return true;
458 
459   if (this-&gt;mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE &amp;&amp; this-&gt;try_make_writable_inplace ())
460     return true;
461 
462   if (this-&gt;mode == HB_MEMORY_MODE_WRITABLE)
463     return true;
464 
465 
466   DEBUG_MSG_FUNC (BLOB, this, &quot;current data is -&gt; %p\n&quot;, this-&gt;data);
467 
468   char *new_data;
469 
470   new_data = (char *) malloc (this-&gt;length);
471   if (unlikely (!new_data))
472     return false;
473 
</pre>
<hr />
<pre>
476   memcpy (new_data, this-&gt;data, this-&gt;length);
477   this-&gt;destroy_user_data ();
478   this-&gt;mode = HB_MEMORY_MODE_WRITABLE;
479   this-&gt;data = new_data;
480   this-&gt;user_data = new_data;
481   this-&gt;destroy = free;
482 
483   return true;
484 }
485 
486 /*
487  * Mmap
488  */
489 
490 #ifdef HAVE_MMAP
491 # include &lt;sys/types.h&gt;
492 # include &lt;sys/stat.h&gt;
493 # include &lt;fcntl.h&gt;
494 #endif
495 
<span class="line-modified">496 #ifdef _WIN32</span>
497 # include &lt;windows.h&gt;
498 #else
<span class="line-modified">499 # ifndef O_BINARY</span>
<span class="line-modified">500 #  define O_BINARY 0</span>
501 # endif
502 #endif
503 
504 #ifndef MAP_NORESERVE
505 # define MAP_NORESERVE 0
506 #endif
507 
508 struct hb_mapped_file_t
509 {
510   char *contents;
511   unsigned long length;
<span class="line-modified">512 #ifdef _WIN32</span>
513   HANDLE mapping;
514 #endif
515 };
516 
<span class="line-added">517 #if (defined(HAVE_MMAP) || defined(_WIN32)) &amp;&amp; !defined(HB_NO_MMAP)</span>
518 static void
<span class="line-modified">519 _hb_mapped_file_destroy (void *file_)</span>
520 {
<span class="line-added">521   hb_mapped_file_t *file = (hb_mapped_file_t *) file_;</span>
522 #ifdef HAVE_MMAP
523   munmap (file-&gt;contents, file-&gt;length);
<span class="line-modified">524 #elif defined(_WIN32)</span>
525   UnmapViewOfFile (file-&gt;contents);
526   CloseHandle (file-&gt;mapping);
527 #else
528   assert (0); // If we don&#39;t have mmap we shouldn&#39;t reach here
529 #endif
530 
531   free (file);
532 }
<span class="line-added">533 #endif</span>
534 
535 /**
536  * hb_blob_create_from_file:
537  * @file_name: font filename.
538  *
539  * Returns: A hb_blob_t pointer with the content of the file
540  *
541  * Since: 1.7.7
542  **/
543 hb_blob_t *
544 hb_blob_create_from_file (const char *file_name)
545 {
546   /* Adopted from glib&#39;s gmappedfile.c with Matthias Clasen and
547      Allison Lortie permission but changed a lot to suit our need. */
548 #if defined(HAVE_MMAP) &amp;&amp; !defined(HB_NO_MMAP)
549   hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));
550   if (unlikely (!file)) return hb_blob_get_empty ();
551 
<span class="line-modified">552   int fd = open (file_name, O_RDONLY | O_BINARY, 0);</span>
553   if (unlikely (fd == -1)) goto fail_without_close;
554 
555   struct stat st;
556   if (unlikely (fstat (fd, &amp;st) == -1)) goto fail;
557 
558   file-&gt;length = (unsigned long) st.st_size;
559   file-&gt;contents = (char *) mmap (nullptr, file-&gt;length, PROT_READ,
560                                   MAP_PRIVATE | MAP_NORESERVE, fd, 0);
561 
562   if (unlikely (file-&gt;contents == MAP_FAILED)) goto fail;
563 
564   close (fd);
565 
566   return hb_blob_create (file-&gt;contents, file-&gt;length,
567                          HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,
568                          (hb_destroy_func_t) _hb_mapped_file_destroy);
569 
570 fail:
571   close (fd);
572 fail_without_close:
573   free (file);
574 
<span class="line-modified">575 #elif defined(_WIN32) &amp;&amp; !defined(HB_NO_MMAP)</span>
576   hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));
577   if (unlikely (!file)) return hb_blob_get_empty ();
578 
<span class="line-modified">579   HANDLE fd;</span>
<span class="line-modified">580   unsigned int size = strlen (file_name) + 1;</span>
<span class="line-modified">581   wchar_t * wchar_file_name = (wchar_t *) malloc (sizeof (wchar_t) * size);</span>
<span class="line-added">582   if (unlikely (wchar_file_name == nullptr)) goto fail_without_close;</span>
<span class="line-added">583   mbstowcs (wchar_file_name, file_name, size);</span>
<span class="line-added">584 #if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)</span>
<span class="line-added">585   {</span>
<span class="line-added">586     CREATEFILE2_EXTENDED_PARAMETERS ceparams = { 0 };</span>
<span class="line-added">587     ceparams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);</span>
<span class="line-added">588     ceparams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED &amp; 0xFFFF;</span>
<span class="line-added">589     ceparams.dwFileFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED &amp; 0xFFF00000;</span>
<span class="line-added">590     ceparams.dwSecurityQosFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED &amp; 0x000F0000;</span>
<span class="line-added">591     ceparams.lpSecurityAttributes = nullptr;</span>
<span class="line-added">592     ceparams.hTemplateFile = nullptr;</span>
<span class="line-added">593     fd = CreateFile2 (wchar_file_name, GENERIC_READ, FILE_SHARE_READ,</span>
<span class="line-added">594                       OPEN_EXISTING, &amp;ceparams);</span>
<span class="line-added">595   }</span>
<span class="line-added">596 #else</span>
<span class="line-added">597   fd = CreateFileW (wchar_file_name, GENERIC_READ, FILE_SHARE_READ, nullptr,</span>
<span class="line-added">598                     OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED,</span>
<span class="line-added">599                     nullptr);</span>
<span class="line-added">600 #endif</span>
<span class="line-added">601   free (wchar_file_name);</span>
602 
603   if (unlikely (fd == INVALID_HANDLE_VALUE)) goto fail_without_close;
604 
<span class="line-added">605 #if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)</span>
<span class="line-added">606   {</span>
<span class="line-added">607     LARGE_INTEGER length;</span>
<span class="line-added">608     GetFileSizeEx (fd, &amp;length);</span>
<span class="line-added">609     file-&gt;length = length.LowPart;</span>
<span class="line-added">610     file-&gt;mapping = CreateFileMappingFromApp (fd, nullptr, PAGE_READONLY, length.QuadPart, nullptr);</span>
<span class="line-added">611   }</span>
<span class="line-added">612 #else</span>
613   file-&gt;length = (unsigned long) GetFileSize (fd, nullptr);
614   file-&gt;mapping = CreateFileMapping (fd, nullptr, PAGE_READONLY, 0, 0, nullptr);
<span class="line-added">615 #endif</span>
616   if (unlikely (file-&gt;mapping == nullptr)) goto fail;
617 
<span class="line-added">618 #if defined(WINAPI_FAMILY) &amp;&amp; (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)</span>
<span class="line-added">619   file-&gt;contents = (char *) MapViewOfFileFromApp (file-&gt;mapping, FILE_MAP_READ, 0, 0);</span>
<span class="line-added">620 #else</span>
621   file-&gt;contents = (char *) MapViewOfFile (file-&gt;mapping, FILE_MAP_READ, 0, 0, 0);
<span class="line-added">622 #endif</span>
623   if (unlikely (file-&gt;contents == nullptr)) goto fail;
624 
625   CloseHandle (fd);
626   return hb_blob_create (file-&gt;contents, file-&gt;length,
627                          HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,
628                          (hb_destroy_func_t) _hb_mapped_file_destroy);
629 
630 fail:
631   CloseHandle (fd);
632 fail_without_close:
633   free (file);
634 
635 #endif
636 
637   /* The following tries to read a file without knowing its size beforehand
638      It&#39;s used as a fallback for systems without mmap or to read from pipes */
639   unsigned long len = 0, allocated = BUFSIZ * 16;
640   char *data = (char *) malloc (allocated);
641   if (unlikely (data == nullptr)) return hb_blob_get_empty ();
642 
</pre>
</td>
</tr>
</table>
<center><a href="../freetypeScaler.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer-deserialize-json.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
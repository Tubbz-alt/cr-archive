<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-deprecated.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.cc.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-dsalgs.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,23 ***</span>
   */
  
  #ifndef HB_DSALGS_HH
  #define HB_DSALGS_HH
  
<span class="line-modified">! #include &quot;hb-private.hh&quot;</span>
  
  
  static inline void *
  hb_bsearch_r (const void *key, const void *base,
                size_t nmemb, size_t size,
                int (*compar)(const void *_key, const void *_item, void *_arg),
                void *arg)
  {
    int min = 0, max = (int) nmemb - 1;
    while (min &lt;= max)
    {
<span class="line-modified">!     int mid = (min + max) / 2;</span>
      const void *p = (const void *) (((const char *) base) + (mid * size));
      int c = compar (key, p, arg);
      if (c &lt; 0)
        max = mid - 1;
      else if (c &gt; 0)
<span class="line-new-header">--- 25,353 ---</span>
   */
  
  #ifndef HB_DSALGS_HH
  #define HB_DSALGS_HH
  
<span class="line-modified">! #include &quot;hb.hh&quot;</span>
<span class="line-added">+ #include &quot;hb-null.hh&quot;</span>
  
  
<span class="line-added">+ /* Void! For when we need a expression-type of void. */</span>
<span class="line-added">+ typedef const struct _hb_void_t *hb_void_t;</span>
<span class="line-added">+ #define HB_VOID ((const _hb_void_t *) nullptr)</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Bithacks.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Return the number of 1 bits in v. */</span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added">+ hb_popcount (T v)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">+     return __builtin_popcount (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added">+     return __builtin_popcountl (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added">+     return __builtin_popcountll (v);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= 4)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* &quot;HACKMEM 169&quot; */</span>
<span class="line-added">+     uint32_t y;</span>
<span class="line-added">+     y = (v &gt;&gt; 1) &amp;033333333333;</span>
<span class="line-added">+     y = v - y - ((y &gt;&gt;1) &amp; 033333333333);</span>
<span class="line-added">+     return (((y + (y &gt;&gt; 3)) &amp; 030707070707) % 077);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) == 8)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int shift = 32;</span>
<span class="line-added">+     return hb_popcount&lt;uint32_t&gt; ((uint32_t) v) + hb_popcount ((uint32_t) (v &gt;&gt; shift));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) == 16)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int shift = 64;</span>
<span class="line-added">+     return hb_popcount&lt;uint64_t&gt; ((uint64_t) v) + hb_popcount ((uint64_t) (v &gt;&gt; shift));</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert (0);</span>
<span class="line-added">+   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Returns the number of bits needed to store number */</span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added">+ hb_bit_storage (T v)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (unlikely (!v)) return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">+     return sizeof (unsigned int) * 8 - __builtin_clz (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added">+     return sizeof (unsigned long) * 8 - __builtin_clzl (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added">+     return sizeof (unsigned long long) * 8 - __builtin_clzll (v);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1500) || defined(__MINGW32__)</span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned long where;</span>
<span class="line-added">+     _BitScanReverse (&amp;where, v);</span>
<span class="line-added">+     return 1 + where;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ # if defined(_WIN64)</span>
<span class="line-added">+   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned long where;</span>
<span class="line-added">+     _BitScanReverse64 (&amp;where, v);</span>
<span class="line-added">+     return 1 + where;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ # endif</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= 4)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* &quot;bithacks&quot; */</span>
<span class="line-added">+     const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};</span>
<span class="line-added">+     const unsigned int S[] = {1, 2, 4, 8, 16};</span>
<span class="line-added">+     unsigned int r = 0;</span>
<span class="line-added">+     for (int i = 4; i &gt;= 0; i--)</span>
<span class="line-added">+       if (v &amp; b[i])</span>
<span class="line-added">+       {</span>
<span class="line-added">+         v &gt;&gt;= S[i];</span>
<span class="line-added">+         r |= S[i];</span>
<span class="line-added">+       }</span>
<span class="line-added">+     return r + 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* &quot;bithacks&quot; */</span>
<span class="line-added">+     const uint64_t b[] = {0x2ULL, 0xCULL, 0xF0ULL, 0xFF00ULL, 0xFFFF0000ULL, 0xFFFFFFFF00000000ULL};</span>
<span class="line-added">+     const unsigned int S[] = {1, 2, 4, 8, 16, 32};</span>
<span class="line-added">+     unsigned int r = 0;</span>
<span class="line-added">+     for (int i = 5; i &gt;= 0; i--)</span>
<span class="line-added">+       if (v &amp; b[i])</span>
<span class="line-added">+       {</span>
<span class="line-added">+         v &gt;&gt;= S[i];</span>
<span class="line-added">+         r |= S[i];</span>
<span class="line-added">+       }</span>
<span class="line-added">+     return r + 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (sizeof (T) == 16)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int shift = 64;</span>
<span class="line-added">+     return (v &gt;&gt; shift) ? hb_bit_storage&lt;uint64_t&gt; ((uint64_t) (v &gt;&gt; shift)) + shift :</span>
<span class="line-added">+                           hb_bit_storage&lt;uint64_t&gt; ((uint64_t) v);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert (0);</span>
<span class="line-added">+   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Returns the number of zero bits in the least significant side of v */</span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ static inline HB_CONST_FUNC unsigned int</span>
<span class="line-added">+ hb_ctz (T v)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (unlikely (!v)) return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if (defined(__GNUC__) &amp;&amp; (__GNUC__ &gt;= 4)) || defined(__clang__)</span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">+     return __builtin_ctz (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long))</span>
<span class="line-added">+     return __builtin_ctzl (v);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned long long))</span>
<span class="line-added">+     return __builtin_ctzll (v);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if (defined(_MSC_VER) &amp;&amp; _MSC_VER &gt;= 1500) || defined(__MINGW32__)</span>
<span class="line-added">+   if (sizeof (T) &lt;= sizeof (unsigned int))</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned long where;</span>
<span class="line-added">+     _BitScanForward (&amp;where, v);</span>
<span class="line-added">+     return where;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ # if defined(_WIN64)</span>
<span class="line-added">+   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned long where;</span>
<span class="line-added">+     _BitScanForward64 (&amp;where, v);</span>
<span class="line-added">+     return where;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ # endif</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (sizeof (T) &lt;= 4)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* &quot;bithacks&quot; */</span>
<span class="line-added">+     unsigned int c = 32;</span>
<span class="line-added">+     v &amp;= - (int32_t) v;</span>
<span class="line-added">+     if (v) c--;</span>
<span class="line-added">+     if (v &amp; 0x0000FFFF) c -= 16;</span>
<span class="line-added">+     if (v &amp; 0x00FF00FF) c -= 8;</span>
<span class="line-added">+     if (v &amp; 0x0F0F0F0F) c -= 4;</span>
<span class="line-added">+     if (v &amp; 0x33333333) c -= 2;</span>
<span class="line-added">+     if (v &amp; 0x55555555) c -= 1;</span>
<span class="line-added">+     return c;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (sizeof (T) &lt;= 8)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* &quot;bithacks&quot; */</span>
<span class="line-added">+     unsigned int c = 64;</span>
<span class="line-added">+     v &amp;= - (int64_t) (v);</span>
<span class="line-added">+     if (v) c--;</span>
<span class="line-added">+     if (v &amp; 0x00000000FFFFFFFFULL) c -= 32;</span>
<span class="line-added">+     if (v &amp; 0x0000FFFF0000FFFFULL) c -= 16;</span>
<span class="line-added">+     if (v &amp; 0x00FF00FF00FF00FFULL) c -= 8;</span>
<span class="line-added">+     if (v &amp; 0x0F0F0F0F0F0F0F0FULL) c -= 4;</span>
<span class="line-added">+     if (v &amp; 0x3333333333333333ULL) c -= 2;</span>
<span class="line-added">+     if (v &amp; 0x5555555555555555ULL) c -= 1;</span>
<span class="line-added">+     return c;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   if (sizeof (T) == 16)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int shift = 64;</span>
<span class="line-added">+     return (uint64_t) v ? hb_bit_storage&lt;uint64_t&gt; ((uint64_t) v) :</span>
<span class="line-added">+                           hb_bit_storage&lt;uint64_t&gt; ((uint64_t) (v &gt;&gt; shift)) + shift;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert (0);</span>
<span class="line-added">+   return 0; /* Shut up stupid compiler. */</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Tiny stuff.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt;</span>
<span class="line-added">+ static inline T* hb_addressof (T&amp; arg)</span>
<span class="line-added">+ {</span>
<span class="line-added">+ #pragma GCC diagnostic push</span>
<span class="line-added">+ #pragma GCC diagnostic ignored &quot;-Wcast-align&quot;</span>
<span class="line-added">+   /* https://en.cppreference.com/w/cpp/memory/addressof */</span>
<span class="line-added">+   return reinterpret_cast&lt;T*&gt;(</span>
<span class="line-added">+            &amp;const_cast&lt;char&amp;&gt;(</span>
<span class="line-added">+               reinterpret_cast&lt;const volatile char&amp;&gt;(arg)));</span>
<span class="line-added">+ #pragma GCC diagnostic pop</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* ASCII tag/character handling */</span>
<span class="line-added">+ static inline bool ISALPHA (unsigned char c)</span>
<span class="line-added">+ { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;); }</span>
<span class="line-added">+ static inline bool ISALNUM (unsigned char c)</span>
<span class="line-added">+ { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) || (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;); }</span>
<span class="line-added">+ static inline bool ISSPACE (unsigned char c)</span>
<span class="line-added">+ { return c == &#39; &#39; || c ==&#39;\f&#39;|| c ==&#39;\n&#39;|| c ==&#39;\r&#39;|| c ==&#39;\t&#39;|| c ==&#39;\v&#39;; }</span>
<span class="line-added">+ static inline unsigned char TOUPPER (unsigned char c)</span>
<span class="line-added">+ { return (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;) ? c - &#39;a&#39; + &#39;A&#39; : c; }</span>
<span class="line-added">+ static inline unsigned char TOLOWER (unsigned char c)</span>
<span class="line-added">+ { return (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;) ? c - &#39;A&#39; + &#39;a&#39; : c; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef MIN</span>
<span class="line-added">+ template &lt;typename Type&gt;</span>
<span class="line-added">+ static inline Type MIN (const Type &amp;a, const Type &amp;b) { return a &lt; b ? a : b; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef MAX</span>
<span class="line-added">+ template &lt;typename Type&gt;</span>
<span class="line-added">+ static inline Type MAX (const Type &amp;a, const Type &amp;b) { return a &gt; b ? a : b; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline unsigned int DIV_CEIL (const unsigned int a, unsigned int b)</span>
<span class="line-added">+ { return (a + (b - 1)) / b; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ #undef  ARRAY_LENGTH</span>
<span class="line-added">+ template &lt;typename Type, unsigned int n&gt;</span>
<span class="line-added">+ static inline unsigned int ARRAY_LENGTH (const Type (&amp;)[n]) { return n; }</span>
<span class="line-added">+ /* A const version, but does not detect erratically being called on pointers. */</span>
<span class="line-added">+ #define ARRAY_LENGTH_CONST(__array) ((signed int) (sizeof (__array) / sizeof (__array[0])))</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline int</span>
<span class="line-added">+ hb_memcmp (const void *a, const void *b, unsigned int len)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* It&#39;s illegal to pass NULL to memcmp(), even if len is zero.</span>
<span class="line-added">+    * So, wrap it.</span>
<span class="line-added">+    * https://sourceware.org/bugzilla/show_bug.cgi?id=23878 */</span>
<span class="line-added">+   if (!len) return 0;</span>
<span class="line-added">+   return memcmp (a, b, len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline bool</span>
<span class="line-added">+ hb_unsigned_mul_overflows (unsigned int count, unsigned int size)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return (size &gt; 0) &amp;&amp; (count &gt;= ((unsigned int) -1) / size);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline unsigned int</span>
<span class="line-added">+ hb_ceil_to_4 (unsigned int v)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return ((v - 1) | 3) + 1;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt; struct hb_is_signed;</span>
<span class="line-added">+ /* https://github.com/harfbuzz/harfbuzz/issues/1535 */</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;int8_t&gt; { enum { value = true }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;int16_t&gt; { enum { value = true }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;int32_t&gt; { enum { value = true }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;int64_t&gt; { enum { value = true }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;uint8_t&gt; { enum { value = false }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;uint16_t&gt; { enum { value = false }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;uint32_t&gt; { enum { value = false }; };</span>
<span class="line-added">+ template &lt;&gt; struct hb_is_signed&lt;uint64_t&gt; { enum { value = false }; };</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt; static inline bool</span>
<span class="line-added">+ hb_in_range (T u, T lo, T hi)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* The sizeof() is here to force template instantiation.</span>
<span class="line-added">+    * I&#39;m sure there are better ways to do this but can&#39;t think of</span>
<span class="line-added">+    * one right now.  Declaring a variable won&#39;t work as HB_UNUSED</span>
<span class="line-added">+    * is unusable on some platforms and unused types are less likely</span>
<span class="line-added">+    * to generate a warning than unused variables. */</span>
<span class="line-added">+   static_assert (!hb_is_signed&lt;T&gt;::value, &quot;&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* The casts below are important as if T is smaller than int,</span>
<span class="line-added">+    * the subtract results will become a signed int! */</span>
<span class="line-added">+   return (T)(u - lo) &lt;= (T)(hi - lo);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ template &lt;typename T&gt; static inline bool</span>
<span class="line-added">+ hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ template &lt;typename T&gt; static inline bool</span>
<span class="line-added">+ hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Sort and search.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline void *</span>
<span class="line-added">+ hb_bsearch (const void *key, const void *base,</span>
<span class="line-added">+             size_t nmemb, size_t size,</span>
<span class="line-added">+             int (*compar)(const void *_key, const void *_item))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   int min = 0, max = (int) nmemb - 1;</span>
<span class="line-added">+   while (min &lt;= max)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     int mid = (min + max) / 2;</span>
<span class="line-added">+     const void *p = (const void *) (((const char *) base) + (mid * size));</span>
<span class="line-added">+     int c = compar (key, p);</span>
<span class="line-added">+     if (c &lt; 0)</span>
<span class="line-added">+       max = mid - 1;</span>
<span class="line-added">+     else if (c &gt; 0)</span>
<span class="line-added">+       min = mid + 1;</span>
<span class="line-added">+     else</span>
<span class="line-added">+       return (void *) p;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline void *
  hb_bsearch_r (const void *key, const void *base,
                size_t nmemb, size_t size,
                int (*compar)(const void *_key, const void *_item, void *_arg),
                void *arg)
  {
    int min = 0, max = (int) nmemb - 1;
    while (min &lt;= max)
    {
<span class="line-modified">!     int mid = ((unsigned int) min + (unsigned int) max) / 2;</span>
      const void *p = (const void *) (((const char *) base) + (mid * size));
      int c = compar (key, p, arg);
      if (c &lt; 0)
        max = mid - 1;
      else if (c &gt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 51,12 ***</span>
    }
    return nullptr;
  }
  
  
<span class="line-modified">! </span>
<span class="line-modified">! /* From https://github.com/noporpoise/sort_r */</span>
  
  /* Isaac Turner 29 April 2014 Public Domain */
  
  /*
  
<span class="line-new-header">--- 381,16 ---</span>
    }
    return nullptr;
  }
  
  
<span class="line-modified">! /* From https://github.com/noporpoise/sort_r</span>
<span class="line-modified">!  * With following modifications:</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * 10 November 2018:</span>
<span class="line-added">+  * https://github.com/noporpoise/sort_r/issues/7</span>
<span class="line-added">+  */</span>
  
  /* Isaac Turner 29 April 2014 Public Domain */
  
  /*
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 108,11 ***</span>
    {
      /* nel &gt; 6; Quicksort */
  
      /* Use median of first, middle and last items as pivot */
      char *x, *y, *xend, ch;
<span class="line-modified">!     char *pl, *pr;</span>
      char *last = b+w*(nel-1), *tmp;
      char *l[3];
      l[0] = b;
      l[1] = b+w*(nel/2);
      l[2] = last;
<span class="line-new-header">--- 442,11 ---</span>
    {
      /* nel &gt; 6; Quicksort */
  
      /* Use median of first, middle and last items as pivot */
      char *x, *y, *xend, ch;
<span class="line-modified">!     char *pl, *pm, *pr;</span>
      char *last = b+w*(nel-1), *tmp;
      char *l[3];
      l[0] = b;
      l[1] = b+w*(nel/2);
      l[2] = last;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,17 ***</span>
  
      pl = b;
      pr = last;
  
      while(pl &lt; pr) {
<span class="line-modified">!       for(; pl &lt; pr; pl += w) {</span>
          if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
            pr -= w; /* pivot now at pl */
            break;
          }
        }
<span class="line-modified">!       for(; pl &lt; pr; pr -= w) {</span>
          if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
            pl += w; /* pivot now at pr */
            break;
          }
        }
<span class="line-new-header">--- 464,19 ---</span>
  
      pl = b;
      pr = last;
  
      while(pl &lt; pr) {
<span class="line-modified">!       pm = pl+((pr-pl+1)&gt;&gt;1);</span>
<span class="line-added">+       for(; pl &lt; pm; pl += w) {</span>
          if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
            pr -= w; /* pivot now at pl */
            break;
          }
        }
<span class="line-modified">!       pm = pl+((pr-pl)&gt;&gt;1);</span>
<span class="line-added">+       for(; pm &lt; pr; pr -= w) {</span>
          if(sort_r_cmpswap(pl, pr, w, compar, arg)) {
            pl += w; /* pivot now at pr */
            break;
          }
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 156,6 ***</span>
<span class="line-new-header">--- 492,141 ---</span>
                               void *arg)
  {
      sort_r_simple(base, nel, width, compar, arg);
  }
  
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T, typename T2&gt; static inline void</span>
<span class="line-added">+ hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *), T2 *array2)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   for (unsigned int i = 1; i &lt; len; i++)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned int j = i;</span>
<span class="line-added">+     while (j &amp;&amp; compar (&amp;array[j - 1], &amp;array[i]) &gt; 0)</span>
<span class="line-added">+       j--;</span>
<span class="line-added">+     if (i == j)</span>
<span class="line-added">+       continue;</span>
<span class="line-added">+     /* Move item i to occupy place for item j, shift what&#39;s in between. */</span>
<span class="line-added">+     {</span>
<span class="line-added">+       T t = array[i];</span>
<span class="line-added">+       memmove (&amp;array[j + 1], &amp;array[j], (i - j) * sizeof (T));</span>
<span class="line-added">+       array[j] = t;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (array2)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       T2 t = array2[i];</span>
<span class="line-added">+       memmove (&amp;array2[j + 1], &amp;array2[j], (i - j) * sizeof (T2));</span>
<span class="line-added">+       array2[j] = t;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ template &lt;typename T&gt; static inline void</span>
<span class="line-added">+ hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   hb_stable_sort (array, len, compar, (int *) nullptr);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static inline hb_bool_t</span>
<span class="line-added">+ hb_codepoint_parse (const char *s, unsigned int len, int base, hb_codepoint_t *out)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* Pain because we don&#39;t know whether s is nul-terminated. */</span>
<span class="line-added">+   char buf[64];</span>
<span class="line-added">+   len = MIN (ARRAY_LENGTH (buf) - 1, len);</span>
<span class="line-added">+   strncpy (buf, s, len);</span>
<span class="line-added">+   buf[len] = &#39;\0&#39;;</span>
<span class="line-added">+ </span>
<span class="line-added">+   char *end;</span>
<span class="line-added">+   errno = 0;</span>
<span class="line-added">+   unsigned long v = strtoul (buf, &amp;end, base);</span>
<span class="line-added">+   if (errno) return false;</span>
<span class="line-added">+   if (*end) return false;</span>
<span class="line-added">+   *out = v;</span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ struct HbOpOr</span>
<span class="line-added">+ {</span>
<span class="line-added">+   static constexpr bool passthru_left = true;</span>
<span class="line-added">+   static constexpr bool passthru_right = true;</span>
<span class="line-added">+   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a | b; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ struct HbOpAnd</span>
<span class="line-added">+ {</span>
<span class="line-added">+   static constexpr bool passthru_left = false;</span>
<span class="line-added">+   static constexpr bool passthru_right = false;</span>
<span class="line-added">+   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a &amp; b; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ struct HbOpMinus</span>
<span class="line-added">+ {</span>
<span class="line-added">+   static constexpr bool passthru_left = true;</span>
<span class="line-added">+   static constexpr bool passthru_right = false;</span>
<span class="line-added">+   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a &amp; ~b; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ struct HbOpXor</span>
<span class="line-added">+ {</span>
<span class="line-added">+   static constexpr bool passthru_left = true;</span>
<span class="line-added">+   static constexpr bool passthru_right = true;</span>
<span class="line-added">+   template &lt;typename T&gt; static void process (T &amp;o, const T &amp;a, const T &amp;b) { o = a ^ b; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Compiler-assisted vectorization. */</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Type behaving similar to vectorized vars defined using __attribute__((vector_size(...))),</span>
<span class="line-added">+  * using vectorized operations if HB_VECTOR_SIZE is set to **bit** numbers (eg 128).</span>
<span class="line-added">+  * Define that to 0 to disable. */</span>
<span class="line-added">+ template &lt;typename elt_t, unsigned int byte_size&gt;</span>
<span class="line-added">+ struct hb_vector_size_t</span>
<span class="line-added">+ {</span>
<span class="line-added">+   elt_t&amp; operator [] (unsigned int i) { return u.v[i]; }</span>
<span class="line-added">+   const elt_t&amp; operator [] (unsigned int i) const { return u.v[i]; }</span>
<span class="line-added">+ </span>
<span class="line-added">+   void clear (unsigned char v = 0) { memset (this, v, sizeof (*this)); }</span>
<span class="line-added">+ </span>
<span class="line-added">+   template &lt;class Op&gt;</span>
<span class="line-added">+   hb_vector_size_t process (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_vector_size_t r;</span>
<span class="line-added">+ #if HB_VECTOR_SIZE</span>
<span class="line-added">+     if (HB_VECTOR_SIZE &amp;&amp; 0 == (byte_size * 8) % HB_VECTOR_SIZE)</span>
<span class="line-added">+       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.vec); i++)</span>
<span class="line-added">+         Op::process (r.u.vec[i], u.vec[i], o.u.vec[i]);</span>
<span class="line-added">+     else</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.v); i++)</span>
<span class="line-added">+         Op::process (r.u.v[i], u.v[i], o.u.v[i]);</span>
<span class="line-added">+     return r;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   hb_vector_size_t operator | (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">+   { return process&lt;HbOpOr&gt; (o); }</span>
<span class="line-added">+   hb_vector_size_t operator &amp; (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">+   { return process&lt;HbOpAnd&gt; (o); }</span>
<span class="line-added">+   hb_vector_size_t operator ^ (const hb_vector_size_t &amp;o) const</span>
<span class="line-added">+   { return process&lt;HbOpXor&gt; (o); }</span>
<span class="line-added">+   hb_vector_size_t operator ~ () const</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_vector_size_t r;</span>
<span class="line-added">+ #if HB_VECTOR_SIZE &amp;&amp; 0</span>
<span class="line-added">+     if (HB_VECTOR_SIZE &amp;&amp; 0 == (byte_size * 8) % HB_VECTOR_SIZE)</span>
<span class="line-added">+       for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.vec); i++)</span>
<span class="line-added">+         r.u.vec[i] = ~u.vec[i];</span>
<span class="line-added">+     else</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; ARRAY_LENGTH (u.v); i++)</span>
<span class="line-added">+       r.u.v[i] = ~u.v[i];</span>
<span class="line-added">+     return r;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   private:</span>
<span class="line-added">+   static_assert (byte_size / sizeof (elt_t) * sizeof (elt_t) == byte_size, &quot;&quot;);</span>
<span class="line-added">+   union {</span>
<span class="line-added">+     elt_t v[byte_size / sizeof (elt_t)];</span>
<span class="line-added">+ #if HB_VECTOR_SIZE</span>
<span class="line-added">+     hb_vector_size_impl_t vec[byte_size / sizeof (hb_vector_size_impl_t)];</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   } u;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #endif /* HB_DSALGS_HH */
</pre>
<center><a href="hb-deprecated.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-face.cc.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
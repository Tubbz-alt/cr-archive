<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-kern-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gdef-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-base-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright © 2016 Elie Roux &lt;elie.roux@telecom-bretagne.eu&gt;
  3  * Copyright © 2018  Google, Inc.

  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Google Author(s): Behdad Esfahbod
 26  */
 27 
 28 #ifndef HB_OT_LAYOUT_BASE_TABLE_HH
 29 #define HB_OT_LAYOUT_BASE_TABLE_HH
 30 
<span class="line-modified"> 31 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified"> 32 #include &quot;hb-ot-layout-common-private.hh&quot;</span>
 33 
<span class="line-modified"> 34 namespace OT {</span>

 35 
<span class="line-modified"> 36 #define NOT_INDEXED   ((unsigned int) -1)</span>
 37 
 38 /*
 39  * BASE -- Baseline
 40  * https://docs.microsoft.com/en-us/typography/opentype/spec/base
 41  */
 42 
 43 struct BaseCoordFormat1
 44 {
<span class="line-modified"> 45   inline int get_coord (void) const { return coordinate; }</span>
 46 
<span class="line-modified"> 47   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 48   {
 49     TRACE_SANITIZE (this);
<span class="line-modified"> 50     return_trace (c-&gt;check_struct (this));</span>
 51   }
 52 
 53   protected:
 54   HBUINT16      format;         /* Format identifier--format = 1 */
<span class="line-modified"> 55   HBINT16       coordinate;     /* X or Y value, in design units */</span>
 56   public:
 57   DEFINE_SIZE_STATIC (4);
 58 };
 59 
 60 struct BaseCoordFormat2
 61 {
<span class="line-modified"> 62   inline int get_coord (void) const</span>
 63   {
 64     /* TODO */
 65     return coordinate;
 66   }
 67 
<span class="line-modified"> 68   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 69   {
 70     TRACE_SANITIZE (this);
 71     return_trace (c-&gt;check_struct (this));
 72   }
 73 
 74   protected:
 75   HBUINT16      format;         /* Format identifier--format = 2 */
<span class="line-modified"> 76   HBINT16       coordinate;     /* X or Y value, in design units */</span>
 77   GlyphID       referenceGlyph; /* Glyph ID of control glyph */
 78   HBUINT16      coordPoint;     /* Index of contour point on the
 79                                  * reference glyph */
 80   public:
 81   DEFINE_SIZE_STATIC (8);
 82 };
 83 
 84 struct BaseCoordFormat3
 85 {
<span class="line-modified"> 86   inline int get_coord (void) const</span>


 87   {
<span class="line-modified"> 88     /* TODO */</span>
<span class="line-modified"> 89     return coordinate;</span>


 90   }
 91 
<span class="line-modified"> 92   inline bool sanitize (hb_sanitize_context_t *c) const</span>

 93   {
 94     TRACE_SANITIZE (this);
<span class="line-modified"> 95     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));</span>

 96   }
 97 
 98   protected:
<span class="line-modified"> 99   HBUINT16              format;         /* Format identifier--format = 3 */</span>
<span class="line-modified">100   HBINT16               coordinate;     /* X or Y value, in design units */</span>
<span class="line-modified">101   OffsetTo&lt;Device&gt;      deviceTable;    /* Offset to Device table for X or</span>
<span class="line-modified">102                                          * Y value, from beginning of</span>
<span class="line-modified">103                                          * BaseCoord table (may be NULL). */</span>

104   public:
105   DEFINE_SIZE_STATIC (6);
106 };
107 
108 struct BaseCoord
109 {
<span class="line-modified">110   inline int get_coord (void) const</span>


111   {
112     switch (u.format) {
113     case 1: return u.format1.get_coord ();
114     case 2: return u.format2.get_coord ();
<span class="line-modified">115     case 3: return u.format3.get_coord ();</span>
116     default:return 0;
117     }
118   }
119 
<span class="line-modified">120   inline bool sanitize (hb_sanitize_context_t *c) const</span>
121   {
122     TRACE_SANITIZE (this);
<span class="line-modified">123     if (!u.format.sanitize (c)) return_trace (false);</span>
124     switch (u.format) {
125     case 1: return_trace (u.format1.sanitize (c));
126     case 2: return_trace (u.format2.sanitize (c));
127     case 3: return_trace (u.format3.sanitize (c));
128     default:return_trace (false);
129     }
130   }
131 
132   protected:
133   union {
134     HBUINT16            format;
135     BaseCoordFormat1    format1;
136     BaseCoordFormat2    format2;
137     BaseCoordFormat3    format3;
138   } u;
139   public:
140   DEFINE_SIZE_UNION (2, format);
141 };
142 
143 struct FeatMinMaxRecord
144 {
<span class="line-modified">145   inline int get_min_value (void) const</span>
<span class="line-modified">146   { return (this+minCoord).get_coord(); }</span>
<span class="line-modified">147 </span>
<span class="line-modified">148   inline int get_max_value (void) const</span>
<span class="line-modified">149   { return (this+maxCoord).get_coord(); }</span>



150 
<span class="line-modified">151   inline const Tag &amp;get_tag () const</span>
<span class="line-modified">152   { return tag; }</span>



153 
<span class="line-modified">154   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
155   {
156     TRACE_SANITIZE (this);
<span class="line-modified">157     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">158                   minCoord.sanitize (c, base) &amp;&amp;</span>
<span class="line-modified">159                   maxCoord.sanitize (c, base));</span>
160   }
161 
162   protected:
<span class="line-modified">163   Tag                   tag;            /* 4-byte feature identification tag--must</span>
<span class="line-modified">164                                          * match feature tag in FeatureList */</span>
<span class="line-modified">165   OffsetTo&lt;BaseCoord&gt;   minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">166                                          * the minimum extent value, from beginning</span>
<span class="line-modified">167                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">168   OffsetTo&lt;BaseCoord&gt;   maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">169                                          * the maximum extent value, from beginning</span>
<span class="line-modified">170                                          * of MinMax table (may be NULL) */</span>


171   public:
172   DEFINE_SIZE_STATIC (8);
173 
174 };
175 
176 struct MinMax
177 {
<span class="line-modified">178   inline unsigned int get_feature_tag_index (Tag featureTableTag) const</span>
<span class="line-modified">179   {</span>
<span class="line-modified">180     /* TODO bsearch */</span>
<span class="line-modified">181     unsigned int count = featMinMaxRecords.len;</span>
<span class="line-modified">182     for (unsigned int i = 0; i &lt; count; i++)</span>








183     {
<span class="line-modified">184       Tag tag = featMinMaxRecords[i].get_tag();</span>
<span class="line-modified">185       int cmp = tag.cmp(featureTableTag);</span>
<span class="line-removed">186       if (cmp == 0) return i;</span>
<span class="line-removed">187       if (cmp &gt; 0)  return NOT_INDEXED;</span>
188     }
<span class="line-removed">189     return NOT_INDEXED;</span>
<span class="line-removed">190   }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192   inline int get_min_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">193   {</span>
<span class="line-removed">194     if (featureTableTagIndex == NOT_INDEXED)</span>
<span class="line-removed">195       return (this+minCoord).get_coord();</span>
<span class="line-removed">196     return featMinMaxRecords[featureTableTagIndex].get_min_value();</span>
<span class="line-removed">197   }</span>
<span class="line-removed">198 </span>
<span class="line-removed">199   inline int get_max_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">200   {</span>
<span class="line-removed">201     if (featureTableTagIndex == NOT_INDEXED)</span>
<span class="line-removed">202       return (this+maxCoord).get_coord();</span>
<span class="line-removed">203     return featMinMaxRecords[featureTableTagIndex].get_max_value();</span>
204   }
205 
<span class="line-modified">206   inline bool sanitize (hb_sanitize_context_t *c) const</span>
207   {
208     TRACE_SANITIZE (this);
<span class="line-modified">209     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">210                   minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">211                   maxCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">212                   featMinMaxRecords.sanitize (c, this));</span>
213   }
214 
215   protected:
<span class="line-modified">216   OffsetTo&lt;BaseCoord&gt;   minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">217                                          * minimum extent value, from the beginning</span>
<span class="line-modified">218                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">219   OffsetTo&lt;BaseCoord&gt;   maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">220                                          * maximum extent value, from the beginning</span>
<span class="line-modified">221                                          * of MinMax table (may be NULL) */</span>
<span class="line-modified">222   ArrayOf&lt;FeatMinMaxRecord&gt;</span>
<span class="line-modified">223                 featMinMaxRecords;      /* Array of FeatMinMaxRecords, in alphabetical</span>
<span class="line-modified">224                                          * order by featureTableTag */</span>



225   public:
226   DEFINE_SIZE_ARRAY (6, featMinMaxRecords);
227 };
228 
<span class="line-removed">229 /* TODO... */</span>
<span class="line-removed">230 struct BaseLangSysRecord</span>
<span class="line-removed">231 {</span>
<span class="line-removed">232   inline const Tag&amp; get_tag(void) const</span>
<span class="line-removed">233   { return baseLangSysTag; }</span>
<span class="line-removed">234 </span>
<span class="line-removed">235   inline unsigned int get_feature_tag_index (Tag featureTableTag) const</span>
<span class="line-removed">236   { return (this+minMax).get_feature_tag_index(featureTableTag); }</span>
<span class="line-removed">237 </span>
<span class="line-removed">238   inline int get_min_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">239   { return (this+minMax).get_min_value(featureTableTagIndex); }</span>
<span class="line-removed">240 </span>
<span class="line-removed">241   inline int get_max_value (unsigned int featureTableTagIndex) const</span>
<span class="line-removed">242   { return (this+minMax).get_max_value(featureTableTagIndex); }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
<span class="line-removed">245   {</span>
<span class="line-removed">246     TRACE_SANITIZE (this);</span>
<span class="line-removed">247     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed">248                   minMax.sanitize (c, base));</span>
<span class="line-removed">249   }</span>
<span class="line-removed">250 </span>
<span class="line-removed">251   protected:</span>
<span class="line-removed">252   Tag                   baseLangSysTag;</span>
<span class="line-removed">253   OffsetTo&lt;MinMax&gt;      minMax;</span>
<span class="line-removed">254   public:</span>
<span class="line-removed">255   DEFINE_SIZE_STATIC (6);</span>
<span class="line-removed">256 </span>
<span class="line-removed">257 };</span>
<span class="line-removed">258 </span>
259 struct BaseValues
260 {
<span class="line-modified">261   inline unsigned int get_default_base_tag_index (void) const</span>
<span class="line-removed">262   { return defaultIndex; }</span>
<span class="line-removed">263 </span>
<span class="line-removed">264   inline int get_base_coord (unsigned int baselineTagIndex) const</span>
265   {
<span class="line-modified">266     return (this+baseCoords[baselineTagIndex]).get_coord();</span>

267   }
268 
<span class="line-modified">269   inline bool sanitize (hb_sanitize_context_t *c) const</span>
270   {
271     TRACE_SANITIZE (this);
<span class="line-modified">272     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">273       defaultIndex &lt;= baseCoordCount &amp;&amp;</span>
<span class="line-removed">274       baseCoords.sanitize (c, this));</span>
275   }
276 
277   protected:
<span class="line-modified">278   Index                         defaultIndex;</span>
<span class="line-modified">279   HBUINT16                      baseCoordCount;</span>
<span class="line-modified">280   OffsetArrayOf&lt;BaseCoord&gt;      baseCoords;</span>







281   public:
<span class="line-modified">282   DEFINE_SIZE_ARRAY (6, baseCoords);</span>
<span class="line-removed">283 </span>
284 };
285 
<span class="line-modified">286 struct BaseScript {</span>
<span class="line-modified">287 </span>
<span class="line-modified">288   inline unsigned int get_lang_tag_index (Tag baseLangSysTag) const</span>
<span class="line-removed">289   {</span>
<span class="line-removed">290     Tag tag;</span>
<span class="line-removed">291     int cmp;</span>
<span class="line-removed">292     for (unsigned int i = 0; i &lt; baseLangSysCount; i++) {</span>
<span class="line-removed">293       tag = baseLangSysRecords[i].get_tag();</span>
<span class="line-removed">294       // taking advantage of alphabetical order</span>
<span class="line-removed">295       cmp = tag.cmp(baseLangSysTag);</span>
<span class="line-removed">296       if (cmp == 0) return i;</span>
<span class="line-removed">297       if (cmp &gt; 0)  return NOT_INDEXED;</span>
<span class="line-removed">298     }</span>
<span class="line-removed">299     return NOT_INDEXED;</span>
<span class="line-removed">300   }</span>
<span class="line-removed">301 </span>
<span class="line-removed">302   inline unsigned int get_feature_tag_index (unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">303   {</span>
<span class="line-removed">304     if (baseLangSysIndex == NOT_INDEXED) {</span>
<span class="line-removed">305       if (unlikely(defaultMinMax)) return NOT_INDEXED;</span>
<span class="line-removed">306       return (this+defaultMinMax).get_feature_tag_index(featureTableTag);</span>
<span class="line-removed">307     }</span>
<span class="line-removed">308     if (unlikely(baseLangSysIndex &gt;= baseLangSysCount)) return NOT_INDEXED;</span>
<span class="line-removed">309     return baseLangSysRecords[baseLangSysIndex].get_feature_tag_index(featureTableTag);</span>
<span class="line-removed">310   }</span>
<span class="line-removed">311 </span>
<span class="line-removed">312   inline int get_min_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">313   {</span>
<span class="line-removed">314     if (baseLangSysIndex == NOT_INDEXED)</span>
<span class="line-removed">315       return (this+defaultMinMax).get_min_value(featureTableTagIndex);</span>
<span class="line-removed">316     return baseLangSysRecords[baseLangSysIndex].get_max_value(featureTableTagIndex);</span>
<span class="line-removed">317   }</span>
<span class="line-removed">318 </span>
<span class="line-removed">319   inline int get_max_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
320   {
<span class="line-modified">321     if (baseLangSysIndex == NOT_INDEXED)</span>
<span class="line-modified">322       return (this+defaultMinMax).get_min_value(featureTableTagIndex);</span>
<span class="line-modified">323     return baseLangSysRecords[baseLangSysIndex].get_max_value(featureTableTagIndex);</span>


324   }
325 
<span class="line-modified">326   inline unsigned int get_default_base_tag_index (void) const</span>
<span class="line-modified">327   { return (this+baseValues).get_default_base_tag_index(); }</span>
328 
<span class="line-modified">329   inline int get_base_coord (unsigned int baselineTagIndex) const</span>
<span class="line-removed">330   { return (this+baseValues).get_base_coord(baselineTagIndex); }</span>
<span class="line-removed">331 </span>
<span class="line-removed">332   inline bool sanitize (hb_sanitize_context_t *c) const</span>
333   {
334     TRACE_SANITIZE (this);
<span class="line-modified">335     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">336       baseValues.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">337       defaultMinMax.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">338       baseLangSysRecords.sanitize (c, this));</span>
339   }
340 
341   protected:
<span class="line-modified">342   OffsetTo&lt;BaseValues&gt;        baseValues;</span>
<span class="line-modified">343   OffsetTo&lt;MinMax&gt;            defaultMinMax;</span>
<span class="line-modified">344   HBUINT16                      baseLangSysCount;</span>
<span class="line-modified">345   ArrayOf&lt;BaseLangSysRecord&gt;  baseLangSysRecords;</span>
<span class="line-removed">346 </span>
347   public:
<span class="line-modified">348     DEFINE_SIZE_ARRAY (8, baseLangSysRecords);</span>
349 };
350 












351 
<span class="line-modified">352 struct BaseScriptRecord {</span>
<span class="line-modified">353 </span>
<span class="line-removed">354   inline const Tag&amp; get_tag (void) const</span>
<span class="line-removed">355   { return baseScriptTag; }</span>
<span class="line-removed">356 </span>
<span class="line-removed">357   inline unsigned int get_default_base_tag_index(void) const</span>
<span class="line-removed">358   { return (this+baseScript).get_default_base_tag_index(); }</span>
<span class="line-removed">359 </span>
<span class="line-removed">360   inline int get_base_coord(unsigned int baselineTagIndex) const</span>
<span class="line-removed">361   { return (this+baseScript).get_base_coord(baselineTagIndex); }</span>
<span class="line-removed">362 </span>
<span class="line-removed">363   inline unsigned int get_lang_tag_index (Tag baseLangSysTag) const</span>
<span class="line-removed">364   { return (this+baseScript).get_lang_tag_index(baseLangSysTag); }</span>
<span class="line-removed">365 </span>
<span class="line-removed">366   inline unsigned int get_feature_tag_index (unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">367   { return (this+baseScript).get_feature_tag_index(baseLangSysIndex, featureTableTag); }</span>
<span class="line-removed">368 </span>
<span class="line-removed">369   inline int get_max_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">370   { return (this+baseScript).get_max_value(baseLangSysIndex, featureTableTagIndex); }</span>
371 
<span class="line-modified">372   inline int get_min_value (unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">373   { return (this+baseScript).get_min_value(baseLangSysIndex, featureTableTagIndex); }</span>
374 
<span class="line-modified">375   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
376   {
377     TRACE_SANITIZE (this);
<span class="line-modified">378     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">379       baseScript != Null(OffsetTo&lt;BaseScript&gt;) &amp;&amp;</span>
<span class="line-modified">380       baseScript.sanitize (c, base));</span>

381   }
382 
383   protected:
<span class="line-modified">384   Tag                   baseScriptTag;</span>
<span class="line-modified">385   OffsetTo&lt;BaseScript&gt;  baseScript;</span>








386 
387   public:
<span class="line-modified">388     DEFINE_SIZE_STATIC (6);</span>
389 };
390 
<span class="line-modified">391 struct BaseScriptList {</span>
<span class="line-modified">392 </span>
<span class="line-modified">393   inline unsigned int get_base_script_index (Tag baseScriptTag) const</span>
<span class="line-modified">394   {</span>
<span class="line-removed">395     for (unsigned int i = 0; i &lt; baseScriptCount; i++)</span>
<span class="line-removed">396       if (baseScriptRecords[i].get_tag() == baseScriptTag)</span>
<span class="line-removed">397         return i;</span>
<span class="line-removed">398     return NOT_INDEXED;</span>
<span class="line-removed">399   }</span>
<span class="line-removed">400 </span>
<span class="line-removed">401   inline unsigned int get_default_base_tag_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">402   {</span>
<span class="line-removed">403     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">404     return baseScriptRecords[baseScriptIndex].get_default_base_tag_index();</span>
<span class="line-removed">405   }</span>
<span class="line-removed">406 </span>
<span class="line-removed">407   inline int get_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">408   {</span>
<span class="line-removed">409     return baseScriptRecords[baseScriptIndex].get_base_coord(baselineTagIndex);</span>
<span class="line-removed">410   }</span>
<span class="line-removed">411 </span>
<span class="line-removed">412   inline unsigned int get_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">413   {</span>
<span class="line-removed">414     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">415     return baseScriptRecords[baseScriptIndex].get_lang_tag_index(baseLangSysTag);</span>
<span class="line-removed">416   }</span>
<span class="line-removed">417 </span>
<span class="line-removed">418   inline unsigned int get_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">419   {</span>
<span class="line-removed">420     if (unlikely(baseScriptIndex &gt;= baseScriptCount)) return NOT_INDEXED;</span>
<span class="line-removed">421     return baseScriptRecords[baseScriptIndex].get_feature_tag_index(baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">422   }</span>
<span class="line-removed">423 </span>
<span class="line-removed">424   inline int get_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
425   {
<span class="line-modified">426     return baseScriptRecords[baseScriptIndex].get_max_value(baseLangSysIndex, featureTableTagIndex);</span>




427   }
428 
<span class="line-modified">429   inline int get_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-modified">430   {</span>
<span class="line-removed">431     return baseScriptRecords[baseScriptIndex].get_min_value(baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">432   }</span>
433 
<span class="line-modified">434   inline bool sanitize (hb_sanitize_context_t *c) const</span>
435   {
436     TRACE_SANITIZE (this);
<span class="line-modified">437     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">438       baseScriptRecords.sanitize (c, this));</span>
439   }
440 
441   protected:
<span class="line-modified">442   HBUINT16                    baseScriptCount;</span>
<span class="line-modified">443   ArrayOf&lt;BaseScriptRecord&gt; baseScriptRecords;</span>


444 
445   public:
<span class="line-modified">446   DEFINE_SIZE_ARRAY (4, baseScriptRecords);</span>
<span class="line-removed">447 </span>
448 };
449 
<span class="line-modified">450 struct BaseTagList</span>
451 {








452 
<span class="line-modified">453   inline unsigned int get_tag_index(Tag baselineTag) const</span>

454   {
<span class="line-modified">455     for (unsigned int i = 0; i &lt; baseTagCount; i++)</span>
<span class="line-modified">456       if (baselineTags[i] == baselineTag)</span>
<span class="line-modified">457         return i;</span>
<span class="line-modified">458     return NOT_INDEXED;</span>
459   }
460 
<span class="line-modified">461   inline bool sanitize (hb_sanitize_context_t *c) const</span>
462   {
463     TRACE_SANITIZE (this);
<span class="line-modified">464     return_trace (c-&gt;check_struct (this));</span>

465   }
466 
467   protected:
<span class="line-modified">468   HBUINT16        baseTagCount;</span>
<span class="line-modified">469   SortedArrayOf&lt;Tag&gt;  baselineTags;</span>
470 
471   public:
<span class="line-modified">472   DEFINE_SIZE_ARRAY (4, baselineTags);</span>
473 };
474 
475 struct Axis
476 {
<span class="line-modified">477 </span>
<span class="line-modified">478   inline unsigned int get_base_tag_index(Tag baselineTag) const</span>


479   {
<span class="line-modified">480     if (unlikely(baseTagList == Null(OffsetTo&lt;BaseTagList&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">481     return (this+baseTagList).get_tag_index(baselineTag);</span>
<span class="line-removed">482   }</span>
483 
<span class="line-modified">484   inline unsigned int get_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">485   {</span>
<span class="line-removed">486     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">487     return (this+baseScriptList).get_default_base_tag_index(baseScriptIndex);</span>
<span class="line-removed">488   }</span>
<span class="line-removed">489 </span>
<span class="line-removed">490   inline int get_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">491   {</span>
<span class="line-removed">492     return (this+baseScriptList).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-removed">493   }</span>
494 
<span class="line-modified">495   inline unsigned int get_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">496   {</span>
<span class="line-removed">497     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">498     return (this+baseScriptList).get_lang_tag_index(baseScriptIndex, baseLangSysTag);</span>
499   }
500 
<span class="line-modified">501   inline unsigned int get_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>




502   {
<span class="line-modified">503     if (unlikely(baseScriptList == Null(OffsetTo&lt;BaseScriptList&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">504     return (this+baseScriptList).get_feature_tag_index(baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">505   }</span>
506 
<span class="line-modified">507   inline int get_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">508   {</span>
<span class="line-removed">509     return (this+baseScriptList).get_max_value(baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">510   }</span>
511 
<span class="line-modified">512   inline int get_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">513   {</span>
<span class="line-removed">514     return (this+baseScriptList).get_min_value(baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
515   }
516 
<span class="line-modified">517   inline bool sanitize (hb_sanitize_context_t *c) const</span>
518   {
519     TRACE_SANITIZE (this);
<span class="line-modified">520     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">521       baseTagList.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">522       baseScriptList.sanitize (c, this));</span>
523   }
524 
525   protected:
<span class="line-modified">526   OffsetTo&lt;BaseTagList&gt;     baseTagList;</span>
<span class="line-modified">527   OffsetTo&lt;BaseScriptList&gt;  baseScriptList;</span>








528 
529   public:
530   DEFINE_SIZE_STATIC (4);
531 };
532 
533 struct BASE
534 {
<span class="line-modified">535   static const hb_tag_t tableTag = HB_OT_TAG_BASE;</span>
<span class="line-removed">536 </span>
<span class="line-removed">537   inline bool has_vert_axis(void)</span>
<span class="line-removed">538   { return vertAxis != Null(OffsetTo&lt;Axis&gt;); }</span>
539 
<span class="line-modified">540   inline bool has_horiz_axis(void)</span>
<span class="line-modified">541   { return horizAxis != Null(OffsetTo&lt;Axis&gt;); }</span>
542 
<span class="line-modified">543   // horizontal axis base coords:</span>

544 
<span class="line-modified">545   inline unsigned int get_horiz_base_tag_index(Tag baselineTag) const</span>





546   {
<span class="line-modified">547     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">548     return (this+horizAxis).get_base_tag_index(baselineTag);</span>
<span class="line-modified">549   }</span>
550 
<span class="line-modified">551   inline unsigned int get_horiz_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-modified">552   {</span>
<span class="line-modified">553     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-modified">554     return (this+horizAxis).get_default_base_tag_index_for_script_index(baseScriptIndex);</span>
555   }
556 
<span class="line-modified">557   inline int get_horiz_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>







558   {
<span class="line-modified">559     return (this+horizAxis).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-modified">560   }</span>
<span class="line-modified">561 </span>
<span class="line-modified">562   // vertical axis base coords:</span>
<span class="line-removed">563 </span>
<span class="line-removed">564   inline unsigned int get_vert_base_tag_index(Tag baselineTag) const</span>
<span class="line-removed">565   {</span>
<span class="line-removed">566     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">567     return (this+vertAxis).get_base_tag_index(baselineTag);</span>
<span class="line-removed">568   }</span>
<span class="line-removed">569 </span>
<span class="line-removed">570   inline unsigned int get_vert_default_base_tag_index_for_script_index (unsigned int baseScriptIndex) const</span>
<span class="line-removed">571   {</span>
<span class="line-removed">572     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">573     return (this+vertAxis).get_default_base_tag_index_for_script_index(baseScriptIndex);</span>
<span class="line-removed">574   }</span>
<span class="line-removed">575 </span>
<span class="line-removed">576   inline int get_vert_base_coord(unsigned int baseScriptIndex, unsigned int baselineTagIndex) const</span>
<span class="line-removed">577   {</span>
<span class="line-removed">578     return (this+vertAxis).get_base_coord(baseScriptIndex, baselineTagIndex);</span>
<span class="line-removed">579   }</span>
<span class="line-removed">580 </span>
<span class="line-removed">581   // horizontal axis min/max coords:</span>
<span class="line-removed">582 </span>
<span class="line-removed">583   inline unsigned int get_horiz_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">584   {</span>
<span class="line-removed">585     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">586     return (this+horizAxis).get_lang_tag_index (baseScriptIndex, baseLangSysTag);</span>
<span class="line-removed">587   }</span>
<span class="line-removed">588 </span>
<span class="line-removed">589   inline unsigned int get_horiz_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">590   {</span>
<span class="line-removed">591     if (unlikely(horizAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">592     return (this+horizAxis).get_feature_tag_index (baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">593   }</span>
594 
<span class="line-modified">595   inline int get_horiz_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-modified">596   {</span>
<span class="line-modified">597     return (this+horizAxis).get_max_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-modified">598   }</span>
<span class="line-removed">599 </span>
<span class="line-removed">600   inline int get_horiz_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">601   {</span>
<span class="line-removed">602     return (this+horizAxis).get_min_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">603   }</span>
<span class="line-removed">604 </span>
<span class="line-removed">605     // vertical axis min/max coords:</span>
<span class="line-removed">606 </span>
<span class="line-removed">607   inline unsigned int get_vert_lang_tag_index (unsigned int baseScriptIndex, Tag baseLangSysTag) const</span>
<span class="line-removed">608   {</span>
<span class="line-removed">609     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">610     return (this+vertAxis).get_lang_tag_index (baseScriptIndex, baseLangSysTag);</span>
<span class="line-removed">611   }</span>
<span class="line-removed">612 </span>
<span class="line-removed">613   inline unsigned int get_vert_feature_tag_index (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, Tag featureTableTag) const</span>
<span class="line-removed">614   {</span>
<span class="line-removed">615     if (unlikely(vertAxis == Null(OffsetTo&lt;Axis&gt;))) return NOT_INDEXED;</span>
<span class="line-removed">616     return (this+vertAxis).get_feature_tag_index (baseScriptIndex, baseLangSysIndex, featureTableTag);</span>
<span class="line-removed">617   }</span>
<span class="line-removed">618 </span>
<span class="line-removed">619   inline int get_vert_max_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">620   {</span>
<span class="line-removed">621     return (this+vertAxis).get_max_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
622   }
623 
<span class="line-modified">624   inline int get_vert_min_value (unsigned int baseScriptIndex, unsigned int baseLangSysIndex, unsigned int featureTableTagIndex) const</span>
<span class="line-removed">625   {</span>
<span class="line-removed">626     return (this+vertAxis).get_min_value (baseScriptIndex, baseLangSysIndex, featureTableTagIndex);</span>
<span class="line-removed">627   }</span>
<span class="line-removed">628 </span>
<span class="line-removed">629   inline bool sanitize (hb_sanitize_context_t *c) const</span>
630   {
631     TRACE_SANITIZE (this);
<span class="line-modified">632     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">633                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-modified">634                   horizAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">635                   vertAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">636                   (version.to_int () &lt; 0x00010001u || varStore.sanitize (c, this)));</span>
637   }
638 
639   protected:
<span class="line-modified">640   FixedVersion&lt;&gt;  version;</span>
<span class="line-modified">641   OffsetTo&lt;Axis&gt;  horizAxis;</span>
<span class="line-modified">642   OffsetTo&lt;Axis&gt;  vertAxis;</span>


643   LOffsetTo&lt;VariationStore&gt;
<span class="line-modified">644                 varStore;               /* Offset to the table of Item Variation</span>
<span class="line-modified">645                                          * Store--from beginning of BASE</span>
<span class="line-modified">646                                          * header (may be NULL).  Introduced</span>
<span class="line-modified">647                                          * in version 0x00010001. */</span>
648   public:
649   DEFINE_SIZE_MIN (8);
650 };
651 
652 
653 } /* namespace OT */
654 
655 
656 #endif /* HB_OT_LAYOUT_BASE_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright © 2016 Elie Roux &lt;elie.roux@telecom-bretagne.eu&gt;
  3  * Copyright © 2018  Google, Inc.
<span class="line-added">  4  * Copyright © 2018  Ebrahim Byagowi</span>
  5  *
  6  *  This is part of HarfBuzz, a text shaping library.
  7  *
  8  * Permission is hereby granted, without written agreement and without
  9  * license or royalty fees, to use, copy, modify, and distribute this
 10  * software and its documentation for any purpose, provided that the
 11  * above copyright notice and the following two paragraphs appear in
 12  * all copies of this software.
 13  *
 14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 18  * DAMAGE.
 19  *
 20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 25  *
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_BASE_TABLE_HH
 30 #define HB_OT_LAYOUT_BASE_TABLE_HH
 31 
<span class="line-modified"> 32 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified"> 33 #include &quot;hb-ot-layout-common.hh&quot;</span>
 34 
<span class="line-modified"> 35 /* To be removed */</span>
<span class="line-added"> 36 typedef hb_tag_t hb_ot_layout_baseline_t;</span>
 37 
<span class="line-modified"> 38 namespace OT {</span>
 39 
 40 /*
 41  * BASE -- Baseline
 42  * https://docs.microsoft.com/en-us/typography/opentype/spec/base
 43  */
 44 
 45 struct BaseCoordFormat1
 46 {
<span class="line-modified"> 47   hb_position_t get_coord () const { return coordinate; }</span>
 48 
<span class="line-modified"> 49   bool sanitize (hb_sanitize_context_t *c) const</span>
 50   {
 51     TRACE_SANITIZE (this);
<span class="line-modified"> 52     return_trace (likely (c-&gt;check_struct (this)));</span>
 53   }
 54 
 55   protected:
 56   HBUINT16      format;         /* Format identifier--format = 1 */
<span class="line-modified"> 57   FWORD         coordinate;     /* X or Y value, in design units */</span>
 58   public:
 59   DEFINE_SIZE_STATIC (4);
 60 };
 61 
 62 struct BaseCoordFormat2
 63 {
<span class="line-modified"> 64   hb_position_t get_coord () const</span>
 65   {
 66     /* TODO */
 67     return coordinate;
 68   }
 69 
<span class="line-modified"> 70   bool sanitize (hb_sanitize_context_t *c) const</span>
 71   {
 72     TRACE_SANITIZE (this);
 73     return_trace (c-&gt;check_struct (this));
 74   }
 75 
 76   protected:
 77   HBUINT16      format;         /* Format identifier--format = 2 */
<span class="line-modified"> 78   FWORD         coordinate;     /* X or Y value, in design units */</span>
 79   GlyphID       referenceGlyph; /* Glyph ID of control glyph */
 80   HBUINT16      coordPoint;     /* Index of contour point on the
 81                                  * reference glyph */
 82   public:
 83   DEFINE_SIZE_STATIC (8);
 84 };
 85 
 86 struct BaseCoordFormat3
 87 {
<span class="line-modified"> 88   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added"> 89                            const VariationStore &amp;var_store,</span>
<span class="line-added"> 90                            hb_direction_t direction) const</span>
 91   {
<span class="line-modified"> 92     const Device &amp;device = this+deviceTable;</span>
<span class="line-modified"> 93     return coordinate + (HB_DIRECTION_IS_VERTICAL (direction) ?</span>
<span class="line-added"> 94                          device.get_y_delta (font, var_store) :</span>
<span class="line-added"> 95                          device.get_x_delta (font, var_store));</span>
 96   }
 97 
<span class="line-modified"> 98 </span>
<span class="line-added"> 99   bool sanitize (hb_sanitize_context_t *c) const</span>
100   {
101     TRACE_SANITIZE (this);
<span class="line-modified">102     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">103                           deviceTable.sanitize (c, this)));</span>
104   }
105 
106   protected:
<span class="line-modified">107   HBUINT16      format;         /* Format identifier--format = 3 */</span>
<span class="line-modified">108   FWORD         coordinate;     /* X or Y value, in design units */</span>
<span class="line-modified">109   OffsetTo&lt;Device&gt;</span>
<span class="line-modified">110                 deviceTable;    /* Offset to Device table for X or</span>
<span class="line-modified">111                                  * Y value, from beginning of</span>
<span class="line-added">112                                  * BaseCoord table (may be NULL). */</span>
113   public:
114   DEFINE_SIZE_STATIC (6);
115 };
116 
117 struct BaseCoord
118 {
<span class="line-modified">119   hb_position_t get_coord (hb_font_t *font,</span>
<span class="line-added">120                            const VariationStore &amp;var_store,</span>
<span class="line-added">121                            hb_direction_t direction) const</span>
122   {
123     switch (u.format) {
124     case 1: return u.format1.get_coord ();
125     case 2: return u.format2.get_coord ();
<span class="line-modified">126     case 3: return u.format3.get_coord (font, var_store, direction);</span>
127     default:return 0;
128     }
129   }
130 
<span class="line-modified">131   bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
<span class="line-modified">134     if (unlikely (!u.format.sanitize (c))) return_trace (false);</span>
135     switch (u.format) {
136     case 1: return_trace (u.format1.sanitize (c));
137     case 2: return_trace (u.format2.sanitize (c));
138     case 3: return_trace (u.format3.sanitize (c));
139     default:return_trace (false);
140     }
141   }
142 
143   protected:
144   union {
145     HBUINT16            format;
146     BaseCoordFormat1    format1;
147     BaseCoordFormat2    format2;
148     BaseCoordFormat3    format3;
149   } u;
150   public:
151   DEFINE_SIZE_UNION (2, format);
152 };
153 
154 struct FeatMinMaxRecord
155 {
<span class="line-modified">156   static int cmp (const void *key_, const void *entry_)</span>
<span class="line-modified">157   {</span>
<span class="line-modified">158     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">159     const FeatMinMaxRecord &amp;entry = * (const FeatMinMaxRecord *) entry_;</span>
<span class="line-modified">160     return key &lt; (unsigned int) entry.tag ? -1 :</span>
<span class="line-added">161            key &gt; (unsigned int) entry.tag ? 1 :</span>
<span class="line-added">162            0;</span>
<span class="line-added">163   }</span>
164 
<span class="line-modified">165   void get_min_max (const BaseCoord **min, const BaseCoord **max) const</span>
<span class="line-modified">166   {</span>
<span class="line-added">167     if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-added">168     if (likely (max)) *max = &amp;(this+maxCoord);</span>
<span class="line-added">169   }</span>
170 
<span class="line-modified">171   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
172   {
173     TRACE_SANITIZE (this);
<span class="line-modified">174     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">175                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">176                           maxCoord.sanitize (c, this)));</span>
177   }
178 
179   protected:
<span class="line-modified">180   Tag           tag;            /* 4-byte feature identification tag--must</span>
<span class="line-modified">181                                  * match feature tag in FeatureList */</span>
<span class="line-modified">182   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">183                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">184                                  * the minimum extent value, from beginning</span>
<span class="line-modified">185                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">186   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">187                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-added">188                                  * the maximum extent value, from beginning</span>
<span class="line-added">189                                  * of MinMax table (may be NULL) */</span>
190   public:
191   DEFINE_SIZE_STATIC (8);
192 
193 };
194 
195 struct MinMax
196 {
<span class="line-modified">197   void get_min_max (hb_tag_t          feature_tag,</span>
<span class="line-modified">198                            const BaseCoord **min,</span>
<span class="line-modified">199                            const BaseCoord **max) const</span>
<span class="line-modified">200   {</span>
<span class="line-modified">201     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">202     const FeatMinMaxRecord *minMaxCoord = (const FeatMinMaxRecord *)</span>
<span class="line-added">203                                           hb_bsearch (&amp;feature_tag, featMinMaxRecords.arrayZ,</span>
<span class="line-added">204                                                       featMinMaxRecords.len,</span>
<span class="line-added">205                                                       FeatMinMaxRecord::static_size,</span>
<span class="line-added">206                                                       FeatMinMaxRecord::cmp);</span>
<span class="line-added">207     if (minMaxCoord)</span>
<span class="line-added">208       minMaxCoord-&gt;get_min_max (min, max);</span>
<span class="line-added">209     else</span>
210     {
<span class="line-modified">211       if (likely (min)) *min = &amp;(this+minCoord);</span>
<span class="line-modified">212       if (likely (max)) *max = &amp;(this+maxCoord);</span>


213     }















214   }
215 
<span class="line-modified">216   bool sanitize (hb_sanitize_context_t *c) const</span>
217   {
218     TRACE_SANITIZE (this);
<span class="line-modified">219     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">220                           minCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">221                           maxCoord.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">222                           featMinMaxRecords.sanitize (c, this)));</span>
223   }
224 
225   protected:
<span class="line-modified">226   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">227                 minCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">228                                  * minimum extent value, from the beginning</span>
<span class="line-modified">229                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">230   OffsetTo&lt;BaseCoord&gt;</span>
<span class="line-modified">231                 maxCoord;       /* Offset to BaseCoord table that defines</span>
<span class="line-modified">232                                  * maximum extent value, from the beginning</span>
<span class="line-modified">233                                  * of MinMax table (may be NULL) */</span>
<span class="line-modified">234   SortedArrayOf&lt;FeatMinMaxRecord&gt;</span>
<span class="line-added">235                 featMinMaxRecords;</span>
<span class="line-added">236                                 /* Array of FeatMinMaxRecords, in alphabetical</span>
<span class="line-added">237                                  * order by featureTableTag */</span>
238   public:
239   DEFINE_SIZE_ARRAY (6, featMinMaxRecords);
240 };
241 






























242 struct BaseValues
243 {
<span class="line-modified">244   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>



245   {
<span class="line-modified">246     if (baseline_tag_index == -1) baseline_tag_index = defaultIndex;</span>
<span class="line-added">247     return this+baseCoords[baseline_tag_index];</span>
248   }
249 
<span class="line-modified">250   bool sanitize (hb_sanitize_context_t *c) const</span>
251   {
252     TRACE_SANITIZE (this);
<span class="line-modified">253     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">254                           baseCoords.sanitize (c, this)));</span>

255   }
256 
257   protected:
<span class="line-modified">258   Index         defaultIndex;   /* Index number of default baseline for this</span>
<span class="line-modified">259                                  * script — equals index position of baseline tag</span>
<span class="line-modified">260                                  * in baselineTags array of the BaseTagList */</span>
<span class="line-added">261   OffsetArrayOf&lt;BaseCoord&gt;</span>
<span class="line-added">262                 baseCoords;     /* Number of BaseCoord tables defined — should equal</span>
<span class="line-added">263                                  * baseTagCount in the BaseTagList</span>
<span class="line-added">264                                  *</span>
<span class="line-added">265                                  * Array of offsets to BaseCoord tables, from beginning of</span>
<span class="line-added">266                                  * BaseValues table — order matches baselineTags array in</span>
<span class="line-added">267                                  * the BaseTagList */</span>
268   public:
<span class="line-modified">269   DEFINE_SIZE_ARRAY (4, baseCoords);</span>

270 };
271 
<span class="line-modified">272 struct BaseLangSysRecord</span>
<span class="line-modified">273 {</span>
<span class="line-modified">274   static int cmp (const void *key_, const void *entry_)</span>































275   {
<span class="line-modified">276     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-modified">277     const BaseLangSysRecord &amp;entry = * (const BaseLangSysRecord *) entry_;</span>
<span class="line-modified">278     return key &lt; (unsigned int) entry.baseLangSysTag ? -1 :</span>
<span class="line-added">279            key &gt; (unsigned int) entry.baseLangSysTag ? 1 :</span>
<span class="line-added">280            0;</span>
281   }
282 
<span class="line-modified">283   const MinMax &amp;get_min_max () const</span>
<span class="line-modified">284   { return this+minMax; }</span>
285 
<span class="line-modified">286   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>



287   {
288     TRACE_SANITIZE (this);
<span class="line-modified">289     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">290                           minMax.sanitize (c, this)));</span>


291   }
292 
293   protected:
<span class="line-modified">294   Tag           baseLangSysTag; /* 4-byte language system identification tag */</span>
<span class="line-modified">295   OffsetTo&lt;MinMax&gt;</span>
<span class="line-modified">296                 minMax;         /* Offset to MinMax table, from beginning</span>
<span class="line-modified">297                                  * of BaseScript table */</span>

298   public:
<span class="line-modified">299   DEFINE_SIZE_STATIC (6);</span>
300 };
301 
<span class="line-added">302 struct BaseScript</span>
<span class="line-added">303 {</span>
<span class="line-added">304   const MinMax &amp;get_min_max (hb_tag_t language_tag) const</span>
<span class="line-added">305   {</span>
<span class="line-added">306     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">307     const BaseLangSysRecord* record = (const BaseLangSysRecord *)</span>
<span class="line-added">308                                       hb_bsearch (&amp;language_tag, baseLangSysRecords.arrayZ,</span>
<span class="line-added">309                                                   baseLangSysRecords.len,</span>
<span class="line-added">310                                                   BaseLangSysRecord::static_size,</span>
<span class="line-added">311                                                   BaseLangSysRecord::cmp);</span>
<span class="line-added">312     return record ? record-&gt;get_min_max () : this+defaultMinMax;</span>
<span class="line-added">313   }</span>
314 
<span class="line-modified">315   const BaseCoord &amp;get_base_coord (int baseline_tag_index) const</span>
<span class="line-modified">316   { return (this+baseValues).get_base_coord (baseline_tag_index); }</span>

















317 
<span class="line-modified">318   bool is_empty () const { return !baseValues; }</span>

319 
<span class="line-modified">320   bool sanitize (hb_sanitize_context_t *c) const</span>
321   {
322     TRACE_SANITIZE (this);
<span class="line-modified">323     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">324                           baseValues.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">325                           defaultMinMax.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">326                           baseLangSysRecords.sanitize (c, this)));</span>
327   }
328 
329   protected:
<span class="line-modified">330   OffsetTo&lt;BaseValues&gt;</span>
<span class="line-modified">331                 baseValues;     /* Offset to BaseValues table, from beginning</span>
<span class="line-added">332                                  * of BaseScript table (may be NULL) */</span>
<span class="line-added">333   OffsetTo&lt;MinMax&gt;</span>
<span class="line-added">334                 defaultMinMax;  /* Offset to MinMax table, from beginning of</span>
<span class="line-added">335                                  * BaseScript table (may be NULL) */</span>
<span class="line-added">336   SortedArrayOf&lt;BaseLangSysRecord&gt;</span>
<span class="line-added">337                 baseLangSysRecords;</span>
<span class="line-added">338                                 /* Number of BaseLangSysRecords</span>
<span class="line-added">339                                  * defined — may be zero (0) */</span>
340 
341   public:
<span class="line-modified">342   DEFINE_SIZE_ARRAY (6, baseLangSysRecords);</span>
343 };
344 
<span class="line-modified">345 struct BaseScriptList;</span>
<span class="line-modified">346 struct BaseScriptRecord</span>
<span class="line-modified">347 {</span>
<span class="line-modified">348   static int cmp (const void *key_, const void *entry_)</span>






























349   {
<span class="line-modified">350     hb_tag_t key = * (hb_tag_t *) key_;</span>
<span class="line-added">351     const BaseScriptRecord &amp;entry = * (const BaseScriptRecord *) entry_;</span>
<span class="line-added">352     return key &lt; (unsigned int) entry.baseScriptTag ? -1 :</span>
<span class="line-added">353            key &gt; (unsigned int) entry.baseScriptTag ? 1 :</span>
<span class="line-added">354            0;</span>
355   }
356 
<span class="line-modified">357   const BaseScript &amp;get_base_script (const BaseScriptList *list) const</span>
<span class="line-modified">358   { return list+baseScript; }</span>


359 
<span class="line-modified">360   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
361   {
362     TRACE_SANITIZE (this);
<span class="line-modified">363     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">364                           baseScript.sanitize (c, base)));</span>
365   }
366 
367   protected:
<span class="line-modified">368   Tag           baseScriptTag;  /* 4-byte script identification tag */</span>
<span class="line-modified">369   OffsetTo&lt;BaseScript&gt;</span>
<span class="line-added">370                 baseScript;     /* Offset to BaseScript table, from beginning</span>
<span class="line-added">371                                  * of BaseScriptList */</span>
372 
373   public:
<span class="line-modified">374   DEFINE_SIZE_STATIC (6);</span>

375 };
376 
<span class="line-modified">377 struct BaseScriptList</span>
378 {
<span class="line-added">379   const BaseScriptRecord *find_record (hb_tag_t script) const</span>
<span class="line-added">380   {</span>
<span class="line-added">381     /* TODO Replace hb_bsearch() with .bsearch(). */</span>
<span class="line-added">382     return (const BaseScriptRecord *) hb_bsearch (&amp;script, baseScriptRecords.arrayZ,</span>
<span class="line-added">383                                                   baseScriptRecords.len,</span>
<span class="line-added">384                                                   BaseScriptRecord::static_size,</span>
<span class="line-added">385                                                   BaseScriptRecord::cmp);</span>
<span class="line-added">386   }</span>
387 
<span class="line-modified">388   /* TODO: Or client should handle fallback? */</span>
<span class="line-added">389   const BaseScript &amp;get_base_script (hb_tag_t script) const</span>
390   {
<span class="line-modified">391     const BaseScriptRecord *record = find_record (script);</span>
<span class="line-modified">392     if (!record) record = find_record ((hb_script_t) HB_TAG (&#39;D&#39;,&#39;F&#39;,&#39;L&#39;,&#39;T&#39;));</span>
<span class="line-modified">393 </span>
<span class="line-modified">394     return record ? record-&gt;get_base_script (this) : Null (BaseScript);</span>
395   }
396 
<span class="line-modified">397   bool sanitize (hb_sanitize_context_t *c) const</span>
398   {
399     TRACE_SANITIZE (this);
<span class="line-modified">400     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-added">401                   baseScriptRecords.sanitize (c, this));</span>
402   }
403 
404   protected:
<span class="line-modified">405   SortedArrayOf&lt;BaseScriptRecord&gt;</span>
<span class="line-modified">406                         baseScriptRecords;</span>
407 
408   public:
<span class="line-modified">409   DEFINE_SIZE_ARRAY (2, baseScriptRecords);</span>
410 };
411 
412 struct Axis
413 {
<span class="line-modified">414   bool get_baseline (hb_ot_layout_baseline_t   baseline,</span>
<span class="line-modified">415                             hb_tag_t                  script_tag,</span>
<span class="line-added">416                             hb_tag_t                  language_tag,</span>
<span class="line-added">417                             const BaseCoord         **coord) const</span>
418   {
<span class="line-modified">419     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">420     if (base_script.is_empty ()) return false;</span>

421 
<span class="line-modified">422     if (likely (coord)) *coord = &amp;base_script.get_base_coord ((this+baseTagList).bsearch (baseline));</span>









423 
<span class="line-modified">424     return true;</span>



425   }
426 
<span class="line-modified">427   bool get_min_max (hb_tag_t          script_tag,</span>
<span class="line-added">428                     hb_tag_t          language_tag,</span>
<span class="line-added">429                     hb_tag_t          feature_tag,</span>
<span class="line-added">430                     const BaseCoord **min_coord,</span>
<span class="line-added">431                     const BaseCoord **max_coord) const</span>
432   {
<span class="line-modified">433     const BaseScript &amp;base_script = (this+baseScriptList).get_base_script (script_tag);</span>
<span class="line-modified">434     if (base_script.is_empty ()) return false;</span>

435 
<span class="line-modified">436     base_script.get_min_max (language_tag).get_min_max (feature_tag, min_coord, max_coord);</span>



437 
<span class="line-modified">438     return true;</span>


439   }
440 
<span class="line-modified">441   bool sanitize (hb_sanitize_context_t *c) const</span>
442   {
443     TRACE_SANITIZE (this);
<span class="line-modified">444     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">445                           (this+baseTagList).sanitize (c) &amp;&amp;</span>
<span class="line-modified">446                           (this+baseScriptList).sanitize (c)));</span>
447   }
448 
449   protected:
<span class="line-modified">450   OffsetTo&lt;SortedArrayOf&lt;Tag&gt; &gt;</span>
<span class="line-modified">451                 baseTagList;    /* Offset to BaseTagList table, from beginning</span>
<span class="line-added">452                                  * of Axis table (may be NULL)</span>
<span class="line-added">453                                  * Array of 4-byte baseline identification tags — must</span>
<span class="line-added">454                                  * be in alphabetical order */</span>
<span class="line-added">455   OffsetTo&lt;BaseScriptList&gt;</span>
<span class="line-added">456                 baseScriptList; /* Offset to BaseScriptList table, from beginning</span>
<span class="line-added">457                                  * of Axis table</span>
<span class="line-added">458                                  * Array of BaseScriptRecords, in alphabetical order</span>
<span class="line-added">459                                  * by baseScriptTag */</span>
460 
461   public:
462   DEFINE_SIZE_STATIC (4);
463 };
464 
465 struct BASE
466 {
<span class="line-modified">467   static constexpr hb_tag_t tableTag = HB_OT_TAG_BASE;</span>



468 
<span class="line-modified">469   const Axis &amp;get_axis (hb_direction_t direction) const</span>
<span class="line-modified">470   { return HB_DIRECTION_IS_VERTICAL (direction) ? this+vAxis : this+hAxis; }</span>
471 
<span class="line-modified">472   const VariationStore &amp;get_var_store () const</span>
<span class="line-added">473   { return version.to_int () &lt; 0x00010001u ? Null (VariationStore) : this+varStore; }</span>
474 
<span class="line-modified">475   bool get_baseline (hb_font_t               *font,</span>
<span class="line-added">476                      hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">477                      hb_direction_t           direction,</span>
<span class="line-added">478                      hb_tag_t                 script_tag,</span>
<span class="line-added">479                      hb_tag_t                 language_tag,</span>
<span class="line-added">480                      hb_position_t           *base) const</span>
481   {
<span class="line-modified">482     const BaseCoord *base_coord;</span>
<span class="line-modified">483     if (!get_axis (direction).get_baseline (baseline, script_tag, language_tag, &amp;base_coord))</span>
<span class="line-modified">484       return false;</span>
485 
<span class="line-modified">486     if (likely (base &amp;&amp; base_coord)) *base = base_coord-&gt;get_coord (font,</span>
<span class="line-modified">487                                                                     get_var_store (),</span>
<span class="line-modified">488                                                                     direction);</span>
<span class="line-modified">489     return true;</span>
490   }
491 
<span class="line-modified">492   /* TODO: Expose this separately sometime? */</span>
<span class="line-added">493   bool get_min_max (hb_font_t      *font,</span>
<span class="line-added">494                     hb_direction_t  direction,</span>
<span class="line-added">495                     hb_tag_t        script_tag,</span>
<span class="line-added">496                     hb_tag_t        language_tag,</span>
<span class="line-added">497                     hb_tag_t        feature_tag,</span>
<span class="line-added">498                     hb_position_t  *min,</span>
<span class="line-added">499                     hb_position_t  *max)</span>
500   {
<span class="line-modified">501     const BaseCoord *min_coord, *max_coord;</span>
<span class="line-modified">502     if (!get_axis (direction).get_min_max (script_tag, language_tag, feature_tag,</span>
<span class="line-modified">503                                            &amp;min_coord, &amp;max_coord))</span>
<span class="line-modified">504       return false;</span>































505 
<span class="line-modified">506     const VariationStore &amp;var_store = get_var_store ();</span>
<span class="line-modified">507     if (likely (min &amp;&amp; min_coord)) *min = min_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">508     if (likely (max &amp;&amp; max_coord)) *max = max_coord-&gt;get_coord (font, var_store, direction);</span>
<span class="line-modified">509     return true;</span>























510   }
511 
<span class="line-modified">512   bool sanitize (hb_sanitize_context_t *c) const</span>





513   {
514     TRACE_SANITIZE (this);
<span class="line-modified">515     return_trace (likely (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified">516                           likely (version.major == 1) &amp;&amp;</span>
<span class="line-modified">517                           hAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">518                           vAxis.sanitize (c, this) &amp;&amp;</span>
<span class="line-modified">519                           (version.to_int () &lt; 0x00010001u || varStore.sanitize (c, this))));</span>
520   }
521 
522   protected:
<span class="line-modified">523   FixedVersion&lt;&gt;version;        /* Version of the BASE table */</span>
<span class="line-modified">524   OffsetTo&lt;Axis&gt;hAxis;          /* Offset to horizontal Axis table, from beginning</span>
<span class="line-modified">525                                  * of BASE table (may be NULL) */</span>
<span class="line-added">526   OffsetTo&lt;Axis&gt;vAxis;          /* Offset to vertical Axis table, from beginning</span>
<span class="line-added">527                                  * of BASE table (may be NULL) */</span>
528   LOffsetTo&lt;VariationStore&gt;
<span class="line-modified">529                 varStore;       /* Offset to the table of Item Variation</span>
<span class="line-modified">530                                  * Store--from beginning of BASE</span>
<span class="line-modified">531                                  * header (may be NULL).  Introduced</span>
<span class="line-modified">532                                  * in version 0x00010001. */</span>
533   public:
534   DEFINE_SIZE_MIN (8);
535 };
536 
537 
538 } /* namespace OT */
539 
540 
541 #endif /* HB_OT_LAYOUT_BASE_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-kern-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gdef-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
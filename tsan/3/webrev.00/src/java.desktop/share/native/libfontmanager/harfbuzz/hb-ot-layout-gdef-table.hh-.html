<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright © 2007,2008,2009  Red Hat, Inc.
  3  * Copyright © 2010,2011,2012  Google, Inc.
  4  *
  5  *  This is part of HarfBuzz, a text shaping library.
  6  *
  7  * Permission is hereby granted, without written agreement and without
  8  * license or royalty fees, to use, copy, modify, and distribute this
  9  * software and its documentation for any purpose, provided that the
 10  * above copyright notice and the following two paragraphs appear in
 11  * all copies of this software.
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
 30 #define HB_OT_LAYOUT_GDEF_TABLE_HH
 31 
 32 #include &quot;hb-ot-layout-common-private.hh&quot;
 33 
 34 #include &quot;hb-font-private.hh&quot;
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 /*
 41  * Attachment List Table
 42  */
 43 
 44 typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
 45                                          * increasing numerical order */
 46 
 47 struct AttachList
 48 {
 49   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
 50                                          unsigned int start_offset,
 51                                          unsigned int *point_count /* IN/OUT */,
 52                                          unsigned int *point_array /* OUT */) const
 53   {
 54     unsigned int index = (this+coverage).get_coverage (glyph_id);
 55     if (index == NOT_COVERED)
 56     {
 57       if (point_count)
 58         *point_count = 0;
 59       return 0;
 60     }
 61 
 62     const AttachPoint &amp;points = this+attachPoint[index];
 63 
 64     if (point_count) {
 65       const HBUINT16 *array = points.sub_array (start_offset, point_count);
 66       unsigned int count = *point_count;
 67       for (unsigned int i = 0; i &lt; count; i++)
 68         point_array[i] = array[i];
 69     }
 70 
 71     return points.len;
 72   }
 73 
 74   inline bool sanitize (hb_sanitize_context_t *c) const
 75   {
 76     TRACE_SANITIZE (this);
 77     return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
 78   }
 79 
 80   protected:
 81   OffsetTo&lt;Coverage&gt;
 82                 coverage;               /* Offset to Coverage table -- from
 83                                          * beginning of AttachList table */
 84   OffsetArrayOf&lt;AttachPoint&gt;
 85                 attachPoint;            /* Array of AttachPoint tables
 86                                          * in Coverage Index order */
 87   public:
 88   DEFINE_SIZE_ARRAY (4, attachPoint);
 89 };
 90 
 91 /*
 92  * Ligature Caret Table
 93  */
 94 
 95 struct CaretValueFormat1
 96 {
 97   friend struct CaretValue;
 98 
 99   private:
100   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const
101   {
102     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
103   }
104 
105   inline bool sanitize (hb_sanitize_context_t *c) const
106   {
107     TRACE_SANITIZE (this);
108     return_trace (c-&gt;check_struct (this));
109   }
110 
111   protected:
112   HBUINT16      caretValueFormat;       /* Format identifier--format = 1 */
113   FWORD         coordinate;             /* X or Y value, in design units */
114   public:
115   DEFINE_SIZE_STATIC (4);
116 };
117 
118 struct CaretValueFormat2
119 {
120   friend struct CaretValue;
121 
122   private:
123   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const
124   {
125     hb_position_t x, y;
126     if (font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y))
127       return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;
128     else
129       return 0;
130   }
131 
132   inline bool sanitize (hb_sanitize_context_t *c) const
133   {
134     TRACE_SANITIZE (this);
135     return_trace (c-&gt;check_struct (this));
136   }
137 
138   protected:
139   HBUINT16      caretValueFormat;       /* Format identifier--format = 2 */
140   HBUINT16      caretValuePoint;        /* Contour point index on glyph */
141   public:
142   DEFINE_SIZE_STATIC (4);
143 };
144 
145 struct CaretValueFormat3
146 {
147   friend struct CaretValue;
148 
149   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, const VariationStore &amp;var_store) const
150   {
151     return HB_DIRECTION_IS_HORIZONTAL (direction) ?
152            font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
153            font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
154   }
155 
156   inline bool sanitize (hb_sanitize_context_t *c) const
157   {
158     TRACE_SANITIZE (this);
159     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
160   }
161 
162   protected:
163   HBUINT16      caretValueFormat;       /* Format identifier--format = 3 */
164   FWORD         coordinate;             /* X or Y value, in design units */
165   OffsetTo&lt;Device&gt;
166                 deviceTable;            /* Offset to Device table for X or Y
167                                          * value--from beginning of CaretValue
168                                          * table */
169   public:
170   DEFINE_SIZE_STATIC (6);
171 };
172 
173 struct CaretValue
174 {
175   inline hb_position_t get_caret_value (hb_font_t *font,
176                                         hb_direction_t direction,
177                                         hb_codepoint_t glyph_id,
178                                         const VariationStore &amp;var_store) const
179   {
180     switch (u.format) {
181     case 1: return u.format1.get_caret_value (font, direction);
182     case 2: return u.format2.get_caret_value (font, direction, glyph_id);
183     case 3: return u.format3.get_caret_value (font, direction, var_store);
184     default:return 0;
185     }
186   }
187 
188   inline bool sanitize (hb_sanitize_context_t *c) const
189   {
190     TRACE_SANITIZE (this);
191     if (!u.format.sanitize (c)) return_trace (false);
192     switch (u.format) {
193     case 1: return_trace (u.format1.sanitize (c));
194     case 2: return_trace (u.format2.sanitize (c));
195     case 3: return_trace (u.format3.sanitize (c));
196     default:return_trace (true);
197     }
198   }
199 
200   protected:
201   union {
202   HBUINT16              format;         /* Format identifier */
203   CaretValueFormat1     format1;
204   CaretValueFormat2     format2;
205   CaretValueFormat3     format3;
206   } u;
207   public:
208   DEFINE_SIZE_UNION (2, format);
209 };
210 
211 struct LigGlyph
212 {
213   inline unsigned int get_lig_carets (hb_font_t *font,
214                                       hb_direction_t direction,
215                                       hb_codepoint_t glyph_id,
216                                       const VariationStore &amp;var_store,
217                                       unsigned int start_offset,
218                                       unsigned int *caret_count /* IN/OUT */,
219                                       hb_position_t *caret_array /* OUT */) const
220   {
221     if (caret_count) {
222       const OffsetTo&lt;CaretValue&gt; *array = carets.sub_array (start_offset, caret_count);
223       unsigned int count = *caret_count;
224       for (unsigned int i = 0; i &lt; count; i++)
225         caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
226     }
227 
228     return carets.len;
229   }
230 
231   inline bool sanitize (hb_sanitize_context_t *c) const
232   {
233     TRACE_SANITIZE (this);
234     return_trace (carets.sanitize (c, this));
235   }
236 
237   protected:
238   OffsetArrayOf&lt;CaretValue&gt;
239                 carets;                 /* Offset array of CaretValue tables
240                                          * --from beginning of LigGlyph table
241                                          * --in increasing coordinate order */
242   public:
243   DEFINE_SIZE_ARRAY (2, carets);
244 };
245 
246 struct LigCaretList
247 {
248   inline unsigned int get_lig_carets (hb_font_t *font,
249                                       hb_direction_t direction,
250                                       hb_codepoint_t glyph_id,
251                                       const VariationStore &amp;var_store,
252                                       unsigned int start_offset,
253                                       unsigned int *caret_count /* IN/OUT */,
254                                       hb_position_t *caret_array /* OUT */) const
255   {
256     unsigned int index = (this+coverage).get_coverage (glyph_id);
257     if (index == NOT_COVERED)
258     {
259       if (caret_count)
260         *caret_count = 0;
261       return 0;
262     }
263     const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
264     return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
265   }
266 
267   inline bool sanitize (hb_sanitize_context_t *c) const
268   {
269     TRACE_SANITIZE (this);
270     return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
271   }
272 
273   protected:
274   OffsetTo&lt;Coverage&gt;
275                 coverage;               /* Offset to Coverage table--from
276                                          * beginning of LigCaretList table */
277   OffsetArrayOf&lt;LigGlyph&gt;
278                 ligGlyph;               /* Array of LigGlyph tables
279                                          * in Coverage Index order */
280   public:
281   DEFINE_SIZE_ARRAY (4, ligGlyph);
282 };
283 
284 
285 struct MarkGlyphSetsFormat1
286 {
287   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
288   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
289 
290   inline bool sanitize (hb_sanitize_context_t *c) const
291   {
292     TRACE_SANITIZE (this);
293     return_trace (coverage.sanitize (c, this));
294   }
295 
296   protected:
297   HBUINT16      format;                 /* Format identifier--format = 1 */
298   ArrayOf&lt;LOffsetTo&lt;Coverage&gt; &gt;
299                 coverage;               /* Array of long offsets to mark set
300                                          * coverage tables */
301   public:
302   DEFINE_SIZE_ARRAY (4, coverage);
303 };
304 
305 struct MarkGlyphSets
306 {
307   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const
308   {
309     switch (u.format) {
310     case 1: return u.format1.covers (set_index, glyph_id);
311     default:return false;
312     }
313   }
314 
315   inline bool sanitize (hb_sanitize_context_t *c) const
316   {
317     TRACE_SANITIZE (this);
318     if (!u.format.sanitize (c)) return_trace (false);
319     switch (u.format) {
320     case 1: return_trace (u.format1.sanitize (c));
321     default:return_trace (true);
322     }
323   }
324 
325   protected:
326   union {
327   HBUINT16              format;         /* Format identifier */
328   MarkGlyphSetsFormat1  format1;
329   } u;
330   public:
331   DEFINE_SIZE_UNION (2, format);
332 };
333 
334 
335 /*
336  * GDEF -- Glyph Definition
337  * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
338  */
339 
340 struct GDEF
341 {
342   static const hb_tag_t tableTag        = HB_OT_TAG_GDEF;
343 
344   enum GlyphClasses {
345     UnclassifiedGlyph   = 0,
346     BaseGlyph           = 1,
347     LigatureGlyph       = 2,
348     MarkGlyph           = 3,
349     ComponentGlyph      = 4
350   };
351 
352   inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }
353   inline unsigned int get_glyph_class (hb_codepoint_t glyph) const
354   { return (this+glyphClassDef).get_class (glyph); }
355   inline void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const
356   { (this+glyphClassDef).add_class (glyphs, klass); }
357 
358   inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }
359   inline unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const
360   { return (this+markAttachClassDef).get_class (glyph); }
361 
362   inline bool has_attach_points (void) const { return attachList != 0; }
363   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,
364                                          unsigned int start_offset,
365                                          unsigned int *point_count /* IN/OUT */,
366                                          unsigned int *point_array /* OUT */) const
367   { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
368 
369   inline bool has_lig_carets (void) const { return ligCaretList != 0; }
370   inline unsigned int get_lig_carets (hb_font_t *font,
371                                       hb_direction_t direction,
372                                       hb_codepoint_t glyph_id,
373                                       unsigned int start_offset,
374                                       unsigned int *caret_count /* IN/OUT */,
375                                       hb_position_t *caret_array /* OUT */) const
376   { return (this+ligCaretList).get_lig_carets (font,
377                                                direction, glyph_id, get_var_store(),
378                                                start_offset, caret_count, caret_array); }
379 
380   inline bool has_mark_sets (void) const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }
381   inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const
382   { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
383 
384   inline bool has_var_store (void) const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }
385   inline const VariationStore &amp;get_var_store (void) const
386   { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
387 
388   inline bool sanitize (hb_sanitize_context_t *c) const
389   {
390     TRACE_SANITIZE (this);
391     return_trace (version.sanitize (c) &amp;&amp;
392                   likely (version.major == 1) &amp;&amp;
393                   glyphClassDef.sanitize (c, this) &amp;&amp;
394                   attachList.sanitize (c, this) &amp;&amp;
395                   ligCaretList.sanitize (c, this) &amp;&amp;
396                   markAttachClassDef.sanitize (c, this) &amp;&amp;
397                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;
398                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));
399   }
400 
401   /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
402    * glyph class and other bits, and high 8-bit gthe mark attachment type (if any).
403    * Not to be confused with lookup_props which is very similar. */
404   inline unsigned int get_glyph_props (hb_codepoint_t glyph) const
405   {
406     unsigned int klass = get_glyph_class (glyph);
407 
408     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
409     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
410     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), &quot;&quot;);
411 
412     switch (klass) {
413     default:                    return 0;
414     case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;
415     case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;
416     case MarkGlyph:
417           klass = get_mark_attachment_type (glyph);
418           return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
419     }
420   }
421 
422 
423   protected:
424   FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
425                                          * 0x00010003u */
426   OffsetTo&lt;ClassDef&gt;
427                 glyphClassDef;          /* Offset to class definition table
428                                          * for glyph type--from beginning of
429                                          * GDEF header (may be Null) */
430   OffsetTo&lt;AttachList&gt;
431                 attachList;             /* Offset to list of glyphs with
432                                          * attachment points--from beginning
433                                          * of GDEF header (may be Null) */
434   OffsetTo&lt;LigCaretList&gt;
435                 ligCaretList;           /* Offset to list of positioning points
436                                          * for ligature carets--from beginning
437                                          * of GDEF header (may be Null) */
438   OffsetTo&lt;ClassDef&gt;
439                 markAttachClassDef;     /* Offset to class definition table for
440                                          * mark attachment type--from beginning
441                                          * of GDEF header (may be Null) */
442   OffsetTo&lt;MarkGlyphSets&gt;
443                 markGlyphSetsDef;       /* Offset to the table of mark set
444                                          * definitions--from beginning of GDEF
445                                          * header (may be NULL).  Introduced
446                                          * in version 0x00010002. */
447   LOffsetTo&lt;VariationStore&gt;
448                 varStore;               /* Offset to the table of Item Variation
449                                          * Store--from beginning of GDEF
450                                          * header (may be NULL).  Introduced
451                                          * in version 0x00010003. */
452   public:
453   DEFINE_SIZE_MIN (12);
454 };
455 
456 
457 } /* namespace OT */
458 
459 
460 #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
    </pre>
  </body>
</html>
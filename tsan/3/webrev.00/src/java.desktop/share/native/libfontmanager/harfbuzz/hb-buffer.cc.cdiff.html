<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-buffer-serialize.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 25,24 ***</span>
   *
   * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-buffer-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-utf-private.hh&quot;</span>
  
  
  /**
   * SECTION: hb-buffer
<span class="line-modified">!  * @title: Buffers</span>
   * @short_description: Input and output buffers
   * @include: hb.h
   *
   * Buffers serve dual role in HarfBuzz; they hold the input characters that are
<span class="line-modified">!  * passed hb_shape(), and after shaping they hold the output glyphs.</span>
   **/
  
  /**
   * hb_segment_properties_equal:
   * @a: first #hb_segment_properties_t to compare.
   * @b: second #hb_segment_properties_t to compare.
   *
<span class="line-new-header">--- 25,25 ---</span>
   *
   * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-buffer.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-utf.hh&quot;</span>
  
  
  /**
   * SECTION: hb-buffer
<span class="line-modified">!  * @title: hb-buffer</span>
   * @short_description: Input and output buffers
   * @include: hb.h
   *
   * Buffers serve dual role in HarfBuzz; they hold the input characters that are
<span class="line-modified">!  * passed to hb_shape(), and after shaping they hold the output glyphs.</span>
   **/
  
<span class="line-added">+ </span>
  /**
   * hb_segment_properties_equal:
   * @a: first #hb_segment_properties_t to compare.
   * @b: second #hb_segment_properties_t to compare.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 122,18 ***</span>
    unsigned int new_allocated = allocated;
    hb_glyph_position_t *new_pos = nullptr;
    hb_glyph_info_t *new_info = nullptr;
    bool separate_out = out_info != info;
  
<span class="line-modified">!   if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))</span>
      goto done;
  
    while (size &gt;= new_allocated)
      new_allocated += (new_allocated &gt;&gt; 1) + 32;
  
    static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
<span class="line-modified">!   if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))</span>
      goto done;
  
    new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
    new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
  
<span class="line-new-header">--- 123,18 ---</span>
    unsigned int new_allocated = allocated;
    hb_glyph_position_t *new_pos = nullptr;
    hb_glyph_info_t *new_info = nullptr;
    bool separate_out = out_info != info;
  
<span class="line-modified">!   if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))</span>
      goto done;
  
    while (size &gt;= new_allocated)
      new_allocated += (new_allocated &gt;&gt; 1) + 32;
  
    static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
<span class="line-modified">!   if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))</span>
      goto done;
  
    new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
    new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 180,11 ***</span>
  
    memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
    if (idx + count &gt; len)
    {
      /* Under memory failure we might expose this area.  At least
<span class="line-modified">!      * clean it up.  Oh well... */</span>
      memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
    }
    len += count;
    idx += count;
  
<span class="line-new-header">--- 181,15 ---</span>
  
    memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
    if (idx + count &gt; len)
    {
      /* Under memory failure we might expose this area.  At least
<span class="line-modified">!      * clean it up.  Oh well...</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * Ideally, we should at least set Default_Ignorable bits on</span>
<span class="line-added">+      * these, as well as consistent cluster values.  But the former</span>
<span class="line-added">+      * is layering violation... */</span>
      memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
    }
    len += count;
    idx += count;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,27 ***</span>
  
  
  /* HarfBuzz-Internal API */
  
  void
<span class="line-modified">! hb_buffer_t::reset (void)</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (this)))</span>
      return;
  
    hb_unicode_funcs_destroy (unicode);
<span class="line-modified">!   unicode = hb_unicode_funcs_get_default ();</span>
    flags = HB_BUFFER_FLAG_DEFAULT;
    replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;
  
    clear ();
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear (void)</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (this)))</span>
      return;
  
    hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
    props = default_props;
    scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<span class="line-new-header">--- 213,28 ---</span>
  
  
  /* HarfBuzz-Internal API */
  
  void
<span class="line-modified">! hb_buffer_t::reset ()</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    hb_unicode_funcs_destroy (unicode);
<span class="line-modified">!   unicode = hb_unicode_funcs_reference (hb_unicode_funcs_get_default ());</span>
    flags = HB_BUFFER_FLAG_DEFAULT;
    replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;
<span class="line-added">+   invisible = 0;</span>
  
    clear ();
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear ()</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
    props = default_props;
    scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 279,39 ***</span>
    len++;
  }
  
  
  void
<span class="line-modified">! hb_buffer_t::remove_output (void)</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (this)))</span>
      return;
  
    have_output = false;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear_output (void)</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (this)))</span>
      return;
  
    have_output = true;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear_positions (void)</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (this)))</span>
      return;
  
    have_output = false;
    have_positions = true;
  
<span class="line-new-header">--- 285,39 ---</span>
    len++;
  }
  
  
  void
<span class="line-modified">! hb_buffer_t::remove_output ()</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = false;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear_output ()</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = true;
    have_positions = false;
  
    out_len = 0;
    out_info = info;
  }
  
  void
<span class="line-modified">! hb_buffer_t::clear_positions ()</span>
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (this)))</span>
      return;
  
    have_output = false;
    have_positions = true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,11 ***</span>
  
    memset (pos, 0, sizeof (pos[0]) * len);
  }
  
  void
<span class="line-modified">! hb_buffer_t::swap_buffers (void)</span>
  {
    if (unlikely (!successful)) return;
  
    assert (have_output);
    have_output = false;
<span class="line-new-header">--- 326,11 ---</span>
  
    memset (pos, 0, sizeof (pos[0]) * len);
  }
  
  void
<span class="line-modified">! hb_buffer_t::swap_buffers ()</span>
  {
    if (unlikely (!successful)) return;
  
    assert (have_output);
    have_output = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 352,10 ***</span>
<span class="line-new-header">--- 358,12 ---</span>
                               unsigned int num_out,
                               const uint32_t *glyph_data)
  {
    if (unlikely (!make_room_for (num_in, num_out))) return;
  
<span class="line-added">+   assert (idx + num_in &lt;= len);</span>
<span class="line-added">+ </span>
    merge_clusters (idx, idx + num_in);
  
    hb_glyph_info_t orig_info = info[idx];
    hb_glyph_info_t *pinfo = &amp;out_info[out_len];
    for (unsigned int i = 0; i &lt; num_out; i++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 367,41 ***</span>
  
    idx  += num_in;
    out_len += num_out;
  }
  
<span class="line-removed">- void</span>
<span class="line-removed">- hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_info[out_len] = info[idx];</span>
<span class="line-removed">-   out_info[out_len].codepoint = glyph_index;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_len++;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void</span>
<span class="line-removed">- hb_buffer_t::output_info (const hb_glyph_info_t &amp;glyph_info)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_info[out_len] = glyph_info;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_len++;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void</span>
<span class="line-removed">- hb_buffer_t::copy_glyph (void)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (unlikely (!make_room_for (0, 1))) return;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_info[out_len] = info[idx];</span>
<span class="line-removed">- </span>
<span class="line-removed">-   out_len++;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  bool
  hb_buffer_t::move_to (unsigned int i)
  {
    if (!have_output)
    {
<span class="line-new-header">--- 375,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,12 ***</span>
    {
      /* Tricky part: rewinding... */
      unsigned int count = out_len - i;
  
      /* This will blow in our face if memory allocation fails later
<span class="line-modified">!      * in this same lookup... */</span>
<span class="line-modified">!     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 32))) return false;</span>
  
      assert (idx &gt;= count);
  
      idx -= count;
      out_len -= count;
<span class="line-new-header">--- 404,18 ---</span>
    {
      /* Tricky part: rewinding... */
      unsigned int count = out_len - i;
  
      /* This will blow in our face if memory allocation fails later
<span class="line-modified">!      * in this same lookup...</span>
<span class="line-modified">!      *</span>
<span class="line-added">+      * We used to shift with extra 32 items, instead of the 0 below.</span>
<span class="line-added">+      * But that would leave empty slots in the buffer in case of allocation</span>
<span class="line-added">+      * failures.  Setting to zero for now to avoid other problems (see</span>
<span class="line-added">+      * comments in shift_forward().  This can cause O(N^2) behavior more</span>
<span class="line-added">+      * severely than adding 32 empty slots can... */</span>
<span class="line-added">+     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 0))) return false;</span>
  
      assert (idx &gt;= count);
  
      idx -= count;
      out_len -= count;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 440,23 ***</span>
    }
  
    return true;
  }
  
<span class="line-removed">- void</span>
<span class="line-removed">- hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   if (unlikely (out_info != info || out_len != idx)) {</span>
<span class="line-removed">-     if (unlikely (!make_room_for (1, 1))) return;</span>
<span class="line-removed">-     out_info[out_len] = info[idx];</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   out_info[out_len].codepoint = glyph_index;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   idx++;</span>
<span class="line-removed">-   out_len++;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  
  void
  hb_buffer_t::set_masks (hb_mask_t    value,
                          hb_mask_t    mask,
                          unsigned int cluster_start,
<span class="line-new-header">--- 423,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 508,20 ***</span>
      }
    }
  }
  
  void
<span class="line-modified">! hb_buffer_t::reverse (void)</span>
  {
    if (unlikely (!len))
      return;
  
    reverse_range (0, len);
  }
  
  void
<span class="line-modified">! hb_buffer_t::reverse_clusters (void)</span>
  {
    unsigned int i, start, count, last_cluster;
  
    if (unlikely (!len))
      return;
<span class="line-new-header">--- 478,20 ---</span>
      }
    }
  }
  
  void
<span class="line-modified">! hb_buffer_t::reverse ()</span>
  {
    if (unlikely (!len))
      return;
  
    reverse_range (0, len);
  }
  
  void
<span class="line-modified">! hb_buffer_t::reverse_clusters ()</span>
  {
    unsigned int i, start, count, last_cluster;
  
    if (unlikely (!len))
      return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 664,11 ***</span>
    _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
    _unsafe_to_break_set_mask (info, idx, end, cluster);
  }
  
  void
<span class="line-modified">! hb_buffer_t::guess_segment_properties (void)</span>
  {
    assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
    /* If script is set to INVALID, guess from buffer contents */
<span class="line-new-header">--- 634,11 ---</span>
    _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
    _unsafe_to_break_set_mask (info, idx, end, cluster);
  }
  
  void
<span class="line-modified">! hb_buffer_t::guess_segment_properties ()</span>
  {
    assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
    /* If script is set to INVALID, guess from buffer contents */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 699,10 ***</span>
<span class="line-new-header">--- 669,33 ---</span>
  }
  
  
  /* Public API */
  
<span class="line-added">+ DEFINE_NULL_INSTANCE (hb_buffer_t) =</span>
<span class="line-added">+ {</span>
<span class="line-added">+   HB_OBJECT_HEADER_STATIC,</span>
<span class="line-added">+ </span>
<span class="line-added">+   const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_Null_hb_unicode_funcs_t),</span>
<span class="line-added">+   HB_BUFFER_FLAG_DEFAULT,</span>
<span class="line-added">+   HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="line-added">+   HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="line-added">+   0, /* invisible */</span>
<span class="line-added">+   HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="line-added">+   HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="line-added">+   HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="line-added">+ </span>
<span class="line-added">+   HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="line-added">+   HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="line-added">+   false, /* successful */</span>
<span class="line-added">+   true, /* have_output */</span>
<span class="line-added">+   true  /* have_positions */</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Zero is good enough for everything else. */</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  /**
   * hb_buffer_create: (Xconstructor)
   *
   * Creates a new #hb_buffer_t with all properties to defaults.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,11 ***</span>
   * hb_buffer_allocation_successful() returns %false.
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="line-modified">! hb_buffer_create (void)</span>
  {
    hb_buffer_t *buffer;
  
    if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
      return hb_buffer_get_empty ();
<span class="line-new-header">--- 707,11 ---</span>
   * hb_buffer_allocation_successful() returns %false.
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="line-modified">! hb_buffer_create ()</span>
  {
    hb_buffer_t *buffer;
  
    if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
      return hb_buffer_get_empty ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 739,33 ***</span>
   * Return value: (transfer full):
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="line-modified">! hb_buffer_get_empty (void)</span>
  {
<span class="line-modified">!   static const hb_buffer_t _hb_buffer_nil = {</span>
<span class="line-removed">-     HB_OBJECT_HEADER_STATIC,</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_unicode_funcs_nil),</span>
<span class="line-removed">-     HB_BUFFER_FLAG_DEFAULT,</span>
<span class="line-removed">-     HB_BUFFER_CLUSTER_LEVEL_DEFAULT,</span>
<span class="line-removed">-     HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,</span>
<span class="line-removed">-     HB_BUFFER_SCRATCH_FLAG_DEFAULT,</span>
<span class="line-removed">-     HB_BUFFER_MAX_LEN_DEFAULT,</span>
<span class="line-removed">-     HB_BUFFER_MAX_OPS_DEFAULT,</span>
<span class="line-removed">- </span>
<span class="line-removed">-     HB_BUFFER_CONTENT_TYPE_INVALID,</span>
<span class="line-removed">-     HB_SEGMENT_PROPERTIES_DEFAULT,</span>
<span class="line-removed">-     false, /* successful */</span>
<span class="line-removed">-     true, /* have_output */</span>
<span class="line-removed">-     true  /* have_positions */</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* Zero is good enough for everything else. */</span>
<span class="line-removed">-   };</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return const_cast&lt;hb_buffer_t *&gt; (&amp;_hb_buffer_nil);</span>
  }
  
  /**
   * hb_buffer_reference: (skip)
   * @buffer: an #hb_buffer_t.
<span class="line-new-header">--- 732,13 ---</span>
   * Return value: (transfer full):
   *
   * Since: 0.9.2
   **/
  hb_buffer_t *
<span class="line-modified">! hb_buffer_get_empty ()</span>
  {
<span class="line-modified">!   return const_cast&lt;hb_buffer_t *&gt; (&amp;Null(hb_buffer_t));</span>
  }
  
  /**
   * hb_buffer_reference: (skip)
   * @buffer: an #hb_buffer_t.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 898,17 ***</span>
   **/
  void
  hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
                               hb_unicode_funcs_t *unicode_funcs)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    if (!unicode_funcs)
      unicode_funcs = hb_unicode_funcs_get_default ();
  
<span class="line-removed">- </span>
    hb_unicode_funcs_reference (unicode_funcs);
    hb_unicode_funcs_destroy (buffer-&gt;unicode);
    buffer-&gt;unicode = unicode_funcs;
  }
  
<span class="line-new-header">--- 871,16 ---</span>
   **/
  void
  hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
                               hb_unicode_funcs_t *unicode_funcs)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    if (!unicode_funcs)
      unicode_funcs = hb_unicode_funcs_get_default ();
  
    hb_unicode_funcs_reference (unicode_funcs);
    hb_unicode_funcs_destroy (buffer-&gt;unicode);
    buffer-&gt;unicode = unicode_funcs;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,11 ***</span>
  void
  hb_buffer_set_direction (hb_buffer_t    *buffer,
                           hb_direction_t  direction)
  
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;props.direction = direction;
  }
  
<span class="line-new-header">--- 918,11 ---</span>
  void
  hb_buffer_set_direction (hb_buffer_t    *buffer,
                           hb_direction_t  direction)
  
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.direction = direction;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,11 ***</span>
   **/
  void
  hb_buffer_set_script (hb_buffer_t *buffer,
                        hb_script_t  script)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;props.script = script;
  }
  
<span class="line-new-header">--- 962,11 ---</span>
   **/
  void
  hb_buffer_set_script (hb_buffer_t *buffer,
                        hb_script_t  script)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.script = script;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1025,20 ***</span>
   * Languages are crucial for selecting which OpenType feature to apply to the
   * buffer which can result in applying language-specific behaviour. Languages
   * are orthogonal to the scripts, and though they are related, they are
   * different concepts and should not be confused with each other.
   *
<span class="line-modified">!  * Use hb_language_from_string() to convert from ISO 639 language codes to</span>
   * #hb_language_t.
   *
   * Since: 0.9.2
   **/
  void
  hb_buffer_set_language (hb_buffer_t   *buffer,
                          hb_language_t  language)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;props.language = language;
  }
  
<span class="line-new-header">--- 997,20 ---</span>
   * Languages are crucial for selecting which OpenType feature to apply to the
   * buffer which can result in applying language-specific behaviour. Languages
   * are orthogonal to the scripts, and though they are related, they are
   * different concepts and should not be confused with each other.
   *
<span class="line-modified">!  * Use hb_language_from_string() to convert from BCP 47 language tags to</span>
   * #hb_language_t.
   *
   * Since: 0.9.2
   **/
  void
  hb_buffer_set_language (hb_buffer_t   *buffer,
                          hb_language_t  language)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props.language = language;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1072,11 ***</span>
   **/
  void
  hb_buffer_set_segment_properties (hb_buffer_t *buffer,
                                    const hb_segment_properties_t *props)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;props = *props;
  }
  
<span class="line-new-header">--- 1044,11 ---</span>
   **/
  void
  hb_buffer_set_segment_properties (hb_buffer_t *buffer,
                                    const hb_segment_properties_t *props)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;props = *props;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1108,11 ***</span>
   **/
  void
  hb_buffer_set_flags (hb_buffer_t       *buffer,
                       hb_buffer_flags_t  flags)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;flags = flags;
  }
  
<span class="line-new-header">--- 1080,11 ---</span>
   **/
  void
  hb_buffer_set_flags (hb_buffer_t       *buffer,
                       hb_buffer_flags_t  flags)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;flags = flags;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1144,11 ***</span>
   **/
  void
  hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
                       hb_buffer_cluster_level_t  cluster_level)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;cluster_level = cluster_level;
  }
  
<span class="line-new-header">--- 1116,11 ---</span>
   **/
  void
  hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
                       hb_buffer_cluster_level_t  cluster_level)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;cluster_level = cluster_level;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1183,11 ***</span>
   **/
  void
  hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
                                       hb_codepoint_t  replacement)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    buffer-&gt;replacement = replacement;
  }
  
<span class="line-new-header">--- 1155,11 ---</span>
   **/
  void
  hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
                                       hb_codepoint_t  replacement)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    buffer-&gt;replacement = replacement;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1207,10 ***</span>
<span class="line-new-header">--- 1179,50 ---</span>
  {
    return buffer-&gt;replacement;
  }
  
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_buffer_set_invisible_glyph:</span>
<span class="line-added">+  * @buffer: an #hb_buffer_t.</span>
<span class="line-added">+  * @invisible: the invisible #hb_codepoint_t</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Sets the #hb_codepoint_t that replaces invisible characters in</span>
<span class="line-added">+  * the shaping result.  If set to zero (default), the glyph for the</span>
<span class="line-added">+  * U+0020 SPACE character is used.  Otherwise, this value is used</span>
<span class="line-added">+  * verbatim.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,</span>
<span class="line-added">+                                hb_codepoint_t  invisible)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (unlikely (hb_object_is_immutable (buffer)))</span>
<span class="line-added">+     return;</span>
<span class="line-added">+ </span>
<span class="line-added">+   buffer-&gt;invisible = invisible;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * hb_buffer_get_invisible_glyph:</span>
<span class="line-added">+  * @buffer: an #hb_buffer_t.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * See hb_buffer_set_invisible_glyph().</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Return value:</span>
<span class="line-added">+  * The @buffer invisible #hb_codepoint_t.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.0.0</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ hb_codepoint_t</span>
<span class="line-added">+ hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   return buffer-&gt;invisible;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  /**
   * hb_buffer_reset:
   * @buffer: an #hb_buffer_t.
   *
   * Resets the buffer to its initial status, as if it was just newly created
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1315,11 ***</span>
   **/
  hb_bool_t
  hb_buffer_set_length (hb_buffer_t  *buffer,
                        unsigned int  length)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return length == 0;
  
    if (!buffer-&gt;ensure (length))
      return false;
  
<span class="line-new-header">--- 1327,11 ---</span>
   **/
  hb_bool_t
  hb_buffer_set_length (hb_buffer_t  *buffer,
                        unsigned int  length)
  {
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return length == 0;
  
    if (!buffer-&gt;ensure (length))
      return false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1496,10 ***</span>
<span class="line-new-header">--- 1508,12 ---</span>
   *
   * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
   * it will be set to the process&#39;s default language as returned by
   * hb_language_get_default().  This may change in the future by
   * taking buffer script into consideration when choosing a language.
<span class="line-added">+  * Note that hb_language_get_default() is NOT threadsafe the first time</span>
<span class="line-added">+  * it is called.  See documentation for that function for details.</span>
   *
   * Since: 0.9.7
   **/
  void
  hb_buffer_guess_segment_properties (hb_buffer_t *buffer)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1519,11 ***</span>
    const hb_codepoint_t replacement = buffer-&gt;replacement;
  
    assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
<span class="line-modified">!   if (unlikely (hb_object_is_inert (buffer)))</span>
      return;
  
    if (text_length == -1)
      text_length = utf_t::strlen (text);
  
<span class="line-new-header">--- 1533,11 ---</span>
    const hb_codepoint_t replacement = buffer-&gt;replacement;
  
    assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
            (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
  
<span class="line-modified">!   if (unlikely (hb_object_is_immutable (buffer)))</span>
      return;
  
    if (text_length == -1)
      text_length = utf_t::strlen (text);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1650,11 ***</span>
                       const uint32_t *text,
                       int             text_length,
                       unsigned int    item_offset,
                       int             item_length)
  {
<span class="line-modified">!   hb_buffer_add_utf&lt;hb_utf32_t&lt;&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  /**
   * hb_buffer_add_latin1:
   * @buffer: an #hb_buffer_t.
<span class="line-new-header">--- 1664,11 ---</span>
                       const uint32_t *text,
                       int             text_length,
                       unsigned int    item_offset,
                       int             item_length)
  {
<span class="line-modified">!   hb_buffer_add_utf&lt;hb_utf32_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  /**
   * hb_buffer_add_latin1:
   * @buffer: an #hb_buffer_t.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1711,11 ***</span>
                            const hb_codepoint_t *text,
                            int                   text_length,
                            unsigned int          item_offset,
                            int                   item_length)
  {
<span class="line-modified">!   hb_buffer_add_utf&lt;hb_utf32_t&lt;false&gt; &gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  
  /**
   * hb_buffer_append:
<span class="line-new-header">--- 1725,11 ---</span>
                            const hb_codepoint_t *text,
                            int                   text_length,
                            unsigned int          item_offset,
                            int                   item_length)
  {
<span class="line-modified">!   hb_buffer_add_utf&lt;hb_utf32_novalidate_t&gt; (buffer, text, text_length, item_offset, item_length);</span>
  }
  
  
  /**
   * hb_buffer_append:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1884,10 ***</span>
<span class="line-new-header">--- 1898,14 ---</span>
   * Comparing buffers.
   */
  
  /**
   * hb_buffer_diff:
<span class="line-added">+  * @buffer: a buffer.</span>
<span class="line-added">+  * @reference: other buffer to compare to.</span>
<span class="line-added">+  * @dottedcircle_glyph: glyph id of U+25CC DOTTED CIRCLE, or (hb_codepont_t) -1.</span>
<span class="line-added">+  * @position_fuzz: allowed absolute difference in position values.</span>
   *
   * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
   * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
   * callers if just comparing two buffers is needed.
   *
</pre>
<center><a href="hb-buffer-serialize.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-buffer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
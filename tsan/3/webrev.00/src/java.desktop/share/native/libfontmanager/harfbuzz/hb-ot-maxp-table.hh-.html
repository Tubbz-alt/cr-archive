<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-maxp-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_MAXP_TABLE_HH
 28 #define HB_OT_MAXP_TABLE_HH
 29 
 30 #include &quot;hb-open-type-private.hh&quot;
 31 #include &quot;hb-subset-plan.hh&quot;
 32 
 33 namespace OT {
 34 
 35 
 36 /*
 37  * maxp -- Maximum Profile
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/maxp
 39  */
 40 
 41 #define HB_OT_TAG_maxp HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;x&#39;,&#39;p&#39;)
 42 
 43 struct maxpV1Tail
 44 {
 45   inline bool sanitize (hb_sanitize_context_t *c) const
 46   {
 47     TRACE_SANITIZE (this);
 48     return_trace (c-&gt;check_struct (this));
 49   }
 50 
 51   HBUINT16 maxPoints;             /* Maximum points in a non-composite glyph. */
 52   HBUINT16 maxContours;           /* Maximum contours in a non-composite glyph. */
 53   HBUINT16 maxCompositePoints;    /* Maximum points in a composite glyph. */
 54   HBUINT16 maxCompositeContours;  /* Maximum contours in a composite glyph. */
 55   HBUINT16 maxZones;              /* 1 if instructions do not use the twilight zone (Z0),
 56                                    * or 2 if instructions do use Z0; should be set to 2 in
 57                                    * most cases. */
 58   HBUINT16 maxTwilightPoints;     /* Maximum points used in Z0. */
 59   HBUINT16 maxStorage;            /* Number of Storage Area locations. */
 60   HBUINT16 maxFunctionDefs;       /* Number of FDEFs, equal to the highest function number + 1. */
 61   HBUINT16 maxInstructionDefs;    /* Number of IDEFs. */
 62   HBUINT16 maxStackElements;      /* Maximum stack depth. (This includes Font and CVT
 63                                    * Programs, as well as the instructions for each glyph.) */
 64   HBUINT16 maxSizeOfInstructions; /* Maximum byte count for glyph instructions. */
 65   HBUINT16 maxComponentElements;  /* Maximum number of components referenced at
 66                                    * &quot;top level&quot; for any composite glyph. */
 67   HBUINT16 maxComponentDepth;     /* Maximum levels of recursion; 1 for simple components. */
 68  public:
 69   DEFINE_SIZE_STATIC (26);
 70 };
 71 
 72 
 73 struct maxp
 74 {
 75   static const hb_tag_t tableTag = HB_OT_TAG_maxp;
 76 
 77   inline unsigned int get_num_glyphs (void) const
 78   {
 79     return numGlyphs;
 80   }
 81 
 82   inline void set_num_glyphs (unsigned int count)
 83   {
 84     numGlyphs.set (count);
 85   }
 86 
 87   inline bool sanitize (hb_sanitize_context_t *c) const
 88   {
 89     TRACE_SANITIZE (this);
 90     if (unlikely (!c-&gt;check_struct (this)))
 91       return_trace (false);
 92 
 93     if (version.major == 1)
 94     {
 95       const maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*this);
 96       return v1.sanitize (c);
 97     }
 98     return_trace (likely (version.major == 0 &amp;&amp; version.minor == 0x5000u));
 99   }
100 
101   inline bool subset (hb_subset_plan_t *plan) const
102   {
103     hb_blob_t *maxp_blob = OT::Sanitizer&lt;OT::maxp&gt;().sanitize (hb_face_reference_table (plan-&gt;source, HB_OT_TAG_maxp));
104     hb_blob_t *maxp_prime_blob = hb_blob_copy_writable_or_fail (maxp_blob);
105     hb_blob_destroy (maxp_blob);
106 
107     if (unlikely (!maxp_prime_blob)) {
108       return false;
109     }
110     OT::maxp *maxp_prime = (OT::maxp *) hb_blob_get_data (maxp_prime_blob, nullptr);
111 
112     maxp_prime-&gt;set_num_glyphs (plan-&gt;glyphs.len);
113     if (plan-&gt;drop_hints)
114       drop_hint_fields (plan, maxp_prime);
115 
116     bool result = plan-&gt;add_table (HB_OT_TAG_maxp, maxp_prime_blob);
117     hb_blob_destroy (maxp_prime_blob);
118     return result;
119   }
120 
121   static inline void drop_hint_fields (hb_subset_plan_t *plan, OT::maxp *maxp_prime)
122   {
123     if (maxp_prime-&gt;version.major == 1)
124     {
125       maxpV1Tail &amp;v1 = StructAfter&lt;maxpV1Tail&gt; (*maxp_prime);
126       v1.maxZones.set (1);
127       v1.maxTwilightPoints.set (0);
128       v1.maxStorage.set (0);
129       v1.maxFunctionDefs.set (0);
130       v1.maxInstructionDefs.set (0);
131       v1.maxStackElements.set (0);
132       v1.maxSizeOfInstructions.set (0);
133     }
134   }
135 
136   protected:
137   FixedVersion&lt;&gt;version;                /* Version of the maxp table (0.5 or 1.0),
138                                          * 0x00005000u or 0x00010000u. */
139   HBUINT16      numGlyphs;              /* The number of glyphs in the font. */
140 /*maxpV1Tail v1Tail[VAR]; */
141   public:
142   DEFINE_SIZE_STATIC (6);
143 };
144 
145 
146 } /* namespace OT */
147 
148 
149 #endif /* HB_OT_MAXP_TABLE_HH */
    </pre>
  </body>
</html>
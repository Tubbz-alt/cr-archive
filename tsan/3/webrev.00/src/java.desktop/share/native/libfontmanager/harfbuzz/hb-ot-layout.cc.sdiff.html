<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-jstf-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * software and its documentation for any purpose, provided that the
  12  * above copyright notice and the following two paragraphs appear in
  13  * all copies of this software.
  14  *
  15  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  16  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  17  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  18  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  19  * DAMAGE.
  20  *
  21  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  22  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  23  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  24  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  25  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  26  *
  27  * Red Hat Author(s): Behdad Esfahbod
  28  * Google Author(s): Behdad Esfahbod
  29  */
  30 
<span class="line-modified">  31 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-map-private.hh&quot;</span>
<span class="line-modified">  34 </span>




  35 #include &quot;hb-ot-layout-gdef-table.hh&quot;
  36 #include &quot;hb-ot-layout-gsub-table.hh&quot;
  37 #include &quot;hb-ot-layout-gpos-table.hh&quot;
<span class="line-modified">  38 </span>
<span class="line-modified">  39 // Just so we compile them; unused otherwise:</span>
<span class="line-removed">  40 #include &quot;hb-ot-layout-base-table.hh&quot;</span>
<span class="line-removed">  41 #include &quot;hb-ot-layout-jstf-table.hh&quot;</span>
<span class="line-removed">  42 #include &quot;hb-ot-color-colr-table.hh&quot;</span>
<span class="line-removed">  43 #include &quot;hb-ot-color-cpal-table.hh&quot;</span>
<span class="line-removed">  44 #include &quot;hb-ot-color-sbix-table.hh&quot;</span>
<span class="line-removed">  45 #include &quot;hb-ot-color-svg-table.hh&quot;</span>
  46 #include &quot;hb-ot-name-table.hh&quot;
<span class="line-modified">  47 #include &quot;hb-map-private.hh&quot;</span>
<span class="line-removed">  48 </span>
<span class="line-removed">  49 </span>
<span class="line-removed">  50 hb_ot_layout_t *</span>
<span class="line-removed">  51 _hb_ot_layout_create (hb_face_t *face)</span>
<span class="line-removed">  52 {</span>
<span class="line-removed">  53   hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));</span>
<span class="line-removed">  54   if (unlikely (!layout))</span>
<span class="line-removed">  55     return nullptr;</span>
<span class="line-removed">  56 </span>
<span class="line-removed">  57   layout-&gt;gdef_blob = OT::Sanitizer&lt;OT::GDEF&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GDEF));</span>
<span class="line-removed">  58   layout-&gt;gdef = layout-&gt;gdef_blob-&gt;as&lt;OT::GDEF&gt; ();</span>
  59 
<span class="line-modified">  60   layout-&gt;gsub_blob = OT::Sanitizer&lt;OT::GSUB&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GSUB));</span>
<span class="line-modified">  61   layout-&gt;gsub = layout-&gt;gsub_blob-&gt;as&lt;OT::GSUB&gt; ();</span>
  62 
<span class="line-removed">  63   layout-&gt;gpos_blob = OT::Sanitizer&lt;OT::GPOS&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GPOS));</span>
<span class="line-removed">  64   layout-&gt;gpos = layout-&gt;gpos_blob-&gt;as&lt;OT::GPOS&gt; ();</span>
  65 
<span class="line-modified">  66   layout-&gt;math.init (face);</span>
<span class="line-modified">  67   layout-&gt;fvar.init (face);</span>
<span class="line-modified">  68   layout-&gt;avar.init (face);</span>
<span class="line-modified">  69 </span>
<span class="line-modified">  70   {</span>
<span class="line-modified">  71     /*</span>
<span class="line-modified">  72      * The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified">  73      * See this thread for why we finally had to bend in and do this:</span>
<span class="line-removed">  74      * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">  75      */</span>
<span class="line-removed">  76     unsigned int gdef_len = layout-&gt;gdef_blob-&gt;length;</span>
<span class="line-removed">  77     unsigned int gsub_len = layout-&gt;gsub_blob-&gt;length;</span>
<span class="line-removed">  78     unsigned int gpos_len = layout-&gt;gpos_blob-&gt;length;</span>
<span class="line-removed">  79     if (0</span>
<span class="line-removed">  80       /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-removed">  81       || (442 == gdef_len &amp;&amp; 42038 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  82       /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-removed">  83       || (430 == gdef_len &amp;&amp; 40662 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  84       /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-removed">  85       || (442 == gdef_len &amp;&amp; 39116 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  86       /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-removed">  87       || (430 == gdef_len &amp;&amp; 39374 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  88       /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-removed">  89       || (490 == gdef_len &amp;&amp; 41638 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">  90       /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-removed">  91       || (478 == gdef_len &amp;&amp; 41902 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">  92     )</span>
<span class="line-removed">  93     {</span>
<span class="line-removed">  94       /* In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-removed">  95        * ASCII double quotation mark U+0022, mapped to glyph 5, has wrong</span>
<span class="line-removed">  96        * glyph class 3 (mark) in GDEF.  Nuke the GDEF to avoid zero-width</span>
<span class="line-removed">  97        * double-quote.  See:</span>
<span class="line-removed">  98        * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">  99        */</span>
<span class="line-removed"> 100      if (3 == layout-&gt;gdef-&gt;get_glyph_class (5))</span>
<span class="line-removed"> 101        layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed"> 102     }</span>
<span class="line-removed"> 103     else if (0</span>
<span class="line-removed"> 104       /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-removed"> 105       || (898 == gdef_len &amp;&amp; 46470 == gpos_len &amp;&amp; 12554 == gsub_len)</span>
<span class="line-removed"> 106       /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-removed"> 107       || (910 == gdef_len &amp;&amp; 47732 == gpos_len &amp;&amp; 12566 == gsub_len)</span>
<span class="line-removed"> 108       /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-removed"> 109       || (928 == gdef_len &amp;&amp; 59332 == gpos_len &amp;&amp; 23298 == gsub_len)</span>
<span class="line-removed"> 110       /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-removed"> 111       || (940 == gdef_len &amp;&amp; 60732 == gpos_len &amp;&amp; 23310 == gsub_len)</span>
<span class="line-removed"> 112       /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 113       || (964 == gdef_len &amp;&amp; 60072 == gpos_len &amp;&amp; 23836 == gsub_len)</span>
<span class="line-removed"> 114       /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 115       || (976 == gdef_len &amp;&amp; 61456 == gpos_len &amp;&amp; 23832 == gsub_len)</span>
<span class="line-removed"> 116       /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-removed"> 117       || (994 == gdef_len &amp;&amp; 60336 == gpos_len &amp;&amp; 24474 == gsub_len)</span>
<span class="line-removed"> 118       /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-removed"> 119       || (1006 == gdef_len &amp;&amp; 61740 == gpos_len &amp;&amp; 24470 == gsub_len)</span>
<span class="line-removed"> 120       /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 121       || (1006 == gdef_len &amp;&amp; 61346 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed"> 122       /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 123       || (1018 == gdef_len &amp;&amp; 62828 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed"> 124       /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-removed"> 125       || (1006 == gdef_len &amp;&amp; 61352 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed"> 126       /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-removed"> 127       || (1018 == gdef_len &amp;&amp; 62834 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed"> 128       /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-removed"> 129       || (832 == gdef_len &amp;&amp; 47162 == gpos_len &amp;&amp; 7324 == gsub_len)</span>
<span class="line-removed"> 130       /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-removed"> 131       || (844 == gdef_len &amp;&amp; 45474 == gpos_len &amp;&amp; 7302 == gsub_len)</span>
<span class="line-removed"> 132       /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-removed"> 133       || (180 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 13054 == gsub_len)</span>
<span class="line-removed"> 134       /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-removed"> 135       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12638 == gsub_len)</span>
<span class="line-removed"> 136       /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-removed"> 137       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12690 == gsub_len)</span>
<span class="line-removed"> 138       /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-removed"> 139       /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-removed"> 140       || (188 == gdef_len &amp;&amp; 3852 == gpos_len &amp;&amp; 248 == gsub_len)</span>
<span class="line-removed"> 141       /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-removed"> 142       /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-removed"> 143       || (188 == gdef_len &amp;&amp; 3426 == gpos_len &amp;&amp; 264 == gsub_len)</span>
<span class="line-removed"> 144       /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-removed"> 145       || (1058 == gdef_len &amp;&amp; 11818 == gpos_len &amp;&amp; 47032 == gsub_len)</span>
<span class="line-removed"> 146       /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-removed"> 147       || (1046 == gdef_len &amp;&amp; 12600 == gpos_len &amp;&amp; 47030 == gsub_len)</span>
<span class="line-removed"> 148       /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-removed"> 149       || (1058 == gdef_len &amp;&amp; 16770 == gpos_len &amp;&amp; 71796 == gsub_len)</span>
<span class="line-removed"> 150       /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-removed"> 151       || (1046 == gdef_len &amp;&amp; 17862 == gpos_len &amp;&amp; 71790 == gsub_len)</span>
<span class="line-removed"> 152       /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-removed"> 153       || (1046 == gdef_len &amp;&amp; 17112 == gpos_len &amp;&amp; 71788 == gsub_len)</span>
<span class="line-removed"> 154       /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-removed"> 155       || (1058 == gdef_len &amp;&amp; 17514 == gpos_len &amp;&amp; 71794 == gsub_len)</span>
<span class="line-removed"> 156       /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-removed"> 157       || (1330 == gdef_len &amp;&amp; 57938 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed"> 158       /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-removed"> 159       || (1330 == gdef_len &amp;&amp; 58972 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed"> 160       /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-removed"> 161        *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-removed"> 162       || (1004 == gdef_len &amp;&amp; 14836 == gpos_len &amp;&amp; 59092 == gsub_len)</span>
<span class="line-removed"> 163     )</span>
<span class="line-removed"> 164     {</span>
<span class="line-removed"> 165       /* Many versions of Tahoma have bad GDEF tables that incorrectly classify some spacing marks</span>
<span class="line-removed"> 166        * such as certain IPA symbols as glyph class 3. So do older versions of Microsoft Himalaya,</span>
<span class="line-removed"> 167        * and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-removed"> 168        * Nuke the GDEF tables of these fonts to avoid unwanted width-zeroing.</span>
<span class="line-removed"> 169        * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-removed"> 170        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-removed"> 171        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-removed"> 172        */</span>
<span class="line-removed"> 173       layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed"> 174     }</span>
<span class="line-removed"> 175   }</span>
 176 
<span class="line-removed"> 177   layout-&gt;gsub_lookup_count = layout-&gt;gsub-&gt;get_lookup_count ();</span>
<span class="line-removed"> 178   layout-&gt;gpos_lookup_count = layout-&gt;gpos-&gt;get_lookup_count ();</span>
 179 
<span class="line-modified"> 180   layout-&gt;gsub_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gsub-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>
<span class="line-modified"> 181   layout-&gt;gpos_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gpos-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>

 182 
<span class="line-modified"> 183   if (unlikely ((layout-&gt;gsub_lookup_count &amp;&amp; !layout-&gt;gsub_accels) ||</span>
<span class="line-modified"> 184                 (layout-&gt;gpos_lookup_count &amp;&amp; !layout-&gt;gpos_accels)))</span>
<span class="line-modified"> 185   {</span>
<span class="line-modified"> 186     _hb_ot_layout_destroy (layout);</span>
<span class="line-modified"> 187     return nullptr;</span>
<span class="line-removed"> 188   }</span>
 189 
<span class="line-modified"> 190   for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-modified"> 191     layout-&gt;gsub_accels[i].init (layout-&gt;gsub-&gt;get_lookup (i));</span>
<span class="line-modified"> 192   for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-modified"> 193     layout-&gt;gpos_accels[i].init (layout-&gt;gpos-&gt;get_lookup (i));</span>

 194 
<span class="line-modified"> 195   return layout;</span>



 196 }
 197 
 198 void
<span class="line-modified"> 199 _hb_ot_layout_destroy (hb_ot_layout_t *layout)</span>


 200 {
<span class="line-modified"> 201   if (layout-&gt;gsub_accels)</span>
<span class="line-modified"> 202     for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-removed"> 203       layout-&gt;gsub_accels[i].fini ();</span>
<span class="line-removed"> 204   if (layout-&gt;gpos_accels)</span>
<span class="line-removed"> 205     for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-removed"> 206       layout-&gt;gpos_accels[i].fini ();</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208   free (layout-&gt;gsub_accels);</span>
<span class="line-removed"> 209   free (layout-&gt;gpos_accels);</span>
 210 
<span class="line-modified"> 211   hb_blob_destroy (layout-&gt;gdef_blob);</span>
<span class="line-removed"> 212   hb_blob_destroy (layout-&gt;gsub_blob);</span>
<span class="line-removed"> 213   hb_blob_destroy (layout-&gt;gpos_blob);</span>
 214 
<span class="line-modified"> 215   layout-&gt;math.fini ();</span>
<span class="line-removed"> 216   layout-&gt;fvar.fini ();</span>
<span class="line-removed"> 217   layout-&gt;avar.fini ();</span>
<span class="line-removed"> 218 </span>
<span class="line-removed"> 219   free (layout);</span>
 220 }
 221 
<span class="line-removed"> 222 // static inline const OT::BASE&amp;</span>
<span class="line-removed"> 223 // _get_base (hb_face_t *face)</span>
<span class="line-removed"> 224 // {</span>
<span class="line-removed"> 225 //   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::BASE);</span>
<span class="line-removed"> 226 //   hb_ot_layout_t * layout = hb_ot_layout_from_face (face);</span>
<span class="line-removed"> 227 //   return *(layout-&gt;base.get ());</span>
<span class="line-removed"> 228 // }</span>
 229 
<span class="line-modified"> 230 static inline const OT::GDEF&amp;</span>
<span class="line-modified"> 231 _get_gdef (hb_face_t *face)</span>
<span class="line-modified"> 232 {</span>
<span class="line-modified"> 233   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GDEF);</span>
<span class="line-modified"> 234   return *hb_ot_layout_from_face (face)-&gt;gdef;</span>
<span class="line-modified"> 235 }</span>
<span class="line-modified"> 236 static inline const OT::GSUB&amp;</span>
<span class="line-removed"> 237 _get_gsub (hb_face_t *face)</span>
 238 {
<span class="line-modified"> 239   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GSUB);</span>
<span class="line-modified"> 240   return *hb_ot_layout_from_face (face)-&gt;gsub;</span>































































































 241 }
<span class="line-modified"> 242 static inline const OT::GPOS&amp;</span>
<span class="line-modified"> 243 _get_gpos (hb_face_t *face)</span>


 244 {
<span class="line-modified"> 245   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GPOS);</span>
<span class="line-modified"> 246   return *hb_ot_layout_from_face (face)-&gt;gpos;</span>








 247 }
 248 
<span class="line-modified"> 249 /*</span>
<span class="line-removed"> 250  * GDEF</span>
<span class="line-removed"> 251  */</span>
 252 
 253 hb_bool_t
 254 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 255 {
<span class="line-modified"> 256   return _get_gdef (face).has_glyph_classes ();</span>
 257 }
 258 
 259 /**
 260  * hb_ot_layout_get_glyph_class:
 261  *
 262  * Since: 0.9.7
 263  **/
 264 hb_ot_layout_glyph_class_t
 265 hb_ot_layout_get_glyph_class (hb_face_t      *face,
 266                               hb_codepoint_t  glyph)
 267 {
<span class="line-modified"> 268   return (hb_ot_layout_glyph_class_t) _get_gdef (face).get_glyph_class (glyph);</span>
 269 }
 270 
 271 /**
 272  * hb_ot_layout_get_glyphs_in_class:
 273  *
 274  * Since: 0.9.7
 275  **/
 276 void
 277 hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
 278                                   hb_ot_layout_glyph_class_t  klass,
 279                                   hb_set_t                   *glyphs /* OUT */)
 280 {
<span class="line-modified"> 281   return _get_gdef (face).get_glyphs_in_class (klass, glyphs);</span>
 282 }
 283 
 284 unsigned int
 285 hb_ot_layout_get_attach_points (hb_face_t      *face,
 286                                 hb_codepoint_t  glyph,
 287                                 unsigned int    start_offset,
 288                                 unsigned int   *point_count /* IN/OUT */,
 289                                 unsigned int   *point_array /* OUT */)
 290 {
<span class="line-modified"> 291   return _get_gdef (face).get_attach_points (glyph, start_offset, point_count, point_array);</span>



 292 }
 293 
 294 unsigned int
 295 hb_ot_layout_get_ligature_carets (hb_font_t      *font,
 296                                   hb_direction_t  direction,
 297                                   hb_codepoint_t  glyph,
 298                                   unsigned int    start_offset,
 299                                   unsigned int   *caret_count /* IN/OUT */,
 300                                   hb_position_t  *caret_array /* OUT */)
 301 {
<span class="line-modified"> 302   return _get_gdef (font-&gt;face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>








 303 }
 304 
 305 
 306 /*
 307  * GSUB/GPOS
 308  */
 309 
































 310 static const OT::GSUBGPOS&amp;
 311 get_gsubgpos_table (hb_face_t *face,
 312                     hb_tag_t   table_tag)
 313 {
 314   switch (table_tag) {
<span class="line-modified"> 315     case HB_OT_TAG_GSUB: return _get_gsub (face);</span>
<span class="line-modified"> 316     case HB_OT_TAG_GPOS: return _get_gpos (face);</span>
 317     default:             return Null(OT::GSUBGPOS);
 318   }
 319 }
 320 
 321 
 322 unsigned int
 323 hb_ot_layout_table_get_script_tags (hb_face_t    *face,
 324                                     hb_tag_t      table_tag,
 325                                     unsigned int  start_offset,
 326                                     unsigned int *script_count /* IN/OUT */,
<span class="line-modified"> 327                                     hb_tag_t     *script_tags /* OUT */)</span>
 328 {
 329   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 330 
 331   return g.get_script_tags (start_offset, script_count, script_tags);
 332 }
 333 
 334 #define HB_OT_TAG_LATIN_SCRIPT          HB_TAG (&#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;n&#39;)
 335 
 336 hb_bool_t
 337 hb_ot_layout_table_find_script (hb_face_t    *face,
 338                                 hb_tag_t      table_tag,
 339                                 hb_tag_t      script_tag,
 340                                 unsigned int *script_index)
 341 {
 342   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 343   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 344 
 345   if (g.find_script_index (script_tag, script_index))
 346     return true;
 347 
</pre>
<hr />
<pre>
 352   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :(.
 353    * including many versions of DejaVu Sans Mono! */
 354   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
 355     return false;
 356 
 357   /* try with &#39;latn&#39;; some old fonts put their features there even though
 358      they&#39;re really trying to support Thai, for example :( */
 359   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))
 360     return false;
 361 
 362   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 363   return false;
 364 }
 365 
 366 hb_bool_t
 367 hb_ot_layout_table_choose_script (hb_face_t      *face,
 368                                   hb_tag_t        table_tag,
 369                                   const hb_tag_t *script_tags,
 370                                   unsigned int   *script_index,
 371                                   hb_tag_t       *chosen_script)


















 372 {
 373   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 374   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);

 375 
<span class="line-modified"> 376   while (*script_tags)</span>
 377   {
<span class="line-modified"> 378     if (g.find_script_index (*script_tags, script_index)) {</span>

 379       if (chosen_script)
<span class="line-modified"> 380         *chosen_script = *script_tags;</span>
 381       return true;
 382     }
<span class="line-removed"> 383     script_tags++;</span>
 384   }
 385 
 386   /* try finding &#39;DFLT&#39; */
 387   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
 388     if (chosen_script)
 389       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
 390     return false;
 391   }
 392 
 393   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 394   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
 395     if (chosen_script)
 396       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
 397     return false;
 398   }
 399 
 400   /* try with &#39;latn&#39;; some old fonts put their features there even though
 401      they&#39;re really trying to support Thai, for example :( */
 402   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
 403     if (chosen_script)
 404       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
 405     return false;
 406   }
 407 
 408   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 409   if (chosen_script)
 410     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 411   return false;
 412 }
 413 
 414 unsigned int
 415 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 416                                      hb_tag_t      table_tag,
 417                                      unsigned int  start_offset,
 418                                      unsigned int *feature_count /* IN/OUT */,
<span class="line-modified"> 419                                      hb_tag_t     *feature_tags /* OUT */)</span>
 420 {
 421   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 422 
 423   return g.get_feature_tags (start_offset, feature_count, feature_tags);
 424 }
 425 
<span class="line-modified"> 426 hb_bool_t</span>
 427 hb_ot_layout_table_find_feature (hb_face_t    *face,
 428                                  hb_tag_t      table_tag,
 429                                  hb_tag_t      feature_tag,
 430                                  unsigned int *feature_index)
 431 {
 432   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 433   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 434 
 435   unsigned int num_features = g.get_feature_count ();
 436   for (unsigned int i = 0; i &lt; num_features; i++)
 437   {
 438     if (feature_tag == g.get_feature_tag (i)) {
 439       if (feature_index) *feature_index = i;
 440       return true;
 441     }
 442   }
 443 
 444   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 445   return false;
 446 }
 447 
 448 
 449 unsigned int
 450 hb_ot_layout_script_get_language_tags (hb_face_t    *face,
 451                                        hb_tag_t      table_tag,
 452                                        unsigned int  script_index,
 453                                        unsigned int  start_offset,
 454                                        unsigned int *language_count /* IN/OUT */,
<span class="line-modified"> 455                                        hb_tag_t     *language_tags /* OUT */)</span>
 456 {
 457   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 458 
 459   return s.get_lang_sys_tags (start_offset, language_count, language_tags);
 460 }
 461 
 462 hb_bool_t
 463 hb_ot_layout_script_find_language (hb_face_t    *face,
 464                                    hb_tag_t      table_tag,
 465                                    unsigned int  script_index,
 466                                    hb_tag_t      language_tag,
 467                                    unsigned int *language_index)





















 468 {
 469   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
 470   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);

 471 
<span class="line-modified"> 472   if (s.find_lang_sys_index (language_tag, language_index))</span>
<span class="line-modified"> 473     return true;</span>



 474 
<span class="line-modified"> 475   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */</span>
 476   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
 477     return false;
 478 
 479   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
 480   return false;
 481 }
 482 
 483 hb_bool_t
 484 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 485                                                   hb_tag_t      table_tag,
 486                                                   unsigned int  script_index,
 487                                                   unsigned int  language_index,
 488                                                   unsigned int *feature_index)
 489 {
 490   return hb_ot_layout_language_get_required_feature (face,
 491                                                      table_tag,
 492                                                      script_index,
 493                                                      language_index,
 494                                                      feature_index,
 495                                                      nullptr);
</pre>
<hr />
<pre>
 507                                             unsigned int  language_index,
 508                                             unsigned int *feature_index,
 509                                             hb_tag_t     *feature_tag)
 510 {
 511   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 512   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 513 
 514   unsigned int index = l.get_required_feature_index ();
 515   if (feature_index) *feature_index = index;
 516   if (feature_tag) *feature_tag = g.get_feature_tag (index);
 517 
 518   return l.has_required_feature ();
 519 }
 520 
 521 unsigned int
 522 hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
 523                                            hb_tag_t      table_tag,
 524                                            unsigned int  script_index,
 525                                            unsigned int  language_index,
 526                                            unsigned int  start_offset,
<span class="line-modified"> 527                                            unsigned int *feature_count /* IN/OUT */,</span>
 528                                            unsigned int *feature_indexes /* OUT */)
 529 {
 530   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 531   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 532 
 533   return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
 534 }
 535 
 536 unsigned int
 537 hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
 538                                         hb_tag_t      table_tag,
 539                                         unsigned int  script_index,
 540                                         unsigned int  language_index,
 541                                         unsigned int  start_offset,
 542                                         unsigned int *feature_count /* IN/OUT */,
<span class="line-modified"> 543                                         hb_tag_t     *feature_tags /* OUT */)</span>
 544 {
 545   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 546   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 547 
 548   static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
 549   unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
 550 
 551   if (feature_tags) {
 552     unsigned int count = *feature_count;
 553     for (unsigned int i = 0; i &lt; count; i++)
 554       feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
 555   }
 556 
 557   return ret;
 558 }
 559 
 560 
 561 hb_bool_t
 562 hb_ot_layout_language_find_feature (hb_face_t    *face,
 563                                     hb_tag_t      table_tag,
</pre>
<hr />
<pre>
 577     if (feature_tag == g.get_feature_tag (f_index)) {
 578       if (feature_index) *feature_index = f_index;
 579       return true;
 580     }
 581   }
 582 
 583   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 584   return false;
 585 }
 586 
 587 /**
 588  * hb_ot_layout_feature_get_lookups:
 589  *
 590  * Since: 0.9.7
 591  **/
 592 unsigned int
 593 hb_ot_layout_feature_get_lookups (hb_face_t    *face,
 594                                   hb_tag_t      table_tag,
 595                                   unsigned int  feature_index,
 596                                   unsigned int  start_offset,
<span class="line-modified"> 597                                   unsigned int *lookup_count /* IN/OUT */,</span>
 598                                   unsigned int *lookup_indexes /* OUT */)
 599 {
 600   return hb_ot_layout_feature_with_variations_get_lookups (face,
 601                                                            table_tag,
 602                                                            feature_index,
 603                                                            HB_OT_LAYOUT_NO_VARIATIONS_INDEX,
 604                                                            start_offset,
 605                                                            lookup_count,
 606                                                            lookup_indexes);
 607 }
 608 
 609 /**
 610  * hb_ot_layout_table_get_lookup_count:
 611  *
 612  * Since: 0.9.22
 613  **/
 614 unsigned int
 615 hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
 616                                      hb_tag_t      table_tag)
 617 {
<span class="line-modified"> 618   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return 0;</span>
<span class="line-removed"> 619   switch (table_tag)</span>
<span class="line-removed"> 620   {</span>
<span class="line-removed"> 621     case HB_OT_TAG_GSUB:</span>
<span class="line-removed"> 622     {</span>
<span class="line-removed"> 623       return hb_ot_layout_from_face (face)-&gt;gsub_lookup_count;</span>
<span class="line-removed"> 624     }</span>
<span class="line-removed"> 625     case HB_OT_TAG_GPOS:</span>
<span class="line-removed"> 626     {</span>
<span class="line-removed"> 627       return hb_ot_layout_from_face (face)-&gt;gpos_lookup_count;</span>
<span class="line-removed"> 628     }</span>
<span class="line-removed"> 629   }</span>
<span class="line-removed"> 630   return 0;</span>
 631 }
 632 
<span class="line-modified"> 633 static void</span>
<span class="line-modified"> 634 _hb_ot_layout_collect_lookups_lookups (hb_face_t      *face,</span>
<span class="line-removed"> 635                                        hb_tag_t        table_tag,</span>
<span class="line-removed"> 636                                        unsigned int    feature_index,</span>
<span class="line-removed"> 637                                        hb_set_t       *lookup_indexes /* OUT */)</span>
 638 {
<span class="line-modified"> 639   unsigned int lookup_indices[32];</span>
<span class="line-modified"> 640   unsigned int offset, len;</span>
<span class="line-modified"> 641 </span>
<span class="line-modified"> 642   offset = 0;</span>
<span class="line-modified"> 643   do {</span>
<span class="line-modified"> 644     len = ARRAY_LENGTH (lookup_indices);</span>
<span class="line-modified"> 645     hb_ot_layout_feature_get_lookups (face,</span>
<span class="line-modified"> 646                                       table_tag,</span>
<span class="line-modified"> 647                                       feature_index,</span>
<span class="line-modified"> 648                                       offset, &amp;len,</span>
<span class="line-modified"> 649                                       lookup_indices);</span>
<span class="line-modified"> 650 </span>
<span class="line-modified"> 651     for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-modified"> 652       lookup_indexes-&gt;add (lookup_indices[i]);</span>
<span class="line-modified"> 653 </span>
<span class="line-modified"> 654     offset += len;</span>
<span class="line-modified"> 655   } while (len == ARRAY_LENGTH (lookup_indices));</span>
<span class="line-modified"> 656 }</span>






































 657 
 658 static void
<span class="line-modified"> 659 _hb_ot_layout_collect_lookups_features (hb_face_t      *face,</span>
<span class="line-modified"> 660                                         hb_tag_t        table_tag,</span>
<span class="line-modified"> 661                                         unsigned int    script_index,</span>
<span class="line-removed"> 662                                         unsigned int    language_index,</span>
<span class="line-removed"> 663                                         const hb_tag_t *features,</span>
<span class="line-removed"> 664                                         hb_set_t       *lookup_indexes /* OUT */)</span>
 665 {


 666   if (!features)
 667   {
<span class="line-modified"> 668     unsigned int required_feature_index;</span>
<span class="line-modified"> 669     if (hb_ot_layout_language_get_required_feature (face,</span>
<span class="line-modified"> 670                                                     table_tag,</span>
<span class="line-modified"> 671                                                     script_index,</span>
<span class="line-modified"> 672                                                     language_index,</span>
<span class="line-removed"> 673                                                     &amp;required_feature_index,</span>
<span class="line-removed"> 674                                                     nullptr))</span>
<span class="line-removed"> 675       _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed"> 676                                              table_tag,</span>
<span class="line-removed"> 677                                              required_feature_index,</span>
<span class="line-removed"> 678                                              lookup_indexes);</span>
<span class="line-removed"> 679 </span>
<span class="line-removed"> 680     /* All features */</span>
<span class="line-removed"> 681     unsigned int feature_indices[32];</span>
<span class="line-removed"> 682     unsigned int offset, len;</span>
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684     offset = 0;</span>
<span class="line-removed"> 685     do {</span>
<span class="line-removed"> 686       len = ARRAY_LENGTH (feature_indices);</span>
<span class="line-removed"> 687       hb_ot_layout_language_get_feature_indexes (face,</span>
<span class="line-removed"> 688                                                  table_tag,</span>
<span class="line-removed"> 689                                                  script_index,</span>
<span class="line-removed"> 690                                                  language_index,</span>
<span class="line-removed"> 691                                                  offset, &amp;len,</span>
<span class="line-removed"> 692                                                  feature_indices);</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694       for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-removed"> 695         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed"> 696                                                table_tag,</span>
<span class="line-removed"> 697                                                feature_indices[i],</span>
<span class="line-removed"> 698                                                lookup_indexes);</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700       offset += len;</span>
<span class="line-removed"> 701     } while (len == ARRAY_LENGTH (feature_indices));</span>
 702   }
 703   else
 704   {

 705     for (; *features; features++)
 706     {
<span class="line-modified"> 707       unsigned int feature_index;</span>
<span class="line-modified"> 708       if (hb_ot_layout_language_find_feature (face,</span>
<span class="line-modified"> 709                                               table_tag,</span>
<span class="line-modified"> 710                                               script_index,</span>
<span class="line-modified"> 711                                               language_index,</span>
<span class="line-modified"> 712                                               *features,</span>
<span class="line-modified"> 713                                               &amp;feature_index))</span>
<span class="line-modified"> 714         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-modified"> 715                                                table_tag,</span>
<span class="line-modified"> 716                                                feature_index,</span>
<span class="line-modified"> 717                                                lookup_indexes);</span>

 718     }
 719   }
 720 }
 721 
 722 static void
<span class="line-modified"> 723 _hb_ot_layout_collect_lookups_languages (hb_face_t      *face,</span>
<span class="line-modified"> 724                                          hb_tag_t        table_tag,</span>
<span class="line-modified"> 725                                          unsigned int    script_index,</span>
<span class="line-modified"> 726                                          const hb_tag_t *languages,</span>
<span class="line-removed"> 727                                          const hb_tag_t *features,</span>
<span class="line-removed"> 728                                          hb_set_t       *lookup_indexes /* OUT */)</span>
 729 {
<span class="line-modified"> 730   _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed"> 731                                           table_tag,</span>
<span class="line-removed"> 732                                           script_index,</span>
<span class="line-removed"> 733                                           HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX,</span>
<span class="line-removed"> 734                                           features,</span>
<span class="line-removed"> 735                                           lookup_indexes);</span>
 736 
 737   if (!languages)
 738   {
<span class="line-modified"> 739     /* All languages */</span>
<span class="line-modified"> 740     unsigned int count = hb_ot_layout_script_get_language_tags (face,</span>
<span class="line-modified"> 741                                                                 table_tag,</span>
<span class="line-modified"> 742                                                                 script_index,</span>
<span class="line-modified"> 743                                                                 0, nullptr, nullptr);</span>


 744     for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<span class="line-modified"> 745       _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-modified"> 746                                               table_tag,</span>
<span class="line-modified"> 747                                               script_index,</span>
<span class="line-removed"> 748                                               language_index,</span>
<span class="line-removed"> 749                                               features,</span>
<span class="line-removed"> 750                                               lookup_indexes);</span>
 751   }
 752   else
 753   {
 754     for (; *languages; languages++)
 755     {
 756       unsigned int language_index;
<span class="line-modified"> 757       if (hb_ot_layout_script_find_language (face,</span>
<span class="line-modified"> 758                                              table_tag,</span>
<span class="line-modified"> 759                                              script_index,</span>
<span class="line-modified"> 760                                              *languages,</span>
<span class="line-removed"> 761                                              &amp;language_index))</span>
<span class="line-removed"> 762         _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed"> 763                                                 table_tag,</span>
<span class="line-removed"> 764                                                 script_index,</span>
<span class="line-removed"> 765                                                 language_index,</span>
<span class="line-removed"> 766                                                 features,</span>
<span class="line-removed"> 767                                                 lookup_indexes);</span>
 768     }
 769   }
 770 }
 771 
 772 /**
<span class="line-modified"> 773  * hb_ot_layout_collect_lookups:</span>
 774  *
<span class="line-modified"> 775  * Since: 0.9.8</span>
 776  **/
 777 void
<span class="line-modified"> 778 hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-modified"> 779                               hb_tag_t        table_tag,</span>
<span class="line-modified"> 780                               const hb_tag_t *scripts,</span>
<span class="line-modified"> 781                               const hb_tag_t *languages,</span>
<span class="line-modified"> 782                               const hb_tag_t *features,</span>
<span class="line-modified"> 783                               hb_set_t       *lookup_indexes /* OUT */)</span>
 784 {

 785   if (!scripts)
 786   {
<span class="line-modified"> 787     /* All scripts */</span>
<span class="line-modified"> 788     unsigned int count = hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-removed"> 789                                                              table_tag,</span>
<span class="line-removed"> 790                                                              0, nullptr, nullptr);</span>
 791     for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<span class="line-modified"> 792       _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-modified"> 793                                                table_tag,</span>
<span class="line-modified"> 794                                                script_index,</span>
<span class="line-modified"> 795                                                languages,</span>
<span class="line-removed"> 796                                                features,</span>
<span class="line-removed"> 797                                                lookup_indexes);</span>
 798   }
 799   else
 800   {
 801     for (; *scripts; scripts++)
 802     {
 803       unsigned int script_index;
<span class="line-modified"> 804       if (hb_ot_layout_table_find_script (face,</span>
<span class="line-modified"> 805                                           table_tag,</span>
<span class="line-modified"> 806                                           *scripts,</span>
<span class="line-modified"> 807                                           &amp;script_index))</span>
<span class="line-modified"> 808         _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-removed"> 809                                                  table_tag,</span>
<span class="line-removed"> 810                                                  script_index,</span>
<span class="line-removed"> 811                                                  languages,</span>
<span class="line-removed"> 812                                                  features,</span>
<span class="line-removed"> 813                                                  lookup_indexes);</span>
 814     }
 815   }
 816 }
 817 























 818 /**
 819  * hb_ot_layout_lookup_collect_glyphs:
 820  *
 821  * Since: 0.9.7
 822  **/
 823 void
 824 hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
 825                                     hb_tag_t      table_tag,
 826                                     unsigned int  lookup_index,
<span class="line-modified"> 827                                     hb_set_t     *glyphs_before, /* OUT. May be nullptr */</span>
<span class="line-modified"> 828                                     hb_set_t     *glyphs_input,  /* OUT. May be nullptr */</span>
<span class="line-modified"> 829                                     hb_set_t     *glyphs_after,  /* OUT. May be nullptr */</span>
<span class="line-modified"> 830                                     hb_set_t     *glyphs_output  /* OUT. May be nullptr */)</span>
 831 {
<span class="line-removed"> 832   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return;</span>
<span class="line-removed"> 833 </span>
 834   OT::hb_collect_glyphs_context_t c (face,
 835                                      glyphs_before,
 836                                      glyphs_input,
 837                                      glyphs_after,
 838                                      glyphs_output);
 839 
 840   switch (table_tag)
 841   {
 842     case HB_OT_TAG_GSUB:
 843     {
<span class="line-modified"> 844       const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
 845       l.collect_glyphs (&amp;c);
 846       return;
 847     }
 848     case HB_OT_TAG_GPOS:
 849     {
<span class="line-modified"> 850       const OT::PosLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gpos-&gt;get_lookup (lookup_index);</span>
 851       l.collect_glyphs (&amp;c);
 852       return;
 853     }
 854   }
 855 }
 856 
 857 
 858 /* Variations support */
 859 
 860 hb_bool_t
 861 hb_ot_layout_table_find_feature_variations (hb_face_t    *face,
 862                                             hb_tag_t      table_tag,
 863                                             const int    *coords,
 864                                             unsigned int  num_coords,
 865                                             unsigned int *variations_index /* out */)
 866 {
 867   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 868 
 869   return g.find_variations_index (coords, num_coords, variations_index);
 870 }
</pre>
<hr />
<pre>
 877                                                   unsigned int  start_offset,
 878                                                   unsigned int *lookup_count /* IN/OUT */,
 879                                                   unsigned int *lookup_indexes /* OUT */)
 880 {
 881   static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), &quot;&quot;);
 882   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 883 
 884   const OT::Feature &amp;f = g.get_feature_variation (feature_index, variations_index);
 885 
 886   return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
 887 }
 888 
 889 
 890 /*
 891  * OT::GSUB
 892  */
 893 
 894 hb_bool_t
 895 hb_ot_layout_has_substitution (hb_face_t *face)
 896 {
<span class="line-modified"> 897   return &amp;_get_gsub (face) != &amp;Null(OT::GSUB);</span>
 898 }
 899 
 900 /**
 901  * hb_ot_layout_lookup_would_substitute:
 902  *
 903  * Since: 0.9.7
 904  **/
 905 hb_bool_t
 906 hb_ot_layout_lookup_would_substitute (hb_face_t            *face,
 907                                       unsigned int          lookup_index,
 908                                       const hb_codepoint_t *glyphs,
 909                                       unsigned int          glyphs_length,
 910                                       hb_bool_t             zero_context)
 911 {
<span class="line-modified"> 912   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return false;</span>
<span class="line-modified"> 913   return hb_ot_layout_lookup_would_substitute_fast (face, lookup_index, glyphs, glyphs_length, zero_context);</span>


 914 }
 915 
<span class="line-modified"> 916 hb_bool_t</span>
 917 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 918                                            unsigned int          lookup_index,
 919                                            const hb_codepoint_t *glyphs,
 920                                            unsigned int          glyphs_length,
<span class="line-modified"> 921                                            hb_bool_t             zero_context)</span>
 922 {
<span class="line-modified"> 923   if (unlikely (lookup_index &gt;= hb_ot_layout_from_face (face)-&gt;gsub_lookup_count)) return false;</span>
 924   OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
 925 
<span class="line-modified"> 926   const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
 927 
<span class="line-modified"> 928   return l.would_apply (&amp;c, &amp;hb_ot_layout_from_face (face)-&gt;gsub_accels[lookup_index]);</span>
 929 }
 930 
 931 void
<span class="line-modified"> 932 hb_ot_layout_substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>

 933 {
<span class="line-modified"> 934   OT::GSUB::substitute_start (font, buffer);</span>


















































 935 }
 936 
 937 /**
 938  * hb_ot_layout_lookup_substitute_closure:
 939  *
 940  * Since: 0.9.7
 941  **/
 942 void
 943 hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
 944                                         unsigned int  lookup_index,
 945                                         hb_set_t     *glyphs)
 946 {
<span class="line-modified"> 947   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
 948   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
 949 
<span class="line-modified"> 950   const OT::SubstLookup&amp; l = _get_gsub (face).get_lookup (lookup_index);</span>
 951 
 952   l.closure (&amp;c, lookup_index);
 953 }
 954 
 955 /**
 956  * hb_ot_layout_lookups_substitute_closure:
 957  *
 958  * Compute the transitive closure of glyphs needed for all of the
 959  * provided lookups.
 960  *
 961  * Since: 1.8.1
 962  **/
 963 void
 964 hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
 965                                          const hb_set_t *lookups,
 966                                          hb_set_t       *glyphs)
 967 {
<span class="line-modified"> 968   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
 969   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<span class="line-modified"> 970   const OT::GSUB&amp; gsub = _get_gsub (face);</span>
 971 

 972   unsigned int glyphs_length;
 973   do
 974   {
 975     glyphs_length = glyphs-&gt;get_population ();
 976     if (lookups != nullptr)
 977     {
 978       for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &amp;lookup_index);)
 979         gsub.get_lookup (lookup_index).closure (&amp;c, lookup_index);
 980     }
 981     else
 982     {
 983       for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
 984         gsub.get_lookup (i).closure (&amp;c, i);
 985     }
<span class="line-modified"> 986   } while (glyphs_length != glyphs-&gt;get_population ());</span>

 987 }
 988 
 989 /*
 990  * OT::GPOS
 991  */
 992 
 993 hb_bool_t
 994 hb_ot_layout_has_positioning (hb_face_t *face)
 995 {
<span class="line-modified"> 996   return &amp;_get_gpos (face) != &amp;Null(OT::GPOS);</span>
 997 }
 998 
 999 void
1000 hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
1001 {
1002   OT::GPOS::position_start (font, buffer);
1003 }
1004 
1005 void
1006 hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)
1007 {
1008   OT::GPOS::position_finish_advances (font, buffer);
1009 }
1010 
1011 void
1012 hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)
1013 {
1014   OT::GPOS::position_finish_offsets (font, buffer);
1015 }
1016 
1017 /**
1018  * hb_ot_layout_get_size_params:
1019  *
1020  * Since: 0.9.10
1021  **/
1022 hb_bool_t
<span class="line-modified">1023 hb_ot_layout_get_size_params (hb_face_t    *face,</span>
<span class="line-modified">1024                               unsigned int *design_size,       /* OUT.  May be nullptr */</span>
<span class="line-modified">1025                               unsigned int *subfamily_id,      /* OUT.  May be nullptr */</span>
<span class="line-modified">1026                               unsigned int *subfamily_name_id, /* OUT.  May be nullptr */</span>
<span class="line-modified">1027                               unsigned int *range_start,       /* OUT.  May be nullptr */</span>
<span class="line-modified">1028                               unsigned int *range_end          /* OUT.  May be nullptr */)</span>
1029 {
<span class="line-modified">1030   const OT::GPOS &amp;gpos = _get_gpos (face);</span>
1031   const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
1032 
1033   unsigned int num_features = gpos.get_feature_count ();
1034   for (unsigned int i = 0; i &lt; num_features; i++)
1035   {
1036     if (tag == gpos.get_feature_tag (i))
1037     {
1038       const OT::Feature &amp;f = gpos.get_feature (i);
1039       const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
1040 
1041       if (params.designSize)
1042       {
<span class="line-modified">1043 #define PARAM(a, A) if (a) *a = params.A</span>
<span class="line-modified">1044         PARAM (design_size, designSize);</span>
<span class="line-modified">1045         PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">1046         PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">1047         PARAM (range_start, rangeStart);</span>
<span class="line-removed">1048         PARAM (range_end, rangeEnd);</span>
<span class="line-removed">1049 #undef PARAM</span>
1050 
1051         return true;
1052       }
1053     }
1054   }
1055 
<span class="line-modified">1056 #define PARAM(a, A) if (a) *a = 0</span>
<span class="line-modified">1057   PARAM (design_size, designSize);</span>
<span class="line-modified">1058   PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">1059   PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">1060   PARAM (range_start, rangeStart);</span>
<span class="line-removed">1061   PARAM (range_end, rangeEnd);</span>
<span class="line-removed">1062 #undef PARAM</span>
1063 
1064   return false;
1065 }
1066 






























































































































1067 
1068 /*
1069  * Parts of different types are implemented here such that they have direct
1070  * access to GSUB/GPOS lookups.
1071  */
1072 
1073 
1074 struct GSUBProxy
1075 {
<span class="line-modified">1076   static const unsigned int table_index = 0;</span>
<span class="line-modified">1077   static const bool inplace = false;</span>
1078   typedef OT::SubstLookup Lookup;
1079 
1080   GSUBProxy (hb_face_t *face) :
<span class="line-modified">1081     table (*hb_ot_layout_from_face (face)-&gt;gsub),</span>
<span class="line-modified">1082     accels (hb_ot_layout_from_face (face)-&gt;gsub_accels) {}</span>
1083 
1084   const OT::GSUB &amp;table;
<span class="line-modified">1085   const hb_ot_layout_lookup_accelerator_t *accels;</span>
1086 };
1087 
1088 struct GPOSProxy
1089 {
<span class="line-modified">1090   static const unsigned int table_index = 1;</span>
<span class="line-modified">1091   static const bool inplace = true;</span>
1092   typedef OT::PosLookup Lookup;
1093 
1094   GPOSProxy (hb_face_t *face) :
<span class="line-modified">1095     table (*hb_ot_layout_from_face (face)-&gt;gpos),</span>
<span class="line-modified">1096     accels (hb_ot_layout_from_face (face)-&gt;gpos_accels) {}</span>
1097 
1098   const OT::GPOS &amp;table;
<span class="line-modified">1099   const hb_ot_layout_lookup_accelerator_t *accels;</span>
1100 };
1101 
1102 
<span class="line-removed">1103 struct hb_get_subtables_context_t :</span>
<span class="line-removed">1104        OT::hb_dispatch_context_t&lt;hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY&gt;</span>
<span class="line-removed">1105 {</span>
<span class="line-removed">1106   template &lt;typename Type&gt;</span>
<span class="line-removed">1107   static inline bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)</span>
<span class="line-removed">1108   {</span>
<span class="line-removed">1109     const Type *typed_obj = (const Type *) obj;</span>
<span class="line-removed">1110     return typed_obj-&gt;apply (c);</span>
<span class="line-removed">1111   }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113   typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);</span>
<span class="line-removed">1114 </span>
<span class="line-removed">1115   struct hb_applicable_t</span>
<span class="line-removed">1116   {</span>
<span class="line-removed">1117     inline void init (const void *obj_, hb_apply_func_t apply_func_)</span>
<span class="line-removed">1118     {</span>
<span class="line-removed">1119       obj = obj_;</span>
<span class="line-removed">1120       apply_func = apply_func_;</span>
<span class="line-removed">1121     }</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123     inline bool apply (OT::hb_ot_apply_context_t *c) const { return apply_func (obj, c); }</span>
<span class="line-removed">1124 </span>
<span class="line-removed">1125     private:</span>
<span class="line-removed">1126     const void *obj;</span>
<span class="line-removed">1127     hb_apply_func_t apply_func;</span>
<span class="line-removed">1128   };</span>
<span class="line-removed">1129 </span>
<span class="line-removed">1130   typedef hb_auto_t&lt;hb_vector_t&lt;hb_applicable_t&gt; &gt; array_t;</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132   /* Dispatch interface. */</span>
<span class="line-removed">1133   inline const char *get_name (void) { return &quot;GET_SUBTABLES&quot;; }</span>
<span class="line-removed">1134   template &lt;typename T&gt;</span>
<span class="line-removed">1135   inline return_t dispatch (const T &amp;obj)</span>
<span class="line-removed">1136   {</span>
<span class="line-removed">1137     hb_applicable_t *entry = array.push();</span>
<span class="line-removed">1138     entry-&gt;init (&amp;obj, apply_to&lt;T&gt;);</span>
<span class="line-removed">1139     return HB_VOID;</span>
<span class="line-removed">1140   }</span>
<span class="line-removed">1141   static return_t default_return_value (void) { return HB_VOID; }</span>
<span class="line-removed">1142   bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }</span>
<span class="line-removed">1143 </span>
<span class="line-removed">1144   hb_get_subtables_context_t (array_t &amp;array_) :</span>
<span class="line-removed">1145                               array (array_),</span>
<span class="line-removed">1146                               debug_depth (0) {}</span>
<span class="line-removed">1147 </span>
<span class="line-removed">1148   array_t &amp;array;</span>
<span class="line-removed">1149   unsigned int debug_depth;</span>
<span class="line-removed">1150 };</span>
<span class="line-removed">1151 </span>
1152 static inline bool
1153 apply_forward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">1154                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">1155                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
1156 {
1157   bool ret = false;
1158   hb_buffer_t *buffer = c-&gt;buffer;
1159   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
1160   {
1161     bool applied = false;
1162     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1163         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1164         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1165      {
<span class="line-modified">1166        for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">1167          if (subtables[i].apply (c))</span>
<span class="line-removed">1168          {</span>
<span class="line-removed">1169            applied = true;</span>
<span class="line-removed">1170            break;</span>
<span class="line-removed">1171          }</span>
1172      }
1173 
1174     if (applied)
1175       ret = true;
1176     else
1177       buffer-&gt;next_glyph ();
1178   }
1179   return ret;
1180 }
1181 
1182 static inline bool
1183 apply_backward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">1184                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">1185                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
1186 {
1187   bool ret = false;
1188   hb_buffer_t *buffer = c-&gt;buffer;
1189   do
1190   {
1191     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1192         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1193         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<span class="line-modified">1194     {</span>
<span class="line-modified">1195      for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">1196        if (subtables[i].apply (c))</span>
<span class="line-removed">1197        {</span>
<span class="line-removed">1198          ret = true;</span>
<span class="line-removed">1199          break;</span>
<span class="line-removed">1200        }</span>
<span class="line-removed">1201     }</span>
1202     /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
1203     buffer-&gt;idx--;
1204 
1205   }
1206   while ((int) buffer-&gt;idx &gt;= 0);
1207   return ret;
1208 }
1209 
1210 template &lt;typename Proxy&gt;
1211 static inline void
1212 apply_string (OT::hb_ot_apply_context_t *c,
1213               const typename Proxy::Lookup &amp;lookup,
<span class="line-modified">1214               const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1215 {
1216   hb_buffer_t *buffer = c-&gt;buffer;
1217 
1218   if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
1219     return;
1220 
1221   c-&gt;set_lookup_props (lookup.get_props ());
1222 
<span class="line-removed">1223   hb_get_subtables_context_t::array_t subtables;</span>
<span class="line-removed">1224   hb_get_subtables_context_t c_get_subtables (subtables);</span>
<span class="line-removed">1225   lookup.dispatch (&amp;c_get_subtables);</span>
<span class="line-removed">1226 </span>
1227   if (likely (!lookup.is_reverse ()))
1228   {
1229     /* in/out forward substitution/positioning */
<span class="line-modified">1230     if (Proxy::table_index == 0)</span>
1231       buffer-&gt;clear_output ();
1232     buffer-&gt;idx = 0;
1233 
1234     bool ret;
<span class="line-modified">1235     ret = apply_forward (c, accel, subtables);</span>
1236     if (ret)
1237     {
1238       if (!Proxy::inplace)
1239         buffer-&gt;swap_buffers ();
1240       else
1241         assert (!buffer-&gt;has_separate_output ());
1242     }
1243   }
1244   else
1245   {
1246     /* in-place backward substitution/positioning */
<span class="line-modified">1247     if (Proxy::table_index == 0)</span>
1248       buffer-&gt;remove_output ();
1249     buffer-&gt;idx = buffer-&gt;len - 1;
1250 
<span class="line-modified">1251     apply_backward (c, accel, subtables);</span>
1252   }
1253 }
1254 
1255 template &lt;typename Proxy&gt;
1256 inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
1257                                 const hb_ot_shape_plan_t *plan,
1258                                 hb_font_t *font,
1259                                 hb_buffer_t *buffer) const
1260 {
1261   const unsigned int table_index = proxy.table_index;
1262   unsigned int i = 0;
1263   OT::hb_ot_apply_context_t c (table_index, font, buffer);
1264   c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
1265 
<span class="line-modified">1266   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].len; stage_index++) {</span>
1267     const stage_map_t *stage = &amp;stages[table_index][stage_index];
1268     for (; i &lt; stage-&gt;last_lookup; i++)
1269     {
1270       unsigned int lookup_index = lookups[table_index][i].index;
1271       if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
1272       c.set_lookup_index (lookup_index);
1273       c.set_lookup_mask (lookups[table_index][i].mask);
1274       c.set_auto_zwj (lookups[table_index][i].auto_zwj);
1275       c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);





1276       apply_string&lt;Proxy&gt; (&amp;c,
1277                            proxy.table.get_lookup (lookup_index),
1278                            proxy.accels[lookup_index]);
1279       (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
1280     }
1281 
1282     if (stage-&gt;pause_func)
1283     {
1284       buffer-&gt;clear_output ();
1285       stage-&gt;pause_func (plan, font, buffer);
1286     }
1287   }
1288 }
1289 
1290 void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1291 {
1292   GSUBProxy proxy (font-&gt;face);
1293   apply (proxy, plan, font, buffer);
1294 }
1295 
1296 void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1297 {
1298   GPOSProxy proxy (font-&gt;face);
1299   apply (proxy, plan, font, buffer);
1300 }
1301 
1302 void
1303 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
1304                                 const OT::SubstLookup &amp;lookup,
<span class="line-modified">1305                                 const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1306 {
1307   apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
1308 }
1309 





1310 











1311 


1312 






1313 /*
<span class="line-modified">1314  * OT::BASE</span>
1315  */
1316 
<span class="line-modified">1317 // /**</span>
<span class="line-modified">1318 //  * hb_ot_base_has_data:</span>
<span class="line-modified">1319 //  * @face: #hb_face_t to test</span>
<span class="line-modified">1320 //  *</span>
<span class="line-modified">1321 //  * This function allows to verify the presence of an OpenType BASE table on the</span>
<span class="line-modified">1322 //  * face.</span>
<span class="line-modified">1323 //  *</span>
<span class="line-modified">1324 //  * Return value: true if face has a BASE table, false otherwise</span>
<span class="line-modified">1325 //  *</span>
<span class="line-modified">1326 //  * Since: XXX</span>
<span class="line-modified">1327 //  **/</span>
<span class="line-modified">1328 // hb_bool_t</span>
<span class="line-modified">1329 // hb_ot_base_has_data (hb_face_t *face)</span>
<span class="line-modified">1330 // {</span>
<span class="line-modified">1331 //   return &amp;_get_base (face) != &amp;Null(OT::BASE);</span>
<span class="line-modified">1332 // }</span>










</pre>
</td>
<td>
<hr />
<pre>
  11  * software and its documentation for any purpose, provided that the
  12  * above copyright notice and the following two paragraphs appear in
  13  * all copies of this software.
  14  *
  15  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  16  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  17  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  18  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  19  * DAMAGE.
  20  *
  21  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  22  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  23  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  24  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  25  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  26  *
  27  * Red Hat Author(s): Behdad Esfahbod
  28  * Google Author(s): Behdad Esfahbod
  29  */
  30 
<span class="line-modified">  31 #include &quot;hb-open-type.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-layout.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">  34 #include &quot;hb-ot-map.hh&quot;</span>
<span class="line-added">  35 #include &quot;hb-map.hh&quot;</span>
<span class="line-added">  36 </span>
<span class="line-added">  37 #include &quot;hb-ot-kern-table.hh&quot;</span>
<span class="line-added">  38 #include &quot;hb-ot-gasp-table.hh&quot; // Just so we compile it; unused otherwise.</span>
  39 #include &quot;hb-ot-layout-gdef-table.hh&quot;
  40 #include &quot;hb-ot-layout-gsub-table.hh&quot;
  41 #include &quot;hb-ot-layout-gpos-table.hh&quot;
<span class="line-modified">  42 #include &quot;hb-ot-layout-base-table.hh&quot; // Just so we compile it; unused otherwise.</span>
<span class="line-modified">  43 #include &quot;hb-ot-layout-jstf-table.hh&quot; // Just so we compile it; unused otherwise.</span>






  44 #include &quot;hb-ot-name-table.hh&quot;
<span class="line-modified">  45 #include &quot;hb-ot-os2-table.hh&quot;</span>











  46 
<span class="line-modified">  47 #include &quot;hb-aat-layout-lcar-table.hh&quot;</span>
<span class="line-modified">  48 #include &quot;hb-aat-layout-morx-table.hh&quot;</span>
  49 


  50 
<span class="line-modified">  51 /**</span>
<span class="line-modified">  52  * SECTION:hb-ot-layout</span>
<span class="line-modified">  53  * @title: hb-ot-layout</span>
<span class="line-modified">  54  * @short_description: OpenType Layout</span>
<span class="line-modified">  55  * @include: hb-ot.h</span>
<span class="line-modified">  56  *</span>
<span class="line-modified">  57  * Functions for querying OpenType Layout features in the font face.</span>
<span class="line-modified">  58  **/</span>






































































































  59 


  60 
<span class="line-modified">  61 /*</span>
<span class="line-modified">  62  * kern</span>
<span class="line-added">  63  */</span>
  64 
<span class="line-modified">  65 bool</span>
<span class="line-modified">  66 hb_ot_layout_has_kerning (hb_face_t *face)</span>
<span class="line-modified">  67 {</span>
<span class="line-modified">  68   return face-&gt;table.kern-&gt;has_data ();</span>
<span class="line-modified">  69 }</span>

  70 
<span class="line-modified">  71 bool</span>
<span class="line-modified">  72 hb_ot_layout_has_machine_kerning (hb_face_t *face)</span>
<span class="line-modified">  73 {</span>
<span class="line-modified">  74   return face-&gt;table.kern-&gt;has_state_machine ();</span>
<span class="line-added">  75 }</span>
  76 
<span class="line-modified">  77 bool</span>
<span class="line-added">  78 hb_ot_layout_has_cross_kerning (hb_face_t *face)</span>
<span class="line-added">  79 {</span>
<span class="line-added">  80   return face-&gt;table.kern-&gt;has_cross_stream ();</span>
  81 }
  82 
  83 void
<span class="line-modified">  84 hb_ot_layout_kern (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">  85                    hb_font_t *font,</span>
<span class="line-added">  86                    hb_buffer_t  *buffer)</span>
  87 {
<span class="line-modified">  88   hb_blob_t *blob = font-&gt;face-&gt;table.kern.get_blob ();</span>
<span class="line-modified">  89   const AAT::kern&amp; kern = *blob-&gt;as&lt;AAT::kern&gt; ();</span>







  90 
<span class="line-modified">  91   AAT::hb_aat_apply_context_t c (plan, font, buffer, blob);</span>


  92 
<span class="line-modified">  93   kern.apply (&amp;c);</span>




  94 }
  95 







  96 
<span class="line-modified">  97 /*</span>
<span class="line-modified">  98  * GDEF</span>
<span class="line-modified">  99  */</span>
<span class="line-modified"> 100 </span>
<span class="line-modified"> 101 bool</span>
<span class="line-modified"> 102 OT::GDEF::is_blacklisted (hb_blob_t *blob,</span>
<span class="line-modified"> 103                           hb_face_t *face) const</span>

 104 {
<span class="line-modified"> 105   /* The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified"> 106    * See this thread for why we finally had to bend in and do this:</span>
<span class="line-added"> 107    * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-added"> 108    *</span>
<span class="line-added"> 109    * In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-added"> 110    * ASCII double quotation mark U+0022 has wrong glyph class 3 (mark)</span>
<span class="line-added"> 111    * in GDEF.  Many versions of Tahoma have bad GDEF tables that</span>
<span class="line-added"> 112    * incorrectly classify some spacing marks such as certain IPA</span>
<span class="line-added"> 113    * symbols as glyph class 3. So do older versions of Microsoft</span>
<span class="line-added"> 114    * Himalaya, and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-added"> 115    *</span>
<span class="line-added"> 116    * Nuke the GDEF tables of to avoid unwanted width-zeroing.</span>
<span class="line-added"> 117    *</span>
<span class="line-added"> 118    * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-added"> 119    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-added"> 120    *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-added"> 121    */</span>
<span class="line-added"> 122 #define ENCODE(x,y,z) (((uint64_t) (x) &lt;&lt; 48) | ((uint64_t) (y) &lt;&lt; 24) | (uint64_t) (z))</span>
<span class="line-added"> 123   switch ENCODE(blob-&gt;length,</span>
<span class="line-added"> 124                 face-&gt;table.GSUB-&gt;table.get_length (),</span>
<span class="line-added"> 125                 face-&gt;table.GPOS-&gt;table.get_length ())</span>
<span class="line-added"> 126   {</span>
<span class="line-added"> 127     /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-added"> 128     case ENCODE (442, 2874, 42038):</span>
<span class="line-added"> 129     /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-added"> 130     case ENCODE (430, 2874, 40662):</span>
<span class="line-added"> 131     /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-added"> 132     case ENCODE (442, 2874, 39116):</span>
<span class="line-added"> 133     /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-added"> 134     case ENCODE (430, 2874, 39374):</span>
<span class="line-added"> 135     /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-added"> 136     case ENCODE (490, 3046, 41638):</span>
<span class="line-added"> 137     /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-added"> 138     case ENCODE (478, 3046, 41902):</span>
<span class="line-added"> 139     /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-added"> 140     case ENCODE (898, 12554, 46470):</span>
<span class="line-added"> 141     /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-added"> 142     case ENCODE (910, 12566, 47732):</span>
<span class="line-added"> 143     /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-added"> 144     case ENCODE (928, 23298, 59332):</span>
<span class="line-added"> 145     /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-added"> 146     case ENCODE (940, 23310, 60732):</span>
<span class="line-added"> 147     /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 148     case ENCODE (964, 23836, 60072):</span>
<span class="line-added"> 149     /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 150     case ENCODE (976, 23832, 61456):</span>
<span class="line-added"> 151     /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-added"> 152     case ENCODE (994, 24474, 60336):</span>
<span class="line-added"> 153     /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-added"> 154     case ENCODE (1006, 24470, 61740):</span>
<span class="line-added"> 155     /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 156     case ENCODE (1006, 24576, 61346):</span>
<span class="line-added"> 157     /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-added"> 158     case ENCODE (1018, 24572, 62828):</span>
<span class="line-added"> 159     /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-added"> 160     case ENCODE (1006, 24576, 61352):</span>
<span class="line-added"> 161     /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-added"> 162     case ENCODE (1018, 24572, 62834):</span>
<span class="line-added"> 163     /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-added"> 164     case ENCODE (832, 7324, 47162):</span>
<span class="line-added"> 165     /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-added"> 166     case ENCODE (844, 7302, 45474):</span>
<span class="line-added"> 167     /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-added"> 168     case ENCODE (180, 13054, 7254):</span>
<span class="line-added"> 169     /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-added"> 170     case ENCODE (192, 12638, 7254):</span>
<span class="line-added"> 171     /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-added"> 172     case ENCODE (192, 12690, 7254):</span>
<span class="line-added"> 173     /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-added"> 174     /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-added"> 175     case ENCODE (188, 248, 3852):</span>
<span class="line-added"> 176     /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-added"> 177     /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-added"> 178     case ENCODE (188, 264, 3426):</span>
<span class="line-added"> 179     /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-added"> 180     case ENCODE (1058, 47032, 11818):</span>
<span class="line-added"> 181     /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-added"> 182     case ENCODE (1046, 47030, 12600):</span>
<span class="line-added"> 183     /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-added"> 184     case ENCODE (1058, 71796, 16770):</span>
<span class="line-added"> 185     /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-added"> 186     case ENCODE (1046, 71790, 17862):</span>
<span class="line-added"> 187     /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-added"> 188     case ENCODE (1046, 71788, 17112):</span>
<span class="line-added"> 189     /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-added"> 190     case ENCODE (1058, 71794, 17514):</span>
<span class="line-added"> 191     /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-added"> 192     case ENCODE (1330, 109904, 57938):</span>
<span class="line-added"> 193     /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-added"> 194     case ENCODE (1330, 109904, 58972):</span>
<span class="line-added"> 195     /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-added"> 196      *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-added"> 197     case ENCODE (1004, 59092, 14836):</span>
<span class="line-added"> 198       return true;</span>
<span class="line-added"> 199 #undef ENCODE</span>
<span class="line-added"> 200   }</span>
<span class="line-added"> 201   return false;</span>
 202 }
<span class="line-modified"> 203 </span>
<span class="line-modified"> 204 static void</span>
<span class="line-added"> 205 _hb_ot_layout_set_glyph_props (hb_font_t *font,</span>
<span class="line-added"> 206                                hb_buffer_t *buffer)</span>
 207 {
<span class="line-modified"> 208   _hb_buffer_assert_gsubgpos_vars (buffer);</span>
<span class="line-modified"> 209 </span>
<span class="line-added"> 210   const OT::GDEF &amp;gdef = *font-&gt;face-&gt;table.GDEF-&gt;table;</span>
<span class="line-added"> 211   unsigned int count = buffer-&gt;len;</span>
<span class="line-added"> 212   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 213   {</span>
<span class="line-added"> 214     _hb_glyph_info_set_glyph_props (&amp;buffer-&gt;info[i], gdef.get_glyph_props (buffer-&gt;info[i].codepoint));</span>
<span class="line-added"> 215     _hb_glyph_info_clear_lig_props (&amp;buffer-&gt;info[i]);</span>
<span class="line-added"> 216     buffer-&gt;info[i].syllable() = 0;</span>
<span class="line-added"> 217   }</span>
 218 }
 219 
<span class="line-modified"> 220 /* Public API */</span>


 221 
 222 hb_bool_t
 223 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 224 {
<span class="line-modified"> 225   return face-&gt;table.GDEF-&gt;table-&gt;has_glyph_classes ();</span>
 226 }
 227 
 228 /**
 229  * hb_ot_layout_get_glyph_class:
 230  *
 231  * Since: 0.9.7
 232  **/
 233 hb_ot_layout_glyph_class_t
 234 hb_ot_layout_get_glyph_class (hb_face_t      *face,
 235                               hb_codepoint_t  glyph)
 236 {
<span class="line-modified"> 237   return (hb_ot_layout_glyph_class_t) face-&gt;table.GDEF-&gt;table-&gt;get_glyph_class (glyph);</span>
 238 }
 239 
 240 /**
 241  * hb_ot_layout_get_glyphs_in_class:
 242  *
 243  * Since: 0.9.7
 244  **/
 245 void
 246 hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
 247                                   hb_ot_layout_glyph_class_t  klass,
 248                                   hb_set_t                   *glyphs /* OUT */)
 249 {
<span class="line-modified"> 250   return face-&gt;table.GDEF-&gt;table-&gt;get_glyphs_in_class (klass, glyphs);</span>
 251 }
 252 
 253 unsigned int
 254 hb_ot_layout_get_attach_points (hb_face_t      *face,
 255                                 hb_codepoint_t  glyph,
 256                                 unsigned int    start_offset,
 257                                 unsigned int   *point_count /* IN/OUT */,
 258                                 unsigned int   *point_array /* OUT */)
 259 {
<span class="line-modified"> 260   return face-&gt;table.GDEF-&gt;table-&gt;get_attach_points (glyph,</span>
<span class="line-added"> 261                                                      start_offset,</span>
<span class="line-added"> 262                                                      point_count,</span>
<span class="line-added"> 263                                                      point_array);</span>
 264 }
 265 
 266 unsigned int
 267 hb_ot_layout_get_ligature_carets (hb_font_t      *font,
 268                                   hb_direction_t  direction,
 269                                   hb_codepoint_t  glyph,
 270                                   unsigned int    start_offset,
 271                                   unsigned int   *caret_count /* IN/OUT */,
 272                                   hb_position_t  *caret_array /* OUT */)
 273 {
<span class="line-modified"> 274   unsigned int result_caret_count = 0;</span>
<span class="line-added"> 275   unsigned int result = font-&gt;face-&gt;table.GDEF-&gt;table-&gt;get_lig_carets (font, direction, glyph, start_offset, &amp;result_caret_count, caret_array);</span>
<span class="line-added"> 276   if (result)</span>
<span class="line-added"> 277   {</span>
<span class="line-added"> 278     if (caret_count) *caret_count = result_caret_count;</span>
<span class="line-added"> 279   }</span>
<span class="line-added"> 280   else</span>
<span class="line-added"> 281     result = font-&gt;face-&gt;table.lcar-&gt;get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>
<span class="line-added"> 282   return result;</span>
 283 }
 284 
 285 
 286 /*
 287  * GSUB/GPOS
 288  */
 289 
<span class="line-added"> 290 bool</span>
<span class="line-added"> 291 OT::GSUB::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added"> 292                           hb_face_t *face) const</span>
<span class="line-added"> 293 {</span>
<span class="line-added"> 294   /* Mac OS X prefers morx over GSUB.  It also ships with various Indic fonts,</span>
<span class="line-added"> 295    * all by &#39;MUTF&#39; foundry (Tamil MN, Tamil Sangam MN, etc.), that have broken</span>
<span class="line-added"> 296    * GSUB/GPOS tables.  Some have GSUB with zero scripts, those are ignored by</span>
<span class="line-added"> 297    * our morx/GSUB preference code.  But if GSUB has non-zero scripts, we tend</span>
<span class="line-added"> 298    * to prefer it over morx because we want to be consistent with other OpenType</span>
<span class="line-added"> 299    * shapers.</span>
<span class="line-added"> 300    *</span>
<span class="line-added"> 301    * To work around broken Indic Mac system fonts, we ignore GSUB table if</span>
<span class="line-added"> 302    * OS/2 VendorId is &#39;MUTF&#39; and font has morx table as well.</span>
<span class="line-added"> 303    *</span>
<span class="line-added"> 304    * https://github.com/harfbuzz/harfbuzz/issues/1410</span>
<span class="line-added"> 305    * https://github.com/harfbuzz/harfbuzz/issues/1348</span>
<span class="line-added"> 306    * https://github.com/harfbuzz/harfbuzz/issues/1391</span>
<span class="line-added"> 307    */</span>
<span class="line-added"> 308   if (unlikely (face-&gt;table.OS2-&gt;achVendID == HB_TAG (&#39;M&#39;,&#39;U&#39;,&#39;T&#39;,&#39;F&#39;) &amp;&amp;</span>
<span class="line-added"> 309                 face-&gt;table.morx-&gt;has_data ()))</span>
<span class="line-added"> 310     return true;</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   return false;</span>
<span class="line-added"> 313 }</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315 bool</span>
<span class="line-added"> 316 OT::GPOS::is_blacklisted (hb_blob_t *blob HB_UNUSED,</span>
<span class="line-added"> 317                           hb_face_t *face HB_UNUSED) const</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319   return false;</span>
<span class="line-added"> 320 }</span>
<span class="line-added"> 321 </span>
 322 static const OT::GSUBGPOS&amp;
 323 get_gsubgpos_table (hb_face_t *face,
 324                     hb_tag_t   table_tag)
 325 {
 326   switch (table_tag) {
<span class="line-modified"> 327     case HB_OT_TAG_GSUB: return *face-&gt;table.GSUB-&gt;table;</span>
<span class="line-modified"> 328     case HB_OT_TAG_GPOS: return *face-&gt;table.GPOS-&gt;table;</span>
 329     default:             return Null(OT::GSUBGPOS);
 330   }
 331 }
 332 
 333 
 334 unsigned int
 335 hb_ot_layout_table_get_script_tags (hb_face_t    *face,
 336                                     hb_tag_t      table_tag,
 337                                     unsigned int  start_offset,
 338                                     unsigned int *script_count /* IN/OUT */,
<span class="line-modified"> 339                                     hb_tag_t     *script_tags  /* OUT */)</span>
 340 {
 341   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 342 
 343   return g.get_script_tags (start_offset, script_count, script_tags);
 344 }
 345 
 346 #define HB_OT_TAG_LATIN_SCRIPT          HB_TAG (&#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;n&#39;)
 347 
 348 hb_bool_t
 349 hb_ot_layout_table_find_script (hb_face_t    *face,
 350                                 hb_tag_t      table_tag,
 351                                 hb_tag_t      script_tag,
 352                                 unsigned int *script_index)
 353 {
 354   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 355   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 356 
 357   if (g.find_script_index (script_tag, script_index))
 358     return true;
 359 
</pre>
<hr />
<pre>
 364   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :(.
 365    * including many versions of DejaVu Sans Mono! */
 366   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
 367     return false;
 368 
 369   /* try with &#39;latn&#39;; some old fonts put their features there even though
 370      they&#39;re really trying to support Thai, for example :( */
 371   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))
 372     return false;
 373 
 374   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 375   return false;
 376 }
 377 
 378 hb_bool_t
 379 hb_ot_layout_table_choose_script (hb_face_t      *face,
 380                                   hb_tag_t        table_tag,
 381                                   const hb_tag_t *script_tags,
 382                                   unsigned int   *script_index,
 383                                   hb_tag_t       *chosen_script)
<span class="line-added"> 384 {</span>
<span class="line-added"> 385   const hb_tag_t *t;</span>
<span class="line-added"> 386   for (t = script_tags; *t; t++);</span>
<span class="line-added"> 387   return hb_ot_layout_table_select_script (face, table_tag, t - script_tags, script_tags, script_index, chosen_script);</span>
<span class="line-added"> 388 }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390 /**</span>
<span class="line-added"> 391  * hb_ot_layout_table_select_script:</span>
<span class="line-added"> 392  *</span>
<span class="line-added"> 393  * Since: 2.0.0</span>
<span class="line-added"> 394  **/</span>
<span class="line-added"> 395 hb_bool_t</span>
<span class="line-added"> 396 hb_ot_layout_table_select_script (hb_face_t      *face,</span>
<span class="line-added"> 397                                   hb_tag_t        table_tag,</span>
<span class="line-added"> 398                                   unsigned int    script_count,</span>
<span class="line-added"> 399                                   const hb_tag_t *script_tags,</span>
<span class="line-added"> 400                                   unsigned int   *script_index  /* OUT */,</span>
<span class="line-added"> 401                                   hb_tag_t       *chosen_script /* OUT */)</span>
 402 {
 403   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 404   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
<span class="line-added"> 405   unsigned int i;</span>
 406 
<span class="line-modified"> 407   for (i = 0; i &lt; script_count; i++)</span>
 408   {
<span class="line-modified"> 409     if (g.find_script_index (script_tags[i], script_index))</span>
<span class="line-added"> 410     {</span>
 411       if (chosen_script)
<span class="line-modified"> 412         *chosen_script = script_tags[i];</span>
 413       return true;
 414     }

 415   }
 416 
 417   /* try finding &#39;DFLT&#39; */
 418   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
 419     if (chosen_script)
 420       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
 421     return false;
 422   }
 423 
 424   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 425   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
 426     if (chosen_script)
 427       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
 428     return false;
 429   }
 430 
 431   /* try with &#39;latn&#39;; some old fonts put their features there even though
 432      they&#39;re really trying to support Thai, for example :( */
 433   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
 434     if (chosen_script)
 435       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
 436     return false;
 437   }
 438 
 439   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 440   if (chosen_script)
 441     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 442   return false;
 443 }
 444 
 445 unsigned int
 446 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 447                                      hb_tag_t      table_tag,
 448                                      unsigned int  start_offset,
 449                                      unsigned int *feature_count /* IN/OUT */,
<span class="line-modified"> 450                                      hb_tag_t     *feature_tags  /* OUT */)</span>
 451 {
 452   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 453 
 454   return g.get_feature_tags (start_offset, feature_count, feature_tags);
 455 }
 456 
<span class="line-modified"> 457 bool</span>
 458 hb_ot_layout_table_find_feature (hb_face_t    *face,
 459                                  hb_tag_t      table_tag,
 460                                  hb_tag_t      feature_tag,
 461                                  unsigned int *feature_index)
 462 {
 463   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 464   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 465 
 466   unsigned int num_features = g.get_feature_count ();
 467   for (unsigned int i = 0; i &lt; num_features; i++)
 468   {
 469     if (feature_tag == g.get_feature_tag (i)) {
 470       if (feature_index) *feature_index = i;
 471       return true;
 472     }
 473   }
 474 
 475   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 476   return false;
 477 }
 478 
 479 
 480 unsigned int
 481 hb_ot_layout_script_get_language_tags (hb_face_t    *face,
 482                                        hb_tag_t      table_tag,
 483                                        unsigned int  script_index,
 484                                        unsigned int  start_offset,
 485                                        unsigned int *language_count /* IN/OUT */,
<span class="line-modified"> 486                                        hb_tag_t     *language_tags  /* OUT */)</span>
 487 {
 488   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 489 
 490   return s.get_lang_sys_tags (start_offset, language_count, language_tags);
 491 }
 492 
 493 hb_bool_t
 494 hb_ot_layout_script_find_language (hb_face_t    *face,
 495                                    hb_tag_t      table_tag,
 496                                    unsigned int  script_index,
 497                                    hb_tag_t      language_tag,
 498                                    unsigned int *language_index)
<span class="line-added"> 499 {</span>
<span class="line-added"> 500   return hb_ot_layout_script_select_language (face,</span>
<span class="line-added"> 501                                               table_tag,</span>
<span class="line-added"> 502                                               script_index,</span>
<span class="line-added"> 503                                               1,</span>
<span class="line-added"> 504                                               &amp;language_tag,</span>
<span class="line-added"> 505                                               language_index);</span>
<span class="line-added"> 506 }</span>
<span class="line-added"> 507 </span>
<span class="line-added"> 508 /**</span>
<span class="line-added"> 509  * hb_ot_layout_script_select_language:</span>
<span class="line-added"> 510  *</span>
<span class="line-added"> 511  * Since: 2.0.0</span>
<span class="line-added"> 512  **/</span>
<span class="line-added"> 513 hb_bool_t</span>
<span class="line-added"> 514 hb_ot_layout_script_select_language (hb_face_t      *face,</span>
<span class="line-added"> 515                                      hb_tag_t        table_tag,</span>
<span class="line-added"> 516                                      unsigned int    script_index,</span>
<span class="line-added"> 517                                      unsigned int    language_count,</span>
<span class="line-added"> 518                                      const hb_tag_t *language_tags,</span>
<span class="line-added"> 519                                      unsigned int   *language_index /* OUT */)</span>
 520 {
 521   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
 522   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
<span class="line-added"> 523   unsigned int i;</span>
 524 
<span class="line-modified"> 525   for (i = 0; i &lt; language_count; i++)</span>
<span class="line-modified"> 526   {</span>
<span class="line-added"> 527     if (s.find_lang_sys_index (language_tags[i], language_index))</span>
<span class="line-added"> 528       return true;</span>
<span class="line-added"> 529   }</span>
 530 
<span class="line-modified"> 531   /* try finding &#39;dflt&#39; */</span>
 532   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
 533     return false;
 534 
 535   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
 536   return false;
 537 }
 538 
 539 hb_bool_t
 540 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 541                                                   hb_tag_t      table_tag,
 542                                                   unsigned int  script_index,
 543                                                   unsigned int  language_index,
 544                                                   unsigned int *feature_index)
 545 {
 546   return hb_ot_layout_language_get_required_feature (face,
 547                                                      table_tag,
 548                                                      script_index,
 549                                                      language_index,
 550                                                      feature_index,
 551                                                      nullptr);
</pre>
<hr />
<pre>
 563                                             unsigned int  language_index,
 564                                             unsigned int *feature_index,
 565                                             hb_tag_t     *feature_tag)
 566 {
 567   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 568   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 569 
 570   unsigned int index = l.get_required_feature_index ();
 571   if (feature_index) *feature_index = index;
 572   if (feature_tag) *feature_tag = g.get_feature_tag (index);
 573 
 574   return l.has_required_feature ();
 575 }
 576 
 577 unsigned int
 578 hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
 579                                            hb_tag_t      table_tag,
 580                                            unsigned int  script_index,
 581                                            unsigned int  language_index,
 582                                            unsigned int  start_offset,
<span class="line-modified"> 583                                            unsigned int *feature_count   /* IN/OUT */,</span>
 584                                            unsigned int *feature_indexes /* OUT */)
 585 {
 586   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 587   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 588 
 589   return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
 590 }
 591 
 592 unsigned int
 593 hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
 594                                         hb_tag_t      table_tag,
 595                                         unsigned int  script_index,
 596                                         unsigned int  language_index,
 597                                         unsigned int  start_offset,
 598                                         unsigned int *feature_count /* IN/OUT */,
<span class="line-modified"> 599                                         hb_tag_t     *feature_tags  /* OUT */)</span>
 600 {
 601   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 602   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 603 
 604   static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
 605   unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
 606 
 607   if (feature_tags) {
 608     unsigned int count = *feature_count;
 609     for (unsigned int i = 0; i &lt; count; i++)
 610       feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
 611   }
 612 
 613   return ret;
 614 }
 615 
 616 
 617 hb_bool_t
 618 hb_ot_layout_language_find_feature (hb_face_t    *face,
 619                                     hb_tag_t      table_tag,
</pre>
<hr />
<pre>
 633     if (feature_tag == g.get_feature_tag (f_index)) {
 634       if (feature_index) *feature_index = f_index;
 635       return true;
 636     }
 637   }
 638 
 639   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 640   return false;
 641 }
 642 
 643 /**
 644  * hb_ot_layout_feature_get_lookups:
 645  *
 646  * Since: 0.9.7
 647  **/
 648 unsigned int
 649 hb_ot_layout_feature_get_lookups (hb_face_t    *face,
 650                                   hb_tag_t      table_tag,
 651                                   unsigned int  feature_index,
 652                                   unsigned int  start_offset,
<span class="line-modified"> 653                                   unsigned int *lookup_count   /* IN/OUT */,</span>
 654                                   unsigned int *lookup_indexes /* OUT */)
 655 {
 656   return hb_ot_layout_feature_with_variations_get_lookups (face,
 657                                                            table_tag,
 658                                                            feature_index,
 659                                                            HB_OT_LAYOUT_NO_VARIATIONS_INDEX,
 660                                                            start_offset,
 661                                                            lookup_count,
 662                                                            lookup_indexes);
 663 }
 664 
 665 /**
 666  * hb_ot_layout_table_get_lookup_count:
 667  *
 668  * Since: 0.9.22
 669  **/
 670 unsigned int
 671 hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
 672                                      hb_tag_t      table_tag)
 673 {
<span class="line-modified"> 674   return get_gsubgpos_table (face, table_tag).get_lookup_count ();</span>












 675 }
 676 
<span class="line-modified"> 677 </span>
<span class="line-modified"> 678 struct hb_collect_features_context_t</span>



 679 {
<span class="line-modified"> 680   hb_collect_features_context_t (hb_face_t       *face,</span>
<span class="line-modified"> 681                                  hb_tag_t         table_tag,</span>
<span class="line-modified"> 682                                  hb_set_t        *feature_indexes_)</span>
<span class="line-modified"> 683     : g (get_gsubgpos_table (face, table_tag)),</span>
<span class="line-modified"> 684       feature_indexes (feature_indexes_),</span>
<span class="line-modified"> 685       script_count(0),langsys_count(0) {}</span>
<span class="line-modified"> 686 </span>
<span class="line-modified"> 687   bool visited (const OT::Script &amp;s)</span>
<span class="line-modified"> 688   {</span>
<span class="line-modified"> 689     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-modified"> 690      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-modified"> 691     if (unlikely (!s.has_default_lang_sys () &amp;&amp;</span>
<span class="line-modified"> 692                   !s.get_lang_sys_count ()))</span>
<span class="line-modified"> 693       return true;</span>
<span class="line-modified"> 694 </span>
<span class="line-modified"> 695     if (script_count++ &gt; HB_MAX_SCRIPTS)</span>
<span class="line-modified"> 696       return true;</span>
<span class="line-modified"> 697 </span>
<span class="line-added"> 698     return visited (s, visited_script);</span>
<span class="line-added"> 699   }</span>
<span class="line-added"> 700   bool visited (const OT::LangSys &amp;l)</span>
<span class="line-added"> 701   {</span>
<span class="line-added"> 702     /* We might have Null() object here.  Don&#39;t want to involve</span>
<span class="line-added"> 703      * that in the memoize.  So, detect empty objects and return. */</span>
<span class="line-added"> 704     if (unlikely (!l.has_required_feature () &amp;&amp;</span>
<span class="line-added"> 705                   !l.get_feature_count ()))</span>
<span class="line-added"> 706       return true;</span>
<span class="line-added"> 707 </span>
<span class="line-added"> 708     if (langsys_count++ &gt; HB_MAX_LANGSYS)</span>
<span class="line-added"> 709       return true;</span>
<span class="line-added"> 710 </span>
<span class="line-added"> 711     return visited (l, visited_langsys);</span>
<span class="line-added"> 712   }</span>
<span class="line-added"> 713 </span>
<span class="line-added"> 714   private:</span>
<span class="line-added"> 715   template &lt;typename T&gt;</span>
<span class="line-added"> 716   bool visited (const T &amp;p, hb_set_t &amp;visited_set)</span>
<span class="line-added"> 717   {</span>
<span class="line-added"> 718     hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) &amp;p - (uintptr_t) &amp;g);</span>
<span class="line-added"> 719      if (visited_set.has (delta))</span>
<span class="line-added"> 720       return true;</span>
<span class="line-added"> 721 </span>
<span class="line-added"> 722     visited_set.add (delta);</span>
<span class="line-added"> 723     return false;</span>
<span class="line-added"> 724   }</span>
<span class="line-added"> 725 </span>
<span class="line-added"> 726   public:</span>
<span class="line-added"> 727   const OT::GSUBGPOS &amp;g;</span>
<span class="line-added"> 728   hb_set_t           *feature_indexes;</span>
<span class="line-added"> 729 </span>
<span class="line-added"> 730   private:</span>
<span class="line-added"> 731   hb_set_t visited_script;</span>
<span class="line-added"> 732   hb_set_t visited_langsys;</span>
<span class="line-added"> 733   unsigned int script_count;</span>
<span class="line-added"> 734   unsigned int langsys_count;</span>
<span class="line-added"> 735 };</span>
 736 
 737 static void
<span class="line-modified"> 738 langsys_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified"> 739                           const OT::LangSys  &amp;l,</span>
<span class="line-modified"> 740                           const hb_tag_t     *features)</span>



 741 {
<span class="line-added"> 742   if (c-&gt;visited (l)) return;</span>
<span class="line-added"> 743 </span>
 744   if (!features)
 745   {
<span class="line-modified"> 746     /* All features. */</span>
<span class="line-modified"> 747     if (l.has_required_feature ())</span>
<span class="line-modified"> 748       c-&gt;feature_indexes-&gt;add (l.get_required_feature_index ());</span>
<span class="line-modified"> 749 </span>
<span class="line-modified"> 750     l.add_feature_indexes_to (c-&gt;feature_indexes);</span>





























 751   }
 752   else
 753   {
<span class="line-added"> 754     /* Ugh. Any faster way? */</span>
 755     for (; *features; features++)
 756     {
<span class="line-modified"> 757       hb_tag_t feature_tag = *features;</span>
<span class="line-modified"> 758       unsigned int num_features = l.get_feature_count ();</span>
<span class="line-modified"> 759       for (unsigned int i = 0; i &lt; num_features; i++)</span>
<span class="line-modified"> 760       {</span>
<span class="line-modified"> 761         unsigned int feature_index = l.get_feature_index (i);</span>
<span class="line-modified"> 762 </span>
<span class="line-modified"> 763         if (feature_tag == c-&gt;g.get_feature_tag (feature_index))</span>
<span class="line-modified"> 764         {</span>
<span class="line-modified"> 765           c-&gt;feature_indexes-&gt;add (feature_index);</span>
<span class="line-modified"> 766           break;</span>
<span class="line-modified"> 767         }</span>
<span class="line-added"> 768       }</span>
 769     }
 770   }
 771 }
 772 
 773 static void
<span class="line-modified"> 774 script_collect_features (hb_collect_features_context_t *c,</span>
<span class="line-modified"> 775                          const OT::Script   &amp;s,</span>
<span class="line-modified"> 776                          const hb_tag_t *languages,</span>
<span class="line-modified"> 777                          const hb_tag_t *features)</span>


 778 {
<span class="line-modified"> 779   if (c-&gt;visited (s)) return;</span>





 780 
 781   if (!languages)
 782   {
<span class="line-modified"> 783     /* All languages. */</span>
<span class="line-modified"> 784     if (s.has_default_lang_sys ())</span>
<span class="line-modified"> 785       langsys_collect_features (c,</span>
<span class="line-modified"> 786                                 s.get_default_lang_sys (),</span>
<span class="line-modified"> 787                                 features);</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     unsigned int count = s.get_lang_sys_count ();</span>
 790     for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<span class="line-modified"> 791       langsys_collect_features (c,</span>
<span class="line-modified"> 792                                 s.get_lang_sys (language_index),</span>
<span class="line-modified"> 793                                 features);</span>



 794   }
 795   else
 796   {
 797     for (; *languages; languages++)
 798     {
 799       unsigned int language_index;
<span class="line-modified"> 800       if (s.find_lang_sys_index (*languages, &amp;language_index))</span>
<span class="line-modified"> 801         langsys_collect_features (c,</span>
<span class="line-modified"> 802                                   s.get_lang_sys (language_index),</span>
<span class="line-modified"> 803                                   features);</span>







 804     }
 805   }
 806 }
 807 
 808 /**
<span class="line-modified"> 809  * hb_ot_layout_collect_features:</span>
 810  *
<span class="line-modified"> 811  * Since: 1.8.5</span>
 812  **/
 813 void
<span class="line-modified"> 814 hb_ot_layout_collect_features (hb_face_t      *face,</span>
<span class="line-modified"> 815                                hb_tag_t        table_tag,</span>
<span class="line-modified"> 816                                const hb_tag_t *scripts,</span>
<span class="line-modified"> 817                                const hb_tag_t *languages,</span>
<span class="line-modified"> 818                                const hb_tag_t *features,</span>
<span class="line-modified"> 819                                hb_set_t       *feature_indexes /* OUT */)</span>
 820 {
<span class="line-added"> 821   hb_collect_features_context_t c (face, table_tag, feature_indexes);</span>
 822   if (!scripts)
 823   {
<span class="line-modified"> 824     /* All scripts. */</span>
<span class="line-modified"> 825     unsigned int count = c.g.get_script_count ();</span>


 826     for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<span class="line-modified"> 827       script_collect_features (&amp;c,</span>
<span class="line-modified"> 828                                c.g.get_script (script_index),</span>
<span class="line-modified"> 829                                languages,</span>
<span class="line-modified"> 830                                features);</span>


 831   }
 832   else
 833   {
 834     for (; *scripts; scripts++)
 835     {
 836       unsigned int script_index;
<span class="line-modified"> 837       if (c.g.find_script_index (*scripts, &amp;script_index))</span>
<span class="line-modified"> 838         script_collect_features (&amp;c,</span>
<span class="line-modified"> 839                                  c.g.get_script (script_index),</span>
<span class="line-modified"> 840                                  languages,</span>
<span class="line-modified"> 841                                  features);</span>





 842     }
 843   }
 844 }
 845 
<span class="line-added"> 846 /**</span>
<span class="line-added"> 847  * hb_ot_layout_collect_lookups:</span>
<span class="line-added"> 848  *</span>
<span class="line-added"> 849  * Since: 0.9.8</span>
<span class="line-added"> 850  **/</span>
<span class="line-added"> 851 void</span>
<span class="line-added"> 852 hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-added"> 853                               hb_tag_t        table_tag,</span>
<span class="line-added"> 854                               const hb_tag_t *scripts,</span>
<span class="line-added"> 855                               const hb_tag_t *languages,</span>
<span class="line-added"> 856                               const hb_tag_t *features,</span>
<span class="line-added"> 857                               hb_set_t       *lookup_indexes /* OUT */)</span>
<span class="line-added"> 858 {</span>
<span class="line-added"> 859   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added"> 860 </span>
<span class="line-added"> 861   hb_set_t feature_indexes;</span>
<span class="line-added"> 862   hb_ot_layout_collect_features (face, table_tag, scripts, languages, features, &amp;feature_indexes);</span>
<span class="line-added"> 863 </span>
<span class="line-added"> 864   for (hb_codepoint_t feature_index = HB_SET_VALUE_INVALID;</span>
<span class="line-added"> 865        hb_set_next (&amp;feature_indexes, &amp;feature_index);)</span>
<span class="line-added"> 866     g.get_feature (feature_index).add_lookup_indexes_to (lookup_indexes);</span>
<span class="line-added"> 867 }</span>
<span class="line-added"> 868 </span>
 869 /**
 870  * hb_ot_layout_lookup_collect_glyphs:
 871  *
 872  * Since: 0.9.7
 873  **/
 874 void
 875 hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
 876                                     hb_tag_t      table_tag,
 877                                     unsigned int  lookup_index,
<span class="line-modified"> 878                                     hb_set_t     *glyphs_before, /* OUT.  May be NULL */</span>
<span class="line-modified"> 879                                     hb_set_t     *glyphs_input,  /* OUT.  May be NULL */</span>
<span class="line-modified"> 880                                     hb_set_t     *glyphs_after,  /* OUT.  May be NULL */</span>
<span class="line-modified"> 881                                     hb_set_t     *glyphs_output  /* OUT.  May be NULL */)</span>
 882 {


 883   OT::hb_collect_glyphs_context_t c (face,
 884                                      glyphs_before,
 885                                      glyphs_input,
 886                                      glyphs_after,
 887                                      glyphs_output);
 888 
 889   switch (table_tag)
 890   {
 891     case HB_OT_TAG_GSUB:
 892     {
<span class="line-modified"> 893       const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
 894       l.collect_glyphs (&amp;c);
 895       return;
 896     }
 897     case HB_OT_TAG_GPOS:
 898     {
<span class="line-modified"> 899       const OT::PosLookup&amp; l = face-&gt;table.GPOS-&gt;table-&gt;get_lookup (lookup_index);</span>
 900       l.collect_glyphs (&amp;c);
 901       return;
 902     }
 903   }
 904 }
 905 
 906 
 907 /* Variations support */
 908 
 909 hb_bool_t
 910 hb_ot_layout_table_find_feature_variations (hb_face_t    *face,
 911                                             hb_tag_t      table_tag,
 912                                             const int    *coords,
 913                                             unsigned int  num_coords,
 914                                             unsigned int *variations_index /* out */)
 915 {
 916   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 917 
 918   return g.find_variations_index (coords, num_coords, variations_index);
 919 }
</pre>
<hr />
<pre>
 926                                                   unsigned int  start_offset,
 927                                                   unsigned int *lookup_count /* IN/OUT */,
 928                                                   unsigned int *lookup_indexes /* OUT */)
 929 {
 930   static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), &quot;&quot;);
 931   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 932 
 933   const OT::Feature &amp;f = g.get_feature_variation (feature_index, variations_index);
 934 
 935   return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
 936 }
 937 
 938 
 939 /*
 940  * OT::GSUB
 941  */
 942 
 943 hb_bool_t
 944 hb_ot_layout_has_substitution (hb_face_t *face)
 945 {
<span class="line-modified"> 946   return face-&gt;table.GSUB-&gt;table-&gt;has_data ();</span>
 947 }
 948 
 949 /**
 950  * hb_ot_layout_lookup_would_substitute:
 951  *
 952  * Since: 0.9.7
 953  **/
 954 hb_bool_t
 955 hb_ot_layout_lookup_would_substitute (hb_face_t            *face,
 956                                       unsigned int          lookup_index,
 957                                       const hb_codepoint_t *glyphs,
 958                                       unsigned int          glyphs_length,
 959                                       hb_bool_t             zero_context)
 960 {
<span class="line-modified"> 961   return hb_ot_layout_lookup_would_substitute_fast (face,</span>
<span class="line-modified"> 962                                                     lookup_index,</span>
<span class="line-added"> 963                                                     glyphs, glyphs_length,</span>
<span class="line-added"> 964                                                     zero_context);</span>
 965 }
 966 
<span class="line-modified"> 967 bool</span>
 968 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 969                                            unsigned int          lookup_index,
 970                                            const hb_codepoint_t *glyphs,
 971                                            unsigned int          glyphs_length,
<span class="line-modified"> 972                                            bool                  zero_context)</span>
 973 {
<span class="line-modified"> 974   if (unlikely (lookup_index &gt;= face-&gt;table.GSUB-&gt;lookup_count)) return false;</span>
 975   OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
 976 
<span class="line-modified"> 977   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
 978 
<span class="line-modified"> 979   return l.would_apply (&amp;c, &amp;face-&gt;table.GSUB-&gt;accels[lookup_index]);</span>
 980 }
 981 
 982 void
<span class="line-modified"> 983 hb_ot_layout_substitute_start (hb_font_t    *font,</span>
<span class="line-added"> 984                                hb_buffer_t  *buffer)</span>
 985 {
<span class="line-modified"> 986 _hb_ot_layout_set_glyph_props (font, buffer);</span>
<span class="line-added"> 987 }</span>
<span class="line-added"> 988 </span>
<span class="line-added"> 989 void</span>
<span class="line-added"> 990 hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,</span>
<span class="line-added"> 991                                     bool (*filter) (const hb_glyph_info_t *info))</span>
<span class="line-added"> 992 {</span>
<span class="line-added"> 993   /* Merge clusters and delete filtered glyphs.</span>
<span class="line-added"> 994    * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-added"> 995   unsigned int j = 0;</span>
<span class="line-added"> 996   unsigned int count = buffer-&gt;len;</span>
<span class="line-added"> 997   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-added"> 998   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-added"> 999   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1000   {</span>
<span class="line-added">1001     if (filter (&amp;info[i]))</span>
<span class="line-added">1002     {</span>
<span class="line-added">1003       /* Merge clusters.</span>
<span class="line-added">1004        * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-added">1005 </span>
<span class="line-added">1006       unsigned int cluster = info[i].cluster;</span>
<span class="line-added">1007       if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-added">1008         continue; /* Cluster survives; do nothing. */</span>
<span class="line-added">1009 </span>
<span class="line-added">1010       if (j)</span>
<span class="line-added">1011       {</span>
<span class="line-added">1012         /* Merge cluster backward. */</span>
<span class="line-added">1013         if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-added">1014         {</span>
<span class="line-added">1015           unsigned int mask = info[i].mask;</span>
<span class="line-added">1016           unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-added">1017           for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-added">1018             buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-added">1019         }</span>
<span class="line-added">1020         continue;</span>
<span class="line-added">1021       }</span>
<span class="line-added">1022 </span>
<span class="line-added">1023       if (i + 1 &lt; count)</span>
<span class="line-added">1024         buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-added">1025 </span>
<span class="line-added">1026       continue;</span>
<span class="line-added">1027     }</span>
<span class="line-added">1028 </span>
<span class="line-added">1029     if (j != i)</span>
<span class="line-added">1030     {</span>
<span class="line-added">1031       info[j] = info[i];</span>
<span class="line-added">1032       pos[j] = pos[i];</span>
<span class="line-added">1033     }</span>
<span class="line-added">1034     j++;</span>
<span class="line-added">1035   }</span>
<span class="line-added">1036   buffer-&gt;len = j;</span>
1037 }
1038 
1039 /**
1040  * hb_ot_layout_lookup_substitute_closure:
1041  *
1042  * Since: 0.9.7
1043  **/
1044 void
1045 hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
1046                                         unsigned int  lookup_index,
1047                                         hb_set_t     *glyphs)
1048 {
<span class="line-modified">1049   hb_map_t done_lookups;</span>
1050   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
1051 
<span class="line-modified">1052   const OT::SubstLookup&amp; l = face-&gt;table.GSUB-&gt;table-&gt;get_lookup (lookup_index);</span>
1053 
1054   l.closure (&amp;c, lookup_index);
1055 }
1056 
1057 /**
1058  * hb_ot_layout_lookups_substitute_closure:
1059  *
1060  * Compute the transitive closure of glyphs needed for all of the
1061  * provided lookups.
1062  *
1063  * Since: 1.8.1
1064  **/
1065 void
1066 hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
1067                                          const hb_set_t *lookups,
1068                                          hb_set_t       *glyphs)
1069 {
<span class="line-modified">1070   hb_map_t done_lookups;</span>
1071   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<span class="line-modified">1072   const OT::GSUB&amp; gsub = *face-&gt;table.GSUB-&gt;table;</span>
1073 
<span class="line-added">1074   unsigned int iteration_count = 0;</span>
1075   unsigned int glyphs_length;
1076   do
1077   {
1078     glyphs_length = glyphs-&gt;get_population ();
1079     if (lookups != nullptr)
1080     {
1081       for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &amp;lookup_index);)
1082         gsub.get_lookup (lookup_index).closure (&amp;c, lookup_index);
1083     }
1084     else
1085     {
1086       for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
1087         gsub.get_lookup (i).closure (&amp;c, i);
1088     }
<span class="line-modified">1089   } while (iteration_count++ &lt;= HB_CLOSURE_MAX_STAGES &amp;&amp;</span>
<span class="line-added">1090            glyphs_length != glyphs-&gt;get_population ());</span>
1091 }
1092 
1093 /*
1094  * OT::GPOS
1095  */
1096 
1097 hb_bool_t
1098 hb_ot_layout_has_positioning (hb_face_t *face)
1099 {
<span class="line-modified">1100   return face-&gt;table.GPOS-&gt;table-&gt;has_data ();</span>
1101 }
1102 
1103 void
1104 hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
1105 {
1106   OT::GPOS::position_start (font, buffer);
1107 }
1108 
1109 void
1110 hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)
1111 {
1112   OT::GPOS::position_finish_advances (font, buffer);
1113 }
1114 
1115 void
1116 hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)
1117 {
1118   OT::GPOS::position_finish_offsets (font, buffer);
1119 }
1120 
1121 /**
1122  * hb_ot_layout_get_size_params:
1123  *
1124  * Since: 0.9.10
1125  **/
1126 hb_bool_t
<span class="line-modified">1127 hb_ot_layout_get_size_params (hb_face_t       *face,</span>
<span class="line-modified">1128                               unsigned int    *design_size,       /* OUT.  May be NULL */</span>
<span class="line-modified">1129                               unsigned int    *subfamily_id,      /* OUT.  May be NULL */</span>
<span class="line-modified">1130                               hb_ot_name_id_t *subfamily_name_id, /* OUT.  May be NULL */</span>
<span class="line-modified">1131                               unsigned int    *range_start,       /* OUT.  May be NULL */</span>
<span class="line-modified">1132                               unsigned int    *range_end          /* OUT.  May be NULL */)</span>
1133 {
<span class="line-modified">1134   const OT::GPOS &amp;gpos = *face-&gt;table.GPOS-&gt;table;</span>
1135   const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
1136 
1137   unsigned int num_features = gpos.get_feature_count ();
1138   for (unsigned int i = 0; i &lt; num_features; i++)
1139   {
1140     if (tag == gpos.get_feature_tag (i))
1141     {
1142       const OT::Feature &amp;f = gpos.get_feature (i);
1143       const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
1144 
1145       if (params.designSize)
1146       {
<span class="line-modified">1147         if (design_size) *design_size = params.designSize;</span>
<span class="line-modified">1148         if (subfamily_id) *subfamily_id = params.subfamilyID;</span>
<span class="line-modified">1149         if (subfamily_name_id) *subfamily_name_id = params.subfamilyNameID;</span>
<span class="line-modified">1150         if (range_start) *range_start = params.rangeStart;</span>
<span class="line-modified">1151         if (range_end) *range_end = params.rangeEnd;</span>


1152 
1153         return true;
1154       }
1155     }
1156   }
1157 
<span class="line-modified">1158   if (design_size) *design_size = 0;</span>
<span class="line-modified">1159   if (subfamily_id) *subfamily_id = 0;</span>
<span class="line-modified">1160   if (subfamily_name_id) *subfamily_name_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-modified">1161   if (range_start) *range_start = 0;</span>
<span class="line-modified">1162   if (range_end) *range_end = 0;</span>


1163 
1164   return false;
1165 }
1166 
<span class="line-added">1167 /**</span>
<span class="line-added">1168  * hb_ot_layout_feature_get_name_ids:</span>
<span class="line-added">1169  * @face: #hb_face_t to work upon</span>
<span class="line-added">1170  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">1171  * @feature_index: index of feature to query.</span>
<span class="line-added">1172  * @label_id: (out) (allow-none): The ‘name’ table name ID that specifies a string</span>
<span class="line-added">1173  *            for a user-interface label for this feature. (May be NULL.)</span>
<span class="line-added">1174  * @tooltip_id: (out) (allow-none): The ‘name’ table name ID that specifies a string</span>
<span class="line-added">1175  *              that an application can use for tooltip text for this</span>
<span class="line-added">1176  *              feature. (May be NULL.)</span>
<span class="line-added">1177  * @sample_id: (out) (allow-none): The ‘name’ table name ID that specifies sample text</span>
<span class="line-added">1178  *             that illustrates the effect of this feature. (May be NULL.)</span>
<span class="line-added">1179  * @num_named_parameters: (out) (allow-none):  Number of named parameters. (May be zero.)</span>
<span class="line-added">1180  * @first_param_id: (out) (allow-none): The first ‘name’ table name ID used to specify</span>
<span class="line-added">1181  *                  strings for user-interface labels for the feature</span>
<span class="line-added">1182  *                  parameters. (Must be zero if numParameters is zero.)</span>
<span class="line-added">1183  *</span>
<span class="line-added">1184  * Fetches name indices from feature parameters for &quot;Stylistic Set&quot; (&#39;ssXX&#39;) or</span>
<span class="line-added">1185  * &quot;Character Variant&quot; (&#39;cvXX&#39;) features.</span>
<span class="line-added">1186  *</span>
<span class="line-added">1187  * Return value: true if data found, false otherwise</span>
<span class="line-added">1188  *</span>
<span class="line-added">1189  * Since: 2.0.0</span>
<span class="line-added">1190  **/</span>
<span class="line-added">1191 hb_bool_t</span>
<span class="line-added">1192 hb_ot_layout_feature_get_name_ids (hb_face_t       *face,</span>
<span class="line-added">1193                                    hb_tag_t         table_tag,</span>
<span class="line-added">1194                                    unsigned int     feature_index,</span>
<span class="line-added">1195                                    hb_ot_name_id_t *label_id,             /* OUT.  May be NULL */</span>
<span class="line-added">1196                                    hb_ot_name_id_t *tooltip_id,           /* OUT.  May be NULL */</span>
<span class="line-added">1197                                    hb_ot_name_id_t *sample_id,            /* OUT.  May be NULL */</span>
<span class="line-added">1198                                    unsigned int    *num_named_parameters, /* OUT.  May be NULL */</span>
<span class="line-added">1199                                    hb_ot_name_id_t *first_param_id        /* OUT.  May be NULL */)</span>
<span class="line-added">1200 {</span>
<span class="line-added">1201   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">1202 </span>
<span class="line-added">1203   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">1204   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">1205 </span>
<span class="line-added">1206   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">1207   if (&amp;feature_params != &amp;Null (OT::FeatureParams))</span>
<span class="line-added">1208   {</span>
<span class="line-added">1209     const OT::FeatureParamsStylisticSet&amp; ss_params =</span>
<span class="line-added">1210       feature_params.get_stylistic_set_params (feature_tag);</span>
<span class="line-added">1211     if (&amp;ss_params != &amp;Null (OT::FeatureParamsStylisticSet)) /* ssXX */</span>
<span class="line-added">1212     {</span>
<span class="line-added">1213       if (label_id) *label_id = ss_params.uiNameID;</span>
<span class="line-added">1214       // ssXX features don&#39;t have the rest</span>
<span class="line-added">1215       if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1216       if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1217       if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">1218       if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1219       return true;</span>
<span class="line-added">1220     }</span>
<span class="line-added">1221     const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">1222       feature_params.get_character_variants_params (feature_tag);</span>
<span class="line-added">1223     if (&amp;cv_params != &amp;Null (OT::FeatureParamsCharacterVariants)) /* cvXX */</span>
<span class="line-added">1224     {</span>
<span class="line-added">1225       if (label_id) *label_id = cv_params.featUILableNameID;</span>
<span class="line-added">1226       if (tooltip_id) *tooltip_id = cv_params.featUITooltipTextNameID;</span>
<span class="line-added">1227       if (sample_id) *sample_id = cv_params.sampleTextNameID;</span>
<span class="line-added">1228       if (num_named_parameters) *num_named_parameters = cv_params.numNamedParameters;</span>
<span class="line-added">1229       if (first_param_id) *first_param_id = cv_params.firstParamUILabelNameID;</span>
<span class="line-added">1230       return true;</span>
<span class="line-added">1231     }</span>
<span class="line-added">1232   }</span>
<span class="line-added">1233 </span>
<span class="line-added">1234   if (label_id) *label_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1235   if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1236   if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1237   if (num_named_parameters) *num_named_parameters = 0;</span>
<span class="line-added">1238   if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;</span>
<span class="line-added">1239   return false;</span>
<span class="line-added">1240 }</span>
<span class="line-added">1241 </span>
<span class="line-added">1242 /**</span>
<span class="line-added">1243  * hb_ot_layout_feature_get_characters:</span>
<span class="line-added">1244  * @face: #hb_face_t to work upon</span>
<span class="line-added">1245  * @table_tag: table tag to query, &quot;GSUB&quot; or &quot;GPOS&quot;.</span>
<span class="line-added">1246  * @feature_index: index of feature to query.</span>
<span class="line-added">1247  * @start_offset: In case the resulting char_count was equal to its input value, there</span>
<span class="line-added">1248  *                is a chance there were more characters on the tag so this API can be</span>
<span class="line-added">1249  *                called with an offset till resulting char_count gets to a number</span>
<span class="line-added">1250  *                lower than input buffer (or consider using just a bigger buffer for</span>
<span class="line-added">1251  *                one shot copying).</span>
<span class="line-added">1252  * @char_count: (inout) (allow-none): The count of characters for which this feature</span>
<span class="line-added">1253  *              provides glyph variants. (May be zero.)</span>
<span class="line-added">1254  * @characters: (out caller-allocates) (array length=char_count): A buffer pointer. The Unicode codepoints</span>
<span class="line-added">1255  *              of the characters for which this feature provides glyph variants.</span>
<span class="line-added">1256  *</span>
<span class="line-added">1257  * Fetches characters listed by designer under feature parameters for &quot;Character</span>
<span class="line-added">1258  * Variant&quot; (&quot;cvXX&quot;) features.</span>
<span class="line-added">1259  *</span>
<span class="line-added">1260  * Return value: Number of total sample characters in the cvXX feature.</span>
<span class="line-added">1261  *</span>
<span class="line-added">1262  * Since: 2.0.0</span>
<span class="line-added">1263  **/</span>
<span class="line-added">1264 unsigned int</span>
<span class="line-added">1265 hb_ot_layout_feature_get_characters (hb_face_t      *face,</span>
<span class="line-added">1266                                      hb_tag_t        table_tag,</span>
<span class="line-added">1267                                      unsigned int    feature_index,</span>
<span class="line-added">1268                                      unsigned int    start_offset,</span>
<span class="line-added">1269                                      unsigned int   *char_count, /* IN/OUT.  May be NULL */</span>
<span class="line-added">1270                                      hb_codepoint_t *characters  /* OUT.     May be NULL */)</span>
<span class="line-added">1271 {</span>
<span class="line-added">1272   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);</span>
<span class="line-added">1273 </span>
<span class="line-added">1274   hb_tag_t feature_tag = g.get_feature_tag (feature_index);</span>
<span class="line-added">1275   const OT::Feature &amp;f = g.get_feature (feature_index);</span>
<span class="line-added">1276 </span>
<span class="line-added">1277   const OT::FeatureParams &amp;feature_params = f.get_feature_params ();</span>
<span class="line-added">1278 </span>
<span class="line-added">1279   const OT::FeatureParamsCharacterVariants&amp; cv_params =</span>
<span class="line-added">1280     feature_params.get_character_variants_params(feature_tag);</span>
<span class="line-added">1281 </span>
<span class="line-added">1282   unsigned int len = 0;</span>
<span class="line-added">1283   if (char_count &amp;&amp; characters &amp;&amp; start_offset &lt; cv_params.characters.len)</span>
<span class="line-added">1284   {</span>
<span class="line-added">1285     len = MIN (cv_params.characters.len - start_offset, *char_count);</span>
<span class="line-added">1286     for (unsigned int i = 0; i &lt; len; ++i)</span>
<span class="line-added">1287       characters[i] = cv_params.characters[start_offset + i];</span>
<span class="line-added">1288   }</span>
<span class="line-added">1289   if (char_count) *char_count = len;</span>
<span class="line-added">1290   return cv_params.characters.len;</span>
<span class="line-added">1291 }</span>
<span class="line-added">1292 </span>
1293 
1294 /*
1295  * Parts of different types are implemented here such that they have direct
1296  * access to GSUB/GPOS lookups.
1297  */
1298 
1299 
1300 struct GSUBProxy
1301 {
<span class="line-modified">1302   static constexpr unsigned table_index = 0u;</span>
<span class="line-modified">1303   static constexpr bool inplace = false;</span>
1304   typedef OT::SubstLookup Lookup;
1305 
1306   GSUBProxy (hb_face_t *face) :
<span class="line-modified">1307     table (*face-&gt;table.GSUB-&gt;table),</span>
<span class="line-modified">1308     accels (face-&gt;table.GSUB-&gt;accels) {}</span>
1309 
1310   const OT::GSUB &amp;table;
<span class="line-modified">1311   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
1312 };
1313 
1314 struct GPOSProxy
1315 {
<span class="line-modified">1316   static constexpr unsigned table_index = 1u;</span>
<span class="line-modified">1317   static constexpr bool inplace = true;</span>
1318   typedef OT::PosLookup Lookup;
1319 
1320   GPOSProxy (hb_face_t *face) :
<span class="line-modified">1321     table (*face-&gt;table.GPOS-&gt;table),</span>
<span class="line-modified">1322     accels (face-&gt;table.GPOS-&gt;accels) {}</span>
1323 
1324   const OT::GPOS &amp;table;
<span class="line-modified">1325   const OT::hb_ot_layout_lookup_accelerator_t *accels;</span>
1326 };
1327 
1328 

















































1329 static inline bool
1330 apply_forward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">1331                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>

1332 {
1333   bool ret = false;
1334   hb_buffer_t *buffer = c-&gt;buffer;
1335   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
1336   {
1337     bool applied = false;
1338     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1339         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1340         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1341      {
<span class="line-modified">1342        applied = accel.apply (c);</span>





1343      }
1344 
1345     if (applied)
1346       ret = true;
1347     else
1348       buffer-&gt;next_glyph ();
1349   }
1350   return ret;
1351 }
1352 
1353 static inline bool
1354 apply_backward (OT::hb_ot_apply_context_t *c,
<span class="line-modified">1355                const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>

1356 {
1357   bool ret = false;
1358   hb_buffer_t *buffer = c-&gt;buffer;
1359   do
1360   {
1361     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1362         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1363         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<span class="line-modified">1364      ret |= accel.apply (c);</span>
<span class="line-modified">1365 </span>






1366     /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
1367     buffer-&gt;idx--;
1368 
1369   }
1370   while ((int) buffer-&gt;idx &gt;= 0);
1371   return ret;
1372 }
1373 
1374 template &lt;typename Proxy&gt;
1375 static inline void
1376 apply_string (OT::hb_ot_apply_context_t *c,
1377               const typename Proxy::Lookup &amp;lookup,
<span class="line-modified">1378               const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1379 {
1380   hb_buffer_t *buffer = c-&gt;buffer;
1381 
1382   if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
1383     return;
1384 
1385   c-&gt;set_lookup_props (lookup.get_props ());
1386 




1387   if (likely (!lookup.is_reverse ()))
1388   {
1389     /* in/out forward substitution/positioning */
<span class="line-modified">1390     if (Proxy::table_index == 0u)</span>
1391       buffer-&gt;clear_output ();
1392     buffer-&gt;idx = 0;
1393 
1394     bool ret;
<span class="line-modified">1395     ret = apply_forward (c, accel);</span>
1396     if (ret)
1397     {
1398       if (!Proxy::inplace)
1399         buffer-&gt;swap_buffers ();
1400       else
1401         assert (!buffer-&gt;has_separate_output ());
1402     }
1403   }
1404   else
1405   {
1406     /* in-place backward substitution/positioning */
<span class="line-modified">1407     if (Proxy::table_index == 0u)</span>
1408       buffer-&gt;remove_output ();
1409     buffer-&gt;idx = buffer-&gt;len - 1;
1410 
<span class="line-modified">1411     apply_backward (c, accel);</span>
1412   }
1413 }
1414 
1415 template &lt;typename Proxy&gt;
1416 inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
1417                                 const hb_ot_shape_plan_t *plan,
1418                                 hb_font_t *font,
1419                                 hb_buffer_t *buffer) const
1420 {
1421   const unsigned int table_index = proxy.table_index;
1422   unsigned int i = 0;
1423   OT::hb_ot_apply_context_t c (table_index, font, buffer);
1424   c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
1425 
<span class="line-modified">1426   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].length; stage_index++) {</span>
1427     const stage_map_t *stage = &amp;stages[table_index][stage_index];
1428     for (; i &lt; stage-&gt;last_lookup; i++)
1429     {
1430       unsigned int lookup_index = lookups[table_index][i].index;
1431       if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
1432       c.set_lookup_index (lookup_index);
1433       c.set_lookup_mask (lookups[table_index][i].mask);
1434       c.set_auto_zwj (lookups[table_index][i].auto_zwj);
1435       c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
<span class="line-added">1436       if (lookups[table_index][i].random)</span>
<span class="line-added">1437       {</span>
<span class="line-added">1438         c.set_random (true);</span>
<span class="line-added">1439         buffer-&gt;unsafe_to_break_all ();</span>
<span class="line-added">1440       }</span>
1441       apply_string&lt;Proxy&gt; (&amp;c,
1442                            proxy.table.get_lookup (lookup_index),
1443                            proxy.accels[lookup_index]);
1444       (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
1445     }
1446 
1447     if (stage-&gt;pause_func)
1448     {
1449       buffer-&gt;clear_output ();
1450       stage-&gt;pause_func (plan, font, buffer);
1451     }
1452   }
1453 }
1454 
1455 void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1456 {
1457   GSUBProxy proxy (font-&gt;face);
1458   apply (proxy, plan, font, buffer);
1459 }
1460 
1461 void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1462 {
1463   GPOSProxy proxy (font-&gt;face);
1464   apply (proxy, plan, font, buffer);
1465 }
1466 
1467 void
1468 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
1469                                 const OT::SubstLookup &amp;lookup,
<span class="line-modified">1470                                 const OT::hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1471 {
1472   apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
1473 }
1474 
<span class="line-added">1475 #if 0</span>
<span class="line-added">1476 static const OT::BASE&amp; _get_base (hb_face_t *face)</span>
<span class="line-added">1477 {</span>
<span class="line-added">1478   return *face-&gt;table.BASE;</span>
<span class="line-added">1479 }</span>
1480 
<span class="line-added">1481 hb_bool_t</span>
<span class="line-added">1482 hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">1483                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">1484                            hb_direction_t           direction,</span>
<span class="line-added">1485                            hb_tag_t                 script_tag,</span>
<span class="line-added">1486                            hb_tag_t                 language_tag,</span>
<span class="line-added">1487                            hb_position_t           *coord        /* OUT.  May be NULL. */)</span>
<span class="line-added">1488 {</span>
<span class="line-added">1489   const OT::BASE &amp;base = _get_base (font-&gt;face);</span>
<span class="line-added">1490   bool result = base.get_baseline (font, baseline, direction, script_tag,</span>
<span class="line-added">1491                                    language_tag, coord);</span>
1492 
<span class="line-added">1493   /* TODO: Simulate https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags#ideographic-em-box */</span>
<span class="line-added">1494   if (!result &amp;&amp; coord) *coord = 0;</span>
1495 
<span class="line-added">1496   if (coord) *coord = font-&gt;em_scale_dir (*coord, direction);</span>
<span class="line-added">1497 </span>
<span class="line-added">1498   return result;</span>
<span class="line-added">1499 }</span>
<span class="line-added">1500 </span>
<span class="line-added">1501 /* To be moved to public header */</span>
1502 /*
<span class="line-modified">1503  * BASE</span>
1504  */
1505 
<span class="line-modified">1506 /**</span>
<span class="line-modified">1507  * hb_ot_layout_baseline_t:</span>
<span class="line-modified">1508  *</span>
<span class="line-modified">1509  * https://docs.microsoft.com/en-us/typography/opentype/spec/baselinetags</span>
<span class="line-modified">1510  *</span>
<span class="line-modified">1511  * Since: DONTREPLACEME</span>
<span class="line-modified">1512  */</span>
<span class="line-modified">1513 typedef enum {</span>
<span class="line-modified">1514   HB_OT_LAYOUT_BASELINE_HANG = HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;),</span>
<span class="line-modified">1515   HB_OT_LAYOUT_BASELINE_ICFB = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;),</span>
<span class="line-modified">1516   HB_OT_LAYOUT_BASELINE_ICFT = HB_TAG(&#39;i&#39;,&#39;c&#39;,&#39;f&#39;,&#39;t&#39;),</span>
<span class="line-modified">1517   HB_OT_LAYOUT_BASELINE_IDEO = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;e&#39;,&#39;o&#39;),</span>
<span class="line-modified">1518   HB_OT_LAYOUT_BASELINE_IDTB = HB_TAG(&#39;i&#39;,&#39;d&#39;,&#39;t&#39;,&#39;b&#39;),</span>
<span class="line-modified">1519   HB_OT_LAYOUT_BASELINE_MATH = HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;t&#39;,&#39;h&#39;),</span>
<span class="line-modified">1520   HB_OT_LAYOUT_BASELINE_ROMN = HB_TAG(&#39;r&#39;,&#39;o&#39;,&#39;m&#39;,&#39;n&#39;)</span>
<span class="line-modified">1521 } hb_ot_layout_baseline_t;</span>
<span class="line-added">1522 </span>
<span class="line-added">1523 HB_EXTERN hb_bool_t</span>
<span class="line-added">1524 hb_ot_layout_get_baseline (hb_font_t               *font,</span>
<span class="line-added">1525                            hb_ot_layout_baseline_t  baseline,</span>
<span class="line-added">1526                            hb_direction_t           direction,</span>
<span class="line-added">1527                            hb_tag_t                 script_tag,</span>
<span class="line-added">1528                            hb_tag_t                 language_tag,</span>
<span class="line-added">1529                            hb_position_t           *coord        /* OUT.  May be NULL. */);</span>
<span class="line-added">1530 </span>
<span class="line-added">1531 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-layout-jstf-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
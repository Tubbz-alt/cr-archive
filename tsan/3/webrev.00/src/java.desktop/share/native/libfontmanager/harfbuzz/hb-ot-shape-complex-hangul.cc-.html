<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2013  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #include &quot;hb-ot-shape-complex-private.hh&quot;
 28 
 29 
 30 /* Hangul shaper */
 31 
 32 
 33 /* Same order as the feature array below */
 34 enum {
 35   _JMO,
 36 
 37   LJMO,
 38   VJMO,
 39   TJMO,
 40 
 41   FIRST_HANGUL_FEATURE = LJMO,
 42   HANGUL_FEATURE_COUNT = TJMO + 1
 43 };
 44 
 45 static const hb_tag_t hangul_features[HANGUL_FEATURE_COUNT] =
 46 {
 47   HB_TAG_NONE,
 48   HB_TAG(&#39;l&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 49   HB_TAG(&#39;v&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 50   HB_TAG(&#39;t&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;)
 51 };
 52 
 53 static void
 54 collect_features_hangul (hb_ot_shape_planner_t *plan)
 55 {
 56   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 57 
 58   for (unsigned int i = FIRST_HANGUL_FEATURE; i &lt; HANGUL_FEATURE_COUNT; i++)
 59     map-&gt;add_feature (hangul_features[i], 1, F_NONE);
 60 }
 61 
 62 static void
 63 override_features_hangul (hb_ot_shape_planner_t *plan)
 64 {
 65   /* Uniscribe does not apply &#39;calt&#39; for Hangul, and certain fonts
 66    * (Noto Sans CJK, Source Sans Han, etc) apply all of jamo lookups
 67    * in calt, which is not desirable. */
 68   plan-&gt;map.add_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), 0, F_GLOBAL);
 69 }
 70 
 71 struct hangul_shape_plan_t
 72 {
 73   ASSERT_POD ();
 74 
 75   hb_mask_t mask_array[HANGUL_FEATURE_COUNT];
 76 };
 77 
 78 static void *
 79 data_create_hangul (const hb_ot_shape_plan_t *plan)
 80 {
 81   hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) calloc (1, sizeof (hangul_shape_plan_t));
 82   if (unlikely (!hangul_plan))
 83     return nullptr;
 84 
 85   for (unsigned int i = 0; i &lt; HANGUL_FEATURE_COUNT; i++)
 86     hangul_plan-&gt;mask_array[i] = plan-&gt;map.get_1_mask (hangul_features[i]);
 87 
 88   return hangul_plan;
 89 }
 90 
 91 static void
 92 data_destroy_hangul (void *data)
 93 {
 94   free (data);
 95 }
 96 
 97 /* Constants for algorithmic hangul syllable [de]composition. */
 98 #define LBase 0x1100u
 99 #define VBase 0x1161u
100 #define TBase 0x11A7u
101 #define LCount 19u
102 #define VCount 21u
103 #define TCount 28u
104 #define SBase 0xAC00u
105 #define NCount (VCount * TCount)
106 #define SCount (LCount * NCount)
107 
108 #define isCombiningL(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), LBase, LBase+LCount-1))
109 #define isCombiningV(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), VBase, VBase+VCount-1))
110 #define isCombiningT(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), TBase+1, TBase+TCount-1))
111 #define isCombinedS(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), SBase, SBase+SCount-1))
112 
113 #define isL(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1100u, 0x115Fu, 0xA960u, 0xA97Cu))
114 #define isV(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1160u, 0x11A7u, 0xD7B0u, 0xD7C6u))
115 #define isT(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x11A8u, 0x11FFu, 0xD7CBu, 0xD7FBu))
116 
117 #define isHangulTone(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), 0x302Eu, 0x302Fu))
118 
119 /* buffer var allocations */
120 #define hangul_shaping_feature() complex_var_u8_0() /* hangul jamo shaping feature */
121 
122 static bool
123 is_zero_width_char (hb_font_t *font,
124                     hb_codepoint_t unicode)
125 {
126   hb_codepoint_t glyph;
127   return hb_font_get_glyph (font, unicode, 0, &amp;glyph) &amp;&amp; hb_font_get_glyph_h_advance (font, glyph) == 0;
128 }
129 
130 static void
131 preprocess_text_hangul (const hb_ot_shape_plan_t *plan,
132                         hb_buffer_t              *buffer,
133                         hb_font_t                *font)
134 {
135   HB_BUFFER_ALLOCATE_VAR (buffer, hangul_shaping_feature);
136 
137   /* Hangul syllables come in two shapes: LV, and LVT.  Of those:
138    *
139    *   - LV can be precomposed, or decomposed.  Lets call those
140    *     &lt;LV&gt; and &lt;L,V&gt;,
141    *   - LVT can be fully precomposed, partically precomposed, or
142    *     fully decomposed.  Ie. &lt;LVT&gt;, &lt;LV,T&gt;, or &lt;L,V,T&gt;.
143    *
144    * The composition / decomposition is mechanical.  However, not
145    * all &lt;L,V&gt; sequences compose, and not all &lt;LV,T&gt; sequences
146    * compose.
147    *
148    * Here are the specifics:
149    *
150    *   - &lt;L&gt;: U+1100..115F, U+A960..A97F
151    *   - &lt;V&gt;: U+1160..11A7, U+D7B0..D7C7
152    *   - &lt;T&gt;: U+11A8..11FF, U+D7CB..D7FB
153    *
154    *   - Only the &lt;L,V&gt; sequences for some of the U+11xx ranges combine.
155    *   - Only &lt;LV,T&gt; sequences for some of the Ts in U+11xx range combine.
156    *
157    * Here is what we want to accomplish in this shaper:
158    *
159    *   - If the whole syllable can be precomposed, do that,
160    *   - Otherwise, fully decompose and apply ljmo/vjmo/tjmo features.
161    *   - If a valid syllable is followed by a Hangul tone mark, reorder the tone
162    *     mark to precede the whole syllable - unless it is a zero-width glyph, in
163    *     which case we leave it untouched, assuming it&#39;s designed to overstrike.
164    *
165    * That is, of the different possible syllables:
166    *
167    *   &lt;L&gt;
168    *   &lt;L,V&gt;
169    *   &lt;L,V,T&gt;
170    *   &lt;LV&gt;
171    *   &lt;LVT&gt;
172    *   &lt;LV, T&gt;
173    *
174    * - &lt;L&gt; needs no work.
175    *
176    * - &lt;LV&gt; and &lt;LVT&gt; can stay the way they are if the font supports them, otherwise we
177    *   should fully decompose them if font supports.
178    *
179    * - &lt;L,V&gt; and &lt;L,V,T&gt; we should compose if the whole thing can be composed.
180    *
181    * - &lt;LV,T&gt; we should compose if the whole thing can be composed, otherwise we should
182    *   decompose.
183    */
184 
185   buffer-&gt;clear_output ();
186   unsigned int start = 0, end = 0; /* Extent of most recently seen syllable;
187                                     * valid only if start &lt; end
188                                     */
189   unsigned int count = buffer-&gt;len;
190 
191   for (buffer-&gt;idx = 0; buffer-&gt;idx &lt; count &amp;&amp; buffer-&gt;successful;)
192   {
193     hb_codepoint_t u = buffer-&gt;cur().codepoint;
194 
195     if (isHangulTone (u))
196     {
197       /*
198        * We could cache the width of the tone marks and the existence of dotted-circle,
199        * but the use of the Hangul tone mark characters seems to be rare enough that
200        * I didn&#39;t bother for now.
201        */
202       if (start &lt; end &amp;&amp; end == buffer-&gt;out_len)
203       {
204         /* Tone mark follows a valid syllable; move it in front, unless it&#39;s zero width. */
205         buffer-&gt;unsafe_to_break_from_outbuffer (start, buffer-&gt;idx);
206         buffer-&gt;next_glyph ();
207         if (!is_zero_width_char (font, u))
208         {
209           buffer-&gt;merge_out_clusters (start, end + 1);
210           hb_glyph_info_t *info = buffer-&gt;out_info;
211           hb_glyph_info_t tone = info[end];
212           memmove (&amp;info[start + 1], &amp;info[start], (end - start) * sizeof (hb_glyph_info_t));
213           info[start] = tone;
214         }
215       }
216       else
217       {
218         /* No valid syllable as base for tone mark; try to insert dotted circle. */
219         if (font-&gt;has_glyph (0x25CCu))
220         {
221           hb_codepoint_t chars[2];
222           if (!is_zero_width_char (font, u)) {
223             chars[0] = u;
224             chars[1] = 0x25CCu;
225           } else {
226             chars[0] = 0x25CCu;
227             chars[1] = u;
228           }
229           buffer-&gt;replace_glyphs (1, 2, chars);
230         }
231         else
232         {
233           /* No dotted circle available in the font; just leave tone mark untouched. */
234           buffer-&gt;next_glyph ();
235         }
236       }
237       start = end = buffer-&gt;out_len;
238       continue;
239     }
240 
241     start = buffer-&gt;out_len; /* Remember current position as a potential syllable start;
242                               * will only be used if we set end to a later position.
243                               */
244 
245     if (isL (u) &amp;&amp; buffer-&gt;idx + 1 &lt; count)
246     {
247       hb_codepoint_t l = u;
248       hb_codepoint_t v = buffer-&gt;cur(+1).codepoint;
249       if (isV (v))
250       {
251         /* Have &lt;L,V&gt; or &lt;L,V,T&gt;. */
252         hb_codepoint_t t = 0;
253         unsigned int tindex = 0;
254         if (buffer-&gt;idx + 2 &lt; count)
255         {
256           t = buffer-&gt;cur(+2).codepoint;
257           if (isT (t))
258             tindex = t - TBase; /* Only used if isCombiningT (t); otherwise invalid. */
259           else
260             t = 0; /* The next character was not a trailing jamo. */
261         }
262         buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + (t ? 3 : 2));
263 
264         /* We&#39;ve got a syllable &lt;L,V,T?&gt;; see if it can potentially be composed. */
265         if (isCombiningL (l) &amp;&amp; isCombiningV (v) &amp;&amp; (t == 0 || isCombiningT (t)))
266         {
267           /* Try to compose; if this succeeds, end is set to start+1. */
268           hb_codepoint_t s = SBase + (l - LBase) * NCount + (v - VBase) * TCount + tindex;
269           if (font-&gt;has_glyph (s))
270           {
271             buffer-&gt;replace_glyphs (t ? 3 : 2, 1, &amp;s);
272             if (unlikely (!buffer-&gt;successful))
273               return;
274             end = start + 1;
275             continue;
276           }
277         }
278 
279         /* We didn&#39;t compose, either because it&#39;s an Old Hangul syllable without a
280          * precomposed character in Unicode, or because the font didn&#39;t support the
281          * necessary precomposed glyph.
282          * Set jamo features on the individual glyphs, and advance past them.
283          */
284         buffer-&gt;cur().hangul_shaping_feature() = LJMO;
285         buffer-&gt;next_glyph ();
286         buffer-&gt;cur().hangul_shaping_feature() = VJMO;
287         buffer-&gt;next_glyph ();
288         if (t)
289         {
290           buffer-&gt;cur().hangul_shaping_feature() = TJMO;
291           buffer-&gt;next_glyph ();
292           end = start + 3;
293         }
294         else
295           end = start + 2;
296         if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
297           buffer-&gt;merge_out_clusters (start, end);
298         continue;
299       }
300     }
301 
302     else if (isCombinedS (u))
303     {
304       /* Have &lt;LV&gt;, &lt;LVT&gt;, or &lt;LV,T&gt; */
305       hb_codepoint_t s = u;
306       bool has_glyph = font-&gt;has_glyph (s);
307       unsigned int lindex = (s - SBase) / NCount;
308       unsigned int nindex = (s - SBase) % NCount;
309       unsigned int vindex = nindex / TCount;
310       unsigned int tindex = nindex % TCount;
311 
312       if (!tindex &amp;&amp;
313           buffer-&gt;idx + 1 &lt; count &amp;&amp;
314           isCombiningT (buffer-&gt;cur(+1).codepoint))
315       {
316         /* &lt;LV,T&gt;, try to combine. */
317         unsigned int new_tindex = buffer-&gt;cur(+1).codepoint - TBase;
318         hb_codepoint_t new_s = s + new_tindex;
319         if (font-&gt;has_glyph (new_s))
320         {
321           buffer-&gt;replace_glyphs (2, 1, &amp;new_s);
322           if (unlikely (!buffer-&gt;successful))
323             return;
324           end = start + 1;
325           continue;
326         }
327         else
328           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
329       }
330 
331       /* Otherwise, decompose if font doesn&#39;t support &lt;LV&gt; or &lt;LVT&gt;,
332        * or if having non-combining &lt;LV,T&gt;.  Note that we already handled
333        * combining &lt;LV,T&gt; above. */
334       if (!has_glyph ||
335           (!tindex &amp;&amp;
336            buffer-&gt;idx + 1 &lt; count &amp;&amp;
337            isT (buffer-&gt;cur(+1).codepoint)))
338       {
339         hb_codepoint_t decomposed[3] = {LBase + lindex,
340                                         VBase + vindex,
341                                         TBase + tindex};
342         if (font-&gt;has_glyph (decomposed[0]) &amp;&amp;
343             font-&gt;has_glyph (decomposed[1]) &amp;&amp;
344             (!tindex || font-&gt;has_glyph (decomposed[2])))
345         {
346           unsigned int s_len = tindex ? 3 : 2;
347           buffer-&gt;replace_glyphs (1, s_len, decomposed);
348           if (unlikely (!buffer-&gt;successful))
349             return;
350 
351           /* We decomposed S: apply jamo features to the individual glyphs
352            * that are now in buffer-&gt;out_info.
353            */
354           hb_glyph_info_t *info = buffer-&gt;out_info;
355 
356           /* If we decomposed an LV because of a non-combining T following,
357            * we want to include this T in the syllable.
358            */
359           if (has_glyph &amp;&amp; !tindex)
360           {
361             buffer-&gt;next_glyph ();
362             s_len++;
363           }
364           end = start + s_len;
365 
366           unsigned int i = start;
367           info[i++].hangul_shaping_feature() = LJMO;
368           info[i++].hangul_shaping_feature() = VJMO;
369           if (i &lt; end)
370             info[i++].hangul_shaping_feature() = TJMO;
371           if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
372             buffer-&gt;merge_out_clusters (start, end);
373           continue;
374         }
375         else if ((!tindex &amp;&amp; buffer-&gt;idx + 1 &lt; count &amp;&amp; isT (buffer-&gt;cur(+1).codepoint)))
376           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
377       }
378 
379       if (has_glyph)
380       {
381         /* We didn&#39;t decompose the S, so just advance past it. */
382         end = start + 1;
383         buffer-&gt;next_glyph ();
384         continue;
385       }
386     }
387 
388     /* Didn&#39;t find a recognizable syllable, so we leave end &lt;= start;
389      * this will prevent tone-mark reordering happening.
390      */
391     buffer-&gt;next_glyph ();
392   }
393   buffer-&gt;swap_buffers ();
394 }
395 
396 static void
397 setup_masks_hangul (const hb_ot_shape_plan_t *plan,
398                     hb_buffer_t              *buffer,
399                     hb_font_t                *font HB_UNUSED)
400 {
401   const hangul_shape_plan_t *hangul_plan = (const hangul_shape_plan_t *) plan-&gt;data;
402 
403   if (likely (hangul_plan))
404   {
405     unsigned int count = buffer-&gt;len;
406     hb_glyph_info_t *info = buffer-&gt;info;
407     for (unsigned int i = 0; i &lt; count; i++, info++)
408       info-&gt;mask |= hangul_plan-&gt;mask_array[info-&gt;hangul_shaping_feature()];
409   }
410 
411   HB_BUFFER_DEALLOCATE_VAR (buffer, hangul_shaping_feature);
412 }
413 
414 
415 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hangul =
416 {
417   collect_features_hangul,
418   override_features_hangul,
419   data_create_hangul,
420   data_destroy_hangul,
421   preprocess_text_hangul,
422   nullptr, /* postprocess_glyphs */
423   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,
424   nullptr, /* decompose */
425   nullptr, /* compose */
426   setup_masks_hangul,
427   nullptr, /* disable_otl */
428   nullptr, /* reorder_marks */
429   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
430   false, /* fallback_position */
431 };
    </pre>
  </body>
</html>
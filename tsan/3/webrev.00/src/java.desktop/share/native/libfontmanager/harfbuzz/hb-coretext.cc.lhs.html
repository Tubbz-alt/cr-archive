<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-coretext.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 2012,2013  Mozilla Foundation.
   3  * Copyright © 2012,2013  Google, Inc.
   4  *
   5  *  This is part of HarfBuzz, a text shaping library.
   6  *
   7  * Permission is hereby granted, without written agreement and without
   8  * license or royalty fees, to use, copy, modify, and distribute this
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Mozilla Author(s): Jonathan Kew
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
<a name="1" id="anc1"></a><span class="line-modified">  29 #define HB_SHAPER coretext</span>
<span class="line-modified">  30 </span>
<span class="line-removed">  31 #include &quot;hb-private.hh&quot;</span>
<span class="line-removed">  32 #include &quot;hb-debug.hh&quot;</span>
<span class="line-removed">  33 #include &quot;hb-shaper-impl-private.hh&quot;</span>
  34 
  35 #include &quot;hb-coretext.h&quot;
<a name="2" id="anc2"></a>
  36 #include &lt;math.h&gt;
  37 
<a name="3" id="anc3"></a>









  38 /* https://developer.apple.com/documentation/coretext/1508745-ctfontcreatewithgraphicsfont */
  39 #define HB_CORETEXT_DEFAULT_FONT_SIZE 12.f
  40 
  41 static CGFloat
  42 coretext_font_size_from_ptem (float ptem)
  43 {
  44   /* CoreText points are CSS pixels (96 per inch),
  45    * NOT typographic points (72 per inch).
  46    *
  47    * https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html
  48    */
  49   ptem *= 96.f / 72.f;
  50   return ptem &lt;= 0.f ? HB_CORETEXT_DEFAULT_FONT_SIZE : ptem;
  51 }
  52 static float
  53 coretext_font_size_to_ptem (CGFloat size)
  54 {
  55   size *= 72.f / 96.f;
  56   return size &lt;= 0.f ? 0 : size;
  57 }
  58 
  59 static void
  60 release_table_data (void *user_data)
  61 {
  62   CFDataRef cf_data = reinterpret_cast&lt;CFDataRef&gt; (user_data);
  63   CFRelease(cf_data);
  64 }
  65 
  66 static hb_blob_t *
  67 reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)
  68 {
  69   CGFontRef cg_font = reinterpret_cast&lt;CGFontRef&gt; (user_data);
  70   CFDataRef cf_data = CGFontCopyTableForTag (cg_font, tag);
  71   if (unlikely (!cf_data))
  72     return nullptr;
  73 
  74   const char *data = reinterpret_cast&lt;const char*&gt; (CFDataGetBytePtr (cf_data));
  75   const size_t length = CFDataGetLength (cf_data);
  76   if (!data || !length)
  77   {
  78     CFRelease (cf_data);
  79     return nullptr;
  80   }
  81 
  82   return hb_blob_create (data, length, HB_MEMORY_MODE_READONLY,
  83                          reinterpret_cast&lt;void *&gt; (const_cast&lt;__CFData *&gt; (cf_data)),
  84                          release_table_data);
  85 }
  86 
  87 static void
  88 _hb_cg_font_release (void *data)
  89 {
  90   CGFontRelease ((CGFontRef) data);
  91 }
  92 
  93 
<a name="4" id="anc4"></a><span class="line-removed">  94 HB_SHAPER_DATA_ENSURE_DEFINE(coretext, face)</span>
<span class="line-removed">  95 HB_SHAPER_DATA_ENSURE_DEFINE_WITH_CONDITION(coretext, font,</span>
<span class="line-removed">  96         fabs (CTFontGetSize((CTFontRef) data) - coretext_font_size_from_ptem (font-&gt;ptem)) &lt;= .5</span>
<span class="line-removed">  97 )</span>
<span class="line-removed">  98 </span>
  99 static CTFontDescriptorRef
<a name="5" id="anc5"></a><span class="line-modified"> 100 get_last_resort_font_desc (void)</span>
 101 {
 102   // TODO Handle allocation failures?
 103   CTFontDescriptorRef last_resort = CTFontDescriptorCreateWithNameAndSize (CFSTR(&quot;LastResort&quot;), 0);
 104   CFArrayRef cascade_list = CFArrayCreate (kCFAllocatorDefault,
 105                                            (const void **) &amp;last_resort,
 106                                            1,
 107                                            &amp;kCFTypeArrayCallBacks);
 108   CFRelease (last_resort);
 109   CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,
 110                                                    (const void **) &amp;kCTFontCascadeListAttribute,
 111                                                    (const void **) &amp;cascade_list,
 112                                                    1,
 113                                                    &amp;kCFTypeDictionaryKeyCallBacks,
 114                                                    &amp;kCFTypeDictionaryValueCallBacks);
 115   CFRelease (cascade_list);
 116 
 117   CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);
 118   CFRelease (attributes);
 119   return font_desc;
 120 }
 121 
 122 static void
 123 release_data (void *info, const void *data, size_t size)
 124 {
 125   assert (hb_blob_get_length ((hb_blob_t *) info) == size &amp;&amp;
 126           hb_blob_get_data ((hb_blob_t *) info, nullptr) == data);
 127 
 128   hb_blob_destroy ((hb_blob_t *) info);
 129 }
 130 
 131 static CGFontRef
 132 create_cg_font (hb_face_t *face)
 133 {
 134   CGFontRef cg_font = nullptr;
 135   if (face-&gt;destroy == _hb_cg_font_release)
 136   {
 137     cg_font = CGFontRetain ((CGFontRef) face-&gt;user_data);
 138   }
 139   else
 140   {
 141     hb_blob_t *blob = hb_face_reference_blob (face);
 142     unsigned int blob_length;
 143     const char *blob_data = hb_blob_get_data (blob, &amp;blob_length);
 144     if (unlikely (!blob_length))
 145       DEBUG_MSG (CORETEXT, face, &quot;Face has empty blob&quot;);
 146 
 147     CGDataProviderRef provider = CGDataProviderCreateWithData (blob, blob_data, blob_length, &amp;release_data);
 148     if (likely (provider))
 149     {
 150       cg_font = CGFontCreateWithDataProvider (provider);
 151       if (unlikely (!cg_font))
 152         DEBUG_MSG (CORETEXT, face, &quot;Face CGFontCreateWithDataProvider() failed&quot;);
 153       CGDataProviderRelease (provider);
 154     }
 155   }
 156   return cg_font;
 157 }
 158 
 159 static CTFontRef
 160 create_ct_font (CGFontRef cg_font, CGFloat font_size)
 161 {
 162   CTFontRef ct_font = nullptr;
 163 
 164   /* CoreText does not enable trak table usage / tracking when creating a CTFont
 165    * using CTFontCreateWithGraphicsFont. The only way of enabling tracking seems
 166    * to be through the CTFontCreateUIFontForLanguage call. */
 167   CFStringRef cg_postscript_name = CGFontCopyPostScriptName (cg_font);
 168   if (CFStringHasPrefix (cg_postscript_name, CFSTR (&quot;.SFNSText&quot;)) ||
 169       CFStringHasPrefix (cg_postscript_name, CFSTR (&quot;.SFNSDisplay&quot;)))
 170   {
 171 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1080
 172 # define kCTFontUIFontSystem kCTFontSystemFontType
 173 # define kCTFontUIFontEmphasizedSystem kCTFontEmphasizedSystemFontType
 174 #endif
 175     CTFontUIFontType font_type = kCTFontUIFontSystem;
 176     if (CFStringHasSuffix (cg_postscript_name, CFSTR (&quot;-Bold&quot;)))
 177       font_type = kCTFontUIFontEmphasizedSystem;
 178 
 179     ct_font = CTFontCreateUIFontForLanguage (font_type, font_size, nullptr);
 180     CFStringRef ct_result_name = CTFontCopyPostScriptName(ct_font);
 181     if (CFStringCompare (ct_result_name, cg_postscript_name, 0) != kCFCompareEqualTo)
 182     {
 183       CFRelease(ct_font);
 184       ct_font = nullptr;
 185     }
 186     CFRelease (ct_result_name);
 187   }
 188   CFRelease (cg_postscript_name);
 189 
 190   if (!ct_font)
 191     ct_font = CTFontCreateWithGraphicsFont (cg_font, font_size, nullptr, nullptr);
 192 
 193   if (unlikely (!ct_font)) {
 194     DEBUG_MSG (CORETEXT, cg_font, &quot;Font CTFontCreateWithGraphicsFont() failed&quot;);
 195     return nullptr;
 196   }
 197 
 198   /* crbug.com/576941 and crbug.com/625902 and the investigation in the latter
 199    * bug indicate that the cascade list reconfiguration occasionally causes
 200    * crashes in CoreText on OS X 10.9, thus let&#39;s skip this step on older
 201    * operating system versions. Except for the emoji font, where _not_
 202    * reconfiguring the cascade list causes CoreText crashes. For details, see
 203    * crbug.com/549610 */
 204   // 0x00070000 stands for &quot;kCTVersionNumber10_10&quot;, see CoreText.h
 205   if (&amp;CTGetCoreTextVersion != nullptr &amp;&amp; CTGetCoreTextVersion() &lt; 0x00070000) {
 206     CFStringRef fontName = CTFontCopyPostScriptName (ct_font);
 207     bool isEmojiFont = CFStringCompare (fontName, CFSTR(&quot;AppleColorEmoji&quot;), 0) == kCFCompareEqualTo;
 208     CFRelease (fontName);
 209     if (!isEmojiFont)
 210       return ct_font;
 211   }
 212 
 213   CFURLRef original_url = nullptr;
<a name="6" id="anc6"></a><span class="line-modified"> 214 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 215   ATSFontRef atsFont;
 216   FSRef fsref;
 217   OSStatus status;
 218   atsFont = CTFontGetPlatformFont (ct_font, NULL);
 219   status = ATSFontGetFileReference (atsFont, &amp;fsref);
 220   if (status == noErr)
 221     original_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 222 #else
 223   original_url = (CFURLRef) CTFontCopyAttribute (ct_font, kCTFontURLAttribute);
 224 #endif
 225 
 226   /* Create font copy with cascade list that has LastResort first; this speeds up CoreText
 227    * font fallback which we don&#39;t need anyway. */
 228   {
 229     CTFontDescriptorRef last_resort_font_desc = get_last_resort_font_desc ();
 230     CTFontRef new_ct_font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, last_resort_font_desc);
 231     CFRelease (last_resort_font_desc);
 232     if (new_ct_font)
 233     {
 234       /* The CTFontCreateCopyWithAttributes call fails to stay on the same font
 235        * when reconfiguring the cascade list and may switch to a different font
 236        * when there are fonts that go by the same name, since the descriptor is
 237        * just name and size.
 238        *
 239        * Avoid reconfiguring the cascade lists if the new font is outside the
 240        * system locations that we cannot access from the sandboxed renderer
 241        * process in Blink. This can be detected by the new file URL location
 242        * that the newly found font points to. */
 243       CFURLRef new_url = nullptr;
<a name="7" id="anc7"></a><span class="line-modified"> 244 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060</span>
 245       atsFont = CTFontGetPlatformFont (new_ct_font, NULL);
 246       status = ATSFontGetFileReference (atsFont, &amp;fsref);
 247       if (status == noErr)
 248         new_url = CFURLCreateFromFSRef (NULL, &amp;fsref);
 249 #else
 250       new_url = (CFURLRef) CTFontCopyAttribute (new_ct_font, kCTFontURLAttribute);
 251 #endif
 252       // Keep reconfigured font if URL cannot be retrieved (seems to be the case
 253       // on Mac OS 10.12 Sierra), speculative fix for crbug.com/625606
 254       if (!original_url || !new_url || CFEqual (original_url, new_url)) {
 255         CFRelease (ct_font);
 256         ct_font = new_ct_font;
 257       } else {
 258         CFRelease (new_ct_font);
 259         DEBUG_MSG (CORETEXT, ct_font, &quot;Discarding reconfigured CTFont, location changed.&quot;);
 260       }
 261       if (new_url)
 262         CFRelease (new_url);
 263     }
 264     else
 265       DEBUG_MSG (CORETEXT, ct_font, &quot;Font copy with empty cascade list failed&quot;);
 266   }
 267 
 268   if (original_url)
 269     CFRelease (original_url);
 270   return ct_font;
 271 }
 272 
<a name="8" id="anc8"></a><span class="line-modified"> 273 hb_coretext_shaper_face_data_t *</span>
 274 _hb_coretext_shaper_face_data_create (hb_face_t *face)
 275 {
 276   CGFontRef cg_font = create_cg_font (face);
 277 
 278   if (unlikely (!cg_font))
 279   {
 280     DEBUG_MSG (CORETEXT, face, &quot;CGFont creation failed..&quot;);
 281     return nullptr;
 282   }
 283 
<a name="9" id="anc9"></a><span class="line-modified"> 284   return (hb_coretext_shaper_face_data_t *) cg_font;</span>
 285 }
 286 
 287 void
<a name="10" id="anc10"></a><span class="line-modified"> 288 _hb_coretext_shaper_face_data_destroy (hb_coretext_shaper_face_data_t *data)</span>
 289 {
 290   CFRelease ((CGFontRef) data);
 291 }
 292 
 293 hb_face_t *
 294 hb_coretext_face_create (CGFontRef cg_font)
 295 {
 296   return hb_face_create_for_tables (reference_table, CGFontRetain (cg_font), _hb_cg_font_release);
 297 }
 298 
 299 /*
 300  * Since: 0.9.10
 301  */
 302 CGFontRef
 303 hb_coretext_face_get_cg_font (hb_face_t *face)
 304 {
<a name="11" id="anc11"></a><span class="line-modified"> 305   if (unlikely (!hb_coretext_shaper_face_data_ensure (face))) return nullptr;</span>
<span class="line-removed"> 306   return (CGFontRef) HB_SHAPER_DATA_GET (face);</span>
 307 }
 308 
 309 
<a name="12" id="anc12"></a><span class="line-modified"> 310 hb_coretext_shaper_font_data_t *</span>
 311 _hb_coretext_shaper_font_data_create (hb_font_t *font)
 312 {
 313   hb_face_t *face = font-&gt;face;
<a name="13" id="anc13"></a><span class="line-modified"> 314   if (unlikely (!hb_coretext_shaper_face_data_ensure (face))) return nullptr;</span>
<span class="line-modified"> 315   CGFontRef cg_font = (CGFontRef) HB_SHAPER_DATA_GET (face);</span>

 316 
 317   CTFontRef ct_font = create_ct_font (cg_font, coretext_font_size_from_ptem (font-&gt;ptem));
 318 
 319   if (unlikely (!ct_font))
 320   {
 321     DEBUG_MSG (CORETEXT, font, &quot;CGFont creation failed..&quot;);
 322     return nullptr;
 323   }
 324 
<a name="14" id="anc14"></a><span class="line-modified"> 325   return (hb_coretext_shaper_font_data_t *) ct_font;</span>
 326 }
 327 
 328 void
<a name="15" id="anc15"></a><span class="line-modified"> 329 _hb_coretext_shaper_font_data_destroy (hb_coretext_shaper_font_data_t *data)</span>
 330 {
 331   CFRelease ((CTFontRef) data);
 332 }
 333 
<a name="16" id="anc16"></a>































 334 /*
 335  * Since: 1.7.2
 336  */
 337 hb_font_t *
 338 hb_coretext_font_create (CTFontRef ct_font)
 339 {
 340   CGFontRef cg_font = CTFontCopyGraphicsFont (ct_font, nullptr);
 341   hb_face_t *face = hb_coretext_face_create (cg_font);
 342   CFRelease (cg_font);
 343   hb_font_t *font = hb_font_create (face);
 344   hb_face_destroy (face);
 345 
<a name="17" id="anc17"></a><span class="line-modified"> 346   if (unlikely (hb_object_is_inert (font)))</span>
 347     return font;
 348 
 349   hb_font_set_ptem (font, coretext_font_size_to_ptem (CTFontGetSize(ct_font)));
 350 
 351   /* Let there be dragons here... */
<a name="18" id="anc18"></a><span class="line-modified"> 352   HB_SHAPER_DATA_GET (font) = (hb_coretext_shaper_font_data_t *) CFRetain (ct_font);</span>
 353 
 354   return font;
 355 }
 356 
 357 CTFontRef
 358 hb_coretext_font_get_ct_font (hb_font_t *font)
 359 {
<a name="19" id="anc19"></a><span class="line-modified"> 360   if (unlikely (!hb_coretext_shaper_font_data_ensure (font))) return nullptr;</span>
<span class="line-modified"> 361   return (CTFontRef) HB_SHAPER_DATA_GET (font);</span>
<span class="line-removed"> 362 }</span>
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365 </span>
<span class="line-removed"> 366 /*</span>
<span class="line-removed"> 367  * shaper shape_plan data</span>
<span class="line-removed"> 368  */</span>
<span class="line-removed"> 369 </span>
<span class="line-removed"> 370 struct hb_coretext_shaper_shape_plan_data_t {};</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372 hb_coretext_shaper_shape_plan_data_t *</span>
<span class="line-removed"> 373 _hb_coretext_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan HB_UNUSED,</span>
<span class="line-removed"> 374                                              const hb_feature_t *user_features HB_UNUSED,</span>
<span class="line-removed"> 375                                              unsigned int        num_user_features HB_UNUSED,</span>
<span class="line-removed"> 376                                              const int          *coords HB_UNUSED,</span>
<span class="line-removed"> 377                                              unsigned int        num_coords HB_UNUSED)</span>
<span class="line-removed"> 378 {</span>
<span class="line-removed"> 379   return (hb_coretext_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
<span class="line-removed"> 380 }</span>
<span class="line-removed"> 381 </span>
<span class="line-removed"> 382 void</span>
<span class="line-removed"> 383 _hb_coretext_shaper_shape_plan_data_destroy (hb_coretext_shaper_shape_plan_data_t *data HB_UNUSED)</span>
<span class="line-removed"> 384 {</span>
 385 }
 386 
 387 
 388 /*
 389  * shaper
 390  */
 391 
 392 struct feature_record_t {
 393   unsigned int feature;
 394   unsigned int setting;
 395 };
 396 
 397 struct active_feature_t {
 398   feature_record_t rec;
 399   unsigned int order;
 400 
 401   static int cmp (const void *pa, const void *pb) {
 402     const active_feature_t *a = (const active_feature_t *) pa;
 403     const active_feature_t *b = (const active_feature_t *) pb;
 404     return a-&gt;rec.feature &lt; b-&gt;rec.feature ? -1 : a-&gt;rec.feature &gt; b-&gt;rec.feature ? 1 :
 405            a-&gt;order &lt; b-&gt;order ? -1 : a-&gt;order &gt; b-&gt;order ? 1 :
 406            a-&gt;rec.setting &lt; b-&gt;rec.setting ? -1 : a-&gt;rec.setting &gt; b-&gt;rec.setting ? 1 :
 407            0;
 408   }
 409   bool operator== (const active_feature_t *f) {
 410     return cmp (this, f) == 0;
 411   }
 412 };
 413 
 414 struct feature_event_t {
 415   unsigned int index;
 416   bool start;
 417   active_feature_t feature;
 418 
 419   static int cmp (const void *pa, const void *pb) {
 420     const feature_event_t *a = (const feature_event_t *) pa;
 421     const feature_event_t *b = (const feature_event_t *) pb;
 422     return a-&gt;index &lt; b-&gt;index ? -1 : a-&gt;index &gt; b-&gt;index ? 1 :
 423            a-&gt;start &lt; b-&gt;start ? -1 : a-&gt;start &gt; b-&gt;start ? 1 :
 424            active_feature_t::cmp (&amp;a-&gt;feature, &amp;b-&gt;feature);
 425   }
 426 };
 427 
 428 struct range_record_t {
 429   CTFontRef font;
 430   unsigned int index_first; /* == start */
 431   unsigned int index_last;  /* == end - 1 */
 432 };
 433 
 434 
<a name="20" id="anc20"></a><span class="line-removed"> 435 /* The following enum members are added in OS X 10.8. */</span>
<span class="line-removed"> 436 #define kAltHalfWidthTextSelector               6</span>
<span class="line-removed"> 437 #define kAltProportionalTextSelector            5</span>
<span class="line-removed"> 438 #define kAlternateHorizKanaOffSelector          1</span>
<span class="line-removed"> 439 #define kAlternateHorizKanaOnSelector           0</span>
<span class="line-removed"> 440 #define kAlternateKanaType                      34</span>
<span class="line-removed"> 441 #define kAlternateVertKanaOffSelector           3</span>
<span class="line-removed"> 442 #define kAlternateVertKanaOnSelector            2</span>
<span class="line-removed"> 443 #define kCaseSensitiveLayoutOffSelector         1</span>
<span class="line-removed"> 444 #define kCaseSensitiveLayoutOnSelector          0</span>
<span class="line-removed"> 445 #define kCaseSensitiveLayoutType                33</span>
<span class="line-removed"> 446 #define kCaseSensitiveSpacingOffSelector        3</span>
<span class="line-removed"> 447 #define kCaseSensitiveSpacingOnSelector         2</span>
<span class="line-removed"> 448 #define kContextualAlternatesOffSelector        1</span>
<span class="line-removed"> 449 #define kContextualAlternatesOnSelector         0</span>
<span class="line-removed"> 450 #define kContextualAlternatesType               36</span>
<span class="line-removed"> 451 #define kContextualLigaturesOffSelector         19</span>
<span class="line-removed"> 452 #define kContextualLigaturesOnSelector          18</span>
<span class="line-removed"> 453 #define kContextualSwashAlternatesOffSelector   5</span>
<span class="line-removed"> 454 #define kContextualSwashAlternatesOnSelector    4</span>
<span class="line-removed"> 455 #define kDefaultLowerCaseSelector               0</span>
<span class="line-removed"> 456 #define kDefaultUpperCaseSelector               0</span>
<span class="line-removed"> 457 #define kHistoricalLigaturesOffSelector         21</span>
<span class="line-removed"> 458 #define kHistoricalLigaturesOnSelector          20</span>
<span class="line-removed"> 459 #define kHojoCharactersSelector                 12</span>
<span class="line-removed"> 460 #define kJIS2004CharactersSelector              11</span>
<span class="line-removed"> 461 #define kLowerCasePetiteCapsSelector            2</span>
<span class="line-removed"> 462 #define kLowerCaseSmallCapsSelector             1</span>
<span class="line-removed"> 463 #define kLowerCaseType                          37</span>
<span class="line-removed"> 464 #define kMathematicalGreekOffSelector           11</span>
<span class="line-removed"> 465 #define kMathematicalGreekOnSelector            10</span>
<span class="line-removed"> 466 #define kNLCCharactersSelector                  13</span>
<span class="line-removed"> 467 #define kQuarterWidthTextSelector               4</span>
<span class="line-removed"> 468 #define kScientificInferiorsSelector            4</span>
<span class="line-removed"> 469 #define kStylisticAltEightOffSelector           17</span>
<span class="line-removed"> 470 #define kStylisticAltEightOnSelector            16</span>
<span class="line-removed"> 471 #define kStylisticAltEighteenOffSelector        37</span>
<span class="line-removed"> 472 #define kStylisticAltEighteenOnSelector         36</span>
<span class="line-removed"> 473 #define kStylisticAltElevenOffSelector          23</span>
<span class="line-removed"> 474 #define kStylisticAltElevenOnSelector           22</span>
<span class="line-removed"> 475 #define kStylisticAltFifteenOffSelector         31</span>
<span class="line-removed"> 476 #define kStylisticAltFifteenOnSelector          30</span>
<span class="line-removed"> 477 #define kStylisticAltFiveOffSelector            11</span>
<span class="line-removed"> 478 #define kStylisticAltFiveOnSelector             10</span>
<span class="line-removed"> 479 #define kStylisticAltFourOffSelector            9</span>
<span class="line-removed"> 480 #define kStylisticAltFourOnSelector             8</span>
<span class="line-removed"> 481 #define kStylisticAltFourteenOffSelector        29</span>
<span class="line-removed"> 482 #define kStylisticAltFourteenOnSelector         28</span>
<span class="line-removed"> 483 #define kStylisticAltNineOffSelector            19</span>
<span class="line-removed"> 484 #define kStylisticAltNineOnSelector             18</span>
<span class="line-removed"> 485 #define kStylisticAltNineteenOffSelector        39</span>
<span class="line-removed"> 486 #define kStylisticAltNineteenOnSelector         38</span>
<span class="line-removed"> 487 #define kStylisticAltOneOffSelector             3</span>
<span class="line-removed"> 488 #define kStylisticAltOneOnSelector              2</span>
<span class="line-removed"> 489 #define kStylisticAltSevenOffSelector           15</span>
<span class="line-removed"> 490 #define kStylisticAltSevenOnSelector            14</span>
<span class="line-removed"> 491 #define kStylisticAltSeventeenOffSelector       35</span>
<span class="line-removed"> 492 #define kStylisticAltSeventeenOnSelector        34</span>
<span class="line-removed"> 493 #define kStylisticAltSixOffSelector             13</span>
<span class="line-removed"> 494 #define kStylisticAltSixOnSelector              12</span>
<span class="line-removed"> 495 #define kStylisticAltSixteenOffSelector         33</span>
<span class="line-removed"> 496 #define kStylisticAltSixteenOnSelector          32</span>
<span class="line-removed"> 497 #define kStylisticAltTenOffSelector             21</span>
<span class="line-removed"> 498 #define kStylisticAltTenOnSelector              20</span>
<span class="line-removed"> 499 #define kStylisticAltThirteenOffSelector        27</span>
<span class="line-removed"> 500 #define kStylisticAltThirteenOnSelector         26</span>
<span class="line-removed"> 501 #define kStylisticAltThreeOffSelector           7</span>
<span class="line-removed"> 502 #define kStylisticAltThreeOnSelector            6</span>
<span class="line-removed"> 503 #define kStylisticAltTwelveOffSelector          25</span>
<span class="line-removed"> 504 #define kStylisticAltTwelveOnSelector           24</span>
<span class="line-removed"> 505 #define kStylisticAltTwentyOffSelector          41</span>
<span class="line-removed"> 506 #define kStylisticAltTwentyOnSelector           40</span>
<span class="line-removed"> 507 #define kStylisticAltTwoOffSelector             5</span>
<span class="line-removed"> 508 #define kStylisticAltTwoOnSelector              4</span>
<span class="line-removed"> 509 #define kStylisticAlternativesType              35</span>
<span class="line-removed"> 510 #define kSwashAlternatesOffSelector             3</span>
<span class="line-removed"> 511 #define kSwashAlternatesOnSelector              2</span>
<span class="line-removed"> 512 #define kThirdWidthTextSelector                 3</span>
<span class="line-removed"> 513 #define kTraditionalNamesCharactersSelector     14</span>
<span class="line-removed"> 514 #define kUpperCasePetiteCapsSelector            2</span>
<span class="line-removed"> 515 #define kUpperCaseSmallCapsSelector             1</span>
<span class="line-removed"> 516 #define kUpperCaseType                          38</span>
<span class="line-removed"> 517 </span>
<span class="line-removed"> 518 /* Table data courtesy of Apple. */</span>
<span class="line-removed"> 519 static const struct feature_mapping_t {</span>
<span class="line-removed"> 520     FourCharCode otFeatureTag;</span>
<span class="line-removed"> 521     uint16_t aatFeatureType;</span>
<span class="line-removed"> 522     uint16_t selectorToEnable;</span>
<span class="line-removed"> 523     uint16_t selectorToDisable;</span>
<span class="line-removed"> 524 } feature_mappings[] = {</span>
<span class="line-removed"> 525     { &#39;c2pc&#39;,   kUpperCaseType,             kUpperCasePetiteCapsSelector,           kDefaultUpperCaseSelector },</span>
<span class="line-removed"> 526     { &#39;c2sc&#39;,   kUpperCaseType,             kUpperCaseSmallCapsSelector,            kDefaultUpperCaseSelector },</span>
<span class="line-removed"> 527     { &#39;calt&#39;,   kContextualAlternatesType,  kContextualAlternatesOnSelector,        kContextualAlternatesOffSelector },</span>
<span class="line-removed"> 528     { &#39;case&#39;,   kCaseSensitiveLayoutType,   kCaseSensitiveLayoutOnSelector,         kCaseSensitiveLayoutOffSelector },</span>
<span class="line-removed"> 529     { &#39;clig&#39;,   kLigaturesType,             kContextualLigaturesOnSelector,         kContextualLigaturesOffSelector },</span>
<span class="line-removed"> 530     { &#39;cpsp&#39;,   kCaseSensitiveLayoutType,   kCaseSensitiveSpacingOnSelector,        kCaseSensitiveSpacingOffSelector },</span>
<span class="line-removed"> 531     { &#39;cswh&#39;,   kContextualAlternatesType,  kContextualSwashAlternatesOnSelector,   kContextualSwashAlternatesOffSelector },</span>
<span class="line-removed"> 532     { &#39;dlig&#39;,   kLigaturesType,             kRareLigaturesOnSelector,               kRareLigaturesOffSelector },</span>
<span class="line-removed"> 533     { &#39;expt&#39;,   kCharacterShapeType,        kExpertCharactersSelector,              16 },</span>
<span class="line-removed"> 534     { &#39;frac&#39;,   kFractionsType,             kDiagonalFractionsSelector,             kNoFractionsSelector },</span>
<span class="line-removed"> 535     { &#39;fwid&#39;,   kTextSpacingType,           kMonospacedTextSelector,                7 },</span>
<span class="line-removed"> 536     { &#39;halt&#39;,   kTextSpacingType,           kAltHalfWidthTextSelector,              7 },</span>
<span class="line-removed"> 537     { &#39;hist&#39;,   kLigaturesType,             kHistoricalLigaturesOnSelector,         kHistoricalLigaturesOffSelector },</span>
<span class="line-removed"> 538     { &#39;hkna&#39;,   kAlternateKanaType,         kAlternateHorizKanaOnSelector,          kAlternateHorizKanaOffSelector, },</span>
<span class="line-removed"> 539     { &#39;hlig&#39;,   kLigaturesType,             kHistoricalLigaturesOnSelector,         kHistoricalLigaturesOffSelector },</span>
<span class="line-removed"> 540     { &#39;hngl&#39;,   kTransliterationType,       kHanjaToHangulSelector,                 kNoTransliterationSelector },</span>
<span class="line-removed"> 541     { &#39;hojo&#39;,   kCharacterShapeType,        kHojoCharactersSelector,                16 },</span>
<span class="line-removed"> 542     { &#39;hwid&#39;,   kTextSpacingType,           kHalfWidthTextSelector,                 7 },</span>
<span class="line-removed"> 543     { &#39;ital&#39;,   kItalicCJKRomanType,        kCJKItalicRomanOnSelector,              kCJKItalicRomanOffSelector },</span>
<span class="line-removed"> 544     { &#39;jp04&#39;,   kCharacterShapeType,        kJIS2004CharactersSelector,             16 },</span>
<span class="line-removed"> 545     { &#39;jp78&#39;,   kCharacterShapeType,        kJIS1978CharactersSelector,             16 },</span>
<span class="line-removed"> 546     { &#39;jp83&#39;,   kCharacterShapeType,        kJIS1983CharactersSelector,             16 },</span>
<span class="line-removed"> 547     { &#39;jp90&#39;,   kCharacterShapeType,        kJIS1990CharactersSelector,             16 },</span>
<span class="line-removed"> 548     { &#39;liga&#39;,   kLigaturesType,             kCommonLigaturesOnSelector,             kCommonLigaturesOffSelector },</span>
<span class="line-removed"> 549     { &#39;lnum&#39;,   kNumberCaseType,            kUpperCaseNumbersSelector,              2 },</span>
<span class="line-removed"> 550     { &#39;mgrk&#39;,   kMathematicalExtrasType,    kMathematicalGreekOnSelector,           kMathematicalGreekOffSelector },</span>
<span class="line-removed"> 551     { &#39;nlck&#39;,   kCharacterShapeType,        kNLCCharactersSelector,                 16 },</span>
<span class="line-removed"> 552     { &#39;onum&#39;,   kNumberCaseType,            kLowerCaseNumbersSelector,              2 },</span>
<span class="line-removed"> 553     { &#39;ordn&#39;,   kVerticalPositionType,      kOrdinalsSelector,                      kNormalPositionSelector },</span>
<span class="line-removed"> 554     { &#39;palt&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 555     { &#39;pcap&#39;,   kLowerCaseType,             kLowerCasePetiteCapsSelector,           kDefaultLowerCaseSelector },</span>
<span class="line-removed"> 556     { &#39;pkna&#39;,   kTextSpacingType,           kProportionalTextSelector,              7 },</span>
<span class="line-removed"> 557     { &#39;pnum&#39;,   kNumberSpacingType,         kProportionalNumbersSelector,           4 },</span>
<span class="line-removed"> 558     { &#39;pwid&#39;,   kTextSpacingType,           kProportionalTextSelector,              7 },</span>
<span class="line-removed"> 559     { &#39;qwid&#39;,   kTextSpacingType,           kQuarterWidthTextSelector,              7 },</span>
<span class="line-removed"> 560     { &#39;ruby&#39;,   kRubyKanaType,              kRubyKanaOnSelector,                    kRubyKanaOffSelector },</span>
<span class="line-removed"> 561     { &#39;sinf&#39;,   kVerticalPositionType,      kScientificInferiorsSelector,           kNormalPositionSelector },</span>
<span class="line-removed"> 562     { &#39;smcp&#39;,   kLowerCaseType,             kLowerCaseSmallCapsSelector,            kDefaultLowerCaseSelector },</span>
<span class="line-removed"> 563     { &#39;smpl&#39;,   kCharacterShapeType,        kSimplifiedCharactersSelector,          16 },</span>
<span class="line-removed"> 564     { &#39;ss01&#39;,   kStylisticAlternativesType, kStylisticAltOneOnSelector,             kStylisticAltOneOffSelector },</span>
<span class="line-removed"> 565     { &#39;ss02&#39;,   kStylisticAlternativesType, kStylisticAltTwoOnSelector,             kStylisticAltTwoOffSelector },</span>
<span class="line-removed"> 566     { &#39;ss03&#39;,   kStylisticAlternativesType, kStylisticAltThreeOnSelector,           kStylisticAltThreeOffSelector },</span>
<span class="line-removed"> 567     { &#39;ss04&#39;,   kStylisticAlternativesType, kStylisticAltFourOnSelector,            kStylisticAltFourOffSelector },</span>
<span class="line-removed"> 568     { &#39;ss05&#39;,   kStylisticAlternativesType, kStylisticAltFiveOnSelector,            kStylisticAltFiveOffSelector },</span>
<span class="line-removed"> 569     { &#39;ss06&#39;,   kStylisticAlternativesType, kStylisticAltSixOnSelector,             kStylisticAltSixOffSelector },</span>
<span class="line-removed"> 570     { &#39;ss07&#39;,   kStylisticAlternativesType, kStylisticAltSevenOnSelector,           kStylisticAltSevenOffSelector },</span>
<span class="line-removed"> 571     { &#39;ss08&#39;,   kStylisticAlternativesType, kStylisticAltEightOnSelector,           kStylisticAltEightOffSelector },</span>
<span class="line-removed"> 572     { &#39;ss09&#39;,   kStylisticAlternativesType, kStylisticAltNineOnSelector,            kStylisticAltNineOffSelector },</span>
<span class="line-removed"> 573     { &#39;ss10&#39;,   kStylisticAlternativesType, kStylisticAltTenOnSelector,             kStylisticAltTenOffSelector },</span>
<span class="line-removed"> 574     { &#39;ss11&#39;,   kStylisticAlternativesType, kStylisticAltElevenOnSelector,          kStylisticAltElevenOffSelector },</span>
<span class="line-removed"> 575     { &#39;ss12&#39;,   kStylisticAlternativesType, kStylisticAltTwelveOnSelector,          kStylisticAltTwelveOffSelector },</span>
<span class="line-removed"> 576     { &#39;ss13&#39;,   kStylisticAlternativesType, kStylisticAltThirteenOnSelector,        kStylisticAltThirteenOffSelector },</span>
<span class="line-removed"> 577     { &#39;ss14&#39;,   kStylisticAlternativesType, kStylisticAltFourteenOnSelector,        kStylisticAltFourteenOffSelector },</span>
<span class="line-removed"> 578     { &#39;ss15&#39;,   kStylisticAlternativesType, kStylisticAltFifteenOnSelector,         kStylisticAltFifteenOffSelector },</span>
<span class="line-removed"> 579     { &#39;ss16&#39;,   kStylisticAlternativesType, kStylisticAltSixteenOnSelector,         kStylisticAltSixteenOffSelector },</span>
<span class="line-removed"> 580     { &#39;ss17&#39;,   kStylisticAlternativesType, kStylisticAltSeventeenOnSelector,       kStylisticAltSeventeenOffSelector },</span>
<span class="line-removed"> 581     { &#39;ss18&#39;,   kStylisticAlternativesType, kStylisticAltEighteenOnSelector,        kStylisticAltEighteenOffSelector },</span>
<span class="line-removed"> 582     { &#39;ss19&#39;,   kStylisticAlternativesType, kStylisticAltNineteenOnSelector,        kStylisticAltNineteenOffSelector },</span>
<span class="line-removed"> 583     { &#39;ss20&#39;,   kStylisticAlternativesType, kStylisticAltTwentyOnSelector,          kStylisticAltTwentyOffSelector },</span>
<span class="line-removed"> 584     { &#39;subs&#39;,   kVerticalPositionType,      kInferiorsSelector,                     kNormalPositionSelector },</span>
<span class="line-removed"> 585     { &#39;sups&#39;,   kVerticalPositionType,      kSuperiorsSelector,                     kNormalPositionSelector },</span>
<span class="line-removed"> 586     { &#39;swsh&#39;,   kContextualAlternatesType,  kSwashAlternatesOnSelector,             kSwashAlternatesOffSelector },</span>
<span class="line-removed"> 587     { &#39;titl&#39;,   kStyleOptionsType,          kTitlingCapsSelector,                   kNoStyleOptionsSelector },</span>
<span class="line-removed"> 588     { &#39;tnam&#39;,   kCharacterShapeType,        kTraditionalNamesCharactersSelector,    16 },</span>
<span class="line-removed"> 589     { &#39;tnum&#39;,   kNumberSpacingType,         kMonospacedNumbersSelector,             4 },</span>
<span class="line-removed"> 590     { &#39;trad&#39;,   kCharacterShapeType,        kTraditionalCharactersSelector,         16 },</span>
<span class="line-removed"> 591     { &#39;twid&#39;,   kTextSpacingType,           kThirdWidthTextSelector,                7 },</span>
<span class="line-removed"> 592     { &#39;unic&#39;,   kLetterCaseType,            14,                                     15 },</span>
<span class="line-removed"> 593     { &#39;valt&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 594     { &#39;vert&#39;,   kVerticalSubstitutionType,  kSubstituteVerticalFormsOnSelector,     kSubstituteVerticalFormsOffSelector },</span>
<span class="line-removed"> 595     { &#39;vhal&#39;,   kTextSpacingType,           kAltHalfWidthTextSelector,              7 },</span>
<span class="line-removed"> 596     { &#39;vkna&#39;,   kAlternateKanaType,         kAlternateVertKanaOnSelector,           kAlternateVertKanaOffSelector },</span>
<span class="line-removed"> 597     { &#39;vpal&#39;,   kTextSpacingType,           kAltProportionalTextSelector,           7 },</span>
<span class="line-removed"> 598     { &#39;vrt2&#39;,   kVerticalSubstitutionType,  kSubstituteVerticalFormsOnSelector,     kSubstituteVerticalFormsOffSelector },</span>
<span class="line-removed"> 599     { &#39;zero&#39;,   kTypographicExtrasType,     kSlashedZeroOnSelector,                 kSlashedZeroOffSelector },</span>
<span class="line-removed"> 600 };</span>
<span class="line-removed"> 601 </span>
<span class="line-removed"> 602 static int</span>
<span class="line-removed"> 603 _hb_feature_mapping_cmp (const void *key_, const void *entry_)</span>
<span class="line-removed"> 604 {</span>
<span class="line-removed"> 605   unsigned int key = * (unsigned int *) key_;</span>
<span class="line-removed"> 606   const feature_mapping_t * entry = (const feature_mapping_t *) entry_;</span>
<span class="line-removed"> 607   return key &lt; entry-&gt;otFeatureTag ? -1 :</span>
<span class="line-removed"> 608          key &gt; entry-&gt;otFeatureTag ? 1 :</span>
<span class="line-removed"> 609          0;</span>
<span class="line-removed"> 610 }</span>
<span class="line-removed"> 611 </span>
 612 hb_bool_t
 613 _hb_coretext_shape (hb_shape_plan_t    *shape_plan,
 614                     hb_font_t          *font,
 615                     hb_buffer_t        *buffer,
 616                     const hb_feature_t *features,
 617                     unsigned int        num_features)
 618 {
 619   hb_face_t *face = font-&gt;face;
<a name="21" id="anc21"></a><span class="line-modified"> 620   CGFontRef cg_font = (CGFontRef) HB_SHAPER_DATA_GET (face);</span>
<span class="line-modified"> 621   CTFontRef ct_font = (CTFontRef) HB_SHAPER_DATA_GET (font);</span>
 622 
 623   CGFloat ct_font_size = CTFontGetSize (ct_font);
 624   CGFloat x_mult = (CGFloat) font-&gt;x_scale / ct_font_size;
 625   CGFloat y_mult = (CGFloat) font-&gt;y_scale / ct_font_size;
 626 
 627   /* Attach marks to their bases, to match the &#39;ot&#39; shaper.
<a name="22" id="anc22"></a><span class="line-modified"> 628    * Adapted from hb-ot-shape:hb_form_clusters().</span>
 629    * Note that this only makes us be closer to the &#39;ot&#39; shaper,
 630    * but by no means the same.  For example, if there&#39;s
 631    * B1 M1 B2 M2, and B1-B2 form a ligature, M2&#39;s cluster will
 632    * continue pointing to B2 even though B2 was merged into B1&#39;s
 633    * cluster... */
 634   if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
 635   {
 636     hb_unicode_funcs_t *unicode = buffer-&gt;unicode;
 637     unsigned int count = buffer-&gt;len;
 638     hb_glyph_info_t *info = buffer-&gt;info;
 639     for (unsigned int i = 1; i &lt; count; i++)
 640       if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (unicode-&gt;general_category (info[i].codepoint)))
 641         buffer-&gt;merge_clusters (i - 1, i + 1);
 642   }
 643 
<a name="23" id="anc23"></a><span class="line-modified"> 644   hb_auto_t&lt;hb_vector_t&lt;feature_record_t&gt; &gt; feature_records;</span>
<span class="line-modified"> 645   hb_auto_t&lt;hb_vector_t&lt;range_record_t&gt; &gt; range_records;</span>
 646 
 647   /*
 648    * Set up features.
 649    * (copied + modified from code from hb-uniscribe.cc)
 650    */
 651   if (num_features)
 652   {
 653     /* Sort features by start/end events. */
<a name="24" id="anc24"></a><span class="line-modified"> 654     hb_auto_t&lt;hb_vector_t&lt;feature_event_t&gt; &gt; feature_events;</span>
 655     for (unsigned int i = 0; i &lt; num_features; i++)
 656     {
<a name="25" id="anc25"></a><span class="line-modified"> 657       const feature_mapping_t * mapping = (const feature_mapping_t *) bsearch (&amp;features[i].tag,</span>
<span class="line-removed"> 658                                                                                feature_mappings,</span>
<span class="line-removed"> 659                                                                                ARRAY_LENGTH (feature_mappings),</span>
<span class="line-removed"> 660                                                                                sizeof (feature_mappings[0]),</span>
<span class="line-removed"> 661                                                                                _hb_feature_mapping_cmp);</span>
 662       if (!mapping)
 663         continue;
 664 
 665       active_feature_t feature;
 666       feature.rec.feature = mapping-&gt;aatFeatureType;
 667       feature.rec.setting = features[i].value ? mapping-&gt;selectorToEnable : mapping-&gt;selectorToDisable;
 668       feature.order = i;
 669 
 670       feature_event_t *event;
 671 
 672       event = feature_events.push ();
 673       event-&gt;index = features[i].start;
 674       event-&gt;start = true;
 675       event-&gt;feature = feature;
 676 
 677       event = feature_events.push ();
 678       event-&gt;index = features[i].end;
 679       event-&gt;start = false;
 680       event-&gt;feature = feature;
 681     }
 682     feature_events.qsort ();
 683     /* Add a strategic final event. */
 684     {
 685       active_feature_t feature;
 686       feature.rec.feature = HB_TAG_NONE;
 687       feature.rec.setting = 0;
 688       feature.order = num_features + 1;
 689 
 690       feature_event_t *event = feature_events.push ();
 691       event-&gt;index = 0; /* This value does magic. */
 692       event-&gt;start = false;
 693       event-&gt;feature = feature;
 694     }
 695 
 696     /* Scan events and save features for each range. */
<a name="26" id="anc26"></a><span class="line-modified"> 697     hb_auto_t&lt;hb_vector_t&lt;active_feature_t&gt; &gt; active_features;</span>
 698     unsigned int last_index = 0;
<a name="27" id="anc27"></a><span class="line-modified"> 699     for (unsigned int i = 0; i &lt; feature_events.len; i++)</span>
 700     {
 701       feature_event_t *event = &amp;feature_events[i];
 702 
 703       if (event-&gt;index != last_index)
 704       {
 705         /* Save a snapshot of active features and the range. */
 706         range_record_t *range = range_records.push ();
 707 
<a name="28" id="anc28"></a><span class="line-modified"> 708         if (active_features.len)</span>
 709         {
 710           CFMutableArrayRef features_array = CFArrayCreateMutable(kCFAllocatorDefault, 0, &amp;kCFTypeArrayCallBacks);
 711 
 712           /* TODO sort and resolve conflicting features? */
 713           /* active_features.qsort (); */
<a name="29" id="anc29"></a><span class="line-modified"> 714           for (unsigned int j = 0; j &lt; active_features.len; j++)</span>
 715           {
 716             CFStringRef keys[] = {
 717               kCTFontFeatureTypeIdentifierKey,
 718               kCTFontFeatureSelectorIdentifierKey
 719             };
 720             CFNumberRef values[] = {
 721               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.feature),
 722               CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;active_features[j].rec.setting)
 723             };
 724             static_assert ((ARRAY_LENGTH_CONST (keys) == ARRAY_LENGTH_CONST (values)), &quot;&quot;);
 725             CFDictionaryRef dict = CFDictionaryCreate (kCFAllocatorDefault,
 726                                                        (const void **) keys,
 727                                                        (const void **) values,
 728                                                        ARRAY_LENGTH (keys),
 729                                                        &amp;kCFTypeDictionaryKeyCallBacks,
 730                                                        &amp;kCFTypeDictionaryValueCallBacks);
 731             for (unsigned int i = 0; i &lt; ARRAY_LENGTH (values); i++)
 732               CFRelease (values[i]);
 733 
 734             CFArrayAppendValue (features_array, dict);
 735             CFRelease (dict);
 736 
 737           }
 738 
 739           CFDictionaryRef attributes = CFDictionaryCreate (kCFAllocatorDefault,
 740                                                            (const void **) &amp;kCTFontFeatureSettingsAttribute,
 741                                                            (const void **) &amp;features_array,
 742                                                            1,
 743                                                            &amp;kCFTypeDictionaryKeyCallBacks,
 744                                                            &amp;kCFTypeDictionaryValueCallBacks);
 745           CFRelease (features_array);
 746 
 747           CTFontDescriptorRef font_desc = CTFontDescriptorCreateWithAttributes (attributes);
 748           CFRelease (attributes);
 749 
 750           range-&gt;font = CTFontCreateCopyWithAttributes (ct_font, 0.0, nullptr, font_desc);
 751           CFRelease (font_desc);
 752         }
 753         else
 754         {
 755           range-&gt;font = nullptr;
 756         }
 757 
 758         range-&gt;index_first = last_index;
 759         range-&gt;index_last  = event-&gt;index - 1;
 760 
 761         last_index = event-&gt;index;
 762       }
 763 
 764       if (event-&gt;start)
 765       {
 766         active_features.push (event-&gt;feature);
 767       } else {
 768         active_feature_t *feature = active_features.find (&amp;event-&gt;feature);
 769         if (feature)
<a name="30" id="anc30"></a><span class="line-modified"> 770           active_features.remove (feature - active_features.arrayZ);</span>
 771       }
 772     }
 773   }
 774 
 775   unsigned int scratch_size;
 776   hb_buffer_t::scratch_buffer_t *scratch = buffer-&gt;get_scratch_buffer (&amp;scratch_size);
 777 
 778 #define ALLOCATE_ARRAY(Type, name, len, on_no_room) \
 779   Type *name = (Type *) scratch; \
 780   { \
 781     unsigned int _consumed = DIV_CEIL ((len) * sizeof (Type), sizeof (*scratch)); \
 782     if (unlikely (_consumed &gt; scratch_size)) \
 783     { \
 784       on_no_room; \
 785       assert (0); \
 786     } \
 787     scratch += _consumed; \
 788     scratch_size -= _consumed; \
 789   }
 790 
 791   ALLOCATE_ARRAY (UniChar, pchars, buffer-&gt;len * 2, /*nothing*/);
 792   unsigned int chars_len = 0;
 793   for (unsigned int i = 0; i &lt; buffer-&gt;len; i++) {
 794     hb_codepoint_t c = buffer-&gt;info[i].codepoint;
 795     if (likely (c &lt;= 0xFFFFu))
 796       pchars[chars_len++] = c;
 797     else if (unlikely (c &gt; 0x10FFFFu))
 798       pchars[chars_len++] = 0xFFFDu;
 799     else {
 800       pchars[chars_len++] = 0xD800u + ((c - 0x10000u) &gt;&gt; 10);
 801       pchars[chars_len++] = 0xDC00u + ((c - 0x10000u) &amp; ((1u &lt;&lt; 10) - 1));
 802     }
 803   }
 804 
 805   ALLOCATE_ARRAY (unsigned int, log_clusters, chars_len, /*nothing*/);
 806   chars_len = 0;
 807   for (unsigned int i = 0; i &lt; buffer-&gt;len; i++)
 808   {
 809     hb_codepoint_t c = buffer-&gt;info[i].codepoint;
 810     unsigned int cluster = buffer-&gt;info[i].cluster;
 811     log_clusters[chars_len++] = cluster;
 812     if (hb_in_range (c, 0x10000u, 0x10FFFFu))
 813       log_clusters[chars_len++] = cluster; /* Surrogates. */
 814   }
 815 
 816 #define FAIL(...) \
 817   HB_STMT_START { \
 818     DEBUG_MSG (CORETEXT, nullptr, __VA_ARGS__); \
 819     ret = false; \
 820     goto fail; \
 821   } HB_STMT_END;
 822 
 823   bool ret = true;
 824   CFStringRef string_ref = nullptr;
 825   CTLineRef line = nullptr;
 826 
<a name="31" id="anc31"></a><span class="line-modified"> 827   if (0)</span>
 828   {
 829 resize_and_retry:
 830     DEBUG_MSG (CORETEXT, buffer, &quot;Buffer resize&quot;);
 831     /* string_ref uses the scratch-buffer for backing store, and line references
 832      * string_ref (via attr_string).  We must release those before resizing buffer. */
 833     assert (string_ref);
 834     assert (line);
 835     CFRelease (string_ref);
 836     CFRelease (line);
 837     string_ref = nullptr;
 838     line = nullptr;
 839 
 840     /* Get previous start-of-scratch-area, that we use later for readjusting
 841      * our existing scratch arrays. */
 842     unsigned int old_scratch_used;
 843     hb_buffer_t::scratch_buffer_t *old_scratch;
 844     old_scratch = buffer-&gt;get_scratch_buffer (&amp;old_scratch_used);
 845     old_scratch_used = scratch - old_scratch;
 846 
 847     if (unlikely (!buffer-&gt;ensure (buffer-&gt;allocated * 2)))
 848       FAIL (&quot;Buffer resize failed&quot;);
 849 
 850     /* Adjust scratch, pchars, and log_cluster arrays.  This is ugly, but really the
 851      * cleanest way to do without completely restructuring the rest of this shaper. */
 852     scratch = buffer-&gt;get_scratch_buffer (&amp;scratch_size);
 853     pchars = reinterpret_cast&lt;UniChar *&gt; (((char *) scratch + ((char *) pchars - (char *) old_scratch)));
 854     log_clusters = reinterpret_cast&lt;unsigned int *&gt; (((char *) scratch + ((char *) log_clusters - (char *) old_scratch)));
 855     scratch += old_scratch_used;
 856     scratch_size -= old_scratch_used;
 857   }
 858   {
 859     string_ref = CFStringCreateWithCharactersNoCopy (nullptr,
 860                                                      pchars, chars_len,
 861                                                      kCFAllocatorNull);
 862     if (unlikely (!string_ref))
 863       FAIL (&quot;CFStringCreateWithCharactersNoCopy failed&quot;);
 864 
 865     /* Create an attributed string, populate it, and create a line from it, then release attributed string. */
 866     {
 867       CFMutableAttributedStringRef attr_string = CFAttributedStringCreateMutable (kCFAllocatorDefault,
 868                                                                                   chars_len);
 869       if (unlikely (!attr_string))
 870         FAIL (&quot;CFAttributedStringCreateMutable failed&quot;);
 871       CFAttributedStringReplaceString (attr_string, CFRangeMake (0, 0), string_ref);
 872       if (HB_DIRECTION_IS_VERTICAL (buffer-&gt;props.direction))
 873       {
 874         CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 875                                         kCTVerticalFormsAttributeName, kCFBooleanTrue);
 876       }
 877 
 878       if (buffer-&gt;props.language)
 879       {
 880 /* What&#39;s the iOS equivalent of this check?
 881  * The symbols was introduced in iOS 7.0.
 882  * At any rate, our fallback is safe and works fine. */
 883 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1090
 884 #  define kCTLanguageAttributeName CFSTR (&quot;NSLanguage&quot;)
 885 #endif
 886         CFStringRef lang = CFStringCreateWithCStringNoCopy (kCFAllocatorDefault,
 887                                                             hb_language_to_string (buffer-&gt;props.language),
 888                                                             kCFStringEncodingUTF8,
 889                                                             kCFAllocatorNull);
 890         if (unlikely (!lang))
 891         {
 892           CFRelease (attr_string);
 893           FAIL (&quot;CFStringCreateWithCStringNoCopy failed&quot;);
 894         }
 895         CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 896                                         kCTLanguageAttributeName, lang);
 897         CFRelease (lang);
 898       }
 899       CFAttributedStringSetAttribute (attr_string, CFRangeMake (0, chars_len),
 900                                       kCTFontAttributeName, ct_font);
 901 
<a name="32" id="anc32"></a><span class="line-modified"> 902       if (num_features &amp;&amp; range_records.len)</span>
 903       {
 904         unsigned int start = 0;
 905         range_record_t *last_range = &amp;range_records[0];
 906         for (unsigned int k = 0; k &lt; chars_len; k++)
 907         {
 908           range_record_t *range = last_range;
 909           while (log_clusters[k] &lt; range-&gt;index_first)
 910             range--;
 911           while (log_clusters[k] &gt; range-&gt;index_last)
 912             range++;
 913           if (range != last_range)
 914           {
 915             if (last_range-&gt;font)
 916               CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, k - start),
 917                                               kCTFontAttributeName, last_range-&gt;font);
 918 
 919             start = k;
 920           }
 921 
 922           last_range = range;
 923         }
 924         if (start != chars_len &amp;&amp; last_range-&gt;font)
 925           CFAttributedStringSetAttribute (attr_string, CFRangeMake (start, chars_len - start),
 926                                           kCTFontAttributeName, last_range-&gt;font);
 927       }
 928       /* Enable/disable kern if requested.
 929        *
 930        * Note: once kern is disabled, reenabling it doesn&#39;t currently seem to work in CoreText.
 931        */
 932       if (num_features)
 933       {
 934         unsigned int zeroint = 0;
 935         CFNumberRef zero = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;zeroint);
 936         for (unsigned int i = 0; i &lt; num_features; i++)
 937         {
 938           const hb_feature_t &amp;feature = features[i];
 939           if (feature.tag == HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) &amp;&amp;
 940               feature.start &lt; chars_len &amp;&amp; feature.start &lt; feature.end)
 941           {
 942             CFRange feature_range = CFRangeMake (feature.start,
 943                                                  MIN (feature.end, chars_len) - feature.start);
 944             if (feature.value)
 945               CFAttributedStringRemoveAttribute (attr_string, feature_range, kCTKernAttributeName);
 946             else
 947               CFAttributedStringSetAttribute (attr_string, feature_range, kCTKernAttributeName, zero);
 948           }
 949         }
 950         CFRelease (zero);
 951       }
 952 
 953       int level = HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction) ? 0 : 1;
 954       CFNumberRef level_number = CFNumberCreate (kCFAllocatorDefault, kCFNumberIntType, &amp;level);
 955 #if MAC_OS_X_VERSION_MIN_REQUIRED &lt; 1060
 956       extern const CFStringRef kCTTypesetterOptionForcedEmbeddingLevel;
 957 #endif
 958       CFDictionaryRef options = CFDictionaryCreate (kCFAllocatorDefault,
 959                                                     (const void **) &amp;kCTTypesetterOptionForcedEmbeddingLevel,
 960                                                     (const void **) &amp;level_number,
 961                                                     1,
 962                                                     &amp;kCFTypeDictionaryKeyCallBacks,
 963                                                     &amp;kCFTypeDictionaryValueCallBacks);
 964       CFRelease (level_number);
 965       if (unlikely (!options))
 966       {
 967         CFRelease (attr_string);
 968         FAIL (&quot;CFDictionaryCreate failed&quot;);
 969       }
 970 
 971       CTTypesetterRef typesetter = CTTypesetterCreateWithAttributedStringAndOptions (attr_string, options);
 972       CFRelease (options);
 973       CFRelease (attr_string);
 974       if (unlikely (!typesetter))
 975         FAIL (&quot;CTTypesetterCreateWithAttributedStringAndOptions failed&quot;);
 976 
 977       line = CTTypesetterCreateLine (typesetter, CFRangeMake(0, 0));
 978       CFRelease (typesetter);
 979       if (unlikely (!line))
 980         FAIL (&quot;CTTypesetterCreateLine failed&quot;);
 981     }
 982 
 983     CFArrayRef glyph_runs = CTLineGetGlyphRuns (line);
 984     unsigned int num_runs = CFArrayGetCount (glyph_runs);
 985     DEBUG_MSG (CORETEXT, nullptr, &quot;Num runs: %d&quot;, num_runs);
 986 
 987     buffer-&gt;len = 0;
 988     uint32_t status_and = ~0, status_or = 0;
 989     double advances_so_far = 0;
 990     /* For right-to-left runs, CoreText returns the glyphs positioned such that
 991      * any trailing whitespace is to the left of (0,0).  Adjust coordinate system
 992      * to fix for that.  Test with any RTL string with trailing spaces.
 993      * https://crbug.com/469028
 994      */
 995     if (HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction))
 996     {
 997       advances_so_far -= CTLineGetTrailingWhitespaceWidth (line);
 998       if (HB_DIRECTION_IS_VERTICAL (buffer-&gt;props.direction))
 999           advances_so_far = -advances_so_far;
1000     }
1001 
1002     const CFRange range_all = CFRangeMake (0, 0);
1003 
1004     for (unsigned int i = 0; i &lt; num_runs; i++)
1005     {
1006       CTRunRef run = static_cast&lt;CTRunRef&gt;(CFArrayGetValueAtIndex (glyph_runs, i));
1007       CTRunStatus run_status = CTRunGetStatus (run);
1008       status_or  |= run_status;
1009       status_and &amp;= run_status;
1010       DEBUG_MSG (CORETEXT, run, &quot;CTRunStatus: %x&quot;, run_status);
1011       double run_advance = CTRunGetTypographicBounds (run, range_all, nullptr, nullptr, nullptr);
1012       if (HB_DIRECTION_IS_VERTICAL (buffer-&gt;props.direction))
1013           run_advance = -run_advance;
1014       DEBUG_MSG (CORETEXT, run, &quot;Run advance: %g&quot;, run_advance);
1015 
1016       /* CoreText does automatic font fallback (AKA &quot;cascading&quot;) for  characters
1017        * not supported by the requested font, and provides no way to turn it off,
1018        * so we must detect if the returned run uses a font other than the requested
1019        * one and fill in the buffer with .notdef glyphs instead of random glyph
1020        * indices from a different font.
1021        */
1022       CFDictionaryRef attributes = CTRunGetAttributes (run);
1023       CTFontRef run_ct_font = static_cast&lt;CTFontRef&gt;(CFDictionaryGetValue (attributes, kCTFontAttributeName));
1024       if (!CFEqual (run_ct_font, ct_font))
1025       {
1026         /* The run doesn&#39;t use our main font instance.  We have to figure out
1027          * whether font fallback happened, or this is just CoreText giving us
1028          * another CTFont using the same underlying CGFont.  CoreText seems
1029          * to do that in a variety of situations, one of which being vertical
1030          * text, but also perhaps for caching reasons.
1031          *
1032          * First, see if it uses any of our subfonts created to set font features...
1033          *
1034          * Next, compare the CGFont to the one we used to create our fonts.
1035          * Even this doesn&#39;t work all the time.
1036          *
1037          * Finally, we compare PS names, which I don&#39;t think are unique...
1038          *
1039          * Looks like if we really want to be sure here we have to modify the
1040          * font to change the name table, similar to what we do in the uniscribe
1041          * backend.
1042          *
1043          * However, even that wouldn&#39;t work if we were passed in the CGFont to
1044          * construct a hb_face to begin with.
1045          *
1046          * See: https://github.com/harfbuzz/harfbuzz/pull/36
1047          *
1048          * Also see: https://bugs.chromium.org/p/chromium/issues/detail?id=597098
1049          */
1050         bool matched = false;
<a name="33" id="anc33"></a><span class="line-modified">1051         for (unsigned int i = 0; i &lt; range_records.len; i++)</span>
1052           if (range_records[i].font &amp;&amp; CFEqual (run_ct_font, range_records[i].font))
1053           {
1054             matched = true;
1055             break;
1056           }
1057         if (!matched)
1058         {
1059           CGFontRef run_cg_font = CTFontCopyGraphicsFont (run_ct_font, nullptr);
1060           if (run_cg_font)
1061           {
1062             matched = CFEqual (run_cg_font, cg_font);
1063             CFRelease (run_cg_font);
1064           }
1065         }
1066         if (!matched)
1067         {
1068           CFStringRef font_ps_name = CTFontCopyName (ct_font, kCTFontPostScriptNameKey);
1069           CFStringRef run_ps_name = CTFontCopyName (run_ct_font, kCTFontPostScriptNameKey);
1070           CFComparisonResult result = CFStringCompare (run_ps_name, font_ps_name, 0);
1071           CFRelease (run_ps_name);
1072           CFRelease (font_ps_name);
1073           if (result == kCFCompareEqualTo)
1074             matched = true;
1075         }
1076         if (!matched)
1077         {
1078           CFRange range = CTRunGetStringRange (run);
1079           DEBUG_MSG (CORETEXT, run, &quot;Run used fallback font: %ld..%ld&quot;,
1080                      range.location, range.location + range.length);
1081           if (!buffer-&gt;ensure_inplace (buffer-&gt;len + range.length))
1082             goto resize_and_retry;
1083           hb_glyph_info_t *info = buffer-&gt;info + buffer-&gt;len;
1084 
1085           hb_codepoint_t notdef = 0;
1086           hb_direction_t dir = buffer-&gt;props.direction;
1087           hb_position_t x_advance, y_advance, x_offset, y_offset;
1088           hb_font_get_glyph_advance_for_direction (font, notdef, dir, &amp;x_advance, &amp;y_advance);
1089           hb_font_get_glyph_origin_for_direction (font, notdef, dir, &amp;x_offset, &amp;y_offset);
1090           hb_position_t advance = x_advance + y_advance;
1091           x_offset = -x_offset;
1092           y_offset = -y_offset;
1093 
1094           unsigned int old_len = buffer-&gt;len;
1095           for (CFIndex j = range.location; j &lt; range.location + range.length; j++)
1096           {
1097               UniChar ch = CFStringGetCharacterAtIndex (string_ref, j);
1098               if (hb_in_range&lt;UniChar&gt; (ch, 0xDC00u, 0xDFFFu) &amp;&amp; range.location &lt; j)
1099               {
1100                 ch = CFStringGetCharacterAtIndex (string_ref, j - 1);
1101                 if (hb_in_range&lt;UniChar&gt; (ch, 0xD800u, 0xDBFFu))
1102                   /* This is the second of a surrogate pair.  Don&#39;t need .notdef
1103                    * for this one. */
1104                   continue;
1105               }
1106               if (buffer-&gt;unicode-&gt;is_default_ignorable (ch))
1107                 continue;
1108 
1109               info-&gt;codepoint = notdef;
1110               info-&gt;cluster = log_clusters[j];
1111 
1112               info-&gt;mask = advance;
1113               info-&gt;var1.i32 = x_offset;
1114               info-&gt;var2.i32 = y_offset;
1115 
1116               info++;
1117               buffer-&gt;len++;
1118           }
1119           if (HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction))
1120             buffer-&gt;reverse_range (old_len, buffer-&gt;len);
1121           advances_so_far += run_advance;
1122           continue;
1123         }
1124       }
1125 
1126       unsigned int num_glyphs = CTRunGetGlyphCount (run);
1127       if (num_glyphs == 0)
1128         continue;
1129 
1130       if (!buffer-&gt;ensure_inplace (buffer-&gt;len + num_glyphs))
1131         goto resize_and_retry;
1132 
1133       hb_glyph_info_t *run_info = buffer-&gt;info + buffer-&gt;len;
1134 
1135       /* Testing used to indicate that CTRunGetGlyphsPtr, etc (almost?) always
1136        * succeed, and so copying data to our own buffer will be rare.  Reports
1137        * have it that this changed in OS X 10.10 Yosemite, and nullptr is returned
1138        * frequently.  At any rate, we can test that codepath by setting USE_PTR
1139        * to false. */
1140 
1141 #define USE_PTR true
1142 
1143 #define SCRATCH_SAVE() \
1144   unsigned int scratch_size_saved = scratch_size; \
1145   hb_buffer_t::scratch_buffer_t *scratch_saved = scratch
1146 
1147 #define SCRATCH_RESTORE() \
1148   scratch_size = scratch_size_saved; \
1149   scratch = scratch_saved;
1150 
1151       { /* Setup glyphs */
1152         SCRATCH_SAVE();
1153         const CGGlyph* glyphs = USE_PTR ? CTRunGetGlyphsPtr (run) : nullptr;
1154         if (!glyphs) {
1155           ALLOCATE_ARRAY (CGGlyph, glyph_buf, num_glyphs, goto resize_and_retry);
1156           CTRunGetGlyphs (run, range_all, glyph_buf);
1157           glyphs = glyph_buf;
1158         }
1159         const CFIndex* string_indices = USE_PTR ? CTRunGetStringIndicesPtr (run) : nullptr;
1160         if (!string_indices) {
1161           ALLOCATE_ARRAY (CFIndex, index_buf, num_glyphs, goto resize_and_retry);
1162           CTRunGetStringIndices (run, range_all, index_buf);
1163           string_indices = index_buf;
1164         }
1165         hb_glyph_info_t *info = run_info;
1166         for (unsigned int j = 0; j &lt; num_glyphs; j++)
1167         {
1168           info-&gt;codepoint = glyphs[j];
1169           info-&gt;cluster = log_clusters[string_indices[j]];
1170           info++;
1171         }
1172         SCRATCH_RESTORE();
1173       }
1174       {
1175         /* Setup positions.
1176          * Note that CoreText does not return advances for glyphs.  As such,
1177          * for all but last glyph, we use the delta position to next glyph as
1178          * advance (in the advance direction only), and for last glyph we set
1179          * whatever is needed to make the whole run&#39;s advance add up. */
1180         SCRATCH_SAVE();
1181         const CGPoint* positions = USE_PTR ? CTRunGetPositionsPtr (run) : nullptr;
1182         if (!positions) {
1183           ALLOCATE_ARRAY (CGPoint, position_buf, num_glyphs, goto resize_and_retry);
1184           CTRunGetPositions (run, range_all, position_buf);
1185           positions = position_buf;
1186         }
1187         hb_glyph_info_t *info = run_info;
1188         if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))
1189         {
1190           hb_position_t x_offset = (positions[0].x - advances_so_far) * x_mult;
1191           for (unsigned int j = 0; j &lt; num_glyphs; j++)
1192           {
1193             double advance;
1194             if (likely (j + 1 &lt; num_glyphs))
1195               advance = positions[j + 1].x - positions[j].x;
1196             else /* last glyph */
1197               advance = run_advance - (positions[j].x - positions[0].x);
1198             info-&gt;mask = advance * x_mult;
1199             info-&gt;var1.i32 = x_offset;
1200             info-&gt;var2.i32 = positions[j].y * y_mult;
1201             info++;
1202           }
1203         }
1204         else
1205         {
1206           hb_position_t y_offset = (positions[0].y - advances_so_far) * y_mult;
1207           for (unsigned int j = 0; j &lt; num_glyphs; j++)
1208           {
1209             double advance;
1210             if (likely (j + 1 &lt; num_glyphs))
1211               advance = positions[j + 1].y - positions[j].y;
1212             else /* last glyph */
1213               advance = run_advance - (positions[j].y - positions[0].y);
1214             info-&gt;mask = advance * y_mult;
1215             info-&gt;var1.i32 = positions[j].x * x_mult;
1216             info-&gt;var2.i32 = y_offset;
1217             info++;
1218           }
1219         }
1220         SCRATCH_RESTORE();
1221         advances_so_far += run_advance;
1222       }
1223 #undef SCRATCH_RESTORE
1224 #undef SCRATCH_SAVE
1225 #undef USE_PTR
1226 #undef ALLOCATE_ARRAY
1227 
1228       buffer-&gt;len += num_glyphs;
1229     }
1230 
1231     /* Mac OS 10.6 doesn&#39;t have kCTTypesetterOptionForcedEmbeddingLevel,
1232      * or if it does, it doesn&#39;t respect it.  So we get runs with wrong
1233      * directions.  As such, disable the assert...  It wouldn&#39;t crash, but
1234      * cursoring will be off...
1235      *
1236      * https://crbug.com/419769
1237      */
<a name="34" id="anc34"></a><span class="line-modified">1238     if (0)</span>
1239     {
1240       /* Make sure all runs had the expected direction. */
1241       bool backward = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);
1242       assert (bool (status_and &amp; kCTRunStatusRightToLeft) == backward);
1243       assert (bool (status_or  &amp; kCTRunStatusRightToLeft) == backward);
1244     }
1245 
1246     buffer-&gt;clear_positions ();
1247 
1248     unsigned int count = buffer-&gt;len;
1249     hb_glyph_info_t *info = buffer-&gt;info;
1250     hb_glyph_position_t *pos = buffer-&gt;pos;
1251     if (HB_DIRECTION_IS_HORIZONTAL (buffer-&gt;props.direction))
1252       for (unsigned int i = 0; i &lt; count; i++)
1253       {
1254         pos-&gt;x_advance = info-&gt;mask;
1255         pos-&gt;x_offset = info-&gt;var1.i32;
1256         pos-&gt;y_offset = info-&gt;var2.i32;
1257 
1258         info++, pos++;
1259       }
1260     else
1261       for (unsigned int i = 0; i &lt; count; i++)
1262       {
1263         pos-&gt;y_advance = info-&gt;mask;
1264         pos-&gt;x_offset = info-&gt;var1.i32;
1265         pos-&gt;y_offset = info-&gt;var2.i32;
1266 
1267         info++, pos++;
1268       }
1269 
1270     /* Fix up clusters so that we never return out-of-order indices;
1271      * if core text has reordered glyphs, we&#39;ll merge them to the
1272      * beginning of the reordered cluster.  CoreText is nice enough
1273      * to tell us whenever it has produced nonmonotonic results...
1274      * Note that we assume the input clusters were nonmonotonic to
1275      * begin with.
1276      *
1277      * This does *not* mean we&#39;ll form the same clusters as Uniscribe
1278      * or the native OT backend, only that the cluster indices will be
1279      * monotonic in the output buffer. */
1280     if (count &gt; 1 &amp;&amp; (status_or &amp; kCTRunStatusNonMonotonic))
1281     {
1282       hb_glyph_info_t *info = buffer-&gt;info;
1283       if (HB_DIRECTION_IS_FORWARD (buffer-&gt;props.direction))
1284       {
1285         unsigned int cluster = info[count - 1].cluster;
1286         for (unsigned int i = count - 1; i &gt; 0; i--)
1287         {
1288           cluster = MIN (cluster, info[i - 1].cluster);
1289           info[i - 1].cluster = cluster;
1290         }
1291       }
1292       else
1293       {
1294         unsigned int cluster = info[0].cluster;
1295         for (unsigned int i = 1; i &lt; count; i++)
1296         {
1297           cluster = MIN (cluster, info[i].cluster);
1298           info[i].cluster = cluster;
1299         }
1300       }
1301     }
1302   }
1303 
1304   buffer-&gt;unsafe_to_break_all ();
1305 
1306 #undef FAIL
1307 
1308 fail:
1309   if (string_ref)
1310     CFRelease (string_ref);
1311   if (line)
1312     CFRelease (line);
1313 
<a name="35" id="anc35"></a><span class="line-modified">1314   for (unsigned int i = 0; i &lt; range_records.len; i++)</span>
1315     if (range_records[i].font)
1316       CFRelease (range_records[i].font);
1317 
1318   return ret;
1319 }
1320 
1321 
1322 /*
1323  * AAT shaper
1324  */
1325 
<a name="36" id="anc36"></a><span class="line-removed">1326 HB_SHAPER_DATA_ENSURE_DEFINE(coretext_aat, face)</span>
<span class="line-removed">1327 HB_SHAPER_DATA_ENSURE_DEFINE(coretext_aat, font)</span>
<span class="line-removed">1328 </span>
1329 /*
1330  * shaper face data
1331  */
1332 
<a name="37" id="anc37"></a><span class="line-modified">1333 struct hb_coretext_aat_shaper_face_data_t {};</span>
1334 
<a name="38" id="anc38"></a><span class="line-modified">1335 hb_coretext_aat_shaper_face_data_t *</span>
1336 _hb_coretext_aat_shaper_face_data_create (hb_face_t *face)
1337 {
<a name="39" id="anc39"></a><span class="line-modified">1338   static const hb_tag_t tags[] = {HB_CORETEXT_TAG_MORX, HB_CORETEXT_TAG_MORT, HB_CORETEXT_TAG_KERX};</span>
<span class="line-modified">1339 </span>
<span class="line-removed">1340   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (tags); i++)</span>
<span class="line-removed">1341   {</span>
<span class="line-removed">1342     hb_blob_t *blob = face-&gt;reference_table (tags[i]);</span>
<span class="line-removed">1343     if (hb_blob_get_length (blob))</span>
<span class="line-removed">1344     {</span>
<span class="line-removed">1345       hb_blob_destroy (blob);</span>
<span class="line-removed">1346       return hb_coretext_shaper_face_data_ensure (face) ? (hb_coretext_aat_shaper_face_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>
<span class="line-removed">1347     }</span>
<span class="line-removed">1348     hb_blob_destroy (blob);</span>
<span class="line-removed">1349   }</span>
<span class="line-removed">1350 </span>
<span class="line-removed">1351   return nullptr;</span>
1352 }
1353 
1354 void
<a name="40" id="anc40"></a><span class="line-modified">1355 _hb_coretext_aat_shaper_face_data_destroy (hb_coretext_aat_shaper_face_data_t *data HB_UNUSED)</span>
1356 {
1357 }
1358 
1359 
1360 /*
1361  * shaper font data
1362  */
1363 
<a name="41" id="anc41"></a><span class="line-modified">1364 struct hb_coretext_aat_shaper_font_data_t {};</span>
1365 
<a name="42" id="anc42"></a><span class="line-modified">1366 hb_coretext_aat_shaper_font_data_t *</span>
1367 _hb_coretext_aat_shaper_font_data_create (hb_font_t *font)
1368 {
<a name="43" id="anc43"></a><span class="line-modified">1369   return hb_coretext_shaper_font_data_ensure (font) ? (hb_coretext_aat_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED : nullptr;</span>
<span class="line-removed">1370 }</span>
<span class="line-removed">1371 </span>
<span class="line-removed">1372 void</span>
<span class="line-removed">1373 _hb_coretext_aat_shaper_font_data_destroy (hb_coretext_aat_shaper_font_data_t *data HB_UNUSED)</span>
<span class="line-removed">1374 {</span>
<span class="line-removed">1375 }</span>
<span class="line-removed">1376 </span>
<span class="line-removed">1377 </span>
<span class="line-removed">1378 /*</span>
<span class="line-removed">1379  * shaper shape_plan data</span>
<span class="line-removed">1380  */</span>
<span class="line-removed">1381 </span>
<span class="line-removed">1382 struct hb_coretext_aat_shaper_shape_plan_data_t {};</span>
<span class="line-removed">1383 </span>
<span class="line-removed">1384 hb_coretext_aat_shaper_shape_plan_data_t *</span>
<span class="line-removed">1385 _hb_coretext_aat_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan HB_UNUSED,</span>
<span class="line-removed">1386                                              const hb_feature_t *user_features HB_UNUSED,</span>
<span class="line-removed">1387                                              unsigned int        num_user_features HB_UNUSED,</span>
<span class="line-removed">1388                                              const int          *coords HB_UNUSED,</span>
<span class="line-removed">1389                                              unsigned int        num_coords HB_UNUSED)</span>
<span class="line-removed">1390 {</span>
<span class="line-removed">1391   return (hb_coretext_aat_shaper_shape_plan_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
1392 }
1393 
1394 void
<a name="44" id="anc44"></a><span class="line-modified">1395 _hb_coretext_aat_shaper_shape_plan_data_destroy (hb_coretext_aat_shaper_shape_plan_data_t *data HB_UNUSED)</span>
1396 {
1397 }
1398 
1399 
1400 /*
1401  * shaper
1402  */
1403 
1404 hb_bool_t
1405 _hb_coretext_aat_shape (hb_shape_plan_t    *shape_plan,
1406                         hb_font_t          *font,
1407                         hb_buffer_t        *buffer,
1408                         const hb_feature_t *features,
1409                         unsigned int        num_features)
1410 {
1411   return _hb_coretext_shape (shape_plan, font, buffer, features, num_features);
1412 }
<a name="45" id="anc45"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="45" type="hidden" />
</body>
</html>
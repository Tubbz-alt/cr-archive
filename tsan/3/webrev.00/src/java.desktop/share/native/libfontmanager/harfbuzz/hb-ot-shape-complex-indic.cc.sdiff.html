<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-indic-table.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-khmer-machine.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
<span class="line-modified">  27 #include &quot;hb-ot-shape-complex-indic-private.hh&quot;</span>
<span class="line-modified">  28 #include &quot;hb-ot-layout-private.hh&quot;</span>

  29 
  30 
  31 /*
  32  * Indic shaper.
  33  */
  34 
  35 
  36 /*
  37  * Indic configurations.  Note that we do not want to keep every single script-specific
  38  * behavior in these tables necessarily.  This should mainly be used for per-script
  39  * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and
  40  * only one script has an exception, that one script can be if&#39;ed directly in the code,
  41  * instead of adding a new flag in these structs.
  42  */
  43 
  44 enum base_position_t {
  45   BASE_POS_LAST_SINHALA,
  46   BASE_POS_LAST
  47 };
  48 enum reph_position_t {
</pre>
<hr />
<pre>
  78   {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  79   {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  80   {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  81   {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  82   {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  83   {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  84   {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  85   {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},
  86   {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},
  87   {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},
  88   {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,
  89                                                      REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},
  90 };
  91 
  92 
  93 
  94 /*
  95  * Indic shaper.
  96  */
  97 
<span class="line-modified">  98 struct feature_list_t {</span>
<span class="line-removed">  99   hb_tag_t tag;</span>
<span class="line-removed"> 100   hb_ot_map_feature_flags_t flags;</span>
<span class="line-removed"> 101 };</span>
<span class="line-removed"> 102 </span>
<span class="line-removed"> 103 static const feature_list_t</span>
 104 indic_features[] =
 105 {
 106   /*
 107    * Basic features.
 108    * These features are applied in order, one at a time, after initial_reordering.
 109    */
<span class="line-modified"> 110   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-modified"> 111   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="line-modified"> 112   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 113   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL},</span>
<span class="line-modified"> 114   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 115   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 116   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 117   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 118   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), F_NONE},</span>
<span class="line-modified"> 119   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL},</span>
<span class="line-modified"> 120   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL},</span>
 121   /*
 122    * Other features.
<span class="line-modified"> 123    * These features are applied all at once, after final_reordering.</span>

 124    * Default Bengali font in Windows for example has intermixed
 125    * lookups for init,pres,abvs,blws features.
 126    */
<span class="line-modified"> 127   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;), F_NONE},</span>
<span class="line-modified"> 128   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 129   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 130   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 131   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-modified"> 132   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL},</span>
<span class="line-modified"> 133   /* Positioning features, though we don&#39;t care about the types. */</span>



 134   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 135   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 136   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 137 };
 138 
 139 /*
 140  * Must be in the same order as the indic_features array.
 141  */
 142 enum {
 143   _NUKT,
 144   _AKHN,
 145   RPHF,
 146   _RKRF,
 147   PREF,
 148   BLWF,
 149   ABVF,
 150   HALF,
 151   PSTF,
 152   _VATU,
 153   _CJCT,
 154 
 155   INIT,
 156   _PRES,
 157   _ABVS,
 158   _BLWS,
 159   _PSTS,
 160   _HALN,

 161   _DIST,
 162   _ABVM,
 163   _BLWM,
 164 
 165   INDIC_NUM_FEATURES,
<span class="line-modified"> 166   INDIC_BASIC_FEATURES = INIT /* Don&#39;t forget to update this! */</span>
 167 };
 168 
 169 static void
 170 setup_syllables (const hb_ot_shape_plan_t *plan,
 171                  hb_font_t *font,
 172                  hb_buffer_t *buffer);
 173 static void
 174 initial_reordering (const hb_ot_shape_plan_t *plan,
 175                     hb_font_t *font,
 176                     hb_buffer_t *buffer);
 177 static void
 178 final_reordering (const hb_ot_shape_plan_t *plan,
 179                   hb_font_t *font,
 180                   hb_buffer_t *buffer);
 181 static void
 182 clear_syllables (const hb_ot_shape_plan_t *plan,
 183                  hb_font_t *font,
 184                  hb_buffer_t *buffer);
 185 
 186 static void
 187 collect_features_indic (hb_ot_shape_planner_t *plan)
 188 {
 189   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 190 
 191   /* Do this before any lookups have been applied. */
 192   map-&gt;add_gsub_pause (setup_syllables);
 193 
<span class="line-modified"> 194   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
 195   /* The Indic specs do not require ccmp, but we apply it here since if
 196    * there is a use of it, it&#39;s typically at the beginning. */
<span class="line-modified"> 197   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
 198 
 199 
 200   unsigned int i = 0;
 201   map-&gt;add_gsub_pause (initial_reordering);

 202   for (; i &lt; INDIC_BASIC_FEATURES; i++) {
<span class="line-modified"> 203     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
 204     map-&gt;add_gsub_pause (nullptr);
 205   }

 206   map-&gt;add_gsub_pause (final_reordering);
<span class="line-removed"> 207   for (; i &lt; INDIC_NUM_FEATURES; i++) {</span>
<span class="line-removed"> 208     map-&gt;add_feature (indic_features[i].tag, 1, indic_features[i].flags | F_MANUAL_ZWJ | F_MANUAL_ZWNJ);</span>
<span class="line-removed"> 209   }</span>
 210 
<span class="line-modified"> 211   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-modified"> 212   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>



 213 
 214   map-&gt;add_gsub_pause (clear_syllables);
 215 }
 216 
 217 static void
 218 override_features_indic (hb_ot_shape_planner_t *plan)
 219 {
<span class="line-modified"> 220   plan-&gt;map.add_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), 0, F_GLOBAL);</span>
 221 }
 222 
 223 
 224 struct would_substitute_feature_t
 225 {
<span class="line-modified"> 226   inline void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
 227   {
 228     zero_context = zero_context_;
 229     map-&gt;get_stage_lookups (0/*GSUB*/,
 230                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
 231                             &amp;lookups, &amp;count);
 232   }
 233 
<span class="line-modified"> 234   inline bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified"> 235                                 unsigned int          glyphs_count,</span>
<span class="line-modified"> 236                                 hb_face_t            *face) const</span>
 237   {
 238     for (unsigned int i = 0; i &lt; count; i++)
 239       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
 240         return true;
 241     return false;
 242   }
 243 
 244   private:
 245   const hb_ot_map_t::lookup_map_t *lookups;
 246   unsigned int count;
 247   bool zero_context;
 248 };
 249 
 250 struct indic_shape_plan_t
 251 {
<span class="line-modified"> 252   ASSERT_POD ();</span>
<span class="line-removed"> 253 </span>
<span class="line-removed"> 254   inline bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>
 255   {
<span class="line-modified"> 256     hb_codepoint_t glyph = virama_glyph;</span>
<span class="line-modified"> 257     if (unlikely (virama_glyph == (hb_codepoint_t) -1))</span>
 258     {
 259       if (!config-&gt;virama || !font-&gt;get_nominal_glyph (config-&gt;virama, &amp;glyph))
 260         glyph = 0;
 261       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
 262        * Maybe one day... */
 263 
 264       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
<span class="line-modified"> 265        * during shape planning...  Instead, overwrite it here.  It&#39;s safe.  Don&#39;t worry! */</span>
<span class="line-modified"> 266       virama_glyph = glyph;</span>
 267     }
 268 
 269     *pglyph = glyph;
 270     return glyph != 0;
 271   }
 272 
 273   const indic_config_t *config;
 274 
 275   bool is_old_spec;
<span class="line-modified"> 276   mutable hb_codepoint_t virama_glyph;</span>

 277 
 278   would_substitute_feature_t rphf;
 279   would_substitute_feature_t pref;
 280   would_substitute_feature_t blwf;
 281   would_substitute_feature_t pstf;
 282 
 283   hb_mask_t mask_array[INDIC_NUM_FEATURES];
 284 };
 285 
 286 static void *
 287 data_create_indic (const hb_ot_shape_plan_t *plan)
 288 {
 289   indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));
 290   if (unlikely (!indic_plan))
 291     return nullptr;
 292 
 293   indic_plan-&gt;config = &amp;indic_configs[0];
 294   for (unsigned int i = 1; i &lt; ARRAY_LENGTH (indic_configs); i++)
 295     if (plan-&gt;props.script == indic_configs[i].script) {
 296       indic_plan-&gt;config = &amp;indic_configs[i];
 297       break;
 298     }
 299 
 300   indic_plan-&gt;is_old_spec = indic_plan-&gt;config-&gt;has_old_spec &amp;&amp; ((plan-&gt;map.chosen_script[0] &amp; 0x000000FFu) != &#39;2&#39;);
<span class="line-modified"> 301   indic_plan-&gt;virama_glyph = (hb_codepoint_t) -1;</span>

 302 
 303   /* Use zero-context would_substitute() matching for new-spec of the main
 304    * Indic scripts, and scripts with one spec only, but not for old-specs.
 305    * The new-spec for all dual-spec scripts says zero-context matching happens.
 306    *
 307    * However, testing with Malayalam shows that old and new spec both allow
 308    * context.  Testing with Bengali new-spec however shows that it doesn&#39;t.
 309    * So, the heuristic here is the way it is.  It should *only* be changed,
 310    * as we discover more cases of what Windows does.  DON&#39;T TOUCH OTHERWISE.
 311    */
 312   bool zero_context = !indic_plan-&gt;is_old_spec &amp;&amp; plan-&gt;props.script != HB_SCRIPT_MALAYALAM;
 313   indic_plan-&gt;rphf.init (&amp;plan-&gt;map, HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), zero_context);
 314   indic_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), zero_context);
 315   indic_plan-&gt;blwf.init (&amp;plan-&gt;map, HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), zero_context);
 316   indic_plan-&gt;pstf.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), zero_context);
 317 
 318   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (indic_plan-&gt;mask_array); i++)
 319     indic_plan-&gt;mask_array[i] = (indic_features[i].flags &amp; F_GLOBAL) ?
 320                                  0 : plan-&gt;map.get_1_mask (indic_features[i].tag);
 321 
</pre>
<hr />
<pre>
 402 {
 403   int a = pa-&gt;indic_position();
 404   int b = pb-&gt;indic_position();
 405 
 406   return a &lt; b ? -1 : a == b ? 0 : +1;
 407 }
 408 
 409 
 410 
 411 static void
 412 update_consonant_positions (const hb_ot_shape_plan_t *plan,
 413                             hb_font_t         *font,
 414                             hb_buffer_t       *buffer)
 415 {
 416   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 417 
 418   if (indic_plan-&gt;config-&gt;base_pos != BASE_POS_LAST)
 419     return;
 420 
 421   hb_codepoint_t virama;
<span class="line-modified"> 422   if (indic_plan-&gt;get_virama_glyph (font, &amp;virama))</span>
 423   {
 424     hb_face_t *face = font-&gt;face;
 425     unsigned int count = buffer-&gt;len;
 426     hb_glyph_info_t *info = buffer-&gt;info;
 427     for (unsigned int i = 0; i &lt; count; i++)
 428       if (info[i].indic_position() == POS_BASE_C)
 429       {
 430         hb_codepoint_t consonant = info[i].codepoint;
 431         info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);
 432       }
 433   }
 434 }
 435 
 436 
 437 /* Rules from:
 438  * https://docs.microsqoft.com/en-us/typography/script-development/devanagari */
 439 
 440 static void
 441 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,
 442                                        hb_face_t *face,
</pre>
<hr />
<pre>
 650   /* Mark final consonants.  A final consonant is one appearing after a matra.
 651    * Happens in Sinhala. */
 652   for (unsigned int i = base + 1; i &lt; end; i++)
 653     if (info[i].indic_category() == OT_M) {
 654       for (unsigned int j = i + 1; j &lt; end; j++)
 655         if (is_consonant (info[j])) {
 656          info[j].indic_position() = POS_FINAL_C;
 657          break;
 658        }
 659       break;
 660     }
 661 
 662   /* Handle beginning Ra */
 663   if (has_reph)
 664     info[start].indic_position() = POS_RA_TO_BECOME_REPH;
 665 
 666   /* For old-style Indic script tags, move the first post-base Halant after
 667    * last consonant.
 668    *
 669    * Reports suggest that in some scripts Uniscribe does this only if there
<span class="line-modified"> 670    * is *not* a Halant after last consonant already (eg. Kannada), while it</span>
<span class="line-modified"> 671    * does it unconditionally in other scripts (eg. Malayalam, Bengali).  We</span>
<span class="line-modified"> 672    * don&#39;t currently know about other scripts, so we whitelist Malayalam and</span>
<span class="line-modified"> 673    * Bengali for now.</span>
 674    *
 675    * Kannada test case:
 676    * U+0C9A,U+0CCD,U+0C9A,U+0CCD
 677    * With some versions of Lohit Kannada.
 678    * https://bugs.freedesktop.org/show_bug.cgi?id=59118
 679    *
 680    * Malayalam test case:
 681    * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D
 682    * With lohit-ttf-20121122/Lohit-Malayalam.ttf
 683    *
<span class="line-modified"> 684    * Bengali test case</span>
 685    * U+0998,U+09CD,U+09AF,U+09CD
 686    * With Windows XP vrinda.ttf
 687    * https://github.com/harfbuzz/harfbuzz/issues/1073





 688    */
 689   if (indic_plan-&gt;is_old_spec)
 690   {
<span class="line-modified"> 691     bool disallow_double_halants = buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp;</span>
<span class="line-removed"> 692                                    buffer-&gt;props.script != HB_SCRIPT_BENGALI;</span>
 693     for (unsigned int i = base + 1; i &lt; end; i++)
 694       if (info[i].indic_category() == OT_H)
 695       {
 696         unsigned int j;
 697         for (j = end - 1; j &gt; i; j--)
 698           if (is_consonant (info[j]) ||
 699               (disallow_double_halants &amp;&amp; info[j].indic_category() == OT_H))
 700             break;
 701         if (info[j].indic_category() != OT_H &amp;&amp; j &gt; i) {
 702           /* Move Halant to after last consonant. */
 703           hb_glyph_info_t t = info[i];
 704           memmove (&amp;info[i], &amp;info[i + 1], (j - i) * sizeof (info[0]));
 705           info[j] = t;
 706         }
 707         break;
 708       }
 709   }
 710 
 711   /* Attach misc marks to previous char to move with them. */
 712   {
 713     indic_position_t last_pos = POS_START;
 714     for (unsigned int i = start; i &lt; end; i++)
 715     {
<span class="line-modified"> 716       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | MEDIAL_FLAGS | FLAG (OT_H))))</span>
 717       {
 718         info[i].indic_position() = last_pos;
 719         if (unlikely (info[i].indic_category() == OT_H &amp;&amp;
 720                       info[i].indic_position() == POS_PRE_M))
 721         {
 722           /*
 723            * Uniscribe doesn&#39;t move the Halant with Left Matra.
 724            * TEST: U+092B,U+093F,U+094DE
 725            * We follow.  This is important for the Sinhala
 726            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA
 727            * where U+0DD9 is a left matra and U+0DCA is the virama.
 728            * We don&#39;t want to move the virama with the left matra.
 729            * TEST: U+0D9A,U+0DDA
 730            */
 731           for (unsigned int j = i; j &gt; start; j--)
 732             if (info[j - 1].indic_position() != POS_PRE_M) {
 733               info[i].indic_position() = info[j - 1].indic_position();
 734               break;
 735             }
 736         }
</pre>
<hr />
<pre>
 762       info[i].syllable() = i - start;
 763 
 764     /* Sit tight, rock &#39;n roll! */
 765     hb_stable_sort (info + start, end - start, compare_indic_order);
 766     /* Find base again */
 767     base = end;
 768     for (unsigned int i = start; i &lt; end; i++)
 769       if (info[i].indic_position() == POS_BASE_C)
 770       {
 771         base = i;
 772         break;
 773       }
 774     /* Things are out-of-control for post base positions, they may shuffle
 775      * around like crazy.  In old-spec mode, we move halants around, so in
 776      * that case merge all clusters after base.  Otherwise, check the sort
 777      * order and merge as needed.
 778      * For pre-base stuff, we handle cluster issues in final reordering.
 779      *
 780      * We could use buffer-&gt;sort() for this, if there was no special
 781      * reordering of pre-base stuff happening later...


 782      */
<span class="line-modified"> 783     if (indic_plan-&gt;is_old_spec || end - base &gt; 127)</span>
 784       buffer-&gt;merge_clusters (base, end);
 785     else
 786     {
 787       /* Note!  syllable() is a one-byte field. */
 788       for (unsigned int i = base; i &lt; end; i++)
 789         if (info[i].syllable() != 255)
 790         {
 791           unsigned int max = i;
 792           unsigned int j = start + info[i].syllable();
 793           while (j != i)
 794           {
 795             max = MAX (max, j);
 796             unsigned int next = start + info[j].syllable();
 797             info[j].syllable() = 255; /* So we don&#39;t process j later again. */
 798             j = next;
 799           }
 800           if (i != max)
 801             buffer-&gt;merge_clusters (i, max + 1);
 802         }
 803     }
</pre>
<hr />
<pre>
 892         j--;
 893 
 894         /* ZWJ/ZWNJ should disable CJCT.  They do that by simply
 895          * being there, since we don&#39;t skip them for the CJCT
 896          * feature (ie. F_MANUAL_ZWJ) */
 897 
 898         /* A ZWNJ disables HALF. */
 899         if (non_joiner)
 900           info[j].mask &amp;= ~indic_plan-&gt;mask_array[HALF];
 901 
 902       } while (j &gt; start &amp;&amp; !is_consonant (info[j]));
 903     }
 904 }
 905 
 906 static void
 907 initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
 908                                        hb_face_t *face,
 909                                        hb_buffer_t *buffer,
 910                                        unsigned int start, unsigned int end)
 911 {


 912   /* We treat placeholder/dotted-circle as if they are consonants, so we
 913    * should just chain.  Only if not in compatibility mode that is... */
 914 
<span class="line-modified"> 915   if (hb_options ().uniscribe_bug_compatible)</span>
 916   {
 917     /* For dotted-circle, this is what Uniscribe does:
 918      * If dotted-circle is the last glyph, it just does nothing.
 919      * Ie. It doesn&#39;t form Reph. */
 920     if (buffer-&gt;info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
 921       return;
 922   }
 923 
 924   initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 925 }
 926 
 927 static void
 928 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
 929                              hb_face_t *face,
 930                              hb_buffer_t *buffer,
 931                              unsigned int start, unsigned int end)
 932 {
 933   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
 934   switch (syllable_type)
 935   {
</pre>
<hr />
<pre>
 937     case consonant_syllable:
 938      initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 939      break;
 940 
 941     case broken_cluster: /* We already inserted dotted-circles, so just call the standalone_cluster. */
 942     case standalone_cluster:
 943      initial_reordering_standalone_cluster (plan, face, buffer, start, end);
 944      break;
 945 
 946     case symbol_cluster:
 947     case non_indic_cluster:
 948       break;
 949   }
 950 }
 951 
 952 static inline void
 953 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
 954                        hb_font_t *font,
 955                        hb_buffer_t *buffer)
 956 {
<span class="line-modified"> 957   /* Note: This loop is extra overhead, but should not be measurable. */</span>

 958   bool has_broken_syllables = false;
 959   unsigned int count = buffer-&gt;len;
 960   hb_glyph_info_t *info = buffer-&gt;info;
 961   for (unsigned int i = 0; i &lt; count; i++)
 962     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
 963     {
 964       has_broken_syllables = true;
 965       break;
 966     }
 967   if (likely (!has_broken_syllables))
 968     return;
 969 
 970 
 971   hb_codepoint_t dottedcircle_glyph;
 972   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
 973     return;
 974 
 975   hb_glyph_info_t dottedcircle = {0};
 976   dottedcircle.codepoint = 0x25CCu;
 977   set_indic_properties (dottedcircle);
</pre>
<hr />
<pre>
 989     {
 990       last_syllable = syllable;
 991 
 992       hb_glyph_info_t ginfo = dottedcircle;
 993       ginfo.cluster = buffer-&gt;cur().cluster;
 994       ginfo.mask = buffer-&gt;cur().mask;
 995       ginfo.syllable() = buffer-&gt;cur().syllable();
 996       /* TODO Set glyph_props? */
 997 
 998       /* Insert dottedcircle after possible Repha. */
 999       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
1000              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
1001              buffer-&gt;cur().indic_category() == OT_Repha)
1002         buffer-&gt;next_glyph ();
1003 
1004       buffer-&gt;output_info (ginfo);
1005     }
1006     else
1007       buffer-&gt;next_glyph ();
1008   }
<span class="line-removed">1009 </span>
1010   buffer-&gt;swap_buffers ();
1011 }
1012 
1013 static void
1014 initial_reordering (const hb_ot_shape_plan_t *plan,
1015                     hb_font_t *font,
1016                     hb_buffer_t *buffer)
1017 {
1018   update_consonant_positions (plan, font, buffer);
1019   insert_dotted_circles (plan, font, buffer);
1020 
1021   foreach_syllable (buffer, start, end)
1022     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
1023 }
1024 
1025 static void
1026 final_reordering_syllable (const hb_ot_shape_plan_t *plan,
1027                            hb_buffer_t *buffer,
1028                            unsigned int start, unsigned int end)
1029 {
1030   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
1031   hb_glyph_info_t *info = buffer-&gt;info;
1032 
1033 
1034   /* This function relies heavily on halant glyphs.  Lots of ligation
1035    * and possibly multiple substitutions happened prior to this
1036    * phase, and that might have messed up our properties.  Recover
1037    * from a particular case of that where we&#39;re fairly sure that a
1038    * class of OT_H is desired but has been lost. */
<span class="line-modified">1039   if (indic_plan-&gt;virama_glyph)</span>



1040   {
<span class="line-removed">1041     unsigned int virama_glyph = indic_plan-&gt;virama_glyph;</span>
1042     for (unsigned int i = start; i &lt; end; i++)
1043       if (info[i].codepoint == virama_glyph &amp;&amp;
1044           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;
1045           _hb_glyph_info_multiplied (&amp;info[i]))
1046       {
1047         /* This will make sure that this glyph passes is_halant() test. */
1048         info[i].indic_category() = OT_H;
1049         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);
1050       }
1051   }
1052 
1053 
1054   /* 4. Final reordering:
1055    *
1056    * After the localized forms and basic shaping forms GSUB features have been
1057    * applied (see below), the shaping engine performs some final glyph
1058    * reordering before applying all the remaining font features to the entire
1059    * syllable.
1060    */
1061 
</pre>
<hr />
<pre>
1110         base--;
1111       break;
1112     }
1113   if (base == end &amp;&amp; start &lt; base &amp;&amp;
1114       is_one_of (info[base - 1], FLAG (OT_ZWJ)))
1115     base--;
1116   if (base &lt; end)
1117     while (start &lt; base &amp;&amp;
1118            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))
1119       base--;
1120 
1121 
1122   /*   o Reorder matras:
1123    *
1124    *     If a pre-base matra character had been reordered before applying basic
1125    *     features, the glyph can be moved closer to the main consonant based on
1126    *     whether half-forms had been formed. Actual position for the matra is
1127    *     defined as “after last standalone halant glyph, after initial matra
1128    *     position and before the main consonant”. If ZWJ or ZWNJ follow this
1129    *     halant, position is moved after it.


















1130    */
1131 
1132   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */
1133   {
1134     /* If we lost track of base, alas, position before last thingy. */
1135     unsigned int new_pos = base == end ? base - 2 : base - 1;
1136 
1137     /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1138      * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1139      * We want to position matra after them.
1140      */
1141     if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1142     {

1143       while (new_pos &gt; start &amp;&amp;
1144              !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))
1145         new_pos--;
1146 
1147       /* If we found no Halant we are done.
1148        * Otherwise only proceed if the Halant does
1149        * not belong to the Matra itself! */
1150       if (is_halant (info[new_pos]) &amp;&amp;
1151           info[new_pos].indic_position() != POS_PRE_M)
1152       {

1153         /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1154         if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))
1155           new_pos++;

















1156       }
1157       else
1158         new_pos = start; /* No move. */
1159     }
1160 
1161     if (start &lt; new_pos &amp;&amp; info[new_pos].indic_position () != POS_PRE_M)
1162     {
1163       /* Now go see if there&#39;s actually any matras... */
1164       for (unsigned int i = new_pos; i &gt; start; i--)
1165         if (info[i - 1].indic_position () == POS_PRE_M)
1166         {
1167           unsigned int old_pos = i - 1;
1168           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */
1169             base--;
1170 
1171           hb_glyph_info_t tmp = info[old_pos];
1172           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));
1173           info[new_pos] = tmp;
1174 
1175           /* Note: this merge_clusters() is intentionally *after* the reordering.
</pre>
<hr />
<pre>
1296         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1297           new_reph_pos++;
1298         goto reph_move;
1299       }
1300     }
1301 
1302     /*       6. Otherwise, reorder reph to the end of the syllable.
1303      */
1304     {
1305       new_reph_pos = end - 1;
1306       while (new_reph_pos &gt; start &amp;&amp; info[new_reph_pos].indic_position() == POS_SMVD)
1307         new_reph_pos--;
1308 
1309       /*
1310        * If the Reph is to be ending up after a Matra,Halant sequence,
1311        * position it before that Halant so it can interact with the Matra.
1312        * However, if it&#39;s a plain Consonant,Halant we shouldn&#39;t do that.
1313        * Uniscribe doesn&#39;t do this.
1314        * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
1315        */
<span class="line-modified">1316       if (!hb_options ().uniscribe_bug_compatible &amp;&amp;</span>
1317           unlikely (is_halant (info[new_reph_pos]))) {
1318         for (unsigned int i = base + 1; i &lt; new_reph_pos; i++)
1319           if (info[i].indic_category() == OT_M) {
1320             /* Ok, got it. */
1321             new_reph_pos--;
1322           }
1323       }
1324       goto reph_move;
1325     }
1326 
1327     reph_move:
1328     {
1329       /* Move */
1330       buffer-&gt;merge_clusters (start, new_reph_pos + 1);
1331       hb_glyph_info_t reph = info[start];
1332       memmove (&amp;info[start], &amp;info[start + 1], (new_reph_pos - start) * sizeof (info[0]));
1333       info[new_reph_pos] = reph;
1334 
1335       if (start &lt; base &amp;&amp; base &lt;= new_reph_pos)
1336         base--;
</pre>
<hr />
<pre>
1402         break;
1403       }
1404   }
1405 
1406 
1407   /* Apply &#39;init&#39; to the Left Matra if it&#39;s a word start. */
1408   if (info[start].indic_position () == POS_PRE_M)
1409   {
1410     if (!start ||
1411         !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&amp;info[start - 1])) &amp;
1412          FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
1413       info[start].mask |= indic_plan-&gt;mask_array[INIT];
1414     else
1415       buffer-&gt;unsafe_to_break (start - 1, start + 1);
1416   }
1417 
1418 
1419   /*
1420    * Finish off the clusters and go home!
1421    */
<span class="line-modified">1422   if (hb_options ().uniscribe_bug_compatible)</span>
1423   {
1424     switch ((hb_tag_t) plan-&gt;props.script)
1425     {
1426       case HB_SCRIPT_TAMIL:
1427       case HB_SCRIPT_SINHALA:
1428         break;
1429 
1430       default:
1431         /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.
1432          * This means, half forms are submerged into the main consonant&#39;s cluster.
1433          * This is unnecessary, and makes cursor positioning harder, but that&#39;s what
1434          * Uniscribe does. */
1435         buffer-&gt;merge_clusters (start, end);
1436         break;
1437     }
1438   }
1439 }
1440 
1441 
1442 static void
</pre>
<hr />
<pre>
1450   foreach_syllable (buffer, start, end)
1451     final_reordering_syllable (plan, buffer, start, end);
1452 
1453   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
1454   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
1455 }
1456 
1457 
1458 static void
1459 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
1460                  hb_font_t *font HB_UNUSED,
1461                  hb_buffer_t *buffer)
1462 {
1463   hb_glyph_info_t *info = buffer-&gt;info;
1464   unsigned int count = buffer-&gt;len;
1465   for (unsigned int i = 0; i &lt; count; i++)
1466     info[i].syllable() = 0;
1467 }
1468 
1469 








1470 static bool
1471 decompose_indic (const hb_ot_shape_normalize_context_t *c,
1472                  hb_codepoint_t  ab,
1473                  hb_codepoint_t *a,
1474                  hb_codepoint_t *b)
1475 {
1476   switch (ab)
1477   {
1478     /* Don&#39;t decompose these. */
1479     case 0x0931u  : return false; /* DEVANAGARI LETTER RRA */
1480     // https://github.com/harfbuzz/harfbuzz/issues/779
1481     case 0x09DCu  : return false; /* BENGALI LETTER RRA */
1482     case 0x09DDu  : return false; /* BENGALI LETTER RHA */
1483     case 0x0B94u  : return false; /* TAMIL LETTER AU */
1484 
1485 
1486     /*
1487      * Decompose split matras that don&#39;t have Unicode decompositions.
1488      */
1489 
</pre>
<hr />
<pre>
1549                hb_codepoint_t  b,
1550                hb_codepoint_t *ab)
1551 {
1552   /* Avoid recomposing split matras. */
1553   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
1554     return false;
1555 
1556   /* Composition-exclusion exceptions that we want to recompose. */
1557   if (a == 0x09AFu &amp;&amp; b == 0x09BCu) { *ab = 0x09DFu; return true; }
1558 
1559   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
1560 }
1561 
1562 
1563 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =
1564 {
1565   collect_features_indic,
1566   override_features_indic,
1567   data_create_indic,
1568   data_destroy_indic,
<span class="line-modified">1569   nullptr, /* preprocess_text */</span>
1570   nullptr, /* postprocess_glyphs */
1571   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
1572   decompose_indic,
1573   compose_indic,
1574   setup_masks_indic,
<span class="line-modified">1575   nullptr, /* disable_otl */</span>
1576   nullptr, /* reorder_marks */
1577   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
1578   false, /* fallback_position */
1579 };
</pre>
</td>
<td>
<hr />
<pre>
   7  * license or royalty fees, to use, copy, modify, and distribute this
   8  * software and its documentation for any purpose, provided that the
   9  * above copyright notice and the following two paragraphs appear in
  10  * all copies of this software.
  11  *
  12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  16  * DAMAGE.
  17  *
  18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  23  *
  24  * Google Author(s): Behdad Esfahbod
  25  */
  26 
<span class="line-modified">  27 #include &quot;hb-ot-shape-complex-indic.hh&quot;</span>
<span class="line-modified">  28 #include &quot;hb-ot-shape-complex-vowel-constraints.hh&quot;</span>
<span class="line-added">  29 #include &quot;hb-ot-layout.hh&quot;</span>
  30 
  31 
  32 /*
  33  * Indic shaper.
  34  */
  35 
  36 
  37 /*
  38  * Indic configurations.  Note that we do not want to keep every single script-specific
  39  * behavior in these tables necessarily.  This should mainly be used for per-script
  40  * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and
  41  * only one script has an exception, that one script can be if&#39;ed directly in the code,
  42  * instead of adding a new flag in these structs.
  43  */
  44 
  45 enum base_position_t {
  46   BASE_POS_LAST_SINHALA,
  47   BASE_POS_LAST
  48 };
  49 enum reph_position_t {
</pre>
<hr />
<pre>
  79   {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  80   {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  81   {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  82   {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  83   {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  84   {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  85   {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},
  86   {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},
  87   {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},
  88   {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},
  89   {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,
  90                                                      REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},
  91 };
  92 
  93 
  94 
  95 /*
  96  * Indic shaper.
  97  */
  98 
<span class="line-modified">  99 static const hb_ot_map_feature_t</span>





 100 indic_features[] =
 101 {
 102   /*
 103    * Basic features.
 104    * These features are applied in order, one at a time, after initial_reordering.
 105    */
<span class="line-modified"> 106   {HB_TAG(&#39;n&#39;,&#39;u&#39;,&#39;k&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 107   {HB_TAG(&#39;a&#39;,&#39;k&#39;,&#39;h&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 108   {HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 109   {HB_TAG(&#39;r&#39;,&#39;k&#39;,&#39;r&#39;,&#39;f&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 110   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 111   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 112   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 113   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 114   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 115   {HB_TAG(&#39;v&#39;,&#39;a&#39;,&#39;t&#39;,&#39;u&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 116   {HB_TAG(&#39;c&#39;,&#39;j&#39;,&#39;c&#39;,&#39;t&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
 117   /*
 118    * Other features.
<span class="line-modified"> 119    * These features are applied all at once, after final_reordering</span>
<span class="line-added"> 120    * but before clearing syllables.</span>
 121    * Default Bengali font in Windows for example has intermixed
 122    * lookups for init,pres,abvs,blws features.
 123    */
<span class="line-modified"> 124   {HB_TAG(&#39;i&#39;,&#39;n&#39;,&#39;i&#39;,&#39;t&#39;),        F_MANUAL_JOINERS},</span>
<span class="line-modified"> 125   {HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 126   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 127   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 128   {HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;s&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 129   {HB_TAG(&#39;h&#39;,&#39;a&#39;,&#39;l&#39;,&#39;n&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-modified"> 130   /*</span>
<span class="line-added"> 131    * Positioning features.</span>
<span class="line-added"> 132    * We don&#39;t care about the types.</span>
<span class="line-added"> 133    */</span>
 134   {HB_TAG(&#39;d&#39;,&#39;i&#39;,&#39;s&#39;,&#39;t&#39;), F_GLOBAL},
 135   {HB_TAG(&#39;a&#39;,&#39;b&#39;,&#39;v&#39;,&#39;m&#39;), F_GLOBAL},
 136   {HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;m&#39;), F_GLOBAL},
 137 };
 138 
 139 /*
 140  * Must be in the same order as the indic_features array.
 141  */
 142 enum {
 143   _NUKT,
 144   _AKHN,
 145   RPHF,
 146   _RKRF,
 147   PREF,
 148   BLWF,
 149   ABVF,
 150   HALF,
 151   PSTF,
 152   _VATU,
 153   _CJCT,
 154 
 155   INIT,
 156   _PRES,
 157   _ABVS,
 158   _BLWS,
 159   _PSTS,
 160   _HALN,
<span class="line-added"> 161 </span>
 162   _DIST,
 163   _ABVM,
 164   _BLWM,
 165 
 166   INDIC_NUM_FEATURES,
<span class="line-modified"> 167   INDIC_BASIC_FEATURES = INIT, /* Don&#39;t forget to update this! */</span>
 168 };
 169 
 170 static void
 171 setup_syllables (const hb_ot_shape_plan_t *plan,
 172                  hb_font_t *font,
 173                  hb_buffer_t *buffer);
 174 static void
 175 initial_reordering (const hb_ot_shape_plan_t *plan,
 176                     hb_font_t *font,
 177                     hb_buffer_t *buffer);
 178 static void
 179 final_reordering (const hb_ot_shape_plan_t *plan,
 180                   hb_font_t *font,
 181                   hb_buffer_t *buffer);
 182 static void
 183 clear_syllables (const hb_ot_shape_plan_t *plan,
 184                  hb_font_t *font,
 185                  hb_buffer_t *buffer);
 186 
 187 static void
 188 collect_features_indic (hb_ot_shape_planner_t *plan)
 189 {
 190   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 191 
 192   /* Do this before any lookups have been applied. */
 193   map-&gt;add_gsub_pause (setup_syllables);
 194 
<span class="line-modified"> 195   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
 196   /* The Indic specs do not require ccmp, but we apply it here since if
 197    * there is a use of it, it&#39;s typically at the beginning. */
<span class="line-modified"> 198   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
 199 
 200 
 201   unsigned int i = 0;
 202   map-&gt;add_gsub_pause (initial_reordering);
<span class="line-added"> 203 </span>
 204   for (; i &lt; INDIC_BASIC_FEATURES; i++) {
<span class="line-modified"> 205     map-&gt;add_feature (indic_features[i]);</span>
 206     map-&gt;add_gsub_pause (nullptr);
 207   }
<span class="line-added"> 208 </span>
 209   map-&gt;add_gsub_pause (final_reordering);



 210 
<span class="line-modified"> 211   for (; i &lt; INDIC_NUM_FEATURES; i++)</span>
<span class="line-modified"> 212     map-&gt;add_feature (indic_features[i]);</span>
<span class="line-added"> 213 </span>
<span class="line-added"> 214   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="line-added"> 215   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;));</span>
 216 
 217   map-&gt;add_gsub_pause (clear_syllables);
 218 }
 219 
 220 static void
 221 override_features_indic (hb_ot_shape_planner_t *plan)
 222 {
<span class="line-modified"> 223   plan-&gt;map.disable_feature (HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;));</span>
 224 }
 225 
 226 
 227 struct would_substitute_feature_t
 228 {
<span class="line-modified"> 229   void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)</span>
 230   {
 231     zero_context = zero_context_;
 232     map-&gt;get_stage_lookups (0/*GSUB*/,
 233                             map-&gt;get_feature_stage (0/*GSUB*/, feature_tag),
 234                             &amp;lookups, &amp;count);
 235   }
 236 
<span class="line-modified"> 237   bool would_substitute (const hb_codepoint_t *glyphs,</span>
<span class="line-modified"> 238                          unsigned int          glyphs_count,</span>
<span class="line-modified"> 239                          hb_face_t            *face) const</span>
 240   {
 241     for (unsigned int i = 0; i &lt; count; i++)
 242       if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))
 243         return true;
 244     return false;
 245   }
 246 
 247   private:
 248   const hb_ot_map_t::lookup_map_t *lookups;
 249   unsigned int count;
 250   bool zero_context;
 251 };
 252 
 253 struct indic_shape_plan_t
 254 {
<span class="line-modified"> 255   bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const</span>


 256   {
<span class="line-modified"> 257     hb_codepoint_t glyph = virama_glyph.get_relaxed ();</span>
<span class="line-modified"> 258     if (unlikely (glyph == (hb_codepoint_t) -1))</span>
 259     {
 260       if (!config-&gt;virama || !font-&gt;get_nominal_glyph (config-&gt;virama, &amp;glyph))
 261         glyph = 0;
 262       /* Technically speaking, the spec says we should apply &#39;locl&#39; to virama too.
 263        * Maybe one day... */
 264 
 265       /* Our get_nominal_glyph() function needs a font, so we can&#39;t get the virama glyph
<span class="line-modified"> 266        * during shape planning...  Instead, overwrite it here. */</span>
<span class="line-modified"> 267       virama_glyph.set_relaxed ((int) glyph);</span>
 268     }
 269 
 270     *pglyph = glyph;
 271     return glyph != 0;
 272   }
 273 
 274   const indic_config_t *config;
 275 
 276   bool is_old_spec;
<span class="line-modified"> 277   bool uniscribe_bug_compatible;</span>
<span class="line-added"> 278   mutable hb_atomic_int_t virama_glyph;</span>
 279 
 280   would_substitute_feature_t rphf;
 281   would_substitute_feature_t pref;
 282   would_substitute_feature_t blwf;
 283   would_substitute_feature_t pstf;
 284 
 285   hb_mask_t mask_array[INDIC_NUM_FEATURES];
 286 };
 287 
 288 static void *
 289 data_create_indic (const hb_ot_shape_plan_t *plan)
 290 {
 291   indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));
 292   if (unlikely (!indic_plan))
 293     return nullptr;
 294 
 295   indic_plan-&gt;config = &amp;indic_configs[0];
 296   for (unsigned int i = 1; i &lt; ARRAY_LENGTH (indic_configs); i++)
 297     if (plan-&gt;props.script == indic_configs[i].script) {
 298       indic_plan-&gt;config = &amp;indic_configs[i];
 299       break;
 300     }
 301 
 302   indic_plan-&gt;is_old_spec = indic_plan-&gt;config-&gt;has_old_spec &amp;&amp; ((plan-&gt;map.chosen_script[0] &amp; 0x000000FFu) != &#39;2&#39;);
<span class="line-modified"> 303   indic_plan-&gt;uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;</span>
<span class="line-added"> 304   indic_plan-&gt;virama_glyph.set_relaxed (-1);</span>
 305 
 306   /* Use zero-context would_substitute() matching for new-spec of the main
 307    * Indic scripts, and scripts with one spec only, but not for old-specs.
 308    * The new-spec for all dual-spec scripts says zero-context matching happens.
 309    *
 310    * However, testing with Malayalam shows that old and new spec both allow
 311    * context.  Testing with Bengali new-spec however shows that it doesn&#39;t.
 312    * So, the heuristic here is the way it is.  It should *only* be changed,
 313    * as we discover more cases of what Windows does.  DON&#39;T TOUCH OTHERWISE.
 314    */
 315   bool zero_context = !indic_plan-&gt;is_old_spec &amp;&amp; plan-&gt;props.script != HB_SCRIPT_MALAYALAM;
 316   indic_plan-&gt;rphf.init (&amp;plan-&gt;map, HB_TAG(&#39;r&#39;,&#39;p&#39;,&#39;h&#39;,&#39;f&#39;), zero_context);
 317   indic_plan-&gt;pref.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;r&#39;,&#39;e&#39;,&#39;f&#39;), zero_context);
 318   indic_plan-&gt;blwf.init (&amp;plan-&gt;map, HB_TAG(&#39;b&#39;,&#39;l&#39;,&#39;w&#39;,&#39;f&#39;), zero_context);
 319   indic_plan-&gt;pstf.init (&amp;plan-&gt;map, HB_TAG(&#39;p&#39;,&#39;s&#39;,&#39;t&#39;,&#39;f&#39;), zero_context);
 320 
 321   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (indic_plan-&gt;mask_array); i++)
 322     indic_plan-&gt;mask_array[i] = (indic_features[i].flags &amp; F_GLOBAL) ?
 323                                  0 : plan-&gt;map.get_1_mask (indic_features[i].tag);
 324 
</pre>
<hr />
<pre>
 405 {
 406   int a = pa-&gt;indic_position();
 407   int b = pb-&gt;indic_position();
 408 
 409   return a &lt; b ? -1 : a == b ? 0 : +1;
 410 }
 411 
 412 
 413 
 414 static void
 415 update_consonant_positions (const hb_ot_shape_plan_t *plan,
 416                             hb_font_t         *font,
 417                             hb_buffer_t       *buffer)
 418 {
 419   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
 420 
 421   if (indic_plan-&gt;config-&gt;base_pos != BASE_POS_LAST)
 422     return;
 423 
 424   hb_codepoint_t virama;
<span class="line-modified"> 425   if (indic_plan-&gt;load_virama_glyph (font, &amp;virama))</span>
 426   {
 427     hb_face_t *face = font-&gt;face;
 428     unsigned int count = buffer-&gt;len;
 429     hb_glyph_info_t *info = buffer-&gt;info;
 430     for (unsigned int i = 0; i &lt; count; i++)
 431       if (info[i].indic_position() == POS_BASE_C)
 432       {
 433         hb_codepoint_t consonant = info[i].codepoint;
 434         info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);
 435       }
 436   }
 437 }
 438 
 439 
 440 /* Rules from:
 441  * https://docs.microsqoft.com/en-us/typography/script-development/devanagari */
 442 
 443 static void
 444 initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,
 445                                        hb_face_t *face,
</pre>
<hr />
<pre>
 653   /* Mark final consonants.  A final consonant is one appearing after a matra.
 654    * Happens in Sinhala. */
 655   for (unsigned int i = base + 1; i &lt; end; i++)
 656     if (info[i].indic_category() == OT_M) {
 657       for (unsigned int j = i + 1; j &lt; end; j++)
 658         if (is_consonant (info[j])) {
 659          info[j].indic_position() = POS_FINAL_C;
 660          break;
 661        }
 662       break;
 663     }
 664 
 665   /* Handle beginning Ra */
 666   if (has_reph)
 667     info[start].indic_position() = POS_RA_TO_BECOME_REPH;
 668 
 669   /* For old-style Indic script tags, move the first post-base Halant after
 670    * last consonant.
 671    *
 672    * Reports suggest that in some scripts Uniscribe does this only if there
<span class="line-modified"> 673    * is *not* a Halant after last consonant already.  We know that is the</span>
<span class="line-modified"> 674    * case for Kannada, while it reorders unconditionally in other scripts,</span>
<span class="line-modified"> 675    * eg. Malayalam, Bengali, and Devanagari.  We don&#39;t currently know about</span>
<span class="line-modified"> 676    * other scripts, so we blacklist Kannada.</span>
 677    *
 678    * Kannada test case:
 679    * U+0C9A,U+0CCD,U+0C9A,U+0CCD
 680    * With some versions of Lohit Kannada.
 681    * https://bugs.freedesktop.org/show_bug.cgi?id=59118
 682    *
 683    * Malayalam test case:
 684    * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D
 685    * With lohit-ttf-20121122/Lohit-Malayalam.ttf
 686    *
<span class="line-modified"> 687    * Bengali test case:</span>
 688    * U+0998,U+09CD,U+09AF,U+09CD
 689    * With Windows XP vrinda.ttf
 690    * https://github.com/harfbuzz/harfbuzz/issues/1073
<span class="line-added"> 691    *</span>
<span class="line-added"> 692    * Devanagari test case:</span>
<span class="line-added"> 693    * U+091F,U+094D,U+0930,U+094D</span>
<span class="line-added"> 694    * With chandas.ttf</span>
<span class="line-added"> 695    * https://github.com/harfbuzz/harfbuzz/issues/1071</span>
 696    */
 697   if (indic_plan-&gt;is_old_spec)
 698   {
<span class="line-modified"> 699     bool disallow_double_halants = buffer-&gt;props.script == HB_SCRIPT_KANNADA;</span>

 700     for (unsigned int i = base + 1; i &lt; end; i++)
 701       if (info[i].indic_category() == OT_H)
 702       {
 703         unsigned int j;
 704         for (j = end - 1; j &gt; i; j--)
 705           if (is_consonant (info[j]) ||
 706               (disallow_double_halants &amp;&amp; info[j].indic_category() == OT_H))
 707             break;
 708         if (info[j].indic_category() != OT_H &amp;&amp; j &gt; i) {
 709           /* Move Halant to after last consonant. */
 710           hb_glyph_info_t t = info[i];
 711           memmove (&amp;info[i], &amp;info[i + 1], (j - i) * sizeof (info[0]));
 712           info[j] = t;
 713         }
 714         break;
 715       }
 716   }
 717 
 718   /* Attach misc marks to previous char to move with them. */
 719   {
 720     indic_position_t last_pos = POS_START;
 721     for (unsigned int i = start; i &lt; end; i++)
 722     {
<span class="line-modified"> 723       if ((FLAG_UNSAFE (info[i].indic_category()) &amp; (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | FLAG (OT_H))))</span>
 724       {
 725         info[i].indic_position() = last_pos;
 726         if (unlikely (info[i].indic_category() == OT_H &amp;&amp;
 727                       info[i].indic_position() == POS_PRE_M))
 728         {
 729           /*
 730            * Uniscribe doesn&#39;t move the Halant with Left Matra.
 731            * TEST: U+092B,U+093F,U+094DE
 732            * We follow.  This is important for the Sinhala
 733            * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA
 734            * where U+0DD9 is a left matra and U+0DCA is the virama.
 735            * We don&#39;t want to move the virama with the left matra.
 736            * TEST: U+0D9A,U+0DDA
 737            */
 738           for (unsigned int j = i; j &gt; start; j--)
 739             if (info[j - 1].indic_position() != POS_PRE_M) {
 740               info[i].indic_position() = info[j - 1].indic_position();
 741               break;
 742             }
 743         }
</pre>
<hr />
<pre>
 769       info[i].syllable() = i - start;
 770 
 771     /* Sit tight, rock &#39;n roll! */
 772     hb_stable_sort (info + start, end - start, compare_indic_order);
 773     /* Find base again */
 774     base = end;
 775     for (unsigned int i = start; i &lt; end; i++)
 776       if (info[i].indic_position() == POS_BASE_C)
 777       {
 778         base = i;
 779         break;
 780       }
 781     /* Things are out-of-control for post base positions, they may shuffle
 782      * around like crazy.  In old-spec mode, we move halants around, so in
 783      * that case merge all clusters after base.  Otherwise, check the sort
 784      * order and merge as needed.
 785      * For pre-base stuff, we handle cluster issues in final reordering.
 786      *
 787      * We could use buffer-&gt;sort() for this, if there was no special
 788      * reordering of pre-base stuff happening later...
<span class="line-added"> 789      * We don&#39;t want to merge_clusters all of that, which buffer-&gt;sort()</span>
<span class="line-added"> 790      * would.</span>
 791      */
<span class="line-modified"> 792     if (indic_plan-&gt;is_old_spec || end - start &gt; 127)</span>
 793       buffer-&gt;merge_clusters (base, end);
 794     else
 795     {
 796       /* Note!  syllable() is a one-byte field. */
 797       for (unsigned int i = base; i &lt; end; i++)
 798         if (info[i].syllable() != 255)
 799         {
 800           unsigned int max = i;
 801           unsigned int j = start + info[i].syllable();
 802           while (j != i)
 803           {
 804             max = MAX (max, j);
 805             unsigned int next = start + info[j].syllable();
 806             info[j].syllable() = 255; /* So we don&#39;t process j later again. */
 807             j = next;
 808           }
 809           if (i != max)
 810             buffer-&gt;merge_clusters (i, max + 1);
 811         }
 812     }
</pre>
<hr />
<pre>
 901         j--;
 902 
 903         /* ZWJ/ZWNJ should disable CJCT.  They do that by simply
 904          * being there, since we don&#39;t skip them for the CJCT
 905          * feature (ie. F_MANUAL_ZWJ) */
 906 
 907         /* A ZWNJ disables HALF. */
 908         if (non_joiner)
 909           info[j].mask &amp;= ~indic_plan-&gt;mask_array[HALF];
 910 
 911       } while (j &gt; start &amp;&amp; !is_consonant (info[j]));
 912     }
 913 }
 914 
 915 static void
 916 initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,
 917                                        hb_face_t *face,
 918                                        hb_buffer_t *buffer,
 919                                        unsigned int start, unsigned int end)
 920 {
<span class="line-added"> 921   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;</span>
<span class="line-added"> 922 </span>
 923   /* We treat placeholder/dotted-circle as if they are consonants, so we
 924    * should just chain.  Only if not in compatibility mode that is... */
 925 
<span class="line-modified"> 926   if (indic_plan-&gt;uniscribe_bug_compatible)</span>
 927   {
 928     /* For dotted-circle, this is what Uniscribe does:
 929      * If dotted-circle is the last glyph, it just does nothing.
 930      * Ie. It doesn&#39;t form Reph. */
 931     if (buffer-&gt;info[end - 1].indic_category() == OT_DOTTEDCIRCLE)
 932       return;
 933   }
 934 
 935   initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 936 }
 937 
 938 static void
 939 initial_reordering_syllable (const hb_ot_shape_plan_t *plan,
 940                              hb_face_t *face,
 941                              hb_buffer_t *buffer,
 942                              unsigned int start, unsigned int end)
 943 {
 944   syllable_type_t syllable_type = (syllable_type_t) (buffer-&gt;info[start].syllable() &amp; 0x0F);
 945   switch (syllable_type)
 946   {
</pre>
<hr />
<pre>
 948     case consonant_syllable:
 949      initial_reordering_consonant_syllable (plan, face, buffer, start, end);
 950      break;
 951 
 952     case broken_cluster: /* We already inserted dotted-circles, so just call the standalone_cluster. */
 953     case standalone_cluster:
 954      initial_reordering_standalone_cluster (plan, face, buffer, start, end);
 955      break;
 956 
 957     case symbol_cluster:
 958     case non_indic_cluster:
 959       break;
 960   }
 961 }
 962 
 963 static inline void
 964 insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,
 965                        hb_font_t *font,
 966                        hb_buffer_t *buffer)
 967 {
<span class="line-modified"> 968   /* Note: This loop is extra overhead, but should not be measurable.</span>
<span class="line-added"> 969    * TODO Use a buffer scratch flag to remove the loop. */</span>
 970   bool has_broken_syllables = false;
 971   unsigned int count = buffer-&gt;len;
 972   hb_glyph_info_t *info = buffer-&gt;info;
 973   for (unsigned int i = 0; i &lt; count; i++)
 974     if ((info[i].syllable() &amp; 0x0F) == broken_cluster)
 975     {
 976       has_broken_syllables = true;
 977       break;
 978     }
 979   if (likely (!has_broken_syllables))
 980     return;
 981 
 982 
 983   hb_codepoint_t dottedcircle_glyph;
 984   if (!font-&gt;get_nominal_glyph (0x25CCu, &amp;dottedcircle_glyph))
 985     return;
 986 
 987   hb_glyph_info_t dottedcircle = {0};
 988   dottedcircle.codepoint = 0x25CCu;
 989   set_indic_properties (dottedcircle);
</pre>
<hr />
<pre>
1001     {
1002       last_syllable = syllable;
1003 
1004       hb_glyph_info_t ginfo = dottedcircle;
1005       ginfo.cluster = buffer-&gt;cur().cluster;
1006       ginfo.mask = buffer-&gt;cur().mask;
1007       ginfo.syllable() = buffer-&gt;cur().syllable();
1008       /* TODO Set glyph_props? */
1009 
1010       /* Insert dottedcircle after possible Repha. */
1011       while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful &amp;&amp;
1012              last_syllable == buffer-&gt;cur().syllable() &amp;&amp;
1013              buffer-&gt;cur().indic_category() == OT_Repha)
1014         buffer-&gt;next_glyph ();
1015 
1016       buffer-&gt;output_info (ginfo);
1017     }
1018     else
1019       buffer-&gt;next_glyph ();
1020   }

1021   buffer-&gt;swap_buffers ();
1022 }
1023 
1024 static void
1025 initial_reordering (const hb_ot_shape_plan_t *plan,
1026                     hb_font_t *font,
1027                     hb_buffer_t *buffer)
1028 {
1029   update_consonant_positions (plan, font, buffer);
1030   insert_dotted_circles (plan, font, buffer);
1031 
1032   foreach_syllable (buffer, start, end)
1033     initial_reordering_syllable (plan, font-&gt;face, buffer, start, end);
1034 }
1035 
1036 static void
1037 final_reordering_syllable (const hb_ot_shape_plan_t *plan,
1038                            hb_buffer_t *buffer,
1039                            unsigned int start, unsigned int end)
1040 {
1041   const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan-&gt;data;
1042   hb_glyph_info_t *info = buffer-&gt;info;
1043 
1044 
1045   /* This function relies heavily on halant glyphs.  Lots of ligation
1046    * and possibly multiple substitutions happened prior to this
1047    * phase, and that might have messed up our properties.  Recover
1048    * from a particular case of that where we&#39;re fairly sure that a
1049    * class of OT_H is desired but has been lost. */
<span class="line-modified">1050   /* We don&#39;t call load_virama_glyph(), since we know it&#39;s already</span>
<span class="line-added">1051    * loaded. */</span>
<span class="line-added">1052   hb_codepoint_t virama_glyph = indic_plan-&gt;virama_glyph.get_relaxed ();</span>
<span class="line-added">1053   if (virama_glyph)</span>
1054   {

1055     for (unsigned int i = start; i &lt; end; i++)
1056       if (info[i].codepoint == virama_glyph &amp;&amp;
1057           _hb_glyph_info_ligated (&amp;info[i]) &amp;&amp;
1058           _hb_glyph_info_multiplied (&amp;info[i]))
1059       {
1060         /* This will make sure that this glyph passes is_halant() test. */
1061         info[i].indic_category() = OT_H;
1062         _hb_glyph_info_clear_ligated_and_multiplied (&amp;info[i]);
1063       }
1064   }
1065 
1066 
1067   /* 4. Final reordering:
1068    *
1069    * After the localized forms and basic shaping forms GSUB features have been
1070    * applied (see below), the shaping engine performs some final glyph
1071    * reordering before applying all the remaining font features to the entire
1072    * syllable.
1073    */
1074 
</pre>
<hr />
<pre>
1123         base--;
1124       break;
1125     }
1126   if (base == end &amp;&amp; start &lt; base &amp;&amp;
1127       is_one_of (info[base - 1], FLAG (OT_ZWJ)))
1128     base--;
1129   if (base &lt; end)
1130     while (start &lt; base &amp;&amp;
1131            is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))
1132       base--;
1133 
1134 
1135   /*   o Reorder matras:
1136    *
1137    *     If a pre-base matra character had been reordered before applying basic
1138    *     features, the glyph can be moved closer to the main consonant based on
1139    *     whether half-forms had been formed. Actual position for the matra is
1140    *     defined as “after last standalone halant glyph, after initial matra
1141    *     position and before the main consonant”. If ZWJ or ZWNJ follow this
1142    *     halant, position is moved after it.
<span class="line-added">1143    *</span>
<span class="line-added">1144    * IMPLEMENTATION NOTES:</span>
<span class="line-added">1145    *</span>
<span class="line-added">1146    * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe</span>
<span class="line-added">1147    * and Devanagari shows that the behavior is best described as:</span>
<span class="line-added">1148    *</span>
<span class="line-added">1149    * &quot;If ZWJ follows this halant, matra is NOT repositioned after this halant.</span>
<span class="line-added">1150    *  If ZWNJ follows this halant, position is moved after it.&quot;</span>
<span class="line-added">1151    *</span>
<span class="line-added">1152    * Test case, with Adobe Devanagari or Nirmala UI:</span>
<span class="line-added">1153    *</span>
<span class="line-added">1154    *   U+091F,U+094D,U+200C,U+092F,U+093F</span>
<span class="line-added">1155    *   (Matra moves to the middle, after ZWNJ.)</span>
<span class="line-added">1156    *</span>
<span class="line-added">1157    *   U+091F,U+094D,U+200D,U+092F,U+093F</span>
<span class="line-added">1158    *   (Matra does NOT move, stays to the left.)</span>
<span class="line-added">1159    *</span>
<span class="line-added">1160    * https://github.com/harfbuzz/harfbuzz/issues/1070</span>
1161    */
1162 
1163   if (start + 1 &lt; end &amp;&amp; start &lt; base) /* Otherwise there can&#39;t be any pre-base matra characters. */
1164   {
1165     /* If we lost track of base, alas, position before last thingy. */
1166     unsigned int new_pos = base == end ? base - 2 : base - 1;
1167 
1168     /* Malayalam / Tamil do not have &quot;half&quot; forms or explicit virama forms.
1169      * The glyphs formed by &#39;half&#39; are Chillus or ligated explicit viramas.
1170      * We want to position matra after them.
1171      */
1172     if (buffer-&gt;props.script != HB_SCRIPT_MALAYALAM &amp;&amp; buffer-&gt;props.script != HB_SCRIPT_TAMIL)
1173     {
<span class="line-added">1174     search:</span>
1175       while (new_pos &gt; start &amp;&amp;
1176              !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))
1177         new_pos--;
1178 
1179       /* If we found no Halant we are done.
1180        * Otherwise only proceed if the Halant does
1181        * not belong to the Matra itself! */
1182       if (is_halant (info[new_pos]) &amp;&amp;
1183           info[new_pos].indic_position() != POS_PRE_M)
1184       {
<span class="line-added">1185 #if 0 // See comment above</span>
1186         /* -&gt; If ZWJ or ZWNJ follow this halant, position is moved after it. */
1187         if (new_pos + 1 &lt; end &amp;&amp; is_joiner (info[new_pos + 1]))
1188           new_pos++;
<span class="line-added">1189 #endif</span>
<span class="line-added">1190         if (new_pos + 1 &lt; end)</span>
<span class="line-added">1191         {</span>
<span class="line-added">1192           /* -&gt; If ZWJ follows this halant, matra is NOT repositioned after this halant. */</span>
<span class="line-added">1193           if (info[new_pos + 1].indic_category() == OT_ZWJ)</span>
<span class="line-added">1194           {</span>
<span class="line-added">1195             /* Keep searching. */</span>
<span class="line-added">1196             if (new_pos &gt; start)</span>
<span class="line-added">1197             {</span>
<span class="line-added">1198               new_pos--;</span>
<span class="line-added">1199               goto search;</span>
<span class="line-added">1200             }</span>
<span class="line-added">1201           }</span>
<span class="line-added">1202           /* -&gt; If ZWNJ follows this halant, position is moved after it. */</span>
<span class="line-added">1203           if (info[new_pos + 1].indic_category() == OT_ZWNJ)</span>
<span class="line-added">1204             new_pos++;</span>
<span class="line-added">1205         }</span>
1206       }
1207       else
1208         new_pos = start; /* No move. */
1209     }
1210 
1211     if (start &lt; new_pos &amp;&amp; info[new_pos].indic_position () != POS_PRE_M)
1212     {
1213       /* Now go see if there&#39;s actually any matras... */
1214       for (unsigned int i = new_pos; i &gt; start; i--)
1215         if (info[i - 1].indic_position () == POS_PRE_M)
1216         {
1217           unsigned int old_pos = i - 1;
1218           if (old_pos &lt; base &amp;&amp; base &lt;= new_pos) /* Shouldn&#39;t actually happen. */
1219             base--;
1220 
1221           hb_glyph_info_t tmp = info[old_pos];
1222           memmove (&amp;info[old_pos], &amp;info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));
1223           info[new_pos] = tmp;
1224 
1225           /* Note: this merge_clusters() is intentionally *after* the reordering.
</pre>
<hr />
<pre>
1346         if (new_reph_pos + 1 &lt; base &amp;&amp; is_joiner (info[new_reph_pos + 1]))
1347           new_reph_pos++;
1348         goto reph_move;
1349       }
1350     }
1351 
1352     /*       6. Otherwise, reorder reph to the end of the syllable.
1353      */
1354     {
1355       new_reph_pos = end - 1;
1356       while (new_reph_pos &gt; start &amp;&amp; info[new_reph_pos].indic_position() == POS_SMVD)
1357         new_reph_pos--;
1358 
1359       /*
1360        * If the Reph is to be ending up after a Matra,Halant sequence,
1361        * position it before that Halant so it can interact with the Matra.
1362        * However, if it&#39;s a plain Consonant,Halant we shouldn&#39;t do that.
1363        * Uniscribe doesn&#39;t do this.
1364        * TEST: U+0930,U+094D,U+0915,U+094B,U+094D
1365        */
<span class="line-modified">1366       if (!indic_plan-&gt;uniscribe_bug_compatible &amp;&amp;</span>
1367           unlikely (is_halant (info[new_reph_pos]))) {
1368         for (unsigned int i = base + 1; i &lt; new_reph_pos; i++)
1369           if (info[i].indic_category() == OT_M) {
1370             /* Ok, got it. */
1371             new_reph_pos--;
1372           }
1373       }
1374       goto reph_move;
1375     }
1376 
1377     reph_move:
1378     {
1379       /* Move */
1380       buffer-&gt;merge_clusters (start, new_reph_pos + 1);
1381       hb_glyph_info_t reph = info[start];
1382       memmove (&amp;info[start], &amp;info[start + 1], (new_reph_pos - start) * sizeof (info[0]));
1383       info[new_reph_pos] = reph;
1384 
1385       if (start &lt; base &amp;&amp; base &lt;= new_reph_pos)
1386         base--;
</pre>
<hr />
<pre>
1452         break;
1453       }
1454   }
1455 
1456 
1457   /* Apply &#39;init&#39; to the Left Matra if it&#39;s a word start. */
1458   if (info[start].indic_position () == POS_PRE_M)
1459   {
1460     if (!start ||
1461         !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&amp;info[start - 1])) &amp;
1462          FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))
1463       info[start].mask |= indic_plan-&gt;mask_array[INIT];
1464     else
1465       buffer-&gt;unsafe_to_break (start - 1, start + 1);
1466   }
1467 
1468 
1469   /*
1470    * Finish off the clusters and go home!
1471    */
<span class="line-modified">1472   if (indic_plan-&gt;uniscribe_bug_compatible)</span>
1473   {
1474     switch ((hb_tag_t) plan-&gt;props.script)
1475     {
1476       case HB_SCRIPT_TAMIL:
1477       case HB_SCRIPT_SINHALA:
1478         break;
1479 
1480       default:
1481         /* Uniscribe merges the entire syllable into a single cluster... Except for Tamil &amp; Sinhala.
1482          * This means, half forms are submerged into the main consonant&#39;s cluster.
1483          * This is unnecessary, and makes cursor positioning harder, but that&#39;s what
1484          * Uniscribe does. */
1485         buffer-&gt;merge_clusters (start, end);
1486         break;
1487     }
1488   }
1489 }
1490 
1491 
1492 static void
</pre>
<hr />
<pre>
1500   foreach_syllable (buffer, start, end)
1501     final_reordering_syllable (plan, buffer, start, end);
1502 
1503   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);
1504   HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);
1505 }
1506 
1507 
1508 static void
1509 clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,
1510                  hb_font_t *font HB_UNUSED,
1511                  hb_buffer_t *buffer)
1512 {
1513   hb_glyph_info_t *info = buffer-&gt;info;
1514   unsigned int count = buffer-&gt;len;
1515   for (unsigned int i = 0; i &lt; count; i++)
1516     info[i].syllable() = 0;
1517 }
1518 
1519 
<span class="line-added">1520 static void</span>
<span class="line-added">1521 preprocess_text_indic (const hb_ot_shape_plan_t *plan,</span>
<span class="line-added">1522                        hb_buffer_t              *buffer,</span>
<span class="line-added">1523                        hb_font_t                *font)</span>
<span class="line-added">1524 {</span>
<span class="line-added">1525   _hb_preprocess_text_vowel_constraints (plan, buffer, font);</span>
<span class="line-added">1526 }</span>
<span class="line-added">1527 </span>
1528 static bool
1529 decompose_indic (const hb_ot_shape_normalize_context_t *c,
1530                  hb_codepoint_t  ab,
1531                  hb_codepoint_t *a,
1532                  hb_codepoint_t *b)
1533 {
1534   switch (ab)
1535   {
1536     /* Don&#39;t decompose these. */
1537     case 0x0931u  : return false; /* DEVANAGARI LETTER RRA */
1538     // https://github.com/harfbuzz/harfbuzz/issues/779
1539     case 0x09DCu  : return false; /* BENGALI LETTER RRA */
1540     case 0x09DDu  : return false; /* BENGALI LETTER RHA */
1541     case 0x0B94u  : return false; /* TAMIL LETTER AU */
1542 
1543 
1544     /*
1545      * Decompose split matras that don&#39;t have Unicode decompositions.
1546      */
1547 
</pre>
<hr />
<pre>
1607                hb_codepoint_t  b,
1608                hb_codepoint_t *ab)
1609 {
1610   /* Avoid recomposing split matras. */
1611   if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c-&gt;unicode-&gt;general_category (a)))
1612     return false;
1613 
1614   /* Composition-exclusion exceptions that we want to recompose. */
1615   if (a == 0x09AFu &amp;&amp; b == 0x09BCu) { *ab = 0x09DFu; return true; }
1616 
1617   return (bool) c-&gt;unicode-&gt;compose (a, b, ab);
1618 }
1619 
1620 
1621 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =
1622 {
1623   collect_features_indic,
1624   override_features_indic,
1625   data_create_indic,
1626   data_destroy_indic,
<span class="line-modified">1627   preprocess_text_indic,</span>
1628   nullptr, /* postprocess_glyphs */
1629   HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,
1630   decompose_indic,
1631   compose_indic,
1632   setup_masks_indic,
<span class="line-modified">1633   HB_TAG_NONE, /* gpos_tag */</span>
1634   nullptr, /* reorder_marks */
1635   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
1636   false, /* fallback_position */
1637 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-indic-table.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-khmer-machine.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
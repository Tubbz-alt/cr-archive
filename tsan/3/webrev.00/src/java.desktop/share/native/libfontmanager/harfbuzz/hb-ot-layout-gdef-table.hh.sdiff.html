<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-layout-base-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gpos-table.hh.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gdef-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
 30 #define HB_OT_LAYOUT_GDEF_TABLE_HH
 31 
<span class="line-modified"> 32 #include &quot;hb-ot-layout-common-private.hh&quot;</span>
 33 
<span class="line-modified"> 34 #include &quot;hb-font-private.hh&quot;</span>
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 /*
 41  * Attachment List Table
 42  */
 43 
 44 typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
 45                                          * increasing numerical order */
 46 
 47 struct AttachList
 48 {
<span class="line-modified"> 49   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 50                                          unsigned int start_offset,</span>
<span class="line-modified"> 51                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified"> 52                                          unsigned int *point_array /* OUT */) const</span>
 53   {
 54     unsigned int index = (this+coverage).get_coverage (glyph_id);
 55     if (index == NOT_COVERED)
 56     {
 57       if (point_count)
 58         *point_count = 0;
 59       return 0;
 60     }
 61 
 62     const AttachPoint &amp;points = this+attachPoint[index];
 63 
<span class="line-modified"> 64     if (point_count) {</span>
<span class="line-modified"> 65       const HBUINT16 *array = points.sub_array (start_offset, point_count);</span>
<span class="line-modified"> 66       unsigned int count = *point_count;</span>

 67       for (unsigned int i = 0; i &lt; count; i++)
 68         point_array[i] = array[i];
 69     }
 70 
 71     return points.len;
 72   }
 73 
<span class="line-modified"> 74   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 75   {
 76     TRACE_SANITIZE (this);
 77     return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
 78   }
 79 
 80   protected:
 81   OffsetTo&lt;Coverage&gt;
 82                 coverage;               /* Offset to Coverage table -- from
 83                                          * beginning of AttachList table */
 84   OffsetArrayOf&lt;AttachPoint&gt;
 85                 attachPoint;            /* Array of AttachPoint tables
 86                                          * in Coverage Index order */
 87   public:
 88   DEFINE_SIZE_ARRAY (4, attachPoint);
 89 };
 90 
 91 /*
 92  * Ligature Caret Table
 93  */
 94 
 95 struct CaretValueFormat1
 96 {
 97   friend struct CaretValue;
 98 
 99   private:
<span class="line-modified">100   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
101   {
102     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
103   }
104 
<span class="line-modified">105   inline bool sanitize (hb_sanitize_context_t *c) const</span>
106   {
107     TRACE_SANITIZE (this);
108     return_trace (c-&gt;check_struct (this));
109   }
110 
111   protected:
112   HBUINT16      caretValueFormat;       /* Format identifier--format = 1 */
113   FWORD         coordinate;             /* X or Y value, in design units */
114   public:
115   DEFINE_SIZE_STATIC (4);
116 };
117 
118 struct CaretValueFormat2
119 {
120   friend struct CaretValue;
121 
122   private:
<span class="line-modified">123   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
124   {
125     hb_position_t x, y;
<span class="line-modified">126     if (font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y))</span>
<span class="line-modified">127       return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>
<span class="line-removed">128     else</span>
<span class="line-removed">129       return 0;</span>
130   }
131 
<span class="line-modified">132   inline bool sanitize (hb_sanitize_context_t *c) const</span>
133   {
134     TRACE_SANITIZE (this);
135     return_trace (c-&gt;check_struct (this));
136   }
137 
138   protected:
139   HBUINT16      caretValueFormat;       /* Format identifier--format = 2 */
140   HBUINT16      caretValuePoint;        /* Contour point index on glyph */
141   public:
142   DEFINE_SIZE_STATIC (4);
143 };
144 
145 struct CaretValueFormat3
146 {
147   friend struct CaretValue;
148 
<span class="line-modified">149   inline hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, const VariationStore &amp;var_store) const</span>

150   {
151     return HB_DIRECTION_IS_HORIZONTAL (direction) ?
152            font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
153            font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
154   }
155 
<span class="line-modified">156   inline bool sanitize (hb_sanitize_context_t *c) const</span>
157   {
158     TRACE_SANITIZE (this);
159     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
160   }
161 
162   protected:
163   HBUINT16      caretValueFormat;       /* Format identifier--format = 3 */
164   FWORD         coordinate;             /* X or Y value, in design units */
165   OffsetTo&lt;Device&gt;
166                 deviceTable;            /* Offset to Device table for X or Y
167                                          * value--from beginning of CaretValue
168                                          * table */
169   public:
170   DEFINE_SIZE_STATIC (6);
171 };
172 
173 struct CaretValue
174 {
<span class="line-modified">175   inline hb_position_t get_caret_value (hb_font_t *font,</span>
176                                         hb_direction_t direction,
177                                         hb_codepoint_t glyph_id,
178                                         const VariationStore &amp;var_store) const
179   {
180     switch (u.format) {
181     case 1: return u.format1.get_caret_value (font, direction);
182     case 2: return u.format2.get_caret_value (font, direction, glyph_id);
183     case 3: return u.format3.get_caret_value (font, direction, var_store);
184     default:return 0;
185     }
186   }
187 
<span class="line-modified">188   inline bool sanitize (hb_sanitize_context_t *c) const</span>
189   {
190     TRACE_SANITIZE (this);
191     if (!u.format.sanitize (c)) return_trace (false);
192     switch (u.format) {
193     case 1: return_trace (u.format1.sanitize (c));
194     case 2: return_trace (u.format2.sanitize (c));
195     case 3: return_trace (u.format3.sanitize (c));
196     default:return_trace (true);
197     }
198   }
199 
200   protected:
201   union {
202   HBUINT16              format;         /* Format identifier */
203   CaretValueFormat1     format1;
204   CaretValueFormat2     format2;
205   CaretValueFormat3     format3;
206   } u;
207   public:
208   DEFINE_SIZE_UNION (2, format);
209 };
210 
211 struct LigGlyph
212 {
<span class="line-modified">213   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">214                                       hb_direction_t direction,</span>
<span class="line-modified">215                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">216                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">217                                       unsigned int start_offset,</span>
<span class="line-modified">218                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">219                                       hb_position_t *caret_array /* OUT */) const</span>
220   {
<span class="line-modified">221     if (caret_count) {</span>
<span class="line-modified">222       const OffsetTo&lt;CaretValue&gt; *array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-modified">223       unsigned int count = *caret_count;</span>

224       for (unsigned int i = 0; i &lt; count; i++)
225         caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
226     }
227 
228     return carets.len;
229   }
230 
<span class="line-modified">231   inline bool sanitize (hb_sanitize_context_t *c) const</span>
232   {
233     TRACE_SANITIZE (this);
234     return_trace (carets.sanitize (c, this));
235   }
236 
237   protected:
238   OffsetArrayOf&lt;CaretValue&gt;
239                 carets;                 /* Offset array of CaretValue tables
240                                          * --from beginning of LigGlyph table
241                                          * --in increasing coordinate order */
242   public:
243   DEFINE_SIZE_ARRAY (2, carets);
244 };
245 
246 struct LigCaretList
247 {
<span class="line-modified">248   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">249                                       hb_direction_t direction,</span>
<span class="line-modified">250                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">251                                       const VariationStore &amp;var_store,</span>
<span class="line-modified">252                                       unsigned int start_offset,</span>
<span class="line-modified">253                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">254                                       hb_position_t *caret_array /* OUT */) const</span>
255   {
256     unsigned int index = (this+coverage).get_coverage (glyph_id);
257     if (index == NOT_COVERED)
258     {
259       if (caret_count)
260         *caret_count = 0;
261       return 0;
262     }
263     const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
264     return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
265   }
266 
<span class="line-modified">267   inline bool sanitize (hb_sanitize_context_t *c) const</span>
268   {
269     TRACE_SANITIZE (this);
270     return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
271   }
272 
273   protected:
274   OffsetTo&lt;Coverage&gt;
275                 coverage;               /* Offset to Coverage table--from
276                                          * beginning of LigCaretList table */
277   OffsetArrayOf&lt;LigGlyph&gt;
278                 ligGlyph;               /* Array of LigGlyph tables
279                                          * in Coverage Index order */
280   public:
281   DEFINE_SIZE_ARRAY (4, ligGlyph);
282 };
283 
284 
285 struct MarkGlyphSetsFormat1
286 {
<span class="line-modified">287   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
288   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
289 
<span class="line-modified">290   inline bool sanitize (hb_sanitize_context_t *c) const</span>
291   {
292     TRACE_SANITIZE (this);
293     return_trace (coverage.sanitize (c, this));
294   }
295 
296   protected:
297   HBUINT16      format;                 /* Format identifier--format = 1 */
298   ArrayOf&lt;LOffsetTo&lt;Coverage&gt; &gt;
299                 coverage;               /* Array of long offsets to mark set
300                                          * coverage tables */
301   public:
302   DEFINE_SIZE_ARRAY (4, coverage);
303 };
304 
305 struct MarkGlyphSets
306 {
<span class="line-modified">307   inline bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
308   {
309     switch (u.format) {
310     case 1: return u.format1.covers (set_index, glyph_id);
311     default:return false;
312     }
313   }
314 
<span class="line-modified">315   inline bool sanitize (hb_sanitize_context_t *c) const</span>
316   {
317     TRACE_SANITIZE (this);
318     if (!u.format.sanitize (c)) return_trace (false);
319     switch (u.format) {
320     case 1: return_trace (u.format1.sanitize (c));
321     default:return_trace (true);
322     }
323   }
324 
325   protected:
326   union {
327   HBUINT16              format;         /* Format identifier */
328   MarkGlyphSetsFormat1  format1;
329   } u;
330   public:
331   DEFINE_SIZE_UNION (2, format);
332 };
333 
334 
335 /*
336  * GDEF -- Glyph Definition
337  * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
338  */
339 

340 struct GDEF
341 {
<span class="line-modified">342   static const hb_tag_t tableTag        = HB_OT_TAG_GDEF;</span>
343 
344   enum GlyphClasses {
345     UnclassifiedGlyph   = 0,
346     BaseGlyph           = 1,
347     LigatureGlyph       = 2,
348     MarkGlyph           = 3,
349     ComponentGlyph      = 4
350   };
351 
<span class="line-modified">352   inline bool has_glyph_classes (void) const { return glyphClassDef != 0; }</span>
<span class="line-modified">353   inline unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>

354   { return (this+glyphClassDef).get_class (glyph); }
<span class="line-modified">355   inline void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
356   { (this+glyphClassDef).add_class (glyphs, klass); }
357 
<span class="line-modified">358   inline bool has_mark_attachment_types (void) const { return markAttachClassDef != 0; }</span>
<span class="line-modified">359   inline unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
360   { return (this+markAttachClassDef).get_class (glyph); }
361 
<span class="line-modified">362   inline bool has_attach_points (void) const { return attachList != 0; }</span>
<span class="line-modified">363   inline unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">364                                          unsigned int start_offset,</span>
<span class="line-modified">365                                          unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">366                                          unsigned int *point_array /* OUT */) const</span>
367   { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
368 
<span class="line-modified">369   inline bool has_lig_carets (void) const { return ligCaretList != 0; }</span>
<span class="line-modified">370   inline unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">371                                       hb_direction_t direction,</span>
<span class="line-modified">372                                       hb_codepoint_t glyph_id,</span>
<span class="line-modified">373                                       unsigned int start_offset,</span>
<span class="line-modified">374                                       unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">375                                       hb_position_t *caret_array /* OUT */) const</span>
376   { return (this+ligCaretList).get_lig_carets (font,
377                                                direction, glyph_id, get_var_store(),
378                                                start_offset, caret_count, caret_array); }
379 
<span class="line-modified">380   inline bool has_mark_sets (void) const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">381   inline bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
382   { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
383 
<span class="line-modified">384   inline bool has_var_store (void) const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">385   inline const VariationStore &amp;get_var_store (void) const</span>
386   { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
387 
<span class="line-removed">388   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">389   {</span>
<span class="line-removed">390     TRACE_SANITIZE (this);</span>
<span class="line-removed">391     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-removed">392                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-removed">393                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">394                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">395                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">396                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-removed">397                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-removed">398                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-removed">399   }</span>
<span class="line-removed">400 </span>
401   /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<span class="line-modified">402    * glyph class and other bits, and high 8-bit gthe mark attachment type (if any).</span>
403    * Not to be confused with lookup_props which is very similar. */
<span class="line-modified">404   inline unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
405   {
406     unsigned int klass = get_glyph_class (glyph);
407 
408     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
409     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
410     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), &quot;&quot;);
411 
412     switch (klass) {
413     default:                    return 0;
414     case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;
415     case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;
416     case MarkGlyph:
417           klass = get_mark_attachment_type (glyph);
418           return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
419     }
420   }
421 



























































422 
423   protected:
424   FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
425                                          * 0x00010003u */
426   OffsetTo&lt;ClassDef&gt;
427                 glyphClassDef;          /* Offset to class definition table
428                                          * for glyph type--from beginning of
429                                          * GDEF header (may be Null) */
430   OffsetTo&lt;AttachList&gt;
431                 attachList;             /* Offset to list of glyphs with
432                                          * attachment points--from beginning
433                                          * of GDEF header (may be Null) */
434   OffsetTo&lt;LigCaretList&gt;
435                 ligCaretList;           /* Offset to list of positioning points
436                                          * for ligature carets--from beginning
437                                          * of GDEF header (may be Null) */
438   OffsetTo&lt;ClassDef&gt;
439                 markAttachClassDef;     /* Offset to class definition table for
440                                          * mark attachment type--from beginning
441                                          * of GDEF header (may be Null) */
442   OffsetTo&lt;MarkGlyphSets&gt;
443                 markGlyphSetsDef;       /* Offset to the table of mark set
444                                          * definitions--from beginning of GDEF
445                                          * header (may be NULL).  Introduced
446                                          * in version 0x00010002. */
447   LOffsetTo&lt;VariationStore&gt;
448                 varStore;               /* Offset to the table of Item Variation
449                                          * Store--from beginning of GDEF
450                                          * header (may be NULL).  Introduced
451                                          * in version 0x00010003. */
452   public:
453   DEFINE_SIZE_MIN (12);
454 };
455 

456 
457 } /* namespace OT */
458 
459 
460 #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 17  * DAMAGE.
 18  *
 19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 24  *
 25  * Red Hat Author(s): Behdad Esfahbod
 26  * Google Author(s): Behdad Esfahbod
 27  */
 28 
 29 #ifndef HB_OT_LAYOUT_GDEF_TABLE_HH
 30 #define HB_OT_LAYOUT_GDEF_TABLE_HH
 31 
<span class="line-modified"> 32 #include &quot;hb-ot-layout-common.hh&quot;</span>
 33 
<span class="line-modified"> 34 #include &quot;hb-font.hh&quot;</span>
 35 
 36 
 37 namespace OT {
 38 
 39 
 40 /*
 41  * Attachment List Table
 42  */
 43 
 44 typedef ArrayOf&lt;HBUINT16&gt; AttachPoint;  /* Array of contour point indices--in
 45                                          * increasing numerical order */
 46 
 47 struct AttachList
 48 {
<span class="line-modified"> 49   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified"> 50                                   unsigned int start_offset,</span>
<span class="line-modified"> 51                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified"> 52                                   unsigned int *point_array /* OUT */) const</span>
 53   {
 54     unsigned int index = (this+coverage).get_coverage (glyph_id);
 55     if (index == NOT_COVERED)
 56     {
 57       if (point_count)
 58         *point_count = 0;
 59       return 0;
 60     }
 61 
 62     const AttachPoint &amp;points = this+attachPoint[index];
 63 
<span class="line-modified"> 64     if (point_count)</span>
<span class="line-modified"> 65     {</span>
<span class="line-modified"> 66       hb_array_t&lt;const HBUINT16&gt; array = points.sub_array (start_offset, point_count);</span>
<span class="line-added"> 67       unsigned int count = array.length;</span>
 68       for (unsigned int i = 0; i &lt; count; i++)
 69         point_array[i] = array[i];
 70     }
 71 
 72     return points.len;
 73   }
 74 
<span class="line-modified"> 75   bool sanitize (hb_sanitize_context_t *c) const</span>
 76   {
 77     TRACE_SANITIZE (this);
 78     return_trace (coverage.sanitize (c, this) &amp;&amp; attachPoint.sanitize (c, this));
 79   }
 80 
 81   protected:
 82   OffsetTo&lt;Coverage&gt;
 83                 coverage;               /* Offset to Coverage table -- from
 84                                          * beginning of AttachList table */
 85   OffsetArrayOf&lt;AttachPoint&gt;
 86                 attachPoint;            /* Array of AttachPoint tables
 87                                          * in Coverage Index order */
 88   public:
 89   DEFINE_SIZE_ARRAY (4, attachPoint);
 90 };
 91 
 92 /*
 93  * Ligature Caret Table
 94  */
 95 
 96 struct CaretValueFormat1
 97 {
 98   friend struct CaretValue;
 99 
100   private:
<span class="line-modified">101   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const</span>
102   {
103     return HB_DIRECTION_IS_HORIZONTAL (direction) ? font-&gt;em_scale_x (coordinate) : font-&gt;em_scale_y (coordinate);
104   }
105 
<span class="line-modified">106   bool sanitize (hb_sanitize_context_t *c) const</span>
107   {
108     TRACE_SANITIZE (this);
109     return_trace (c-&gt;check_struct (this));
110   }
111 
112   protected:
113   HBUINT16      caretValueFormat;       /* Format identifier--format = 1 */
114   FWORD         coordinate;             /* X or Y value, in design units */
115   public:
116   DEFINE_SIZE_STATIC (4);
117 };
118 
119 struct CaretValueFormat2
120 {
121   friend struct CaretValue;
122 
123   private:
<span class="line-modified">124   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const</span>
125   {
126     hb_position_t x, y;
<span class="line-modified">127     font-&gt;get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &amp;x, &amp;y);</span>
<span class="line-modified">128     return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;</span>


129   }
130 
<span class="line-modified">131   bool sanitize (hb_sanitize_context_t *c) const</span>
132   {
133     TRACE_SANITIZE (this);
134     return_trace (c-&gt;check_struct (this));
135   }
136 
137   protected:
138   HBUINT16      caretValueFormat;       /* Format identifier--format = 2 */
139   HBUINT16      caretValuePoint;        /* Contour point index on glyph */
140   public:
141   DEFINE_SIZE_STATIC (4);
142 };
143 
144 struct CaretValueFormat3
145 {
146   friend struct CaretValue;
147 
<span class="line-modified">148   hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,</span>
<span class="line-added">149                                  const VariationStore &amp;var_store) const</span>
150   {
151     return HB_DIRECTION_IS_HORIZONTAL (direction) ?
152            font-&gt;em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :
153            font-&gt;em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);
154   }
155 
<span class="line-modified">156   bool sanitize (hb_sanitize_context_t *c) const</span>
157   {
158     TRACE_SANITIZE (this);
159     return_trace (c-&gt;check_struct (this) &amp;&amp; deviceTable.sanitize (c, this));
160   }
161 
162   protected:
163   HBUINT16      caretValueFormat;       /* Format identifier--format = 3 */
164   FWORD         coordinate;             /* X or Y value, in design units */
165   OffsetTo&lt;Device&gt;
166                 deviceTable;            /* Offset to Device table for X or Y
167                                          * value--from beginning of CaretValue
168                                          * table */
169   public:
170   DEFINE_SIZE_STATIC (6);
171 };
172 
173 struct CaretValue
174 {
<span class="line-modified">175   hb_position_t get_caret_value (hb_font_t *font,</span>
176                                         hb_direction_t direction,
177                                         hb_codepoint_t glyph_id,
178                                         const VariationStore &amp;var_store) const
179   {
180     switch (u.format) {
181     case 1: return u.format1.get_caret_value (font, direction);
182     case 2: return u.format2.get_caret_value (font, direction, glyph_id);
183     case 3: return u.format3.get_caret_value (font, direction, var_store);
184     default:return 0;
185     }
186   }
187 
<span class="line-modified">188   bool sanitize (hb_sanitize_context_t *c) const</span>
189   {
190     TRACE_SANITIZE (this);
191     if (!u.format.sanitize (c)) return_trace (false);
192     switch (u.format) {
193     case 1: return_trace (u.format1.sanitize (c));
194     case 2: return_trace (u.format2.sanitize (c));
195     case 3: return_trace (u.format3.sanitize (c));
196     default:return_trace (true);
197     }
198   }
199 
200   protected:
201   union {
202   HBUINT16              format;         /* Format identifier */
203   CaretValueFormat1     format1;
204   CaretValueFormat2     format2;
205   CaretValueFormat3     format3;
206   } u;
207   public:
208   DEFINE_SIZE_UNION (2, format);
209 };
210 
211 struct LigGlyph
212 {
<span class="line-modified">213   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">214                                hb_direction_t direction,</span>
<span class="line-modified">215                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">216                                const VariationStore &amp;var_store,</span>
<span class="line-modified">217                                unsigned int start_offset,</span>
<span class="line-modified">218                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">219                                hb_position_t *caret_array /* OUT */) const</span>
220   {
<span class="line-modified">221     if (caret_count)</span>
<span class="line-modified">222     {</span>
<span class="line-modified">223       hb_array_t &lt;const OffsetTo&lt;CaretValue&gt; &gt; array = carets.sub_array (start_offset, caret_count);</span>
<span class="line-added">224       unsigned int count = array.length;</span>
225       for (unsigned int i = 0; i &lt; count; i++)
226         caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);
227     }
228 
229     return carets.len;
230   }
231 
<span class="line-modified">232   bool sanitize (hb_sanitize_context_t *c) const</span>
233   {
234     TRACE_SANITIZE (this);
235     return_trace (carets.sanitize (c, this));
236   }
237 
238   protected:
239   OffsetArrayOf&lt;CaretValue&gt;
240                 carets;                 /* Offset array of CaretValue tables
241                                          * --from beginning of LigGlyph table
242                                          * --in increasing coordinate order */
243   public:
244   DEFINE_SIZE_ARRAY (2, carets);
245 };
246 
247 struct LigCaretList
248 {
<span class="line-modified">249   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">250                                hb_direction_t direction,</span>
<span class="line-modified">251                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">252                                const VariationStore &amp;var_store,</span>
<span class="line-modified">253                                unsigned int start_offset,</span>
<span class="line-modified">254                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">255                                hb_position_t *caret_array /* OUT */) const</span>
256   {
257     unsigned int index = (this+coverage).get_coverage (glyph_id);
258     if (index == NOT_COVERED)
259     {
260       if (caret_count)
261         *caret_count = 0;
262       return 0;
263     }
264     const LigGlyph &amp;lig_glyph = this+ligGlyph[index];
265     return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);
266   }
267 
<span class="line-modified">268   bool sanitize (hb_sanitize_context_t *c) const</span>
269   {
270     TRACE_SANITIZE (this);
271     return_trace (coverage.sanitize (c, this) &amp;&amp; ligGlyph.sanitize (c, this));
272   }
273 
274   protected:
275   OffsetTo&lt;Coverage&gt;
276                 coverage;               /* Offset to Coverage table--from
277                                          * beginning of LigCaretList table */
278   OffsetArrayOf&lt;LigGlyph&gt;
279                 ligGlyph;               /* Array of LigGlyph tables
280                                          * in Coverage Index order */
281   public:
282   DEFINE_SIZE_ARRAY (4, ligGlyph);
283 };
284 
285 
286 struct MarkGlyphSetsFormat1
287 {
<span class="line-modified">288   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
289   { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }
290 
<span class="line-modified">291   bool sanitize (hb_sanitize_context_t *c) const</span>
292   {
293     TRACE_SANITIZE (this);
294     return_trace (coverage.sanitize (c, this));
295   }
296 
297   protected:
298   HBUINT16      format;                 /* Format identifier--format = 1 */
299   ArrayOf&lt;LOffsetTo&lt;Coverage&gt; &gt;
300                 coverage;               /* Array of long offsets to mark set
301                                          * coverage tables */
302   public:
303   DEFINE_SIZE_ARRAY (4, coverage);
304 };
305 
306 struct MarkGlyphSets
307 {
<span class="line-modified">308   bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
309   {
310     switch (u.format) {
311     case 1: return u.format1.covers (set_index, glyph_id);
312     default:return false;
313     }
314   }
315 
<span class="line-modified">316   bool sanitize (hb_sanitize_context_t *c) const</span>
317   {
318     TRACE_SANITIZE (this);
319     if (!u.format.sanitize (c)) return_trace (false);
320     switch (u.format) {
321     case 1: return_trace (u.format1.sanitize (c));
322     default:return_trace (true);
323     }
324   }
325 
326   protected:
327   union {
328   HBUINT16              format;         /* Format identifier */
329   MarkGlyphSetsFormat1  format1;
330   } u;
331   public:
332   DEFINE_SIZE_UNION (2, format);
333 };
334 
335 
336 /*
337  * GDEF -- Glyph Definition
338  * https://docs.microsoft.com/en-us/typography/opentype/spec/gdef
339  */
340 
<span class="line-added">341 </span>
342 struct GDEF
343 {
<span class="line-modified">344   static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;</span>
345 
346   enum GlyphClasses {
347     UnclassifiedGlyph   = 0,
348     BaseGlyph           = 1,
349     LigatureGlyph       = 2,
350     MarkGlyph           = 3,
351     ComponentGlyph      = 4
352   };
353 
<span class="line-modified">354   bool has_data () const { return version.to_int (); }</span>
<span class="line-modified">355   bool has_glyph_classes () const { return glyphClassDef != 0; }</span>
<span class="line-added">356   unsigned int get_glyph_class (hb_codepoint_t glyph) const</span>
357   { return (this+glyphClassDef).get_class (glyph); }
<span class="line-modified">358   void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const</span>
359   { (this+glyphClassDef).add_class (glyphs, klass); }
360 
<span class="line-modified">361   bool has_mark_attachment_types () const { return markAttachClassDef != 0; }</span>
<span class="line-modified">362   unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const</span>
363   { return (this+markAttachClassDef).get_class (glyph); }
364 
<span class="line-modified">365   bool has_attach_points () const { return attachList != 0; }</span>
<span class="line-modified">366   unsigned int get_attach_points (hb_codepoint_t glyph_id,</span>
<span class="line-modified">367                                   unsigned int start_offset,</span>
<span class="line-modified">368                                   unsigned int *point_count /* IN/OUT */,</span>
<span class="line-modified">369                                   unsigned int *point_array /* OUT */) const</span>
370   { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }
371 
<span class="line-modified">372   bool has_lig_carets () const { return ligCaretList != 0; }</span>
<span class="line-modified">373   unsigned int get_lig_carets (hb_font_t *font,</span>
<span class="line-modified">374                                hb_direction_t direction,</span>
<span class="line-modified">375                                hb_codepoint_t glyph_id,</span>
<span class="line-modified">376                                unsigned int start_offset,</span>
<span class="line-modified">377                                unsigned int *caret_count /* IN/OUT */,</span>
<span class="line-modified">378                                hb_position_t *caret_array /* OUT */) const</span>
379   { return (this+ligCaretList).get_lig_carets (font,
380                                                direction, glyph_id, get_var_store(),
381                                                start_offset, caret_count, caret_array); }
382 
<span class="line-modified">383   bool has_mark_sets () const { return version.to_int () &gt;= 0x00010002u &amp;&amp; markGlyphSetsDef != 0; }</span>
<span class="line-modified">384   bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const</span>
385   { return version.to_int () &gt;= 0x00010002u &amp;&amp; (this+markGlyphSetsDef).covers (set_index, glyph_id); }
386 
<span class="line-modified">387   bool has_var_store () const { return version.to_int () &gt;= 0x00010003u &amp;&amp; varStore != 0; }</span>
<span class="line-modified">388   const VariationStore &amp;get_var_store () const</span>
389   { return version.to_int () &gt;= 0x00010003u ? this+varStore : Null(VariationStore); }
390 













391   /* glyph_props is a 16-bit integer where the lower 8-bit have bits representing
<span class="line-modified">392    * glyph class and other bits, and high 8-bit the mark attachment type (if any).</span>
393    * Not to be confused with lookup_props which is very similar. */
<span class="line-modified">394   unsigned int get_glyph_props (hb_codepoint_t glyph) const</span>
395   {
396     unsigned int klass = get_glyph_class (glyph);
397 
398     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), &quot;&quot;);
399     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), &quot;&quot;);
400     static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), &quot;&quot;);
401 
402     switch (klass) {
403     default:                    return 0;
404     case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;
405     case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;
406     case MarkGlyph:
407           klass = get_mark_attachment_type (glyph);
408           return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass &lt;&lt; 8);
409     }
410   }
411 
<span class="line-added">412   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">413                                    hb_face_t *face) const;</span>
<span class="line-added">414 </span>
<span class="line-added">415   struct accelerator_t</span>
<span class="line-added">416   {</span>
<span class="line-added">417     void init (hb_face_t *face)</span>
<span class="line-added">418     {</span>
<span class="line-added">419       this-&gt;table = hb_sanitize_context_t().reference_table&lt;GDEF&gt; (face);</span>
<span class="line-added">420       if (unlikely (this-&gt;table-&gt;is_blacklisted (this-&gt;table.get_blob (), face)))</span>
<span class="line-added">421       {</span>
<span class="line-added">422         hb_blob_destroy (this-&gt;table.get_blob ());</span>
<span class="line-added">423         this-&gt;table = hb_blob_get_empty ();</span>
<span class="line-added">424       }</span>
<span class="line-added">425     }</span>
<span class="line-added">426 </span>
<span class="line-added">427     void fini () { this-&gt;table.destroy (); }</span>
<span class="line-added">428 </span>
<span class="line-added">429     hb_blob_ptr_t&lt;GDEF&gt; table;</span>
<span class="line-added">430   };</span>
<span class="line-added">431 </span>
<span class="line-added">432   unsigned int get_size () const</span>
<span class="line-added">433   {</span>
<span class="line-added">434     return min_size +</span>
<span class="line-added">435            (version.to_int () &gt;= 0x00010002u ? markGlyphSetsDef.static_size : 0) +</span>
<span class="line-added">436            (version.to_int () &gt;= 0x00010003u ? varStore.static_size : 0);</span>
<span class="line-added">437   }</span>
<span class="line-added">438 </span>
<span class="line-added">439   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">440   {</span>
<span class="line-added">441     TRACE_SUBSET (this);</span>
<span class="line-added">442     struct GDEF *out = c-&gt;serializer-&gt;embed (*this);</span>
<span class="line-added">443     if (unlikely (!out)) return_trace (false);</span>
<span class="line-added">444 </span>
<span class="line-added">445     out-&gt;glyphClassDef.serialize_subset (c, this+glyphClassDef, out);</span>
<span class="line-added">446     out-&gt;attachList.set (0);//TODO(subset) serialize_subset (c, this+attachList, out);</span>
<span class="line-added">447     out-&gt;ligCaretList.set (0);//TODO(subset) serialize_subset (c, this+ligCaretList, out);</span>
<span class="line-added">448     out-&gt;markAttachClassDef.serialize_subset (c, this+markAttachClassDef, out);</span>
<span class="line-added">449 </span>
<span class="line-added">450     if (version.to_int () &gt;= 0x00010002u)</span>
<span class="line-added">451       out-&gt;markGlyphSetsDef.set (0);// TODO(subset) serialize_subset (c, this+markGlyphSetsDef, out);</span>
<span class="line-added">452 </span>
<span class="line-added">453     if (version.to_int () &gt;= 0x00010003u)</span>
<span class="line-added">454       out-&gt;varStore.set (0);// TODO(subset) serialize_subset (c, this+varStore, out);</span>
<span class="line-added">455 </span>
<span class="line-added">456     return_trace (true);</span>
<span class="line-added">457   }</span>
<span class="line-added">458 </span>
<span class="line-added">459   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">460   {</span>
<span class="line-added">461     TRACE_SANITIZE (this);</span>
<span class="line-added">462     return_trace (version.sanitize (c) &amp;&amp;</span>
<span class="line-added">463                   likely (version.major == 1) &amp;&amp;</span>
<span class="line-added">464                   glyphClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">465                   attachList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">466                   ligCaretList.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">467                   markAttachClassDef.sanitize (c, this) &amp;&amp;</span>
<span class="line-added">468                   (version.to_int () &lt; 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &amp;&amp;</span>
<span class="line-added">469                   (version.to_int () &lt; 0x00010003u || varStore.sanitize (c, this)));</span>
<span class="line-added">470   }</span>
471 
472   protected:
473   FixedVersion&lt;&gt;version;                /* Version of the GDEF table--currently
474                                          * 0x00010003u */
475   OffsetTo&lt;ClassDef&gt;
476                 glyphClassDef;          /* Offset to class definition table
477                                          * for glyph type--from beginning of
478                                          * GDEF header (may be Null) */
479   OffsetTo&lt;AttachList&gt;
480                 attachList;             /* Offset to list of glyphs with
481                                          * attachment points--from beginning
482                                          * of GDEF header (may be Null) */
483   OffsetTo&lt;LigCaretList&gt;
484                 ligCaretList;           /* Offset to list of positioning points
485                                          * for ligature carets--from beginning
486                                          * of GDEF header (may be Null) */
487   OffsetTo&lt;ClassDef&gt;
488                 markAttachClassDef;     /* Offset to class definition table for
489                                          * mark attachment type--from beginning
490                                          * of GDEF header (may be Null) */
491   OffsetTo&lt;MarkGlyphSets&gt;
492                 markGlyphSetsDef;       /* Offset to the table of mark set
493                                          * definitions--from beginning of GDEF
494                                          * header (may be NULL).  Introduced
495                                          * in version 0x00010002. */
496   LOffsetTo&lt;VariationStore&gt;
497                 varStore;               /* Offset to the table of Item Variation
498                                          * Store--from beginning of GDEF
499                                          * header (may be NULL).  Introduced
500                                          * in version 0x00010003. */
501   public:
502   DEFINE_SIZE_MIN (12);
503 };
504 
<span class="line-added">505 struct GDEF_accelerator_t : GDEF::accelerator_t {};</span>
506 
507 } /* namespace OT */
508 
509 
510 #endif /* HB_OT_LAYOUT_GDEF_TABLE_HH */
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-layout-base-table.hh.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-layout-gpos-table.hh.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
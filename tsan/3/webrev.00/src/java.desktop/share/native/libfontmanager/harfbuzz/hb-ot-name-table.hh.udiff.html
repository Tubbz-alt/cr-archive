<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-maxp-table.hh.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-table.hh.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,42 +25,77 @@</span>
   */
  
  #ifndef HB_OT_NAME_TABLE_HH
  #define HB_OT_NAME_TABLE_HH
  
<span class="udiff-line-modified-removed">- #include &quot;hb-open-type-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-open-type.hh&quot;</span>
<span class="udiff-line-added">+ #include &quot;hb-ot-name-language.hh&quot;</span>
<span class="udiff-line-added">+ #include &quot;hb-aat-layout.hh&quot;</span>
  
  
  namespace OT {
  
  
<span class="udiff-line-added">+ #define entry_score var.u16[0]</span>
<span class="udiff-line-added">+ #define entry_index var.u16[1]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  /*
   * name -- Naming
   * https://docs.microsoft.com/en-us/typography/opentype/spec/name
   */
  #define HB_OT_TAG_name HB_TAG(&#39;n&#39;,&#39;a&#39;,&#39;m&#39;,&#39;e&#39;)
  
<span class="udiff-line-added">+ #define UNSUPPORTED     42</span>
  
  struct NameRecord
  {
<span class="udiff-line-modified-removed">-   static int cmp (const void *pa, const void *pb)</span>
<span class="udiff-line-modified-added">+   hb_language_t language (hb_face_t *face) const</span>
    {
<span class="udiff-line-modified-removed">-     const NameRecord *a = (const NameRecord *) pa;</span>
<span class="udiff-line-modified-removed">-     const NameRecord *b = (const NameRecord *) pb;</span>
<span class="udiff-line-modified-removed">-     int ret;</span>
<span class="udiff-line-modified-removed">-     ret = b-&gt;platformID.cmp (a-&gt;platformID);</span>
<span class="udiff-line-modified-removed">-     if (ret) return ret;</span>
<span class="udiff-line-modified-removed">-     ret = b-&gt;encodingID.cmp (a-&gt;encodingID);</span>
<span class="udiff-line-modified-removed">-     if (ret) return ret;</span>
<span class="udiff-line-modified-removed">-     ret = b-&gt;languageID.cmp (a-&gt;languageID);</span>
<span class="udiff-line-modified-removed">-     if (ret) return ret;</span>
<span class="udiff-line-modified-removed">-     ret = b-&gt;nameID.cmp (a-&gt;nameID);</span>
<span class="udiff-line-modified-removed">-     if (ret) return ret;</span>
<span class="udiff-line-modified-removed">-     return 0;</span>
<span class="udiff-line-modified-added">+     unsigned int p = platformID;</span>
<span class="udiff-line-modified-added">+     unsigned int l = languageID;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (p == 3)</span>
<span class="udiff-line-modified-added">+       return _hb_ot_name_language_for_ms_code (l);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (p == 1)</span>
<span class="udiff-line-modified-added">+       return _hb_ot_name_language_for_mac_code (l);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (p == 0)</span>
<span class="udiff-line-modified-added">+       return _hb_aat_language_get (face, l);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     return HB_LANGUAGE_INVALID;</span>
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
<span class="udiff-line-modified-added">+   uint16_t score () const</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     /* Same order as in cmap::find_best_subtable(). */</span>
<span class="udiff-line-added">+     unsigned int p = platformID;</span>
<span class="udiff-line-added">+     unsigned int e = encodingID;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* 32-bit. */</span>
<span class="udiff-line-added">+     if (p == 3 &amp;&amp; e == 10) return 0;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  6) return 1;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  4) return 2;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* 16-bit. */</span>
<span class="udiff-line-added">+     if (p == 3 &amp;&amp; e ==  1) return 3;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  3) return 4;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  2) return 5;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  1) return 6;</span>
<span class="udiff-line-added">+     if (p == 0 &amp;&amp; e ==  0) return 7;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* Symbol. */</span>
<span class="udiff-line-added">+     if (p == 3 &amp;&amp; e ==  0) return 8;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /* We treat all Mac Latin names as ASCII only. */</span>
<span class="udiff-line-added">+     if (p == 1 &amp;&amp; e ==  0) return 10; /* 10 is magic number :| */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return UNSUPPORTED;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
    {
      TRACE_SANITIZE (this);
      /* We can check from base all the way up to the end of string... */
      return_trace (c-&gt;check_struct (this) &amp;&amp; c-&gt;check_range ((char *) base, (unsigned int) length + offset));
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,66 +108,172 @@</span>
    HBUINT16      offset;         /* String offset from start of storage area (in bytes). */
    public:
    DEFINE_SIZE_STATIC (12);
  };
  
<span class="udiff-line-added">+ static int</span>
<span class="udiff-line-added">+ _hb_ot_name_entry_cmp_key (const void *pa, const void *pb)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="udiff-line-added">+   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Compare by name_id, then language. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (a-&gt;name_id != b-&gt;name_id)</span>
<span class="udiff-line-added">+     return a-&gt;name_id &lt; b-&gt;name_id ? -1 : +1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (a-&gt;language == b-&gt;language) return 0;</span>
<span class="udiff-line-added">+   if (!a-&gt;language) return -1;</span>
<span class="udiff-line-added">+   if (!b-&gt;language) return +1;</span>
<span class="udiff-line-added">+   return strcmp (hb_language_to_string (a-&gt;language),</span>
<span class="udiff-line-added">+                  hb_language_to_string (b-&gt;language));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ static int</span>
<span class="udiff-line-added">+ _hb_ot_name_entry_cmp (const void *pa, const void *pb)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   /* Compare by name_id, then language, then score, then index. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   int v = _hb_ot_name_entry_cmp_key (pa, pb);</span>
<span class="udiff-line-added">+   if (v)</span>
<span class="udiff-line-added">+     return v;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;</span>
<span class="udiff-line-added">+   const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (a-&gt;entry_score != b-&gt;entry_score)</span>
<span class="udiff-line-added">+     return a-&gt;entry_score &lt; b-&gt;entry_score ? -1 : +1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (a-&gt;entry_index != b-&gt;entry_index)</span>
<span class="udiff-line-added">+     return a-&gt;entry_index &lt; b-&gt;entry_index ? -1 : +1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  struct name
  {
<span class="udiff-line-modified-removed">-   static const hb_tag_t tableTag        = HB_OT_TAG_name;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   inline unsigned int get_name (unsigned int platform_id,</span>
<span class="udiff-line-removed">-                                 unsigned int encoding_id,</span>
<span class="udiff-line-removed">-                                 unsigned int language_id,</span>
<span class="udiff-line-removed">-                                 unsigned int name_id,</span>
<span class="udiff-line-removed">-                                 void *buffer,</span>
<span class="udiff-line-removed">-                                 unsigned int buffer_length) const</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     NameRecord key;</span>
<span class="udiff-line-removed">-     key.platformID.set (platform_id);</span>
<span class="udiff-line-removed">-     key.encodingID.set (encoding_id);</span>
<span class="udiff-line-removed">-     key.languageID.set (language_id);</span>
<span class="udiff-line-removed">-     key.nameID.set (name_id);</span>
<span class="udiff-line-removed">-     NameRecord *match = (NameRecord *) bsearch (&amp;key, nameRecord, count, sizeof (nameRecord[0]), NameRecord::cmp);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (!match)</span>
<span class="udiff-line-removed">-       return 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     unsigned int length = MIN (buffer_length, (unsigned int) match-&gt;length);</span>
<span class="udiff-line-removed">-     memcpy (buffer, (char *) this + stringOffset + match-&gt;offset, length);</span>
<span class="udiff-line-removed">-     return length;</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-modified-added">+   static constexpr hb_tag_t tableTag = HB_OT_TAG_name;</span>
  
<span class="udiff-line-modified-removed">-   inline unsigned int get_size (void) const</span>
<span class="udiff-line-modified-removed">-   { return min_size + count * nameRecord[0].min_size; }</span>
<span class="udiff-line-modified-added">+   unsigned int get_size () const</span>
<span class="udiff-line-modified-added">+   { return min_size + count * nameRecordZ.item_size; }</span>
  
<span class="udiff-line-modified-removed">-   inline bool sanitize_records (hb_sanitize_context_t *c) const {</span>
<span class="udiff-line-modified-added">+   bool sanitize_records (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-added">+   {</span>
      TRACE_SANITIZE (this);
<span class="udiff-line-modified-removed">-     char *string_pool = (char *) this + stringOffset;</span>
<span class="udiff-line-modified-added">+     const void *string_pool = (this+stringOffset).arrayZ;</span>
      unsigned int _count = count;
<span class="udiff-line-added">+     /* Move to run-time?! */</span>
      for (unsigned int i = 0; i &lt; _count; i++)
<span class="udiff-line-modified-removed">-       if (!nameRecord[i].sanitize (c, string_pool)) return_trace (false);</span>
<span class="udiff-line-modified-added">+       if (!nameRecordZ[i].sanitize (c, string_pool)) return_trace (false);</span>
      return_trace (true);
    }
  
<span class="udiff-line-modified-removed">-   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="udiff-line-modified-added">+   bool sanitize (hb_sanitize_context_t *c) const</span>
    {
      TRACE_SANITIZE (this);
      return_trace (c-&gt;check_struct (this) &amp;&amp;
                    likely (format == 0 || format == 1) &amp;&amp;
<span class="udiff-line-modified-removed">-                   c-&gt;check_array (nameRecord, nameRecord[0].static_size, count) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                   sanitize_records (c));</span>
<span class="udiff-line-modified-added">+                   c-&gt;check_array (nameRecordZ.arrayZ, count) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                   c-&gt;check_range (this, stringOffset));</span>
    }
  
<span class="udiff-line-added">+   struct accelerator_t</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     void init (hb_face_t *face)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       this-&gt;table = hb_sanitize_context_t().reference_table&lt;name&gt; (face);</span>
<span class="udiff-line-added">+       assert (this-&gt;table.get_length () &gt;= this-&gt;table-&gt;stringOffset);</span>
<span class="udiff-line-added">+       this-&gt;pool = (const char *) (const void *) (this-&gt;table+this-&gt;table-&gt;stringOffset);</span>
<span class="udiff-line-added">+       this-&gt;pool_len = this-&gt;table.get_length () - this-&gt;table-&gt;stringOffset;</span>
<span class="udiff-line-added">+       const hb_array_t&lt;const NameRecord&gt; all_names (this-&gt;table-&gt;nameRecordZ.arrayZ,</span>
<span class="udiff-line-added">+                                                     this-&gt;table-&gt;count);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       this-&gt;names.init ();</span>
<span class="udiff-line-added">+       this-&gt;names.alloc (all_names.length);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       for (unsigned int i = 0; i &lt; all_names.length; i++)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         hb_ot_name_entry_t *entry = this-&gt;names.push ();</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         entry-&gt;name_id = all_names[i].nameID;</span>
<span class="udiff-line-added">+         entry-&gt;language = all_names[i].language (face);</span>
<span class="udiff-line-added">+         entry-&gt;entry_score =  all_names[i].score ();</span>
<span class="udiff-line-added">+         entry-&gt;entry_index = i;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       this-&gt;names.qsort (_hb_ot_name_entry_cmp);</span>
<span class="udiff-line-added">+       /* Walk and pick best only for each name_id,language pair,</span>
<span class="udiff-line-added">+        * while dropping unsupported encodings. */</span>
<span class="udiff-line-added">+       unsigned int j = 0;</span>
<span class="udiff-line-added">+       for (unsigned int i = 0; i &lt; this-&gt;names.length; i++)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         if (this-&gt;names[i].entry_score == UNSUPPORTED ||</span>
<span class="udiff-line-added">+             this-&gt;names[i].language == HB_LANGUAGE_INVALID)</span>
<span class="udiff-line-added">+           continue;</span>
<span class="udiff-line-added">+         if (i &amp;&amp;</span>
<span class="udiff-line-added">+             this-&gt;names[i - 1].name_id  == this-&gt;names[i].name_id &amp;&amp;</span>
<span class="udiff-line-added">+             this-&gt;names[i - 1].language == this-&gt;names[i].language)</span>
<span class="udiff-line-added">+           continue;</span>
<span class="udiff-line-added">+         this-&gt;names[j++] = this-&gt;names[i];</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+       this-&gt;names.resize (j);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     void fini ()</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       this-&gt;names.fini ();</span>
<span class="udiff-line-added">+       this-&gt;table.destroy ();</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     int get_index (hb_ot_name_id_t   name_id,</span>
<span class="udiff-line-added">+                           hb_language_t     language,</span>
<span class="udiff-line-added">+                           unsigned int     *width=nullptr) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       const hb_ot_name_entry_t key = {name_id, {0}, language};</span>
<span class="udiff-line-added">+       const hb_ot_name_entry_t *entry = (const hb_ot_name_entry_t *)</span>
<span class="udiff-line-added">+                                         hb_bsearch (&amp;key,</span>
<span class="udiff-line-added">+                                                     (const hb_ot_name_entry_t *) this-&gt;names,</span>
<span class="udiff-line-added">+                                                     this-&gt;names.length,</span>
<span class="udiff-line-added">+                                                     sizeof (key),</span>
<span class="udiff-line-added">+                                                     _hb_ot_name_entry_cmp_key);</span>
<span class="udiff-line-added">+       if (!entry)</span>
<span class="udiff-line-added">+         return -1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if (width)</span>
<span class="udiff-line-added">+         *width = entry-&gt;entry_score &lt; 10 ? 2 : 1;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       return entry-&gt;entry_index;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     hb_bytes_t get_name (unsigned int idx) const</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       const hb_array_t&lt;const NameRecord&gt; all_names (table-&gt;nameRecordZ.arrayZ, table-&gt;count);</span>
<span class="udiff-line-added">+       const NameRecord &amp;record = all_names[idx];</span>
<span class="udiff-line-added">+       const hb_bytes_t string_pool (pool, pool_len);</span>
<span class="udiff-line-added">+       return string_pool.sub_array (record.offset, record.length);</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private:</span>
<span class="udiff-line-added">+     const char *pool;</span>
<span class="udiff-line-added">+     unsigned int pool_len;</span>
<span class="udiff-line-added">+     public:</span>
<span class="udiff-line-added">+     hb_blob_ptr_t&lt;name&gt; table;</span>
<span class="udiff-line-added">+     hb_vector_t&lt;hb_ot_name_entry_t&gt; names;</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ </span>
    /* We only implement format 0 for now. */
    HBUINT16      format;                 /* Format selector (=0/1). */
    HBUINT16      count;                  /* Number of name records. */
<span class="udiff-line-modified-removed">-   Offset16      stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="udiff-line-modified-removed">-   NameRecord    nameRecord[VAR];        /* The name records where count is the number of records. */</span>
<span class="udiff-line-modified-added">+   NNOffsetTo&lt;UnsizedArrayOf&lt;HBUINT8&gt; &gt;</span>
<span class="udiff-line-modified-added">+                 stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="udiff-line-added">+   UnsizedArrayOf&lt;NameRecord&gt;</span>
<span class="udiff-line-added">+                 nameRecordZ;            /* The name records where count is the number of records. */</span>
    public:
<span class="udiff-line-modified-removed">-   DEFINE_SIZE_ARRAY (6, nameRecord);</span>
<span class="udiff-line-modified-added">+   DEFINE_SIZE_ARRAY (6, nameRecordZ);</span>
  };
  
<span class="udiff-line-added">+ struct name_accelerator_t : name::accelerator_t {};</span>
  
  } /* namespace OT */
  
  
  #endif /* HB_OT_NAME_TABLE_HH */
</pre>
<center><a href="hb-ot-maxp-table.hh.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-os2-table.hh.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
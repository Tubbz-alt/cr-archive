<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-default.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-hebrew.cc.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-hangul.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
 28 
 29 
 30 /* Hangul shaper */
 31 
 32 
 33 /* Same order as the feature array below */
 34 enum {
 35   _JMO,
 36 
 37   LJMO,
 38   VJMO,
 39   TJMO,
 40 
 41   FIRST_HANGUL_FEATURE = LJMO,
 42   HANGUL_FEATURE_COUNT = TJMO + 1
 43 };
 44 
 45 static const hb_tag_t hangul_features[HANGUL_FEATURE_COUNT] =
 46 {
 47   HB_TAG_NONE,
 48   HB_TAG(&#39;l&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 49   HB_TAG(&#39;v&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 50   HB_TAG(&#39;t&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;)
 51 };
 52 
 53 static void
 54 collect_features_hangul (hb_ot_shape_planner_t *plan)
 55 {
 56   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 57 
 58   for (unsigned int i = FIRST_HANGUL_FEATURE; i &lt; HANGUL_FEATURE_COUNT; i++)
<span class="line-modified"> 59     map-&gt;add_feature (hangul_features[i], 1, F_NONE);</span>
 60 }
 61 
 62 static void
 63 override_features_hangul (hb_ot_shape_planner_t *plan)
 64 {
 65   /* Uniscribe does not apply &#39;calt&#39; for Hangul, and certain fonts
 66    * (Noto Sans CJK, Source Sans Han, etc) apply all of jamo lookups
 67    * in calt, which is not desirable. */
<span class="line-modified"> 68   plan-&gt;map.add_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), 0, F_GLOBAL);</span>
 69 }
 70 
 71 struct hangul_shape_plan_t
 72 {
<span class="line-removed"> 73   ASSERT_POD ();</span>
<span class="line-removed"> 74 </span>
 75   hb_mask_t mask_array[HANGUL_FEATURE_COUNT];
 76 };
 77 
 78 static void *
 79 data_create_hangul (const hb_ot_shape_plan_t *plan)
 80 {
 81   hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) calloc (1, sizeof (hangul_shape_plan_t));
 82   if (unlikely (!hangul_plan))
 83     return nullptr;
 84 
 85   for (unsigned int i = 0; i &lt; HANGUL_FEATURE_COUNT; i++)
 86     hangul_plan-&gt;mask_array[i] = plan-&gt;map.get_1_mask (hangul_features[i]);
 87 
 88   return hangul_plan;
 89 }
 90 
 91 static void
 92 data_destroy_hangul (void *data)
 93 {
 94   free (data);
</pre>
<hr />
<pre>
111 #define isCombinedS(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), SBase, SBase+SCount-1))
112 
113 #define isL(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1100u, 0x115Fu, 0xA960u, 0xA97Cu))
114 #define isV(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1160u, 0x11A7u, 0xD7B0u, 0xD7C6u))
115 #define isT(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x11A8u, 0x11FFu, 0xD7CBu, 0xD7FBu))
116 
117 #define isHangulTone(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), 0x302Eu, 0x302Fu))
118 
119 /* buffer var allocations */
120 #define hangul_shaping_feature() complex_var_u8_0() /* hangul jamo shaping feature */
121 
122 static bool
123 is_zero_width_char (hb_font_t *font,
124                     hb_codepoint_t unicode)
125 {
126   hb_codepoint_t glyph;
127   return hb_font_get_glyph (font, unicode, 0, &amp;glyph) &amp;&amp; hb_font_get_glyph_h_advance (font, glyph) == 0;
128 }
129 
130 static void
<span class="line-modified">131 preprocess_text_hangul (const hb_ot_shape_plan_t *plan,</span>
132                         hb_buffer_t              *buffer,
133                         hb_font_t                *font)
134 {
135   HB_BUFFER_ALLOCATE_VAR (buffer, hangul_shaping_feature);
136 
137   /* Hangul syllables come in two shapes: LV, and LVT.  Of those:
138    *
139    *   - LV can be precomposed, or decomposed.  Lets call those
140    *     &lt;LV&gt; and &lt;L,V&gt;,
141    *   - LVT can be fully precomposed, partically precomposed, or
142    *     fully decomposed.  Ie. &lt;LVT&gt;, &lt;LV,T&gt;, or &lt;L,V,T&gt;.
143    *
144    * The composition / decomposition is mechanical.  However, not
145    * all &lt;L,V&gt; sequences compose, and not all &lt;LV,T&gt; sequences
146    * compose.
147    *
148    * Here are the specifics:
149    *
150    *   - &lt;L&gt;: U+1100..115F, U+A960..A97F
151    *   - &lt;V&gt;: U+1160..11A7, U+D7B0..D7C7
</pre>
<hr />
<pre>
328           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
329       }
330 
331       /* Otherwise, decompose if font doesn&#39;t support &lt;LV&gt; or &lt;LVT&gt;,
332        * or if having non-combining &lt;LV,T&gt;.  Note that we already handled
333        * combining &lt;LV,T&gt; above. */
334       if (!has_glyph ||
335           (!tindex &amp;&amp;
336            buffer-&gt;idx + 1 &lt; count &amp;&amp;
337            isT (buffer-&gt;cur(+1).codepoint)))
338       {
339         hb_codepoint_t decomposed[3] = {LBase + lindex,
340                                         VBase + vindex,
341                                         TBase + tindex};
342         if (font-&gt;has_glyph (decomposed[0]) &amp;&amp;
343             font-&gt;has_glyph (decomposed[1]) &amp;&amp;
344             (!tindex || font-&gt;has_glyph (decomposed[2])))
345         {
346           unsigned int s_len = tindex ? 3 : 2;
347           buffer-&gt;replace_glyphs (1, s_len, decomposed);
<span class="line-removed">348           if (unlikely (!buffer-&gt;successful))</span>
<span class="line-removed">349             return;</span>
<span class="line-removed">350 </span>
<span class="line-removed">351           /* We decomposed S: apply jamo features to the individual glyphs</span>
<span class="line-removed">352            * that are now in buffer-&gt;out_info.</span>
<span class="line-removed">353            */</span>
<span class="line-removed">354           hb_glyph_info_t *info = buffer-&gt;out_info;</span>
355 
356           /* If we decomposed an LV because of a non-combining T following,
357            * we want to include this T in the syllable.
358            */
359           if (has_glyph &amp;&amp; !tindex)
360           {
361             buffer-&gt;next_glyph ();
362             s_len++;
363           }








364           end = start + s_len;
365 
366           unsigned int i = start;
367           info[i++].hangul_shaping_feature() = LJMO;
368           info[i++].hangul_shaping_feature() = VJMO;
369           if (i &lt; end)
370             info[i++].hangul_shaping_feature() = TJMO;

371           if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
372             buffer-&gt;merge_out_clusters (start, end);
373           continue;
374         }
375         else if ((!tindex &amp;&amp; buffer-&gt;idx + 1 &lt; count &amp;&amp; isT (buffer-&gt;cur(+1).codepoint)))
376           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
377       }
378 
379       if (has_glyph)
380       {
381         /* We didn&#39;t decompose the S, so just advance past it. */
382         end = start + 1;
383         buffer-&gt;next_glyph ();
384         continue;
385       }
386     }
387 
388     /* Didn&#39;t find a recognizable syllable, so we leave end &lt;= start;
389      * this will prevent tone-mark reordering happening.
390      */
</pre>
<hr />
<pre>
407     for (unsigned int i = 0; i &lt; count; i++, info++)
408       info-&gt;mask |= hangul_plan-&gt;mask_array[info-&gt;hangul_shaping_feature()];
409   }
410 
411   HB_BUFFER_DEALLOCATE_VAR (buffer, hangul_shaping_feature);
412 }
413 
414 
415 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hangul =
416 {
417   collect_features_hangul,
418   override_features_hangul,
419   data_create_hangul,
420   data_destroy_hangul,
421   preprocess_text_hangul,
422   nullptr, /* postprocess_glyphs */
423   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,
424   nullptr, /* decompose */
425   nullptr, /* compose */
426   setup_masks_hangul,
<span class="line-modified">427   nullptr, /* disable_otl */</span>
428   nullptr, /* reorder_marks */
429   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
430   false, /* fallback_position */
431 };
</pre>
</td>
<td>
<hr />
<pre>
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
<span class="line-modified"> 27 #include &quot;hb-ot-shape-complex.hh&quot;</span>
 28 
 29 
 30 /* Hangul shaper */
 31 
 32 
 33 /* Same order as the feature array below */
 34 enum {
 35   _JMO,
 36 
 37   LJMO,
 38   VJMO,
 39   TJMO,
 40 
 41   FIRST_HANGUL_FEATURE = LJMO,
 42   HANGUL_FEATURE_COUNT = TJMO + 1
 43 };
 44 
 45 static const hb_tag_t hangul_features[HANGUL_FEATURE_COUNT] =
 46 {
 47   HB_TAG_NONE,
 48   HB_TAG(&#39;l&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 49   HB_TAG(&#39;v&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;),
 50   HB_TAG(&#39;t&#39;,&#39;j&#39;,&#39;m&#39;,&#39;o&#39;)
 51 };
 52 
 53 static void
 54 collect_features_hangul (hb_ot_shape_planner_t *plan)
 55 {
 56   hb_ot_map_builder_t *map = &amp;plan-&gt;map;
 57 
 58   for (unsigned int i = FIRST_HANGUL_FEATURE; i &lt; HANGUL_FEATURE_COUNT; i++)
<span class="line-modified"> 59     map-&gt;add_feature (hangul_features[i]);</span>
 60 }
 61 
 62 static void
 63 override_features_hangul (hb_ot_shape_planner_t *plan)
 64 {
 65   /* Uniscribe does not apply &#39;calt&#39; for Hangul, and certain fonts
 66    * (Noto Sans CJK, Source Sans Han, etc) apply all of jamo lookups
 67    * in calt, which is not desirable. */
<span class="line-modified"> 68   plan-&gt;map.disable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
 69 }
 70 
 71 struct hangul_shape_plan_t
 72 {


 73   hb_mask_t mask_array[HANGUL_FEATURE_COUNT];
 74 };
 75 
 76 static void *
 77 data_create_hangul (const hb_ot_shape_plan_t *plan)
 78 {
 79   hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) calloc (1, sizeof (hangul_shape_plan_t));
 80   if (unlikely (!hangul_plan))
 81     return nullptr;
 82 
 83   for (unsigned int i = 0; i &lt; HANGUL_FEATURE_COUNT; i++)
 84     hangul_plan-&gt;mask_array[i] = plan-&gt;map.get_1_mask (hangul_features[i]);
 85 
 86   return hangul_plan;
 87 }
 88 
 89 static void
 90 data_destroy_hangul (void *data)
 91 {
 92   free (data);
</pre>
<hr />
<pre>
109 #define isCombinedS(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), SBase, SBase+SCount-1))
110 
111 #define isL(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1100u, 0x115Fu, 0xA960u, 0xA97Cu))
112 #define isV(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x1160u, 0x11A7u, 0xD7B0u, 0xD7C6u))
113 #define isT(u) (hb_in_ranges&lt;hb_codepoint_t&gt; ((u), 0x11A8u, 0x11FFu, 0xD7CBu, 0xD7FBu))
114 
115 #define isHangulTone(u) (hb_in_range&lt;hb_codepoint_t&gt; ((u), 0x302Eu, 0x302Fu))
116 
117 /* buffer var allocations */
118 #define hangul_shaping_feature() complex_var_u8_0() /* hangul jamo shaping feature */
119 
120 static bool
121 is_zero_width_char (hb_font_t *font,
122                     hb_codepoint_t unicode)
123 {
124   hb_codepoint_t glyph;
125   return hb_font_get_glyph (font, unicode, 0, &amp;glyph) &amp;&amp; hb_font_get_glyph_h_advance (font, glyph) == 0;
126 }
127 
128 static void
<span class="line-modified">129 preprocess_text_hangul (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
130                         hb_buffer_t              *buffer,
131                         hb_font_t                *font)
132 {
133   HB_BUFFER_ALLOCATE_VAR (buffer, hangul_shaping_feature);
134 
135   /* Hangul syllables come in two shapes: LV, and LVT.  Of those:
136    *
137    *   - LV can be precomposed, or decomposed.  Lets call those
138    *     &lt;LV&gt; and &lt;L,V&gt;,
139    *   - LVT can be fully precomposed, partically precomposed, or
140    *     fully decomposed.  Ie. &lt;LVT&gt;, &lt;LV,T&gt;, or &lt;L,V,T&gt;.
141    *
142    * The composition / decomposition is mechanical.  However, not
143    * all &lt;L,V&gt; sequences compose, and not all &lt;LV,T&gt; sequences
144    * compose.
145    *
146    * Here are the specifics:
147    *
148    *   - &lt;L&gt;: U+1100..115F, U+A960..A97F
149    *   - &lt;V&gt;: U+1160..11A7, U+D7B0..D7C7
</pre>
<hr />
<pre>
326           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
327       }
328 
329       /* Otherwise, decompose if font doesn&#39;t support &lt;LV&gt; or &lt;LVT&gt;,
330        * or if having non-combining &lt;LV,T&gt;.  Note that we already handled
331        * combining &lt;LV,T&gt; above. */
332       if (!has_glyph ||
333           (!tindex &amp;&amp;
334            buffer-&gt;idx + 1 &lt; count &amp;&amp;
335            isT (buffer-&gt;cur(+1).codepoint)))
336       {
337         hb_codepoint_t decomposed[3] = {LBase + lindex,
338                                         VBase + vindex,
339                                         TBase + tindex};
340         if (font-&gt;has_glyph (decomposed[0]) &amp;&amp;
341             font-&gt;has_glyph (decomposed[1]) &amp;&amp;
342             (!tindex || font-&gt;has_glyph (decomposed[2])))
343         {
344           unsigned int s_len = tindex ? 3 : 2;
345           buffer-&gt;replace_glyphs (1, s_len, decomposed);







346 
347           /* If we decomposed an LV because of a non-combining T following,
348            * we want to include this T in the syllable.
349            */
350           if (has_glyph &amp;&amp; !tindex)
351           {
352             buffer-&gt;next_glyph ();
353             s_len++;
354           }
<span class="line-added">355 </span>
<span class="line-added">356           if (unlikely (!buffer-&gt;successful))</span>
<span class="line-added">357             return;</span>
<span class="line-added">358 </span>
<span class="line-added">359           /* We decomposed S: apply jamo features to the individual glyphs</span>
<span class="line-added">360            * that are now in buffer-&gt;out_info.</span>
<span class="line-added">361            */</span>
<span class="line-added">362           hb_glyph_info_t *info = buffer-&gt;out_info;</span>
363           end = start + s_len;
364 
365           unsigned int i = start;
366           info[i++].hangul_shaping_feature() = LJMO;
367           info[i++].hangul_shaping_feature() = VJMO;
368           if (i &lt; end)
369             info[i++].hangul_shaping_feature() = TJMO;
<span class="line-added">370 </span>
371           if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
372             buffer-&gt;merge_out_clusters (start, end);
373           continue;
374         }
375         else if ((!tindex &amp;&amp; buffer-&gt;idx + 1 &lt; count &amp;&amp; isT (buffer-&gt;cur(+1).codepoint)))
376           buffer-&gt;unsafe_to_break (buffer-&gt;idx, buffer-&gt;idx + 2); /* Mark unsafe between LV and T. */
377       }
378 
379       if (has_glyph)
380       {
381         /* We didn&#39;t decompose the S, so just advance past it. */
382         end = start + 1;
383         buffer-&gt;next_glyph ();
384         continue;
385       }
386     }
387 
388     /* Didn&#39;t find a recognizable syllable, so we leave end &lt;= start;
389      * this will prevent tone-mark reordering happening.
390      */
</pre>
<hr />
<pre>
407     for (unsigned int i = 0; i &lt; count; i++, info++)
408       info-&gt;mask |= hangul_plan-&gt;mask_array[info-&gt;hangul_shaping_feature()];
409   }
410 
411   HB_BUFFER_DEALLOCATE_VAR (buffer, hangul_shaping_feature);
412 }
413 
414 
415 const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hangul =
416 {
417   collect_features_hangul,
418   override_features_hangul,
419   data_create_hangul,
420   data_destroy_hangul,
421   preprocess_text_hangul,
422   nullptr, /* postprocess_glyphs */
423   HB_OT_SHAPE_NORMALIZATION_MODE_NONE,
424   nullptr, /* decompose */
425   nullptr, /* compose */
426   setup_masks_hangul,
<span class="line-modified">427   HB_TAG_NONE, /* gpos_tag */</span>
428   nullptr, /* reorder_marks */
429   HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,
430   false, /* fallback_position */
431 };
</pre>
</td>
</tr>
</table>
<center><a href="hb-ot-shape-complex-default.cc.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-hebrew.cc.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
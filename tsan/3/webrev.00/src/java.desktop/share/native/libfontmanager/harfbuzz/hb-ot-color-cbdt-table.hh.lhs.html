<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-color-cbdt-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2016  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Seigo Nonaka
 25  */
 26 
 27 #ifndef HB_OT_COLOR_CBDT_TABLE_HH
 28 #define HB_OT_COLOR_CBDT_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 
 32 /*
 33  * CBLC -- Color Bitmap Location
 34  * https://docs.microsoft.com/en-us/typography/opentype/spec/cblc
 35  * https://docs.microsoft.com/en-us/typography/opentype/spec/eblc
 36  * CBDT -- Color Bitmap Data
 37  * https://docs.microsoft.com/en-us/typography/opentype/spec/cbdt
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/ebdt
 39  */
 40 #define HB_OT_TAG_CBLC HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;L&#39;,&#39;C&#39;)
 41 #define HB_OT_TAG_CBDT HB_TAG(&#39;C&#39;,&#39;B&#39;,&#39;D&#39;,&#39;T&#39;)
 42 
 43 
 44 namespace OT {
 45 
 46 struct SmallGlyphMetrics
 47 {
<a name="2" id="anc2"></a><span class="line-modified"> 48   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 49   {
 50     TRACE_SANITIZE (this);
 51     return_trace (c-&gt;check_struct (this));
 52   }
 53 
<a name="3" id="anc3"></a><span class="line-modified"> 54   inline void get_extents (hb_glyph_extents_t *extents) const</span>
 55   {
 56     extents-&gt;x_bearing = bearingX;
 57     extents-&gt;y_bearing = bearingY;
 58     extents-&gt;width = width;
<a name="4" id="anc4"></a><span class="line-modified"> 59     extents-&gt;height = -height;</span>
 60   }
 61 
 62   HBUINT8       height;
 63   HBUINT8       width;
 64   HBINT8        bearingX;
 65   HBINT8        bearingY;
 66   HBUINT8       advance;
 67   public:
 68   DEFINE_SIZE_STATIC(5);
 69 };
 70 
 71 struct BigGlyphMetrics : SmallGlyphMetrics
 72 {
 73   HBINT8        vertBearingX;
 74   HBINT8        vertBearingY;
 75   HBUINT8       vertAdvance;
 76   public:
 77   DEFINE_SIZE_STATIC(8);
 78 };
 79 
 80 struct SBitLineMetrics
 81 {
<a name="5" id="anc5"></a><span class="line-modified"> 82   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 83   {
 84     TRACE_SANITIZE (this);
 85     return_trace (c-&gt;check_struct (this));
 86   }
 87 
 88   HBINT8        ascender;
 89   HBINT8        decender;
 90   HBUINT8       widthMax;
 91   HBINT8        caretSlopeNumerator;
 92   HBINT8        caretSlopeDenominator;
 93   HBINT8        caretOffset;
 94   HBINT8        minOriginSB;
 95   HBINT8        minAdvanceSB;
 96   HBINT8        maxBeforeBL;
 97   HBINT8        minAfterBL;
 98   HBINT8        padding1;
 99   HBINT8        padding2;
100   public:
101   DEFINE_SIZE_STATIC(12);
102 };
103 
104 
105 /*
106  * Index Subtables.
107  */
108 
109 struct IndexSubtableHeader
110 {
<a name="6" id="anc6"></a><span class="line-modified">111   inline bool sanitize (hb_sanitize_context_t *c) const</span>
112   {
113     TRACE_SANITIZE (this);
114     return_trace (c-&gt;check_struct (this));
115   }
116 
117   HBUINT16      indexFormat;
118   HBUINT16      imageFormat;
119   HBUINT32      imageDataOffset;
120   public:
121   DEFINE_SIZE_STATIC(8);
122 };
123 
124 template &lt;typename OffsetType&gt;
125 struct IndexSubtableFormat1Or3
126 {
<a name="7" id="anc7"></a><span class="line-modified">127   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
128   {
129     TRACE_SANITIZE (this);
130     return_trace (c-&gt;check_struct (this) &amp;&amp;
<a name="8" id="anc8"></a><span class="line-modified">131                   c-&gt;check_array (offsetArrayZ, offsetArrayZ[0].static_size, glyph_count + 1));</span>
132   }
133 
134   bool get_image_data (unsigned int idx,
135                        unsigned int *offset,
136                        unsigned int *length) const
137   {
138     if (unlikely (offsetArrayZ[idx + 1] &lt;= offsetArrayZ[idx]))
139       return false;
140 
141     *offset = header.imageDataOffset + offsetArrayZ[idx];
142     *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];
143     return true;
144   }
145 
146   IndexSubtableHeader   header;
<a name="9" id="anc9"></a><span class="line-modified">147   Offset&lt;OffsetType&gt;    offsetArrayZ[VAR];</span>

148   public:
149   DEFINE_SIZE_ARRAY(8, offsetArrayZ);
150 };
151 
152 struct IndexSubtableFormat1 : IndexSubtableFormat1Or3&lt;HBUINT32&gt; {};
153 struct IndexSubtableFormat3 : IndexSubtableFormat1Or3&lt;HBUINT16&gt; {};
154 
155 struct IndexSubtable
156 {
<a name="10" id="anc10"></a><span class="line-modified">157   inline bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const</span>
158   {
159     TRACE_SANITIZE (this);
160     if (!u.header.sanitize (c)) return_trace (false);
161     switch (u.header.indexFormat) {
162     case 1: return_trace (u.format1.sanitize (c, glyph_count));
163     case 3: return_trace (u.format3.sanitize (c, glyph_count));
164     default:return_trace (true);
165     }
166   }
167 
<a name="11" id="anc11"></a><span class="line-modified">168   inline bool get_extents (hb_glyph_extents_t *extents) const</span>
169   {
170     switch (u.header.indexFormat) {
171     case 2: case 5: /* TODO */
172     case 1: case 3: case 4: /* Variable-metrics formats do not have metrics here. */
173     default:return (false);
174     }
175   }
176 
177   bool get_image_data (unsigned int idx,
178                        unsigned int *offset,
179                        unsigned int *length,
180                        unsigned int *format) const
181   {
182     *format = u.header.imageFormat;
183     switch (u.header.indexFormat) {
184     case 1: return u.format1.get_image_data (idx, offset, length);
185     case 3: return u.format3.get_image_data (idx, offset, length);
186     default: return false;
187     }
188   }
189 
190   protected:
191   union {
192   IndexSubtableHeader   header;
193   IndexSubtableFormat1  format1;
194   IndexSubtableFormat3  format3;
195   /* TODO: Format 2, 4, 5. */
196   } u;
197   public:
198   DEFINE_SIZE_UNION (8, header);
199 };
200 
201 struct IndexSubtableRecord
202 {
<a name="12" id="anc12"></a><span class="line-modified">203   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
204   {
205     TRACE_SANITIZE (this);
206     return_trace (c-&gt;check_struct (this) &amp;&amp;
207                   firstGlyphIndex &lt;= lastGlyphIndex &amp;&amp;
<a name="13" id="anc13"></a><span class="line-modified">208                   offsetToSubtable.sanitize (c, this, lastGlyphIndex - firstGlyphIndex + 1));</span>
209   }
210 
<a name="14" id="anc14"></a><span class="line-modified">211   inline bool get_extents (hb_glyph_extents_t *extents) const</span>

212   {
<a name="15" id="anc15"></a><span class="line-modified">213     return (this+offsetToSubtable).get_extents (extents);</span>
214   }
215 
<a name="16" id="anc16"></a><span class="line-modified">216   bool get_image_data (unsigned int gid,</span>

217                        unsigned int *offset,
218                        unsigned int *length,
219                        unsigned int *format) const
220   {
<a name="17" id="anc17"></a><span class="line-modified">221     if (gid &lt; firstGlyphIndex || gid &gt; lastGlyphIndex)</span>
<span class="line-modified">222     {</span>
<span class="line-removed">223       return false;</span>
<span class="line-removed">224     }</span>
<span class="line-removed">225     return (this+offsetToSubtable).get_image_data (gid - firstGlyphIndex,</span>
226                                                    offset, length, format);
227   }
228 
229   GlyphID                       firstGlyphIndex;
230   GlyphID                       lastGlyphIndex;
231   LOffsetTo&lt;IndexSubtable&gt;      offsetToSubtable;
232   public:
233   DEFINE_SIZE_STATIC(8);
234 };
235 
236 struct IndexSubtableArray
237 {
238   friend struct CBDT;
239 
<a name="18" id="anc18"></a><span class="line-modified">240   inline bool sanitize (hb_sanitize_context_t *c, unsigned int count) const</span>
241   {
242     TRACE_SANITIZE (this);
<a name="19" id="anc19"></a><span class="line-modified">243     if (unlikely (!c-&gt;check_array (&amp;indexSubtablesZ, indexSubtablesZ[0].static_size, count)))</span>
<span class="line-removed">244       return_trace (false);</span>
<span class="line-removed">245     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-removed">246       if (unlikely (!indexSubtablesZ[i].sanitize (c, this)))</span>
<span class="line-removed">247         return_trace (false);</span>
<span class="line-removed">248     return_trace (true);</span>
249   }
250 
251   public:
252   const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const
253   {
254     for (unsigned int i = 0; i &lt; numTables; ++i)
255     {
256       unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;
257       unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;
<a name="20" id="anc20"></a><span class="line-modified">258       if (firstGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= lastGlyphIndex) {</span>
259         return &amp;indexSubtablesZ[i];
<a name="21" id="anc21"></a><span class="line-removed">260       }</span>
261     }
262     return nullptr;
263   }
264 
265   protected:
<a name="22" id="anc22"></a><span class="line-modified">266   IndexSubtableRecord   indexSubtablesZ[VAR];</span>
<span class="line-removed">267   public:</span>
<span class="line-removed">268   DEFINE_SIZE_ARRAY(0, indexSubtablesZ);</span>
269 };
270 
271 struct BitmapSizeTable
272 {
273   friend struct CBLC;
274   friend struct CBDT;
275 
<a name="23" id="anc23"></a><span class="line-modified">276   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>
277   {
278     TRACE_SANITIZE (this);
279     return_trace (c-&gt;check_struct (this) &amp;&amp;
280                   indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &amp;&amp;
<a name="24" id="anc24"></a><span class="line-removed">281                   c-&gt;check_range (&amp;(base+indexSubtableArrayOffset), indexTablesSize) &amp;&amp;</span>
282                   horizontal.sanitize (c) &amp;&amp;
283                   vertical.sanitize (c));
284   }
285 
<a name="25" id="anc25"></a><span class="line-modified">286   const IndexSubtableRecord *find_table (hb_codepoint_t glyph, const void *base) const</span>


287   {
<a name="26" id="anc26"></a>
288     return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);
289   }
290 
291   protected:
<a name="27" id="anc27"></a><span class="line-modified">292   LOffsetTo&lt;IndexSubtableArray&gt;</span>
293                         indexSubtableArrayOffset;
294   HBUINT32              indexTablesSize;
295   HBUINT32              numberOfIndexSubtables;
296   HBUINT32              colorRef;
297   SBitLineMetrics       horizontal;
298   SBitLineMetrics       vertical;
299   GlyphID               startGlyphIndex;
300   GlyphID               endGlyphIndex;
301   HBUINT8               ppemX;
302   HBUINT8               ppemY;
303   HBUINT8               bitDepth;
304   HBINT8                flags;
305   public:
306   DEFINE_SIZE_STATIC(48);
307 };
308 
309 
310 /*
311  * Glyph Bitmap Data Formats.
312  */
313 
314 struct GlyphBitmapDataFormat17
315 {
316   SmallGlyphMetrics     glyphMetrics;
317   LArrayOf&lt;HBUINT8&gt;     data;
318   public:
319   DEFINE_SIZE_ARRAY(9, data);
320 };
321 
322 struct GlyphBitmapDataFormat18
323 {
324   BigGlyphMetrics       glyphMetrics;
325   LArrayOf&lt;HBUINT8&gt;     data;
326   public:
327   DEFINE_SIZE_ARRAY(12, data);
328 };
329 
330 struct GlyphBitmapDataFormat19
331 {
332   LArrayOf&lt;HBUINT8&gt;     data;
333   public:
334   DEFINE_SIZE_ARRAY(4, data);
335 };
336 
337 struct CBLC
338 {
339   friend struct CBDT;
340 
<a name="28" id="anc28"></a><span class="line-modified">341   static const hb_tag_t tableTag = HB_OT_TAG_CBLC;</span>
342 
<a name="29" id="anc29"></a><span class="line-modified">343   inline bool sanitize (hb_sanitize_context_t *c) const</span>
344   {
345     TRACE_SANITIZE (this);
346     return_trace (c-&gt;check_struct (this) &amp;&amp;
347                   likely (version.major == 2 || version.major == 3) &amp;&amp;
348                   sizeTables.sanitize (c, this));
349   }
350 
351   protected:
<a name="30" id="anc30"></a><span class="line-modified">352   const IndexSubtableRecord *find_table (hb_codepoint_t glyph,</span>
<span class="line-removed">353                                          unsigned int *x_ppem, unsigned int *y_ppem) const</span>
354   {
<a name="31" id="anc31"></a><span class="line-modified">355     /* TODO: Make it possible to select strike. */</span>


356 
<a name="32" id="anc32"></a><span class="line-modified">357     unsigned int count = sizeTables.len;</span>
<span class="line-modified">358     for (uint32_t i = 0; i &lt; count; ++i)</span>





359     {
<a name="33" id="anc33"></a><span class="line-modified">360       unsigned int startGlyphIndex = sizeTables.arrayZ[i].startGlyphIndex;</span>
<span class="line-modified">361       unsigned int endGlyphIndex = sizeTables.arrayZ[i].endGlyphIndex;</span>
<span class="line-modified">362       if (startGlyphIndex &lt;= glyph &amp;&amp; glyph &lt;= endGlyphIndex)</span>
363       {
<a name="34" id="anc34"></a><span class="line-modified">364         *x_ppem = sizeTables[i].ppemX;</span>
<span class="line-modified">365         *y_ppem = sizeTables[i].ppemY;</span>
<span class="line-removed">366         return sizeTables[i].find_table (glyph, this);</span>
367       }
368     }
369 
<a name="35" id="anc35"></a><span class="line-modified">370     return nullptr;</span>
371   }
372 
373   protected:
374   FixedVersion&lt;&gt;                version;
375   LArrayOf&lt;BitmapSizeTable&gt;     sizeTables;
376   public:
377   DEFINE_SIZE_ARRAY(8, sizeTables);
378 };
379 
380 struct CBDT
381 {
<a name="36" id="anc36"></a><span class="line-modified">382   static const hb_tag_t tableTag = HB_OT_TAG_CBDT;</span>
<span class="line-removed">383 </span>
<span class="line-removed">384   inline bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-removed">385   {</span>
<span class="line-removed">386     TRACE_SANITIZE (this);</span>
<span class="line-removed">387     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-removed">388                   likely (version.major == 2 || version.major == 3));</span>
<span class="line-removed">389   }</span>
390 
391   struct accelerator_t
392   {
<a name="37" id="anc37"></a><span class="line-modified">393     inline void init (hb_face_t *face)</span>
394     {
<a name="38" id="anc38"></a><span class="line-modified">395       upem = hb_face_get_upem (face);</span>
<span class="line-modified">396 </span>
<span class="line-removed">397       cblc_blob = Sanitizer&lt;CBLC&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBLC));</span>
<span class="line-removed">398       cbdt_blob = Sanitizer&lt;CBDT&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_CBDT));</span>
<span class="line-removed">399       cbdt_len = hb_blob_get_length (cbdt_blob);</span>
<span class="line-removed">400 </span>
<span class="line-removed">401       if (hb_blob_get_length (cblc_blob) == 0) {</span>
<span class="line-removed">402         cblc = nullptr;</span>
<span class="line-removed">403         cbdt = nullptr;</span>
<span class="line-removed">404         return;  /* Not a bitmap font. */</span>
<span class="line-removed">405       }</span>
<span class="line-removed">406       cblc = cblc_blob-&gt;as&lt;CBLC&gt; ();</span>
<span class="line-removed">407       cbdt = cbdt_blob-&gt;as&lt;CBDT&gt; ();</span>
408 
<a name="39" id="anc39"></a>
409     }
410 
<a name="40" id="anc40"></a><span class="line-modified">411     inline void fini (void)</span>
412     {
<a name="41" id="anc41"></a><span class="line-modified">413       hb_blob_destroy (this-&gt;cblc_blob);</span>
<span class="line-modified">414       hb_blob_destroy (this-&gt;cbdt_blob);</span>
415     }
416 
<a name="42" id="anc42"></a><span class="line-modified">417     inline bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const</span>

418     {
<a name="43" id="anc43"></a><span class="line-modified">419       unsigned int x_ppem = upem, y_ppem = upem; /* TODO Use font ppem if available. */</span>
<span class="line-modified">420 </span>
<span class="line-modified">421       if (!cblc)</span>
<span class="line-modified">422         return false;  // Not a color bitmap font.</span>
<span class="line-removed">423 </span>
<span class="line-removed">424       const IndexSubtableRecord *subtable_record = this-&gt;cblc-&gt;find_table(glyph, &amp;x_ppem, &amp;y_ppem);</span>
<span class="line-removed">425       if (!subtable_record || !x_ppem || !y_ppem)</span>
426         return false;
427 
<a name="44" id="anc44"></a><span class="line-modified">428       if (subtable_record-&gt;get_extents (extents))</span>
429         return true;
430 
431       unsigned int image_offset = 0, image_length = 0, image_format = 0;
<a name="45" id="anc45"></a><span class="line-modified">432       if (!subtable_record-&gt;get_image_data (glyph, &amp;image_offset, &amp;image_length, &amp;image_format))</span>
433         return false;
434 
435       {
<a name="46" id="anc46"></a>
436         if (unlikely (image_offset &gt; cbdt_len || cbdt_len - image_offset &lt; image_length))
437           return false;
438 
439         switch (image_format)
440         {
441           case 17: {
442             if (unlikely (image_length &lt; GlyphBitmapDataFormat17::min_size))
443               return false;
<a name="47" id="anc47"></a><span class="line-removed">444 </span>
445             const GlyphBitmapDataFormat17&amp; glyphFormat17 =
446                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);
447             glyphFormat17.glyphMetrics.get_extents (extents);
<a name="48" id="anc48"></a>








448           }
<a name="49" id="anc49"></a><span class="line-removed">449           break;</span>
450           default:
451             // TODO: Support other image formats.
452             return false;
453         }
454       }
455 
<a name="50" id="anc50"></a><span class="line-modified">456       /* Convert to the font units. */</span>
<span class="line-modified">457       extents-&gt;x_bearing *= upem / (float) x_ppem;</span>
<span class="line-modified">458       extents-&gt;y_bearing *= upem / (float) y_ppem;</span>
<span class="line-modified">459       extents-&gt;width *= upem / (float) x_ppem;</span>
<span class="line-modified">460       extents-&gt;height *= upem / (float) y_ppem;</span>


461 
462       return true;
463     }
464 
<a name="51" id="anc51"></a><span class="line-modified">465     inline void dump (void (*callback) (const uint8_t* data, unsigned int length,</span>
<span class="line-modified">466         unsigned int group, unsigned int gid)) const</span>
467     {
<a name="52" id="anc52"></a><span class="line-modified">468       if (!cblc)</span>
<span class="line-modified">469         return;  // Not a color bitmap font.</span>







470 
<a name="53" id="anc53"></a><span class="line-removed">471       for (unsigned int i = 0; i &lt; cblc-&gt;sizeTables.len; ++i)</span>
472       {
<a name="54" id="anc54"></a><span class="line-modified">473         const BitmapSizeTable &amp;sizeTable = cblc-&gt;sizeTables[i];</span>
<span class="line-modified">474         const IndexSubtableArray &amp;subtable_array = cblc+sizeTable.indexSubtableArrayOffset;</span>
<span class="line-modified">475         for (unsigned int j = 0; j &lt; sizeTable.numberOfIndexSubtables; ++j)</span>


476         {
<a name="55" id="anc55"></a><span class="line-modified">477           const IndexSubtableRecord &amp;subtable_record = subtable_array.indexSubtablesZ[j];</span>
<span class="line-modified">478           for (unsigned int gid = subtable_record.firstGlyphIndex;</span>
<span class="line-modified">479                 gid &lt;= subtable_record.lastGlyphIndex; ++gid)</span>
<span class="line-modified">480           {</span>
<span class="line-modified">481             unsigned int image_offset = 0, image_length = 0, image_format = 0;</span>
<span class="line-modified">482 </span>
<span class="line-modified">483             if (!subtable_record.get_image_data (gid,</span>
<span class="line-modified">484                   &amp;image_offset, &amp;image_length, &amp;image_format))</span>
<span class="line-modified">485               continue;</span>
<span class="line-modified">486 </span>
<span class="line-modified">487             switch (image_format)</span>
<span class="line-modified">488             {</span>
<span class="line-modified">489             case 17: {</span>
<span class="line-modified">490               const GlyphBitmapDataFormat17&amp; glyphFormat17 =</span>
<span class="line-modified">491                 StructAtOffset&lt;GlyphBitmapDataFormat17&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">492               callback ((const uint8_t *) &amp;glyphFormat17.data.arrayZ,</span>
<span class="line-modified">493                 glyphFormat17.data.len, i, gid);</span>
<span class="line-modified">494             }</span>
<span class="line-modified">495             break;</span>
<span class="line-modified">496             case 18: {</span>
<span class="line-modified">497               const GlyphBitmapDataFormat18&amp; glyphFormat18 =</span>
<span class="line-modified">498                 StructAtOffset&lt;GlyphBitmapDataFormat18&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-modified">499               callback ((const uint8_t *) &amp;glyphFormat18.data.arrayZ,</span>
<span class="line-modified">500                 glyphFormat18.data.len, i, gid);</span>
<span class="line-modified">501             }</span>
<span class="line-modified">502             break;</span>
<span class="line-removed">503             case 19: {</span>
<span class="line-removed">504               const GlyphBitmapDataFormat19&amp; glyphFormat19 =</span>
<span class="line-removed">505                 StructAtOffset&lt;GlyphBitmapDataFormat19&gt; (this-&gt;cbdt, image_offset);</span>
<span class="line-removed">506               callback ((const uint8_t *) &amp;glyphFormat19.data.arrayZ,</span>
<span class="line-removed">507                 glyphFormat19.data.len, i, gid);</span>
<span class="line-removed">508             }</span>
<span class="line-removed">509             break;</span>
<span class="line-removed">510             default:</span>
<span class="line-removed">511               continue;</span>
<span class="line-removed">512             }</span>
513           }
514         }
515       }
<a name="56" id="anc56"></a>

516     }
517 
<a name="57" id="anc57"></a>

518     private:
<a name="58" id="anc58"></a><span class="line-modified">519     hb_blob_t *cblc_blob;</span>
<span class="line-modified">520     hb_blob_t *cbdt_blob;</span>
<span class="line-removed">521     const CBLC *cblc;</span>
<span class="line-removed">522     const CBDT *cbdt;</span>
523 
<a name="59" id="anc59"></a><span class="line-removed">524     unsigned int cbdt_len;</span>
525     unsigned int upem;
526   };
527 
<a name="60" id="anc60"></a>





528 
529   protected:
<a name="61" id="anc61"></a><span class="line-modified">530   FixedVersion&lt;&gt;        version;</span>
<span class="line-modified">531   HBUINT8               dataZ[VAR];</span>
532   public:
533   DEFINE_SIZE_ARRAY(4, dataZ);
534 };
535 
<a name="62" id="anc62"></a>

536 } /* namespace OT */
537 
538 #endif /* HB_OT_COLOR_CBDT_TABLE_HH */
<a name="63" id="anc63"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="63" type="hidden" />
</body>
</html>
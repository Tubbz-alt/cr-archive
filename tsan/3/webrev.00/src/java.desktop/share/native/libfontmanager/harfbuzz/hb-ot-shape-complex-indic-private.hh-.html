<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-indic-private.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
 28 #define HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH
 29 
 30 #include &quot;hb-private.hh&quot;
 31 
 32 
 33 #include &quot;hb-ot-shape-complex-private.hh&quot;
 34 #include &quot;hb-ot-shape-private.hh&quot; /* XXX Remove */
 35 
 36 
 37 /* buffer var allocations */
 38 #define indic_category() complex_var_u8_0() /* indic_category_t */
 39 #define indic_position() complex_var_u8_1() /* indic_position_t */
 40 
 41 
 42 #define INDIC_TABLE_ELEMENT_TYPE uint16_t
 43 
 44 /* Cateories used in the OpenType spec:
 45  * https://docs.microsoft.com/en-us/typography/script-development/devanagari
 46  */
 47 /* Note: This enum is duplicated in the -machine.rl source file.
 48  * Not sure how to avoid duplication. */
 49 enum indic_category_t {
 50   OT_X = 0,
 51   OT_C = 1,
 52   OT_V = 2,
 53   OT_N = 3,
 54   OT_H = 4,
 55   OT_ZWNJ = 5,
 56   OT_ZWJ = 6,
 57   OT_M = 7,
 58   OT_SM = 8,
 59   /* OT_VD = 9, UNUSED; we use OT_A instead. */
 60   OT_A = 10,
 61   OT_PLACEHOLDER = 11,
 62   OT_DOTTEDCIRCLE = 12,
 63   OT_RS = 13, /* Register Shifter, used in Khmer OT spec. */
 64   OT_Coeng = 14, /* Khmer-style Virama. */
 65   OT_Repha = 15, /* Atomically-encoded logical or visual repha. */
 66   OT_Ra = 16,
 67   OT_CM = 17,  /* Consonant-Medial. */
 68   OT_Symbol = 18, /* Avagraha, etc that take marks (SM,A,VD). */
 69   OT_CS = 19
 70 };
 71 
 72 #define MEDIAL_FLAGS (FLAG (OT_CM))
 73 
 74 /* Note:
 75  *
 76  * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels
 77  * cannot happen in a consonant syllable.  The plus side however is, we can call the
 78  * consonant syllable logic from the vowel syllable function and get it all right! */
 79 #define CONSONANT_FLAGS (FLAG (OT_C) | FLAG (OT_CS) | FLAG (OT_Ra) | MEDIAL_FLAGS | FLAG (OT_V) | FLAG (OT_PLACEHOLDER) | FLAG (OT_DOTTEDCIRCLE))
 80 #define JOINER_FLAGS (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ))
 81 
 82 
 83 /* Visual positions in a syllable from left to right. */
 84 enum indic_position_t {
 85   POS_START = 0,
 86 
 87   POS_RA_TO_BECOME_REPH = 1,
 88   POS_PRE_M = 2,
 89   POS_PRE_C = 3,
 90 
 91   POS_BASE_C = 4,
 92   POS_AFTER_MAIN = 5,
 93 
 94   POS_ABOVE_C = 6,
 95 
 96   POS_BEFORE_SUB = 7,
 97   POS_BELOW_C = 8,
 98   POS_AFTER_SUB = 9,
 99 
100   POS_BEFORE_POST = 10,
101   POS_POST_C = 11,
102   POS_AFTER_POST = 12,
103 
104   POS_FINAL_C = 13,
105   POS_SMVD = 14,
106 
107   POS_END = 15
108 };
109 
110 /* Categories used in IndicSyllabicCategory.txt from UCD. */
111 enum indic_syllabic_category_t {
112   INDIC_SYLLABIC_CATEGORY_OTHER                         = OT_X,
113 
114   INDIC_SYLLABIC_CATEGORY_AVAGRAHA                      = OT_Symbol,
115   INDIC_SYLLABIC_CATEGORY_BINDU                         = OT_SM,
116   INDIC_SYLLABIC_CATEGORY_BRAHMI_JOINING_NUMBER         = OT_PLACEHOLDER, /* Don&#39;t care. */
117   INDIC_SYLLABIC_CATEGORY_CANTILLATION_MARK             = OT_A,
118   INDIC_SYLLABIC_CATEGORY_CONSONANT                     = OT_C,
119   INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD                = OT_C,
120   INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL               = OT_CM,
121   INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER         = OT_C,
122   INDIC_SYLLABIC_CATEGORY_CONSONANT_KILLER              = OT_M, /* U+17CD only. */
123   INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL              = OT_CM,
124   INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER         = OT_PLACEHOLDER,
125   INDIC_SYLLABIC_CATEGORY_CONSONANT_PRECEDING_REPHA     = OT_Repha,
126   INDIC_SYLLABIC_CATEGORY_CONSONANT_PREFIXED            = OT_X, /* Don&#39;t care. */
127   INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED           = OT_CM,
128   INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA    = OT_N,
129   INDIC_SYLLABIC_CATEGORY_CONSONANT_WITH_STACKER        = OT_CS,
130   INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK               = OT_SM, /* https://github.com/harfbuzz/harfbuzz/issues/552 */
131   INDIC_SYLLABIC_CATEGORY_INVISIBLE_STACKER             = OT_Coeng,
132   INDIC_SYLLABIC_CATEGORY_JOINER                        = OT_ZWJ,
133   INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER              = OT_X,
134   INDIC_SYLLABIC_CATEGORY_NON_JOINER                    = OT_ZWNJ,
135   INDIC_SYLLABIC_CATEGORY_NUKTA                         = OT_N,
136   INDIC_SYLLABIC_CATEGORY_NUMBER                        = OT_PLACEHOLDER,
137   INDIC_SYLLABIC_CATEGORY_NUMBER_JOINER                 = OT_PLACEHOLDER, /* Don&#39;t care. */
138   INDIC_SYLLABIC_CATEGORY_PURE_KILLER                   = OT_M, /* Is like a vowel matra. */
139   INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER              = OT_RS,
140   INDIC_SYLLABIC_CATEGORY_SYLLABLE_MODIFIER             = OT_SM,
141   INDIC_SYLLABIC_CATEGORY_TONE_LETTER                   = OT_X,
142   INDIC_SYLLABIC_CATEGORY_TONE_MARK                     = OT_N,
143   INDIC_SYLLABIC_CATEGORY_VIRAMA                        = OT_H,
144   INDIC_SYLLABIC_CATEGORY_VISARGA                       = OT_SM,
145   INDIC_SYLLABIC_CATEGORY_VOWEL                         = OT_V,
146   INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT               = OT_M,
147   INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT             = OT_V
148 };
149 
150 /* Categories used in IndicSMatraCategory.txt from UCD */
151 enum indic_matra_category_t {
152   INDIC_MATRA_CATEGORY_NOT_APPLICABLE                   = POS_END,
153 
154   INDIC_MATRA_CATEGORY_LEFT                             = POS_PRE_C,
155   INDIC_MATRA_CATEGORY_TOP                              = POS_ABOVE_C,
156   INDIC_MATRA_CATEGORY_BOTTOM                           = POS_BELOW_C,
157   INDIC_MATRA_CATEGORY_RIGHT                            = POS_POST_C,
158 
159   /* These should resolve to the position of the last part of the split sequence. */
160   INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT                 = INDIC_MATRA_CATEGORY_RIGHT,
161   INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT                   = INDIC_MATRA_CATEGORY_RIGHT,
162   INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM                   = INDIC_MATRA_CATEGORY_BOTTOM,
163   INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT         = INDIC_MATRA_CATEGORY_RIGHT,
164   INDIC_MATRA_CATEGORY_TOP_AND_LEFT                     = INDIC_MATRA_CATEGORY_TOP,
165   INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT           = INDIC_MATRA_CATEGORY_RIGHT,
166   INDIC_MATRA_CATEGORY_TOP_AND_RIGHT                    = INDIC_MATRA_CATEGORY_RIGHT,
167 
168   INDIC_MATRA_CATEGORY_OVERSTRUCK                       = POS_AFTER_MAIN,
169   INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT                = POS_PRE_M
170 };
171 
172 #define INDIC_COMBINE_CATEGORIES(S,M) \
173   ( \
174     ASSERT_STATIC_EXPR_ZERO (S &lt; 255 &amp;&amp; M &lt; 255) + \
175     ( S | \
176      ( \
177       ( \
178        S == INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL || \
179        S == INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK || \
180        S == INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER || \
181        S == INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA || \
182        S == INDIC_SYLLABIC_CATEGORY_VIRAMA || \
183        S == INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT || \
184        false \
185        ? M : INDIC_MATRA_CATEGORY_NOT_APPLICABLE \
186       ) &lt;&lt; 8 \
187      ) \
188     ) \
189    )
190 
191 HB_INTERNAL INDIC_TABLE_ELEMENT_TYPE
192 hb_indic_get_categories (hb_codepoint_t u);
193 
194 
195 static inline bool
196 is_one_of (const hb_glyph_info_t &amp;info, unsigned int flags)
197 {
198   /* If it ligated, all bets are off. */
199   if (_hb_glyph_info_ligated (&amp;info)) return false;
200   return !!(FLAG_UNSAFE (info.indic_category()) &amp; flags);
201 }
202 
203 static inline bool
204 is_joiner (const hb_glyph_info_t &amp;info)
205 {
206   return is_one_of (info, JOINER_FLAGS);
207 }
208 
209 static inline bool
210 is_consonant (const hb_glyph_info_t &amp;info)
211 {
212   return is_one_of (info, CONSONANT_FLAGS);
213 }
214 
215 static inline bool
216 is_halant (const hb_glyph_info_t &amp;info)
217 {
218   return is_one_of (info, FLAG (OT_H));
219 }
220 
221 #define IN_HALF_BLOCK(u, Base) (((u) &amp; ~0x7Fu) == (Base))
222 
223 #define IS_DEVA(u) (IN_HALF_BLOCK (u, 0x0900u))
224 #define IS_BENG(u) (IN_HALF_BLOCK (u, 0x0980u))
225 #define IS_GURU(u) (IN_HALF_BLOCK (u, 0x0A00u))
226 #define IS_GUJR(u) (IN_HALF_BLOCK (u, 0x0A80u))
227 #define IS_ORYA(u) (IN_HALF_BLOCK (u, 0x0B00u))
228 #define IS_TAML(u) (IN_HALF_BLOCK (u, 0x0B80u))
229 #define IS_TELU(u) (IN_HALF_BLOCK (u, 0x0C00u))
230 #define IS_KNDA(u) (IN_HALF_BLOCK (u, 0x0C80u))
231 #define IS_MLYM(u) (IN_HALF_BLOCK (u, 0x0D00u))
232 #define IS_SINH(u) (IN_HALF_BLOCK (u, 0x0D80u))
233 
234 
235 #define MATRA_POS_LEFT(u)       POS_PRE_M
236 #define MATRA_POS_RIGHT(u)      ( \
237                                   IS_DEVA(u) ? POS_AFTER_SUB  : \
238                                   IS_BENG(u) ? POS_AFTER_POST : \
239                                   IS_GURU(u) ? POS_AFTER_POST : \
240                                   IS_GUJR(u) ? POS_AFTER_POST : \
241                                   IS_ORYA(u) ? POS_AFTER_POST : \
242                                   IS_TAML(u) ? POS_AFTER_POST : \
243                                   IS_TELU(u) ? (u &lt;= 0x0C42u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \
244                                   IS_KNDA(u) ? (u &lt; 0x0CC3u || u &gt; 0xCD6u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \
245                                   IS_MLYM(u) ? POS_AFTER_POST : \
246                                   IS_SINH(u) ? POS_AFTER_SUB  : \
247                                   /*default*/  POS_AFTER_SUB    \
248                                 )
249 #define MATRA_POS_TOP(u)        ( /* BENG and MLYM don&#39;t have top matras. */ \
250                                   IS_DEVA(u) ? POS_AFTER_SUB  : \
251                                   IS_GURU(u) ? POS_AFTER_POST : /* Deviate from spec */ \
252                                   IS_GUJR(u) ? POS_AFTER_SUB  : \
253                                   IS_ORYA(u) ? POS_AFTER_MAIN : \
254                                   IS_TAML(u) ? POS_AFTER_SUB  : \
255                                   IS_TELU(u) ? POS_BEFORE_SUB : \
256                                   IS_KNDA(u) ? POS_BEFORE_SUB : \
257                                   IS_SINH(u) ? POS_AFTER_SUB  : \
258                                   /*default*/  POS_AFTER_SUB    \
259                                 )
260 #define MATRA_POS_BOTTOM(u)     ( \
261                                   IS_DEVA(u) ? POS_AFTER_SUB  : \
262                                   IS_BENG(u) ? POS_AFTER_SUB  : \
263                                   IS_GURU(u) ? POS_AFTER_POST : \
264                                   IS_GUJR(u) ? POS_AFTER_POST : \
265                                   IS_ORYA(u) ? POS_AFTER_SUB  : \
266                                   IS_TAML(u) ? POS_AFTER_POST : \
267                                   IS_TELU(u) ? POS_BEFORE_SUB : \
268                                   IS_KNDA(u) ? POS_BEFORE_SUB : \
269                                   IS_MLYM(u) ? POS_AFTER_POST : \
270                                   IS_SINH(u) ? POS_AFTER_SUB  : \
271                                   /*default*/  POS_AFTER_SUB    \
272                                 )
273 
274 static inline indic_position_t
275 matra_position_indic (hb_codepoint_t u, indic_position_t side)
276 {
277   switch ((int) side)
278   {
279     case POS_PRE_C:     return MATRA_POS_LEFT (u);
280     case POS_POST_C:    return MATRA_POS_RIGHT (u);
281     case POS_ABOVE_C:   return MATRA_POS_TOP (u);
282     case POS_BELOW_C:   return MATRA_POS_BOTTOM (u);
283   };
284   return side;
285 }
286 
287 /* XXX
288  * This is a hack for now.  We should move this data into the main Indic table.
289  * Or completely remove it and just check in the tables.
290  */
291 static const hb_codepoint_t ra_chars[] = {
292   0x0930u, /* Devanagari */
293   0x09B0u, /* Bengali */
294   0x09F0u, /* Bengali */
295   0x0A30u, /* Gurmukhi */       /* No Reph */
296   0x0AB0u, /* Gujarati */
297   0x0B30u, /* Oriya */
298   0x0BB0u, /* Tamil */          /* No Reph */
299   0x0C30u, /* Telugu */         /* Reph formed only with ZWJ */
300   0x0CB0u, /* Kannada */
301   0x0D30u, /* Malayalam */      /* No Reph, Logical Repha */
302 
303   0x0DBBu, /* Sinhala */                /* Reph formed only with ZWJ */
304 };
305 
306 static inline bool
307 is_ra (hb_codepoint_t u)
308 {
309   for (unsigned int i = 0; i &lt; ARRAY_LENGTH (ra_chars); i++)
310     if (u == ra_chars[i])
311       return true;
312   return false;
313 }
314 
315 static inline void
316 set_indic_properties (hb_glyph_info_t &amp;info)
317 {
318   hb_codepoint_t u = info.codepoint;
319   unsigned int type = hb_indic_get_categories (u);
320   indic_category_t cat = (indic_category_t) (type &amp; 0x7Fu);
321   indic_position_t pos = (indic_position_t) (type &gt;&gt; 8);
322 
323 
324   /*
325    * Re-assign category
326    */
327 
328   /* The following act more like the Bindus. */
329   if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (u, 0x0953u, 0x0954u)))
330     cat = OT_SM;
331   /* The following act like consonants. */
332   else if (unlikely (hb_in_ranges&lt;hb_codepoint_t&gt; (u, 0x0A72u, 0x0A73u,
333                                       0x1CF5u, 0x1CF6u)))
334     cat = OT_C;
335   /* TODO: The following should only be allowed after a Visarga.
336    * For now, just treat them like regular tone marks. */
337   else if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (u, 0x1CE2u, 0x1CE8u)))
338     cat = OT_A;
339   /* TODO: The following should only be allowed after some of
340    * the nasalization marks, maybe only for U+1CE9..U+1CF1.
341    * For now, just treat them like tone marks. */
342   else if (unlikely (u == 0x1CEDu))
343     cat = OT_A;
344   /* The following take marks in standalone clusters, similar to Avagraha. */
345   else if (unlikely (hb_in_ranges&lt;hb_codepoint_t&gt; (u, 0xA8F2u, 0xA8F7u,
346                                       0x1CE9u, 0x1CECu,
347                                       0x1CEEu, 0x1CF1u)))
348   {
349     cat = OT_Symbol;
350     static_assert (((int) INDIC_SYLLABIC_CATEGORY_AVAGRAHA == OT_Symbol), &quot;&quot;);
351   }
352   else if (unlikely (u == 0x0A51u))
353   {
354     /* https://github.com/harfbuzz/harfbuzz/issues/524 */
355     cat = OT_M;
356     pos = POS_BELOW_C;
357   }
358 
359   /* According to ScriptExtensions.txt, these Grantha marks may also be used in Tamil,
360    * so the Indic shaper needs to know their categories. */
361   else if (unlikely (u == 0x11301u || u == 0x11303u)) cat = OT_SM;
362   else if (unlikely (u == 0x1133cu)) cat = OT_N;
363 
364   else if (unlikely (u == 0x0AFBu)) cat = OT_N; /* https://github.com/harfbuzz/harfbuzz/issues/552 */
365 
366   else if (unlikely (u == 0x0980u)) cat = OT_PLACEHOLDER; /* https://github.com/harfbuzz/harfbuzz/issues/538 */
367   else if (unlikely (u == 0x0C80u)) cat = OT_PLACEHOLDER; /* https://github.com/harfbuzz/harfbuzz/pull/623 */
368   else if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (u, 0x2010u, 0x2011u)))
369                                     cat = OT_PLACEHOLDER;
370   else if (unlikely (u == 0x25CCu)) cat = OT_DOTTEDCIRCLE;
371 
372 
373   /*
374    * Re-assign position.
375    */
376 
377   if ((FLAG_UNSAFE (cat) &amp; CONSONANT_FLAGS))
378   {
379     pos = POS_BASE_C;
380     if (is_ra (u))
381       cat = OT_Ra;
382   }
383   else if (cat == OT_M)
384   {
385     pos = matra_position_indic (u, pos);
386   }
387   else if ((FLAG_UNSAFE (cat) &amp; (FLAG (OT_SM) /* | FLAG (OT_VD) */ | FLAG (OT_A) | FLAG (OT_Symbol))))
388   {
389     pos = POS_SMVD;
390   }
391 
392   if (unlikely (u == 0x0B01u)) pos = POS_BEFORE_SUB; /* Oriya Bindu is BeforeSub in the spec. */
393 
394 
395 
396   info.indic_category() = cat;
397   info.indic_position() = pos;
398 }
399 
400 
401 #endif /* HB_OT_SHAPE_COMPLEX_INDIC_PRIVATE_HH */
    </pre>
  </body>
</html>
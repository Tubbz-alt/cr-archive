<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-complex-arabic-win1256.hh.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-default.cc.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape-complex-arabic.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -22,14 +22,13 @@</span>
   * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
   *
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="udiff-line-modified-removed">- #include &quot;hb-private.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-debug.hh&quot;</span>
<span class="udiff-line-modified-removed">- #include &quot;hb-ot-shape-complex-arabic-private.hh&quot;</span>
<span class="udiff-line-removed">- #include &quot;hb-ot-shape-private.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape-complex-arabic.hh&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;hb-ot-shape.hh&quot;</span>
  
  
  /* buffer var allocations */
  #define arabic_shaping_action() complex_var_u8_0() /* arabic shaping action */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -157,15 +156,10 @@</span>
    /* State 6: prev was DALATH/RISH, not willing to join. */
    { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }
  };
  
  
<span class="udiff-line-removed">- static void</span>
<span class="udiff-line-removed">- nuke_joiners (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-removed">-               hb_font_t *font,</span>
<span class="udiff-line-removed">-               hb_buffer_t *buffer);</span>
<span class="udiff-line-removed">- </span>
  static void
  arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
                         hb_font_t *font,
                         hb_buffer_t *buffer);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -199,61 +193,65 @@</span>
     *
     * A pause after calt is required to make KFGQPC Uthmanic Script HAFS
     * work correctly.  See https://github.com/harfbuzz/harfbuzz/issues/505
     */
  
<span class="udiff-line-removed">-   map-&gt;add_gsub_pause (nuke_joiners);</span>
  
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;s&#39;,&#39;t&#39;,&#39;c&#39;,&#39;h&#39;));</span>
    map-&gt;add_gsub_pause (record_stch);
  
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;));</span>
  
    map-&gt;add_gsub_pause (nullptr);
  
    for (unsigned int i = 0; i &lt; ARABIC_NUM_FEATURES; i++)
    {
      bool has_fallback = plan-&gt;props.script == HB_SCRIPT_ARABIC &amp;&amp; !FEATURE_IS_SYRIAC (arabic_features[i]);
<span class="udiff-line-modified-removed">-     map-&gt;add_feature (arabic_features[i], 1, has_fallback ? F_HAS_FALLBACK : F_NONE);</span>
<span class="udiff-line-modified-added">+     map-&gt;add_feature (arabic_features[i], has_fallback ? F_HAS_FALLBACK : F_NONE);</span>
      map-&gt;add_gsub_pause (nullptr);
    }
  
<span class="udiff-line-modified-removed">-   map-&gt;add_feature (HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), 1, F_GLOBAL|F_HAS_FALLBACK);</span>
<span class="udiff-line-modified-added">+   /* Normally, Unicode says a ZWNJ means &quot;don&#39;t ligate&quot;.  In Arabic script</span>
<span class="udiff-line-added">+    * however, it says a ZWJ should also mean &quot;don&#39;t ligate&quot;.  So we run</span>
<span class="udiff-line-added">+    * the main ligating features as MANUAL_ZWJ. */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_MANUAL_ZWJ | F_HAS_FALLBACK);</span>
<span class="udiff-line-added">+ </span>
    if (plan-&gt;props.script == HB_SCRIPT_ARABIC)
      map-&gt;add_gsub_pause (arabic_fallback_shape);
  
    /* No pause after rclt.  See 98460779bae19e4d64d29461ff154b3527bf8420. */
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;), F_MANUAL_ZWJ);</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), F_MANUAL_ZWJ);</span>
    map-&gt;add_gsub_pause (nullptr);
  
<span class="udiff-line-added">+   /* And undo here. */</span>
<span class="udiff-line-added">+ </span>
    /* The spec includes &#39;cswh&#39;.  Earlier versions of Windows
     * used to enable this by default, but testing suggests
     * that Windows 8 and later do not enable it by default,
     * and spec now says &#39;Off by default&#39;.
     * We disabled this in ae23c24c32.
     * Note that IranNastaliq uses this feature extensively
     * to fixup broken glyph sequences.  Oh well...
     * Test case: U+0643,U+0640,U+0631. */
<span class="udiff-line-modified-removed">-   //map-&gt;add_global_bool_feature (HB_TAG(&#39;c&#39;,&#39;s&#39;,&#39;w&#39;,&#39;h&#39;));</span>
<span class="udiff-line-modified-removed">-   map-&gt;add_global_bool_feature (HB_TAG(&#39;m&#39;,&#39;s&#39;,&#39;e&#39;,&#39;t&#39;));</span>
<span class="udiff-line-modified-added">+   //map-&gt;enable_feature (HB_TAG(&#39;c&#39;,&#39;s&#39;,&#39;w&#39;,&#39;h&#39;));</span>
<span class="udiff-line-modified-added">+   map-&gt;enable_feature (HB_TAG(&#39;m&#39;,&#39;s&#39;,&#39;e&#39;,&#39;t&#39;));</span>
  }
  
  #include &quot;hb-ot-shape-complex-arabic-fallback.hh&quot;
  
  struct arabic_shape_plan_t
  {
<span class="udiff-line-removed">-   ASSERT_POD ();</span>
<span class="udiff-line-removed">- </span>
    /* The &quot;+ 1&quot; in the next array is to accommodate for the &quot;NONE&quot; command,
     * which is not an OpenType feature, but this simplifies the code by not
     * having to do a &quot;if (... &lt; NONE) ...&quot; and just rely on the fact that
     * mask_array[NONE] == 0. */
    hb_mask_t mask_array[ARABIC_NUM_FEATURES + 1];
  
<span class="udiff-line-modified-removed">-   arabic_fallback_plan_t *fallback_plan;</span>
<span class="udiff-line-modified-added">+   hb_atomic_ptr_t&lt;arabic_fallback_plan_t&gt; fallback_plan;</span>
  
    unsigned int do_fallback : 1;
    unsigned int has_stch : 1;
  };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,23 +376,10 @@</span>
  {
    const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
    setup_masks_arabic_plan (arabic_plan, buffer, plan-&gt;props.script);
  }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static void</span>
<span class="udiff-line-removed">- nuke_joiners (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
<span class="udiff-line-removed">-               hb_font_t *font HB_UNUSED,</span>
<span class="udiff-line-removed">-               hb_buffer_t *buffer)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   unsigned int count = buffer-&gt;len;</span>
<span class="udiff-line-removed">-   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="udiff-line-removed">-   for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="udiff-line-removed">-     if (_hb_glyph_info_is_zwj (&amp;info[i]))</span>
<span class="udiff-line-removed">-       _hb_glyph_info_flip_joiners (&amp;info[i]);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static void
  arabic_fallback_shape (const hb_ot_shape_plan_t *plan,
                         hb_font_t *font,
                         hb_buffer_t *buffer)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,16 +387,17 @@</span>
  
    if (!arabic_plan-&gt;do_fallback)
      return;
  
  retry:
<span class="udiff-line-modified-removed">-   arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) hb_atomic_ptr_get (&amp;arabic_plan-&gt;fallback_plan);</span>
<span class="udiff-line-modified-added">+   arabic_fallback_plan_t *fallback_plan = arabic_plan-&gt;fallback_plan;</span>
    if (unlikely (!fallback_plan))
    {
      /* This sucks.  We need a font to build the fallback plan... */
      fallback_plan = arabic_fallback_plan_create (plan, font);
<span class="udiff-line-modified-removed">-     if (unlikely (!hb_atomic_ptr_cmpexch (&amp;(const_cast&lt;arabic_shape_plan_t *&gt; (arabic_plan))-&gt;fallback_plan, nullptr, fallback_plan))) {</span>
<span class="udiff-line-modified-added">+     if (unlikely (!arabic_plan-&gt;fallback_plan.cmpexch (nullptr, fallback_plan)))</span>
<span class="udiff-line-added">+     {</span>
        arabic_fallback_plan_destroy (fallback_plan);
        goto retry;
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -426,11 +412,11 @@</span>
   * marks can use it as well.
   */
  
  static void
  record_stch (const hb_ot_shape_plan_t *plan,
<span class="udiff-line-modified-removed">-              hb_font_t *font,</span>
<span class="udiff-line-modified-added">+              hb_font_t *font HB_UNUSED,</span>
               hb_buffer_t *buffer)
  {
    const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan-&gt;data;
    if (!arabic_plan-&gt;has_stch)
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -450,11 +436,11 @@</span>
        buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH;
      }
  }
  
  static void
<span class="udiff-line-modified-removed">- apply_stch (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-added">+ apply_stch (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
              hb_buffer_t              *buffer,
              hb_font_t                *font)
  {
    if (likely (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH)))
      return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,13 +454,13 @@</span>
     * Second pass applies the stretch, copying things to the end of buffer.
     */
  
    int sign = font-&gt;x_scale &lt; 0 ? -1 : +1;
    unsigned int extra_glyphs_needed = 0; // Set during MEASURE, used during CUT
<span class="udiff-line-modified-removed">-   typedef enum { MEASURE, CUT } step_t;</span>
<span class="udiff-line-modified-added">+   enum { MEASURE, CUT } /* step_t */;</span>
  
<span class="udiff-line-modified-removed">-   for (step_t step = MEASURE; step &lt;= CUT; step = (step_t) (step + 1))</span>
<span class="udiff-line-modified-added">+   for (unsigned int step = MEASURE; step &lt;= CUT; step = step + 1)</span>
    {
      unsigned int count = buffer-&gt;len;
      hb_glyph_info_t *info = buffer-&gt;info;
      hb_glyph_position_t *pos = buffer-&gt;pos;
      unsigned int new_len = count + extra_glyphs_needed; // write head during CUT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -609,11 +595,11 @@</span>
    apply_stch (plan, buffer, font);
  
    HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);
  }
  
<span class="udiff-line-modified-removed">- /* https://unicode.org/reports/tr53/tr53-1.pdf */</span>
<span class="udiff-line-modified-added">+ /* http://www.unicode.org/reports/tr53/ */</span>
  
  static hb_codepoint_t
  modifier_combining_marks[] =
  {
    0x0654u, /* ARABIC HAMZA ABOVE */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -621,10 +607,11 @@</span>
    0x0658u, /* ARABIC MARK NOON GHUNNA */
    0x06DCu, /* ARABIC SMALL HIGH SEEN */
    0x06E3u, /* ARABIC SMALL LOW SEEN */
    0x06E7u, /* ARABIC SMALL HIGH YEH */
    0x06E8u, /* ARABIC SMALL HIGH NOON */
<span class="udiff-line-added">+   0x08D3u, /* ARABIC SMALL LOW WAW */</span>
    0x08F3u, /* ARABIC SMALL HIGH WAW */
  };
  
  static inline bool
  info_is_mcm (const hb_glyph_info_t &amp;info)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -635,11 +622,11 @@</span>
        return true;
    return false;
  }
  
  static void
<span class="udiff-line-modified-removed">- reorder_marks_arabic (const hb_ot_shape_plan_t *plan,</span>
<span class="udiff-line-modified-added">+ reorder_marks_arabic (const hb_ot_shape_plan_t *plan HB_UNUSED,</span>
                        hb_buffer_t              *buffer,
                        unsigned int              start,
                        unsigned int              end)
  {
    hb_glyph_info_t *info = buffer-&gt;info;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,10 +699,10 @@</span>
    postprocess_glyphs_arabic,
    HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,
    nullptr, /* decompose */
    nullptr, /* compose */
    setup_masks_arabic,
<span class="udiff-line-modified-removed">-   nullptr, /* disable_otl */</span>
<span class="udiff-line-modified-added">+   HB_TAG_NONE, /* gpos_tag */</span>
    reorder_marks_arabic,
    HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,
    true, /* fallback_position */
  };
</pre>
<center><a href="hb-ot-shape-complex-arabic-win1256.hh.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-shape-complex-default.cc.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
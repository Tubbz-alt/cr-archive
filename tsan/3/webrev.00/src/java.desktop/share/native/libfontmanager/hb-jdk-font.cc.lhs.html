<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/hb-jdk-font.cc</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
<a name="1" id="anc1"></a>


 26 #include &quot;hb.h&quot;
 27 #include &quot;hb-jdk.h&quot;
 28 #ifdef MACOSX
 29 #include &quot;hb-coretext.h&quot;
 30 #endif
 31 #include &lt;stdlib.h&gt;
 32 
 33 #if defined(__GNUC__) &amp;&amp;  __GNUC__ &gt;= 4
 34 #define HB_UNUSED       __attribute__((unused))
 35 #else
 36 #define HB_UNUSED
 37 #endif
 38 
<a name="2" id="anc2"></a>
 39 static hb_bool_t
<a name="3" id="anc3"></a><span class="line-modified"> 40 hb_jdk_get_glyph (hb_font_t *font HB_UNUSED,</span>























 41 		 void *font_data,
 42 		 hb_codepoint_t unicode,
 43 		 hb_codepoint_t variation_selector,
 44 		 hb_codepoint_t *glyph,
 45 		 void *user_data HB_UNUSED)
 46 {
 47 
 48     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
 49     JNIEnv* env = jdkFontInfo-&gt;env;
 50     jobject font2D = jdkFontInfo-&gt;font2D;
<a name="4" id="anc4"></a><span class="line-modified"> 51     if (variation_selector == 0) {</span>
<span class="line-modified"> 52         *glyph = (hb_codepoint_t)env-&gt;CallIntMethod(</span>
<span class="line-modified"> 53                      font2D, sunFontIDs.f2dCharToGlyphMID, unicode);</span>
<span class="line-removed"> 54     } else {</span>
<span class="line-removed"> 55         *glyph = (hb_codepoint_t)env-&gt;CallIntMethod(</span>
<span class="line-removed"> 56                      font2D, sunFontIDs.f2dCharToVariationGlyphMID, </span>
<span class="line-removed"> 57                      unicode, variation_selector);</span>
<span class="line-removed"> 58     }</span>
 59     if (env-&gt;ExceptionOccurred())
 60     {
 61         env-&gt;ExceptionClear();
 62     }
 63     if ((int)*glyph &lt; 0) {
 64         *glyph = 0;
 65     }
 66     return (*glyph != 0);
 67 }
 68 
 69 static hb_position_t
 70 hb_jdk_get_glyph_h_advance (hb_font_t *font HB_UNUSED,
 71 			   void *font_data,
 72 			   hb_codepoint_t glyph,
 73 			   void *user_data HB_UNUSED)
 74 {
 75 
 76     float fadv = 0.0f;
 77     if ((glyph &amp; 0xfffe) == 0xfffe) {
 78         return 0; // JDK uses this glyph code.
 79     }
 80 
 81     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
 82     JNIEnv* env = jdkFontInfo-&gt;env;
 83     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
 84     jobject pt = env-&gt;CallObjectMethod(fontStrike,
 85                                        sunFontIDs.getGlyphMetricsMID, glyph);
 86 
 87     if (pt == NULL) {
 88         return 0;
 89     }
 90     fadv = env-&gt;GetFloatField(pt, sunFontIDs.xFID);
 91     fadv *= jdkFontInfo-&gt;devScale;
 92     env-&gt;DeleteLocalRef(pt);
 93 
 94     return HBFloatToFixed(fadv);
 95 }
 96 
 97 static hb_position_t
 98 hb_jdk_get_glyph_v_advance (hb_font_t *font HB_UNUSED,
 99 			   void *font_data,
100 			   hb_codepoint_t glyph,
101 			   void *user_data HB_UNUSED)
102 {
103 
104     float fadv = 0.0f;
105     if ((glyph &amp; 0xfffe) == 0xfffe) {
106         return 0; // JDK uses this glyph code.
107     }
108 
109     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
110     JNIEnv* env = jdkFontInfo-&gt;env;
111     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
112     jobject pt = env-&gt;CallObjectMethod(fontStrike,
113                                        sunFontIDs.getGlyphMetricsMID, glyph);
114 
115     if (pt == NULL) {
116         return 0;
117     }
118     fadv = env-&gt;GetFloatField(pt, sunFontIDs.yFID);
119     env-&gt;DeleteLocalRef(pt);
120 
121     return HBFloatToFixed(fadv);
122 
123 }
124 
125 static hb_bool_t
126 hb_jdk_get_glyph_h_origin (hb_font_t *font HB_UNUSED,
127 			  void *font_data HB_UNUSED,
128 			  hb_codepoint_t glyph HB_UNUSED,
129 			  hb_position_t *x HB_UNUSED,
130 			  hb_position_t *y HB_UNUSED,
131 			  void *user_data HB_UNUSED)
132 {
133   /* We always work in the horizontal coordinates. */
134   return true;
135 }
136 
137 static hb_bool_t
138 hb_jdk_get_glyph_v_origin (hb_font_t *font HB_UNUSED,
139 			  void *font_data,
140 			  hb_codepoint_t glyph,
141 			  hb_position_t *x,
142 			  hb_position_t *y,
143 			  void *user_data HB_UNUSED)
144 {
145   return false;
146 }
147 
148 static hb_position_t
149 hb_jdk_get_glyph_h_kerning (hb_font_t *font,
150 			   void *font_data,
151 			   hb_codepoint_t lejdk_glyph,
152 			   hb_codepoint_t right_glyph,
153 			   void *user_data HB_UNUSED)
154 {
155   /* Not implemented. This seems to be in the HB API
156    * as a way to fall back to Freetype&#39;s kerning support
157    * which could be based on some on-the fly glyph analysis.
158    * But more likely it reads the kern table. That is easy
159    * enough code to add if we find a need to fall back
160    * to that instead of using gpos. It seems like if
161    * there is a gpos table at all, the practice is to
162    * use that and ignore kern, no matter that gpos does
163    * not implement the kern feature.
164    */
165   return 0;
166 }
167 
168 static hb_position_t
169 hb_jdk_get_glyph_v_kerning (hb_font_t *font HB_UNUSED,
170 			   void *font_data HB_UNUSED,
171 			   hb_codepoint_t top_glyph HB_UNUSED,
172 			   hb_codepoint_t bottom_glyph HB_UNUSED,
173 			   void *user_data HB_UNUSED)
174 {
175   /* OpenType doesn&#39;t have vertical-kerning other than GPOS. */
176   return 0;
177 }
178 
179 static hb_bool_t
180 hb_jdk_get_glyph_extents (hb_font_t *font HB_UNUSED,
181 			 void *font_data,
182 			 hb_codepoint_t glyph,
183 			 hb_glyph_extents_t *extents,
184 			 void *user_data HB_UNUSED)
185 {
186   /* TODO */
187   return false;
188 }
189 
190 static hb_bool_t
191 hb_jdk_get_glyph_contour_point (hb_font_t *font HB_UNUSED,
192 			       void *font_data,
193 			       hb_codepoint_t glyph,
194 			       unsigned int point_index,
195 			       hb_position_t *x,
196 			       hb_position_t *y,
197 			       void *user_data HB_UNUSED)
198 {
199     if ((glyph &amp; 0xfffe) == 0xfffe) {
200         *x = 0; *y = 0;
201         return true;
202     }
203 
204     JDKFontInfo *jdkFontInfo = (JDKFontInfo*)font_data;
205     JNIEnv* env = jdkFontInfo-&gt;env;
206     jobject fontStrike = jdkFontInfo-&gt;fontStrike;
207     jobject pt = env-&gt;CallObjectMethod(fontStrike,
208                                        sunFontIDs.getGlyphPointMID,
209                                        glyph, point_index);
210 
211     if (pt == NULL) {
212         *x = 0; *y = 0;
213         return true;
214     }
215     *x = HBFloatToFixed(env-&gt;GetFloatField(pt, sunFontIDs.xFID));
216     *y = HBFloatToFixed(env-&gt;GetFloatField(pt, sunFontIDs.yFID));
217     env-&gt;DeleteLocalRef(pt);
218 
219   return true;
220 }
221 
222 static hb_bool_t
223 hb_jdk_get_glyph_name (hb_font_t *font HB_UNUSED,
224 		      void *font_data,
225 		      hb_codepoint_t glyph,
226 		      char *name, unsigned int size,
227 		      void *user_data HB_UNUSED)
228 {
229   return false;
230 }
231 
232 static hb_bool_t
233 hb_jdk_get_glyph_from_name (hb_font_t *font HB_UNUSED,
234 			   void *font_data,
235 			   const char *name, int len,
236 			   hb_codepoint_t *glyph,
237 			   void *user_data HB_UNUSED)
238 {
239   return false;
240 }
241 
242 // remind : can we initialise this from the code we call
243 // from the class static method in Java to make it
244 // completely thread safe.
245 static hb_font_funcs_t *
246 _hb_jdk_get_font_funcs (void)
247 {
248   static hb_font_funcs_t *jdk_ffuncs = NULL;
249   hb_font_funcs_t *ff;
250 
251   if (!jdk_ffuncs) {
252       ff = hb_font_funcs_create();
253 
<a name="5" id="anc5"></a><span class="line-modified">254       hb_font_funcs_set_glyph_func(ff, hb_jdk_get_glyph, NULL, NULL);</span>

255       hb_font_funcs_set_glyph_h_advance_func(ff,
256                     hb_jdk_get_glyph_h_advance, NULL, NULL);
257       hb_font_funcs_set_glyph_v_advance_func(ff,
258                     hb_jdk_get_glyph_v_advance, NULL, NULL);
259       hb_font_funcs_set_glyph_h_origin_func(ff,
260                     hb_jdk_get_glyph_h_origin, NULL, NULL);
261       hb_font_funcs_set_glyph_v_origin_func(ff,
262                     hb_jdk_get_glyph_v_origin, NULL, NULL);
263       hb_font_funcs_set_glyph_h_kerning_func(ff,
264                     hb_jdk_get_glyph_h_kerning, NULL, NULL);
265       hb_font_funcs_set_glyph_v_kerning_func(ff,
266                     hb_jdk_get_glyph_v_kerning, NULL, NULL);
267       hb_font_funcs_set_glyph_extents_func(ff,
268                     hb_jdk_get_glyph_extents, NULL, NULL);
269       hb_font_funcs_set_glyph_contour_point_func(ff,
270                     hb_jdk_get_glyph_contour_point, NULL, NULL);
271       hb_font_funcs_set_glyph_name_func(ff,
272                     hb_jdk_get_glyph_name, NULL, NULL);
273       hb_font_funcs_set_glyph_from_name_func(ff,
274                     hb_jdk_get_glyph_from_name, NULL, NULL);
275       hb_font_funcs_make_immutable(ff); // done setting functions.
276       jdk_ffuncs = ff;
277   }
278   return jdk_ffuncs;
279 }
280 
281 static void _do_nothing(void) {
282 }
283 
284 static void _free_nothing(void*) {
285 }
286 
<a name="6" id="anc6"></a>














287 static hb_blob_t *
288 reference_table(hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data) {
289 
<a name="7" id="anc7"></a><span class="line-modified">290   JDKFontInfo *jdkFontInfo = (JDKFontInfo*)user_data;</span>
<span class="line-modified">291   JNIEnv* env = jdkFontInfo-&gt;env;</span>
<span class="line-modified">292   jobject font2D = jdkFontInfo-&gt;font2D;</span>
<span class="line-modified">293   jsize length = 0;</span>
<span class="line-modified">294   void* buffer = NULL;</span>
<span class="line-removed">295   int cacheIdx = 0;</span>
296 
297   // HB_TAG_NONE is 0 and is used to get the whole font file.
298   // It is not expected to be needed for JDK.
<a name="8" id="anc8"></a><span class="line-modified">299   if (tag == 0 || jdkFontInfo-&gt;layoutTables == NULL) {</span>
300       return NULL;
301   }
302 
<a name="9" id="anc9"></a><span class="line-modified">303   for (cacheIdx=0; cacheIdx&lt;LAYOUTCACHE_ENTRIES; cacheIdx++) {</span>
<span class="line-modified">304     if (tag == jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].tag) break;</span>


305   }
<a name="10" id="anc10"></a>
306 
<a name="11" id="anc11"></a><span class="line-modified">307   if (cacheIdx &lt; LAYOUTCACHE_ENTRIES) { // if found</span>
<span class="line-modified">308       if (jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len != -1) {</span>
<span class="line-modified">309           length = jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len;</span>
<span class="line-modified">310           buffer = (void*)jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].ptr;</span>
<span class="line-removed">311       }</span>
312   }
<a name="12" id="anc12"></a><span class="line-modified">313 </span>

314   if (buffer == NULL) {
<a name="13" id="anc13"></a><span class="line-modified">315       jbyteArray tableBytes = (jbyteArray)</span>
<span class="line-removed">316          env-&gt;CallObjectMethod(font2D, sunFontIDs.getTableBytesMID, tag);</span>
<span class="line-removed">317       if (tableBytes == NULL) {</span>
<span class="line-removed">318           return NULL;</span>
<span class="line-removed">319       }</span>
<span class="line-removed">320       length = env-&gt;GetArrayLength(tableBytes);</span>
<span class="line-removed">321       buffer = calloc(length, sizeof(jbyte));</span>
<span class="line-removed">322       env-&gt;GetByteArrayRegion(tableBytes, 0, length, (jbyte*)buffer);</span>
<span class="line-removed">323 </span>
<span class="line-removed">324      if (cacheIdx &gt;= LAYOUTCACHE_ENTRIES) { // not a cacheable table</span>
<span class="line-removed">325           return hb_blob_create((const char *)buffer, length,</span>
<span class="line-removed">326                                  HB_MEMORY_MODE_WRITABLE,</span>
<span class="line-removed">327                                  buffer, free);</span>
<span class="line-removed">328       } else {</span>
<span class="line-removed">329         jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].len = length;</span>
<span class="line-removed">330         jdkFontInfo-&gt;layoutTables-&gt;entries[cacheIdx].ptr = buffer;</span>
<span class="line-removed">331       }</span>
332   }
<a name="14" id="anc14"></a>
333 
334   return hb_blob_create((const char *)buffer, length,
<a name="15" id="anc15"></a><span class="line-modified">335                          HB_MEMORY_MODE_READONLY,</span>
<span class="line-modified">336                          NULL, _free_nothing);</span>
337 }
338 
<a name="16" id="anc16"></a>
339 
<a name="17" id="anc17"></a>































340 
<a name="18" id="anc18"></a><span class="line-modified">341 hb_face_t*</span>
<span class="line-modified">342 hb_jdk_face_create(JDKFontInfo *jdkFontInfo,</span>
<span class="line-modified">343                    hb_destroy_func_t destroy) {</span>
<span class="line-modified">344 </span>
<span class="line-modified">345     hb_face_t *face =</span>
<span class="line-modified">346          hb_face_create_for_tables(reference_table, jdkFontInfo, destroy);</span>
<span class="line-modified">347 </span>
<span class="line-modified">348     return face;</span>


349 }
350 
<a name="19" id="anc19"></a><span class="line-modified">351 static hb_font_t* _hb_jdk_font_create(JDKFontInfo *jdkFontInfo,</span>



352                                       hb_destroy_func_t destroy) {
353 
354     hb_font_t *font;
<a name="20" id="anc20"></a><span class="line-removed">355     hb_face_t *face;</span>
356 
<a name="21" id="anc21"></a><span class="line-removed">357     face = hb_jdk_face_create(jdkFontInfo, destroy);</span>
358     font = hb_font_create(face);
<a name="22" id="anc22"></a><span class="line-removed">359     hb_face_destroy (face);</span>
360     hb_font_set_funcs (font,
361                        _hb_jdk_get_font_funcs (),
362                        jdkFontInfo, (hb_destroy_func_t) _do_nothing);
363     hb_font_set_scale (font,
364                       HBFloatToFixed(jdkFontInfo-&gt;ptSize*jdkFontInfo-&gt;devScale),
365                       HBFloatToFixed(jdkFontInfo-&gt;ptSize*jdkFontInfo-&gt;devScale));
366   return font;
367 }
368 
369 #ifdef MACOSX
<a name="23" id="anc23"></a><span class="line-modified">370 static hb_font_t* _hb_jdk_ct_font_create(JDKFontInfo *jdkFontInfo) {</span>

371 
372     hb_font_t *font = NULL;
<a name="24" id="anc24"></a><span class="line-removed">373     hb_face_t *face = NULL;</span>
<span class="line-removed">374     if (jdkFontInfo-&gt;nativeFont == 0) {</span>
<span class="line-removed">375         return NULL;</span>
<span class="line-removed">376     }</span>
<span class="line-removed">377     face = hb_coretext_face_create((CGFontRef)(jdkFontInfo-&gt;nativeFont));</span>
378     font = hb_font_create(face);
<a name="25" id="anc25"></a><span class="line-removed">379     hb_face_destroy(face);</span>
<span class="line-removed">380 </span>
381     hb_font_set_scale(font,
382                      HBFloatToFixed(jdkFontInfo-&gt;ptSize),
383                      HBFloatToFixed(jdkFontInfo-&gt;ptSize));
384     return font;
385 }
386 #endif
387 
<a name="26" id="anc26"></a><span class="line-modified">388 hb_font_t* hb_jdk_font_create(JDKFontInfo *jdkFontInfo,</span>

389                              hb_destroy_func_t destroy) {
<a name="27" id="anc27"></a><span class="line-removed">390 </span>
<span class="line-removed">391    hb_font_t* font = NULL;</span>
<span class="line-removed">392 </span>
393 #ifdef MACOSX
<a name="28" id="anc28"></a><span class="line-modified">394      if (jdkFontInfo-&gt;aat) {</span>
<span class="line-modified">395          font = _hb_jdk_ct_font_create(jdkFontInfo);</span>
396      }
397 #endif
<a name="29" id="anc29"></a><span class="line-modified">398     if (font == NULL) {</span>
<span class="line-removed">399         font = _hb_jdk_font_create(jdkFontInfo, destroy);</span>
<span class="line-removed">400     }</span>
<span class="line-removed">401     return font;</span>
402 }
<a name="30" id="anc30"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="30" type="hidden" />
</body>
</html>
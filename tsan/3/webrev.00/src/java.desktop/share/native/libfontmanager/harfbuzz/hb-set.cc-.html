<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-set.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright Â© 2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #include &quot;hb-set-private.hh&quot;
 28 
 29 
 30 /* Public API */
 31 
 32 
 33 /**
 34  * hb_set_create: (Xconstructor)
 35  *
 36  * Return value: (transfer full):
 37  *
 38  * Since: 0.9.2
 39  **/
 40 hb_set_t *
 41 hb_set_create (void)
 42 {
 43   hb_set_t *set;
 44 
 45   if (!(set = hb_object_create&lt;hb_set_t&gt; ()))
 46     return hb_set_get_empty ();
 47 
 48   set-&gt;init_shallow ();
 49 
 50   return set;
 51 }
 52 
 53 /**
 54  * hb_set_get_empty:
 55  *
 56  * Return value: (transfer full):
 57  *
 58  * Since: 0.9.2
 59  **/
 60 hb_set_t *
 61 hb_set_get_empty (void)
 62 {
 63   return const_cast&lt;hb_set_t *&gt; (&amp;Null(hb_set_t));
 64 }
 65 
 66 /**
 67  * hb_set_reference: (skip)
 68  * @set: a set.
 69  *
 70  * Return value: (transfer full):
 71  *
 72  * Since: 0.9.2
 73  **/
 74 hb_set_t *
 75 hb_set_reference (hb_set_t *set)
 76 {
 77   return hb_object_reference (set);
 78 }
 79 
 80 /**
 81  * hb_set_destroy: (skip)
 82  * @set: a set.
 83  *
 84  * Since: 0.9.2
 85  **/
 86 void
 87 hb_set_destroy (hb_set_t *set)
 88 {
 89   if (!hb_object_destroy (set)) return;
 90 
 91   set-&gt;fini_shallow ();
 92 
 93   free (set);
 94 }
 95 
 96 /**
 97  * hb_set_set_user_data: (skip)
 98  * @set: a set.
 99  * @key:
100  * @data:
101  * @destroy:
102  * @replace:
103  *
104  * Return value:
105  *
106  * Since: 0.9.2
107  **/
108 hb_bool_t
109 hb_set_set_user_data (hb_set_t           *set,
110                       hb_user_data_key_t *key,
111                       void *              data,
112                       hb_destroy_func_t   destroy,
113                       hb_bool_t           replace)
114 {
115   return hb_object_set_user_data (set, key, data, destroy, replace);
116 }
117 
118 /**
119  * hb_set_get_user_data: (skip)
120  * @set: a set.
121  * @key:
122  *
123  * Return value: (transfer none):
124  *
125  * Since: 0.9.2
126  **/
127 void *
128 hb_set_get_user_data (hb_set_t           *set,
129                       hb_user_data_key_t *key)
130 {
131   return hb_object_get_user_data (set, key);
132 }
133 
134 
135 /**
136  * hb_set_allocation_successful:
137  * @set: a set.
138  *
139  *
140  *
141  * Return value:
142  *
143  * Since: 0.9.2
144  **/
145 hb_bool_t
146 hb_set_allocation_successful (const hb_set_t  *set)
147 {
148   return set-&gt;successful;
149 }
150 
151 /**
152  * hb_set_clear:
153  * @set: a set.
154  *
155  *
156  *
157  * Since: 0.9.2
158  **/
159 void
160 hb_set_clear (hb_set_t *set)
161 {
162   set-&gt;clear ();
163 }
164 
165 /**
166  * hb_set_is_empty:
167  * @set: a set.
168  *
169  *
170  *
171  * Return value:
172  *
173  * Since: 0.9.7
174  **/
175 hb_bool_t
176 hb_set_is_empty (const hb_set_t *set)
177 {
178   return set-&gt;is_empty ();
179 }
180 
181 /**
182  * hb_set_has:
183  * @set: a set.
184  * @codepoint:
185  *
186  *
187  *
188  * Return value:
189  *
190  * Since: 0.9.2
191  **/
192 hb_bool_t
193 hb_set_has (const hb_set_t *set,
194             hb_codepoint_t  codepoint)
195 {
196   return set-&gt;has (codepoint);
197 }
198 
199 /**
200  * hb_set_add:
201  * @set: a set.
202  * @codepoint:
203  *
204  *
205  *
206  * Since: 0.9.2
207  **/
208 void
209 hb_set_add (hb_set_t       *set,
210             hb_codepoint_t  codepoint)
211 {
212   set-&gt;add (codepoint);
213 }
214 
215 /**
216  * hb_set_add_range:
217  * @set: a set.
218  * @first:
219  * @last:
220  *
221  *
222  *
223  * Since: 0.9.7
224  **/
225 void
226 hb_set_add_range (hb_set_t       *set,
227                   hb_codepoint_t  first,
228                   hb_codepoint_t  last)
229 {
230   set-&gt;add_range (first, last);
231 }
232 
233 /**
234  * hb_set_del:
235  * @set: a set.
236  * @codepoint:
237  *
238  *
239  *
240  * Since: 0.9.2
241  **/
242 void
243 hb_set_del (hb_set_t       *set,
244             hb_codepoint_t  codepoint)
245 {
246   set-&gt;del (codepoint);
247 }
248 
249 /**
250  * hb_set_del_range:
251  * @set: a set.
252  * @first:
253  * @last:
254  *
255  *
256  *
257  * Since: 0.9.7
258  **/
259 void
260 hb_set_del_range (hb_set_t       *set,
261                   hb_codepoint_t  first,
262                   hb_codepoint_t  last)
263 {
264   set-&gt;del_range (first, last);
265 }
266 
267 /**
268  * hb_set_is_equal:
269  * @set: a set.
270  * @other: other set.
271  *
272  *
273  *
274  * Return value: %TRUE if the two sets are equal, %FALSE otherwise.
275  *
276  * Since: 0.9.7
277  **/
278 hb_bool_t
279 hb_set_is_equal (const hb_set_t *set,
280                  const hb_set_t *other)
281 {
282   return set-&gt;is_equal (other);
283 }
284 
285 /**
286  * hb_set_is_subset:
287  * @set: a set.
288  * @larger_set: other set.
289  *
290  *
291  *
292  * Return value: %TRUE if the @set is a subset of (or equal to) @larger_set, %FALSE otherwise.
293  *
294  * Since: 1.8.1
295  **/
296 hb_bool_t
297 hb_set_is_subset (const hb_set_t *set,
298                   const hb_set_t *larger_set)
299 {
300   return set-&gt;is_subset (larger_set);
301 }
302 
303 /**
304  * hb_set_set:
305  * @set: a set.
306  * @other:
307  *
308  *
309  *
310  * Since: 0.9.2
311  **/
312 void
313 hb_set_set (hb_set_t       *set,
314             const hb_set_t *other)
315 {
316   set-&gt;set (other);
317 }
318 
319 /**
320  * hb_set_union:
321  * @set: a set.
322  * @other:
323  *
324  *
325  *
326  * Since: 0.9.2
327  **/
328 void
329 hb_set_union (hb_set_t       *set,
330               const hb_set_t *other)
331 {
332   set-&gt;union_ (other);
333 }
334 
335 /**
336  * hb_set_intersect:
337  * @set: a set.
338  * @other:
339  *
340  *
341  *
342  * Since: 0.9.2
343  **/
344 void
345 hb_set_intersect (hb_set_t       *set,
346                   const hb_set_t *other)
347 {
348   set-&gt;intersect (other);
349 }
350 
351 /**
352  * hb_set_subtract:
353  * @set: a set.
354  * @other:
355  *
356  *
357  *
358  * Since: 0.9.2
359  **/
360 void
361 hb_set_subtract (hb_set_t       *set,
362                  const hb_set_t *other)
363 {
364   set-&gt;subtract (other);
365 }
366 
367 /**
368  * hb_set_symmetric_difference:
369  * @set: a set.
370  * @other:
371  *
372  *
373  *
374  * Since: 0.9.2
375  **/
376 void
377 hb_set_symmetric_difference (hb_set_t       *set,
378                              const hb_set_t *other)
379 {
380   set-&gt;symmetric_difference (other);
381 }
382 
383 /**
384  * hb_set_invert:
385  * @set: a set.
386  *
387  *
388  *
389  * Since: 0.9.10
390  *
391  * Deprecated: 1.6.1
392  **/
393 void
394 hb_set_invert (hb_set_t *set)
395 {
396 }
397 
398 /**
399  * hb_set_get_population:
400  * @set: a set.
401  *
402  * Returns the number of numbers in the set.
403  *
404  * Return value: set population.
405  *
406  * Since: 0.9.7
407  **/
408 unsigned int
409 hb_set_get_population (const hb_set_t *set)
410 {
411   return set-&gt;get_population ();
412 }
413 
414 /**
415  * hb_set_get_min:
416  * @set: a set.
417  *
418  * Finds the minimum number in the set.
419  *
420  * Return value: minimum of the set, or %HB_SET_VALUE_INVALID if set is empty.
421  *
422  * Since: 0.9.7
423  **/
424 hb_codepoint_t
425 hb_set_get_min (const hb_set_t *set)
426 {
427   return set-&gt;get_min ();
428 }
429 
430 /**
431  * hb_set_get_max:
432  * @set: a set.
433  *
434  * Finds the maximum number in the set.
435  *
436  * Return value: minimum of the set, or %HB_SET_VALUE_INVALID if set is empty.
437  *
438  * Since: 0.9.7
439  **/
440 hb_codepoint_t
441 hb_set_get_max (const hb_set_t *set)
442 {
443   return set-&gt;get_max ();
444 }
445 
446 /**
447  * hb_set_next:
448  * @set: a set.
449  * @codepoint: (inout):
450  *
451  * Gets the next number in @set that is greater than current value of @codepoint.
452  *
453  * Set @codepoint to %HB_SET_VALUE_INVALID to get started.
454  *
455  * Return value: whether there was a next value.
456  *
457  * Since: 0.9.2
458  **/
459 hb_bool_t
460 hb_set_next (const hb_set_t *set,
461              hb_codepoint_t *codepoint)
462 {
463   return set-&gt;next (codepoint);
464 }
465 
466 /**
467  * hb_set_previous:
468  * @set: a set.
469  * @codepoint: (inout):
470  *
471  * Gets the previous number in @set that is slower than current value of @codepoint.
472  *
473  * Set @codepoint to %HB_SET_VALUE_INVALID to get started.
474  *
475  * Return value: whether there was a previous value.
476  *
477  * Since: 1.8.0
478  **/
479 hb_bool_t
480 hb_set_previous (const hb_set_t *set,
481                  hb_codepoint_t *codepoint)
482 {
483   return set-&gt;previous (codepoint);
484 }
485 
486 /**
487  * hb_set_next_range:
488  * @set: a set.
489  * @first: (out): output first codepoint in the range.
490  * @last: (inout): input current last and output last codepoint in the range.
491  *
492  * Gets the next consecutive range of numbers in @set that
493  * are greater than current value of @last.
494  *
495  * Set @last to %HB_SET_VALUE_INVALID to get started.
496  *
497  * Return value: whether there was a next range.
498  *
499  * Since: 0.9.7
500  **/
501 hb_bool_t
502 hb_set_next_range (const hb_set_t *set,
503                    hb_codepoint_t *first,
504                    hb_codepoint_t *last)
505 {
506   return set-&gt;next_range (first, last);
507 }
508 
509 /**
510  * hb_set_previous_range:
511  * @set: a set.
512  * @first: (inout): input current first and output first codepoint in the range.
513  * @last: (out): output last codepoint in the range.
514  *
515  * Gets the previous consecutive range of numbers in @set that
516  * are greater than current value of @last.
517  *
518  * Set @first to %HB_SET_VALUE_INVALID to get started.
519  *
520  * Return value: whether there was a previous range.
521  *
522  * Since: 1.8.0
523  **/
524 hb_bool_t
525 hb_set_previous_range (const hb_set_t *set,
526                        hb_codepoint_t *first,
527                        hb_codepoint_t *last)
528 {
529   return set-&gt;previous_range (first, last);
530 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gpos-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright © 2007,2008,2009,2010  Red Hat, Inc.
   3  * Copyright © 2010,2012,2013  Google, Inc.
   4  *
   5  *  This is part of HarfBuzz, a text shaping library.
   6  *
   7  * Permission is hereby granted, without written agreement and without
   8  * license or royalty fees, to use, copy, modify, and distribute this
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GPOS_TABLE_HH
  30 #define HB_OT_LAYOUT_GPOS_TABLE_HH
  31 
  32 #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;
  33 
  34 
  35 namespace OT {
  36 
  37 
  38 /* buffer **position** var allocations */
  39 #define attach_chain() var.i16[0] /* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. */
  40 #define attach_type() var.u8[2] /* attachment type */
  41 /* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. */
  42 
  43 enum attach_type_t {
  44   ATTACH_TYPE_NONE      = 0X00,
  45 
  46   /* Each attachment should be either a mark or a cursive; can&#39;t be both. */
  47   ATTACH_TYPE_MARK      = 0X01,
  48   ATTACH_TYPE_CURSIVE   = 0X02,
  49 };
  50 
  51 
  52 /* Shared Tables: ValueRecord, Anchor Table, and MarkArray */
  53 
  54 typedef HBUINT16 Value;
  55 
  56 typedef Value ValueRecord[VAR];
  57 
  58 struct ValueFormat : HBUINT16
  59 {
  60   enum Flags {
  61     xPlacement  = 0x0001u,      /* Includes horizontal adjustment for placement */
  62     yPlacement  = 0x0002u,      /* Includes vertical adjustment for placement */
  63     xAdvance    = 0x0004u,      /* Includes horizontal adjustment for advance */
  64     yAdvance    = 0x0008u,      /* Includes vertical adjustment for advance */
  65     xPlaDevice  = 0x0010u,      /* Includes horizontal Device table for placement */
  66     yPlaDevice  = 0x0020u,      /* Includes vertical Device table for placement */
  67     xAdvDevice  = 0x0040u,      /* Includes horizontal Device table for advance */
  68     yAdvDevice  = 0x0080u,      /* Includes vertical Device table for advance */
  69     ignored     = 0x0F00u,      /* Was used in TrueType Open for MM fonts */
  70     reserved    = 0xF000u,      /* For future use */
  71 
  72     devices     = 0x00F0u       /* Mask for having any Device table */
  73   };
  74 
  75 /* All fields are options.  Only those available advance the value pointer. */
  76 #if 0
  77   HBINT16               xPlacement;             /* Horizontal adjustment for
  78                                          * placement--in design units */
  79   HBINT16               yPlacement;             /* Vertical adjustment for
  80                                          * placement--in design units */
  81   HBINT16               xAdvance;               /* Horizontal adjustment for
  82                                          * advance--in design units (only used
  83                                          * for horizontal writing) */
  84   HBINT16               yAdvance;               /* Vertical adjustment for advance--in
  85                                          * design units (only used for vertical
  86                                          * writing) */
  87   Offset        xPlaDevice;             /* Offset to Device table for
  88                                          * horizontal placement--measured from
  89                                          * beginning of PosTable (may be NULL) */
  90   Offset        yPlaDevice;             /* Offset to Device table for vertical
  91                                          * placement--measured from beginning
  92                                          * of PosTable (may be NULL) */
  93   Offset        xAdvDevice;             /* Offset to Device table for
  94                                          * horizontal advance--measured from
  95                                          * beginning of PosTable (may be NULL) */
  96   Offset        yAdvDevice;             /* Offset to Device table for vertical
  97                                          * advance--measured from beginning of
  98                                          * PosTable (may be NULL) */
  99 #endif
 100 
 101   inline unsigned int get_len (void) const
 102   { return _hb_popcount ((unsigned int) *this); }
 103   inline unsigned int get_size (void) const
 104   { return get_len () * Value::static_size; }
 105 
 106   void apply_value (hb_ot_apply_context_t   *c,
 107                     const void           *base,
 108                     const Value          *values,
 109                     hb_glyph_position_t  &amp;glyph_pos) const
 110   {
 111     unsigned int format = *this;
 112     if (!format) return;
 113 
 114     hb_font_t *font = c-&gt;font;
 115     hb_bool_t horizontal = HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction);
 116 
 117     if (format &amp; xPlacement) glyph_pos.x_offset  += font-&gt;em_scale_x (get_short (values++));
 118     if (format &amp; yPlacement) glyph_pos.y_offset  += font-&gt;em_scale_y (get_short (values++));
 119     if (format &amp; xAdvance) {
 120       if (likely (horizontal)) glyph_pos.x_advance += font-&gt;em_scale_x (get_short (values));
 121       values++;
 122     }
 123     /* y_advance values grow downward but font-space grows upward, hence negation */
 124     if (format &amp; yAdvance) {
 125       if (unlikely (!horizontal)) glyph_pos.y_advance -= font-&gt;em_scale_y (get_short (values));
 126       values++;
 127     }
 128 
 129     if (!has_device ()) return;
 130 
 131     bool use_x_device = font-&gt;x_ppem || font-&gt;num_coords;
 132     bool use_y_device = font-&gt;y_ppem || font-&gt;num_coords;
 133 
 134     if (!use_x_device &amp;&amp; !use_y_device) return;
 135 
 136     const VariationStore &amp;store = c-&gt;var_store;
 137 
 138     /* pixel -&gt; fractional pixel */
 139     if (format &amp; xPlaDevice) {
 140       if (use_x_device) glyph_pos.x_offset  += (base + get_device (values)).get_x_delta (font, store);
 141       values++;
 142     }
 143     if (format &amp; yPlaDevice) {
 144       if (use_y_device) glyph_pos.y_offset  += (base + get_device (values)).get_y_delta (font, store);
 145       values++;
 146     }
 147     if (format &amp; xAdvDevice) {
 148       if (horizontal &amp;&amp; use_x_device) glyph_pos.x_advance += (base + get_device (values)).get_x_delta (font, store);
 149       values++;
 150     }
 151     if (format &amp; yAdvDevice) {
 152       /* y_advance values grow downward but font-space grows upward, hence negation */
 153       if (!horizontal &amp;&amp; use_y_device) glyph_pos.y_advance -= (base + get_device (values)).get_y_delta (font, store);
 154       values++;
 155     }
 156   }
 157 
 158   private:
 159   inline bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const
 160   {
 161     unsigned int format = *this;
 162 
 163     if (format &amp; xPlacement) values++;
 164     if (format &amp; yPlacement) values++;
 165     if (format &amp; xAdvance)   values++;
 166     if (format &amp; yAdvance)   values++;
 167 
 168     if ((format &amp; xPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 169     if ((format &amp; yPlaDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 170     if ((format &amp; xAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 171     if ((format &amp; yAdvDevice) &amp;&amp; !get_device (values++).sanitize (c, base)) return false;
 172 
 173     return true;
 174   }
 175 
 176   static inline OffsetTo&lt;Device&gt;&amp; get_device (Value* value)
 177   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }
 178   static inline const OffsetTo&lt;Device&gt;&amp; get_device (const Value* value)
 179   { return *CastP&lt;OffsetTo&lt;Device&gt; &gt; (value); }
 180 
 181   static inline const HBINT16&amp; get_short (const Value* value)
 182   { return *CastP&lt;HBINT16&gt; (value); }
 183 
 184   public:
 185 
 186   inline bool has_device (void) const {
 187     unsigned int format = *this;
 188     return (format &amp; devices) != 0;
 189   }
 190 
 191   inline bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const
 192   {
 193     TRACE_SANITIZE (this);
 194     return_trace (c-&gt;check_range (values, get_size ()) &amp;&amp; (!has_device () || sanitize_value_devices (c, base, values)));
 195   }
 196 
 197   inline bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const
 198   {
 199     TRACE_SANITIZE (this);
 200     unsigned int len = get_len ();
 201 
 202     if (!c-&gt;check_array (values, get_size (), count)) return_trace (false);
 203 
 204     if (!has_device ()) return_trace (true);
 205 
 206     for (unsigned int i = 0; i &lt; count; i++) {
 207       if (!sanitize_value_devices (c, base, values))
 208         return_trace (false);
 209       values += len;
 210     }
 211 
 212     return_trace (true);
 213   }
 214 
 215   /* Just sanitize referenced Device tables.  Doesn&#39;t check the values themselves. */
 216   inline bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const
 217   {
 218     TRACE_SANITIZE (this);
 219 
 220     if (!has_device ()) return_trace (true);
 221 
 222     for (unsigned int i = 0; i &lt; count; i++) {
 223       if (!sanitize_value_devices (c, base, values))
 224         return_trace (false);
 225       values += stride;
 226     }
 227 
 228     return_trace (true);
 229   }
 230 };
 231 
 232 
 233 struct AnchorFormat1
 234 {
 235   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,
 236                           float *x, float *y) const
 237   {
 238     hb_font_t *font = c-&gt;font;
 239     *x = font-&gt;em_fscale_x (xCoordinate);
 240     *y = font-&gt;em_fscale_y (yCoordinate);
 241   }
 242 
 243   inline bool sanitize (hb_sanitize_context_t *c) const
 244   {
 245     TRACE_SANITIZE (this);
 246     return_trace (c-&gt;check_struct (this));
 247   }
 248 
 249   protected:
 250   HBUINT16      format;                 /* Format identifier--format = 1 */
 251   FWORD         xCoordinate;            /* Horizontal value--in design units */
 252   FWORD         yCoordinate;            /* Vertical value--in design units */
 253   public:
 254   DEFINE_SIZE_STATIC (6);
 255 };
 256 
 257 struct AnchorFormat2
 258 {
 259   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,
 260                           float *x, float *y) const
 261   {
 262     hb_font_t *font = c-&gt;font;
 263     unsigned int x_ppem = font-&gt;x_ppem;
 264     unsigned int y_ppem = font-&gt;y_ppem;
 265     hb_position_t cx = 0, cy = 0;
 266     hb_bool_t ret;
 267 
 268     ret = (x_ppem || y_ppem) &amp;&amp;
 269            font-&gt;get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &amp;cx, &amp;cy);
 270     *x = ret &amp;&amp; x_ppem ? cx : font-&gt;em_fscale_x (xCoordinate);
 271     *y = ret &amp;&amp; y_ppem ? cy : font-&gt;em_fscale_y (yCoordinate);
 272   }
 273 
 274   inline bool sanitize (hb_sanitize_context_t *c) const
 275   {
 276     TRACE_SANITIZE (this);
 277     return_trace (c-&gt;check_struct (this));
 278   }
 279 
 280   protected:
 281   HBUINT16      format;                 /* Format identifier--format = 2 */
 282   FWORD         xCoordinate;            /* Horizontal value--in design units */
 283   FWORD         yCoordinate;            /* Vertical value--in design units */
 284   HBUINT16      anchorPoint;            /* Index to glyph contour point */
 285   public:
 286   DEFINE_SIZE_STATIC (8);
 287 };
 288 
 289 struct AnchorFormat3
 290 {
 291   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,
 292                           float *x, float *y) const
 293   {
 294     hb_font_t *font = c-&gt;font;
 295     *x = font-&gt;em_fscale_x (xCoordinate);
 296     *y = font-&gt;em_fscale_y (yCoordinate);
 297 
 298     if (font-&gt;x_ppem || font-&gt;num_coords)
 299       *x += (this+xDeviceTable).get_x_delta (font, c-&gt;var_store);
 300     if (font-&gt;y_ppem || font-&gt;num_coords)
 301       *y += (this+yDeviceTable).get_y_delta (font, c-&gt;var_store);
 302   }
 303 
 304   inline bool sanitize (hb_sanitize_context_t *c) const
 305   {
 306     TRACE_SANITIZE (this);
 307     return_trace (c-&gt;check_struct (this) &amp;&amp; xDeviceTable.sanitize (c, this) &amp;&amp; yDeviceTable.sanitize (c, this));
 308   }
 309 
 310   protected:
 311   HBUINT16      format;                 /* Format identifier--format = 3 */
 312   FWORD         xCoordinate;            /* Horizontal value--in design units */
 313   FWORD         yCoordinate;            /* Vertical value--in design units */
 314   OffsetTo&lt;Device&gt;
 315                 xDeviceTable;           /* Offset to Device table for X
 316                                          * coordinate-- from beginning of
 317                                          * Anchor table (may be NULL) */
 318   OffsetTo&lt;Device&gt;
 319                 yDeviceTable;           /* Offset to Device table for Y
 320                                          * coordinate-- from beginning of
 321                                          * Anchor table (may be NULL) */
 322   public:
 323   DEFINE_SIZE_STATIC (10);
 324 };
 325 
 326 struct Anchor
 327 {
 328   inline void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,
 329                           float *x, float *y) const
 330   {
 331     *x = *y = 0;
 332     switch (u.format) {
 333     case 1: u.format1.get_anchor (c, glyph_id, x, y); return;
 334     case 2: u.format2.get_anchor (c, glyph_id, x, y); return;
 335     case 3: u.format3.get_anchor (c, glyph_id, x, y); return;
 336     default:                                          return;
 337     }
 338   }
 339 
 340   inline bool sanitize (hb_sanitize_context_t *c) const
 341   {
 342     TRACE_SANITIZE (this);
 343     if (!u.format.sanitize (c)) return_trace (false);
 344     switch (u.format) {
 345     case 1: return_trace (u.format1.sanitize (c));
 346     case 2: return_trace (u.format2.sanitize (c));
 347     case 3: return_trace (u.format3.sanitize (c));
 348     default:return_trace (true);
 349     }
 350   }
 351 
 352   protected:
 353   union {
 354   HBUINT16              format;         /* Format identifier */
 355   AnchorFormat1         format1;
 356   AnchorFormat2         format2;
 357   AnchorFormat3         format3;
 358   } u;
 359   public:
 360   DEFINE_SIZE_UNION (2, format);
 361 };
 362 
 363 
 364 struct AnchorMatrix
 365 {
 366   inline const Anchor&amp; get_anchor (unsigned int row, unsigned int col, unsigned int cols, bool *found) const {
 367     *found = false;
 368     if (unlikely (row &gt;= rows || col &gt;= cols)) return Null(Anchor);
 369     *found = !matrixZ[row * cols + col].is_null ();
 370     return this+matrixZ[row * cols + col];
 371   }
 372 
 373   inline bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const
 374   {
 375     TRACE_SANITIZE (this);
 376     if (!c-&gt;check_struct (this)) return_trace (false);
 377     if (unlikely (_hb_unsigned_int_mul_overflows (rows, cols))) return_trace (false);
 378     unsigned int count = rows * cols;
 379     if (!c-&gt;check_array (matrixZ, matrixZ[0].static_size, count)) return_trace (false);
 380     for (unsigned int i = 0; i &lt; count; i++)
 381       if (!matrixZ[i].sanitize (c, this)) return_trace (false);
 382     return_trace (true);
 383   }
 384 
 385   HBUINT16      rows;                   /* Number of rows */
 386   protected:
 387   OffsetTo&lt;Anchor&gt;
 388                 matrixZ[VAR];           /* Matrix of offsets to Anchor tables--
 389                                          * from beginning of AnchorMatrix table */
 390   public:
 391   DEFINE_SIZE_ARRAY (2, matrixZ);
 392 };
 393 
 394 
 395 struct MarkRecord
 396 {
 397   friend struct MarkArray;
 398 
 399   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const
 400   {
 401     TRACE_SANITIZE (this);
 402     return_trace (c-&gt;check_struct (this) &amp;&amp; markAnchor.sanitize (c, base));
 403   }
 404 
 405   protected:
 406   HBUINT16      klass;                  /* Class defined for this mark */
 407   OffsetTo&lt;Anchor&gt;
 408                 markAnchor;             /* Offset to Anchor table--from
 409                                          * beginning of MarkArray table */
 410   public:
 411   DEFINE_SIZE_STATIC (4);
 412 };
 413 
 414 struct MarkArray : ArrayOf&lt;MarkRecord&gt;  /* Array of MarkRecords--in Coverage order */
 415 {
 416   inline bool apply (hb_ot_apply_context_t *c,
 417                      unsigned int mark_index, unsigned int glyph_index,
 418                      const AnchorMatrix &amp;anchors, unsigned int class_count,
 419                      unsigned int glyph_pos) const
 420   {
 421     TRACE_APPLY (this);
 422     hb_buffer_t *buffer = c-&gt;buffer;
 423     const MarkRecord &amp;record = ArrayOf&lt;MarkRecord&gt;::operator[](mark_index);
 424     unsigned int mark_class = record.klass;
 425 
 426     const Anchor&amp; mark_anchor = this + record.markAnchor;
 427     bool found;
 428     const Anchor&amp; glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &amp;found);
 429     /* If this subtable doesn&#39;t have an anchor for this base and this class,
 430      * return false such that the subsequent subtables have a chance at it. */
 431     if (unlikely (!found)) return_trace (false);
 432 
 433     float mark_x, mark_y, base_x, base_y;
 434 
 435     buffer-&gt;unsafe_to_break (glyph_pos, buffer-&gt;idx);
 436     mark_anchor.get_anchor (c, buffer-&gt;cur().codepoint, &amp;mark_x, &amp;mark_y);
 437     glyph_anchor.get_anchor (c, buffer-&gt;info[glyph_pos].codepoint, &amp;base_x, &amp;base_y);
 438 
 439     hb_glyph_position_t &amp;o = buffer-&gt;cur_pos();
 440     o.x_offset = round (base_x - mark_x);
 441     o.y_offset = round (base_y - mark_y);
 442     o.attach_type() = ATTACH_TYPE_MARK;
 443     o.attach_chain() = (int) glyph_pos - (int) buffer-&gt;idx;
 444     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
 445 
 446     buffer-&gt;idx++;
 447     return_trace (true);
 448   }
 449 
 450   inline bool sanitize (hb_sanitize_context_t *c) const
 451   {
 452     TRACE_SANITIZE (this);
 453     return_trace (ArrayOf&lt;MarkRecord&gt;::sanitize (c, this));
 454   }
 455 };
 456 
 457 
 458 /* Lookups */
 459 
 460 struct SinglePosFormat1
 461 {
 462   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
 463   {
 464     TRACE_COLLECT_GLYPHS (this);
 465     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 466   }
 467 
 468   inline const Coverage &amp;get_coverage (void) const
 469   {
 470     return this+coverage;
 471   }
 472 
 473   inline bool apply (hb_ot_apply_context_t *c) const
 474   {
 475     TRACE_APPLY (this);
 476     hb_buffer_t *buffer = c-&gt;buffer;
 477     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 478     if (likely (index == NOT_COVERED)) return_trace (false);
 479 
 480     valueFormat.apply_value (c, this, values, buffer-&gt;cur_pos());
 481 
 482     buffer-&gt;idx++;
 483     return_trace (true);
 484   }
 485 
 486   inline bool sanitize (hb_sanitize_context_t *c) const
 487   {
 488     TRACE_SANITIZE (this);
 489     return_trace (c-&gt;check_struct (this) &amp;&amp;
 490                   coverage.sanitize (c, this) &amp;&amp;
 491                   valueFormat.sanitize_value (c, this, values));
 492   }
 493 
 494   protected:
 495   HBUINT16      format;                 /* Format identifier--format = 1 */
 496   OffsetTo&lt;Coverage&gt;
 497                 coverage;               /* Offset to Coverage table--from
 498                                          * beginning of subtable */
 499   ValueFormat   valueFormat;            /* Defines the types of data in the
 500                                          * ValueRecord */
 501   ValueRecord   values;                 /* Defines positioning
 502                                          * value(s)--applied to all glyphs in
 503                                          * the Coverage table */
 504   public:
 505   DEFINE_SIZE_ARRAY (6, values);
 506 };
 507 
 508 struct SinglePosFormat2
 509 {
 510   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
 511   {
 512     TRACE_COLLECT_GLYPHS (this);
 513     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 514   }
 515 
 516   inline const Coverage &amp;get_coverage (void) const
 517   {
 518     return this+coverage;
 519   }
 520 
 521   inline bool apply (hb_ot_apply_context_t *c) const
 522   {
 523     TRACE_APPLY (this);
 524     hb_buffer_t *buffer = c-&gt;buffer;
 525     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 526     if (likely (index == NOT_COVERED)) return_trace (false);
 527 
 528     if (likely (index &gt;= valueCount)) return_trace (false);
 529 
 530     valueFormat.apply_value (c, this,
 531                              &amp;values[index * valueFormat.get_len ()],
 532                              buffer-&gt;cur_pos());
 533 
 534     buffer-&gt;idx++;
 535     return_trace (true);
 536   }
 537 
 538   inline bool sanitize (hb_sanitize_context_t *c) const
 539   {
 540     TRACE_SANITIZE (this);
 541     return_trace (c-&gt;check_struct (this) &amp;&amp;
 542                   coverage.sanitize (c, this) &amp;&amp;
 543                   valueFormat.sanitize_values (c, this, values, valueCount));
 544   }
 545 
 546   protected:
 547   HBUINT16      format;                 /* Format identifier--format = 2 */
 548   OffsetTo&lt;Coverage&gt;
 549                 coverage;               /* Offset to Coverage table--from
 550                                          * beginning of subtable */
 551   ValueFormat   valueFormat;            /* Defines the types of data in the
 552                                          * ValueRecord */
 553   HBUINT16      valueCount;             /* Number of ValueRecords */
 554   ValueRecord   values;                 /* Array of ValueRecords--positioning
 555                                          * values applied to glyphs */
 556   public:
 557   DEFINE_SIZE_ARRAY (8, values);
 558 };
 559 
 560 struct SinglePos
 561 {
 562   template &lt;typename context_t&gt;
 563   inline typename context_t::return_t dispatch (context_t *c) const
 564   {
 565     TRACE_DISPATCH (this, u.format);
 566     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 567     switch (u.format) {
 568     case 1: return_trace (c-&gt;dispatch (u.format1));
 569     case 2: return_trace (c-&gt;dispatch (u.format2));
 570     default:return_trace (c-&gt;default_return_value ());
 571     }
 572   }
 573 
 574   protected:
 575   union {
 576   HBUINT16              format;         /* Format identifier */
 577   SinglePosFormat1      format1;
 578   SinglePosFormat2      format2;
 579   } u;
 580 };
 581 
 582 
 583 struct PairValueRecord
 584 {
 585   friend struct PairSet;
 586 
 587   protected:
 588   GlyphID       secondGlyph;            /* GlyphID of second glyph in the
 589                                          * pair--first glyph is listed in the
 590                                          * Coverage table */
 591   ValueRecord   values;                 /* Positioning data for the first glyph
 592                                          * followed by for second glyph */
 593   public:
 594   DEFINE_SIZE_ARRAY (2, values);
 595 };
 596 
 597 struct PairSet
 598 {
 599   friend struct PairPosFormat1;
 600 
 601   inline void collect_glyphs (hb_collect_glyphs_context_t *c,
 602                               const ValueFormat *valueFormats) const
 603   {
 604     TRACE_COLLECT_GLYPHS (this);
 605     unsigned int len1 = valueFormats[0].get_len ();
 606     unsigned int len2 = valueFormats[1].get_len ();
 607     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 608 
 609     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);
 610     c-&gt;input-&gt;add_array (&amp;record-&gt;secondGlyph, len, record_size);
 611   }
 612 
 613   inline bool apply (hb_ot_apply_context_t *c,
 614                      const ValueFormat *valueFormats,
 615                      unsigned int pos) const
 616   {
 617     TRACE_APPLY (this);
 618     hb_buffer_t *buffer = c-&gt;buffer;
 619     unsigned int len1 = valueFormats[0].get_len ();
 620     unsigned int len2 = valueFormats[1].get_len ();
 621     unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);
 622 
 623     const PairValueRecord *record_array = CastP&lt;PairValueRecord&gt; (arrayZ);
 624     unsigned int count = len;
 625 
 626     /* Hand-coded bsearch. */
 627     if (unlikely (!count))
 628       return_trace (false);
 629     hb_codepoint_t x = buffer-&gt;info[pos].codepoint;
 630     int min = 0, max = (int) count - 1;
 631     while (min &lt;= max)
 632     {
 633       int mid = (min + max) / 2;
 634       const PairValueRecord *record = &amp;StructAtOffset&lt;PairValueRecord&gt; (record_array, record_size * mid);
 635       hb_codepoint_t mid_x = record-&gt;secondGlyph;
 636       if (x &lt; mid_x)
 637         max = mid - 1;
 638       else if (x &gt; mid_x)
 639         min = mid + 1;
 640       else
 641       {
 642         buffer-&gt;unsafe_to_break (buffer-&gt;idx, pos + 1);
 643         valueFormats[0].apply_value (c, this, &amp;record-&gt;values[0], buffer-&gt;cur_pos());
 644         valueFormats[1].apply_value (c, this, &amp;record-&gt;values[len1], buffer-&gt;pos[pos]);
 645         if (len2)
 646           pos++;
 647         buffer-&gt;idx = pos;
 648         return_trace (true);
 649       }
 650     }
 651 
 652     return_trace (false);
 653   }
 654 
 655   struct sanitize_closure_t {
 656     const void *base;
 657     const ValueFormat *valueFormats;
 658     unsigned int len1; /* valueFormats[0].get_len() */
 659     unsigned int stride; /* 1 + len1 + len2 */
 660   };
 661 
 662   inline bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const
 663   {
 664     TRACE_SANITIZE (this);
 665     if (!(c-&gt;check_struct (this)
 666        &amp;&amp; c-&gt;check_array (arrayZ, HBUINT16::static_size * closure-&gt;stride, len))) return_trace (false);
 667 
 668     unsigned int count = len;
 669     const PairValueRecord *record = CastP&lt;PairValueRecord&gt; (arrayZ);
 670     return_trace (closure-&gt;valueFormats[0].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[0], count, closure-&gt;stride) &amp;&amp;
 671                   closure-&gt;valueFormats[1].sanitize_values_stride_unsafe (c, closure-&gt;base, &amp;record-&gt;values[closure-&gt;len1], count, closure-&gt;stride));
 672   }
 673 
 674   protected:
 675   HBUINT16      len;                    /* Number of PairValueRecords */
 676   HBUINT16      arrayZ[VAR];            /* Array of PairValueRecords--ordered
 677                                          * by GlyphID of the second glyph */
 678   public:
 679   DEFINE_SIZE_ARRAY (2, arrayZ);
 680 };
 681 
 682 struct PairPosFormat1
 683 {
 684   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
 685   {
 686     TRACE_COLLECT_GLYPHS (this);
 687     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 688     unsigned int count = pairSet.len;
 689     for (unsigned int i = 0; i &lt; count; i++)
 690       (this+pairSet[i]).collect_glyphs (c, valueFormat);
 691   }
 692 
 693   inline const Coverage &amp;get_coverage (void) const
 694   {
 695     return this+coverage;
 696   }
 697 
 698   inline bool apply (hb_ot_apply_context_t *c) const
 699   {
 700     TRACE_APPLY (this);
 701     hb_buffer_t *buffer = c-&gt;buffer;
 702     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 703     if (likely (index == NOT_COVERED)) return_trace (false);
 704 
 705     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 706     skippy_iter.reset (buffer-&gt;idx, 1);
 707     if (!skippy_iter.next ()) return_trace (false);
 708 
 709     return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));
 710   }
 711 
 712   inline bool sanitize (hb_sanitize_context_t *c) const
 713   {
 714     TRACE_SANITIZE (this);
 715 
 716     if (!c-&gt;check_struct (this)) return_trace (false);
 717 
 718     unsigned int len1 = valueFormat[0].get_len ();
 719     unsigned int len2 = valueFormat[1].get_len ();
 720     PairSet::sanitize_closure_t closure = {
 721       this,
 722       valueFormat,
 723       len1,
 724       1 + len1 + len2
 725     };
 726 
 727     return_trace (coverage.sanitize (c, this) &amp;&amp; pairSet.sanitize (c, this, &amp;closure));
 728   }
 729 
 730   protected:
 731   HBUINT16      format;                 /* Format identifier--format = 1 */
 732   OffsetTo&lt;Coverage&gt;
 733                 coverage;               /* Offset to Coverage table--from
 734                                          * beginning of subtable */
 735   ValueFormat   valueFormat[2];         /* [0] Defines the types of data in
 736                                          * ValueRecord1--for the first glyph
 737                                          * in the pair--may be zero (0) */
 738                                         /* [1] Defines the types of data in
 739                                          * ValueRecord2--for the second glyph
 740                                          * in the pair--may be zero (0) */
 741   OffsetArrayOf&lt;PairSet&gt;
 742                 pairSet;                /* Array of PairSet tables
 743                                          * ordered by Coverage Index */
 744   public:
 745   DEFINE_SIZE_ARRAY (10, pairSet);
 746 };
 747 
 748 struct PairPosFormat2
 749 {
 750   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
 751   {
 752     TRACE_COLLECT_GLYPHS (this);
 753     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 754     if (unlikely (!(this+classDef2).add_coverage (c-&gt;input))) return;
 755   }
 756 
 757   inline const Coverage &amp;get_coverage (void) const
 758   {
 759     return this+coverage;
 760   }
 761 
 762   inline bool apply (hb_ot_apply_context_t *c) const
 763   {
 764     TRACE_APPLY (this);
 765     hb_buffer_t *buffer = c-&gt;buffer;
 766     unsigned int index = (this+coverage).get_coverage  (buffer-&gt;cur().codepoint);
 767     if (likely (index == NOT_COVERED)) return_trace (false);
 768 
 769     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 770     skippy_iter.reset (buffer-&gt;idx, 1);
 771     if (!skippy_iter.next ()) return_trace (false);
 772 
 773     unsigned int len1 = valueFormat1.get_len ();
 774     unsigned int len2 = valueFormat2.get_len ();
 775     unsigned int record_len = len1 + len2;
 776 
 777     unsigned int klass1 = (this+classDef1).get_class (buffer-&gt;cur().codepoint);
 778     unsigned int klass2 = (this+classDef2).get_class (buffer-&gt;info[skippy_iter.idx].codepoint);
 779     if (unlikely (klass1 &gt;= class1Count || klass2 &gt;= class2Count)) return_trace (false);
 780 
 781     buffer-&gt;unsafe_to_break (buffer-&gt;idx, skippy_iter.idx + 1);
 782     const Value *v = &amp;values[record_len * (klass1 * class2Count + klass2)];
 783     valueFormat1.apply_value (c, this, v, buffer-&gt;cur_pos());
 784     valueFormat2.apply_value (c, this, v + len1, buffer-&gt;pos[skippy_iter.idx]);
 785 
 786     buffer-&gt;idx = skippy_iter.idx;
 787     if (len2)
 788       buffer-&gt;idx++;
 789 
 790     return_trace (true);
 791   }
 792 
 793   inline bool sanitize (hb_sanitize_context_t *c) const
 794   {
 795     TRACE_SANITIZE (this);
 796     if (!(c-&gt;check_struct (this)
 797        &amp;&amp; coverage.sanitize (c, this)
 798        &amp;&amp; classDef1.sanitize (c, this)
 799        &amp;&amp; classDef2.sanitize (c, this))) return_trace (false);
 800 
 801     unsigned int len1 = valueFormat1.get_len ();
 802     unsigned int len2 = valueFormat2.get_len ();
 803     unsigned int stride = len1 + len2;
 804     unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();
 805     unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;
 806     return_trace (c-&gt;check_array (values, record_size, count) &amp;&amp;
 807                   valueFormat1.sanitize_values_stride_unsafe (c, this, &amp;values[0], count, stride) &amp;&amp;
 808                   valueFormat2.sanitize_values_stride_unsafe (c, this, &amp;values[len1], count, stride));
 809   }
 810 
 811   protected:
 812   HBUINT16      format;                 /* Format identifier--format = 2 */
 813   OffsetTo&lt;Coverage&gt;
 814                 coverage;               /* Offset to Coverage table--from
 815                                          * beginning of subtable */
 816   ValueFormat   valueFormat1;           /* ValueRecord definition--for the
 817                                          * first glyph of the pair--may be zero
 818                                          * (0) */
 819   ValueFormat   valueFormat2;           /* ValueRecord definition--for the
 820                                          * second glyph of the pair--may be
 821                                          * zero (0) */
 822   OffsetTo&lt;ClassDef&gt;
 823                 classDef1;              /* Offset to ClassDef table--from
 824                                          * beginning of PairPos subtable--for
 825                                          * the first glyph of the pair */
 826   OffsetTo&lt;ClassDef&gt;
 827                 classDef2;              /* Offset to ClassDef table--from
 828                                          * beginning of PairPos subtable--for
 829                                          * the second glyph of the pair */
 830   HBUINT16      class1Count;            /* Number of classes in ClassDef1
 831                                          * table--includes Class0 */
 832   HBUINT16      class2Count;            /* Number of classes in ClassDef2
 833                                          * table--includes Class0 */
 834   ValueRecord   values;                 /* Matrix of value pairs:
 835                                          * class1-major, class2-minor,
 836                                          * Each entry has value1 and value2 */
 837   public:
 838   DEFINE_SIZE_ARRAY (16, values);
 839 };
 840 
 841 struct PairPos
 842 {
 843   template &lt;typename context_t&gt;
 844   inline typename context_t::return_t dispatch (context_t *c) const
 845   {
 846     TRACE_DISPATCH (this, u.format);
 847     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 848     switch (u.format) {
 849     case 1: return_trace (c-&gt;dispatch (u.format1));
 850     case 2: return_trace (c-&gt;dispatch (u.format2));
 851     default:return_trace (c-&gt;default_return_value ());
 852     }
 853   }
 854 
 855   protected:
 856   union {
 857   HBUINT16              format;         /* Format identifier */
 858   PairPosFormat1        format1;
 859   PairPosFormat2        format2;
 860   } u;
 861 };
 862 
 863 
 864 struct EntryExitRecord
 865 {
 866   friend struct CursivePosFormat1;
 867 
 868   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const
 869   {
 870     TRACE_SANITIZE (this);
 871     return_trace (entryAnchor.sanitize (c, base) &amp;&amp; exitAnchor.sanitize (c, base));
 872   }
 873 
 874   protected:
 875   OffsetTo&lt;Anchor&gt;
 876                 entryAnchor;            /* Offset to EntryAnchor table--from
 877                                          * beginning of CursivePos
 878                                          * subtable--may be NULL */
 879   OffsetTo&lt;Anchor&gt;
 880                 exitAnchor;             /* Offset to ExitAnchor table--from
 881                                          * beginning of CursivePos
 882                                          * subtable--may be NULL */
 883   public:
 884   DEFINE_SIZE_STATIC (4);
 885 };
 886 
 887 static void
 888 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);
 889 
 890 struct CursivePosFormat1
 891 {
 892   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
 893   {
 894     TRACE_COLLECT_GLYPHS (this);
 895     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 896   }
 897 
 898   inline const Coverage &amp;get_coverage (void) const
 899   {
 900     return this+coverage;
 901   }
 902 
 903   inline bool apply (hb_ot_apply_context_t *c) const
 904   {
 905     TRACE_APPLY (this);
 906     hb_buffer_t *buffer = c-&gt;buffer;
 907 
 908     const EntryExitRecord &amp;this_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;cur().codepoint)];
 909     if (!this_record.exitAnchor) return_trace (false);
 910 
 911     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
 912     skippy_iter.reset (buffer-&gt;idx, 1);
 913     if (!skippy_iter.next ()) return_trace (false);
 914 
 915     const EntryExitRecord &amp;next_record = entryExitRecord[(this+coverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint)];
 916     if (!next_record.entryAnchor) return_trace (false);
 917 
 918     unsigned int i = buffer-&gt;idx;
 919     unsigned int j = skippy_iter.idx;
 920 
 921     buffer-&gt;unsafe_to_break (i, j);
 922     float entry_x, entry_y, exit_x, exit_y;
 923     (this+this_record.exitAnchor).get_anchor (c, buffer-&gt;info[i].codepoint, &amp;exit_x, &amp;exit_y);
 924     (this+next_record.entryAnchor).get_anchor (c, buffer-&gt;info[j].codepoint, &amp;entry_x, &amp;entry_y);
 925 
 926     hb_glyph_position_t *pos = buffer-&gt;pos;
 927 
 928     hb_position_t d;
 929     /* Main-direction adjustment */
 930     switch (c-&gt;direction) {
 931       case HB_DIRECTION_LTR:
 932         pos[i].x_advance  = round (exit_x) + pos[i].x_offset;
 933 
 934         d = round (entry_x) + pos[j].x_offset;
 935         pos[j].x_advance -= d;
 936         pos[j].x_offset  -= d;
 937         break;
 938       case HB_DIRECTION_RTL:
 939         d = round (exit_x) + pos[i].x_offset;
 940         pos[i].x_advance -= d;
 941         pos[i].x_offset  -= d;
 942 
 943         pos[j].x_advance  = round (entry_x) + pos[j].x_offset;
 944         break;
 945       case HB_DIRECTION_TTB:
 946         pos[i].y_advance  = round (exit_y) + pos[i].y_offset;
 947 
 948         d = round (entry_y) + pos[j].y_offset;
 949         pos[j].y_advance -= d;
 950         pos[j].y_offset  -= d;
 951         break;
 952       case HB_DIRECTION_BTT:
 953         d = round (exit_y) + pos[i].y_offset;
 954         pos[i].y_advance -= d;
 955         pos[i].y_offset  -= d;
 956 
 957         pos[j].y_advance  = round (entry_y);
 958         break;
 959       case HB_DIRECTION_INVALID:
 960       default:
 961         break;
 962     }
 963 
 964     /* Cross-direction adjustment */
 965 
 966     /* We attach child to parent (think graph theory and rooted trees whereas
 967      * the root stays on baseline and each node aligns itself against its
 968      * parent.
 969      *
 970      * Optimize things for the case of RightToLeft, as that&#39;s most common in
 971      * Arabinc. */
 972     unsigned int child  = i;
 973     unsigned int parent = j;
 974     hb_position_t x_offset = entry_x - exit_x;
 975     hb_position_t y_offset = entry_y - exit_y;
 976     if  (!(c-&gt;lookup_props &amp; LookupFlag::RightToLeft))
 977     {
 978       unsigned int k = child;
 979       child = parent;
 980       parent = k;
 981       x_offset = -x_offset;
 982       y_offset = -y_offset;
 983     }
 984 
 985     /* If child was already connected to someone else, walk through its old
 986      * chain and reverse the link direction, such that the whole tree of its
 987      * previous connection now attaches to new parent.  Watch out for case
 988      * where new parent is on the path from old chain...
 989      */
 990     reverse_cursive_minor_offset (pos, child, c-&gt;direction, parent);
 991 
 992     pos[child].attach_type() = ATTACH_TYPE_CURSIVE;
 993     pos[child].attach_chain() = (int) parent - (int) child;
 994     buffer-&gt;scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;
 995     if (likely (HB_DIRECTION_IS_HORIZONTAL (c-&gt;direction)))
 996       pos[child].y_offset = y_offset;
 997     else
 998       pos[child].x_offset = x_offset;
 999 
1000     buffer-&gt;idx = j;
1001     return_trace (true);
1002   }
1003 
1004   inline bool sanitize (hb_sanitize_context_t *c) const
1005   {
1006     TRACE_SANITIZE (this);
1007     return_trace (coverage.sanitize (c, this) &amp;&amp; entryExitRecord.sanitize (c, this));
1008   }
1009 
1010   protected:
1011   HBUINT16      format;                 /* Format identifier--format = 1 */
1012   OffsetTo&lt;Coverage&gt;
1013                 coverage;               /* Offset to Coverage table--from
1014                                          * beginning of subtable */
1015   ArrayOf&lt;EntryExitRecord&gt;
1016                 entryExitRecord;        /* Array of EntryExit records--in
1017                                          * Coverage Index order */
1018   public:
1019   DEFINE_SIZE_ARRAY (6, entryExitRecord);
1020 };
1021 
1022 struct CursivePos
1023 {
1024   template &lt;typename context_t&gt;
1025   inline typename context_t::return_t dispatch (context_t *c) const
1026   {
1027     TRACE_DISPATCH (this, u.format);
1028     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1029     switch (u.format) {
1030     case 1: return_trace (c-&gt;dispatch (u.format1));
1031     default:return_trace (c-&gt;default_return_value ());
1032     }
1033   }
1034 
1035   protected:
1036   union {
1037   HBUINT16              format;         /* Format identifier */
1038   CursivePosFormat1     format1;
1039   } u;
1040 };
1041 
1042 
1043 typedef AnchorMatrix BaseArray;         /* base-major--
1044                                          * in order of BaseCoverage Index--,
1045                                          * mark-minor--
1046                                          * ordered by class--zero-based. */
1047 
1048 struct MarkBasePosFormat1
1049 {
1050   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
1051   {
1052     TRACE_COLLECT_GLYPHS (this);
1053     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1054     if (unlikely (!(this+baseCoverage).add_coverage (c-&gt;input))) return;
1055   }
1056 
1057   inline const Coverage &amp;get_coverage (void) const
1058   {
1059     return this+markCoverage;
1060   }
1061 
1062   inline bool apply (hb_ot_apply_context_t *c) const
1063   {
1064     TRACE_APPLY (this);
1065     hb_buffer_t *buffer = c-&gt;buffer;
1066     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1067     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1068 
1069     /* Now we search backwards for a non-mark glyph */
1070     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1071     skippy_iter.reset (buffer-&gt;idx, 1);
1072     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1073     do {
1074       if (!skippy_iter.prev ()) return_trace (false);
1075       /* We only want to attach to the first of a MultipleSubst sequence.
1076        * https://github.com/harfbuzz/harfbuzz/issues/740
1077        * Reject others...
1078        * ...but stop if we find a mark in the MultipleSubst sequence:
1079        * https://github.com/harfbuzz/harfbuzz/issues/1020 */
1080       if (!_hb_glyph_info_multiplied (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1081           0 == _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) ||
1082           (skippy_iter.idx == 0 ||
1083            _hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1084            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1085            _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[skippy_iter.idx - 1]) ||
1086            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx]) !=
1087            _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[skippy_iter.idx - 1]) + 1
1088            ))
1089         break;
1090       skippy_iter.reject ();
1091     } while (1);
1092 
1093     /* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled */
1094     //if (!_hb_glyph_info_is_base_glyph (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1095 
1096     unsigned int base_index = (this+baseCoverage).get_coverage  (buffer-&gt;info[skippy_iter.idx].codepoint);
1097     if (base_index == NOT_COVERED) return_trace (false);
1098 
1099     return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));
1100   }
1101 
1102   inline bool sanitize (hb_sanitize_context_t *c) const
1103   {
1104     TRACE_SANITIZE (this);
1105     return_trace (c-&gt;check_struct (this) &amp;&amp;
1106                   markCoverage.sanitize (c, this) &amp;&amp;
1107                   baseCoverage.sanitize (c, this) &amp;&amp;
1108                   markArray.sanitize (c, this) &amp;&amp;
1109                   baseArray.sanitize (c, this, (unsigned int) classCount));
1110   }
1111 
1112   protected:
1113   HBUINT16      format;                 /* Format identifier--format = 1 */
1114   OffsetTo&lt;Coverage&gt;
1115                 markCoverage;           /* Offset to MarkCoverage table--from
1116                                          * beginning of MarkBasePos subtable */
1117   OffsetTo&lt;Coverage&gt;
1118                 baseCoverage;           /* Offset to BaseCoverage table--from
1119                                          * beginning of MarkBasePos subtable */
1120   HBUINT16      classCount;             /* Number of classes defined for marks */
1121   OffsetTo&lt;MarkArray&gt;
1122                 markArray;              /* Offset to MarkArray table--from
1123                                          * beginning of MarkBasePos subtable */
1124   OffsetTo&lt;BaseArray&gt;
1125                 baseArray;              /* Offset to BaseArray table--from
1126                                          * beginning of MarkBasePos subtable */
1127   public:
1128   DEFINE_SIZE_STATIC (12);
1129 };
1130 
1131 struct MarkBasePos
1132 {
1133   template &lt;typename context_t&gt;
1134   inline typename context_t::return_t dispatch (context_t *c) const
1135   {
1136     TRACE_DISPATCH (this, u.format);
1137     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1138     switch (u.format) {
1139     case 1: return_trace (c-&gt;dispatch (u.format1));
1140     default:return_trace (c-&gt;default_return_value ());
1141     }
1142   }
1143 
1144   protected:
1145   union {
1146   HBUINT16              format;         /* Format identifier */
1147   MarkBasePosFormat1    format1;
1148   } u;
1149 };
1150 
1151 
1152 typedef AnchorMatrix LigatureAttach;    /* component-major--
1153                                          * in order of writing direction--,
1154                                          * mark-minor--
1155                                          * ordered by class--zero-based. */
1156 
1157 typedef OffsetListOf&lt;LigatureAttach&gt; LigatureArray;
1158                                         /* Array of LigatureAttach
1159                                          * tables ordered by
1160                                          * LigatureCoverage Index */
1161 
1162 struct MarkLigPosFormat1
1163 {
1164   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
1165   {
1166     TRACE_COLLECT_GLYPHS (this);
1167     if (unlikely (!(this+markCoverage).add_coverage (c-&gt;input))) return;
1168     if (unlikely (!(this+ligatureCoverage).add_coverage (c-&gt;input))) return;
1169   }
1170 
1171   inline const Coverage &amp;get_coverage (void) const
1172   {
1173     return this+markCoverage;
1174   }
1175 
1176   inline bool apply (hb_ot_apply_context_t *c) const
1177   {
1178     TRACE_APPLY (this);
1179     hb_buffer_t *buffer = c-&gt;buffer;
1180     unsigned int mark_index = (this+markCoverage).get_coverage  (buffer-&gt;cur().codepoint);
1181     if (likely (mark_index == NOT_COVERED)) return_trace (false);
1182 
1183     /* Now we search backwards for a non-mark glyph */
1184     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1185     skippy_iter.reset (buffer-&gt;idx, 1);
1186     skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);
1187     if (!skippy_iter.prev ()) return_trace (false);
1188 
1189     /* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled */
1190     //if (!_hb_glyph_info_is_ligature (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1191 
1192     unsigned int j = skippy_iter.idx;
1193     unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer-&gt;info[j].codepoint);
1194     if (lig_index == NOT_COVERED) return_trace (false);
1195 
1196     const LigatureArray&amp; lig_array = this+ligatureArray;
1197     const LigatureAttach&amp; lig_attach = lig_array[lig_index];
1198 
1199     /* Find component to attach to */
1200     unsigned int comp_count = lig_attach.rows;
1201     if (unlikely (!comp_count)) return_trace (false);
1202 
1203     /* We must now check whether the ligature ID of the current mark glyph
1204      * is identical to the ligature ID of the found ligature.  If yes, we
1205      * can directly use the component index.  If not, we attach the mark
1206      * glyph to the last component of the ligature. */
1207     unsigned int comp_index;
1208     unsigned int lig_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1209     unsigned int mark_id = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1210     unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1211     if (lig_id &amp;&amp; lig_id == mark_id &amp;&amp; mark_comp &gt; 0)
1212       comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur())) - 1;
1213     else
1214       comp_index = comp_count - 1;
1215 
1216     return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));
1217   }
1218 
1219   inline bool sanitize (hb_sanitize_context_t *c) const
1220   {
1221     TRACE_SANITIZE (this);
1222     return_trace (c-&gt;check_struct (this) &amp;&amp;
1223                   markCoverage.sanitize (c, this) &amp;&amp;
1224                   ligatureCoverage.sanitize (c, this) &amp;&amp;
1225                   markArray.sanitize (c, this) &amp;&amp;
1226                   ligatureArray.sanitize (c, this, (unsigned int) classCount));
1227   }
1228 
1229   protected:
1230   HBUINT16      format;                 /* Format identifier--format = 1 */
1231   OffsetTo&lt;Coverage&gt;
1232                 markCoverage;           /* Offset to Mark Coverage table--from
1233                                          * beginning of MarkLigPos subtable */
1234   OffsetTo&lt;Coverage&gt;
1235                 ligatureCoverage;       /* Offset to Ligature Coverage
1236                                          * table--from beginning of MarkLigPos
1237                                          * subtable */
1238   HBUINT16      classCount;             /* Number of defined mark classes */
1239   OffsetTo&lt;MarkArray&gt;
1240                 markArray;              /* Offset to MarkArray table--from
1241                                          * beginning of MarkLigPos subtable */
1242   OffsetTo&lt;LigatureArray&gt;
1243                 ligatureArray;          /* Offset to LigatureArray table--from
1244                                          * beginning of MarkLigPos subtable */
1245   public:
1246   DEFINE_SIZE_STATIC (12);
1247 };
1248 
1249 struct MarkLigPos
1250 {
1251   template &lt;typename context_t&gt;
1252   inline typename context_t::return_t dispatch (context_t *c) const
1253   {
1254     TRACE_DISPATCH (this, u.format);
1255     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1256     switch (u.format) {
1257     case 1: return_trace (c-&gt;dispatch (u.format1));
1258     default:return_trace (c-&gt;default_return_value ());
1259     }
1260   }
1261 
1262   protected:
1263   union {
1264   HBUINT16              format;         /* Format identifier */
1265   MarkLigPosFormat1     format1;
1266   } u;
1267 };
1268 
1269 
1270 typedef AnchorMatrix Mark2Array;        /* mark2-major--
1271                                          * in order of Mark2Coverage Index--,
1272                                          * mark1-minor--
1273                                          * ordered by class--zero-based. */
1274 
1275 struct MarkMarkPosFormat1
1276 {
1277   inline void collect_glyphs (hb_collect_glyphs_context_t *c) const
1278   {
1279     TRACE_COLLECT_GLYPHS (this);
1280     if (unlikely (!(this+mark1Coverage).add_coverage (c-&gt;input))) return;
1281     if (unlikely (!(this+mark2Coverage).add_coverage (c-&gt;input))) return;
1282   }
1283 
1284   inline const Coverage &amp;get_coverage (void) const
1285   {
1286     return this+mark1Coverage;
1287   }
1288 
1289   inline bool apply (hb_ot_apply_context_t *c) const
1290   {
1291     TRACE_APPLY (this);
1292     hb_buffer_t *buffer = c-&gt;buffer;
1293     unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer-&gt;cur().codepoint);
1294     if (likely (mark1_index == NOT_COVERED)) return_trace (false);
1295 
1296     /* now we search backwards for a suitable mark glyph until a non-mark glyph */
1297     hb_ot_apply_context_t::skipping_iterator_t &amp;skippy_iter = c-&gt;iter_input;
1298     skippy_iter.reset (buffer-&gt;idx, 1);
1299     skippy_iter.set_lookup_props (c-&gt;lookup_props &amp; ~LookupFlag::IgnoreFlags);
1300     if (!skippy_iter.prev ()) return_trace (false);
1301 
1302     if (!_hb_glyph_info_is_mark (&amp;buffer-&gt;info[skippy_iter.idx])) { return_trace (false); }
1303 
1304     unsigned int j = skippy_iter.idx;
1305 
1306     unsigned int id1 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;cur());
1307     unsigned int id2 = _hb_glyph_info_get_lig_id (&amp;buffer-&gt;info[j]);
1308     unsigned int comp1 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;cur());
1309     unsigned int comp2 = _hb_glyph_info_get_lig_comp (&amp;buffer-&gt;info[j]);
1310 
1311     if (likely (id1 == id2)) {
1312       if (id1 == 0) /* Marks belonging to the same base. */
1313         goto good;
1314       else if (comp1 == comp2) /* Marks belonging to the same ligature component. */
1315         goto good;
1316     } else {
1317       /* If ligature ids don&#39;t match, it may be the case that one of the marks
1318        * itself is a ligature.  In which case match. */
1319       if ((id1 &gt; 0 &amp;&amp; !comp1) || (id2 &gt; 0 &amp;&amp; !comp2))
1320         goto good;
1321     }
1322 
1323     /* Didn&#39;t match. */
1324     return_trace (false);
1325 
1326     good:
1327     unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer-&gt;info[j].codepoint);
1328     if (mark2_index == NOT_COVERED) return_trace (false);
1329 
1330     return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));
1331   }
1332 
1333   inline bool sanitize (hb_sanitize_context_t *c) const
1334   {
1335     TRACE_SANITIZE (this);
1336     return_trace (c-&gt;check_struct (this) &amp;&amp;
1337                   mark1Coverage.sanitize (c, this) &amp;&amp;
1338                   mark2Coverage.sanitize (c, this) &amp;&amp;
1339                   mark1Array.sanitize (c, this) &amp;&amp;
1340                   mark2Array.sanitize (c, this, (unsigned int) classCount));
1341   }
1342 
1343   protected:
1344   HBUINT16      format;                 /* Format identifier--format = 1 */
1345   OffsetTo&lt;Coverage&gt;
1346                 mark1Coverage;          /* Offset to Combining Mark1 Coverage
1347                                          * table--from beginning of MarkMarkPos
1348                                          * subtable */
1349   OffsetTo&lt;Coverage&gt;
1350                 mark2Coverage;          /* Offset to Combining Mark2 Coverage
1351                                          * table--from beginning of MarkMarkPos
1352                                          * subtable */
1353   HBUINT16      classCount;             /* Number of defined mark classes */
1354   OffsetTo&lt;MarkArray&gt;
1355                 mark1Array;             /* Offset to Mark1Array table--from
1356                                          * beginning of MarkMarkPos subtable */
1357   OffsetTo&lt;Mark2Array&gt;
1358                 mark2Array;             /* Offset to Mark2Array table--from
1359                                          * beginning of MarkMarkPos subtable */
1360   public:
1361   DEFINE_SIZE_STATIC (12);
1362 };
1363 
1364 struct MarkMarkPos
1365 {
1366   template &lt;typename context_t&gt;
1367   inline typename context_t::return_t dispatch (context_t *c) const
1368   {
1369     TRACE_DISPATCH (this, u.format);
1370     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1371     switch (u.format) {
1372     case 1: return_trace (c-&gt;dispatch (u.format1));
1373     default:return_trace (c-&gt;default_return_value ());
1374     }
1375   }
1376 
1377   protected:
1378   union {
1379   HBUINT16              format;         /* Format identifier */
1380   MarkMarkPosFormat1    format1;
1381   } u;
1382 };
1383 
1384 
1385 struct ContextPos : Context {};
1386 
1387 struct ChainContextPos : ChainContext {};
1388 
1389 struct ExtensionPos : Extension&lt;ExtensionPos&gt;
1390 {
1391   typedef struct PosLookupSubTable LookupSubTable;
1392 };
1393 
1394 
1395 
1396 /*
1397  * PosLookup
1398  */
1399 
1400 
1401 struct PosLookupSubTable
1402 {
1403   friend struct PosLookup;
1404 
1405   enum Type {
1406     Single              = 1,
1407     Pair                = 2,
1408     Cursive             = 3,
1409     MarkBase            = 4,
1410     MarkLig             = 5,
1411     MarkMark            = 6,
1412     Context             = 7,
1413     ChainContext        = 8,
1414     Extension           = 9
1415   };
1416 
1417   template &lt;typename context_t&gt;
1418   inline typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const
1419   {
1420     TRACE_DISPATCH (this, lookup_type);
1421     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.sub_format))) return_trace (c-&gt;no_dispatch_return_value ());
1422     switch (lookup_type) {
1423     case Single:                return_trace (u.single.dispatch (c));
1424     case Pair:                  return_trace (u.pair.dispatch (c));
1425     case Cursive:               return_trace (u.cursive.dispatch (c));
1426     case MarkBase:              return_trace (u.markBase.dispatch (c));
1427     case MarkLig:               return_trace (u.markLig.dispatch (c));
1428     case MarkMark:              return_trace (u.markMark.dispatch (c));
1429     case Context:               return_trace (u.context.dispatch (c));
1430     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1431     case Extension:             return_trace (u.extension.dispatch (c));
1432     default:                    return_trace (c-&gt;default_return_value ());
1433     }
1434   }
1435 
1436   protected:
1437   union {
1438   HBUINT16              sub_format;
1439   SinglePos             single;
1440   PairPos               pair;
1441   CursivePos            cursive;
1442   MarkBasePos           markBase;
1443   MarkLigPos            markLig;
1444   MarkMarkPos           markMark;
1445   ContextPos            context;
1446   ChainContextPos       chainContext;
1447   ExtensionPos          extension;
1448   } u;
1449   public:
1450   DEFINE_SIZE_UNION (2, sub_format);
1451 };
1452 
1453 
1454 struct PosLookup : Lookup
1455 {
1456   inline const PosLookupSubTable&amp; get_subtable (unsigned int i) const
1457   { return Lookup::get_subtable&lt;PosLookupSubTable&gt; (i); }
1458 
1459   inline bool is_reverse (void) const
1460   {
1461     return false;
1462   }
1463 
1464   inline bool apply (hb_ot_apply_context_t *c) const
1465   {
1466     TRACE_APPLY (this);
1467     return_trace (dispatch (c));
1468   }
1469 
1470   inline hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const
1471   {
1472     TRACE_COLLECT_GLYPHS (this);
1473     return_trace (dispatch (c));
1474   }
1475 
1476   template &lt;typename set_t&gt;
1477   inline void add_coverage (set_t *glyphs) const
1478   {
1479     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1480     dispatch (&amp;c);
1481   }
1482 
1483   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1484 
1485   template &lt;typename context_t&gt;
1486   static inline typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);
1487 
1488   template &lt;typename context_t&gt;
1489   inline typename context_t::return_t dispatch (context_t *c) const
1490   { return Lookup::dispatch&lt;PosLookupSubTable&gt; (c); }
1491 
1492   inline bool sanitize (hb_sanitize_context_t *c) const
1493   {
1494     TRACE_SANITIZE (this);
1495     if (unlikely (!Lookup::sanitize (c))) return_trace (false);
1496     return_trace (dispatch (c));
1497   }
1498 };
1499 
1500 typedef OffsetListOf&lt;PosLookup&gt; PosLookupList;
1501 
1502 /*
1503  * GPOS -- Glyph Positioning
1504  * https://docs.microsoft.com/en-us/typography/opentype/spec/gpos
1505  */
1506 
1507 struct GPOS : GSUBGPOS
1508 {
1509   static const hb_tag_t tableTag        = HB_OT_TAG_GPOS;
1510 
1511   inline const PosLookup&amp; get_lookup (unsigned int i) const
1512   { return CastR&lt;PosLookup&gt; (GSUBGPOS::get_lookup (i)); }
1513 
1514   static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);
1515   static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);
1516   static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);
1517 
1518   inline bool sanitize (hb_sanitize_context_t *c) const
1519   {
1520     TRACE_SANITIZE (this);
1521     if (unlikely (!GSUBGPOS::sanitize (c))) return_trace (false);
1522     const OffsetTo&lt;PosLookupList&gt; &amp;list = CastR&lt;OffsetTo&lt;PosLookupList&gt; &gt; (lookupList);
1523     return_trace (list.sanitize (c, this));
1524   }
1525 };
1526 
1527 
1528 static void
1529 reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)
1530 {
1531   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1532   if (likely (!chain || 0 == (type &amp; ATTACH_TYPE_CURSIVE)))
1533     return;
1534 
1535   pos[i].attach_chain() = 0;
1536 
1537   unsigned int j = (int) i + chain;
1538 
1539   /* Stop if we see new parent in the chain. */
1540   if (j == new_parent)
1541     return;
1542 
1543   reverse_cursive_minor_offset (pos, j, direction, new_parent);
1544 
1545   if (HB_DIRECTION_IS_HORIZONTAL (direction))
1546     pos[j].y_offset = -pos[i].y_offset;
1547   else
1548     pos[j].x_offset = -pos[i].x_offset;
1549 
1550   pos[j].attach_chain() = -chain;
1551   pos[j].attach_type() = type;
1552 }
1553 static void
1554 propagate_attachment_offsets (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction)
1555 {
1556   /* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate
1557    * offset of glyph they are attached to. */
1558   int chain = pos[i].attach_chain(), type = pos[i].attach_type();
1559   if (likely (!chain))
1560     return;
1561 
1562   unsigned int j = (int) i + chain;
1563 
1564   pos[i].attach_chain() = 0;
1565 
1566   propagate_attachment_offsets (pos, j, direction);
1567 
1568   assert (!!(type &amp; ATTACH_TYPE_MARK) ^ !!(type &amp; ATTACH_TYPE_CURSIVE));
1569 
1570   if (type &amp; ATTACH_TYPE_CURSIVE)
1571   {
1572     if (HB_DIRECTION_IS_HORIZONTAL (direction))
1573       pos[i].y_offset += pos[j].y_offset;
1574     else
1575       pos[i].x_offset += pos[j].x_offset;
1576   }
1577   else /*if (type &amp; ATTACH_TYPE_MARK)*/
1578   {
1579     pos[i].x_offset += pos[j].x_offset;
1580     pos[i].y_offset += pos[j].y_offset;
1581 
1582     assert (j &lt; i);
1583     if (HB_DIRECTION_IS_FORWARD (direction))
1584       for (unsigned int k = j; k &lt; i; k++) {
1585         pos[i].x_offset -= pos[k].x_advance;
1586         pos[i].y_offset -= pos[k].y_advance;
1587       }
1588     else
1589       for (unsigned int k = j + 1; k &lt; i + 1; k++) {
1590         pos[i].x_offset += pos[k].x_advance;
1591         pos[i].y_offset += pos[k].y_advance;
1592       }
1593   }
1594 }
1595 
1596 void
1597 GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1598 {
1599   unsigned int count = buffer-&gt;len;
1600   for (unsigned int i = 0; i &lt; count; i++)
1601     buffer-&gt;pos[i].attach_chain() = buffer-&gt;pos[i].attach_type() = 0;
1602 }
1603 
1604 void
1605 GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1606 {
1607   //_hb_buffer_assert_gsubgpos_vars (buffer);
1608 }
1609 
1610 void
1611 GPOS::position_finish_offsets (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)
1612 {
1613   _hb_buffer_assert_gsubgpos_vars (buffer);
1614 
1615   unsigned int len;
1616   hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &amp;len);
1617   hb_direction_t direction = buffer-&gt;props.direction;
1618 
1619   /* Handle attachments */
1620   if (buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)
1621     for (unsigned int i = 0; i &lt; len; i++)
1622       propagate_attachment_offsets (pos, i, direction);
1623 }
1624 
1625 
1626 /* Out-of-class implementation for methods recursing */
1627 
1628 template &lt;typename context_t&gt;
1629 /*static*/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1630 {
1631   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);
1632   const PosLookup &amp;l = gpos.get_lookup (lookup_index);
1633   return l.dispatch (c);
1634 }
1635 
1636 /*static*/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1637 {
1638   const GPOS &amp;gpos = *(hb_ot_layout_from_face (c-&gt;face)-&gt;gpos);
1639   const PosLookup &amp;l = gpos.get_lookup (lookup_index);
1640   unsigned int saved_lookup_props = c-&gt;lookup_props;
1641   unsigned int saved_lookup_index = c-&gt;lookup_index;
1642   c-&gt;set_lookup_index (lookup_index);
1643   c-&gt;set_lookup_props (l.get_props ());
1644   bool ret = l.dispatch (c);
1645   c-&gt;set_lookup_index (saved_lookup_index);
1646   c-&gt;set_lookup_props (saved_lookup_props);
1647   return ret;
1648 }
1649 
1650 
1651 #undef attach_chain
1652 #undef attach_type
1653 
1654 
1655 } /* namespace OT */
1656 
1657 
1658 #endif /* HB_OT_LAYOUT_GPOS_TABLE_HH */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-name-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_NAME_TABLE_HH
 28 #define HB_OT_NAME_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>


 31 
 32 
 33 namespace OT {
 34 
 35 
<a name="2" id="anc2"></a>



 36 /*
 37  * name -- Naming
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/name
 39  */
 40 #define HB_OT_TAG_name HB_TAG(&#39;n&#39;,&#39;a&#39;,&#39;m&#39;,&#39;e&#39;)
 41 
<a name="3" id="anc3"></a>
 42 
 43 struct NameRecord
 44 {
<a name="4" id="anc4"></a><span class="line-modified"> 45   static int cmp (const void *pa, const void *pb)</span>
 46   {
<a name="5" id="anc5"></a><span class="line-modified"> 47     const NameRecord *a = (const NameRecord *) pa;</span>
<span class="line-modified"> 48     const NameRecord *b = (const NameRecord *) pb;</span>
<span class="line-modified"> 49     int ret;</span>
<span class="line-modified"> 50     ret = b-&gt;platformID.cmp (a-&gt;platformID);</span>
<span class="line-modified"> 51     if (ret) return ret;</span>
<span class="line-modified"> 52     ret = b-&gt;encodingID.cmp (a-&gt;encodingID);</span>
<span class="line-modified"> 53     if (ret) return ret;</span>
<span class="line-modified"> 54     ret = b-&gt;languageID.cmp (a-&gt;languageID);</span>
<span class="line-modified"> 55     if (ret) return ret;</span>
<span class="line-modified"> 56     ret = b-&gt;nameID.cmp (a-&gt;nameID);</span>
<span class="line-modified"> 57     if (ret) return ret;</span>
<span class="line-modified"> 58     return 0;</span>

 59   }
 60 
<a name="6" id="anc6"></a><span class="line-modified"> 61   inline bool sanitize (hb_sanitize_context_t *c, const void *base) const</span>



























 62   {
 63     TRACE_SANITIZE (this);
 64     /* We can check from base all the way up to the end of string... */
 65     return_trace (c-&gt;check_struct (this) &amp;&amp; c-&gt;check_range ((char *) base, (unsigned int) length + offset));
 66   }
 67 
 68   HBUINT16      platformID;     /* Platform ID. */
 69   HBUINT16      encodingID;     /* Platform-specific encoding ID. */
 70   HBUINT16      languageID;     /* Language ID. */
 71   HBUINT16      nameID;         /* Name ID. */
 72   HBUINT16      length;         /* String length (in bytes). */
 73   HBUINT16      offset;         /* String offset from start of storage area (in bytes). */
 74   public:
 75   DEFINE_SIZE_STATIC (12);
 76 };
 77 
<a name="7" id="anc7"></a>






































 78 struct name
 79 {
<a name="8" id="anc8"></a><span class="line-modified"> 80   static const hb_tag_t tableTag        = HB_OT_TAG_name;</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82   inline unsigned int get_name (unsigned int platform_id,</span>
<span class="line-removed"> 83                                 unsigned int encoding_id,</span>
<span class="line-removed"> 84                                 unsigned int language_id,</span>
<span class="line-removed"> 85                                 unsigned int name_id,</span>
<span class="line-removed"> 86                                 void *buffer,</span>
<span class="line-removed"> 87                                 unsigned int buffer_length) const</span>
<span class="line-removed"> 88   {</span>
<span class="line-removed"> 89     NameRecord key;</span>
<span class="line-removed"> 90     key.platformID.set (platform_id);</span>
<span class="line-removed"> 91     key.encodingID.set (encoding_id);</span>
<span class="line-removed"> 92     key.languageID.set (language_id);</span>
<span class="line-removed"> 93     key.nameID.set (name_id);</span>
<span class="line-removed"> 94     NameRecord *match = (NameRecord *) bsearch (&amp;key, nameRecord, count, sizeof (nameRecord[0]), NameRecord::cmp);</span>
<span class="line-removed"> 95 </span>
<span class="line-removed"> 96     if (!match)</span>
<span class="line-removed"> 97       return 0;</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99     unsigned int length = MIN (buffer_length, (unsigned int) match-&gt;length);</span>
<span class="line-removed">100     memcpy (buffer, (char *) this + stringOffset + match-&gt;offset, length);</span>
<span class="line-removed">101     return length;</span>
<span class="line-removed">102   }</span>
103 
<a name="9" id="anc9"></a><span class="line-modified">104   inline unsigned int get_size (void) const</span>
<span class="line-modified">105   { return min_size + count * nameRecord[0].min_size; }</span>
106 
<a name="10" id="anc10"></a><span class="line-modified">107   inline bool sanitize_records (hb_sanitize_context_t *c) const {</span>

108     TRACE_SANITIZE (this);
<a name="11" id="anc11"></a><span class="line-modified">109     char *string_pool = (char *) this + stringOffset;</span>
110     unsigned int _count = count;
<a name="12" id="anc12"></a>
111     for (unsigned int i = 0; i &lt; _count; i++)
<a name="13" id="anc13"></a><span class="line-modified">112       if (!nameRecord[i].sanitize (c, string_pool)) return_trace (false);</span>
113     return_trace (true);
114   }
115 
<a name="14" id="anc14"></a><span class="line-modified">116   inline bool sanitize (hb_sanitize_context_t *c) const</span>
117   {
118     TRACE_SANITIZE (this);
119     return_trace (c-&gt;check_struct (this) &amp;&amp;
120                   likely (format == 0 || format == 1) &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified">121                   c-&gt;check_array (nameRecord, nameRecord[0].static_size, count) &amp;&amp;</span>
<span class="line-modified">122                   sanitize_records (c));</span>
123   }
124 
<a name="16" id="anc16"></a>



















































































125   /* We only implement format 0 for now. */
126   HBUINT16      format;                 /* Format selector (=0/1). */
127   HBUINT16      count;                  /* Number of name records. */
<a name="17" id="anc17"></a><span class="line-modified">128   Offset16      stringOffset;           /* Offset to start of string storage (from start of table). */</span>
<span class="line-modified">129   NameRecord    nameRecord[VAR];        /* The name records where count is the number of records. */</span>


130   public:
<a name="18" id="anc18"></a><span class="line-modified">131   DEFINE_SIZE_ARRAY (6, nameRecord);</span>
132 };
133 
<a name="19" id="anc19"></a>
134 
135 } /* namespace OT */
136 
137 
138 #endif /* HB_OT_NAME_TABLE_HH */
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="hb-ot-shape-normalize.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-tag.cc.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-shape.cc</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 24,195 ***</span>
   *
   * Red Hat Author(s): Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #define HB_SHAPER ot</span>
<span class="line-modified">! #define hb_ot_shaper_face_data_t hb_ot_layout_t</span>
<span class="line-modified">! #define hb_ot_shaper_shape_plan_data_t hb_ot_shape_plan_t</span>
<span class="line-modified">! #include &quot;hb-shaper-impl-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-ot-shape-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-complex-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-fallback-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-normalize-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-unicode-private.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-set-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-ot-layout-gsubgpos-private.hh&quot;</span>
<span class="line-modified">! //#include &quot;hb-aat-layout-private.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! static hb_tag_t common_features[] = {</span>
<span class="line-modified">!   HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified">! };</span>
  
  
<span class="line-modified">! static hb_tag_t horizontal_features[] = {</span>
<span class="line-modified">!   HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;),</span>
<span class="line-modified">!   HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;),</span>
  };
  
  
  
  static void
  hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
<span class="line-removed">-                               const hb_segment_properties_t  *props,</span>
                                const hb_feature_t             *user_features,
                                unsigned int                    num_user_features)
  {
    hb_ot_map_builder_t *map = &amp;planner-&gt;map;
  
<span class="line-modified">!   map-&gt;add_global_bool_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
    map-&gt;add_gsub_pause (nullptr);
  
<span class="line-modified">!   switch (props-&gt;direction) {</span>
      case HB_DIRECTION_LTR:
<span class="line-modified">!       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified">!       map-&gt;add_global_bool_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
        break;
      case HB_DIRECTION_RTL:
<span class="line-modified">!       map-&gt;add_global_bool_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified">!       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;), 1, F_NONE);</span>
        break;
      case HB_DIRECTION_TTB:
      case HB_DIRECTION_BTT:
      case HB_DIRECTION_INVALID:
      default:
        break;
    }
  
<span class="line-modified">!   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;), 1, F_NONE);</span>
<span class="line-modified">!   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;), 1, F_NONE);</span>
<span class="line-modified">!   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;), 1, F_NONE);</span>
  
    if (planner-&gt;shaper-&gt;collect_features)
      planner-&gt;shaper-&gt;collect_features (planner);
  
    for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<span class="line-modified">!     map-&gt;add_global_bool_feature (common_features[i]);</span>
  
<span class="line-modified">!   if (HB_DIRECTION_IS_HORIZONTAL (props-&gt;direction))</span>
      for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<span class="line-modified">!       map-&gt;add_feature (horizontal_features[i], 1, F_GLOBAL |</span>
<span class="line-removed">-                         (horizontal_features[i] == HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) ?</span>
<span class="line-removed">-                          F_HAS_FALLBACK : F_NONE));</span>
    else
    {
      /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
       * matter which script/langsys it is listed (or not) under.
       * See various bugs referenced from:
       * https://github.com/harfbuzz/harfbuzz/issues/63 */
<span class="line-modified">!     map-&gt;add_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), 1, F_GLOBAL | F_GLOBAL_SEARCH);</span>
    }
  
<span class="line-modified">!   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-modified">!     planner-&gt;shaper-&gt;override_features (planner);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (unsigned int i = 0; i &lt; num_user_features; i++) {</span>
      const hb_feature_t *feature = &amp;user_features[i];
<span class="line-modified">!     map-&gt;add_feature (feature-&gt;tag, feature-&gt;value,</span>
<span class="line-modified">!                       (feature-&gt;start == 0 &amp;&amp; feature-&gt;end == (unsigned int) -1) ?</span>
<span class="line-modified">!                        F_GLOBAL : F_NONE);</span>
    }
  }
  
  
  /*
   * shaper face data
   */
  
<span class="line-modified">! HB_SHAPER_DATA_ENSURE_DEFINE(ot, face)</span>
  
<span class="line-modified">! hb_ot_shaper_face_data_t *</span>
  _hb_ot_shaper_face_data_create (hb_face_t *face)
  {
<span class="line-modified">!   return _hb_ot_layout_create (face);</span>
  }
  
  void
<span class="line-modified">! _hb_ot_shaper_face_data_destroy (hb_ot_shaper_face_data_t *data)</span>
  {
<span class="line-removed">-   _hb_ot_layout_destroy (data);</span>
  }
  
  
  /*
   * shaper font data
   */
  
<span class="line-modified">! HB_SHAPER_DATA_ENSURE_DEFINE(ot, font)</span>
<span class="line-removed">- </span>
<span class="line-removed">- struct hb_ot_shaper_font_data_t {};</span>
  
<span class="line-modified">! hb_ot_shaper_font_data_t *</span>
  _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
  {
<span class="line-modified">!   return (hb_ot_shaper_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void</span>
<span class="line-removed">- _hb_ot_shaper_font_data_destroy (hb_ot_shaper_font_data_t *data)</span>
<span class="line-removed">- {</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- /*</span>
<span class="line-removed">-  * shaper shape_plan data</span>
<span class="line-removed">-  */</span>
<span class="line-removed">- </span>
<span class="line-removed">- hb_ot_shaper_shape_plan_data_t *</span>
<span class="line-removed">- _hb_ot_shaper_shape_plan_data_create (hb_shape_plan_t    *shape_plan,</span>
<span class="line-removed">-                                       const hb_feature_t *user_features,</span>
<span class="line-removed">-                                       unsigned int        num_user_features,</span>
<span class="line-removed">-                                       const int          *coords,</span>
<span class="line-removed">-                                       unsigned int        num_coords)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   hb_ot_shape_plan_t *plan = (hb_ot_shape_plan_t *) calloc (1, sizeof (hb_ot_shape_plan_t));</span>
<span class="line-removed">-   if (unlikely (!plan))</span>
<span class="line-removed">-     return nullptr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   plan-&gt;init ();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hb_ot_shape_planner_t planner (shape_plan);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   planner.shaper = hb_ot_shape_complex_categorize (&amp;planner);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   hb_ot_shape_collect_features (&amp;planner, &amp;shape_plan-&gt;props,</span>
<span class="line-removed">-                                 user_features, num_user_features);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   planner.compile (*plan, coords, num_coords);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (plan-&gt;shaper-&gt;data_create) {</span>
<span class="line-removed">-     plan-&gt;data = plan-&gt;shaper-&gt;data_create (plan);</span>
<span class="line-removed">-     if (unlikely (!plan-&gt;data)) {</span>
<span class="line-removed">-       free(plan);</span>
<span class="line-removed">-       return nullptr;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return plan;</span>
  }
  
  void
<span class="line-modified">! _hb_ot_shaper_shape_plan_data_destroy (hb_ot_shaper_shape_plan_data_t *plan)</span>
  {
<span class="line-removed">-   if (plan-&gt;shaper-&gt;data_destroy)</span>
<span class="line-removed">-     plan-&gt;shaper-&gt;data_destroy (const_cast&lt;void *&gt; (plan-&gt;data));</span>
<span class="line-removed">- </span>
<span class="line-removed">-   plan-&gt;fini ();</span>
<span class="line-removed">- </span>
<span class="line-removed">-   free (plan);</span>
  }
  
  
  /*
   * shaper
<span class="line-new-header">--- 24,350 ---</span>
   *
   * Red Hat Author(s): Behdad Esfahbod
   * Google Author(s): Behdad Esfahbod
   */
  
<span class="line-modified">! #include &quot;hb-shaper-impl.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-ot-shape.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-complex.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-fallback.hh&quot;</span>
<span class="line-modified">! #include &quot;hb-ot-shape-normalize.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-ot-face.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-set.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! #include &quot;hb-aat-layout.hh&quot;</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! /**</span>
<span class="line-modified">!  * SECTION:hb-ot-shape</span>
<span class="line-modified">!  * @title: hb-ot-shape</span>
<span class="line-modified">!  * @short_description: OpenType shaping support</span>
<span class="line-modified">!  * @include: hb-ot.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Support functions for OpenType shaping related queries.</span>
<span class="line-modified">!  **/</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-added">+ static void</span>
<span class="line-added">+ hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,</span>
<span class="line-added">+                               const hb_feature_t             *user_features,</span>
<span class="line-added">+                               unsigned int                    num_user_features);</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool</span>
<span class="line-added">+ _hb_apply_morx (hb_face_t *face)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (hb_options ().aat &amp;&amp;</span>
<span class="line-added">+       hb_aat_layout_has_substitution (face))</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Ignore empty GSUB tables. */</span>
<span class="line-added">+   return (!hb_ot_layout_has_substitution (face) ||</span>
<span class="line-added">+           !hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-added">+                                                HB_OT_TAG_GSUB,</span>
<span class="line-added">+                                                0, nullptr, nullptr)) &amp;&amp;</span>
<span class="line-added">+          hb_aat_layout_has_substitution (face);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ hb_ot_shape_planner_t::hb_ot_shape_planner_t (hb_face_t                     *face,</span>
<span class="line-added">+                                               const hb_segment_properties_t *props) :</span>
<span class="line-added">+                                                 face (face),</span>
<span class="line-added">+                                                 props (*props),</span>
<span class="line-added">+                                                 map (face, props),</span>
<span class="line-added">+                                                 aat_map (face, props),</span>
<span class="line-added">+                                                 apply_morx (_hb_apply_morx (face))</span>
<span class="line-added">+ {</span>
<span class="line-added">+   shaper = hb_ot_shape_complex_categorize (this);</span>
<span class="line-added">+ </span>
<span class="line-added">+   script_zero_marks = shaper-&gt;zero_width_marks != HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE;</span>
<span class="line-added">+   script_fallback_mark_positioning = shaper-&gt;fallback_position;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (apply_morx)</span>
<span class="line-added">+     shaper = &amp;_hb_ot_complex_shaper_default;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_shape_planner_t::compile (hb_ot_shape_plan_t           &amp;plan,</span>
<span class="line-added">+                                 const hb_ot_shape_plan_key_t &amp;key)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   plan.props = props;</span>
<span class="line-added">+   plan.shaper = shaper;</span>
<span class="line-added">+   map.compile (plan.map, key);</span>
<span class="line-added">+   if (apply_morx)</span>
<span class="line-added">+     aat_map.compile (plan.aat_map);</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.frac_mask = plan.map.get_1_mask (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-added">+   plan.numr_mask = plan.map.get_1_mask (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added">+   plan.dnom_mask = plan.map.get_1_mask (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added">+   plan.has_frac = plan.frac_mask || (plan.numr_mask &amp;&amp; plan.dnom_mask);</span>
<span class="line-added">+   plan.rtlm_mask = plan.map.get_1_mask (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
<span class="line-added">+   hb_tag_t kern_tag = HB_DIRECTION_IS_HORIZONTAL (props.direction) ?</span>
<span class="line-added">+                       HB_TAG (&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;) : HB_TAG (&#39;v&#39;,&#39;k&#39;,&#39;r&#39;,&#39;n&#39;);</span>
<span class="line-added">+   plan.kern_mask = plan.map.get_mask (kern_tag);</span>
<span class="line-added">+   plan.trak_mask = plan.map.get_mask (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;));</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.requested_kerning = !!plan.kern_mask;</span>
<span class="line-added">+   plan.requested_tracking = !!plan.trak_mask;</span>
<span class="line-added">+   bool has_gpos_kern = plan.map.get_feature_index (1, kern_tag) != HB_OT_LAYOUT_NO_FEATURE_INDEX;</span>
<span class="line-added">+   bool disable_gpos = plan.shaper-&gt;gpos_tag &amp;&amp;</span>
<span class="line-added">+                       plan.shaper-&gt;gpos_tag != plan.map.chosen_script[1];</span>
<span class="line-added">+ </span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * Decide who provides glyph classes. GDEF or Unicode.</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!hb_ot_layout_has_glyph_classes (face))</span>
<span class="line-added">+     plan.fallback_glyph_classes = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * Decide who does substitutions. GSUB, morx, or fallback.</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.apply_morx = apply_morx;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * Decide who does positioning. GPOS, kerx, kern, or fallback.</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (hb_options ().aat &amp;&amp; hb_aat_layout_has_positioning (face))</span>
<span class="line-added">+     plan.apply_kerx = true;</span>
<span class="line-added">+   else if (!apply_morx &amp;&amp; !disable_gpos &amp;&amp; hb_ot_layout_has_positioning (face))</span>
<span class="line-added">+     plan.apply_gpos = true;</span>
<span class="line-added">+   else if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added">+     plan.apply_kerx = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!plan.apply_kerx &amp;&amp; !has_gpos_kern)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     /* Apparently Apple applies kerx if GPOS kern was not applied. */</span>
<span class="line-added">+     if (hb_aat_layout_has_positioning (face))</span>
<span class="line-added">+       plan.apply_kerx = true;</span>
<span class="line-added">+     else if (hb_ot_layout_has_kerning (face))</span>
<span class="line-added">+       plan.apply_kern = true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.zero_marks = script_zero_marks &amp;&amp;</span>
<span class="line-added">+                     !plan.apply_kerx &amp;&amp;</span>
<span class="line-added">+                     (!plan.apply_kern || !hb_ot_layout_has_machine_kerning (face));</span>
<span class="line-added">+   plan.has_gpos_mark = !!plan.map.get_1_mask (HB_TAG (&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;));</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.adjust_mark_positioning_when_zeroing = !plan.apply_gpos &amp;&amp;</span>
<span class="line-added">+                                               !plan.apply_kerx &amp;&amp;</span>
<span class="line-added">+                                               (!plan.apply_kern || !hb_ot_layout_has_cross_kerning (face));</span>
<span class="line-added">+ </span>
<span class="line-added">+   plan.fallback_mark_positioning = plan.adjust_mark_positioning_when_zeroing &amp;&amp;</span>
<span class="line-added">+                                    script_fallback_mark_positioning;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Currently we always apply trak. */</span>
<span class="line-added">+   plan.apply_trak = plan.requested_tracking &amp;&amp; hb_aat_layout_has_tracking (face);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool</span>
<span class="line-added">+ hb_ot_shape_plan_t::init0 (hb_face_t                     *face,</span>
<span class="line-added">+                            const hb_shape_plan_key_t     *key)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   map.init ();</span>
<span class="line-added">+   aat_map.init ();</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_ot_shape_planner_t planner (face,</span>
<span class="line-added">+                                  &amp;key-&gt;props);</span>
<span class="line-added">+ </span>
<span class="line-added">+   hb_ot_shape_collect_features (&amp;planner,</span>
<span class="line-added">+                                 key-&gt;user_features,</span>
<span class="line-added">+                                 key-&gt;num_user_features);</span>
<span class="line-added">+ </span>
<span class="line-added">+   planner.compile (*this, key-&gt;ot);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (shaper-&gt;data_create)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     data = shaper-&gt;data_create (this);</span>
<span class="line-added">+     if (unlikely (!data))</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return true;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_shape_plan_t::fini ()</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (shaper-&gt;data_destroy)</span>
<span class="line-added">+     shaper-&gt;data_destroy (const_cast&lt;void *&gt; (data));</span>
<span class="line-added">+ </span>
<span class="line-added">+   map.fini ();</span>
<span class="line-added">+   aat_map.fini ();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_shape_plan_t::substitute (hb_font_t   *font,</span>
<span class="line-added">+                                 hb_buffer_t *buffer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (unlikely (apply_morx))</span>
<span class="line-added">+     hb_aat_layout_substitute (this, font, buffer);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     map.substitute (this, font, buffer);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void</span>
<span class="line-added">+ hb_ot_shape_plan_t::position (hb_font_t   *font,</span>
<span class="line-added">+                               hb_buffer_t *buffer) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+   if (this-&gt;apply_gpos)</span>
<span class="line-added">+     map.position (this, font, buffer);</span>
<span class="line-added">+   else if (this-&gt;apply_kerx)</span>
<span class="line-added">+     hb_aat_layout_position (this, font, buffer);</span>
<span class="line-added">+   else if (this-&gt;apply_kern)</span>
<span class="line-added">+     hb_ot_layout_kern (this, font, buffer);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     _hb_ot_shape_fallback_kern (this, font, buffer);</span>
  
<span class="line-added">+   if (this-&gt;apply_trak)</span>
<span class="line-added">+     hb_aat_layout_track (this, font, buffer);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! </span>
<span class="line-modified">! static const hb_ot_map_feature_t</span>
<span class="line-modified">! common_features[] =</span>
<span class="line-modified">! {</span>
<span class="line-modified">!   {HB_TAG(&#39;c&#39;,&#39;c&#39;,&#39;m&#39;,&#39;p&#39;), F_GLOBAL},</span>
<span class="line-modified">!   {HB_TAG(&#39;l&#39;,&#39;o&#39;,&#39;c&#39;,&#39;l&#39;), F_GLOBAL},</span>
<span class="line-modified">!   {HB_TAG(&#39;m&#39;,&#39;a&#39;,&#39;r&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   {HB_TAG(&#39;m&#39;,&#39;k&#39;,&#39;m&#39;,&#39;k&#39;), F_GLOBAL_MANUAL_JOINERS},</span>
<span class="line-added">+   {HB_TAG(&#39;r&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
  };
  
  
<span class="line-added">+ static const hb_ot_map_feature_t</span>
<span class="line-added">+ horizontal_features[] =</span>
<span class="line-added">+ {</span>
<span class="line-added">+   {HB_TAG(&#39;c&#39;,&#39;a&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added">+   {HB_TAG(&#39;c&#39;,&#39;l&#39;,&#39;i&#39;,&#39;g&#39;), F_GLOBAL},</span>
<span class="line-added">+   {HB_TAG(&#39;c&#39;,&#39;u&#39;,&#39;r&#39;,&#39;s&#39;), F_GLOBAL},</span>
<span class="line-added">+   {HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;), F_GLOBAL_HAS_FALLBACK},</span>
<span class="line-added">+   {HB_TAG(&#39;l&#39;,&#39;i&#39;,&#39;g&#39;,&#39;a&#39;), F_GLOBAL},</span>
<span class="line-added">+   {HB_TAG(&#39;r&#39;,&#39;c&#39;,&#39;l&#39;,&#39;t&#39;), F_GLOBAL},</span>
<span class="line-added">+ };</span>
  
  static void
  hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,
                                const hb_feature_t             *user_features,
                                unsigned int                    num_user_features)
  {
    hb_ot_map_builder_t *map = &amp;planner-&gt;map;
  
<span class="line-modified">!   map-&gt;enable_feature (HB_TAG(&#39;r&#39;,&#39;v&#39;,&#39;r&#39;,&#39;n&#39;));</span>
    map-&gt;add_gsub_pause (nullptr);
  
<span class="line-modified">!   switch (planner-&gt;props.direction) {</span>
      case HB_DIRECTION_LTR:
<span class="line-modified">!       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;a&#39;));</span>
<span class="line-modified">!       map-&gt;enable_feature (HB_TAG (&#39;l&#39;,&#39;t&#39;,&#39;r&#39;,&#39;m&#39;));</span>
        break;
      case HB_DIRECTION_RTL:
<span class="line-modified">!       map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;a&#39;));</span>
<span class="line-modified">!       map-&gt;add_feature (HB_TAG (&#39;r&#39;,&#39;t&#39;,&#39;l&#39;,&#39;m&#39;));</span>
        break;
      case HB_DIRECTION_TTB:
      case HB_DIRECTION_BTT:
      case HB_DIRECTION_INVALID:
      default:
        break;
    }
  
<span class="line-modified">!   /* Automatic fractions. */</span>
<span class="line-modified">!   map-&gt;add_feature (HB_TAG (&#39;f&#39;,&#39;r&#39;,&#39;a&#39;,&#39;c&#39;));</span>
<span class="line-modified">!   map-&gt;add_feature (HB_TAG (&#39;n&#39;,&#39;u&#39;,&#39;m&#39;,&#39;r&#39;));</span>
<span class="line-added">+   map-&gt;add_feature (HB_TAG (&#39;d&#39;,&#39;n&#39;,&#39;o&#39;,&#39;m&#39;));</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Random! */</span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG (&#39;r&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), F_RANDOM, HB_OT_MAP_MAX_VALUE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Tracking.  We enable dummy feature here just to allow disabling</span>
<span class="line-added">+    * AAT &#39;trak&#39; table using features.</span>
<span class="line-added">+    * https://github.com/harfbuzz/harfbuzz/issues/1303 */</span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG (&#39;t&#39;,&#39;r&#39;,&#39;a&#39;,&#39;k&#39;), F_HAS_FALLBACK);</span>
<span class="line-added">+ </span>
<span class="line-added">+   map-&gt;enable_feature (HB_TAG (&#39;H&#39;,&#39;A&#39;,&#39;R&#39;,&#39;F&#39;));</span>
  
    if (planner-&gt;shaper-&gt;collect_features)
      planner-&gt;shaper-&gt;collect_features (planner);
  
<span class="line-added">+   map-&gt;enable_feature (HB_TAG (&#39;B&#39;,&#39;U&#39;,&#39;Z&#39;,&#39;Z&#39;));</span>
<span class="line-added">+ </span>
    for (unsigned int i = 0; i &lt; ARRAY_LENGTH (common_features); i++)
<span class="line-modified">!     map-&gt;add_feature (common_features[i]);</span>
  
<span class="line-modified">!   if (HB_DIRECTION_IS_HORIZONTAL (planner-&gt;props.direction))</span>
      for (unsigned int i = 0; i &lt; ARRAY_LENGTH (horizontal_features); i++)
<span class="line-modified">!       map-&gt;add_feature (horizontal_features[i]);</span>
    else
    {
      /* We really want to find a &#39;vert&#39; feature if there&#39;s any in the font, no
       * matter which script/langsys it is listed (or not) under.
       * See various bugs referenced from:
       * https://github.com/harfbuzz/harfbuzz/issues/63 */
<span class="line-modified">!     map-&gt;enable_feature (HB_TAG (&#39;v&#39;,&#39;e&#39;,&#39;r&#39;,&#39;t&#39;), F_GLOBAL_SEARCH);</span>
    }
  
<span class="line-modified">!   for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-modified">!   {</span>
      const hb_feature_t *feature = &amp;user_features[i];
<span class="line-modified">!     map-&gt;add_feature (feature-&gt;tag,</span>
<span class="line-modified">!                       (feature-&gt;start == HB_FEATURE_GLOBAL_START &amp;&amp;</span>
<span class="line-modified">!                        feature-&gt;end == HB_FEATURE_GLOBAL_END) ?  F_GLOBAL : F_NONE,</span>
<span class="line-added">+                       feature-&gt;value);</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   if (planner-&gt;apply_morx)</span>
<span class="line-added">+   {</span>
<span class="line-added">+     hb_aat_map_builder_t *aat_map = &amp;planner-&gt;aat_map;</span>
<span class="line-added">+     for (unsigned int i = 0; i &lt; num_user_features; i++)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       const hb_feature_t *feature = &amp;user_features[i];</span>
<span class="line-added">+       aat_map-&gt;add_feature (feature-&gt;tag, feature-&gt;value);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (planner-&gt;shaper-&gt;override_features)</span>
<span class="line-added">+     planner-&gt;shaper-&gt;override_features (planner);</span>
  }
  
  
  /*
   * shaper face data
   */
  
<span class="line-modified">! struct hb_ot_face_data_t {};</span>
  
<span class="line-modified">! hb_ot_face_data_t *</span>
  _hb_ot_shaper_face_data_create (hb_face_t *face)
  {
<span class="line-modified">!   return (hb_ot_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
  }
  
  void
<span class="line-modified">! _hb_ot_shaper_face_data_destroy (hb_ot_face_data_t *data)</span>
  {
  }
  
  
  /*
   * shaper font data
   */
  
<span class="line-modified">! struct hb_ot_font_data_t {};</span>
  
<span class="line-modified">! hb_ot_font_data_t *</span>
  _hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)
  {
<span class="line-modified">!   return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;</span>
  }
  
  void
<span class="line-modified">! _hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data HB_UNUSED)</span>
  {
  }
  
  
  /*
   * shaper
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,12 ***</span>
    hb_buffer_t  *buffer;
    const hb_feature_t *user_features;
    unsigned int        num_user_features;
  
    /* Transient stuff */
<span class="line-removed">-   bool fallback_positioning;</span>
<span class="line-removed">-   bool fallback_glyph_classes;</span>
    hb_direction_t target_direction;
  };
  
  
  
<span class="line-new-header">--- 381,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 241,23 ***</span>
  /* Prepare */
  
  static void
  hb_set_unicode_props (hb_buffer_t *buffer)
  {
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = 0; i &lt; count; i++)
      _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);
  }
  
  static void
  hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
  {
    if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
        buffer-&gt;context_len[0] ||
<span class="line-modified">!       _hb_glyph_info_get_general_category (&amp;buffer-&gt;info[0]) !=</span>
<span class="line-removed">-       HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)</span>
      return;
  
    if (!font-&gt;has_glyph (0x25CCu))
      return;
  
<span class="line-new-header">--- 394,65 ---</span>
  /* Prepare */
  
  static void
  hb_set_unicode_props (hb_buffer_t *buffer)
  {
<span class="line-added">+   /* Implement enough of Unicode Graphemes here that shaping</span>
<span class="line-added">+    * in reverse-direction wouldn&#39;t break graphemes.  Namely,</span>
<span class="line-added">+    * we mark all marks and ZWJ and ZWJ,Extended_Pictographic</span>
<span class="line-added">+    * sequences as continuations.  The foreach_grapheme()</span>
<span class="line-added">+    * macro uses this bit.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * https://www.unicode.org/reports/tr29/#Regex_Definitions</span>
<span class="line-added">+    */</span>
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
    for (unsigned int i = 0; i &lt; count; i++)
<span class="line-added">+   {</span>
      _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);
<span class="line-added">+ </span>
<span class="line-added">+     /* Marks are already set as continuation by the above line.</span>
<span class="line-added">+      * Handle Emoji_Modifier and ZWJ-continuation. */</span>
<span class="line-added">+     if (unlikely (_hb_glyph_info_get_general_category (&amp;info[i]) == HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL &amp;&amp;</span>
<span class="line-added">+                   hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0x1F3FBu, 0x1F3FFu)))</span>
<span class="line-added">+     {</span>
<span class="line-added">+         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     else if (unlikely (_hb_glyph_info_is_zwj (&amp;info[i])))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added">+       if (i + 1 &lt; count &amp;&amp;</span>
<span class="line-added">+           _hb_unicode_is_emoji_Extended_Pictographic (info[i + 1].codepoint))</span>
<span class="line-added">+       {</span>
<span class="line-added">+         i++;</span>
<span class="line-added">+         _hb_glyph_info_set_unicode_props (&amp;info[i], buffer);</span>
<span class="line-added">+         _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     /* Or part of the Other_Grapheme_Extend that is not marks.</span>
<span class="line-added">+      * As of Unicode 11 that is just:</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * 200C          ; Other_Grapheme_Extend # Cf       ZERO WIDTH NON-JOINER</span>
<span class="line-added">+      * FF9E..FF9F    ; Other_Grapheme_Extend # Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK</span>
<span class="line-added">+      * E0020..E007F  ; Other_Grapheme_Extend # Cf  [96] TAG SPACE..CANCEL TAG</span>
<span class="line-added">+      *</span>
<span class="line-added">+      * ZWNJ is special, we don&#39;t want to merge it as there&#39;s no need, and keeping</span>
<span class="line-added">+      * it separate results in more granular clusters.  Ignore Katakana for now.</span>
<span class="line-added">+      * Tags are used for Emoji sub-region flag sequences:</span>
<span class="line-added">+      * https://github.com/harfbuzz/harfbuzz/issues/1556</span>
<span class="line-added">+      */</span>
<span class="line-added">+     else if (unlikely (hb_in_range&lt;hb_codepoint_t&gt; (info[i].codepoint, 0xE0020u, 0xE007Fu)))</span>
<span class="line-added">+       _hb_glyph_info_set_continuation (&amp;info[i]);</span>
<span class="line-added">+   }</span>
  }
  
  static void
  hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)
  {
    if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_BOT) ||
        buffer-&gt;context_len[0] ||
<span class="line-modified">!       !_hb_glyph_info_is_unicode_mark (&amp;buffer-&gt;info[0]))</span>
      return;
  
    if (!font-&gt;has_glyph (0x25CCu))
      return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,40 ***</span>
    info.cluster = buffer-&gt;cur().cluster;
    info.mask = buffer-&gt;cur().mask;
    buffer-&gt;output_info (info);
    while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
      buffer-&gt;next_glyph ();
<span class="line-removed">- </span>
    buffer-&gt;swap_buffers ();
  }
  
  static void
  hb_form_clusters (hb_buffer_t *buffer)
  {
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
      return;
  
<span class="line-removed">-   /* Loop duplicated in hb_ensure_native_direction(), and in _hb-coretext.cc */</span>
<span class="line-removed">-   unsigned int base = 0;</span>
<span class="line-removed">-   unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">-   hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">-   for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i])) &amp;&amp;</span>
<span class="line-removed">-                 !_hb_glyph_info_is_joiner (&amp;info[i])))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)</span>
<span class="line-removed">-         buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         buffer-&gt;unsafe_to_break (base, i);</span>
<span class="line-removed">-       base = i;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
    if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<span class="line-modified">!     buffer-&gt;merge_clusters (base, count);</span>
    else
<span class="line-modified">!     buffer-&gt;unsafe_to_break (base, count);</span>
  }
  
  static void
  hb_ensure_native_direction (hb_buffer_t *buffer)
  {
<span class="line-new-header">--- 467,25 ---</span>
    info.cluster = buffer-&gt;cur().cluster;
    info.mask = buffer-&gt;cur().mask;
    buffer-&gt;output_info (info);
    while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
      buffer-&gt;next_glyph ();
    buffer-&gt;swap_buffers ();
  }
  
  static void
  hb_form_clusters (hb_buffer_t *buffer)
  {
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))
      return;
  
    if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)
<span class="line-modified">!     foreach_grapheme (buffer, start, end)</span>
<span class="line-added">+       buffer-&gt;merge_clusters (start, end);</span>
    else
<span class="line-modified">!     foreach_grapheme (buffer, start, end)</span>
<span class="line-added">+       buffer-&gt;unsafe_to_break (start, end);</span>
  }
  
  static void
  hb_ensure_native_direction (hb_buffer_t *buffer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,41 ***</span>
    if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
         direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
        (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
         direction != HB_DIRECTION_TTB))
    {
<span class="line-removed">-     /* Same loop as hb_form_clusters().</span>
<span class="line-removed">-      * Since form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-removed">-     unsigned int base = 0;</span>
<span class="line-removed">-     unsigned int count = buffer-&gt;len;</span>
<span class="line-removed">-     hb_glyph_info_t *info = buffer-&gt;info;</span>
<span class="line-removed">-     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&amp;info[i]))))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)</span>
<span class="line-removed">-           buffer-&gt;merge_clusters (base, i);</span>
<span class="line-removed">-         buffer-&gt;reverse_range (base, i);</span>
  
<span class="line-removed">-         base = i;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
      if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<span class="line-modified">!       buffer-&gt;merge_clusters (base, count);</span>
<span class="line-modified">!     buffer-&gt;reverse_range (base, count);</span>
  
      buffer-&gt;reverse ();
  
      buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
    }
  }
  
  
<span class="line-modified">! /* Substitute */</span>
  
  static inline void
<span class="line-modified">! hb_ot_mirror_chars (hb_ot_shape_context_t *c)</span>
  {
    if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
      return;
  
    hb_buffer_t *buffer = c-&gt;buffer;
<span class="line-new-header">--- 499,35 ---</span>
    if ((HB_DIRECTION_IS_HORIZONTAL (direction) &amp;&amp;
         direction != horiz_dir &amp;&amp; horiz_dir != HB_DIRECTION_INVALID) ||
        (HB_DIRECTION_IS_VERTICAL   (direction) &amp;&amp;
         direction != HB_DIRECTION_TTB))
    {
  
      if (buffer-&gt;cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)
<span class="line-modified">!       foreach_grapheme (buffer, start, end)</span>
<span class="line-modified">!       {</span>
<span class="line-added">+         buffer-&gt;merge_clusters (start, end);</span>
<span class="line-added">+         buffer-&gt;reverse_range (start, end);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     else</span>
<span class="line-added">+       foreach_grapheme (buffer, start, end)</span>
<span class="line-added">+         /* form_clusters() merged clusters already, we don&#39;t merge. */</span>
<span class="line-added">+         buffer-&gt;reverse_range (start, end);</span>
  
      buffer-&gt;reverse ();
  
      buffer-&gt;props.direction = HB_DIRECTION_REVERSE (buffer-&gt;props.direction);
    }
  }
  
  
<span class="line-modified">! /*</span>
<span class="line-added">+  * Substitute</span>
<span class="line-added">+  */</span>
  
  static inline void
<span class="line-modified">! hb_ot_mirror_chars (const hb_ot_shape_context_t *c)</span>
  {
    if (HB_DIRECTION_IS_FORWARD (c-&gt;target_direction))
      return;
  
    hb_buffer_t *buffer = c-&gt;buffer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 370,11 ***</span>
        info[i].codepoint = codepoint;
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_setup_masks_fraction (hb_ot_shape_context_t *c)</span>
  {
    if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
        !c-&gt;plan-&gt;has_frac)
      return;
  
<span class="line-new-header">--- 544,11 ---</span>
        info[i].codepoint = codepoint;
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_setup_masks_fraction (const hb_ot_shape_context_t *c)</span>
  {
    if (!(c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||
        !c-&gt;plan-&gt;has_frac)
      return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 420,21 ***</span>
      }
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_initialize_masks (hb_ot_shape_context_t *c)</span>
  {
    hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_mask_t global_mask = map-&gt;get_global_mask ();
    buffer-&gt;reset_masks (global_mask);
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_setup_masks (hb_ot_shape_context_t *c)</span>
  {
    hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_shape_setup_masks_fraction (c);
<span class="line-new-header">--- 594,21 ---</span>
      }
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_initialize_masks (const hb_ot_shape_context_t *c)</span>
  {
    hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_mask_t global_mask = map-&gt;get_global_mask ();
    buffer-&gt;reset_masks (global_mask);
  }
  
  static inline void
<span class="line-modified">! hb_ot_shape_setup_masks (const hb_ot_shape_context_t *c)</span>
  {
    hb_ot_map_t *map = &amp;c-&gt;plan-&gt;map;
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_shape_setup_masks_fraction (c);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 452,14 ***</span>
      }
    }
  }
  
  static void
<span class="line-modified">! hb_ot_zero_width_default_ignorables (hb_ot_shape_context_t *c)</span>
  {
<span class="line-removed">-   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed">- </span>
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
      return;
  
<span class="line-new-header">--- 626,12 ---</span>
      }
    }
  }
  
  static void
<span class="line-modified">! hb_ot_zero_width_default_ignorables (const hb_buffer_t *buffer)</span>
  {
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))
      return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,87 ***</span>
      if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
        pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
  }
  
  static void
<span class="line-modified">! hb_ot_hide_default_ignorables (hb_ot_shape_context_t *c)</span>
  {
<span class="line-removed">-   hb_buffer_t *buffer = c-&gt;buffer;</span>
<span class="line-removed">- </span>
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
      return;
  
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
<span class="line-removed">-   hb_glyph_position_t *pos = buffer-&gt;pos;</span>
<span class="line-removed">-   unsigned int i = 0;</span>
<span class="line-removed">-   for (i = 0; i &lt; count; i++)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* No default-ignorables found; return. */</span>
<span class="line-removed">-   if (i == count)</span>
<span class="line-removed">-     return;</span>
  
<span class="line-modified">!   hb_codepoint_t space;</span>
    if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<span class="line-modified">!       c-&gt;font-&gt;get_nominal_glyph (&#39; &#39;, &amp;space))</span>
    {
<span class="line-modified">!     /* Replace default-ignorables with a zero-advance space glyph. */</span>
<span class="line-modified">!     for (/*continue*/; i &lt; count; i++)</span>
      {
        if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<span class="line-modified">!         info[i].codepoint = space;</span>
      }
    }
    else
<span class="line-modified">!   {</span>
<span class="line-removed">-     /* Merge clusters and delete default-ignorables.</span>
<span class="line-removed">-      * NOTE! We can&#39;t use out-buffer as we have positioning data. */</span>
<span class="line-removed">-     unsigned int j = i;</span>
<span class="line-removed">-     for (; i &lt; count; i++)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         /* Merge clusters.</span>
<span class="line-removed">-          * Same logic as buffer-&gt;delete_glyph(), but for in-place removal. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         unsigned int cluster = info[i].cluster;</span>
<span class="line-removed">-         if (i + 1 &lt; count &amp;&amp; cluster == info[i + 1].cluster)</span>
<span class="line-removed">-           continue; /* Cluster survives; do nothing. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (j)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           /* Merge cluster backward. */</span>
<span class="line-removed">-           if (cluster &lt; info[j - 1].cluster)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             unsigned int mask = info[i].mask;</span>
<span class="line-removed">-             unsigned int old_cluster = info[j - 1].cluster;</span>
<span class="line-removed">-             for (unsigned k = j; k &amp;&amp; info[k - 1].cluster == old_cluster; k--)</span>
<span class="line-removed">-               buffer-&gt;set_cluster (info[k - 1], cluster, mask);</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-           continue;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (i + 1 &lt; count)</span>
<span class="line-removed">-           buffer-&gt;merge_clusters (i, i + 2); /* Merge cluster forward. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-         continue;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (j != i)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         info[j] = info[i];</span>
<span class="line-removed">-         pos[j] = pos[i];</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       j++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     buffer-&gt;len = j;</span>
<span class="line-removed">-   }</span>
  }
  
  
  static inline void
  hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
<span class="line-new-header">--- 643,33 ---</span>
      if (unlikely (_hb_glyph_info_is_default_ignorable (&amp;info[i])))
        pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;
  }
  
  static void
<span class="line-modified">! hb_ot_hide_default_ignorables (hb_buffer_t *buffer,</span>
<span class="line-added">+                                hb_font_t   *font)</span>
  {
    if (!(buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||
        (buffer-&gt;flags &amp; HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))
      return;
  
    unsigned int count = buffer-&gt;len;
    hb_glyph_info_t *info = buffer-&gt;info;
  
<span class="line-modified">!   hb_codepoint_t invisible = buffer-&gt;invisible;</span>
    if (!(buffer-&gt;flags &amp; HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &amp;&amp;
<span class="line-modified">!       (invisible || font-&gt;get_nominal_glyph (&#39; &#39;, &amp;invisible)))</span>
    {
<span class="line-modified">!     /* Replace default-ignorables with a zero-advance invisible glyph. */</span>
<span class="line-modified">!     for (unsigned int i = 0; i &lt; count; i++)</span>
      {
        if (_hb_glyph_info_is_default_ignorable (&amp;info[i]))
<span class="line-modified">!         info[i].codepoint = invisible;</span>
      }
    }
    else
<span class="line-modified">!     hb_ot_layout_delete_glyphs_inplace (buffer, _hb_glyph_info_is_default_ignorable);</span>
  }
  
  
  static inline void
  hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,14 ***</span>
  
    buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
  }
  
  static inline void
<span class="line-modified">! hb_synthesize_glyph_classes (hb_ot_shape_context_t *c)</span>
  {
<span class="line-modified">!   unsigned int count = c-&gt;buffer-&gt;len;</span>
<span class="line-modified">!   hb_glyph_info_t *info = c-&gt;buffer-&gt;info;</span>
    for (unsigned int i = 0; i &lt; count; i++)
    {
      hb_ot_layout_glyph_props_flags_t klass;
  
      /* Never mark default-ignorables as marks.
<span class="line-new-header">--- 682,14 ---</span>
  
    buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;
  }
  
  static inline void
<span class="line-modified">! hb_synthesize_glyph_classes (hb_buffer_t *buffer)</span>
  {
<span class="line-modified">!   unsigned int count = buffer-&gt;len;</span>
<span class="line-modified">!   hb_glyph_info_t *info = buffer-&gt;info;</span>
    for (unsigned int i = 0; i &lt; count; i++)
    {
      hb_ot_layout_glyph_props_flags_t klass;
  
      /* Never mark default-ignorables as marks.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,11 ***</span>
      _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute_default (hb_ot_shape_context_t *c)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_mirror_chars (c);
  
<span class="line-new-header">--- 708,11 ---</span>
      _hb_glyph_info_set_glyph_props (&amp;info[i], klass);
    }
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute_default (const hb_ot_shape_context_t *c)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_mirror_chars (c);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,45 ***</span>
    _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
  
    hb_ot_shape_setup_masks (c);
  
    /* This is unfortunate to go here, but necessary... */
<span class="line-modified">!   if (c-&gt;fallback_positioning)</span>
<span class="line-modified">!     _hb_ot_shape_fallback_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
  
    hb_ot_map_glyphs_fast (buffer);
  
    HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute_complex (hb_ot_shape_context_t *c)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_layout_substitute_start (c-&gt;font, buffer);
  
<span class="line-modified">!   if (!hb_ot_layout_has_glyph_classes (c-&gt;face))</span>
<span class="line-modified">!     hb_synthesize_glyph_classes (c);</span>
  
    c-&gt;plan-&gt;substitute (c-&gt;font, buffer);
<span class="line-removed">- </span>
<span class="line-removed">-   /* XXX Call morx instead. */</span>
<span class="line-removed">-   //hb_aat_layout_substitute (c-&gt;font, c-&gt;buffer);</span>
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute (hb_ot_shape_context_t *c)</span>
  {
    hb_ot_substitute_default (c);
  
    _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
  
    hb_ot_substitute_complex (c);
  }
  
<span class="line-modified">! /* Position */</span>
  
  static inline void
  adjust_mark_offsets (hb_glyph_position_t *pos)
  {
    pos-&gt;x_offset -= pos-&gt;x_advance;
<span class="line-new-header">--- 721,56 ---</span>
    _hb_ot_shape_normalize (c-&gt;plan, buffer, c-&gt;font);
  
    hb_ot_shape_setup_masks (c);
  
    /* This is unfortunate to go here, but necessary... */
<span class="line-modified">!   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-modified">!     _hb_ot_shape_fallback_mark_position_recategorize_marks (c-&gt;plan, c-&gt;font, buffer);</span>
  
    hb_ot_map_glyphs_fast (buffer);
  
    HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute_complex (const hb_ot_shape_context_t *c)</span>
  {
    hb_buffer_t *buffer = c-&gt;buffer;
  
    hb_ot_layout_substitute_start (c-&gt;font, buffer);
  
<span class="line-modified">!   if (c-&gt;plan-&gt;fallback_glyph_classes)</span>
<span class="line-modified">!     hb_synthesize_glyph_classes (c-&gt;buffer);</span>
  
    c-&gt;plan-&gt;substitute (c-&gt;font, buffer);
  }
  
  static inline void
<span class="line-modified">! hb_ot_substitute_pre (const hb_ot_shape_context_t *c)</span>
  {
    hb_ot_substitute_default (c);
  
    _hb_buffer_allocate_gsubgpos_vars (c-&gt;buffer);
  
    hb_ot_substitute_complex (c);
  }
  
<span class="line-modified">! static inline void</span>
<span class="line-added">+ hb_ot_substitute_post (const hb_ot_shape_context_t *c)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   hb_ot_hide_default_ignorables (c-&gt;buffer, c-&gt;font);</span>
<span class="line-added">+   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added">+     hb_aat_layout_remove_deleted_glyphs (c-&gt;buffer);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-added">+     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ /*</span>
<span class="line-added">+  * Position</span>
<span class="line-added">+  */</span>
  
  static inline void
  adjust_mark_offsets (hb_glyph_position_t *pos)
  {
    pos-&gt;x_offset -= pos-&gt;x_advance;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,60 ***</span>
        zero_mark_width (&amp;buffer-&gt;pos[i]);
      }
  }
  
  static inline void
<span class="line-modified">! hb_ot_position_default (hb_ot_shape_context_t *c)</span>
  {
    hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
    unsigned int count = c-&gt;buffer-&gt;len;
    hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
    hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
  
    if (HB_DIRECTION_IS_HORIZONTAL (direction))
    {
<span class="line-modified">!     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-modified">!       pos[i].x_advance = c-&gt;font-&gt;get_glyph_h_advance (info[i].codepoint);</span>
      /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
      if (c-&gt;font-&gt;has_glyph_h_origin_func ())
        for (unsigned int i = 0; i &lt; count; i++)
          c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
                                            &amp;pos[i].x_offset,
                                            &amp;pos[i].y_offset);
    }
    else
    {
      for (unsigned int i = 0; i &lt; count; i++)
      {
<span class="line-removed">-       pos[i].y_advance = c-&gt;font-&gt;get_glyph_v_advance (info[i].codepoint);</span>
        c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
                                          &amp;pos[i].x_offset,
                                          &amp;pos[i].y_offset);
      }
    }
    if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
      _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
  }
  
  static inline void
<span class="line-modified">! hb_ot_position_complex (hb_ot_shape_context_t *c)</span>
  {
    unsigned int count = c-&gt;buffer-&gt;len;
    hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
    hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
  
<span class="line-modified">!   /* If the font has no GPOS, AND, no fallback positioning will</span>
<span class="line-modified">!    * happen, AND, direction is forward, then when zeroing mark</span>
<span class="line-modified">!    * widths, we shift the mark with it, such that the mark</span>
<span class="line-removed">-    * is positioned hanging over the previous glyph.  When</span>
     * direction is backward we don&#39;t shift and it will end up
     * hanging over the next glyph after the final reordering.
<span class="line-modified">!    * If fallback positinoing happens or GPOS is present, we don&#39;t</span>
<span class="line-modified">!    * care.</span>
     */
<span class="line-modified">!   bool adjust_offsets_when_zeroing = c-&gt;fallback_positioning &amp;&amp;</span>
<span class="line-removed">-                                      !c-&gt;plan-&gt;shaper-&gt;fallback_position &amp;&amp;</span>
                                       HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
  
    /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
  
    /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
<span class="line-new-header">--- 797,60 ---</span>
        zero_mark_width (&amp;buffer-&gt;pos[i]);
      }
  }
  
  static inline void
<span class="line-modified">! hb_ot_position_default (const hb_ot_shape_context_t *c)</span>
  {
    hb_direction_t direction = c-&gt;buffer-&gt;props.direction;
    unsigned int count = c-&gt;buffer-&gt;len;
    hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
    hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
  
    if (HB_DIRECTION_IS_HORIZONTAL (direction))
    {
<span class="line-modified">!     c-&gt;font-&gt;get_glyph_h_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-modified">!                                    &amp;pos[0].x_advance, sizeof(pos[0]));</span>
      /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
      if (c-&gt;font-&gt;has_glyph_h_origin_func ())
        for (unsigned int i = 0; i &lt; count; i++)
          c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
                                            &amp;pos[i].x_offset,
                                            &amp;pos[i].y_offset);
    }
    else
    {
<span class="line-added">+     c-&gt;font-&gt;get_glyph_v_advances (count, &amp;info[0].codepoint, sizeof(info[0]),</span>
<span class="line-added">+                                    &amp;pos[0].y_advance, sizeof(pos[0]));</span>
      for (unsigned int i = 0; i &lt; count; i++)
      {
        c-&gt;font-&gt;subtract_glyph_v_origin (info[i].codepoint,
                                          &amp;pos[i].x_offset,
                                          &amp;pos[i].y_offset);
      }
    }
    if (c-&gt;buffer-&gt;scratch_flags &amp; HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)
      _hb_ot_shape_fallback_spaces (c-&gt;plan, c-&gt;font, c-&gt;buffer);
  }
  
  static inline void
<span class="line-modified">! hb_ot_position_complex (const hb_ot_shape_context_t *c)</span>
  {
    unsigned int count = c-&gt;buffer-&gt;len;
    hb_glyph_info_t *info = c-&gt;buffer-&gt;info;
    hb_glyph_position_t *pos = c-&gt;buffer-&gt;pos;
  
<span class="line-modified">!   /* If the font has no GPOS and direction is forward, then when</span>
<span class="line-modified">!    * zeroing mark widths, we shift the mark with it, such that the</span>
<span class="line-modified">!    * mark is positioned hanging over the previous glyph.  When</span>
     * direction is backward we don&#39;t shift and it will end up
     * hanging over the next glyph after the final reordering.
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Note: If fallback positinoing happens, we don&#39;t care about</span>
<span class="line-added">+    * this as it will be overriden.</span>
     */
<span class="line-modified">!   bool adjust_offsets_when_zeroing = c-&gt;plan-&gt;adjust_mark_positioning_when_zeroing &amp;&amp;</span>
                                       HB_DIRECTION_IS_FORWARD (c-&gt;buffer-&gt;props.direction);
  
    /* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. */
  
    /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,73 ***</span>
                                     &amp;pos[i].x_offset,
                                     &amp;pos[i].y_offset);
  
    hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
  
<span class="line-modified">!   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified">!       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     default:</span>
<span class="line-modified">!     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified">!     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-removed">-   if (likely (!c-&gt;fallback_positioning))</span>
<span class="line-removed">-     c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>
  
<span class="line-modified">!   switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-removed">-       zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-removed">-       break;</span>
  
<span class="line-modified">!     default:</span>
<span class="line-modified">!     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified">!     case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!   }</span>
  
<span class="line-modified">!   /* Finishing off GPOS has to follow a certain order. */</span>
    hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<span class="line-modified">!   hb_ot_zero_width_default_ignorables (c);</span>
    hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
  
    /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
    if (c-&gt;font-&gt;has_glyph_h_origin_func ())
      for (unsigned int i = 0; i &lt; count; i++)
        c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
                                          &amp;pos[i].x_offset,
                                          &amp;pos[i].y_offset);
  }
  
  static inline void
<span class="line-modified">! hb_ot_position (hb_ot_shape_context_t *c)</span>
  {
    c-&gt;buffer-&gt;clear_positions ();
  
    hb_ot_position_default (c);
  
    hb_ot_position_complex (c);
  
<span class="line-removed">-   if (c-&gt;fallback_positioning &amp;&amp; c-&gt;plan-&gt;shaper-&gt;fallback_position)</span>
<span class="line-removed">-     _hb_ot_shape_fallback_position (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed">- </span>
    if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
      hb_buffer_reverse (c-&gt;buffer);
  
<span class="line-removed">-   /* Visual fallback goes here. */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (c-&gt;fallback_positioning)</span>
<span class="line-removed">-     _hb_ot_shape_fallback_kern (c-&gt;plan, c-&gt;font, c-&gt;buffer);</span>
<span class="line-removed">- </span>
    _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);
<span class="line-removed">- </span>
<span class="line-removed">-   //hb_aat_layout_position (c-&gt;font, c-&gt;buffer);</span>
  }
  
  static inline void
  hb_propagate_flags (hb_buffer_t *buffer)
  {
<span class="line-new-header">--- 860,70 ---</span>
                                     &amp;pos[i].x_offset,
                                     &amp;pos[i].y_offset);
  
    hb_ot_layout_position_start (c-&gt;font, c-&gt;buffer);
  
<span class="line-modified">!   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified">!     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-modified">!         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       default:</span>
<span class="line-modified">!       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-modified">!       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!   c-&gt;plan-&gt;position (c-&gt;font, c-&gt;buffer);</span>
  
<span class="line-modified">!   if (c-&gt;plan-&gt;zero_marks)</span>
<span class="line-modified">!     switch (c-&gt;plan-&gt;shaper-&gt;zero_width_marks)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:</span>
<span class="line-modified">!         zero_mark_widths_by_gdef (c-&gt;buffer, adjust_offsets_when_zeroing);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+       default:</span>
<span class="line-added">+       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:</span>
<span class="line-added">+       case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!   /* Finish off.  Has to follow a certain order. */</span>
    hb_ot_layout_position_finish_advances (c-&gt;font, c-&gt;buffer);
<span class="line-modified">!   hb_ot_zero_width_default_ignorables (c-&gt;buffer);</span>
<span class="line-added">+   if (c-&gt;plan-&gt;apply_morx)</span>
<span class="line-added">+     hb_aat_layout_zero_width_deleted_glyphs (c-&gt;buffer);</span>
    hb_ot_layout_position_finish_offsets (c-&gt;font, c-&gt;buffer);
  
    /* The nil glyph_h_origin() func returns 0, so no need to apply it. */
    if (c-&gt;font-&gt;has_glyph_h_origin_func ())
      for (unsigned int i = 0; i &lt; count; i++)
        c-&gt;font-&gt;subtract_glyph_h_origin (info[i].codepoint,
                                          &amp;pos[i].x_offset,
                                          &amp;pos[i].y_offset);
<span class="line-added">+ </span>
<span class="line-added">+   if (c-&gt;plan-&gt;fallback_mark_positioning)</span>
<span class="line-added">+     _hb_ot_shape_fallback_mark_position (c-&gt;plan, c-&gt;font, c-&gt;buffer,</span>
<span class="line-added">+                                          adjust_offsets_when_zeroing);</span>
  }
  
  static inline void
<span class="line-modified">! hb_ot_position (const hb_ot_shape_context_t *c)</span>
  {
    c-&gt;buffer-&gt;clear_positions ();
  
    hb_ot_position_default (c);
  
    hb_ot_position_complex (c);
  
    if (HB_DIRECTION_IS_BACKWARD (c-&gt;buffer-&gt;props.direction))
      hb_buffer_reverse (c-&gt;buffer);
  
    _hb_buffer_deallocate_gsubgpos_vars (c-&gt;buffer);
  }
  
  static inline void
  hb_propagate_flags (hb_buffer_t *buffer)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 829,26 ***</span>
  static void
  hb_ot_shape_internal (hb_ot_shape_context_t *c)
  {
    c-&gt;buffer-&gt;deallocate_var_all ();
    c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<span class="line-modified">!   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
    {
      c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
                                (unsigned) HB_BUFFER_MAX_LEN_MIN);
    }
<span class="line-modified">!   if (likely (!_hb_unsigned_int_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
    {
      c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
                                (unsigned) HB_BUFFER_MAX_OPS_MIN);
    }
  
<span class="line-removed">-   bool disable_otl = c-&gt;plan-&gt;shaper-&gt;disable_otl &amp;&amp; c-&gt;plan-&gt;shaper-&gt;disable_otl (c-&gt;plan);</span>
<span class="line-removed">-   //c-&gt;fallback_substitute     = disable_otl || !hb_ot_layout_has_substitution (c-&gt;face);</span>
<span class="line-removed">-   c-&gt;fallback_positioning    = disable_otl || !hb_ot_layout_has_positioning (c-&gt;face);</span>
<span class="line-removed">-   c-&gt;fallback_glyph_classes  = disable_otl || !hb_ot_layout_has_glyph_classes (c-&gt;face);</span>
<span class="line-removed">- </span>
    /* Save the original direction, we use it later. */
    c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
  
    _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
  
<span class="line-new-header">--- 955,21 ---</span>
  static void
  hb_ot_shape_internal (hb_ot_shape_context_t *c)
  {
    c-&gt;buffer-&gt;deallocate_var_all ();
    c-&gt;buffer-&gt;scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
<span class="line-modified">!   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_LEN_FACTOR)))</span>
    {
      c-&gt;buffer-&gt;max_len = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_LEN_FACTOR,
                                (unsigned) HB_BUFFER_MAX_LEN_MIN);
    }
<span class="line-modified">!   if (likely (!hb_unsigned_mul_overflows (c-&gt;buffer-&gt;len, HB_BUFFER_MAX_OPS_FACTOR)))</span>
    {
      c-&gt;buffer-&gt;max_ops = MAX (c-&gt;buffer-&gt;len * HB_BUFFER_MAX_OPS_FACTOR,
                                (unsigned) HB_BUFFER_MAX_OPS_MIN);
    }
  
    /* Save the original direction, we use it later. */
    c-&gt;target_direction = c-&gt;buffer-&gt;props.direction;
  
    _hb_buffer_allocate_unicode_vars (c-&gt;buffer);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,17 ***</span>
    hb_ensure_native_direction (c-&gt;buffer);
  
    if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
      c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
  
<span class="line-modified">!   hb_ot_substitute (c);</span>
    hb_ot_position (c);
<span class="line-modified">! </span>
<span class="line-removed">-   hb_ot_hide_default_ignorables (c);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs)</span>
<span class="line-removed">-     c-&gt;plan-&gt;shaper-&gt;postprocess_glyphs (c-&gt;plan, c-&gt;buffer, c-&gt;font);</span>
  
    hb_propagate_flags (c-&gt;buffer);
  
    _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
  
<span class="line-new-header">--- 984,13 ---</span>
    hb_ensure_native_direction (c-&gt;buffer);
  
    if (c-&gt;plan-&gt;shaper-&gt;preprocess_text)
      c-&gt;plan-&gt;shaper-&gt;preprocess_text (c-&gt;plan, c-&gt;buffer, c-&gt;font);
  
<span class="line-modified">!   hb_ot_substitute_pre (c);</span>
    hb_ot_position (c);
<span class="line-modified">!   hb_ot_substitute_post (c);</span>
  
    hb_propagate_flags (c-&gt;buffer);
  
    _hb_buffer_deallocate_unicode_vars (c-&gt;buffer);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 890,11 ***</span>
                hb_font_t          *font,
                hb_buffer_t        *buffer,
                const hb_feature_t *features,
                unsigned int        num_features)
  {
<span class="line-modified">!   hb_ot_shape_context_t c = {HB_SHAPER_DATA_GET (shape_plan), font, font-&gt;face, buffer, features, num_features};</span>
    hb_ot_shape_internal (&amp;c);
  
    return true;
  }
  
<span class="line-new-header">--- 1007,11 ---</span>
                hb_font_t          *font,
                hb_buffer_t        *buffer,
                const hb_feature_t *features,
                unsigned int        num_features)
  {
<span class="line-modified">!   hb_ot_shape_context_t c = {&amp;shape_plan-&gt;ot, font, font-&gt;face, buffer, features, num_features};</span>
    hb_ot_shape_internal (&amp;c);
  
    return true;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 907,12 ***</span>
  void
  hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
                                    hb_tag_t         table_tag,
                                    hb_set_t        *lookup_indexes /* OUT */)
  {
<span class="line-modified">!   /* XXX Does the first part always succeed? */</span>
<span class="line-removed">-   HB_SHAPER_DATA_GET (shape_plan)-&gt;collect_lookups (table_tag, lookup_indexes);</span>
  }
  
  
  /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
  static void
<span class="line-new-header">--- 1024,11 ---</span>
  void
  hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,
                                    hb_tag_t         table_tag,
                                    hb_set_t        *lookup_indexes /* OUT */)
  {
<span class="line-modified">!   shape_plan-&gt;ot.collect_lookups (table_tag, lookup_indexes);</span>
  }
  
  
  /* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. */
  static void
</pre>
<center><a href="hb-ot-shape-normalize.cc.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="hb-ot-tag.cc.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
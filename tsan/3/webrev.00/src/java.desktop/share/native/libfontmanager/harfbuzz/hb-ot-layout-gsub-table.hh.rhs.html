<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout-gsub-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 2007,2008,2009,2010  Red Hat, Inc.
   3  * Copyright © 2010,2012,2013  Google, Inc.
   4  *
   5  *  This is part of HarfBuzz, a text shaping library.
   6  *
   7  * Permission is hereby granted, without written agreement and without
   8  * license or royalty fees, to use, copy, modify, and distribute this
   9  * software and its documentation for any purpose, provided that the
  10  * above copyright notice and the following two paragraphs appear in
  11  * all copies of this software.
  12  *
  13  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  14  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  15  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  16  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  17  * DAMAGE.
  18  *
  19  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  20  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  21  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  22  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  23  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  24  *
  25  * Red Hat Author(s): Behdad Esfahbod
  26  * Google Author(s): Behdad Esfahbod
  27  */
  28 
  29 #ifndef HB_OT_LAYOUT_GSUB_TABLE_HH
  30 #define HB_OT_LAYOUT_GSUB_TABLE_HH
  31 
<a name="1" id="anc1"></a><span class="line-modified">  32 #include &quot;hb-ot-layout-gsubgpos.hh&quot;</span>
  33 
  34 
  35 namespace OT {
  36 
  37 
<a name="2" id="anc2"></a><span class="line-added">  38 static inline void SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added">  39                                           hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added">  40                                           hb_array_t&lt;const GlyphID&gt; substitutes);</span>
<span class="line-added">  41 </span>
  42 struct SingleSubstFormat1
  43 {
<a name="3" id="anc3"></a><span class="line-modified">  44   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">  45   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added">  46 </span>
<span class="line-added">  47   void closure (hb_closure_context_t *c) const</span>
  48   {
<a name="4" id="anc4"></a><span class="line-modified">  49     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>


  50     {
  51       /* TODO Switch to range-based API to work around malicious fonts.
  52        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  53       hb_codepoint_t glyph_id = iter.get_glyph ();
  54       if (c-&gt;glyphs-&gt;has (glyph_id))
<a name="5" id="anc5"></a><span class="line-modified">  55         c-&gt;out-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);</span>
  56     }
  57   }
  58 
<a name="6" id="anc6"></a><span class="line-modified">  59   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
  60   {
<a name="7" id="anc7"></a>
  61     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="8" id="anc8"></a><span class="line-modified">  62     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>

  63     {
  64       /* TODO Switch to range-based API to work around malicious fonts.
  65        * https://github.com/harfbuzz/harfbuzz/issues/363 */
  66       hb_codepoint_t glyph_id = iter.get_glyph ();
  67       c-&gt;output-&gt;add ((glyph_id + deltaGlyphID) &amp; 0xFFFFu);
  68     }
  69   }
  70 
<a name="9" id="anc9"></a><span class="line-modified">  71   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



  72 
<a name="10" id="anc10"></a><span class="line-modified">  73   bool would_apply (hb_would_apply_context_t *c) const</span>
  74   {
  75     TRACE_WOULD_APPLY (this);
  76     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
  77   }
  78 
<a name="11" id="anc11"></a><span class="line-modified">  79   bool apply (hb_ot_apply_context_t *c) const</span>
  80   {
  81     TRACE_APPLY (this);
  82     hb_codepoint_t glyph_id = c-&gt;buffer-&gt;cur().codepoint;
  83     unsigned int index = (this+coverage).get_coverage (glyph_id);
  84     if (likely (index == NOT_COVERED)) return_trace (false);
  85 
  86     /* According to the Adobe Annotated OpenType Suite, result is always
  87      * limited to 16bit. */
  88     glyph_id = (glyph_id + deltaGlyphID) &amp; 0xFFFFu;
  89     c-&gt;replace_glyph (glyph_id);
  90 
  91     return_trace (true);
  92   }
  93 
<a name="12" id="anc12"></a><span class="line-modified">  94   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified">  95                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">  96                   int delta)</span>

  97   {
  98     TRACE_SERIALIZE (this);
  99     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="13" id="anc13"></a><span class="line-modified"> 100     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
<span class="line-modified"> 101     deltaGlyphID.set (delta); /* TODO(serialize) overflow? */</span>
 102     return_trace (true);
 103   }
 104 
<a name="14" id="anc14"></a><span class="line-modified"> 105   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 106   {</span>
<span class="line-added"> 107     TRACE_SUBSET (this);</span>
<span class="line-added"> 108     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added"> 109     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added"> 110     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added"> 111     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added"> 112     hb_codepoint_t delta = deltaGlyphID;</span>
<span class="line-added"> 113     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 114     {</span>
<span class="line-added"> 115       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added"> 116       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added"> 117       to.push ()-&gt;set (glyph_map[(iter.get_glyph () + delta) &amp; 0xFFFF]);</span>
<span class="line-added"> 118     }</span>
<span class="line-added"> 119     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added"> 120     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added"> 121     return_trace (from.length);</span>
<span class="line-added"> 122   }</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   bool sanitize (hb_sanitize_context_t *c) const</span>
 125   {
 126     TRACE_SANITIZE (this);
 127     return_trace (coverage.sanitize (c, this) &amp;&amp; deltaGlyphID.sanitize (c));
 128   }
 129 
 130   protected:
 131   HBUINT16      format;                 /* Format identifier--format = 1 */
 132   OffsetTo&lt;Coverage&gt;
 133                 coverage;               /* Offset to Coverage table--from
 134                                          * beginning of Substitution table */
 135   HBINT16       deltaGlyphID;           /* Add to original GlyphID to get
 136                                          * substitute GlyphID */
 137   public:
 138   DEFINE_SIZE_STATIC (6);
 139 };
 140 
 141 struct SingleSubstFormat2
 142 {
<a name="15" id="anc15"></a><span class="line-modified"> 143   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 144   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146   void closure (hb_closure_context_t *c) const</span>
 147   {
<a name="16" id="anc16"></a>

 148     unsigned int count = substitute.len;
<a name="17" id="anc17"></a><span class="line-modified"> 149     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 150     {
 151       if (unlikely (iter.get_coverage () &gt;= count))
 152         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 153       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<a name="18" id="anc18"></a><span class="line-modified"> 154         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
 155     }
 156   }
 157 
<a name="19" id="anc19"></a><span class="line-modified"> 158   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 159   {
<a name="20" id="anc20"></a>
 160     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="21" id="anc21"></a>
 161     unsigned int count = substitute.len;
<a name="22" id="anc22"></a><span class="line-modified"> 162     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 163     {
 164       if (unlikely (iter.get_coverage () &gt;= count))
 165         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 166       c-&gt;output-&gt;add (substitute[iter.get_coverage ()]);
 167     }
 168   }
 169 
<a name="23" id="anc23"></a><span class="line-modified"> 170   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 171 
<a name="24" id="anc24"></a><span class="line-modified"> 172   bool would_apply (hb_would_apply_context_t *c) const</span>
 173   {
 174     TRACE_WOULD_APPLY (this);
 175     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 176   }
 177 
<a name="25" id="anc25"></a><span class="line-modified"> 178   bool apply (hb_ot_apply_context_t *c) const</span>
 179   {
 180     TRACE_APPLY (this);
<a name="26" id="anc26"></a><span class="line-modified"> 181     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>

 182     if (likely (index == NOT_COVERED)) return_trace (false);
 183 
 184     if (unlikely (index &gt;= substitute.len)) return_trace (false);
 185 
<a name="27" id="anc27"></a><span class="line-modified"> 186     c-&gt;replace_glyph (substitute[index]);</span>

 187 
 188     return_trace (true);
 189   }
 190 
<a name="28" id="anc28"></a><span class="line-modified"> 191   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 192                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 193                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>

 194   {
 195     TRACE_SERIALIZE (this);
 196     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="29" id="anc29"></a><span class="line-modified"> 197     if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);</span>
<span class="line-modified"> 198     if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);</span>
 199     return_trace (true);
 200   }
 201 
<a name="30" id="anc30"></a><span class="line-modified"> 202   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 203   {</span>
<span class="line-added"> 204     TRACE_SUBSET (this);</span>
<span class="line-added"> 205     const hb_set_t &amp;glyphset = *c-&gt;plan-&gt;glyphset;</span>
<span class="line-added"> 206     const hb_map_t &amp;glyph_map = *c-&gt;plan-&gt;glyph_map;</span>
<span class="line-added"> 207     hb_vector_t&lt;GlyphID&gt; from;</span>
<span class="line-added"> 208     hb_vector_t&lt;GlyphID&gt; to;</span>
<span class="line-added"> 209     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 210     {</span>
<span class="line-added"> 211       if (!glyphset.has (iter.get_glyph ())) continue;</span>
<span class="line-added"> 212       from.push ()-&gt;set (glyph_map[iter.get_glyph ()]);</span>
<span class="line-added"> 213       to.push ()-&gt;set (glyph_map[substitute[iter.get_coverage ()]]);</span>
<span class="line-added"> 214     }</span>
<span class="line-added"> 215     c-&gt;serializer-&gt;propagate_error (from, to);</span>
<span class="line-added"> 216     SingleSubst_serialize (c-&gt;serializer, from, to);</span>
<span class="line-added"> 217     return_trace (from.length);</span>
<span class="line-added"> 218   }</span>
<span class="line-added"> 219 </span>
<span class="line-added"> 220   bool sanitize (hb_sanitize_context_t *c) const</span>
 221   {
 222     TRACE_SANITIZE (this);
 223     return_trace (coverage.sanitize (c, this) &amp;&amp; substitute.sanitize (c));
 224   }
 225 
 226   protected:
 227   HBUINT16      format;                 /* Format identifier--format = 2 */
 228   OffsetTo&lt;Coverage&gt;
 229                 coverage;               /* Offset to Coverage table--from
 230                                          * beginning of Substitution table */
 231   ArrayOf&lt;GlyphID&gt;
 232                 substitute;             /* Array of substitute
 233                                          * GlyphIDs--ordered by Coverage Index */
 234   public:
 235   DEFINE_SIZE_ARRAY (6, substitute);
 236 };
 237 
 238 struct SingleSubst
 239 {
<a name="31" id="anc31"></a><span class="line-modified"> 240   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 241                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 242                   hb_array_t&lt;const GlyphID&gt; substitutes)</span>

 243   {
 244     TRACE_SERIALIZE (this);
 245     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 246     unsigned int format = 2;
 247     int delta = 0;
<a name="32" id="anc32"></a><span class="line-modified"> 248     if (glyphs.length)</span>
<span class="line-added"> 249     {</span>
 250       format = 1;
 251       /* TODO(serialize) check for wrap-around */
 252       delta = substitutes[0] - glyphs[0];
<a name="33" id="anc33"></a><span class="line-modified"> 253       for (unsigned int i = 1; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 254         if (delta != (int) (substitutes[i] - glyphs[i])) {</span>
 255           format = 2;
 256           break;
 257         }
 258     }
 259     u.format.set (format);
 260     switch (u.format) {
<a name="34" id="anc34"></a><span class="line-modified"> 261     case 1: return_trace (u.format1.serialize (c, glyphs, delta));</span>
<span class="line-modified"> 262     case 2: return_trace (u.format2.serialize (c, glyphs, substitutes));</span>
 263     default:return_trace (false);
 264     }
 265   }
 266 
 267   template &lt;typename context_t&gt;
<a name="35" id="anc35"></a><span class="line-modified"> 268   typename context_t::return_t dispatch (context_t *c) const</span>
 269   {
 270     TRACE_DISPATCH (this, u.format);
 271     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 272     switch (u.format) {
 273     case 1: return_trace (c-&gt;dispatch (u.format1));
 274     case 2: return_trace (c-&gt;dispatch (u.format2));
 275     default:return_trace (c-&gt;default_return_value ());
 276     }
 277   }
 278 
 279   protected:
 280   union {
 281   HBUINT16              format;         /* Format identifier */
 282   SingleSubstFormat1    format1;
 283   SingleSubstFormat2    format2;
 284   } u;
 285 };
 286 
<a name="36" id="anc36"></a><span class="line-added"> 287 static inline void</span>
<span class="line-added"> 288 SingleSubst_serialize (hb_serialize_context_t *c,</span>
<span class="line-added"> 289                        hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-added"> 290                        hb_array_t&lt;const GlyphID&gt; substitutes)</span>
<span class="line-added"> 291 { c-&gt;start_embed&lt;SingleSubst&gt; ()-&gt;serialize (c, glyphs, substitutes); }</span>
 292 
 293 struct Sequence
 294 {
<a name="37" id="anc37"></a><span class="line-modified"> 295   void closure (hb_closure_context_t *c) const</span>
 296   {
<a name="38" id="anc38"></a>
 297     unsigned int count = substitute.len;
 298     for (unsigned int i = 0; i &lt; count; i++)
<a name="39" id="anc39"></a><span class="line-modified"> 299       c-&gt;out-&gt;add (substitute[i]);</span>
 300   }
 301 
<a name="40" id="anc40"></a><span class="line-modified"> 302   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-modified"> 303   { c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len); }</span>



 304 
<a name="41" id="anc41"></a><span class="line-modified"> 305   bool apply (hb_ot_apply_context_t *c) const</span>
 306   {
 307     TRACE_APPLY (this);
 308     unsigned int count = substitute.len;
 309 
 310     /* Special-case to make it in-place and not consider this
 311      * as a &quot;multiplied&quot; substitution. */
 312     if (unlikely (count == 1))
 313     {
 314       c-&gt;replace_glyph (substitute.arrayZ[0]);
 315       return_trace (true);
 316     }
 317     /* Spec disallows this, but Uniscribe allows it.
 318      * https://github.com/harfbuzz/harfbuzz/issues/253 */
 319     else if (unlikely (count == 0))
 320     {
 321       c-&gt;buffer-&gt;delete_glyph ();
 322       return_trace (true);
 323     }
 324 
 325     unsigned int klass = _hb_glyph_info_is_ligature (&amp;c-&gt;buffer-&gt;cur()) ?
 326                          HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;
 327 
 328     for (unsigned int i = 0; i &lt; count; i++) {
 329       _hb_glyph_info_set_lig_props_for_component (&amp;c-&gt;buffer-&gt;cur(), i);
 330       c-&gt;output_glyph_for_component (substitute.arrayZ[i], klass);
 331     }
 332     c-&gt;buffer-&gt;skip_glyph ();
 333 
 334     return_trace (true);
 335   }
 336 
<a name="42" id="anc42"></a><span class="line-modified"> 337   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 338                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>

 339   {
 340     TRACE_SERIALIZE (this);
<a name="43" id="anc43"></a><span class="line-modified"> 341     return_trace (substitute.serialize (c, glyphs));</span>


 342   }
 343 
<a name="44" id="anc44"></a><span class="line-modified"> 344   bool sanitize (hb_sanitize_context_t *c) const</span>
 345   {
 346     TRACE_SANITIZE (this);
 347     return_trace (substitute.sanitize (c));
 348   }
 349 
 350   protected:
 351   ArrayOf&lt;GlyphID&gt;
 352                 substitute;             /* String of GlyphIDs to substitute */
 353   public:
 354   DEFINE_SIZE_ARRAY (2, substitute);
 355 };
 356 
 357 struct MultipleSubstFormat1
 358 {
<a name="45" id="anc45"></a><span class="line-modified"> 359   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 360   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362   void closure (hb_closure_context_t *c) const</span>
 363   {
<a name="46" id="anc46"></a>

 364     unsigned int count = sequence.len;
<a name="47" id="anc47"></a><span class="line-modified"> 365     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 366     {
 367       if (unlikely (iter.get_coverage () &gt;= count))
 368         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 369       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 370         (this+sequence[iter.get_coverage ()]).closure (c);
 371     }
 372   }
 373 
<a name="48" id="anc48"></a><span class="line-modified"> 374   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 375   {
<a name="49" id="anc49"></a>
 376     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
 377     unsigned int count = sequence.len;
 378     for (unsigned int i = 0; i &lt; count; i++)
<a name="50" id="anc50"></a><span class="line-modified"> 379       (this+sequence[i]).collect_glyphs (c);</span>
 380   }
 381 
<a name="51" id="anc51"></a><span class="line-modified"> 382   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 383 
<a name="52" id="anc52"></a><span class="line-modified"> 384   bool would_apply (hb_would_apply_context_t *c) const</span>
 385   {
 386     TRACE_WOULD_APPLY (this);
 387     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 388   }
 389 
<a name="53" id="anc53"></a><span class="line-modified"> 390   bool apply (hb_ot_apply_context_t *c) const</span>
 391   {
 392     TRACE_APPLY (this);
 393 
 394     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
 395     if (likely (index == NOT_COVERED)) return_trace (false);
 396 
 397     return_trace ((this+sequence[index]).apply (c));
 398   }
 399 
<a name="54" id="anc54"></a><span class="line-modified"> 400   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 401                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 402                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified"> 403                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

 404   {
 405     TRACE_SERIALIZE (this);
 406     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="55" id="anc55"></a><span class="line-modified"> 407     if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 408     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 409     {</span>
<span class="line-modified"> 410       unsigned int substitute_len = substitute_len_list[i];</span>
<span class="line-modified"> 411       if (unlikely (!sequence[i].serialize (c, this)</span>
<span class="line-modified"> 412                                 .serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))</span>
<span class="line-modified"> 413         return_trace (false);</span>
<span class="line-modified"> 414       substitute_glyphs_list += substitute_len;</span>
<span class="line-added"> 415     }</span>
<span class="line-added"> 416     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
 417   }
 418 
<a name="56" id="anc56"></a><span class="line-modified"> 419   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 420   {</span>
<span class="line-added"> 421     TRACE_SUBSET (this);</span>
<span class="line-added"> 422     // TODO(subset)</span>
<span class="line-added"> 423     return_trace (false);</span>
<span class="line-added"> 424   }</span>
<span class="line-added"> 425 </span>
<span class="line-added"> 426   bool sanitize (hb_sanitize_context_t *c) const</span>
 427   {
 428     TRACE_SANITIZE (this);
 429     return_trace (coverage.sanitize (c, this) &amp;&amp; sequence.sanitize (c, this));
 430   }
 431 
 432   protected:
 433   HBUINT16      format;                 /* Format identifier--format = 1 */
 434   OffsetTo&lt;Coverage&gt;
 435                 coverage;               /* Offset to Coverage table--from
 436                                          * beginning of Substitution table */
 437   OffsetArrayOf&lt;Sequence&gt;
 438                 sequence;               /* Array of Sequence tables
 439                                          * ordered by Coverage Index */
 440   public:
 441   DEFINE_SIZE_ARRAY (6, sequence);
 442 };
 443 
 444 struct MultipleSubst
 445 {
<a name="57" id="anc57"></a><span class="line-modified"> 446   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 447                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 448                   hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified"> 449                   hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

 450   {
 451     TRACE_SERIALIZE (this);
 452     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 453     unsigned int format = 1;
 454     u.format.set (format);
 455     switch (u.format) {
<a name="58" id="anc58"></a><span class="line-modified"> 456     case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));</span>
 457     default:return_trace (false);
 458     }
 459   }
 460 
 461   template &lt;typename context_t&gt;
<a name="59" id="anc59"></a><span class="line-modified"> 462   typename context_t::return_t dispatch (context_t *c) const</span>
 463   {
 464     TRACE_DISPATCH (this, u.format);
 465     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 466     switch (u.format) {
 467     case 1: return_trace (c-&gt;dispatch (u.format1));
 468     default:return_trace (c-&gt;default_return_value ());
 469     }
 470   }
 471 
 472   protected:
 473   union {
 474   HBUINT16              format;         /* Format identifier */
 475   MultipleSubstFormat1  format1;
 476   } u;
 477 };
 478 
<a name="60" id="anc60"></a><span class="line-added"> 479 struct AlternateSet</span>
<span class="line-added"> 480 {</span>
<span class="line-added"> 481   void closure (hb_closure_context_t *c) const</span>
<span class="line-added"> 482   {</span>
<span class="line-added"> 483     unsigned int count = alternates.len;</span>
<span class="line-added"> 484     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added"> 485       c-&gt;out-&gt;add (alternates[i]);</span>
<span class="line-added"> 486   }</span>
<span class="line-added"> 487 </span>
<span class="line-added"> 488   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
<span class="line-added"> 489   { c-&gt;output-&gt;add_array (alternates.arrayZ, alternates.len); }</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491   bool apply (hb_ot_apply_context_t *c) const</span>
<span class="line-added"> 492   {</span>
<span class="line-added"> 493     TRACE_APPLY (this);</span>
<span class="line-added"> 494     unsigned int count = alternates.len;</span>
 495 
<a name="61" id="anc61"></a><span class="line-modified"> 496     if (unlikely (!count)) return_trace (false);</span>
<span class="line-added"> 497 </span>
<span class="line-added"> 498     hb_mask_t glyph_mask = c-&gt;buffer-&gt;cur().mask;</span>
<span class="line-added"> 499     hb_mask_t lookup_mask = c-&gt;lookup_mask;</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501     /* Note: This breaks badly if two features enabled this lookup together. */</span>
<span class="line-added"> 502     unsigned int shift = hb_ctz (lookup_mask);</span>
<span class="line-added"> 503     unsigned int alt_index = ((lookup_mask &amp; glyph_mask) &gt;&gt; shift);</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505     /* If alt_index is MAX, randomize feature if it is the rand feature. */</span>
<span class="line-added"> 506     if (alt_index == HB_OT_MAP_MAX_VALUE &amp;&amp; c-&gt;random)</span>
<span class="line-added"> 507       alt_index = c-&gt;random_number () % count + 1;</span>
<span class="line-added"> 508 </span>
<span class="line-added"> 509     if (unlikely (alt_index &gt; count || alt_index == 0)) return_trace (false);</span>
<span class="line-added"> 510 </span>
<span class="line-added"> 511     c-&gt;replace_glyph (alternates[alt_index - 1]);</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513     return_trace (true);</span>
<span class="line-added"> 514   }</span>
<span class="line-added"> 515 </span>
<span class="line-added"> 516   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-added"> 517                   hb_array_t&lt;const GlyphID&gt; glyphs)</span>
<span class="line-added"> 518   {</span>
<span class="line-added"> 519     TRACE_SERIALIZE (this);</span>
<span class="line-added"> 520     return_trace (alternates.serialize (c, glyphs));</span>
<span class="line-added"> 521   }</span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added"> 524   {</span>
<span class="line-added"> 525     TRACE_SANITIZE (this);</span>
<span class="line-added"> 526     return_trace (alternates.sanitize (c));</span>
<span class="line-added"> 527   }</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529   protected:</span>
<span class="line-added"> 530   ArrayOf&lt;GlyphID&gt;</span>
<span class="line-added"> 531                 alternates;             /* Array of alternate GlyphIDs--in</span>
 532                                          * arbitrary order */
<a name="62" id="anc62"></a><span class="line-added"> 533   public:</span>
<span class="line-added"> 534   DEFINE_SIZE_ARRAY (2, alternates);</span>
<span class="line-added"> 535 };</span>
 536 
 537 struct AlternateSubstFormat1
 538 {
<a name="63" id="anc63"></a><span class="line-modified"> 539   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 540   { return (this+coverage).intersects (glyphs); }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542   void closure (hb_closure_context_t *c) const</span>
 543   {
<a name="64" id="anc64"></a>

 544     unsigned int count = alternateSet.len;
<a name="65" id="anc65"></a><span class="line-modified"> 545     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 546     {
 547       if (unlikely (iter.get_coverage () &gt;= count))
 548         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<a name="66" id="anc66"></a><span class="line-modified"> 549       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))</span>
<span class="line-modified"> 550         (this+alternateSet[iter.get_coverage ()]).closure (c);</span>




 551     }
 552   }
 553 
<a name="67" id="anc67"></a><span class="line-modified"> 554   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 555   {
<a name="68" id="anc68"></a>
 556     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="69" id="anc69"></a>
 557     unsigned int count = alternateSet.len;
<a name="70" id="anc70"></a><span class="line-modified"> 558     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 559     {
 560       if (unlikely (iter.get_coverage () &gt;= count))
 561         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
<a name="71" id="anc71"></a><span class="line-modified"> 562       (this+alternateSet[iter.get_coverage ()]).collect_glyphs (c);</span>

 563     }
 564   }
 565 
<a name="72" id="anc72"></a><span class="line-modified"> 566   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 567 
<a name="73" id="anc73"></a><span class="line-modified"> 568   bool would_apply (hb_would_apply_context_t *c) const</span>
 569   {
 570     TRACE_WOULD_APPLY (this);
 571     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
 572   }
 573 
<a name="74" id="anc74"></a><span class="line-modified"> 574   bool apply (hb_ot_apply_context_t *c) const</span>
 575   {
 576     TRACE_APPLY (this);
<a name="75" id="anc75"></a>
 577 
<a name="76" id="anc76"></a><span class="line-modified"> 578     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
 579     if (likely (index == NOT_COVERED)) return_trace (false);
 580 
<a name="77" id="anc77"></a><span class="line-modified"> 581     return_trace ((this+alternateSet[index]).apply (c));</span>

















 582   }
 583 
<a name="78" id="anc78"></a><span class="line-modified"> 584   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 585                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 586                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified"> 587                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

 588   {
 589     TRACE_SERIALIZE (this);
 590     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="79" id="anc79"></a><span class="line-modified"> 591     if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 592     for (unsigned int i = 0; i &lt; glyphs.length; i++)</span>
<span class="line-modified"> 593     {</span>
<span class="line-modified"> 594       unsigned int alternate_len = alternate_len_list[i];</span>
<span class="line-modified"> 595       if (unlikely (!alternateSet[i].serialize (c, this)</span>
<span class="line-modified"> 596                                     .serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))</span>
<span class="line-modified"> 597         return_trace (false);</span>
<span class="line-modified"> 598       alternate_glyphs_list += alternate_len;</span>
<span class="line-added"> 599     }</span>
<span class="line-added"> 600     return_trace (coverage.serialize (c, this).serialize (c, glyphs));</span>
<span class="line-added"> 601   }</span>
<span class="line-added"> 602 </span>
<span class="line-added"> 603   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 604   {</span>
<span class="line-added"> 605     TRACE_SUBSET (this);</span>
<span class="line-added"> 606     // TODO(subset)</span>
<span class="line-added"> 607     return_trace (false);</span>
 608   }
 609 
<a name="80" id="anc80"></a><span class="line-modified"> 610   bool sanitize (hb_sanitize_context_t *c) const</span>
 611   {
 612     TRACE_SANITIZE (this);
 613     return_trace (coverage.sanitize (c, this) &amp;&amp; alternateSet.sanitize (c, this));
 614   }
 615 
 616   protected:
 617   HBUINT16      format;                 /* Format identifier--format = 1 */
 618   OffsetTo&lt;Coverage&gt;
 619                 coverage;               /* Offset to Coverage table--from
 620                                          * beginning of Substitution table */
 621   OffsetArrayOf&lt;AlternateSet&gt;
 622                 alternateSet;           /* Array of AlternateSet tables
 623                                          * ordered by Coverage Index */
 624   public:
 625   DEFINE_SIZE_ARRAY (6, alternateSet);
 626 };
 627 
 628 struct AlternateSubst
 629 {
<a name="81" id="anc81"></a><span class="line-modified"> 630   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 631                   hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified"> 632                   hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified"> 633                   hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

 634   {
 635     TRACE_SERIALIZE (this);
 636     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 637     unsigned int format = 1;
 638     u.format.set (format);
 639     switch (u.format) {
<a name="82" id="anc82"></a><span class="line-modified"> 640     case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));</span>
 641     default:return_trace (false);
 642     }
 643   }
 644 
 645   template &lt;typename context_t&gt;
<a name="83" id="anc83"></a><span class="line-modified"> 646   typename context_t::return_t dispatch (context_t *c) const</span>
 647   {
 648     TRACE_DISPATCH (this, u.format);
 649     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 650     switch (u.format) {
 651     case 1: return_trace (c-&gt;dispatch (u.format1));
 652     default:return_trace (c-&gt;default_return_value ());
 653     }
 654   }
 655 
 656   protected:
 657   union {
 658   HBUINT16              format;         /* Format identifier */
 659   AlternateSubstFormat1 format1;
 660   } u;
 661 };
 662 
 663 
 664 struct Ligature
 665 {
<a name="84" id="anc84"></a><span class="line-modified"> 666   bool intersects (const hb_set_t *glyphs) const</span>
 667   {
<a name="85" id="anc85"></a><span class="line-modified"> 668     unsigned int count = component.lenP1;</span>
<span class="line-modified"> 669     for (unsigned int i = 1; i &lt; count; i++)</span>
<span class="line-added"> 670       if (!glyphs-&gt;has (component[i]))</span>
<span class="line-added"> 671         return false;</span>
<span class="line-added"> 672     return true;</span>
<span class="line-added"> 673   }</span>
<span class="line-added"> 674 </span>
<span class="line-added"> 675   void closure (hb_closure_context_t *c) const</span>
<span class="line-added"> 676   {</span>
<span class="line-added"> 677     unsigned int count = component.lenP1;</span>
 678     for (unsigned int i = 1; i &lt; count; i++)
 679       if (!c-&gt;glyphs-&gt;has (component[i]))
 680         return;
<a name="86" id="anc86"></a><span class="line-modified"> 681     c-&gt;out-&gt;add (ligGlyph);</span>
 682   }
 683 
<a name="87" id="anc87"></a><span class="line-modified"> 684   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 685   {
<a name="88" id="anc88"></a><span class="line-modified"> 686     c-&gt;input-&gt;add_array (component.arrayZ, component.lenP1 ? component.lenP1 - 1 : 0);</span>

 687     c-&gt;output-&gt;add (ligGlyph);
 688   }
 689 
<a name="89" id="anc89"></a><span class="line-modified"> 690   bool would_apply (hb_would_apply_context_t *c) const</span>
 691   {
 692     TRACE_WOULD_APPLY (this);
<a name="90" id="anc90"></a><span class="line-modified"> 693     if (c-&gt;len != component.lenP1)</span>
 694       return_trace (false);
 695 
 696     for (unsigned int i = 1; i &lt; c-&gt;len; i++)
 697       if (likely (c-&gt;glyphs[i] != component[i]))
 698         return_trace (false);
 699 
 700     return_trace (true);
 701   }
 702 
<a name="91" id="anc91"></a><span class="line-modified"> 703   bool apply (hb_ot_apply_context_t *c) const</span>
 704   {
 705     TRACE_APPLY (this);
<a name="92" id="anc92"></a><span class="line-modified"> 706     unsigned int count = component.lenP1;</span>
 707 
 708     if (unlikely (!count)) return_trace (false);
 709 
 710     /* Special-case to make it in-place and not consider this
 711      * as a &quot;ligated&quot; substitution. */
 712     if (unlikely (count == 1))
 713     {
 714       c-&gt;replace_glyph (ligGlyph);
 715       return_trace (true);
 716     }
 717 
<a name="93" id="anc93"></a>
 718     unsigned int total_component_count = 0;
 719 
 720     unsigned int match_length = 0;
 721     unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];
 722 
 723     if (likely (!match_input (c, count,
 724                               &amp;component[1],
 725                               match_glyph,
 726                               nullptr,
 727                               &amp;match_length,
 728                               match_positions,
<a name="94" id="anc94"></a>
 729                               &amp;total_component_count)))
 730       return_trace (false);
 731 
 732     ligate_input (c,
 733                   count,
 734                   match_positions,
 735                   match_length,
 736                   ligGlyph,
<a name="95" id="anc95"></a>
 737                   total_component_count);
 738 
 739     return_trace (true);
 740   }
 741 
<a name="96" id="anc96"></a><span class="line-modified"> 742   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 743                   GlyphID ligature,</span>
<span class="line-modified"> 744                   hb_array_t&lt;const GlyphID&gt; components /* Starting from second */)</span>

 745   {
 746     TRACE_SERIALIZE (this);
 747     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
 748     ligGlyph = ligature;
<a name="97" id="anc97"></a><span class="line-modified"> 749     if (unlikely (!component.serialize (c, components))) return_trace (false);</span>
 750     return_trace (true);
 751   }
 752 
 753   public:
<a name="98" id="anc98"></a><span class="line-modified"> 754   bool sanitize (hb_sanitize_context_t *c) const</span>
 755   {
 756     TRACE_SANITIZE (this);
 757     return_trace (ligGlyph.sanitize (c) &amp;&amp; component.sanitize (c));
 758   }
 759 
 760   protected:
 761   GlyphID       ligGlyph;               /* GlyphID of ligature to substitute */
 762   HeadlessArrayOf&lt;GlyphID&gt;
 763                 component;              /* Array of component GlyphIDs--start
 764                                          * with the second  component--ordered
 765                                          * in writing direction */
 766   public:
 767   DEFINE_SIZE_ARRAY (4, component);
 768 };
 769 
 770 struct LigatureSet
 771 {
<a name="99" id="anc99"></a><span class="line-modified"> 772   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 773   {</span>
<span class="line-added"> 774     unsigned int num_ligs = ligature.len;</span>
<span class="line-added"> 775     for (unsigned int i = 0; i &lt; num_ligs; i++)</span>
<span class="line-added"> 776       if ((this+ligature[i]).intersects (glyphs))</span>
<span class="line-added"> 777         return true;</span>
<span class="line-added"> 778     return false;</span>
<span class="line-added"> 779   }</span>
<span class="line-added"> 780 </span>
<span class="line-added"> 781   void closure (hb_closure_context_t *c) const</span>
 782   {
<a name="100" id="anc100"></a>
 783     unsigned int num_ligs = ligature.len;
 784     for (unsigned int i = 0; i &lt; num_ligs; i++)
 785       (this+ligature[i]).closure (c);
 786   }
 787 
<a name="101" id="anc101"></a><span class="line-modified"> 788   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 789   {
<a name="102" id="anc102"></a>
 790     unsigned int num_ligs = ligature.len;
 791     for (unsigned int i = 0; i &lt; num_ligs; i++)
 792       (this+ligature[i]).collect_glyphs (c);
 793   }
 794 
<a name="103" id="anc103"></a><span class="line-modified"> 795   bool would_apply (hb_would_apply_context_t *c) const</span>
 796   {
 797     TRACE_WOULD_APPLY (this);
 798     unsigned int num_ligs = ligature.len;
 799     for (unsigned int i = 0; i &lt; num_ligs; i++)
 800     {
 801       const Ligature &amp;lig = this+ligature[i];
 802       if (lig.would_apply (c))
 803         return_trace (true);
 804     }
 805     return_trace (false);
 806   }
 807 
<a name="104" id="anc104"></a><span class="line-modified"> 808   bool apply (hb_ot_apply_context_t *c) const</span>
 809   {
 810     TRACE_APPLY (this);
 811     unsigned int num_ligs = ligature.len;
 812     for (unsigned int i = 0; i &lt; num_ligs; i++)
 813     {
 814       const Ligature &amp;lig = this+ligature[i];
 815       if (lig.apply (c)) return_trace (true);
 816     }
 817 
 818     return_trace (false);
 819   }
 820 
<a name="105" id="anc105"></a><span class="line-modified"> 821   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 822                   hb_array_t&lt;const GlyphID&gt; ligatures,</span>
<span class="line-modified"> 823                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 824                   hb_array_t&lt;const GlyphID&gt; &amp;component_list /* Starting from second for each ligature */)</span>

 825   {
 826     TRACE_SERIALIZE (this);
 827     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="106" id="anc106"></a><span class="line-modified"> 828     if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);</span>
<span class="line-modified"> 829     for (unsigned int i = 0; i &lt; ligatures.length; i++)</span>
<span class="line-modified"> 830     {</span>
<span class="line-modified"> 831       unsigned int component_count = MAX&lt;int&gt; (component_count_list[i] - 1, 0);</span>
<span class="line-modified"> 832       if (unlikely (!ligature[i].serialize (c, this)</span>
<span class="line-modified"> 833                                 .serialize (c,</span>
<span class="line-modified"> 834                                             ligatures[i],</span>
<span class="line-modified"> 835                                             component_list.sub_array (0, component_count))))</span>
<span class="line-added"> 836         return_trace (false);</span>
<span class="line-added"> 837       component_list += component_count;</span>
<span class="line-added"> 838     }</span>
 839     return_trace (true);
 840   }
 841 
<a name="107" id="anc107"></a><span class="line-modified"> 842   bool sanitize (hb_sanitize_context_t *c) const</span>
 843   {
 844     TRACE_SANITIZE (this);
 845     return_trace (ligature.sanitize (c, this));
 846   }
 847 
 848   protected:
 849   OffsetArrayOf&lt;Ligature&gt;
 850                 ligature;               /* Array LigatureSet tables
 851                                          * ordered by preference */
 852   public:
 853   DEFINE_SIZE_ARRAY (2, ligature);
 854 };
 855 
 856 struct LigatureSubstFormat1
 857 {
<a name="108" id="anc108"></a><span class="line-modified"> 858   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added"> 859   {</span>
<span class="line-added"> 860     unsigned int count = ligatureSet.len;</span>
<span class="line-added"> 861     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
<span class="line-added"> 862     {</span>
<span class="line-added"> 863       if (unlikely (iter.get_coverage () &gt;= count))</span>
<span class="line-added"> 864         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */</span>
<span class="line-added"> 865       if (glyphs-&gt;has (iter.get_glyph ()) &amp;&amp;</span>
<span class="line-added"> 866           (this+ligatureSet[iter.get_coverage ()]).intersects (glyphs))</span>
<span class="line-added"> 867         return true;</span>
<span class="line-added"> 868     }</span>
<span class="line-added"> 869     return false;</span>
<span class="line-added"> 870   }</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872   void closure (hb_closure_context_t *c) const</span>
 873   {
<a name="109" id="anc109"></a>

 874     unsigned int count = ligatureSet.len;
<a name="110" id="anc110"></a><span class="line-modified"> 875     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 876     {
 877       if (unlikely (iter.get_coverage () &gt;= count))
 878         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 879       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
 880         (this+ligatureSet[iter.get_coverage ()]).closure (c);
 881     }
 882   }
 883 
<a name="111" id="anc111"></a><span class="line-modified"> 884   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
 885   {
<a name="112" id="anc112"></a>
 886     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
<a name="113" id="anc113"></a>
 887     unsigned int count = ligatureSet.len;
<a name="114" id="anc114"></a><span class="line-modified"> 888     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
 889     {
 890       if (unlikely (iter.get_coverage () &gt;= count))
 891         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
 892       (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);
 893     }
 894   }
 895 
<a name="115" id="anc115"></a><span class="line-modified"> 896   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



 897 
<a name="116" id="anc116"></a><span class="line-modified"> 898   bool would_apply (hb_would_apply_context_t *c) const</span>
 899   {
 900     TRACE_WOULD_APPLY (this);
 901     unsigned int index = (this+coverage).get_coverage (c-&gt;glyphs[0]);
 902     if (likely (index == NOT_COVERED)) return_trace (false);
 903 
 904     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 905     return_trace (lig_set.would_apply (c));
 906   }
 907 
<a name="117" id="anc117"></a><span class="line-modified"> 908   bool apply (hb_ot_apply_context_t *c) const</span>
 909   {
 910     TRACE_APPLY (this);
<a name="118" id="anc118"></a>
 911 
<a name="119" id="anc119"></a><span class="line-modified"> 912     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);</span>
 913     if (likely (index == NOT_COVERED)) return_trace (false);
 914 
 915     const LigatureSet &amp;lig_set = this+ligatureSet[index];
 916     return_trace (lig_set.apply (c));
 917   }
 918 
<a name="120" id="anc120"></a><span class="line-modified"> 919   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 920                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified"> 921                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 922                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified"> 923                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 924                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

 925   {
 926     TRACE_SERIALIZE (this);
 927     if (unlikely (!c-&gt;extend_min (*this))) return_trace (false);
<a name="121" id="anc121"></a><span class="line-modified"> 928     if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);</span>
<span class="line-modified"> 929     for (unsigned int i = 0; i &lt; first_glyphs.length; i++)</span>
<span class="line-modified"> 930     {</span>
<span class="line-modified"> 931       unsigned int ligature_count = ligature_per_first_glyph_count_list[i];</span>
<span class="line-modified"> 932       if (unlikely (!ligatureSet[i].serialize (c, this)</span>
<span class="line-modified"> 933                                    .serialize (c,</span>
<span class="line-modified"> 934                                                ligatures_list.sub_array (0, ligature_count),</span>
<span class="line-modified"> 935                                                component_count_list.sub_array (0, ligature_count),</span>
<span class="line-modified"> 936                                                component_list))) return_trace (false);</span>
<span class="line-modified"> 937       ligatures_list += ligature_count;</span>
<span class="line-added"> 938       component_count_list += ligature_count;</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940     return_trace (coverage.serialize (c, this).serialize (c, first_glyphs));</span>
<span class="line-added"> 941   }</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added"> 944   {</span>
<span class="line-added"> 945     TRACE_SUBSET (this);</span>
<span class="line-added"> 946     // TODO(subset)</span>
<span class="line-added"> 947     return_trace (false);</span>
 948   }
 949 
<a name="122" id="anc122"></a><span class="line-modified"> 950   bool sanitize (hb_sanitize_context_t *c) const</span>
 951   {
 952     TRACE_SANITIZE (this);
 953     return_trace (coverage.sanitize (c, this) &amp;&amp; ligatureSet.sanitize (c, this));
 954   }
 955 
 956   protected:
 957   HBUINT16      format;                 /* Format identifier--format = 1 */
 958   OffsetTo&lt;Coverage&gt;
 959                 coverage;               /* Offset to Coverage table--from
 960                                          * beginning of Substitution table */
 961   OffsetArrayOf&lt;LigatureSet&gt;
 962                 ligatureSet;            /* Array LigatureSet tables
 963                                          * ordered by Coverage Index */
 964   public:
 965   DEFINE_SIZE_ARRAY (6, ligatureSet);
 966 };
 967 
 968 struct LigatureSubst
 969 {
<a name="123" id="anc123"></a><span class="line-modified"> 970   bool serialize (hb_serialize_context_t *c,</span>
<span class="line-modified"> 971                   hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified"> 972                   hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified"> 973                   hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified"> 974                   hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified"> 975                   hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

 976   {
 977     TRACE_SERIALIZE (this);
 978     if (unlikely (!c-&gt;extend_min (u.format))) return_trace (false);
 979     unsigned int format = 1;
 980     u.format.set (format);
 981     switch (u.format) {
 982     case 1: return_trace (u.format1.serialize (c,
 983                                                first_glyphs,
 984                                                ligature_per_first_glyph_count_list,
<a name="124" id="anc124"></a>
 985                                                ligatures_list,
 986                                                component_count_list,
 987                                                component_list));
 988     default:return_trace (false);
 989     }
 990   }
 991 
 992   template &lt;typename context_t&gt;
<a name="125" id="anc125"></a><span class="line-modified"> 993   typename context_t::return_t dispatch (context_t *c) const</span>
 994   {
 995     TRACE_DISPATCH (this, u.format);
 996     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
 997     switch (u.format) {
 998     case 1: return_trace (c-&gt;dispatch (u.format1));
 999     default:return_trace (c-&gt;default_return_value ());
1000     }
1001   }
1002 
1003   protected:
1004   union {
1005   HBUINT16              format;         /* Format identifier */
1006   LigatureSubstFormat1  format1;
1007   } u;
1008 };
1009 
1010 
1011 struct ContextSubst : Context {};
1012 
1013 struct ChainContextSubst : ChainContext {};
1014 
1015 struct ExtensionSubst : Extension&lt;ExtensionSubst&gt;
1016 {
<a name="126" id="anc126"></a><span class="line-modified">1017   typedef struct SubstLookupSubTable SubTable;</span>
1018 
<a name="127" id="anc127"></a><span class="line-modified">1019   bool is_reverse () const;</span>
1020 };
1021 
1022 
1023 struct ReverseChainSingleSubstFormat1
1024 {
<a name="128" id="anc128"></a><span class="line-modified">1025   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1026   {</span>
<span class="line-added">1027     if (!(this+coverage).intersects (glyphs))</span>
<span class="line-added">1028       return false;</span>
<span class="line-added">1029 </span>
<span class="line-added">1030     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);</span>
<span class="line-added">1031 </span>
<span class="line-added">1032     unsigned int count;</span>
<span class="line-added">1033 </span>
<span class="line-added">1034     count = backtrack.len;</span>
<span class="line-added">1035     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1036       if (!(this+backtrack[i]).intersects (glyphs))</span>
<span class="line-added">1037         return false;</span>
<span class="line-added">1038 </span>
<span class="line-added">1039     count = lookahead.len;</span>
<span class="line-added">1040     for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="line-added">1041       if (!(this+lookahead[i]).intersects (glyphs))</span>
<span class="line-added">1042         return false;</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     return true;</span>
<span class="line-added">1045   }</span>
<span class="line-added">1046 </span>
<span class="line-added">1047   void closure (hb_closure_context_t *c) const</span>
1048   {
<a name="129" id="anc129"></a>
1049     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1050 
1051     unsigned int count;
1052 
1053     count = backtrack.len;
1054     for (unsigned int i = 0; i &lt; count; i++)
1055       if (!(this+backtrack[i]).intersects (c-&gt;glyphs))
1056         return;
1057 
1058     count = lookahead.len;
1059     for (unsigned int i = 0; i &lt; count; i++)
1060       if (!(this+lookahead[i]).intersects (c-&gt;glyphs))
1061         return;
1062 
1063     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
<a name="130" id="anc130"></a>
1064     count = substitute.len;
<a name="131" id="anc131"></a><span class="line-modified">1065     for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())</span>
1066     {
1067       if (unlikely (iter.get_coverage () &gt;= count))
1068         break; /* Work around malicious fonts. https://github.com/harfbuzz/harfbuzz/issues/363 */
1069       if (c-&gt;glyphs-&gt;has (iter.get_glyph ()))
<a name="132" id="anc132"></a><span class="line-modified">1070         c-&gt;out-&gt;add (substitute[iter.get_coverage ()]);</span>
1071     }
1072   }
1073 
<a name="133" id="anc133"></a><span class="line-modified">1074   void collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1075   {
<a name="134" id="anc134"></a>
1076     if (unlikely (!(this+coverage).add_coverage (c-&gt;input))) return;
1077 
1078     unsigned int count;
1079 
1080     count = backtrack.len;
1081     for (unsigned int i = 0; i &lt; count; i++)
1082       if (unlikely (!(this+backtrack[i]).add_coverage (c-&gt;before))) return;
1083 
1084     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1085     count = lookahead.len;
1086     for (unsigned int i = 0; i &lt; count; i++)
1087       if (unlikely (!(this+lookahead[i]).add_coverage (c-&gt;after))) return;
1088 
1089     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1090     count = substitute.len;
1091     c-&gt;output-&gt;add_array (substitute.arrayZ, substitute.len);
1092   }
1093 
<a name="135" id="anc135"></a><span class="line-modified">1094   const Coverage &amp;get_coverage () const { return this+coverage; }</span>



1095 
<a name="136" id="anc136"></a><span class="line-modified">1096   bool would_apply (hb_would_apply_context_t *c) const</span>
1097   {
1098     TRACE_WOULD_APPLY (this);
1099     return_trace (c-&gt;len == 1 &amp;&amp; (this+coverage).get_coverage (c-&gt;glyphs[0]) != NOT_COVERED);
1100   }
1101 
<a name="137" id="anc137"></a><span class="line-modified">1102   bool apply (hb_ot_apply_context_t *c) const</span>
1103   {
1104     TRACE_APPLY (this);
1105     if (unlikely (c-&gt;nesting_level_left != HB_MAX_NESTING_LEVEL))
1106       return_trace (false); /* No chaining to this type */
1107 
1108     unsigned int index = (this+coverage).get_coverage (c-&gt;buffer-&gt;cur().codepoint);
1109     if (likely (index == NOT_COVERED)) return_trace (false);
1110 
1111     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1112     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1113 
1114   unsigned int start_index = 0, end_index = 0;
1115     if (match_backtrack (c,
1116                          backtrack.len, (HBUINT16 *) backtrack.arrayZ,
1117                          match_coverage, this,
1118                          &amp;start_index) &amp;&amp;
1119         match_lookahead (c,
1120                          lookahead.len, (HBUINT16 *) lookahead.arrayZ,
1121                          match_coverage, this,
1122                          1, &amp;end_index))
1123     {
1124       c-&gt;buffer-&gt;unsafe_to_break_from_outbuffer (start_index, end_index);
1125       c-&gt;replace_glyph_inplace (substitute[index]);
1126       /* Note: We DON&#39;T decrease buffer-&gt;idx.  The main loop does it
1127        * for us.  This is useful for preventing surprises if someone
1128        * calls us through a Context lookup. */
1129       return_trace (true);
1130     }
1131 
1132     return_trace (false);
1133   }
1134 
<a name="138" id="anc138"></a><span class="line-modified">1135   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1136   {</span>
<span class="line-added">1137     TRACE_SUBSET (this);</span>
<span class="line-added">1138     // TODO(subset)</span>
<span class="line-added">1139     return_trace (false);</span>
<span class="line-added">1140   }</span>
<span class="line-added">1141 </span>
<span class="line-added">1142   bool sanitize (hb_sanitize_context_t *c) const</span>
1143   {
1144     TRACE_SANITIZE (this);
1145     if (!(coverage.sanitize (c, this) &amp;&amp; backtrack.sanitize (c, this)))
1146       return_trace (false);
1147     const OffsetArrayOf&lt;Coverage&gt; &amp;lookahead = StructAfter&lt;OffsetArrayOf&lt;Coverage&gt; &gt; (backtrack);
1148     if (!lookahead.sanitize (c, this))
1149       return_trace (false);
1150     const ArrayOf&lt;GlyphID&gt; &amp;substitute = StructAfter&lt;ArrayOf&lt;GlyphID&gt; &gt; (lookahead);
1151     return_trace (substitute.sanitize (c));
1152   }
1153 
1154   protected:
1155   HBUINT16      format;                 /* Format identifier--format = 1 */
1156   OffsetTo&lt;Coverage&gt;
1157                 coverage;               /* Offset to Coverage table--from
1158                                          * beginning of table */
1159   OffsetArrayOf&lt;Coverage&gt;
1160                 backtrack;              /* Array of coverage tables
<a name="139" id="anc139"></a><span class="line-modified">1161                                          * in backtracking sequence, in glyph</span>
1162                                          * sequence order */
1163   OffsetArrayOf&lt;Coverage&gt;
1164                 lookaheadX;             /* Array of coverage tables
1165                                          * in lookahead sequence, in glyph
1166                                          * sequence order */
1167   ArrayOf&lt;GlyphID&gt;
1168                 substituteX;            /* Array of substitute
1169                                          * GlyphIDs--ordered by Coverage Index */
1170   public:
1171   DEFINE_SIZE_MIN (10);
1172 };
1173 
1174 struct ReverseChainSingleSubst
1175 {
1176   template &lt;typename context_t&gt;
<a name="140" id="anc140"></a><span class="line-modified">1177   typename context_t::return_t dispatch (context_t *c) const</span>
1178   {
1179     TRACE_DISPATCH (this, u.format);
1180     if (unlikely (!c-&gt;may_dispatch (this, &amp;u.format))) return_trace (c-&gt;no_dispatch_return_value ());
1181     switch (u.format) {
1182     case 1: return_trace (c-&gt;dispatch (u.format1));
1183     default:return_trace (c-&gt;default_return_value ());
1184     }
1185   }
1186 
1187   protected:
1188   union {
1189   HBUINT16                              format;         /* Format identifier */
1190   ReverseChainSingleSubstFormat1        format1;
1191   } u;
1192 };
1193 
1194 
1195 
1196 /*
1197  * SubstLookup
1198  */
1199 
1200 struct SubstLookupSubTable
1201 {
<a name="141" id="anc141"></a><span class="line-added">1202   friend struct Lookup;</span>
1203   friend struct SubstLookup;
1204 
1205   enum Type {
1206     Single              = 1,
1207     Multiple            = 2,
1208     Alternate           = 3,
1209     Ligature            = 4,
1210     Context             = 5,
1211     ChainContext        = 6,
1212     Extension           = 7,
1213     ReverseChainSingle  = 8
1214   };
1215 
1216   template &lt;typename context_t&gt;
<a name="142" id="anc142"></a><span class="line-modified">1217   typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const</span>
1218   {
1219     TRACE_DISPATCH (this, lookup_type);
<a name="143" id="anc143"></a>
1220     switch (lookup_type) {
1221     case Single:                return_trace (u.single.dispatch (c));
1222     case Multiple:              return_trace (u.multiple.dispatch (c));
1223     case Alternate:             return_trace (u.alternate.dispatch (c));
1224     case Ligature:              return_trace (u.ligature.dispatch (c));
1225     case Context:               return_trace (u.context.dispatch (c));
1226     case ChainContext:          return_trace (u.chainContext.dispatch (c));
1227     case Extension:             return_trace (u.extension.dispatch (c));
1228     case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c));
1229     default:                    return_trace (c-&gt;default_return_value ());
1230     }
1231   }
1232 
1233   protected:
1234   union {
<a name="144" id="anc144"></a>
1235   SingleSubst                   single;
1236   MultipleSubst                 multiple;
1237   AlternateSubst                alternate;
1238   LigatureSubst                 ligature;
1239   ContextSubst                  context;
1240   ChainContextSubst             chainContext;
1241   ExtensionSubst                extension;
1242   ReverseChainSingleSubst       reverseChainContextSingle;
1243   } u;
1244   public:
<a name="145" id="anc145"></a><span class="line-modified">1245   DEFINE_SIZE_MIN (0);</span>
1246 };
1247 
1248 
1249 struct SubstLookup : Lookup
1250 {
<a name="146" id="anc146"></a><span class="line-modified">1251   typedef SubstLookupSubTable SubTable;</span>

1252 
<a name="147" id="anc147"></a><span class="line-modified">1253   const SubTable&amp; get_subtable (unsigned int i) const</span>
<span class="line-modified">1254   { return Lookup::get_subtable&lt;SubTable&gt; (i); }</span>
1255 
<a name="148" id="anc148"></a><span class="line-modified">1256   static bool lookup_type_is_reverse (unsigned int lookup_type)</span>
<span class="line-added">1257   { return lookup_type == SubTable::ReverseChainSingle; }</span>
<span class="line-added">1258 </span>
<span class="line-added">1259   bool is_reverse () const</span>
1260   {
1261     unsigned int type = get_type ();
<a name="149" id="anc149"></a><span class="line-modified">1262     if (unlikely (type == SubTable::Extension))</span>
1263       return CastR&lt;ExtensionSubst&gt; (get_subtable(0)).is_reverse ();
1264     return lookup_type_is_reverse (type);
1265   }
1266 
<a name="150" id="anc150"></a><span class="line-modified">1267   bool apply (hb_ot_apply_context_t *c) const</span>
1268   {
1269     TRACE_APPLY (this);
1270     return_trace (dispatch (c));
1271   }
1272 
<a name="151" id="anc151"></a><span class="line-modified">1273   bool intersects (const hb_set_t *glyphs) const</span>
<span class="line-added">1274   {</span>
<span class="line-added">1275     hb_intersects_context_t c (glyphs);</span>
<span class="line-added">1276     return dispatch (&amp;c);</span>
<span class="line-added">1277   }</span>
<span class="line-added">1278 </span>
<span class="line-added">1279   hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const</span>
1280   {
<a name="152" id="anc152"></a>
1281     if (!c-&gt;should_visit_lookup (this_index))
<a name="153" id="anc153"></a><span class="line-modified">1282       return hb_closure_context_t::default_return_value ();</span>
1283 
1284     c-&gt;set_recurse_func (dispatch_closure_recurse_func);
<a name="154" id="anc154"></a><span class="line-modified">1285 </span>
<span class="line-added">1286     hb_closure_context_t::return_t ret = dispatch (c);</span>
<span class="line-added">1287 </span>
<span class="line-added">1288     c-&gt;flush ();</span>
<span class="line-added">1289 </span>
<span class="line-added">1290     return ret;</span>
1291   }
1292 
<a name="155" id="anc155"></a><span class="line-modified">1293   hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const</span>
1294   {
<a name="156" id="anc156"></a>
1295     c-&gt;set_recurse_func (dispatch_recurse_func&lt;hb_collect_glyphs_context_t&gt;);
<a name="157" id="anc157"></a><span class="line-modified">1296     return dispatch (c);</span>
1297   }
1298 
1299   template &lt;typename set_t&gt;
<a name="158" id="anc158"></a><span class="line-modified">1300   void add_coverage (set_t *glyphs) const</span>
1301   {
1302     hb_add_coverage_context_t&lt;set_t&gt; c (glyphs);
1303     dispatch (&amp;c);
1304   }
1305 
<a name="159" id="anc159"></a><span class="line-modified">1306   bool would_apply (hb_would_apply_context_t *c,</span>
<span class="line-modified">1307                     const hb_ot_layout_lookup_accelerator_t *accel) const</span>
1308   {
1309     TRACE_WOULD_APPLY (this);
1310     if (unlikely (!c-&gt;len))  return_trace (false);
1311     if (!accel-&gt;may_have (c-&gt;glyphs[0]))  return_trace (false);
1312       return_trace (dispatch (c));
1313   }
1314 
1315   static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);
1316 
<a name="160" id="anc160"></a><span class="line-modified">1317   SubTable&amp; serialize_subtable (hb_serialize_context_t *c,</span>
<span class="line-modified">1318                                        unsigned int i)</span>
<span class="line-modified">1319   { return get_subtables&lt;SubTable&gt; ()[i].serialize (c, this); }</span>
1320 
<a name="161" id="anc161"></a><span class="line-modified">1321   bool serialize_single (hb_serialize_context_t *c,</span>
<span class="line-modified">1322                          uint32_t lookup_props,</span>
<span class="line-modified">1323                          hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1324                          hb_array_t&lt;const GlyphID&gt; substitutes)</span>

1325   {
1326     TRACE_SERIALIZE (this);
<a name="162" id="anc162"></a><span class="line-modified">1327     if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);</span>
<span class="line-modified">1328     return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes));</span>
1329   }
1330 
<a name="163" id="anc163"></a><span class="line-modified">1331   bool serialize_multiple (hb_serialize_context_t *c,</span>
<span class="line-modified">1332                            uint32_t lookup_props,</span>
<span class="line-modified">1333                            hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1334                            hb_array_t&lt;const unsigned int&gt; substitute_len_list,</span>
<span class="line-modified">1335                            hb_array_t&lt;const GlyphID&gt; substitute_glyphs_list)</span>

1336   {
1337     TRACE_SERIALIZE (this);
<a name="164" id="anc164"></a><span class="line-modified">1338     if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);</span>
1339     return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,
1340                                                                   glyphs,
1341                                                                   substitute_len_list,
<a name="165" id="anc165"></a>
1342                                                                   substitute_glyphs_list));
1343   }
1344 
<a name="166" id="anc166"></a><span class="line-modified">1345   bool serialize_alternate (hb_serialize_context_t *c,</span>
<span class="line-modified">1346                             uint32_t lookup_props,</span>
<span class="line-modified">1347                             hb_array_t&lt;const GlyphID&gt; glyphs,</span>
<span class="line-modified">1348                             hb_array_t&lt;const unsigned int&gt; alternate_len_list,</span>
<span class="line-modified">1349                             hb_array_t&lt;const GlyphID&gt; alternate_glyphs_list)</span>

1350   {
1351     TRACE_SERIALIZE (this);
<a name="167" id="anc167"></a><span class="line-modified">1352     if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);</span>
1353     return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,
1354                                                                    glyphs,
1355                                                                    alternate_len_list,
<a name="168" id="anc168"></a>
1356                                                                    alternate_glyphs_list));
1357   }
1358 
<a name="169" id="anc169"></a><span class="line-modified">1359   bool serialize_ligature (hb_serialize_context_t *c,</span>
<span class="line-modified">1360                            uint32_t lookup_props,</span>
<span class="line-modified">1361                            hb_array_t&lt;const GlyphID&gt; first_glyphs,</span>
<span class="line-modified">1362                            hb_array_t&lt;const unsigned int&gt; ligature_per_first_glyph_count_list,</span>
<span class="line-modified">1363                            hb_array_t&lt;const GlyphID&gt; ligatures_list,</span>
<span class="line-modified">1364                            hb_array_t&lt;const unsigned int&gt; component_count_list,</span>
<span class="line-modified">1365                            hb_array_t&lt;const GlyphID&gt; component_list /* Starting from second for each ligature */)</span>

1366   {
1367     TRACE_SERIALIZE (this);
<a name="170" id="anc170"></a><span class="line-modified">1368     if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);</span>
1369     return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,
1370                                                                   first_glyphs,
1371                                                                   ligature_per_first_glyph_count_list,
<a name="171" id="anc171"></a>
1372                                                                   ligatures_list,
1373                                                                   component_count_list,
1374                                                                   component_list));
1375   }
1376 
1377   template &lt;typename context_t&gt;
<a name="172" id="anc172"></a><span class="line-modified">1378   static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);</span>
1379 
<a name="173" id="anc173"></a><span class="line-modified">1380   static hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)</span>
1381   {
1382     if (!c-&gt;should_visit_lookup (lookup_index))
1383       return HB_VOID;
<a name="174" id="anc174"></a><span class="line-modified">1384 </span>
<span class="line-added">1385     hb_closure_context_t::return_t ret = dispatch_recurse_func (c, lookup_index);</span>
<span class="line-added">1386 </span>
<span class="line-added">1387     /* While in theory we should flush here, it will cause timeouts because a recursive</span>
<span class="line-added">1388      * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to</span>
<span class="line-added">1389      * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. */</span>
<span class="line-added">1390     //c-&gt;flush ();</span>
<span class="line-added">1391 </span>
<span class="line-added">1392     return ret;</span>
1393   }
1394 
1395   template &lt;typename context_t&gt;
<a name="175" id="anc175"></a><span class="line-modified">1396   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">1397   { return Lookup::dispatch&lt;SubTable&gt; (c); }</span>
1398 
<a name="176" id="anc176"></a><span class="line-modified">1399   bool subset (hb_subset_context_t *c) const</span>
<span class="line-modified">1400   { return Lookup::subset&lt;SubTable&gt; (c); }</span>



1401 
<a name="177" id="anc177"></a><span class="line-modified">1402   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1403   { return Lookup::sanitize&lt;SubTable&gt; (c); }</span>












1404 };
1405 
<a name="178" id="anc178"></a>

1406 /*
1407  * GSUB -- Glyph Substitution
1408  * https://docs.microsoft.com/en-us/typography/opentype/spec/gsub
1409  */
1410 
1411 struct GSUB : GSUBGPOS
1412 {
<a name="179" id="anc179"></a><span class="line-modified">1413   static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;</span>
1414 
<a name="180" id="anc180"></a><span class="line-modified">1415   const SubstLookup&amp; get_lookup (unsigned int i) const</span>
1416   { return CastR&lt;SubstLookup&gt; (GSUBGPOS::get_lookup (i)); }
1417 
<a name="181" id="anc181"></a><span class="line-modified">1418   bool subset (hb_subset_context_t *c) const</span>
<span class="line-added">1419   { return GSUBGPOS::subset&lt;SubstLookup&gt; (c); }</span>
1420 
<a name="182" id="anc182"></a><span class="line-modified">1421   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">1422   { return GSUBGPOS::sanitize&lt;SubstLookup&gt; (c); }</span>






1423 
<a name="183" id="anc183"></a><span class="line-added">1424   HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,</span>
<span class="line-added">1425                                    hb_face_t *face) const;</span>
1426 
<a name="184" id="anc184"></a><span class="line-modified">1427   typedef GSUBGPOS::accelerator_t&lt;GSUB&gt; accelerator_t;</span>
<span class="line-modified">1428 };</span>


1429 
<a name="185" id="anc185"></a><span class="line-modified">1430 </span>
<span class="line-modified">1431 struct GSUB_accelerator_t : GSUB::accelerator_t {};</span>







1432 
1433 
1434 /* Out-of-class implementation for methods recursing */
1435 
<a name="186" id="anc186"></a><span class="line-modified">1436 /*static*/ inline bool ExtensionSubst::is_reverse () const</span>
1437 {
1438   unsigned int type = get_type ();
<a name="187" id="anc187"></a><span class="line-modified">1439   if (unlikely (type == SubTable::Extension))</span>
<span class="line-modified">1440     return CastR&lt;ExtensionSubst&gt; (get_subtable&lt;SubTable&gt;()).is_reverse ();</span>
1441   return SubstLookup::lookup_type_is_reverse (type);
1442 }
1443 
1444 template &lt;typename context_t&gt;
1445 /*static*/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)
1446 {
<a name="188" id="anc188"></a><span class="line-modified">1447   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1448   return l.dispatch (c);
1449 }
1450 
1451 /*static*/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)
1452 {
<a name="189" id="anc189"></a><span class="line-modified">1453   const SubstLookup &amp;l = c-&gt;face-&gt;table.GSUB.get_relaxed ()-&gt;table-&gt;get_lookup (lookup_index);</span>

1454   unsigned int saved_lookup_props = c-&gt;lookup_props;
1455   unsigned int saved_lookup_index = c-&gt;lookup_index;
1456   c-&gt;set_lookup_index (lookup_index);
1457   c-&gt;set_lookup_props (l.get_props ());
1458   bool ret = l.dispatch (c);
1459   c-&gt;set_lookup_index (saved_lookup_index);
1460   c-&gt;set_lookup_props (saved_lookup_props);
1461   return ret;
1462 }
1463 
<a name="190" id="anc190"></a>
1464 } /* namespace OT */
1465 
1466 
1467 #endif /* HB_OT_LAYOUT_GSUB_TABLE_HH */
<a name="191" id="anc191"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="191" type="hidden" />
</body>
</html>
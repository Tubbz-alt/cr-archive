<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright © 1998-2004  David Turner and Werner Lemberg
   3  * Copyright © 2006  Behdad Esfahbod
   4  * Copyright © 2007,2008,2009  Red Hat, Inc.
   5  * Copyright © 2012,2013  Google, Inc.
   6  *
   7  *  This is part of HarfBuzz, a text shaping library.
   8  *
   9  * Permission is hereby granted, without written agreement and without
  10  * license or royalty fees, to use, copy, modify, and distribute this
  11  * software and its documentation for any purpose, provided that the
  12  * above copyright notice and the following two paragraphs appear in
  13  * all copies of this software.
  14  *
  15  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  16  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  17  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  18  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  19  * DAMAGE.
  20  *
  21  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  22  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  23  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  24  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  25  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  26  *
  27  * Red Hat Author(s): Behdad Esfahbod
  28  * Google Author(s): Behdad Esfahbod
  29  */
  30 
  31 #include &quot;hb-open-type-private.hh&quot;
  32 #include &quot;hb-ot-layout-private.hh&quot;
  33 #include &quot;hb-ot-map-private.hh&quot;
  34 
  35 #include &quot;hb-ot-layout-gdef-table.hh&quot;
  36 #include &quot;hb-ot-layout-gsub-table.hh&quot;
  37 #include &quot;hb-ot-layout-gpos-table.hh&quot;
  38 
  39 // Just so we compile them; unused otherwise:
  40 #include &quot;hb-ot-layout-base-table.hh&quot;
  41 #include &quot;hb-ot-layout-jstf-table.hh&quot;
  42 #include &quot;hb-ot-color-colr-table.hh&quot;
  43 #include &quot;hb-ot-color-cpal-table.hh&quot;
  44 #include &quot;hb-ot-color-sbix-table.hh&quot;
  45 #include &quot;hb-ot-color-svg-table.hh&quot;
  46 #include &quot;hb-ot-name-table.hh&quot;
  47 #include &quot;hb-map-private.hh&quot;
  48 
  49 
  50 hb_ot_layout_t *
  51 _hb_ot_layout_create (hb_face_t *face)
  52 {
  53   hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));
  54   if (unlikely (!layout))
  55     return nullptr;
  56 
  57   layout-&gt;gdef_blob = OT::Sanitizer&lt;OT::GDEF&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GDEF));
  58   layout-&gt;gdef = layout-&gt;gdef_blob-&gt;as&lt;OT::GDEF&gt; ();
  59 
  60   layout-&gt;gsub_blob = OT::Sanitizer&lt;OT::GSUB&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GSUB));
  61   layout-&gt;gsub = layout-&gt;gsub_blob-&gt;as&lt;OT::GSUB&gt; ();
  62 
  63   layout-&gt;gpos_blob = OT::Sanitizer&lt;OT::GPOS&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GPOS));
  64   layout-&gt;gpos = layout-&gt;gpos_blob-&gt;as&lt;OT::GPOS&gt; ();
  65 
  66   layout-&gt;math.init (face);
  67   layout-&gt;fvar.init (face);
  68   layout-&gt;avar.init (face);
  69 
  70   {
  71     /*
  72      * The ugly business of blacklisting individual fonts&#39; tables happen here!
  73      * See this thread for why we finally had to bend in and do this:
  74      * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html
  75      */
  76     unsigned int gdef_len = layout-&gt;gdef_blob-&gt;length;
  77     unsigned int gsub_len = layout-&gt;gsub_blob-&gt;length;
  78     unsigned int gpos_len = layout-&gt;gpos_blob-&gt;length;
  79     if (0
  80       /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */
  81       || (442 == gdef_len &amp;&amp; 42038 == gpos_len &amp;&amp; 2874 == gsub_len)
  82       /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */
  83       || (430 == gdef_len &amp;&amp; 40662 == gpos_len &amp;&amp; 2874 == gsub_len)
  84       /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */
  85       || (442 == gdef_len &amp;&amp; 39116 == gpos_len &amp;&amp; 2874 == gsub_len)
  86       /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */
  87       || (430 == gdef_len &amp;&amp; 39374 == gpos_len &amp;&amp; 2874 == gsub_len)
  88       /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */
  89       || (490 == gdef_len &amp;&amp; 41638 == gpos_len &amp;&amp; 3046 == gsub_len)
  90       /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */
  91       || (478 == gdef_len &amp;&amp; 41902 == gpos_len &amp;&amp; 3046 == gsub_len)
  92     )
  93     {
  94       /* In certain versions of Times New Roman Italic and Bold Italic,
  95        * ASCII double quotation mark U+0022, mapped to glyph 5, has wrong
  96        * glyph class 3 (mark) in GDEF.  Nuke the GDEF to avoid zero-width
  97        * double-quote.  See:
  98        * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html
  99        */
 100      if (3 == layout-&gt;gdef-&gt;get_glyph_class (5))
 101        layout-&gt;gdef = &amp;Null(OT::GDEF);
 102     }
 103     else if (0
 104       /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */
 105       || (898 == gdef_len &amp;&amp; 46470 == gpos_len &amp;&amp; 12554 == gsub_len)
 106       /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */
 107       || (910 == gdef_len &amp;&amp; 47732 == gpos_len &amp;&amp; 12566 == gsub_len)
 108       /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */
 109       || (928 == gdef_len &amp;&amp; 59332 == gpos_len &amp;&amp; 23298 == gsub_len)
 110       /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */
 111       || (940 == gdef_len &amp;&amp; 60732 == gpos_len &amp;&amp; 23310 == gsub_len)
 112       /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */
 113       || (964 == gdef_len &amp;&amp; 60072 == gpos_len &amp;&amp; 23836 == gsub_len)
 114       /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */
 115       || (976 == gdef_len &amp;&amp; 61456 == gpos_len &amp;&amp; 23832 == gsub_len)
 116       /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */
 117       || (994 == gdef_len &amp;&amp; 60336 == gpos_len &amp;&amp; 24474 == gsub_len)
 118       /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */
 119       || (1006 == gdef_len &amp;&amp; 61740 == gpos_len &amp;&amp; 24470 == gsub_len)
 120       /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */
 121       || (1006 == gdef_len &amp;&amp; 61346 == gpos_len &amp;&amp; 24576 == gsub_len)
 122       /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */
 123       || (1018 == gdef_len &amp;&amp; 62828 == gpos_len &amp;&amp; 24572 == gsub_len)
 124       /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */
 125       || (1006 == gdef_len &amp;&amp; 61352 == gpos_len &amp;&amp; 24576 == gsub_len)
 126       /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */
 127       || (1018 == gdef_len &amp;&amp; 62834 == gpos_len &amp;&amp; 24572 == gsub_len)
 128       /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */
 129       || (832 == gdef_len &amp;&amp; 47162 == gpos_len &amp;&amp; 7324 == gsub_len)
 130       /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */
 131       || (844 == gdef_len &amp;&amp; 45474 == gpos_len &amp;&amp; 7302 == gsub_len)
 132       /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */
 133       || (180 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 13054 == gsub_len)
 134       /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */
 135       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12638 == gsub_len)
 136       /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */
 137       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12690 == gsub_len)
 138       /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */
 139       /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */
 140       || (188 == gdef_len &amp;&amp; 3852 == gpos_len &amp;&amp; 248 == gsub_len)
 141       /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */
 142       /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */
 143       || (188 == gdef_len &amp;&amp; 3426 == gpos_len &amp;&amp; 264 == gsub_len)
 144       /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */
 145       || (1058 == gdef_len &amp;&amp; 11818 == gpos_len &amp;&amp; 47032 == gsub_len)
 146       /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/
 147       || (1046 == gdef_len &amp;&amp; 12600 == gpos_len &amp;&amp; 47030 == gsub_len)
 148       /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */
 149       || (1058 == gdef_len &amp;&amp; 16770 == gpos_len &amp;&amp; 71796 == gsub_len)
 150       /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */
 151       || (1046 == gdef_len &amp;&amp; 17862 == gpos_len &amp;&amp; 71790 == gsub_len)
 152       /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */
 153       || (1046 == gdef_len &amp;&amp; 17112 == gpos_len &amp;&amp; 71788 == gsub_len)
 154       /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */
 155       || (1058 == gdef_len &amp;&amp; 17514 == gpos_len &amp;&amp; 71794 == gsub_len)
 156       /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */
 157       || (1330 == gdef_len &amp;&amp; 57938 == gpos_len &amp;&amp; 109904 == gsub_len)
 158       /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */
 159       || (1330 == gdef_len &amp;&amp; 58972 == gpos_len &amp;&amp; 109904 == gsub_len)
 160       /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf
 161        *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */
 162       || (1004 == gdef_len &amp;&amp; 14836 == gpos_len &amp;&amp; 59092 == gsub_len)
 163     )
 164     {
 165       /* Many versions of Tahoma have bad GDEF tables that incorrectly classify some spacing marks
 166        * such as certain IPA symbols as glyph class 3. So do older versions of Microsoft Himalaya,
 167        * and the version of Cantarell shipped by Ubuntu 16.04.
 168        * Nuke the GDEF tables of these fonts to avoid unwanted width-zeroing.
 169        * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925
 170        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693
 171        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875
 172        */
 173       layout-&gt;gdef = &amp;Null(OT::GDEF);
 174     }
 175   }
 176 
 177   layout-&gt;gsub_lookup_count = layout-&gt;gsub-&gt;get_lookup_count ();
 178   layout-&gt;gpos_lookup_count = layout-&gt;gpos-&gt;get_lookup_count ();
 179 
 180   layout-&gt;gsub_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gsub-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));
 181   layout-&gt;gpos_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gpos-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));
 182 
 183   if (unlikely ((layout-&gt;gsub_lookup_count &amp;&amp; !layout-&gt;gsub_accels) ||
 184                 (layout-&gt;gpos_lookup_count &amp;&amp; !layout-&gt;gpos_accels)))
 185   {
 186     _hb_ot_layout_destroy (layout);
 187     return nullptr;
 188   }
 189 
 190   for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)
 191     layout-&gt;gsub_accels[i].init (layout-&gt;gsub-&gt;get_lookup (i));
 192   for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)
 193     layout-&gt;gpos_accels[i].init (layout-&gt;gpos-&gt;get_lookup (i));
 194 
 195   return layout;
 196 }
 197 
 198 void
 199 _hb_ot_layout_destroy (hb_ot_layout_t *layout)
 200 {
 201   if (layout-&gt;gsub_accels)
 202     for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)
 203       layout-&gt;gsub_accels[i].fini ();
 204   if (layout-&gt;gpos_accels)
 205     for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)
 206       layout-&gt;gpos_accels[i].fini ();
 207 
 208   free (layout-&gt;gsub_accels);
 209   free (layout-&gt;gpos_accels);
 210 
 211   hb_blob_destroy (layout-&gt;gdef_blob);
 212   hb_blob_destroy (layout-&gt;gsub_blob);
 213   hb_blob_destroy (layout-&gt;gpos_blob);
 214 
 215   layout-&gt;math.fini ();
 216   layout-&gt;fvar.fini ();
 217   layout-&gt;avar.fini ();
 218 
 219   free (layout);
 220 }
 221 
 222 // static inline const OT::BASE&amp;
 223 // _get_base (hb_face_t *face)
 224 // {
 225 //   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::BASE);
 226 //   hb_ot_layout_t * layout = hb_ot_layout_from_face (face);
 227 //   return *(layout-&gt;base.get ());
 228 // }
 229 
 230 static inline const OT::GDEF&amp;
 231 _get_gdef (hb_face_t *face)
 232 {
 233   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GDEF);
 234   return *hb_ot_layout_from_face (face)-&gt;gdef;
 235 }
 236 static inline const OT::GSUB&amp;
 237 _get_gsub (hb_face_t *face)
 238 {
 239   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GSUB);
 240   return *hb_ot_layout_from_face (face)-&gt;gsub;
 241 }
 242 static inline const OT::GPOS&amp;
 243 _get_gpos (hb_face_t *face)
 244 {
 245   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GPOS);
 246   return *hb_ot_layout_from_face (face)-&gt;gpos;
 247 }
 248 
 249 /*
 250  * GDEF
 251  */
 252 
 253 hb_bool_t
 254 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 255 {
 256   return _get_gdef (face).has_glyph_classes ();
 257 }
 258 
 259 /**
 260  * hb_ot_layout_get_glyph_class:
 261  *
 262  * Since: 0.9.7
 263  **/
 264 hb_ot_layout_glyph_class_t
 265 hb_ot_layout_get_glyph_class (hb_face_t      *face,
 266                               hb_codepoint_t  glyph)
 267 {
 268   return (hb_ot_layout_glyph_class_t) _get_gdef (face).get_glyph_class (glyph);
 269 }
 270 
 271 /**
 272  * hb_ot_layout_get_glyphs_in_class:
 273  *
 274  * Since: 0.9.7
 275  **/
 276 void
 277 hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
 278                                   hb_ot_layout_glyph_class_t  klass,
 279                                   hb_set_t                   *glyphs /* OUT */)
 280 {
 281   return _get_gdef (face).get_glyphs_in_class (klass, glyphs);
 282 }
 283 
 284 unsigned int
 285 hb_ot_layout_get_attach_points (hb_face_t      *face,
 286                                 hb_codepoint_t  glyph,
 287                                 unsigned int    start_offset,
 288                                 unsigned int   *point_count /* IN/OUT */,
 289                                 unsigned int   *point_array /* OUT */)
 290 {
 291   return _get_gdef (face).get_attach_points (glyph, start_offset, point_count, point_array);
 292 }
 293 
 294 unsigned int
 295 hb_ot_layout_get_ligature_carets (hb_font_t      *font,
 296                                   hb_direction_t  direction,
 297                                   hb_codepoint_t  glyph,
 298                                   unsigned int    start_offset,
 299                                   unsigned int   *caret_count /* IN/OUT */,
 300                                   hb_position_t  *caret_array /* OUT */)
 301 {
 302   return _get_gdef (font-&gt;face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);
 303 }
 304 
 305 
 306 /*
 307  * GSUB/GPOS
 308  */
 309 
 310 static const OT::GSUBGPOS&amp;
 311 get_gsubgpos_table (hb_face_t *face,
 312                     hb_tag_t   table_tag)
 313 {
 314   switch (table_tag) {
 315     case HB_OT_TAG_GSUB: return _get_gsub (face);
 316     case HB_OT_TAG_GPOS: return _get_gpos (face);
 317     default:             return Null(OT::GSUBGPOS);
 318   }
 319 }
 320 
 321 
 322 unsigned int
 323 hb_ot_layout_table_get_script_tags (hb_face_t    *face,
 324                                     hb_tag_t      table_tag,
 325                                     unsigned int  start_offset,
 326                                     unsigned int *script_count /* IN/OUT */,
 327                                     hb_tag_t     *script_tags /* OUT */)
 328 {
 329   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 330 
 331   return g.get_script_tags (start_offset, script_count, script_tags);
 332 }
 333 
 334 #define HB_OT_TAG_LATIN_SCRIPT          HB_TAG (&#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;n&#39;)
 335 
 336 hb_bool_t
 337 hb_ot_layout_table_find_script (hb_face_t    *face,
 338                                 hb_tag_t      table_tag,
 339                                 hb_tag_t      script_tag,
 340                                 unsigned int *script_index)
 341 {
 342   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 343   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 344 
 345   if (g.find_script_index (script_tag, script_index))
 346     return true;
 347 
 348   /* try finding &#39;DFLT&#39; */
 349   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))
 350     return false;
 351 
 352   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :(.
 353    * including many versions of DejaVu Sans Mono! */
 354   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
 355     return false;
 356 
 357   /* try with &#39;latn&#39;; some old fonts put their features there even though
 358      they&#39;re really trying to support Thai, for example :( */
 359   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))
 360     return false;
 361 
 362   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 363   return false;
 364 }
 365 
 366 hb_bool_t
 367 hb_ot_layout_table_choose_script (hb_face_t      *face,
 368                                   hb_tag_t        table_tag,
 369                                   const hb_tag_t *script_tags,
 370                                   unsigned int   *script_index,
 371                                   hb_tag_t       *chosen_script)
 372 {
 373   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 374   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 375 
 376   while (*script_tags)
 377   {
 378     if (g.find_script_index (*script_tags, script_index)) {
 379       if (chosen_script)
 380         *chosen_script = *script_tags;
 381       return true;
 382     }
 383     script_tags++;
 384   }
 385 
 386   /* try finding &#39;DFLT&#39; */
 387   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
 388     if (chosen_script)
 389       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
 390     return false;
 391   }
 392 
 393   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 394   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
 395     if (chosen_script)
 396       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
 397     return false;
 398   }
 399 
 400   /* try with &#39;latn&#39;; some old fonts put their features there even though
 401      they&#39;re really trying to support Thai, for example :( */
 402   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
 403     if (chosen_script)
 404       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
 405     return false;
 406   }
 407 
 408   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 409   if (chosen_script)
 410     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 411   return false;
 412 }
 413 
 414 unsigned int
 415 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 416                                      hb_tag_t      table_tag,
 417                                      unsigned int  start_offset,
 418                                      unsigned int *feature_count /* IN/OUT */,
 419                                      hb_tag_t     *feature_tags /* OUT */)
 420 {
 421   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 422 
 423   return g.get_feature_tags (start_offset, feature_count, feature_tags);
 424 }
 425 
 426 hb_bool_t
 427 hb_ot_layout_table_find_feature (hb_face_t    *face,
 428                                  hb_tag_t      table_tag,
 429                                  hb_tag_t      feature_tag,
 430                                  unsigned int *feature_index)
 431 {
 432   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 433   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 434 
 435   unsigned int num_features = g.get_feature_count ();
 436   for (unsigned int i = 0; i &lt; num_features; i++)
 437   {
 438     if (feature_tag == g.get_feature_tag (i)) {
 439       if (feature_index) *feature_index = i;
 440       return true;
 441     }
 442   }
 443 
 444   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 445   return false;
 446 }
 447 
 448 
 449 unsigned int
 450 hb_ot_layout_script_get_language_tags (hb_face_t    *face,
 451                                        hb_tag_t      table_tag,
 452                                        unsigned int  script_index,
 453                                        unsigned int  start_offset,
 454                                        unsigned int *language_count /* IN/OUT */,
 455                                        hb_tag_t     *language_tags /* OUT */)
 456 {
 457   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 458 
 459   return s.get_lang_sys_tags (start_offset, language_count, language_tags);
 460 }
 461 
 462 hb_bool_t
 463 hb_ot_layout_script_find_language (hb_face_t    *face,
 464                                    hb_tag_t      table_tag,
 465                                    unsigned int  script_index,
 466                                    hb_tag_t      language_tag,
 467                                    unsigned int *language_index)
 468 {
 469   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
 470   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 471 
 472   if (s.find_lang_sys_index (language_tag, language_index))
 473     return true;
 474 
 475   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 476   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
 477     return false;
 478 
 479   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
 480   return false;
 481 }
 482 
 483 hb_bool_t
 484 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 485                                                   hb_tag_t      table_tag,
 486                                                   unsigned int  script_index,
 487                                                   unsigned int  language_index,
 488                                                   unsigned int *feature_index)
 489 {
 490   return hb_ot_layout_language_get_required_feature (face,
 491                                                      table_tag,
 492                                                      script_index,
 493                                                      language_index,
 494                                                      feature_index,
 495                                                      nullptr);
 496 }
 497 
 498 /**
 499  * hb_ot_layout_language_get_required_feature:
 500  *
 501  * Since: 0.9.30
 502  **/
 503 hb_bool_t
 504 hb_ot_layout_language_get_required_feature (hb_face_t    *face,
 505                                             hb_tag_t      table_tag,
 506                                             unsigned int  script_index,
 507                                             unsigned int  language_index,
 508                                             unsigned int *feature_index,
 509                                             hb_tag_t     *feature_tag)
 510 {
 511   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 512   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 513 
 514   unsigned int index = l.get_required_feature_index ();
 515   if (feature_index) *feature_index = index;
 516   if (feature_tag) *feature_tag = g.get_feature_tag (index);
 517 
 518   return l.has_required_feature ();
 519 }
 520 
 521 unsigned int
 522 hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
 523                                            hb_tag_t      table_tag,
 524                                            unsigned int  script_index,
 525                                            unsigned int  language_index,
 526                                            unsigned int  start_offset,
 527                                            unsigned int *feature_count /* IN/OUT */,
 528                                            unsigned int *feature_indexes /* OUT */)
 529 {
 530   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 531   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 532 
 533   return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
 534 }
 535 
 536 unsigned int
 537 hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
 538                                         hb_tag_t      table_tag,
 539                                         unsigned int  script_index,
 540                                         unsigned int  language_index,
 541                                         unsigned int  start_offset,
 542                                         unsigned int *feature_count /* IN/OUT */,
 543                                         hb_tag_t     *feature_tags /* OUT */)
 544 {
 545   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 546   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 547 
 548   static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
 549   unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
 550 
 551   if (feature_tags) {
 552     unsigned int count = *feature_count;
 553     for (unsigned int i = 0; i &lt; count; i++)
 554       feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
 555   }
 556 
 557   return ret;
 558 }
 559 
 560 
 561 hb_bool_t
 562 hb_ot_layout_language_find_feature (hb_face_t    *face,
 563                                     hb_tag_t      table_tag,
 564                                     unsigned int  script_index,
 565                                     unsigned int  language_index,
 566                                     hb_tag_t      feature_tag,
 567                                     unsigned int *feature_index)
 568 {
 569   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 570   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 571   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 572 
 573   unsigned int num_features = l.get_feature_count ();
 574   for (unsigned int i = 0; i &lt; num_features; i++) {
 575     unsigned int f_index = l.get_feature_index (i);
 576 
 577     if (feature_tag == g.get_feature_tag (f_index)) {
 578       if (feature_index) *feature_index = f_index;
 579       return true;
 580     }
 581   }
 582 
 583   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 584   return false;
 585 }
 586 
 587 /**
 588  * hb_ot_layout_feature_get_lookups:
 589  *
 590  * Since: 0.9.7
 591  **/
 592 unsigned int
 593 hb_ot_layout_feature_get_lookups (hb_face_t    *face,
 594                                   hb_tag_t      table_tag,
 595                                   unsigned int  feature_index,
 596                                   unsigned int  start_offset,
 597                                   unsigned int *lookup_count /* IN/OUT */,
 598                                   unsigned int *lookup_indexes /* OUT */)
 599 {
 600   return hb_ot_layout_feature_with_variations_get_lookups (face,
 601                                                            table_tag,
 602                                                            feature_index,
 603                                                            HB_OT_LAYOUT_NO_VARIATIONS_INDEX,
 604                                                            start_offset,
 605                                                            lookup_count,
 606                                                            lookup_indexes);
 607 }
 608 
 609 /**
 610  * hb_ot_layout_table_get_lookup_count:
 611  *
 612  * Since: 0.9.22
 613  **/
 614 unsigned int
 615 hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
 616                                      hb_tag_t      table_tag)
 617 {
 618   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return 0;
 619   switch (table_tag)
 620   {
 621     case HB_OT_TAG_GSUB:
 622     {
 623       return hb_ot_layout_from_face (face)-&gt;gsub_lookup_count;
 624     }
 625     case HB_OT_TAG_GPOS:
 626     {
 627       return hb_ot_layout_from_face (face)-&gt;gpos_lookup_count;
 628     }
 629   }
 630   return 0;
 631 }
 632 
 633 static void
 634 _hb_ot_layout_collect_lookups_lookups (hb_face_t      *face,
 635                                        hb_tag_t        table_tag,
 636                                        unsigned int    feature_index,
 637                                        hb_set_t       *lookup_indexes /* OUT */)
 638 {
 639   unsigned int lookup_indices[32];
 640   unsigned int offset, len;
 641 
 642   offset = 0;
 643   do {
 644     len = ARRAY_LENGTH (lookup_indices);
 645     hb_ot_layout_feature_get_lookups (face,
 646                                       table_tag,
 647                                       feature_index,
 648                                       offset, &amp;len,
 649                                       lookup_indices);
 650 
 651     for (unsigned int i = 0; i &lt; len; i++)
 652       lookup_indexes-&gt;add (lookup_indices[i]);
 653 
 654     offset += len;
 655   } while (len == ARRAY_LENGTH (lookup_indices));
 656 }
 657 
 658 static void
 659 _hb_ot_layout_collect_lookups_features (hb_face_t      *face,
 660                                         hb_tag_t        table_tag,
 661                                         unsigned int    script_index,
 662                                         unsigned int    language_index,
 663                                         const hb_tag_t *features,
 664                                         hb_set_t       *lookup_indexes /* OUT */)
 665 {
 666   if (!features)
 667   {
 668     unsigned int required_feature_index;
 669     if (hb_ot_layout_language_get_required_feature (face,
 670                                                     table_tag,
 671                                                     script_index,
 672                                                     language_index,
 673                                                     &amp;required_feature_index,
 674                                                     nullptr))
 675       _hb_ot_layout_collect_lookups_lookups (face,
 676                                              table_tag,
 677                                              required_feature_index,
 678                                              lookup_indexes);
 679 
 680     /* All features */
 681     unsigned int feature_indices[32];
 682     unsigned int offset, len;
 683 
 684     offset = 0;
 685     do {
 686       len = ARRAY_LENGTH (feature_indices);
 687       hb_ot_layout_language_get_feature_indexes (face,
 688                                                  table_tag,
 689                                                  script_index,
 690                                                  language_index,
 691                                                  offset, &amp;len,
 692                                                  feature_indices);
 693 
 694       for (unsigned int i = 0; i &lt; len; i++)
 695         _hb_ot_layout_collect_lookups_lookups (face,
 696                                                table_tag,
 697                                                feature_indices[i],
 698                                                lookup_indexes);
 699 
 700       offset += len;
 701     } while (len == ARRAY_LENGTH (feature_indices));
 702   }
 703   else
 704   {
 705     for (; *features; features++)
 706     {
 707       unsigned int feature_index;
 708       if (hb_ot_layout_language_find_feature (face,
 709                                               table_tag,
 710                                               script_index,
 711                                               language_index,
 712                                               *features,
 713                                               &amp;feature_index))
 714         _hb_ot_layout_collect_lookups_lookups (face,
 715                                                table_tag,
 716                                                feature_index,
 717                                                lookup_indexes);
 718     }
 719   }
 720 }
 721 
 722 static void
 723 _hb_ot_layout_collect_lookups_languages (hb_face_t      *face,
 724                                          hb_tag_t        table_tag,
 725                                          unsigned int    script_index,
 726                                          const hb_tag_t *languages,
 727                                          const hb_tag_t *features,
 728                                          hb_set_t       *lookup_indexes /* OUT */)
 729 {
 730   _hb_ot_layout_collect_lookups_features (face,
 731                                           table_tag,
 732                                           script_index,
 733                                           HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX,
 734                                           features,
 735                                           lookup_indexes);
 736 
 737   if (!languages)
 738   {
 739     /* All languages */
 740     unsigned int count = hb_ot_layout_script_get_language_tags (face,
 741                                                                 table_tag,
 742                                                                 script_index,
 743                                                                 0, nullptr, nullptr);
 744     for (unsigned int language_index = 0; language_index &lt; count; language_index++)
 745       _hb_ot_layout_collect_lookups_features (face,
 746                                               table_tag,
 747                                               script_index,
 748                                               language_index,
 749                                               features,
 750                                               lookup_indexes);
 751   }
 752   else
 753   {
 754     for (; *languages; languages++)
 755     {
 756       unsigned int language_index;
 757       if (hb_ot_layout_script_find_language (face,
 758                                              table_tag,
 759                                              script_index,
 760                                              *languages,
 761                                              &amp;language_index))
 762         _hb_ot_layout_collect_lookups_features (face,
 763                                                 table_tag,
 764                                                 script_index,
 765                                                 language_index,
 766                                                 features,
 767                                                 lookup_indexes);
 768     }
 769   }
 770 }
 771 
 772 /**
 773  * hb_ot_layout_collect_lookups:
 774  *
 775  * Since: 0.9.8
 776  **/
 777 void
 778 hb_ot_layout_collect_lookups (hb_face_t      *face,
 779                               hb_tag_t        table_tag,
 780                               const hb_tag_t *scripts,
 781                               const hb_tag_t *languages,
 782                               const hb_tag_t *features,
 783                               hb_set_t       *lookup_indexes /* OUT */)
 784 {
 785   if (!scripts)
 786   {
 787     /* All scripts */
 788     unsigned int count = hb_ot_layout_table_get_script_tags (face,
 789                                                              table_tag,
 790                                                              0, nullptr, nullptr);
 791     for (unsigned int script_index = 0; script_index &lt; count; script_index++)
 792       _hb_ot_layout_collect_lookups_languages (face,
 793                                                table_tag,
 794                                                script_index,
 795                                                languages,
 796                                                features,
 797                                                lookup_indexes);
 798   }
 799   else
 800   {
 801     for (; *scripts; scripts++)
 802     {
 803       unsigned int script_index;
 804       if (hb_ot_layout_table_find_script (face,
 805                                           table_tag,
 806                                           *scripts,
 807                                           &amp;script_index))
 808         _hb_ot_layout_collect_lookups_languages (face,
 809                                                  table_tag,
 810                                                  script_index,
 811                                                  languages,
 812                                                  features,
 813                                                  lookup_indexes);
 814     }
 815   }
 816 }
 817 
 818 /**
 819  * hb_ot_layout_lookup_collect_glyphs:
 820  *
 821  * Since: 0.9.7
 822  **/
 823 void
 824 hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
 825                                     hb_tag_t      table_tag,
 826                                     unsigned int  lookup_index,
 827                                     hb_set_t     *glyphs_before, /* OUT. May be nullptr */
 828                                     hb_set_t     *glyphs_input,  /* OUT. May be nullptr */
 829                                     hb_set_t     *glyphs_after,  /* OUT. May be nullptr */
 830                                     hb_set_t     *glyphs_output  /* OUT. May be nullptr */)
 831 {
 832   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return;
 833 
 834   OT::hb_collect_glyphs_context_t c (face,
 835                                      glyphs_before,
 836                                      glyphs_input,
 837                                      glyphs_after,
 838                                      glyphs_output);
 839 
 840   switch (table_tag)
 841   {
 842     case HB_OT_TAG_GSUB:
 843     {
 844       const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);
 845       l.collect_glyphs (&amp;c);
 846       return;
 847     }
 848     case HB_OT_TAG_GPOS:
 849     {
 850       const OT::PosLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gpos-&gt;get_lookup (lookup_index);
 851       l.collect_glyphs (&amp;c);
 852       return;
 853     }
 854   }
 855 }
 856 
 857 
 858 /* Variations support */
 859 
 860 hb_bool_t
 861 hb_ot_layout_table_find_feature_variations (hb_face_t    *face,
 862                                             hb_tag_t      table_tag,
 863                                             const int    *coords,
 864                                             unsigned int  num_coords,
 865                                             unsigned int *variations_index /* out */)
 866 {
 867   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 868 
 869   return g.find_variations_index (coords, num_coords, variations_index);
 870 }
 871 
 872 unsigned int
 873 hb_ot_layout_feature_with_variations_get_lookups (hb_face_t    *face,
 874                                                   hb_tag_t      table_tag,
 875                                                   unsigned int  feature_index,
 876                                                   unsigned int  variations_index,
 877                                                   unsigned int  start_offset,
 878                                                   unsigned int *lookup_count /* IN/OUT */,
 879                                                   unsigned int *lookup_indexes /* OUT */)
 880 {
 881   static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), &quot;&quot;);
 882   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 883 
 884   const OT::Feature &amp;f = g.get_feature_variation (feature_index, variations_index);
 885 
 886   return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
 887 }
 888 
 889 
 890 /*
 891  * OT::GSUB
 892  */
 893 
 894 hb_bool_t
 895 hb_ot_layout_has_substitution (hb_face_t *face)
 896 {
 897   return &amp;_get_gsub (face) != &amp;Null(OT::GSUB);
 898 }
 899 
 900 /**
 901  * hb_ot_layout_lookup_would_substitute:
 902  *
 903  * Since: 0.9.7
 904  **/
 905 hb_bool_t
 906 hb_ot_layout_lookup_would_substitute (hb_face_t            *face,
 907                                       unsigned int          lookup_index,
 908                                       const hb_codepoint_t *glyphs,
 909                                       unsigned int          glyphs_length,
 910                                       hb_bool_t             zero_context)
 911 {
 912   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return false;
 913   return hb_ot_layout_lookup_would_substitute_fast (face, lookup_index, glyphs, glyphs_length, zero_context);
 914 }
 915 
 916 hb_bool_t
 917 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 918                                            unsigned int          lookup_index,
 919                                            const hb_codepoint_t *glyphs,
 920                                            unsigned int          glyphs_length,
 921                                            hb_bool_t             zero_context)
 922 {
 923   if (unlikely (lookup_index &gt;= hb_ot_layout_from_face (face)-&gt;gsub_lookup_count)) return false;
 924   OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
 925 
 926   const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);
 927 
 928   return l.would_apply (&amp;c, &amp;hb_ot_layout_from_face (face)-&gt;gsub_accels[lookup_index]);
 929 }
 930 
 931 void
 932 hb_ot_layout_substitute_start (hb_font_t *font, hb_buffer_t *buffer)
 933 {
 934   OT::GSUB::substitute_start (font, buffer);
 935 }
 936 
 937 /**
 938  * hb_ot_layout_lookup_substitute_closure:
 939  *
 940  * Since: 0.9.7
 941  **/
 942 void
 943 hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
 944                                         unsigned int  lookup_index,
 945                                         hb_set_t     *glyphs)
 946 {
 947   hb_auto_t&lt;hb_map_t&gt; done_lookups;
 948   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
 949 
 950   const OT::SubstLookup&amp; l = _get_gsub (face).get_lookup (lookup_index);
 951 
 952   l.closure (&amp;c, lookup_index);
 953 }
 954 
 955 /**
 956  * hb_ot_layout_lookups_substitute_closure:
 957  *
 958  * Compute the transitive closure of glyphs needed for all of the
 959  * provided lookups.
 960  *
 961  * Since: 1.8.1
 962  **/
 963 void
 964 hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
 965                                          const hb_set_t *lookups,
 966                                          hb_set_t       *glyphs)
 967 {
 968   hb_auto_t&lt;hb_map_t&gt; done_lookups;
 969   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
 970   const OT::GSUB&amp; gsub = _get_gsub (face);
 971 
 972   unsigned int glyphs_length;
 973   do
 974   {
 975     glyphs_length = glyphs-&gt;get_population ();
 976     if (lookups != nullptr)
 977     {
 978       for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &amp;lookup_index);)
 979         gsub.get_lookup (lookup_index).closure (&amp;c, lookup_index);
 980     }
 981     else
 982     {
 983       for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
 984         gsub.get_lookup (i).closure (&amp;c, i);
 985     }
 986   } while (glyphs_length != glyphs-&gt;get_population ());
 987 }
 988 
 989 /*
 990  * OT::GPOS
 991  */
 992 
 993 hb_bool_t
 994 hb_ot_layout_has_positioning (hb_face_t *face)
 995 {
 996   return &amp;_get_gpos (face) != &amp;Null(OT::GPOS);
 997 }
 998 
 999 void
1000 hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
1001 {
1002   OT::GPOS::position_start (font, buffer);
1003 }
1004 
1005 void
1006 hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)
1007 {
1008   OT::GPOS::position_finish_advances (font, buffer);
1009 }
1010 
1011 void
1012 hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)
1013 {
1014   OT::GPOS::position_finish_offsets (font, buffer);
1015 }
1016 
1017 /**
1018  * hb_ot_layout_get_size_params:
1019  *
1020  * Since: 0.9.10
1021  **/
1022 hb_bool_t
1023 hb_ot_layout_get_size_params (hb_face_t    *face,
1024                               unsigned int *design_size,       /* OUT.  May be nullptr */
1025                               unsigned int *subfamily_id,      /* OUT.  May be nullptr */
1026                               unsigned int *subfamily_name_id, /* OUT.  May be nullptr */
1027                               unsigned int *range_start,       /* OUT.  May be nullptr */
1028                               unsigned int *range_end          /* OUT.  May be nullptr */)
1029 {
1030   const OT::GPOS &amp;gpos = _get_gpos (face);
1031   const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
1032 
1033   unsigned int num_features = gpos.get_feature_count ();
1034   for (unsigned int i = 0; i &lt; num_features; i++)
1035   {
1036     if (tag == gpos.get_feature_tag (i))
1037     {
1038       const OT::Feature &amp;f = gpos.get_feature (i);
1039       const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
1040 
1041       if (params.designSize)
1042       {
1043 #define PARAM(a, A) if (a) *a = params.A
1044         PARAM (design_size, designSize);
1045         PARAM (subfamily_id, subfamilyID);
1046         PARAM (subfamily_name_id, subfamilyNameID);
1047         PARAM (range_start, rangeStart);
1048         PARAM (range_end, rangeEnd);
1049 #undef PARAM
1050 
1051         return true;
1052       }
1053     }
1054   }
1055 
1056 #define PARAM(a, A) if (a) *a = 0
1057   PARAM (design_size, designSize);
1058   PARAM (subfamily_id, subfamilyID);
1059   PARAM (subfamily_name_id, subfamilyNameID);
1060   PARAM (range_start, rangeStart);
1061   PARAM (range_end, rangeEnd);
1062 #undef PARAM
1063 
1064   return false;
1065 }
1066 
1067 
1068 /*
1069  * Parts of different types are implemented here such that they have direct
1070  * access to GSUB/GPOS lookups.
1071  */
1072 
1073 
1074 struct GSUBProxy
1075 {
1076   static const unsigned int table_index = 0;
1077   static const bool inplace = false;
1078   typedef OT::SubstLookup Lookup;
1079 
1080   GSUBProxy (hb_face_t *face) :
1081     table (*hb_ot_layout_from_face (face)-&gt;gsub),
1082     accels (hb_ot_layout_from_face (face)-&gt;gsub_accels) {}
1083 
1084   const OT::GSUB &amp;table;
1085   const hb_ot_layout_lookup_accelerator_t *accels;
1086 };
1087 
1088 struct GPOSProxy
1089 {
1090   static const unsigned int table_index = 1;
1091   static const bool inplace = true;
1092   typedef OT::PosLookup Lookup;
1093 
1094   GPOSProxy (hb_face_t *face) :
1095     table (*hb_ot_layout_from_face (face)-&gt;gpos),
1096     accels (hb_ot_layout_from_face (face)-&gt;gpos_accels) {}
1097 
1098   const OT::GPOS &amp;table;
1099   const hb_ot_layout_lookup_accelerator_t *accels;
1100 };
1101 
1102 
1103 struct hb_get_subtables_context_t :
1104        OT::hb_dispatch_context_t&lt;hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY&gt;
1105 {
1106   template &lt;typename Type&gt;
1107   static inline bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)
1108   {
1109     const Type *typed_obj = (const Type *) obj;
1110     return typed_obj-&gt;apply (c);
1111   }
1112 
1113   typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);
1114 
1115   struct hb_applicable_t
1116   {
1117     inline void init (const void *obj_, hb_apply_func_t apply_func_)
1118     {
1119       obj = obj_;
1120       apply_func = apply_func_;
1121     }
1122 
1123     inline bool apply (OT::hb_ot_apply_context_t *c) const { return apply_func (obj, c); }
1124 
1125     private:
1126     const void *obj;
1127     hb_apply_func_t apply_func;
1128   };
1129 
1130   typedef hb_auto_t&lt;hb_vector_t&lt;hb_applicable_t&gt; &gt; array_t;
1131 
1132   /* Dispatch interface. */
1133   inline const char *get_name (void) { return &quot;GET_SUBTABLES&quot;; }
1134   template &lt;typename T&gt;
1135   inline return_t dispatch (const T &amp;obj)
1136   {
1137     hb_applicable_t *entry = array.push();
1138     entry-&gt;init (&amp;obj, apply_to&lt;T&gt;);
1139     return HB_VOID;
1140   }
1141   static return_t default_return_value (void) { return HB_VOID; }
1142   bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }
1143 
1144   hb_get_subtables_context_t (array_t &amp;array_) :
1145                               array (array_),
1146                               debug_depth (0) {}
1147 
1148   array_t &amp;array;
1149   unsigned int debug_depth;
1150 };
1151 
1152 static inline bool
1153 apply_forward (OT::hb_ot_apply_context_t *c,
1154                const hb_ot_layout_lookup_accelerator_t &amp;accel,
1155                const hb_get_subtables_context_t::array_t &amp;subtables)
1156 {
1157   bool ret = false;
1158   hb_buffer_t *buffer = c-&gt;buffer;
1159   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
1160   {
1161     bool applied = false;
1162     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1163         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1164         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1165      {
1166        for (unsigned int i = 0; i &lt; subtables.len; i++)
1167          if (subtables[i].apply (c))
1168          {
1169            applied = true;
1170            break;
1171          }
1172      }
1173 
1174     if (applied)
1175       ret = true;
1176     else
1177       buffer-&gt;next_glyph ();
1178   }
1179   return ret;
1180 }
1181 
1182 static inline bool
1183 apply_backward (OT::hb_ot_apply_context_t *c,
1184                const hb_ot_layout_lookup_accelerator_t &amp;accel,
1185                const hb_get_subtables_context_t::array_t &amp;subtables)
1186 {
1187   bool ret = false;
1188   hb_buffer_t *buffer = c-&gt;buffer;
1189   do
1190   {
1191     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1192         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1193         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1194     {
1195      for (unsigned int i = 0; i &lt; subtables.len; i++)
1196        if (subtables[i].apply (c))
1197        {
1198          ret = true;
1199          break;
1200        }
1201     }
1202     /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
1203     buffer-&gt;idx--;
1204 
1205   }
1206   while ((int) buffer-&gt;idx &gt;= 0);
1207   return ret;
1208 }
1209 
1210 template &lt;typename Proxy&gt;
1211 static inline void
1212 apply_string (OT::hb_ot_apply_context_t *c,
1213               const typename Proxy::Lookup &amp;lookup,
1214               const hb_ot_layout_lookup_accelerator_t &amp;accel)
1215 {
1216   hb_buffer_t *buffer = c-&gt;buffer;
1217 
1218   if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
1219     return;
1220 
1221   c-&gt;set_lookup_props (lookup.get_props ());
1222 
1223   hb_get_subtables_context_t::array_t subtables;
1224   hb_get_subtables_context_t c_get_subtables (subtables);
1225   lookup.dispatch (&amp;c_get_subtables);
1226 
1227   if (likely (!lookup.is_reverse ()))
1228   {
1229     /* in/out forward substitution/positioning */
1230     if (Proxy::table_index == 0)
1231       buffer-&gt;clear_output ();
1232     buffer-&gt;idx = 0;
1233 
1234     bool ret;
1235     ret = apply_forward (c, accel, subtables);
1236     if (ret)
1237     {
1238       if (!Proxy::inplace)
1239         buffer-&gt;swap_buffers ();
1240       else
1241         assert (!buffer-&gt;has_separate_output ());
1242     }
1243   }
1244   else
1245   {
1246     /* in-place backward substitution/positioning */
1247     if (Proxy::table_index == 0)
1248       buffer-&gt;remove_output ();
1249     buffer-&gt;idx = buffer-&gt;len - 1;
1250 
1251     apply_backward (c, accel, subtables);
1252   }
1253 }
1254 
1255 template &lt;typename Proxy&gt;
1256 inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
1257                                 const hb_ot_shape_plan_t *plan,
1258                                 hb_font_t *font,
1259                                 hb_buffer_t *buffer) const
1260 {
1261   const unsigned int table_index = proxy.table_index;
1262   unsigned int i = 0;
1263   OT::hb_ot_apply_context_t c (table_index, font, buffer);
1264   c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
1265 
1266   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].len; stage_index++) {
1267     const stage_map_t *stage = &amp;stages[table_index][stage_index];
1268     for (; i &lt; stage-&gt;last_lookup; i++)
1269     {
1270       unsigned int lookup_index = lookups[table_index][i].index;
1271       if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
1272       c.set_lookup_index (lookup_index);
1273       c.set_lookup_mask (lookups[table_index][i].mask);
1274       c.set_auto_zwj (lookups[table_index][i].auto_zwj);
1275       c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
1276       apply_string&lt;Proxy&gt; (&amp;c,
1277                            proxy.table.get_lookup (lookup_index),
1278                            proxy.accels[lookup_index]);
1279       (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
1280     }
1281 
1282     if (stage-&gt;pause_func)
1283     {
1284       buffer-&gt;clear_output ();
1285       stage-&gt;pause_func (plan, font, buffer);
1286     }
1287   }
1288 }
1289 
1290 void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1291 {
1292   GSUBProxy proxy (font-&gt;face);
1293   apply (proxy, plan, font, buffer);
1294 }
1295 
1296 void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1297 {
1298   GPOSProxy proxy (font-&gt;face);
1299   apply (proxy, plan, font, buffer);
1300 }
1301 
1302 void
1303 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
1304                                 const OT::SubstLookup &amp;lookup,
1305                                 const hb_ot_layout_lookup_accelerator_t &amp;accel)
1306 {
1307   apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
1308 }
1309 
1310 
1311 
1312 
1313 /*
1314  * OT::BASE
1315  */
1316 
1317 // /**
1318 //  * hb_ot_base_has_data:
1319 //  * @face: #hb_face_t to test
1320 //  *
1321 //  * This function allows to verify the presence of an OpenType BASE table on the
1322 //  * face.
1323 //  *
1324 //  * Return value: true if face has a BASE table, false otherwise
1325 //  *
1326 //  * Since: XXX
1327 //  **/
1328 // hb_bool_t
1329 // hb_ot_base_has_data (hb_face_t *face)
1330 // {
1331 //   return &amp;_get_base (face) != &amp;Null(OT::BASE);
1332 // }
    </pre>
  </body>
</html>
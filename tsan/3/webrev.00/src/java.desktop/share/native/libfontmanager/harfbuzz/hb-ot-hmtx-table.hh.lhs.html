<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-hmtx-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2011,2012  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod, Roderick Sheeter
 25  */
 26 
 27 #ifndef HB_OT_HMTX_TABLE_HH
 28 #define HB_OT_HMTX_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-open-type-private.hh&quot;</span>
 31 #include &quot;hb-ot-hhea-table.hh&quot;
 32 #include &quot;hb-ot-os2-table.hh&quot;
 33 #include &quot;hb-ot-var-hvar-table.hh&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 34 #include &quot;hb-subset-plan.hh&quot;</span>
 35 
 36 /*
 37  * hmtx -- Horizontal Metrics
 38  * https://docs.microsoft.com/en-us/typography/opentype/spec/hmtx
 39  * vmtx -- Vertical Metrics
 40  * https://docs.microsoft.com/en-us/typography/opentype/spec/vmtx
 41  */
 42 #define HB_OT_TAG_hmtx HB_TAG(&#39;h&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 43 #define HB_OT_TAG_vmtx HB_TAG(&#39;v&#39;,&#39;m&#39;,&#39;t&#39;,&#39;x&#39;)
 44 
 45 
 46 namespace OT {
 47 
 48 
 49 struct LongMetric
 50 {
 51   UFWORD        advance; /* Advance width/height. */
<a name="3" id="anc3"></a><span class="line-modified"> 52   FWORD         lsb; /* Leading (left/top) side bearing. */</span>
 53   public:
 54   DEFINE_SIZE_STATIC (4);
 55 };
 56 
 57 template &lt;typename T, typename H&gt;
 58 struct hmtxvmtx
 59 {
<a name="4" id="anc4"></a><span class="line-modified"> 60   inline bool sanitize (hb_sanitize_context_t *c) const</span>
 61   {
 62     TRACE_SANITIZE (this);
 63     /* We don&#39;t check for anything specific here.  The users of the
 64      * struct do all the hard work... */
 65     return_trace (true);
 66   }
 67 
 68 
<a name="5" id="anc5"></a><span class="line-modified"> 69   inline bool subset_update_header (hb_subset_plan_t *plan,</span>
 70                                     unsigned int num_hmetrics) const
 71   {
<a name="6" id="anc6"></a><span class="line-modified"> 72     hb_blob_t *src_blob = OT::Sanitizer&lt;H&gt; ().sanitize (plan-&gt;source-&gt;reference_table (H::tableTag));</span>
<span class="line-modified"> 73     hb_blob_t *dest_blob = hb_blob_copy_writable_or_fail(src_blob);</span>
 74     hb_blob_destroy (src_blob);
 75 
 76     if (unlikely (!dest_blob)) {
 77       return false;
 78     }
 79 
 80     unsigned int length;
 81     H *table = (H *) hb_blob_get_data (dest_blob, &amp;length);
 82     table-&gt;numberOfLongMetrics.set (num_hmetrics);
 83 
 84     bool result = plan-&gt;add_table (H::tableTag, dest_blob);
 85     hb_blob_destroy (dest_blob);
 86 
 87     return result;
 88   }
 89 
<a name="7" id="anc7"></a><span class="line-modified"> 90   inline bool subset (hb_subset_plan_t *plan) const</span>
 91   {
 92     typename T::accelerator_t _mtx;
 93     _mtx.init (plan-&gt;source);
 94 
 95     /* All the trailing glyphs with the same advance can use one LongMetric
 96      * and just keep LSB */
 97     hb_vector_t&lt;hb_codepoint_t&gt; &amp;gids = plan-&gt;glyphs;
<a name="8" id="anc8"></a><span class="line-modified"> 98     unsigned int num_advances = gids.len;</span>
 99     unsigned int last_advance = _mtx.get_advance (gids[num_advances - 1]);
<a name="9" id="anc9"></a><span class="line-modified">100     while (num_advances &gt; 1</span>
<span class="line-modified">101         &amp;&amp; last_advance == _mtx.get_advance (gids[num_advances - 2]))</span>
102     {
103       num_advances--;
104     }
105 
106     /* alloc the new table */
107     size_t dest_sz = num_advances * 4
<a name="10" id="anc10"></a><span class="line-modified">108                   + (gids.len - num_advances) * 2;</span>
109     void *dest = (void *) malloc (dest_sz);
110     if (unlikely (!dest))
111     {
112       return false;
113     }
114     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in src has %d advances, %d lsbs&quot;, HB_UNTAG(T::tableTag), _mtx.num_advances, _mtx.num_metrics - _mtx.num_advances);
<a name="11" id="anc11"></a><span class="line-modified">115     DEBUG_MSG(SUBSET, nullptr, &quot;%c%c%c%c in dest has %d advances, %d lsbs, %u bytes&quot;, HB_UNTAG(T::tableTag), num_advances, gids.len - num_advances, (unsigned int) dest_sz);</span>
116 
<a name="12" id="anc12"></a><span class="line-modified">117     const char *source_table = hb_blob_get_data (_mtx.blob, nullptr);</span>
118     // Copy everything over
119     LongMetric * old_metrics = (LongMetric *) source_table;
120     FWORD *lsbs = (FWORD *) (old_metrics + _mtx.num_advances);
121     char * dest_pos = (char *) dest;
122 
123     bool failed = false;
<a name="13" id="anc13"></a><span class="line-modified">124     for (unsigned int i = 0; i &lt; gids.len; i++)</span>
125     {
126       /* the last metric or the one for gids[i] */
127       LongMetric *src_metric = old_metrics + MIN ((hb_codepoint_t) _mtx.num_advances - 1, gids[i]);
128       if (gids[i] &lt; _mtx.num_advances)
129       {
130         /* src is a LongMetric */
131         if (i &lt; num_advances)
132         {
133           /* dest is a LongMetric, copy it */
134           *((LongMetric *) dest_pos) = *src_metric;
135         }
136         else
137         {
<a name="14" id="anc14"></a><span class="line-modified">138           /* dest just lsb */</span>
<span class="line-modified">139           *((FWORD *) dest_pos) = src_metric-&gt;lsb;</span>
140         }
141       }
142       else
143       {
144         if (gids[i] &gt;= _mtx.num_metrics)
145         {
146           DEBUG_MSG(SUBSET, nullptr, &quot;gid %d is &gt;= number of source metrics %d&quot;,
147                     gids[i], _mtx.num_metrics);
148           failed = true;
149           break;
150         }
<a name="15" id="anc15"></a><span class="line-modified">151         FWORD src_lsb = *(lsbs + gids[i] - _mtx.num_advances);</span>
152         if (i &lt; num_advances)
153         {
154           /* dest needs a full LongMetric */
155           LongMetric *metric = (LongMetric *)dest_pos;
156           metric-&gt;advance = src_metric-&gt;advance;
<a name="16" id="anc16"></a><span class="line-modified">157           metric-&gt;lsb = src_lsb;</span>
158         }
159         else
160         {
<a name="17" id="anc17"></a><span class="line-modified">161           /* dest just needs an lsb */</span>
<span class="line-modified">162           *((FWORD *) dest_pos) = src_lsb;</span>
163         }
164       }
165       dest_pos += (i &lt; num_advances ? 4 : 2);
166     }
167     _mtx.fini ();
168 
169     // Amend header num hmetrics
170     if (failed || unlikely (!subset_update_header (plan, num_advances)))
171     {
172       free (dest);
173       return false;
174     }
175 
176     hb_blob_t *result = hb_blob_create ((const char *)dest,
177                                         dest_sz,
178                                         HB_MEMORY_MODE_READONLY,
179                                         dest,
180                                         free);
181     bool success = plan-&gt;add_table (T::tableTag, result);
182     hb_blob_destroy (result);
183     return success;
184   }
185 
186   struct accelerator_t
187   {
188     friend struct hmtxvmtx;
189 
<a name="18" id="anc18"></a><span class="line-modified">190     inline void init (hb_face_t *face,</span>
191                       unsigned int default_advance_ = 0)
192     {
193       default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);
194 
195       bool got_font_extents = false;
<a name="19" id="anc19"></a><span class="line-modified">196       if (T::os2Tag)</span>
197       {
<a name="20" id="anc20"></a><span class="line-modified">198         hb_blob_t *os2_blob = Sanitizer&lt;os2&gt; ().sanitize (face-&gt;reference_table (T::os2Tag));</span>
<span class="line-modified">199         const os2 *os2_table = os2_blob-&gt;as&lt;os2&gt; ();</span>
<span class="line-modified">200 #define USE_TYPO_METRICS (1u&lt;&lt;7)</span>
<span class="line-modified">201         if (0 != (os2_table-&gt;fsSelection &amp; USE_TYPO_METRICS))</span>
<span class="line-removed">202         {</span>
<span class="line-removed">203           ascender = os2_table-&gt;sTypoAscender;</span>
<span class="line-removed">204           descender = os2_table-&gt;sTypoDescender;</span>
<span class="line-removed">205           line_gap = os2_table-&gt;sTypoLineGap;</span>
<span class="line-removed">206           got_font_extents = (ascender | descender) != 0;</span>
<span class="line-removed">207         }</span>
<span class="line-removed">208         hb_blob_destroy (os2_blob);</span>
209       }
210 
<a name="21" id="anc21"></a><span class="line-modified">211       hb_blob_t *_hea_blob = Sanitizer&lt;H&gt; ().sanitize (face-&gt;reference_table (H::tableTag));</span>
212       const H *_hea_table = _hea_blob-&gt;as&lt;H&gt; ();
213       num_advances = _hea_table-&gt;numberOfLongMetrics;
214       if (!got_font_extents)
215       {
<a name="22" id="anc22"></a><span class="line-modified">216         ascender = _hea_table-&gt;ascender;</span>
<span class="line-modified">217         descender = _hea_table-&gt;descender;</span>
218         line_gap = _hea_table-&gt;lineGap;
219         got_font_extents = (ascender | descender) != 0;
220       }
221       hb_blob_destroy (_hea_blob);
222 
223       has_font_extents = got_font_extents;
224 
<a name="23" id="anc23"></a><span class="line-modified">225       blob = Sanitizer&lt;hmtxvmtx&gt; ().sanitize (face-&gt;reference_table (T::tableTag));</span>
226 
227       /* Cap num_metrics() and num_advances() based on table length. */
<a name="24" id="anc24"></a><span class="line-modified">228       unsigned int len = hb_blob_get_length (blob);</span>
229       if (unlikely (num_advances * 4 &gt; len))
230         num_advances = len / 4;
231       num_metrics = num_advances + (len - 4 * num_advances) / 2;
232 
233       /* We MUST set num_metrics to zero if num_advances is zero.
234        * Our get_advance() depends on that. */
235       if (unlikely (!num_advances))
236       {
237         num_metrics = num_advances = 0;
<a name="25" id="anc25"></a><span class="line-modified">238         hb_blob_destroy (blob);</span>
<span class="line-modified">239         blob = hb_blob_get_empty ();</span>
240       }
<a name="26" id="anc26"></a><span class="line-removed">241       table = blob-&gt;as&lt;hmtxvmtx&gt; ();</span>
242 
<a name="27" id="anc27"></a><span class="line-modified">243       var_blob = Sanitizer&lt;HVARVVAR&gt; ().sanitize (face-&gt;reference_table (T::variationsTag));</span>
<span class="line-modified">244       var_table = var_blob-&gt;as&lt;HVARVVAR&gt; ();</span>





245     }
246 
<a name="28" id="anc28"></a><span class="line-modified">247     inline void fini (void)</span>

248     {
<a name="29" id="anc29"></a><span class="line-modified">249       hb_blob_destroy (blob);</span>
<span class="line-modified">250       hb_blob_destroy (var_blob);</span>






251     }
252 
<a name="30" id="anc30"></a><span class="line-modified">253     inline unsigned int get_advance (hb_codepoint_t  glyph) const</span>
254     {
255       if (unlikely (glyph &gt;= num_metrics))
256       {
257         /* If num_metrics is zero, it means we don&#39;t have the metrics table
258          * for this direction: return default advance.  Otherwise, it means that the
259          * glyph index is out of bound: return zero. */
260         if (num_metrics)
261           return 0;
262         else
263           return default_advance;
264       }
265 
<a name="31" id="anc31"></a><span class="line-modified">266       return table-&gt;longMetric[MIN (glyph, (uint32_t) num_advances - 1)].advance;</span>
267     }
268 
<a name="32" id="anc32"></a><span class="line-modified">269     inline unsigned int get_advance (hb_codepoint_t  glyph,</span>
<span class="line-modified">270                                      hb_font_t      *font) const</span>
271     {
272       unsigned int advance = get_advance (glyph);
<a name="33" id="anc33"></a><span class="line-modified">273       if (likely(glyph &lt; num_metrics))</span>
274       {
275         advance += (font-&gt;num_coords ? var_table-&gt;get_advance_var (glyph, font-&gt;coords, font-&gt;num_coords) : 0); // TODO Optimize?!
276       }
277       return advance;
278     }
279 
280     public:
281     bool has_font_extents;
<a name="34" id="anc34"></a><span class="line-modified">282     unsigned short ascender;</span>
<span class="line-modified">283     unsigned short descender;</span>
<span class="line-modified">284     unsigned short line_gap;</span>
285 
286     protected:
287     unsigned int num_metrics;
288     unsigned int num_advances;
289     unsigned int default_advance;
290 
291     private:
<a name="35" id="anc35"></a><span class="line-modified">292     const hmtxvmtx *table;</span>
<span class="line-modified">293     hb_blob_t *blob;</span>
<span class="line-removed">294     const HVARVVAR *var_table;</span>
<span class="line-removed">295     hb_blob_t *var_blob;</span>
296   };
297 
298   protected:
<a name="36" id="anc36"></a><span class="line-modified">299   LongMetric    longMetric[VAR];        /* Paired advance width and leading</span>
300                                          * bearing values for each glyph. The
301                                          * value numOfHMetrics comes from
302                                          * the &#39;hhea&#39; table. If the font is
303                                          * monospaced, only one entry need
304                                          * be in the array, but that entry is
305                                          * required. The last entry applies to
306                                          * all subsequent glyphs. */
<a name="37" id="anc37"></a><span class="line-modified">307 /*FWORD         leadingBearingX[VAR];*/ /* Here the advance is assumed</span>
308                                          * to be the same as the advance
309                                          * for the last entry above. The
310                                          * number of entries in this array is
311                                          * derived from numGlyphs (from &#39;maxp&#39;
312                                          * table) minus numberOfLongMetrics.
313                                          * This generally is used with a run
314                                          * of monospaced glyphs (e.g., Kanji
315                                          * fonts or Courier fonts). Only one
316                                          * run is allowed and it must be at
317                                          * the end. This allows a monospaced
318                                          * font to vary the side bearing
319                                          * values for each glyph. */
320   public:
<a name="38" id="anc38"></a><span class="line-modified">321   DEFINE_SIZE_ARRAY (0, longMetric);</span>
322 };
323 
324 struct hmtx : hmtxvmtx&lt;hmtx, hhea&gt; {
<a name="39" id="anc39"></a><span class="line-modified">325   static const hb_tag_t tableTag        = HB_OT_TAG_hmtx;</span>
<span class="line-modified">326   static const hb_tag_t variationsTag   = HB_OT_TAG_HVAR;</span>
<span class="line-modified">327   static const hb_tag_t os2Tag          = HB_OT_TAG_os2;</span>
328 };
329 struct vmtx : hmtxvmtx&lt;vmtx, vhea&gt; {
<a name="40" id="anc40"></a><span class="line-modified">330   static const hb_tag_t tableTag        = HB_OT_TAG_vmtx;</span>
<span class="line-modified">331   static const hb_tag_t variationsTag   = HB_OT_TAG_VVAR;</span>
<span class="line-modified">332   static const hb_tag_t os2Tag          = HB_TAG_NONE;</span>
333 };
334 
<a name="41" id="anc41"></a>


335 } /* namespace OT */
336 
337 
338 #endif /* HB_OT_HMTX_TABLE_HH */
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>
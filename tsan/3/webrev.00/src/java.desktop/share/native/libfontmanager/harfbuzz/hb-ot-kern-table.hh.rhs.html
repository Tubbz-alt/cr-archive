<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-kern-table.hh</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright Â© 2017  Google, Inc.
  3  *
  4  *  This is part of HarfBuzz, a text shaping library.
  5  *
  6  * Permission is hereby granted, without written agreement and without
  7  * license or royalty fees, to use, copy, modify, and distribute this
  8  * software and its documentation for any purpose, provided that the
  9  * above copyright notice and the following two paragraphs appear in
 10  * all copies of this software.
 11  *
 12  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
 13  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 14  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
 15  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
 16  * DAMAGE.
 17  *
 18  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
 19  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 20  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 21  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
 22  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 23  *
 24  * Google Author(s): Behdad Esfahbod
 25  */
 26 
 27 #ifndef HB_OT_KERN_TABLE_HH
 28 #define HB_OT_KERN_TABLE_HH
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #include &quot;hb-aat-layout-kerx-table.hh&quot;</span>
<span class="line-added"> 31 </span>
 32 
 33 /*
 34  * kern -- Kerning
 35  * https://docs.microsoft.com/en-us/typography/opentype/spec/kern
 36  * https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html
 37  */
 38 #define HB_OT_TAG_kern HB_TAG(&#39;k&#39;,&#39;e&#39;,&#39;r&#39;,&#39;n&#39;)
 39 
 40 
 41 namespace OT {
 42 
 43 
<a name="2" id="anc2"></a><span class="line-modified"> 44 template &lt;typename KernSubTableHeader&gt;</span>
<span class="line-modified"> 45 struct KernSubTableFormat3</span>































 46 {
<a name="3" id="anc3"></a><span class="line-modified"> 47   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
 48   {
<a name="4" id="anc4"></a><span class="line-modified"> 49     hb_array_t&lt;const FWORD&gt; kernValue = kernValueZ.as_array (kernValueCount);</span>
<span class="line-modified"> 50     hb_array_t&lt;const HBUINT8&gt; leftClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (kernValue).as_array (glyphCount);</span>
<span class="line-modified"> 51     hb_array_t&lt;const HBUINT8&gt; rightClass = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (leftClass).as_array (glyphCount);</span>
<span class="line-added"> 52     hb_array_t&lt;const HBUINT8&gt; kernIndex = StructAfter&lt;const UnsizedArrayOf&lt;HBUINT8&gt; &gt; (rightClass).as_array (leftClassCount * rightClassCount);</span>
<span class="line-added"> 53 </span>
<span class="line-added"> 54     unsigned int leftC = leftClass[left];</span>
<span class="line-added"> 55     unsigned int rightC = rightClass[right];</span>
<span class="line-added"> 56     if (unlikely (leftC &gt;= leftClassCount || rightC &gt;= rightClassCount))</span>
 57       return 0;
<a name="5" id="anc5"></a><span class="line-modified"> 58     unsigned int i = leftC * rightClassCount + rightC;</span>
<span class="line-added"> 59     return kernValue[kernIndex[i]];</span>
 60   }
 61 
<a name="6" id="anc6"></a><span class="line-modified"> 62   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
 63   {
<a name="7" id="anc7"></a><span class="line-modified"> 64     TRACE_APPLY (this);</span>








 65 
<a name="8" id="anc8"></a><span class="line-modified"> 66     if (!c-&gt;plan-&gt;requested_kerning)</span>
<span class="line-modified"> 67       return false;</span>

 68 
<a name="9" id="anc9"></a><span class="line-modified"> 69     if (header.coverage &amp; header.Backwards)</span>
<span class="line-modified"> 70       return false;</span>



 71 
<a name="10" id="anc10"></a><span class="line-modified"> 72     hb_kern_machine_t&lt;KernSubTableFormat3&gt; machine (*this, header.coverage &amp; header.CrossStream);</span>
<span class="line-modified"> 73     machine.kern (c-&gt;font, c-&gt;buffer, c-&gt;plan-&gt;kern_mask);</span>




 74 
<a name="11" id="anc11"></a><span class="line-modified"> 75     return_trace (true);</span>













 76   }
 77 
<a name="12" id="anc12"></a><span class="line-modified"> 78   bool sanitize (hb_sanitize_context_t *c) const</span>
 79   {
 80     TRACE_SANITIZE (this);
<a name="13" id="anc13"></a><span class="line-modified"> 81     return_trace (c-&gt;check_struct (this) &amp;&amp;</span>
<span class="line-modified"> 82                   c-&gt;check_range (kernValueZ,</span>
<span class="line-modified"> 83                                   kernValueCount * sizeof (FWORD) +</span>
<span class="line-modified"> 84                                   glyphCount * 2 +</span>
<span class="line-added"> 85                                   leftClassCount * rightClassCount));</span>
 86   }
 87 
 88   protected:
<a name="14" id="anc14"></a><span class="line-modified"> 89   KernSubTableHeader    header;</span>
<span class="line-modified"> 90   HBUINT16              glyphCount;     /* The number of glyphs in this font. */</span>
<span class="line-modified"> 91   HBUINT8               kernValueCount; /* The number of kerning values. */</span>
<span class="line-modified"> 92   HBUINT8               leftClassCount; /* The number of left-hand classes. */</span>
<span class="line-modified"> 93   HBUINT8               rightClassCount;/* The number of right-hand classes. */</span>
<span class="line-modified"> 94   HBUINT8               flags;          /* Set to zero (reserved for future use). */</span>
<span class="line-modified"> 95   UnsizedArrayOf&lt;FWORD&gt; kernValueZ;     /* The kerning values.</span>
<span class="line-modified"> 96                                          * Length kernValueCount. */</span>
<span class="line-modified"> 97 #if 0</span>
<span class="line-modified"> 98   UnsizedArrayOf&lt;HBUINT8&gt;leftClass;     /* The left-hand classes.</span>
<span class="line-added"> 99                                          * Length glyphCount. */</span>
<span class="line-added">100   UnsizedArrayOf&lt;HBUINT8&gt;rightClass;    /* The right-hand classes.</span>
<span class="line-added">101                                          * Length glyphCount. */</span>
<span class="line-added">102   UnsizedArrayOf&lt;HBUINT8&gt;kernIndex;     /* The indices into the kernValue array.</span>
<span class="line-added">103                                          * Length leftClassCount * rightClassCount */</span>
<span class="line-added">104 #endif</span>
105   public:
<a name="15" id="anc15"></a><span class="line-modified">106   DEFINE_SIZE_ARRAY (KernSubTableHeader::static_size + 6, kernValueZ);</span>
107 };
108 
<a name="16" id="anc16"></a><span class="line-added">109 template &lt;typename KernSubTableHeader&gt;</span>
110 struct KernSubTable
111 {
<a name="17" id="anc17"></a><span class="line-modified">112   unsigned int get_size () const { return u.header.length; }</span>
<span class="line-added">113   unsigned int get_type () const { return u.header.format; }</span>
<span class="line-added">114 </span>
<span class="line-added">115   int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
116   {
<a name="18" id="anc18"></a><span class="line-modified">117     switch (get_type ()) {</span>
<span class="line-added">118     /* This method hooks up to hb_font_t&#39;s get_h_kerning.  Only support Format0. */</span>
119     case 0: return u.format0.get_kerning (left, right);
<a name="19" id="anc19"></a>
120     default:return 0;
121     }
122   }
123 
<a name="20" id="anc20"></a><span class="line-modified">124   template &lt;typename context_t&gt;</span>
<span class="line-added">125   typename context_t::return_t dispatch (context_t *c) const</span>
126   {
<a name="21" id="anc21"></a><span class="line-modified">127     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">128     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-modified">129     switch (subtable_type) {</span>
<span class="line-modified">130     case 0:     return_trace (c-&gt;dispatch (u.format0));</span>
<span class="line-modified">131     case 1:     return_trace (u.header.apple ? c-&gt;dispatch (u.format1) : c-&gt;default_return_value ());</span>
<span class="line-added">132     case 2:     return_trace (c-&gt;dispatch (u.format2));</span>
<span class="line-added">133     case 3:     return_trace (u.header.apple ? c-&gt;dispatch (u.format3) : c-&gt;default_return_value ());</span>
<span class="line-added">134     default:    return_trace (c-&gt;default_return_value ());</span>
135     }
136   }
137 
<a name="22" id="anc22"></a><span class="line-modified">138   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">139   {</span>
<span class="line-added">140     TRACE_SANITIZE (this);</span>
<span class="line-added">141     if (unlikely (!u.header.sanitize (c) ||</span>
<span class="line-added">142                   u.header.length &lt; u.header.min_size ||</span>
<span class="line-added">143                   !c-&gt;check_range (this, u.header.length))) return_trace (false);</span>
<span class="line-added">144 </span>
<span class="line-added">145     return_trace (dispatch (c));</span>
<span class="line-added">146   }</span>
<span class="line-added">147 </span>
<span class="line-added">148   public:</span>
149   union {
<a name="23" id="anc23"></a><span class="line-modified">150   KernSubTableHeader                            header;</span>
<span class="line-modified">151   AAT::KerxSubTableFormat0&lt;KernSubTableHeader&gt;  format0;</span>
<span class="line-added">152   AAT::KerxSubTableFormat1&lt;KernSubTableHeader&gt;  format1;</span>
<span class="line-added">153   AAT::KerxSubTableFormat2&lt;KernSubTableHeader&gt;  format2;</span>
<span class="line-added">154   KernSubTableFormat3&lt;KernSubTableHeader&gt;       format3;</span>
155   } u;
156   public:
<a name="24" id="anc24"></a><span class="line-modified">157   DEFINE_SIZE_MIN (KernSubTableHeader::static_size);</span>
158 };
159 
160 
<a name="25" id="anc25"></a><span class="line-modified">161 struct KernOTSubTableHeader</span>

162 {
<a name="26" id="anc26"></a><span class="line-modified">163   static constexpr bool apple = false;</span>
<span class="line-modified">164   typedef AAT::ObsoleteTypes Types;</span>



165 
<a name="27" id="anc27"></a><span class="line-modified">166   unsigned int tuple_count () const { return 0; }</span>
<span class="line-modified">167   bool is_horizontal () const { return (coverage &amp; Horizontal); }</span>
168 
<a name="28" id="anc28"></a><span class="line-modified">169   enum Coverage</span>
<span class="line-modified">170   {</span>
<span class="line-modified">171     Horizontal  = 0x01u,</span>
<span class="line-modified">172     Minimum     = 0x02u,</span>
<span class="line-modified">173     CrossStream = 0x04u,</span>
<span class="line-modified">174     Override    = 0x08u,</span>
<span class="line-modified">175 </span>
<span class="line-added">176     /* Not supported: */</span>
<span class="line-added">177     Backwards   = 0x00u,</span>
<span class="line-added">178     Variation   = 0x00u,</span>
<span class="line-added">179   };</span>
180 
<a name="29" id="anc29"></a><span class="line-modified">181   bool sanitize (hb_sanitize_context_t *c) const</span>
182   {
183     TRACE_SANITIZE (this);
<a name="30" id="anc30"></a><span class="line-modified">184     return_trace (c-&gt;check_struct (this));</span>



185   }
<a name="31" id="anc31"></a><span class="line-added">186 </span>
<span class="line-added">187   public:</span>
<span class="line-added">188   HBUINT16      versionZ;       /* Unused. */</span>
<span class="line-added">189   HBUINT16      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">190   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">191   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">192   public:</span>
<span class="line-added">193   DEFINE_SIZE_STATIC (6);</span>
194 };
195 
<a name="32" id="anc32"></a><span class="line-modified">196 struct KernOT : AAT::KerxTable&lt;KernOT&gt;</span>

197 {
<a name="33" id="anc33"></a><span class="line-modified">198   friend struct AAT::KerxTable&lt;KernOT&gt;;</span>

199 
<a name="34" id="anc34"></a><span class="line-modified">200   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-modified">201   static constexpr unsigned minVersion = 0u;</span>












202 
<a name="35" id="anc35"></a><span class="line-modified">203   typedef KernOTSubTableHeader SubTableHeader;</span>
<span class="line-modified">204   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">205   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>












206 
<a name="36" id="anc36"></a><span class="line-modified">207   protected:</span>
<span class="line-modified">208   HBUINT16      version;        /* Version--0x0000u */</span>
<span class="line-added">209   HBUINT16      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-added">210   SubTable      firstSubTable;  /* Subtables. */</span>
<span class="line-added">211   public:</span>
<span class="line-added">212   DEFINE_SIZE_MIN (4);</span>
213 };
214 
<a name="37" id="anc37"></a><span class="line-modified">215 </span>
<span class="line-added">216 struct KernAATSubTableHeader</span>
217 {
<a name="38" id="anc38"></a><span class="line-modified">218   static constexpr bool apple = true;</span>
<span class="line-added">219   typedef AAT::ObsoleteTypes Types;</span>
220 
<a name="39" id="anc39"></a><span class="line-modified">221   unsigned int tuple_count () const { return 0; }</span>
<span class="line-added">222   bool is_horizontal () const       { return !(coverage &amp; Vertical); }</span>
223 
<a name="40" id="anc40"></a><span class="line-modified">224   enum Coverage</span>
225   {
<a name="41" id="anc41"></a><span class="line-modified">226     Vertical    = 0x80u,</span>
<span class="line-modified">227     CrossStream = 0x40u,</span>
<span class="line-modified">228     Variation   = 0x20u,</span>
<span class="line-modified">229 </span>
<span class="line-modified">230     /* Not supported: */</span>
<span class="line-modified">231     Backwards   = 0x00u,</span>
















232   };
233 
<a name="42" id="anc42"></a><span class="line-modified">234   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-modified">235   {</span>
<span class="line-modified">236     TRACE_SANITIZE (this);</span>
<span class="line-modified">237     return_trace (c-&gt;check_struct (this));</span>
<span class="line-added">238   }</span>
<span class="line-added">239 </span>
<span class="line-added">240   public:</span>
<span class="line-added">241   HBUINT32      length;         /* Length of the subtable (including this header). */</span>
<span class="line-added">242   HBUINT8       coverage;       /* Coverage bits. */</span>
<span class="line-added">243   HBUINT8       format;         /* Subtable format. */</span>
<span class="line-added">244   HBUINT16      tupleIndex;     /* The tuple index (used for variations fonts).</span>
<span class="line-added">245                                * This value specifies which tuple this subtable covers.</span>
<span class="line-added">246                                * Note: We don&#39;t implement. */</span>
247   public:
<a name="43" id="anc43"></a><span class="line-modified">248   DEFINE_SIZE_STATIC (8);</span>
249 };
250 
<a name="44" id="anc44"></a><span class="line-modified">251 struct KernAAT : AAT::KerxTable&lt;KernAAT&gt;</span>
252 {
<a name="45" id="anc45"></a><span class="line-modified">253   friend struct AAT::KerxTable&lt;KernAAT&gt;;</span>
254 
<a name="46" id="anc46"></a><span class="line-modified">255   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
<span class="line-added">256   static constexpr unsigned minVersion = 0x00010000u;</span>
257 
<a name="47" id="anc47"></a><span class="line-modified">258   typedef KernAATSubTableHeader SubTableHeader;</span>
<span class="line-modified">259   typedef SubTableHeader::Types Types;</span>
<span class="line-modified">260   typedef KernSubTable&lt;SubTableHeader&gt; SubTable;</span>






















261 
262   protected:
<a name="48" id="anc48"></a><span class="line-modified">263   HBUINT32      version;        /* Version--0x00010000u */</span>
<span class="line-modified">264   HBUINT32      tableCount;     /* Number of subtables in the kerning table. */</span>
<span class="line-modified">265   SubTable      firstSubTable;  /* Subtables. */</span>
266   public:
<a name="49" id="anc49"></a><span class="line-modified">267   DEFINE_SIZE_MIN (8);</span>
268 };
269 
270 struct kern
271 {
<a name="50" id="anc50"></a><span class="line-modified">272   static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;</span>
273 
<a name="51" id="anc51"></a><span class="line-modified">274   bool has_data () const { return u.version32; }</span>
<span class="line-added">275   unsigned int get_type () const { return u.major; }</span>
<span class="line-added">276 </span>
<span class="line-added">277   bool has_state_machine () const</span>
278   {
<a name="52" id="anc52"></a><span class="line-modified">279     switch (get_type ()) {</span>
<span class="line-modified">280     case 0: return u.ot.has_state_machine ();</span>
<span class="line-modified">281     case 1: return u.aat.has_state_machine ();</span>
<span class="line-modified">282     default:return false;</span>
283     }
284   }
285 
<a name="53" id="anc53"></a><span class="line-modified">286   bool has_cross_stream () const</span>
287   {
<a name="54" id="anc54"></a><span class="line-modified">288     switch (get_type ()) {</span>
<span class="line-modified">289     case 0: return u.ot.has_cross_stream ();</span>
<span class="line-modified">290     case 1: return u.aat.has_cross_stream ();</span>
<span class="line-modified">291     default:return false;</span>


292     }
293   }
294 
<a name="55" id="anc55"></a><span class="line-modified">295   int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const</span>
296   {
<a name="56" id="anc56"></a><span class="line-modified">297     switch (get_type ()) {</span>
<span class="line-modified">298     case 0: return u.ot.get_h_kerning (left, right);</span>
<span class="line-modified">299     case 1: return u.aat.get_h_kerning (left, right);</span>
<span class="line-modified">300     default:return 0;</span>





301     }
<a name="57" id="anc57"></a><span class="line-added">302   }</span>
303 
<a name="58" id="anc58"></a><span class="line-modified">304   bool apply (AAT::hb_aat_apply_context_t *c) const</span>
<span class="line-modified">305   { return dispatch (c); }</span>
306 
<a name="59" id="anc59"></a><span class="line-modified">307   template &lt;typename context_t&gt;</span>
<span class="line-modified">308   typename context_t::return_t dispatch (context_t *c) const</span>
<span class="line-modified">309   {</span>
<span class="line-modified">310     unsigned int subtable_type = get_type ();</span>
<span class="line-modified">311     TRACE_DISPATCH (this, subtable_type);</span>
<span class="line-added">312     switch (subtable_type) {</span>
<span class="line-added">313     case 0:     return_trace (c-&gt;dispatch (u.ot));</span>
<span class="line-added">314     case 1:     return_trace (c-&gt;dispatch (u.aat));</span>
<span class="line-added">315     default:    return_trace (c-&gt;default_return_value ());</span>
<span class="line-added">316     }</span>
<span class="line-added">317   }</span>
<span class="line-added">318 </span>
<span class="line-added">319   bool sanitize (hb_sanitize_context_t *c) const</span>
<span class="line-added">320   {</span>
<span class="line-added">321     TRACE_SANITIZE (this);</span>
<span class="line-added">322     if (!u.version32.sanitize (c)) return_trace (false);</span>
<span class="line-added">323     return_trace (dispatch (c));</span>
<span class="line-added">324   }</span>
325 
326   protected:
327   union {
<a name="60" id="anc60"></a><span class="line-added">328   HBUINT32              version32;</span>
329   HBUINT16              major;
330   KernOT                ot;
331   KernAAT               aat;
332   } u;
333   public:
<a name="61" id="anc61"></a><span class="line-modified">334   DEFINE_SIZE_UNION (4, version32);</span>
335 };
336 
337 } /* namespace OT */
338 
339 
340 #endif /* HB_OT_KERN_TABLE_HH */
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfontmanager/harfbuzz/hb-ot-layout.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright © 1998-2004  David Turner and Werner Lemberg
   3  * Copyright © 2006  Behdad Esfahbod
   4  * Copyright © 2007,2008,2009  Red Hat, Inc.
   5  * Copyright © 2012,2013  Google, Inc.
   6  *
   7  *  This is part of HarfBuzz, a text shaping library.
   8  *
   9  * Permission is hereby granted, without written agreement and without
  10  * license or royalty fees, to use, copy, modify, and distribute this
  11  * software and its documentation for any purpose, provided that the
  12  * above copyright notice and the following two paragraphs appear in
  13  * all copies of this software.
  14  *
  15  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  16  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  17  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  18  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  19  * DAMAGE.
  20  *
  21  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  22  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  23  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  24  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  25  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  26  *
  27  * Red Hat Author(s): Behdad Esfahbod
  28  * Google Author(s): Behdad Esfahbod
  29  */
  30 
<a name="1" id="anc1"></a><span class="line-modified">  31 #include &quot;hb-open-type-private.hh&quot;</span>
<span class="line-modified">  32 #include &quot;hb-ot-layout-private.hh&quot;</span>
<span class="line-modified">  33 #include &quot;hb-ot-map-private.hh&quot;</span>
<span class="line-modified">  34 </span>




  35 #include &quot;hb-ot-layout-gdef-table.hh&quot;
  36 #include &quot;hb-ot-layout-gsub-table.hh&quot;
  37 #include &quot;hb-ot-layout-gpos-table.hh&quot;
<a name="2" id="anc2"></a><span class="line-modified">  38 </span>
<span class="line-modified">  39 // Just so we compile them; unused otherwise:</span>
<span class="line-removed">  40 #include &quot;hb-ot-layout-base-table.hh&quot;</span>
<span class="line-removed">  41 #include &quot;hb-ot-layout-jstf-table.hh&quot;</span>
<span class="line-removed">  42 #include &quot;hb-ot-color-colr-table.hh&quot;</span>
<span class="line-removed">  43 #include &quot;hb-ot-color-cpal-table.hh&quot;</span>
<span class="line-removed">  44 #include &quot;hb-ot-color-sbix-table.hh&quot;</span>
<span class="line-removed">  45 #include &quot;hb-ot-color-svg-table.hh&quot;</span>
  46 #include &quot;hb-ot-name-table.hh&quot;
<a name="3" id="anc3"></a><span class="line-modified">  47 #include &quot;hb-map-private.hh&quot;</span>
<span class="line-removed">  48 </span>
<span class="line-removed">  49 </span>
<span class="line-removed">  50 hb_ot_layout_t *</span>
<span class="line-removed">  51 _hb_ot_layout_create (hb_face_t *face)</span>
<span class="line-removed">  52 {</span>
<span class="line-removed">  53   hb_ot_layout_t *layout = (hb_ot_layout_t *) calloc (1, sizeof (hb_ot_layout_t));</span>
<span class="line-removed">  54   if (unlikely (!layout))</span>
<span class="line-removed">  55     return nullptr;</span>
<span class="line-removed">  56 </span>
<span class="line-removed">  57   layout-&gt;gdef_blob = OT::Sanitizer&lt;OT::GDEF&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GDEF));</span>
<span class="line-removed">  58   layout-&gt;gdef = layout-&gt;gdef_blob-&gt;as&lt;OT::GDEF&gt; ();</span>
  59 
<a name="4" id="anc4"></a><span class="line-modified">  60   layout-&gt;gsub_blob = OT::Sanitizer&lt;OT::GSUB&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GSUB));</span>
<span class="line-modified">  61   layout-&gt;gsub = layout-&gt;gsub_blob-&gt;as&lt;OT::GSUB&gt; ();</span>
  62 
<a name="5" id="anc5"></a><span class="line-removed">  63   layout-&gt;gpos_blob = OT::Sanitizer&lt;OT::GPOS&gt;().sanitize (face-&gt;reference_table (HB_OT_TAG_GPOS));</span>
<span class="line-removed">  64   layout-&gt;gpos = layout-&gt;gpos_blob-&gt;as&lt;OT::GPOS&gt; ();</span>
  65 
<a name="6" id="anc6"></a><span class="line-modified">  66   layout-&gt;math.init (face);</span>
<span class="line-modified">  67   layout-&gt;fvar.init (face);</span>
<span class="line-modified">  68   layout-&gt;avar.init (face);</span>
<span class="line-modified">  69 </span>
<span class="line-modified">  70   {</span>
<span class="line-modified">  71     /*</span>
<span class="line-modified">  72      * The ugly business of blacklisting individual fonts&#39; tables happen here!</span>
<span class="line-modified">  73      * See this thread for why we finally had to bend in and do this:</span>
<span class="line-removed">  74      * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">  75      */</span>
<span class="line-removed">  76     unsigned int gdef_len = layout-&gt;gdef_blob-&gt;length;</span>
<span class="line-removed">  77     unsigned int gsub_len = layout-&gt;gsub_blob-&gt;length;</span>
<span class="line-removed">  78     unsigned int gpos_len = layout-&gt;gpos_blob-&gt;length;</span>
<span class="line-removed">  79     if (0</span>
<span class="line-removed">  80       /* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf */</span>
<span class="line-removed">  81       || (442 == gdef_len &amp;&amp; 42038 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  82       /* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf */</span>
<span class="line-removed">  83       || (430 == gdef_len &amp;&amp; 40662 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  84       /* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf */</span>
<span class="line-removed">  85       || (442 == gdef_len &amp;&amp; 39116 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  86       /* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf */</span>
<span class="line-removed">  87       || (430 == gdef_len &amp;&amp; 39374 == gpos_len &amp;&amp; 2874 == gsub_len)</span>
<span class="line-removed">  88       /* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf */</span>
<span class="line-removed">  89       || (490 == gdef_len &amp;&amp; 41638 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">  90       /* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf */</span>
<span class="line-removed">  91       || (478 == gdef_len &amp;&amp; 41902 == gpos_len &amp;&amp; 3046 == gsub_len)</span>
<span class="line-removed">  92     )</span>
<span class="line-removed">  93     {</span>
<span class="line-removed">  94       /* In certain versions of Times New Roman Italic and Bold Italic,</span>
<span class="line-removed">  95        * ASCII double quotation mark U+0022, mapped to glyph 5, has wrong</span>
<span class="line-removed">  96        * glyph class 3 (mark) in GDEF.  Nuke the GDEF to avoid zero-width</span>
<span class="line-removed">  97        * double-quote.  See:</span>
<span class="line-removed">  98        * https://lists.freedesktop.org/archives/harfbuzz/2016-February/005489.html</span>
<span class="line-removed">  99        */</span>
<span class="line-removed"> 100      if (3 == layout-&gt;gdef-&gt;get_glyph_class (5))</span>
<span class="line-removed"> 101        layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed"> 102     }</span>
<span class="line-removed"> 103     else if (0</span>
<span class="line-removed"> 104       /* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 */</span>
<span class="line-removed"> 105       || (898 == gdef_len &amp;&amp; 46470 == gpos_len &amp;&amp; 12554 == gsub_len)</span>
<span class="line-removed"> 106       /* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 */</span>
<span class="line-removed"> 107       || (910 == gdef_len &amp;&amp; 47732 == gpos_len &amp;&amp; 12566 == gsub_len)</span>
<span class="line-removed"> 108       /* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 */</span>
<span class="line-removed"> 109       || (928 == gdef_len &amp;&amp; 59332 == gpos_len &amp;&amp; 23298 == gsub_len)</span>
<span class="line-removed"> 110       /* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 */</span>
<span class="line-removed"> 111       || (940 == gdef_len &amp;&amp; 60732 == gpos_len &amp;&amp; 23310 == gsub_len)</span>
<span class="line-removed"> 112       /* tahoma.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 113       || (964 == gdef_len &amp;&amp; 60072 == gpos_len &amp;&amp; 23836 == gsub_len)</span>
<span class="line-removed"> 114       /* tahomabd.ttf v6.04 from Windows 8.1 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 115       || (976 == gdef_len &amp;&amp; 61456 == gpos_len &amp;&amp; 23832 == gsub_len)</span>
<span class="line-removed"> 116       /* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 */</span>
<span class="line-removed"> 117       || (994 == gdef_len &amp;&amp; 60336 == gpos_len &amp;&amp; 24474 == gsub_len)</span>
<span class="line-removed"> 118       /* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 */</span>
<span class="line-removed"> 119       || (1006 == gdef_len &amp;&amp; 61740 == gpos_len &amp;&amp; 24470 == gsub_len)</span>
<span class="line-removed"> 120       /* tahoma.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 121       || (1006 == gdef_len &amp;&amp; 61346 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed"> 122       /* tahomabd.ttf v6.91 from Windows 10 x64, see https://bugzilla.mozilla.org/show_bug.cgi?id=1279925 */</span>
<span class="line-removed"> 123       || (1018 == gdef_len &amp;&amp; 62828 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed"> 124       /* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU */</span>
<span class="line-removed"> 125       || (1006 == gdef_len &amp;&amp; 61352 == gpos_len &amp;&amp; 24576 == gsub_len)</span>
<span class="line-removed"> 126       /* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU */</span>
<span class="line-removed"> 127       || (1018 == gdef_len &amp;&amp; 62834 == gpos_len &amp;&amp; 24572 == gsub_len)</span>
<span class="line-removed"> 128       /* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 */</span>
<span class="line-removed"> 129       || (832 == gdef_len &amp;&amp; 47162 == gpos_len &amp;&amp; 7324 == gsub_len)</span>
<span class="line-removed"> 130       /* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 */</span>
<span class="line-removed"> 131       || (844 == gdef_len &amp;&amp; 45474 == gpos_len &amp;&amp; 7302 == gsub_len)</span>
<span class="line-removed"> 132       /* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 */</span>
<span class="line-removed"> 133       || (180 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 13054 == gsub_len)</span>
<span class="line-removed"> 134       /* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 */</span>
<span class="line-removed"> 135       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12638 == gsub_len)</span>
<span class="line-removed"> 136       /* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 */</span>
<span class="line-removed"> 137       || (192 == gdef_len &amp;&amp; 7254 == gpos_len &amp;&amp; 12690 == gsub_len)</span>
<span class="line-removed"> 138       /* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21/otf/Cantarell-Regular.otf */</span>
<span class="line-removed"> 139       /* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21/otf/Cantarell-Oblique.otf */</span>
<span class="line-removed"> 140       || (188 == gdef_len &amp;&amp; 3852 == gpos_len &amp;&amp; 248 == gsub_len)</span>
<span class="line-removed"> 141       /* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21/otf/Cantarell-Bold.otf */</span>
<span class="line-removed"> 142       /* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21/otf/Cantarell-Bold-Oblique.otf */</span>
<span class="line-removed"> 143       || (188 == gdef_len &amp;&amp; 3426 == gpos_len &amp;&amp; 264 == gsub_len)</span>
<span class="line-removed"> 144       /* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80/Padauk.ttf RHEL 7.2 */</span>
<span class="line-removed"> 145       || (1058 == gdef_len &amp;&amp; 11818 == gpos_len &amp;&amp; 47032 == gsub_len)</span>
<span class="line-removed"> 146       /* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80/Padauk-Bold.ttf RHEL 7.2*/</span>
<span class="line-removed"> 147       || (1046 == gdef_len &amp;&amp; 12600 == gpos_len &amp;&amp; 47030 == gsub_len)</span>
<span class="line-removed"> 148       /* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80/Padauk.ttf Ubuntu 16.04 */</span>
<span class="line-removed"> 149       || (1058 == gdef_len &amp;&amp; 16770 == gpos_len &amp;&amp; 71796 == gsub_len)</span>
<span class="line-removed"> 150       /* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80/Padauk-Bold.ttf Ubuntu 16.04 */</span>
<span class="line-removed"> 151       || (1046 == gdef_len &amp;&amp; 17862 == gpos_len &amp;&amp; 71790 == gsub_len)</span>
<span class="line-removed"> 152       /* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80/Padauk-book.ttf */</span>
<span class="line-removed"> 153       || (1046 == gdef_len &amp;&amp; 17112 == gpos_len &amp;&amp; 71788 == gsub_len)</span>
<span class="line-removed"> 154       /* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80/Padauk-bookbold.ttf */</span>
<span class="line-removed"> 155       || (1058 == gdef_len &amp;&amp; 17514 == gpos_len &amp;&amp; 71794 == gsub_len)</span>
<span class="line-removed"> 156       /* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0/Padauk-book.ttf */</span>
<span class="line-removed"> 157       || (1330 == gdef_len &amp;&amp; 57938 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed"> 158       /* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0/Padauk-bookbold.ttf */</span>
<span class="line-removed"> 159       || (1330 == gdef_len &amp;&amp; 58972 == gpos_len &amp;&amp; 109904 == gsub_len)</span>
<span class="line-removed"> 160       /* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf</span>
<span class="line-removed"> 161        *  &quot;Padauk Regular&quot; &quot;Version 2.5&quot;, see https://crbug.com/681813 */</span>
<span class="line-removed"> 162       || (1004 == gdef_len &amp;&amp; 14836 == gpos_len &amp;&amp; 59092 == gsub_len)</span>
<span class="line-removed"> 163     )</span>
<span class="line-removed"> 164     {</span>
<span class="line-removed"> 165       /* Many versions of Tahoma have bad GDEF tables that incorrectly classify some spacing marks</span>
<span class="line-removed"> 166        * such as certain IPA symbols as glyph class 3. So do older versions of Microsoft Himalaya,</span>
<span class="line-removed"> 167        * and the version of Cantarell shipped by Ubuntu 16.04.</span>
<span class="line-removed"> 168        * Nuke the GDEF tables of these fonts to avoid unwanted width-zeroing.</span>
<span class="line-removed"> 169        * See https://bugzilla.mozilla.org/show_bug.cgi?id=1279925</span>
<span class="line-removed"> 170        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279693</span>
<span class="line-removed"> 171        *     https://bugzilla.mozilla.org/show_bug.cgi?id=1279875</span>
<span class="line-removed"> 172        */</span>
<span class="line-removed"> 173       layout-&gt;gdef = &amp;Null(OT::GDEF);</span>
<span class="line-removed"> 174     }</span>
<span class="line-removed"> 175   }</span>
 176 
<a name="7" id="anc7"></a><span class="line-removed"> 177   layout-&gt;gsub_lookup_count = layout-&gt;gsub-&gt;get_lookup_count ();</span>
<span class="line-removed"> 178   layout-&gt;gpos_lookup_count = layout-&gt;gpos-&gt;get_lookup_count ();</span>
 179 
<a name="8" id="anc8"></a><span class="line-modified"> 180   layout-&gt;gsub_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gsub-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>
<span class="line-modified"> 181   layout-&gt;gpos_accels = (hb_ot_layout_lookup_accelerator_t *) calloc (layout-&gt;gpos-&gt;get_lookup_count (), sizeof (hb_ot_layout_lookup_accelerator_t));</span>

 182 
<a name="9" id="anc9"></a><span class="line-modified"> 183   if (unlikely ((layout-&gt;gsub_lookup_count &amp;&amp; !layout-&gt;gsub_accels) ||</span>
<span class="line-modified"> 184                 (layout-&gt;gpos_lookup_count &amp;&amp; !layout-&gt;gpos_accels)))</span>
<span class="line-modified"> 185   {</span>
<span class="line-modified"> 186     _hb_ot_layout_destroy (layout);</span>
<span class="line-modified"> 187     return nullptr;</span>
<span class="line-removed"> 188   }</span>
 189 
<a name="10" id="anc10"></a><span class="line-modified"> 190   for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-modified"> 191     layout-&gt;gsub_accels[i].init (layout-&gt;gsub-&gt;get_lookup (i));</span>
<span class="line-modified"> 192   for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-modified"> 193     layout-&gt;gpos_accels[i].init (layout-&gt;gpos-&gt;get_lookup (i));</span>

 194 
<a name="11" id="anc11"></a><span class="line-modified"> 195   return layout;</span>



 196 }
 197 
 198 void
<a name="12" id="anc12"></a><span class="line-modified"> 199 _hb_ot_layout_destroy (hb_ot_layout_t *layout)</span>


 200 {
<a name="13" id="anc13"></a><span class="line-modified"> 201   if (layout-&gt;gsub_accels)</span>
<span class="line-modified"> 202     for (unsigned int i = 0; i &lt; layout-&gt;gsub_lookup_count; i++)</span>
<span class="line-removed"> 203       layout-&gt;gsub_accels[i].fini ();</span>
<span class="line-removed"> 204   if (layout-&gt;gpos_accels)</span>
<span class="line-removed"> 205     for (unsigned int i = 0; i &lt; layout-&gt;gpos_lookup_count; i++)</span>
<span class="line-removed"> 206       layout-&gt;gpos_accels[i].fini ();</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208   free (layout-&gt;gsub_accels);</span>
<span class="line-removed"> 209   free (layout-&gt;gpos_accels);</span>
 210 
<a name="14" id="anc14"></a><span class="line-modified"> 211   hb_blob_destroy (layout-&gt;gdef_blob);</span>
<span class="line-removed"> 212   hb_blob_destroy (layout-&gt;gsub_blob);</span>
<span class="line-removed"> 213   hb_blob_destroy (layout-&gt;gpos_blob);</span>
 214 
<a name="15" id="anc15"></a><span class="line-modified"> 215   layout-&gt;math.fini ();</span>
<span class="line-removed"> 216   layout-&gt;fvar.fini ();</span>
<span class="line-removed"> 217   layout-&gt;avar.fini ();</span>
<span class="line-removed"> 218 </span>
<span class="line-removed"> 219   free (layout);</span>
 220 }
 221 
<a name="16" id="anc16"></a><span class="line-removed"> 222 // static inline const OT::BASE&amp;</span>
<span class="line-removed"> 223 // _get_base (hb_face_t *face)</span>
<span class="line-removed"> 224 // {</span>
<span class="line-removed"> 225 //   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::BASE);</span>
<span class="line-removed"> 226 //   hb_ot_layout_t * layout = hb_ot_layout_from_face (face);</span>
<span class="line-removed"> 227 //   return *(layout-&gt;base.get ());</span>
<span class="line-removed"> 228 // }</span>
 229 
<a name="17" id="anc17"></a><span class="line-modified"> 230 static inline const OT::GDEF&amp;</span>
<span class="line-modified"> 231 _get_gdef (hb_face_t *face)</span>
<span class="line-modified"> 232 {</span>
<span class="line-modified"> 233   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GDEF);</span>
<span class="line-modified"> 234   return *hb_ot_layout_from_face (face)-&gt;gdef;</span>
<span class="line-modified"> 235 }</span>
<span class="line-modified"> 236 static inline const OT::GSUB&amp;</span>
<span class="line-removed"> 237 _get_gsub (hb_face_t *face)</span>
 238 {
<a name="18" id="anc18"></a><span class="line-modified"> 239   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GSUB);</span>
<span class="line-modified"> 240   return *hb_ot_layout_from_face (face)-&gt;gsub;</span>































































































 241 }
<a name="19" id="anc19"></a><span class="line-modified"> 242 static inline const OT::GPOS&amp;</span>
<span class="line-modified"> 243 _get_gpos (hb_face_t *face)</span>


 244 {
<a name="20" id="anc20"></a><span class="line-modified"> 245   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return Null(OT::GPOS);</span>
<span class="line-modified"> 246   return *hb_ot_layout_from_face (face)-&gt;gpos;</span>








 247 }
 248 
<a name="21" id="anc21"></a><span class="line-modified"> 249 /*</span>
<span class="line-removed"> 250  * GDEF</span>
<span class="line-removed"> 251  */</span>
 252 
 253 hb_bool_t
 254 hb_ot_layout_has_glyph_classes (hb_face_t *face)
 255 {
<a name="22" id="anc22"></a><span class="line-modified"> 256   return _get_gdef (face).has_glyph_classes ();</span>
 257 }
 258 
 259 /**
 260  * hb_ot_layout_get_glyph_class:
 261  *
 262  * Since: 0.9.7
 263  **/
 264 hb_ot_layout_glyph_class_t
 265 hb_ot_layout_get_glyph_class (hb_face_t      *face,
 266                               hb_codepoint_t  glyph)
 267 {
<a name="23" id="anc23"></a><span class="line-modified"> 268   return (hb_ot_layout_glyph_class_t) _get_gdef (face).get_glyph_class (glyph);</span>
 269 }
 270 
 271 /**
 272  * hb_ot_layout_get_glyphs_in_class:
 273  *
 274  * Since: 0.9.7
 275  **/
 276 void
 277 hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,
 278                                   hb_ot_layout_glyph_class_t  klass,
 279                                   hb_set_t                   *glyphs /* OUT */)
 280 {
<a name="24" id="anc24"></a><span class="line-modified"> 281   return _get_gdef (face).get_glyphs_in_class (klass, glyphs);</span>
 282 }
 283 
 284 unsigned int
 285 hb_ot_layout_get_attach_points (hb_face_t      *face,
 286                                 hb_codepoint_t  glyph,
 287                                 unsigned int    start_offset,
 288                                 unsigned int   *point_count /* IN/OUT */,
 289                                 unsigned int   *point_array /* OUT */)
 290 {
<a name="25" id="anc25"></a><span class="line-modified"> 291   return _get_gdef (face).get_attach_points (glyph, start_offset, point_count, point_array);</span>



 292 }
 293 
 294 unsigned int
 295 hb_ot_layout_get_ligature_carets (hb_font_t      *font,
 296                                   hb_direction_t  direction,
 297                                   hb_codepoint_t  glyph,
 298                                   unsigned int    start_offset,
 299                                   unsigned int   *caret_count /* IN/OUT */,
 300                                   hb_position_t  *caret_array /* OUT */)
 301 {
<a name="26" id="anc26"></a><span class="line-modified"> 302   return _get_gdef (font-&gt;face).get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);</span>








 303 }
 304 
 305 
 306 /*
 307  * GSUB/GPOS
 308  */
 309 
<a name="27" id="anc27"></a>































 310 static const OT::GSUBGPOS&amp;
 311 get_gsubgpos_table (hb_face_t *face,
 312                     hb_tag_t   table_tag)
 313 {
 314   switch (table_tag) {
<a name="28" id="anc28"></a><span class="line-modified"> 315     case HB_OT_TAG_GSUB: return _get_gsub (face);</span>
<span class="line-modified"> 316     case HB_OT_TAG_GPOS: return _get_gpos (face);</span>
 317     default:             return Null(OT::GSUBGPOS);
 318   }
 319 }
 320 
 321 
 322 unsigned int
 323 hb_ot_layout_table_get_script_tags (hb_face_t    *face,
 324                                     hb_tag_t      table_tag,
 325                                     unsigned int  start_offset,
 326                                     unsigned int *script_count /* IN/OUT */,
<a name="29" id="anc29"></a><span class="line-modified"> 327                                     hb_tag_t     *script_tags /* OUT */)</span>
 328 {
 329   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 330 
 331   return g.get_script_tags (start_offset, script_count, script_tags);
 332 }
 333 
 334 #define HB_OT_TAG_LATIN_SCRIPT          HB_TAG (&#39;l&#39;, &#39;a&#39;, &#39;t&#39;, &#39;n&#39;)
 335 
 336 hb_bool_t
 337 hb_ot_layout_table_find_script (hb_face_t    *face,
 338                                 hb_tag_t      table_tag,
 339                                 hb_tag_t      script_tag,
 340                                 unsigned int *script_index)
 341 {
 342   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 343   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 344 
 345   if (g.find_script_index (script_tag, script_index))
 346     return true;
 347 
 348   /* try finding &#39;DFLT&#39; */
 349   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))
 350     return false;
 351 
 352   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :(.
 353    * including many versions of DejaVu Sans Mono! */
 354   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))
 355     return false;
 356 
 357   /* try with &#39;latn&#39;; some old fonts put their features there even though
 358      they&#39;re really trying to support Thai, for example :( */
 359   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))
 360     return false;
 361 
 362   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 363   return false;
 364 }
 365 
 366 hb_bool_t
 367 hb_ot_layout_table_choose_script (hb_face_t      *face,
 368                                   hb_tag_t        table_tag,
 369                                   const hb_tag_t *script_tags,
 370                                   unsigned int   *script_index,
 371                                   hb_tag_t       *chosen_script)
<a name="30" id="anc30"></a>

















 372 {
 373   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), &quot;&quot;);
 374   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
<a name="31" id="anc31"></a>
 375 
<a name="32" id="anc32"></a><span class="line-modified"> 376   while (*script_tags)</span>
 377   {
<a name="33" id="anc33"></a><span class="line-modified"> 378     if (g.find_script_index (*script_tags, script_index)) {</span>

 379       if (chosen_script)
<a name="34" id="anc34"></a><span class="line-modified"> 380         *chosen_script = *script_tags;</span>
 381       return true;
 382     }
<a name="35" id="anc35"></a><span class="line-removed"> 383     script_tags++;</span>
 384   }
 385 
 386   /* try finding &#39;DFLT&#39; */
 387   if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {
 388     if (chosen_script)
 389       *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;
 390     return false;
 391   }
 392 
 393   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */
 394   if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {
 395     if (chosen_script)
 396       *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;
 397     return false;
 398   }
 399 
 400   /* try with &#39;latn&#39;; some old fonts put their features there even though
 401      they&#39;re really trying to support Thai, for example :( */
 402   if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {
 403     if (chosen_script)
 404       *chosen_script = HB_OT_TAG_LATIN_SCRIPT;
 405     return false;
 406   }
 407 
 408   if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 409   if (chosen_script)
 410     *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;
 411   return false;
 412 }
 413 
 414 unsigned int
 415 hb_ot_layout_table_get_feature_tags (hb_face_t    *face,
 416                                      hb_tag_t      table_tag,
 417                                      unsigned int  start_offset,
 418                                      unsigned int *feature_count /* IN/OUT */,
<a name="36" id="anc36"></a><span class="line-modified"> 419                                      hb_tag_t     *feature_tags /* OUT */)</span>
 420 {
 421   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 422 
 423   return g.get_feature_tags (start_offset, feature_count, feature_tags);
 424 }
 425 
<a name="37" id="anc37"></a><span class="line-modified"> 426 hb_bool_t</span>
 427 hb_ot_layout_table_find_feature (hb_face_t    *face,
 428                                  hb_tag_t      table_tag,
 429                                  hb_tag_t      feature_tag,
 430                                  unsigned int *feature_index)
 431 {
 432   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 433   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 434 
 435   unsigned int num_features = g.get_feature_count ();
 436   for (unsigned int i = 0; i &lt; num_features; i++)
 437   {
 438     if (feature_tag == g.get_feature_tag (i)) {
 439       if (feature_index) *feature_index = i;
 440       return true;
 441     }
 442   }
 443 
 444   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 445   return false;
 446 }
 447 
 448 
 449 unsigned int
 450 hb_ot_layout_script_get_language_tags (hb_face_t    *face,
 451                                        hb_tag_t      table_tag,
 452                                        unsigned int  script_index,
 453                                        unsigned int  start_offset,
 454                                        unsigned int *language_count /* IN/OUT */,
<a name="38" id="anc38"></a><span class="line-modified"> 455                                        hb_tag_t     *language_tags /* OUT */)</span>
 456 {
 457   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
 458 
 459   return s.get_lang_sys_tags (start_offset, language_count, language_tags);
 460 }
 461 
 462 hb_bool_t
 463 hb_ot_layout_script_find_language (hb_face_t    *face,
 464                                    hb_tag_t      table_tag,
 465                                    unsigned int  script_index,
 466                                    hb_tag_t      language_tag,
 467                                    unsigned int *language_index)
<a name="39" id="anc39"></a>




















 468 {
 469   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), &quot;&quot;);
 470   const OT::Script &amp;s = get_gsubgpos_table (face, table_tag).get_script (script_index);
<a name="40" id="anc40"></a>
 471 
<a name="41" id="anc41"></a><span class="line-modified"> 472   if (s.find_lang_sys_index (language_tag, language_index))</span>
<span class="line-modified"> 473     return true;</span>



 474 
<a name="42" id="anc42"></a><span class="line-modified"> 475   /* try with &#39;dflt&#39;; MS site has had typos and many fonts use it now :( */</span>
 476   if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))
 477     return false;
 478 
 479   if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;
 480   return false;
 481 }
 482 
 483 hb_bool_t
 484 hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,
 485                                                   hb_tag_t      table_tag,
 486                                                   unsigned int  script_index,
 487                                                   unsigned int  language_index,
 488                                                   unsigned int *feature_index)
 489 {
 490   return hb_ot_layout_language_get_required_feature (face,
 491                                                      table_tag,
 492                                                      script_index,
 493                                                      language_index,
 494                                                      feature_index,
 495                                                      nullptr);
 496 }
 497 
 498 /**
 499  * hb_ot_layout_language_get_required_feature:
 500  *
 501  * Since: 0.9.30
 502  **/
 503 hb_bool_t
 504 hb_ot_layout_language_get_required_feature (hb_face_t    *face,
 505                                             hb_tag_t      table_tag,
 506                                             unsigned int  script_index,
 507                                             unsigned int  language_index,
 508                                             unsigned int *feature_index,
 509                                             hb_tag_t     *feature_tag)
 510 {
 511   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 512   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 513 
 514   unsigned int index = l.get_required_feature_index ();
 515   if (feature_index) *feature_index = index;
 516   if (feature_tag) *feature_tag = g.get_feature_tag (index);
 517 
 518   return l.has_required_feature ();
 519 }
 520 
 521 unsigned int
 522 hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,
 523                                            hb_tag_t      table_tag,
 524                                            unsigned int  script_index,
 525                                            unsigned int  language_index,
 526                                            unsigned int  start_offset,
<a name="43" id="anc43"></a><span class="line-modified"> 527                                            unsigned int *feature_count /* IN/OUT */,</span>
 528                                            unsigned int *feature_indexes /* OUT */)
 529 {
 530   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 531   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 532 
 533   return l.get_feature_indexes (start_offset, feature_count, feature_indexes);
 534 }
 535 
 536 unsigned int
 537 hb_ot_layout_language_get_feature_tags (hb_face_t    *face,
 538                                         hb_tag_t      table_tag,
 539                                         unsigned int  script_index,
 540                                         unsigned int  language_index,
 541                                         unsigned int  start_offset,
 542                                         unsigned int *feature_count /* IN/OUT */,
<a name="44" id="anc44"></a><span class="line-modified"> 543                                         hb_tag_t     *feature_tags /* OUT */)</span>
 544 {
 545   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 546   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 547 
 548   static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), &quot;&quot;);
 549   unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);
 550 
 551   if (feature_tags) {
 552     unsigned int count = *feature_count;
 553     for (unsigned int i = 0; i &lt; count; i++)
 554       feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);
 555   }
 556 
 557   return ret;
 558 }
 559 
 560 
 561 hb_bool_t
 562 hb_ot_layout_language_find_feature (hb_face_t    *face,
 563                                     hb_tag_t      table_tag,
 564                                     unsigned int  script_index,
 565                                     unsigned int  language_index,
 566                                     hb_tag_t      feature_tag,
 567                                     unsigned int *feature_index)
 568 {
 569   static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), &quot;&quot;);
 570   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 571   const OT::LangSys &amp;l = g.get_script (script_index).get_lang_sys (language_index);
 572 
 573   unsigned int num_features = l.get_feature_count ();
 574   for (unsigned int i = 0; i &lt; num_features; i++) {
 575     unsigned int f_index = l.get_feature_index (i);
 576 
 577     if (feature_tag == g.get_feature_tag (f_index)) {
 578       if (feature_index) *feature_index = f_index;
 579       return true;
 580     }
 581   }
 582 
 583   if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;
 584   return false;
 585 }
 586 
 587 /**
 588  * hb_ot_layout_feature_get_lookups:
 589  *
 590  * Since: 0.9.7
 591  **/
 592 unsigned int
 593 hb_ot_layout_feature_get_lookups (hb_face_t    *face,
 594                                   hb_tag_t      table_tag,
 595                                   unsigned int  feature_index,
 596                                   unsigned int  start_offset,
<a name="45" id="anc45"></a><span class="line-modified"> 597                                   unsigned int *lookup_count /* IN/OUT */,</span>
 598                                   unsigned int *lookup_indexes /* OUT */)
 599 {
 600   return hb_ot_layout_feature_with_variations_get_lookups (face,
 601                                                            table_tag,
 602                                                            feature_index,
 603                                                            HB_OT_LAYOUT_NO_VARIATIONS_INDEX,
 604                                                            start_offset,
 605                                                            lookup_count,
 606                                                            lookup_indexes);
 607 }
 608 
 609 /**
 610  * hb_ot_layout_table_get_lookup_count:
 611  *
 612  * Since: 0.9.22
 613  **/
 614 unsigned int
 615 hb_ot_layout_table_get_lookup_count (hb_face_t    *face,
 616                                      hb_tag_t      table_tag)
 617 {
<a name="46" id="anc46"></a><span class="line-modified"> 618   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return 0;</span>
<span class="line-removed"> 619   switch (table_tag)</span>
<span class="line-removed"> 620   {</span>
<span class="line-removed"> 621     case HB_OT_TAG_GSUB:</span>
<span class="line-removed"> 622     {</span>
<span class="line-removed"> 623       return hb_ot_layout_from_face (face)-&gt;gsub_lookup_count;</span>
<span class="line-removed"> 624     }</span>
<span class="line-removed"> 625     case HB_OT_TAG_GPOS:</span>
<span class="line-removed"> 626     {</span>
<span class="line-removed"> 627       return hb_ot_layout_from_face (face)-&gt;gpos_lookup_count;</span>
<span class="line-removed"> 628     }</span>
<span class="line-removed"> 629   }</span>
<span class="line-removed"> 630   return 0;</span>
 631 }
 632 
<a name="47" id="anc47"></a><span class="line-modified"> 633 static void</span>
<span class="line-modified"> 634 _hb_ot_layout_collect_lookups_lookups (hb_face_t      *face,</span>
<span class="line-removed"> 635                                        hb_tag_t        table_tag,</span>
<span class="line-removed"> 636                                        unsigned int    feature_index,</span>
<span class="line-removed"> 637                                        hb_set_t       *lookup_indexes /* OUT */)</span>
 638 {
<a name="48" id="anc48"></a><span class="line-modified"> 639   unsigned int lookup_indices[32];</span>
<span class="line-modified"> 640   unsigned int offset, len;</span>
<span class="line-modified"> 641 </span>
<span class="line-modified"> 642   offset = 0;</span>
<span class="line-modified"> 643   do {</span>
<span class="line-modified"> 644     len = ARRAY_LENGTH (lookup_indices);</span>
<span class="line-modified"> 645     hb_ot_layout_feature_get_lookups (face,</span>
<span class="line-modified"> 646                                       table_tag,</span>
<span class="line-modified"> 647                                       feature_index,</span>
<span class="line-modified"> 648                                       offset, &amp;len,</span>
<span class="line-modified"> 649                                       lookup_indices);</span>
<span class="line-modified"> 650 </span>
<span class="line-modified"> 651     for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-modified"> 652       lookup_indexes-&gt;add (lookup_indices[i]);</span>
<span class="line-modified"> 653 </span>
<span class="line-modified"> 654     offset += len;</span>
<span class="line-modified"> 655   } while (len == ARRAY_LENGTH (lookup_indices));</span>
<span class="line-modified"> 656 }</span>






































 657 
 658 static void
<a name="49" id="anc49"></a><span class="line-modified"> 659 _hb_ot_layout_collect_lookups_features (hb_face_t      *face,</span>
<span class="line-modified"> 660                                         hb_tag_t        table_tag,</span>
<span class="line-modified"> 661                                         unsigned int    script_index,</span>
<span class="line-removed"> 662                                         unsigned int    language_index,</span>
<span class="line-removed"> 663                                         const hb_tag_t *features,</span>
<span class="line-removed"> 664                                         hb_set_t       *lookup_indexes /* OUT */)</span>
 665 {
<a name="50" id="anc50"></a>

 666   if (!features)
 667   {
<a name="51" id="anc51"></a><span class="line-modified"> 668     unsigned int required_feature_index;</span>
<span class="line-modified"> 669     if (hb_ot_layout_language_get_required_feature (face,</span>
<span class="line-modified"> 670                                                     table_tag,</span>
<span class="line-modified"> 671                                                     script_index,</span>
<span class="line-modified"> 672                                                     language_index,</span>
<span class="line-removed"> 673                                                     &amp;required_feature_index,</span>
<span class="line-removed"> 674                                                     nullptr))</span>
<span class="line-removed"> 675       _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed"> 676                                              table_tag,</span>
<span class="line-removed"> 677                                              required_feature_index,</span>
<span class="line-removed"> 678                                              lookup_indexes);</span>
<span class="line-removed"> 679 </span>
<span class="line-removed"> 680     /* All features */</span>
<span class="line-removed"> 681     unsigned int feature_indices[32];</span>
<span class="line-removed"> 682     unsigned int offset, len;</span>
<span class="line-removed"> 683 </span>
<span class="line-removed"> 684     offset = 0;</span>
<span class="line-removed"> 685     do {</span>
<span class="line-removed"> 686       len = ARRAY_LENGTH (feature_indices);</span>
<span class="line-removed"> 687       hb_ot_layout_language_get_feature_indexes (face,</span>
<span class="line-removed"> 688                                                  table_tag,</span>
<span class="line-removed"> 689                                                  script_index,</span>
<span class="line-removed"> 690                                                  language_index,</span>
<span class="line-removed"> 691                                                  offset, &amp;len,</span>
<span class="line-removed"> 692                                                  feature_indices);</span>
<span class="line-removed"> 693 </span>
<span class="line-removed"> 694       for (unsigned int i = 0; i &lt; len; i++)</span>
<span class="line-removed"> 695         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-removed"> 696                                                table_tag,</span>
<span class="line-removed"> 697                                                feature_indices[i],</span>
<span class="line-removed"> 698                                                lookup_indexes);</span>
<span class="line-removed"> 699 </span>
<span class="line-removed"> 700       offset += len;</span>
<span class="line-removed"> 701     } while (len == ARRAY_LENGTH (feature_indices));</span>
 702   }
 703   else
 704   {
<a name="52" id="anc52"></a>
 705     for (; *features; features++)
 706     {
<a name="53" id="anc53"></a><span class="line-modified"> 707       unsigned int feature_index;</span>
<span class="line-modified"> 708       if (hb_ot_layout_language_find_feature (face,</span>
<span class="line-modified"> 709                                               table_tag,</span>
<span class="line-modified"> 710                                               script_index,</span>
<span class="line-modified"> 711                                               language_index,</span>
<span class="line-modified"> 712                                               *features,</span>
<span class="line-modified"> 713                                               &amp;feature_index))</span>
<span class="line-modified"> 714         _hb_ot_layout_collect_lookups_lookups (face,</span>
<span class="line-modified"> 715                                                table_tag,</span>
<span class="line-modified"> 716                                                feature_index,</span>
<span class="line-modified"> 717                                                lookup_indexes);</span>

 718     }
 719   }
 720 }
 721 
 722 static void
<a name="54" id="anc54"></a><span class="line-modified"> 723 _hb_ot_layout_collect_lookups_languages (hb_face_t      *face,</span>
<span class="line-modified"> 724                                          hb_tag_t        table_tag,</span>
<span class="line-modified"> 725                                          unsigned int    script_index,</span>
<span class="line-modified"> 726                                          const hb_tag_t *languages,</span>
<span class="line-removed"> 727                                          const hb_tag_t *features,</span>
<span class="line-removed"> 728                                          hb_set_t       *lookup_indexes /* OUT */)</span>
 729 {
<a name="55" id="anc55"></a><span class="line-modified"> 730   _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed"> 731                                           table_tag,</span>
<span class="line-removed"> 732                                           script_index,</span>
<span class="line-removed"> 733                                           HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX,</span>
<span class="line-removed"> 734                                           features,</span>
<span class="line-removed"> 735                                           lookup_indexes);</span>
 736 
 737   if (!languages)
 738   {
<a name="56" id="anc56"></a><span class="line-modified"> 739     /* All languages */</span>
<span class="line-modified"> 740     unsigned int count = hb_ot_layout_script_get_language_tags (face,</span>
<span class="line-modified"> 741                                                                 table_tag,</span>
<span class="line-modified"> 742                                                                 script_index,</span>
<span class="line-modified"> 743                                                                 0, nullptr, nullptr);</span>


 744     for (unsigned int language_index = 0; language_index &lt; count; language_index++)
<a name="57" id="anc57"></a><span class="line-modified"> 745       _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-modified"> 746                                               table_tag,</span>
<span class="line-modified"> 747                                               script_index,</span>
<span class="line-removed"> 748                                               language_index,</span>
<span class="line-removed"> 749                                               features,</span>
<span class="line-removed"> 750                                               lookup_indexes);</span>
 751   }
 752   else
 753   {
 754     for (; *languages; languages++)
 755     {
 756       unsigned int language_index;
<a name="58" id="anc58"></a><span class="line-modified"> 757       if (hb_ot_layout_script_find_language (face,</span>
<span class="line-modified"> 758                                              table_tag,</span>
<span class="line-modified"> 759                                              script_index,</span>
<span class="line-modified"> 760                                              *languages,</span>
<span class="line-removed"> 761                                              &amp;language_index))</span>
<span class="line-removed"> 762         _hb_ot_layout_collect_lookups_features (face,</span>
<span class="line-removed"> 763                                                 table_tag,</span>
<span class="line-removed"> 764                                                 script_index,</span>
<span class="line-removed"> 765                                                 language_index,</span>
<span class="line-removed"> 766                                                 features,</span>
<span class="line-removed"> 767                                                 lookup_indexes);</span>
 768     }
 769   }
 770 }
 771 
 772 /**
<a name="59" id="anc59"></a><span class="line-modified"> 773  * hb_ot_layout_collect_lookups:</span>
 774  *
<a name="60" id="anc60"></a><span class="line-modified"> 775  * Since: 0.9.8</span>
 776  **/
 777 void
<a name="61" id="anc61"></a><span class="line-modified"> 778 hb_ot_layout_collect_lookups (hb_face_t      *face,</span>
<span class="line-modified"> 779                               hb_tag_t        table_tag,</span>
<span class="line-modified"> 780                               const hb_tag_t *scripts,</span>
<span class="line-modified"> 781                               const hb_tag_t *languages,</span>
<span class="line-modified"> 782                               const hb_tag_t *features,</span>
<span class="line-modified"> 783                               hb_set_t       *lookup_indexes /* OUT */)</span>
 784 {
<a name="62" id="anc62"></a>
 785   if (!scripts)
 786   {
<a name="63" id="anc63"></a><span class="line-modified"> 787     /* All scripts */</span>
<span class="line-modified"> 788     unsigned int count = hb_ot_layout_table_get_script_tags (face,</span>
<span class="line-removed"> 789                                                              table_tag,</span>
<span class="line-removed"> 790                                                              0, nullptr, nullptr);</span>
 791     for (unsigned int script_index = 0; script_index &lt; count; script_index++)
<a name="64" id="anc64"></a><span class="line-modified"> 792       _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-modified"> 793                                                table_tag,</span>
<span class="line-modified"> 794                                                script_index,</span>
<span class="line-modified"> 795                                                languages,</span>
<span class="line-removed"> 796                                                features,</span>
<span class="line-removed"> 797                                                lookup_indexes);</span>
 798   }
 799   else
 800   {
 801     for (; *scripts; scripts++)
 802     {
 803       unsigned int script_index;
<a name="65" id="anc65"></a><span class="line-modified"> 804       if (hb_ot_layout_table_find_script (face,</span>
<span class="line-modified"> 805                                           table_tag,</span>
<span class="line-modified"> 806                                           *scripts,</span>
<span class="line-modified"> 807                                           &amp;script_index))</span>
<span class="line-modified"> 808         _hb_ot_layout_collect_lookups_languages (face,</span>
<span class="line-removed"> 809                                                  table_tag,</span>
<span class="line-removed"> 810                                                  script_index,</span>
<span class="line-removed"> 811                                                  languages,</span>
<span class="line-removed"> 812                                                  features,</span>
<span class="line-removed"> 813                                                  lookup_indexes);</span>
 814     }
 815   }
 816 }
 817 
<a name="66" id="anc66"></a>






















 818 /**
 819  * hb_ot_layout_lookup_collect_glyphs:
 820  *
 821  * Since: 0.9.7
 822  **/
 823 void
 824 hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,
 825                                     hb_tag_t      table_tag,
 826                                     unsigned int  lookup_index,
<a name="67" id="anc67"></a><span class="line-modified"> 827                                     hb_set_t     *glyphs_before, /* OUT. May be nullptr */</span>
<span class="line-modified"> 828                                     hb_set_t     *glyphs_input,  /* OUT. May be nullptr */</span>
<span class="line-modified"> 829                                     hb_set_t     *glyphs_after,  /* OUT. May be nullptr */</span>
<span class="line-modified"> 830                                     hb_set_t     *glyphs_output  /* OUT. May be nullptr */)</span>
 831 {
<a name="68" id="anc68"></a><span class="line-removed"> 832   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return;</span>
<span class="line-removed"> 833 </span>
 834   OT::hb_collect_glyphs_context_t c (face,
 835                                      glyphs_before,
 836                                      glyphs_input,
 837                                      glyphs_after,
 838                                      glyphs_output);
 839 
 840   switch (table_tag)
 841   {
 842     case HB_OT_TAG_GSUB:
 843     {
<a name="69" id="anc69"></a><span class="line-modified"> 844       const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
 845       l.collect_glyphs (&amp;c);
 846       return;
 847     }
 848     case HB_OT_TAG_GPOS:
 849     {
<a name="70" id="anc70"></a><span class="line-modified"> 850       const OT::PosLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gpos-&gt;get_lookup (lookup_index);</span>
 851       l.collect_glyphs (&amp;c);
 852       return;
 853     }
 854   }
 855 }
 856 
 857 
 858 /* Variations support */
 859 
 860 hb_bool_t
 861 hb_ot_layout_table_find_feature_variations (hb_face_t    *face,
 862                                             hb_tag_t      table_tag,
 863                                             const int    *coords,
 864                                             unsigned int  num_coords,
 865                                             unsigned int *variations_index /* out */)
 866 {
 867   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 868 
 869   return g.find_variations_index (coords, num_coords, variations_index);
 870 }
 871 
 872 unsigned int
 873 hb_ot_layout_feature_with_variations_get_lookups (hb_face_t    *face,
 874                                                   hb_tag_t      table_tag,
 875                                                   unsigned int  feature_index,
 876                                                   unsigned int  variations_index,
 877                                                   unsigned int  start_offset,
 878                                                   unsigned int *lookup_count /* IN/OUT */,
 879                                                   unsigned int *lookup_indexes /* OUT */)
 880 {
 881   static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), &quot;&quot;);
 882   const OT::GSUBGPOS &amp;g = get_gsubgpos_table (face, table_tag);
 883 
 884   const OT::Feature &amp;f = g.get_feature_variation (feature_index, variations_index);
 885 
 886   return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);
 887 }
 888 
 889 
 890 /*
 891  * OT::GSUB
 892  */
 893 
 894 hb_bool_t
 895 hb_ot_layout_has_substitution (hb_face_t *face)
 896 {
<a name="71" id="anc71"></a><span class="line-modified"> 897   return &amp;_get_gsub (face) != &amp;Null(OT::GSUB);</span>
 898 }
 899 
 900 /**
 901  * hb_ot_layout_lookup_would_substitute:
 902  *
 903  * Since: 0.9.7
 904  **/
 905 hb_bool_t
 906 hb_ot_layout_lookup_would_substitute (hb_face_t            *face,
 907                                       unsigned int          lookup_index,
 908                                       const hb_codepoint_t *glyphs,
 909                                       unsigned int          glyphs_length,
 910                                       hb_bool_t             zero_context)
 911 {
<a name="72" id="anc72"></a><span class="line-modified"> 912   if (unlikely (!hb_ot_shaper_face_data_ensure (face))) return false;</span>
<span class="line-modified"> 913   return hb_ot_layout_lookup_would_substitute_fast (face, lookup_index, glyphs, glyphs_length, zero_context);</span>


 914 }
 915 
<a name="73" id="anc73"></a><span class="line-modified"> 916 hb_bool_t</span>
 917 hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,
 918                                            unsigned int          lookup_index,
 919                                            const hb_codepoint_t *glyphs,
 920                                            unsigned int          glyphs_length,
<a name="74" id="anc74"></a><span class="line-modified"> 921                                            hb_bool_t             zero_context)</span>
 922 {
<a name="75" id="anc75"></a><span class="line-modified"> 923   if (unlikely (lookup_index &gt;= hb_ot_layout_from_face (face)-&gt;gsub_lookup_count)) return false;</span>
 924   OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);
 925 
<a name="76" id="anc76"></a><span class="line-modified"> 926   const OT::SubstLookup&amp; l = hb_ot_layout_from_face (face)-&gt;gsub-&gt;get_lookup (lookup_index);</span>
 927 
<a name="77" id="anc77"></a><span class="line-modified"> 928   return l.would_apply (&amp;c, &amp;hb_ot_layout_from_face (face)-&gt;gsub_accels[lookup_index]);</span>
 929 }
 930 
 931 void
<a name="78" id="anc78"></a><span class="line-modified"> 932 hb_ot_layout_substitute_start (hb_font_t *font, hb_buffer_t *buffer)</span>

 933 {
<a name="79" id="anc79"></a><span class="line-modified"> 934   OT::GSUB::substitute_start (font, buffer);</span>


















































 935 }
 936 
 937 /**
 938  * hb_ot_layout_lookup_substitute_closure:
 939  *
 940  * Since: 0.9.7
 941  **/
 942 void
 943 hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,
 944                                         unsigned int  lookup_index,
 945                                         hb_set_t     *glyphs)
 946 {
<a name="80" id="anc80"></a><span class="line-modified"> 947   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
 948   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
 949 
<a name="81" id="anc81"></a><span class="line-modified"> 950   const OT::SubstLookup&amp; l = _get_gsub (face).get_lookup (lookup_index);</span>
 951 
 952   l.closure (&amp;c, lookup_index);
 953 }
 954 
 955 /**
 956  * hb_ot_layout_lookups_substitute_closure:
 957  *
 958  * Compute the transitive closure of glyphs needed for all of the
 959  * provided lookups.
 960  *
 961  * Since: 1.8.1
 962  **/
 963 void
 964 hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,
 965                                          const hb_set_t *lookups,
 966                                          hb_set_t       *glyphs)
 967 {
<a name="82" id="anc82"></a><span class="line-modified"> 968   hb_auto_t&lt;hb_map_t&gt; done_lookups;</span>
 969   OT::hb_closure_context_t c (face, glyphs, &amp;done_lookups);
<a name="83" id="anc83"></a><span class="line-modified"> 970   const OT::GSUB&amp; gsub = _get_gsub (face);</span>
 971 
<a name="84" id="anc84"></a>
 972   unsigned int glyphs_length;
 973   do
 974   {
 975     glyphs_length = glyphs-&gt;get_population ();
 976     if (lookups != nullptr)
 977     {
 978       for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &amp;lookup_index);)
 979         gsub.get_lookup (lookup_index).closure (&amp;c, lookup_index);
 980     }
 981     else
 982     {
 983       for (unsigned int i = 0; i &lt; gsub.get_lookup_count (); i++)
 984         gsub.get_lookup (i).closure (&amp;c, i);
 985     }
<a name="85" id="anc85"></a><span class="line-modified"> 986   } while (glyphs_length != glyphs-&gt;get_population ());</span>

 987 }
 988 
 989 /*
 990  * OT::GPOS
 991  */
 992 
 993 hb_bool_t
 994 hb_ot_layout_has_positioning (hb_face_t *face)
 995 {
<a name="86" id="anc86"></a><span class="line-modified"> 996   return &amp;_get_gpos (face) != &amp;Null(OT::GPOS);</span>
 997 }
 998 
 999 void
1000 hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)
1001 {
1002   OT::GPOS::position_start (font, buffer);
1003 }
1004 
1005 void
1006 hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)
1007 {
1008   OT::GPOS::position_finish_advances (font, buffer);
1009 }
1010 
1011 void
1012 hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)
1013 {
1014   OT::GPOS::position_finish_offsets (font, buffer);
1015 }
1016 
1017 /**
1018  * hb_ot_layout_get_size_params:
1019  *
1020  * Since: 0.9.10
1021  **/
1022 hb_bool_t
<a name="87" id="anc87"></a><span class="line-modified">1023 hb_ot_layout_get_size_params (hb_face_t    *face,</span>
<span class="line-modified">1024                               unsigned int *design_size,       /* OUT.  May be nullptr */</span>
<span class="line-modified">1025                               unsigned int *subfamily_id,      /* OUT.  May be nullptr */</span>
<span class="line-modified">1026                               unsigned int *subfamily_name_id, /* OUT.  May be nullptr */</span>
<span class="line-modified">1027                               unsigned int *range_start,       /* OUT.  May be nullptr */</span>
<span class="line-modified">1028                               unsigned int *range_end          /* OUT.  May be nullptr */)</span>
1029 {
<a name="88" id="anc88"></a><span class="line-modified">1030   const OT::GPOS &amp;gpos = _get_gpos (face);</span>
1031   const hb_tag_t tag = HB_TAG (&#39;s&#39;,&#39;i&#39;,&#39;z&#39;,&#39;e&#39;);
1032 
1033   unsigned int num_features = gpos.get_feature_count ();
1034   for (unsigned int i = 0; i &lt; num_features; i++)
1035   {
1036     if (tag == gpos.get_feature_tag (i))
1037     {
1038       const OT::Feature &amp;f = gpos.get_feature (i);
1039       const OT::FeatureParamsSize &amp;params = f.get_feature_params ().get_size_params (tag);
1040 
1041       if (params.designSize)
1042       {
<a name="89" id="anc89"></a><span class="line-modified">1043 #define PARAM(a, A) if (a) *a = params.A</span>
<span class="line-modified">1044         PARAM (design_size, designSize);</span>
<span class="line-modified">1045         PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">1046         PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">1047         PARAM (range_start, rangeStart);</span>
<span class="line-removed">1048         PARAM (range_end, rangeEnd);</span>
<span class="line-removed">1049 #undef PARAM</span>
1050 
1051         return true;
1052       }
1053     }
1054   }
1055 
<a name="90" id="anc90"></a><span class="line-modified">1056 #define PARAM(a, A) if (a) *a = 0</span>
<span class="line-modified">1057   PARAM (design_size, designSize);</span>
<span class="line-modified">1058   PARAM (subfamily_id, subfamilyID);</span>
<span class="line-modified">1059   PARAM (subfamily_name_id, subfamilyNameID);</span>
<span class="line-modified">1060   PARAM (range_start, rangeStart);</span>
<span class="line-removed">1061   PARAM (range_end, rangeEnd);</span>
<span class="line-removed">1062 #undef PARAM</span>
1063 
1064   return false;
1065 }
1066 
<a name="91" id="anc91"></a>





























































































































1067 
1068 /*
1069  * Parts of different types are implemented here such that they have direct
1070  * access to GSUB/GPOS lookups.
1071  */
1072 
1073 
1074 struct GSUBProxy
1075 {
<a name="92" id="anc92"></a><span class="line-modified">1076   static const unsigned int table_index = 0;</span>
<span class="line-modified">1077   static const bool inplace = false;</span>
1078   typedef OT::SubstLookup Lookup;
1079 
1080   GSUBProxy (hb_face_t *face) :
<a name="93" id="anc93"></a><span class="line-modified">1081     table (*hb_ot_layout_from_face (face)-&gt;gsub),</span>
<span class="line-modified">1082     accels (hb_ot_layout_from_face (face)-&gt;gsub_accels) {}</span>
1083 
1084   const OT::GSUB &amp;table;
<a name="94" id="anc94"></a><span class="line-modified">1085   const hb_ot_layout_lookup_accelerator_t *accels;</span>
1086 };
1087 
1088 struct GPOSProxy
1089 {
<a name="95" id="anc95"></a><span class="line-modified">1090   static const unsigned int table_index = 1;</span>
<span class="line-modified">1091   static const bool inplace = true;</span>
1092   typedef OT::PosLookup Lookup;
1093 
1094   GPOSProxy (hb_face_t *face) :
<a name="96" id="anc96"></a><span class="line-modified">1095     table (*hb_ot_layout_from_face (face)-&gt;gpos),</span>
<span class="line-modified">1096     accels (hb_ot_layout_from_face (face)-&gt;gpos_accels) {}</span>
1097 
1098   const OT::GPOS &amp;table;
<a name="97" id="anc97"></a><span class="line-modified">1099   const hb_ot_layout_lookup_accelerator_t *accels;</span>
1100 };
1101 
1102 
<a name="98" id="anc98"></a><span class="line-removed">1103 struct hb_get_subtables_context_t :</span>
<span class="line-removed">1104        OT::hb_dispatch_context_t&lt;hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY&gt;</span>
<span class="line-removed">1105 {</span>
<span class="line-removed">1106   template &lt;typename Type&gt;</span>
<span class="line-removed">1107   static inline bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)</span>
<span class="line-removed">1108   {</span>
<span class="line-removed">1109     const Type *typed_obj = (const Type *) obj;</span>
<span class="line-removed">1110     return typed_obj-&gt;apply (c);</span>
<span class="line-removed">1111   }</span>
<span class="line-removed">1112 </span>
<span class="line-removed">1113   typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);</span>
<span class="line-removed">1114 </span>
<span class="line-removed">1115   struct hb_applicable_t</span>
<span class="line-removed">1116   {</span>
<span class="line-removed">1117     inline void init (const void *obj_, hb_apply_func_t apply_func_)</span>
<span class="line-removed">1118     {</span>
<span class="line-removed">1119       obj = obj_;</span>
<span class="line-removed">1120       apply_func = apply_func_;</span>
<span class="line-removed">1121     }</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123     inline bool apply (OT::hb_ot_apply_context_t *c) const { return apply_func (obj, c); }</span>
<span class="line-removed">1124 </span>
<span class="line-removed">1125     private:</span>
<span class="line-removed">1126     const void *obj;</span>
<span class="line-removed">1127     hb_apply_func_t apply_func;</span>
<span class="line-removed">1128   };</span>
<span class="line-removed">1129 </span>
<span class="line-removed">1130   typedef hb_auto_t&lt;hb_vector_t&lt;hb_applicable_t&gt; &gt; array_t;</span>
<span class="line-removed">1131 </span>
<span class="line-removed">1132   /* Dispatch interface. */</span>
<span class="line-removed">1133   inline const char *get_name (void) { return &quot;GET_SUBTABLES&quot;; }</span>
<span class="line-removed">1134   template &lt;typename T&gt;</span>
<span class="line-removed">1135   inline return_t dispatch (const T &amp;obj)</span>
<span class="line-removed">1136   {</span>
<span class="line-removed">1137     hb_applicable_t *entry = array.push();</span>
<span class="line-removed">1138     entry-&gt;init (&amp;obj, apply_to&lt;T&gt;);</span>
<span class="line-removed">1139     return HB_VOID;</span>
<span class="line-removed">1140   }</span>
<span class="line-removed">1141   static return_t default_return_value (void) { return HB_VOID; }</span>
<span class="line-removed">1142   bool stop_sublookup_iteration (return_t r HB_UNUSED) const { return false; }</span>
<span class="line-removed">1143 </span>
<span class="line-removed">1144   hb_get_subtables_context_t (array_t &amp;array_) :</span>
<span class="line-removed">1145                               array (array_),</span>
<span class="line-removed">1146                               debug_depth (0) {}</span>
<span class="line-removed">1147 </span>
<span class="line-removed">1148   array_t &amp;array;</span>
<span class="line-removed">1149   unsigned int debug_depth;</span>
<span class="line-removed">1150 };</span>
<span class="line-removed">1151 </span>
1152 static inline bool
1153 apply_forward (OT::hb_ot_apply_context_t *c,
<a name="99" id="anc99"></a><span class="line-modified">1154                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">1155                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
1156 {
1157   bool ret = false;
1158   hb_buffer_t *buffer = c-&gt;buffer;
1159   while (buffer-&gt;idx &lt; buffer-&gt;len &amp;&amp; buffer-&gt;successful)
1160   {
1161     bool applied = false;
1162     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1163         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1164         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
1165      {
<a name="100" id="anc100"></a><span class="line-modified">1166        for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">1167          if (subtables[i].apply (c))</span>
<span class="line-removed">1168          {</span>
<span class="line-removed">1169            applied = true;</span>
<span class="line-removed">1170            break;</span>
<span class="line-removed">1171          }</span>
1172      }
1173 
1174     if (applied)
1175       ret = true;
1176     else
1177       buffer-&gt;next_glyph ();
1178   }
1179   return ret;
1180 }
1181 
1182 static inline bool
1183 apply_backward (OT::hb_ot_apply_context_t *c,
<a name="101" id="anc101"></a><span class="line-modified">1184                const hb_ot_layout_lookup_accelerator_t &amp;accel,</span>
<span class="line-removed">1185                const hb_get_subtables_context_t::array_t &amp;subtables)</span>
1186 {
1187   bool ret = false;
1188   hb_buffer_t *buffer = c-&gt;buffer;
1189   do
1190   {
1191     if (accel.may_have (buffer-&gt;cur().codepoint) &amp;&amp;
1192         (buffer-&gt;cur().mask &amp; c-&gt;lookup_mask) &amp;&amp;
1193         c-&gt;check_glyph_property (&amp;buffer-&gt;cur(), c-&gt;lookup_props))
<a name="102" id="anc102"></a><span class="line-modified">1194     {</span>
<span class="line-modified">1195      for (unsigned int i = 0; i &lt; subtables.len; i++)</span>
<span class="line-removed">1196        if (subtables[i].apply (c))</span>
<span class="line-removed">1197        {</span>
<span class="line-removed">1198          ret = true;</span>
<span class="line-removed">1199          break;</span>
<span class="line-removed">1200        }</span>
<span class="line-removed">1201     }</span>
1202     /* The reverse lookup doesn&#39;t &quot;advance&quot; cursor (for good reason). */
1203     buffer-&gt;idx--;
1204 
1205   }
1206   while ((int) buffer-&gt;idx &gt;= 0);
1207   return ret;
1208 }
1209 
1210 template &lt;typename Proxy&gt;
1211 static inline void
1212 apply_string (OT::hb_ot_apply_context_t *c,
1213               const typename Proxy::Lookup &amp;lookup,
<a name="103" id="anc103"></a><span class="line-modified">1214               const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1215 {
1216   hb_buffer_t *buffer = c-&gt;buffer;
1217 
1218   if (unlikely (!buffer-&gt;len || !c-&gt;lookup_mask))
1219     return;
1220 
1221   c-&gt;set_lookup_props (lookup.get_props ());
1222 
<a name="104" id="anc104"></a><span class="line-removed">1223   hb_get_subtables_context_t::array_t subtables;</span>
<span class="line-removed">1224   hb_get_subtables_context_t c_get_subtables (subtables);</span>
<span class="line-removed">1225   lookup.dispatch (&amp;c_get_subtables);</span>
<span class="line-removed">1226 </span>
1227   if (likely (!lookup.is_reverse ()))
1228   {
1229     /* in/out forward substitution/positioning */
<a name="105" id="anc105"></a><span class="line-modified">1230     if (Proxy::table_index == 0)</span>
1231       buffer-&gt;clear_output ();
1232     buffer-&gt;idx = 0;
1233 
1234     bool ret;
<a name="106" id="anc106"></a><span class="line-modified">1235     ret = apply_forward (c, accel, subtables);</span>
1236     if (ret)
1237     {
1238       if (!Proxy::inplace)
1239         buffer-&gt;swap_buffers ();
1240       else
1241         assert (!buffer-&gt;has_separate_output ());
1242     }
1243   }
1244   else
1245   {
1246     /* in-place backward substitution/positioning */
<a name="107" id="anc107"></a><span class="line-modified">1247     if (Proxy::table_index == 0)</span>
1248       buffer-&gt;remove_output ();
1249     buffer-&gt;idx = buffer-&gt;len - 1;
1250 
<a name="108" id="anc108"></a><span class="line-modified">1251     apply_backward (c, accel, subtables);</span>
1252   }
1253 }
1254 
1255 template &lt;typename Proxy&gt;
1256 inline void hb_ot_map_t::apply (const Proxy &amp;proxy,
1257                                 const hb_ot_shape_plan_t *plan,
1258                                 hb_font_t *font,
1259                                 hb_buffer_t *buffer) const
1260 {
1261   const unsigned int table_index = proxy.table_index;
1262   unsigned int i = 0;
1263   OT::hb_ot_apply_context_t c (table_index, font, buffer);
1264   c.set_recurse_func (Proxy::Lookup::apply_recurse_func);
1265 
<a name="109" id="anc109"></a><span class="line-modified">1266   for (unsigned int stage_index = 0; stage_index &lt; stages[table_index].len; stage_index++) {</span>
1267     const stage_map_t *stage = &amp;stages[table_index][stage_index];
1268     for (; i &lt; stage-&gt;last_lookup; i++)
1269     {
1270       unsigned int lookup_index = lookups[table_index][i].index;
1271       if (!buffer-&gt;message (font, &quot;start lookup %d&quot;, lookup_index)) continue;
1272       c.set_lookup_index (lookup_index);
1273       c.set_lookup_mask (lookups[table_index][i].mask);
1274       c.set_auto_zwj (lookups[table_index][i].auto_zwj);
1275       c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);
<a name="110" id="anc110"></a>




1276       apply_string&lt;Proxy&gt; (&amp;c,
1277                            proxy.table.get_lookup (lookup_index),
1278                            proxy.accels[lookup_index]);
1279       (void) buffer-&gt;message (font, &quot;end lookup %d&quot;, lookup_index);
1280     }
1281 
1282     if (stage-&gt;pause_func)
1283     {
1284       buffer-&gt;clear_output ();
1285       stage-&gt;pause_func (plan, font, buffer);
1286     }
1287   }
1288 }
1289 
1290 void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1291 {
1292   GSUBProxy proxy (font-&gt;face);
1293   apply (proxy, plan, font, buffer);
1294 }
1295 
1296 void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const
1297 {
1298   GPOSProxy proxy (font-&gt;face);
1299   apply (proxy, plan, font, buffer);
1300 }
1301 
1302 void
1303 hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,
1304                                 const OT::SubstLookup &amp;lookup,
<a name="111" id="anc111"></a><span class="line-modified">1305                                 const hb_ot_layout_lookup_accelerator_t &amp;accel)</span>
1306 {
1307   apply_string&lt;GSUBProxy&gt; (c, lookup, accel);
1308 }
1309 
<a name="112" id="anc112"></a>




1310 
<a name="113" id="anc113"></a>










1311 
<a name="114" id="anc114"></a>

1312 
<a name="115" id="anc115"></a>





1313 /*
<a name="116" id="anc116"></a><span class="line-modified">1314  * OT::BASE</span>
1315  */
1316 
<a name="117" id="anc117"></a><span class="line-modified">1317 // /**</span>
<span class="line-modified">1318 //  * hb_ot_base_has_data:</span>
<span class="line-modified">1319 //  * @face: #hb_face_t to test</span>
<span class="line-modified">1320 //  *</span>
<span class="line-modified">1321 //  * This function allows to verify the presence of an OpenType BASE table on the</span>
<span class="line-modified">1322 //  * face.</span>
<span class="line-modified">1323 //  *</span>
<span class="line-modified">1324 //  * Return value: true if face has a BASE table, false otherwise</span>
<span class="line-modified">1325 //  *</span>
<span class="line-modified">1326 //  * Since: XXX</span>
<span class="line-modified">1327 //  **/</span>
<span class="line-modified">1328 // hb_bool_t</span>
<span class="line-modified">1329 // hb_ot_base_has_data (hb_face_t *face)</span>
<span class="line-modified">1330 // {</span>
<span class="line-modified">1331 //   return &amp;_get_base (face) != &amp;Null(OT::BASE);</span>
<span class="line-modified">1332 // }</span>










<a name="118" id="anc118"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="118" type="hidden" />
</body>
</html>
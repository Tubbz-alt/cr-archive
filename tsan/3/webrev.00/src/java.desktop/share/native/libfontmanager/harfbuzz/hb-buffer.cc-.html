<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfontmanager/harfbuzz/hb-buffer.cc</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright © 1998-2004  David Turner and Werner Lemberg
   3  * Copyright © 2004,2007,2009,2010  Red Hat, Inc.
   4  * Copyright © 2011,2012  Google, Inc.
   5  *
   6  *  This is part of HarfBuzz, a text shaping library.
   7  *
   8  * Permission is hereby granted, without written agreement and without
   9  * license or royalty fees, to use, copy, modify, and distribute this
  10  * software and its documentation for any purpose, provided that the
  11  * above copyright notice and the following two paragraphs appear in
  12  * all copies of this software.
  13  *
  14  * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR
  15  * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
  16  * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN
  17  * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
  18  * DAMAGE.
  19  *
  20  * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,
  21  * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
  22  * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
  23  * ON AN &quot;AS IS&quot; BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO
  24  * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
  25  *
  26  * Red Hat Author(s): Owen Taylor, Behdad Esfahbod
  27  * Google Author(s): Behdad Esfahbod
  28  */
  29 
  30 #include &quot;hb-buffer-private.hh&quot;
  31 #include &quot;hb-utf-private.hh&quot;
  32 
  33 
  34 /**
  35  * SECTION: hb-buffer
  36  * @title: Buffers
  37  * @short_description: Input and output buffers
  38  * @include: hb.h
  39  *
  40  * Buffers serve dual role in HarfBuzz; they hold the input characters that are
  41  * passed hb_shape(), and after shaping they hold the output glyphs.
  42  **/
  43 
  44 /**
  45  * hb_segment_properties_equal:
  46  * @a: first #hb_segment_properties_t to compare.
  47  * @b: second #hb_segment_properties_t to compare.
  48  *
  49  * Checks the equality of two #hb_segment_properties_t&#39;s.
  50  *
  51  * Return value:
  52  * %true if all properties of @a equal those of @b, false otherwise.
  53  *
  54  * Since: 0.9.7
  55  **/
  56 hb_bool_t
  57 hb_segment_properties_equal (const hb_segment_properties_t *a,
  58                              const hb_segment_properties_t *b)
  59 {
  60   return a-&gt;direction == b-&gt;direction &amp;&amp;
  61          a-&gt;script    == b-&gt;script    &amp;&amp;
  62          a-&gt;language  == b-&gt;language  &amp;&amp;
  63          a-&gt;reserved1 == b-&gt;reserved1 &amp;&amp;
  64          a-&gt;reserved2 == b-&gt;reserved2;
  65 
  66 }
  67 
  68 /**
  69  * hb_segment_properties_hash:
  70  * @p: #hb_segment_properties_t to hash.
  71  *
  72  * Creates a hash representing @p.
  73  *
  74  * Return value:
  75  * A hash of @p.
  76  *
  77  * Since: 0.9.7
  78  **/
  79 unsigned int
  80 hb_segment_properties_hash (const hb_segment_properties_t *p)
  81 {
  82   return (unsigned int) p-&gt;direction ^
  83          (unsigned int) p-&gt;script ^
  84          (intptr_t) (p-&gt;language);
  85 }
  86 
  87 
  88 
  89 /* Here is how the buffer works internally:
  90  *
  91  * There are two info pointers: info and out_info.  They always have
  92  * the same allocated size, but different lengths.
  93  *
  94  * As an optimization, both info and out_info may point to the
  95  * same piece of memory, which is owned by info.  This remains the
  96  * case as long as out_len doesn&#39;t exceed i at any time.
  97  * In that case, swap_buffers() is no-op and the glyph operations operate
  98  * mostly in-place.
  99  *
 100  * As soon as out_info gets longer than info, out_info is moved over
 101  * to an alternate buffer (which we reuse the pos buffer for!), and its
 102  * current contents (out_len entries) are copied to the new place.
 103  * This should all remain transparent to the user.  swap_buffers() then
 104  * switches info and out_info.
 105  */
 106 
 107 
 108 
 109 /* Internal API */
 110 
 111 bool
 112 hb_buffer_t::enlarge (unsigned int size)
 113 {
 114   if (unlikely (!successful))
 115     return false;
 116   if (unlikely (size &gt; max_len))
 117   {
 118     successful = false;
 119     return false;
 120   }
 121 
 122   unsigned int new_allocated = allocated;
 123   hb_glyph_position_t *new_pos = nullptr;
 124   hb_glyph_info_t *new_info = nullptr;
 125   bool separate_out = out_info != info;
 126 
 127   if (unlikely (_hb_unsigned_int_mul_overflows (size, sizeof (info[0]))))
 128     goto done;
 129 
 130   while (size &gt;= new_allocated)
 131     new_allocated += (new_allocated &gt;&gt; 1) + 32;
 132 
 133   static_assert ((sizeof (info[0]) == sizeof (pos[0])), &quot;&quot;);
 134   if (unlikely (_hb_unsigned_int_mul_overflows (new_allocated, sizeof (info[0]))))
 135     goto done;
 136 
 137   new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));
 138   new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));
 139 
 140 done:
 141   if (unlikely (!new_pos || !new_info))
 142     successful = false;
 143 
 144   if (likely (new_pos))
 145     pos = new_pos;
 146 
 147   if (likely (new_info))
 148     info = new_info;
 149 
 150   out_info = separate_out ? (hb_glyph_info_t *) pos : info;
 151   if (likely (successful))
 152     allocated = new_allocated;
 153 
 154   return likely (successful);
 155 }
 156 
 157 bool
 158 hb_buffer_t::make_room_for (unsigned int num_in,
 159                             unsigned int num_out)
 160 {
 161   if (unlikely (!ensure (out_len + num_out))) return false;
 162 
 163   if (out_info == info &amp;&amp;
 164       out_len + num_out &gt; idx + num_in)
 165   {
 166     assert (have_output);
 167 
 168     out_info = (hb_glyph_info_t *) pos;
 169     memcpy (out_info, info, out_len * sizeof (out_info[0]));
 170   }
 171 
 172   return true;
 173 }
 174 
 175 bool
 176 hb_buffer_t::shift_forward (unsigned int count)
 177 {
 178   assert (have_output);
 179   if (unlikely (!ensure (len + count))) return false;
 180 
 181   memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));
 182   if (idx + count &gt; len)
 183   {
 184     /* Under memory failure we might expose this area.  At least
 185      * clean it up.  Oh well... */
 186     memset (info + len, 0, (idx + count - len) * sizeof (info[0]));
 187   }
 188   len += count;
 189   idx += count;
 190 
 191   return true;
 192 }
 193 
 194 hb_buffer_t::scratch_buffer_t *
 195 hb_buffer_t::get_scratch_buffer (unsigned int *size)
 196 {
 197   have_output = false;
 198   have_positions = false;
 199 
 200   out_len = 0;
 201   out_info = info;
 202 
 203   assert ((uintptr_t) pos % sizeof (scratch_buffer_t) == 0);
 204   *size = allocated * sizeof (pos[0]) / sizeof (scratch_buffer_t);
 205   return (scratch_buffer_t *) (void *) pos;
 206 }
 207 
 208 
 209 
 210 /* HarfBuzz-Internal API */
 211 
 212 void
 213 hb_buffer_t::reset (void)
 214 {
 215   if (unlikely (hb_object_is_inert (this)))
 216     return;
 217 
 218   hb_unicode_funcs_destroy (unicode);
 219   unicode = hb_unicode_funcs_get_default ();
 220   flags = HB_BUFFER_FLAG_DEFAULT;
 221   replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;
 222 
 223   clear ();
 224 }
 225 
 226 void
 227 hb_buffer_t::clear (void)
 228 {
 229   if (unlikely (hb_object_is_inert (this)))
 230     return;
 231 
 232   hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;
 233   props = default_props;
 234   scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;
 235 
 236   content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
 237   successful = true;
 238   have_output = false;
 239   have_positions = false;
 240 
 241   idx = 0;
 242   len = 0;
 243   out_len = 0;
 244   out_info = info;
 245 
 246   serial = 0;
 247 
 248   memset (context, 0, sizeof context);
 249   memset (context_len, 0, sizeof context_len);
 250 
 251   deallocate_var_all ();
 252 }
 253 
 254 void
 255 hb_buffer_t::add (hb_codepoint_t  codepoint,
 256                   unsigned int    cluster)
 257 {
 258   hb_glyph_info_t *glyph;
 259 
 260   if (unlikely (!ensure (len + 1))) return;
 261 
 262   glyph = &amp;info[len];
 263 
 264   memset (glyph, 0, sizeof (*glyph));
 265   glyph-&gt;codepoint = codepoint;
 266   glyph-&gt;mask = 0;
 267   glyph-&gt;cluster = cluster;
 268 
 269   len++;
 270 }
 271 
 272 void
 273 hb_buffer_t::add_info (const hb_glyph_info_t &amp;glyph_info)
 274 {
 275   if (unlikely (!ensure (len + 1))) return;
 276 
 277   info[len] = glyph_info;
 278 
 279   len++;
 280 }
 281 
 282 
 283 void
 284 hb_buffer_t::remove_output (void)
 285 {
 286   if (unlikely (hb_object_is_inert (this)))
 287     return;
 288 
 289   have_output = false;
 290   have_positions = false;
 291 
 292   out_len = 0;
 293   out_info = info;
 294 }
 295 
 296 void
 297 hb_buffer_t::clear_output (void)
 298 {
 299   if (unlikely (hb_object_is_inert (this)))
 300     return;
 301 
 302   have_output = true;
 303   have_positions = false;
 304 
 305   out_len = 0;
 306   out_info = info;
 307 }
 308 
 309 void
 310 hb_buffer_t::clear_positions (void)
 311 {
 312   if (unlikely (hb_object_is_inert (this)))
 313     return;
 314 
 315   have_output = false;
 316   have_positions = true;
 317 
 318   out_len = 0;
 319   out_info = info;
 320 
 321   memset (pos, 0, sizeof (pos[0]) * len);
 322 }
 323 
 324 void
 325 hb_buffer_t::swap_buffers (void)
 326 {
 327   if (unlikely (!successful)) return;
 328 
 329   assert (have_output);
 330   have_output = false;
 331 
 332   if (out_info != info)
 333   {
 334     hb_glyph_info_t *tmp_string;
 335     tmp_string = info;
 336     info = out_info;
 337     out_info = tmp_string;
 338     pos = (hb_glyph_position_t *) out_info;
 339   }
 340 
 341   unsigned int tmp;
 342   tmp = len;
 343   len = out_len;
 344   out_len = tmp;
 345 
 346   idx = 0;
 347 }
 348 
 349 
 350 void
 351 hb_buffer_t::replace_glyphs (unsigned int num_in,
 352                              unsigned int num_out,
 353                              const uint32_t *glyph_data)
 354 {
 355   if (unlikely (!make_room_for (num_in, num_out))) return;
 356 
 357   merge_clusters (idx, idx + num_in);
 358 
 359   hb_glyph_info_t orig_info = info[idx];
 360   hb_glyph_info_t *pinfo = &amp;out_info[out_len];
 361   for (unsigned int i = 0; i &lt; num_out; i++)
 362   {
 363     *pinfo = orig_info;
 364     pinfo-&gt;codepoint = glyph_data[i];
 365     pinfo++;
 366   }
 367 
 368   idx  += num_in;
 369   out_len += num_out;
 370 }
 371 
 372 void
 373 hb_buffer_t::output_glyph (hb_codepoint_t glyph_index)
 374 {
 375   if (unlikely (!make_room_for (0, 1))) return;
 376 
 377   out_info[out_len] = info[idx];
 378   out_info[out_len].codepoint = glyph_index;
 379 
 380   out_len++;
 381 }
 382 
 383 void
 384 hb_buffer_t::output_info (const hb_glyph_info_t &amp;glyph_info)
 385 {
 386   if (unlikely (!make_room_for (0, 1))) return;
 387 
 388   out_info[out_len] = glyph_info;
 389 
 390   out_len++;
 391 }
 392 
 393 void
 394 hb_buffer_t::copy_glyph (void)
 395 {
 396   if (unlikely (!make_room_for (0, 1))) return;
 397 
 398   out_info[out_len] = info[idx];
 399 
 400   out_len++;
 401 }
 402 
 403 bool
 404 hb_buffer_t::move_to (unsigned int i)
 405 {
 406   if (!have_output)
 407   {
 408     assert (i &lt;= len);
 409     idx = i;
 410     return true;
 411   }
 412   if (unlikely (!successful))
 413     return false;
 414 
 415   assert (i &lt;= out_len + (len - idx));
 416 
 417   if (out_len &lt; i)
 418   {
 419     unsigned int count = i - out_len;
 420     if (unlikely (!make_room_for (count, count))) return false;
 421 
 422     memmove (out_info + out_len, info + idx, count * sizeof (out_info[0]));
 423     idx += count;
 424     out_len += count;
 425   }
 426   else if (out_len &gt; i)
 427   {
 428     /* Tricky part: rewinding... */
 429     unsigned int count = out_len - i;
 430 
 431     /* This will blow in our face if memory allocation fails later
 432      * in this same lookup... */
 433     if (unlikely (idx &lt; count &amp;&amp; !shift_forward (count + 32))) return false;
 434 
 435     assert (idx &gt;= count);
 436 
 437     idx -= count;
 438     out_len -= count;
 439     memmove (info + idx, out_info + out_len, count * sizeof (out_info[0]));
 440   }
 441 
 442   return true;
 443 }
 444 
 445 void
 446 hb_buffer_t::replace_glyph (hb_codepoint_t glyph_index)
 447 {
 448   if (unlikely (out_info != info || out_len != idx)) {
 449     if (unlikely (!make_room_for (1, 1))) return;
 450     out_info[out_len] = info[idx];
 451   }
 452   out_info[out_len].codepoint = glyph_index;
 453 
 454   idx++;
 455   out_len++;
 456 }
 457 
 458 
 459 void
 460 hb_buffer_t::set_masks (hb_mask_t    value,
 461                         hb_mask_t    mask,
 462                         unsigned int cluster_start,
 463                         unsigned int cluster_end)
 464 {
 465   hb_mask_t not_mask = ~mask;
 466   value &amp;= mask;
 467 
 468   if (!mask)
 469     return;
 470 
 471   if (cluster_start == 0 &amp;&amp; cluster_end == (unsigned int)-1) {
 472     unsigned int count = len;
 473     for (unsigned int i = 0; i &lt; count; i++)
 474       info[i].mask = (info[i].mask &amp; not_mask) | value;
 475     return;
 476   }
 477 
 478   unsigned int count = len;
 479   for (unsigned int i = 0; i &lt; count; i++)
 480     if (cluster_start &lt;= info[i].cluster &amp;&amp; info[i].cluster &lt; cluster_end)
 481       info[i].mask = (info[i].mask &amp; not_mask) | value;
 482 }
 483 
 484 void
 485 hb_buffer_t::reverse_range (unsigned int start,
 486                             unsigned int end)
 487 {
 488   unsigned int i, j;
 489 
 490   if (end - start &lt; 2)
 491     return;
 492 
 493   for (i = start, j = end - 1; i &lt; j; i++, j--) {
 494     hb_glyph_info_t t;
 495 
 496     t = info[i];
 497     info[i] = info[j];
 498     info[j] = t;
 499   }
 500 
 501   if (have_positions) {
 502     for (i = start, j = end - 1; i &lt; j; i++, j--) {
 503       hb_glyph_position_t t;
 504 
 505       t = pos[i];
 506       pos[i] = pos[j];
 507       pos[j] = t;
 508     }
 509   }
 510 }
 511 
 512 void
 513 hb_buffer_t::reverse (void)
 514 {
 515   if (unlikely (!len))
 516     return;
 517 
 518   reverse_range (0, len);
 519 }
 520 
 521 void
 522 hb_buffer_t::reverse_clusters (void)
 523 {
 524   unsigned int i, start, count, last_cluster;
 525 
 526   if (unlikely (!len))
 527     return;
 528 
 529   reverse ();
 530 
 531   count = len;
 532   start = 0;
 533   last_cluster = info[0].cluster;
 534   for (i = 1; i &lt; count; i++) {
 535     if (last_cluster != info[i].cluster) {
 536       reverse_range (start, i);
 537       start = i;
 538       last_cluster = info[i].cluster;
 539     }
 540   }
 541   reverse_range (start, i);
 542 }
 543 
 544 void
 545 hb_buffer_t::merge_clusters_impl (unsigned int start,
 546                                   unsigned int end)
 547 {
 548   if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)
 549   {
 550     unsafe_to_break (start, end);
 551     return;
 552   }
 553 
 554   unsigned int cluster = info[start].cluster;
 555 
 556   for (unsigned int i = start + 1; i &lt; end; i++)
 557     cluster = MIN&lt;unsigned int&gt; (cluster, info[i].cluster);
 558 
 559   /* Extend end */
 560   while (end &lt; len &amp;&amp; info[end - 1].cluster == info[end].cluster)
 561     end++;
 562 
 563   /* Extend start */
 564   while (idx &lt; start &amp;&amp; info[start - 1].cluster == info[start].cluster)
 565     start--;
 566 
 567   /* If we hit the start of buffer, continue in out-buffer. */
 568   if (idx == start)
 569     for (unsigned int i = out_len; i &amp;&amp; out_info[i - 1].cluster == info[start].cluster; i--)
 570       set_cluster (out_info[i - 1], cluster);
 571 
 572   for (unsigned int i = start; i &lt; end; i++)
 573     set_cluster (info[i], cluster);
 574 }
 575 void
 576 hb_buffer_t::merge_out_clusters (unsigned int start,
 577                                  unsigned int end)
 578 {
 579   if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)
 580     return;
 581 
 582   if (unlikely (end - start &lt; 2))
 583     return;
 584 
 585   unsigned int cluster = out_info[start].cluster;
 586 
 587   for (unsigned int i = start + 1; i &lt; end; i++)
 588     cluster = MIN&lt;unsigned int&gt; (cluster, out_info[i].cluster);
 589 
 590   /* Extend start */
 591   while (start &amp;&amp; out_info[start - 1].cluster == out_info[start].cluster)
 592     start--;
 593 
 594   /* Extend end */
 595   while (end &lt; out_len &amp;&amp; out_info[end - 1].cluster == out_info[end].cluster)
 596     end++;
 597 
 598   /* If we hit the end of out-buffer, continue in buffer. */
 599   if (end == out_len)
 600     for (unsigned int i = idx; i &lt; len &amp;&amp; info[i].cluster == out_info[end - 1].cluster; i++)
 601       set_cluster (info[i], cluster);
 602 
 603   for (unsigned int i = start; i &lt; end; i++)
 604     set_cluster (out_info[i], cluster);
 605 }
 606 void
 607 hb_buffer_t::delete_glyph ()
 608 {
 609   /* The logic here is duplicated in hb_ot_hide_default_ignorables(). */
 610 
 611   unsigned int cluster = info[idx].cluster;
 612   if (idx + 1 &lt; len &amp;&amp; cluster == info[idx + 1].cluster)
 613   {
 614     /* Cluster survives; do nothing. */
 615     goto done;
 616   }
 617 
 618   if (out_len)
 619   {
 620     /* Merge cluster backward. */
 621     if (cluster &lt; out_info[out_len - 1].cluster)
 622     {
 623       unsigned int mask = info[idx].mask;
 624       unsigned int old_cluster = out_info[out_len - 1].cluster;
 625       for (unsigned i = out_len; i &amp;&amp; out_info[i - 1].cluster == old_cluster; i--)
 626         set_cluster (out_info[i - 1], cluster, mask);
 627     }
 628     goto done;
 629   }
 630 
 631   if (idx + 1 &lt; len)
 632   {
 633     /* Merge cluster forward. */
 634     merge_clusters (idx, idx + 2);
 635     goto done;
 636   }
 637 
 638 done:
 639   skip_glyph ();
 640 }
 641 
 642 void
 643 hb_buffer_t::unsafe_to_break_impl (unsigned int start, unsigned int end)
 644 {
 645   unsigned int cluster = (unsigned int) -1;
 646   cluster = _unsafe_to_break_find_min_cluster (info, start, end, cluster);
 647   _unsafe_to_break_set_mask (info, start, end, cluster);
 648 }
 649 void
 650 hb_buffer_t::unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end)
 651 {
 652   if (!have_output)
 653   {
 654     unsafe_to_break_impl (start, end);
 655     return;
 656   }
 657 
 658   assert (start &lt;= out_len);
 659   assert (idx &lt;= end);
 660 
 661   unsigned int cluster = (unsigned int) -1;
 662   cluster = _unsafe_to_break_find_min_cluster (out_info, start, out_len, cluster);
 663   cluster = _unsafe_to_break_find_min_cluster (info, idx, end, cluster);
 664   _unsafe_to_break_set_mask (out_info, start, out_len, cluster);
 665   _unsafe_to_break_set_mask (info, idx, end, cluster);
 666 }
 667 
 668 void
 669 hb_buffer_t::guess_segment_properties (void)
 670 {
 671   assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
 672           (!len &amp;&amp; content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
 673 
 674   /* If script is set to INVALID, guess from buffer contents */
 675   if (props.script == HB_SCRIPT_INVALID) {
 676     for (unsigned int i = 0; i &lt; len; i++) {
 677       hb_script_t script = unicode-&gt;script (info[i].codepoint);
 678       if (likely (script != HB_SCRIPT_COMMON &amp;&amp;
 679                   script != HB_SCRIPT_INHERITED &amp;&amp;
 680                   script != HB_SCRIPT_UNKNOWN)) {
 681         props.script = script;
 682         break;
 683       }
 684     }
 685   }
 686 
 687   /* If direction is set to INVALID, guess from script */
 688   if (props.direction == HB_DIRECTION_INVALID) {
 689     props.direction = hb_script_get_horizontal_direction (props.script);
 690     if (props.direction == HB_DIRECTION_INVALID)
 691       props.direction = HB_DIRECTION_LTR;
 692   }
 693 
 694   /* If language is not set, use default language from locale */
 695   if (props.language == HB_LANGUAGE_INVALID) {
 696     /* TODO get_default_for_script? using $LANGUAGE */
 697     props.language = hb_language_get_default ();
 698   }
 699 }
 700 
 701 
 702 /* Public API */
 703 
 704 /**
 705  * hb_buffer_create: (Xconstructor)
 706  *
 707  * Creates a new #hb_buffer_t with all properties to defaults.
 708  *
 709  * Return value: (transfer full):
 710  * A newly allocated #hb_buffer_t with a reference count of 1. The initial
 711  * reference count should be released with hb_buffer_destroy() when you are done
 712  * using the #hb_buffer_t. This function never returns %NULL. If memory cannot
 713  * be allocated, a special #hb_buffer_t object will be returned on which
 714  * hb_buffer_allocation_successful() returns %false.
 715  *
 716  * Since: 0.9.2
 717  **/
 718 hb_buffer_t *
 719 hb_buffer_create (void)
 720 {
 721   hb_buffer_t *buffer;
 722 
 723   if (!(buffer = hb_object_create&lt;hb_buffer_t&gt; ()))
 724     return hb_buffer_get_empty ();
 725 
 726   buffer-&gt;max_len = HB_BUFFER_MAX_LEN_DEFAULT;
 727   buffer-&gt;max_ops = HB_BUFFER_MAX_OPS_DEFAULT;
 728 
 729   buffer-&gt;reset ();
 730 
 731   return buffer;
 732 }
 733 
 734 /**
 735  * hb_buffer_get_empty:
 736  *
 737  *
 738  *
 739  * Return value: (transfer full):
 740  *
 741  * Since: 0.9.2
 742  **/
 743 hb_buffer_t *
 744 hb_buffer_get_empty (void)
 745 {
 746   static const hb_buffer_t _hb_buffer_nil = {
 747     HB_OBJECT_HEADER_STATIC,
 748 
 749     const_cast&lt;hb_unicode_funcs_t *&gt; (&amp;_hb_unicode_funcs_nil),
 750     HB_BUFFER_FLAG_DEFAULT,
 751     HB_BUFFER_CLUSTER_LEVEL_DEFAULT,
 752     HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,
 753     HB_BUFFER_SCRATCH_FLAG_DEFAULT,
 754     HB_BUFFER_MAX_LEN_DEFAULT,
 755     HB_BUFFER_MAX_OPS_DEFAULT,
 756 
 757     HB_BUFFER_CONTENT_TYPE_INVALID,
 758     HB_SEGMENT_PROPERTIES_DEFAULT,
 759     false, /* successful */
 760     true, /* have_output */
 761     true  /* have_positions */
 762 
 763     /* Zero is good enough for everything else. */
 764   };
 765 
 766   return const_cast&lt;hb_buffer_t *&gt; (&amp;_hb_buffer_nil);
 767 }
 768 
 769 /**
 770  * hb_buffer_reference: (skip)
 771  * @buffer: an #hb_buffer_t.
 772  *
 773  * Increases the reference count on @buffer by one. This prevents @buffer from
 774  * being destroyed until a matching call to hb_buffer_destroy() is made.
 775  *
 776  * Return value: (transfer full):
 777  * The referenced #hb_buffer_t.
 778  *
 779  * Since: 0.9.2
 780  **/
 781 hb_buffer_t *
 782 hb_buffer_reference (hb_buffer_t *buffer)
 783 {
 784   return hb_object_reference (buffer);
 785 }
 786 
 787 /**
 788  * hb_buffer_destroy: (skip)
 789  * @buffer: an #hb_buffer_t.
 790  *
 791  * Deallocate the @buffer.
 792  * Decreases the reference count on @buffer by one. If the result is zero, then
 793  * @buffer and all associated resources are freed. See hb_buffer_reference().
 794  *
 795  * Since: 0.9.2
 796  **/
 797 void
 798 hb_buffer_destroy (hb_buffer_t *buffer)
 799 {
 800   if (!hb_object_destroy (buffer)) return;
 801 
 802   hb_unicode_funcs_destroy (buffer-&gt;unicode);
 803 
 804   free (buffer-&gt;info);
 805   free (buffer-&gt;pos);
 806   if (buffer-&gt;message_destroy)
 807     buffer-&gt;message_destroy (buffer-&gt;message_data);
 808 
 809   free (buffer);
 810 }
 811 
 812 /**
 813  * hb_buffer_set_user_data: (skip)
 814  * @buffer: an #hb_buffer_t.
 815  * @key:
 816  * @data:
 817  * @destroy:
 818  * @replace:
 819  *
 820  *
 821  *
 822  * Return value:
 823  *
 824  * Since: 0.9.2
 825  **/
 826 hb_bool_t
 827 hb_buffer_set_user_data (hb_buffer_t        *buffer,
 828                          hb_user_data_key_t *key,
 829                          void *              data,
 830                          hb_destroy_func_t   destroy,
 831                          hb_bool_t           replace)
 832 {
 833   return hb_object_set_user_data (buffer, key, data, destroy, replace);
 834 }
 835 
 836 /**
 837  * hb_buffer_get_user_data: (skip)
 838  * @buffer: an #hb_buffer_t.
 839  * @key:
 840  *
 841  *
 842  *
 843  * Return value:
 844  *
 845  * Since: 0.9.2
 846  **/
 847 void *
 848 hb_buffer_get_user_data (hb_buffer_t        *buffer,
 849                          hb_user_data_key_t *key)
 850 {
 851   return hb_object_get_user_data (buffer, key);
 852 }
 853 
 854 
 855 /**
 856  * hb_buffer_set_content_type:
 857  * @buffer: an #hb_buffer_t.
 858  * @content_type: the type of buffer contents to set
 859  *
 860  * Sets the type of @buffer contents, buffers are either empty, contain
 861  * characters (before shaping) or glyphs (the result of shaping).
 862  *
 863  * Since: 0.9.5
 864  **/
 865 void
 866 hb_buffer_set_content_type (hb_buffer_t              *buffer,
 867                             hb_buffer_content_type_t  content_type)
 868 {
 869   buffer-&gt;content_type = content_type;
 870 }
 871 
 872 /**
 873  * hb_buffer_get_content_type:
 874  * @buffer: an #hb_buffer_t.
 875  *
 876  * see hb_buffer_set_content_type().
 877  *
 878  * Return value:
 879  * The type of @buffer contents.
 880  *
 881  * Since: 0.9.5
 882  **/
 883 hb_buffer_content_type_t
 884 hb_buffer_get_content_type (hb_buffer_t *buffer)
 885 {
 886   return buffer-&gt;content_type;
 887 }
 888 
 889 
 890 /**
 891  * hb_buffer_set_unicode_funcs:
 892  * @buffer: an #hb_buffer_t.
 893  * @unicode_funcs:
 894  *
 895  *
 896  *
 897  * Since: 0.9.2
 898  **/
 899 void
 900 hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,
 901                              hb_unicode_funcs_t *unicode_funcs)
 902 {
 903   if (unlikely (hb_object_is_inert (buffer)))
 904     return;
 905 
 906   if (!unicode_funcs)
 907     unicode_funcs = hb_unicode_funcs_get_default ();
 908 
 909 
 910   hb_unicode_funcs_reference (unicode_funcs);
 911   hb_unicode_funcs_destroy (buffer-&gt;unicode);
 912   buffer-&gt;unicode = unicode_funcs;
 913 }
 914 
 915 /**
 916  * hb_buffer_get_unicode_funcs:
 917  * @buffer: an #hb_buffer_t.
 918  *
 919  *
 920  *
 921  * Return value:
 922  *
 923  * Since: 0.9.2
 924  **/
 925 hb_unicode_funcs_t *
 926 hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)
 927 {
 928   return buffer-&gt;unicode;
 929 }
 930 
 931 /**
 932  * hb_buffer_set_direction:
 933  * @buffer: an #hb_buffer_t.
 934  * @direction: the #hb_direction_t of the @buffer
 935  *
 936  * Set the text flow direction of the buffer. No shaping can happen without
 937  * setting @buffer direction, and it controls the visual direction for the
 938  * output glyphs; for RTL direction the glyphs will be reversed. Many layout
 939  * features depend on the proper setting of the direction, for example,
 940  * reversing RTL text before shaping, then shaping with LTR direction is not
 941  * the same as keeping the text in logical order and shaping with RTL
 942  * direction.
 943  *
 944  * Since: 0.9.2
 945  **/
 946 void
 947 hb_buffer_set_direction (hb_buffer_t    *buffer,
 948                          hb_direction_t  direction)
 949 
 950 {
 951   if (unlikely (hb_object_is_inert (buffer)))
 952     return;
 953 
 954   buffer-&gt;props.direction = direction;
 955 }
 956 
 957 /**
 958  * hb_buffer_get_direction:
 959  * @buffer: an #hb_buffer_t.
 960  *
 961  * See hb_buffer_set_direction()
 962  *
 963  * Return value:
 964  * The direction of the @buffer.
 965  *
 966  * Since: 0.9.2
 967  **/
 968 hb_direction_t
 969 hb_buffer_get_direction (hb_buffer_t    *buffer)
 970 {
 971   return buffer-&gt;props.direction;
 972 }
 973 
 974 /**
 975  * hb_buffer_set_script:
 976  * @buffer: an #hb_buffer_t.
 977  * @script: an #hb_script_t to set.
 978  *
 979  * Sets the script of @buffer to @script.
 980  *
 981  * Script is crucial for choosing the proper shaping behaviour for scripts that
 982  * require it (e.g. Arabic) and the which OpenType features defined in the font
 983  * to be applied.
 984  *
 985  * You can pass one of the predefined #hb_script_t values, or use
 986  * hb_script_from_string() or hb_script_from_iso15924_tag() to get the
 987  * corresponding script from an ISO 15924 script tag.
 988  *
 989  * Since: 0.9.2
 990  **/
 991 void
 992 hb_buffer_set_script (hb_buffer_t *buffer,
 993                       hb_script_t  script)
 994 {
 995   if (unlikely (hb_object_is_inert (buffer)))
 996     return;
 997 
 998   buffer-&gt;props.script = script;
 999 }
1000 
1001 /**
1002  * hb_buffer_get_script:
1003  * @buffer: an #hb_buffer_t.
1004  *
1005  * See hb_buffer_set_script().
1006  *
1007  * Return value:
1008  * The #hb_script_t of the @buffer.
1009  *
1010  * Since: 0.9.2
1011  **/
1012 hb_script_t
1013 hb_buffer_get_script (hb_buffer_t *buffer)
1014 {
1015   return buffer-&gt;props.script;
1016 }
1017 
1018 /**
1019  * hb_buffer_set_language:
1020  * @buffer: an #hb_buffer_t.
1021  * @language: an hb_language_t to set.
1022  *
1023  * Sets the language of @buffer to @language.
1024  *
1025  * Languages are crucial for selecting which OpenType feature to apply to the
1026  * buffer which can result in applying language-specific behaviour. Languages
1027  * are orthogonal to the scripts, and though they are related, they are
1028  * different concepts and should not be confused with each other.
1029  *
1030  * Use hb_language_from_string() to convert from ISO 639 language codes to
1031  * #hb_language_t.
1032  *
1033  * Since: 0.9.2
1034  **/
1035 void
1036 hb_buffer_set_language (hb_buffer_t   *buffer,
1037                         hb_language_t  language)
1038 {
1039   if (unlikely (hb_object_is_inert (buffer)))
1040     return;
1041 
1042   buffer-&gt;props.language = language;
1043 }
1044 
1045 /**
1046  * hb_buffer_get_language:
1047  * @buffer: an #hb_buffer_t.
1048  *
1049  * See hb_buffer_set_language().
1050  *
1051  * Return value: (transfer none):
1052  * The #hb_language_t of the buffer. Must not be freed by the caller.
1053  *
1054  * Since: 0.9.2
1055  **/
1056 hb_language_t
1057 hb_buffer_get_language (hb_buffer_t *buffer)
1058 {
1059   return buffer-&gt;props.language;
1060 }
1061 
1062 /**
1063  * hb_buffer_set_segment_properties:
1064  * @buffer: an #hb_buffer_t.
1065  * @props: an #hb_segment_properties_t to use.
1066  *
1067  * Sets the segment properties of the buffer, a shortcut for calling
1068  * hb_buffer_set_direction(), hb_buffer_set_script() and
1069  * hb_buffer_set_language() individually.
1070  *
1071  * Since: 0.9.7
1072  **/
1073 void
1074 hb_buffer_set_segment_properties (hb_buffer_t *buffer,
1075                                   const hb_segment_properties_t *props)
1076 {
1077   if (unlikely (hb_object_is_inert (buffer)))
1078     return;
1079 
1080   buffer-&gt;props = *props;
1081 }
1082 
1083 /**
1084  * hb_buffer_get_segment_properties:
1085  * @buffer: an #hb_buffer_t.
1086  * @props: (out): the output #hb_segment_properties_t.
1087  *
1088  * Sets @props to the #hb_segment_properties_t of @buffer.
1089  *
1090  * Since: 0.9.7
1091  **/
1092 void
1093 hb_buffer_get_segment_properties (hb_buffer_t *buffer,
1094                                   hb_segment_properties_t *props)
1095 {
1096   *props = buffer-&gt;props;
1097 }
1098 
1099 
1100 /**
1101  * hb_buffer_set_flags:
1102  * @buffer: an #hb_buffer_t.
1103  * @flags: the buffer flags to set.
1104  *
1105  * Sets @buffer flags to @flags. See #hb_buffer_flags_t.
1106  *
1107  * Since: 0.9.7
1108  **/
1109 void
1110 hb_buffer_set_flags (hb_buffer_t       *buffer,
1111                      hb_buffer_flags_t  flags)
1112 {
1113   if (unlikely (hb_object_is_inert (buffer)))
1114     return;
1115 
1116   buffer-&gt;flags = flags;
1117 }
1118 
1119 /**
1120  * hb_buffer_get_flags:
1121  * @buffer: an #hb_buffer_t.
1122  *
1123  * See hb_buffer_set_flags().
1124  *
1125  * Return value:
1126  * The @buffer flags.
1127  *
1128  * Since: 0.9.7
1129  **/
1130 hb_buffer_flags_t
1131 hb_buffer_get_flags (hb_buffer_t *buffer)
1132 {
1133   return buffer-&gt;flags;
1134 }
1135 
1136 /**
1137  * hb_buffer_set_cluster_level:
1138  * @buffer: an #hb_buffer_t.
1139  * @cluster_level:
1140  *
1141  *
1142  *
1143  * Since: 0.9.42
1144  **/
1145 void
1146 hb_buffer_set_cluster_level (hb_buffer_t       *buffer,
1147                      hb_buffer_cluster_level_t  cluster_level)
1148 {
1149   if (unlikely (hb_object_is_inert (buffer)))
1150     return;
1151 
1152   buffer-&gt;cluster_level = cluster_level;
1153 }
1154 
1155 /**
1156  * hb_buffer_get_cluster_level:
1157  * @buffer: an #hb_buffer_t.
1158  *
1159  *
1160  *
1161  * Return value:
1162  *
1163  * Since: 0.9.42
1164  **/
1165 hb_buffer_cluster_level_t
1166 hb_buffer_get_cluster_level (hb_buffer_t *buffer)
1167 {
1168   return buffer-&gt;cluster_level;
1169 }
1170 
1171 
1172 /**
1173  * hb_buffer_set_replacement_codepoint:
1174  * @buffer: an #hb_buffer_t.
1175  * @replacement: the replacement #hb_codepoint_t
1176  *
1177  * Sets the #hb_codepoint_t that replaces invalid entries for a given encoding
1178  * when adding text to @buffer.
1179  *
1180  * Default is %HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT.
1181  *
1182  * Since: 0.9.31
1183  **/
1184 void
1185 hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,
1186                                      hb_codepoint_t  replacement)
1187 {
1188   if (unlikely (hb_object_is_inert (buffer)))
1189     return;
1190 
1191   buffer-&gt;replacement = replacement;
1192 }
1193 
1194 /**
1195  * hb_buffer_get_replacement_codepoint:
1196  * @buffer: an #hb_buffer_t.
1197  *
1198  * See hb_buffer_set_replacement_codepoint().
1199  *
1200  * Return value:
1201  * The @buffer replacement #hb_codepoint_t.
1202  *
1203  * Since: 0.9.31
1204  **/
1205 hb_codepoint_t
1206 hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer)
1207 {
1208   return buffer-&gt;replacement;
1209 }
1210 
1211 
1212 /**
1213  * hb_buffer_reset:
1214  * @buffer: an #hb_buffer_t.
1215  *
1216  * Resets the buffer to its initial status, as if it was just newly created
1217  * with hb_buffer_create().
1218  *
1219  * Since: 0.9.2
1220  **/
1221 void
1222 hb_buffer_reset (hb_buffer_t *buffer)
1223 {
1224   buffer-&gt;reset ();
1225 }
1226 
1227 /**
1228  * hb_buffer_clear_contents:
1229  * @buffer: an #hb_buffer_t.
1230  *
1231  * Similar to hb_buffer_reset(), but does not clear the Unicode functions and
1232  * the replacement code point.
1233  *
1234  * Since: 0.9.11
1235  **/
1236 void
1237 hb_buffer_clear_contents (hb_buffer_t *buffer)
1238 {
1239   buffer-&gt;clear ();
1240 }
1241 
1242 /**
1243  * hb_buffer_pre_allocate:
1244  * @buffer: an #hb_buffer_t.
1245  * @size: number of items to pre allocate.
1246  *
1247  * Pre allocates memory for @buffer to fit at least @size number of items.
1248  *
1249  * Return value:
1250  * %true if @buffer memory allocation succeeded, %false otherwise.
1251  *
1252  * Since: 0.9.2
1253  **/
1254 hb_bool_t
1255 hb_buffer_pre_allocate (hb_buffer_t *buffer, unsigned int size)
1256 {
1257   return buffer-&gt;ensure (size);
1258 }
1259 
1260 /**
1261  * hb_buffer_allocation_successful:
1262  * @buffer: an #hb_buffer_t.
1263  *
1264  * Check if allocating memory for the buffer succeeded.
1265  *
1266  * Return value:
1267  * %true if @buffer memory allocation succeeded, %false otherwise.
1268  *
1269  * Since: 0.9.2
1270  **/
1271 hb_bool_t
1272 hb_buffer_allocation_successful (hb_buffer_t  *buffer)
1273 {
1274   return buffer-&gt;successful;
1275 }
1276 
1277 /**
1278  * hb_buffer_add:
1279  * @buffer: an #hb_buffer_t.
1280  * @codepoint: a Unicode code point.
1281  * @cluster: the cluster value of @codepoint.
1282  *
1283  * Appends a character with the Unicode value of @codepoint to @buffer, and
1284  * gives it the initial cluster value of @cluster. Clusters can be any thing
1285  * the client wants, they are usually used to refer to the index of the
1286  * character in the input text stream and are output in
1287  * #hb_glyph_info_t.cluster field.
1288  *
1289  * This function does not check the validity of @codepoint, it is up to the
1290  * caller to ensure it is a valid Unicode code point.
1291  *
1292  * Since: 0.9.7
1293  **/
1294 void
1295 hb_buffer_add (hb_buffer_t    *buffer,
1296                hb_codepoint_t  codepoint,
1297                unsigned int    cluster)
1298 {
1299   buffer-&gt;add (codepoint, cluster);
1300   buffer-&gt;clear_context (1);
1301 }
1302 
1303 /**
1304  * hb_buffer_set_length:
1305  * @buffer: an #hb_buffer_t.
1306  * @length: the new length of @buffer.
1307  *
1308  * Similar to hb_buffer_pre_allocate(), but clears any new items added at the
1309  * end.
1310  *
1311  * Return value:
1312  * %true if @buffer memory allocation succeeded, %false otherwise.
1313  *
1314  * Since: 0.9.2
1315  **/
1316 hb_bool_t
1317 hb_buffer_set_length (hb_buffer_t  *buffer,
1318                       unsigned int  length)
1319 {
1320   if (unlikely (hb_object_is_inert (buffer)))
1321     return length == 0;
1322 
1323   if (!buffer-&gt;ensure (length))
1324     return false;
1325 
1326   /* Wipe the new space */
1327   if (length &gt; buffer-&gt;len) {
1328     memset (buffer-&gt;info + buffer-&gt;len, 0, sizeof (buffer-&gt;info[0]) * (length - buffer-&gt;len));
1329     if (buffer-&gt;have_positions)
1330       memset (buffer-&gt;pos + buffer-&gt;len, 0, sizeof (buffer-&gt;pos[0]) * (length - buffer-&gt;len));
1331   }
1332 
1333   buffer-&gt;len = length;
1334 
1335   if (!length)
1336   {
1337     buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_INVALID;
1338     buffer-&gt;clear_context (0);
1339   }
1340   buffer-&gt;clear_context (1);
1341 
1342   return true;
1343 }
1344 
1345 /**
1346  * hb_buffer_get_length:
1347  * @buffer: an #hb_buffer_t.
1348  *
1349  * Returns the number of items in the buffer.
1350  *
1351  * Return value:
1352  * The @buffer length.
1353  * The value valid as long as buffer has not been modified.
1354  *
1355  * Since: 0.9.2
1356  **/
1357 unsigned int
1358 hb_buffer_get_length (hb_buffer_t *buffer)
1359 {
1360   return buffer-&gt;len;
1361 }
1362 
1363 /**
1364  * hb_buffer_get_glyph_infos:
1365  * @buffer: an #hb_buffer_t.
1366  * @length: (out): output array length.
1367  *
1368  * Returns @buffer glyph information array.  Returned pointer
1369  * is valid as long as @buffer contents are not modified.
1370  *
1371  * Return value: (transfer none) (array length=length):
1372  * The @buffer glyph information array.
1373  * The value valid as long as buffer has not been modified.
1374  *
1375  * Since: 0.9.2
1376  **/
1377 hb_glyph_info_t *
1378 hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,
1379                            unsigned int *length)
1380 {
1381   if (length)
1382     *length = buffer-&gt;len;
1383 
1384   return (hb_glyph_info_t *) buffer-&gt;info;
1385 }
1386 
1387 /**
1388  * hb_buffer_get_glyph_positions:
1389  * @buffer: an #hb_buffer_t.
1390  * @length: (out): output length.
1391  *
1392  * Returns @buffer glyph position array.  Returned pointer
1393  * is valid as long as @buffer contents are not modified.
1394  *
1395  * Return value: (transfer none) (array length=length):
1396  * The @buffer glyph position array.
1397  * The value valid as long as buffer has not been modified.
1398  *
1399  * Since: 0.9.2
1400  **/
1401 hb_glyph_position_t *
1402 hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,
1403                                unsigned int *length)
1404 {
1405   if (!buffer-&gt;have_positions)
1406     buffer-&gt;clear_positions ();
1407 
1408   if (length)
1409     *length = buffer-&gt;len;
1410 
1411   return (hb_glyph_position_t *) buffer-&gt;pos;
1412 }
1413 
1414 /**
1415  * hb_glyph_info_get_glyph_flags:
1416  * @info: a #hb_glyph_info_t.
1417  *
1418  * Returns glyph flags encoded within a #hb_glyph_info_t.
1419  *
1420  * Return value:
1421  * The #hb_glyph_flags_t encoded within @info.
1422  *
1423  * Since: 1.5.0
1424  **/
1425 hb_glyph_flags_t
1426 (hb_glyph_info_get_glyph_flags) (const hb_glyph_info_t *info)
1427 {
1428   return hb_glyph_info_get_glyph_flags (info);
1429 }
1430 
1431 /**
1432  * hb_buffer_reverse:
1433  * @buffer: an #hb_buffer_t.
1434  *
1435  * Reverses buffer contents.
1436  *
1437  * Since: 0.9.2
1438  **/
1439 void
1440 hb_buffer_reverse (hb_buffer_t *buffer)
1441 {
1442   buffer-&gt;reverse ();
1443 }
1444 
1445 /**
1446  * hb_buffer_reverse_range:
1447  * @buffer: an #hb_buffer_t.
1448  * @start: start index.
1449  * @end: end index.
1450  *
1451  * Reverses buffer contents between start to end.
1452  *
1453  * Since: 0.9.41
1454  **/
1455 void
1456 hb_buffer_reverse_range (hb_buffer_t *buffer,
1457                          unsigned int start, unsigned int end)
1458 {
1459   buffer-&gt;reverse_range (start, end);
1460 }
1461 
1462 /**
1463  * hb_buffer_reverse_clusters:
1464  * @buffer: an #hb_buffer_t.
1465  *
1466  * Reverses buffer clusters.  That is, the buffer contents are
1467  * reversed, then each cluster (consecutive items having the
1468  * same cluster number) are reversed again.
1469  *
1470  * Since: 0.9.2
1471  **/
1472 void
1473 hb_buffer_reverse_clusters (hb_buffer_t *buffer)
1474 {
1475   buffer-&gt;reverse_clusters ();
1476 }
1477 
1478 /**
1479  * hb_buffer_guess_segment_properties:
1480  * @buffer: an #hb_buffer_t.
1481  *
1482  * Sets unset buffer segment properties based on buffer Unicode
1483  * contents.  If buffer is not empty, it must have content type
1484  * %HB_BUFFER_CONTENT_TYPE_UNICODE.
1485  *
1486  * If buffer script is not set (ie. is %HB_SCRIPT_INVALID), it
1487  * will be set to the Unicode script of the first character in
1488  * the buffer that has a script other than %HB_SCRIPT_COMMON,
1489  * %HB_SCRIPT_INHERITED, and %HB_SCRIPT_UNKNOWN.
1490  *
1491  * Next, if buffer direction is not set (ie. is %HB_DIRECTION_INVALID),
1492  * it will be set to the natural horizontal direction of the
1493  * buffer script as returned by hb_script_get_horizontal_direction().
1494  * If hb_script_get_horizontal_direction() returns %HB_DIRECTION_INVALID,
1495  * then %HB_DIRECTION_LTR is used.
1496  *
1497  * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),
1498  * it will be set to the process&#39;s default language as returned by
1499  * hb_language_get_default().  This may change in the future by
1500  * taking buffer script into consideration when choosing a language.
1501  *
1502  * Since: 0.9.7
1503  **/
1504 void
1505 hb_buffer_guess_segment_properties (hb_buffer_t *buffer)
1506 {
1507   buffer-&gt;guess_segment_properties ();
1508 }
1509 
1510 template &lt;typename utf_t&gt;
1511 static inline void
1512 hb_buffer_add_utf (hb_buffer_t  *buffer,
1513                    const typename utf_t::codepoint_t *text,
1514                    int           text_length,
1515                    unsigned int  item_offset,
1516                    int           item_length)
1517 {
1518   typedef typename utf_t::codepoint_t T;
1519   const hb_codepoint_t replacement = buffer-&gt;replacement;
1520 
1521   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||
1522           (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
1523 
1524   if (unlikely (hb_object_is_inert (buffer)))
1525     return;
1526 
1527   if (text_length == -1)
1528     text_length = utf_t::strlen (text);
1529 
1530   if (item_length == -1)
1531     item_length = text_length - item_offset;
1532 
1533   buffer-&gt;ensure (buffer-&gt;len + item_length * sizeof (T) / 4);
1534 
1535   /* If buffer is empty and pre-context provided, install it.
1536    * This check is written this way, to make sure people can
1537    * provide pre-context in one add_utf() call, then provide
1538    * text in a follow-up call.  See:
1539    *
1540    * https://bugzilla.mozilla.org/show_bug.cgi?id=801410#c13
1541    */
1542   if (!buffer-&gt;len &amp;&amp; item_offset &gt; 0)
1543   {
1544     /* Add pre-context */
1545     buffer-&gt;clear_context (0);
1546     const T *prev = text + item_offset;
1547     const T *start = text;
1548     while (start &lt; prev &amp;&amp; buffer-&gt;context_len[0] &lt; buffer-&gt;CONTEXT_LENGTH)
1549     {
1550       hb_codepoint_t u;
1551       prev = utf_t::prev (prev, start, &amp;u, replacement);
1552       buffer-&gt;context[0][buffer-&gt;context_len[0]++] = u;
1553     }
1554   }
1555 
1556   const T *next = text + item_offset;
1557   const T *end = next + item_length;
1558   while (next &lt; end)
1559   {
1560     hb_codepoint_t u;
1561     const T *old_next = next;
1562     next = utf_t::next (next, end, &amp;u, replacement);
1563     buffer-&gt;add (u, old_next - (const T *) text);
1564   }
1565 
1566   /* Add post-context */
1567   buffer-&gt;clear_context (1);
1568   end = text + text_length;
1569   while (next &lt; end &amp;&amp; buffer-&gt;context_len[1] &lt; buffer-&gt;CONTEXT_LENGTH)
1570   {
1571     hb_codepoint_t u;
1572     next = utf_t::next (next, end, &amp;u, replacement);
1573     buffer-&gt;context[1][buffer-&gt;context_len[1]++] = u;
1574   }
1575 
1576   buffer-&gt;content_type = HB_BUFFER_CONTENT_TYPE_UNICODE;
1577 }
1578 
1579 /**
1580  * hb_buffer_add_utf8:
1581  * @buffer: an #hb_buffer_t.
1582  * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8
1583  *               characters to append.
1584  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1585  * @item_offset: the offset of the first character to add to the @buffer.
1586  * @item_length: the number of characters to add to the @buffer, or -1 for the
1587  *               end of @text (assuming it is %NULL terminated).
1588  *
1589  * See hb_buffer_add_codepoints().
1590  *
1591  * Replaces invalid UTF-8 characters with the @buffer replacement code point,
1592  * see hb_buffer_set_replacement_codepoint().
1593  *
1594  * Since: 0.9.2
1595  **/
1596 void
1597 hb_buffer_add_utf8 (hb_buffer_t  *buffer,
1598                     const char   *text,
1599                     int           text_length,
1600                     unsigned int  item_offset,
1601                     int           item_length)
1602 {
1603   hb_buffer_add_utf&lt;hb_utf8_t&gt; (buffer, (const uint8_t *) text, text_length, item_offset, item_length);
1604 }
1605 
1606 /**
1607  * hb_buffer_add_utf16:
1608  * @buffer: an #hb_buffer_t.
1609  * @text: (array length=text_length): an array of UTF-16 characters to append.
1610  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1611  * @item_offset: the offset of the first character to add to the @buffer.
1612  * @item_length: the number of characters to add to the @buffer, or -1 for the
1613  *               end of @text (assuming it is %NULL terminated).
1614  *
1615  * See hb_buffer_add_codepoints().
1616  *
1617  * Replaces invalid UTF-16 characters with the @buffer replacement code point,
1618  * see hb_buffer_set_replacement_codepoint().
1619  *
1620  * Since: 0.9.2
1621  **/
1622 void
1623 hb_buffer_add_utf16 (hb_buffer_t    *buffer,
1624                      const uint16_t *text,
1625                      int             text_length,
1626                      unsigned int    item_offset,
1627                      int             item_length)
1628 {
1629   hb_buffer_add_utf&lt;hb_utf16_t&gt; (buffer, text, text_length, item_offset, item_length);
1630 }
1631 
1632 /**
1633  * hb_buffer_add_utf32:
1634  * @buffer: an #hb_buffer_t.
1635  * @text: (array length=text_length): an array of UTF-32 characters to append.
1636  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1637  * @item_offset: the offset of the first character to add to the @buffer.
1638  * @item_length: the number of characters to add to the @buffer, or -1 for the
1639  *               end of @text (assuming it is %NULL terminated).
1640  *
1641  * See hb_buffer_add_codepoints().
1642  *
1643  * Replaces invalid UTF-32 characters with the @buffer replacement code point,
1644  * see hb_buffer_set_replacement_codepoint().
1645  *
1646  * Since: 0.9.2
1647  **/
1648 void
1649 hb_buffer_add_utf32 (hb_buffer_t    *buffer,
1650                      const uint32_t *text,
1651                      int             text_length,
1652                      unsigned int    item_offset,
1653                      int             item_length)
1654 {
1655   hb_buffer_add_utf&lt;hb_utf32_t&lt;&gt; &gt; (buffer, text, text_length, item_offset, item_length);
1656 }
1657 
1658 /**
1659  * hb_buffer_add_latin1:
1660  * @buffer: an #hb_buffer_t.
1661  * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8
1662  *               characters to append.
1663  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1664  * @item_offset: the offset of the first character to add to the @buffer.
1665  * @item_length: the number of characters to add to the @buffer, or -1 for the
1666  *               end of @text (assuming it is %NULL terminated).
1667  *
1668  * Similar to hb_buffer_add_codepoints(), but allows only access to first 256
1669  * Unicode code points that can fit in 8-bit strings.
1670  *
1671  * &lt;note&gt;Has nothing to do with non-Unicode Latin-1 encoding.&lt;/note&gt;
1672  *
1673  * Since: 0.9.39
1674  **/
1675 void
1676 hb_buffer_add_latin1 (hb_buffer_t   *buffer,
1677                       const uint8_t *text,
1678                       int            text_length,
1679                       unsigned int   item_offset,
1680                       int            item_length)
1681 {
1682   hb_buffer_add_utf&lt;hb_latin1_t&gt; (buffer, text, text_length, item_offset, item_length);
1683 }
1684 
1685 /**
1686  * hb_buffer_add_codepoints:
1687  * @buffer: a #hb_buffer_t to append characters to.
1688  * @text: (array length=text_length): an array of Unicode code points to append.
1689  * @text_length: the length of the @text, or -1 if it is %NULL terminated.
1690  * @item_offset: the offset of the first code point to add to the @buffer.
1691  * @item_length: the number of code points to add to the @buffer, or -1 for the
1692  *               end of @text (assuming it is %NULL terminated).
1693  *
1694  * Appends characters from @text array to @buffer. The @item_offset is the
1695  * position of the first character from @text that will be appended, and
1696  * @item_length is the number of character. When shaping part of a larger text
1697  * (e.g. a run of text from a paragraph), instead of passing just the substring
1698  * corresponding to the run, it is preferable to pass the whole
1699  * paragraph and specify the run start and length as @item_offset and
1700  * @item_length, respectively, to give HarfBuzz the full context to be able,
1701  * for example, to do cross-run Arabic shaping or properly handle combining
1702  * marks at stat of run.
1703  *
1704  * This function does not check the validity of @text, it is up to the caller
1705  * to ensure it contains a valid Unicode code points.
1706  *
1707  * Since: 0.9.31
1708  **/
1709 void
1710 hb_buffer_add_codepoints (hb_buffer_t          *buffer,
1711                           const hb_codepoint_t *text,
1712                           int                   text_length,
1713                           unsigned int          item_offset,
1714                           int                   item_length)
1715 {
1716   hb_buffer_add_utf&lt;hb_utf32_t&lt;false&gt; &gt; (buffer, text, text_length, item_offset, item_length);
1717 }
1718 
1719 
1720 /**
1721  * hb_buffer_append:
1722  * @buffer: an #hb_buffer_t.
1723  * @source: source #hb_buffer_t.
1724  * @start: start index into source buffer to copy.  Use 0 to copy from start of buffer.
1725  * @end: end index into source buffer to copy.  Use (unsigned int) -1 to copy to end of buffer.
1726  *
1727  * Append (part of) contents of another buffer to this buffer.
1728  *
1729  * Since: 1.5.0
1730  **/
1731 HB_EXTERN void
1732 hb_buffer_append (hb_buffer_t *buffer,
1733                   hb_buffer_t *source,
1734                   unsigned int start,
1735                   unsigned int end)
1736 {
1737   assert (!buffer-&gt;have_output &amp;&amp; !source-&gt;have_output);
1738   assert (buffer-&gt;have_positions == source-&gt;have_positions ||
1739           !buffer-&gt;len || !source-&gt;len);
1740   assert (buffer-&gt;content_type == source-&gt;content_type ||
1741           !buffer-&gt;len || !source-&gt;len);
1742 
1743   if (end &gt; source-&gt;len)
1744     end = source-&gt;len;
1745   if (start &gt; end)
1746     start = end;
1747   if (start == end)
1748     return;
1749 
1750   if (!buffer-&gt;len)
1751     buffer-&gt;content_type = source-&gt;content_type;
1752   if (!buffer-&gt;have_positions &amp;&amp; source-&gt;have_positions)
1753     buffer-&gt;clear_positions ();
1754 
1755   if (buffer-&gt;len + (end - start) &lt; buffer-&gt;len) /* Overflows. */
1756   {
1757     buffer-&gt;successful = false;
1758     return;
1759   }
1760 
1761   unsigned int orig_len = buffer-&gt;len;
1762   hb_buffer_set_length (buffer, buffer-&gt;len + (end - start));
1763   if (unlikely (!buffer-&gt;successful))
1764     return;
1765 
1766   memcpy (buffer-&gt;info + orig_len, source-&gt;info + start, (end - start) * sizeof (buffer-&gt;info[0]));
1767   if (buffer-&gt;have_positions)
1768     memcpy (buffer-&gt;pos + orig_len, source-&gt;pos + start, (end - start) * sizeof (buffer-&gt;pos[0]));
1769 }
1770 
1771 
1772 static int
1773 compare_info_codepoint (const hb_glyph_info_t *pa,
1774                         const hb_glyph_info_t *pb)
1775 {
1776   return (int) pb-&gt;codepoint - (int) pa-&gt;codepoint;
1777 }
1778 
1779 static inline void
1780 normalize_glyphs_cluster (hb_buffer_t *buffer,
1781                           unsigned int start,
1782                           unsigned int end,
1783                           bool backward)
1784 {
1785   hb_glyph_position_t *pos = buffer-&gt;pos;
1786 
1787   /* Total cluster advance */
1788   hb_position_t total_x_advance = 0, total_y_advance = 0;
1789   for (unsigned int i = start; i &lt; end; i++)
1790   {
1791     total_x_advance += pos[i].x_advance;
1792     total_y_advance += pos[i].y_advance;
1793   }
1794 
1795   hb_position_t x_advance = 0, y_advance = 0;
1796   for (unsigned int i = start; i &lt; end; i++)
1797   {
1798     pos[i].x_offset += x_advance;
1799     pos[i].y_offset += y_advance;
1800 
1801     x_advance += pos[i].x_advance;
1802     y_advance += pos[i].y_advance;
1803 
1804     pos[i].x_advance = 0;
1805     pos[i].y_advance = 0;
1806   }
1807 
1808   if (backward)
1809   {
1810     /* Transfer all cluster advance to the last glyph. */
1811     pos[end - 1].x_advance = total_x_advance;
1812     pos[end - 1].y_advance = total_y_advance;
1813 
1814     hb_stable_sort (buffer-&gt;info + start, end - start - 1, compare_info_codepoint, buffer-&gt;pos + start);
1815   } else {
1816     /* Transfer all cluster advance to the first glyph. */
1817     pos[start].x_advance += total_x_advance;
1818     pos[start].y_advance += total_y_advance;
1819     for (unsigned int i = start + 1; i &lt; end; i++) {
1820       pos[i].x_offset -= total_x_advance;
1821       pos[i].y_offset -= total_y_advance;
1822     }
1823     hb_stable_sort (buffer-&gt;info + start + 1, end - start - 1, compare_info_codepoint, buffer-&gt;pos + start + 1);
1824   }
1825 }
1826 
1827 /**
1828  * hb_buffer_normalize_glyphs:
1829  * @buffer: an #hb_buffer_t.
1830  *
1831  * Reorders a glyph buffer to have canonical in-cluster glyph order / position.
1832  * The resulting clusters should behave identical to pre-reordering clusters.
1833  *
1834  * &lt;note&gt;This has nothing to do with Unicode normalization.&lt;/note&gt;
1835  *
1836  * Since: 0.9.2
1837  **/
1838 void
1839 hb_buffer_normalize_glyphs (hb_buffer_t *buffer)
1840 {
1841   assert (buffer-&gt;have_positions);
1842   assert (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS ||
1843           (!buffer-&gt;len &amp;&amp; buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_INVALID));
1844 
1845   bool backward = HB_DIRECTION_IS_BACKWARD (buffer-&gt;props.direction);
1846 
1847   unsigned int count = buffer-&gt;len;
1848   if (unlikely (!count)) return;
1849   hb_glyph_info_t *info = buffer-&gt;info;
1850 
1851   unsigned int start = 0;
1852   unsigned int end;
1853   for (end = start + 1; end &lt; count; end++)
1854     if (info[start].cluster != info[end].cluster) {
1855       normalize_glyphs_cluster (buffer, start, end, backward);
1856       start = end;
1857     }
1858   normalize_glyphs_cluster (buffer, start, end, backward);
1859 }
1860 
1861 void
1862 hb_buffer_t::sort (unsigned int start, unsigned int end, int(*compar)(const hb_glyph_info_t *, const hb_glyph_info_t *))
1863 {
1864   assert (!have_positions);
1865   for (unsigned int i = start + 1; i &lt; end; i++)
1866   {
1867     unsigned int j = i;
1868     while (j &gt; start &amp;&amp; compar (&amp;info[j - 1], &amp;info[i]) &gt; 0)
1869       j--;
1870     if (i == j)
1871       continue;
1872     /* Move item i to occupy place for item j, shift what&#39;s in between. */
1873     merge_clusters (j, i + 1);
1874     {
1875       hb_glyph_info_t t = info[i];
1876       memmove (&amp;info[j + 1], &amp;info[j], (i - j) * sizeof (hb_glyph_info_t));
1877       info[j] = t;
1878     }
1879   }
1880 }
1881 
1882 
1883 /*
1884  * Comparing buffers.
1885  */
1886 
1887 /**
1888  * hb_buffer_diff:
1889  *
1890  * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT
1891  * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most
1892  * callers if just comparing two buffers is needed.
1893  *
1894  * Since: 1.5.0
1895  **/
1896 hb_buffer_diff_flags_t
1897 hb_buffer_diff (hb_buffer_t *buffer,
1898                 hb_buffer_t *reference,
1899                 hb_codepoint_t dottedcircle_glyph,
1900                 unsigned int position_fuzz)
1901 {
1902   if (buffer-&gt;content_type != reference-&gt;content_type &amp;&amp; buffer-&gt;len &amp;&amp; reference-&gt;len)
1903     return HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH;
1904 
1905   hb_buffer_diff_flags_t result = HB_BUFFER_DIFF_FLAG_EQUAL;
1906   bool contains = dottedcircle_glyph != (hb_codepoint_t) -1;
1907 
1908   unsigned int count = reference-&gt;len;
1909 
1910   if (buffer-&gt;len != count)
1911   {
1912     /*
1913      * we can&#39;t compare glyph-by-glyph, but we do want to know if there
1914      * are .notdef or dottedcircle glyphs present in the reference buffer
1915      */
1916     const hb_glyph_info_t *info = reference-&gt;info;
1917     unsigned int i;
1918     for (i = 0; i &lt; count; i++)
1919     {
1920       if (contains &amp;&amp; info[i].codepoint == dottedcircle_glyph)
1921         result |= HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT;
1922       if (contains &amp;&amp; info[i].codepoint == 0)
1923         result |= HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT;
1924     }
1925     result |= HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH;
1926     return hb_buffer_diff_flags_t (result);
1927   }
1928 
1929   if (!count)
1930     return hb_buffer_diff_flags_t (result);
1931 
1932   const hb_glyph_info_t *buf_info = buffer-&gt;info;
1933   const hb_glyph_info_t *ref_info = reference-&gt;info;
1934   for (unsigned int i = 0; i &lt; count; i++)
1935   {
1936     if (buf_info-&gt;codepoint != ref_info-&gt;codepoint)
1937       result |= HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH;
1938     if (buf_info-&gt;cluster != ref_info-&gt;cluster)
1939       result |= HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH;
1940     if ((buf_info-&gt;mask &amp; ~ref_info-&gt;mask &amp; HB_GLYPH_FLAG_DEFINED))
1941       result |= HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH;
1942     if (contains &amp;&amp; ref_info-&gt;codepoint == dottedcircle_glyph)
1943       result |= HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT;
1944     if (contains &amp;&amp; ref_info-&gt;codepoint == 0)
1945       result |= HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT;
1946     buf_info++;
1947     ref_info++;
1948   }
1949 
1950   if (buffer-&gt;content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS)
1951   {
1952     assert (buffer-&gt;have_positions);
1953     const hb_glyph_position_t *buf_pos = buffer-&gt;pos;
1954     const hb_glyph_position_t *ref_pos = reference-&gt;pos;
1955     for (unsigned int i = 0; i &lt; count; i++)
1956     {
1957       if ((unsigned int) abs (buf_pos-&gt;x_advance - ref_pos-&gt;x_advance) &gt; position_fuzz ||
1958           (unsigned int) abs (buf_pos-&gt;y_advance - ref_pos-&gt;y_advance) &gt; position_fuzz ||
1959           (unsigned int) abs (buf_pos-&gt;x_offset - ref_pos-&gt;x_offset) &gt; position_fuzz ||
1960           (unsigned int) abs (buf_pos-&gt;y_offset - ref_pos-&gt;y_offset) &gt; position_fuzz)
1961       {
1962         result |= HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH;
1963         break;
1964       }
1965       buf_pos++;
1966       ref_pos++;
1967     }
1968   }
1969 
1970   return result;
1971 }
1972 
1973 
1974 /*
1975  * Debugging.
1976  */
1977 
1978 /**
1979  * hb_buffer_set_message_func:
1980  * @buffer: an #hb_buffer_t.
1981  * @func: (closure user_data) (destroy destroy) (scope notified):
1982  * @user_data:
1983  * @destroy:
1984  *
1985  *
1986  *
1987  * Since: 1.1.3
1988  **/
1989 void
1990 hb_buffer_set_message_func (hb_buffer_t *buffer,
1991                             hb_buffer_message_func_t func,
1992                             void *user_data, hb_destroy_func_t destroy)
1993 {
1994   if (buffer-&gt;message_destroy)
1995     buffer-&gt;message_destroy (buffer-&gt;message_data);
1996 
1997   if (func) {
1998     buffer-&gt;message_func = func;
1999     buffer-&gt;message_data = user_data;
2000     buffer-&gt;message_destroy = destroy;
2001   } else {
2002     buffer-&gt;message_func = nullptr;
2003     buffer-&gt;message_data = nullptr;
2004     buffer-&gt;message_destroy = nullptr;
2005   }
2006 }
2007 
2008 bool
2009 hb_buffer_t::message_impl (hb_font_t *font, const char *fmt, va_list ap)
2010 {
2011   char buf[100];
2012   vsnprintf (buf, sizeof (buf),  fmt, ap);
2013   return (bool) this-&gt;message_func (this, font, buf, this-&gt;message_data);
2014 }
    </pre>
  </body>
</html>
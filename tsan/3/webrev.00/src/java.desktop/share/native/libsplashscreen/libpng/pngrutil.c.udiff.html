<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libsplashscreen/libpng/pngrutil.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="pngrtran.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngset.c.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/libpng/pngrutil.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,14 +27,14 @@</span>
   * This file is available under and governed by the GNU General Public
   * License version 2 only, as published by the Free Software Foundation.
   * However, the following notice accompanied the original version of this
   * file and, per its terms, should not be removed:
   *
<span class="udiff-line-modified-removed">-  * Last changed in libpng 1.6.35 [July 15, 2018]</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 2018 Cosmin Truta</span>
   * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="udiff-line-modified-removed">-  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)</span>
<span class="udiff-line-modified-removed">-  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1996-1997 Andreas Dilger</span>
<span class="udiff-line-modified-added">+  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.</span>
   *
   * This code is released under the libpng license.
   * For conditions of distribution and use, see the disclaimer
   * and license in png.h
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1487,12 +1487,11 @@</span>
  
                 if (size == 0)
                 {
                    /* We have the ICC profile header; do the basic header checks.
                     */
<span class="udiff-line-modified-removed">-                   const png_uint_32 profile_length =</span>
<span class="udiff-line-removed">-                      png_get_uint_32(profile_header);</span>
<span class="udiff-line-modified-added">+                   png_uint_32 profile_length = png_get_uint_32(profile_header);</span>
  
                    if (png_icc_check_length(png_ptr, &amp;png_ptr-&gt;colorspace,
                        keyword, profile_length) != 0)
                    {
                       /* The length is apparently ok, so we can check the 132
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1505,12 +1504,12 @@</span>
                          /* Now read the tag table; a variable size buffer is
                           * needed at this point, allocate one for the whole
                           * profile.  The header check has already validated
                           * that none of this stuff will overflow.
                           */
<span class="udiff-line-modified-removed">-                         const png_uint_32 tag_count = png_get_uint_32(</span>
<span class="udiff-line-modified-removed">-                             profile_header+128);</span>
<span class="udiff-line-modified-added">+                         png_uint_32 tag_count =</span>
<span class="udiff-line-modified-added">+                            png_get_uint_32(profile_header + 128);</span>
                          png_bytep profile = png_read_buffer(png_ptr,
                              profile_length, 2/*silent*/);
  
                          if (profile != NULL)
                          {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3158,11 +3157,11 @@</span>
   *
   * ((c) &lt; 65 || (c) &gt; 122 || ((c) &gt; 90 &amp;&amp; (c) &lt; 97))
   */
  
  void /* PRIVATE */
<span class="udiff-line-modified-removed">- png_check_chunk_name(png_const_structrp png_ptr, const png_uint_32 chunk_name)</span>
<span class="udiff-line-modified-added">+ png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)</span>
  {
     int i;
     png_uint_32 cn=chunk_name;
  
     png_debug(1, &quot;in png_check_chunk_name&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3177,11 +3176,11 @@</span>
        cn &gt;&gt;= 8;
     }
  }
  
  void /* PRIVATE */
<span class="udiff-line-modified-removed">- png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)</span>
<span class="udiff-line-modified-added">+ png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)</span>
  {
     png_alloc_size_t limit = PNG_UINT_31_MAX;
  
  # ifdef PNG_SET_USER_LIMITS_SUPPORTED
     if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3389,22 +3388,22 @@</span>
  #        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
  
           /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
            * then pass:
            */
<span class="udiff-line-modified-removed">-          static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =</span>
<span class="udiff-line-modified-added">+          static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =</span>
           {
              /* Little-endian byte masks for PACKSWAP */
              { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
              /* Normal (big-endian byte) masks - PNG format */
              { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
           };
  
           /* display_mask has only three entries for the odd passes, so index by
            * pass&gt;&gt;1.
            */
<span class="udiff-line-modified-removed">-          static PNG_CONST png_uint_32 display_mask[2][3][3] =</span>
<span class="udiff-line-modified-added">+          static const png_uint_32 display_mask[2][3][3] =</span>
           {
              /* Little-endian byte masks for PACKSWAP */
              { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
              /* Normal (big-endian byte) masks - PNG format */
              { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3713,11 +3712,11 @@</span>
  png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
      png_uint_32 transformations /* Because these may affect the byte layout */)
  {
     /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
     /* Offset to next interlace block */
<span class="udiff-line-modified-removed">-    static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
<span class="udiff-line-modified-added">+    static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
  
     png_debug(1, &quot;in png_do_read_interlace&quot;);
     if (row != NULL &amp;&amp; row_info != NULL)
     {
        png_uint_32 final_width;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4355,20 +4354,20 @@</span>
  png_read_finish_row(png_structrp png_ptr)
  {
     /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
  
     /* Start of interlace block */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
  
     /* Offset to next interlace block */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
  
     /* Start of interlace block in the y direction */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
  
     /* Offset to next interlace block in the y direction */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
  
     png_debug(1, &quot;in png_read_finish_row&quot;);
     png_ptr-&gt;row_number++;
     if (png_ptr-&gt;row_number &lt; png_ptr-&gt;num_rows)
        return;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4420,20 +4419,20 @@</span>
  png_read_start_row(png_structrp png_ptr)
  {
     /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
  
     /* Start of interlace block */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
  
     /* Offset to next interlace block */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
  
     /* Start of interlace block in the y direction */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
  
     /* Offset to next interlace block in the y direction */
<span class="udiff-line-modified-removed">-    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
<span class="udiff-line-modified-added">+    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
  
     unsigned int max_pixel_depth;
     size_t row_bytes;
  
     png_debug(1, &quot;in png_read_start_row&quot;);
</pre>
<center><a href="pngrtran.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngset.c.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
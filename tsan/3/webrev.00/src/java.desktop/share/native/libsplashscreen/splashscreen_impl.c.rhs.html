<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libsplashscreen/splashscreen_impl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 #include &quot;splashscreen_gfx_impl.h&quot;
 28 #define BUFF_SIZE 1024
 29 #ifdef _MSC_VER
 30 # ifndef snprintf
 31 #       define snprintf _snprintf
 32 # endif
 33 #endif
 34 int splashIsVisible = 0;
 35 
 36 Splash *
 37 SplashGetInstance()
 38 {
 39     static Splash splash;
 40     static int preInitialized = 0;
 41     if (!preInitialized) {
 42         memset(&amp;splash, 0, sizeof(Splash));
 43         splash.currentFrame = -1;
 44         preInitialized = 1;
 45     }
 46     return &amp;splash;
 47 }
 48 
<a name="2" id="anc2"></a><span class="line-modified"> 49 JNIEXPORT void</span>
 50 SplashSetFileJarName(const char* fileName, const char* jarName) {
 51     Splash *splash = SplashGetInstance();
 52 
 53     free(splash-&gt;fileName);
 54     splash-&gt;fileName = SplashConvertStringAlloc(fileName, &amp;splash-&gt;fileNameLen);
 55 
 56     free(splash-&gt;jarName);
 57     splash-&gt;jarName = SplashConvertStringAlloc(jarName, &amp;splash-&gt;jarNameLen);
 58 }
 59 
<a name="3" id="anc3"></a><span class="line-modified"> 60 JNIEXPORT int</span>
 61 SplashInit()
 62 {
 63     Splash *splash = SplashGetInstance();
 64 
 65     memset(splash, 0, sizeof(Splash));
 66     splash-&gt;currentFrame = -1;
 67     splash-&gt;scaleFactor = 1;
 68     initFormat(&amp;splash-&gt;imageFormat, QUAD_RED_MASK, QUAD_GREEN_MASK,
 69         QUAD_BLUE_MASK, QUAD_ALPHA_MASK);
<a name="4" id="anc4"></a><span class="line-modified"> 70     return SplashInitPlatform(splash);</span>
 71 }
 72 
<a name="5" id="anc5"></a><span class="line-modified"> 73 JNIEXPORT void</span>
 74 SplashClose()
 75 {
 76     Splash *splash = SplashGetInstance();
 77 
 78     if (splash-&gt;isVisible &gt; 0) {
 79         SplashLock(splash);
 80         splash-&gt;isVisible = -1;
 81         SplashClosePlatform(splash);
 82         SplashUnlock(splash);
 83     }
 84 }
 85 
 86 void
 87 SplashCleanup(Splash * splash)
 88 {
 89     int i;
 90 
 91     splash-&gt;currentFrame = -1;
 92     SplashCleanupPlatform(splash);
 93     if (splash-&gt;frames) {
 94         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
 95             if (splash-&gt;frames[i].bitmapBits) {
 96                 free(splash-&gt;frames[i].bitmapBits);
 97                 splash-&gt;frames[i].bitmapBits = NULL;
 98             }
 99         }
100         free(splash-&gt;frames);
101         splash-&gt;frames = NULL;
102     }
103     if (splash-&gt;overlayData) {
104         free(splash-&gt;overlayData);
105         splash-&gt;overlayData = NULL;
106     }
107     SplashSetFileJarName(NULL, NULL);
108 }
109 
<a name="6" id="anc6"></a><span class="line-modified">110 JNIEXPORT void</span>
111 SplashSetScaleFactor(float scaleFactor)
112 {
113     Splash *splash = SplashGetInstance();
114     splash-&gt;scaleFactor = scaleFactor;
115 }
116 
117 void
118 SplashDone(Splash * splash)
119 {
120     SplashCleanup(splash);
121     SplashDonePlatform(splash);
122 }
123 
124 int
125 SplashIsStillLooping(Splash * splash)
126 {
127     if (splash-&gt;currentFrame &lt; 0) {
128         return 0;
129     }
130     return splash-&gt;loopCount != 1 ||
131         splash-&gt;currentFrame + 1 &lt; splash-&gt;frameCount;
132 }
133 
134 void
135 SplashUpdateScreenData(Splash * splash)
136 {
137     ImageRect srcRect, dstRect;
138     if (splash-&gt;currentFrame &lt; 0) {
139         return;
140     }
141 
142     initRect(&amp;srcRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
143         splash-&gt;width * sizeof(rgbquad_t),
144         splash-&gt;frames[splash-&gt;currentFrame].bitmapBits, &amp;splash-&gt;imageFormat);
145     if (splash-&gt;screenData) {
146         free(splash-&gt;screenData);
147     }
148     splash-&gt;screenStride = splash-&gt;width * splash-&gt;screenFormat.depthBytes;
149     if (splash-&gt;byteAlignment &gt; 1) {
150         splash-&gt;screenStride =
151             (splash-&gt;screenStride + splash-&gt;byteAlignment - 1) &amp;
152             ~(splash-&gt;byteAlignment - 1);
153     }
154     splash-&gt;screenData = malloc(splash-&gt;height * splash-&gt;screenStride);
155     initRect(&amp;dstRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
156         splash-&gt;screenStride, splash-&gt;screenData, &amp;splash-&gt;screenFormat);
157     if (splash-&gt;overlayData) {
158         convertRect2(&amp;srcRect, &amp;dstRect, CVT_BLEND, &amp;splash-&gt;overlayRect);
159     }
160     else {
161         convertRect(&amp;srcRect, &amp;dstRect, CVT_COPY);
162     }
163 }
164 
165 void
166 SplashNextFrame(Splash * splash)
167 {
168     if (splash-&gt;currentFrame &lt; 0) {
169         return;
170     }
171     do {
172         if (!SplashIsStillLooping(splash)) {
173             return;
174         }
175         splash-&gt;time += splash-&gt;frames[splash-&gt;currentFrame].delay;
176         if (++splash-&gt;currentFrame &gt;= splash-&gt;frameCount) {
177             splash-&gt;currentFrame = 0;
178             if (splash-&gt;loopCount &gt; 0) {
179                 splash-&gt;loopCount--;
180             }
181         }
182     } while (splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay -
183         SplashTime() &lt;= 0);
184 }
185 
186 int
187 BitmapToYXBandedRectangles(ImageRect * pSrcRect, RECT_T * out)
188 {
189     RECT_T *pPrevLine = NULL, *pFirst = out, *pThis = pFirst;
190     int i, j, i0;
191     int length;
192 
193     for (j = 0; j &lt; pSrcRect-&gt;numLines; j++) {
194 
195         /* generate data for a scanline */
196 
197         byte_t *pSrc = (byte_t *) pSrcRect-&gt;pBits + j * pSrcRect-&gt;stride;
198         RECT_T *pLine = pThis;
199 
200         i = 0;
201 
202         do {
203             while (i &lt; pSrcRect-&gt;numSamples &amp;&amp;
204                    getRGBA(pSrc, pSrcRect-&gt;format) &lt; ALPHA_THRESHOLD) {
205                 pSrc += pSrcRect-&gt;depthBytes;
206                 ++i;
207             }
208             if (i &gt;= pSrcRect-&gt;numSamples) {
209                 break;
210             }
211             i0 = i;
212             while (i &lt; pSrcRect-&gt;numSamples &amp;&amp;
213                    getRGBA(pSrc, pSrcRect-&gt;format) &gt;= ALPHA_THRESHOLD) {
214                 pSrc += pSrcRect-&gt;depthBytes;
215                 ++i;
216             }
217             RECT_SET(*pThis, i0, j, i - i0, 1);
218             ++pThis;
219         } while (i &lt; pSrcRect-&gt;numSamples);
220 
221         /*  check if the previous scanline is exactly the same, merge if so
222            (this is the only optimization we can use for YXBanded rectangles, and win32 supports
223            YXBanded only */
224 
225         length = pThis - pLine;
226         if (pPrevLine &amp;&amp; pLine - pPrevLine == length) {
227             for (i = 0; i &lt; length &amp;&amp; RECT_EQ_X(pPrevLine[i], pLine[i]); ++i) {
228             }
229             if (i == pLine - pPrevLine) {
230                 // do merge
231                 for (i = 0; i &lt; length; i++) {
232                     RECT_INC_HEIGHT(pPrevLine[i]);
233                 }
234                 pThis = pLine;
235                 continue;
236             }
237         }
238         /* or else use the generated scanline */
239 
240         pPrevLine = pLine;
241     }
242     return pThis - pFirst;
243 }
244 
245 typedef struct FILEFORMAT
246 {
247     int sign;
248     int (*decodeStream) (Splash * splash, SplashStream * stream);
249 } FILEFORMAT;
250 
251 static const FILEFORMAT formats[] = {
252     {0x47, SplashDecodeGifStream},
253     {0x89, SplashDecodePngStream},
254     {0xFF, SplashDecodeJpegStream}
255 };
256 
257 static int
258 SplashLoadStream(SplashStream * stream)
259 {
260     int success = 0;
261     int c;
262     size_t i;
263 
264     Splash *splash = SplashGetInstance();
265     if (splash-&gt;isVisible &lt; 0) {
<a name="7" id="anc7"></a><span class="line-added">266         stream-&gt;close(stream);</span>
267         return 0;
268     }
269 
270     SplashLock(splash);
271 
272     /* the formats we support can be easily distinguished by the first byte */
273     c = stream-&gt;peek(stream);
274     if (c != -1) {
275         for (i = 0; i &lt; sizeof(formats) / sizeof(FILEFORMAT); i++) {
276             if (c == formats[i].sign) {
277                 success = formats[i].decodeStream(splash, stream);
278                 break;
279             }
280         }
281     }
282     stream-&gt;close(stream);
283 
284     if (!success) {             // failed to decode
285         if (splash-&gt;isVisible == 0) {
286             SplashCleanup(splash);
287         }
288         SplashUnlock(splash);   // SplashClose locks
289         if (splash-&gt;isVisible == 0) {
290             SplashClose();
291         }
292     }
293     else {
294         splash-&gt;currentFrame = 0;
295         if (splash-&gt;isVisible == 0) {
296             SplashStart(splash);
297         } else {
298             SplashReconfigure(splash);
299             splash-&gt;time = SplashTime();
300         }
301         SplashUnlock(splash);
302     }
303     return success;
304 }
305 
<a name="8" id="anc8"></a><span class="line-modified">306 JNIEXPORT int</span>
307 SplashLoadFile(const char *filename)
308 {
309     SplashStream stream;
310     return SplashStreamInitFile(&amp;stream, filename) &amp;&amp;
311                 SplashLoadStream(&amp;stream);
312 }
313 
<a name="9" id="anc9"></a><span class="line-modified">314 JNIEXPORT int</span>
315 SplashLoadMemory(void *data, int size)
316 {
317     SplashStream stream;
318     return SplashStreamInitMemory(&amp;stream, data, size) &amp;&amp;
319                 SplashLoadStream(&amp;stream);
320 }
321 
322 /* SplashStart MUST be called from under the lock */
323 
324 void
325 SplashStart(Splash * splash)
326 {
327     if (splash-&gt;isVisible == 0) {
328         SplashCreateThread(splash);
329         splash-&gt;isVisible = 1;
330     }
331 }
332 
333 /* SplashStream functions */
334 
335 static int readFile(void* pStream, void* pData, int nBytes) {
336     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
337     return fread(pData, 1, nBytes, f);
338 }
339 static int peekFile(void* pStream) {
340     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
341     int c = fgetc(f);
342     if (c != EOF) {
343         ungetc(c, f);
344         return c;
345     } else {
346         return -1;
347     }
348 }
349 
350 static void closeFile(void* pStream) {
351     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
352     fclose(f);
353 }
354 
355 static int readMem(void* pStream, void* pData, int nBytes) {
356     unsigned char* pSrc = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pData);
357     unsigned char* pSrcEnd = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pDataEnd);
358     if (nBytes &gt; pSrcEnd - pSrc) {
359         nBytes = pSrcEnd - pSrc;
360     }
361     if (nBytes&gt;0) {
362         memcpy(pData, pSrc, nBytes);
363         pSrc += nBytes;
364         ((SplashStream*)pStream)-&gt;arg.mem.pData = (void*)pSrc;
365     }
366     return nBytes;
367 }
368 
369 static int peekMem(void* pStream) {
370     unsigned char* pSrc = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pData);
371     unsigned char* pSrcEnd = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pDataEnd);
372     if (pSrc &gt;= pSrcEnd) {
373         return -1;
374     } else {
375         return (int)*pSrc;
376     }
377 }
378 
379 static void closeMem(void* pStream) {
380 }
381 
382 int SplashStreamInitFile(SplashStream * pStream, const char* filename) {
383     pStream-&gt;arg.stdio.f = fopen(filename, &quot;rb&quot;);
384     pStream-&gt;read = readFile;
385     pStream-&gt;peek = peekFile;
386     pStream-&gt;close = closeFile;
387     return pStream-&gt;arg.stdio.f != 0;
388 }
389 
390 int SplashStreamInitMemory(SplashStream * pStream, void* pData, int size) {
391     pStream-&gt;arg.mem.pData = (unsigned char*)pData;
392     pStream-&gt;arg.mem.pDataEnd = (unsigned char*)pData + size;
393     pStream-&gt;read = readMem;
394     pStream-&gt;peek = peekMem;
395     pStream-&gt;close = closeMem;
396     return 1;
397 }
398 
<a name="10" id="anc10"></a><span class="line-modified">399 JNIEXPORT int</span>
400 SplashGetScaledImgNameMaxPstfixLen(const char *fileName){
401     return strlen(fileName) + strlen(&quot;@100pct&quot;) + 1;
402 }
403 
404 jboolean GetScaledImageName(const char *fileName, char *scaleImageName,
405         float *scaleFactor, const size_t scaledImageLength) {
406     if (*scaleFactor &gt; 1.0) {
407         FILE *fp = NULL;
408         char scaledImgPct[BUFF_SIZE];
409         char scaledImgX[BUFF_SIZE];
410         char *scaledImageXName = NULL;
411         char *scaledImagePctName = malloc(scaledImageLength);
412         char *dupFileName = strdup(fileName);
413         char *fileExtension = strrchr(dupFileName, &#39;.&#39;);
414         size_t lengthPct = 0;
415         size_t lengthX = 0;
416         int retValPct = 0;
417         int retValX = 0;
418         jboolean isPctScaledImage = (*scaleFactor * 100) != ((int) (*scaleFactor)) *100;
419         snprintf(scaledImgPct, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;,
420                 (int) (*scaleFactor * 100), &quot;pct&quot;);
421         if (!isPctScaledImage) {
422             scaledImageXName = malloc(scaledImageLength);
423             snprintf(scaledImgX, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;, (int) (*scaleFactor), &quot;x&quot;);
424         }
425         /*File is missing extension */
426         if (fileExtension == NULL) {
427             lengthPct = strlen(dupFileName) +
428                     strlen(scaledImgPct) + 1;
429             if (!isPctScaledImage) {
430                 lengthX = strlen(dupFileName) +
431                         strlen(scaledImgX) + 1;
432             }
433             if (lengthPct &gt; scaledImageLength || lengthX &gt; scaledImageLength) {
434                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
435                 return JNI_FALSE;
436             }
437             retValPct = snprintf(scaledImagePctName, lengthPct, &quot;%s%s&quot;, dupFileName,
438                     scaledImgPct);
439             if (!isPctScaledImage) {
440                 retValX = snprintf(scaledImageXName, lengthX, &quot;%s%s&quot;, dupFileName,
441                         scaledImgX);
442             }
443             if ((retValPct &lt; 0 || (retValPct &gt; lengthPct - 1)) ||
444                     (retValX &lt; 0 || (retValX &gt; lengthX - 1))) {
445                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
446                 return JNI_FALSE;
447             }
448         } else {
449             int length_Without_Ext = fileExtension - dupFileName;
450             lengthPct = length_Without_Ext + strlen(scaledImgPct) +
451                     strlen(fileExtension) + 1;
452             if (!isPctScaledImage) {
453                 lengthX = length_Without_Ext + strlen(scaledImgX) +
454                         strlen(fileExtension) + 1;
455             }
456             if (lengthPct &gt; scaledImageLength || lengthX &gt; scaledImageLength) {
457                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
458                 return JNI_FALSE;
459             }
460             retValPct = snprintf(scaledImagePctName, lengthPct, &quot;%.*s%s%s&quot;,
461                     length_Without_Ext, dupFileName, scaledImgPct, fileExtension);
462             if (!isPctScaledImage) {
463                 retValX = snprintf(scaledImageXName, lengthX, &quot;%.*s%s%s&quot;,
464                         length_Without_Ext, dupFileName, scaledImgX, fileExtension);
465             }
466             if ((retValPct &lt; 0 || (retValPct &gt; lengthPct - 1)) ||
467                     (retValX &lt; 0 || (retValX &gt; lengthX - 1))) {
468                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
469                 return JNI_FALSE;
470             }
471         }
472         free(dupFileName);
473         if (!(fp = fopen(scaledImagePctName, &quot;r&quot;))) {
474             if (!isPctScaledImage &amp;&amp; (fp = fopen(scaledImageXName, &quot;r&quot;))) {
475                 fclose(fp);
476                 strcpy(scaleImageName, scaledImageXName);
477                 free(scaledImageXName);
478                 free(scaledImagePctName);
479                 return JNI_TRUE;
480             }
481             cleanUp(NULL, scaledImageXName, scaledImagePctName, scaleFactor);
482             return JNI_FALSE;
483         }
484         fclose(fp);
485         strcpy(scaleImageName, scaledImagePctName);
486         free(scaledImageXName);
487         free(scaledImagePctName);
488         return JNI_TRUE;
489     }
490     return JNI_FALSE;
491 }
492 
493 void cleanUp(char *fName, char *xName, char *pctName, float *scaleFactor) {
494     *scaleFactor = 1;
495     free(fName);
496     free(xName);
497     free(pctName);
498 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libsplashscreen/libpng/pngstruct.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /* pngstruct.h - header file for PNG reference library
 26  *
 27  * This file is available under and governed by the GNU General Public
 28  * License version 2 only, as published by the Free Software Foundation.
 29  * However, the following notice accompanied the original version of this
 30  * file and, per its terms, should not be removed:
 31  *
 32  * Last changed in libpng 1.6.35 [July 15, 2018]
 33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
 34  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)
 35  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)
 36  *
 37  * This code is released under the libpng license.
 38  * For conditions of distribution and use, see the disclaimer
 39  * and license in png.h
 40  */
 41 
 42 /* The structure that holds the information to read and write PNG files.
 43  * The only people who need to care about what is inside of this are the
 44  * people who will be modifying the library for their own special needs.
 45  * It should NOT be accessed directly by an application.
 46  */
 47 
 48 #ifndef PNGSTRUCT_H
 49 #define PNGSTRUCT_H
 50 /* zlib.h defines the structure z_stream, an instance of which is included
 51  * in this structure and is required for decompressing the LZ compressed
 52  * data in PNG files.
 53  */
 54 #ifndef ZLIB_CONST
 55    /* We must ensure that zlib uses &#39;const&#39; in declarations. */
 56 #  define ZLIB_CONST
 57 #endif
 58 #include &quot;zlib.h&quot;
 59 #ifdef const
 60    /* zlib.h sometimes #defines const to nothing, undo this. */
 61 #  undef const
 62 #endif
 63 
 64 /* zlib.h has mediocre z_const use before 1.2.6, this stuff is for compatibility
 65  * with older builds.
 66  */
 67 #if ZLIB_VERNUM &lt; 0x1260
 68 #  define PNGZ_MSG_CAST(s) png_constcast(char*,s)
 69 #  define PNGZ_INPUT_CAST(b) png_constcast(png_bytep,b)
 70 #else
 71 #  define PNGZ_MSG_CAST(s) (s)
 72 #  define PNGZ_INPUT_CAST(b) (b)
 73 #endif
 74 
 75 /* zlib.h declares a magic type &#39;uInt&#39; that limits the amount of data that zlib
 76  * can handle at once.  This type need be no larger than 16 bits (so maximum of
 77  * 65535), this define allows us to discover how big it is, but limited by the
 78  * maximum for size_t.  The value can be overridden in a library build
 79  * (pngusr.h, or set it in CPPFLAGS) and it works to set it to a considerably
 80  * lower value (e.g. 255 works).  A lower value may help memory usage (slightly)
 81  * and may even improve performance on some systems (and degrade it on others.)
 82  */
 83 #ifndef ZLIB_IO_MAX
 84 #  define ZLIB_IO_MAX ((uInt)-1)
 85 #endif
 86 
 87 #ifdef PNG_WRITE_SUPPORTED
 88 /* The type of a compression buffer list used by the write code. */
 89 typedef struct png_compression_buffer
 90 {
 91    struct png_compression_buffer *next;
 92    png_byte                       output[1]; /* actually zbuf_size */
 93 } png_compression_buffer, *png_compression_bufferp;
 94 
 95 #define PNG_COMPRESSION_BUFFER_SIZE(pp)\
 96    (offsetof(png_compression_buffer, output) + (pp)-&gt;zbuffer_size)
 97 #endif
 98 
 99 /* Colorspace support; structures used in png_struct, png_info and in internal
100  * functions to hold and communicate information about the color space.
101  *
102  * PNG_COLORSPACE_SUPPORTED is only required if the application will perform
103  * colorspace corrections, otherwise all the colorspace information can be
104  * skipped and the size of libpng can be reduced (significantly) by compiling
105  * out the colorspace support.
106  */
107 #ifdef PNG_COLORSPACE_SUPPORTED
108 /* The chromaticities of the red, green and blue colorants and the chromaticity
109  * of the corresponding white point (i.e. of rgb(1.0,1.0,1.0)).
110  */
111 typedef struct png_xy
112 {
113    png_fixed_point redx, redy;
114    png_fixed_point greenx, greeny;
115    png_fixed_point bluex, bluey;
116    png_fixed_point whitex, whitey;
117 } png_xy;
118 
119 /* The same data as above but encoded as CIE XYZ values.  When this data comes
120  * from chromaticities the sum of the Y values is assumed to be 1.0
121  */
122 typedef struct png_XYZ
123 {
124    png_fixed_point red_X, red_Y, red_Z;
125    png_fixed_point green_X, green_Y, green_Z;
126    png_fixed_point blue_X, blue_Y, blue_Z;
127 } png_XYZ;
128 #endif /* COLORSPACE */
129 
130 #if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
131 /* A colorspace is all the above plus, potentially, profile information;
132  * however at present libpng does not use the profile internally so it is only
133  * stored in the png_info struct (if iCCP is supported.)  The rendering intent
134  * is retained here and is checked.
135  *
136  * The file gamma encoding information is also stored here and gamma correction
137  * is done by libpng, whereas color correction must currently be done by the
138  * application.
139  */
140 typedef struct png_colorspace
141 {
142 #ifdef PNG_GAMMA_SUPPORTED
143    png_fixed_point gamma;        /* File gamma */
144 #endif
145 
146 #ifdef PNG_COLORSPACE_SUPPORTED
147    png_xy      end_points_xy;    /* End points as chromaticities */
148    png_XYZ     end_points_XYZ;   /* End points as CIE XYZ colorant values */
149    png_uint_16 rendering_intent; /* Rendering intent of a profile */
150 #endif
151 
152    /* Flags are always defined to simplify the code. */
153    png_uint_16 flags;            /* As defined below */
154 } png_colorspace, * PNG_RESTRICT png_colorspacerp;
155 
156 typedef const png_colorspace * PNG_RESTRICT png_const_colorspacerp;
157 
158 /* General flags for the &#39;flags&#39; field */
159 #define PNG_COLORSPACE_HAVE_GAMMA           0x0001
160 #define PNG_COLORSPACE_HAVE_ENDPOINTS       0x0002
161 #define PNG_COLORSPACE_HAVE_INTENT          0x0004
162 #define PNG_COLORSPACE_FROM_gAMA            0x0008
163 #define PNG_COLORSPACE_FROM_cHRM            0x0010
164 #define PNG_COLORSPACE_FROM_sRGB            0x0020
165 #define PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB 0x0040
166 #define PNG_COLORSPACE_MATCHES_sRGB         0x0080 /* exact match on profile */
167 #define PNG_COLORSPACE_INVALID              0x8000
168 #define PNG_COLORSPACE_CANCEL(flags)        (0xffff ^ (flags))
169 #endif /* COLORSPACE || GAMMA */
170 
171 struct png_struct_def
172 {
173 #ifdef PNG_SETJMP_SUPPORTED
174    jmp_buf jmp_buf_local;     /* New name in 1.6.0 for jmp_buf in png_struct */
175    png_longjmp_ptr longjmp_fn;/* setjmp non-local goto function. */
176    jmp_buf *jmp_buf_ptr;      /* passed to longjmp_fn */
177    size_t jmp_buf_size;       /* size of the above, if allocated */
178 #endif
179    png_error_ptr error_fn;    /* function for printing errors and aborting */
180 #ifdef PNG_WARNINGS_SUPPORTED
181    png_error_ptr warning_fn;  /* function for printing warnings */
182 #endif
183    png_voidp error_ptr;       /* user supplied struct for error functions */
184    png_rw_ptr write_data_fn;  /* function for writing output data */
185    png_rw_ptr read_data_fn;   /* function for reading input data */
186    png_voidp io_ptr;          /* ptr to application struct for I/O functions */
187 
188 #ifdef PNG_READ_USER_TRANSFORM_SUPPORTED
189    png_user_transform_ptr read_user_transform_fn; /* user read transform */
190 #endif
191 
192 #ifdef PNG_WRITE_USER_TRANSFORM_SUPPORTED
193    png_user_transform_ptr write_user_transform_fn; /* user write transform */
194 #endif
195 
196 /* These were added in libpng-1.0.2 */
197 #ifdef PNG_USER_TRANSFORM_PTR_SUPPORTED
198 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) || \
199     defined(PNG_WRITE_USER_TRANSFORM_SUPPORTED)
200    png_voidp user_transform_ptr; /* user supplied struct for user transform */
201    png_byte user_transform_depth;    /* bit depth of user transformed pixels */
202    png_byte user_transform_channels; /* channels in user transformed pixels */
203 #endif
204 #endif
205 
206    png_uint_32 mode;          /* tells us where we are in the PNG file */
207    png_uint_32 flags;         /* flags indicating various things to libpng */
208    png_uint_32 transformations; /* which transformations to perform */
209 
210    png_uint_32 zowner;        /* ID (chunk type) of zstream owner, 0 if none */
211    z_stream    zstream;       /* decompression structure */
212 
213 #ifdef PNG_WRITE_SUPPORTED
214    png_compression_bufferp zbuffer_list; /* Created on demand during write */
215    uInt                    zbuffer_size; /* size of the actual buffer */
216 
217    int zlib_level;            /* holds zlib compression level */
218    int zlib_method;           /* holds zlib compression method */
219    int zlib_window_bits;      /* holds zlib compression window bits */
220    int zlib_mem_level;        /* holds zlib compression memory level */
221    int zlib_strategy;         /* holds zlib compression strategy */
222 #endif
223 /* Added at libpng 1.5.4 */
224 #ifdef PNG_WRITE_CUSTOMIZE_ZTXT_COMPRESSION_SUPPORTED
225    int zlib_text_level;            /* holds zlib compression level */
226    int zlib_text_method;           /* holds zlib compression method */
227    int zlib_text_window_bits;      /* holds zlib compression window bits */
228    int zlib_text_mem_level;        /* holds zlib compression memory level */
229    int zlib_text_strategy;         /* holds zlib compression strategy */
230 #endif
231 /* End of material added at libpng 1.5.4 */
232 /* Added at libpng 1.6.0 */
233 #ifdef PNG_WRITE_SUPPORTED
234    int zlib_set_level;        /* Actual values set into the zstream on write */
235    int zlib_set_method;
236    int zlib_set_window_bits;
237    int zlib_set_mem_level;
238    int zlib_set_strategy;
239 #endif
240 
241    png_uint_32 width;         /* width of image in pixels */
242    png_uint_32 height;        /* height of image in pixels */
243    png_uint_32 num_rows;      /* number of rows in current pass */
244    png_uint_32 usr_width;     /* width of row at start of write */
245    size_t rowbytes;           /* size of row in bytes */
246    png_uint_32 iwidth;        /* width of current interlaced row in pixels */
247    png_uint_32 row_number;    /* current row in interlace pass */
248    png_uint_32 chunk_name;    /* PNG_CHUNK() id of current chunk */
249    png_bytep prev_row;        /* buffer to save previous (unfiltered) row.
250                                * While reading this is a pointer into
251                                * big_prev_row; while writing it is separately
252                                * allocated if needed.
253                                */
254    png_bytep row_buf;         /* buffer to save current (unfiltered) row.
255                                * While reading, this is a pointer into
256                                * big_row_buf; while writing it is separately
257                                * allocated.
258                                */
259 #ifdef PNG_WRITE_FILTER_SUPPORTED
260    png_bytep try_row;    /* buffer to save trial row when filtering */
261    png_bytep tst_row;    /* buffer to save best trial row when filtering */
262 #endif
263    size_t info_rowbytes;      /* Added in 1.5.4: cache of updated row bytes */
264 
265    png_uint_32 idat_size;     /* current IDAT size for read */
266    png_uint_32 crc;           /* current chunk CRC value */
267    png_colorp palette;        /* palette from the input file */
268    png_uint_16 num_palette;   /* number of color entries in palette */
269 
270 /* Added at libpng-1.5.10 */
271 #ifdef PNG_CHECK_FOR_INVALID_INDEX_SUPPORTED
272    int num_palette_max;       /* maximum palette index found in IDAT */
273 #endif
274 
275    png_uint_16 num_trans;     /* number of transparency values */
276    png_byte compression;      /* file compression type (always 0) */
277    png_byte filter;           /* file filter type (always 0) */
278    png_byte interlaced;       /* PNG_INTERLACE_NONE, PNG_INTERLACE_ADAM7 */
279    png_byte pass;             /* current interlace pass (0 - 6) */
280    png_byte do_filter;        /* row filter flags (see PNG_FILTER_ in png.h ) */
281    png_byte color_type;       /* color type of file */
282    png_byte bit_depth;        /* bit depth of file */
283    png_byte usr_bit_depth;    /* bit depth of users row: write only */
284    png_byte pixel_depth;      /* number of bits per pixel */
285    png_byte channels;         /* number of channels in file */
286 #ifdef PNG_WRITE_SUPPORTED
287    png_byte usr_channels;     /* channels at start of write: write only */
288 #endif
289    png_byte sig_bytes;        /* magic bytes read/written from start of file */
290    png_byte maximum_pixel_depth;
291                               /* pixel depth used for the row buffers */
292    png_byte transformed_pixel_depth;
293                               /* pixel depth after read/write transforms */
294 #if ZLIB_VERNUM &gt;= 0x1240
295    png_byte zstream_start;    /* at start of an input zlib stream */
296 #endif /* Zlib &gt;= 1.2.4 */
297 #if defined(PNG_READ_FILLER_SUPPORTED) || defined(PNG_WRITE_FILLER_SUPPORTED)
298    png_uint_16 filler;           /* filler bytes for pixel expansion */
299 #endif
300 
301 #if defined(PNG_bKGD_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) ||\
302    defined(PNG_READ_ALPHA_MODE_SUPPORTED)
303    png_byte background_gamma_type;
304    png_fixed_point background_gamma;
305    png_color_16 background;   /* background color in screen gamma space */
306 #ifdef PNG_READ_GAMMA_SUPPORTED
307    png_color_16 background_1; /* background normalized to gamma 1.0 */
308 #endif
309 #endif /* bKGD */
310 
311 #ifdef PNG_WRITE_FLUSH_SUPPORTED
312    png_flush_ptr output_flush_fn; /* Function for flushing output */
313    png_uint_32 flush_dist;    /* how many rows apart to flush, 0 - no flush */
314    png_uint_32 flush_rows;    /* number of rows written since last flush */
315 #endif
316 
317 #ifdef PNG_READ_GAMMA_SUPPORTED
318    int gamma_shift;      /* number of &quot;insignificant&quot; bits in 16-bit gamma */
319    png_fixed_point screen_gamma; /* screen gamma value (display_exponent) */
320 
321    png_bytep gamma_table;     /* gamma table for 8-bit depth files */
322    png_uint_16pp gamma_16_table; /* gamma table for 16-bit depth files */
323 #if defined(PNG_READ_BACKGROUND_SUPPORTED) || \
324    defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \
325    defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)
326    png_bytep gamma_from_1;    /* converts from 1.0 to screen */
327    png_bytep gamma_to_1;      /* converts from file to 1.0 */
328    png_uint_16pp gamma_16_from_1; /* converts from 1.0 to screen */
329    png_uint_16pp gamma_16_to_1; /* converts from file to 1.0 */
330 #endif /* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY */
331 #endif
332 
333 #if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_sBIT_SUPPORTED)
334    png_color_8 sig_bit;       /* significant bits in each available channel */
335 #endif
336 
337 #if defined(PNG_READ_SHIFT_SUPPORTED) || defined(PNG_WRITE_SHIFT_SUPPORTED)
338    png_color_8 shift;         /* shift for significant bit transformation */
339 #endif
340 
341 #if defined(PNG_tRNS_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED) \
342  || defined(PNG_READ_EXPAND_SUPPORTED) || defined(PNG_READ_BACKGROUND_SUPPORTED)
343    png_bytep trans_alpha;           /* alpha values for paletted files */
344    png_color_16 trans_color;  /* transparent color for non-paletted files */
345 #endif
346 
347    png_read_status_ptr read_row_fn;   /* called after each row is decoded */
348    png_write_status_ptr write_row_fn; /* called after each row is encoded */
349 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
350    png_progressive_info_ptr info_fn; /* called after header data fully read */
351    png_progressive_row_ptr row_fn;   /* called after a prog. row is decoded */
352    png_progressive_end_ptr end_fn;   /* called after image is complete */
353    png_bytep save_buffer_ptr;        /* current location in save_buffer */
354    png_bytep save_buffer;            /* buffer for previously read data */
355    png_bytep current_buffer_ptr;     /* current location in current_buffer */
356    png_bytep current_buffer;         /* buffer for recently used data */
357    png_uint_32 push_length;          /* size of current input chunk */
358    png_uint_32 skip_length;          /* bytes to skip in input data */
359    size_t save_buffer_size;          /* amount of data now in save_buffer */
360    size_t save_buffer_max;           /* total size of save_buffer */
361    size_t buffer_size;               /* total amount of available input data */
362    size_t current_buffer_size;       /* amount of data now in current_buffer */
363    int process_mode;                 /* what push library is currently doing */
364    int cur_palette;                  /* current push library palette index */
365 
366 #endif /* PROGRESSIVE_READ */
367 
368 #if defined(__TURBOC__) &amp;&amp; !defined(_Windows) &amp;&amp; !defined(__FLAT__)
369 /* For the Borland special 64K segment handler */
370    png_bytepp offset_table_ptr;
371    png_bytep offset_table;
372    png_uint_16 offset_table_number;
373    png_uint_16 offset_table_count;
374    png_uint_16 offset_table_count_free;
375 #endif
376 
377 #ifdef PNG_READ_QUANTIZE_SUPPORTED
378    png_bytep palette_lookup; /* lookup table for quantizing */
379    png_bytep quantize_index; /* index translation for palette files */
380 #endif
381 
382 /* Options */
383 #ifdef PNG_SET_OPTION_SUPPORTED
384    png_uint_32 options;           /* On/off state (up to 16 options) */
385 #endif
386 
387 #if PNG_LIBPNG_VER &lt; 10700
388 /* To do: remove this from libpng-1.7 */
389 #ifdef PNG_TIME_RFC1123_SUPPORTED
390    char time_buffer[29]; /* String to hold RFC 1123 time text */
391 #endif
392 #endif
393 
394 /* New members added in libpng-1.0.6 */
395 
396    png_uint_32 free_me;    /* flags items libpng is responsible for freeing */
397 
398 #ifdef PNG_USER_CHUNKS_SUPPORTED
399    png_voidp user_chunk_ptr;
400 #ifdef PNG_READ_USER_CHUNKS_SUPPORTED
401    png_user_chunk_ptr read_user_chunk_fn; /* user read chunk handler */
402 #endif
403 #endif
404 
405 #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
406    int          unknown_default; /* As PNG_HANDLE_* */
407    unsigned int num_chunk_list;  /* Number of entries in the list */
408    png_bytep    chunk_list;      /* List of png_byte[5]; the textual chunk name
409                                   * followed by a PNG_HANDLE_* byte */
410 #endif
411 
412 /* New members added in libpng-1.0.3 */
413 #ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED
414    png_byte rgb_to_gray_status;
415    /* Added in libpng 1.5.5 to record setting of coefficients: */
416    png_byte rgb_to_gray_coefficients_set;
417    /* These were changed from png_byte in libpng-1.0.6 */
418    png_uint_16 rgb_to_gray_red_coeff;
419    png_uint_16 rgb_to_gray_green_coeff;
420    /* deleted in 1.5.5: rgb_to_gray_blue_coeff; */
421 #endif
422 
423 /* New member added in libpng-1.0.4 (renamed in 1.0.9) */
424 #if defined(PNG_MNG_FEATURES_SUPPORTED)
425 /* Changed from png_byte to png_uint_32 at version 1.2.0 */
426    png_uint_32 mng_features_permitted;
427 #endif
428 
429 /* New member added in libpng-1.0.9, ifdef&#39;ed out in 1.0.12, enabled in 1.2.0 */
430 #ifdef PNG_MNG_FEATURES_SUPPORTED
431    png_byte filter_type;
432 #endif
433 
434 /* New members added in libpng-1.2.0 */
435 
436 /* New members added in libpng-1.0.2 but first enabled by default in 1.2.0 */
437 #ifdef PNG_USER_MEM_SUPPORTED
438    png_voidp mem_ptr;             /* user supplied struct for mem functions */
439    png_malloc_ptr malloc_fn;      /* function for allocating memory */
440    png_free_ptr free_fn;          /* function for freeing memory */
441 #endif
442 
443 /* New member added in libpng-1.0.13 and 1.2.0 */
444    png_bytep big_row_buf;         /* buffer to save current (unfiltered) row */
445 
446 #ifdef PNG_READ_QUANTIZE_SUPPORTED
447 /* The following three members were added at version 1.0.14 and 1.2.4 */
448    png_bytep quantize_sort;          /* working sort array */
449    png_bytep index_to_palette;       /* where the original index currently is
450                                         in the palette */
451    png_bytep palette_to_index;       /* which original index points to this
452                                          palette color */
453 #endif
454 
455 /* New members added in libpng-1.0.16 and 1.2.6 */
456    png_byte compression_type;
457 
458 #ifdef PNG_USER_LIMITS_SUPPORTED
459    png_uint_32 user_width_max;
460    png_uint_32 user_height_max;
461 
462    /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
463     * chunks that can be stored (0 means unlimited).
464     */
465    png_uint_32 user_chunk_cache_max;
466 
467    /* Total memory that a zTXt, sPLT, iTXt, iCCP, or unknown chunk
468     * can occupy when decompressed.  0 means unlimited.
469     */
470    png_alloc_size_t user_chunk_malloc_max;
471 #endif
472 
473 /* New member added in libpng-1.0.25 and 1.2.17 */
474 #ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
475    /* Temporary storage for unknown chunk that the library doesn&#39;t recognize,
476     * used while reading the chunk.
477     */
478    png_unknown_chunk unknown_chunk;
479 #endif
480 
481 /* New member added in libpng-1.2.26 */
482    size_t old_big_row_buf_size;
483 
484 #ifdef PNG_READ_SUPPORTED
485 /* New member added in libpng-1.2.30 */
486   png_bytep        read_buffer;      /* buffer for reading chunk data */
487   png_alloc_size_t read_buffer_size; /* current size of the buffer */
488 #endif
489 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
490   uInt             IDAT_read_size;   /* limit on read buffer size for IDAT */
491 #endif
492 
493 #ifdef PNG_IO_STATE_SUPPORTED
494 /* New member added in libpng-1.4.0 */
495    png_uint_32 io_state;
496 #endif
497 
498 /* New member added in libpng-1.5.6 */
499    png_bytep big_prev_row;
500 
501 /* New member added in libpng-1.5.7 */
502    void (*read_filter[PNG_FILTER_VALUE_LAST-1])(png_row_infop row_info,
503       png_bytep row, png_const_bytep prev_row);
504 
505 #ifdef PNG_READ_SUPPORTED
506 #if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)
507    png_colorspace   colorspace;
508 #endif
509 #endif
510 };
511 #endif /* PNGSTRUCT_H */
    </pre>
  </body>
</html>
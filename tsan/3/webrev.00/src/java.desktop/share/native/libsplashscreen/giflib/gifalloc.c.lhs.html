<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libsplashscreen/giflib/gifalloc.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*****************************************************************************
 26 
 27  GIF construction tools
 28 
<a name="1" id="anc1"></a>

 29 ****************************************************************************/
 30 
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;stdio.h&gt;
 33 #include &lt;string.h&gt;
 34 
 35 #include &quot;gif_lib.h&quot;
<a name="2" id="anc2"></a>
 36 
 37 #define MAX(x, y)    (((x) &gt; (y)) ? (x) : (y))
 38 
 39 /******************************************************************************
 40  Miscellaneous utility functions
 41 ******************************************************************************/
 42 
 43 /* return smallest bitfield size n will fit in */
 44 int
 45 GifBitSize(int n)
 46 {
 47     register int i;
 48 
 49     for (i = 1; i &lt;= 8; i++)
 50         if ((1 &lt;&lt; i) &gt;= n)
 51             break;
 52     return (i);
 53 }
 54 
 55 /******************************************************************************
 56   Color map object functions
 57 ******************************************************************************/
 58 
 59 /*
 60  * Allocate a color map of given size; initialize with contents of
 61  * ColorMap if that pointer is non-NULL.
 62  */
 63 ColorMapObject *
 64 GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)
 65 {
 66     ColorMapObject *Object;
 67 
 68     /*** FIXME: Our ColorCount has to be a power of two.  Is it necessary to
 69      * make the user know that or should we automatically round up instead? */
 70     if (ColorCount != (1 &lt;&lt; GifBitSize(ColorCount))) {
 71         return ((ColorMapObject *) NULL);
 72     }
 73 
 74     Object = (ColorMapObject *)malloc(sizeof(ColorMapObject));
 75     if (Object == (ColorMapObject *) NULL) {
 76         return ((ColorMapObject *) NULL);
 77     }
 78 
 79     Object-&gt;Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
 80     if (Object-&gt;Colors == (GifColorType *) NULL) {
 81         free(Object);
 82         return ((ColorMapObject *) NULL);
 83     }
 84 
 85     Object-&gt;ColorCount = ColorCount;
 86     Object-&gt;BitsPerPixel = GifBitSize(ColorCount);
 87     Object-&gt;SortFlag = false;
 88 
 89     if (ColorMap != NULL) {
 90         memcpy((char *)Object-&gt;Colors,
 91                (char *)ColorMap, ColorCount * sizeof(GifColorType));
 92     }
 93 
 94     return (Object);
 95 }
 96 
 97 /*******************************************************************************
 98 Free a color map object
 99 *******************************************************************************/
100 void
101 GifFreeMapObject(ColorMapObject *Object)
102 {
103     if (Object != NULL) {
104         (void)free(Object-&gt;Colors);
105         (void)free(Object);
106     }
107 }
108 
109 #ifdef DEBUG
110 void
111 DumpColorMap(ColorMapObject *Object,
112              FILE * fp)
113 {
114     if (Object != NULL) {
115         int i, j, Len = Object-&gt;ColorCount;
116 
117         for (i = 0; i &lt; Len; i += 4) {
118             for (j = 0; j &lt; 4 &amp;&amp; j &lt; Len; j++) {
119                 (void)fprintf(fp, &quot;%3d: %02x %02x %02x   &quot;, i + j,
120                               Object-&gt;Colors[i + j].Red,
121                               Object-&gt;Colors[i + j].Green,
122                               Object-&gt;Colors[i + j].Blue);
123             }
124             (void)fprintf(fp, &quot;\n&quot;);
125         }
126     }
127 }
128 #endif /* DEBUG */
129 
130 /*******************************************************************************
131  Compute the union of two given color maps and return it.  If result can&#39;t
132  fit into 256 colors, NULL is returned, the allocated union otherwise.
133  ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are
134  copied iff they didn&#39;t exist before.  ColorTransIn2 maps the old
135  ColorIn2 into the ColorUnion color map table./
136 *******************************************************************************/
137 ColorMapObject *
138 GifUnionColorMap(const ColorMapObject *ColorIn1,
139               const ColorMapObject *ColorIn2,
140               GifPixelType ColorTransIn2[])
141 {
142     int i, j, CrntSlot, RoundUpTo, NewGifBitSize;
143     ColorMapObject *ColorUnion;
144 
145     /*
146      * We don&#39;t worry about duplicates within either color map; if
147      * the caller wants to resolve those, he can perform unions
148      * with an empty color map.
149      */
150 
151     /* Allocate table which will hold the result for sure. */
152     ColorUnion = GifMakeMapObject(MAX(ColorIn1-&gt;ColorCount,
153                                ColorIn2-&gt;ColorCount) * 2, NULL);
154 
155     if (ColorUnion == NULL)
156         return (NULL);
157 
158     /*
159      * Copy ColorIn1 to ColorUnion.
160      */
161     for (i = 0; i &lt; ColorIn1-&gt;ColorCount; i++)
162         ColorUnion-&gt;Colors[i] = ColorIn1-&gt;Colors[i];
163     CrntSlot = ColorIn1-&gt;ColorCount;
164 
165     /*
166      * Potentially obnoxious hack:
167      *
168      * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end
169      * of table 1.  This is very useful if your display is limited to
170      * 16 colors.
171      */
172     while (ColorIn1-&gt;Colors[CrntSlot - 1].Red == 0
173            &amp;&amp; ColorIn1-&gt;Colors[CrntSlot - 1].Green == 0
174            &amp;&amp; ColorIn1-&gt;Colors[CrntSlot - 1].Blue == 0)
175         CrntSlot--;
176 
177     /* Copy ColorIn2 to ColorUnion (use old colors if they exist): */
178     for (i = 0; i &lt; ColorIn2-&gt;ColorCount &amp;&amp; CrntSlot &lt;= 256; i++) {
179         /* Let&#39;s see if this color already exists: */
180         for (j = 0; j &lt; ColorIn1-&gt;ColorCount; j++)
181             if (memcmp (&amp;ColorIn1-&gt;Colors[j], &amp;ColorIn2-&gt;Colors[i],
182                         sizeof(GifColorType)) == 0)
183                 break;
184 
185         if (j &lt; ColorIn1-&gt;ColorCount)
186             ColorTransIn2[i] = j;    /* color exists in Color1 */
187         else {
188             /* Color is new - copy it to a new slot: */
189             ColorUnion-&gt;Colors[CrntSlot] = ColorIn2-&gt;Colors[i];
190             ColorTransIn2[i] = CrntSlot++;
191         }
192     }
193 
194     if (CrntSlot &gt; 256) {
195         GifFreeMapObject(ColorUnion);
196         return ((ColorMapObject *) NULL);
197     }
198 
199     NewGifBitSize = GifBitSize(CrntSlot);
200     RoundUpTo = (1 &lt;&lt; NewGifBitSize);
201 
202     if (RoundUpTo != ColorUnion-&gt;ColorCount) {
203         register GifColorType *Map = ColorUnion-&gt;Colors;
204 
205         /*
206          * Zero out slots up to next power of 2.
207          * We know these slots exist because of the way ColorUnion&#39;s
208          * start dimension was computed.
209          */
210         for (j = CrntSlot; j &lt; RoundUpTo; j++)
211             Map[j].Red = Map[j].Green = Map[j].Blue = 0;
212 
213         /* perhaps we can shrink the map? */
214         if (RoundUpTo &lt; ColorUnion-&gt;ColorCount) {
215             GifColorType *new_map = (GifColorType *)reallocarray(Map,
216                                  RoundUpTo, sizeof(GifColorType));
217             if( new_map == NULL ) {
218                 GifFreeMapObject(ColorUnion);
219                 return ((ColorMapObject *) NULL);
220             }
221             ColorUnion-&gt;Colors = new_map;
222         }
223     }
224 
225     ColorUnion-&gt;ColorCount = RoundUpTo;
226     ColorUnion-&gt;BitsPerPixel = NewGifBitSize;
227 
228     return (ColorUnion);
229 }
230 
231 /*******************************************************************************
232  Apply a given color translation to the raster bits of an image
233 *******************************************************************************/
234 void
235 GifApplyTranslation(SavedImage *Image, GifPixelType Translation[])
236 {
237     register int i;
238     register int RasterSize = Image-&gt;ImageDesc.Height * Image-&gt;ImageDesc.Width;
239 
240     for (i = 0; i &lt; RasterSize; i++)
241         Image-&gt;RasterBits[i] = Translation[Image-&gt;RasterBits[i]];
242 }
243 
244 /******************************************************************************
245  Extension record functions
246 ******************************************************************************/
247 int
248 GifAddExtensionBlock(int *ExtensionBlockCount,
249                      ExtensionBlock **ExtensionBlocks,
250                      int Function,
251                      unsigned int Len,
252                      unsigned char ExtData[])
253 {
254     ExtensionBlock *ep;
255 
256     if (*ExtensionBlocks == NULL)
257         *ExtensionBlocks=(ExtensionBlock *)malloc(sizeof(ExtensionBlock));
258     else {
259         ExtensionBlock* ep_new = (ExtensionBlock *)reallocarray
260                                       (*ExtensionBlocks, (*ExtensionBlockCount + 1),
261                                       sizeof(ExtensionBlock));
262         if( ep_new == NULL )
263             return (GIF_ERROR);
264         *ExtensionBlocks = ep_new;
265     }
266 
267     if (*ExtensionBlocks == NULL)
268         return (GIF_ERROR);
269 
270     ep = &amp;(*ExtensionBlocks)[(*ExtensionBlockCount)++];
271 
272     ep-&gt;Function = Function;
273     ep-&gt;ByteCount=Len;
274     ep-&gt;Bytes = (GifByteType *)malloc(ep-&gt;ByteCount);
275     if (ep-&gt;Bytes == NULL)
276         return (GIF_ERROR);
277 
278     if (ExtData != NULL) {
279         memcpy(ep-&gt;Bytes, ExtData, Len);
280     }
281 
282     return (GIF_OK);
283 }
284 
285 void
286 GifFreeExtensions(int *ExtensionBlockCount,
287                   ExtensionBlock **ExtensionBlocks)
288 {
289     ExtensionBlock *ep;
290 
291     if (*ExtensionBlocks == NULL)
292         return;
293 
294     for (ep = *ExtensionBlocks;
295          ep &lt; (*ExtensionBlocks + *ExtensionBlockCount);
296          ep++)
297         (void)free((char *)ep-&gt;Bytes);
298     (void)free((char *)*ExtensionBlocks);
299     *ExtensionBlocks = NULL;
300     *ExtensionBlockCount = 0;
301 }
302 
303 /******************************************************************************
304  Image block allocation functions
305 ******************************************************************************/
306 
307 /* Private Function:
308  * Frees the last image in the GifFile-&gt;SavedImages array
309  */
310 void
311 FreeLastSavedImage(GifFileType *GifFile)
312 {
313     SavedImage *sp;
314 
315     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL))
316         return;
317 
318     /* Remove one SavedImage from the GifFile */
319     GifFile-&gt;ImageCount--;
320     sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount];
321 
322     /* Deallocate its Colormap */
323     if (sp-&gt;ImageDesc.ColorMap != NULL) {
324         GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
325         sp-&gt;ImageDesc.ColorMap = NULL;
326     }
327 
328     /* Deallocate the image data */
329     if (sp-&gt;RasterBits != NULL)
330         free((char *)sp-&gt;RasterBits);
331 
332     /* Deallocate any extensions */
333     GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
334 
335     /*** FIXME: We could realloc the GifFile-&gt;SavedImages structure but is
336      * there a point to it? Saves some memory but we&#39;d have to do it every
337      * time.  If this is used in GifFreeSavedImages then it would be inefficient
338      * (The whole array is going to be deallocated.)  If we just use it when
339      * we want to free the last Image it&#39;s convenient to do it here.
340      */
341 }
342 
343 /*
344  * Append an image block to the SavedImages array
345  */
346 SavedImage *
347 GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
348 {
349     if (GifFile-&gt;SavedImages == NULL)
350         GifFile-&gt;SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
<a name="3" id="anc3"></a><span class="line-modified">351     else</span>
<span class="line-modified">352         GifFile-&gt;SavedImages = (SavedImage *)reallocarray(GifFile-&gt;SavedImages,</span>
353                                (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
<a name="4" id="anc4"></a><span class="line-modified">354 </span>



355     if (GifFile-&gt;SavedImages == NULL)
356         return ((SavedImage *)NULL);
357     else {
358         SavedImage *sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount++];
<a name="5" id="anc5"></a><span class="line-removed">359         memset((char *)sp, &#39;\0&#39;, sizeof(SavedImage));</span>
360 
361         if (CopyFrom != NULL) {
362             memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
363 
364             /*
365              * Make our own allocated copies of the heap fields in the
366              * copied record.  This guards against potential aliasing
367              * problems.
368              */
369 
370             /* first, the local color map */
<a name="6" id="anc6"></a><span class="line-modified">371             if (sp-&gt;ImageDesc.ColorMap != NULL) {</span>
372                 sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
373                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;ColorCount,
374                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;Colors);
375                 if (sp-&gt;ImageDesc.ColorMap == NULL) {
376                     FreeLastSavedImage(GifFile);
377                     return (SavedImage *)(NULL);
378                 }
379             }
380 
381             /* next, the raster */
382             sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL,
383                                                   (CopyFrom-&gt;ImageDesc.Height *
384                                                   CopyFrom-&gt;ImageDesc.Width),
385                                                   sizeof(GifPixelType));
386             if (sp-&gt;RasterBits == NULL) {
387                 FreeLastSavedImage(GifFile);
388                 return (SavedImage *)(NULL);
389             }
390             memcpy(sp-&gt;RasterBits, CopyFrom-&gt;RasterBits,
391                    sizeof(GifPixelType) * CopyFrom-&gt;ImageDesc.Height *
392                    CopyFrom-&gt;ImageDesc.Width);
393 
394             /* finally, the extension blocks */
<a name="7" id="anc7"></a><span class="line-modified">395             if (sp-&gt;ExtensionBlocks != NULL) {</span>
396                 sp-&gt;ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
397                                       CopyFrom-&gt;ExtensionBlockCount,
398                                       sizeof(ExtensionBlock));
399                 if (sp-&gt;ExtensionBlocks == NULL) {
400                     FreeLastSavedImage(GifFile);
401                     return (SavedImage *)(NULL);
402                 }
403                 memcpy(sp-&gt;ExtensionBlocks, CopyFrom-&gt;ExtensionBlocks,
404                        sizeof(ExtensionBlock) * CopyFrom-&gt;ExtensionBlockCount);
405             }
406         }
<a name="8" id="anc8"></a>


407 
408         return (sp);
409     }
410 }
411 
412 void
413 GifFreeSavedImages(GifFileType *GifFile)
414 {
415     SavedImage *sp;
416 
417     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL)) {
418         return;
419     }
420     for (sp = GifFile-&gt;SavedImages;
421          sp &lt; GifFile-&gt;SavedImages + GifFile-&gt;ImageCount; sp++) {
422         if (sp-&gt;ImageDesc.ColorMap != NULL) {
423             GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
424             sp-&gt;ImageDesc.ColorMap = NULL;
425         }
426 
427         if (sp-&gt;RasterBits != NULL)
428             free((char *)sp-&gt;RasterBits);
429 
430         GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
431     }
432     free((char *)GifFile-&gt;SavedImages);
433     GifFile-&gt;SavedImages = NULL;
434 }
435 
436 /* end */
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
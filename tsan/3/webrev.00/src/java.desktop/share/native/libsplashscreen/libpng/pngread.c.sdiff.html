<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/libpng/pngread.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="pngpriv.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngrio.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/libpng/pngread.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* pngread.c - read a PNG file
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Last changed in libpng 1.6.35 [July 15, 2018]</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)</span>
<span class="line-modified">  35  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  *
  41  * This file contains routines that an application calls directly to
  42  * read a PNG file or stream.
  43  */
  44 
  45 #include &quot;pngpriv.h&quot;
  46 #if defined(PNG_SIMPLIFIED_READ_SUPPORTED) &amp;&amp; defined(PNG_STDIO_SUPPORTED)
  47 #  include &lt;errno.h&gt;
  48 #endif
  49 
  50 #ifdef PNG_READ_SUPPORTED
  51 
  52 /* Create a PNG structure for reading, and allocate any memory needed. */
  53 PNG_FUNCTION(png_structp,PNGAPI
  54 png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
  55     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
</pre>
<hr />
<pre>
1005 #endif
1006 
1007    inflateEnd(&amp;png_ptr-&gt;zstream);
1008 
1009 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
1010    png_free(png_ptr, png_ptr-&gt;save_buffer);
1011    png_ptr-&gt;save_buffer = NULL;
1012 #endif
1013 
1014 #if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) &amp;&amp; \
1015    defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
1016    png_free(png_ptr, png_ptr-&gt;unknown_chunk.data);
1017    png_ptr-&gt;unknown_chunk.data = NULL;
1018 #endif
1019 
1020 #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
1021    png_free(png_ptr, png_ptr-&gt;chunk_list);
1022    png_ptr-&gt;chunk_list = NULL;
1023 #endif
1024 






1025    /* NOTE: the &#39;setjmp&#39; buffer may still be allocated and the memory and error
1026     * callbacks are still set at this point.  They are required to complete the
1027     * destruction of the png_struct itself.
1028     */
1029 }
1030 
1031 /* Free all memory used by the read */
1032 void PNGAPI
1033 png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
1034     png_infopp end_info_ptr_ptr)
1035 {
1036    png_structrp png_ptr = NULL;
1037 
1038    png_debug(1, &quot;in png_destroy_read_struct&quot;);
1039 
1040    if (png_ptr_ptr != NULL)
1041       png_ptr = *png_ptr_ptr;
1042 
1043    if (png_ptr == NULL)
1044       return;
</pre>
<hr />
<pre>
1632 {
1633    /* Prepare the reader to ignore all recognized chunks whose data will not
1634     * be used, i.e., all chunks recognized by libpng except for those
1635     * involved in basic image reading:
1636     *
1637     *    IHDR, PLTE, IDAT, IEND
1638     *
1639     * Or image data handling:
1640     *
1641     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.
1642     *
1643     * This provides a small performance improvement and eliminates any
1644     * potential vulnerability to security problems in the unused chunks.
1645     *
1646     * At present the iCCP chunk data isn&#39;t used, so iCCP chunk can be ignored
1647     * too.  This allows the simplified API to be compiled without iCCP support,
1648     * however if the support is there the chunk is still checked to detect
1649     * errors (which are unfortunately quite common.)
1650     */
1651    {
<span class="line-modified">1652          static PNG_CONST png_byte chunks_to_process[] = {</span>
1653             98,  75,  71,  68, &#39;\0&#39;,  /* bKGD */
1654             99,  72,  82,  77, &#39;\0&#39;,  /* cHRM */
1655            103,  65,  77,  65, &#39;\0&#39;,  /* gAMA */
1656 #        ifdef PNG_READ_iCCP_SUPPORTED
1657            105,  67,  67,  80, &#39;\0&#39;,  /* iCCP */
1658 #        endif
1659            115,  66,  73,  84, &#39;\0&#39;,  /* sBIT */
1660            115,  82,  71,  66, &#39;\0&#39;,  /* sRGB */
1661            };
1662 
1663        /* Ignore unknown chunks and all other chunks except for the
1664         * IHDR, PLTE, tRNS, IDAT, and IEND chunks.
1665         */
1666        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,
1667            NULL, -1);
1668 
1669        /* But do not ignore image data handling chunks */
1670        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,
1671            chunks_to_process, (int)/*SAFE*/(sizeof chunks_to_process)/5);
1672    }
</pre>
<hr />
<pre>
1769       f *= 257; /* Now scaled by 65535 */
1770       f += f &gt;&gt; 16;
1771       f = (f+32768) &gt;&gt; 16;
1772    }
1773 
1774    else /* P_sRGB */
1775       f = PNG_sRGB_FROM_LINEAR(f);
1776 
1777    return f;
1778 }
1779 
1780 /* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must
1781  * be 8-bit.
1782  */
1783 static void
1784 png_create_colormap_entry(png_image_read_control *display,
1785     png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,
1786     png_uint_32 alpha, int encoding)
1787 {
1788    png_imagep image = display-&gt;image;
<span class="line-modified">1789    const int output_encoding = (image-&gt;format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
1790        P_LINEAR : P_sRGB;
<span class="line-modified">1791    const int convert_to_Y = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) == 0 &amp;&amp;</span>
1792        (red != green || green != blue);
1793 
1794    if (ip &gt; 255)
1795       png_error(image-&gt;opaque-&gt;png_ptr, &quot;color-map index out of range&quot;);
1796 
1797    /* Update the cache with whether the file gamma is significantly different
1798     * from sRGB.
1799     */
1800    if (encoding == P_FILE)
1801    {
1802       if (display-&gt;file_encoding == P_NOTSET)
1803          set_file_encoding(display);
1804 
1805       /* Note that the cached value may be P_FILE too, but if it is then the
1806        * gamma_to_linear member has been set.
1807        */
1808       encoding = display-&gt;file_encoding;
1809    }
1810 
1811    if (encoding == P_FILE)
</pre>
<hr />
<pre>
1880 
1881          blue = red = green = y;
1882       }
1883 
1884       else if (output_encoding == P_sRGB)
1885       {
1886          red = PNG_sRGB_FROM_LINEAR(red * 255);
1887          green = PNG_sRGB_FROM_LINEAR(green * 255);
1888          blue = PNG_sRGB_FROM_LINEAR(blue * 255);
1889          alpha = PNG_DIV257(alpha);
1890          encoding = P_sRGB;
1891       }
1892    }
1893 
1894    if (encoding != output_encoding)
1895       png_error(image-&gt;opaque-&gt;png_ptr, &quot;bad encoding (internal error)&quot;);
1896 
1897    /* Store the value. */
1898    {
1899 #     ifdef PNG_FORMAT_AFIRST_SUPPORTED
<span class="line-modified">1900          const int afirst = (image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0 &amp;&amp;</span>
1901             (image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0;
1902 #     else
1903 #        define afirst 0
1904 #     endif
1905 #     ifdef PNG_FORMAT_BGR_SUPPORTED
<span class="line-modified">1906          const int bgr = (image-&gt;format &amp; PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;</span>
1907 #     else
1908 #        define bgr 0
1909 #     endif
1910 
1911       if (output_encoding == P_LINEAR)
1912       {
1913          png_uint_16p entry = png_voidcast(png_uint_16p, display-&gt;colormap);
1914 
1915          entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image-&gt;format);
1916 
1917          /* The linear 16-bit values must be pre-multiplied by the alpha channel
1918           * value, if less than 65535 (this is, effectively, composite on black
1919           * if the alpha channel is removed.)
1920           */
1921          switch (PNG_IMAGE_SAMPLE_CHANNELS(image-&gt;format))
1922          {
1923             case 4:
1924                entry[afirst ? 0 : 3] = (png_uint_16)alpha;
1925                /* FALLTHROUGH */
1926 
</pre>
<hr />
<pre>
2096          for (b=0; b&lt;6; ++b)
2097             png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,
2098                 P_sRGB);
2099       }
2100    }
2101 
2102    return (int)i;
2103 }
2104 
2105 #define PNG_RGB_COLORMAP_ENTRIES 216
2106 
2107 /* Return a palette index to the above palette given three 8-bit sRGB values. */
2108 #define PNG_RGB_INDEX(r,g,b) \
2109    ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))
2110 
2111 static int
2112 png_image_read_colormap(png_voidp argument)
2113 {
2114    png_image_read_control *display =
2115       png_voidcast(png_image_read_control*, argument);
<span class="line-modified">2116    const png_imagep image = display-&gt;image;</span>
2117 
<span class="line-modified">2118    const png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;</span>
<span class="line-modified">2119    const png_uint_32 output_format = image-&gt;format;</span>
<span class="line-modified">2120    const int output_encoding = (output_format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
2121       P_LINEAR : P_sRGB;
2122 
2123    unsigned int cmap_entries;
2124    unsigned int output_processing;        /* Output processing option */
2125    unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */
2126 
2127    /* Background information; the background color and the index of this color
2128     * in the color-map if it exists (else 256).
2129     */
2130    unsigned int background_index = 256;
2131    png_uint_32 back_r, back_g, back_b;
2132 
2133    /* Flags to accumulate things that need to be done to the input. */
2134    int expand_tRNS = 0;
2135 
2136    /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
2137     * very difficult to do, the results look awful, and it is difficult to see
2138     * what possible use it is because the application can&#39;t control the
2139     * color-map.
2140     */
</pre>
<hr />
<pre>
2813                /* Alpha in the output is irrelevant, simply map the opaque input
2814                 * pixels to the 6x6x6 color-map.
2815                 */
2816                if (PNG_RGB_COLORMAP_ENTRIES &gt; image-&gt;colormap_entries)
2817                   png_error(png_ptr, &quot;rgb color-map: too few entries&quot;);
2818 
2819                cmap_entries = (unsigned int)make_rgb_colormap(display);
2820                output_processing = PNG_CMAP_RGB;
2821             }
2822          }
2823          break;
2824 
2825       case PNG_COLOR_TYPE_PALETTE:
2826          /* It&#39;s already got a color-map.  It may be necessary to eliminate the
2827           * tRNS entries though.
2828           */
2829          {
2830             unsigned int num_trans = png_ptr-&gt;num_trans;
2831             png_const_bytep trans = num_trans &gt; 0 ? png_ptr-&gt;trans_alpha : NULL;
2832             png_const_colorp colormap = png_ptr-&gt;palette;
<span class="line-modified">2833             const int do_background = trans != NULL &amp;&amp;</span>
2834                (output_format &amp; PNG_FORMAT_FLAG_ALPHA) == 0;
2835             unsigned int i;
2836 
2837             /* Just in case: */
2838             if (trans == NULL)
2839                num_trans = 0;
2840 
2841             output_processing = PNG_CMAP_NONE;
2842             data_encoding = P_FILE; /* Don&#39;t change from color-map indices */
2843             cmap_entries = (unsigned int)png_ptr-&gt;num_palette;
2844             if (cmap_entries &gt; 256)
2845                cmap_entries = 256;
2846 
2847             if (cmap_entries &gt; (unsigned int)image-&gt;colormap_entries)
2848                png_error(png_ptr, &quot;palette color-map: too few entries&quot;);
2849 
2850             for (i=0; i &lt; cmap_entries; ++i)
2851             {
2852                if (do_background != 0 &amp;&amp; i &lt; num_trans &amp;&amp; trans[i] &lt; 255)
2853                {
</pre>
<hr />
<pre>
3957             {
3958                /* Disable this if doing a local background,
3959                 * TODO: remove this when local background is no longer required.
3960                 */
3961                if (do_local_background != 2)
3962                   png_set_swap_alpha(png_ptr);
3963             }
3964 
3965             else
3966                format &amp;= ~PNG_FORMAT_FLAG_AFIRST;
3967 
3968             change &amp;= ~PNG_FORMAT_FLAG_AFIRST;
3969          }
3970 #     endif
3971 
3972       /* If the *output* is 16-bit then we need to check for a byte-swap on this
3973        * architecture.
3974        */
3975       if (linear != 0)
3976       {
<span class="line-modified">3977          PNG_CONST png_uint_16 le = 0x0001;</span>
3978 
3979          if ((*(png_const_bytep) &amp; le) != 0)
3980             png_set_swap(png_ptr);
3981       }
3982 
3983       /* If change is not now 0 some transformation is missing - error out. */
3984       if (change != 0)
3985          png_error(png_ptr, &quot;png_read_image: unsupported transformation&quot;);
3986    }
3987 
3988    PNG_SKIP_CHUNKS(png_ptr);
3989 
3990    /* Update the &#39;info&#39; structure and make sure the result is as required; first
3991     * make sure to turn on the interlace handling if it will be required
3992     * (because it can&#39;t be turned on *after* the call to png_read_update_info!)
3993     *
3994     * TODO: remove the do_local_background fixup below.
3995     */
3996    if (do_local_compose == 0 &amp;&amp; do_local_background != 2)
3997       passes = png_set_interlace_handling(png_ptr);
</pre>
<hr />
<pre>
4119          {
4120             png_read_row(png_ptr, row, NULL);
4121             row += row_bytes;
4122          }
4123       }
4124 
4125       return 1;
4126    }
4127 }
4128 
4129 int PNGAPI
4130 png_image_finish_read(png_imagep image, png_const_colorp background,
4131     void *buffer, png_int_32 row_stride, void *colormap)
4132 {
4133    if (image != NULL &amp;&amp; image-&gt;version == PNG_IMAGE_VERSION)
4134    {
4135       /* Check for row_stride overflow.  This check is not performed on the
4136        * original PNG format because it may not occur in the output PNG format
4137        * and libpng deals with the issues of reading the original.
4138        */
<span class="line-modified">4139       const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image-&gt;format);</span>
4140 
4141       /* The following checks just the &#39;row_stride&#39; calculation to ensure it
4142        * fits in a signed 32-bit value.  Because channels/components can be
4143        * either 1 or 2 bytes in size the length of a row can still overflow 32
4144        * bits; this is just to verify that the &#39;row_stride&#39; argument can be
4145        * represented.
4146        */
4147       if (image-&gt;width &lt;= 0x7fffffffU/channels) /* no overflow */
4148       {
4149          png_uint_32 check;
<span class="line-modified">4150          const png_uint_32 png_row_stride = image-&gt;width * channels;</span>
4151 
4152          if (row_stride == 0)
4153             row_stride = (png_int_32)/*SAFE*/png_row_stride;
4154 
4155          if (row_stride &lt; 0)
4156             check = (png_uint_32)(-row_stride);
4157 
4158          else
4159             check = (png_uint_32)row_stride;
4160 
4161          /* This verifies &#39;check&#39;, the absolute value of the actual stride
4162           * passed in and detects overflow in the application calculation (i.e.
4163           * if the app did actually pass in a non-zero &#39;row_stride&#39;.
4164           */
4165          if (image-&gt;opaque != NULL &amp;&amp; buffer != NULL &amp;&amp; check &gt;= png_row_stride)
4166          {
4167             /* Now check for overflow of the image buffer calculation; this
4168              * limits the whole image size to 32 bits for API compatibility with
4169              * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
4170              *
</pre>
</td>
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* pngread.c - read a PNG file
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Copyright (c) 2018-2019 Cosmin Truta</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * Copyright (c) 1996-1997 Andreas Dilger</span>
<span class="line-modified">  35  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  *
  41  * This file contains routines that an application calls directly to
  42  * read a PNG file or stream.
  43  */
  44 
  45 #include &quot;pngpriv.h&quot;
  46 #if defined(PNG_SIMPLIFIED_READ_SUPPORTED) &amp;&amp; defined(PNG_STDIO_SUPPORTED)
  47 #  include &lt;errno.h&gt;
  48 #endif
  49 
  50 #ifdef PNG_READ_SUPPORTED
  51 
  52 /* Create a PNG structure for reading, and allocate any memory needed. */
  53 PNG_FUNCTION(png_structp,PNGAPI
  54 png_create_read_struct,(png_const_charp user_png_ver, png_voidp error_ptr,
  55     png_error_ptr error_fn, png_error_ptr warn_fn),PNG_ALLOCATED)
</pre>
<hr />
<pre>
1005 #endif
1006 
1007    inflateEnd(&amp;png_ptr-&gt;zstream);
1008 
1009 #ifdef PNG_PROGRESSIVE_READ_SUPPORTED
1010    png_free(png_ptr, png_ptr-&gt;save_buffer);
1011    png_ptr-&gt;save_buffer = NULL;
1012 #endif
1013 
1014 #if defined(PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED) &amp;&amp; \
1015    defined(PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
1016    png_free(png_ptr, png_ptr-&gt;unknown_chunk.data);
1017    png_ptr-&gt;unknown_chunk.data = NULL;
1018 #endif
1019 
1020 #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
1021    png_free(png_ptr, png_ptr-&gt;chunk_list);
1022    png_ptr-&gt;chunk_list = NULL;
1023 #endif
1024 
<span class="line-added">1025 #if defined(PNG_READ_EXPAND_SUPPORTED) &amp;&amp; \</span>
<span class="line-added">1026     defined(PNG_ARM_NEON_IMPLEMENTATION)</span>
<span class="line-added">1027    png_free(png_ptr, png_ptr-&gt;riffled_palette);</span>
<span class="line-added">1028    png_ptr-&gt;riffled_palette = NULL;</span>
<span class="line-added">1029 #endif</span>
<span class="line-added">1030 </span>
1031    /* NOTE: the &#39;setjmp&#39; buffer may still be allocated and the memory and error
1032     * callbacks are still set at this point.  They are required to complete the
1033     * destruction of the png_struct itself.
1034     */
1035 }
1036 
1037 /* Free all memory used by the read */
1038 void PNGAPI
1039 png_destroy_read_struct(png_structpp png_ptr_ptr, png_infopp info_ptr_ptr,
1040     png_infopp end_info_ptr_ptr)
1041 {
1042    png_structrp png_ptr = NULL;
1043 
1044    png_debug(1, &quot;in png_destroy_read_struct&quot;);
1045 
1046    if (png_ptr_ptr != NULL)
1047       png_ptr = *png_ptr_ptr;
1048 
1049    if (png_ptr == NULL)
1050       return;
</pre>
<hr />
<pre>
1638 {
1639    /* Prepare the reader to ignore all recognized chunks whose data will not
1640     * be used, i.e., all chunks recognized by libpng except for those
1641     * involved in basic image reading:
1642     *
1643     *    IHDR, PLTE, IDAT, IEND
1644     *
1645     * Or image data handling:
1646     *
1647     *    tRNS, bKGD, gAMA, cHRM, sRGB, [iCCP] and sBIT.
1648     *
1649     * This provides a small performance improvement and eliminates any
1650     * potential vulnerability to security problems in the unused chunks.
1651     *
1652     * At present the iCCP chunk data isn&#39;t used, so iCCP chunk can be ignored
1653     * too.  This allows the simplified API to be compiled without iCCP support,
1654     * however if the support is there the chunk is still checked to detect
1655     * errors (which are unfortunately quite common.)
1656     */
1657    {
<span class="line-modified">1658          static const png_byte chunks_to_process[] = {</span>
1659             98,  75,  71,  68, &#39;\0&#39;,  /* bKGD */
1660             99,  72,  82,  77, &#39;\0&#39;,  /* cHRM */
1661            103,  65,  77,  65, &#39;\0&#39;,  /* gAMA */
1662 #        ifdef PNG_READ_iCCP_SUPPORTED
1663            105,  67,  67,  80, &#39;\0&#39;,  /* iCCP */
1664 #        endif
1665            115,  66,  73,  84, &#39;\0&#39;,  /* sBIT */
1666            115,  82,  71,  66, &#39;\0&#39;,  /* sRGB */
1667            };
1668 
1669        /* Ignore unknown chunks and all other chunks except for the
1670         * IHDR, PLTE, tRNS, IDAT, and IEND chunks.
1671         */
1672        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_NEVER,
1673            NULL, -1);
1674 
1675        /* But do not ignore image data handling chunks */
1676        png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_AS_DEFAULT,
1677            chunks_to_process, (int)/*SAFE*/(sizeof chunks_to_process)/5);
1678    }
</pre>
<hr />
<pre>
1775       f *= 257; /* Now scaled by 65535 */
1776       f += f &gt;&gt; 16;
1777       f = (f+32768) &gt;&gt; 16;
1778    }
1779 
1780    else /* P_sRGB */
1781       f = PNG_sRGB_FROM_LINEAR(f);
1782 
1783    return f;
1784 }
1785 
1786 /* NOTE: P_LINEAR values to this routine must be 16-bit, but P_FILE values must
1787  * be 8-bit.
1788  */
1789 static void
1790 png_create_colormap_entry(png_image_read_control *display,
1791     png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,
1792     png_uint_32 alpha, int encoding)
1793 {
1794    png_imagep image = display-&gt;image;
<span class="line-modified">1795    int output_encoding = (image-&gt;format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
1796        P_LINEAR : P_sRGB;
<span class="line-modified">1797    int convert_to_Y = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) == 0 &amp;&amp;</span>
1798        (red != green || green != blue);
1799 
1800    if (ip &gt; 255)
1801       png_error(image-&gt;opaque-&gt;png_ptr, &quot;color-map index out of range&quot;);
1802 
1803    /* Update the cache with whether the file gamma is significantly different
1804     * from sRGB.
1805     */
1806    if (encoding == P_FILE)
1807    {
1808       if (display-&gt;file_encoding == P_NOTSET)
1809          set_file_encoding(display);
1810 
1811       /* Note that the cached value may be P_FILE too, but if it is then the
1812        * gamma_to_linear member has been set.
1813        */
1814       encoding = display-&gt;file_encoding;
1815    }
1816 
1817    if (encoding == P_FILE)
</pre>
<hr />
<pre>
1886 
1887          blue = red = green = y;
1888       }
1889 
1890       else if (output_encoding == P_sRGB)
1891       {
1892          red = PNG_sRGB_FROM_LINEAR(red * 255);
1893          green = PNG_sRGB_FROM_LINEAR(green * 255);
1894          blue = PNG_sRGB_FROM_LINEAR(blue * 255);
1895          alpha = PNG_DIV257(alpha);
1896          encoding = P_sRGB;
1897       }
1898    }
1899 
1900    if (encoding != output_encoding)
1901       png_error(image-&gt;opaque-&gt;png_ptr, &quot;bad encoding (internal error)&quot;);
1902 
1903    /* Store the value. */
1904    {
1905 #     ifdef PNG_FORMAT_AFIRST_SUPPORTED
<span class="line-modified">1906          int afirst = (image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0 &amp;&amp;</span>
1907             (image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0;
1908 #     else
1909 #        define afirst 0
1910 #     endif
1911 #     ifdef PNG_FORMAT_BGR_SUPPORTED
<span class="line-modified">1912          int bgr = (image-&gt;format &amp; PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;</span>
1913 #     else
1914 #        define bgr 0
1915 #     endif
1916 
1917       if (output_encoding == P_LINEAR)
1918       {
1919          png_uint_16p entry = png_voidcast(png_uint_16p, display-&gt;colormap);
1920 
1921          entry += ip * PNG_IMAGE_SAMPLE_CHANNELS(image-&gt;format);
1922 
1923          /* The linear 16-bit values must be pre-multiplied by the alpha channel
1924           * value, if less than 65535 (this is, effectively, composite on black
1925           * if the alpha channel is removed.)
1926           */
1927          switch (PNG_IMAGE_SAMPLE_CHANNELS(image-&gt;format))
1928          {
1929             case 4:
1930                entry[afirst ? 0 : 3] = (png_uint_16)alpha;
1931                /* FALLTHROUGH */
1932 
</pre>
<hr />
<pre>
2102          for (b=0; b&lt;6; ++b)
2103             png_create_colormap_entry(display, i++, r*51, g*51, b*51, 255,
2104                 P_sRGB);
2105       }
2106    }
2107 
2108    return (int)i;
2109 }
2110 
2111 #define PNG_RGB_COLORMAP_ENTRIES 216
2112 
2113 /* Return a palette index to the above palette given three 8-bit sRGB values. */
2114 #define PNG_RGB_INDEX(r,g,b) \
2115    ((png_byte)(6 * (6 * PNG_DIV51(r) + PNG_DIV51(g)) + PNG_DIV51(b)))
2116 
2117 static int
2118 png_image_read_colormap(png_voidp argument)
2119 {
2120    png_image_read_control *display =
2121       png_voidcast(png_image_read_control*, argument);
<span class="line-modified">2122    png_imagep image = display-&gt;image;</span>
2123 
<span class="line-modified">2124    png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;</span>
<span class="line-modified">2125    png_uint_32 output_format = image-&gt;format;</span>
<span class="line-modified">2126    int output_encoding = (output_format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
2127       P_LINEAR : P_sRGB;
2128 
2129    unsigned int cmap_entries;
2130    unsigned int output_processing;        /* Output processing option */
2131    unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */
2132 
2133    /* Background information; the background color and the index of this color
2134     * in the color-map if it exists (else 256).
2135     */
2136    unsigned int background_index = 256;
2137    png_uint_32 back_r, back_g, back_b;
2138 
2139    /* Flags to accumulate things that need to be done to the input. */
2140    int expand_tRNS = 0;
2141 
2142    /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
2143     * very difficult to do, the results look awful, and it is difficult to see
2144     * what possible use it is because the application can&#39;t control the
2145     * color-map.
2146     */
</pre>
<hr />
<pre>
2819                /* Alpha in the output is irrelevant, simply map the opaque input
2820                 * pixels to the 6x6x6 color-map.
2821                 */
2822                if (PNG_RGB_COLORMAP_ENTRIES &gt; image-&gt;colormap_entries)
2823                   png_error(png_ptr, &quot;rgb color-map: too few entries&quot;);
2824 
2825                cmap_entries = (unsigned int)make_rgb_colormap(display);
2826                output_processing = PNG_CMAP_RGB;
2827             }
2828          }
2829          break;
2830 
2831       case PNG_COLOR_TYPE_PALETTE:
2832          /* It&#39;s already got a color-map.  It may be necessary to eliminate the
2833           * tRNS entries though.
2834           */
2835          {
2836             unsigned int num_trans = png_ptr-&gt;num_trans;
2837             png_const_bytep trans = num_trans &gt; 0 ? png_ptr-&gt;trans_alpha : NULL;
2838             png_const_colorp colormap = png_ptr-&gt;palette;
<span class="line-modified">2839             int do_background = trans != NULL &amp;&amp;</span>
2840                (output_format &amp; PNG_FORMAT_FLAG_ALPHA) == 0;
2841             unsigned int i;
2842 
2843             /* Just in case: */
2844             if (trans == NULL)
2845                num_trans = 0;
2846 
2847             output_processing = PNG_CMAP_NONE;
2848             data_encoding = P_FILE; /* Don&#39;t change from color-map indices */
2849             cmap_entries = (unsigned int)png_ptr-&gt;num_palette;
2850             if (cmap_entries &gt; 256)
2851                cmap_entries = 256;
2852 
2853             if (cmap_entries &gt; (unsigned int)image-&gt;colormap_entries)
2854                png_error(png_ptr, &quot;palette color-map: too few entries&quot;);
2855 
2856             for (i=0; i &lt; cmap_entries; ++i)
2857             {
2858                if (do_background != 0 &amp;&amp; i &lt; num_trans &amp;&amp; trans[i] &lt; 255)
2859                {
</pre>
<hr />
<pre>
3963             {
3964                /* Disable this if doing a local background,
3965                 * TODO: remove this when local background is no longer required.
3966                 */
3967                if (do_local_background != 2)
3968                   png_set_swap_alpha(png_ptr);
3969             }
3970 
3971             else
3972                format &amp;= ~PNG_FORMAT_FLAG_AFIRST;
3973 
3974             change &amp;= ~PNG_FORMAT_FLAG_AFIRST;
3975          }
3976 #     endif
3977 
3978       /* If the *output* is 16-bit then we need to check for a byte-swap on this
3979        * architecture.
3980        */
3981       if (linear != 0)
3982       {
<span class="line-modified">3983          png_uint_16 le = 0x0001;</span>
3984 
3985          if ((*(png_const_bytep) &amp; le) != 0)
3986             png_set_swap(png_ptr);
3987       }
3988 
3989       /* If change is not now 0 some transformation is missing - error out. */
3990       if (change != 0)
3991          png_error(png_ptr, &quot;png_read_image: unsupported transformation&quot;);
3992    }
3993 
3994    PNG_SKIP_CHUNKS(png_ptr);
3995 
3996    /* Update the &#39;info&#39; structure and make sure the result is as required; first
3997     * make sure to turn on the interlace handling if it will be required
3998     * (because it can&#39;t be turned on *after* the call to png_read_update_info!)
3999     *
4000     * TODO: remove the do_local_background fixup below.
4001     */
4002    if (do_local_compose == 0 &amp;&amp; do_local_background != 2)
4003       passes = png_set_interlace_handling(png_ptr);
</pre>
<hr />
<pre>
4125          {
4126             png_read_row(png_ptr, row, NULL);
4127             row += row_bytes;
4128          }
4129       }
4130 
4131       return 1;
4132    }
4133 }
4134 
4135 int PNGAPI
4136 png_image_finish_read(png_imagep image, png_const_colorp background,
4137     void *buffer, png_int_32 row_stride, void *colormap)
4138 {
4139    if (image != NULL &amp;&amp; image-&gt;version == PNG_IMAGE_VERSION)
4140    {
4141       /* Check for row_stride overflow.  This check is not performed on the
4142        * original PNG format because it may not occur in the output PNG format
4143        * and libpng deals with the issues of reading the original.
4144        */
<span class="line-modified">4145       unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image-&gt;format);</span>
4146 
4147       /* The following checks just the &#39;row_stride&#39; calculation to ensure it
4148        * fits in a signed 32-bit value.  Because channels/components can be
4149        * either 1 or 2 bytes in size the length of a row can still overflow 32
4150        * bits; this is just to verify that the &#39;row_stride&#39; argument can be
4151        * represented.
4152        */
4153       if (image-&gt;width &lt;= 0x7fffffffU/channels) /* no overflow */
4154       {
4155          png_uint_32 check;
<span class="line-modified">4156          png_uint_32 png_row_stride = image-&gt;width * channels;</span>
4157 
4158          if (row_stride == 0)
4159             row_stride = (png_int_32)/*SAFE*/png_row_stride;
4160 
4161          if (row_stride &lt; 0)
4162             check = (png_uint_32)(-row_stride);
4163 
4164          else
4165             check = (png_uint_32)row_stride;
4166 
4167          /* This verifies &#39;check&#39;, the absolute value of the actual stride
4168           * passed in and detects overflow in the application calculation (i.e.
4169           * if the app did actually pass in a non-zero &#39;row_stride&#39;.
4170           */
4171          if (image-&gt;opaque != NULL &amp;&amp; buffer != NULL &amp;&amp; check &gt;= png_row_stride)
4172          {
4173             /* Now check for overflow of the image buffer calculation; this
4174              * limits the whole image size to 32 bits for API compatibility with
4175              * the current, 32-bit, PNG_IMAGE_BUFFER_SIZE macro.
4176              *
</pre>
</td>
</tr>
</table>
<center><a href="pngpriv.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngrio.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/giflib/gifalloc.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="gif_lib_private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="openbsd-reallocarray.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/giflib/gifalloc.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*****************************************************************************
 26 
 27  GIF construction tools
 28 


 29 ****************************************************************************/
 30 
 31 #include &lt;stdlib.h&gt;
 32 #include &lt;stdio.h&gt;
 33 #include &lt;string.h&gt;
 34 
 35 #include &quot;gif_lib.h&quot;

 36 
 37 #define MAX(x, y)    (((x) &gt; (y)) ? (x) : (y))
 38 
 39 /******************************************************************************
 40  Miscellaneous utility functions
 41 ******************************************************************************/
 42 
 43 /* return smallest bitfield size n will fit in */
 44 int
 45 GifBitSize(int n)
 46 {
 47     register int i;
 48 
 49     for (i = 1; i &lt;= 8; i++)
 50         if ((1 &lt;&lt; i) &gt;= n)
 51             break;
 52     return (i);
 53 }
 54 
 55 /******************************************************************************
</pre>
<hr />
<pre>
331 
332     /* Deallocate any extensions */
333     GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
334 
335     /*** FIXME: We could realloc the GifFile-&gt;SavedImages structure but is
336      * there a point to it? Saves some memory but we&#39;d have to do it every
337      * time.  If this is used in GifFreeSavedImages then it would be inefficient
338      * (The whole array is going to be deallocated.)  If we just use it when
339      * we want to free the last Image it&#39;s convenient to do it here.
340      */
341 }
342 
343 /*
344  * Append an image block to the SavedImages array
345  */
346 SavedImage *
347 GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
348 {
349     if (GifFile-&gt;SavedImages == NULL)
350         GifFile-&gt;SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
<span class="line-modified">351     else</span>
<span class="line-modified">352         GifFile-&gt;SavedImages = (SavedImage *)reallocarray(GifFile-&gt;SavedImages,</span>
353                                (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
<span class="line-modified">354 </span>



355     if (GifFile-&gt;SavedImages == NULL)
356         return ((SavedImage *)NULL);
357     else {
358         SavedImage *sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount++];
<span class="line-removed">359         memset((char *)sp, &#39;\0&#39;, sizeof(SavedImage));</span>
360 
361         if (CopyFrom != NULL) {
362             memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
363 
364             /*
365              * Make our own allocated copies of the heap fields in the
366              * copied record.  This guards against potential aliasing
367              * problems.
368              */
369 
370             /* first, the local color map */
<span class="line-modified">371             if (sp-&gt;ImageDesc.ColorMap != NULL) {</span>
372                 sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
373                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;ColorCount,
374                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;Colors);
375                 if (sp-&gt;ImageDesc.ColorMap == NULL) {
376                     FreeLastSavedImage(GifFile);
377                     return (SavedImage *)(NULL);
378                 }
379             }
380 
381             /* next, the raster */
382             sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL,
383                                                   (CopyFrom-&gt;ImageDesc.Height *
384                                                   CopyFrom-&gt;ImageDesc.Width),
385                                                   sizeof(GifPixelType));
386             if (sp-&gt;RasterBits == NULL) {
387                 FreeLastSavedImage(GifFile);
388                 return (SavedImage *)(NULL);
389             }
390             memcpy(sp-&gt;RasterBits, CopyFrom-&gt;RasterBits,
391                    sizeof(GifPixelType) * CopyFrom-&gt;ImageDesc.Height *
392                    CopyFrom-&gt;ImageDesc.Width);
393 
394             /* finally, the extension blocks */
<span class="line-modified">395             if (sp-&gt;ExtensionBlocks != NULL) {</span>
396                 sp-&gt;ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
397                                       CopyFrom-&gt;ExtensionBlockCount,
398                                       sizeof(ExtensionBlock));
399                 if (sp-&gt;ExtensionBlocks == NULL) {
400                     FreeLastSavedImage(GifFile);
401                     return (SavedImage *)(NULL);
402                 }
403                 memcpy(sp-&gt;ExtensionBlocks, CopyFrom-&gt;ExtensionBlocks,
404                        sizeof(ExtensionBlock) * CopyFrom-&gt;ExtensionBlockCount);
405             }
406         }



407 
408         return (sp);
409     }
410 }
411 
412 void
413 GifFreeSavedImages(GifFileType *GifFile)
414 {
415     SavedImage *sp;
416 
417     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL)) {
418         return;
419     }
420     for (sp = GifFile-&gt;SavedImages;
421          sp &lt; GifFile-&gt;SavedImages + GifFile-&gt;ImageCount; sp++) {
422         if (sp-&gt;ImageDesc.ColorMap != NULL) {
423             GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
424             sp-&gt;ImageDesc.ColorMap = NULL;
425         }
426 
</pre>
</td>
<td>
<hr />
<pre>
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*****************************************************************************
 26 
 27  GIF construction tools
 28 
<span class="line-added"> 29 SPDX-License-Identifier: MIT</span>
<span class="line-added"> 30 </span>
 31 ****************************************************************************/
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;stdio.h&gt;
 35 #include &lt;string.h&gt;
 36 
 37 #include &quot;gif_lib.h&quot;
<span class="line-added"> 38 #include &quot;gif_lib_private.h&quot;</span>
 39 
 40 #define MAX(x, y)    (((x) &gt; (y)) ? (x) : (y))
 41 
 42 /******************************************************************************
 43  Miscellaneous utility functions
 44 ******************************************************************************/
 45 
 46 /* return smallest bitfield size n will fit in */
 47 int
 48 GifBitSize(int n)
 49 {
 50     register int i;
 51 
 52     for (i = 1; i &lt;= 8; i++)
 53         if ((1 &lt;&lt; i) &gt;= n)
 54             break;
 55     return (i);
 56 }
 57 
 58 /******************************************************************************
</pre>
<hr />
<pre>
334 
335     /* Deallocate any extensions */
336     GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
337 
338     /*** FIXME: We could realloc the GifFile-&gt;SavedImages structure but is
339      * there a point to it? Saves some memory but we&#39;d have to do it every
340      * time.  If this is used in GifFreeSavedImages then it would be inefficient
341      * (The whole array is going to be deallocated.)  If we just use it when
342      * we want to free the last Image it&#39;s convenient to do it here.
343      */
344 }
345 
346 /*
347  * Append an image block to the SavedImages array
348  */
349 SavedImage *
350 GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
351 {
352     if (GifFile-&gt;SavedImages == NULL)
353         GifFile-&gt;SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
<span class="line-modified">354     else {</span>
<span class="line-modified">355         SavedImage* newSavedImages = (SavedImage *)reallocarray(GifFile-&gt;SavedImages,</span>
356                                (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
<span class="line-modified">357         if( newSavedImages == NULL)</span>
<span class="line-added">358             return ((SavedImage *)NULL);</span>
<span class="line-added">359         GifFile-&gt;SavedImages = newSavedImages;</span>
<span class="line-added">360     }</span>
361     if (GifFile-&gt;SavedImages == NULL)
362         return ((SavedImage *)NULL);
363     else {
364         SavedImage *sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount++];

365 
366         if (CopyFrom != NULL) {
367             memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
368 
369             /*
370              * Make our own allocated copies of the heap fields in the
371              * copied record.  This guards against potential aliasing
372              * problems.
373              */
374 
375             /* first, the local color map */
<span class="line-modified">376             if (CopyFrom-&gt;ImageDesc.ColorMap != NULL) {</span>
377                 sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
378                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;ColorCount,
379                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;Colors);
380                 if (sp-&gt;ImageDesc.ColorMap == NULL) {
381                     FreeLastSavedImage(GifFile);
382                     return (SavedImage *)(NULL);
383                 }
384             }
385 
386             /* next, the raster */
387             sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL,
388                                                   (CopyFrom-&gt;ImageDesc.Height *
389                                                   CopyFrom-&gt;ImageDesc.Width),
390                                                   sizeof(GifPixelType));
391             if (sp-&gt;RasterBits == NULL) {
392                 FreeLastSavedImage(GifFile);
393                 return (SavedImage *)(NULL);
394             }
395             memcpy(sp-&gt;RasterBits, CopyFrom-&gt;RasterBits,
396                    sizeof(GifPixelType) * CopyFrom-&gt;ImageDesc.Height *
397                    CopyFrom-&gt;ImageDesc.Width);
398 
399             /* finally, the extension blocks */
<span class="line-modified">400             if (CopyFrom-&gt;ExtensionBlocks != NULL) {</span>
401                 sp-&gt;ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
402                                       CopyFrom-&gt;ExtensionBlockCount,
403                                       sizeof(ExtensionBlock));
404                 if (sp-&gt;ExtensionBlocks == NULL) {
405                     FreeLastSavedImage(GifFile);
406                     return (SavedImage *)(NULL);
407                 }
408                 memcpy(sp-&gt;ExtensionBlocks, CopyFrom-&gt;ExtensionBlocks,
409                        sizeof(ExtensionBlock) * CopyFrom-&gt;ExtensionBlockCount);
410             }
411         }
<span class="line-added">412         else {</span>
<span class="line-added">413             memset((char *)sp, &#39;\0&#39;, sizeof(SavedImage));</span>
<span class="line-added">414         }</span>
415 
416         return (sp);
417     }
418 }
419 
420 void
421 GifFreeSavedImages(GifFileType *GifFile)
422 {
423     SavedImage *sp;
424 
425     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL)) {
426         return;
427     }
428     for (sp = GifFile-&gt;SavedImages;
429          sp &lt; GifFile-&gt;SavedImages + GifFile-&gt;ImageCount; sp++) {
430         if (sp-&gt;ImageDesc.ColorMap != NULL) {
431             GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
432             sp-&gt;ImageDesc.ColorMap = NULL;
433         }
434 
</pre>
</td>
</tr>
</table>
<center><a href="gif_lib_private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="openbsd-reallocarray.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
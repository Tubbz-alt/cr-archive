<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/libpng/png.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="README.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="png.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/libpng/png.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* png.c - location for general purpose libpng functions
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Last changed in libpng 1.6.35 [July 15, 2018]</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)</span>
<span class="line-modified">  35  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  */
  41 
  42 #include &quot;pngpriv.h&quot;
  43 
  44 /* Generate a compiler error if there is an old png.h in the search path. */
<span class="line-modified">  45 typedef png_libpng_version_1_6_35 Your_png_h_is_not_version_1_6_35;</span>
  46 
  47 #ifdef __GNUC__
  48 /* The version tests may need to be added to, but the problem warning has
  49  * consistently been fixed in GCC versions which obtain wide-spread release.
  50  * The problem is that many versions of GCC rearrange comparison expressions in
  51  * the optimizer in such a way that the results of the comparison will change
  52  * if signed integer overflow occurs.  Such comparisons are not permitted in
  53  * ANSI C90, however GCC isn&#39;t clever enough to work out that that do not occur
  54  * below in png_ascii_from_fp and png_muldiv, so it produces a warning with
  55  * -Wextra.  Unfortunately this is highly dependent on the optimizer and the
  56  * machine architecture so the warning comes and goes unpredictably and is
  57  * impossible to &quot;fix&quot;, even were that a good idea.
  58  */
  59 #if __GNUC__ == 7 &amp;&amp; __GNUC_MINOR__ == 1
  60 #define GCC_STRICT_OVERFLOW 1
  61 #endif /* GNU 7.1.x */
  62 #endif /* GNU */
  63 #ifndef GCC_STRICT_OVERFLOW
  64 #define GCC_STRICT_OVERFLOW 0
  65 #endif
</pre>
<hr />
<pre>
 747  *     (UNSIGNED_MAX+1) + integer
 748  *
 749  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
 750  * negative integral value is added the result will be an unsigned value
 751  * correspnding to the 2&#39;s complement representation.
 752  */
 753 void PNGAPI
 754 png_save_int_32(png_bytep buf, png_int_32 i)
 755 {
 756    png_save_uint_32(buf, (png_uint_32)i);
 757 }
 758 #  endif
 759 
 760 #  ifdef PNG_TIME_RFC1123_SUPPORTED
 761 /* Convert the supplied time into an RFC 1123 string suitable for use in
 762  * a &quot;Creation Time&quot; or other text-based time string.
 763  */
 764 int PNGAPI
 765 png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
 766 {
<span class="line-modified"> 767    static PNG_CONST char short_months[12][4] =</span>
 768         {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
 769          &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
 770 
 771    if (out == NULL)
 772       return 0;
 773 
 774    if (ptime-&gt;year &gt; 9999 /* RFC1123 limitation */ ||
 775        ptime-&gt;month == 0    ||  ptime-&gt;month &gt; 12  ||
 776        ptime-&gt;day   == 0    ||  ptime-&gt;day   &gt; 31  ||
 777        ptime-&gt;hour  &gt; 23    ||  ptime-&gt;minute &gt; 59 ||
 778        ptime-&gt;second &gt; 60)
 779       return 0;
 780 
 781    {
 782       size_t pos = 0;
 783       char number_buf[5]; /* enough for a four-digit year */
 784 
 785 #     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))
 786 #     define APPEND_NUMBER(format, value)\
 787          APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
</pre>
<hr />
<pre>
 825          png_warning(png_ptr, &quot;Ignoring invalid time value&quot;);
 826 
 827       else
 828          return png_ptr-&gt;time_buffer;
 829    }
 830 
 831    return NULL;
 832 }
 833 #    endif /* LIBPNG_VER &lt; 10700 */
 834 #  endif /* TIME_RFC1123 */
 835 
 836 #endif /* READ || WRITE */
 837 
 838 png_const_charp PNGAPI
 839 png_get_copyright(png_const_structrp png_ptr)
 840 {
 841    PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
 842 #ifdef PNG_STRING_COPYRIGHT
 843    return PNG_STRING_COPYRIGHT
 844 #else
<span class="line-removed"> 845 #  ifdef __STDC__</span>
 846    return PNG_STRING_NEWLINE \
<span class="line-modified"> 847       &quot;libpng version 1.6.35 - July 15, 2018&quot; PNG_STRING_NEWLINE \</span>

 848       &quot;Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson&quot; \
 849       PNG_STRING_NEWLINE \
 850       &quot;Copyright (c) 1996-1997 Andreas Dilger&quot; PNG_STRING_NEWLINE \
 851       &quot;Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.&quot; \
 852       PNG_STRING_NEWLINE;
<span class="line-removed"> 853 #  else</span>
<span class="line-removed"> 854    return &quot;libpng version 1.6.35 - July 15, 2018\</span>
<span class="line-removed"> 855       Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson\</span>
<span class="line-removed"> 856       Copyright (c) 1996-1997 Andreas Dilger\</span>
<span class="line-removed"> 857       Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.&quot;;</span>
<span class="line-removed"> 858 #  endif</span>
 859 #endif
 860 }
 861 
 862 /* The following return the library version as a short string in the
 863  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
 864  * used with your application, print out PNG_LIBPNG_VER_STRING, which
 865  * is defined in png.h.
 866  * Note: now there is no difference between png_get_libpng_ver() and
 867  * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
 868  * it is guaranteed that png.c uses the correct version of png.h.
 869  */
 870 png_const_charp PNGAPI
 871 png_get_libpng_ver(png_const_structrp png_ptr)
 872 {
 873    /* Version of *.c files used when building libpng */
 874    return png_get_header_ver(png_ptr);
 875 }
 876 
 877 png_const_charp PNGAPI
 878 png_get_header_ver(png_const_structrp png_ptr)
</pre>
<hr />
<pre>
1132          /* Do not overwrite an sRGB value */
1133          return from == 2;
1134       }
1135 
1136       else /* sRGB tag not involved */
1137       {
1138          png_chunk_report(png_ptr, &quot;gamma value does not match libpng estimate&quot;,
1139              PNG_CHUNK_WARNING);
1140          return from == 1;
1141       }
1142    }
1143 
1144    return 1;
1145 }
1146 
1147 void /* PRIVATE */
1148 png_colorspace_set_gamma(png_const_structrp png_ptr,
1149     png_colorspacerp colorspace, png_fixed_point gAMA)
1150 {
1151    /* Changed in libpng-1.5.4 to limit the values to ensure overflow can&#39;t
<span class="line-modified">1152     * occur.  Since the fixed point representation is asymetrical it is</span>
1153     * possible for 1/gamma to overflow the limit of 21474 and this means the
1154     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
1155     * safety the limits here are a little narrower.  The values are 0.00016 to
1156     * 6250.0, which are truly ridiculous gamma values (and will produce
1157     * displays that are all black or all white.)
1158     *
1159     * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk
1160     * handling code, which only required the value to be &gt;0.
1161     */
1162    png_const_charp errmsg;
1163 
1164    if (gAMA &lt; 16 || gAMA &gt; 625000000)
1165       errmsg = &quot;gamma value out of range&quot;;
1166 
1167 #  ifdef PNG_READ_gAMA_SUPPORTED
1168    /* Allow the application to set the gamma value more than once */
1169    else if ((png_ptr-&gt;mode &amp; PNG_IS_READ_STRUCT) != 0 &amp;&amp;
1170       (colorspace-&gt;flags &amp; PNG_COLORSPACE_FROM_gAMA) != 0)
1171       errmsg = &quot;duplicate&quot;;
1172 #  endif
</pre>
<hr />
<pre>
3145                      *ascii++ = 48; --czero;
3146                   }
3147 
3148                   if (exp_b10 != (-1))
3149                   {
3150                      if (exp_b10 == 0)
3151                      {
3152                         *ascii++ = 46; --size; /* counted above */
3153                      }
3154 
3155                      --exp_b10;
3156                   }
3157                   *ascii++ = (char)(48 + (int)d); ++cdigits;
3158                }
3159             }
3160             while (cdigits+czero &lt; precision+clead &amp;&amp; fp &gt; DBL_MIN);
3161 
3162             /* The total output count (max) is now 4+precision */
3163 
3164             /* Check for an exponent, if we don&#39;t need one we are
<span class="line-modified">3165              * done and just need to terminate the string.  At</span>
<span class="line-modified">3166              * this point exp_b10==(-1) is effectively a flag - it got</span>
<span class="line-modified">3167              * to &#39;-1&#39; because of the decrement after outputting</span>
<span class="line-modified">3168              * the decimal point above (the exponent required is</span>
<span class="line-modified">3169              * *not* -1!)</span>
3170              */
3171             if (exp_b10 &gt;= (-1) &amp;&amp; exp_b10 &lt;= 2)
3172             {
3173                /* The following only happens if we didn&#39;t output the
3174                 * leading zeros above for negative exponent, so this
3175                 * doesn&#39;t add to the digit requirement.  Note that the
3176                 * two zeros here can only be output if the two leading
3177                 * zeros were *not* output, so this doesn&#39;t increase
3178                 * the output count.
3179                 */
3180                while (exp_b10-- &gt; 0) *ascii++ = 48;
3181 
3182                *ascii = 0;
3183 
3184                /* Total buffer requirement (including the &#39;\0&#39;) is
3185                 * 5+precision - see check at the start.
3186                 */
3187                return;
3188             }
3189 
</pre>
<hr />
<pre>
3987 #ifdef PNG_16BIT_SUPPORTED
3988    else
3989       return png_gamma_16bit_correct(value, gamma_val);
3990 #else
3991       /* should not reach this */
3992       return 0;
3993 #endif /* 16BIT */
3994 }
3995 
3996 #ifdef PNG_16BIT_SUPPORTED
3997 /* Internal function to build a single 16-bit table - the table consists of
3998  * &#39;num&#39; 256 entry subtables, where &#39;num&#39; is determined by &#39;shift&#39; - the amount
3999  * to shift the input values right (or 16-number_of_signifiant_bits).
4000  *
4001  * The caller is responsible for ensuring that the table gets cleaned up on
4002  * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument
4003  * should be somewhere that will be cleaned.
4004  */
4005 static void
4006 png_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,
<span class="line-modified">4007     PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)</span>
4008 {
4009    /* Various values derived from &#39;shift&#39;: */
<span class="line-modified">4010    PNG_CONST unsigned int num = 1U &lt;&lt; (8U - shift);</span>
4011 #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
4012    /* CSE the division and work round wacky GCC warnings (see the comments
4013     * in png_gamma_8bit_correct for where these come from.)
4014     */
<span class="line-modified">4015    PNG_CONST double fmax = 1./(((png_int_32)1 &lt;&lt; (16U - shift))-1);</span>
4016 #endif
<span class="line-modified">4017    PNG_CONST unsigned int max = (1U &lt;&lt; (16U - shift))-1U;</span>
<span class="line-modified">4018    PNG_CONST unsigned int max_by_2 = 1U &lt;&lt; (15U-shift);</span>
4019    unsigned int i;
4020 
4021    png_uint_16pp table = *ptable =
4022        (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));
4023 
4024    for (i = 0; i &lt; num; i++)
4025    {
4026       png_uint_16p sub_table = table[i] =
4027           (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));
4028 
4029       /* The &#39;threshold&#39; test is repeated here because it can arise for one of
4030        * the 16-bit tables even if the others don&#39;t hit it.
4031        */
4032       if (png_gamma_significant(gamma_val) != 0)
4033       {
4034          /* The old code would overflow at the end and this would cause the
4035           * &#39;pow&#39; function to return a result &gt;1, resulting in an
4036           * arithmetic error.  This code follows the spec exactly; ig is
4037           * the recovered input sample, it always has 8-16 bits.
4038           *
</pre>
<hr />
<pre>
4064          unsigned int j;
4065 
4066          for (j = 0; j &lt; 256; j++)
4067          {
4068             png_uint_32 ig = (j &lt;&lt; (8-shift)) + i;
4069 
4070             if (shift != 0)
4071                ig = (ig * 65535U + max_by_2)/max;
4072 
4073             sub_table[j] = (png_uint_16)ig;
4074          }
4075       }
4076    }
4077 }
4078 
4079 /* NOTE: this function expects the *inverse* of the overall gamma transformation
4080  * required.
4081  */
4082 static void
4083 png_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,
<span class="line-modified">4084     PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)</span>
4085 {
<span class="line-modified">4086    PNG_CONST unsigned int num = 1U &lt;&lt; (8U - shift);</span>
<span class="line-modified">4087    PNG_CONST unsigned int max = (1U &lt;&lt; (16U - shift))-1U;</span>
4088    unsigned int i;
4089    png_uint_32 last;
4090 
4091    png_uint_16pp table = *ptable =
4092        (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));
4093 
4094    /* &#39;num&#39; is the number of tables and also the number of low bits of low
4095     * bits of the input 16-bit value used to select a table.  Each table is
4096     * itself indexed by the high 8 bits of the value.
4097     */
4098    for (i = 0; i &lt; num; i++)
4099       table[i] = (png_uint_16p)png_malloc(png_ptr,
4100           256 * (sizeof (png_uint_16)));
4101 
4102    /* &#39;gamma_val&#39; is set to the reciprocal of the value calculated above, so
4103     * pow(out,g) is an *input* value.  &#39;last&#39; is the last input value set.
4104     *
4105     * In the loop &#39;i&#39; is used to find output values.  Since the output is
4106     * 8-bit there are only 256 possible values.  The tables are set up to
4107     * select the closest possible output value for each input by finding
</pre>
<hr />
<pre>
4132          table[last &amp; (0xffU &gt;&gt; shift)][last &gt;&gt; (8U - shift)] = out;
4133          last++;
4134       }
4135    }
4136 
4137    /* And fill in the final entries. */
4138    while (last &lt; (num &lt;&lt; 8))
4139    {
4140       table[last &amp; (0xff &gt;&gt; shift)][last &gt;&gt; (8U - shift)] = 65535U;
4141       last++;
4142    }
4143 }
4144 #endif /* 16BIT */
4145 
4146 /* Build a single 8-bit table: same as the 16-bit case but much simpler (and
4147  * typically much faster).  Note that libpng currently does no sBIT processing
4148  * (apparently contrary to the spec) so a 256-entry table is always generated.
4149  */
4150 static void
4151 png_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,
<span class="line-modified">4152     PNG_CONST png_fixed_point gamma_val)</span>
4153 {
4154    unsigned int i;
4155    png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
4156 
4157    if (png_gamma_significant(gamma_val) != 0)
4158       for (i=0; i&lt;256; i++)
4159          table[i] = png_gamma_8bit_correct(i, gamma_val);
4160 
4161    else
4162       for (i=0; i&lt;256; ++i)
4163          table[i] = (png_byte)(i &amp; 0xff);
4164 }
4165 
4166 /* Used from png_read_destroy and below to release the memory used by the gamma
4167  * tables.
4168  */
4169 void /* PRIVATE */
4170 png_destroy_gamma_table(png_structrp png_ptr)
4171 {
4172    png_free(png_ptr, png_ptr-&gt;gamma_table);
</pre>
<hr />
<pre>
4605          png_destroy_read_struct(&amp;c.png_ptr, &amp;c.info_ptr, NULL);
4606 #     else
4607          png_error(c.png_ptr, &quot;simplified read not supported&quot;);
4608 #     endif
4609    }
4610 
4611    /* Success. */
4612    return 1;
4613 }
4614 
4615 void PNGAPI
4616 png_image_free(png_imagep image)
4617 {
4618    /* Safely call the real function, but only if doing so is safe at this point
4619     * (if not inside an error handling context).  Otherwise assume
4620     * png_safe_execute will call this API after the return.
4621     */
4622    if (image != NULL &amp;&amp; image-&gt;opaque != NULL &amp;&amp;
4623       image-&gt;opaque-&gt;error_buf == NULL)
4624    {
<span class="line-modified">4625       /* Ignore errors here: */</span>
<span class="line-removed">4626       (void)png_safe_execute(image, png_image_free_function, image);</span>
4627       image-&gt;opaque = NULL;
4628    }
4629 }
4630 
4631 int /* PRIVATE */
4632 png_image_error(png_imagep image, png_const_charp error_message)
4633 {
4634    /* Utility to log an error. */
4635    png_safecat(image-&gt;message, (sizeof image-&gt;message), 0, error_message);
4636    image-&gt;warning_or_error |= PNG_IMAGE_ERROR;
4637    png_image_free(image);
4638    return 0;
4639 }
4640 
4641 #endif /* SIMPLIFIED READ/WRITE */
4642 #endif /* READ || WRITE */
</pre>
</td>
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* png.c - location for general purpose libpng functions
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Copyright (c) 2018-2019 Cosmin Truta</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * Copyright (c) 1996-1997 Andreas Dilger</span>
<span class="line-modified">  35  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  */
  41 
  42 #include &quot;pngpriv.h&quot;
  43 
  44 /* Generate a compiler error if there is an old png.h in the search path. */
<span class="line-modified">  45 typedef png_libpng_version_1_6_37 Your_png_h_is_not_version_1_6_37;</span>
  46 
  47 #ifdef __GNUC__
  48 /* The version tests may need to be added to, but the problem warning has
  49  * consistently been fixed in GCC versions which obtain wide-spread release.
  50  * The problem is that many versions of GCC rearrange comparison expressions in
  51  * the optimizer in such a way that the results of the comparison will change
  52  * if signed integer overflow occurs.  Such comparisons are not permitted in
  53  * ANSI C90, however GCC isn&#39;t clever enough to work out that that do not occur
  54  * below in png_ascii_from_fp and png_muldiv, so it produces a warning with
  55  * -Wextra.  Unfortunately this is highly dependent on the optimizer and the
  56  * machine architecture so the warning comes and goes unpredictably and is
  57  * impossible to &quot;fix&quot;, even were that a good idea.
  58  */
  59 #if __GNUC__ == 7 &amp;&amp; __GNUC_MINOR__ == 1
  60 #define GCC_STRICT_OVERFLOW 1
  61 #endif /* GNU 7.1.x */
  62 #endif /* GNU */
  63 #ifndef GCC_STRICT_OVERFLOW
  64 #define GCC_STRICT_OVERFLOW 0
  65 #endif
</pre>
<hr />
<pre>
 747  *     (UNSIGNED_MAX+1) + integer
 748  *
 749  * Where UNSIGNED_MAX is the appropriate maximum unsigned value, so when the
 750  * negative integral value is added the result will be an unsigned value
 751  * correspnding to the 2&#39;s complement representation.
 752  */
 753 void PNGAPI
 754 png_save_int_32(png_bytep buf, png_int_32 i)
 755 {
 756    png_save_uint_32(buf, (png_uint_32)i);
 757 }
 758 #  endif
 759 
 760 #  ifdef PNG_TIME_RFC1123_SUPPORTED
 761 /* Convert the supplied time into an RFC 1123 string suitable for use in
 762  * a &quot;Creation Time&quot; or other text-based time string.
 763  */
 764 int PNGAPI
 765 png_convert_to_rfc1123_buffer(char out[29], png_const_timep ptime)
 766 {
<span class="line-modified"> 767    static const char short_months[12][4] =</span>
 768         {&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;,
 769          &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;};
 770 
 771    if (out == NULL)
 772       return 0;
 773 
 774    if (ptime-&gt;year &gt; 9999 /* RFC1123 limitation */ ||
 775        ptime-&gt;month == 0    ||  ptime-&gt;month &gt; 12  ||
 776        ptime-&gt;day   == 0    ||  ptime-&gt;day   &gt; 31  ||
 777        ptime-&gt;hour  &gt; 23    ||  ptime-&gt;minute &gt; 59 ||
 778        ptime-&gt;second &gt; 60)
 779       return 0;
 780 
 781    {
 782       size_t pos = 0;
 783       char number_buf[5]; /* enough for a four-digit year */
 784 
 785 #     define APPEND_STRING(string) pos = png_safecat(out, 29, pos, (string))
 786 #     define APPEND_NUMBER(format, value)\
 787          APPEND_STRING(PNG_FORMAT_NUMBER(number_buf, format, (value)))
</pre>
<hr />
<pre>
 825          png_warning(png_ptr, &quot;Ignoring invalid time value&quot;);
 826 
 827       else
 828          return png_ptr-&gt;time_buffer;
 829    }
 830 
 831    return NULL;
 832 }
 833 #    endif /* LIBPNG_VER &lt; 10700 */
 834 #  endif /* TIME_RFC1123 */
 835 
 836 #endif /* READ || WRITE */
 837 
 838 png_const_charp PNGAPI
 839 png_get_copyright(png_const_structrp png_ptr)
 840 {
 841    PNG_UNUSED(png_ptr)  /* Silence compiler warning about unused png_ptr */
 842 #ifdef PNG_STRING_COPYRIGHT
 843    return PNG_STRING_COPYRIGHT
 844 #else

 845    return PNG_STRING_NEWLINE \
<span class="line-modified"> 846       &quot;libpng version 1.6.37&quot; PNG_STRING_NEWLINE \</span>
<span class="line-added"> 847       &quot;Copyright (c) 2018-2019 Cosmin Truta&quot; PNG_STRING_NEWLINE \</span>
 848       &quot;Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson&quot; \
 849       PNG_STRING_NEWLINE \
 850       &quot;Copyright (c) 1996-1997 Andreas Dilger&quot; PNG_STRING_NEWLINE \
 851       &quot;Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.&quot; \
 852       PNG_STRING_NEWLINE;






 853 #endif
 854 }
 855 
 856 /* The following return the library version as a short string in the
 857  * format 1.0.0 through 99.99.99zz.  To get the version of *.h files
 858  * used with your application, print out PNG_LIBPNG_VER_STRING, which
 859  * is defined in png.h.
 860  * Note: now there is no difference between png_get_libpng_ver() and
 861  * png_get_header_ver().  Due to the version_nn_nn_nn typedef guard,
 862  * it is guaranteed that png.c uses the correct version of png.h.
 863  */
 864 png_const_charp PNGAPI
 865 png_get_libpng_ver(png_const_structrp png_ptr)
 866 {
 867    /* Version of *.c files used when building libpng */
 868    return png_get_header_ver(png_ptr);
 869 }
 870 
 871 png_const_charp PNGAPI
 872 png_get_header_ver(png_const_structrp png_ptr)
</pre>
<hr />
<pre>
1126          /* Do not overwrite an sRGB value */
1127          return from == 2;
1128       }
1129 
1130       else /* sRGB tag not involved */
1131       {
1132          png_chunk_report(png_ptr, &quot;gamma value does not match libpng estimate&quot;,
1133              PNG_CHUNK_WARNING);
1134          return from == 1;
1135       }
1136    }
1137 
1138    return 1;
1139 }
1140 
1141 void /* PRIVATE */
1142 png_colorspace_set_gamma(png_const_structrp png_ptr,
1143     png_colorspacerp colorspace, png_fixed_point gAMA)
1144 {
1145    /* Changed in libpng-1.5.4 to limit the values to ensure overflow can&#39;t
<span class="line-modified">1146     * occur.  Since the fixed point representation is asymmetrical it is</span>
1147     * possible for 1/gamma to overflow the limit of 21474 and this means the
1148     * gamma value must be at least 5/100000 and hence at most 20000.0.  For
1149     * safety the limits here are a little narrower.  The values are 0.00016 to
1150     * 6250.0, which are truly ridiculous gamma values (and will produce
1151     * displays that are all black or all white.)
1152     *
1153     * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk
1154     * handling code, which only required the value to be &gt;0.
1155     */
1156    png_const_charp errmsg;
1157 
1158    if (gAMA &lt; 16 || gAMA &gt; 625000000)
1159       errmsg = &quot;gamma value out of range&quot;;
1160 
1161 #  ifdef PNG_READ_gAMA_SUPPORTED
1162    /* Allow the application to set the gamma value more than once */
1163    else if ((png_ptr-&gt;mode &amp; PNG_IS_READ_STRUCT) != 0 &amp;&amp;
1164       (colorspace-&gt;flags &amp; PNG_COLORSPACE_FROM_gAMA) != 0)
1165       errmsg = &quot;duplicate&quot;;
1166 #  endif
</pre>
<hr />
<pre>
3139                      *ascii++ = 48; --czero;
3140                   }
3141 
3142                   if (exp_b10 != (-1))
3143                   {
3144                      if (exp_b10 == 0)
3145                      {
3146                         *ascii++ = 46; --size; /* counted above */
3147                      }
3148 
3149                      --exp_b10;
3150                   }
3151                   *ascii++ = (char)(48 + (int)d); ++cdigits;
3152                }
3153             }
3154             while (cdigits+czero &lt; precision+clead &amp;&amp; fp &gt; DBL_MIN);
3155 
3156             /* The total output count (max) is now 4+precision */
3157 
3158             /* Check for an exponent, if we don&#39;t need one we are
<span class="line-modified">3159              * done and just need to terminate the string.  At this</span>
<span class="line-modified">3160              * point, exp_b10==(-1) is effectively a flag: it got</span>
<span class="line-modified">3161              * to &#39;-1&#39; because of the decrement, after outputting</span>
<span class="line-modified">3162              * the decimal point above. (The exponent required is</span>
<span class="line-modified">3163              * *not* -1.)</span>
3164              */
3165             if (exp_b10 &gt;= (-1) &amp;&amp; exp_b10 &lt;= 2)
3166             {
3167                /* The following only happens if we didn&#39;t output the
3168                 * leading zeros above for negative exponent, so this
3169                 * doesn&#39;t add to the digit requirement.  Note that the
3170                 * two zeros here can only be output if the two leading
3171                 * zeros were *not* output, so this doesn&#39;t increase
3172                 * the output count.
3173                 */
3174                while (exp_b10-- &gt; 0) *ascii++ = 48;
3175 
3176                *ascii = 0;
3177 
3178                /* Total buffer requirement (including the &#39;\0&#39;) is
3179                 * 5+precision - see check at the start.
3180                 */
3181                return;
3182             }
3183 
</pre>
<hr />
<pre>
3981 #ifdef PNG_16BIT_SUPPORTED
3982    else
3983       return png_gamma_16bit_correct(value, gamma_val);
3984 #else
3985       /* should not reach this */
3986       return 0;
3987 #endif /* 16BIT */
3988 }
3989 
3990 #ifdef PNG_16BIT_SUPPORTED
3991 /* Internal function to build a single 16-bit table - the table consists of
3992  * &#39;num&#39; 256 entry subtables, where &#39;num&#39; is determined by &#39;shift&#39; - the amount
3993  * to shift the input values right (or 16-number_of_signifiant_bits).
3994  *
3995  * The caller is responsible for ensuring that the table gets cleaned up on
3996  * png_error (i.e. if one of the mallocs below fails) - i.e. the *table argument
3997  * should be somewhere that will be cleaned.
3998  */
3999 static void
4000 png_build_16bit_table(png_structrp png_ptr, png_uint_16pp *ptable,
<span class="line-modified">4001     unsigned int shift, png_fixed_point gamma_val)</span>
4002 {
4003    /* Various values derived from &#39;shift&#39;: */
<span class="line-modified">4004    unsigned int num = 1U &lt;&lt; (8U - shift);</span>
4005 #ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED
4006    /* CSE the division and work round wacky GCC warnings (see the comments
4007     * in png_gamma_8bit_correct for where these come from.)
4008     */
<span class="line-modified">4009    double fmax = 1.0 / (((png_int_32)1 &lt;&lt; (16U - shift)) - 1);</span>
4010 #endif
<span class="line-modified">4011    unsigned int max = (1U &lt;&lt; (16U - shift)) - 1U;</span>
<span class="line-modified">4012    unsigned int max_by_2 = 1U &lt;&lt; (15U - shift);</span>
4013    unsigned int i;
4014 
4015    png_uint_16pp table = *ptable =
4016        (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));
4017 
4018    for (i = 0; i &lt; num; i++)
4019    {
4020       png_uint_16p sub_table = table[i] =
4021           (png_uint_16p)png_malloc(png_ptr, 256 * (sizeof (png_uint_16)));
4022 
4023       /* The &#39;threshold&#39; test is repeated here because it can arise for one of
4024        * the 16-bit tables even if the others don&#39;t hit it.
4025        */
4026       if (png_gamma_significant(gamma_val) != 0)
4027       {
4028          /* The old code would overflow at the end and this would cause the
4029           * &#39;pow&#39; function to return a result &gt;1, resulting in an
4030           * arithmetic error.  This code follows the spec exactly; ig is
4031           * the recovered input sample, it always has 8-16 bits.
4032           *
</pre>
<hr />
<pre>
4058          unsigned int j;
4059 
4060          for (j = 0; j &lt; 256; j++)
4061          {
4062             png_uint_32 ig = (j &lt;&lt; (8-shift)) + i;
4063 
4064             if (shift != 0)
4065                ig = (ig * 65535U + max_by_2)/max;
4066 
4067             sub_table[j] = (png_uint_16)ig;
4068          }
4069       }
4070    }
4071 }
4072 
4073 /* NOTE: this function expects the *inverse* of the overall gamma transformation
4074  * required.
4075  */
4076 static void
4077 png_build_16to8_table(png_structrp png_ptr, png_uint_16pp *ptable,
<span class="line-modified">4078     unsigned int shift, png_fixed_point gamma_val)</span>
4079 {
<span class="line-modified">4080    unsigned int num = 1U &lt;&lt; (8U - shift);</span>
<span class="line-modified">4081    unsigned int max = (1U &lt;&lt; (16U - shift))-1U;</span>
4082    unsigned int i;
4083    png_uint_32 last;
4084 
4085    png_uint_16pp table = *ptable =
4086        (png_uint_16pp)png_calloc(png_ptr, num * (sizeof (png_uint_16p)));
4087 
4088    /* &#39;num&#39; is the number of tables and also the number of low bits of low
4089     * bits of the input 16-bit value used to select a table.  Each table is
4090     * itself indexed by the high 8 bits of the value.
4091     */
4092    for (i = 0; i &lt; num; i++)
4093       table[i] = (png_uint_16p)png_malloc(png_ptr,
4094           256 * (sizeof (png_uint_16)));
4095 
4096    /* &#39;gamma_val&#39; is set to the reciprocal of the value calculated above, so
4097     * pow(out,g) is an *input* value.  &#39;last&#39; is the last input value set.
4098     *
4099     * In the loop &#39;i&#39; is used to find output values.  Since the output is
4100     * 8-bit there are only 256 possible values.  The tables are set up to
4101     * select the closest possible output value for each input by finding
</pre>
<hr />
<pre>
4126          table[last &amp; (0xffU &gt;&gt; shift)][last &gt;&gt; (8U - shift)] = out;
4127          last++;
4128       }
4129    }
4130 
4131    /* And fill in the final entries. */
4132    while (last &lt; (num &lt;&lt; 8))
4133    {
4134       table[last &amp; (0xff &gt;&gt; shift)][last &gt;&gt; (8U - shift)] = 65535U;
4135       last++;
4136    }
4137 }
4138 #endif /* 16BIT */
4139 
4140 /* Build a single 8-bit table: same as the 16-bit case but much simpler (and
4141  * typically much faster).  Note that libpng currently does no sBIT processing
4142  * (apparently contrary to the spec) so a 256-entry table is always generated.
4143  */
4144 static void
4145 png_build_8bit_table(png_structrp png_ptr, png_bytepp ptable,
<span class="line-modified">4146     png_fixed_point gamma_val)</span>
4147 {
4148    unsigned int i;
4149    png_bytep table = *ptable = (png_bytep)png_malloc(png_ptr, 256);
4150 
4151    if (png_gamma_significant(gamma_val) != 0)
4152       for (i=0; i&lt;256; i++)
4153          table[i] = png_gamma_8bit_correct(i, gamma_val);
4154 
4155    else
4156       for (i=0; i&lt;256; ++i)
4157          table[i] = (png_byte)(i &amp; 0xff);
4158 }
4159 
4160 /* Used from png_read_destroy and below to release the memory used by the gamma
4161  * tables.
4162  */
4163 void /* PRIVATE */
4164 png_destroy_gamma_table(png_structrp png_ptr)
4165 {
4166    png_free(png_ptr, png_ptr-&gt;gamma_table);
</pre>
<hr />
<pre>
4599          png_destroy_read_struct(&amp;c.png_ptr, &amp;c.info_ptr, NULL);
4600 #     else
4601          png_error(c.png_ptr, &quot;simplified read not supported&quot;);
4602 #     endif
4603    }
4604 
4605    /* Success. */
4606    return 1;
4607 }
4608 
4609 void PNGAPI
4610 png_image_free(png_imagep image)
4611 {
4612    /* Safely call the real function, but only if doing so is safe at this point
4613     * (if not inside an error handling context).  Otherwise assume
4614     * png_safe_execute will call this API after the return.
4615     */
4616    if (image != NULL &amp;&amp; image-&gt;opaque != NULL &amp;&amp;
4617       image-&gt;opaque-&gt;error_buf == NULL)
4618    {
<span class="line-modified">4619       png_image_free_function(image);</span>

4620       image-&gt;opaque = NULL;
4621    }
4622 }
4623 
4624 int /* PRIVATE */
4625 png_image_error(png_imagep image, png_const_charp error_message)
4626 {
4627    /* Utility to log an error. */
4628    png_safecat(image-&gt;message, (sizeof image-&gt;message), 0, error_message);
4629    image-&gt;warning_or_error |= PNG_IMAGE_ERROR;
4630    png_image_free(image);
4631    return 0;
4632 }
4633 
4634 #endif /* SIMPLIFIED READ/WRITE */
4635 #endif /* READ || WRITE */
</pre>
</td>
</tr>
</table>
<center><a href="README.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="png.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
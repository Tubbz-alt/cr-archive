<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/splashscreen_impl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="libpng/pngtrans.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="splashscreen_impl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/splashscreen_impl.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 #ifdef _MSC_VER
 30 # ifndef snprintf
 31 #       define snprintf _snprintf
 32 # endif
 33 #endif
 34 int splashIsVisible = 0;
 35 
 36 Splash *
 37 SplashGetInstance()
 38 {
 39     static Splash splash;
 40     static int preInitialized = 0;
 41     if (!preInitialized) {
 42         memset(&amp;splash, 0, sizeof(Splash));
 43         splash.currentFrame = -1;
 44         preInitialized = 1;
 45     }
 46     return &amp;splash;
 47 }
 48 
<span class="line-modified"> 49 JNIEXPORT void JNICALL</span>
 50 SplashSetFileJarName(const char* fileName, const char* jarName) {
 51     Splash *splash = SplashGetInstance();
 52 
 53     free(splash-&gt;fileName);
 54     splash-&gt;fileName = SplashConvertStringAlloc(fileName, &amp;splash-&gt;fileNameLen);
 55 
 56     free(splash-&gt;jarName);
 57     splash-&gt;jarName = SplashConvertStringAlloc(jarName, &amp;splash-&gt;jarNameLen);
 58 }
 59 
<span class="line-modified"> 60 JNIEXPORT void JNICALL</span>
 61 SplashInit()
 62 {
 63     Splash *splash = SplashGetInstance();
 64 
 65     memset(splash, 0, sizeof(Splash));
 66     splash-&gt;currentFrame = -1;
 67     splash-&gt;scaleFactor = 1;
 68     initFormat(&amp;splash-&gt;imageFormat, QUAD_RED_MASK, QUAD_GREEN_MASK,
 69         QUAD_BLUE_MASK, QUAD_ALPHA_MASK);
<span class="line-modified"> 70     SplashInitPlatform(splash);</span>
 71 }
 72 
<span class="line-modified"> 73 JNIEXPORT void JNICALL</span>
 74 SplashClose()
 75 {
 76     Splash *splash = SplashGetInstance();
 77 
 78     if (splash-&gt;isVisible &gt; 0) {
 79         SplashLock(splash);
 80         splash-&gt;isVisible = -1;
 81         SplashClosePlatform(splash);
 82         SplashUnlock(splash);
 83     }
 84 }
 85 
 86 void
 87 SplashCleanup(Splash * splash)
 88 {
 89     int i;
 90 
 91     splash-&gt;currentFrame = -1;
 92     SplashCleanupPlatform(splash);
 93     if (splash-&gt;frames) {
 94         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
 95             if (splash-&gt;frames[i].bitmapBits) {
 96                 free(splash-&gt;frames[i].bitmapBits);
 97                 splash-&gt;frames[i].bitmapBits = NULL;
 98             }
 99         }
100         free(splash-&gt;frames);
101         splash-&gt;frames = NULL;
102     }
103     if (splash-&gt;overlayData) {
104         free(splash-&gt;overlayData);
105         splash-&gt;overlayData = NULL;
106     }
107     SplashSetFileJarName(NULL, NULL);
108 }
109 
<span class="line-modified">110 JNIEXPORT void JNICALL</span>
111 SplashSetScaleFactor(float scaleFactor)
112 {
113     Splash *splash = SplashGetInstance();
114     splash-&gt;scaleFactor = scaleFactor;
115 }
116 
117 void
118 SplashDone(Splash * splash)
119 {
120     SplashCleanup(splash);
121     SplashDonePlatform(splash);
122 }
123 
124 int
125 SplashIsStillLooping(Splash * splash)
126 {
127     if (splash-&gt;currentFrame &lt; 0) {
128         return 0;
129     }
130     return splash-&gt;loopCount != 1 ||
</pre>
<hr />
<pre>
246 {
247     int sign;
248     int (*decodeStream) (Splash * splash, SplashStream * stream);
249 } FILEFORMAT;
250 
251 static const FILEFORMAT formats[] = {
252     {0x47, SplashDecodeGifStream},
253     {0x89, SplashDecodePngStream},
254     {0xFF, SplashDecodeJpegStream}
255 };
256 
257 static int
258 SplashLoadStream(SplashStream * stream)
259 {
260     int success = 0;
261     int c;
262     size_t i;
263 
264     Splash *splash = SplashGetInstance();
265     if (splash-&gt;isVisible &lt; 0) {

266         return 0;
267     }
268 
269     SplashLock(splash);
270 
271     /* the formats we support can be easily distinguished by the first byte */
272     c = stream-&gt;peek(stream);
273     if (c != -1) {
274         for (i = 0; i &lt; sizeof(formats) / sizeof(FILEFORMAT); i++) {
275             if (c == formats[i].sign) {
276                 success = formats[i].decodeStream(splash, stream);
277                 break;
278             }
279         }
280     }
281     stream-&gt;close(stream);
282 
283     if (!success) {             // failed to decode
284         if (splash-&gt;isVisible == 0) {
285             SplashCleanup(splash);
286         }
287         SplashUnlock(splash);   // SplashClose locks
288         if (splash-&gt;isVisible == 0) {
289             SplashClose();
290         }
291     }
292     else {
293         splash-&gt;currentFrame = 0;
294         if (splash-&gt;isVisible == 0) {
295             SplashStart(splash);
296         } else {
297             SplashReconfigure(splash);
298             splash-&gt;time = SplashTime();
299         }
300         SplashUnlock(splash);
301     }
302     return success;
303 }
304 
<span class="line-modified">305 JNIEXPORT int JNICALL</span>
306 SplashLoadFile(const char *filename)
307 {
308     SplashStream stream;
309     return SplashStreamInitFile(&amp;stream, filename) &amp;&amp;
310                 SplashLoadStream(&amp;stream);
311 }
312 
<span class="line-modified">313 JNIEXPORT int JNICALL</span>
314 SplashLoadMemory(void *data, int size)
315 {
316     SplashStream stream;
317     return SplashStreamInitMemory(&amp;stream, data, size) &amp;&amp;
318                 SplashLoadStream(&amp;stream);
319 }
320 
321 /* SplashStart MUST be called from under the lock */
322 
323 void
324 SplashStart(Splash * splash)
325 {
326     if (splash-&gt;isVisible == 0) {
327         SplashCreateThread(splash);
328         splash-&gt;isVisible = 1;
329     }
330 }
331 
332 /* SplashStream functions */
333 
</pre>
<hr />
<pre>
378 static void closeMem(void* pStream) {
379 }
380 
381 int SplashStreamInitFile(SplashStream * pStream, const char* filename) {
382     pStream-&gt;arg.stdio.f = fopen(filename, &quot;rb&quot;);
383     pStream-&gt;read = readFile;
384     pStream-&gt;peek = peekFile;
385     pStream-&gt;close = closeFile;
386     return pStream-&gt;arg.stdio.f != 0;
387 }
388 
389 int SplashStreamInitMemory(SplashStream * pStream, void* pData, int size) {
390     pStream-&gt;arg.mem.pData = (unsigned char*)pData;
391     pStream-&gt;arg.mem.pDataEnd = (unsigned char*)pData + size;
392     pStream-&gt;read = readMem;
393     pStream-&gt;peek = peekMem;
394     pStream-&gt;close = closeMem;
395     return 1;
396 }
397 
<span class="line-modified">398 JNIEXPORT int JNICALL</span>
399 SplashGetScaledImgNameMaxPstfixLen(const char *fileName){
400     return strlen(fileName) + strlen(&quot;@100pct&quot;) + 1;
401 }
402 
403 jboolean GetScaledImageName(const char *fileName, char *scaleImageName,
404         float *scaleFactor, const size_t scaledImageLength) {
405     if (*scaleFactor &gt; 1.0) {
406         FILE *fp = NULL;
407         char scaledImgPct[BUFF_SIZE];
408         char scaledImgX[BUFF_SIZE];
409         char *scaledImageXName = NULL;
410         char *scaledImagePctName = malloc(scaledImageLength);
411         char *dupFileName = strdup(fileName);
412         char *fileExtension = strrchr(dupFileName, &#39;.&#39;);
413         size_t lengthPct = 0;
414         size_t lengthX = 0;
415         int retValPct = 0;
416         int retValX = 0;
417         jboolean isPctScaledImage = (*scaleFactor * 100) != ((int) (*scaleFactor)) *100;
418         snprintf(scaledImgPct, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;,
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 29 #ifdef _MSC_VER
 30 # ifndef snprintf
 31 #       define snprintf _snprintf
 32 # endif
 33 #endif
 34 int splashIsVisible = 0;
 35 
 36 Splash *
 37 SplashGetInstance()
 38 {
 39     static Splash splash;
 40     static int preInitialized = 0;
 41     if (!preInitialized) {
 42         memset(&amp;splash, 0, sizeof(Splash));
 43         splash.currentFrame = -1;
 44         preInitialized = 1;
 45     }
 46     return &amp;splash;
 47 }
 48 
<span class="line-modified"> 49 JNIEXPORT void</span>
 50 SplashSetFileJarName(const char* fileName, const char* jarName) {
 51     Splash *splash = SplashGetInstance();
 52 
 53     free(splash-&gt;fileName);
 54     splash-&gt;fileName = SplashConvertStringAlloc(fileName, &amp;splash-&gt;fileNameLen);
 55 
 56     free(splash-&gt;jarName);
 57     splash-&gt;jarName = SplashConvertStringAlloc(jarName, &amp;splash-&gt;jarNameLen);
 58 }
 59 
<span class="line-modified"> 60 JNIEXPORT int</span>
 61 SplashInit()
 62 {
 63     Splash *splash = SplashGetInstance();
 64 
 65     memset(splash, 0, sizeof(Splash));
 66     splash-&gt;currentFrame = -1;
 67     splash-&gt;scaleFactor = 1;
 68     initFormat(&amp;splash-&gt;imageFormat, QUAD_RED_MASK, QUAD_GREEN_MASK,
 69         QUAD_BLUE_MASK, QUAD_ALPHA_MASK);
<span class="line-modified"> 70     return SplashInitPlatform(splash);</span>
 71 }
 72 
<span class="line-modified"> 73 JNIEXPORT void</span>
 74 SplashClose()
 75 {
 76     Splash *splash = SplashGetInstance();
 77 
 78     if (splash-&gt;isVisible &gt; 0) {
 79         SplashLock(splash);
 80         splash-&gt;isVisible = -1;
 81         SplashClosePlatform(splash);
 82         SplashUnlock(splash);
 83     }
 84 }
 85 
 86 void
 87 SplashCleanup(Splash * splash)
 88 {
 89     int i;
 90 
 91     splash-&gt;currentFrame = -1;
 92     SplashCleanupPlatform(splash);
 93     if (splash-&gt;frames) {
 94         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
 95             if (splash-&gt;frames[i].bitmapBits) {
 96                 free(splash-&gt;frames[i].bitmapBits);
 97                 splash-&gt;frames[i].bitmapBits = NULL;
 98             }
 99         }
100         free(splash-&gt;frames);
101         splash-&gt;frames = NULL;
102     }
103     if (splash-&gt;overlayData) {
104         free(splash-&gt;overlayData);
105         splash-&gt;overlayData = NULL;
106     }
107     SplashSetFileJarName(NULL, NULL);
108 }
109 
<span class="line-modified">110 JNIEXPORT void</span>
111 SplashSetScaleFactor(float scaleFactor)
112 {
113     Splash *splash = SplashGetInstance();
114     splash-&gt;scaleFactor = scaleFactor;
115 }
116 
117 void
118 SplashDone(Splash * splash)
119 {
120     SplashCleanup(splash);
121     SplashDonePlatform(splash);
122 }
123 
124 int
125 SplashIsStillLooping(Splash * splash)
126 {
127     if (splash-&gt;currentFrame &lt; 0) {
128         return 0;
129     }
130     return splash-&gt;loopCount != 1 ||
</pre>
<hr />
<pre>
246 {
247     int sign;
248     int (*decodeStream) (Splash * splash, SplashStream * stream);
249 } FILEFORMAT;
250 
251 static const FILEFORMAT formats[] = {
252     {0x47, SplashDecodeGifStream},
253     {0x89, SplashDecodePngStream},
254     {0xFF, SplashDecodeJpegStream}
255 };
256 
257 static int
258 SplashLoadStream(SplashStream * stream)
259 {
260     int success = 0;
261     int c;
262     size_t i;
263 
264     Splash *splash = SplashGetInstance();
265     if (splash-&gt;isVisible &lt; 0) {
<span class="line-added">266         stream-&gt;close(stream);</span>
267         return 0;
268     }
269 
270     SplashLock(splash);
271 
272     /* the formats we support can be easily distinguished by the first byte */
273     c = stream-&gt;peek(stream);
274     if (c != -1) {
275         for (i = 0; i &lt; sizeof(formats) / sizeof(FILEFORMAT); i++) {
276             if (c == formats[i].sign) {
277                 success = formats[i].decodeStream(splash, stream);
278                 break;
279             }
280         }
281     }
282     stream-&gt;close(stream);
283 
284     if (!success) {             // failed to decode
285         if (splash-&gt;isVisible == 0) {
286             SplashCleanup(splash);
287         }
288         SplashUnlock(splash);   // SplashClose locks
289         if (splash-&gt;isVisible == 0) {
290             SplashClose();
291         }
292     }
293     else {
294         splash-&gt;currentFrame = 0;
295         if (splash-&gt;isVisible == 0) {
296             SplashStart(splash);
297         } else {
298             SplashReconfigure(splash);
299             splash-&gt;time = SplashTime();
300         }
301         SplashUnlock(splash);
302     }
303     return success;
304 }
305 
<span class="line-modified">306 JNIEXPORT int</span>
307 SplashLoadFile(const char *filename)
308 {
309     SplashStream stream;
310     return SplashStreamInitFile(&amp;stream, filename) &amp;&amp;
311                 SplashLoadStream(&amp;stream);
312 }
313 
<span class="line-modified">314 JNIEXPORT int</span>
315 SplashLoadMemory(void *data, int size)
316 {
317     SplashStream stream;
318     return SplashStreamInitMemory(&amp;stream, data, size) &amp;&amp;
319                 SplashLoadStream(&amp;stream);
320 }
321 
322 /* SplashStart MUST be called from under the lock */
323 
324 void
325 SplashStart(Splash * splash)
326 {
327     if (splash-&gt;isVisible == 0) {
328         SplashCreateThread(splash);
329         splash-&gt;isVisible = 1;
330     }
331 }
332 
333 /* SplashStream functions */
334 
</pre>
<hr />
<pre>
379 static void closeMem(void* pStream) {
380 }
381 
382 int SplashStreamInitFile(SplashStream * pStream, const char* filename) {
383     pStream-&gt;arg.stdio.f = fopen(filename, &quot;rb&quot;);
384     pStream-&gt;read = readFile;
385     pStream-&gt;peek = peekFile;
386     pStream-&gt;close = closeFile;
387     return pStream-&gt;arg.stdio.f != 0;
388 }
389 
390 int SplashStreamInitMemory(SplashStream * pStream, void* pData, int size) {
391     pStream-&gt;arg.mem.pData = (unsigned char*)pData;
392     pStream-&gt;arg.mem.pDataEnd = (unsigned char*)pData + size;
393     pStream-&gt;read = readMem;
394     pStream-&gt;peek = peekMem;
395     pStream-&gt;close = closeMem;
396     return 1;
397 }
398 
<span class="line-modified">399 JNIEXPORT int</span>
400 SplashGetScaledImgNameMaxPstfixLen(const char *fileName){
401     return strlen(fileName) + strlen(&quot;@100pct&quot;) + 1;
402 }
403 
404 jboolean GetScaledImageName(const char *fileName, char *scaleImageName,
405         float *scaleFactor, const size_t scaledImageLength) {
406     if (*scaleFactor &gt; 1.0) {
407         FILE *fp = NULL;
408         char scaledImgPct[BUFF_SIZE];
409         char scaledImgX[BUFF_SIZE];
410         char *scaledImageXName = NULL;
411         char *scaledImagePctName = malloc(scaledImageLength);
412         char *dupFileName = strdup(fileName);
413         char *fileExtension = strrchr(dupFileName, &#39;.&#39;);
414         size_t lengthPct = 0;
415         size_t lengthX = 0;
416         int retValPct = 0;
417         int retValX = 0;
418         jboolean isPctScaledImage = (*scaleFactor * 100) != ((int) (*scaleFactor)) *100;
419         snprintf(scaledImgPct, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;,
</pre>
</td>
</tr>
</table>
<center><a href="libpng/pngtrans.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="splashscreen_impl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
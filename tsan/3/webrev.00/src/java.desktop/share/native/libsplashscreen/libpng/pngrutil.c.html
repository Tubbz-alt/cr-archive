<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libsplashscreen/libpng/pngrutil.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   3  *
   4  * This code is free software; you can redistribute it and/or modify it
   5  * under the terms of the GNU General Public License version 2 only, as
   6  * published by the Free Software Foundation.  Oracle designates this
   7  * particular file as subject to the &quot;Classpath&quot; exception as provided
   8  * by Oracle in the LICENSE file that accompanied this code.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* pngrutil.c - utilities to read a PNG file
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
  32  * Copyright (c) 2018 Cosmin Truta
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
  34  * Copyright (c) 1996-1997 Andreas Dilger
  35  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  *
  41  * This file contains routines that are only called from within
  42  * libpng itself during the course of reading an image.
  43  */
  44 
  45 #include &quot;pngpriv.h&quot;
  46 
  47 #ifdef PNG_READ_SUPPORTED
  48 
  49 png_uint_32 PNGAPI
  50 png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
  51 {
  52    png_uint_32 uval = png_get_uint_32(buf);
  53 
  54    if (uval &gt; PNG_UINT_31_MAX)
  55       png_error(png_ptr, &quot;PNG unsigned integer out of range&quot;);
  56 
  57    return (uval);
  58 }
  59 
  60 #if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)
  61 /* The following is a variation on the above for use with the fixed
  62  * point values used for gAMA and cHRM.  Instead of png_error it
  63  * issues a warning and returns (-1) - an invalid value because both
  64  * gAMA and cHRM use *unsigned* integers for fixed point values.
  65  */
  66 #define PNG_FIXED_ERROR (-1)
  67 
  68 static png_fixed_point /* PRIVATE */
  69 png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)
  70 {
  71    png_uint_32 uval = png_get_uint_32(buf);
  72 
  73    if (uval &lt;= PNG_UINT_31_MAX)
  74       return (png_fixed_point)uval; /* known to be in range */
  75 
  76    /* The caller can turn off the warning by passing NULL. */
  77    if (png_ptr != NULL)
  78       png_warning(png_ptr, &quot;PNG fixed point integer out of range&quot;);
  79 
  80    return PNG_FIXED_ERROR;
  81 }
  82 #endif
  83 
  84 #ifdef PNG_READ_INT_FUNCTIONS_SUPPORTED
  85 /* NOTE: the read macros will obscure these definitions, so that if
  86  * PNG_USE_READ_MACROS is set the library will not use them internally,
  87  * but the APIs will still be available externally.
  88  *
  89  * The parentheses around &quot;PNGAPI function_name&quot; in the following three
  90  * functions are necessary because they allow the macros to co-exist with
  91  * these (unused but exported) functions.
  92  */
  93 
  94 /* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
  95 png_uint_32 (PNGAPI
  96 png_get_uint_32)(png_const_bytep buf)
  97 {
  98    png_uint_32 uval =
  99        ((png_uint_32)(*(buf    )) &lt;&lt; 24) +
 100        ((png_uint_32)(*(buf + 1)) &lt;&lt; 16) +
 101        ((png_uint_32)(*(buf + 2)) &lt;&lt;  8) +
 102        ((png_uint_32)(*(buf + 3))      ) ;
 103 
 104    return uval;
 105 }
 106 
 107 /* Grab a signed 32-bit integer from a buffer in big-endian format.  The
 108  * data is stored in the PNG file in two&#39;s complement format and there
 109  * is no guarantee that a &#39;png_int_32&#39; is exactly 32 bits, therefore
 110  * the following code does a two&#39;s complement to native conversion.
 111  */
 112 png_int_32 (PNGAPI
 113 png_get_int_32)(png_const_bytep buf)
 114 {
 115    png_uint_32 uval = png_get_uint_32(buf);
 116    if ((uval &amp; 0x80000000) == 0) /* non-negative */
 117       return (png_int_32)uval;
 118 
 119    uval = (uval ^ 0xffffffff) + 1;  /* 2&#39;s complement: -x = ~x+1 */
 120    if ((uval &amp; 0x80000000) == 0) /* no overflow */
 121       return -(png_int_32)uval;
 122    /* The following has to be safe; this function only gets called on PNG data
 123     * and if we get here that data is invalid.  0 is the most safe value and
 124     * if not then an attacker would surely just generate a PNG with 0 instead.
 125     */
 126    return 0;
 127 }
 128 
 129 /* Grab an unsigned 16-bit integer from a buffer in big-endian format. */
 130 png_uint_16 (PNGAPI
 131 png_get_uint_16)(png_const_bytep buf)
 132 {
 133    /* ANSI-C requires an int value to accommodate at least 16 bits so this
 134     * works and allows the compiler not to worry about possible narrowing
 135     * on 32-bit systems.  (Pre-ANSI systems did not make integers smaller
 136     * than 16 bits either.)
 137     */
 138    unsigned int val =
 139        ((unsigned int)(*buf) &lt;&lt; 8) +
 140        ((unsigned int)(*(buf + 1)));
 141 
 142    return (png_uint_16)val;
 143 }
 144 
 145 #endif /* READ_INT_FUNCTIONS */
 146 
 147 /* Read and check the PNG file signature */
 148 void /* PRIVATE */
 149 png_read_sig(png_structrp png_ptr, png_inforp info_ptr)
 150 {
 151    size_t num_checked, num_to_check;
 152 
 153    /* Exit if the user application does not expect a signature. */
 154    if (png_ptr-&gt;sig_bytes &gt;= 8)
 155       return;
 156 
 157    num_checked = png_ptr-&gt;sig_bytes;
 158    num_to_check = 8 - num_checked;
 159 
 160 #ifdef PNG_IO_STATE_SUPPORTED
 161    png_ptr-&gt;io_state = PNG_IO_READING | PNG_IO_SIGNATURE;
 162 #endif
 163 
 164    /* The signature must be serialized in a single I/O call. */
 165    png_read_data(png_ptr, &amp;(info_ptr-&gt;signature[num_checked]), num_to_check);
 166    png_ptr-&gt;sig_bytes = 8;
 167 
 168    if (png_sig_cmp(info_ptr-&gt;signature, num_checked, num_to_check) != 0)
 169    {
 170       if (num_checked &lt; 4 &amp;&amp;
 171           png_sig_cmp(info_ptr-&gt;signature, num_checked, num_to_check - 4))
 172          png_error(png_ptr, &quot;Not a PNG file&quot;);
 173       else
 174          png_error(png_ptr, &quot;PNG file corrupted by ASCII conversion&quot;);
 175    }
 176    if (num_checked &lt; 3)
 177       png_ptr-&gt;mode |= PNG_HAVE_PNG_SIGNATURE;
 178 }
 179 
 180 /* Read the chunk header (length + type name).
 181  * Put the type name into png_ptr-&gt;chunk_name, and return the length.
 182  */
 183 png_uint_32 /* PRIVATE */
 184 png_read_chunk_header(png_structrp png_ptr)
 185 {
 186    png_byte buf[8];
 187    png_uint_32 length;
 188 
 189 #ifdef PNG_IO_STATE_SUPPORTED
 190    png_ptr-&gt;io_state = PNG_IO_READING | PNG_IO_CHUNK_HDR;
 191 #endif
 192 
 193    /* Read the length and the chunk name.
 194     * This must be performed in a single I/O call.
 195     */
 196    png_read_data(png_ptr, buf, 8);
 197    length = png_get_uint_31(png_ptr, buf);
 198 
 199    /* Put the chunk name into png_ptr-&gt;chunk_name. */
 200    png_ptr-&gt;chunk_name = PNG_CHUNK_FROM_STRING(buf+4);
 201 
 202    png_debug2(0, &quot;Reading %lx chunk, length = %lu&quot;,
 203        (unsigned long)png_ptr-&gt;chunk_name, (unsigned long)length);
 204 
 205    /* Reset the crc and run it over the chunk name. */
 206    png_reset_crc(png_ptr);
 207    png_calculate_crc(png_ptr, buf + 4, 4);
 208 
 209    /* Check to see if chunk name is valid. */
 210    png_check_chunk_name(png_ptr, png_ptr-&gt;chunk_name);
 211 
 212    /* Check for too-large chunk length */
 213    png_check_chunk_length(png_ptr, length);
 214 
 215 #ifdef PNG_IO_STATE_SUPPORTED
 216    png_ptr-&gt;io_state = PNG_IO_READING | PNG_IO_CHUNK_DATA;
 217 #endif
 218 
 219    return length;
 220 }
 221 
 222 /* Read data, and (optionally) run it through the CRC. */
 223 void /* PRIVATE */
 224 png_crc_read(png_structrp png_ptr, png_bytep buf, png_uint_32 length)
 225 {
 226    if (png_ptr == NULL)
 227       return;
 228 
 229    png_read_data(png_ptr, buf, length);
 230    png_calculate_crc(png_ptr, buf, length);
 231 }
 232 
 233 /* Optionally skip data and then check the CRC.  Depending on whether we
 234  * are reading an ancillary or critical chunk, and how the program has set
 235  * things up, we may calculate the CRC on the data and print a message.
 236  * Returns &#39;1&#39; if there was a CRC error, &#39;0&#39; otherwise.
 237  */
 238 int /* PRIVATE */
 239 png_crc_finish(png_structrp png_ptr, png_uint_32 skip)
 240 {
 241    /* The size of the local buffer for inflate is a good guess as to a
 242     * reasonable size to use for buffering reads from the application.
 243     */
 244    while (skip &gt; 0)
 245    {
 246       png_uint_32 len;
 247       png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
 248 
 249       len = (sizeof tmpbuf);
 250       if (len &gt; skip)
 251          len = skip;
 252       skip -= len;
 253 
 254       png_crc_read(png_ptr, tmpbuf, len);
 255    }
 256 
 257    if (png_crc_error(png_ptr) != 0)
 258    {
 259       if (PNG_CHUNK_ANCILLARY(png_ptr-&gt;chunk_name) != 0 ?
 260           (png_ptr-&gt;flags &amp; PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :
 261           (png_ptr-&gt;flags &amp; PNG_FLAG_CRC_CRITICAL_USE) != 0)
 262       {
 263          png_chunk_warning(png_ptr, &quot;CRC error&quot;);
 264       }
 265 
 266       else
 267          png_chunk_error(png_ptr, &quot;CRC error&quot;);
 268 
 269       return (1);
 270    }
 271 
 272    return (0);
 273 }
 274 
 275 /* Compare the CRC stored in the PNG file with that calculated by libpng from
 276  * the data it has read thus far.
 277  */
 278 int /* PRIVATE */
 279 png_crc_error(png_structrp png_ptr)
 280 {
 281    png_byte crc_bytes[4];
 282    png_uint_32 crc;
 283    int need_crc = 1;
 284 
 285    if (PNG_CHUNK_ANCILLARY(png_ptr-&gt;chunk_name) != 0)
 286    {
 287       if ((png_ptr-&gt;flags &amp; PNG_FLAG_CRC_ANCILLARY_MASK) ==
 288           (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
 289          need_crc = 0;
 290    }
 291 
 292    else /* critical */
 293    {
 294       if ((png_ptr-&gt;flags &amp; PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
 295          need_crc = 0;
 296    }
 297 
 298 #ifdef PNG_IO_STATE_SUPPORTED
 299    png_ptr-&gt;io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
 300 #endif
 301 
 302    /* The chunk CRC must be serialized in a single I/O call. */
 303    png_read_data(png_ptr, crc_bytes, 4);
 304 
 305    if (need_crc != 0)
 306    {
 307       crc = png_get_uint_32(crc_bytes);
 308       return ((int)(crc != png_ptr-&gt;crc));
 309    }
 310 
 311    else
 312       return (0);
 313 }
 314 
 315 #if defined(PNG_READ_iCCP_SUPPORTED) || defined(PNG_READ_iTXt_SUPPORTED) ||\
 316     defined(PNG_READ_pCAL_SUPPORTED) || defined(PNG_READ_sCAL_SUPPORTED) ||\
 317     defined(PNG_READ_sPLT_SUPPORTED) || defined(PNG_READ_tEXt_SUPPORTED) ||\
 318     defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)
 319 /* Manage the read buffer; this simply reallocates the buffer if it is not small
 320  * enough (or if it is not allocated).  The routine returns a pointer to the
 321  * buffer; if an error occurs and &#39;warn&#39; is set the routine returns NULL, else
 322  * it will call png_error (via png_malloc) on failure.  (warn == 2 means
 323  * &#39;silent&#39;).
 324  */
 325 static png_bytep
 326 png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)
 327 {
 328    png_bytep buffer = png_ptr-&gt;read_buffer;
 329 
 330    if (buffer != NULL &amp;&amp; new_size &gt; png_ptr-&gt;read_buffer_size)
 331    {
 332       png_ptr-&gt;read_buffer = NULL;
 333       png_ptr-&gt;read_buffer = NULL;
 334       png_ptr-&gt;read_buffer_size = 0;
 335       png_free(png_ptr, buffer);
 336       buffer = NULL;
 337    }
 338 
 339    if (buffer == NULL)
 340    {
 341       buffer = png_voidcast(png_bytep, png_malloc_base(png_ptr, new_size));
 342 
 343       if (buffer != NULL)
 344       {
 345          memset(buffer, 0, new_size); /* just in case */
 346          png_ptr-&gt;read_buffer = buffer;
 347          png_ptr-&gt;read_buffer_size = new_size;
 348       }
 349 
 350       else if (warn &lt; 2) /* else silent */
 351       {
 352          if (warn != 0)
 353              png_chunk_warning(png_ptr, &quot;insufficient memory to read chunk&quot;);
 354 
 355          else
 356              png_chunk_error(png_ptr, &quot;insufficient memory to read chunk&quot;);
 357       }
 358    }
 359 
 360    return buffer;
 361 }
 362 #endif /* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ */
 363 
 364 /* png_inflate_claim: claim the zstream for some nefarious purpose that involves
 365  * decompression.  Returns Z_OK on success, else a zlib error code.  It checks
 366  * the owner but, in final release builds, just issues a warning if some other
 367  * chunk apparently owns the stream.  Prior to release it does a png_error.
 368  */
 369 static int
 370 png_inflate_claim(png_structrp png_ptr, png_uint_32 owner)
 371 {
 372    if (png_ptr-&gt;zowner != 0)
 373    {
 374       char msg[64];
 375 
 376       PNG_STRING_FROM_CHUNK(msg, png_ptr-&gt;zowner);
 377       /* So the message that results is &quot;&lt;chunk&gt; using zstream&quot;; this is an
 378        * internal error, but is very useful for debugging.  i18n requirements
 379        * are minimal.
 380        */
 381       (void)png_safecat(msg, (sizeof msg), 4, &quot; using zstream&quot;);
 382 #if PNG_RELEASE_BUILD
 383       png_chunk_warning(png_ptr, msg);
 384       png_ptr-&gt;zowner = 0;
 385 #else
 386       png_chunk_error(png_ptr, msg);
 387 #endif
 388    }
 389 
 390    /* Implementation note: unlike &#39;png_deflate_claim&#39; this internal function
 391     * does not take the size of the data as an argument.  Some efficiency could
 392     * be gained by using this when it is known *if* the zlib stream itself does
 393     * not record the number; however, this is an illusion: the original writer
 394     * of the PNG may have selected a lower window size, and we really must
 395     * follow that because, for systems with with limited capabilities, we
 396     * would otherwise reject the application&#39;s attempts to use a smaller window
 397     * size (zlib doesn&#39;t have an interface to say &quot;this or lower&quot;!).
 398     *
 399     * inflateReset2 was added to zlib 1.2.4; before this the window could not be
 400     * reset, therefore it is necessary to always allocate the maximum window
 401     * size with earlier zlibs just in case later compressed chunks need it.
 402     */
 403    {
 404       int ret; /* zlib return code */
 405 #if ZLIB_VERNUM &gt;= 0x1240
 406       int window_bits = 0;
 407 
 408 # if defined(PNG_SET_OPTION_SUPPORTED) &amp;&amp; defined(PNG_MAXIMUM_INFLATE_WINDOW)
 409       if (((png_ptr-&gt;options &gt;&gt; PNG_MAXIMUM_INFLATE_WINDOW) &amp; 3) ==
 410           PNG_OPTION_ON)
 411       {
 412          window_bits = 15;
 413          png_ptr-&gt;zstream_start = 0; /* fixed window size */
 414       }
 415 
 416       else
 417       {
 418          png_ptr-&gt;zstream_start = 1;
 419       }
 420 # endif
 421 
 422 #endif /* ZLIB_VERNUM &gt;= 0x1240 */
 423 
 424       /* Set this for safety, just in case the previous owner left pointers to
 425        * memory allocations.
 426        */
 427       png_ptr-&gt;zstream.next_in = NULL;
 428       png_ptr-&gt;zstream.avail_in = 0;
 429       png_ptr-&gt;zstream.next_out = NULL;
 430       png_ptr-&gt;zstream.avail_out = 0;
 431 
 432       if ((png_ptr-&gt;flags &amp; PNG_FLAG_ZSTREAM_INITIALIZED) != 0)
 433       {
 434 #if ZLIB_VERNUM &gt;= 0x1240
 435          ret = inflateReset2(&amp;png_ptr-&gt;zstream, window_bits);
 436 #else
 437          ret = inflateReset(&amp;png_ptr-&gt;zstream);
 438 #endif
 439       }
 440 
 441       else
 442       {
 443 #if ZLIB_VERNUM &gt;= 0x1240
 444          ret = inflateInit2(&amp;png_ptr-&gt;zstream, window_bits);
 445 #else
 446          ret = inflateInit(&amp;png_ptr-&gt;zstream);
 447 #endif
 448 
 449          if (ret == Z_OK)
 450             png_ptr-&gt;flags |= PNG_FLAG_ZSTREAM_INITIALIZED;
 451       }
 452 
 453 #if ZLIB_VERNUM &gt;= 0x1290 &amp;&amp; \
 454    defined(PNG_SET_OPTION_SUPPORTED) &amp;&amp; defined(PNG_IGNORE_ADLER32)
 455       if (((png_ptr-&gt;options &gt;&gt; PNG_IGNORE_ADLER32) &amp; 3) == PNG_OPTION_ON)
 456          /* Turn off validation of the ADLER32 checksum in IDAT chunks */
 457          ret = inflateValidate(&amp;png_ptr-&gt;zstream, 0);
 458 #endif
 459 
 460       if (ret == Z_OK)
 461          png_ptr-&gt;zowner = owner;
 462 
 463       else
 464          png_zstream_error(png_ptr, ret);
 465 
 466       return ret;
 467    }
 468 
 469 #ifdef window_bits
 470 # undef window_bits
 471 #endif
 472 }
 473 
 474 #if ZLIB_VERNUM &gt;= 0x1240
 475 /* Handle the start of the inflate stream if we called inflateInit2(strm,0);
 476  * in this case some zlib versions skip validation of the CINFO field and, in
 477  * certain circumstances, libpng may end up displaying an invalid image, in
 478  * contrast to implementations that call zlib in the normal way (e.g. libpng
 479  * 1.5).
 480  */
 481 int /* PRIVATE */
 482 png_zlib_inflate(png_structrp png_ptr, int flush)
 483 {
 484    if (png_ptr-&gt;zstream_start &amp;&amp; png_ptr-&gt;zstream.avail_in &gt; 0)
 485    {
 486       if ((*png_ptr-&gt;zstream.next_in &gt;&gt; 4) &gt; 7)
 487       {
 488          png_ptr-&gt;zstream.msg = &quot;invalid window size (libpng)&quot;;
 489          return Z_DATA_ERROR;
 490       }
 491 
 492       png_ptr-&gt;zstream_start = 0;
 493    }
 494 
 495    return inflate(&amp;png_ptr-&gt;zstream, flush);
 496 }
 497 #endif /* Zlib &gt;= 1.2.4 */
 498 
 499 #ifdef PNG_READ_COMPRESSED_TEXT_SUPPORTED
 500 #if defined(PNG_READ_zTXt_SUPPORTED) || defined (PNG_READ_iTXt_SUPPORTED)
 501 /* png_inflate now returns zlib error codes including Z_OK and Z_STREAM_END to
 502  * allow the caller to do multiple calls if required.  If the &#39;finish&#39; flag is
 503  * set Z_FINISH will be passed to the final inflate() call and Z_STREAM_END must
 504  * be returned or there has been a problem, otherwise Z_SYNC_FLUSH is used and
 505  * Z_OK or Z_STREAM_END will be returned on success.
 506  *
 507  * The input and output sizes are updated to the actual amounts of data consumed
 508  * or written, not the amount available (as in a z_stream).  The data pointers
 509  * are not changed, so the next input is (data+input_size) and the next
 510  * available output is (output+output_size).
 511  */
 512 static int
 513 png_inflate(png_structrp png_ptr, png_uint_32 owner, int finish,
 514     /* INPUT: */ png_const_bytep input, png_uint_32p input_size_ptr,
 515     /* OUTPUT: */ png_bytep output, png_alloc_size_t *output_size_ptr)
 516 {
 517    if (png_ptr-&gt;zowner == owner) /* Else not claimed */
 518    {
 519       int ret;
 520       png_alloc_size_t avail_out = *output_size_ptr;
 521       png_uint_32 avail_in = *input_size_ptr;
 522 
 523       /* zlib can&#39;t necessarily handle more than 65535 bytes at once (i.e. it
 524        * can&#39;t even necessarily handle 65536 bytes) because the type uInt is
 525        * &quot;16 bits or more&quot;.  Consequently it is necessary to chunk the input to
 526        * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the
 527        * maximum value that can be stored in a uInt.)  It is possible to set
 528        * ZLIB_IO_MAX to a lower value in pngpriv.h and this may sometimes have
 529        * a performance advantage, because it reduces the amount of data accessed
 530        * at each step and that may give the OS more time to page it in.
 531        */
 532       png_ptr-&gt;zstream.next_in = PNGZ_INPUT_CAST(input);
 533       /* avail_in and avail_out are set below from &#39;size&#39; */
 534       png_ptr-&gt;zstream.avail_in = 0;
 535       png_ptr-&gt;zstream.avail_out = 0;
 536 
 537       /* Read directly into the output if it is available (this is set to
 538        * a local buffer below if output is NULL).
 539        */
 540       if (output != NULL)
 541          png_ptr-&gt;zstream.next_out = output;
 542 
 543       do
 544       {
 545          uInt avail;
 546          Byte local_buffer[PNG_INFLATE_BUF_SIZE];
 547 
 548          /* zlib INPUT BUFFER */
 549          /* The setting of &#39;avail_in&#39; used to be outside the loop; by setting it
 550           * inside it is possible to chunk the input to zlib and simply rely on
 551           * zlib to advance the &#39;next_in&#39; pointer.  This allows arbitrary
 552           * amounts of data to be passed through zlib at the unavoidable cost of
 553           * requiring a window save (memcpy of up to 32768 output bytes)
 554           * every ZLIB_IO_MAX input bytes.
 555           */
 556          avail_in += png_ptr-&gt;zstream.avail_in; /* not consumed last time */
 557 
 558          avail = ZLIB_IO_MAX;
 559 
 560          if (avail_in &lt; avail)
 561             avail = (uInt)avail_in; /* safe: &lt; than ZLIB_IO_MAX */
 562 
 563          avail_in -= avail;
 564          png_ptr-&gt;zstream.avail_in = avail;
 565 
 566          /* zlib OUTPUT BUFFER */
 567          avail_out += png_ptr-&gt;zstream.avail_out; /* not written last time */
 568 
 569          avail = ZLIB_IO_MAX; /* maximum zlib can process */
 570 
 571          if (output == NULL)
 572          {
 573             /* Reset the output buffer each time round if output is NULL and
 574              * make available the full buffer, up to &#39;remaining_space&#39;
 575              */
 576             png_ptr-&gt;zstream.next_out = local_buffer;
 577             if ((sizeof local_buffer) &lt; avail)
 578                avail = (sizeof local_buffer);
 579          }
 580 
 581          if (avail_out &lt; avail)
 582             avail = (uInt)avail_out; /* safe: &lt; ZLIB_IO_MAX */
 583 
 584          png_ptr-&gt;zstream.avail_out = avail;
 585          avail_out -= avail;
 586 
 587          /* zlib inflate call */
 588          /* In fact &#39;avail_out&#39; may be 0 at this point, that happens at the end
 589           * of the read when the final LZ end code was not passed at the end of
 590           * the previous chunk of input data.  Tell zlib if we have reached the
 591           * end of the output buffer.
 592           */
 593          ret = PNG_INFLATE(png_ptr, avail_out &gt; 0 ? Z_NO_FLUSH :
 594              (finish ? Z_FINISH : Z_SYNC_FLUSH));
 595       } while (ret == Z_OK);
 596 
 597       /* For safety kill the local buffer pointer now */
 598       if (output == NULL)
 599          png_ptr-&gt;zstream.next_out = NULL;
 600 
 601       /* Claw back the &#39;size&#39; and &#39;remaining_space&#39; byte counts. */
 602       avail_in += png_ptr-&gt;zstream.avail_in;
 603       avail_out += png_ptr-&gt;zstream.avail_out;
 604 
 605       /* Update the input and output sizes; the updated values are the amount
 606        * consumed or written, effectively the inverse of what zlib uses.
 607        */
 608       if (avail_out &gt; 0)
 609          *output_size_ptr -= avail_out;
 610 
 611       if (avail_in &gt; 0)
 612          *input_size_ptr -= avail_in;
 613 
 614       /* Ensure png_ptr-&gt;zstream.msg is set (even in the success case!) */
 615       png_zstream_error(png_ptr, ret);
 616       return ret;
 617    }
 618 
 619    else
 620    {
 621       /* This is a bad internal error.  The recovery assigns to the zstream msg
 622        * pointer, which is not owned by the caller, but this is safe; it&#39;s only
 623        * used on errors!
 624        */
 625       png_ptr-&gt;zstream.msg = PNGZ_MSG_CAST(&quot;zstream unclaimed&quot;);
 626       return Z_STREAM_ERROR;
 627    }
 628 }
 629 
 630 /*
 631  * Decompress trailing data in a chunk.  The assumption is that read_buffer
 632  * points at an allocated area holding the contents of a chunk with a
 633  * trailing compressed part.  What we get back is an allocated area
 634  * holding the original prefix part and an uncompressed version of the
 635  * trailing part (the malloc area passed in is freed).
 636  */
 637 static int
 638 png_decompress_chunk(png_structrp png_ptr,
 639     png_uint_32 chunklength, png_uint_32 prefix_size,
 640     png_alloc_size_t *newlength /* must be initialized to the maximum! */,
 641     int terminate /*add a &#39;\0&#39; to the end of the uncompressed data*/)
 642 {
 643    /* TODO: implement different limits for different types of chunk.
 644     *
 645     * The caller supplies *newlength set to the maximum length of the
 646     * uncompressed data, but this routine allocates space for the prefix and
 647     * maybe a &#39;\0&#39; terminator too.  We have to assume that &#39;prefix_size&#39; is
 648     * limited only by the maximum chunk size.
 649     */
 650    png_alloc_size_t limit = PNG_SIZE_MAX;
 651 
 652 # ifdef PNG_SET_USER_LIMITS_SUPPORTED
 653    if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
 654        png_ptr-&gt;user_chunk_malloc_max &lt; limit)
 655       limit = png_ptr-&gt;user_chunk_malloc_max;
 656 # elif PNG_USER_CHUNK_MALLOC_MAX &gt; 0
 657    if (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
 658       limit = PNG_USER_CHUNK_MALLOC_MAX;
 659 # endif
 660 
 661    if (limit &gt;= prefix_size + (terminate != 0))
 662    {
 663       int ret;
 664 
 665       limit -= prefix_size + (terminate != 0);
 666 
 667       if (limit &lt; *newlength)
 668          *newlength = limit;
 669 
 670       /* Now try to claim the stream. */
 671       ret = png_inflate_claim(png_ptr, png_ptr-&gt;chunk_name);
 672 
 673       if (ret == Z_OK)
 674       {
 675          png_uint_32 lzsize = chunklength - prefix_size;
 676 
 677          ret = png_inflate(png_ptr, png_ptr-&gt;chunk_name, 1/*finish*/,
 678              /* input: */ png_ptr-&gt;read_buffer + prefix_size, &amp;lzsize,
 679              /* output: */ NULL, newlength);
 680 
 681          if (ret == Z_STREAM_END)
 682          {
 683             /* Use &#39;inflateReset&#39; here, not &#39;inflateReset2&#39; because this
 684              * preserves the previously decided window size (otherwise it would
 685              * be necessary to store the previous window size.)  In practice
 686              * this doesn&#39;t matter anyway, because png_inflate will call inflate
 687              * with Z_FINISH in almost all cases, so the window will not be
 688              * maintained.
 689              */
 690             if (inflateReset(&amp;png_ptr-&gt;zstream) == Z_OK)
 691             {
 692                /* Because of the limit checks above we know that the new,
 693                 * expanded, size will fit in a size_t (let alone an
 694                 * png_alloc_size_t).  Use png_malloc_base here to avoid an
 695                 * extra OOM message.
 696                 */
 697                png_alloc_size_t new_size = *newlength;
 698                png_alloc_size_t buffer_size = prefix_size + new_size +
 699                    (terminate != 0);
 700                png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,
 701                    buffer_size));
 702 
 703                if (text != NULL)
 704                {
 705                   memset(text, 0, buffer_size);
 706 
 707                   ret = png_inflate(png_ptr, png_ptr-&gt;chunk_name, 1/*finish*/,
 708                       png_ptr-&gt;read_buffer + prefix_size, &amp;lzsize,
 709                       text + prefix_size, newlength);
 710 
 711                   if (ret == Z_STREAM_END)
 712                   {
 713                      if (new_size == *newlength)
 714                      {
 715                         if (terminate != 0)
 716                            text[prefix_size + *newlength] = 0;
 717 
 718                         if (prefix_size &gt; 0)
 719                            memcpy(text, png_ptr-&gt;read_buffer, prefix_size);
 720 
 721                         {
 722                            png_bytep old_ptr = png_ptr-&gt;read_buffer;
 723 
 724                            png_ptr-&gt;read_buffer = text;
 725                            png_ptr-&gt;read_buffer_size = buffer_size;
 726                            text = old_ptr; /* freed below */
 727                         }
 728                      }
 729 
 730                      else
 731                      {
 732                         /* The size changed on the second read, there can be no
 733                          * guarantee that anything is correct at this point.
 734                          * The &#39;msg&#39; pointer has been set to &quot;unexpected end of
 735                          * LZ stream&quot;, which is fine, but return an error code
 736                          * that the caller won&#39;t accept.
 737                          */
 738                         ret = PNG_UNEXPECTED_ZLIB_RETURN;
 739                      }
 740                   }
 741 
 742                   else if (ret == Z_OK)
 743                      ret = PNG_UNEXPECTED_ZLIB_RETURN; /* for safety */
 744 
 745                   /* Free the text pointer (this is the old read_buffer on
 746                    * success)
 747                    */
 748                   png_free(png_ptr, text);
 749 
 750                   /* This really is very benign, but it&#39;s still an error because
 751                    * the extra space may otherwise be used as a Trojan Horse.
 752                    */
 753                   if (ret == Z_STREAM_END &amp;&amp;
 754                       chunklength - prefix_size != lzsize)
 755                      png_chunk_benign_error(png_ptr, &quot;extra compressed data&quot;);
 756                }
 757 
 758                else
 759                {
 760                   /* Out of memory allocating the buffer */
 761                   ret = Z_MEM_ERROR;
 762                   png_zstream_error(png_ptr, Z_MEM_ERROR);
 763                }
 764             }
 765 
 766             else
 767             {
 768                /* inflateReset failed, store the error message */
 769                png_zstream_error(png_ptr, ret);
 770                ret = PNG_UNEXPECTED_ZLIB_RETURN;
 771             }
 772          }
 773 
 774          else if (ret == Z_OK)
 775             ret = PNG_UNEXPECTED_ZLIB_RETURN;
 776 
 777          /* Release the claimed stream */
 778          png_ptr-&gt;zowner = 0;
 779       }
 780 
 781       else /* the claim failed */ if (ret == Z_STREAM_END) /* impossible! */
 782          ret = PNG_UNEXPECTED_ZLIB_RETURN;
 783 
 784       return ret;
 785    }
 786 
 787    else
 788    {
 789       /* Application/configuration limits exceeded */
 790       png_zstream_error(png_ptr, Z_MEM_ERROR);
 791       return Z_MEM_ERROR;
 792    }
 793 }
 794 #endif /* READ_zTXt || READ_iTXt */
 795 #endif /* READ_COMPRESSED_TEXT */
 796 
 797 #ifdef PNG_READ_iCCP_SUPPORTED
 798 /* Perform a partial read and decompress, producing &#39;avail_out&#39; bytes and
 799  * reading from the current chunk as required.
 800  */
 801 static int
 802 png_inflate_read(png_structrp png_ptr, png_bytep read_buffer, uInt read_size,
 803     png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,
 804     int finish)
 805 {
 806    if (png_ptr-&gt;zowner == png_ptr-&gt;chunk_name)
 807    {
 808       int ret;
 809 
 810       /* next_in and avail_in must have been initialized by the caller. */
 811       png_ptr-&gt;zstream.next_out = next_out;
 812       png_ptr-&gt;zstream.avail_out = 0; /* set in the loop */
 813 
 814       do
 815       {
 816          if (png_ptr-&gt;zstream.avail_in == 0)
 817          {
 818             if (read_size &gt; *chunk_bytes)
 819                read_size = (uInt)*chunk_bytes;
 820             *chunk_bytes -= read_size;
 821 
 822             if (read_size &gt; 0)
 823                png_crc_read(png_ptr, read_buffer, read_size);
 824 
 825             png_ptr-&gt;zstream.next_in = read_buffer;
 826             png_ptr-&gt;zstream.avail_in = read_size;
 827          }
 828 
 829          if (png_ptr-&gt;zstream.avail_out == 0)
 830          {
 831             uInt avail = ZLIB_IO_MAX;
 832             if (avail &gt; *out_size)
 833                avail = (uInt)*out_size;
 834             *out_size -= avail;
 835 
 836             png_ptr-&gt;zstream.avail_out = avail;
 837          }
 838 
 839          /* Use Z_SYNC_FLUSH when there is no more chunk data to ensure that all
 840           * the available output is produced; this allows reading of truncated
 841           * streams.
 842           */
 843          ret = PNG_INFLATE(png_ptr, *chunk_bytes &gt; 0 ?
 844              Z_NO_FLUSH : (finish ? Z_FINISH : Z_SYNC_FLUSH));
 845       }
 846       while (ret == Z_OK &amp;&amp; (*out_size &gt; 0 || png_ptr-&gt;zstream.avail_out &gt; 0));
 847 
 848       *out_size += png_ptr-&gt;zstream.avail_out;
 849       png_ptr-&gt;zstream.avail_out = 0; /* Should not be required, but is safe */
 850 
 851       /* Ensure the error message pointer is always set: */
 852       png_zstream_error(png_ptr, ret);
 853       return ret;
 854    }
 855 
 856    else
 857    {
 858       png_ptr-&gt;zstream.msg = PNGZ_MSG_CAST(&quot;zstream unclaimed&quot;);
 859       return Z_STREAM_ERROR;
 860    }
 861 }
 862 #endif /* READ_iCCP */
 863 
 864 /* Read and check the IDHR chunk */
 865 
 866 void /* PRIVATE */
 867 png_handle_IHDR(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
 868 {
 869    png_byte buf[13];
 870    png_uint_32 width, height;
 871    int bit_depth, color_type, compression_type, filter_type;
 872    int interlace_type;
 873 
 874    png_debug(1, &quot;in png_handle_IHDR&quot;);
 875 
 876    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) != 0)
 877       png_chunk_error(png_ptr, &quot;out of place&quot;);
 878 
 879    /* Check the length */
 880    if (length != 13)
 881       png_chunk_error(png_ptr, &quot;invalid&quot;);
 882 
 883    png_ptr-&gt;mode |= PNG_HAVE_IHDR;
 884 
 885    png_crc_read(png_ptr, buf, 13);
 886    png_crc_finish(png_ptr, 0);
 887 
 888    width = png_get_uint_31(png_ptr, buf);
 889    height = png_get_uint_31(png_ptr, buf + 4);
 890    bit_depth = buf[8];
 891    color_type = buf[9];
 892    compression_type = buf[10];
 893    filter_type = buf[11];
 894    interlace_type = buf[12];
 895 
 896    /* Set internal variables */
 897    png_ptr-&gt;width = width;
 898    png_ptr-&gt;height = height;
 899    png_ptr-&gt;bit_depth = (png_byte)bit_depth;
 900    png_ptr-&gt;interlaced = (png_byte)interlace_type;
 901    png_ptr-&gt;color_type = (png_byte)color_type;
 902 #ifdef PNG_MNG_FEATURES_SUPPORTED
 903    png_ptr-&gt;filter_type = (png_byte)filter_type;
 904 #endif
 905    png_ptr-&gt;compression_type = (png_byte)compression_type;
 906 
 907    /* Find number of channels */
 908    switch (png_ptr-&gt;color_type)
 909    {
 910       default: /* invalid, png_set_IHDR calls png_error */
 911       case PNG_COLOR_TYPE_GRAY:
 912       case PNG_COLOR_TYPE_PALETTE:
 913          png_ptr-&gt;channels = 1;
 914          break;
 915 
 916       case PNG_COLOR_TYPE_RGB:
 917          png_ptr-&gt;channels = 3;
 918          break;
 919 
 920       case PNG_COLOR_TYPE_GRAY_ALPHA:
 921          png_ptr-&gt;channels = 2;
 922          break;
 923 
 924       case PNG_COLOR_TYPE_RGB_ALPHA:
 925          png_ptr-&gt;channels = 4;
 926          break;
 927    }
 928 
 929    /* Set up other useful info */
 930    png_ptr-&gt;pixel_depth = (png_byte)(png_ptr-&gt;bit_depth * png_ptr-&gt;channels);
 931    png_ptr-&gt;rowbytes = PNG_ROWBYTES(png_ptr-&gt;pixel_depth, png_ptr-&gt;width);
 932    png_debug1(3, &quot;bit_depth = %d&quot;, png_ptr-&gt;bit_depth);
 933    png_debug1(3, &quot;channels = %d&quot;, png_ptr-&gt;channels);
 934    png_debug1(3, &quot;rowbytes = %lu&quot;, (unsigned long)png_ptr-&gt;rowbytes);
 935    png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth,
 936        color_type, interlace_type, compression_type, filter_type);
 937 }
 938 
 939 /* Read and check the palette */
 940 void /* PRIVATE */
 941 png_handle_PLTE(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
 942 {
 943    png_color palette[PNG_MAX_PALETTE_LENGTH];
 944    int max_palette_length, num, i;
 945 #ifdef PNG_POINTER_INDEXING_SUPPORTED
 946    png_colorp pal_ptr;
 947 #endif
 948 
 949    png_debug(1, &quot;in png_handle_PLTE&quot;);
 950 
 951    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
 952       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
 953 
 954    /* Moved to before the &#39;after IDAT&#39; check below because otherwise duplicate
 955     * PLTE chunks are potentially ignored (the spec says there shall not be more
 956     * than one PLTE, the error is not treated as benign, so this check trumps
 957     * the requirement that PLTE appears before IDAT.)
 958     */
 959    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_PLTE) != 0)
 960       png_chunk_error(png_ptr, &quot;duplicate&quot;);
 961 
 962    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
 963    {
 964       /* This is benign because the non-benign error happened before, when an
 965        * IDAT was encountered in a color-mapped image with no PLTE.
 966        */
 967       png_crc_finish(png_ptr, length);
 968       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
 969       return;
 970    }
 971 
 972    png_ptr-&gt;mode |= PNG_HAVE_PLTE;
 973 
 974    if ((png_ptr-&gt;color_type &amp; PNG_COLOR_MASK_COLOR) == 0)
 975    {
 976       png_crc_finish(png_ptr, length);
 977       png_chunk_benign_error(png_ptr, &quot;ignored in grayscale PNG&quot;);
 978       return;
 979    }
 980 
 981 #ifndef PNG_READ_OPT_PLTE_SUPPORTED
 982    if (png_ptr-&gt;color_type != PNG_COLOR_TYPE_PALETTE)
 983    {
 984       png_crc_finish(png_ptr, length);
 985       return;
 986    }
 987 #endif
 988 
 989    if (length &gt; 3*PNG_MAX_PALETTE_LENGTH || length % 3)
 990    {
 991       png_crc_finish(png_ptr, length);
 992 
 993       if (png_ptr-&gt;color_type != PNG_COLOR_TYPE_PALETTE)
 994          png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
 995 
 996       else
 997          png_chunk_error(png_ptr, &quot;invalid&quot;);
 998 
 999       return;
1000    }
1001 
1002    /* The cast is safe because &#39;length&#39; is less than 3*PNG_MAX_PALETTE_LENGTH */
1003    num = (int)length / 3;
1004 
1005    /* If the palette has 256 or fewer entries but is too large for the bit
1006     * depth, we don&#39;t issue an error, to preserve the behavior of previous
1007     * libpng versions. We silently truncate the unused extra palette entries
1008     * here.
1009     */
1010    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
1011       max_palette_length = (1 &lt;&lt; png_ptr-&gt;bit_depth);
1012    else
1013       max_palette_length = PNG_MAX_PALETTE_LENGTH;
1014 
1015    if (num &gt; max_palette_length)
1016       num = max_palette_length;
1017 
1018 #ifdef PNG_POINTER_INDEXING_SUPPORTED
1019    for (i = 0, pal_ptr = palette; i &lt; num; i++, pal_ptr++)
1020    {
1021       png_byte buf[3];
1022 
1023       png_crc_read(png_ptr, buf, 3);
1024       pal_ptr-&gt;red = buf[0];
1025       pal_ptr-&gt;green = buf[1];
1026       pal_ptr-&gt;blue = buf[2];
1027    }
1028 #else
1029    for (i = 0; i &lt; num; i++)
1030    {
1031       png_byte buf[3];
1032 
1033       png_crc_read(png_ptr, buf, 3);
1034       /* Don&#39;t depend upon png_color being any order */
1035       palette[i].red = buf[0];
1036       palette[i].green = buf[1];
1037       palette[i].blue = buf[2];
1038    }
1039 #endif
1040 
1041    /* If we actually need the PLTE chunk (ie for a paletted image), we do
1042     * whatever the normal CRC configuration tells us.  However, if we
1043     * have an RGB image, the PLTE can be considered ancillary, so
1044     * we will act as though it is.
1045     */
1046 #ifndef PNG_READ_OPT_PLTE_SUPPORTED
1047    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
1048 #endif
1049    {
1050       png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));
1051    }
1052 
1053 #ifndef PNG_READ_OPT_PLTE_SUPPORTED
1054    else if (png_crc_error(png_ptr) != 0)  /* Only if we have a CRC error */
1055    {
1056       /* If we don&#39;t want to use the data from an ancillary chunk,
1057        * we have two options: an error abort, or a warning and we
1058        * ignore the data in this chunk (which should be OK, since
1059        * it&#39;s considered ancillary for a RGB or RGBA image).
1060        *
1061        * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the
1062        * chunk type to determine whether to check the ancillary or the critical
1063        * flags.
1064        */
1065       if ((png_ptr-&gt;flags &amp; PNG_FLAG_CRC_ANCILLARY_USE) == 0)
1066       {
1067          if ((png_ptr-&gt;flags &amp; PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)
1068             return;
1069 
1070          else
1071             png_chunk_error(png_ptr, &quot;CRC error&quot;);
1072       }
1073 
1074       /* Otherwise, we (optionally) emit a warning and use the chunk. */
1075       else if ((png_ptr-&gt;flags &amp; PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)
1076          png_chunk_warning(png_ptr, &quot;CRC error&quot;);
1077    }
1078 #endif
1079 
1080    /* TODO: png_set_PLTE has the side effect of setting png_ptr-&gt;palette to its
1081     * own copy of the palette.  This has the side effect that when png_start_row
1082     * is called (this happens after any call to png_read_update_info) the
1083     * info_ptr palette gets changed.  This is extremely unexpected and
1084     * confusing.
1085     *
1086     * Fix this by not sharing the palette in this way.
1087     */
1088    png_set_PLTE(png_ptr, info_ptr, palette, num);
1089 
1090    /* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before
1091     * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely
1092     * checked the apparent validity of a tRNS chunk inserted before PLTE on a
1093     * palette PNG.  1.6.0 attempts to rigorously follow the standard and
1094     * therefore does a benign error if the erroneous condition is detected *and*
1095     * cancels the tRNS if the benign error returns.  The alternative is to
1096     * amend the standard since it would be rather hypocritical of the standards
1097     * maintainers to ignore it.
1098     */
1099 #ifdef PNG_READ_tRNS_SUPPORTED
1100    if (png_ptr-&gt;num_trans &gt; 0 ||
1101        (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_tRNS) != 0))
1102    {
1103       /* Cancel this because otherwise it would be used if the transforms
1104        * require it.  Don&#39;t cancel the &#39;valid&#39; flag because this would prevent
1105        * detection of duplicate chunks.
1106        */
1107       png_ptr-&gt;num_trans = 0;
1108 
1109       if (info_ptr != NULL)
1110          info_ptr-&gt;num_trans = 0;
1111 
1112       png_chunk_benign_error(png_ptr, &quot;tRNS must be after&quot;);
1113    }
1114 #endif
1115 
1116 #ifdef PNG_READ_hIST_SUPPORTED
1117    if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_hIST) != 0)
1118       png_chunk_benign_error(png_ptr, &quot;hIST must be after&quot;);
1119 #endif
1120 
1121 #ifdef PNG_READ_bKGD_SUPPORTED
1122    if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_bKGD) != 0)
1123       png_chunk_benign_error(png_ptr, &quot;bKGD must be after&quot;);
1124 #endif
1125 }
1126 
1127 void /* PRIVATE */
1128 png_handle_IEND(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1129 {
1130    png_debug(1, &quot;in png_handle_IEND&quot;);
1131 
1132    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0 ||
1133        (png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) == 0)
1134       png_chunk_error(png_ptr, &quot;out of place&quot;);
1135 
1136    png_ptr-&gt;mode |= (PNG_AFTER_IDAT | PNG_HAVE_IEND);
1137 
1138    png_crc_finish(png_ptr, length);
1139 
1140    if (length != 0)
1141       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1142 
1143    PNG_UNUSED(info_ptr)
1144 }
1145 
1146 #ifdef PNG_READ_gAMA_SUPPORTED
1147 void /* PRIVATE */
1148 png_handle_gAMA(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1149 {
1150    png_fixed_point igamma;
1151    png_byte buf[4];
1152 
1153    png_debug(1, &quot;in png_handle_gAMA&quot;);
1154 
1155    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1156       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1157 
1158    else if ((png_ptr-&gt;mode &amp; (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
1159    {
1160       png_crc_finish(png_ptr, length);
1161       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1162       return;
1163    }
1164 
1165    if (length != 4)
1166    {
1167       png_crc_finish(png_ptr, length);
1168       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1169       return;
1170    }
1171 
1172    png_crc_read(png_ptr, buf, 4);
1173 
1174    if (png_crc_finish(png_ptr, 0) != 0)
1175       return;
1176 
1177    igamma = png_get_fixed_point(NULL, buf);
1178 
1179    png_colorspace_set_gamma(png_ptr, &amp;png_ptr-&gt;colorspace, igamma);
1180    png_colorspace_sync(png_ptr, info_ptr);
1181 }
1182 #endif
1183 
1184 #ifdef PNG_READ_sBIT_SUPPORTED
1185 void /* PRIVATE */
1186 png_handle_sBIT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1187 {
1188    unsigned int truelen, i;
1189    png_byte sample_depth;
1190    png_byte buf[4];
1191 
1192    png_debug(1, &quot;in png_handle_sBIT&quot;);
1193 
1194    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1195       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1196 
1197    else if ((png_ptr-&gt;mode &amp; (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
1198    {
1199       png_crc_finish(png_ptr, length);
1200       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1201       return;
1202    }
1203 
1204    if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_sBIT) != 0)
1205    {
1206       png_crc_finish(png_ptr, length);
1207       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
1208       return;
1209    }
1210 
1211    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
1212    {
1213       truelen = 3;
1214       sample_depth = 8;
1215    }
1216 
1217    else
1218    {
1219       truelen = png_ptr-&gt;channels;
1220       sample_depth = png_ptr-&gt;bit_depth;
1221    }
1222 
1223    if (length != truelen || length &gt; 4)
1224    {
1225       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1226       png_crc_finish(png_ptr, length);
1227       return;
1228    }
1229 
1230    buf[0] = buf[1] = buf[2] = buf[3] = sample_depth;
1231    png_crc_read(png_ptr, buf, truelen);
1232 
1233    if (png_crc_finish(png_ptr, 0) != 0)
1234       return;
1235 
1236    for (i=0; i&lt;truelen; ++i)
1237    {
1238       if (buf[i] == 0 || buf[i] &gt; sample_depth)
1239       {
1240          png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1241          return;
1242       }
1243    }
1244 
1245    if ((png_ptr-&gt;color_type &amp; PNG_COLOR_MASK_COLOR) != 0)
1246    {
1247       png_ptr-&gt;sig_bit.red = buf[0];
1248       png_ptr-&gt;sig_bit.green = buf[1];
1249       png_ptr-&gt;sig_bit.blue = buf[2];
1250       png_ptr-&gt;sig_bit.alpha = buf[3];
1251    }
1252 
1253    else
1254    {
1255       png_ptr-&gt;sig_bit.gray = buf[0];
1256       png_ptr-&gt;sig_bit.red = buf[0];
1257       png_ptr-&gt;sig_bit.green = buf[0];
1258       png_ptr-&gt;sig_bit.blue = buf[0];
1259       png_ptr-&gt;sig_bit.alpha = buf[1];
1260    }
1261 
1262    png_set_sBIT(png_ptr, info_ptr, &amp;(png_ptr-&gt;sig_bit));
1263 }
1264 #endif
1265 
1266 #ifdef PNG_READ_cHRM_SUPPORTED
1267 void /* PRIVATE */
1268 png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1269 {
1270    png_byte buf[32];
1271    png_xy xy;
1272 
1273    png_debug(1, &quot;in png_handle_cHRM&quot;);
1274 
1275    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1276       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1277 
1278    else if ((png_ptr-&gt;mode &amp; (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
1279    {
1280       png_crc_finish(png_ptr, length);
1281       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1282       return;
1283    }
1284 
1285    if (length != 32)
1286    {
1287       png_crc_finish(png_ptr, length);
1288       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1289       return;
1290    }
1291 
1292    png_crc_read(png_ptr, buf, 32);
1293 
1294    if (png_crc_finish(png_ptr, 0) != 0)
1295       return;
1296 
1297    xy.whitex = png_get_fixed_point(NULL, buf);
1298    xy.whitey = png_get_fixed_point(NULL, buf + 4);
1299    xy.redx   = png_get_fixed_point(NULL, buf + 8);
1300    xy.redy   = png_get_fixed_point(NULL, buf + 12);
1301    xy.greenx = png_get_fixed_point(NULL, buf + 16);
1302    xy.greeny = png_get_fixed_point(NULL, buf + 20);
1303    xy.bluex  = png_get_fixed_point(NULL, buf + 24);
1304    xy.bluey  = png_get_fixed_point(NULL, buf + 28);
1305 
1306    if (xy.whitex == PNG_FIXED_ERROR ||
1307        xy.whitey == PNG_FIXED_ERROR ||
1308        xy.redx   == PNG_FIXED_ERROR ||
1309        xy.redy   == PNG_FIXED_ERROR ||
1310        xy.greenx == PNG_FIXED_ERROR ||
1311        xy.greeny == PNG_FIXED_ERROR ||
1312        xy.bluex  == PNG_FIXED_ERROR ||
1313        xy.bluey  == PNG_FIXED_ERROR)
1314    {
1315       png_chunk_benign_error(png_ptr, &quot;invalid values&quot;);
1316       return;
1317    }
1318 
1319    /* If a colorspace error has already been output skip this chunk */
1320    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) != 0)
1321       return;
1322 
1323    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_FROM_cHRM) != 0)
1324    {
1325       png_ptr-&gt;colorspace.flags |= PNG_COLORSPACE_INVALID;
1326       png_colorspace_sync(png_ptr, info_ptr);
1327       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
1328       return;
1329    }
1330 
1331    png_ptr-&gt;colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;
1332    (void)png_colorspace_set_chromaticities(png_ptr, &amp;png_ptr-&gt;colorspace, &amp;xy,
1333        1/*prefer cHRM values*/);
1334    png_colorspace_sync(png_ptr, info_ptr);
1335 }
1336 #endif
1337 
1338 #ifdef PNG_READ_sRGB_SUPPORTED
1339 void /* PRIVATE */
1340 png_handle_sRGB(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1341 {
1342    png_byte intent;
1343 
1344    png_debug(1, &quot;in png_handle_sRGB&quot;);
1345 
1346    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1347       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1348 
1349    else if ((png_ptr-&gt;mode &amp; (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
1350    {
1351       png_crc_finish(png_ptr, length);
1352       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1353       return;
1354    }
1355 
1356    if (length != 1)
1357    {
1358       png_crc_finish(png_ptr, length);
1359       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1360       return;
1361    }
1362 
1363    png_crc_read(png_ptr, &amp;intent, 1);
1364 
1365    if (png_crc_finish(png_ptr, 0) != 0)
1366       return;
1367 
1368    /* If a colorspace error has already been output skip this chunk */
1369    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) != 0)
1370       return;
1371 
1372    /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
1373     * this.
1374     */
1375    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_HAVE_INTENT) != 0)
1376    {
1377       png_ptr-&gt;colorspace.flags |= PNG_COLORSPACE_INVALID;
1378       png_colorspace_sync(png_ptr, info_ptr);
1379       png_chunk_benign_error(png_ptr, &quot;too many profiles&quot;);
1380       return;
1381    }
1382 
1383    (void)png_colorspace_set_sRGB(png_ptr, &amp;png_ptr-&gt;colorspace, intent);
1384    png_colorspace_sync(png_ptr, info_ptr);
1385 }
1386 #endif /* READ_sRGB */
1387 
1388 #ifdef PNG_READ_iCCP_SUPPORTED
1389 void /* PRIVATE */
1390 png_handle_iCCP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1391 /* Note: this does not properly handle profiles that are &gt; 64K under DOS */
1392 {
1393    png_const_charp errmsg = NULL; /* error message output, or no error */
1394    int finished = 0; /* crc checked */
1395 
1396    png_debug(1, &quot;in png_handle_iCCP&quot;);
1397 
1398    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1399       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1400 
1401    else if ((png_ptr-&gt;mode &amp; (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)
1402    {
1403       png_crc_finish(png_ptr, length);
1404       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1405       return;
1406    }
1407 
1408    /* Consistent with all the above colorspace handling an obviously *invalid*
1409     * chunk is just ignored, so does not invalidate the color space.  An
1410     * alternative is to set the &#39;invalid&#39; flags at the start of this routine
1411     * and only clear them in they were not set before and all the tests pass.
1412     */
1413 
1414    /* The keyword must be at least one character and there is a
1415     * terminator (0) byte and the compression method byte, and the
1416     * &#39;zlib&#39; datastream is at least 11 bytes.
1417     */
1418    if (length &lt; 14)
1419    {
1420       png_crc_finish(png_ptr, length);
1421       png_chunk_benign_error(png_ptr, &quot;too short&quot;);
1422       return;
1423    }
1424 
1425    /* If a colorspace error has already been output skip this chunk */
1426    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_INVALID) != 0)
1427    {
1428       png_crc_finish(png_ptr, length);
1429       return;
1430    }
1431 
1432    /* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect
1433     * this.
1434     */
1435    if ((png_ptr-&gt;colorspace.flags &amp; PNG_COLORSPACE_HAVE_INTENT) == 0)
1436    {
1437       uInt read_length, keyword_length;
1438       char keyword[81];
1439 
1440       /* Find the keyword; the keyword plus separator and compression method
1441        * bytes can be at most 81 characters long.
1442        */
1443       read_length = 81; /* maximum */
1444       if (read_length &gt; length)
1445          read_length = (uInt)length;
1446 
1447       png_crc_read(png_ptr, (png_bytep)keyword, read_length);
1448       length -= read_length;
1449 
1450       /* The minimum &#39;zlib&#39; stream is assumed to be just the 2 byte header,
1451        * 5 bytes minimum &#39;deflate&#39; stream, and the 4 byte checksum.
1452        */
1453       if (length &lt; 11)
1454       {
1455          png_crc_finish(png_ptr, length);
1456          png_chunk_benign_error(png_ptr, &quot;too short&quot;);
1457          return;
1458       }
1459 
1460       keyword_length = 0;
1461       while (keyword_length &lt; 80 &amp;&amp; keyword_length &lt; read_length &amp;&amp;
1462          keyword[keyword_length] != 0)
1463          ++keyword_length;
1464 
1465       /* TODO: make the keyword checking common */
1466       if (keyword_length &gt;= 1 &amp;&amp; keyword_length &lt;= 79)
1467       {
1468          /* We only understand &#39;0&#39; compression - deflate - so if we get a
1469           * different value we can&#39;t safely decode the chunk.
1470           */
1471          if (keyword_length+1 &lt; read_length &amp;&amp;
1472             keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)
1473          {
1474             read_length -= keyword_length+2;
1475 
1476             if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
1477             {
1478                Byte profile_header[132]={0};
1479                Byte local_buffer[PNG_INFLATE_BUF_SIZE];
1480                png_alloc_size_t size = (sizeof profile_header);
1481 
1482                png_ptr-&gt;zstream.next_in = (Bytef*)keyword + (keyword_length+2);
1483                png_ptr-&gt;zstream.avail_in = read_length;
1484                (void)png_inflate_read(png_ptr, local_buffer,
1485                    (sizeof local_buffer), &amp;length, profile_header, &amp;size,
1486                    0/*finish: don&#39;t, because the output is too small*/);
1487 
1488                if (size == 0)
1489                {
1490                   /* We have the ICC profile header; do the basic header checks.
1491                    */
1492                   png_uint_32 profile_length = png_get_uint_32(profile_header);
1493 
1494                   if (png_icc_check_length(png_ptr, &amp;png_ptr-&gt;colorspace,
1495                       keyword, profile_length) != 0)
1496                   {
1497                      /* The length is apparently ok, so we can check the 132
1498                       * byte header.
1499                       */
1500                      if (png_icc_check_header(png_ptr, &amp;png_ptr-&gt;colorspace,
1501                          keyword, profile_length, profile_header,
1502                          png_ptr-&gt;color_type) != 0)
1503                      {
1504                         /* Now read the tag table; a variable size buffer is
1505                          * needed at this point, allocate one for the whole
1506                          * profile.  The header check has already validated
1507                          * that none of this stuff will overflow.
1508                          */
1509                         png_uint_32 tag_count =
1510                            png_get_uint_32(profile_header + 128);
1511                         png_bytep profile = png_read_buffer(png_ptr,
1512                             profile_length, 2/*silent*/);
1513 
1514                         if (profile != NULL)
1515                         {
1516                            memcpy(profile, profile_header,
1517                                (sizeof profile_header));
1518 
1519                            size = 12 * tag_count;
1520 
1521                            (void)png_inflate_read(png_ptr, local_buffer,
1522                                (sizeof local_buffer), &amp;length,
1523                                profile + (sizeof profile_header), &amp;size, 0);
1524 
1525                            /* Still expect a buffer error because we expect
1526                             * there to be some tag data!
1527                             */
1528                            if (size == 0)
1529                            {
1530                               if (png_icc_check_tag_table(png_ptr,
1531                                   &amp;png_ptr-&gt;colorspace, keyword, profile_length,
1532                                   profile) != 0)
1533                               {
1534                                  /* The profile has been validated for basic
1535                                   * security issues, so read the whole thing in.
1536                                   */
1537                                  size = profile_length - (sizeof profile_header)
1538                                      - 12 * tag_count;
1539 
1540                                  (void)png_inflate_read(png_ptr, local_buffer,
1541                                      (sizeof local_buffer), &amp;length,
1542                                      profile + (sizeof profile_header) +
1543                                      12 * tag_count, &amp;size, 1/*finish*/);
1544 
1545                                  if (length &gt; 0 &amp;&amp; !(png_ptr-&gt;flags &amp;
1546                                      PNG_FLAG_BENIGN_ERRORS_WARN))
1547                                     errmsg = &quot;extra compressed data&quot;;
1548 
1549                                  /* But otherwise allow extra data: */
1550                                  else if (size == 0)
1551                                  {
1552                                     if (length &gt; 0)
1553                                     {
1554                                        /* This can be handled completely, so
1555                                         * keep going.
1556                                         */
1557                                        png_chunk_warning(png_ptr,
1558                                            &quot;extra compressed data&quot;);
1559                                     }
1560 
1561                                     png_crc_finish(png_ptr, length);
1562                                     finished = 1;
1563 
1564 # if defined(PNG_sRGB_SUPPORTED) &amp;&amp; PNG_sRGB_PROFILE_CHECKS &gt;= 0
1565                                     /* Check for a match against sRGB */
1566                                     png_icc_set_sRGB(png_ptr,
1567                                         &amp;png_ptr-&gt;colorspace, profile,
1568                                         png_ptr-&gt;zstream.adler);
1569 # endif
1570 
1571                                     /* Steal the profile for info_ptr. */
1572                                     if (info_ptr != NULL)
1573                                     {
1574                                        png_free_data(png_ptr, info_ptr,
1575                                            PNG_FREE_ICCP, 0);
1576 
1577                                        info_ptr-&gt;iccp_name = png_voidcast(char*,
1578                                            png_malloc_base(png_ptr,
1579                                            keyword_length+1));
1580                                        if (info_ptr-&gt;iccp_name != NULL)
1581                                        {
1582                                           memcpy(info_ptr-&gt;iccp_name, keyword,
1583                                               keyword_length+1);
1584                                           info_ptr-&gt;iccp_proflen =
1585                                               profile_length;
1586                                           info_ptr-&gt;iccp_profile = profile;
1587                                           png_ptr-&gt;read_buffer = NULL; /*steal*/
1588                                           info_ptr-&gt;free_me |= PNG_FREE_ICCP;
1589                                           info_ptr-&gt;valid |= PNG_INFO_iCCP;
1590                                        }
1591 
1592                                        else
1593                                        {
1594                                           png_ptr-&gt;colorspace.flags |=
1595                                              PNG_COLORSPACE_INVALID;
1596                                           errmsg = &quot;out of memory&quot;;
1597                                        }
1598                                     }
1599 
1600                                     /* else the profile remains in the read
1601                                      * buffer which gets reused for subsequent
1602                                      * chunks.
1603                                      */
1604 
1605                                     if (info_ptr != NULL)
1606                                        png_colorspace_sync(png_ptr, info_ptr);
1607 
1608                                     if (errmsg == NULL)
1609                                     {
1610                                        png_ptr-&gt;zowner = 0;
1611                                        return;
1612                                     }
1613                                  }
1614                                  if (errmsg == NULL)
1615                                     errmsg = png_ptr-&gt;zstream.msg;
1616                               }
1617                               /* else png_icc_check_tag_table output an error */
1618                            }
1619                            else /* profile truncated */
1620                               errmsg = png_ptr-&gt;zstream.msg;
1621                         }
1622 
1623                         else
1624                            errmsg = &quot;out of memory&quot;;
1625                      }
1626 
1627                      /* else png_icc_check_header output an error */
1628                   }
1629 
1630                   /* else png_icc_check_length output an error */
1631                }
1632 
1633                else /* profile truncated */
1634                   errmsg = png_ptr-&gt;zstream.msg;
1635 
1636                /* Release the stream */
1637                png_ptr-&gt;zowner = 0;
1638             }
1639 
1640             else /* png_inflate_claim failed */
1641                errmsg = png_ptr-&gt;zstream.msg;
1642          }
1643 
1644          else
1645             errmsg = &quot;bad compression method&quot;; /* or missing */
1646       }
1647 
1648       else
1649          errmsg = &quot;bad keyword&quot;;
1650    }
1651 
1652    else
1653       errmsg = &quot;too many profiles&quot;;
1654 
1655    /* Failure: the reason is in &#39;errmsg&#39; */
1656    if (finished == 0)
1657       png_crc_finish(png_ptr, length);
1658 
1659    png_ptr-&gt;colorspace.flags |= PNG_COLORSPACE_INVALID;
1660    png_colorspace_sync(png_ptr, info_ptr);
1661    if (errmsg != NULL) /* else already output */
1662       png_chunk_benign_error(png_ptr, errmsg);
1663 }
1664 #endif /* READ_iCCP */
1665 
1666 #ifdef PNG_READ_sPLT_SUPPORTED
1667 void /* PRIVATE */
1668 png_handle_sPLT(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1669 /* Note: this does not properly handle chunks that are &gt; 64K under DOS */
1670 {
1671    png_bytep entry_start, buffer;
1672    png_sPLT_t new_palette;
1673    png_sPLT_entryp pp;
1674    png_uint_32 data_length;
1675    int entry_size, i;
1676    png_uint_32 skip = 0;
1677    png_uint_32 dl;
1678    size_t max_dl;
1679 
1680    png_debug(1, &quot;in png_handle_sPLT&quot;);
1681 
1682 #ifdef PNG_USER_LIMITS_SUPPORTED
1683    if (png_ptr-&gt;user_chunk_cache_max != 0)
1684    {
1685       if (png_ptr-&gt;user_chunk_cache_max == 1)
1686       {
1687          png_crc_finish(png_ptr, length);
1688          return;
1689       }
1690 
1691       if (--png_ptr-&gt;user_chunk_cache_max == 1)
1692       {
1693          png_warning(png_ptr, &quot;No space in chunk cache for sPLT&quot;);
1694          png_crc_finish(png_ptr, length);
1695          return;
1696       }
1697    }
1698 #endif
1699 
1700    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1701       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1702 
1703    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
1704    {
1705       png_crc_finish(png_ptr, length);
1706       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1707       return;
1708    }
1709 
1710 #ifdef PNG_MAX_MALLOC_64K
1711    if (length &gt; 65535U)
1712    {
1713       png_crc_finish(png_ptr, length);
1714       png_chunk_benign_error(png_ptr, &quot;too large to fit in memory&quot;);
1715       return;
1716    }
1717 #endif
1718 
1719    buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);
1720    if (buffer == NULL)
1721    {
1722       png_crc_finish(png_ptr, length);
1723       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
1724       return;
1725    }
1726 
1727 
1728    /* WARNING: this may break if size_t is less than 32 bits; it is assumed
1729     * that the PNG_MAX_MALLOC_64K test is enabled in this case, but this is a
1730     * potential breakage point if the types in pngconf.h aren&#39;t exactly right.
1731     */
1732    png_crc_read(png_ptr, buffer, length);
1733 
1734    if (png_crc_finish(png_ptr, skip) != 0)
1735       return;
1736 
1737    buffer[length] = 0;
1738 
1739    for (entry_start = buffer; *entry_start; entry_start++)
1740       /* Empty loop to find end of name */ ;
1741 
1742    ++entry_start;
1743 
1744    /* A sample depth should follow the separator, and we should be on it  */
1745    if (length &lt; 2U || entry_start &gt; buffer + (length - 2U))
1746    {
1747       png_warning(png_ptr, &quot;malformed sPLT chunk&quot;);
1748       return;
1749    }
1750 
1751    new_palette.depth = *entry_start++;
1752    entry_size = (new_palette.depth == 8 ? 6 : 10);
1753    /* This must fit in a png_uint_32 because it is derived from the original
1754     * chunk data length.
1755     */
1756    data_length = length - (png_uint_32)(entry_start - buffer);
1757 
1758    /* Integrity-check the data length */
1759    if ((data_length % (unsigned int)entry_size) != 0)
1760    {
1761       png_warning(png_ptr, &quot;sPLT chunk has bad length&quot;);
1762       return;
1763    }
1764 
1765    dl = (png_uint_32)(data_length / (unsigned int)entry_size);
1766    max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));
1767 
1768    if (dl &gt; max_dl)
1769    {
1770       png_warning(png_ptr, &quot;sPLT chunk too long&quot;);
1771       return;
1772    }
1773 
1774    new_palette.nentries = (png_int_32)(data_length / (unsigned int)entry_size);
1775 
1776    new_palette.entries = (png_sPLT_entryp)png_malloc_warn(png_ptr,
1777        (png_alloc_size_t) new_palette.nentries * (sizeof (png_sPLT_entry)));
1778 
1779    if (new_palette.entries == NULL)
1780    {
1781       png_warning(png_ptr, &quot;sPLT chunk requires too much memory&quot;);
1782       return;
1783    }
1784 
1785 #ifdef PNG_POINTER_INDEXING_SUPPORTED
1786    for (i = 0; i &lt; new_palette.nentries; i++)
1787    {
1788       pp = new_palette.entries + i;
1789 
1790       if (new_palette.depth == 8)
1791       {
1792          pp-&gt;red = *entry_start++;
1793          pp-&gt;green = *entry_start++;
1794          pp-&gt;blue = *entry_start++;
1795          pp-&gt;alpha = *entry_start++;
1796       }
1797 
1798       else
1799       {
1800          pp-&gt;red   = png_get_uint_16(entry_start); entry_start += 2;
1801          pp-&gt;green = png_get_uint_16(entry_start); entry_start += 2;
1802          pp-&gt;blue  = png_get_uint_16(entry_start); entry_start += 2;
1803          pp-&gt;alpha = png_get_uint_16(entry_start); entry_start += 2;
1804       }
1805 
1806       pp-&gt;frequency = png_get_uint_16(entry_start); entry_start += 2;
1807    }
1808 #else
1809    pp = new_palette.entries;
1810 
1811    for (i = 0; i &lt; new_palette.nentries; i++)
1812    {
1813 
1814       if (new_palette.depth == 8)
1815       {
1816          pp[i].red   = *entry_start++;
1817          pp[i].green = *entry_start++;
1818          pp[i].blue  = *entry_start++;
1819          pp[i].alpha = *entry_start++;
1820       }
1821 
1822       else
1823       {
1824          pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;
1825          pp[i].green = png_get_uint_16(entry_start); entry_start += 2;
1826          pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;
1827          pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;
1828       }
1829 
1830       pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;
1831    }
1832 #endif
1833 
1834    /* Discard all chunk data except the name and stash that */
1835    new_palette.name = (png_charp)buffer;
1836 
1837    png_set_sPLT(png_ptr, info_ptr, &amp;new_palette, 1);
1838 
1839    png_free(png_ptr, new_palette.entries);
1840 }
1841 #endif /* READ_sPLT */
1842 
1843 #ifdef PNG_READ_tRNS_SUPPORTED
1844 void /* PRIVATE */
1845 png_handle_tRNS(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1846 {
1847    png_byte readbuf[PNG_MAX_PALETTE_LENGTH];
1848 
1849    png_debug(1, &quot;in png_handle_tRNS&quot;);
1850 
1851    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1852       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1853 
1854    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
1855    {
1856       png_crc_finish(png_ptr, length);
1857       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1858       return;
1859    }
1860 
1861    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_tRNS) != 0)
1862    {
1863       png_crc_finish(png_ptr, length);
1864       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
1865       return;
1866    }
1867 
1868    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_GRAY)
1869    {
1870       png_byte buf[2];
1871 
1872       if (length != 2)
1873       {
1874          png_crc_finish(png_ptr, length);
1875          png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1876          return;
1877       }
1878 
1879       png_crc_read(png_ptr, buf, 2);
1880       png_ptr-&gt;num_trans = 1;
1881       png_ptr-&gt;trans_color.gray = png_get_uint_16(buf);
1882    }
1883 
1884    else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_RGB)
1885    {
1886       png_byte buf[6];
1887 
1888       if (length != 6)
1889       {
1890          png_crc_finish(png_ptr, length);
1891          png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1892          return;
1893       }
1894 
1895       png_crc_read(png_ptr, buf, length);
1896       png_ptr-&gt;num_trans = 1;
1897       png_ptr-&gt;trans_color.red = png_get_uint_16(buf);
1898       png_ptr-&gt;trans_color.green = png_get_uint_16(buf + 2);
1899       png_ptr-&gt;trans_color.blue = png_get_uint_16(buf + 4);
1900    }
1901 
1902    else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
1903    {
1904       if ((png_ptr-&gt;mode &amp; PNG_HAVE_PLTE) == 0)
1905       {
1906          /* TODO: is this actually an error in the ISO spec? */
1907          png_crc_finish(png_ptr, length);
1908          png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1909          return;
1910       }
1911 
1912       if (length &gt; (unsigned int) png_ptr-&gt;num_palette ||
1913          length &gt; (unsigned int) PNG_MAX_PALETTE_LENGTH ||
1914          length == 0)
1915       {
1916          png_crc_finish(png_ptr, length);
1917          png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1918          return;
1919       }
1920 
1921       png_crc_read(png_ptr, readbuf, length);
1922       png_ptr-&gt;num_trans = (png_uint_16)length;
1923    }
1924 
1925    else
1926    {
1927       png_crc_finish(png_ptr, length);
1928       png_chunk_benign_error(png_ptr, &quot;invalid with alpha channel&quot;);
1929       return;
1930    }
1931 
1932    if (png_crc_finish(png_ptr, 0) != 0)
1933    {
1934       png_ptr-&gt;num_trans = 0;
1935       return;
1936    }
1937 
1938    /* TODO: this is a horrible side effect in the palette case because the
1939     * png_struct ends up with a pointer to the tRNS buffer owned by the
1940     * png_info.  Fix this.
1941     */
1942    png_set_tRNS(png_ptr, info_ptr, readbuf, png_ptr-&gt;num_trans,
1943        &amp;(png_ptr-&gt;trans_color));
1944 }
1945 #endif
1946 
1947 #ifdef PNG_READ_bKGD_SUPPORTED
1948 void /* PRIVATE */
1949 png_handle_bKGD(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
1950 {
1951    unsigned int truelen;
1952    png_byte buf[6];
1953    png_color_16 background;
1954 
1955    png_debug(1, &quot;in png_handle_bKGD&quot;);
1956 
1957    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
1958       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
1959 
1960    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0 ||
1961        (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE &amp;&amp;
1962        (png_ptr-&gt;mode &amp; PNG_HAVE_PLTE) == 0))
1963    {
1964       png_crc_finish(png_ptr, length);
1965       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
1966       return;
1967    }
1968 
1969    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_bKGD) != 0)
1970    {
1971       png_crc_finish(png_ptr, length);
1972       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
1973       return;
1974    }
1975 
1976    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
1977       truelen = 1;
1978 
1979    else if ((png_ptr-&gt;color_type &amp; PNG_COLOR_MASK_COLOR) != 0)
1980       truelen = 6;
1981 
1982    else
1983       truelen = 2;
1984 
1985    if (length != truelen)
1986    {
1987       png_crc_finish(png_ptr, length);
1988       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
1989       return;
1990    }
1991 
1992    png_crc_read(png_ptr, buf, truelen);
1993 
1994    if (png_crc_finish(png_ptr, 0) != 0)
1995       return;
1996 
1997    /* We convert the index value into RGB components so that we can allow
1998     * arbitrary RGB values for background when we have transparency, and
1999     * so it is easy to determine the RGB values of the background color
2000     * from the info_ptr struct.
2001     */
2002    if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
2003    {
2004       background.index = buf[0];
2005 
2006       if (info_ptr != NULL &amp;&amp; info_ptr-&gt;num_palette != 0)
2007       {
2008          if (buf[0] &gt;= info_ptr-&gt;num_palette)
2009          {
2010             png_chunk_benign_error(png_ptr, &quot;invalid index&quot;);
2011             return;
2012          }
2013 
2014          background.red = (png_uint_16)png_ptr-&gt;palette[buf[0]].red;
2015          background.green = (png_uint_16)png_ptr-&gt;palette[buf[0]].green;
2016          background.blue = (png_uint_16)png_ptr-&gt;palette[buf[0]].blue;
2017       }
2018 
2019       else
2020          background.red = background.green = background.blue = 0;
2021 
2022       background.gray = 0;
2023    }
2024 
2025    else if ((png_ptr-&gt;color_type &amp; PNG_COLOR_MASK_COLOR) == 0) /* GRAY */
2026    {
2027       if (png_ptr-&gt;bit_depth &lt;= 8)
2028       {
2029          if (buf[0] != 0 || buf[1] &gt;= (unsigned int)(1 &lt;&lt; png_ptr-&gt;bit_depth))
2030          {
2031             png_chunk_benign_error(png_ptr, &quot;invalid gray level&quot;);
2032             return;
2033          }
2034       }
2035 
2036       background.index = 0;
2037       background.red =
2038       background.green =
2039       background.blue =
2040       background.gray = png_get_uint_16(buf);
2041    }
2042 
2043    else
2044    {
2045       if (png_ptr-&gt;bit_depth &lt;= 8)
2046       {
2047          if (buf[0] != 0 || buf[2] != 0 || buf[4] != 0)
2048          {
2049             png_chunk_benign_error(png_ptr, &quot;invalid color&quot;);
2050             return;
2051          }
2052       }
2053 
2054       background.index = 0;
2055       background.red = png_get_uint_16(buf);
2056       background.green = png_get_uint_16(buf + 2);
2057       background.blue = png_get_uint_16(buf + 4);
2058       background.gray = 0;
2059    }
2060 
2061    png_set_bKGD(png_ptr, info_ptr, &amp;background);
2062 }
2063 #endif
2064 
2065 #ifdef PNG_READ_eXIf_SUPPORTED
2066 void /* PRIVATE */
2067 png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2068 {
2069    unsigned int i;
2070 
2071    png_debug(1, &quot;in png_handle_eXIf&quot;);
2072 
2073    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2074       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2075 
2076    if (length &lt; 2)
2077    {
2078       png_crc_finish(png_ptr, length);
2079       png_chunk_benign_error(png_ptr, &quot;too short&quot;);
2080       return;
2081    }
2082 
2083    else if (info_ptr == NULL || (info_ptr-&gt;valid &amp; PNG_INFO_eXIf) != 0)
2084    {
2085       png_crc_finish(png_ptr, length);
2086       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2087       return;
2088    }
2089 
2090    info_ptr-&gt;free_me |= PNG_FREE_EXIF;
2091 
2092    info_ptr-&gt;eXIf_buf = png_voidcast(png_bytep,
2093              png_malloc_warn(png_ptr, length));
2094 
2095    if (info_ptr-&gt;eXIf_buf == NULL)
2096    {
2097       png_crc_finish(png_ptr, length);
2098       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2099       return;
2100    }
2101 
2102    for (i = 0; i &lt; length; i++)
2103    {
2104       png_byte buf[1];
2105       png_crc_read(png_ptr, buf, 1);
2106       info_ptr-&gt;eXIf_buf[i] = buf[0];
2107       if (i == 1 &amp;&amp; buf[0] != &#39;M&#39; &amp;&amp; buf[0] != &#39;I&#39;
2108                  &amp;&amp; info_ptr-&gt;eXIf_buf[0] != buf[0])
2109       {
2110          png_crc_finish(png_ptr, length);
2111          png_chunk_benign_error(png_ptr, &quot;incorrect byte-order specifier&quot;);
2112          png_free(png_ptr, info_ptr-&gt;eXIf_buf);
2113          info_ptr-&gt;eXIf_buf = NULL;
2114          return;
2115       }
2116    }
2117 
2118    if (png_crc_finish(png_ptr, 0) != 0)
2119       return;
2120 
2121    png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr-&gt;eXIf_buf);
2122 
2123    png_free(png_ptr, info_ptr-&gt;eXIf_buf);
2124    info_ptr-&gt;eXIf_buf = NULL;
2125 }
2126 #endif
2127 
2128 #ifdef PNG_READ_hIST_SUPPORTED
2129 void /* PRIVATE */
2130 png_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2131 {
2132    unsigned int num, i;
2133    png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];
2134 
2135    png_debug(1, &quot;in png_handle_hIST&quot;);
2136 
2137    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2138       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2139 
2140    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0 ||
2141        (png_ptr-&gt;mode &amp; PNG_HAVE_PLTE) == 0)
2142    {
2143       png_crc_finish(png_ptr, length);
2144       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
2145       return;
2146    }
2147 
2148    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_hIST) != 0)
2149    {
2150       png_crc_finish(png_ptr, length);
2151       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2152       return;
2153    }
2154 
2155    num = length / 2 ;
2156 
2157    if (num != (unsigned int) png_ptr-&gt;num_palette ||
2158        num &gt; (unsigned int) PNG_MAX_PALETTE_LENGTH)
2159    {
2160       png_crc_finish(png_ptr, length);
2161       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2162       return;
2163    }
2164 
2165    for (i = 0; i &lt; num; i++)
2166    {
2167       png_byte buf[2];
2168 
2169       png_crc_read(png_ptr, buf, 2);
2170       readbuf[i] = png_get_uint_16(buf);
2171    }
2172 
2173    if (png_crc_finish(png_ptr, 0) != 0)
2174       return;
2175 
2176    png_set_hIST(png_ptr, info_ptr, readbuf);
2177 }
2178 #endif
2179 
2180 #ifdef PNG_READ_pHYs_SUPPORTED
2181 void /* PRIVATE */
2182 png_handle_pHYs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2183 {
2184    png_byte buf[9];
2185    png_uint_32 res_x, res_y;
2186    int unit_type;
2187 
2188    png_debug(1, &quot;in png_handle_pHYs&quot;);
2189 
2190    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2191       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2192 
2193    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2194    {
2195       png_crc_finish(png_ptr, length);
2196       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
2197       return;
2198    }
2199 
2200    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_pHYs) != 0)
2201    {
2202       png_crc_finish(png_ptr, length);
2203       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2204       return;
2205    }
2206 
2207    if (length != 9)
2208    {
2209       png_crc_finish(png_ptr, length);
2210       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2211       return;
2212    }
2213 
2214    png_crc_read(png_ptr, buf, 9);
2215 
2216    if (png_crc_finish(png_ptr, 0) != 0)
2217       return;
2218 
2219    res_x = png_get_uint_32(buf);
2220    res_y = png_get_uint_32(buf + 4);
2221    unit_type = buf[8];
2222    png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
2223 }
2224 #endif
2225 
2226 #ifdef PNG_READ_oFFs_SUPPORTED
2227 void /* PRIVATE */
2228 png_handle_oFFs(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2229 {
2230    png_byte buf[9];
2231    png_int_32 offset_x, offset_y;
2232    int unit_type;
2233 
2234    png_debug(1, &quot;in png_handle_oFFs&quot;);
2235 
2236    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2237       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2238 
2239    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2240    {
2241       png_crc_finish(png_ptr, length);
2242       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
2243       return;
2244    }
2245 
2246    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_oFFs) != 0)
2247    {
2248       png_crc_finish(png_ptr, length);
2249       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2250       return;
2251    }
2252 
2253    if (length != 9)
2254    {
2255       png_crc_finish(png_ptr, length);
2256       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2257       return;
2258    }
2259 
2260    png_crc_read(png_ptr, buf, 9);
2261 
2262    if (png_crc_finish(png_ptr, 0) != 0)
2263       return;
2264 
2265    offset_x = png_get_int_32(buf);
2266    offset_y = png_get_int_32(buf + 4);
2267    unit_type = buf[8];
2268    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
2269 }
2270 #endif
2271 
2272 #ifdef PNG_READ_pCAL_SUPPORTED
2273 /* Read the pCAL chunk (described in the PNG Extensions document) */
2274 void /* PRIVATE */
2275 png_handle_pCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2276 {
2277    png_int_32 X0, X1;
2278    png_byte type, nparams;
2279    png_bytep buffer, buf, units, endptr;
2280    png_charpp params;
2281    int i;
2282 
2283    png_debug(1, &quot;in png_handle_pCAL&quot;);
2284 
2285    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2286       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2287 
2288    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2289    {
2290       png_crc_finish(png_ptr, length);
2291       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
2292       return;
2293    }
2294 
2295    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_pCAL) != 0)
2296    {
2297       png_crc_finish(png_ptr, length);
2298       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2299       return;
2300    }
2301 
2302    png_debug1(2, &quot;Allocating and reading pCAL chunk data (%u bytes)&quot;,
2303        length + 1);
2304 
2305    buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);
2306 
2307    if (buffer == NULL)
2308    {
2309       png_crc_finish(png_ptr, length);
2310       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2311       return;
2312    }
2313 
2314    png_crc_read(png_ptr, buffer, length);
2315 
2316    if (png_crc_finish(png_ptr, 0) != 0)
2317       return;
2318 
2319    buffer[length] = 0; /* Null terminate the last string */
2320 
2321    png_debug(3, &quot;Finding end of pCAL purpose string&quot;);
2322    for (buf = buffer; *buf; buf++)
2323       /* Empty loop */ ;
2324 
2325    endptr = buffer + length;
2326 
2327    /* We need to have at least 12 bytes after the purpose string
2328     * in order to get the parameter information.
2329     */
2330    if (endptr - buf &lt;= 12)
2331    {
2332       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2333       return;
2334    }
2335 
2336    png_debug(3, &quot;Reading pCAL X0, X1, type, nparams, and units&quot;);
2337    X0 = png_get_int_32((png_bytep)buf+1);
2338    X1 = png_get_int_32((png_bytep)buf+5);
2339    type = buf[9];
2340    nparams = buf[10];
2341    units = buf + 11;
2342 
2343    png_debug(3, &quot;Checking pCAL equation type and number of parameters&quot;);
2344    /* Check that we have the right number of parameters for known
2345     * equation types.
2346     */
2347    if ((type == PNG_EQUATION_LINEAR &amp;&amp; nparams != 2) ||
2348        (type == PNG_EQUATION_BASE_E &amp;&amp; nparams != 3) ||
2349        (type == PNG_EQUATION_ARBITRARY &amp;&amp; nparams != 3) ||
2350        (type == PNG_EQUATION_HYPERBOLIC &amp;&amp; nparams != 4))
2351    {
2352       png_chunk_benign_error(png_ptr, &quot;invalid parameter count&quot;);
2353       return;
2354    }
2355 
2356    else if (type &gt;= PNG_EQUATION_LAST)
2357    {
2358       png_chunk_benign_error(png_ptr, &quot;unrecognized equation type&quot;);
2359    }
2360 
2361    for (buf = units; *buf; buf++)
2362       /* Empty loop to move past the units string. */ ;
2363 
2364    png_debug(3, &quot;Allocating pCAL parameters array&quot;);
2365 
2366    params = png_voidcast(png_charpp, png_malloc_warn(png_ptr,
2367        nparams * (sizeof (png_charp))));
2368 
2369    if (params == NULL)
2370    {
2371       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2372       return;
2373    }
2374 
2375    /* Get pointers to the start of each parameter string. */
2376    for (i = 0; i &lt; nparams; i++)
2377    {
2378       buf++; /* Skip the null string terminator from previous parameter. */
2379 
2380       png_debug1(3, &quot;Reading pCAL parameter %d&quot;, i);
2381 
2382       for (params[i] = (png_charp)buf; buf &lt;= endptr &amp;&amp; *buf != 0; buf++)
2383          /* Empty loop to move past each parameter string */ ;
2384 
2385       /* Make sure we haven&#39;t run out of data yet */
2386       if (buf &gt; endptr)
2387       {
2388          png_free(png_ptr, params);
2389          png_chunk_benign_error(png_ptr, &quot;invalid data&quot;);
2390          return;
2391       }
2392    }
2393 
2394    png_set_pCAL(png_ptr, info_ptr, (png_charp)buffer, X0, X1, type, nparams,
2395        (png_charp)units, params);
2396 
2397    png_free(png_ptr, params);
2398 }
2399 #endif
2400 
2401 #ifdef PNG_READ_sCAL_SUPPORTED
2402 /* Read the sCAL chunk */
2403 void /* PRIVATE */
2404 png_handle_sCAL(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2405 {
2406    png_bytep buffer;
2407    size_t i;
2408    int state;
2409 
2410    png_debug(1, &quot;in png_handle_sCAL&quot;);
2411 
2412    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2413       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2414 
2415    else if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2416    {
2417       png_crc_finish(png_ptr, length);
2418       png_chunk_benign_error(png_ptr, &quot;out of place&quot;);
2419       return;
2420    }
2421 
2422    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_sCAL) != 0)
2423    {
2424       png_crc_finish(png_ptr, length);
2425       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2426       return;
2427    }
2428 
2429    /* Need unit type, width, \0, height: minimum 4 bytes */
2430    else if (length &lt; 4)
2431    {
2432       png_crc_finish(png_ptr, length);
2433       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2434       return;
2435    }
2436 
2437    png_debug1(2, &quot;Allocating and reading sCAL chunk data (%u bytes)&quot;,
2438        length + 1);
2439 
2440    buffer = png_read_buffer(png_ptr, length+1, 2/*silent*/);
2441 
2442    if (buffer == NULL)
2443    {
2444       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2445       png_crc_finish(png_ptr, length);
2446       return;
2447    }
2448 
2449    png_crc_read(png_ptr, buffer, length);
2450    buffer[length] = 0; /* Null terminate the last string */
2451 
2452    if (png_crc_finish(png_ptr, 0) != 0)
2453       return;
2454 
2455    /* Validate the unit. */
2456    if (buffer[0] != 1 &amp;&amp; buffer[0] != 2)
2457    {
2458       png_chunk_benign_error(png_ptr, &quot;invalid unit&quot;);
2459       return;
2460    }
2461 
2462    /* Validate the ASCII numbers, need two ASCII numbers separated by
2463     * a &#39;\0&#39; and they need to fit exactly in the chunk data.
2464     */
2465    i = 1;
2466    state = 0;
2467 
2468    if (png_check_fp_number((png_const_charp)buffer, length, &amp;state, &amp;i) == 0 ||
2469        i &gt;= length || buffer[i++] != 0)
2470       png_chunk_benign_error(png_ptr, &quot;bad width format&quot;);
2471 
2472    else if (PNG_FP_IS_POSITIVE(state) == 0)
2473       png_chunk_benign_error(png_ptr, &quot;non-positive width&quot;);
2474 
2475    else
2476    {
2477       size_t heighti = i;
2478 
2479       state = 0;
2480       if (png_check_fp_number((png_const_charp)buffer, length,
2481           &amp;state, &amp;i) == 0 || i != length)
2482          png_chunk_benign_error(png_ptr, &quot;bad height format&quot;);
2483 
2484       else if (PNG_FP_IS_POSITIVE(state) == 0)
2485          png_chunk_benign_error(png_ptr, &quot;non-positive height&quot;);
2486 
2487       else
2488          /* This is the (only) success case. */
2489          png_set_sCAL_s(png_ptr, info_ptr, buffer[0],
2490              (png_charp)buffer+1, (png_charp)buffer+heighti);
2491    }
2492 }
2493 #endif
2494 
2495 #ifdef PNG_READ_tIME_SUPPORTED
2496 void /* PRIVATE */
2497 png_handle_tIME(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2498 {
2499    png_byte buf[7];
2500    png_time mod_time;
2501 
2502    png_debug(1, &quot;in png_handle_tIME&quot;);
2503 
2504    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2505       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2506 
2507    else if (info_ptr != NULL &amp;&amp; (info_ptr-&gt;valid &amp; PNG_INFO_tIME) != 0)
2508    {
2509       png_crc_finish(png_ptr, length);
2510       png_chunk_benign_error(png_ptr, &quot;duplicate&quot;);
2511       return;
2512    }
2513 
2514    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2515       png_ptr-&gt;mode |= PNG_AFTER_IDAT;
2516 
2517    if (length != 7)
2518    {
2519       png_crc_finish(png_ptr, length);
2520       png_chunk_benign_error(png_ptr, &quot;invalid&quot;);
2521       return;
2522    }
2523 
2524    png_crc_read(png_ptr, buf, 7);
2525 
2526    if (png_crc_finish(png_ptr, 0) != 0)
2527       return;
2528 
2529    mod_time.second = buf[6];
2530    mod_time.minute = buf[5];
2531    mod_time.hour = buf[4];
2532    mod_time.day = buf[3];
2533    mod_time.month = buf[2];
2534    mod_time.year = png_get_uint_16(buf);
2535 
2536    png_set_tIME(png_ptr, info_ptr, &amp;mod_time);
2537 }
2538 #endif
2539 
2540 #ifdef PNG_READ_tEXt_SUPPORTED
2541 /* Note: this does not properly handle chunks that are &gt; 64K under DOS */
2542 void /* PRIVATE */
2543 png_handle_tEXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2544 {
2545    png_text  text_info;
2546    png_bytep buffer;
2547    png_charp key;
2548    png_charp text;
2549    png_uint_32 skip = 0;
2550 
2551    png_debug(1, &quot;in png_handle_tEXt&quot;);
2552 
2553 #ifdef PNG_USER_LIMITS_SUPPORTED
2554    if (png_ptr-&gt;user_chunk_cache_max != 0)
2555    {
2556       if (png_ptr-&gt;user_chunk_cache_max == 1)
2557       {
2558          png_crc_finish(png_ptr, length);
2559          return;
2560       }
2561 
2562       if (--png_ptr-&gt;user_chunk_cache_max == 1)
2563       {
2564          png_crc_finish(png_ptr, length);
2565          png_chunk_benign_error(png_ptr, &quot;no space in chunk cache&quot;);
2566          return;
2567       }
2568    }
2569 #endif
2570 
2571    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2572       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2573 
2574    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2575       png_ptr-&gt;mode |= PNG_AFTER_IDAT;
2576 
2577 #ifdef PNG_MAX_MALLOC_64K
2578    if (length &gt; 65535U)
2579    {
2580       png_crc_finish(png_ptr, length);
2581       png_chunk_benign_error(png_ptr, &quot;too large to fit in memory&quot;);
2582       return;
2583    }
2584 #endif
2585 
2586    buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);
2587 
2588    if (buffer == NULL)
2589    {
2590       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2591       return;
2592    }
2593 
2594    png_crc_read(png_ptr, buffer, length);
2595 
2596    if (png_crc_finish(png_ptr, skip) != 0)
2597       return;
2598 
2599    key = (png_charp)buffer;
2600    key[length] = 0;
2601 
2602    for (text = key; *text; text++)
2603       /* Empty loop to find end of key */ ;
2604 
2605    if (text != key + length)
2606       text++;
2607 
2608    text_info.compression = PNG_TEXT_COMPRESSION_NONE;
2609    text_info.key = key;
2610    text_info.lang = NULL;
2611    text_info.lang_key = NULL;
2612    text_info.itxt_length = 0;
2613    text_info.text = text;
2614    text_info.text_length = strlen(text);
2615 
2616    if (png_set_text_2(png_ptr, info_ptr, &amp;text_info, 1) != 0)
2617       png_warning(png_ptr, &quot;Insufficient memory to process text chunk&quot;);
2618 }
2619 #endif
2620 
2621 #ifdef PNG_READ_zTXt_SUPPORTED
2622 /* Note: this does not correctly handle chunks that are &gt; 64K under DOS */
2623 void /* PRIVATE */
2624 png_handle_zTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2625 {
2626    png_const_charp errmsg = NULL;
2627    png_bytep       buffer;
2628    png_uint_32     keyword_length;
2629 
2630    png_debug(1, &quot;in png_handle_zTXt&quot;);
2631 
2632 #ifdef PNG_USER_LIMITS_SUPPORTED
2633    if (png_ptr-&gt;user_chunk_cache_max != 0)
2634    {
2635       if (png_ptr-&gt;user_chunk_cache_max == 1)
2636       {
2637          png_crc_finish(png_ptr, length);
2638          return;
2639       }
2640 
2641       if (--png_ptr-&gt;user_chunk_cache_max == 1)
2642       {
2643          png_crc_finish(png_ptr, length);
2644          png_chunk_benign_error(png_ptr, &quot;no space in chunk cache&quot;);
2645          return;
2646       }
2647    }
2648 #endif
2649 
2650    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2651       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2652 
2653    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2654       png_ptr-&gt;mode |= PNG_AFTER_IDAT;
2655 
2656    /* Note, &quot;length&quot; is sufficient here; we won&#39;t be adding
2657     * a null terminator later.
2658     */
2659    buffer = png_read_buffer(png_ptr, length, 2/*silent*/);
2660 
2661    if (buffer == NULL)
2662    {
2663       png_crc_finish(png_ptr, length);
2664       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2665       return;
2666    }
2667 
2668    png_crc_read(png_ptr, buffer, length);
2669 
2670    if (png_crc_finish(png_ptr, 0) != 0)
2671       return;
2672 
2673    /* TODO: also check that the keyword contents match the spec! */
2674    for (keyword_length = 0;
2675       keyword_length &lt; length &amp;&amp; buffer[keyword_length] != 0;
2676       ++keyword_length)
2677       /* Empty loop to find end of name */ ;
2678 
2679    if (keyword_length &gt; 79 || keyword_length &lt; 1)
2680       errmsg = &quot;bad keyword&quot;;
2681 
2682    /* zTXt must have some LZ data after the keyword, although it may expand to
2683     * zero bytes; we need a &#39;\0&#39; at the end of the keyword, the compression type
2684     * then the LZ data:
2685     */
2686    else if (keyword_length + 3 &gt; length)
2687       errmsg = &quot;truncated&quot;;
2688 
2689    else if (buffer[keyword_length+1] != PNG_COMPRESSION_TYPE_BASE)
2690       errmsg = &quot;unknown compression type&quot;;
2691 
2692    else
2693    {
2694       png_alloc_size_t uncompressed_length = PNG_SIZE_MAX;
2695 
2696       /* TODO: at present png_decompress_chunk imposes a single application
2697        * level memory limit, this should be split to different values for iCCP
2698        * and text chunks.
2699        */
2700       if (png_decompress_chunk(png_ptr, length, keyword_length+2,
2701           &amp;uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
2702       {
2703          png_text text;
2704 
2705          if (png_ptr-&gt;read_buffer == NULL)
2706            errmsg=&quot;Read failure in png_handle_zTXt&quot;;
2707          else
2708          {
2709             /* It worked; png_ptr-&gt;read_buffer now looks like a tEXt chunk
2710              * except for the extra compression type byte and the fact that
2711              * it isn&#39;t necessarily &#39;\0&#39; terminated.
2712              */
2713             buffer = png_ptr-&gt;read_buffer;
2714             buffer[uncompressed_length+(keyword_length+2)] = 0;
2715 
2716             text.compression = PNG_TEXT_COMPRESSION_zTXt;
2717             text.key = (png_charp)buffer;
2718             text.text = (png_charp)(buffer + keyword_length+2);
2719             text.text_length = uncompressed_length;
2720             text.itxt_length = 0;
2721             text.lang = NULL;
2722             text.lang_key = NULL;
2723 
2724             if (png_set_text_2(png_ptr, info_ptr, &amp;text, 1) != 0)
2725                errmsg = &quot;insufficient memory&quot;;
2726          }
2727       }
2728 
2729       else
2730          errmsg = png_ptr-&gt;zstream.msg;
2731    }
2732 
2733    if (errmsg != NULL)
2734       png_chunk_benign_error(png_ptr, errmsg);
2735 }
2736 #endif
2737 
2738 #ifdef PNG_READ_iTXt_SUPPORTED
2739 /* Note: this does not correctly handle chunks that are &gt; 64K under DOS */
2740 void /* PRIVATE */
2741 png_handle_iTXt(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)
2742 {
2743    png_const_charp errmsg = NULL;
2744    png_bytep buffer;
2745    png_uint_32 prefix_length;
2746 
2747    png_debug(1, &quot;in png_handle_iTXt&quot;);
2748 
2749 #ifdef PNG_USER_LIMITS_SUPPORTED
2750    if (png_ptr-&gt;user_chunk_cache_max != 0)
2751    {
2752       if (png_ptr-&gt;user_chunk_cache_max == 1)
2753       {
2754          png_crc_finish(png_ptr, length);
2755          return;
2756       }
2757 
2758       if (--png_ptr-&gt;user_chunk_cache_max == 1)
2759       {
2760          png_crc_finish(png_ptr, length);
2761          png_chunk_benign_error(png_ptr, &quot;no space in chunk cache&quot;);
2762          return;
2763       }
2764    }
2765 #endif
2766 
2767    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IHDR) == 0)
2768       png_chunk_error(png_ptr, &quot;missing IHDR&quot;);
2769 
2770    if ((png_ptr-&gt;mode &amp; PNG_HAVE_IDAT) != 0)
2771       png_ptr-&gt;mode |= PNG_AFTER_IDAT;
2772 
2773    buffer = png_read_buffer(png_ptr, length+1, 1/*warn*/);
2774 
2775    if (buffer == NULL)
2776    {
2777       png_crc_finish(png_ptr, length);
2778       png_chunk_benign_error(png_ptr, &quot;out of memory&quot;);
2779       return;
2780    }
2781 
2782    png_crc_read(png_ptr, buffer, length);
2783 
2784    if (png_crc_finish(png_ptr, 0) != 0)
2785       return;
2786 
2787    /* First the keyword. */
2788    for (prefix_length=0;
2789       prefix_length &lt; length &amp;&amp; buffer[prefix_length] != 0;
2790       ++prefix_length)
2791       /* Empty loop */ ;
2792 
2793    /* Perform a basic check on the keyword length here. */
2794    if (prefix_length &gt; 79 || prefix_length &lt; 1)
2795       errmsg = &quot;bad keyword&quot;;
2796 
2797    /* Expect keyword, compression flag, compression type, language, translated
2798     * keyword (both may be empty but are 0 terminated) then the text, which may
2799     * be empty.
2800     */
2801    else if (prefix_length + 5 &gt; length)
2802       errmsg = &quot;truncated&quot;;
2803 
2804    else if (buffer[prefix_length+1] == 0 ||
2805       (buffer[prefix_length+1] == 1 &amp;&amp;
2806       buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
2807    {
2808       int compressed = buffer[prefix_length+1] != 0;
2809       png_uint_32 language_offset, translated_keyword_offset;
2810       png_alloc_size_t uncompressed_length = 0;
2811 
2812       /* Now the language tag */
2813       prefix_length += 3;
2814       language_offset = prefix_length;
2815 
2816       for (; prefix_length &lt; length &amp;&amp; buffer[prefix_length] != 0;
2817          ++prefix_length)
2818          /* Empty loop */ ;
2819 
2820       /* WARNING: the length may be invalid here, this is checked below. */
2821       translated_keyword_offset = ++prefix_length;
2822 
2823       for (; prefix_length &lt; length &amp;&amp; buffer[prefix_length] != 0;
2824          ++prefix_length)
2825          /* Empty loop */ ;
2826 
2827       /* prefix_length should now be at the trailing &#39;\0&#39; of the translated
2828        * keyword, but it may already be over the end.  None of this arithmetic
2829        * can overflow because chunks are at most 2^31 bytes long, but on 16-bit
2830        * systems the available allocation may overflow.
2831        */
2832       ++prefix_length;
2833 
2834       if (compressed == 0 &amp;&amp; prefix_length &lt;= length)
2835          uncompressed_length = length - prefix_length;
2836 
2837       else if (compressed != 0 &amp;&amp; prefix_length &lt; length)
2838       {
2839          uncompressed_length = PNG_SIZE_MAX;
2840 
2841          /* TODO: at present png_decompress_chunk imposes a single application
2842           * level memory limit, this should be split to different values for
2843           * iCCP and text chunks.
2844           */
2845          if (png_decompress_chunk(png_ptr, length, prefix_length,
2846              &amp;uncompressed_length, 1/*terminate*/) == Z_STREAM_END)
2847             buffer = png_ptr-&gt;read_buffer;
2848 
2849          else
2850             errmsg = png_ptr-&gt;zstream.msg;
2851       }
2852 
2853       else
2854          errmsg = &quot;truncated&quot;;
2855 
2856       if (errmsg == NULL)
2857       {
2858          png_text text;
2859 
2860          buffer[uncompressed_length+prefix_length] = 0;
2861 
2862          if (compressed == 0)
2863             text.compression = PNG_ITXT_COMPRESSION_NONE;
2864 
2865          else
2866             text.compression = PNG_ITXT_COMPRESSION_zTXt;
2867 
2868          text.key = (png_charp)buffer;
2869          text.lang = (png_charp)buffer + language_offset;
2870          text.lang_key = (png_charp)buffer + translated_keyword_offset;
2871          text.text = (png_charp)buffer + prefix_length;
2872          text.text_length = 0;
2873          text.itxt_length = uncompressed_length;
2874 
2875          if (png_set_text_2(png_ptr, info_ptr, &amp;text, 1) != 0)
2876             errmsg = &quot;insufficient memory&quot;;
2877       }
2878    }
2879 
2880    else
2881       errmsg = &quot;bad compression info&quot;;
2882 
2883    if (errmsg != NULL)
2884       png_chunk_benign_error(png_ptr, errmsg);
2885 }
2886 #endif
2887 
2888 #ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
2889 /* Utility function for png_handle_unknown; set up png_ptr::unknown_chunk */
2890 static int
2891 png_cache_unknown_chunk(png_structrp png_ptr, png_uint_32 length)
2892 {
2893    png_alloc_size_t limit = PNG_SIZE_MAX;
2894 
2895    if (png_ptr-&gt;unknown_chunk.data != NULL)
2896    {
2897       png_free(png_ptr, png_ptr-&gt;unknown_chunk.data);
2898       png_ptr-&gt;unknown_chunk.data = NULL;
2899    }
2900 
2901 #  ifdef PNG_SET_USER_LIMITS_SUPPORTED
2902    if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
2903        png_ptr-&gt;user_chunk_malloc_max &lt; limit)
2904       limit = png_ptr-&gt;user_chunk_malloc_max;
2905 
2906 #  elif PNG_USER_CHUNK_MALLOC_MAX &gt; 0
2907    if (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
2908       limit = PNG_USER_CHUNK_MALLOC_MAX;
2909 #  endif
2910 
2911    if (length &lt;= limit)
2912    {
2913       PNG_CSTRING_FROM_CHUNK(png_ptr-&gt;unknown_chunk.name, png_ptr-&gt;chunk_name);
2914       /* The following is safe because of the PNG_SIZE_MAX init above */
2915       png_ptr-&gt;unknown_chunk.size = (size_t)length/*SAFE*/;
2916       /* &#39;mode&#39; is a flag array, only the bottom four bits matter here */
2917       png_ptr-&gt;unknown_chunk.location = (png_byte)png_ptr-&gt;mode/*SAFE*/;
2918 
2919       if (length == 0)
2920          png_ptr-&gt;unknown_chunk.data = NULL;
2921 
2922       else
2923       {
2924          /* Do a &#39;warn&#39; here - it is handled below. */
2925          png_ptr-&gt;unknown_chunk.data = png_voidcast(png_bytep,
2926              png_malloc_warn(png_ptr, length));
2927       }
2928    }
2929 
2930    if (png_ptr-&gt;unknown_chunk.data == NULL &amp;&amp; length &gt; 0)
2931    {
2932       /* This is benign because we clean up correctly */
2933       png_crc_finish(png_ptr, length);
2934       png_chunk_benign_error(png_ptr, &quot;unknown chunk exceeds memory limits&quot;);
2935       return 0;
2936    }
2937 
2938    else
2939    {
2940       if (length &gt; 0)
2941          png_crc_read(png_ptr, png_ptr-&gt;unknown_chunk.data, length);
2942       png_crc_finish(png_ptr, 0);
2943       return 1;
2944    }
2945 }
2946 #endif /* READ_UNKNOWN_CHUNKS */
2947 
2948 /* Handle an unknown, or known but disabled, chunk */
2949 void /* PRIVATE */
2950 png_handle_unknown(png_structrp png_ptr, png_inforp info_ptr,
2951     png_uint_32 length, int keep)
2952 {
2953    int handled = 0; /* the chunk was handled */
2954 
2955    png_debug(1, &quot;in png_handle_unknown&quot;);
2956 
2957 #ifdef PNG_READ_UNKNOWN_CHUNKS_SUPPORTED
2958    /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
2959     * the bug which meant that setting a non-default behavior for a specific
2960     * chunk would be ignored (the default was always used unless a user
2961     * callback was installed).
2962     *
2963     * &#39;keep&#39; is the value from the png_chunk_unknown_handling, the setting for
2964     * this specific chunk_name, if PNG_HANDLE_AS_UNKNOWN_SUPPORTED, if not it
2965     * will always be PNG_HANDLE_CHUNK_AS_DEFAULT and it needs to be set here.
2966     * This is just an optimization to avoid multiple calls to the lookup
2967     * function.
2968     */
2969 #  ifndef PNG_HANDLE_AS_UNKNOWN_SUPPORTED
2970 #     ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
2971    keep = png_chunk_unknown_handling(png_ptr, png_ptr-&gt;chunk_name);
2972 #     endif
2973 #  endif
2974 
2975    /* One of the following methods will read the chunk or skip it (at least one
2976     * of these is always defined because this is the only way to switch on
2977     * PNG_READ_UNKNOWN_CHUNKS_SUPPORTED)
2978     */
2979 #  ifdef PNG_READ_USER_CHUNKS_SUPPORTED
2980    /* The user callback takes precedence over the chunk keep value, but the
2981     * keep value is still required to validate a save of a critical chunk.
2982     */
2983    if (png_ptr-&gt;read_user_chunk_fn != NULL)
2984    {
2985       if (png_cache_unknown_chunk(png_ptr, length) != 0)
2986       {
2987          /* Callback to user unknown chunk handler */
2988          int ret = (*(png_ptr-&gt;read_user_chunk_fn))(png_ptr,
2989              &amp;png_ptr-&gt;unknown_chunk);
2990 
2991          /* ret is:
2992           * negative: An error occurred; png_chunk_error will be called.
2993           *     zero: The chunk was not handled, the chunk will be discarded
2994           *           unless png_set_keep_unknown_chunks has been used to set
2995           *           a &#39;keep&#39; behavior for this particular chunk, in which
2996           *           case that will be used.  A critical chunk will cause an
2997           *           error at this point unless it is to be saved.
2998           * positive: The chunk was handled, libpng will ignore/discard it.
2999           */
3000          if (ret &lt; 0)
3001             png_chunk_error(png_ptr, &quot;error in user chunk&quot;);
3002 
3003          else if (ret == 0)
3004          {
3005             /* If the keep value is &#39;default&#39; or &#39;never&#39; override it, but
3006              * still error out on critical chunks unless the keep value is
3007              * &#39;always&#39;  While this is weird it is the behavior in 1.4.12.
3008              * A possible improvement would be to obey the value set for the
3009              * chunk, but this would be an API change that would probably
3010              * damage some applications.
3011              *
3012              * The png_app_warning below catches the case that matters, where
3013              * the application has not set specific save or ignore for this
3014              * chunk or global save or ignore.
3015              */
3016             if (keep &lt; PNG_HANDLE_CHUNK_IF_SAFE)
3017             {
3018 #              ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
3019                if (png_ptr-&gt;unknown_default &lt; PNG_HANDLE_CHUNK_IF_SAFE)
3020                {
3021                   png_chunk_warning(png_ptr, &quot;Saving unknown chunk:&quot;);
3022                   png_app_warning(png_ptr,
3023                       &quot;forcing save of an unhandled chunk;&quot;
3024                       &quot; please call png_set_keep_unknown_chunks&quot;);
3025                       /* with keep = PNG_HANDLE_CHUNK_IF_SAFE */
3026                }
3027 #              endif
3028                keep = PNG_HANDLE_CHUNK_IF_SAFE;
3029             }
3030          }
3031 
3032          else /* chunk was handled */
3033          {
3034             handled = 1;
3035             /* Critical chunks can be safely discarded at this point. */
3036             keep = PNG_HANDLE_CHUNK_NEVER;
3037          }
3038       }
3039 
3040       else
3041          keep = PNG_HANDLE_CHUNK_NEVER; /* insufficient memory */
3042    }
3043 
3044    else
3045    /* Use the SAVE_UNKNOWN_CHUNKS code or skip the chunk */
3046 #  endif /* READ_USER_CHUNKS */
3047 
3048 #  ifdef PNG_SAVE_UNKNOWN_CHUNKS_SUPPORTED
3049    {
3050       /* keep is currently just the per-chunk setting, if there was no
3051        * setting change it to the global default now (not that this may
3052        * still be AS_DEFAULT) then obtain the cache of the chunk if required,
3053        * if not simply skip the chunk.
3054        */
3055       if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
3056          keep = png_ptr-&gt;unknown_default;
3057 
3058       if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
3059          (keep == PNG_HANDLE_CHUNK_IF_SAFE &amp;&amp;
3060           PNG_CHUNK_ANCILLARY(png_ptr-&gt;chunk_name)))
3061       {
3062          if (png_cache_unknown_chunk(png_ptr, length) == 0)
3063             keep = PNG_HANDLE_CHUNK_NEVER;
3064       }
3065 
3066       else
3067          png_crc_finish(png_ptr, length);
3068    }
3069 #  else
3070 #     ifndef PNG_READ_USER_CHUNKS_SUPPORTED
3071 #        error no method to support READ_UNKNOWN_CHUNKS
3072 #     endif
3073 
3074    {
3075       /* If here there is no read callback pointer set and no support is
3076        * compiled in to just save the unknown chunks, so simply skip this
3077        * chunk.  If &#39;keep&#39; is something other than AS_DEFAULT or NEVER then
3078        * the app has erroneously asked for unknown chunk saving when there
3079        * is no support.
3080        */
3081       if (keep &gt; PNG_HANDLE_CHUNK_NEVER)
3082          png_app_error(png_ptr, &quot;no unknown chunk support available&quot;);
3083 
3084       png_crc_finish(png_ptr, length);
3085    }
3086 #  endif
3087 
3088 #  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
3089    /* Now store the chunk in the chunk list if appropriate, and if the limits
3090     * permit it.
3091     */
3092    if (keep == PNG_HANDLE_CHUNK_ALWAYS ||
3093       (keep == PNG_HANDLE_CHUNK_IF_SAFE &amp;&amp;
3094        PNG_CHUNK_ANCILLARY(png_ptr-&gt;chunk_name)))
3095    {
3096 #     ifdef PNG_USER_LIMITS_SUPPORTED
3097       switch (png_ptr-&gt;user_chunk_cache_max)
3098       {
3099          case 2:
3100             png_ptr-&gt;user_chunk_cache_max = 1;
3101             png_chunk_benign_error(png_ptr, &quot;no space in chunk cache&quot;);
3102             /* FALLTHROUGH */
3103          case 1:
3104             /* NOTE: prior to 1.6.0 this case resulted in an unknown critical
3105              * chunk being skipped, now there will be a hard error below.
3106              */
3107             break;
3108 
3109          default: /* not at limit */
3110             --(png_ptr-&gt;user_chunk_cache_max);
3111             /* FALLTHROUGH */
3112          case 0: /* no limit */
3113 #  endif /* USER_LIMITS */
3114             /* Here when the limit isn&#39;t reached or when limits are compiled
3115              * out; store the chunk.
3116              */
3117             png_set_unknown_chunks(png_ptr, info_ptr,
3118                 &amp;png_ptr-&gt;unknown_chunk, 1);
3119             handled = 1;
3120 #  ifdef PNG_USER_LIMITS_SUPPORTED
3121             break;
3122       }
3123 #  endif
3124    }
3125 #  else /* no store support: the chunk must be handled by the user callback */
3126    PNG_UNUSED(info_ptr)
3127 #  endif
3128 
3129    /* Regardless of the error handling below the cached data (if any) can be
3130     * freed now.  Notice that the data is not freed if there is a png_error, but
3131     * it will be freed by destroy_read_struct.
3132     */
3133    if (png_ptr-&gt;unknown_chunk.data != NULL)
3134       png_free(png_ptr, png_ptr-&gt;unknown_chunk.data);
3135    png_ptr-&gt;unknown_chunk.data = NULL;
3136 
3137 #else /* !PNG_READ_UNKNOWN_CHUNKS_SUPPORTED */
3138    /* There is no support to read an unknown chunk, so just skip it. */
3139    png_crc_finish(png_ptr, length);
3140    PNG_UNUSED(info_ptr)
3141    PNG_UNUSED(keep)
3142 #endif /* !READ_UNKNOWN_CHUNKS */
3143 
3144    /* Check for unhandled critical chunks */
3145    if (handled == 0 &amp;&amp; PNG_CHUNK_CRITICAL(png_ptr-&gt;chunk_name))
3146       png_chunk_error(png_ptr, &quot;unhandled critical chunk&quot;);
3147 }
3148 
3149 /* This function is called to verify that a chunk name is valid.
3150  * This function can&#39;t have the &quot;critical chunk check&quot; incorporated
3151  * into it, since in the future we will need to be able to call user
3152  * functions to handle unknown critical chunks after we check that
3153  * the chunk name itself is valid.
3154  */
3155 
3156 /* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
3157  *
3158  * ((c) &lt; 65 || (c) &gt; 122 || ((c) &gt; 90 &amp;&amp; (c) &lt; 97))
3159  */
3160 
3161 void /* PRIVATE */
3162 png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)
3163 {
3164    int i;
3165    png_uint_32 cn=chunk_name;
3166 
3167    png_debug(1, &quot;in png_check_chunk_name&quot;);
3168 
3169    for (i=1; i&lt;=4; ++i)
3170    {
3171       int c = cn &amp; 0xff;
3172 
3173       if (c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97))
3174          png_chunk_error(png_ptr, &quot;invalid chunk type&quot;);
3175 
3176       cn &gt;&gt;= 8;
3177    }
3178 }
3179 
3180 void /* PRIVATE */
3181 png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)
3182 {
3183    png_alloc_size_t limit = PNG_UINT_31_MAX;
3184 
3185 # ifdef PNG_SET_USER_LIMITS_SUPPORTED
3186    if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
3187        png_ptr-&gt;user_chunk_malloc_max &lt; limit)
3188       limit = png_ptr-&gt;user_chunk_malloc_max;
3189 # elif PNG_USER_CHUNK_MALLOC_MAX &gt; 0
3190    if (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
3191       limit = PNG_USER_CHUNK_MALLOC_MAX;
3192 # endif
3193    if (png_ptr-&gt;chunk_name == png_IDAT)
3194    {
3195       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
3196       size_t row_factor =
3197          (size_t)png_ptr-&gt;width
3198          * (size_t)png_ptr-&gt;channels
3199          * (png_ptr-&gt;bit_depth &gt; 8? 2: 1)
3200          + 1
3201          + (png_ptr-&gt;interlaced? 6: 0);
3202       if (png_ptr-&gt;height &gt; PNG_UINT_32_MAX/row_factor)
3203          idat_limit = PNG_UINT_31_MAX;
3204       else
3205          idat_limit = png_ptr-&gt;height * row_factor;
3206       row_factor = row_factor &gt; 32566? 32566 : row_factor;
3207       idat_limit += 6 + 5*(idat_limit/row_factor+1); /* zlib+deflate overhead */
3208       idat_limit=idat_limit &lt; PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;
3209       limit = limit &lt; idat_limit? idat_limit : limit;
3210    }
3211 
3212    if (length &gt; limit)
3213    {
3214       png_debug2(0,&quot; length = %lu, limit = %lu&quot;,
3215          (unsigned long)length,(unsigned long)limit);
3216       png_chunk_error(png_ptr, &quot;chunk data is too large&quot;);
3217    }
3218 }
3219 
3220 /* Combines the row recently read in with the existing pixels in the row.  This
3221  * routine takes care of alpha and transparency if requested.  This routine also
3222  * handles the two methods of progressive display of interlaced images,
3223  * depending on the &#39;display&#39; value; if &#39;display&#39; is true then the whole row
3224  * (dp) is filled from the start by replicating the available pixels.  If
3225  * &#39;display&#39; is false only those pixels present in the pass are filled in.
3226  */
3227 void /* PRIVATE */
3228 png_combine_row(png_const_structrp png_ptr, png_bytep dp, int display)
3229 {
3230    unsigned int pixel_depth = png_ptr-&gt;transformed_pixel_depth;
3231    png_const_bytep sp = png_ptr-&gt;row_buf + 1;
3232    png_alloc_size_t row_width = png_ptr-&gt;width;
3233    unsigned int pass = png_ptr-&gt;pass;
3234    png_bytep end_ptr = 0;
3235    png_byte end_byte = 0;
3236    unsigned int end_mask;
3237 
3238    png_debug(1, &quot;in png_combine_row&quot;);
3239 
3240    /* Added in 1.5.6: it should not be possible to enter this routine until at
3241     * least one row has been read from the PNG data and transformed.
3242     */
3243    if (pixel_depth == 0)
3244       png_error(png_ptr, &quot;internal row logic error&quot;);
3245 
3246    /* Added in 1.5.4: the pixel depth should match the information returned by
3247     * any call to png_read_update_info at this point.  Do not continue if we got
3248     * this wrong.
3249     */
3250    if (png_ptr-&gt;info_rowbytes != 0 &amp;&amp; png_ptr-&gt;info_rowbytes !=
3251           PNG_ROWBYTES(pixel_depth, row_width))
3252       png_error(png_ptr, &quot;internal row size calculation error&quot;);
3253 
3254    /* Don&#39;t expect this to ever happen: */
3255    if (row_width == 0)
3256       png_error(png_ptr, &quot;internal row width error&quot;);
3257 
3258    /* Preserve the last byte in cases where only part of it will be overwritten,
3259     * the multiply below may overflow, we don&#39;t care because ANSI-C guarantees
3260     * we get the low bits.
3261     */
3262    end_mask = (pixel_depth * row_width) &amp; 7;
3263    if (end_mask != 0)
3264    {
3265       /* end_ptr == NULL is a flag to say do nothing */
3266       end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
3267       end_byte = *end_ptr;
3268 #     ifdef PNG_READ_PACKSWAP_SUPPORTED
3269       if ((png_ptr-&gt;transformations &amp; PNG_PACKSWAP) != 0)
3270          /* little-endian byte */
3271          end_mask = (unsigned int)(0xff &lt;&lt; end_mask);
3272 
3273       else /* big-endian byte */
3274 #     endif
3275       end_mask = 0xff &gt;&gt; end_mask;
3276       /* end_mask is now the bits to *keep* from the destination row */
3277    }
3278 
3279    /* For non-interlaced images this reduces to a memcpy(). A memcpy()
3280     * will also happen if interlacing isn&#39;t supported or if the application
3281     * does not call png_set_interlace_handling().  In the latter cases the
3282     * caller just gets a sequence of the unexpanded rows from each interlace
3283     * pass.
3284     */
3285 #ifdef PNG_READ_INTERLACING_SUPPORTED
3286    if (png_ptr-&gt;interlaced != 0 &amp;&amp;
3287        (png_ptr-&gt;transformations &amp; PNG_INTERLACE) != 0 &amp;&amp;
3288        pass &lt; 6 &amp;&amp; (display == 0 ||
3289        /* The following copies everything for &#39;display&#39; on passes 0, 2 and 4. */
3290        (display == 1 &amp;&amp; (pass &amp; 1) != 0)))
3291    {
3292       /* Narrow images may have no bits in a pass; the caller should handle
3293        * this, but this test is cheap:
3294        */
3295       if (row_width &lt;= PNG_PASS_START_COL(pass))
3296          return;
3297 
3298       if (pixel_depth &lt; 8)
3299       {
3300          /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
3301           * into 32 bits, then a single loop over the bytes using the four byte
3302           * values in the 32-bit mask can be used.  For the &#39;display&#39; option the
3303           * expanded mask may also not require any masking within a byte.  To
3304           * make this work the PACKSWAP option must be taken into account - it
3305           * simply requires the pixels to be reversed in each byte.
3306           *
3307           * The &#39;regular&#39; case requires a mask for each of the first 6 passes,
3308           * the &#39;display&#39; case does a copy for the even passes in the range
3309           * 0..6.  This has already been handled in the test above.
3310           *
3311           * The masks are arranged as four bytes with the first byte to use in
3312           * the lowest bits (little-endian) regardless of the order (PACKSWAP or
3313           * not) of the pixels in each byte.
3314           *
3315           * NOTE: the whole of this logic depends on the caller of this function
3316           * only calling it on rows appropriate to the pass.  This function only
3317           * understands the &#39;x&#39; logic; the &#39;y&#39; logic is handled by the caller.
3318           *
3319           * The following defines allow generation of compile time constant bit
3320           * masks for each pixel depth and each possibility of swapped or not
3321           * swapped bytes.  Pass &#39;p&#39; is in the range 0..6; &#39;x&#39;, a pixel index,
3322           * is in the range 0..7; and the result is 1 if the pixel is to be
3323           * copied in the pass, 0 if not.  &#39;S&#39; is for the sparkle method, &#39;B&#39;
3324           * for the block method.
3325           *
3326           * With some compilers a compile time expression of the general form:
3327           *
3328           *    (shift &gt;= 32) ? (a &gt;&gt; (shift-32)) : (b &gt;&gt; shift)
3329           *
3330           * Produces warnings with values of &#39;shift&#39; in the range 33 to 63
3331           * because the right hand side of the ?: expression is evaluated by
3332           * the compiler even though it isn&#39;t used.  Microsoft Visual C (various
3333           * versions) and the Intel C compiler are known to do this.  To avoid
3334           * this the following macros are used in 1.5.6.  This is a temporary
3335           * solution to avoid destabilizing the code during the release process.
3336           */
3337 #        if PNG_USE_COMPILE_TIME_MASKS
3338 #           define PNG_LSR(x,s) ((x)&gt;&gt;((s) &amp; 0x1f))
3339 #           define PNG_LSL(x,s) ((x)&lt;&lt;((s) &amp; 0x1f))
3340 #        else
3341 #           define PNG_LSR(x,s) ((x)&gt;&gt;(s))
3342 #           define PNG_LSL(x,s) ((x)&lt;&lt;(s))
3343 #        endif
3344 #        define S_COPY(p,x) (((p)&lt;4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\
3345            PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) &amp; 1)
3346 #        define B_COPY(p,x) (((p)&lt;4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\
3347            PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) &amp; 1)
3348 
3349          /* Return a mask for pass &#39;p&#39; pixel &#39;x&#39; at depth &#39;d&#39;.  The mask is
3350           * little endian - the first pixel is at bit 0 - however the extra
3351           * parameter &#39;s&#39; can be set to cause the mask position to be swapped
3352           * within each byte, to match the PNG format.  This is done by XOR of
3353           * the shift with 7, 6 or 4 for bit depths 1, 2 and 4.
3354           */
3355 #        define PIXEL_MASK(p,x,d,s) \
3356             (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
3357 
3358          /* Hence generate the appropriate &#39;block&#39; or &#39;sparkle&#39; pixel copy mask.
3359           */
3360 #        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
3361 #        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
3362 
3363          /* Combine 8 of these to get the full mask.  For the 1-bpp and 2-bpp
3364           * cases the result needs replicating, for the 4-bpp case the above
3365           * generates a full 32 bits.
3366           */
3367 #        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
3368 
3369 #        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
3370             S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
3371             S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
3372 
3373 #        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
3374             B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
3375             B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
3376 
3377 #if PNG_USE_COMPILE_TIME_MASKS
3378          /* Utility macros to construct all the masks for a depth/swap
3379           * combination.  The &#39;s&#39; parameter says whether the format is PNG
3380           * (big endian bytes) or not.  Only the three odd-numbered passes are
3381           * required for the display/block algorithm.
3382           */
3383 #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
3384             S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
3385 
3386 #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
3387 
3388 #        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
3389 
3390          /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
3391           * then pass:
3392           */
3393          static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =
3394          {
3395             /* Little-endian byte masks for PACKSWAP */
3396             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
3397             /* Normal (big-endian byte) masks - PNG format */
3398             { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
3399          };
3400 
3401          /* display_mask has only three entries for the odd passes, so index by
3402           * pass&gt;&gt;1.
3403           */
3404          static const png_uint_32 display_mask[2][3][3] =
3405          {
3406             /* Little-endian byte masks for PACKSWAP */
3407             { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
3408             /* Normal (big-endian byte) masks - PNG format */
3409             { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
3410          };
3411 
3412 #        define MASK(pass,depth,display,png)\
3413             ((display)?display_mask[png][DEPTH_INDEX(depth)][pass&gt;&gt;1]:\
3414                row_mask[png][DEPTH_INDEX(depth)][pass])
3415 
3416 #else /* !PNG_USE_COMPILE_TIME_MASKS */
3417          /* This is the runtime alternative: it seems unlikely that this will
3418           * ever be either smaller or faster than the compile time approach.
3419           */
3420 #        define MASK(pass,depth,display,png)\
3421             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
3422 #endif /* !USE_COMPILE_TIME_MASKS */
3423 
3424          /* Use the appropriate mask to copy the required bits.  In some cases
3425           * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
3426           * the number of pixels, but the code copies bytes, so it is necessary
3427           * to special case the end.
3428           */
3429          png_uint_32 pixels_per_byte = 8 / pixel_depth;
3430          png_uint_32 mask;
3431 
3432 #        ifdef PNG_READ_PACKSWAP_SUPPORTED
3433          if ((png_ptr-&gt;transformations &amp; PNG_PACKSWAP) != 0)
3434             mask = MASK(pass, pixel_depth, display, 0);
3435 
3436          else
3437 #        endif
3438          mask = MASK(pass, pixel_depth, display, 1);
3439 
3440          for (;;)
3441          {
3442             png_uint_32 m;
3443 
3444             /* It doesn&#39;t matter in the following if png_uint_32 has more than
3445              * 32 bits because the high bits always match those in m&lt;&lt;24; it is,
3446              * however, essential to use OR here, not +, because of this.
3447              */
3448             m = mask;
3449             mask = (m &gt;&gt; 8) | (m &lt;&lt; 24); /* rotate right to good compilers */
3450             m &amp;= 0xff;
3451 
3452             if (m != 0) /* something to copy */
3453             {
3454                if (m != 0xff)
3455                   *dp = (png_byte)((*dp &amp; ~m) | (*sp &amp; m));
3456                else
3457                   *dp = *sp;
3458             }
3459 
3460             /* NOTE: this may overwrite the last byte with garbage if the image
3461              * is not an exact number of bytes wide; libpng has always done
3462              * this.
3463              */
3464             if (row_width &lt;= pixels_per_byte)
3465                break; /* May need to restore part of the last byte */
3466 
3467             row_width -= pixels_per_byte;
3468             ++dp;
3469             ++sp;
3470          }
3471       }
3472 
3473       else /* pixel_depth &gt;= 8 */
3474       {
3475          unsigned int bytes_to_copy, bytes_to_jump;
3476 
3477          /* Validate the depth - it must be a multiple of 8 */
3478          if (pixel_depth &amp; 7)
3479             png_error(png_ptr, &quot;invalid user transform pixel depth&quot;);
3480 
3481          pixel_depth &gt;&gt;= 3; /* now in bytes */
3482          row_width *= pixel_depth;
3483 
3484          /* Regardless of pass number the Adam 7 interlace always results in a
3485           * fixed number of pixels to copy then to skip.  There may be a
3486           * different number of pixels to skip at the start though.
3487           */
3488          {
3489             unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;
3490 
3491             row_width -= offset;
3492             dp += offset;
3493             sp += offset;
3494          }
3495 
3496          /* Work out the bytes to copy. */
3497          if (display != 0)
3498          {
3499             /* When doing the &#39;block&#39; algorithm the pixel in the pass gets
3500              * replicated to adjacent pixels.  This is why the even (0,2,4,6)
3501              * passes are skipped above - the entire expanded row is copied.
3502              */
3503             bytes_to_copy = (1&lt;&lt;((6-pass)&gt;&gt;1)) * pixel_depth;
3504 
3505             /* But don&#39;t allow this number to exceed the actual row width. */
3506             if (bytes_to_copy &gt; row_width)
3507                bytes_to_copy = (unsigned int)/*SAFE*/row_width;
3508          }
3509 
3510          else /* normal row; Adam7 only ever gives us one pixel to copy. */
3511             bytes_to_copy = pixel_depth;
3512 
3513          /* In Adam7 there is a constant offset between where the pixels go. */
3514          bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;
3515 
3516          /* And simply copy these bytes.  Some optimization is possible here,
3517           * depending on the value of &#39;bytes_to_copy&#39;.  Special case the low
3518           * byte counts, which we know to be frequent.
3519           *
3520           * Notice that these cases all &#39;return&#39; rather than &#39;break&#39; - this
3521           * avoids an unnecessary test on whether to restore the last byte
3522           * below.
3523           */
3524          switch (bytes_to_copy)
3525          {
3526             case 1:
3527                for (;;)
3528                {
3529                   *dp = *sp;
3530 
3531                   if (row_width &lt;= bytes_to_jump)
3532                      return;
3533 
3534                   dp += bytes_to_jump;
3535                   sp += bytes_to_jump;
3536                   row_width -= bytes_to_jump;
3537                }
3538 
3539             case 2:
3540                /* There is a possibility of a partial copy at the end here; this
3541                 * slows the code down somewhat.
3542                 */
3543                do
3544                {
3545                   dp[0] = sp[0]; dp[1] = sp[1];
3546 
3547                   if (row_width &lt;= bytes_to_jump)
3548                      return;
3549 
3550                   sp += bytes_to_jump;
3551                   dp += bytes_to_jump;
3552                   row_width -= bytes_to_jump;
3553                }
3554                while (row_width &gt; 1);
3555 
3556                /* And there can only be one byte left at this point: */
3557                *dp = *sp;
3558                return;
3559 
3560             case 3:
3561                /* This can only be the RGB case, so each copy is exactly one
3562                 * pixel and it is not necessary to check for a partial copy.
3563                 */
3564                for (;;)
3565                {
3566                   dp[0] = sp[0]; dp[1] = sp[1]; dp[2] = sp[2];
3567 
3568                   if (row_width &lt;= bytes_to_jump)
3569                      return;
3570 
3571                   sp += bytes_to_jump;
3572                   dp += bytes_to_jump;
3573                   row_width -= bytes_to_jump;
3574                }
3575 
3576             default:
3577 #if PNG_ALIGN_TYPE != PNG_ALIGN_NONE
3578                /* Check for double byte alignment and, if possible, use a
3579                 * 16-bit copy.  Don&#39;t attempt this for narrow images - ones that
3580                 * are less than an interlace panel wide.  Don&#39;t attempt it for
3581                 * wide bytes_to_copy either - use the memcpy there.
3582                 */
3583                if (bytes_to_copy &lt; 16 /*else use memcpy*/ &amp;&amp;
3584                    png_isaligned(dp, png_uint_16) &amp;&amp;
3585                    png_isaligned(sp, png_uint_16) &amp;&amp;
3586                    bytes_to_copy % (sizeof (png_uint_16)) == 0 &amp;&amp;
3587                    bytes_to_jump % (sizeof (png_uint_16)) == 0)
3588                {
3589                   /* Everything is aligned for png_uint_16 copies, but try for
3590                    * png_uint_32 first.
3591                    */
3592                   if (png_isaligned(dp, png_uint_32) &amp;&amp;
3593                       png_isaligned(sp, png_uint_32) &amp;&amp;
3594                       bytes_to_copy % (sizeof (png_uint_32)) == 0 &amp;&amp;
3595                       bytes_to_jump % (sizeof (png_uint_32)) == 0)
3596                   {
3597                      png_uint_32p dp32 = png_aligncast(png_uint_32p,dp);
3598                      png_const_uint_32p sp32 = png_aligncastconst(
3599                          png_const_uint_32p, sp);
3600                      size_t skip = (bytes_to_jump-bytes_to_copy) /
3601                          (sizeof (png_uint_32));
3602 
3603                      do
3604                      {
3605                         size_t c = bytes_to_copy;
3606                         do
3607                         {
3608                            *dp32++ = *sp32++;
3609                            c -= (sizeof (png_uint_32));
3610                         }
3611                         while (c &gt; 0);
3612 
3613                         if (row_width &lt;= bytes_to_jump)
3614                            return;
3615 
3616                         dp32 += skip;
3617                         sp32 += skip;
3618                         row_width -= bytes_to_jump;
3619                      }
3620                      while (bytes_to_copy &lt;= row_width);
3621 
3622                      /* Get to here when the row_width truncates the final copy.
3623                       * There will be 1-3 bytes left to copy, so don&#39;t try the
3624                       * 16-bit loop below.
3625                       */
3626                      dp = (png_bytep)dp32;
3627                      sp = (png_const_bytep)sp32;
3628                      do
3629                         *dp++ = *sp++;
3630                      while (--row_width &gt; 0);
3631                      return;
3632                   }
3633 
3634                   /* Else do it in 16-bit quantities, but only if the size is
3635                    * not too large.
3636                    */
3637                   else
3638                   {
3639                      png_uint_16p dp16 = png_aligncast(png_uint_16p, dp);
3640                      png_const_uint_16p sp16 = png_aligncastconst(
3641                         png_const_uint_16p, sp);
3642                      size_t skip = (bytes_to_jump-bytes_to_copy) /
3643                         (sizeof (png_uint_16));
3644 
3645                      do
3646                      {
3647                         size_t c = bytes_to_copy;
3648                         do
3649                         {
3650                            *dp16++ = *sp16++;
3651                            c -= (sizeof (png_uint_16));
3652                         }
3653                         while (c &gt; 0);
3654 
3655                         if (row_width &lt;= bytes_to_jump)
3656                            return;
3657 
3658                         dp16 += skip;
3659                         sp16 += skip;
3660                         row_width -= bytes_to_jump;
3661                      }
3662                      while (bytes_to_copy &lt;= row_width);
3663 
3664                      /* End of row - 1 byte left, bytes_to_copy &gt; row_width: */
3665                      dp = (png_bytep)dp16;
3666                      sp = (png_const_bytep)sp16;
3667                      do
3668                         *dp++ = *sp++;
3669                      while (--row_width &gt; 0);
3670                      return;
3671                   }
3672                }
3673 #endif /* ALIGN_TYPE code */
3674 
3675                /* The true default - use a memcpy: */
3676                for (;;)
3677                {
3678                   memcpy(dp, sp, bytes_to_copy);
3679 
3680                   if (row_width &lt;= bytes_to_jump)
3681                      return;
3682 
3683                   sp += bytes_to_jump;
3684                   dp += bytes_to_jump;
3685                   row_width -= bytes_to_jump;
3686                   if (bytes_to_copy &gt; row_width)
3687                      bytes_to_copy = (unsigned int)/*SAFE*/row_width;
3688                }
3689          }
3690 
3691          /* NOT REACHED*/
3692       } /* pixel_depth &gt;= 8 */
3693 
3694       /* Here if pixel_depth &lt; 8 to check &#39;end_ptr&#39; below. */
3695    }
3696    else
3697 #endif /* READ_INTERLACING */
3698 
3699    /* If here then the switch above wasn&#39;t used so just memcpy the whole row
3700     * from the temporary row buffer (notice that this overwrites the end of the
3701     * destination row if it is a partial byte.)
3702     */
3703    memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
3704 
3705    /* Restore the overwritten bits from the last byte if necessary. */
3706    if (end_ptr != NULL)
3707       *end_ptr = (png_byte)((end_byte &amp; end_mask) | (*end_ptr &amp; ~end_mask));
3708 }
3709 
3710 #ifdef PNG_READ_INTERLACING_SUPPORTED
3711 void /* PRIVATE */
3712 png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
3713     png_uint_32 transformations /* Because these may affect the byte layout */)
3714 {
3715    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
3716    /* Offset to next interlace block */
3717    static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
3718 
3719    png_debug(1, &quot;in png_do_read_interlace&quot;);
3720    if (row != NULL &amp;&amp; row_info != NULL)
3721    {
3722       png_uint_32 final_width;
3723 
3724       final_width = row_info-&gt;width * png_pass_inc[pass];
3725 
3726       switch (row_info-&gt;pixel_depth)
3727       {
3728          case 1:
3729          {
3730             png_bytep sp = row + (size_t)((row_info-&gt;width - 1) &gt;&gt; 3);
3731             png_bytep dp = row + (size_t)((final_width - 1) &gt;&gt; 3);
3732             unsigned int sshift, dshift;
3733             unsigned int s_start, s_end;
3734             int s_inc;
3735             int jstop = (int)png_pass_inc[pass];
3736             png_byte v;
3737             png_uint_32 i;
3738             int j;
3739 
3740 #ifdef PNG_READ_PACKSWAP_SUPPORTED
3741             if ((transformations &amp; PNG_PACKSWAP) != 0)
3742             {
3743                 sshift = ((row_info-&gt;width + 7) &amp; 0x07);
3744                 dshift = ((final_width + 7) &amp; 0x07);
3745                 s_start = 7;
3746                 s_end = 0;
3747                 s_inc = -1;
3748             }
3749 
3750             else
3751 #endif
3752             {
3753                 sshift = 7 - ((row_info-&gt;width + 7) &amp; 0x07);
3754                 dshift = 7 - ((final_width + 7) &amp; 0x07);
3755                 s_start = 0;
3756                 s_end = 7;
3757                 s_inc = 1;
3758             }
3759 
3760             for (i = 0; i &lt; row_info-&gt;width; i++)
3761             {
3762                v = (png_byte)((*sp &gt;&gt; sshift) &amp; 0x01);
3763                for (j = 0; j &lt; jstop; j++)
3764                {
3765                   unsigned int tmp = *dp &amp; (0x7f7f &gt;&gt; (7 - dshift));
3766                   tmp |= (unsigned int)(v &lt;&lt; dshift);
3767                   *dp = (png_byte)(tmp &amp; 0xff);
3768 
3769                   if (dshift == s_end)
3770                   {
3771                      dshift = s_start;
3772                      dp--;
3773                   }
3774 
3775                   else
3776                      dshift = (unsigned int)((int)dshift + s_inc);
3777                }
3778 
3779                if (sshift == s_end)
3780                {
3781                   sshift = s_start;
3782                   sp--;
3783                }
3784 
3785                else
3786                   sshift = (unsigned int)((int)sshift + s_inc);
3787             }
3788             break;
3789          }
3790 
3791          case 2:
3792          {
3793             png_bytep sp = row + (png_uint_32)((row_info-&gt;width - 1) &gt;&gt; 2);
3794             png_bytep dp = row + (png_uint_32)((final_width - 1) &gt;&gt; 2);
3795             unsigned int sshift, dshift;
3796             unsigned int s_start, s_end;
3797             int s_inc;
3798             int jstop = (int)png_pass_inc[pass];
3799             png_uint_32 i;
3800 
3801 #ifdef PNG_READ_PACKSWAP_SUPPORTED
3802             if ((transformations &amp; PNG_PACKSWAP) != 0)
3803             {
3804                sshift = (((row_info-&gt;width + 3) &amp; 0x03) &lt;&lt; 1);
3805                dshift = (((final_width + 3) &amp; 0x03) &lt;&lt; 1);
3806                s_start = 6;
3807                s_end = 0;
3808                s_inc = -2;
3809             }
3810 
3811             else
3812 #endif
3813             {
3814                sshift = ((3 - ((row_info-&gt;width + 3) &amp; 0x03)) &lt;&lt; 1);
3815                dshift = ((3 - ((final_width + 3) &amp; 0x03)) &lt;&lt; 1);
3816                s_start = 0;
3817                s_end = 6;
3818                s_inc = 2;
3819             }
3820 
3821             for (i = 0; i &lt; row_info-&gt;width; i++)
3822             {
3823                png_byte v;
3824                int j;
3825 
3826                v = (png_byte)((*sp &gt;&gt; sshift) &amp; 0x03);
3827                for (j = 0; j &lt; jstop; j++)
3828                {
3829                   unsigned int tmp = *dp &amp; (0x3f3f &gt;&gt; (6 - dshift));
3830                   tmp |= (unsigned int)(v &lt;&lt; dshift);
3831                   *dp = (png_byte)(tmp &amp; 0xff);
3832 
3833                   if (dshift == s_end)
3834                   {
3835                      dshift = s_start;
3836                      dp--;
3837                   }
3838 
3839                   else
3840                      dshift = (unsigned int)((int)dshift + s_inc);
3841                }
3842 
3843                if (sshift == s_end)
3844                {
3845                   sshift = s_start;
3846                   sp--;
3847                }
3848 
3849                else
3850                   sshift = (unsigned int)((int)sshift + s_inc);
3851             }
3852             break;
3853          }
3854 
3855          case 4:
3856          {
3857             png_bytep sp = row + (size_t)((row_info-&gt;width - 1) &gt;&gt; 1);
3858             png_bytep dp = row + (size_t)((final_width - 1) &gt;&gt; 1);
3859             unsigned int sshift, dshift;
3860             unsigned int s_start, s_end;
3861             int s_inc;
3862             png_uint_32 i;
3863             int jstop = (int)png_pass_inc[pass];
3864 
3865 #ifdef PNG_READ_PACKSWAP_SUPPORTED
3866             if ((transformations &amp; PNG_PACKSWAP) != 0)
3867             {
3868                sshift = (((row_info-&gt;width + 1) &amp; 0x01) &lt;&lt; 2);
3869                dshift = (((final_width + 1) &amp; 0x01) &lt;&lt; 2);
3870                s_start = 4;
3871                s_end = 0;
3872                s_inc = -4;
3873             }
3874 
3875             else
3876 #endif
3877             {
3878                sshift = ((1 - ((row_info-&gt;width + 1) &amp; 0x01)) &lt;&lt; 2);
3879                dshift = ((1 - ((final_width + 1) &amp; 0x01)) &lt;&lt; 2);
3880                s_start = 0;
3881                s_end = 4;
3882                s_inc = 4;
3883             }
3884 
3885             for (i = 0; i &lt; row_info-&gt;width; i++)
3886             {
3887                png_byte v = (png_byte)((*sp &gt;&gt; sshift) &amp; 0x0f);
3888                int j;
3889 
3890                for (j = 0; j &lt; jstop; j++)
3891                {
3892                   unsigned int tmp = *dp &amp; (0xf0f &gt;&gt; (4 - dshift));
3893                   tmp |= (unsigned int)(v &lt;&lt; dshift);
3894                   *dp = (png_byte)(tmp &amp; 0xff);
3895 
3896                   if (dshift == s_end)
3897                   {
3898                      dshift = s_start;
3899                      dp--;
3900                   }
3901 
3902                   else
3903                      dshift = (unsigned int)((int)dshift + s_inc);
3904                }
3905 
3906                if (sshift == s_end)
3907                {
3908                   sshift = s_start;
3909                   sp--;
3910                }
3911 
3912                else
3913                   sshift = (unsigned int)((int)sshift + s_inc);
3914             }
3915             break;
3916          }
3917 
3918          default:
3919          {
3920             size_t pixel_bytes = (row_info-&gt;pixel_depth &gt;&gt; 3);
3921 
3922             png_bytep sp = row + (size_t)(row_info-&gt;width - 1)
3923                 * pixel_bytes;
3924 
3925             png_bytep dp = row + (size_t)(final_width - 1) * pixel_bytes;
3926 
3927             int jstop = (int)png_pass_inc[pass];
3928             png_uint_32 i;
3929 
3930             for (i = 0; i &lt; row_info-&gt;width; i++)
3931             {
3932                png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */
3933                int j;
3934 
3935                memcpy(v, sp, pixel_bytes);
3936 
3937                for (j = 0; j &lt; jstop; j++)
3938                {
3939                   memcpy(dp, v, pixel_bytes);
3940                   dp -= pixel_bytes;
3941                }
3942 
3943                sp -= pixel_bytes;
3944             }
3945             break;
3946          }
3947       }
3948 
3949       row_info-&gt;width = final_width;
3950       row_info-&gt;rowbytes = PNG_ROWBYTES(row_info-&gt;pixel_depth, final_width);
3951    }
3952 #ifndef PNG_READ_PACKSWAP_SUPPORTED
3953    PNG_UNUSED(transformations)  /* Silence compiler warning */
3954 #endif
3955 }
3956 #endif /* READ_INTERLACING */
3957 
3958 static void
3959 png_read_filter_row_sub(png_row_infop row_info, png_bytep row,
3960     png_const_bytep prev_row)
3961 {
3962    size_t i;
3963    size_t istop = row_info-&gt;rowbytes;
3964    unsigned int bpp = (row_info-&gt;pixel_depth + 7) &gt;&gt; 3;
3965    png_bytep rp = row + bpp;
3966 
3967    PNG_UNUSED(prev_row)
3968 
3969    for (i = bpp; i &lt; istop; i++)
3970    {
3971       *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) &amp; 0xff);
3972       rp++;
3973    }
3974 }
3975 
3976 static void
3977 png_read_filter_row_up(png_row_infop row_info, png_bytep row,
3978     png_const_bytep prev_row)
3979 {
3980    size_t i;
3981    size_t istop = row_info-&gt;rowbytes;
3982    png_bytep rp = row;
3983    png_const_bytep pp = prev_row;
3984 
3985    for (i = 0; i &lt; istop; i++)
3986    {
3987       *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) &amp; 0xff);
3988       rp++;
3989    }
3990 }
3991 
3992 static void
3993 png_read_filter_row_avg(png_row_infop row_info, png_bytep row,
3994     png_const_bytep prev_row)
3995 {
3996    size_t i;
3997    png_bytep rp = row;
3998    png_const_bytep pp = prev_row;
3999    unsigned int bpp = (row_info-&gt;pixel_depth + 7) &gt;&gt; 3;
4000    size_t istop = row_info-&gt;rowbytes - bpp;
4001 
4002    for (i = 0; i &lt; bpp; i++)
4003    {
4004       *rp = (png_byte)(((int)(*rp) +
4005          ((int)(*pp++) / 2 )) &amp; 0xff);
4006 
4007       rp++;
4008    }
4009 
4010    for (i = 0; i &lt; istop; i++)
4011    {
4012       *rp = (png_byte)(((int)(*rp) +
4013          (int)(*pp++ + *(rp-bpp)) / 2 ) &amp; 0xff);
4014 
4015       rp++;
4016    }
4017 }
4018 
4019 static void
4020 png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,
4021     png_const_bytep prev_row)
4022 {
4023    png_bytep rp_end = row + row_info-&gt;rowbytes;
4024    int a, c;
4025 
4026    /* First pixel/byte */
4027    c = *prev_row++;
4028    a = *row + c;
4029    *row++ = (png_byte)a;
4030 
4031    /* Remainder */
4032    while (row &lt; rp_end)
4033    {
4034       int b, pa, pb, pc, p;
4035 
4036       a &amp;= 0xff; /* From previous iteration or start */
4037       b = *prev_row++;
4038 
4039       p = b - c;
4040       pc = a - c;
4041 
4042 #ifdef PNG_USE_ABS
4043       pa = abs(p);
4044       pb = abs(pc);
4045       pc = abs(p + pc);
4046 #else
4047       pa = p &lt; 0 ? -p : p;
4048       pb = pc &lt; 0 ? -pc : pc;
4049       pc = (p + pc) &lt; 0 ? -(p + pc) : p + pc;
4050 #endif
4051 
4052       /* Find the best predictor, the least of pa, pb, pc favoring the earlier
4053        * ones in the case of a tie.
4054        */
4055       if (pb &lt; pa)
4056       {
4057          pa = pb; a = b;
4058       }
4059       if (pc &lt; pa) a = c;
4060 
4061       /* Calculate the current pixel in a, and move the previous row pixel to c
4062        * for the next time round the loop
4063        */
4064       c = b;
4065       a += *row;
4066       *row++ = (png_byte)a;
4067    }
4068 }
4069 
4070 static void
4071 png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
4072     png_const_bytep prev_row)
4073 {
4074    unsigned int bpp = (row_info-&gt;pixel_depth + 7) &gt;&gt; 3;
4075    png_bytep rp_end = row + bpp;
4076 
4077    /* Process the first pixel in the row completely (this is the same as &#39;up&#39;
4078     * because there is only one candidate predictor for the first row).
4079     */
4080    while (row &lt; rp_end)
4081    {
4082       int a = *row + *prev_row++;
4083       *row++ = (png_byte)a;
4084    }
4085 
4086    /* Remainder */
4087    rp_end = rp_end + (row_info-&gt;rowbytes - bpp);
4088 
4089    while (row &lt; rp_end)
4090    {
4091       int a, b, c, pa, pb, pc, p;
4092 
4093       c = *(prev_row - bpp);
4094       a = *(row - bpp);
4095       b = *prev_row++;
4096 
4097       p = b - c;
4098       pc = a - c;
4099 
4100 #ifdef PNG_USE_ABS
4101       pa = abs(p);
4102       pb = abs(pc);
4103       pc = abs(p + pc);
4104 #else
4105       pa = p &lt; 0 ? -p : p;
4106       pb = pc &lt; 0 ? -pc : pc;
4107       pc = (p + pc) &lt; 0 ? -(p + pc) : p + pc;
4108 #endif
4109 
4110       if (pb &lt; pa)
4111       {
4112          pa = pb; a = b;
4113       }
4114       if (pc &lt; pa) a = c;
4115 
4116       a += *row;
4117       *row++ = (png_byte)a;
4118    }
4119 }
4120 
4121 static void
4122 png_init_filter_functions(png_structrp pp)
4123    /* This function is called once for every PNG image (except for PNG images
4124     * that only use PNG_FILTER_VALUE_NONE for all rows) to set the
4125     * implementations required to reverse the filtering of PNG rows.  Reversing
4126     * the filter is the first transformation performed on the row data.  It is
4127     * performed in place, therefore an implementation can be selected based on
4128     * the image pixel format.  If the implementation depends on image width then
4129     * take care to ensure that it works correctly if the image is interlaced -
4130     * interlacing causes the actual row width to vary.
4131     */
4132 {
4133    unsigned int bpp = (pp-&gt;pixel_depth + 7) &gt;&gt; 3;
4134 
4135    pp-&gt;read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub;
4136    pp-&gt;read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up;
4137    pp-&gt;read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg;
4138    if (bpp == 1)
4139       pp-&gt;read_filter[PNG_FILTER_VALUE_PAETH-1] =
4140          png_read_filter_row_paeth_1byte_pixel;
4141    else
4142       pp-&gt;read_filter[PNG_FILTER_VALUE_PAETH-1] =
4143          png_read_filter_row_paeth_multibyte_pixel;
4144 
4145 #ifdef PNG_FILTER_OPTIMIZATIONS
4146    /* To use this define PNG_FILTER_OPTIMIZATIONS as the name of a function to
4147     * call to install hardware optimizations for the above functions; simply
4148     * replace whatever elements of the pp-&gt;read_filter[] array with a hardware
4149     * specific (or, for that matter, generic) optimization.
4150     *
4151     * To see an example of this examine what configure.ac does when
4152     * --enable-arm-neon is specified on the command line.
4153     */
4154    PNG_FILTER_OPTIMIZATIONS(pp, bpp);
4155 #endif
4156 }
4157 
4158 void /* PRIVATE */
4159 png_read_filter_row(png_structrp pp, png_row_infop row_info, png_bytep row,
4160     png_const_bytep prev_row, int filter)
4161 {
4162    /* OPTIMIZATION: DO NOT MODIFY THIS FUNCTION, instead #define
4163     * PNG_FILTER_OPTIMIZATIONS to a function that overrides the generic
4164     * implementations.  See png_init_filter_functions above.
4165     */
4166    if (filter &gt; PNG_FILTER_VALUE_NONE &amp;&amp; filter &lt; PNG_FILTER_VALUE_LAST)
4167    {
4168       if (pp-&gt;read_filter[0] == NULL)
4169          png_init_filter_functions(pp);
4170 
4171       pp-&gt;read_filter[filter-1](row_info, row, prev_row);
4172    }
4173 }
4174 
4175 #ifdef PNG_SEQUENTIAL_READ_SUPPORTED
4176 void /* PRIVATE */
4177 png_read_IDAT_data(png_structrp png_ptr, png_bytep output,
4178     png_alloc_size_t avail_out)
4179 {
4180    /* Loop reading IDATs and decompressing the result into output[avail_out] */
4181    png_ptr-&gt;zstream.next_out = output;
4182    png_ptr-&gt;zstream.avail_out = 0; /* safety: set below */
4183 
4184    if (output == NULL)
4185       avail_out = 0;
4186 
4187    do
4188    {
4189       int ret;
4190       png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
4191 
4192       if (png_ptr-&gt;zstream.avail_in == 0)
4193       {
4194          uInt avail_in;
4195          png_bytep buffer;
4196 
4197          while (png_ptr-&gt;idat_size == 0)
4198          {
4199             png_crc_finish(png_ptr, 0);
4200 
4201             png_ptr-&gt;idat_size = png_read_chunk_header(png_ptr);
4202             /* This is an error even in the &#39;check&#39; case because the code just
4203              * consumed a non-IDAT header.
4204              */
4205             if (png_ptr-&gt;chunk_name != png_IDAT)
4206                png_error(png_ptr, &quot;Not enough image data&quot;);
4207          }
4208 
4209          avail_in = png_ptr-&gt;IDAT_read_size;
4210 
4211          if (avail_in &gt; png_ptr-&gt;idat_size)
4212             avail_in = (uInt)png_ptr-&gt;idat_size;
4213 
4214          /* A PNG with a gradually increasing IDAT size will defeat this attempt
4215           * to minimize memory usage by causing lots of re-allocs, but
4216           * realistically doing IDAT_read_size re-allocs is not likely to be a
4217           * big problem.
4218           */
4219          buffer = png_read_buffer(png_ptr, avail_in, 0/*error*/);
4220 
4221          png_crc_read(png_ptr, buffer, avail_in);
4222          png_ptr-&gt;idat_size -= avail_in;
4223 
4224          png_ptr-&gt;zstream.next_in = buffer;
4225          png_ptr-&gt;zstream.avail_in = avail_in;
4226       }
4227 
4228       /* And set up the output side. */
4229       if (output != NULL) /* standard read */
4230       {
4231          uInt out = ZLIB_IO_MAX;
4232 
4233          if (out &gt; avail_out)
4234             out = (uInt)avail_out;
4235 
4236          avail_out -= out;
4237          png_ptr-&gt;zstream.avail_out = out;
4238       }
4239 
4240       else /* after last row, checking for end */
4241       {
4242          png_ptr-&gt;zstream.next_out = tmpbuf;
4243          png_ptr-&gt;zstream.avail_out = (sizeof tmpbuf);
4244       }
4245 
4246       /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
4247        * process.  If the LZ stream is truncated the sequential reader will
4248        * terminally damage the stream, above, by reading the chunk header of the
4249        * following chunk (it then exits with png_error).
4250        *
4251        * TODO: deal more elegantly with truncated IDAT lists.
4252        */
4253       ret = PNG_INFLATE(png_ptr, Z_NO_FLUSH);
4254 
4255       /* Take the unconsumed output back. */
4256       if (output != NULL)
4257          avail_out += png_ptr-&gt;zstream.avail_out;
4258 
4259       else /* avail_out counts the extra bytes */
4260          avail_out += (sizeof tmpbuf) - png_ptr-&gt;zstream.avail_out;
4261 
4262       png_ptr-&gt;zstream.avail_out = 0;
4263 
4264       if (ret == Z_STREAM_END)
4265       {
4266          /* Do this for safety; we won&#39;t read any more into this row. */
4267          png_ptr-&gt;zstream.next_out = NULL;
4268 
4269          png_ptr-&gt;mode |= PNG_AFTER_IDAT;
4270          png_ptr-&gt;flags |= PNG_FLAG_ZSTREAM_ENDED;
4271 
4272          if (png_ptr-&gt;zstream.avail_in &gt; 0 || png_ptr-&gt;idat_size &gt; 0)
4273             png_chunk_benign_error(png_ptr, &quot;Extra compressed data&quot;);
4274          break;
4275       }
4276 
4277       if (ret != Z_OK)
4278       {
4279          png_zstream_error(png_ptr, ret);
4280 
4281          if (output != NULL)
4282             png_chunk_error(png_ptr, png_ptr-&gt;zstream.msg);
4283 
4284          else /* checking */
4285          {
4286             png_chunk_benign_error(png_ptr, png_ptr-&gt;zstream.msg);
4287             return;
4288          }
4289       }
4290    } while (avail_out &gt; 0);
4291 
4292    if (avail_out &gt; 0)
4293    {
4294       /* The stream ended before the image; this is the same as too few IDATs so
4295        * should be handled the same way.
4296        */
4297       if (output != NULL)
4298          png_error(png_ptr, &quot;Not enough image data&quot;);
4299 
4300       else /* the deflate stream contained extra data */
4301          png_chunk_benign_error(png_ptr, &quot;Too much image data&quot;);
4302    }
4303 }
4304 
4305 void /* PRIVATE */
4306 png_read_finish_IDAT(png_structrp png_ptr)
4307 {
4308    /* We don&#39;t need any more data and the stream should have ended, however the
4309     * LZ end code may actually not have been processed.  In this case we must
4310     * read it otherwise stray unread IDAT data or, more likely, an IDAT chunk
4311     * may still remain to be consumed.
4312     */
4313    if ((png_ptr-&gt;flags &amp; PNG_FLAG_ZSTREAM_ENDED) == 0)
4314    {
4315       /* The NULL causes png_read_IDAT_data to swallow any remaining bytes in
4316        * the compressed stream, but the stream may be damaged too, so even after
4317        * this call we may need to terminate the zstream ownership.
4318        */
4319       png_read_IDAT_data(png_ptr, NULL, 0);
4320       png_ptr-&gt;zstream.next_out = NULL; /* safety */
4321 
4322       /* Now clear everything out for safety; the following may not have been
4323        * done.
4324        */
4325       if ((png_ptr-&gt;flags &amp; PNG_FLAG_ZSTREAM_ENDED) == 0)
4326       {
4327          png_ptr-&gt;mode |= PNG_AFTER_IDAT;
4328          png_ptr-&gt;flags |= PNG_FLAG_ZSTREAM_ENDED;
4329       }
4330    }
4331 
4332    /* If the zstream has not been released do it now *and* terminate the reading
4333     * of the final IDAT chunk.
4334     */
4335    if (png_ptr-&gt;zowner == png_IDAT)
4336    {
4337       /* Always do this; the pointers otherwise point into the read buffer. */
4338       png_ptr-&gt;zstream.next_in = NULL;
4339       png_ptr-&gt;zstream.avail_in = 0;
4340 
4341       /* Now we no longer own the zstream. */
4342       png_ptr-&gt;zowner = 0;
4343 
4344       /* The slightly weird semantics of the sequential IDAT reading is that we
4345        * are always in or at the end of an IDAT chunk, so we always need to do a
4346        * crc_finish here.  If idat_size is non-zero we also need to read the
4347        * spurious bytes at the end of the chunk now.
4348        */
4349       (void)png_crc_finish(png_ptr, png_ptr-&gt;idat_size);
4350    }
4351 }
4352 
4353 void /* PRIVATE */
4354 png_read_finish_row(png_structrp png_ptr)
4355 {
4356    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4357 
4358    /* Start of interlace block */
4359    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
4360 
4361    /* Offset to next interlace block */
4362    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
4363 
4364    /* Start of interlace block in the y direction */
4365    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
4366 
4367    /* Offset to next interlace block in the y direction */
4368    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
4369 
4370    png_debug(1, &quot;in png_read_finish_row&quot;);
4371    png_ptr-&gt;row_number++;
4372    if (png_ptr-&gt;row_number &lt; png_ptr-&gt;num_rows)
4373       return;
4374 
4375    if (png_ptr-&gt;interlaced != 0)
4376    {
4377       png_ptr-&gt;row_number = 0;
4378 
4379       /* TO DO: don&#39;t do this if prev_row isn&#39;t needed (requires
4380        * read-ahead of the next row&#39;s filter byte.
4381        */
4382       memset(png_ptr-&gt;prev_row, 0, png_ptr-&gt;rowbytes + 1);
4383 
4384       do
4385       {
4386          png_ptr-&gt;pass++;
4387 
4388          if (png_ptr-&gt;pass &gt;= 7)
4389             break;
4390 
4391          png_ptr-&gt;iwidth = (png_ptr-&gt;width +
4392             png_pass_inc[png_ptr-&gt;pass] - 1 -
4393             png_pass_start[png_ptr-&gt;pass]) /
4394             png_pass_inc[png_ptr-&gt;pass];
4395 
4396          if ((png_ptr-&gt;transformations &amp; PNG_INTERLACE) == 0)
4397          {
4398             png_ptr-&gt;num_rows = (png_ptr-&gt;height +
4399                 png_pass_yinc[png_ptr-&gt;pass] - 1 -
4400                 png_pass_ystart[png_ptr-&gt;pass]) /
4401                 png_pass_yinc[png_ptr-&gt;pass];
4402          }
4403 
4404          else  /* if (png_ptr-&gt;transformations &amp; PNG_INTERLACE) */
4405             break; /* libpng deinterlacing sees every row */
4406 
4407       } while (png_ptr-&gt;num_rows == 0 || png_ptr-&gt;iwidth == 0);
4408 
4409       if (png_ptr-&gt;pass &lt; 7)
4410          return;
4411    }
4412 
4413    /* Here after at the end of the last row of the last pass. */
4414    png_read_finish_IDAT(png_ptr);
4415 }
4416 #endif /* SEQUENTIAL_READ */
4417 
4418 void /* PRIVATE */
4419 png_read_start_row(png_structrp png_ptr)
4420 {
4421    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4422 
4423    /* Start of interlace block */
4424    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};
4425 
4426    /* Offset to next interlace block */
4427    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};
4428 
4429    /* Start of interlace block in the y direction */
4430    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};
4431 
4432    /* Offset to next interlace block in the y direction */
4433    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};
4434 
4435    unsigned int max_pixel_depth;
4436    size_t row_bytes;
4437 
4438    png_debug(1, &quot;in png_read_start_row&quot;);
4439 
4440 #ifdef PNG_READ_TRANSFORMS_SUPPORTED
4441    png_init_read_transformations(png_ptr);
4442 #endif
4443    if (png_ptr-&gt;interlaced != 0)
4444    {
4445       if ((png_ptr-&gt;transformations &amp; PNG_INTERLACE) == 0)
4446          png_ptr-&gt;num_rows = (png_ptr-&gt;height + png_pass_yinc[0] - 1 -
4447              png_pass_ystart[0]) / png_pass_yinc[0];
4448 
4449       else
4450          png_ptr-&gt;num_rows = png_ptr-&gt;height;
4451 
4452       png_ptr-&gt;iwidth = (png_ptr-&gt;width +
4453           png_pass_inc[png_ptr-&gt;pass] - 1 -
4454           png_pass_start[png_ptr-&gt;pass]) /
4455           png_pass_inc[png_ptr-&gt;pass];
4456    }
4457 
4458    else
4459    {
4460       png_ptr-&gt;num_rows = png_ptr-&gt;height;
4461       png_ptr-&gt;iwidth = png_ptr-&gt;width;
4462    }
4463 
4464    max_pixel_depth = (unsigned int)png_ptr-&gt;pixel_depth;
4465 
4466    /* WARNING: * png_read_transform_info (pngrtran.c) performs a simpler set of
4467     * calculations to calculate the final pixel depth, then
4468     * png_do_read_transforms actually does the transforms.  This means that the
4469     * code which effectively calculates this value is actually repeated in three
4470     * separate places.  They must all match.  Innocent changes to the order of
4471     * transformations can and will break libpng in a way that causes memory
4472     * overwrites.
4473     *
4474     * TODO: fix this.
4475     */
4476 #ifdef PNG_READ_PACK_SUPPORTED
4477    if ((png_ptr-&gt;transformations &amp; PNG_PACK) != 0 &amp;&amp; png_ptr-&gt;bit_depth &lt; 8)
4478       max_pixel_depth = 8;
4479 #endif
4480 
4481 #ifdef PNG_READ_EXPAND_SUPPORTED
4482    if ((png_ptr-&gt;transformations &amp; PNG_EXPAND) != 0)
4483    {
4484       if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
4485       {
4486          if (png_ptr-&gt;num_trans != 0)
4487             max_pixel_depth = 32;
4488 
4489          else
4490             max_pixel_depth = 24;
4491       }
4492 
4493       else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_GRAY)
4494       {
4495          if (max_pixel_depth &lt; 8)
4496             max_pixel_depth = 8;
4497 
4498          if (png_ptr-&gt;num_trans != 0)
4499             max_pixel_depth *= 2;
4500       }
4501 
4502       else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_RGB)
4503       {
4504          if (png_ptr-&gt;num_trans != 0)
4505          {
4506             max_pixel_depth *= 4;
4507             max_pixel_depth /= 3;
4508          }
4509       }
4510    }
4511 #endif
4512 
4513 #ifdef PNG_READ_EXPAND_16_SUPPORTED
4514    if ((png_ptr-&gt;transformations &amp; PNG_EXPAND_16) != 0)
4515    {
4516 #  ifdef PNG_READ_EXPAND_SUPPORTED
4517       /* In fact it is an error if it isn&#39;t supported, but checking is
4518        * the safe way.
4519        */
4520       if ((png_ptr-&gt;transformations &amp; PNG_EXPAND) != 0)
4521       {
4522          if (png_ptr-&gt;bit_depth &lt; 16)
4523             max_pixel_depth *= 2;
4524       }
4525       else
4526 #  endif
4527       png_ptr-&gt;transformations &amp;= ~PNG_EXPAND_16;
4528    }
4529 #endif
4530 
4531 #ifdef PNG_READ_FILLER_SUPPORTED
4532    if ((png_ptr-&gt;transformations &amp; (PNG_FILLER)) != 0)
4533    {
4534       if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_GRAY)
4535       {
4536          if (max_pixel_depth &lt;= 8)
4537             max_pixel_depth = 16;
4538 
4539          else
4540             max_pixel_depth = 32;
4541       }
4542 
4543       else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_RGB ||
4544          png_ptr-&gt;color_type == PNG_COLOR_TYPE_PALETTE)
4545       {
4546          if (max_pixel_depth &lt;= 32)
4547             max_pixel_depth = 32;
4548 
4549          else
4550             max_pixel_depth = 64;
4551       }
4552    }
4553 #endif
4554 
4555 #ifdef PNG_READ_GRAY_TO_RGB_SUPPORTED
4556    if ((png_ptr-&gt;transformations &amp; PNG_GRAY_TO_RGB) != 0)
4557    {
4558       if (
4559 #ifdef PNG_READ_EXPAND_SUPPORTED
4560           (png_ptr-&gt;num_trans != 0 &amp;&amp;
4561           (png_ptr-&gt;transformations &amp; PNG_EXPAND) != 0) ||
4562 #endif
4563 #ifdef PNG_READ_FILLER_SUPPORTED
4564           (png_ptr-&gt;transformations &amp; (PNG_FILLER)) != 0 ||
4565 #endif
4566           png_ptr-&gt;color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
4567       {
4568          if (max_pixel_depth &lt;= 16)
4569             max_pixel_depth = 32;
4570 
4571          else
4572             max_pixel_depth = 64;
4573       }
4574 
4575       else
4576       {
4577          if (max_pixel_depth &lt;= 8)
4578          {
4579             if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA)
4580                max_pixel_depth = 32;
4581 
4582             else
4583                max_pixel_depth = 24;
4584          }
4585 
4586          else if (png_ptr-&gt;color_type == PNG_COLOR_TYPE_RGB_ALPHA)
4587             max_pixel_depth = 64;
4588 
4589          else
4590             max_pixel_depth = 48;
4591       }
4592    }
4593 #endif
4594 
4595 #if defined(PNG_READ_USER_TRANSFORM_SUPPORTED) &amp;&amp; \
4596 defined(PNG_USER_TRANSFORM_PTR_SUPPORTED)
4597    if ((png_ptr-&gt;transformations &amp; PNG_USER_TRANSFORM) != 0)
4598    {
4599       unsigned int user_pixel_depth = png_ptr-&gt;user_transform_depth *
4600          png_ptr-&gt;user_transform_channels;
4601 
4602       if (user_pixel_depth &gt; max_pixel_depth)
4603          max_pixel_depth = user_pixel_depth;
4604    }
4605 #endif
4606 
4607    /* This value is stored in png_struct and double checked in the row read
4608     * code.
4609     */
4610    png_ptr-&gt;maximum_pixel_depth = (png_byte)max_pixel_depth;
4611    png_ptr-&gt;transformed_pixel_depth = 0; /* calculated on demand */
4612 
4613    /* Align the width on the next larger 8 pixels.  Mainly used
4614     * for interlacing
4615     */
4616    row_bytes = ((png_ptr-&gt;width + 7) &amp; ~((png_uint_32)7));
4617    /* Calculate the maximum bytes needed, adding a byte and a pixel
4618     * for safety&#39;s sake
4619     */
4620    row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
4621        1 + ((max_pixel_depth + 7) &gt;&gt; 3U);
4622 
4623 #ifdef PNG_MAX_MALLOC_64K
4624    if (row_bytes &gt; (png_uint_32)65536L)
4625       png_error(png_ptr, &quot;This image requires a row greater than 64KB&quot;);
4626 #endif
4627 
4628    if (row_bytes + 48 &gt; png_ptr-&gt;old_big_row_buf_size)
4629    {
4630       png_free(png_ptr, png_ptr-&gt;big_row_buf);
4631       png_free(png_ptr, png_ptr-&gt;big_prev_row);
4632 
4633       if (png_ptr-&gt;interlaced != 0)
4634          png_ptr-&gt;big_row_buf = (png_bytep)png_calloc(png_ptr,
4635              row_bytes + 48);
4636 
4637       else
4638          png_ptr-&gt;big_row_buf = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
4639 
4640       png_ptr-&gt;big_prev_row = (png_bytep)png_malloc(png_ptr, row_bytes + 48);
4641 
4642 #ifdef PNG_ALIGNED_MEMORY_SUPPORTED
4643       /* Use 16-byte aligned memory for row_buf with at least 16 bytes
4644        * of padding before and after row_buf; treat prev_row similarly.
4645        * NOTE: the alignment is to the start of the pixels, one beyond the start
4646        * of the buffer, because of the filter byte.  Prior to libpng 1.5.6 this
4647        * was incorrect; the filter byte was aligned, which had the exact
4648        * opposite effect of that intended.
4649        */
4650       {
4651          png_bytep temp = png_ptr-&gt;big_row_buf + 32;
4652          int extra = (int)((temp - (png_bytep)0) &amp; 0x0f);
4653          png_ptr-&gt;row_buf = temp - extra - 1/*filter byte*/;
4654 
4655          temp = png_ptr-&gt;big_prev_row + 32;
4656          extra = (int)((temp - (png_bytep)0) &amp; 0x0f);
4657          png_ptr-&gt;prev_row = temp - extra - 1/*filter byte*/;
4658       }
4659 
4660 #else
4661       /* Use 31 bytes of padding before and 17 bytes after row_buf. */
4662       png_ptr-&gt;row_buf = png_ptr-&gt;big_row_buf + 31;
4663       png_ptr-&gt;prev_row = png_ptr-&gt;big_prev_row + 31;
4664 #endif
4665       png_ptr-&gt;old_big_row_buf_size = row_bytes + 48;
4666    }
4667 
4668 #ifdef PNG_MAX_MALLOC_64K
4669    if (png_ptr-&gt;rowbytes &gt; 65535)
4670       png_error(png_ptr, &quot;This image requires a row greater than 64KB&quot;);
4671 
4672 #endif
4673    if (png_ptr-&gt;rowbytes &gt; (PNG_SIZE_MAX - 1))
4674       png_error(png_ptr, &quot;Row has too many bytes to allocate in memory&quot;);
4675 
4676    memset(png_ptr-&gt;prev_row, 0, png_ptr-&gt;rowbytes + 1);
4677 
4678    png_debug1(3, &quot;width = %u,&quot;, png_ptr-&gt;width);
4679    png_debug1(3, &quot;height = %u,&quot;, png_ptr-&gt;height);
4680    png_debug1(3, &quot;iwidth = %u,&quot;, png_ptr-&gt;iwidth);
4681    png_debug1(3, &quot;num_rows = %u,&quot;, png_ptr-&gt;num_rows);
4682    png_debug1(3, &quot;rowbytes = %lu,&quot;, (unsigned long)png_ptr-&gt;rowbytes);
4683    png_debug1(3, &quot;irowbytes = %lu&quot;,
4684        (unsigned long)PNG_ROWBYTES(png_ptr-&gt;pixel_depth, png_ptr-&gt;iwidth) + 1);
4685 
4686    /* The sequential reader needs a buffer for IDAT, but the progressive reader
4687     * does not, so free the read buffer now regardless; the sequential reader
4688     * reallocates it on demand.
4689     */
4690    if (png_ptr-&gt;read_buffer != NULL)
4691    {
4692       png_bytep buffer = png_ptr-&gt;read_buffer;
4693 
4694       png_ptr-&gt;read_buffer_size = 0;
4695       png_ptr-&gt;read_buffer = NULL;
4696       png_free(png_ptr, buffer);
4697    }
4698 
4699    /* Finally claim the zstream for the inflate of the IDAT data, use the bits
4700     * value from the stream (note that this will result in a fatal error if the
4701     * IDAT stream has a bogus deflate header window_bits value, but this should
4702     * not be happening any longer!)
4703     */
4704    if (png_inflate_claim(png_ptr, png_IDAT) != Z_OK)
4705       png_error(png_ptr, png_ptr-&gt;zstream.msg);
4706 
4707    png_ptr-&gt;flags |= PNG_FLAG_ROW_INIT;
4708 }
4709 #endif /* READ */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libsplashscreen/libpng/pngread.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="pngpriv.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngrio.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/libpng/pngread.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,14 ***</span>
   * This file is available under and governed by the GNU General Public
   * License version 2 only, as published by the Free Software Foundation.
   * However, the following notice accompanied the original version of this
   * file and, per its terms, should not be removed:
   *
<span class="line-modified">!  * Last changed in libpng 1.6.35 [July 15, 2018]</span>
   * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">!  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)</span>
<span class="line-modified">!  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)</span>
   *
   * This code is released under the libpng license.
   * For conditions of distribution and use, see the disclaimer
   * and license in png.h
   *
<span class="line-new-header">--- 27,14 ---</span>
   * This file is available under and governed by the GNU General Public
   * License version 2 only, as published by the Free Software Foundation.
   * However, the following notice accompanied the original version of this
   * file and, per its terms, should not be removed:
   *
<span class="line-modified">!  * Copyright (c) 2018-2019 Cosmin Truta</span>
   * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">!  * Copyright (c) 1996-1997 Andreas Dilger</span>
<span class="line-modified">!  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.</span>
   *
   * This code is released under the libpng license.
   * For conditions of distribution and use, see the disclaimer
   * and license in png.h
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1020,10 ***</span>
<span class="line-new-header">--- 1020,16 ---</span>
  #ifdef PNG_SET_UNKNOWN_CHUNKS_SUPPORTED
     png_free(png_ptr, png_ptr-&gt;chunk_list);
     png_ptr-&gt;chunk_list = NULL;
  #endif
  
<span class="line-added">+ #if defined(PNG_READ_EXPAND_SUPPORTED) &amp;&amp; \</span>
<span class="line-added">+     defined(PNG_ARM_NEON_IMPLEMENTATION)</span>
<span class="line-added">+    png_free(png_ptr, png_ptr-&gt;riffled_palette);</span>
<span class="line-added">+    png_ptr-&gt;riffled_palette = NULL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
     /* NOTE: the &#39;setjmp&#39; buffer may still be allocated and the memory and error
      * callbacks are still set at this point.  They are required to complete the
      * destruction of the png_struct itself.
      */
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1647,11 ***</span>
      * too.  This allows the simplified API to be compiled without iCCP support,
      * however if the support is there the chunk is still checked to detect
      * errors (which are unfortunately quite common.)
      */
     {
<span class="line-modified">!          static PNG_CONST png_byte chunks_to_process[] = {</span>
              98,  75,  71,  68, &#39;\0&#39;,  /* bKGD */
              99,  72,  82,  77, &#39;\0&#39;,  /* cHRM */
             103,  65,  77,  65, &#39;\0&#39;,  /* gAMA */
  #        ifdef PNG_READ_iCCP_SUPPORTED
             105,  67,  67,  80, &#39;\0&#39;,  /* iCCP */
<span class="line-new-header">--- 1653,11 ---</span>
      * too.  This allows the simplified API to be compiled without iCCP support,
      * however if the support is there the chunk is still checked to detect
      * errors (which are unfortunately quite common.)
      */
     {
<span class="line-modified">!          static const png_byte chunks_to_process[] = {</span>
              98,  75,  71,  68, &#39;\0&#39;,  /* bKGD */
              99,  72,  82,  77, &#39;\0&#39;,  /* cHRM */
             103,  65,  77,  65, &#39;\0&#39;,  /* gAMA */
  #        ifdef PNG_READ_iCCP_SUPPORTED
             105,  67,  67,  80, &#39;\0&#39;,  /* iCCP */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1784,13 ***</span>
  png_create_colormap_entry(png_image_read_control *display,
      png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,
      png_uint_32 alpha, int encoding)
  {
     png_imagep image = display-&gt;image;
<span class="line-modified">!    const int output_encoding = (image-&gt;format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
         P_LINEAR : P_sRGB;
<span class="line-modified">!    const int convert_to_Y = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) == 0 &amp;&amp;</span>
         (red != green || green != blue);
  
     if (ip &gt; 255)
        png_error(image-&gt;opaque-&gt;png_ptr, &quot;color-map index out of range&quot;);
  
<span class="line-new-header">--- 1790,13 ---</span>
  png_create_colormap_entry(png_image_read_control *display,
      png_uint_32 ip, png_uint_32 red, png_uint_32 green, png_uint_32 blue,
      png_uint_32 alpha, int encoding)
  {
     png_imagep image = display-&gt;image;
<span class="line-modified">!    int output_encoding = (image-&gt;format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
         P_LINEAR : P_sRGB;
<span class="line-modified">!    int convert_to_Y = (image-&gt;format &amp; PNG_FORMAT_FLAG_COLOR) == 0 &amp;&amp;</span>
         (red != green || green != blue);
  
     if (ip &gt; 255)
        png_error(image-&gt;opaque-&gt;png_ptr, &quot;color-map index out of range&quot;);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1895,17 ***</span>
        png_error(image-&gt;opaque-&gt;png_ptr, &quot;bad encoding (internal error)&quot;);
  
     /* Store the value. */
     {
  #     ifdef PNG_FORMAT_AFIRST_SUPPORTED
<span class="line-modified">!          const int afirst = (image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0 &amp;&amp;</span>
              (image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0;
  #     else
  #        define afirst 0
  #     endif
  #     ifdef PNG_FORMAT_BGR_SUPPORTED
<span class="line-modified">!          const int bgr = (image-&gt;format &amp; PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;</span>
  #     else
  #        define bgr 0
  #     endif
  
        if (output_encoding == P_LINEAR)
<span class="line-new-header">--- 1901,17 ---</span>
        png_error(image-&gt;opaque-&gt;png_ptr, &quot;bad encoding (internal error)&quot;);
  
     /* Store the value. */
     {
  #     ifdef PNG_FORMAT_AFIRST_SUPPORTED
<span class="line-modified">!          int afirst = (image-&gt;format &amp; PNG_FORMAT_FLAG_AFIRST) != 0 &amp;&amp;</span>
              (image-&gt;format &amp; PNG_FORMAT_FLAG_ALPHA) != 0;
  #     else
  #        define afirst 0
  #     endif
  #     ifdef PNG_FORMAT_BGR_SUPPORTED
<span class="line-modified">!          int bgr = (image-&gt;format &amp; PNG_FORMAT_FLAG_BGR) != 0 ? 2 : 0;</span>
  #     else
  #        define bgr 0
  #     endif
  
        if (output_encoding == P_LINEAR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2111,15 ***</span>
  static int
  png_image_read_colormap(png_voidp argument)
  {
     png_image_read_control *display =
        png_voidcast(png_image_read_control*, argument);
<span class="line-modified">!    const png_imagep image = display-&gt;image;</span>
  
<span class="line-modified">!    const png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;</span>
<span class="line-modified">!    const png_uint_32 output_format = image-&gt;format;</span>
<span class="line-modified">!    const int output_encoding = (output_format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
        P_LINEAR : P_sRGB;
  
     unsigned int cmap_entries;
     unsigned int output_processing;        /* Output processing option */
     unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */
<span class="line-new-header">--- 2117,15 ---</span>
  static int
  png_image_read_colormap(png_voidp argument)
  {
     png_image_read_control *display =
        png_voidcast(png_image_read_control*, argument);
<span class="line-modified">!    png_imagep image = display-&gt;image;</span>
  
<span class="line-modified">!    png_structrp png_ptr = image-&gt;opaque-&gt;png_ptr;</span>
<span class="line-modified">!    png_uint_32 output_format = image-&gt;format;</span>
<span class="line-modified">!    int output_encoding = (output_format &amp; PNG_FORMAT_FLAG_LINEAR) != 0 ?</span>
        P_LINEAR : P_sRGB;
  
     unsigned int cmap_entries;
     unsigned int output_processing;        /* Output processing option */
     unsigned int data_encoding = P_NOTSET; /* Encoding libpng must produce */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2828,11 ***</span>
            */
           {
              unsigned int num_trans = png_ptr-&gt;num_trans;
              png_const_bytep trans = num_trans &gt; 0 ? png_ptr-&gt;trans_alpha : NULL;
              png_const_colorp colormap = png_ptr-&gt;palette;
<span class="line-modified">!             const int do_background = trans != NULL &amp;&amp;</span>
                 (output_format &amp; PNG_FORMAT_FLAG_ALPHA) == 0;
              unsigned int i;
  
              /* Just in case: */
              if (trans == NULL)
<span class="line-new-header">--- 2834,11 ---</span>
            */
           {
              unsigned int num_trans = png_ptr-&gt;num_trans;
              png_const_bytep trans = num_trans &gt; 0 ? png_ptr-&gt;trans_alpha : NULL;
              png_const_colorp colormap = png_ptr-&gt;palette;
<span class="line-modified">!             int do_background = trans != NULL &amp;&amp;</span>
                 (output_format &amp; PNG_FORMAT_FLAG_ALPHA) == 0;
              unsigned int i;
  
              /* Just in case: */
              if (trans == NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3972,11 ***</span>
        /* If the *output* is 16-bit then we need to check for a byte-swap on this
         * architecture.
         */
        if (linear != 0)
        {
<span class="line-modified">!          PNG_CONST png_uint_16 le = 0x0001;</span>
  
           if ((*(png_const_bytep) &amp; le) != 0)
              png_set_swap(png_ptr);
        }
  
<span class="line-new-header">--- 3978,11 ---</span>
        /* If the *output* is 16-bit then we need to check for a byte-swap on this
         * architecture.
         */
        if (linear != 0)
        {
<span class="line-modified">!          png_uint_16 le = 0x0001;</span>
  
           if ((*(png_const_bytep) &amp; le) != 0)
              png_set_swap(png_ptr);
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4134,22 ***</span>
     {
        /* Check for row_stride overflow.  This check is not performed on the
         * original PNG format because it may not occur in the output PNG format
         * and libpng deals with the issues of reading the original.
         */
<span class="line-modified">!       const unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image-&gt;format);</span>
  
        /* The following checks just the &#39;row_stride&#39; calculation to ensure it
         * fits in a signed 32-bit value.  Because channels/components can be
         * either 1 or 2 bytes in size the length of a row can still overflow 32
         * bits; this is just to verify that the &#39;row_stride&#39; argument can be
         * represented.
         */
        if (image-&gt;width &lt;= 0x7fffffffU/channels) /* no overflow */
        {
           png_uint_32 check;
<span class="line-modified">!          const png_uint_32 png_row_stride = image-&gt;width * channels;</span>
  
           if (row_stride == 0)
              row_stride = (png_int_32)/*SAFE*/png_row_stride;
  
           if (row_stride &lt; 0)
<span class="line-new-header">--- 4140,22 ---</span>
     {
        /* Check for row_stride overflow.  This check is not performed on the
         * original PNG format because it may not occur in the output PNG format
         * and libpng deals with the issues of reading the original.
         */
<span class="line-modified">!       unsigned int channels = PNG_IMAGE_PIXEL_CHANNELS(image-&gt;format);</span>
  
        /* The following checks just the &#39;row_stride&#39; calculation to ensure it
         * fits in a signed 32-bit value.  Because channels/components can be
         * either 1 or 2 bytes in size the length of a row can still overflow 32
         * bits; this is just to verify that the &#39;row_stride&#39; argument can be
         * represented.
         */
        if (image-&gt;width &lt;= 0x7fffffffU/channels) /* no overflow */
        {
           png_uint_32 check;
<span class="line-modified">!          png_uint_32 png_row_stride = image-&gt;width * channels;</span>
  
           if (row_stride == 0)
              row_stride = (png_int_32)/*SAFE*/png_row_stride;
  
           if (row_stride &lt; 0)
</pre>
<center><a href="pngpriv.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngrio.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
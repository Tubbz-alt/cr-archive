<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../libfreetype/src/type1/t1tokens.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="gif_err.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /******************************************************************************
  26 
  27 dgif_lib.c - GIF decoding
  28 
  29 The functions here and in egif_lib.c are partitioned carefully so that
  30 if you only require one of read and write capability, only one of these
  31 two modules will be linked.  Preserve this property!
  32 


  33 *****************************************************************************/
  34 
  35 #include &lt;stdlib.h&gt;
  36 #include &lt;limits.h&gt;
  37 #include &lt;stdint.h&gt;
  38 #include &lt;fcntl.h&gt;
  39 #include &lt;stdio.h&gt;
  40 #include &lt;string.h&gt;
  41 
  42 #ifdef _WIN32
  43 #include &lt;io.h&gt;
  44 #else
  45 #include &lt;unistd.h&gt;
  46 #endif /* _WIN32 */
  47 
  48 #include &quot;gif_lib.h&quot;
  49 #include &quot;gif_lib_private.h&quot;
  50 
  51 /* compose unsigned little endian value */
  52 #define UNSIGNED_LITTLE_ENDIAN(lo, hi) ((lo) | ((hi) &lt;&lt; 8))
  53 
  54 /* avoid extra function call in case we use fread (TVT) */
<span class="line-modified">  55 #define READ(_gif,_buf,_len)                                     \</span>
<span class="line-modified">  56   (((GifFilePrivateType*)_gif-&gt;Private)-&gt;Read ?                   \</span>
<span class="line-modified">  57     ((GifFilePrivateType*)_gif-&gt;Private)-&gt;Read(_gif,_buf,_len) : \</span>
<span class="line-modified">  58     fread(_buf,1,_len,((GifFilePrivateType*)_gif-&gt;Private)-&gt;File))</span>



  59 
  60 static int DGifGetWord(GifFileType *GifFile, GifWord *Word);
  61 static int DGifSetupDecompress(GifFileType *GifFile);
  62 static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
  63                               int LineLen);
  64 static int DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode);
  65 static int DGifDecompressInput(GifFileType *GifFile, int *Code);
  66 static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
  67                              GifByteType *NextByte);
  68 
  69 /******************************************************************************
  70  Open a new GIF file for read, given by its name.
  71  Returns dynamically allocated GifFileType pointer which serves as the GIF
  72  info record.
  73 ******************************************************************************/
  74 GifFileType *
  75 DGifOpenFileName(const char *FileName, int *Error)
  76 {
  77     int FileHandle;
  78     GifFileType *GifFile;
</pre>
<hr />
<pre>
 125 
 126     /*@i1@*/memset(Private, &#39;\0&#39;, sizeof(GifFilePrivateType));
 127 
 128 #ifdef _WIN32
 129     _setmode(FileHandle, O_BINARY);    /* Make sure it is in binary mode. */
 130 #endif /* _WIN32 */
 131 
 132     f = fdopen(FileHandle, &quot;rb&quot;);    /* Make it into a stream: */
 133 
 134     /*@-mustfreeonly@*/
 135     GifFile-&gt;Private = (void *)Private;
 136     Private-&gt;FileHandle = FileHandle;
 137     Private-&gt;File = f;
 138     Private-&gt;FileState = FILE_STATE_READ;
 139     Private-&gt;Read = NULL;        /* don&#39;t use alternate input method (TVT) */
 140     GifFile-&gt;UserData = NULL;    /* TVT */
 141     /*@=mustfreeonly@*/
 142 
 143     /* Let&#39;s see if this is a GIF file: */
 144     /* coverity[check_return] */
<span class="line-modified"> 145     if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {</span>
 146         if (Error != NULL)
 147             *Error = D_GIF_ERR_READ_FAILED;
 148         (void)fclose(f);
 149         free((char *)Private);
 150         free((char *)GifFile);
 151         return NULL;
 152     }
 153 
 154     /* Check for GIF prefix at start of file */
 155     Buf[GIF_STAMP_LEN] = 0;
 156     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
 157         if (Error != NULL)
 158             *Error = D_GIF_ERR_NOT_GIF_FILE;
 159         (void)fclose(f);
 160         free((char *)Private);
 161         free((char *)GifFile);
 162         return NULL;
 163     }
 164 
 165     if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
</pre>
<hr />
<pre>
 202 
 203     Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
 204     if (!Private) {
 205         if (Error != NULL)
 206             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 207         free((char *)GifFile);
 208         return NULL;
 209     }
 210     /*@i1@*/memset(Private, &#39;\0&#39;, sizeof(GifFilePrivateType));
 211 
 212     GifFile-&gt;Private = (void *)Private;
 213     Private-&gt;FileHandle = 0;
 214     Private-&gt;File = NULL;
 215     Private-&gt;FileState = FILE_STATE_READ;
 216 
 217     Private-&gt;Read = readFunc;    /* TVT */
 218     GifFile-&gt;UserData = userData;    /* TVT */
 219 
 220     /* Lets see if this is a GIF file: */
 221     /* coverity[check_return] */
<span class="line-modified"> 222     if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {</span>
 223         if (Error != NULL)
 224             *Error = D_GIF_ERR_READ_FAILED;
 225         free((char *)Private);
 226         free((char *)GifFile);
 227         return NULL;
 228     }
 229 
 230     /* Check for GIF prefix at start of file */
 231     Buf[GIF_STAMP_LEN] = &#39;\0&#39;;
 232     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
 233         if (Error != NULL)
 234             *Error = D_GIF_ERR_NOT_GIF_FILE;
 235         free((char *)Private);
 236         free((char *)GifFile);
 237         return NULL;
 238     }
 239 
 240     if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
 241         free((char *)Private);
 242         free((char *)GifFile);
</pre>
<hr />
<pre>
 259 ******************************************************************************/
 260 int
 261 DGifGetScreenDesc(GifFileType *GifFile)
 262 {
 263     int BitsPerPixel;
 264     bool SortFlag;
 265     GifByteType Buf[3];
 266     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 267 
 268     if (!IS_READABLE(Private)) {
 269         /* This file was NOT open for reading: */
 270         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 271         return GIF_ERROR;
 272     }
 273 
 274     /* Put the screen descriptor into the file: */
 275     if (DGifGetWord(GifFile, &amp;GifFile-&gt;SWidth) == GIF_ERROR ||
 276         DGifGetWord(GifFile, &amp;GifFile-&gt;SHeight) == GIF_ERROR)
 277         return GIF_ERROR;
 278 
<span class="line-modified"> 279     if (READ(GifFile, Buf, 3) != 3) {</span>
 280         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 281         GifFreeMapObject(GifFile-&gt;SColorMap);
 282         GifFile-&gt;SColorMap = NULL;
 283         return GIF_ERROR;
 284     }
 285     GifFile-&gt;SColorResolution = (((Buf[0] &amp; 0x70) + 1) &gt;&gt; 4) + 1;
 286     SortFlag = (Buf[0] &amp; 0x08) != 0;
 287     BitsPerPixel = (Buf[0] &amp; 0x07) + 1;
 288     GifFile-&gt;SBackGroundColor = Buf[1];
 289     GifFile-&gt;AspectByte = Buf[2];
 290     if (Buf[0] &amp; 0x80) {    /* Do we have global color map? */
 291         int i;
 292 
 293         GifFile-&gt;SColorMap = GifMakeMapObject(1 &lt;&lt; BitsPerPixel, NULL);
 294         if (GifFile-&gt;SColorMap == NULL) {
 295             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 296             return GIF_ERROR;
 297         }
 298 
 299         /* Get the global color map: */
 300         GifFile-&gt;SColorMap-&gt;SortFlag = SortFlag;
 301         for (i = 0; i &lt; GifFile-&gt;SColorMap-&gt;ColorCount; i++) {
 302             /* coverity[check_return] */
<span class="line-modified"> 303             if (READ(GifFile, Buf, 3) != 3) {</span>
 304                 GifFreeMapObject(GifFile-&gt;SColorMap);
 305                 GifFile-&gt;SColorMap = NULL;
 306                 GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 307                 return GIF_ERROR;
 308             }
 309             GifFile-&gt;SColorMap-&gt;Colors[i].Red = Buf[0];
 310             GifFile-&gt;SColorMap-&gt;Colors[i].Green = Buf[1];
 311             GifFile-&gt;SColorMap-&gt;Colors[i].Blue = Buf[2];
 312         }
 313     } else {
 314         GifFile-&gt;SColorMap = NULL;
 315     }
 316 





 317     return GIF_OK;
 318 }
 319 











 320 /******************************************************************************
 321  This routine should be called before any attempt to read an image.
 322 ******************************************************************************/
 323 int
 324 DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
 325 {
 326     GifByteType Buf;
 327     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 328 
 329     if (!IS_READABLE(Private)) {
 330         /* This file was NOT open for reading: */
 331         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 332         return GIF_ERROR;
 333     }
 334 
 335     /* coverity[check_return] */
<span class="line-modified"> 336     if (READ(GifFile, &amp;Buf, 1) != 1) {</span>
 337         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 338         return GIF_ERROR;
 339     }
 340 

 341     switch (Buf) {
 342       case DESCRIPTOR_INTRODUCER:
 343           *Type = IMAGE_DESC_RECORD_TYPE;
 344           break;
 345       case EXTENSION_INTRODUCER:
 346           *Type = EXTENSION_RECORD_TYPE;
 347           break;
 348       case TERMINATOR_INTRODUCER:
 349           *Type = TERMINATE_RECORD_TYPE;
 350           break;
 351       default:
 352           *Type = UNDEFINED_RECORD_TYPE;
 353           GifFile-&gt;Error = D_GIF_ERR_WRONG_RECORD;
 354           return GIF_ERROR;
 355     }
 356 
 357     return GIF_OK;
 358 }
 359 
<span class="line-removed"> 360 /******************************************************************************</span>
<span class="line-removed"> 361  This routine should be called before any attempt to read an image.</span>
<span class="line-removed"> 362  Note it is assumed the Image desc. header has been read.</span>
<span class="line-removed"> 363 ******************************************************************************/</span>
 364 int
<span class="line-modified"> 365 DGifGetImageDesc(GifFileType *GifFile)</span>
 366 {
 367     unsigned int BitsPerPixel;
 368     GifByteType Buf[3];
 369     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
<span class="line-removed"> 370     SavedImage *sp;</span>
 371 
 372     if (!IS_READABLE(Private)) {
 373         /* This file was NOT open for reading: */
 374         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 375         return GIF_ERROR;
 376     }
 377 
 378     if (DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Left) == GIF_ERROR ||
 379         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Top) == GIF_ERROR ||
 380         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Width) == GIF_ERROR ||
 381         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Height) == GIF_ERROR)
 382         return GIF_ERROR;
<span class="line-modified"> 383     if (READ(GifFile, Buf, 1) != 1) {</span>
 384         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 385         GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 386         GifFile-&gt;Image.ColorMap = NULL;
 387         return GIF_ERROR;
 388     }
 389     BitsPerPixel = (Buf[0] &amp; 0x07) + 1;
 390     GifFile-&gt;Image.Interlace = (Buf[0] &amp; 0x40) ? true : false;
 391 
 392     /* Setup the colormap */
 393     if (GifFile-&gt;Image.ColorMap) {
 394         GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 395         GifFile-&gt;Image.ColorMap = NULL;
 396     }
 397     /* Does this image have local color map? */
 398     if (Buf[0] &amp; 0x80) {
 399         unsigned int i;
 400 
 401         GifFile-&gt;Image.ColorMap = GifMakeMapObject(1 &lt;&lt; BitsPerPixel, NULL);
 402         if (GifFile-&gt;Image.ColorMap == NULL) {
 403             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 404             return GIF_ERROR;
 405         }
 406 
 407         /* Get the image local color map: */
 408         for (i = 0; i &lt; GifFile-&gt;Image.ColorMap-&gt;ColorCount; i++) {
 409             /* coverity[check_return] */
<span class="line-modified"> 410             if (READ(GifFile, Buf, 3) != 3) {</span>
 411                 GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 412                 GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 413                 GifFile-&gt;Image.ColorMap = NULL;
 414                 return GIF_ERROR;
 415             }
 416             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Red = Buf[0];
 417             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Green = Buf[1];
 418             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Blue = Buf[2];
 419         }
 420     }
 421 



























 422     if (GifFile-&gt;SavedImages) {
 423         SavedImage* new_saved_images =
 424             (SavedImage *)reallocarray(GifFile-&gt;SavedImages,
 425                             (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
 426         if (new_saved_images == NULL) {
 427             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 428             return GIF_ERROR;
 429         }
 430         GifFile-&gt;SavedImages = new_saved_images;
 431     } else {
 432         if ((GifFile-&gt;SavedImages =
 433              (SavedImage *) malloc(sizeof(SavedImage))) == NULL) {
 434             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 435             return GIF_ERROR;
 436         }
 437     }
 438 
 439     sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount];
 440     memcpy(&amp;sp-&gt;ImageDesc, &amp;GifFile-&gt;Image, sizeof(GifImageDesc));
 441     if (GifFile-&gt;Image.ColorMap != NULL) {
 442         sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
 443                                  GifFile-&gt;Image.ColorMap-&gt;ColorCount,
 444                                  GifFile-&gt;Image.ColorMap-&gt;Colors);
 445         if (sp-&gt;ImageDesc.ColorMap == NULL) {
 446             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 447             return GIF_ERROR;
 448         }
 449     }
 450     sp-&gt;RasterBits = (unsigned char *)NULL;
 451     sp-&gt;ExtensionBlockCount = 0;
 452     sp-&gt;ExtensionBlocks = (ExtensionBlock *) NULL;
 453 
 454     GifFile-&gt;ImageCount++;
 455 
<span class="line-modified"> 456     Private-&gt;PixelCount = (long)GifFile-&gt;Image.Width *</span>
<span class="line-removed"> 457        (long)GifFile-&gt;Image.Height;</span>
<span class="line-removed"> 458 </span>
<span class="line-removed"> 459     /* Reset decompress algorithm parameters. */</span>
<span class="line-removed"> 460     return DGifSetupDecompress(GifFile);</span>
 461 }
 462 
 463 /******************************************************************************
 464  Get one full scanned line (Line) of length LineLen from GIF file.
 465 ******************************************************************************/
 466 int
 467 DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
 468 {
 469     GifByteType *Dummy;
 470     GifFilePrivateType *Private = (GifFilePrivateType *) GifFile-&gt;Private;
 471 
 472     if (!IS_READABLE(Private)) {
 473         /* This file was NOT open for reading: */
 474         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 475         return GIF_ERROR;
 476     }
 477 
 478     if (!LineLen)
 479         LineLen = GifFile-&gt;Image.Width;
 480 
</pre>
<hr />
<pre>
 533             while (Dummy != NULL) ;
 534         }
 535         return GIF_OK;
 536     } else
 537         return GIF_ERROR;
 538 }
 539 
 540 /******************************************************************************
 541  Get an extension block (see GIF manual) from GIF file. This routine only
 542  returns the first data block, and DGifGetExtensionNext should be called
 543  after this one until NULL extension is returned.
 544  The Extension should NOT be freed by the user (not dynamically allocated).
 545  Note it is assumed the Extension description header has been read.
 546 ******************************************************************************/
 547 int
 548 DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
 549 {
 550     GifByteType Buf;
 551     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 552 

 553     if (!IS_READABLE(Private)) {
 554         /* This file was NOT open for reading: */
 555         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 556         return GIF_ERROR;
 557     }
 558 
 559     /* coverity[check_return] */
<span class="line-modified"> 560     if (READ(GifFile, &amp;Buf, 1) != 1) {</span>
 561         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 562         return GIF_ERROR;
 563     }
 564     *ExtCode = Buf;

 565 
 566     return DGifGetExtensionNext(GifFile, Extension);
 567 }
 568 
 569 /******************************************************************************
 570  Get a following extension block (see GIF manual) from GIF file. This
 571  routine should be called until NULL Extension is returned.
 572  The Extension should NOT be freed by the user (not dynamically allocated).
 573 ******************************************************************************/
 574 int
 575 DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
 576 {
 577     GifByteType Buf;
 578     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 579 
<span class="line-modified"> 580     if (READ(GifFile, &amp;Buf, 1) != 1) {</span>

 581         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 582         return GIF_ERROR;
 583     }


 584     if (Buf &gt; 0) {
 585         *Extension = Private-&gt;Buf;    /* Use private unused buffer. */
 586         (*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
 587         /* coverity[tainted_data,check_return] */
<span class="line-modified"> 588         if (READ(GifFile, &amp;((*Extension)[1]), Buf) != Buf) {</span>
 589             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 590             return GIF_ERROR;
 591         }
 592     } else
 593         *Extension = NULL;

 594 
 595     return GIF_OK;
 596 }
 597 
 598 /******************************************************************************
 599  Extract a Graphics Control Block from raw extension data
 600 ******************************************************************************/
 601 
 602 int DGifExtensionToGCB(const size_t GifExtensionLength,
 603                        const GifByteType *GifExtension,
 604                        GraphicsControlBlock *GCB)
 605 {
 606     if (GifExtensionLength != 4) {
 607         return GIF_ERROR;
 608     }
 609 
 610     GCB-&gt;DisposalMode = (GifExtension[0] &gt;&gt; 2) &amp; 0x07;
 611     GCB-&gt;UserInputFlag = (GifExtension[0] &amp; 0x02) != 0;
 612     GCB-&gt;DelayTime = UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
 613     if (GifExtension[0] &amp; 0x01)
</pre>
<hr />
<pre>
 690         free(GifFile);
 691         return GIF_ERROR;
 692     }
 693 
 694     free((char *)GifFile-&gt;Private);
 695     free(GifFile);
 696     if (ErrorCode != NULL)
 697         *ErrorCode = D_GIF_SUCCEEDED;
 698     return GIF_OK;
 699 }
 700 
 701 /******************************************************************************
 702  Get 2 bytes (word) from the given file:
 703 ******************************************************************************/
 704 static int
 705 DGifGetWord(GifFileType *GifFile, GifWord *Word)
 706 {
 707     unsigned char c[2];
 708 
 709     /* coverity[check_return] */
<span class="line-modified"> 710     if (READ(GifFile, c, 2) != 2) {</span>
 711         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 712         return GIF_ERROR;
 713     }
 714 
 715     *Word = (GifWord)UNSIGNED_LITTLE_ENDIAN(c[0], c[1]);
 716     return GIF_OK;
 717 }
 718 
 719 /******************************************************************************
 720  Get the image code in compressed form.  This routine can be called if the
 721  information needed to be piped out as is. Obviously this is much faster
 722  than decoding and encoding again. This routine should be followed by calls
 723  to DGifGetCodeNext, until NULL block is returned.
 724  The block should NOT be freed by the user (not dynamically allocated).
 725 ******************************************************************************/
 726 int
 727 DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
 728 {
 729     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 730 
</pre>
<hr />
<pre>
 735     }
 736 
 737     *CodeSize = Private-&gt;BitsPerPixel;
 738 
 739     return DGifGetCodeNext(GifFile, CodeBlock);
 740 }
 741 
 742 /******************************************************************************
 743  Continue to get the image code in compressed form. This routine should be
 744  called until NULL block is returned.
 745  The block should NOT be freed by the user (not dynamically allocated).
 746 ******************************************************************************/
 747 int
 748 DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
 749 {
 750     GifByteType Buf;
 751     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 752 
 753     /* coverity[tainted_data_argument] */
 754     /* coverity[check_return] */
<span class="line-modified"> 755     if (READ(GifFile, &amp;Buf, 1) != 1) {</span>
 756         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 757         return GIF_ERROR;
 758     }
 759 
 760     /* coverity[lower_bounds] */
 761     if (Buf &gt; 0) {
 762         *CodeBlock = Private-&gt;Buf;    /* Use private unused buffer. */
 763         (*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
 764         /* coverity[tainted_data] */
<span class="line-modified"> 765         if (READ(GifFile, &amp;((*CodeBlock)[1]), Buf) != Buf) {</span>
 766             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 767             return GIF_ERROR;
 768         }
 769     } else {
 770         *CodeBlock = NULL;
 771         Private-&gt;Buf[0] = 0;    /* Make sure the buffer is empty! */
 772         Private-&gt;PixelCount = 0;    /* And local info. indicate image read. */
 773     }
 774 
 775     return GIF_OK;
 776 }
 777 
 778 /******************************************************************************
 779  Setup the LZ decompression for this image:
 780 ******************************************************************************/
 781 static int
 782 DGifSetupDecompress(GifFileType *GifFile)
 783 {
 784     int i, BitsPerPixel;
 785     GifByteType CodeSize;
 786     GifPrefixType *Prefix;
 787     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 788 
 789     /* coverity[check_return] */
<span class="line-modified"> 790     if (READ(GifFile, &amp;CodeSize, 1) &lt; 1) {    /* Read Code size from file. */</span>
 791         return GIF_ERROR;    /* Failed to read Code size. */
 792     }
 793     BitsPerPixel = CodeSize;
 794 
 795     /* this can only happen on a severely malformed GIF */
 796     if (BitsPerPixel &gt; 8) {
 797         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;    /* somewhat bogus error code */
 798         return GIF_ERROR;    /* Failed to read Code size. */
 799     }
 800 
 801     Private-&gt;Buf[0] = 0;    /* Input Buffer empty. */
 802     Private-&gt;BitsPerPixel = BitsPerPixel;
 803     Private-&gt;ClearCode = (1 &lt;&lt; BitsPerPixel);
 804     Private-&gt;EOFCode = Private-&gt;ClearCode + 1;
 805     Private-&gt;RunningCode = Private-&gt;EOFCode + 1;
 806     Private-&gt;RunningBits = BitsPerPixel + 1;    /* Number of bits per code. */
 807     Private-&gt;MaxCode1 = 1 &lt;&lt; Private-&gt;RunningBits;    /* Max. code + 1. */
 808     Private-&gt;StackPtr = 0;    /* No pixels on the pixel stack. */
 809     Private-&gt;LastCode = NO_SUCH_CODE;
 810     Private-&gt;CrntShiftState = 0;    /* No information in CrntShiftDWord. */
</pre>
<hr />
<pre>
 904                 /* Now (if image is O.K.) we should not get a NO_SUCH_CODE
 905                  * during the trace. As we might loop forever, in case of
 906                  * defective image, we use StackPtr as loop counter and stop
 907                  * before overflowing Stack[]. */
 908                 while (StackPtr &lt; LZ_MAX_CODE &amp;&amp;
 909                        CrntPrefix &gt; ClearCode &amp;&amp; CrntPrefix &lt;= LZ_MAX_CODE) {
 910                     Stack[StackPtr++] = Suffix[CrntPrefix];
 911                     CrntPrefix = Prefix[CrntPrefix];
 912                 }
 913                 if (StackPtr &gt;= LZ_MAX_CODE || CrntPrefix &gt; LZ_MAX_CODE) {
 914                     GifFile-&gt;Error = D_GIF_ERR_IMAGE_DEFECT;
 915                     return GIF_ERROR;
 916                 }
 917                 /* Push the last character on stack: */
 918                 Stack[StackPtr++] = CrntPrefix;
 919 
 920                 /* Now lets pop all the stack into output: */
 921                 while (StackPtr != 0 &amp;&amp; i &lt; LineLen)
 922                     Line[i++] = Stack[--StackPtr];
 923             }
<span class="line-modified"> 924             if (LastCode != NO_SUCH_CODE &amp;&amp; Prefix[Private-&gt;RunningCode - 2] == NO_SUCH_CODE) {</span>
 925                 Prefix[Private-&gt;RunningCode - 2] = LastCode;
 926 
 927                 if (CrntCode == Private-&gt;RunningCode - 2) {
 928                     /* Only allowed if CrntCode is exactly the running code:
 929                      * In that case CrntCode = XXXCode, CrntCode or the
 930                      * prefix code is last code and the suffix char is
 931                      * exactly the prefix of last code! */
 932                     Suffix[Private-&gt;RunningCode - 2] =
 933                        DGifGetPrefixChar(Prefix, LastCode, ClearCode);
 934                 } else {
 935                     Suffix[Private-&gt;RunningCode - 2] =
 936                        DGifGetPrefixChar(Prefix, CrntCode, ClearCode);
 937                 }
 938             }
 939             LastCode = CrntCode;
 940         }
 941     }
 942 
 943     Private-&gt;LastCode = LastCode;
 944     Private-&gt;StackPtr = StackPtr;
</pre>
<hr />
<pre>
1052         ++Private-&gt;RunningCode &gt; Private-&gt;MaxCode1 &amp;&amp;
1053         Private-&gt;RunningBits &lt; LZ_BITS) {
1054         Private-&gt;MaxCode1 &lt;&lt;= 1;
1055         Private-&gt;RunningBits++;
1056     }
1057     return GIF_OK;
1058 }
1059 
1060 /******************************************************************************
1061  This routines read one GIF data block at a time and buffers it internally
1062  so that the decompression routine could access it.
1063  The routine returns the next byte from its internal buffer (or read next
1064  block in if buffer empty) and returns GIF_OK if succesful.
1065 ******************************************************************************/
1066 static int
1067 DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
1068 {
1069     if (Buf[0] == 0) {
1070         /* Needs to read the next buffer - this one is empty: */
1071         /* coverity[check_return] */
<span class="line-modified">1072         if (READ(GifFile, Buf, 1) != 1) {</span>
1073             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
1074             return GIF_ERROR;
1075         }
1076         /* There shouldn&#39;t be any empty data blocks here as the LZW spec
1077          * says the LZW termination code should come first.  Therefore we
1078          * shouldn&#39;t be inside this routine at that point.
1079          */
1080         if (Buf[0] == 0) {
1081             GifFile-&gt;Error = D_GIF_ERR_IMAGE_DEFECT;
1082             return GIF_ERROR;
1083         }
<span class="line-modified">1084         if (READ(GifFile, &amp;Buf[1], Buf[0]) != Buf[0]) {</span>
1085             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
1086             return GIF_ERROR;
1087         }
1088         *NextByte = Buf[1];
1089         Buf[1] = 2;    /* We use now the second place as last char read! */
1090         Buf[0]--;
1091     } else {
1092         *NextByte = Buf[Buf[1]++];
1093         Buf[0]--;
1094     }
1095 
1096     return GIF_OK;
1097 }
1098 
1099 /******************************************************************************
1100  This routine reads an entire GIF into core, hanging all its state info off
1101  the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()
1102  first to initialize I/O.  Its inverse is EGifSpew().
1103 *******************************************************************************/
1104 int
</pre>
<hr />
<pre>
1107     size_t ImageSize;
1108     GifRecordType RecordType;
1109     SavedImage *sp;
1110     GifByteType *ExtData;
1111     int ExtFunction;
1112 
1113     GifFile-&gt;ExtensionBlocks = NULL;
1114     GifFile-&gt;ExtensionBlockCount = 0;
1115 
1116     do {
1117         if (DGifGetRecordType(GifFile, &amp;RecordType) == GIF_ERROR)
1118             return (GIF_ERROR);
1119 
1120         switch (RecordType) {
1121           case IMAGE_DESC_RECORD_TYPE:
1122               if (DGifGetImageDesc(GifFile) == GIF_ERROR)
1123                   return (GIF_ERROR);
1124 
1125               sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount - 1];
1126               /* Allocate memory for the image */
<span class="line-modified">1127               if (sp-&gt;ImageDesc.Width &lt; 0 &amp;&amp; sp-&gt;ImageDesc.Height &lt; 0 &amp;&amp;</span>
1128                       sp-&gt;ImageDesc.Width &gt; (INT_MAX / sp-&gt;ImageDesc.Height)) {
1129                   return GIF_ERROR;
1130               }
1131               ImageSize = sp-&gt;ImageDesc.Width * sp-&gt;ImageDesc.Height;
1132 
1133               if (ImageSize &gt; (SIZE_MAX / sizeof(GifPixelType))) {
1134                   return GIF_ERROR;
1135               }
1136               sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL, ImageSize,
1137                       sizeof(GifPixelType));
1138 
1139               if (sp-&gt;RasterBits == NULL) {
1140                   return GIF_ERROR;
1141               }
1142 
1143               if (sp-&gt;ImageDesc.Interlace) {
1144                   int i, j;
1145                    /*
1146                     * The way an interlaced image should be read -
1147                     * offsets and jumps...
</pre>
<hr />
<pre>
1167               if (GifFile-&gt;ExtensionBlocks) {
1168                   sp-&gt;ExtensionBlocks = GifFile-&gt;ExtensionBlocks;
1169                   sp-&gt;ExtensionBlockCount = GifFile-&gt;ExtensionBlockCount;
1170 
1171                   GifFile-&gt;ExtensionBlocks = NULL;
1172                   GifFile-&gt;ExtensionBlockCount = 0;
1173               }
1174               break;
1175 
1176           case EXTENSION_RECORD_TYPE:
1177               if (DGifGetExtension(GifFile,&amp;ExtFunction,&amp;ExtData) == GIF_ERROR)
1178                   return (GIF_ERROR);
1179               /* Create an extension block with our data */
1180               if (ExtData != NULL) {
1181                   if (GifAddExtensionBlock(&amp;GifFile-&gt;ExtensionBlockCount,
1182                                &amp;GifFile-&gt;ExtensionBlocks,
1183                                ExtFunction, ExtData[0], &amp;ExtData[1])
1184                       == GIF_ERROR)
1185                       return (GIF_ERROR);
1186               }
<span class="line-modified">1187               while (ExtData != NULL) {</span>
1188                   if (DGifGetExtensionNext(GifFile, &amp;ExtData) == GIF_ERROR)
1189                       return (GIF_ERROR);


1190                   /* Continue the extension block */
1191                   if (ExtData != NULL)
1192                       if (GifAddExtensionBlock(&amp;GifFile-&gt;ExtensionBlockCount,
1193                                    &amp;GifFile-&gt;ExtensionBlocks,
1194                                    CONTINUE_EXT_FUNC_CODE,
1195                                    ExtData[0], &amp;ExtData[1]) == GIF_ERROR)
1196                               return (GIF_ERROR);
1197               }
1198               break;
1199 
1200           case TERMINATE_RECORD_TYPE:
1201               break;
1202 
1203           default:    /* Should be trapped by DGifGetRecordType */
1204               break;
1205         }
1206     } while (RecordType != TERMINATE_RECORD_TYPE);
1207 
1208     /* Sanity check for corrupted file */
1209     if (GifFile-&gt;ImageCount == 0) {
</pre>
</td>
<td>
<hr />
<pre>
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /******************************************************************************
  26 
  27 dgif_lib.c - GIF decoding
  28 
  29 The functions here and in egif_lib.c are partitioned carefully so that
  30 if you only require one of read and write capability, only one of these
  31 two modules will be linked.  Preserve this property!
  32 
<span class="line-added">  33 SPDX-License-Identifier: MIT</span>
<span class="line-added">  34 </span>
  35 *****************************************************************************/
  36 
  37 #include &lt;stdlib.h&gt;
  38 #include &lt;limits.h&gt;
  39 #include &lt;stdint.h&gt;
  40 #include &lt;fcntl.h&gt;
  41 #include &lt;stdio.h&gt;
  42 #include &lt;string.h&gt;
  43 
  44 #ifdef _WIN32
  45 #include &lt;io.h&gt;
  46 #else
  47 #include &lt;unistd.h&gt;
  48 #endif /* _WIN32 */
  49 
  50 #include &quot;gif_lib.h&quot;
  51 #include &quot;gif_lib_private.h&quot;
  52 
  53 /* compose unsigned little endian value */
  54 #define UNSIGNED_LITTLE_ENDIAN(lo, hi) ((lo) | ((hi) &lt;&lt; 8))
  55 
  56 /* avoid extra function call in case we use fread (TVT) */
<span class="line-modified">  57 static int InternalRead(GifFileType *gif, GifByteType *buf, int len) {</span>
<span class="line-modified">  58     //fprintf(stderr, &quot;### Read: %d\n&quot;, len);</span>
<span class="line-modified">  59     return</span>
<span class="line-modified">  60     (((GifFilePrivateType*)gif-&gt;Private)-&gt;Read ?</span>
<span class="line-added">  61      ((GifFilePrivateType*)gif-&gt;Private)-&gt;Read(gif,buf,len) :</span>
<span class="line-added">  62      fread(buf,1,len,((GifFilePrivateType*)gif-&gt;Private)-&gt;File));</span>
<span class="line-added">  63 }</span>
  64 
  65 static int DGifGetWord(GifFileType *GifFile, GifWord *Word);
  66 static int DGifSetupDecompress(GifFileType *GifFile);
  67 static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
  68                               int LineLen);
  69 static int DGifGetPrefixChar(GifPrefixType *Prefix, int Code, int ClearCode);
  70 static int DGifDecompressInput(GifFileType *GifFile, int *Code);
  71 static int DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf,
  72                              GifByteType *NextByte);
  73 
  74 /******************************************************************************
  75  Open a new GIF file for read, given by its name.
  76  Returns dynamically allocated GifFileType pointer which serves as the GIF
  77  info record.
  78 ******************************************************************************/
  79 GifFileType *
  80 DGifOpenFileName(const char *FileName, int *Error)
  81 {
  82     int FileHandle;
  83     GifFileType *GifFile;
</pre>
<hr />
<pre>
 130 
 131     /*@i1@*/memset(Private, &#39;\0&#39;, sizeof(GifFilePrivateType));
 132 
 133 #ifdef _WIN32
 134     _setmode(FileHandle, O_BINARY);    /* Make sure it is in binary mode. */
 135 #endif /* _WIN32 */
 136 
 137     f = fdopen(FileHandle, &quot;rb&quot;);    /* Make it into a stream: */
 138 
 139     /*@-mustfreeonly@*/
 140     GifFile-&gt;Private = (void *)Private;
 141     Private-&gt;FileHandle = FileHandle;
 142     Private-&gt;File = f;
 143     Private-&gt;FileState = FILE_STATE_READ;
 144     Private-&gt;Read = NULL;        /* don&#39;t use alternate input method (TVT) */
 145     GifFile-&gt;UserData = NULL;    /* TVT */
 146     /*@=mustfreeonly@*/
 147 
 148     /* Let&#39;s see if this is a GIF file: */
 149     /* coverity[check_return] */
<span class="line-modified"> 150     if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {</span>
 151         if (Error != NULL)
 152             *Error = D_GIF_ERR_READ_FAILED;
 153         (void)fclose(f);
 154         free((char *)Private);
 155         free((char *)GifFile);
 156         return NULL;
 157     }
 158 
 159     /* Check for GIF prefix at start of file */
 160     Buf[GIF_STAMP_LEN] = 0;
 161     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
 162         if (Error != NULL)
 163             *Error = D_GIF_ERR_NOT_GIF_FILE;
 164         (void)fclose(f);
 165         free((char *)Private);
 166         free((char *)GifFile);
 167         return NULL;
 168     }
 169 
 170     if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
</pre>
<hr />
<pre>
 207 
 208     Private = (GifFilePrivateType *)calloc(1, sizeof(GifFilePrivateType));
 209     if (!Private) {
 210         if (Error != NULL)
 211             *Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 212         free((char *)GifFile);
 213         return NULL;
 214     }
 215     /*@i1@*/memset(Private, &#39;\0&#39;, sizeof(GifFilePrivateType));
 216 
 217     GifFile-&gt;Private = (void *)Private;
 218     Private-&gt;FileHandle = 0;
 219     Private-&gt;File = NULL;
 220     Private-&gt;FileState = FILE_STATE_READ;
 221 
 222     Private-&gt;Read = readFunc;    /* TVT */
 223     GifFile-&gt;UserData = userData;    /* TVT */
 224 
 225     /* Lets see if this is a GIF file: */
 226     /* coverity[check_return] */
<span class="line-modified"> 227     if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {</span>
 228         if (Error != NULL)
 229             *Error = D_GIF_ERR_READ_FAILED;
 230         free((char *)Private);
 231         free((char *)GifFile);
 232         return NULL;
 233     }
 234 
 235     /* Check for GIF prefix at start of file */
 236     Buf[GIF_STAMP_LEN] = &#39;\0&#39;;
 237     if (strncmp(GIF_STAMP, Buf, GIF_VERSION_POS) != 0) {
 238         if (Error != NULL)
 239             *Error = D_GIF_ERR_NOT_GIF_FILE;
 240         free((char *)Private);
 241         free((char *)GifFile);
 242         return NULL;
 243     }
 244 
 245     if (DGifGetScreenDesc(GifFile) == GIF_ERROR) {
 246         free((char *)Private);
 247         free((char *)GifFile);
</pre>
<hr />
<pre>
 264 ******************************************************************************/
 265 int
 266 DGifGetScreenDesc(GifFileType *GifFile)
 267 {
 268     int BitsPerPixel;
 269     bool SortFlag;
 270     GifByteType Buf[3];
 271     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 272 
 273     if (!IS_READABLE(Private)) {
 274         /* This file was NOT open for reading: */
 275         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 276         return GIF_ERROR;
 277     }
 278 
 279     /* Put the screen descriptor into the file: */
 280     if (DGifGetWord(GifFile, &amp;GifFile-&gt;SWidth) == GIF_ERROR ||
 281         DGifGetWord(GifFile, &amp;GifFile-&gt;SHeight) == GIF_ERROR)
 282         return GIF_ERROR;
 283 
<span class="line-modified"> 284     if (InternalRead(GifFile, Buf, 3) != 3) {</span>
 285         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 286         GifFreeMapObject(GifFile-&gt;SColorMap);
 287         GifFile-&gt;SColorMap = NULL;
 288         return GIF_ERROR;
 289     }
 290     GifFile-&gt;SColorResolution = (((Buf[0] &amp; 0x70) + 1) &gt;&gt; 4) + 1;
 291     SortFlag = (Buf[0] &amp; 0x08) != 0;
 292     BitsPerPixel = (Buf[0] &amp; 0x07) + 1;
 293     GifFile-&gt;SBackGroundColor = Buf[1];
 294     GifFile-&gt;AspectByte = Buf[2];
 295     if (Buf[0] &amp; 0x80) {    /* Do we have global color map? */
 296         int i;
 297 
 298         GifFile-&gt;SColorMap = GifMakeMapObject(1 &lt;&lt; BitsPerPixel, NULL);
 299         if (GifFile-&gt;SColorMap == NULL) {
 300             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 301             return GIF_ERROR;
 302         }
 303 
 304         /* Get the global color map: */
 305         GifFile-&gt;SColorMap-&gt;SortFlag = SortFlag;
 306         for (i = 0; i &lt; GifFile-&gt;SColorMap-&gt;ColorCount; i++) {
 307             /* coverity[check_return] */
<span class="line-modified"> 308             if (InternalRead(GifFile, Buf, 3) != 3) {</span>
 309                 GifFreeMapObject(GifFile-&gt;SColorMap);
 310                 GifFile-&gt;SColorMap = NULL;
 311                 GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 312                 return GIF_ERROR;
 313             }
 314             GifFile-&gt;SColorMap-&gt;Colors[i].Red = Buf[0];
 315             GifFile-&gt;SColorMap-&gt;Colors[i].Green = Buf[1];
 316             GifFile-&gt;SColorMap-&gt;Colors[i].Blue = Buf[2];
 317         }
 318     } else {
 319         GifFile-&gt;SColorMap = NULL;
 320     }
 321 
<span class="line-added"> 322     /*</span>
<span class="line-added"> 323      * No check here for whether the background color is in range for the</span>
<span class="line-added"> 324      * screen color map.  Possibly there should be.</span>
<span class="line-added"> 325      */</span>
<span class="line-added"> 326 </span>
 327     return GIF_OK;
 328 }
 329 
<span class="line-added"> 330 const char *</span>
<span class="line-added"> 331 DGifGetGifVersion(GifFileType *GifFile)</span>
<span class="line-added"> 332 {</span>
<span class="line-added"> 333     GifFilePrivateType *Private = (GifFilePrivateType *) GifFile-&gt;Private;</span>
<span class="line-added"> 334 </span>
<span class="line-added"> 335     if (Private-&gt;gif89)</span>
<span class="line-added"> 336         return GIF89_STAMP;</span>
<span class="line-added"> 337     else</span>
<span class="line-added"> 338         return GIF87_STAMP;</span>
<span class="line-added"> 339 }</span>
<span class="line-added"> 340 </span>
 341 /******************************************************************************
 342  This routine should be called before any attempt to read an image.
 343 ******************************************************************************/
 344 int
 345 DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
 346 {
 347     GifByteType Buf;
 348     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 349 
 350     if (!IS_READABLE(Private)) {
 351         /* This file was NOT open for reading: */
 352         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 353         return GIF_ERROR;
 354     }
 355 
 356     /* coverity[check_return] */
<span class="line-modified"> 357     if (InternalRead(GifFile, &amp;Buf, 1) != 1) {</span>
 358         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 359         return GIF_ERROR;
 360     }
 361 
<span class="line-added"> 362     //fprintf(stderr, &quot;### DGifGetRecordType: %02x\n&quot;, Buf);</span>
 363     switch (Buf) {
 364       case DESCRIPTOR_INTRODUCER:
 365           *Type = IMAGE_DESC_RECORD_TYPE;
 366           break;
 367       case EXTENSION_INTRODUCER:
 368           *Type = EXTENSION_RECORD_TYPE;
 369           break;
 370       case TERMINATOR_INTRODUCER:
 371           *Type = TERMINATE_RECORD_TYPE;
 372           break;
 373       default:
 374           *Type = UNDEFINED_RECORD_TYPE;
 375           GifFile-&gt;Error = D_GIF_ERR_WRONG_RECORD;
 376           return GIF_ERROR;
 377     }
 378 
 379     return GIF_OK;
 380 }
 381 




 382 int
<span class="line-modified"> 383 DGifGetImageHeader(GifFileType *GifFile)</span>
 384 {
 385     unsigned int BitsPerPixel;
 386     GifByteType Buf[3];
 387     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;

 388 
 389     if (!IS_READABLE(Private)) {
 390         /* This file was NOT open for reading: */
 391         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 392         return GIF_ERROR;
 393     }
 394 
 395     if (DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Left) == GIF_ERROR ||
 396         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Top) == GIF_ERROR ||
 397         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Width) == GIF_ERROR ||
 398         DGifGetWord(GifFile, &amp;GifFile-&gt;Image.Height) == GIF_ERROR)
 399         return GIF_ERROR;
<span class="line-modified"> 400     if (InternalRead(GifFile, Buf, 1) != 1) {</span>
 401         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 402         GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 403         GifFile-&gt;Image.ColorMap = NULL;
 404         return GIF_ERROR;
 405     }
 406     BitsPerPixel = (Buf[0] &amp; 0x07) + 1;
 407     GifFile-&gt;Image.Interlace = (Buf[0] &amp; 0x40) ? true : false;
 408 
 409     /* Setup the colormap */
 410     if (GifFile-&gt;Image.ColorMap) {
 411         GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 412         GifFile-&gt;Image.ColorMap = NULL;
 413     }
 414     /* Does this image have local color map? */
 415     if (Buf[0] &amp; 0x80) {
 416         unsigned int i;
 417 
 418         GifFile-&gt;Image.ColorMap = GifMakeMapObject(1 &lt;&lt; BitsPerPixel, NULL);
 419         if (GifFile-&gt;Image.ColorMap == NULL) {
 420             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 421             return GIF_ERROR;
 422         }
 423 
 424         /* Get the image local color map: */
 425         for (i = 0; i &lt; GifFile-&gt;Image.ColorMap-&gt;ColorCount; i++) {
 426             /* coverity[check_return] */
<span class="line-modified"> 427             if (InternalRead(GifFile, Buf, 3) != 3) {</span>
 428                 GifFreeMapObject(GifFile-&gt;Image.ColorMap);
 429                 GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 430                 GifFile-&gt;Image.ColorMap = NULL;
 431                 return GIF_ERROR;
 432             }
 433             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Red = Buf[0];
 434             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Green = Buf[1];
 435             GifFile-&gt;Image.ColorMap-&gt;Colors[i].Blue = Buf[2];
 436         }
 437     }
 438 
<span class="line-added"> 439     Private-&gt;PixelCount = (long)GifFile-&gt;Image.Width *</span>
<span class="line-added"> 440        (long)GifFile-&gt;Image.Height;</span>
<span class="line-added"> 441 </span>
<span class="line-added"> 442     /* Reset decompress algorithm parameters. */</span>
<span class="line-added"> 443     return DGifSetupDecompress(GifFile);</span>
<span class="line-added"> 444 }</span>
<span class="line-added"> 445 </span>
<span class="line-added"> 446 /******************************************************************************</span>
<span class="line-added"> 447  This routine should be called before any attempt to read an image.</span>
<span class="line-added"> 448  Note it is assumed the Image desc. header has been read.</span>
<span class="line-added"> 449 ******************************************************************************/</span>
<span class="line-added"> 450 int</span>
<span class="line-added"> 451 DGifGetImageDesc(GifFileType *GifFile)</span>
<span class="line-added"> 452 {</span>
<span class="line-added"> 453     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;</span>
<span class="line-added"> 454     SavedImage *sp;</span>
<span class="line-added"> 455 </span>
<span class="line-added"> 456     if (!IS_READABLE(Private)) {</span>
<span class="line-added"> 457         /* This file was NOT open for reading: */</span>
<span class="line-added"> 458         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;</span>
<span class="line-added"> 459         return GIF_ERROR;</span>
<span class="line-added"> 460     }</span>
<span class="line-added"> 461 </span>
<span class="line-added"> 462     if (DGifGetImageHeader(GifFile) == GIF_ERROR) {</span>
<span class="line-added"> 463         return GIF_ERROR;</span>
<span class="line-added"> 464     }</span>
<span class="line-added"> 465 </span>
 466     if (GifFile-&gt;SavedImages) {
 467         SavedImage* new_saved_images =
 468             (SavedImage *)reallocarray(GifFile-&gt;SavedImages,
 469                             (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
 470         if (new_saved_images == NULL) {
 471             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 472             return GIF_ERROR;
 473         }
 474         GifFile-&gt;SavedImages = new_saved_images;
 475     } else {
 476         if ((GifFile-&gt;SavedImages =
 477              (SavedImage *) malloc(sizeof(SavedImage))) == NULL) {
 478             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 479             return GIF_ERROR;
 480         }
 481     }
 482 
 483     sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount];
 484     memcpy(&amp;sp-&gt;ImageDesc, &amp;GifFile-&gt;Image, sizeof(GifImageDesc));
 485     if (GifFile-&gt;Image.ColorMap != NULL) {
 486         sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
 487                                  GifFile-&gt;Image.ColorMap-&gt;ColorCount,
 488                                  GifFile-&gt;Image.ColorMap-&gt;Colors);
 489         if (sp-&gt;ImageDesc.ColorMap == NULL) {
 490             GifFile-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;
 491             return GIF_ERROR;
 492         }
 493     }
 494     sp-&gt;RasterBits = (unsigned char *)NULL;
 495     sp-&gt;ExtensionBlockCount = 0;
 496     sp-&gt;ExtensionBlocks = (ExtensionBlock *) NULL;
 497 
 498     GifFile-&gt;ImageCount++;
 499 
<span class="line-modified"> 500     return GIF_OK;</span>




 501 }
 502 
 503 /******************************************************************************
 504  Get one full scanned line (Line) of length LineLen from GIF file.
 505 ******************************************************************************/
 506 int
 507 DGifGetLine(GifFileType *GifFile, GifPixelType *Line, int LineLen)
 508 {
 509     GifByteType *Dummy;
 510     GifFilePrivateType *Private = (GifFilePrivateType *) GifFile-&gt;Private;
 511 
 512     if (!IS_READABLE(Private)) {
 513         /* This file was NOT open for reading: */
 514         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 515         return GIF_ERROR;
 516     }
 517 
 518     if (!LineLen)
 519         LineLen = GifFile-&gt;Image.Width;
 520 
</pre>
<hr />
<pre>
 573             while (Dummy != NULL) ;
 574         }
 575         return GIF_OK;
 576     } else
 577         return GIF_ERROR;
 578 }
 579 
 580 /******************************************************************************
 581  Get an extension block (see GIF manual) from GIF file. This routine only
 582  returns the first data block, and DGifGetExtensionNext should be called
 583  after this one until NULL extension is returned.
 584  The Extension should NOT be freed by the user (not dynamically allocated).
 585  Note it is assumed the Extension description header has been read.
 586 ******************************************************************************/
 587 int
 588 DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
 589 {
 590     GifByteType Buf;
 591     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 592 
<span class="line-added"> 593     //fprintf(stderr, &quot;### -&gt; DGifGetExtension:\n&quot;);</span>
 594     if (!IS_READABLE(Private)) {
 595         /* This file was NOT open for reading: */
 596         GifFile-&gt;Error = D_GIF_ERR_NOT_READABLE;
 597         return GIF_ERROR;
 598     }
 599 
 600     /* coverity[check_return] */
<span class="line-modified"> 601     if (InternalRead(GifFile, &amp;Buf, 1) != 1) {</span>
 602         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 603         return GIF_ERROR;
 604     }
 605     *ExtCode = Buf;
<span class="line-added"> 606     //fprintf(stderr, &quot;### &lt;- DGifGetExtension: %02x, about to call next\n&quot;, Buf);</span>
 607 
 608     return DGifGetExtensionNext(GifFile, Extension);
 609 }
 610 
 611 /******************************************************************************
 612  Get a following extension block (see GIF manual) from GIF file. This
 613  routine should be called until NULL Extension is returned.
 614  The Extension should NOT be freed by the user (not dynamically allocated).
 615 ******************************************************************************/
 616 int
 617 DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
 618 {
 619     GifByteType Buf;
 620     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 621 
<span class="line-modified"> 622     //fprintf(stderr, &quot;### -&gt; DGifGetExtensionNext\n&quot;);</span>
<span class="line-added"> 623     if (InternalRead(GifFile, &amp;Buf, 1) != 1) {</span>
 624         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 625         return GIF_ERROR;
 626     }
<span class="line-added"> 627     //fprintf(stderr, &quot;### DGifGetExtensionNext sees %d\n&quot;, Buf);</span>
<span class="line-added"> 628 </span>
 629     if (Buf &gt; 0) {
 630         *Extension = Private-&gt;Buf;    /* Use private unused buffer. */
 631         (*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
 632         /* coverity[tainted_data,check_return] */
<span class="line-modified"> 633         if (InternalRead(GifFile, &amp;((*Extension)[1]), Buf) != Buf) {</span>
 634             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 635             return GIF_ERROR;
 636         }
 637     } else
 638         *Extension = NULL;
<span class="line-added"> 639     //fprintf(stderr, &quot;### &lt;- DGifGetExtensionNext: %p\n&quot;, Extension);</span>
 640 
 641     return GIF_OK;
 642 }
 643 
 644 /******************************************************************************
 645  Extract a Graphics Control Block from raw extension data
 646 ******************************************************************************/
 647 
 648 int DGifExtensionToGCB(const size_t GifExtensionLength,
 649                        const GifByteType *GifExtension,
 650                        GraphicsControlBlock *GCB)
 651 {
 652     if (GifExtensionLength != 4) {
 653         return GIF_ERROR;
 654     }
 655 
 656     GCB-&gt;DisposalMode = (GifExtension[0] &gt;&gt; 2) &amp; 0x07;
 657     GCB-&gt;UserInputFlag = (GifExtension[0] &amp; 0x02) != 0;
 658     GCB-&gt;DelayTime = UNSIGNED_LITTLE_ENDIAN(GifExtension[1], GifExtension[2]);
 659     if (GifExtension[0] &amp; 0x01)
</pre>
<hr />
<pre>
 736         free(GifFile);
 737         return GIF_ERROR;
 738     }
 739 
 740     free((char *)GifFile-&gt;Private);
 741     free(GifFile);
 742     if (ErrorCode != NULL)
 743         *ErrorCode = D_GIF_SUCCEEDED;
 744     return GIF_OK;
 745 }
 746 
 747 /******************************************************************************
 748  Get 2 bytes (word) from the given file:
 749 ******************************************************************************/
 750 static int
 751 DGifGetWord(GifFileType *GifFile, GifWord *Word)
 752 {
 753     unsigned char c[2];
 754 
 755     /* coverity[check_return] */
<span class="line-modified"> 756     if (InternalRead(GifFile, c, 2) != 2) {</span>
 757         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 758         return GIF_ERROR;
 759     }
 760 
 761     *Word = (GifWord)UNSIGNED_LITTLE_ENDIAN(c[0], c[1]);
 762     return GIF_OK;
 763 }
 764 
 765 /******************************************************************************
 766  Get the image code in compressed form.  This routine can be called if the
 767  information needed to be piped out as is. Obviously this is much faster
 768  than decoding and encoding again. This routine should be followed by calls
 769  to DGifGetCodeNext, until NULL block is returned.
 770  The block should NOT be freed by the user (not dynamically allocated).
 771 ******************************************************************************/
 772 int
 773 DGifGetCode(GifFileType *GifFile, int *CodeSize, GifByteType **CodeBlock)
 774 {
 775     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 776 
</pre>
<hr />
<pre>
 781     }
 782 
 783     *CodeSize = Private-&gt;BitsPerPixel;
 784 
 785     return DGifGetCodeNext(GifFile, CodeBlock);
 786 }
 787 
 788 /******************************************************************************
 789  Continue to get the image code in compressed form. This routine should be
 790  called until NULL block is returned.
 791  The block should NOT be freed by the user (not dynamically allocated).
 792 ******************************************************************************/
 793 int
 794 DGifGetCodeNext(GifFileType *GifFile, GifByteType **CodeBlock)
 795 {
 796     GifByteType Buf;
 797     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 798 
 799     /* coverity[tainted_data_argument] */
 800     /* coverity[check_return] */
<span class="line-modified"> 801     if (InternalRead(GifFile, &amp;Buf, 1) != 1) {</span>
 802         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 803         return GIF_ERROR;
 804     }
 805 
 806     /* coverity[lower_bounds] */
 807     if (Buf &gt; 0) {
 808         *CodeBlock = Private-&gt;Buf;    /* Use private unused buffer. */
 809         (*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
 810         /* coverity[tainted_data] */
<span class="line-modified"> 811         if (InternalRead(GifFile, &amp;((*CodeBlock)[1]), Buf) != Buf) {</span>
 812             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
 813             return GIF_ERROR;
 814         }
 815     } else {
 816         *CodeBlock = NULL;
 817         Private-&gt;Buf[0] = 0;    /* Make sure the buffer is empty! */
 818         Private-&gt;PixelCount = 0;    /* And local info. indicate image read. */
 819     }
 820 
 821     return GIF_OK;
 822 }
 823 
 824 /******************************************************************************
 825  Setup the LZ decompression for this image:
 826 ******************************************************************************/
 827 static int
 828 DGifSetupDecompress(GifFileType *GifFile)
 829 {
 830     int i, BitsPerPixel;
 831     GifByteType CodeSize;
 832     GifPrefixType *Prefix;
 833     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile-&gt;Private;
 834 
 835     /* coverity[check_return] */
<span class="line-modified"> 836     if (InternalRead(GifFile, &amp;CodeSize, 1) &lt; 1) {    /* Read Code size from file. */</span>
 837         return GIF_ERROR;    /* Failed to read Code size. */
 838     }
 839     BitsPerPixel = CodeSize;
 840 
 841     /* this can only happen on a severely malformed GIF */
 842     if (BitsPerPixel &gt; 8) {
 843         GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;    /* somewhat bogus error code */
 844         return GIF_ERROR;    /* Failed to read Code size. */
 845     }
 846 
 847     Private-&gt;Buf[0] = 0;    /* Input Buffer empty. */
 848     Private-&gt;BitsPerPixel = BitsPerPixel;
 849     Private-&gt;ClearCode = (1 &lt;&lt; BitsPerPixel);
 850     Private-&gt;EOFCode = Private-&gt;ClearCode + 1;
 851     Private-&gt;RunningCode = Private-&gt;EOFCode + 1;
 852     Private-&gt;RunningBits = BitsPerPixel + 1;    /* Number of bits per code. */
 853     Private-&gt;MaxCode1 = 1 &lt;&lt; Private-&gt;RunningBits;    /* Max. code + 1. */
 854     Private-&gt;StackPtr = 0;    /* No pixels on the pixel stack. */
 855     Private-&gt;LastCode = NO_SUCH_CODE;
 856     Private-&gt;CrntShiftState = 0;    /* No information in CrntShiftDWord. */
</pre>
<hr />
<pre>
 950                 /* Now (if image is O.K.) we should not get a NO_SUCH_CODE
 951                  * during the trace. As we might loop forever, in case of
 952                  * defective image, we use StackPtr as loop counter and stop
 953                  * before overflowing Stack[]. */
 954                 while (StackPtr &lt; LZ_MAX_CODE &amp;&amp;
 955                        CrntPrefix &gt; ClearCode &amp;&amp; CrntPrefix &lt;= LZ_MAX_CODE) {
 956                     Stack[StackPtr++] = Suffix[CrntPrefix];
 957                     CrntPrefix = Prefix[CrntPrefix];
 958                 }
 959                 if (StackPtr &gt;= LZ_MAX_CODE || CrntPrefix &gt; LZ_MAX_CODE) {
 960                     GifFile-&gt;Error = D_GIF_ERR_IMAGE_DEFECT;
 961                     return GIF_ERROR;
 962                 }
 963                 /* Push the last character on stack: */
 964                 Stack[StackPtr++] = CrntPrefix;
 965 
 966                 /* Now lets pop all the stack into output: */
 967                 while (StackPtr != 0 &amp;&amp; i &lt; LineLen)
 968                     Line[i++] = Stack[--StackPtr];
 969             }
<span class="line-modified"> 970             if (LastCode != NO_SUCH_CODE &amp;&amp; Private-&gt;RunningCode - 2 &lt; (LZ_MAX_CODE+1) &amp;&amp; Prefix[Private-&gt;RunningCode - 2] == NO_SUCH_CODE) {</span>
 971                 Prefix[Private-&gt;RunningCode - 2] = LastCode;
 972 
 973                 if (CrntCode == Private-&gt;RunningCode - 2) {
 974                     /* Only allowed if CrntCode is exactly the running code:
 975                      * In that case CrntCode = XXXCode, CrntCode or the
 976                      * prefix code is last code and the suffix char is
 977                      * exactly the prefix of last code! */
 978                     Suffix[Private-&gt;RunningCode - 2] =
 979                        DGifGetPrefixChar(Prefix, LastCode, ClearCode);
 980                 } else {
 981                     Suffix[Private-&gt;RunningCode - 2] =
 982                        DGifGetPrefixChar(Prefix, CrntCode, ClearCode);
 983                 }
 984             }
 985             LastCode = CrntCode;
 986         }
 987     }
 988 
 989     Private-&gt;LastCode = LastCode;
 990     Private-&gt;StackPtr = StackPtr;
</pre>
<hr />
<pre>
1098         ++Private-&gt;RunningCode &gt; Private-&gt;MaxCode1 &amp;&amp;
1099         Private-&gt;RunningBits &lt; LZ_BITS) {
1100         Private-&gt;MaxCode1 &lt;&lt;= 1;
1101         Private-&gt;RunningBits++;
1102     }
1103     return GIF_OK;
1104 }
1105 
1106 /******************************************************************************
1107  This routines read one GIF data block at a time and buffers it internally
1108  so that the decompression routine could access it.
1109  The routine returns the next byte from its internal buffer (or read next
1110  block in if buffer empty) and returns GIF_OK if succesful.
1111 ******************************************************************************/
1112 static int
1113 DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
1114 {
1115     if (Buf[0] == 0) {
1116         /* Needs to read the next buffer - this one is empty: */
1117         /* coverity[check_return] */
<span class="line-modified">1118         if (InternalRead(GifFile, Buf, 1) != 1) {</span>
1119             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
1120             return GIF_ERROR;
1121         }
1122         /* There shouldn&#39;t be any empty data blocks here as the LZW spec
1123          * says the LZW termination code should come first.  Therefore we
1124          * shouldn&#39;t be inside this routine at that point.
1125          */
1126         if (Buf[0] == 0) {
1127             GifFile-&gt;Error = D_GIF_ERR_IMAGE_DEFECT;
1128             return GIF_ERROR;
1129         }
<span class="line-modified">1130         if (InternalRead(GifFile, &amp;Buf[1], Buf[0]) != Buf[0]) {</span>
1131             GifFile-&gt;Error = D_GIF_ERR_READ_FAILED;
1132             return GIF_ERROR;
1133         }
1134         *NextByte = Buf[1];
1135         Buf[1] = 2;    /* We use now the second place as last char read! */
1136         Buf[0]--;
1137     } else {
1138         *NextByte = Buf[Buf[1]++];
1139         Buf[0]--;
1140     }
1141 
1142     return GIF_OK;
1143 }
1144 
1145 /******************************************************************************
1146  This routine reads an entire GIF into core, hanging all its state info off
1147  the GifFileType pointer.  Call DGifOpenFileName() or DGifOpenFileHandle()
1148  first to initialize I/O.  Its inverse is EGifSpew().
1149 *******************************************************************************/
1150 int
</pre>
<hr />
<pre>
1153     size_t ImageSize;
1154     GifRecordType RecordType;
1155     SavedImage *sp;
1156     GifByteType *ExtData;
1157     int ExtFunction;
1158 
1159     GifFile-&gt;ExtensionBlocks = NULL;
1160     GifFile-&gt;ExtensionBlockCount = 0;
1161 
1162     do {
1163         if (DGifGetRecordType(GifFile, &amp;RecordType) == GIF_ERROR)
1164             return (GIF_ERROR);
1165 
1166         switch (RecordType) {
1167           case IMAGE_DESC_RECORD_TYPE:
1168               if (DGifGetImageDesc(GifFile) == GIF_ERROR)
1169                   return (GIF_ERROR);
1170 
1171               sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount - 1];
1172               /* Allocate memory for the image */
<span class="line-modified">1173               if (sp-&gt;ImageDesc.Width &lt;= 0 || sp-&gt;ImageDesc.Height &lt;= 0 ||</span>
1174                       sp-&gt;ImageDesc.Width &gt; (INT_MAX / sp-&gt;ImageDesc.Height)) {
1175                   return GIF_ERROR;
1176               }
1177               ImageSize = sp-&gt;ImageDesc.Width * sp-&gt;ImageDesc.Height;
1178 
1179               if (ImageSize &gt; (SIZE_MAX / sizeof(GifPixelType))) {
1180                   return GIF_ERROR;
1181               }
1182               sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL, ImageSize,
1183                       sizeof(GifPixelType));
1184 
1185               if (sp-&gt;RasterBits == NULL) {
1186                   return GIF_ERROR;
1187               }
1188 
1189               if (sp-&gt;ImageDesc.Interlace) {
1190                   int i, j;
1191                    /*
1192                     * The way an interlaced image should be read -
1193                     * offsets and jumps...
</pre>
<hr />
<pre>
1213               if (GifFile-&gt;ExtensionBlocks) {
1214                   sp-&gt;ExtensionBlocks = GifFile-&gt;ExtensionBlocks;
1215                   sp-&gt;ExtensionBlockCount = GifFile-&gt;ExtensionBlockCount;
1216 
1217                   GifFile-&gt;ExtensionBlocks = NULL;
1218                   GifFile-&gt;ExtensionBlockCount = 0;
1219               }
1220               break;
1221 
1222           case EXTENSION_RECORD_TYPE:
1223               if (DGifGetExtension(GifFile,&amp;ExtFunction,&amp;ExtData) == GIF_ERROR)
1224                   return (GIF_ERROR);
1225               /* Create an extension block with our data */
1226               if (ExtData != NULL) {
1227                   if (GifAddExtensionBlock(&amp;GifFile-&gt;ExtensionBlockCount,
1228                                &amp;GifFile-&gt;ExtensionBlocks,
1229                                ExtFunction, ExtData[0], &amp;ExtData[1])
1230                       == GIF_ERROR)
1231                       return (GIF_ERROR);
1232               }
<span class="line-modified">1233               for (;;) {</span>
1234                   if (DGifGetExtensionNext(GifFile, &amp;ExtData) == GIF_ERROR)
1235                       return (GIF_ERROR);
<span class="line-added">1236                   if (ExtData == NULL)</span>
<span class="line-added">1237                       break;</span>
1238                   /* Continue the extension block */
1239                   if (ExtData != NULL)
1240                       if (GifAddExtensionBlock(&amp;GifFile-&gt;ExtensionBlockCount,
1241                                    &amp;GifFile-&gt;ExtensionBlocks,
1242                                    CONTINUE_EXT_FUNC_CODE,
1243                                    ExtData[0], &amp;ExtData[1]) == GIF_ERROR)
1244                               return (GIF_ERROR);
1245               }
1246               break;
1247 
1248           case TERMINATE_RECORD_TYPE:
1249               break;
1250 
1251           default:    /* Should be trapped by DGifGetRecordType */
1252               break;
1253         }
1254     } while (RecordType != TERMINATE_RECORD_TYPE);
1255 
1256     /* Sanity check for corrupted file */
1257     if (GifFile-&gt;ImageCount == 0) {
</pre>
</td>
</tr>
</table>
<center><a href="../../libfreetype/src/type1/t1tokens.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="gif_err.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
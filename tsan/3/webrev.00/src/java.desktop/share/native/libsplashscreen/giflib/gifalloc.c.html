<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libsplashscreen/giflib/gifalloc.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  3  *
  4  * This code is free software; you can redistribute it and/or modify it
  5  * under the terms of the GNU General Public License version 2 only, as
  6  * published by the Free Software Foundation.  Oracle designates this
  7  * particular file as subject to the &quot;Classpath&quot; exception as provided
  8  * by Oracle in the LICENSE file that accompanied this code.
  9  *
 10  * This code is distributed in the hope that it will be useful, but WITHOUT
 11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 13  * version 2 for more details (a copy is included in the LICENSE file that
 14  * accompanied this code).
 15  *
 16  * You should have received a copy of the GNU General Public License version
 17  * 2 along with this work; if not, write to the Free Software Foundation,
 18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 19  *
 20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 21  * or visit www.oracle.com if you need additional information or have any
 22  * questions.
 23  */
 24 
 25 /*****************************************************************************
 26 
 27  GIF construction tools
 28 
 29 SPDX-License-Identifier: MIT
 30 
 31 ****************************************************************************/
 32 
 33 #include &lt;stdlib.h&gt;
 34 #include &lt;stdio.h&gt;
 35 #include &lt;string.h&gt;
 36 
 37 #include &quot;gif_lib.h&quot;
 38 #include &quot;gif_lib_private.h&quot;
 39 
 40 #define MAX(x, y)    (((x) &gt; (y)) ? (x) : (y))
 41 
 42 /******************************************************************************
 43  Miscellaneous utility functions
 44 ******************************************************************************/
 45 
 46 /* return smallest bitfield size n will fit in */
 47 int
 48 GifBitSize(int n)
 49 {
 50     register int i;
 51 
 52     for (i = 1; i &lt;= 8; i++)
 53         if ((1 &lt;&lt; i) &gt;= n)
 54             break;
 55     return (i);
 56 }
 57 
 58 /******************************************************************************
 59   Color map object functions
 60 ******************************************************************************/
 61 
 62 /*
 63  * Allocate a color map of given size; initialize with contents of
 64  * ColorMap if that pointer is non-NULL.
 65  */
 66 ColorMapObject *
 67 GifMakeMapObject(int ColorCount, const GifColorType *ColorMap)
 68 {
 69     ColorMapObject *Object;
 70 
 71     /*** FIXME: Our ColorCount has to be a power of two.  Is it necessary to
 72      * make the user know that or should we automatically round up instead? */
 73     if (ColorCount != (1 &lt;&lt; GifBitSize(ColorCount))) {
 74         return ((ColorMapObject *) NULL);
 75     }
 76 
 77     Object = (ColorMapObject *)malloc(sizeof(ColorMapObject));
 78     if (Object == (ColorMapObject *) NULL) {
 79         return ((ColorMapObject *) NULL);
 80     }
 81 
 82     Object-&gt;Colors = (GifColorType *)calloc(ColorCount, sizeof(GifColorType));
 83     if (Object-&gt;Colors == (GifColorType *) NULL) {
 84         free(Object);
 85         return ((ColorMapObject *) NULL);
 86     }
 87 
 88     Object-&gt;ColorCount = ColorCount;
 89     Object-&gt;BitsPerPixel = GifBitSize(ColorCount);
 90     Object-&gt;SortFlag = false;
 91 
 92     if (ColorMap != NULL) {
 93         memcpy((char *)Object-&gt;Colors,
 94                (char *)ColorMap, ColorCount * sizeof(GifColorType));
 95     }
 96 
 97     return (Object);
 98 }
 99 
100 /*******************************************************************************
101 Free a color map object
102 *******************************************************************************/
103 void
104 GifFreeMapObject(ColorMapObject *Object)
105 {
106     if (Object != NULL) {
107         (void)free(Object-&gt;Colors);
108         (void)free(Object);
109     }
110 }
111 
112 #ifdef DEBUG
113 void
114 DumpColorMap(ColorMapObject *Object,
115              FILE * fp)
116 {
117     if (Object != NULL) {
118         int i, j, Len = Object-&gt;ColorCount;
119 
120         for (i = 0; i &lt; Len; i += 4) {
121             for (j = 0; j &lt; 4 &amp;&amp; j &lt; Len; j++) {
122                 (void)fprintf(fp, &quot;%3d: %02x %02x %02x   &quot;, i + j,
123                               Object-&gt;Colors[i + j].Red,
124                               Object-&gt;Colors[i + j].Green,
125                               Object-&gt;Colors[i + j].Blue);
126             }
127             (void)fprintf(fp, &quot;\n&quot;);
128         }
129     }
130 }
131 #endif /* DEBUG */
132 
133 /*******************************************************************************
134  Compute the union of two given color maps and return it.  If result can&#39;t
135  fit into 256 colors, NULL is returned, the allocated union otherwise.
136  ColorIn1 is copied as is to ColorUnion, while colors from ColorIn2 are
137  copied iff they didn&#39;t exist before.  ColorTransIn2 maps the old
138  ColorIn2 into the ColorUnion color map table./
139 *******************************************************************************/
140 ColorMapObject *
141 GifUnionColorMap(const ColorMapObject *ColorIn1,
142               const ColorMapObject *ColorIn2,
143               GifPixelType ColorTransIn2[])
144 {
145     int i, j, CrntSlot, RoundUpTo, NewGifBitSize;
146     ColorMapObject *ColorUnion;
147 
148     /*
149      * We don&#39;t worry about duplicates within either color map; if
150      * the caller wants to resolve those, he can perform unions
151      * with an empty color map.
152      */
153 
154     /* Allocate table which will hold the result for sure. */
155     ColorUnion = GifMakeMapObject(MAX(ColorIn1-&gt;ColorCount,
156                                ColorIn2-&gt;ColorCount) * 2, NULL);
157 
158     if (ColorUnion == NULL)
159         return (NULL);
160 
161     /*
162      * Copy ColorIn1 to ColorUnion.
163      */
164     for (i = 0; i &lt; ColorIn1-&gt;ColorCount; i++)
165         ColorUnion-&gt;Colors[i] = ColorIn1-&gt;Colors[i];
166     CrntSlot = ColorIn1-&gt;ColorCount;
167 
168     /*
169      * Potentially obnoxious hack:
170      *
171      * Back CrntSlot down past all contiguous {0, 0, 0} slots at the end
172      * of table 1.  This is very useful if your display is limited to
173      * 16 colors.
174      */
175     while (ColorIn1-&gt;Colors[CrntSlot - 1].Red == 0
176            &amp;&amp; ColorIn1-&gt;Colors[CrntSlot - 1].Green == 0
177            &amp;&amp; ColorIn1-&gt;Colors[CrntSlot - 1].Blue == 0)
178         CrntSlot--;
179 
180     /* Copy ColorIn2 to ColorUnion (use old colors if they exist): */
181     for (i = 0; i &lt; ColorIn2-&gt;ColorCount &amp;&amp; CrntSlot &lt;= 256; i++) {
182         /* Let&#39;s see if this color already exists: */
183         for (j = 0; j &lt; ColorIn1-&gt;ColorCount; j++)
184             if (memcmp (&amp;ColorIn1-&gt;Colors[j], &amp;ColorIn2-&gt;Colors[i],
185                         sizeof(GifColorType)) == 0)
186                 break;
187 
188         if (j &lt; ColorIn1-&gt;ColorCount)
189             ColorTransIn2[i] = j;    /* color exists in Color1 */
190         else {
191             /* Color is new - copy it to a new slot: */
192             ColorUnion-&gt;Colors[CrntSlot] = ColorIn2-&gt;Colors[i];
193             ColorTransIn2[i] = CrntSlot++;
194         }
195     }
196 
197     if (CrntSlot &gt; 256) {
198         GifFreeMapObject(ColorUnion);
199         return ((ColorMapObject *) NULL);
200     }
201 
202     NewGifBitSize = GifBitSize(CrntSlot);
203     RoundUpTo = (1 &lt;&lt; NewGifBitSize);
204 
205     if (RoundUpTo != ColorUnion-&gt;ColorCount) {
206         register GifColorType *Map = ColorUnion-&gt;Colors;
207 
208         /*
209          * Zero out slots up to next power of 2.
210          * We know these slots exist because of the way ColorUnion&#39;s
211          * start dimension was computed.
212          */
213         for (j = CrntSlot; j &lt; RoundUpTo; j++)
214             Map[j].Red = Map[j].Green = Map[j].Blue = 0;
215 
216         /* perhaps we can shrink the map? */
217         if (RoundUpTo &lt; ColorUnion-&gt;ColorCount) {
218             GifColorType *new_map = (GifColorType *)reallocarray(Map,
219                                  RoundUpTo, sizeof(GifColorType));
220             if( new_map == NULL ) {
221                 GifFreeMapObject(ColorUnion);
222                 return ((ColorMapObject *) NULL);
223             }
224             ColorUnion-&gt;Colors = new_map;
225         }
226     }
227 
228     ColorUnion-&gt;ColorCount = RoundUpTo;
229     ColorUnion-&gt;BitsPerPixel = NewGifBitSize;
230 
231     return (ColorUnion);
232 }
233 
234 /*******************************************************************************
235  Apply a given color translation to the raster bits of an image
236 *******************************************************************************/
237 void
238 GifApplyTranslation(SavedImage *Image, GifPixelType Translation[])
239 {
240     register int i;
241     register int RasterSize = Image-&gt;ImageDesc.Height * Image-&gt;ImageDesc.Width;
242 
243     for (i = 0; i &lt; RasterSize; i++)
244         Image-&gt;RasterBits[i] = Translation[Image-&gt;RasterBits[i]];
245 }
246 
247 /******************************************************************************
248  Extension record functions
249 ******************************************************************************/
250 int
251 GifAddExtensionBlock(int *ExtensionBlockCount,
252                      ExtensionBlock **ExtensionBlocks,
253                      int Function,
254                      unsigned int Len,
255                      unsigned char ExtData[])
256 {
257     ExtensionBlock *ep;
258 
259     if (*ExtensionBlocks == NULL)
260         *ExtensionBlocks=(ExtensionBlock *)malloc(sizeof(ExtensionBlock));
261     else {
262         ExtensionBlock* ep_new = (ExtensionBlock *)reallocarray
263                                       (*ExtensionBlocks, (*ExtensionBlockCount + 1),
264                                       sizeof(ExtensionBlock));
265         if( ep_new == NULL )
266             return (GIF_ERROR);
267         *ExtensionBlocks = ep_new;
268     }
269 
270     if (*ExtensionBlocks == NULL)
271         return (GIF_ERROR);
272 
273     ep = &amp;(*ExtensionBlocks)[(*ExtensionBlockCount)++];
274 
275     ep-&gt;Function = Function;
276     ep-&gt;ByteCount=Len;
277     ep-&gt;Bytes = (GifByteType *)malloc(ep-&gt;ByteCount);
278     if (ep-&gt;Bytes == NULL)
279         return (GIF_ERROR);
280 
281     if (ExtData != NULL) {
282         memcpy(ep-&gt;Bytes, ExtData, Len);
283     }
284 
285     return (GIF_OK);
286 }
287 
288 void
289 GifFreeExtensions(int *ExtensionBlockCount,
290                   ExtensionBlock **ExtensionBlocks)
291 {
292     ExtensionBlock *ep;
293 
294     if (*ExtensionBlocks == NULL)
295         return;
296 
297     for (ep = *ExtensionBlocks;
298          ep &lt; (*ExtensionBlocks + *ExtensionBlockCount);
299          ep++)
300         (void)free((char *)ep-&gt;Bytes);
301     (void)free((char *)*ExtensionBlocks);
302     *ExtensionBlocks = NULL;
303     *ExtensionBlockCount = 0;
304 }
305 
306 /******************************************************************************
307  Image block allocation functions
308 ******************************************************************************/
309 
310 /* Private Function:
311  * Frees the last image in the GifFile-&gt;SavedImages array
312  */
313 void
314 FreeLastSavedImage(GifFileType *GifFile)
315 {
316     SavedImage *sp;
317 
318     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL))
319         return;
320 
321     /* Remove one SavedImage from the GifFile */
322     GifFile-&gt;ImageCount--;
323     sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount];
324 
325     /* Deallocate its Colormap */
326     if (sp-&gt;ImageDesc.ColorMap != NULL) {
327         GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
328         sp-&gt;ImageDesc.ColorMap = NULL;
329     }
330 
331     /* Deallocate the image data */
332     if (sp-&gt;RasterBits != NULL)
333         free((char *)sp-&gt;RasterBits);
334 
335     /* Deallocate any extensions */
336     GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
337 
338     /*** FIXME: We could realloc the GifFile-&gt;SavedImages structure but is
339      * there a point to it? Saves some memory but we&#39;d have to do it every
340      * time.  If this is used in GifFreeSavedImages then it would be inefficient
341      * (The whole array is going to be deallocated.)  If we just use it when
342      * we want to free the last Image it&#39;s convenient to do it here.
343      */
344 }
345 
346 /*
347  * Append an image block to the SavedImages array
348  */
349 SavedImage *
350 GifMakeSavedImage(GifFileType *GifFile, const SavedImage *CopyFrom)
351 {
352     if (GifFile-&gt;SavedImages == NULL)
353         GifFile-&gt;SavedImages = (SavedImage *)malloc(sizeof(SavedImage));
354     else {
355         SavedImage* newSavedImages = (SavedImage *)reallocarray(GifFile-&gt;SavedImages,
356                                (GifFile-&gt;ImageCount + 1), sizeof(SavedImage));
357         if( newSavedImages == NULL)
358             return ((SavedImage *)NULL);
359         GifFile-&gt;SavedImages = newSavedImages;
360     }
361     if (GifFile-&gt;SavedImages == NULL)
362         return ((SavedImage *)NULL);
363     else {
364         SavedImage *sp = &amp;GifFile-&gt;SavedImages[GifFile-&gt;ImageCount++];
365 
366         if (CopyFrom != NULL) {
367             memcpy((char *)sp, CopyFrom, sizeof(SavedImage));
368 
369             /*
370              * Make our own allocated copies of the heap fields in the
371              * copied record.  This guards against potential aliasing
372              * problems.
373              */
374 
375             /* first, the local color map */
376             if (CopyFrom-&gt;ImageDesc.ColorMap != NULL) {
377                 sp-&gt;ImageDesc.ColorMap = GifMakeMapObject(
378                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;ColorCount,
379                                          CopyFrom-&gt;ImageDesc.ColorMap-&gt;Colors);
380                 if (sp-&gt;ImageDesc.ColorMap == NULL) {
381                     FreeLastSavedImage(GifFile);
382                     return (SavedImage *)(NULL);
383                 }
384             }
385 
386             /* next, the raster */
387             sp-&gt;RasterBits = (unsigned char *)reallocarray(NULL,
388                                                   (CopyFrom-&gt;ImageDesc.Height *
389                                                   CopyFrom-&gt;ImageDesc.Width),
390                                                   sizeof(GifPixelType));
391             if (sp-&gt;RasterBits == NULL) {
392                 FreeLastSavedImage(GifFile);
393                 return (SavedImage *)(NULL);
394             }
395             memcpy(sp-&gt;RasterBits, CopyFrom-&gt;RasterBits,
396                    sizeof(GifPixelType) * CopyFrom-&gt;ImageDesc.Height *
397                    CopyFrom-&gt;ImageDesc.Width);
398 
399             /* finally, the extension blocks */
400             if (CopyFrom-&gt;ExtensionBlocks != NULL) {
401                 sp-&gt;ExtensionBlocks = (ExtensionBlock *)reallocarray(NULL,
402                                       CopyFrom-&gt;ExtensionBlockCount,
403                                       sizeof(ExtensionBlock));
404                 if (sp-&gt;ExtensionBlocks == NULL) {
405                     FreeLastSavedImage(GifFile);
406                     return (SavedImage *)(NULL);
407                 }
408                 memcpy(sp-&gt;ExtensionBlocks, CopyFrom-&gt;ExtensionBlocks,
409                        sizeof(ExtensionBlock) * CopyFrom-&gt;ExtensionBlockCount);
410             }
411         }
412         else {
413             memset((char *)sp, &#39;\0&#39;, sizeof(SavedImage));
414         }
415 
416         return (sp);
417     }
418 }
419 
420 void
421 GifFreeSavedImages(GifFileType *GifFile)
422 {
423     SavedImage *sp;
424 
425     if ((GifFile == NULL) || (GifFile-&gt;SavedImages == NULL)) {
426         return;
427     }
428     for (sp = GifFile-&gt;SavedImages;
429          sp &lt; GifFile-&gt;SavedImages + GifFile-&gt;ImageCount; sp++) {
430         if (sp-&gt;ImageDesc.ColorMap != NULL) {
431             GifFreeMapObject(sp-&gt;ImageDesc.ColorMap);
432             sp-&gt;ImageDesc.ColorMap = NULL;
433         }
434 
435         if (sp-&gt;RasterBits != NULL)
436             free((char *)sp-&gt;RasterBits);
437 
438         GifFreeExtensions(&amp;sp-&gt;ExtensionBlockCount, &amp;sp-&gt;ExtensionBlocks);
439     }
440     free((char *)GifFile-&gt;SavedImages);
441     GifFile-&gt;SavedImages = NULL;
442 }
443 
444 /* end */
    </pre>
  </body>
</html>
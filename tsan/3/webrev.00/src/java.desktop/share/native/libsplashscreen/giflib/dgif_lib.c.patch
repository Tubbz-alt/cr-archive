diff a/src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c b/src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c
--- a/src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c
+++ b/src/java.desktop/share/native/libsplashscreen/giflib/dgif_lib.c
@@ -28,10 +28,12 @@
 
 The functions here and in egif_lib.c are partitioned carefully so that
 if you only require one of read and write capability, only one of these
 two modules will be linked.  Preserve this property!
 
+SPDX-License-Identifier: MIT
+
 *****************************************************************************/
 
 #include <stdlib.h>
 #include <limits.h>
 #include <stdint.h>
@@ -50,14 +52,17 @@
 
 /* compose unsigned little endian value */
 #define UNSIGNED_LITTLE_ENDIAN(lo, hi) ((lo) | ((hi) << 8))
 
 /* avoid extra function call in case we use fread (TVT) */
-#define READ(_gif,_buf,_len)                                     \
-  (((GifFilePrivateType*)_gif->Private)->Read ?                   \
-    ((GifFilePrivateType*)_gif->Private)->Read(_gif,_buf,_len) : \
-    fread(_buf,1,_len,((GifFilePrivateType*)_gif->Private)->File))
+static int InternalRead(GifFileType *gif, GifByteType *buf, int len) {
+    //fprintf(stderr, "### Read: %d\n", len);
+    return
+    (((GifFilePrivateType*)gif->Private)->Read ?
+     ((GifFilePrivateType*)gif->Private)->Read(gif,buf,len) :
+     fread(buf,1,len,((GifFilePrivateType*)gif->Private)->File));
+}
 
 static int DGifGetWord(GifFileType *GifFile, GifWord *Word);
 static int DGifSetupDecompress(GifFileType *GifFile);
 static int DGifDecompressLine(GifFileType *GifFile, GifPixelType *Line,
                               int LineLen);
@@ -140,11 +145,11 @@
     GifFile->UserData = NULL;    /* TVT */
     /*@=mustfreeonly@*/
 
     /* Let's see if this is a GIF file: */
     /* coverity[check_return] */
-    if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
         if (Error != NULL)
             *Error = D_GIF_ERR_READ_FAILED;
         (void)fclose(f);
         free((char *)Private);
         free((char *)GifFile);
@@ -217,11 +222,11 @@
     Private->Read = readFunc;    /* TVT */
     GifFile->UserData = userData;    /* TVT */
 
     /* Lets see if this is a GIF file: */
     /* coverity[check_return] */
-    if (READ(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
+    if (InternalRead(GifFile, (unsigned char *)Buf, GIF_STAMP_LEN) != GIF_STAMP_LEN) {
         if (Error != NULL)
             *Error = D_GIF_ERR_READ_FAILED;
         free((char *)Private);
         free((char *)GifFile);
         return NULL;
@@ -274,11 +279,11 @@
     /* Put the screen descriptor into the file: */
     if (DGifGetWord(GifFile, &GifFile->SWidth) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->SHeight) == GIF_ERROR)
         return GIF_ERROR;
 
-    if (READ(GifFile, Buf, 3) != 3) {
+    if (InternalRead(GifFile, Buf, 3) != 3) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         GifFreeMapObject(GifFile->SColorMap);
         GifFile->SColorMap = NULL;
         return GIF_ERROR;
     }
@@ -298,11 +303,11 @@
 
         /* Get the global color map: */
         GifFile->SColorMap->SortFlag = SortFlag;
         for (i = 0; i < GifFile->SColorMap->ColorCount; i++) {
             /* coverity[check_return] */
-            if (READ(GifFile, Buf, 3) != 3) {
+            if (InternalRead(GifFile, Buf, 3) != 3) {
                 GifFreeMapObject(GifFile->SColorMap);
                 GifFile->SColorMap = NULL;
                 GifFile->Error = D_GIF_ERR_READ_FAILED;
                 return GIF_ERROR;
             }
@@ -312,13 +317,29 @@
         }
     } else {
         GifFile->SColorMap = NULL;
     }
 
+    /*
+     * No check here for whether the background color is in range for the
+     * screen color map.  Possibly there should be.
+     */
+
     return GIF_OK;
 }
 
+const char *
+DGifGetGifVersion(GifFileType *GifFile)
+{
+    GifFilePrivateType *Private = (GifFilePrivateType *) GifFile->Private;
+
+    if (Private->gif89)
+        return GIF89_STAMP;
+    else
+        return GIF87_STAMP;
+}
+
 /******************************************************************************
  This routine should be called before any attempt to read an image.
 ******************************************************************************/
 int
 DGifGetRecordType(GifFileType *GifFile, GifRecordType* Type)
@@ -331,15 +352,16 @@
         GifFile->Error = D_GIF_ERR_NOT_READABLE;
         return GIF_ERROR;
     }
 
     /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
+    if (InternalRead(GifFile, &Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
 
+    //fprintf(stderr, "### DGifGetRecordType: %02x\n", Buf);
     switch (Buf) {
       case DESCRIPTOR_INTRODUCER:
           *Type = IMAGE_DESC_RECORD_TYPE;
           break;
       case EXTENSION_INTRODUCER:
@@ -355,21 +377,16 @@
     }
 
     return GIF_OK;
 }
 
-/******************************************************************************
- This routine should be called before any attempt to read an image.
- Note it is assumed the Image desc. header has been read.
-******************************************************************************/
 int
-DGifGetImageDesc(GifFileType *GifFile)
+DGifGetImageHeader(GifFileType *GifFile)
 {
     unsigned int BitsPerPixel;
     GifByteType Buf[3];
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
-    SavedImage *sp;
 
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
         GifFile->Error = D_GIF_ERR_NOT_READABLE;
         return GIF_ERROR;
@@ -378,11 +395,11 @@
     if (DGifGetWord(GifFile, &GifFile->Image.Left) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->Image.Top) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->Image.Width) == GIF_ERROR ||
         DGifGetWord(GifFile, &GifFile->Image.Height) == GIF_ERROR)
         return GIF_ERROR;
-    if (READ(GifFile, Buf, 1) != 1) {
+    if (InternalRead(GifFile, Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         GifFreeMapObject(GifFile->Image.ColorMap);
         GifFile->Image.ColorMap = NULL;
         return GIF_ERROR;
     }
@@ -405,11 +422,11 @@
         }
 
         /* Get the image local color map: */
         for (i = 0; i < GifFile->Image.ColorMap->ColorCount; i++) {
             /* coverity[check_return] */
-            if (READ(GifFile, Buf, 3) != 3) {
+            if (InternalRead(GifFile, Buf, 3) != 3) {
                 GifFreeMapObject(GifFile->Image.ColorMap);
                 GifFile->Error = D_GIF_ERR_READ_FAILED;
                 GifFile->Image.ColorMap = NULL;
                 return GIF_ERROR;
             }
@@ -417,10 +434,37 @@
             GifFile->Image.ColorMap->Colors[i].Green = Buf[1];
             GifFile->Image.ColorMap->Colors[i].Blue = Buf[2];
         }
     }
 
+    Private->PixelCount = (long)GifFile->Image.Width *
+       (long)GifFile->Image.Height;
+
+    /* Reset decompress algorithm parameters. */
+    return DGifSetupDecompress(GifFile);
+}
+
+/******************************************************************************
+ This routine should be called before any attempt to read an image.
+ Note it is assumed the Image desc. header has been read.
+******************************************************************************/
+int
+DGifGetImageDesc(GifFileType *GifFile)
+{
+    GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
+    SavedImage *sp;
+
+    if (!IS_READABLE(Private)) {
+        /* This file was NOT open for reading: */
+        GifFile->Error = D_GIF_ERR_NOT_READABLE;
+        return GIF_ERROR;
+    }
+
+    if (DGifGetImageHeader(GifFile) == GIF_ERROR) {
+        return GIF_ERROR;
+    }
+
     if (GifFile->SavedImages) {
         SavedImage* new_saved_images =
             (SavedImage *)reallocarray(GifFile->SavedImages,
                             (GifFile->ImageCount + 1), sizeof(SavedImage));
         if (new_saved_images == NULL) {
@@ -451,15 +495,11 @@
     sp->ExtensionBlockCount = 0;
     sp->ExtensionBlocks = (ExtensionBlock *) NULL;
 
     GifFile->ImageCount++;
 
-    Private->PixelCount = (long)GifFile->Image.Width *
-       (long)GifFile->Image.Height;
-
-    /* Reset decompress algorithm parameters. */
-    return DGifSetupDecompress(GifFile);
+    return GIF_OK;
 }
 
 /******************************************************************************
  Get one full scanned line (Line) of length LineLen from GIF file.
 ******************************************************************************/
@@ -548,22 +588,24 @@
 DGifGetExtension(GifFileType *GifFile, int *ExtCode, GifByteType **Extension)
 {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
+    //fprintf(stderr, "### -> DGifGetExtension:\n");
     if (!IS_READABLE(Private)) {
         /* This file was NOT open for reading: */
         GifFile->Error = D_GIF_ERR_NOT_READABLE;
         return GIF_ERROR;
     }
 
     /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
+    if (InternalRead(GifFile, &Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
     *ExtCode = Buf;
+    //fprintf(stderr, "### <- DGifGetExtension: %02x, about to call next\n", Buf);
 
     return DGifGetExtensionNext(GifFile, Extension);
 }
 
 /******************************************************************************
@@ -575,24 +617,28 @@
 DGifGetExtensionNext(GifFileType *GifFile, GifByteType ** Extension)
 {
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
-    if (READ(GifFile, &Buf, 1) != 1) {
+    //fprintf(stderr, "### -> DGifGetExtensionNext\n");
+    if (InternalRead(GifFile, &Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
+    //fprintf(stderr, "### DGifGetExtensionNext sees %d\n", Buf);
+
     if (Buf > 0) {
         *Extension = Private->Buf;    /* Use private unused buffer. */
         (*Extension)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
         /* coverity[tainted_data,check_return] */
-        if (READ(GifFile, &((*Extension)[1]), Buf) != Buf) {
+        if (InternalRead(GifFile, &((*Extension)[1]), Buf) != Buf) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
     } else
         *Extension = NULL;
+    //fprintf(stderr, "### <- DGifGetExtensionNext: %p\n", Extension);
 
     return GIF_OK;
 }
 
 /******************************************************************************
@@ -705,11 +751,11 @@
 DGifGetWord(GifFileType *GifFile, GifWord *Word)
 {
     unsigned char c[2];
 
     /* coverity[check_return] */
-    if (READ(GifFile, c, 2) != 2) {
+    if (InternalRead(GifFile, c, 2) != 2) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
 
     *Word = (GifWord)UNSIGNED_LITTLE_ENDIAN(c[0], c[1]);
@@ -750,21 +796,21 @@
     GifByteType Buf;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     /* coverity[tainted_data_argument] */
     /* coverity[check_return] */
-    if (READ(GifFile, &Buf, 1) != 1) {
+    if (InternalRead(GifFile, &Buf, 1) != 1) {
         GifFile->Error = D_GIF_ERR_READ_FAILED;
         return GIF_ERROR;
     }
 
     /* coverity[lower_bounds] */
     if (Buf > 0) {
         *CodeBlock = Private->Buf;    /* Use private unused buffer. */
         (*CodeBlock)[0] = Buf;  /* Pascal strings notation (pos. 0 is len.). */
         /* coverity[tainted_data] */
-        if (READ(GifFile, &((*CodeBlock)[1]), Buf) != Buf) {
+        if (InternalRead(GifFile, &((*CodeBlock)[1]), Buf) != Buf) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
     } else {
         *CodeBlock = NULL;
@@ -785,11 +831,11 @@
     GifByteType CodeSize;
     GifPrefixType *Prefix;
     GifFilePrivateType *Private = (GifFilePrivateType *)GifFile->Private;
 
     /* coverity[check_return] */
-    if (READ(GifFile, &CodeSize, 1) < 1) {    /* Read Code size from file. */
+    if (InternalRead(GifFile, &CodeSize, 1) < 1) {    /* Read Code size from file. */
         return GIF_ERROR;    /* Failed to read Code size. */
     }
     BitsPerPixel = CodeSize;
 
     /* this can only happen on a severely malformed GIF */
@@ -919,11 +965,11 @@
 
                 /* Now lets pop all the stack into output: */
                 while (StackPtr != 0 && i < LineLen)
                     Line[i++] = Stack[--StackPtr];
             }
-            if (LastCode != NO_SUCH_CODE && Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
+            if (LastCode != NO_SUCH_CODE && Private->RunningCode - 2 < (LZ_MAX_CODE+1) && Prefix[Private->RunningCode - 2] == NO_SUCH_CODE) {
                 Prefix[Private->RunningCode - 2] = LastCode;
 
                 if (CrntCode == Private->RunningCode - 2) {
                     /* Only allowed if CrntCode is exactly the running code:
                      * In that case CrntCode = XXXCode, CrntCode or the
@@ -1067,11 +1113,11 @@
 DGifBufferedInput(GifFileType *GifFile, GifByteType *Buf, GifByteType *NextByte)
 {
     if (Buf[0] == 0) {
         /* Needs to read the next buffer - this one is empty: */
         /* coverity[check_return] */
-        if (READ(GifFile, Buf, 1) != 1) {
+        if (InternalRead(GifFile, Buf, 1) != 1) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
         /* There shouldn't be any empty data blocks here as the LZW spec
          * says the LZW termination code should come first.  Therefore we
@@ -1079,11 +1125,11 @@
          */
         if (Buf[0] == 0) {
             GifFile->Error = D_GIF_ERR_IMAGE_DEFECT;
             return GIF_ERROR;
         }
-        if (READ(GifFile, &Buf[1], Buf[0]) != Buf[0]) {
+        if (InternalRead(GifFile, &Buf[1], Buf[0]) != Buf[0]) {
             GifFile->Error = D_GIF_ERR_READ_FAILED;
             return GIF_ERROR;
         }
         *NextByte = Buf[1];
         Buf[1] = 2;    /* We use now the second place as last char read! */
@@ -1122,11 +1168,11 @@
               if (DGifGetImageDesc(GifFile) == GIF_ERROR)
                   return (GIF_ERROR);
 
               sp = &GifFile->SavedImages[GifFile->ImageCount - 1];
               /* Allocate memory for the image */
-              if (sp->ImageDesc.Width < 0 && sp->ImageDesc.Height < 0 &&
+              if (sp->ImageDesc.Width <= 0 || sp->ImageDesc.Height <= 0 ||
                       sp->ImageDesc.Width > (INT_MAX / sp->ImageDesc.Height)) {
                   return GIF_ERROR;
               }
               ImageSize = sp->ImageDesc.Width * sp->ImageDesc.Height;
 
@@ -1182,13 +1228,15 @@
                                &GifFile->ExtensionBlocks,
                                ExtFunction, ExtData[0], &ExtData[1])
                       == GIF_ERROR)
                       return (GIF_ERROR);
               }
-              while (ExtData != NULL) {
+              for (;;) {
                   if (DGifGetExtensionNext(GifFile, &ExtData) == GIF_ERROR)
                       return (GIF_ERROR);
+                  if (ExtData == NULL)
+                      break;
                   /* Continue the extension block */
                   if (ExtData != NULL)
                       if (GifAddExtensionBlock(&GifFile->ExtensionBlockCount,
                                    &GifFile->ExtensionBlocks,
                                    CONTINUE_EXT_FUNC_CODE,

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libsplashscreen/libpng/pngrutil.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="pngrtran.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngset.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libsplashscreen/libpng/pngrutil.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* pngrutil.c - utilities to read a PNG file
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Last changed in libpng 1.6.35 [July 15, 2018]</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * (Version 0.96 Copyright (c) 1996, 1997 Andreas Dilger)</span>
<span class="line-modified">  35  * (Version 0.88 Copyright (c) 1995, 1996 Guy Eric Schalnat, Group 42, Inc.)</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  *
  41  * This file contains routines that are only called from within
  42  * libpng itself during the course of reading an image.
  43  */
  44 
  45 #include &quot;pngpriv.h&quot;
  46 
  47 #ifdef PNG_READ_SUPPORTED
  48 
  49 png_uint_32 PNGAPI
  50 png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
  51 {
  52    png_uint_32 uval = png_get_uint_32(buf);
  53 
  54    if (uval &gt; PNG_UINT_31_MAX)
  55       png_error(png_ptr, &quot;PNG unsigned integer out of range&quot;);
</pre>
<hr />
<pre>
1472             keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)
1473          {
1474             read_length -= keyword_length+2;
1475 
1476             if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
1477             {
1478                Byte profile_header[132]={0};
1479                Byte local_buffer[PNG_INFLATE_BUF_SIZE];
1480                png_alloc_size_t size = (sizeof profile_header);
1481 
1482                png_ptr-&gt;zstream.next_in = (Bytef*)keyword + (keyword_length+2);
1483                png_ptr-&gt;zstream.avail_in = read_length;
1484                (void)png_inflate_read(png_ptr, local_buffer,
1485                    (sizeof local_buffer), &amp;length, profile_header, &amp;size,
1486                    0/*finish: don&#39;t, because the output is too small*/);
1487 
1488                if (size == 0)
1489                {
1490                   /* We have the ICC profile header; do the basic header checks.
1491                    */
<span class="line-modified">1492                   const png_uint_32 profile_length =</span>
<span class="line-removed">1493                      png_get_uint_32(profile_header);</span>
1494 
1495                   if (png_icc_check_length(png_ptr, &amp;png_ptr-&gt;colorspace,
1496                       keyword, profile_length) != 0)
1497                   {
1498                      /* The length is apparently ok, so we can check the 132
1499                       * byte header.
1500                       */
1501                      if (png_icc_check_header(png_ptr, &amp;png_ptr-&gt;colorspace,
1502                          keyword, profile_length, profile_header,
1503                          png_ptr-&gt;color_type) != 0)
1504                      {
1505                         /* Now read the tag table; a variable size buffer is
1506                          * needed at this point, allocate one for the whole
1507                          * profile.  The header check has already validated
1508                          * that none of this stuff will overflow.
1509                          */
<span class="line-modified">1510                         const png_uint_32 tag_count = png_get_uint_32(</span>
<span class="line-modified">1511                             profile_header+128);</span>
1512                         png_bytep profile = png_read_buffer(png_ptr,
1513                             profile_length, 2/*silent*/);
1514 
1515                         if (profile != NULL)
1516                         {
1517                            memcpy(profile, profile_header,
1518                                (sizeof profile_header));
1519 
1520                            size = 12 * tag_count;
1521 
1522                            (void)png_inflate_read(png_ptr, local_buffer,
1523                                (sizeof local_buffer), &amp;length,
1524                                profile + (sizeof profile_header), &amp;size, 0);
1525 
1526                            /* Still expect a buffer error because we expect
1527                             * there to be some tag data!
1528                             */
1529                            if (size == 0)
1530                            {
1531                               if (png_icc_check_tag_table(png_ptr,
</pre>
<hr />
<pre>
3143 #endif /* !READ_UNKNOWN_CHUNKS */
3144 
3145    /* Check for unhandled critical chunks */
3146    if (handled == 0 &amp;&amp; PNG_CHUNK_CRITICAL(png_ptr-&gt;chunk_name))
3147       png_chunk_error(png_ptr, &quot;unhandled critical chunk&quot;);
3148 }
3149 
3150 /* This function is called to verify that a chunk name is valid.
3151  * This function can&#39;t have the &quot;critical chunk check&quot; incorporated
3152  * into it, since in the future we will need to be able to call user
3153  * functions to handle unknown critical chunks after we check that
3154  * the chunk name itself is valid.
3155  */
3156 
3157 /* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
3158  *
3159  * ((c) &lt; 65 || (c) &gt; 122 || ((c) &gt; 90 &amp;&amp; (c) &lt; 97))
3160  */
3161 
3162 void /* PRIVATE */
<span class="line-modified">3163 png_check_chunk_name(png_const_structrp png_ptr, const png_uint_32 chunk_name)</span>
3164 {
3165    int i;
3166    png_uint_32 cn=chunk_name;
3167 
3168    png_debug(1, &quot;in png_check_chunk_name&quot;);
3169 
3170    for (i=1; i&lt;=4; ++i)
3171    {
3172       int c = cn &amp; 0xff;
3173 
3174       if (c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97))
3175          png_chunk_error(png_ptr, &quot;invalid chunk type&quot;);
3176 
3177       cn &gt;&gt;= 8;
3178    }
3179 }
3180 
3181 void /* PRIVATE */
<span class="line-modified">3182 png_check_chunk_length(png_const_structrp png_ptr, const png_uint_32 length)</span>
3183 {
3184    png_alloc_size_t limit = PNG_UINT_31_MAX;
3185 
3186 # ifdef PNG_SET_USER_LIMITS_SUPPORTED
3187    if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
3188        png_ptr-&gt;user_chunk_malloc_max &lt; limit)
3189       limit = png_ptr-&gt;user_chunk_malloc_max;
3190 # elif PNG_USER_CHUNK_MALLOC_MAX &gt; 0
3191    if (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
3192       limit = PNG_USER_CHUNK_MALLOC_MAX;
3193 # endif
3194    if (png_ptr-&gt;chunk_name == png_IDAT)
3195    {
3196       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
3197       size_t row_factor =
3198          (size_t)png_ptr-&gt;width
3199          * (size_t)png_ptr-&gt;channels
3200          * (png_ptr-&gt;bit_depth &gt; 8? 2: 1)
3201          + 1
3202          + (png_ptr-&gt;interlaced? 6: 0);
</pre>
<hr />
<pre>
3374 #        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
3375             B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
3376             B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
3377 
3378 #if PNG_USE_COMPILE_TIME_MASKS
3379          /* Utility macros to construct all the masks for a depth/swap
3380           * combination.  The &#39;s&#39; parameter says whether the format is PNG
3381           * (big endian bytes) or not.  Only the three odd-numbered passes are
3382           * required for the display/block algorithm.
3383           */
3384 #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
3385             S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
3386 
3387 #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
3388 
3389 #        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
3390 
3391          /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
3392           * then pass:
3393           */
<span class="line-modified">3394          static PNG_CONST png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =</span>
3395          {
3396             /* Little-endian byte masks for PACKSWAP */
3397             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
3398             /* Normal (big-endian byte) masks - PNG format */
3399             { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
3400          };
3401 
3402          /* display_mask has only three entries for the odd passes, so index by
3403           * pass&gt;&gt;1.
3404           */
<span class="line-modified">3405          static PNG_CONST png_uint_32 display_mask[2][3][3] =</span>
3406          {
3407             /* Little-endian byte masks for PACKSWAP */
3408             { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
3409             /* Normal (big-endian byte) masks - PNG format */
3410             { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
3411          };
3412 
3413 #        define MASK(pass,depth,display,png)\
3414             ((display)?display_mask[png][DEPTH_INDEX(depth)][pass&gt;&gt;1]:\
3415                row_mask[png][DEPTH_INDEX(depth)][pass])
3416 
3417 #else /* !PNG_USE_COMPILE_TIME_MASKS */
3418          /* This is the runtime alternative: it seems unlikely that this will
3419           * ever be either smaller or faster than the compile time approach.
3420           */
3421 #        define MASK(pass,depth,display,png)\
3422             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
3423 #endif /* !USE_COMPILE_TIME_MASKS */
3424 
3425          /* Use the appropriate mask to copy the required bits.  In some cases
</pre>
<hr />
<pre>
3698 #endif /* READ_INTERLACING */
3699 
3700    /* If here then the switch above wasn&#39;t used so just memcpy the whole row
3701     * from the temporary row buffer (notice that this overwrites the end of the
3702     * destination row if it is a partial byte.)
3703     */
3704    memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
3705 
3706    /* Restore the overwritten bits from the last byte if necessary. */
3707    if (end_ptr != NULL)
3708       *end_ptr = (png_byte)((end_byte &amp; end_mask) | (*end_ptr &amp; ~end_mask));
3709 }
3710 
3711 #ifdef PNG_READ_INTERLACING_SUPPORTED
3712 void /* PRIVATE */
3713 png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
3714     png_uint_32 transformations /* Because these may affect the byte layout */)
3715 {
3716    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
3717    /* Offset to next interlace block */
<span class="line-modified">3718    static PNG_CONST unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
3719 
3720    png_debug(1, &quot;in png_do_read_interlace&quot;);
3721    if (row != NULL &amp;&amp; row_info != NULL)
3722    {
3723       png_uint_32 final_width;
3724 
3725       final_width = row_info-&gt;width * png_pass_inc[pass];
3726 
3727       switch (row_info-&gt;pixel_depth)
3728       {
3729          case 1:
3730          {
3731             png_bytep sp = row + (size_t)((row_info-&gt;width - 1) &gt;&gt; 3);
3732             png_bytep dp = row + (size_t)((final_width - 1) &gt;&gt; 3);
3733             unsigned int sshift, dshift;
3734             unsigned int s_start, s_end;
3735             int s_inc;
3736             int jstop = (int)png_pass_inc[pass];
3737             png_byte v;
3738             png_uint_32 i;
</pre>
<hr />
<pre>
4340       png_ptr-&gt;zstream.avail_in = 0;
4341 
4342       /* Now we no longer own the zstream. */
4343       png_ptr-&gt;zowner = 0;
4344 
4345       /* The slightly weird semantics of the sequential IDAT reading is that we
4346        * are always in or at the end of an IDAT chunk, so we always need to do a
4347        * crc_finish here.  If idat_size is non-zero we also need to read the
4348        * spurious bytes at the end of the chunk now.
4349        */
4350       (void)png_crc_finish(png_ptr, png_ptr-&gt;idat_size);
4351    }
4352 }
4353 
4354 void /* PRIVATE */
4355 png_read_finish_row(png_structrp png_ptr)
4356 {
4357    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4358 
4359    /* Start of interlace block */
<span class="line-modified">4360    static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
4361 
4362    /* Offset to next interlace block */
<span class="line-modified">4363    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
4364 
4365    /* Start of interlace block in the y direction */
<span class="line-modified">4366    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
4367 
4368    /* Offset to next interlace block in the y direction */
<span class="line-modified">4369    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
4370 
4371    png_debug(1, &quot;in png_read_finish_row&quot;);
4372    png_ptr-&gt;row_number++;
4373    if (png_ptr-&gt;row_number &lt; png_ptr-&gt;num_rows)
4374       return;
4375 
4376    if (png_ptr-&gt;interlaced != 0)
4377    {
4378       png_ptr-&gt;row_number = 0;
4379 
4380       /* TO DO: don&#39;t do this if prev_row isn&#39;t needed (requires
4381        * read-ahead of the next row&#39;s filter byte.
4382        */
4383       memset(png_ptr-&gt;prev_row, 0, png_ptr-&gt;rowbytes + 1);
4384 
4385       do
4386       {
4387          png_ptr-&gt;pass++;
4388 
4389          if (png_ptr-&gt;pass &gt;= 7)
</pre>
<hr />
<pre>
4405          else  /* if (png_ptr-&gt;transformations &amp; PNG_INTERLACE) */
4406             break; /* libpng deinterlacing sees every row */
4407 
4408       } while (png_ptr-&gt;num_rows == 0 || png_ptr-&gt;iwidth == 0);
4409 
4410       if (png_ptr-&gt;pass &lt; 7)
4411          return;
4412    }
4413 
4414    /* Here after at the end of the last row of the last pass. */
4415    png_read_finish_IDAT(png_ptr);
4416 }
4417 #endif /* SEQUENTIAL_READ */
4418 
4419 void /* PRIVATE */
4420 png_read_start_row(png_structrp png_ptr)
4421 {
4422    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4423 
4424    /* Start of interlace block */
<span class="line-modified">4425    static PNG_CONST png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
4426 
4427    /* Offset to next interlace block */
<span class="line-modified">4428    static PNG_CONST png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
4429 
4430    /* Start of interlace block in the y direction */
<span class="line-modified">4431    static PNG_CONST png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
4432 
4433    /* Offset to next interlace block in the y direction */
<span class="line-modified">4434    static PNG_CONST png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
4435 
4436    unsigned int max_pixel_depth;
4437    size_t row_bytes;
4438 
4439    png_debug(1, &quot;in png_read_start_row&quot;);
4440 
4441 #ifdef PNG_READ_TRANSFORMS_SUPPORTED
4442    png_init_read_transformations(png_ptr);
4443 #endif
4444    if (png_ptr-&gt;interlaced != 0)
4445    {
4446       if ((png_ptr-&gt;transformations &amp; PNG_INTERLACE) == 0)
4447          png_ptr-&gt;num_rows = (png_ptr-&gt;height + png_pass_yinc[0] - 1 -
4448              png_pass_ystart[0]) / png_pass_yinc[0];
4449 
4450       else
4451          png_ptr-&gt;num_rows = png_ptr-&gt;height;
4452 
4453       png_ptr-&gt;iwidth = (png_ptr-&gt;width +
4454           png_pass_inc[png_ptr-&gt;pass] - 1 -
</pre>
</td>
<td>
<hr />
<pre>
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  */
  24 
  25 /* pngrutil.c - utilities to read a PNG file
  26  *
  27  * This file is available under and governed by the GNU General Public
  28  * License version 2 only, as published by the Free Software Foundation.
  29  * However, the following notice accompanied the original version of this
  30  * file and, per its terms, should not be removed:
  31  *
<span class="line-modified">  32  * Copyright (c) 2018 Cosmin Truta</span>
  33  * Copyright (c) 1998-2002,2004,2006-2018 Glenn Randers-Pehrson
<span class="line-modified">  34  * Copyright (c) 1996-1997 Andreas Dilger</span>
<span class="line-modified">  35  * Copyright (c) 1995-1996 Guy Eric Schalnat, Group 42, Inc.</span>
  36  *
  37  * This code is released under the libpng license.
  38  * For conditions of distribution and use, see the disclaimer
  39  * and license in png.h
  40  *
  41  * This file contains routines that are only called from within
  42  * libpng itself during the course of reading an image.
  43  */
  44 
  45 #include &quot;pngpriv.h&quot;
  46 
  47 #ifdef PNG_READ_SUPPORTED
  48 
  49 png_uint_32 PNGAPI
  50 png_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
  51 {
  52    png_uint_32 uval = png_get_uint_32(buf);
  53 
  54    if (uval &gt; PNG_UINT_31_MAX)
  55       png_error(png_ptr, &quot;PNG unsigned integer out of range&quot;);
</pre>
<hr />
<pre>
1472             keyword[keyword_length+1] == PNG_COMPRESSION_TYPE_BASE)
1473          {
1474             read_length -= keyword_length+2;
1475 
1476             if (png_inflate_claim(png_ptr, png_iCCP) == Z_OK)
1477             {
1478                Byte profile_header[132]={0};
1479                Byte local_buffer[PNG_INFLATE_BUF_SIZE];
1480                png_alloc_size_t size = (sizeof profile_header);
1481 
1482                png_ptr-&gt;zstream.next_in = (Bytef*)keyword + (keyword_length+2);
1483                png_ptr-&gt;zstream.avail_in = read_length;
1484                (void)png_inflate_read(png_ptr, local_buffer,
1485                    (sizeof local_buffer), &amp;length, profile_header, &amp;size,
1486                    0/*finish: don&#39;t, because the output is too small*/);
1487 
1488                if (size == 0)
1489                {
1490                   /* We have the ICC profile header; do the basic header checks.
1491                    */
<span class="line-modified">1492                   png_uint_32 profile_length = png_get_uint_32(profile_header);</span>

1493 
1494                   if (png_icc_check_length(png_ptr, &amp;png_ptr-&gt;colorspace,
1495                       keyword, profile_length) != 0)
1496                   {
1497                      /* The length is apparently ok, so we can check the 132
1498                       * byte header.
1499                       */
1500                      if (png_icc_check_header(png_ptr, &amp;png_ptr-&gt;colorspace,
1501                          keyword, profile_length, profile_header,
1502                          png_ptr-&gt;color_type) != 0)
1503                      {
1504                         /* Now read the tag table; a variable size buffer is
1505                          * needed at this point, allocate one for the whole
1506                          * profile.  The header check has already validated
1507                          * that none of this stuff will overflow.
1508                          */
<span class="line-modified">1509                         png_uint_32 tag_count =</span>
<span class="line-modified">1510                            png_get_uint_32(profile_header + 128);</span>
1511                         png_bytep profile = png_read_buffer(png_ptr,
1512                             profile_length, 2/*silent*/);
1513 
1514                         if (profile != NULL)
1515                         {
1516                            memcpy(profile, profile_header,
1517                                (sizeof profile_header));
1518 
1519                            size = 12 * tag_count;
1520 
1521                            (void)png_inflate_read(png_ptr, local_buffer,
1522                                (sizeof local_buffer), &amp;length,
1523                                profile + (sizeof profile_header), &amp;size, 0);
1524 
1525                            /* Still expect a buffer error because we expect
1526                             * there to be some tag data!
1527                             */
1528                            if (size == 0)
1529                            {
1530                               if (png_icc_check_tag_table(png_ptr,
</pre>
<hr />
<pre>
3142 #endif /* !READ_UNKNOWN_CHUNKS */
3143 
3144    /* Check for unhandled critical chunks */
3145    if (handled == 0 &amp;&amp; PNG_CHUNK_CRITICAL(png_ptr-&gt;chunk_name))
3146       png_chunk_error(png_ptr, &quot;unhandled critical chunk&quot;);
3147 }
3148 
3149 /* This function is called to verify that a chunk name is valid.
3150  * This function can&#39;t have the &quot;critical chunk check&quot; incorporated
3151  * into it, since in the future we will need to be able to call user
3152  * functions to handle unknown critical chunks after we check that
3153  * the chunk name itself is valid.
3154  */
3155 
3156 /* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:
3157  *
3158  * ((c) &lt; 65 || (c) &gt; 122 || ((c) &gt; 90 &amp;&amp; (c) &lt; 97))
3159  */
3160 
3161 void /* PRIVATE */
<span class="line-modified">3162 png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)</span>
3163 {
3164    int i;
3165    png_uint_32 cn=chunk_name;
3166 
3167    png_debug(1, &quot;in png_check_chunk_name&quot;);
3168 
3169    for (i=1; i&lt;=4; ++i)
3170    {
3171       int c = cn &amp; 0xff;
3172 
3173       if (c &lt; 65 || c &gt; 122 || (c &gt; 90 &amp;&amp; c &lt; 97))
3174          png_chunk_error(png_ptr, &quot;invalid chunk type&quot;);
3175 
3176       cn &gt;&gt;= 8;
3177    }
3178 }
3179 
3180 void /* PRIVATE */
<span class="line-modified">3181 png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)</span>
3182 {
3183    png_alloc_size_t limit = PNG_UINT_31_MAX;
3184 
3185 # ifdef PNG_SET_USER_LIMITS_SUPPORTED
3186    if (png_ptr-&gt;user_chunk_malloc_max &gt; 0 &amp;&amp;
3187        png_ptr-&gt;user_chunk_malloc_max &lt; limit)
3188       limit = png_ptr-&gt;user_chunk_malloc_max;
3189 # elif PNG_USER_CHUNK_MALLOC_MAX &gt; 0
3190    if (PNG_USER_CHUNK_MALLOC_MAX &lt; limit)
3191       limit = PNG_USER_CHUNK_MALLOC_MAX;
3192 # endif
3193    if (png_ptr-&gt;chunk_name == png_IDAT)
3194    {
3195       png_alloc_size_t idat_limit = PNG_UINT_31_MAX;
3196       size_t row_factor =
3197          (size_t)png_ptr-&gt;width
3198          * (size_t)png_ptr-&gt;channels
3199          * (png_ptr-&gt;bit_depth &gt; 8? 2: 1)
3200          + 1
3201          + (png_ptr-&gt;interlaced? 6: 0);
</pre>
<hr />
<pre>
3373 #        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
3374             B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
3375             B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
3376 
3377 #if PNG_USE_COMPILE_TIME_MASKS
3378          /* Utility macros to construct all the masks for a depth/swap
3379           * combination.  The &#39;s&#39; parameter says whether the format is PNG
3380           * (big endian bytes) or not.  Only the three odd-numbered passes are
3381           * required for the display/block algorithm.
3382           */
3383 #        define S_MASKS(d,s) { S_MASK(0,d,s), S_MASK(1,d,s), S_MASK(2,d,s),\
3384             S_MASK(3,d,s), S_MASK(4,d,s), S_MASK(5,d,s) }
3385 
3386 #        define B_MASKS(d,s) { B_MASK(1,d,s), B_MASK(3,d,s), B_MASK(5,d,s) }
3387 
3388 #        define DEPTH_INDEX(d) ((d)==1?0:((d)==2?1:2))
3389 
3390          /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
3391           * then pass:
3392           */
<span class="line-modified">3393          static const png_uint_32 row_mask[2/*PACKSWAP*/][3/*depth*/][6] =</span>
3394          {
3395             /* Little-endian byte masks for PACKSWAP */
3396             { S_MASKS(1,0), S_MASKS(2,0), S_MASKS(4,0) },
3397             /* Normal (big-endian byte) masks - PNG format */
3398             { S_MASKS(1,1), S_MASKS(2,1), S_MASKS(4,1) }
3399          };
3400 
3401          /* display_mask has only three entries for the odd passes, so index by
3402           * pass&gt;&gt;1.
3403           */
<span class="line-modified">3404          static const png_uint_32 display_mask[2][3][3] =</span>
3405          {
3406             /* Little-endian byte masks for PACKSWAP */
3407             { B_MASKS(1,0), B_MASKS(2,0), B_MASKS(4,0) },
3408             /* Normal (big-endian byte) masks - PNG format */
3409             { B_MASKS(1,1), B_MASKS(2,1), B_MASKS(4,1) }
3410          };
3411 
3412 #        define MASK(pass,depth,display,png)\
3413             ((display)?display_mask[png][DEPTH_INDEX(depth)][pass&gt;&gt;1]:\
3414                row_mask[png][DEPTH_INDEX(depth)][pass])
3415 
3416 #else /* !PNG_USE_COMPILE_TIME_MASKS */
3417          /* This is the runtime alternative: it seems unlikely that this will
3418           * ever be either smaller or faster than the compile time approach.
3419           */
3420 #        define MASK(pass,depth,display,png)\
3421             ((display)?B_MASK(pass,depth,png):S_MASK(pass,depth,png))
3422 #endif /* !USE_COMPILE_TIME_MASKS */
3423 
3424          /* Use the appropriate mask to copy the required bits.  In some cases
</pre>
<hr />
<pre>
3697 #endif /* READ_INTERLACING */
3698 
3699    /* If here then the switch above wasn&#39;t used so just memcpy the whole row
3700     * from the temporary row buffer (notice that this overwrites the end of the
3701     * destination row if it is a partial byte.)
3702     */
3703    memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
3704 
3705    /* Restore the overwritten bits from the last byte if necessary. */
3706    if (end_ptr != NULL)
3707       *end_ptr = (png_byte)((end_byte &amp; end_mask) | (*end_ptr &amp; ~end_mask));
3708 }
3709 
3710 #ifdef PNG_READ_INTERLACING_SUPPORTED
3711 void /* PRIVATE */
3712 png_do_read_interlace(png_row_infop row_info, png_bytep row, int pass,
3713     png_uint_32 transformations /* Because these may affect the byte layout */)
3714 {
3715    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
3716    /* Offset to next interlace block */
<span class="line-modified">3717    static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
3718 
3719    png_debug(1, &quot;in png_do_read_interlace&quot;);
3720    if (row != NULL &amp;&amp; row_info != NULL)
3721    {
3722       png_uint_32 final_width;
3723 
3724       final_width = row_info-&gt;width * png_pass_inc[pass];
3725 
3726       switch (row_info-&gt;pixel_depth)
3727       {
3728          case 1:
3729          {
3730             png_bytep sp = row + (size_t)((row_info-&gt;width - 1) &gt;&gt; 3);
3731             png_bytep dp = row + (size_t)((final_width - 1) &gt;&gt; 3);
3732             unsigned int sshift, dshift;
3733             unsigned int s_start, s_end;
3734             int s_inc;
3735             int jstop = (int)png_pass_inc[pass];
3736             png_byte v;
3737             png_uint_32 i;
</pre>
<hr />
<pre>
4339       png_ptr-&gt;zstream.avail_in = 0;
4340 
4341       /* Now we no longer own the zstream. */
4342       png_ptr-&gt;zowner = 0;
4343 
4344       /* The slightly weird semantics of the sequential IDAT reading is that we
4345        * are always in or at the end of an IDAT chunk, so we always need to do a
4346        * crc_finish here.  If idat_size is non-zero we also need to read the
4347        * spurious bytes at the end of the chunk now.
4348        */
4349       (void)png_crc_finish(png_ptr, png_ptr-&gt;idat_size);
4350    }
4351 }
4352 
4353 void /* PRIVATE */
4354 png_read_finish_row(png_structrp png_ptr)
4355 {
4356    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4357 
4358    /* Start of interlace block */
<span class="line-modified">4359    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
4360 
4361    /* Offset to next interlace block */
<span class="line-modified">4362    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
4363 
4364    /* Start of interlace block in the y direction */
<span class="line-modified">4365    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
4366 
4367    /* Offset to next interlace block in the y direction */
<span class="line-modified">4368    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
4369 
4370    png_debug(1, &quot;in png_read_finish_row&quot;);
4371    png_ptr-&gt;row_number++;
4372    if (png_ptr-&gt;row_number &lt; png_ptr-&gt;num_rows)
4373       return;
4374 
4375    if (png_ptr-&gt;interlaced != 0)
4376    {
4377       png_ptr-&gt;row_number = 0;
4378 
4379       /* TO DO: don&#39;t do this if prev_row isn&#39;t needed (requires
4380        * read-ahead of the next row&#39;s filter byte.
4381        */
4382       memset(png_ptr-&gt;prev_row, 0, png_ptr-&gt;rowbytes + 1);
4383 
4384       do
4385       {
4386          png_ptr-&gt;pass++;
4387 
4388          if (png_ptr-&gt;pass &gt;= 7)
</pre>
<hr />
<pre>
4404          else  /* if (png_ptr-&gt;transformations &amp; PNG_INTERLACE) */
4405             break; /* libpng deinterlacing sees every row */
4406 
4407       } while (png_ptr-&gt;num_rows == 0 || png_ptr-&gt;iwidth == 0);
4408 
4409       if (png_ptr-&gt;pass &lt; 7)
4410          return;
4411    }
4412 
4413    /* Here after at the end of the last row of the last pass. */
4414    png_read_finish_IDAT(png_ptr);
4415 }
4416 #endif /* SEQUENTIAL_READ */
4417 
4418 void /* PRIVATE */
4419 png_read_start_row(png_structrp png_ptr)
4420 {
4421    /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
4422 
4423    /* Start of interlace block */
<span class="line-modified">4424    static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};</span>
4425 
4426    /* Offset to next interlace block */
<span class="line-modified">4427    static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};</span>
4428 
4429    /* Start of interlace block in the y direction */
<span class="line-modified">4430    static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};</span>
4431 
4432    /* Offset to next interlace block in the y direction */
<span class="line-modified">4433    static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};</span>
4434 
4435    unsigned int max_pixel_depth;
4436    size_t row_bytes;
4437 
4438    png_debug(1, &quot;in png_read_start_row&quot;);
4439 
4440 #ifdef PNG_READ_TRANSFORMS_SUPPORTED
4441    png_init_read_transformations(png_ptr);
4442 #endif
4443    if (png_ptr-&gt;interlaced != 0)
4444    {
4445       if ((png_ptr-&gt;transformations &amp; PNG_INTERLACE) == 0)
4446          png_ptr-&gt;num_rows = (png_ptr-&gt;height + png_pass_yinc[0] - 1 -
4447              png_pass_ystart[0]) / png_pass_yinc[0];
4448 
4449       else
4450          png_ptr-&gt;num_rows = png_ptr-&gt;height;
4451 
4452       png_ptr-&gt;iwidth = (png_ptr-&gt;width +
4453           png_pass_inc[png_ptr-&gt;pass] - 1 -
</pre>
</td>
</tr>
</table>
<center><a href="pngrtran.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="pngset.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libsplashscreen/splashscreen_impl.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 #include &quot;splashscreen_gfx_impl.h&quot;
 28 #define BUFF_SIZE 1024
 29 #ifdef _MSC_VER
 30 # ifndef snprintf
 31 #       define snprintf _snprintf
 32 # endif
 33 #endif
 34 int splashIsVisible = 0;
 35 
 36 Splash *
 37 SplashGetInstance()
 38 {
 39     static Splash splash;
 40     static int preInitialized = 0;
 41     if (!preInitialized) {
 42         memset(&amp;splash, 0, sizeof(Splash));
 43         splash.currentFrame = -1;
 44         preInitialized = 1;
 45     }
 46     return &amp;splash;
 47 }
 48 
<a name="2" id="anc2"></a><span class="line-modified"> 49 JNIEXPORT void JNICALL</span>
 50 SplashSetFileJarName(const char* fileName, const char* jarName) {
 51     Splash *splash = SplashGetInstance();
 52 
 53     free(splash-&gt;fileName);
 54     splash-&gt;fileName = SplashConvertStringAlloc(fileName, &amp;splash-&gt;fileNameLen);
 55 
 56     free(splash-&gt;jarName);
 57     splash-&gt;jarName = SplashConvertStringAlloc(jarName, &amp;splash-&gt;jarNameLen);
 58 }
 59 
<a name="3" id="anc3"></a><span class="line-modified"> 60 JNIEXPORT void JNICALL</span>
 61 SplashInit()
 62 {
 63     Splash *splash = SplashGetInstance();
 64 
 65     memset(splash, 0, sizeof(Splash));
 66     splash-&gt;currentFrame = -1;
 67     splash-&gt;scaleFactor = 1;
 68     initFormat(&amp;splash-&gt;imageFormat, QUAD_RED_MASK, QUAD_GREEN_MASK,
 69         QUAD_BLUE_MASK, QUAD_ALPHA_MASK);
<a name="4" id="anc4"></a><span class="line-modified"> 70     SplashInitPlatform(splash);</span>
 71 }
 72 
<a name="5" id="anc5"></a><span class="line-modified"> 73 JNIEXPORT void JNICALL</span>
 74 SplashClose()
 75 {
 76     Splash *splash = SplashGetInstance();
 77 
 78     if (splash-&gt;isVisible &gt; 0) {
 79         SplashLock(splash);
 80         splash-&gt;isVisible = -1;
 81         SplashClosePlatform(splash);
 82         SplashUnlock(splash);
 83     }
 84 }
 85 
 86 void
 87 SplashCleanup(Splash * splash)
 88 {
 89     int i;
 90 
 91     splash-&gt;currentFrame = -1;
 92     SplashCleanupPlatform(splash);
 93     if (splash-&gt;frames) {
 94         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
 95             if (splash-&gt;frames[i].bitmapBits) {
 96                 free(splash-&gt;frames[i].bitmapBits);
 97                 splash-&gt;frames[i].bitmapBits = NULL;
 98             }
 99         }
100         free(splash-&gt;frames);
101         splash-&gt;frames = NULL;
102     }
103     if (splash-&gt;overlayData) {
104         free(splash-&gt;overlayData);
105         splash-&gt;overlayData = NULL;
106     }
107     SplashSetFileJarName(NULL, NULL);
108 }
109 
<a name="6" id="anc6"></a><span class="line-modified">110 JNIEXPORT void JNICALL</span>
111 SplashSetScaleFactor(float scaleFactor)
112 {
113     Splash *splash = SplashGetInstance();
114     splash-&gt;scaleFactor = scaleFactor;
115 }
116 
117 void
118 SplashDone(Splash * splash)
119 {
120     SplashCleanup(splash);
121     SplashDonePlatform(splash);
122 }
123 
124 int
125 SplashIsStillLooping(Splash * splash)
126 {
127     if (splash-&gt;currentFrame &lt; 0) {
128         return 0;
129     }
130     return splash-&gt;loopCount != 1 ||
131         splash-&gt;currentFrame + 1 &lt; splash-&gt;frameCount;
132 }
133 
134 void
135 SplashUpdateScreenData(Splash * splash)
136 {
137     ImageRect srcRect, dstRect;
138     if (splash-&gt;currentFrame &lt; 0) {
139         return;
140     }
141 
142     initRect(&amp;srcRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
143         splash-&gt;width * sizeof(rgbquad_t),
144         splash-&gt;frames[splash-&gt;currentFrame].bitmapBits, &amp;splash-&gt;imageFormat);
145     if (splash-&gt;screenData) {
146         free(splash-&gt;screenData);
147     }
148     splash-&gt;screenStride = splash-&gt;width * splash-&gt;screenFormat.depthBytes;
149     if (splash-&gt;byteAlignment &gt; 1) {
150         splash-&gt;screenStride =
151             (splash-&gt;screenStride + splash-&gt;byteAlignment - 1) &amp;
152             ~(splash-&gt;byteAlignment - 1);
153     }
154     splash-&gt;screenData = malloc(splash-&gt;height * splash-&gt;screenStride);
155     initRect(&amp;dstRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
156         splash-&gt;screenStride, splash-&gt;screenData, &amp;splash-&gt;screenFormat);
157     if (splash-&gt;overlayData) {
158         convertRect2(&amp;srcRect, &amp;dstRect, CVT_BLEND, &amp;splash-&gt;overlayRect);
159     }
160     else {
161         convertRect(&amp;srcRect, &amp;dstRect, CVT_COPY);
162     }
163 }
164 
165 void
166 SplashNextFrame(Splash * splash)
167 {
168     if (splash-&gt;currentFrame &lt; 0) {
169         return;
170     }
171     do {
172         if (!SplashIsStillLooping(splash)) {
173             return;
174         }
175         splash-&gt;time += splash-&gt;frames[splash-&gt;currentFrame].delay;
176         if (++splash-&gt;currentFrame &gt;= splash-&gt;frameCount) {
177             splash-&gt;currentFrame = 0;
178             if (splash-&gt;loopCount &gt; 0) {
179                 splash-&gt;loopCount--;
180             }
181         }
182     } while (splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay -
183         SplashTime() &lt;= 0);
184 }
185 
186 int
187 BitmapToYXBandedRectangles(ImageRect * pSrcRect, RECT_T * out)
188 {
189     RECT_T *pPrevLine = NULL, *pFirst = out, *pThis = pFirst;
190     int i, j, i0;
191     int length;
192 
193     for (j = 0; j &lt; pSrcRect-&gt;numLines; j++) {
194 
195         /* generate data for a scanline */
196 
197         byte_t *pSrc = (byte_t *) pSrcRect-&gt;pBits + j * pSrcRect-&gt;stride;
198         RECT_T *pLine = pThis;
199 
200         i = 0;
201 
202         do {
203             while (i &lt; pSrcRect-&gt;numSamples &amp;&amp;
204                    getRGBA(pSrc, pSrcRect-&gt;format) &lt; ALPHA_THRESHOLD) {
205                 pSrc += pSrcRect-&gt;depthBytes;
206                 ++i;
207             }
208             if (i &gt;= pSrcRect-&gt;numSamples) {
209                 break;
210             }
211             i0 = i;
212             while (i &lt; pSrcRect-&gt;numSamples &amp;&amp;
213                    getRGBA(pSrc, pSrcRect-&gt;format) &gt;= ALPHA_THRESHOLD) {
214                 pSrc += pSrcRect-&gt;depthBytes;
215                 ++i;
216             }
217             RECT_SET(*pThis, i0, j, i - i0, 1);
218             ++pThis;
219         } while (i &lt; pSrcRect-&gt;numSamples);
220 
221         /*  check if the previous scanline is exactly the same, merge if so
222            (this is the only optimization we can use for YXBanded rectangles, and win32 supports
223            YXBanded only */
224 
225         length = pThis - pLine;
226         if (pPrevLine &amp;&amp; pLine - pPrevLine == length) {
227             for (i = 0; i &lt; length &amp;&amp; RECT_EQ_X(pPrevLine[i], pLine[i]); ++i) {
228             }
229             if (i == pLine - pPrevLine) {
230                 // do merge
231                 for (i = 0; i &lt; length; i++) {
232                     RECT_INC_HEIGHT(pPrevLine[i]);
233                 }
234                 pThis = pLine;
235                 continue;
236             }
237         }
238         /* or else use the generated scanline */
239 
240         pPrevLine = pLine;
241     }
242     return pThis - pFirst;
243 }
244 
245 typedef struct FILEFORMAT
246 {
247     int sign;
248     int (*decodeStream) (Splash * splash, SplashStream * stream);
249 } FILEFORMAT;
250 
251 static const FILEFORMAT formats[] = {
252     {0x47, SplashDecodeGifStream},
253     {0x89, SplashDecodePngStream},
254     {0xFF, SplashDecodeJpegStream}
255 };
256 
257 static int
258 SplashLoadStream(SplashStream * stream)
259 {
260     int success = 0;
261     int c;
262     size_t i;
263 
264     Splash *splash = SplashGetInstance();
265     if (splash-&gt;isVisible &lt; 0) {
<a name="7" id="anc7"></a>
266         return 0;
267     }
268 
269     SplashLock(splash);
270 
271     /* the formats we support can be easily distinguished by the first byte */
272     c = stream-&gt;peek(stream);
273     if (c != -1) {
274         for (i = 0; i &lt; sizeof(formats) / sizeof(FILEFORMAT); i++) {
275             if (c == formats[i].sign) {
276                 success = formats[i].decodeStream(splash, stream);
277                 break;
278             }
279         }
280     }
281     stream-&gt;close(stream);
282 
283     if (!success) {             // failed to decode
284         if (splash-&gt;isVisible == 0) {
285             SplashCleanup(splash);
286         }
287         SplashUnlock(splash);   // SplashClose locks
288         if (splash-&gt;isVisible == 0) {
289             SplashClose();
290         }
291     }
292     else {
293         splash-&gt;currentFrame = 0;
294         if (splash-&gt;isVisible == 0) {
295             SplashStart(splash);
296         } else {
297             SplashReconfigure(splash);
298             splash-&gt;time = SplashTime();
299         }
300         SplashUnlock(splash);
301     }
302     return success;
303 }
304 
<a name="8" id="anc8"></a><span class="line-modified">305 JNIEXPORT int JNICALL</span>
306 SplashLoadFile(const char *filename)
307 {
308     SplashStream stream;
309     return SplashStreamInitFile(&amp;stream, filename) &amp;&amp;
310                 SplashLoadStream(&amp;stream);
311 }
312 
<a name="9" id="anc9"></a><span class="line-modified">313 JNIEXPORT int JNICALL</span>
314 SplashLoadMemory(void *data, int size)
315 {
316     SplashStream stream;
317     return SplashStreamInitMemory(&amp;stream, data, size) &amp;&amp;
318                 SplashLoadStream(&amp;stream);
319 }
320 
321 /* SplashStart MUST be called from under the lock */
322 
323 void
324 SplashStart(Splash * splash)
325 {
326     if (splash-&gt;isVisible == 0) {
327         SplashCreateThread(splash);
328         splash-&gt;isVisible = 1;
329     }
330 }
331 
332 /* SplashStream functions */
333 
334 static int readFile(void* pStream, void* pData, int nBytes) {
335     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
336     return fread(pData, 1, nBytes, f);
337 }
338 static int peekFile(void* pStream) {
339     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
340     int c = fgetc(f);
341     if (c != EOF) {
342         ungetc(c, f);
343         return c;
344     } else {
345         return -1;
346     }
347 }
348 
349 static void closeFile(void* pStream) {
350     FILE* f = ((SplashStream*)pStream)-&gt;arg.stdio.f;
351     fclose(f);
352 }
353 
354 static int readMem(void* pStream, void* pData, int nBytes) {
355     unsigned char* pSrc = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pData);
356     unsigned char* pSrcEnd = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pDataEnd);
357     if (nBytes &gt; pSrcEnd - pSrc) {
358         nBytes = pSrcEnd - pSrc;
359     }
360     if (nBytes&gt;0) {
361         memcpy(pData, pSrc, nBytes);
362         pSrc += nBytes;
363         ((SplashStream*)pStream)-&gt;arg.mem.pData = (void*)pSrc;
364     }
365     return nBytes;
366 }
367 
368 static int peekMem(void* pStream) {
369     unsigned char* pSrc = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pData);
370     unsigned char* pSrcEnd = (unsigned char*)(((SplashStream*)pStream)-&gt;arg.mem.pDataEnd);
371     if (pSrc &gt;= pSrcEnd) {
372         return -1;
373     } else {
374         return (int)*pSrc;
375     }
376 }
377 
378 static void closeMem(void* pStream) {
379 }
380 
381 int SplashStreamInitFile(SplashStream * pStream, const char* filename) {
382     pStream-&gt;arg.stdio.f = fopen(filename, &quot;rb&quot;);
383     pStream-&gt;read = readFile;
384     pStream-&gt;peek = peekFile;
385     pStream-&gt;close = closeFile;
386     return pStream-&gt;arg.stdio.f != 0;
387 }
388 
389 int SplashStreamInitMemory(SplashStream * pStream, void* pData, int size) {
390     pStream-&gt;arg.mem.pData = (unsigned char*)pData;
391     pStream-&gt;arg.mem.pDataEnd = (unsigned char*)pData + size;
392     pStream-&gt;read = readMem;
393     pStream-&gt;peek = peekMem;
394     pStream-&gt;close = closeMem;
395     return 1;
396 }
397 
<a name="10" id="anc10"></a><span class="line-modified">398 JNIEXPORT int JNICALL</span>
399 SplashGetScaledImgNameMaxPstfixLen(const char *fileName){
400     return strlen(fileName) + strlen(&quot;@100pct&quot;) + 1;
401 }
402 
403 jboolean GetScaledImageName(const char *fileName, char *scaleImageName,
404         float *scaleFactor, const size_t scaledImageLength) {
405     if (*scaleFactor &gt; 1.0) {
406         FILE *fp = NULL;
407         char scaledImgPct[BUFF_SIZE];
408         char scaledImgX[BUFF_SIZE];
409         char *scaledImageXName = NULL;
410         char *scaledImagePctName = malloc(scaledImageLength);
411         char *dupFileName = strdup(fileName);
412         char *fileExtension = strrchr(dupFileName, &#39;.&#39;);
413         size_t lengthPct = 0;
414         size_t lengthX = 0;
415         int retValPct = 0;
416         int retValX = 0;
417         jboolean isPctScaledImage = (*scaleFactor * 100) != ((int) (*scaleFactor)) *100;
418         snprintf(scaledImgPct, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;,
419                 (int) (*scaleFactor * 100), &quot;pct&quot;);
420         if (!isPctScaledImage) {
421             scaledImageXName = malloc(scaledImageLength);
422             snprintf(scaledImgX, BUFF_SIZE, &quot;%s%d%s&quot;, &quot;@&quot;, (int) (*scaleFactor), &quot;x&quot;);
423         }
424         /*File is missing extension */
425         if (fileExtension == NULL) {
426             lengthPct = strlen(dupFileName) +
427                     strlen(scaledImgPct) + 1;
428             if (!isPctScaledImage) {
429                 lengthX = strlen(dupFileName) +
430                         strlen(scaledImgX) + 1;
431             }
432             if (lengthPct &gt; scaledImageLength || lengthX &gt; scaledImageLength) {
433                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
434                 return JNI_FALSE;
435             }
436             retValPct = snprintf(scaledImagePctName, lengthPct, &quot;%s%s&quot;, dupFileName,
437                     scaledImgPct);
438             if (!isPctScaledImage) {
439                 retValX = snprintf(scaledImageXName, lengthX, &quot;%s%s&quot;, dupFileName,
440                         scaledImgX);
441             }
442             if ((retValPct &lt; 0 || (retValPct &gt; lengthPct - 1)) ||
443                     (retValX &lt; 0 || (retValX &gt; lengthX - 1))) {
444                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
445                 return JNI_FALSE;
446             }
447         } else {
448             int length_Without_Ext = fileExtension - dupFileName;
449             lengthPct = length_Without_Ext + strlen(scaledImgPct) +
450                     strlen(fileExtension) + 1;
451             if (!isPctScaledImage) {
452                 lengthX = length_Without_Ext + strlen(scaledImgX) +
453                         strlen(fileExtension) + 1;
454             }
455             if (lengthPct &gt; scaledImageLength || lengthX &gt; scaledImageLength) {
456                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
457                 return JNI_FALSE;
458             }
459             retValPct = snprintf(scaledImagePctName, lengthPct, &quot;%.*s%s%s&quot;,
460                     length_Without_Ext, dupFileName, scaledImgPct, fileExtension);
461             if (!isPctScaledImage) {
462                 retValX = snprintf(scaledImageXName, lengthX, &quot;%.*s%s%s&quot;,
463                         length_Without_Ext, dupFileName, scaledImgX, fileExtension);
464             }
465             if ((retValPct &lt; 0 || (retValPct &gt; lengthPct - 1)) ||
466                     (retValX &lt; 0 || (retValX &gt; lengthX - 1))) {
467                 cleanUp(dupFileName, scaledImageXName, scaledImagePctName, scaleFactor);
468                 return JNI_FALSE;
469             }
470         }
471         free(dupFileName);
472         if (!(fp = fopen(scaledImagePctName, &quot;r&quot;))) {
473             if (!isPctScaledImage &amp;&amp; (fp = fopen(scaledImageXName, &quot;r&quot;))) {
474                 fclose(fp);
475                 strcpy(scaleImageName, scaledImageXName);
476                 free(scaledImageXName);
477                 free(scaledImagePctName);
478                 return JNI_TRUE;
479             }
480             cleanUp(NULL, scaledImageXName, scaledImagePctName, scaleFactor);
481             return JNI_FALSE;
482         }
483         fclose(fp);
484         strcpy(scaleImageName, scaledImagePctName);
485         free(scaledImageXName);
486         free(scaledImagePctName);
487         return JNI_TRUE;
488     }
489     return JNI_FALSE;
490 }
491 
492 void cleanUp(char *fName, char *xName, char *pctName, float *scaleFactor) {
493     *scaleFactor = 1;
494     free(fName);
495     free(xName);
496     free(pctName);
497 }
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
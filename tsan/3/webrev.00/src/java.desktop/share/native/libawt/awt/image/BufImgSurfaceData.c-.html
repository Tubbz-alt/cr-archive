<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libawt/awt/image/BufImgSurfaceData.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;BufImgSurfaceData.h&quot;
 27 #include &lt;stdlib.h&gt;
 28 
 29 #include &quot;sun_awt_image_BufImgSurfaceData.h&quot;
 30 
 31 #include &quot;img_util_md.h&quot;
 32 #include &quot;jni_util.h&quot;
 33 /* Define uintptr_t */
 34 #include &quot;gdefs.h&quot;
 35 #include &quot;Disposer.h&quot;
 36 
 37 /**
 38  * This include file contains support code for loops using the
 39  * SurfaceData interface to talk to an X11 drawable from native
 40  * code.
 41  */
 42 
 43 static LockFunc                 BufImg_Lock;
 44 static GetRasInfoFunc           BufImg_GetRasInfo;
 45 static ReleaseFunc              BufImg_Release;
 46 static DisposeFunc              BufImg_Dispose;
 47 
 48 static ColorData *BufImg_SetupICM(JNIEnv *env, BufImgSDOps *bisdo);
 49 
 50 static jfieldID         rgbID;
 51 static jfieldID         mapSizeID;
 52 static jfieldID         colorDataID;
 53 static jfieldID         pDataID;
 54 static jfieldID         allGrayID;
 55 
 56 static jclass           clsICMCD;
 57 static jmethodID        initICMCDmID;
 58 /*
 59  * Class:     sun_awt_image_BufImgSurfaceData
 60  * Method:    initIDs
 61  * Signature: ()V
 62  */
 63 JNIEXPORT void JNICALL
 64 Java_sun_awt_image_BufImgSurfaceData_initIDs
 65 (JNIEnv *env, jclass bisd, jclass icm, jclass cd)
 66 {
 67     if (sizeof(BufImgRIPrivate) &gt; SD_RASINFO_PRIVATE_SIZE) {
 68         JNU_ThrowInternalError(env, &quot;Private RasInfo structure too large!&quot;);
 69         return;
 70     }
 71 
 72     clsICMCD = (*env)-&gt;NewWeakGlobalRef(env, cd);
 73     JNU_CHECK_EXCEPTION(env);
 74     CHECK_NULL(initICMCDmID = (*env)-&gt;GetMethodID(env, cd, &quot;&lt;init&gt;&quot;, &quot;(J)V&quot;));
 75     CHECK_NULL(pDataID = (*env)-&gt;GetFieldID(env, cd, &quot;pData&quot;, &quot;J&quot;));
 76     CHECK_NULL(rgbID = (*env)-&gt;GetFieldID(env, icm, &quot;rgb&quot;, &quot;[I&quot;));
 77     CHECK_NULL(allGrayID = (*env)-&gt;GetFieldID(env, icm, &quot;allgrayopaque&quot;, &quot;Z&quot;));
 78     CHECK_NULL(mapSizeID = (*env)-&gt;GetFieldID(env, icm, &quot;map_size&quot;, &quot;I&quot;));
 79     CHECK_NULL(colorDataID = (*env)-&gt;GetFieldID(env, icm, &quot;colorData&quot;,
 80                                            &quot;Lsun/awt/image/BufImgSurfaceData$ICMColorData;&quot;));
 81 }
 82 
 83 /*
 84  * Class:     sun_awt_image_BufImgSurfaceData
 85  * Method:    initOps
 86  * Signature: (Ljava/lang/Object;IIIII)V
 87  */
 88 JNIEXPORT void JNICALL
 89 Java_sun_awt_image_BufImgSurfaceData_initRaster(JNIEnv *env, jobject bisd,
 90                                                 jobject array,
 91                                                 jint offset, jint bitoffset,
 92                                                 jint width, jint height,
 93                                                 jint pixStr, jint scanStr,
 94                                                 jobject icm)
 95 {
 96     BufImgSDOps *bisdo =
 97         (BufImgSDOps*)SurfaceData_InitOps(env, bisd, sizeof(BufImgSDOps));
 98     if (bisdo == NULL) {
 99         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);
100         return;
101     }
102     bisdo-&gt;sdOps.Lock = BufImg_Lock;
103     bisdo-&gt;sdOps.GetRasInfo = BufImg_GetRasInfo;
104     bisdo-&gt;sdOps.Release = BufImg_Release;
105     bisdo-&gt;sdOps.Unlock = NULL;
106     bisdo-&gt;sdOps.Dispose = BufImg_Dispose;
107     bisdo-&gt;array = (*env)-&gt;NewWeakGlobalRef(env, array);
108     JNU_CHECK_EXCEPTION(env);
109     bisdo-&gt;offset = offset;
110     bisdo-&gt;bitoffset = bitoffset;
111     bisdo-&gt;scanStr = scanStr;
112     bisdo-&gt;pixStr = pixStr;
113     if (JNU_IsNull(env, icm)) {
114         bisdo-&gt;lutarray = NULL;
115         bisdo-&gt;lutsize = 0;
116         bisdo-&gt;icm = NULL;
117     } else {
118         jobject lutarray = (*env)-&gt;GetObjectField(env, icm, rgbID);
119         bisdo-&gt;lutarray = (*env)-&gt;NewWeakGlobalRef(env, lutarray);
120         JNU_CHECK_EXCEPTION(env);
121         bisdo-&gt;lutsize = (*env)-&gt;GetIntField(env, icm, mapSizeID);
122         bisdo-&gt;icm = (*env)-&gt;NewWeakGlobalRef(env, icm);
123     }
124     bisdo-&gt;rasbounds.x1 = 0;
125     bisdo-&gt;rasbounds.y1 = 0;
126     bisdo-&gt;rasbounds.x2 = width;
127     bisdo-&gt;rasbounds.y2 = height;
128 }
129 
130 /*
131  * Releases native structures associated with BufImgSurfaceData.ICMColorData.
132  */
133 static void BufImg_Dispose_ICMColorData(JNIEnv *env, jlong pData)
134 {
135     ColorData *cdata = (ColorData*)jlong_to_ptr(pData);
136     freeICMColorData(cdata);
137 }
138 
139 /*
140  * Method for disposing native BufImgSD
141  */
142 static void BufImg_Dispose(JNIEnv *env, SurfaceDataOps *ops)
143 {
144     /* ops is assumed non-null as it is checked in SurfaceData_DisposeOps */
145     BufImgSDOps *bisdo = (BufImgSDOps *)ops;
146     (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;array);
147     if (bisdo-&gt;lutarray != NULL) {
148         (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;lutarray);
149     }
150     if (bisdo-&gt;icm != NULL) {
151         (*env)-&gt;DeleteWeakGlobalRef(env, bisdo-&gt;icm);
152     }
153 }
154 
155 static jint BufImg_Lock(JNIEnv *env,
156                         SurfaceDataOps *ops,
157                         SurfaceDataRasInfo *pRasInfo,
158                         jint lockflags)
159 {
160     BufImgSDOps *bisdo = (BufImgSDOps *)ops;
161     BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
162 
163     if ((lockflags &amp; (SD_LOCK_LUT)) != 0 &amp;&amp; JNU_IsNull(env, bisdo-&gt;lutarray)) {
164         /* REMIND: Should this be an InvalidPipe exception? */
165         JNU_ThrowNullPointerException(env, &quot;Attempt to lock missing colormap&quot;);
166         return SD_FAILURE;
167     }
168     if ((lockflags &amp; SD_LOCK_INVCOLOR) != 0 ||
169         (lockflags &amp; SD_LOCK_INVGRAY) != 0)
170     {
171         bipriv-&gt;cData = BufImg_SetupICM(env, bisdo);
172         if (bipriv-&gt;cData == NULL) {
173             (*env)-&gt;ExceptionClear(env);
174             JNU_ThrowNullPointerException(env, &quot;Could not initialize inverse tables&quot;);
175             return SD_FAILURE;
176         }
177     } else {
178         bipriv-&gt;cData = NULL;
179     }
180 
181     bipriv-&gt;lockFlags = lockflags;
182     bipriv-&gt;base = NULL;
183     bipriv-&gt;lutbase = NULL;
184 
185     SurfaceData_IntersectBounds(&amp;pRasInfo-&gt;bounds, &amp;bisdo-&gt;rasbounds);
186 
187     return SD_SUCCESS;
188 }
189 
190 static void BufImg_GetRasInfo(JNIEnv *env,
191                               SurfaceDataOps *ops,
192                               SurfaceDataRasInfo *pRasInfo)
193 {
194     BufImgSDOps *bisdo = (BufImgSDOps *)ops;
195     BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
196 
197     if ((bipriv-&gt;lockFlags &amp; (SD_LOCK_RD_WR)) != 0) {
198         bipriv-&gt;base =
199             (*env)-&gt;GetPrimitiveArrayCritical(env, bisdo-&gt;array, NULL);
200         CHECK_NULL(bipriv-&gt;base);
201     }
202     if ((bipriv-&gt;lockFlags &amp; (SD_LOCK_LUT)) != 0) {
203         bipriv-&gt;lutbase =
204             (*env)-&gt;GetPrimitiveArrayCritical(env, bisdo-&gt;lutarray, NULL);
205     }
206 
207     if (bipriv-&gt;base == NULL) {
208         pRasInfo-&gt;rasBase = NULL;
209         pRasInfo-&gt;pixelStride = 0;
210         pRasInfo-&gt;pixelBitOffset = 0;
211         pRasInfo-&gt;scanStride = 0;
212     } else {
213         pRasInfo-&gt;rasBase = (void *)
214             (((uintptr_t) bipriv-&gt;base) + bisdo-&gt;offset);
215         pRasInfo-&gt;pixelStride = bisdo-&gt;pixStr;
216         pRasInfo-&gt;pixelBitOffset = bisdo-&gt;bitoffset;
217         pRasInfo-&gt;scanStride = bisdo-&gt;scanStr;
218     }
219     if (bipriv-&gt;lutbase == NULL) {
220         pRasInfo-&gt;lutBase = NULL;
221         pRasInfo-&gt;lutSize = 0;
222     } else {
223         pRasInfo-&gt;lutBase = bipriv-&gt;lutbase;
224         pRasInfo-&gt;lutSize = bisdo-&gt;lutsize;
225     }
226     if (bipriv-&gt;cData == NULL) {
227         pRasInfo-&gt;invColorTable = NULL;
228         pRasInfo-&gt;redErrTable = NULL;
229         pRasInfo-&gt;grnErrTable = NULL;
230         pRasInfo-&gt;bluErrTable = NULL;
231         pRasInfo-&gt;representsPrimaries = 0;
232     } else {
233         pRasInfo-&gt;invColorTable = bipriv-&gt;cData-&gt;img_clr_tbl;
234         pRasInfo-&gt;redErrTable = bipriv-&gt;cData-&gt;img_oda_red;
235         pRasInfo-&gt;grnErrTable = bipriv-&gt;cData-&gt;img_oda_green;
236         pRasInfo-&gt;bluErrTable = bipriv-&gt;cData-&gt;img_oda_blue;
237         pRasInfo-&gt;invGrayTable = bipriv-&gt;cData-&gt;pGrayInverseLutData;
238         pRasInfo-&gt;representsPrimaries = bipriv-&gt;cData-&gt;representsPrimaries;
239     }
240 }
241 
242 static void BufImg_Release(JNIEnv *env,
243                            SurfaceDataOps *ops,
244                            SurfaceDataRasInfo *pRasInfo)
245 {
246     BufImgSDOps *bisdo = (BufImgSDOps *)ops;
247     BufImgRIPrivate *bipriv = (BufImgRIPrivate *) &amp;(pRasInfo-&gt;priv);
248 
249     if (bipriv-&gt;base != NULL) {
250         jint mode = (((bipriv-&gt;lockFlags &amp; (SD_LOCK_WRITE)) != 0)
251                      ? 0 : JNI_ABORT);
252         (*env)-&gt;ReleasePrimitiveArrayCritical(env, bisdo-&gt;array,
253                                               bipriv-&gt;base, mode);
254     }
255     if (bipriv-&gt;lutbase != NULL) {
256         (*env)-&gt;ReleasePrimitiveArrayCritical(env, bisdo-&gt;lutarray,
257                                               bipriv-&gt;lutbase, JNI_ABORT);
258     }
259 }
260 
261 static int calculatePrimaryColorsApproximation(int* cmap, unsigned char* cube, int cube_size) {
262     int i, j, k;
263     int index, value, color;
264     // values calculated from cmap
265     int r, g, b;
266     // maximum positive/negative variation allowed for r, g, b values for primary colors
267     int delta = 5;
268     // get the primary color cmap indices from corner of inverse color table
269     for (i = 0; i &lt; cube_size; i += (cube_size - 1)) {
270         for (j = 0; j &lt; cube_size; j += (cube_size - 1)) {
271             for (k = 0; k &lt; cube_size; k += (cube_size - 1)) {
272                 // calculate inverse color table index
273                 index = i + cube_size * (j + cube_size * k);
274                 // get value present in corners of inverse color table
275                 value = cube[index];
276                 // use the corner values as index for cmap
277                 color = cmap[value];
278                 // extract r,g,b values from cmap value
279                 r = ((color) &gt;&gt; 16) &amp; 0xff;
280                 g = ((color) &gt;&gt; 8) &amp; 0xff;
281                 b = color &amp; 0xff;
282                 /*
283                  * If i/j/k value is 0 optimum value of b/g/r should be 0 but we allow
284                  * maximum positive variation of 5. If i/j/k value is 31 optimum value
285                  * of b/g/r should be 255 but we allow maximum negative variation of 5.
286                  */
287                 if (i == 0) {
288                     if (b &gt; delta)
289                         return 0;
290                 } else {
291                     if (b &lt; (255 - delta))
292                         return 0;
293                 }
294                 if (j == 0) {
295                     if (g &gt; delta)
296                         return 0;
297                 } else {
298                     if (g &lt; (255 - delta))
299                         return 0;
300                 }
301                 if (k == 0) {
302                     if (r &gt; delta)
303                         return 0;
304                 } else {
305                     if (r &lt; (255 - delta))
306                         return 0;
307                 }
308             }
309         }
310     }
311     return 1;
312 }
313 
314 static ColorData *BufImg_SetupICM(JNIEnv *env,
315                                   BufImgSDOps *bisdo)
316 {
317     ColorData *cData = NULL;
318     jobject colorData;
319 
320     if (JNU_IsNull(env, bisdo-&gt;icm)) {
321         return (ColorData *) NULL;
322     }
323 
324     colorData = (*env)-&gt;GetObjectField(env, bisdo-&gt;icm, colorDataID);
325 
326     if (JNU_IsNull(env, colorData)) {
327         if (JNU_IsNull(env, clsICMCD)) {
328             // we are unable to create a wrapper object
329             return (ColorData*)NULL;
330         }
331     } else {
332         cData = (ColorData*)JNU_GetLongFieldAsPtr(env, colorData, pDataID);
333     }
334 
335     if (cData != NULL) {
336         return cData;
337     }
338 
339     cData = (ColorData*)calloc(1, sizeof(ColorData));
340 
341     if (cData != NULL) {
342         jboolean allGray
343             = (*env)-&gt;GetBooleanField(env, bisdo-&gt;icm, allGrayID);
344         int *pRgb = (int *)
345             ((*env)-&gt;GetPrimitiveArrayCritical(env, bisdo-&gt;lutarray, NULL));
346 
347         if (pRgb == NULL) {
348             free(cData);
349             return (ColorData*)NULL;
350         }
351 
352         cData-&gt;img_clr_tbl = initCubemap(pRgb, bisdo-&gt;lutsize, 32);
353         if (cData-&gt;img_clr_tbl == NULL) {
354             free(cData);
355             return (ColorData*)NULL;
356         }
357         cData-&gt;representsPrimaries = calculatePrimaryColorsApproximation(pRgb, cData-&gt;img_clr_tbl, 32);
358         if (allGray == JNI_TRUE) {
359             initInverseGrayLut(pRgb, bisdo-&gt;lutsize, cData);
360         }
361         (*env)-&gt;ReleasePrimitiveArrayCritical(env, bisdo-&gt;lutarray, pRgb,
362                                               JNI_ABORT);
363 
364         initDitherTables(cData);
365 
366         if (JNU_IsNull(env, colorData)) {
367             jlong pData = ptr_to_jlong(cData);
368             colorData = (*env)-&gt;NewObjectA(env, clsICMCD, initICMCDmID, (jvalue *)&amp;pData);
369 
370             if ((*env)-&gt;ExceptionCheck(env))
371             {
372                 free(cData);
373                 return (ColorData*)NULL;
374             }
375 
376             (*env)-&gt;SetObjectField(env, bisdo-&gt;icm, colorDataID, colorData);
377             Disposer_AddRecord(env, colorData, BufImg_Dispose_ICMColorData, pData);
378         }
379     }
380 
381     return cData;
382 }
    </pre>
  </body>
</html>
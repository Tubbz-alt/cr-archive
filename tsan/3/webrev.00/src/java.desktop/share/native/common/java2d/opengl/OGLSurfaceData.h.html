<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/common/java2d/opengl/OGLSurfaceData.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef OGLSurfaceData_h_Included
 27 #define OGLSurfaceData_h_Included
 28 
 29 #include &quot;java_awt_image_AffineTransformOp.h&quot;
 30 #include &quot;sun_java2d_opengl_OGLSurfaceData.h&quot;
 31 #include &quot;sun_java2d_pipe_hw_AccelSurface.h&quot;
 32 
 33 #include &quot;J2D_GL/gl.h&quot;
 34 #include &quot;SurfaceData.h&quot;
 35 #include &quot;Trace.h&quot;
 36 #include &quot;OGLFuncs.h&quot;
 37 
 38 typedef struct _OGLSDOps OGLSDOps;
 39 
 40 /**
 41  * The OGLPixelFormat structure contains all the information OpenGL needs to
 42  * know when copying from or into a particular system memory image buffer (via
 43  * glDrawPixels(), glReadPixels, glTexSubImage2D(), etc).
 44  *
 45  *     GLenum format;
 46  * The pixel format parameter used in glDrawPixels() and other similar calls.
 47  * Indicates the component ordering for each pixel (e.g. GL_BGRA).
 48  *
 49  *     GLenum type;
 50  * The pixel data type parameter used in glDrawPixels() and other similar
 51  * calls.  Indicates the data type for an entire pixel or for each component
 52  * in a pixel (e.g. GL_UNSIGNED_BYTE with GL_BGR means a pixel consists of
 53  * 3 unsigned byte components, blue first, then green, then red;
 54  * GL_UNSIGNED_INT_8_8_8_8_REV with GL_BGRA means a pixel consists of 1
 55  * unsigned integer comprised of four byte components, alpha first, then red,
 56  * then green, then blue).
 57  *
 58  *     jint alignment;
 59  * The byte alignment parameter used in glPixelStorei(GL_UNPACK_ALIGNMENT).  A
 60  * value of 4 indicates that each pixel starts on a 4-byte aligned region in
 61  * memory, and so on.  This alignment parameter helps OpenGL speed up pixel
 62  * transfer operations by transferring memory in aligned blocks.
 63  *
 64  *     jboolean hasAlpha;
 65  * If true, indicates that this pixel format contains an alpha component.
 66  *
 67  *     jboolean isPremult;
 68  * If true, indicates that this pixel format contains color components that
 69  * have been pre-multiplied by their corresponding alpha component.
 70  */
 71 typedef struct {
 72     GLenum   format;
 73     GLenum   type;
 74     jint     alignment;
 75     jboolean hasAlpha;
 76     jboolean isPremult;
 77 } OGLPixelFormat;
 78 
 79 /**
 80  * The OGLSDOps structure describes a native OpenGL surface and contains all
 81  * information pertaining to the native surface.  Some information about
 82  * the more important/different fields:
 83  *
 84  *     void *privOps;
 85  * Pointer to native-specific (GLX, WGL, etc.) SurfaceData info, such as the
 86  * native Drawable handle and GraphicsConfig data.
 87  *
 88  *     jobject graphicsConfig;;
 89  * Strong reference to the OGLGraphicsConfig used by this OGLSurfaceData.
 90  *
 91  *     jint drawableType;
 92  * The surface type; can be any one of the surface type constants defined
 93  * below (OGLSD_WINDOW, OGLSD_TEXTURE, etc).
 94  *
 95  *     GLenum activeBuffer;
 96  * Can be either GL_FRONT if this is the front buffer surface of an onscreen
 97  * window or a pbuffer surface, or GL_BACK if this is the backbuffer surface
 98  * of an onscreen window.
 99  *
100  *     jboolean isOpaque;
101  * If true, the surface should be treated as being fully opaque.  If
102  * the underlying surface (e.g. pbuffer) has an alpha channel and isOpaque
103  * is true, then we should take appropriate action (i.e. call glColorMask()
104  * to disable writes into the alpha channel) to ensure that the surface
105  * remains fully opaque.
106  *
107  *     jboolean needsInit;
108  * If true, the surface requires some one-time initialization, which should
109  * be performed after a context has been made current to the surface for
110  * the first time.
111  *
112  *     jint x/yOffset
113  * The offset in pixels of the OpenGL viewport origin from the lower-left
114  * corner of the heavyweight drawable.  For example, a top-level frame on
115  * Windows XP has lower-left insets of (4,4).  The OpenGL viewport origin
116  * would typically begin at the lower-left corner of the client region (inside
117  * the frame decorations), but AWT/Swing will take the insets into account
118  * when rendering into that window.  So in order to account for this, we
119  * need to adjust the OpenGL viewport origin by an x/yOffset of (-4,-4).  On
120  * X11, top-level frames typically don&#39;t have this insets issue, so their
121  * x/yOffset would be (0,0) (the same applies to pbuffers).
122  *
123  *     jint width/height;
124  * The cached surface bounds.  For offscreen surface types (OGLSD_FBOBJECT,
125  * OGLSD_TEXTURE, etc.) these values must remain constant.  Onscreen window
126  * surfaces (OGLSD_WINDOW, OGLSD_FLIP_BACKBUFFER, etc.) may have their
127  * bounds changed in response to a programmatic or user-initiated event, so
128  * these values represent the last known dimensions.  To determine the true
129  * current bounds of this surface, query the native Drawable through the
130  * privOps field.
131  *
132  *     GLuint textureID;
133  * The texture object handle, as generated by glGenTextures().  If this value
134  * is zero, the texture has not yet been initialized.
135  *
136  *     jint textureWidth/Height;
137  * The actual bounds of the texture object for this surface.  If the
138  * GL_ARB_texture_non_power_of_two extension is not present, the dimensions
139  * of an OpenGL texture object must be a power-of-two (e.g. 64x32 or 128x512).
140  * The texture image that we care about has dimensions specified by the width
141  * and height fields in this OGLSDOps structure.  For example, if the image
142  * to be stored in the texture has dimensions 115x47, the actual OpenGL
143  * texture we allocate will have dimensions 128x64 to meet the pow2
144  * restriction.  The image bounds within the texture can be accessed using
145  * floating point texture coordinates in the range [0.0,1.0].
146  *
147  *     GLenum textureTarget;
148  * The texture target of the texture object for this surface.  If this
149  * surface is not backed by a texture, this value is set to zero.  Otherwise,
150  * this value is GL_TEXTURE_RECTANGLE_ARB when the GL_ARB_texture_rectangle
151  * extension is in use; if not, it is set to GL_TEXTURE_2D.
152  *
153  *     GLint textureFilter;
154  * The current filter state for this texture object (can be either GL_NEAREST
155  * or GL_LINEAR).  We cache this value here and check it before updating
156  * the filter state to avoid redundant calls to glTexParameteri() when the
157  * filter state remains constant (see the OGLSD_UPDATE_TEXTURE_FILTER()
158  * macro below).
159  *
160  *     GLuint fbobjectID, depthID;
161  * The object handles for the framebuffer object and depth renderbuffer
162  * associated with this surface.  These fields are only used when
163  * drawableType is OGLSD_FBOBJECT, otherwise they are zero.
164  */
165 struct _OGLSDOps {
166     SurfaceDataOps               sdOps;
167     void                         *privOps;
168     jobject                      graphicsConfig;
169     jint                         drawableType;
170     GLenum                       activeBuffer;
171     jboolean                     isOpaque;
172     jboolean                     needsInit;
173     jint                         xOffset;
174     jint                         yOffset;
175     jint                         width;
176     jint                         height;
177     GLuint                       textureID;
178     jint                         textureWidth;
179     jint                         textureHeight;
180     GLenum                       textureTarget;
181     GLint                        textureFilter;
182     GLuint                       fbobjectID;
183     GLuint                       depthID;
184 };
185 
186 /**
187  * The following convenience macros are used when rendering rectangles (either
188  * a single rectangle, or a whole series of them).  To render a single
189  * rectangle, simply invoke the GLRECT() macro.  To render a whole series of
190  * rectangles, such as spans in a complex shape, first invoke GLRECT_BEGIN(),
191  * then invoke the appropriate inner loop macro (either XYXY or XYWH) for
192  * each rectangle, and finally invoke GLRECT_END() to notify OpenGL that the
193  * vertex list is complete.  Care should be taken to avoid calling OpenGL
194  * commands (besides GLRECT_BODY_*()) inside the BEGIN/END pair.
195  */
196 
197 #define GLRECT_BEGIN j2d_glBegin(GL_QUADS)
198 
199 #define GLRECT_BODY_XYXY(x1, y1, x2, y2) \
200     do { \
201         j2d_glVertex2i(x1, y1); \
202         j2d_glVertex2i(x2, y1); \
203         j2d_glVertex2i(x2, y2); \
204         j2d_glVertex2i(x1, y2); \
205     } while (0)
206 
207 #define GLRECT_BODY_XYWH(x, y, w, h) \
208     GLRECT_BODY_XYXY(x, y, (x) + (w), (y) + (h))
209 
210 #define GLRECT_END j2d_glEnd()
211 
212 #define GLRECT(x, y, w, h) \
213     do { \
214         GLRECT_BEGIN; \
215         GLRECT_BODY_XYWH(x, y, w, h); \
216         GLRECT_END; \
217     } while (0)
218 
219 /**
220  * These are shorthand names for the surface type constants defined in
221  * OGLSurfaceData.java.
222  */
223 #define OGLSD_UNDEFINED       sun_java2d_pipe_hw_AccelSurface_UNDEFINED
224 #define OGLSD_WINDOW          sun_java2d_pipe_hw_AccelSurface_WINDOW
225 #define OGLSD_TEXTURE         sun_java2d_pipe_hw_AccelSurface_TEXTURE
226 #define OGLSD_FLIP_BACKBUFFER sun_java2d_pipe_hw_AccelSurface_FLIP_BACKBUFFER
227 #define OGLSD_FBOBJECT        sun_java2d_pipe_hw_AccelSurface_RT_TEXTURE
228 
229 /**
230  * These are shorthand names for the filtering method constants used by
231  * image transform methods.
232  */
233 #define OGLSD_XFORM_DEFAULT 0
234 #define OGLSD_XFORM_NEAREST_NEIGHBOR \
235     java_awt_image_AffineTransformOp_TYPE_NEAREST_NEIGHBOR
236 #define OGLSD_XFORM_BILINEAR \
237     java_awt_image_AffineTransformOp_TYPE_BILINEAR
238 
239 /**
240  * Helper macros that update the current texture filter state only when
241  * it needs to be changed, which helps reduce overhead for small texturing
242  * operations.  The filter state is set on a per-texture (not per-context)
243  * basis; for example, it is possible for one texture to be using GL_NEAREST
244  * while another texture uses GL_LINEAR under the same context.
245  */
246 #define OGLSD_INIT_TEXTURE_FILTER(oglSDOps, filter)                          \
247     do {                                                                     \
248         j2d_glTexParameteri((oglSDOps)-&gt;textureTarget,                       \
249                             GL_TEXTURE_MAG_FILTER, (filter));                \
250         j2d_glTexParameteri((oglSDOps)-&gt;textureTarget,                       \
251                             GL_TEXTURE_MIN_FILTER, (filter));                \
252         (oglSDOps)-&gt;textureFilter = (filter);                                \
253     } while (0)
254 
255 #define OGLSD_UPDATE_TEXTURE_FILTER(oglSDOps, filter)    \
256     do {                                                 \
257         if ((oglSDOps)-&gt;textureFilter != (filter)) {     \
258             OGLSD_INIT_TEXTURE_FILTER(oglSDOps, filter); \
259         }                                                \
260     } while (0)
261 
262 /**
263  * Convenience macros for setting the texture wrap mode for a given target.
264  * The texture wrap mode should be reset to our default value of
265  * GL_CLAMP_TO_EDGE by calling OGLSD_RESET_TEXTURE_WRAP() when a texture
266  * is first created.  If another mode is needed (e.g. GL_REPEAT in the case
267  * of TexturePaint acceleration), one can call the OGLSD_UPDATE_TEXTURE_WRAP()
268  * macro to easily set up the new wrap mode.  However, it is important to
269  * restore the wrap mode back to its default value (by calling the
270  * OGLSD_RESET_TEXTURE_WRAP() macro) when the operation is finished.
271  */
272 #define OGLSD_UPDATE_TEXTURE_WRAP(target, wrap)                   \
273     do {                                                          \
274         j2d_glTexParameteri((target), GL_TEXTURE_WRAP_S, (wrap)); \
275         j2d_glTexParameteri((target), GL_TEXTURE_WRAP_T, (wrap)); \
276     } while (0)
277 
278 #define OGLSD_RESET_TEXTURE_WRAP(target) \
279     OGLSD_UPDATE_TEXTURE_WRAP(target, GL_CLAMP_TO_EDGE)
280 
281 /**
282  * Exported methods.
283  */
284 jint OGLSD_Lock(JNIEnv *env,
285                 SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo,
286                 jint lockflags);
287 void OGLSD_GetRasInfo(JNIEnv *env,
288                       SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo);
289 void OGLSD_Unlock(JNIEnv *env,
290                   SurfaceDataOps *ops, SurfaceDataRasInfo *pRasInfo);
291 void OGLSD_Dispose(JNIEnv *env, SurfaceDataOps *ops);
292 void OGLSD_Delete(JNIEnv *env, OGLSDOps *oglsdo);
293 jint OGLSD_NextPowerOfTwo(jint val, jint max);
294 jboolean OGLSD_InitFBObject(GLuint *fbobjectID, GLuint *depthID,
295                             GLuint textureID, GLenum textureTarget,
296                             jint textureWidth, jint textureHeight);
297 
298 #endif /* OGLSurfaceData_h_Included */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/common/font/fontscalerdefs.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../awt/debug/debug_trace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/opengl/J2D_GL/gl.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/common/font/fontscalerdefs.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 71 typedef struct GlyphInfo {
 72     float        advanceX;
 73     float        advanceY;
 74     UInt16       width;
 75     UInt16       height;
 76     UInt16       rowBytes;
 77     UInt8         managed;
 78     float        topLeftX;
 79     float        topLeftY;
 80     void         *cellInfo;
 81     UInt8        *image;
 82 } GlyphInfo;
 83 
 84   /* We use fffe and ffff as meaning invisible glyphs which have no
 85    * image, or advance and an empty outline.
 86    * Since there are no valid glyphs with this great a value (watch out for
 87    * large fonts in the future!) we can safely use check for &gt;= this value
 88    */
 89 #define INVISIBLE_GLYPHS 0xfffe
 90 
<span class="line-removed"> 91 #define GSUB_TAG 0x47535542 /* &#39;GSUB&#39; */</span>
<span class="line-removed"> 92 #define GPOS_TAG 0x47504F53 /* &#39;GPOS&#39; */</span>
<span class="line-removed"> 93 #define GDEF_TAG 0x47444546 /* &#39;GDEF&#39; */</span>
<span class="line-removed"> 94 #define HEAD_TAG 0x68656164 /* &#39;head&#39; */</span>
<span class="line-removed"> 95 #define MORT_TAG 0x6D6F7274 /* &#39;mort&#39; */</span>
<span class="line-removed"> 96 #define MORX_TAG 0x6D6F7278 /* &#39;morx&#39; */</span>
<span class="line-removed"> 97 #define KERN_TAG 0x6B65726E /* &#39;kern&#39; */</span>
<span class="line-removed"> 98 </span>
<span class="line-removed"> 99 typedef struct TTLayoutTableCacheEntry {</span>
<span class="line-removed">100   const void* ptr;</span>
<span class="line-removed">101   int   len;</span>
<span class="line-removed">102   int   tag;</span>
<span class="line-removed">103 } TTLayoutTableCacheEntry;</span>
<span class="line-removed">104 </span>
<span class="line-removed">105 #define LAYOUTCACHE_ENTRIES 7</span>
<span class="line-removed">106 </span>
<span class="line-removed">107 typedef struct TTLayoutTableCache {</span>
<span class="line-removed">108   TTLayoutTableCacheEntry entries[LAYOUTCACHE_ENTRIES];</span>
<span class="line-removed">109   void* kernPairs;</span>
<span class="line-removed">110 } TTLayoutTableCache;</span>
<span class="line-removed">111 </span>
112 #include &quot;sunfontids.h&quot;
113 
<span class="line-removed">114 JNIEXPORT extern TTLayoutTableCache* newLayoutTableCache();</span>
<span class="line-removed">115 JNIEXPORT extern void freeLayoutTableCache(TTLayoutTableCache* ltc);</span>
<span class="line-removed">116 </span>
117 /* If font is malformed then scaler context created by particular scaler
118  * will be replaced by null scaler context.
119  * Note that this context is not compatible with structure of the context
120  * object used by particular scaler. Therefore, before using context
121  * scaler has to check if it is NullContext.
122  *
123  * Note that in theory request with NullContext should not even reach native
124  * scaler.
125  *
126  * It seems that the only reason to support NullContext is to simplify
127  * FileFontStrike logic - presence of context is used as marker to
128  * free the memory.
129 */
130 JNIEXPORT int isNullScalerContext(void *context);
131 
132 #ifdef  __cplusplus
133 }
134 #endif
135 
136 #endif
</pre>
</td>
<td>
<hr />
<pre>
 71 typedef struct GlyphInfo {
 72     float        advanceX;
 73     float        advanceY;
 74     UInt16       width;
 75     UInt16       height;
 76     UInt16       rowBytes;
 77     UInt8         managed;
 78     float        topLeftX;
 79     float        topLeftY;
 80     void         *cellInfo;
 81     UInt8        *image;
 82 } GlyphInfo;
 83 
 84   /* We use fffe and ffff as meaning invisible glyphs which have no
 85    * image, or advance and an empty outline.
 86    * Since there are no valid glyphs with this great a value (watch out for
 87    * large fonts in the future!) we can safely use check for &gt;= this value
 88    */
 89 #define INVISIBLE_GLYPHS 0xfffe
 90 





















 91 #include &quot;sunfontids.h&quot;
 92 



 93 /* If font is malformed then scaler context created by particular scaler
 94  * will be replaced by null scaler context.
 95  * Note that this context is not compatible with structure of the context
 96  * object used by particular scaler. Therefore, before using context
 97  * scaler has to check if it is NullContext.
 98  *
 99  * Note that in theory request with NullContext should not even reach native
100  * scaler.
101  *
102  * It seems that the only reason to support NullContext is to simplify
103  * FileFontStrike logic - presence of context is used as marker to
104  * free the memory.
105 */
106 JNIEXPORT int isNullScalerContext(void *context);
107 
108 #ifdef  __cplusplus
109 }
110 #endif
111 
112 #endif
</pre>
</td>
</tr>
</table>
<center><a href="../awt/debug/debug_trace.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../java2d/opengl/J2D_GL/gl.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
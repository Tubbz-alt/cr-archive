<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/common/java2d/opengl/OGLSurfaceData.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="OGLSurfaceData.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../libawt/awt/image/BufImgSurfaceData.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/common/java2d/opengl/OGLSurfaceData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 68  * If true, indicates that this pixel format contains color components that
 69  * have been pre-multiplied by their corresponding alpha component.
 70  */
 71 typedef struct {
 72     GLenum   format;
 73     GLenum   type;
 74     jint     alignment;
 75     jboolean hasAlpha;
 76     jboolean isPremult;
 77 } OGLPixelFormat;
 78 
 79 /**
 80  * The OGLSDOps structure describes a native OpenGL surface and contains all
 81  * information pertaining to the native surface.  Some information about
 82  * the more important/different fields:
 83  *
 84  *     void *privOps;
 85  * Pointer to native-specific (GLX, WGL, etc.) SurfaceData info, such as the
 86  * native Drawable handle and GraphicsConfig data.
 87  *



 88  *     jint drawableType;
 89  * The surface type; can be any one of the surface type constants defined
 90  * below (OGLSD_WINDOW, OGLSD_TEXTURE, etc).
 91  *
 92  *     GLenum activeBuffer;
 93  * Can be either GL_FRONT if this is the front buffer surface of an onscreen
 94  * window or a pbuffer surface, or GL_BACK if this is the backbuffer surface
 95  * of an onscreen window.
 96  *
 97  *     jboolean isOpaque;
 98  * If true, the surface should be treated as being fully opaque.  If
 99  * the underlying surface (e.g. pbuffer) has an alpha channel and isOpaque
100  * is true, then we should take appropriate action (i.e. call glColorMask()
101  * to disable writes into the alpha channel) to ensure that the surface
102  * remains fully opaque.
103  *
104  *     jboolean needsInit;
105  * If true, the surface requires some one-time initialization, which should
106  * be performed after a context has been made current to the surface for
107  * the first time.
</pre>
<hr />
<pre>
145  * The texture target of the texture object for this surface.  If this
146  * surface is not backed by a texture, this value is set to zero.  Otherwise,
147  * this value is GL_TEXTURE_RECTANGLE_ARB when the GL_ARB_texture_rectangle
148  * extension is in use; if not, it is set to GL_TEXTURE_2D.
149  *
150  *     GLint textureFilter;
151  * The current filter state for this texture object (can be either GL_NEAREST
152  * or GL_LINEAR).  We cache this value here and check it before updating
153  * the filter state to avoid redundant calls to glTexParameteri() when the
154  * filter state remains constant (see the OGLSD_UPDATE_TEXTURE_FILTER()
155  * macro below).
156  *
157  *     GLuint fbobjectID, depthID;
158  * The object handles for the framebuffer object and depth renderbuffer
159  * associated with this surface.  These fields are only used when
160  * drawableType is OGLSD_FBOBJECT, otherwise they are zero.
161  */
162 struct _OGLSDOps {
163     SurfaceDataOps               sdOps;
164     void                         *privOps;

165     jint                         drawableType;
166     GLenum                       activeBuffer;
167     jboolean                     isOpaque;
168     jboolean                     needsInit;
169     jint                         xOffset;
170     jint                         yOffset;
171     jint                         width;
172     jint                         height;
173     GLuint                       textureID;
174     jint                         textureWidth;
175     jint                         textureHeight;
176     GLenum                       textureTarget;
177     GLint                        textureFilter;
178     GLuint                       fbobjectID;
179     GLuint                       depthID;
180 };
181 
182 /**
183  * The following convenience macros are used when rendering rectangles (either
184  * a single rectangle, or a whole series of them).  To render a single
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 68  * If true, indicates that this pixel format contains color components that
 69  * have been pre-multiplied by their corresponding alpha component.
 70  */
 71 typedef struct {
 72     GLenum   format;
 73     GLenum   type;
 74     jint     alignment;
 75     jboolean hasAlpha;
 76     jboolean isPremult;
 77 } OGLPixelFormat;
 78 
 79 /**
 80  * The OGLSDOps structure describes a native OpenGL surface and contains all
 81  * information pertaining to the native surface.  Some information about
 82  * the more important/different fields:
 83  *
 84  *     void *privOps;
 85  * Pointer to native-specific (GLX, WGL, etc.) SurfaceData info, such as the
 86  * native Drawable handle and GraphicsConfig data.
 87  *
<span class="line-added"> 88  *     jobject graphicsConfig;;</span>
<span class="line-added"> 89  * Strong reference to the OGLGraphicsConfig used by this OGLSurfaceData.</span>
<span class="line-added"> 90  *</span>
 91  *     jint drawableType;
 92  * The surface type; can be any one of the surface type constants defined
 93  * below (OGLSD_WINDOW, OGLSD_TEXTURE, etc).
 94  *
 95  *     GLenum activeBuffer;
 96  * Can be either GL_FRONT if this is the front buffer surface of an onscreen
 97  * window or a pbuffer surface, or GL_BACK if this is the backbuffer surface
 98  * of an onscreen window.
 99  *
100  *     jboolean isOpaque;
101  * If true, the surface should be treated as being fully opaque.  If
102  * the underlying surface (e.g. pbuffer) has an alpha channel and isOpaque
103  * is true, then we should take appropriate action (i.e. call glColorMask()
104  * to disable writes into the alpha channel) to ensure that the surface
105  * remains fully opaque.
106  *
107  *     jboolean needsInit;
108  * If true, the surface requires some one-time initialization, which should
109  * be performed after a context has been made current to the surface for
110  * the first time.
</pre>
<hr />
<pre>
148  * The texture target of the texture object for this surface.  If this
149  * surface is not backed by a texture, this value is set to zero.  Otherwise,
150  * this value is GL_TEXTURE_RECTANGLE_ARB when the GL_ARB_texture_rectangle
151  * extension is in use; if not, it is set to GL_TEXTURE_2D.
152  *
153  *     GLint textureFilter;
154  * The current filter state for this texture object (can be either GL_NEAREST
155  * or GL_LINEAR).  We cache this value here and check it before updating
156  * the filter state to avoid redundant calls to glTexParameteri() when the
157  * filter state remains constant (see the OGLSD_UPDATE_TEXTURE_FILTER()
158  * macro below).
159  *
160  *     GLuint fbobjectID, depthID;
161  * The object handles for the framebuffer object and depth renderbuffer
162  * associated with this surface.  These fields are only used when
163  * drawableType is OGLSD_FBOBJECT, otherwise they are zero.
164  */
165 struct _OGLSDOps {
166     SurfaceDataOps               sdOps;
167     void                         *privOps;
<span class="line-added">168     jobject                      graphicsConfig;</span>
169     jint                         drawableType;
170     GLenum                       activeBuffer;
171     jboolean                     isOpaque;
172     jboolean                     needsInit;
173     jint                         xOffset;
174     jint                         yOffset;
175     jint                         width;
176     jint                         height;
177     GLuint                       textureID;
178     jint                         textureWidth;
179     jint                         textureHeight;
180     GLenum                       textureTarget;
181     GLint                        textureFilter;
182     GLuint                       fbobjectID;
183     GLuint                       depthID;
184 };
185 
186 /**
187  * The following convenience macros are used when rendering rectangles (either
188  * a single rectangle, or a whole series of them).  To render a single
</pre>
</td>
</tr>
</table>
<center><a href="OGLSurfaceData.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../libawt/awt/image/BufImgSurfaceData.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
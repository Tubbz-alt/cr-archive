<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/common/java2d/opengl/OGLRenderQueue.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef HEADLESS
 27 
 28 #include &lt;stdlib.h&gt;
 29 
 30 #include &quot;sun_java2d_pipe_BufferedOpCodes.h&quot;
 31 
 32 #include &quot;jlong.h&quot;
 33 #include &quot;OGLBlitLoops.h&quot;
 34 #include &quot;OGLBufImgOps.h&quot;
 35 #include &quot;OGLContext.h&quot;
 36 #include &quot;OGLMaskBlit.h&quot;
 37 #include &quot;OGLMaskFill.h&quot;
 38 #include &quot;OGLPaints.h&quot;
 39 #include &quot;OGLRenderQueue.h&quot;
 40 #include &quot;OGLRenderer.h&quot;
 41 #include &quot;OGLSurfaceData.h&quot;
 42 #include &quot;OGLTextRenderer.h&quot;
 43 #include &quot;OGLVertexCache.h&quot;
 44 
 45 /**
 46  * Used to track whether we are in a series of a simple primitive operations
 47  * or texturing operations.  This variable should be controlled only via
 48  * the INIT/CHECK/RESET_PREVIOUS_OP() macros.  See the
 49  * OGLRenderQueue_CheckPreviousOp() method below for more information.
 50  */
 51 jint previousOp;
 52 
 53 /**
 54  * References to the &quot;current&quot; context and destination surface.
 55  */
 56 static OGLContext *oglc = NULL;
 57 static OGLSDOps *dstOps = NULL;
 58 
 59 /**
 60  * The following methods are implemented in the windowing system (i.e. GLX
 61  * and WGL) source files.
 62  */
 63 extern OGLContext *OGLSD_SetScratchSurface(JNIEnv *env, jlong pConfigInfo);
 64 extern void OGLGC_DestroyOGLGraphicsConfig(jlong pConfigInfo);
 65 extern void OGLSD_SwapBuffers(JNIEnv *env, jlong window);
 66 extern void OGLSD_Flush(JNIEnv *env);
 67 
 68 JNIEXPORT void JNICALL
 69 Java_sun_java2d_opengl_OGLRenderQueue_flushBuffer
 70     (JNIEnv *env, jobject oglrq,
 71      jlong buf, jint limit)
 72 {
 73     jboolean sync = JNI_FALSE;
 74     unsigned char *b, *end;
 75 
 76     J2dTraceLn1(J2D_TRACE_INFO,
 77                 &quot;OGLRenderQueue_flushBuffer: limit=%d&quot;, limit);
 78 
 79     b = (unsigned char *)jlong_to_ptr(buf);
 80     if (b == NULL) {
 81         J2dRlsTraceLn(J2D_TRACE_ERROR,
 82             &quot;OGLRenderQueue_flushBuffer: cannot get direct buffer address&quot;);
 83         return;
 84     }
 85 
 86     INIT_PREVIOUS_OP();
 87     end = b + limit;
 88 
 89     while (b &lt; end) {
 90         jint opcode = NEXT_INT(b);
 91 
 92         J2dTraceLn2(J2D_TRACE_VERBOSE,
 93                     &quot;OGLRenderQueue_flushBuffer: opcode=%d, rem=%d&quot;,
 94                     opcode, (end-b));
 95 
 96         switch (opcode) {
 97 
 98         // draw ops
 99         case sun_java2d_pipe_BufferedOpCodes_DRAW_LINE:
100             {
101                 jint x1 = NEXT_INT(b);
102                 jint y1 = NEXT_INT(b);
103                 jint x2 = NEXT_INT(b);
104                 jint y2 = NEXT_INT(b);
105                 OGLRenderer_DrawLine(oglc, x1, y1, x2, y2);
106             }
107             break;
108         case sun_java2d_pipe_BufferedOpCodes_DRAW_RECT:
109             {
110                 jint x = NEXT_INT(b);
111                 jint y = NEXT_INT(b);
112                 jint w = NEXT_INT(b);
113                 jint h = NEXT_INT(b);
114                 OGLRenderer_DrawRect(oglc, x, y, w, h);
115             }
116             break;
117         case sun_java2d_pipe_BufferedOpCodes_DRAW_POLY:
118             {
119                 jint nPoints      = NEXT_INT(b);
120                 jboolean isClosed = NEXT_BOOLEAN(b);
121                 jint transX       = NEXT_INT(b);
122                 jint transY       = NEXT_INT(b);
123                 jint *xPoints = (jint *)b;
124                 jint *yPoints = ((jint *)b) + nPoints;
125                 OGLRenderer_DrawPoly(oglc, nPoints, isClosed,
126                                      transX, transY,
127                                      xPoints, yPoints);
128                 SKIP_BYTES(b, nPoints * BYTES_PER_POLY_POINT);
129             }
130             break;
131         case sun_java2d_pipe_BufferedOpCodes_DRAW_PIXEL:
132             {
133                 jint x = NEXT_INT(b);
134                 jint y = NEXT_INT(b);
135                 // Note that we could use GL_POINTS here, but the common
136                 // use case for DRAW_PIXEL is when rendering a Path2D,
137                 // which will consist of a mix of DRAW_PIXEL and DRAW_LINE
138                 // calls.  So to improve batching we use GL_LINES here,
139                 // even though it requires an extra vertex per pixel.
140                 CONTINUE_IF_NULL(oglc);
141                 CHECK_PREVIOUS_OP(GL_LINES);
142                 j2d_glVertex2i(x, y);
143                 j2d_glVertex2i(x+1, y+1);
144             }
145             break;
146         case sun_java2d_pipe_BufferedOpCodes_DRAW_SCANLINES:
147             {
148                 jint count = NEXT_INT(b);
149                 OGLRenderer_DrawScanlines(oglc, count, (jint *)b);
150                 SKIP_BYTES(b, count * BYTES_PER_SCANLINE);
151             }
152             break;
153         case sun_java2d_pipe_BufferedOpCodes_DRAW_PARALLELOGRAM:
154             {
155                 jfloat x11 = NEXT_FLOAT(b);
156                 jfloat y11 = NEXT_FLOAT(b);
157                 jfloat dx21 = NEXT_FLOAT(b);
158                 jfloat dy21 = NEXT_FLOAT(b);
159                 jfloat dx12 = NEXT_FLOAT(b);
160                 jfloat dy12 = NEXT_FLOAT(b);
161                 jfloat lwr21 = NEXT_FLOAT(b);
162                 jfloat lwr12 = NEXT_FLOAT(b);
163                 OGLRenderer_DrawParallelogram(oglc,
164                                               x11, y11,
165                                               dx21, dy21,
166                                               dx12, dy12,
167                                               lwr21, lwr12);
168             }
169             break;
170         case sun_java2d_pipe_BufferedOpCodes_DRAW_AAPARALLELOGRAM:
171             {
172                 jfloat x11 = NEXT_FLOAT(b);
173                 jfloat y11 = NEXT_FLOAT(b);
174                 jfloat dx21 = NEXT_FLOAT(b);
175                 jfloat dy21 = NEXT_FLOAT(b);
176                 jfloat dx12 = NEXT_FLOAT(b);
177                 jfloat dy12 = NEXT_FLOAT(b);
178                 jfloat lwr21 = NEXT_FLOAT(b);
179                 jfloat lwr12 = NEXT_FLOAT(b);
180                 OGLRenderer_DrawAAParallelogram(oglc, dstOps,
181                                                 x11, y11,
182                                                 dx21, dy21,
183                                                 dx12, dy12,
184                                                 lwr21, lwr12);
185             }
186             break;
187 
188         // fill ops
189         case sun_java2d_pipe_BufferedOpCodes_FILL_RECT:
190             {
191                 jint x = NEXT_INT(b);
192                 jint y = NEXT_INT(b);
193                 jint w = NEXT_INT(b);
194                 jint h = NEXT_INT(b);
195                 OGLRenderer_FillRect(oglc, x, y, w, h);
196             }
197             break;
198         case sun_java2d_pipe_BufferedOpCodes_FILL_SPANS:
199             {
200                 jint count = NEXT_INT(b);
201                 OGLRenderer_FillSpans(oglc, count, (jint *)b);
202                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
203             }
204             break;
205         case sun_java2d_pipe_BufferedOpCodes_FILL_PARALLELOGRAM:
206             {
207                 jfloat x11 = NEXT_FLOAT(b);
208                 jfloat y11 = NEXT_FLOAT(b);
209                 jfloat dx21 = NEXT_FLOAT(b);
210                 jfloat dy21 = NEXT_FLOAT(b);
211                 jfloat dx12 = NEXT_FLOAT(b);
212                 jfloat dy12 = NEXT_FLOAT(b);
213                 OGLRenderer_FillParallelogram(oglc,
214                                               x11, y11,
215                                               dx21, dy21,
216                                               dx12, dy12);
217             }
218             break;
219         case sun_java2d_pipe_BufferedOpCodes_FILL_AAPARALLELOGRAM:
220             {
221                 jfloat x11 = NEXT_FLOAT(b);
222                 jfloat y11 = NEXT_FLOAT(b);
223                 jfloat dx21 = NEXT_FLOAT(b);
224                 jfloat dy21 = NEXT_FLOAT(b);
225                 jfloat dx12 = NEXT_FLOAT(b);
226                 jfloat dy12 = NEXT_FLOAT(b);
227                 OGLRenderer_FillAAParallelogram(oglc, dstOps,
228                                                 x11, y11,
229                                                 dx21, dy21,
230                                                 dx12, dy12);
231             }
232             break;
233 
234         // text-related ops
235         case sun_java2d_pipe_BufferedOpCodes_DRAW_GLYPH_LIST:
236             {
237                 jint numGlyphs        = NEXT_INT(b);
238                 jint packedParams     = NEXT_INT(b);
239                 jfloat glyphListOrigX = NEXT_FLOAT(b);
240                 jfloat glyphListOrigY = NEXT_FLOAT(b);
241                 jboolean usePositions = EXTRACT_BOOLEAN(packedParams,
242                                                         OFFSET_POSITIONS);
243                 jboolean subPixPos    = EXTRACT_BOOLEAN(packedParams,
244                                                         OFFSET_SUBPIXPOS);
245                 jboolean rgbOrder     = EXTRACT_BOOLEAN(packedParams,
246                                                         OFFSET_RGBORDER);
247                 jint lcdContrast      = EXTRACT_BYTE(packedParams,
248                                                      OFFSET_CONTRAST);
249                 unsigned char *images = b;
250                 unsigned char *positions;
251                 jint bytesPerGlyph;
252                 if (usePositions) {
253                     positions = (b + numGlyphs * BYTES_PER_GLYPH_IMAGE);
254                     bytesPerGlyph = BYTES_PER_POSITIONED_GLYPH;
255                 } else {
256                     positions = NULL;
257                     bytesPerGlyph = BYTES_PER_GLYPH_IMAGE;
258                 }
259                 OGLTR_DrawGlyphList(env, oglc, dstOps,
260                                     numGlyphs, usePositions,
261                                     subPixPos, rgbOrder, lcdContrast,
262                                     glyphListOrigX, glyphListOrigY,
263                                     images, positions);
264                 SKIP_BYTES(b, numGlyphs * bytesPerGlyph);
265             }
266             break;
267 
268         // copy-related ops
269         case sun_java2d_pipe_BufferedOpCodes_COPY_AREA:
270             {
271                 jint x  = NEXT_INT(b);
272                 jint y  = NEXT_INT(b);
273                 jint w  = NEXT_INT(b);
274                 jint h  = NEXT_INT(b);
275                 jint dx = NEXT_INT(b);
276                 jint dy = NEXT_INT(b);
277                 OGLBlitLoops_CopyArea(env, oglc, dstOps,
278                                       x, y, w, h, dx, dy);
279             }
280             break;
281         case sun_java2d_pipe_BufferedOpCodes_BLIT:
282             {
283                 jint packedParams = NEXT_INT(b);
284                 jint sx1          = NEXT_INT(b);
285                 jint sy1          = NEXT_INT(b);
286                 jint sx2          = NEXT_INT(b);
287                 jint sy2          = NEXT_INT(b);
288                 jdouble dx1       = NEXT_DOUBLE(b);
289                 jdouble dy1       = NEXT_DOUBLE(b);
290                 jdouble dx2       = NEXT_DOUBLE(b);
291                 jdouble dy2       = NEXT_DOUBLE(b);
292                 jlong pSrc        = NEXT_LONG(b);
293                 jlong pDst        = NEXT_LONG(b);
294                 jint hint         = EXTRACT_BYTE(packedParams, OFFSET_HINT);
295                 jboolean texture  = EXTRACT_BOOLEAN(packedParams,
296                                                     OFFSET_TEXTURE);
297                 jboolean rtt      = EXTRACT_BOOLEAN(packedParams,
298                                                     OFFSET_RTT);
299                 jboolean xform    = EXTRACT_BOOLEAN(packedParams,
300                                                     OFFSET_XFORM);
301                 jboolean isoblit  = EXTRACT_BOOLEAN(packedParams,
302                                                     OFFSET_ISOBLIT);
303                 if (isoblit) {
304                     OGLBlitLoops_IsoBlit(env, oglc, pSrc, pDst,
305                                          xform, hint, texture, rtt,
306                                          sx1, sy1, sx2, sy2,
307                                          dx1, dy1, dx2, dy2);
308                 } else {
309                     jint srctype = EXTRACT_BYTE(packedParams, OFFSET_SRCTYPE);
310                     OGLBlitLoops_Blit(env, oglc, pSrc, pDst,
311                                       xform, hint, srctype, texture,
312                                       sx1, sy1, sx2, sy2,
313                                       dx1, dy1, dx2, dy2);
314                 }
315             }
316             break;
317         case sun_java2d_pipe_BufferedOpCodes_SURFACE_TO_SW_BLIT:
318             {
319                 jint sx      = NEXT_INT(b);
320                 jint sy      = NEXT_INT(b);
321                 jint dx      = NEXT_INT(b);
322                 jint dy      = NEXT_INT(b);
323                 jint w       = NEXT_INT(b);
324                 jint h       = NEXT_INT(b);
325                 jint dsttype = NEXT_INT(b);
326                 jlong pSrc   = NEXT_LONG(b);
327                 jlong pDst   = NEXT_LONG(b);
328                 OGLBlitLoops_SurfaceToSwBlit(env, oglc,
329                                              pSrc, pDst, dsttype,
330                                              sx, sy, dx, dy, w, h);
331             }
332             break;
333         case sun_java2d_pipe_BufferedOpCodes_MASK_FILL:
334             {
335                 jint x        = NEXT_INT(b);
336                 jint y        = NEXT_INT(b);
337                 jint w        = NEXT_INT(b);
338                 jint h        = NEXT_INT(b);
339                 jint maskoff  = NEXT_INT(b);
340                 jint maskscan = NEXT_INT(b);
341                 jint masklen  = NEXT_INT(b);
342                 unsigned char *pMask = (masklen &gt; 0) ? b : NULL;
343                 OGLMaskFill_MaskFill(oglc, x, y, w, h,
344                                      maskoff, maskscan, masklen, pMask);
345                 SKIP_BYTES(b, masklen);
346             }
347             break;
348         case sun_java2d_pipe_BufferedOpCodes_MASK_BLIT:
349             {
350                 jint dstx     = NEXT_INT(b);
351                 jint dsty     = NEXT_INT(b);
352                 jint width    = NEXT_INT(b);
353                 jint height   = NEXT_INT(b);
354                 jint masklen  = width * height * sizeof(jint);
355                 OGLMaskBlit_MaskBlit(env, oglc,
356                                      dstx, dsty, width, height, b);
357                 SKIP_BYTES(b, masklen);
358             }
359             break;
360 
361         // state-related ops
362         case sun_java2d_pipe_BufferedOpCodes_SET_RECT_CLIP:
363             {
364                 jint x1 = NEXT_INT(b);
365                 jint y1 = NEXT_INT(b);
366                 jint x2 = NEXT_INT(b);
367                 jint y2 = NEXT_INT(b);
368                 OGLContext_SetRectClip(oglc, dstOps, x1, y1, x2, y2);
369             }
370             break;
371         case sun_java2d_pipe_BufferedOpCodes_BEGIN_SHAPE_CLIP:
372             {
373                 OGLContext_BeginShapeClip(oglc);
374             }
375             break;
376         case sun_java2d_pipe_BufferedOpCodes_SET_SHAPE_CLIP_SPANS:
377             {
378                 jint count = NEXT_INT(b);
379                 OGLRenderer_FillSpans(oglc, count, (jint *)b);
380                 SKIP_BYTES(b, count * BYTES_PER_SPAN);
381             }
382             break;
383         case sun_java2d_pipe_BufferedOpCodes_END_SHAPE_CLIP:
384             {
385                 OGLContext_EndShapeClip(oglc, dstOps);
386             }
387             break;
388         case sun_java2d_pipe_BufferedOpCodes_RESET_CLIP:
389             {
390                 OGLContext_ResetClip(oglc);
391             }
392             break;
393         case sun_java2d_pipe_BufferedOpCodes_SET_ALPHA_COMPOSITE:
394             {
395                 jint rule         = NEXT_INT(b);
396                 jfloat extraAlpha = NEXT_FLOAT(b);
397                 jint flags        = NEXT_INT(b);
398                 OGLContext_SetAlphaComposite(oglc, rule, extraAlpha, flags);
399             }
400             break;
401         case sun_java2d_pipe_BufferedOpCodes_SET_XOR_COMPOSITE:
402             {
403                 jint xorPixel = NEXT_INT(b);
404                 OGLContext_SetXorComposite(oglc, xorPixel);
405             }
406             break;
407         case sun_java2d_pipe_BufferedOpCodes_RESET_COMPOSITE:
408             {
409                 OGLContext_ResetComposite(oglc);
410             }
411             break;
412         case sun_java2d_pipe_BufferedOpCodes_SET_TRANSFORM:
413             {
414                 jdouble m00 = NEXT_DOUBLE(b);
415                 jdouble m10 = NEXT_DOUBLE(b);
416                 jdouble m01 = NEXT_DOUBLE(b);
417                 jdouble m11 = NEXT_DOUBLE(b);
418                 jdouble m02 = NEXT_DOUBLE(b);
419                 jdouble m12 = NEXT_DOUBLE(b);
420                 OGLContext_SetTransform(oglc, m00, m10, m01, m11, m02, m12);
421             }
422             break;
423         case sun_java2d_pipe_BufferedOpCodes_RESET_TRANSFORM:
424             {
425                 OGLContext_ResetTransform(oglc);
426             }
427             break;
428 
429         // context-related ops
430         case sun_java2d_pipe_BufferedOpCodes_SET_SURFACES:
431             {
432                 jlong pSrc = NEXT_LONG(b);
433                 jlong pDst = NEXT_LONG(b);
434                 if (oglc != NULL) {
435                     RESET_PREVIOUS_OP();
436                 }
437                 oglc = OGLContext_SetSurfaces(env, pSrc, pDst);
438                 dstOps = (OGLSDOps *)jlong_to_ptr(pDst);
439             }
440             break;
441         case sun_java2d_pipe_BufferedOpCodes_SET_SCRATCH_SURFACE:
442             {
443                 jlong pConfigInfo = NEXT_LONG(b);
444                 if (oglc != NULL) {
445                     RESET_PREVIOUS_OP();
446                 }
447                 oglc = OGLSD_SetScratchSurface(env, pConfigInfo);
448                 dstOps = NULL;
449             }
450             break;
451         case sun_java2d_pipe_BufferedOpCodes_FLUSH_SURFACE:
452             {
453                 jlong pData = NEXT_LONG(b);
454                 OGLSDOps *oglsdo = (OGLSDOps *)jlong_to_ptr(pData);
455                 if (oglsdo != NULL) {
456                     CONTINUE_IF_NULL(oglc);
457                     RESET_PREVIOUS_OP();
458                     OGLSD_Delete(env, oglsdo);
459                 }
460             }
461             break;
462         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_SURFACE:
463             {
464                 jlong pData = NEXT_LONG(b);
465                 OGLSDOps *oglsdo = (OGLSDOps *)jlong_to_ptr(pData);
466                 if (oglsdo != NULL) {
467                     CONTINUE_IF_NULL(oglc);
468                     RESET_PREVIOUS_OP();
469                     OGLSD_Delete(env, oglsdo);
470                     if (oglsdo-&gt;privOps != NULL) {
471                         free(oglsdo-&gt;privOps);
472                     }
473                 }
474             }
475             break;
476         case sun_java2d_pipe_BufferedOpCodes_DISPOSE_CONFIG:
477             {
478                 jlong pConfigInfo = NEXT_LONG(b);
479                 CONTINUE_IF_NULL(oglc);
480                 RESET_PREVIOUS_OP();
481                 OGLGC_DestroyOGLGraphicsConfig(pConfigInfo);
482 
483                 // the previous method will call glX/wglMakeCurrent(None),
484                 // so we should nullify the current oglc and dstOps to avoid
485                 // calling glFlush() (or similar) while no context is current
486                 oglc = NULL;
487                 dstOps = NULL;
488             }
489             break;
490         case sun_java2d_pipe_BufferedOpCodes_INVALIDATE_CONTEXT:
491             {
492                 // flush just in case there are any pending operations in
493                 // the hardware pipe
494                 if (oglc != NULL) {
495                     RESET_PREVIOUS_OP();
496                     j2d_glFlush();
497                 }
498 
499                 // invalidate the references to the current context and
500                 // destination surface that are maintained at the native level
501                 oglc = NULL;
502                 dstOps = NULL;
503             }
504             break;
505         case sun_java2d_pipe_BufferedOpCodes_SYNC:
506             {
507                 sync = JNI_TRUE;
508             }
509             break;
510 
511         // multibuffering ops
512         case sun_java2d_pipe_BufferedOpCodes_SWAP_BUFFERS:
513             {
514                 jlong window = NEXT_LONG(b);
515                 if (oglc != NULL) {
516                     RESET_PREVIOUS_OP();
517                 }
518                 OGLSD_SwapBuffers(env, window);
519             }
520             break;
521 
522         // special no-op (mainly used for achieving 8-byte alignment)
523         case sun_java2d_pipe_BufferedOpCodes_NOOP:
524             break;
525 
526         // paint-related ops
527         case sun_java2d_pipe_BufferedOpCodes_RESET_PAINT:
528             {
529                 OGLPaints_ResetPaint(oglc);
530             }
531             break;
532         case sun_java2d_pipe_BufferedOpCodes_SET_COLOR:
533             {
534                 jint pixel = NEXT_INT(b);
535                 OGLPaints_SetColor(oglc, pixel);
536             }
537             break;
538         case sun_java2d_pipe_BufferedOpCodes_SET_GRADIENT_PAINT:
539             {
540                 jboolean useMask= NEXT_BOOLEAN(b);
541                 jboolean cyclic = NEXT_BOOLEAN(b);
542                 jdouble p0      = NEXT_DOUBLE(b);
543                 jdouble p1      = NEXT_DOUBLE(b);
544                 jdouble p3      = NEXT_DOUBLE(b);
545                 jint pixel1     = NEXT_INT(b);
546                 jint pixel2     = NEXT_INT(b);
547                 OGLPaints_SetGradientPaint(oglc, useMask, cyclic,
548                                            p0, p1, p3,
549                                            pixel1, pixel2);
550             }
551             break;
552         case sun_java2d_pipe_BufferedOpCodes_SET_LINEAR_GRADIENT_PAINT:
553             {
554                 jboolean useMask = NEXT_BOOLEAN(b);
555                 jboolean linear  = NEXT_BOOLEAN(b);
556                 jint cycleMethod = NEXT_INT(b);
557                 jint numStops    = NEXT_INT(b);
558                 jfloat p0        = NEXT_FLOAT(b);
559                 jfloat p1        = NEXT_FLOAT(b);
560                 jfloat p3        = NEXT_FLOAT(b);
561                 void *fractions, *pixels;
562                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
563                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
564                 OGLPaints_SetLinearGradientPaint(oglc, dstOps,
565                                                  useMask, linear,
566                                                  cycleMethod, numStops,
567                                                  p0, p1, p3,
568                                                  fractions, pixels);
569             }
570             break;
571         case sun_java2d_pipe_BufferedOpCodes_SET_RADIAL_GRADIENT_PAINT:
572             {
573                 jboolean useMask = NEXT_BOOLEAN(b);
574                 jboolean linear  = NEXT_BOOLEAN(b);
575                 jint numStops    = NEXT_INT(b);
576                 jint cycleMethod = NEXT_INT(b);
577                 jfloat m00       = NEXT_FLOAT(b);
578                 jfloat m01       = NEXT_FLOAT(b);
579                 jfloat m02       = NEXT_FLOAT(b);
580                 jfloat m10       = NEXT_FLOAT(b);
581                 jfloat m11       = NEXT_FLOAT(b);
582                 jfloat m12       = NEXT_FLOAT(b);
583                 jfloat focusX    = NEXT_FLOAT(b);
584                 void *fractions, *pixels;
585                 fractions = b; SKIP_BYTES(b, numStops * sizeof(jfloat));
586                 pixels    = b; SKIP_BYTES(b, numStops * sizeof(jint));
587                 OGLPaints_SetRadialGradientPaint(oglc, dstOps,
588                                                  useMask, linear,
589                                                  cycleMethod, numStops,
590                                                  m00, m01, m02,
591                                                  m10, m11, m12,
592                                                  focusX,
593                                                  fractions, pixels);
594             }
595             break;
596         case sun_java2d_pipe_BufferedOpCodes_SET_TEXTURE_PAINT:
597             {
598                 jboolean useMask= NEXT_BOOLEAN(b);
599                 jboolean filter = NEXT_BOOLEAN(b);
600                 jlong pSrc      = NEXT_LONG(b);
601                 jdouble xp0     = NEXT_DOUBLE(b);
602                 jdouble xp1     = NEXT_DOUBLE(b);
603                 jdouble xp3     = NEXT_DOUBLE(b);
604                 jdouble yp0     = NEXT_DOUBLE(b);
605                 jdouble yp1     = NEXT_DOUBLE(b);
606                 jdouble yp3     = NEXT_DOUBLE(b);
607                 OGLPaints_SetTexturePaint(oglc, useMask, pSrc, filter,
608                                           xp0, xp1, xp3,
609                                           yp0, yp1, yp3);
610             }
611             break;
612 
613         // BufferedImageOp-related ops
614         case sun_java2d_pipe_BufferedOpCodes_ENABLE_CONVOLVE_OP:
615             {
616                 jlong pSrc        = NEXT_LONG(b);
617                 jboolean edgeZero = NEXT_BOOLEAN(b);
618                 jint kernelWidth  = NEXT_INT(b);
619                 jint kernelHeight = NEXT_INT(b);
620                 OGLBufImgOps_EnableConvolveOp(oglc, pSrc, edgeZero,
621                                               kernelWidth, kernelHeight, b);
622                 SKIP_BYTES(b, kernelWidth * kernelHeight * sizeof(jfloat));
623             }
624             break;
625         case sun_java2d_pipe_BufferedOpCodes_DISABLE_CONVOLVE_OP:
626             {
627                 OGLBufImgOps_DisableConvolveOp(oglc);
628             }
629             break;
630         case sun_java2d_pipe_BufferedOpCodes_ENABLE_RESCALE_OP:
631             {
632                 jlong pSrc          = NEXT_LONG(b);
633                 jboolean nonPremult = NEXT_BOOLEAN(b);
634                 jint numFactors     = 4;
635                 unsigned char *scaleFactors = b;
636                 unsigned char *offsets = (b + numFactors * sizeof(jfloat));
637                 OGLBufImgOps_EnableRescaleOp(oglc, pSrc, nonPremult,
638                                              scaleFactors, offsets);
639                 SKIP_BYTES(b, numFactors * sizeof(jfloat) * 2);
640             }
641             break;
642         case sun_java2d_pipe_BufferedOpCodes_DISABLE_RESCALE_OP:
643             {
644                 OGLBufImgOps_DisableRescaleOp(oglc);
645             }
646             break;
647         case sun_java2d_pipe_BufferedOpCodes_ENABLE_LOOKUP_OP:
648             {
649                 jlong pSrc          = NEXT_LONG(b);
650                 jboolean nonPremult = NEXT_BOOLEAN(b);
651                 jboolean shortData  = NEXT_BOOLEAN(b);
652                 jint numBands       = NEXT_INT(b);
653                 jint bandLength     = NEXT_INT(b);
654                 jint offset         = NEXT_INT(b);
655                 jint bytesPerElem = shortData ? sizeof(jshort):sizeof(jbyte);
656                 void *tableValues = b;
657                 OGLBufImgOps_EnableLookupOp(oglc, pSrc, nonPremult, shortData,
658                                             numBands, bandLength, offset,
659                                             tableValues);
660                 SKIP_BYTES(b, numBands * bandLength * bytesPerElem);
661             }
662             break;
663         case sun_java2d_pipe_BufferedOpCodes_DISABLE_LOOKUP_OP:
664             {
665                 OGLBufImgOps_DisableLookupOp(oglc);
666             }
667             break;
668 
669         default:
670             J2dRlsTraceLn1(J2D_TRACE_ERROR,
671                 &quot;OGLRenderQueue_flushBuffer: invalid opcode=%d&quot;, opcode);
672             if (oglc != NULL) {
673                 RESET_PREVIOUS_OP();
674             }
675             return;
676         }
677     }
678 
679     if (oglc != NULL) {
680         RESET_PREVIOUS_OP();
681         if (sync) {
682             j2d_glFinish();
683         } else {
684             j2d_glFlush();
685         }
686         OGLSD_Flush(env);
687     }
688 }
689 
690 /**
691  * Returns a pointer to the &quot;current&quot; context, as set by the last SET_SURFACES
692  * or SET_SCRATCH_SURFACE operation.
693  */
694 OGLContext *
695 OGLRenderQueue_GetCurrentContext()
696 {
697     return oglc;
698 }
699 
700 /**
701  * Returns a pointer to the &quot;current&quot; destination surface, as set by the last
702  * SET_SURFACES operation.
703  */
704 OGLSDOps *
705 OGLRenderQueue_GetCurrentDestination()
706 {
707     return dstOps;
708 }
709 
710 /**
711  * Used to track whether we are within a series of simple primitive operations
712  * or texturing operations.  The op parameter determines the nature of the
713  * operation that is to follow.  Valid values for this op parameter are:
714  *
715  *     GL_QUADS
716  *     GL_LINES
717  *     GL_LINE_LOOP
718  *     GL_LINE_STRIP
719  *     (basically any of the valid parameters for glBegin())
720  *
721  *     GL_TEXTURE_2D
722  *     GL_TEXTURE_RECTANGLE_ARB
723  *
724  *     OGL_STATE_RESET
725  *     OGL_STATE_CHANGE
726  *     OGL_STATE_MASK_OP
727  *     OGL_STATE_GLYPH_OP
728  *
729  * Note that the above constants are guaranteed to be unique values.  The
730  * last few are defined to be negative values to differentiate them from
731  * the core GL* constants, which are defined to be non-negative.
732  *
733  * For simple primitives, this method allows us to batch similar primitives
734  * within the same glBegin()/glEnd() pair.  For example, if we have 100
735  * consecutive FILL_RECT operations, we only have to call glBegin(GL_QUADS)
736  * for the first op, and then subsequent operations will consist only of
737  * glVertex*() calls, which helps improve performance.  The glEnd() call
738  * only needs to be issued before an operation that cannot happen within a
739  * glBegin()/glEnd() pair (e.g. updating the clip), or one that requires a
740  * different primitive mode (e.g. GL_LINES).
741  *
742  * For operations that involve texturing, this method helps us to avoid
743  * calling glEnable(GL_TEXTURE_2D) and glDisable(GL_TEXTURE_2D) around each
744  * operation.  For example, if we have an alternating series of ISO_BLIT
745  * and MASK_BLIT operations (both of which involve texturing), we need
746  * only to call glEnable(GL_TEXTURE_2D) before the first ISO_BLIT operation.
747  * The glDisable(GL_TEXTURE_2D) call only needs to be issued before an
748  * operation that cannot (or should not) happen while texturing is enabled
749  * (e.g. a context change, or a simple primitive operation like GL_QUADS).
750  */
751 void
752 OGLRenderQueue_CheckPreviousOp(jint op)
753 {
754     if (previousOp == op) {
755         // The op is the same as last time, so we can return immediately.
756         return;
757     }
758 
759     J2dTraceLn1(J2D_TRACE_VERBOSE,
760                 &quot;OGLRenderQueue_CheckPreviousOp: new op=%d&quot;, op);
761 
762     switch (previousOp) {
763     case GL_TEXTURE_2D:
764     case GL_TEXTURE_RECTANGLE_ARB:
765         if (op == OGL_STATE_CHANGE) {
766             // Optimization: Certain state changes (those marked as
767             // OGL_STATE_CHANGE) are allowed while texturing is enabled.
768             // In this case, we can allow previousOp to remain as it is and
769             // then return early.
770             return;
771         } else {
772             // Otherwise, op must be a primitive operation, or a reset, so
773             // we will disable texturing.
774             j2d_glDisable(previousOp);
775             // This next step of binding to zero should not be strictly
776             // necessary, but on some older Nvidia boards (e.g. GeForce 2)
777             // problems will arise if GL_TEXTURE_2D and
778             // GL_TEXTURE_RECTANGLE_ARB are bound at the same time, so we
779             // will do this just to be safe.
780             j2d_glBindTexture(previousOp, 0);
781         }
782         break;
783     case OGL_STATE_MASK_OP:
784         OGLVertexCache_DisableMaskCache(oglc);
785         break;
786     case OGL_STATE_GLYPH_OP:
787         OGLTR_DisableGlyphVertexCache(oglc);
788         break;
789     case OGL_STATE_PGRAM_OP:
790         OGLRenderer_DisableAAParallelogramProgram();
791         break;
792     case OGL_STATE_RESET:
793     case OGL_STATE_CHANGE:
794         // No-op
795         break;
796     default:
797         // In this case, op must be one of:
798         //     - the start of a different primitive type (glBegin())
799         //     - a texturing operation
800         //     - a state change (not allowed within glBegin()/glEnd() pairs)
801         //     - a reset
802         // so we must first complete the previous primitive operation.
803         j2d_glEnd();
804         break;
805     }
806 
807     switch (op) {
808     case GL_TEXTURE_2D:
809     case GL_TEXTURE_RECTANGLE_ARB:
810         // We are starting a texturing operation, so enable texturing.
811         j2d_glEnable(op);
812         break;
813     case OGL_STATE_MASK_OP:
814         OGLVertexCache_EnableMaskCache(oglc);
815         break;
816     case OGL_STATE_GLYPH_OP:
817         OGLTR_EnableGlyphVertexCache(oglc);
818         break;
819     case OGL_STATE_PGRAM_OP:
820         OGLRenderer_EnableAAParallelogramProgram();
821         break;
822     case OGL_STATE_RESET:
823     case OGL_STATE_CHANGE:
824         // No-op
825         break;
826     default:
827         // We are starting a primitive operation, so call glBegin() with
828         // the given primitive type.
829         j2d_glBegin(op);
830         break;
831     }
832 
833     previousOp = op;
834 }
835 
836 #endif /* !HEADLESS */
    </pre>
  </body>
</html>
diff a/src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c b/src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c
--- a/src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c
+++ b/src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -206,25 +206,26 @@
     j2d_glRasterPos2i(0, 0);
     j2d_glBitmap(0, 0, 0, 0, (GLfloat)dx1, (GLfloat)-dy1, NULL);
 
     j2d_glPixelZoom(scalex, -scaley);
 
+    GLvoid *pSrc = PtrCoord(srcInfo->rasBase, sx1, srcInfo->pixelStride,
+                                              sy1, srcInfo->scanStride);
+
     // in case pixel stride is not a multiple of scanline stride the copy
     // has to be done line by line (see 6207877)
     if (srcInfo->scanStride % srcInfo->pixelStride != 0) {
         jint width = sx2-sx1;
         jint height = sy2-sy1;
-        GLvoid *pSrc = srcInfo->rasBase;
-
         while (height > 0) {
             j2d_glDrawPixels(width, 1, pf->format, pf->type, pSrc);
-            j2d_glBitmap(0, 0, 0, 0, (GLfloat)0, (GLfloat)-1, NULL);
+            j2d_glBitmap(0, 0, 0, 0, (GLfloat)0, (GLfloat)-scaley, NULL);
             pSrc = PtrAddBytes(pSrc, srcInfo->scanStride);
             height--;
         }
     } else {
-        j2d_glDrawPixels(sx2-sx1, sy2-sy1, pf->format, pf->type, srcInfo->rasBase);
+        j2d_glDrawPixels(sx2-sx1, sy2-sy1, pf->format, pf->type, pSrc);
     }
 
     j2d_glPixelZoom(1.0, 1.0);
 
     if (oglc->extraAlpha != 1.0f) {
@@ -315,35 +316,28 @@
 
             tx2 = ((GLdouble)sw) / tw;
             ty2 = ((GLdouble)sh) / th;
 
             if (swsurface) {
+                GLvoid *pSrc = PtrCoord(srcInfo->rasBase,
+                                        sx, srcInfo->pixelStride,
+                                        sy, srcInfo->scanStride);
                 if (slowPath) {
                     jint tmph = sh;
-                    GLvoid *pSrc = PtrCoord(srcInfo->rasBase,
-                                            sx, srcInfo->pixelStride,
-                                            sy, srcInfo->scanStride);
-
                     while (tmph > 0) {
                         j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
                                             0, sh - tmph, sw, 1,
                                             pf->format, pf->type,
                                             pSrc);
                         pSrc = PtrAddBytes(pSrc, srcInfo->scanStride);
                         tmph--;
                     }
                 } else {
-                    j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, sx);
-                    j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, sy);
-
                     j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
                                         0, 0, sw, sh,
                                         pf->format, pf->type,
-                                        srcInfo->rasBase);
-
-                    j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
-                    j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
+                                        pSrc);
                 }
 
                 // the texture image is "right side up", so we align the
                 // upper-left texture corner with the upper-left quad corner
                 j2d_glBegin(GL_QUADS);
@@ -636,12 +630,13 @@
             J2dTraceLn4(J2D_TRACE_VERBOSE, "  sx1=%d sy1=%d sx2=%d sy2=%d",
                         sx1, sy1, sx2, sy2);
             J2dTraceLn4(J2D_TRACE_VERBOSE, "  dx1=%f dy1=%f dx2=%f dy2=%f",
                         dx1, dy1, dx2, dy2);
 
-            j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, sx1);
-            j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, sy1);
+            // Note: we will calculate x/y positions in the raster manually
+            j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
+            j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH,
                               srcInfo.scanStride / srcInfo.pixelStride);
             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, pf.alignment);
 
             if (texture) {
@@ -694,12 +689,10 @@
                                        sx1, sy1, sx2, sy2,
                                        dx1, dy1, dx2, dy2);
                 }
             }
 
-            j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
-            j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
         }
         SurfaceData_InvokeRelease(env, srcOps, &srcInfo);
     }
@@ -715,12 +708,12 @@
     void *tempRow = (h > 1 && !convert) ? malloc(clippedStride) : NULL;
     juint i = 0;
     juint step = 0;
     // vertical flip and convert argbpre to argb if necessary
     for (; i < h / 2; ++i) {
-        juint *r1 = PtrAddBytes(pDst, (i * scanStride));
-        juint *r2 = PtrAddBytes(pDst, (h - i - 1) * scanStride);
+        juint *r1 = PtrPixelsRow(pDst, i, scanStride);
+        juint *r2 = PtrPixelsRow(pDst, h - i - 1, scanStride);
         if (tempRow) {
             // fast path
             memcpy(tempRow, r1, clippedStride);
             memcpy(r1, r2, clippedStride);
             memcpy(r2, tempRow, clippedStride);
@@ -738,11 +731,11 @@
             }
         }
     }
     // convert the middle line if necessary
     if (convert && h % 2) {
-        juint *r1 = PtrAddBytes(pDst, (i * scanStride));
+        juint *r1 = PtrPixelsRow(pDst, i, scanStride);
         for (step = 0; step < w; ++step) {
             LoadIntArgbPreTo1IntArgb(r1, 0, step, r1[step]);
         }
     }
     if (tempRow) {
@@ -811,11 +804,11 @@
             dsty = dstInfo.bounds.y1;
             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
 
             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
-            pDst = PtrAddBytes(pDst, dsty * dstInfo.scanStride);
+            pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);
 
             j2d_glPixelStorei(GL_PACK_ROW_LENGTH,
                               dstInfo.scanStride / dstInfo.pixelStride);
             j2d_glPixelStorei(GL_PACK_ALIGNMENT, pf.alignment);
 #ifdef MACOSX

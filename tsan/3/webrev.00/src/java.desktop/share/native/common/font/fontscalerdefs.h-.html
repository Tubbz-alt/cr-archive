<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/common/font/fontscalerdefs.h</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifndef FontScalerDefsIncludesDefined
 27 #define FontScalerDefsIncludesDefined
 28 
 29 #include &quot;AccelGlyphCache.h&quot;
 30 
 31 #ifdef  __cplusplus
 32 extern &quot;C&quot; {
 33 #endif
 34 
 35 #ifdef _LP64
 36 typedef unsigned int            UInt32;
 37 typedef int                     Int32;
 38 #else
 39 typedef unsigned long           UInt32;
 40 typedef long                    Int32;
 41 #endif
 42 typedef unsigned short          UInt16;
 43 typedef short                   Int16;
 44 typedef unsigned char           UInt8;
 45 
 46 typedef UInt8                   Byte;
 47 typedef Int32                   hsFixed;
 48 typedef Int32                   hsFract;
 49 typedef UInt32                  Bool32;
 50 
 51 #ifndef  __cplusplus
 52 #ifndef false
 53          #define false           0
 54 #endif
 55 
 56 #ifndef true
 57         #define true            1
 58 #endif
 59 #endif
 60 
 61   /* managed: 1 means the glyph has a hardware cached
 62    * copy, and its freeing is managed by the usual
 63    * 2D disposer code.
 64    * A value of 0 means its either unaccelerated (and so has no cellInfos)
 65    * or we want to free this in a different way.
 66    * The field uses previously unused padding, so doesn&#39;t enlarge
 67    * the structure.
 68    */
 69 #define UNMANAGED_GLYPH 0
 70 #define MANAGED_GLYPH   1
 71 typedef struct GlyphInfo {
 72     float        advanceX;
 73     float        advanceY;
 74     UInt16       width;
 75     UInt16       height;
 76     UInt16       rowBytes;
 77     UInt8         managed;
 78     float        topLeftX;
 79     float        topLeftY;
 80     void         *cellInfo;
 81     UInt8        *image;
 82 } GlyphInfo;
 83 
 84   /* We use fffe and ffff as meaning invisible glyphs which have no
 85    * image, or advance and an empty outline.
 86    * Since there are no valid glyphs with this great a value (watch out for
 87    * large fonts in the future!) we can safely use check for &gt;= this value
 88    */
 89 #define INVISIBLE_GLYPHS 0xfffe
 90 
 91 #define GSUB_TAG 0x47535542 /* &#39;GSUB&#39; */
 92 #define GPOS_TAG 0x47504F53 /* &#39;GPOS&#39; */
 93 #define GDEF_TAG 0x47444546 /* &#39;GDEF&#39; */
 94 #define HEAD_TAG 0x68656164 /* &#39;head&#39; */
 95 #define MORT_TAG 0x6D6F7274 /* &#39;mort&#39; */
 96 #define MORX_TAG 0x6D6F7278 /* &#39;morx&#39; */
 97 #define KERN_TAG 0x6B65726E /* &#39;kern&#39; */
 98 
 99 typedef struct TTLayoutTableCacheEntry {
100   const void* ptr;
101   int   len;
102   int   tag;
103 } TTLayoutTableCacheEntry;
104 
105 #define LAYOUTCACHE_ENTRIES 7
106 
107 typedef struct TTLayoutTableCache {
108   TTLayoutTableCacheEntry entries[LAYOUTCACHE_ENTRIES];
109   void* kernPairs;
110 } TTLayoutTableCache;
111 
112 #include &quot;sunfontids.h&quot;
113 
114 JNIEXPORT extern TTLayoutTableCache* newLayoutTableCache();
115 JNIEXPORT extern void freeLayoutTableCache(TTLayoutTableCache* ltc);
116 
117 /* If font is malformed then scaler context created by particular scaler
118  * will be replaced by null scaler context.
119  * Note that this context is not compatible with structure of the context
120  * object used by particular scaler. Therefore, before using context
121  * scaler has to check if it is NullContext.
122  *
123  * Note that in theory request with NullContext should not even reach native
124  * scaler.
125  *
126  * It seems that the only reason to support NullContext is to simplify
127  * FileFontStrike logic - presence of context is used as marker to
128  * free the memory.
129 */
130 JNIEXPORT int isNullScalerContext(void *context);
131 
132 #ifdef  __cplusplus
133 }
134 #endif
135 
136 #endif
    </pre>
  </body>
</html>
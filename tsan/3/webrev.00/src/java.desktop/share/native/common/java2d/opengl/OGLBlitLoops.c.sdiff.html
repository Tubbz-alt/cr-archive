<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="J2D_GL/glext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OGLRenderQueue.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/common/java2d/opengl/OGLBlitLoops.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
191         // if the source surface does not have an alpha channel,
192         // we need to ensure that the alpha values are forced to
193         // the current extra alpha value (see OGLContext_SetExtraAlpha()
194         // for more information)
195         j2d_glPixelTransferf(GL_ALPHA_SCALE, 0.0f);
196         j2d_glPixelTransferf(GL_ALPHA_BIAS, oglc-&gt;extraAlpha);
197     }
198 
199     // This is a rather intriguing (yet totally valid) hack... If we were to
200     // specify a raster position that is outside the surface bounds, the raster
201     // position would be invalid and nothing would be rendered.  However, we
202     // can use a widely known trick to move the raster position outside the
203     // surface bounds while maintaining its status as valid.  The following
204     // call to glBitmap() renders a no-op bitmap, but offsets the current
205     // raster position from (0,0) to the desired location of (dx1,-dy1)...
206     j2d_glRasterPos2i(0, 0);
207     j2d_glBitmap(0, 0, 0, 0, (GLfloat)dx1, (GLfloat)-dy1, NULL);
208 
209     j2d_glPixelZoom(scalex, -scaley);
210 



211     // in case pixel stride is not a multiple of scanline stride the copy
212     // has to be done line by line (see 6207877)
213     if (srcInfo-&gt;scanStride % srcInfo-&gt;pixelStride != 0) {
214         jint width = sx2-sx1;
215         jint height = sy2-sy1;
<span class="line-removed">216         GLvoid *pSrc = srcInfo-&gt;rasBase;</span>
<span class="line-removed">217 </span>
218         while (height &gt; 0) {
219             j2d_glDrawPixels(width, 1, pf-&gt;format, pf-&gt;type, pSrc);
<span class="line-modified">220             j2d_glBitmap(0, 0, 0, 0, (GLfloat)0, (GLfloat)-1, NULL);</span>
221             pSrc = PtrAddBytes(pSrc, srcInfo-&gt;scanStride);
222             height--;
223         }
224     } else {
<span class="line-modified">225         j2d_glDrawPixels(sx2-sx1, sy2-sy1, pf-&gt;format, pf-&gt;type, srcInfo-&gt;rasBase);</span>
226     }
227 
228     j2d_glPixelZoom(1.0, 1.0);
229 
230     if (oglc-&gt;extraAlpha != 1.0f) {
231         OGLContext_SetExtraAlpha(1.0f);
232     }
233     if (!pf-&gt;hasAlpha) {
234         // restore scale/bias to their original values
235         j2d_glPixelTransferf(GL_ALPHA_SCALE, 1.0f);
236         j2d_glPixelTransferf(GL_ALPHA_BIAS, 0.0f);
237     }
238 }
239 
240 /**
241  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface or
242  * OpenGL &quot;Surface&quot; to a destination OpenGL &quot;Surface&quot;, using an OpenGL texture
243  * tile as an intermediate surface.  This method is invoked from
244  * OGLBlitLoops_Blit() for &quot;Sw&quot; surfaces and OGLBlitLoops_IsoBlit() for
245  * &quot;Surface&quot; surfaces.
</pre>
<hr />
<pre>
300         j2d_glPixelTransferf(GL_ALPHA_SCALE, 0.0f);
301         j2d_glPixelTransferf(GL_ALPHA_BIAS, 1.0f);
302     }
303 
304     // in case pixel stride is not a multiple of scanline stride the copy
305     // has to be done line by line (see 6207877)
306     slowPath = srcInfo-&gt;scanStride % srcInfo-&gt;pixelStride != 0;
307 
308     for (sy = sy1, dy = dy1; sy &lt; sy2; sy += th, dy += cdh) {
309         sh = ((sy + th) &gt; sy2) ? (sy2 - sy) : th;
310         dh = ((dy + cdh) &gt; dy2) ? (dy2 - dy) : cdh;
311 
312         for (sx = sx1, dx = dx1; sx &lt; sx2; sx += tw, dx += cdw) {
313             sw = ((sx + tw) &gt; sx2) ? (sx2 - sx) : tw;
314             dw = ((dx + cdw) &gt; dx2) ? (dx2 - dx) : cdw;
315 
316             tx2 = ((GLdouble)sw) / tw;
317             ty2 = ((GLdouble)sh) / th;
318 
319             if (swsurface) {



320                 if (slowPath) {
321                     jint tmph = sh;
<span class="line-removed">322                     GLvoid *pSrc = PtrCoord(srcInfo-&gt;rasBase,</span>
<span class="line-removed">323                                             sx, srcInfo-&gt;pixelStride,</span>
<span class="line-removed">324                                             sy, srcInfo-&gt;scanStride);</span>
<span class="line-removed">325 </span>
326                     while (tmph &gt; 0) {
327                         j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
328                                             0, sh - tmph, sw, 1,
329                                             pf-&gt;format, pf-&gt;type,
330                                             pSrc);
331                         pSrc = PtrAddBytes(pSrc, srcInfo-&gt;scanStride);
332                         tmph--;
333                     }
334                 } else {
<span class="line-removed">335                     j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, sx);</span>
<span class="line-removed">336                     j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, sy);</span>
<span class="line-removed">337 </span>
338                     j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
339                                         0, 0, sw, sh,
340                                         pf-&gt;format, pf-&gt;type,
<span class="line-modified">341                                         srcInfo-&gt;rasBase);</span>
<span class="line-removed">342 </span>
<span class="line-removed">343                     j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);</span>
<span class="line-removed">344                     j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);</span>
345                 }
346 
347                 // the texture image is &quot;right side up&quot;, so we align the
348                 // upper-left texture corner with the upper-left quad corner
349                 j2d_glBegin(GL_QUADS);
350                 j2d_glTexCoord2d(tx1, ty1); j2d_glVertex2d(dx, dy);
351                 j2d_glTexCoord2d(tx2, ty1); j2d_glVertex2d(dx + dw, dy);
352                 j2d_glTexCoord2d(tx2, ty2); j2d_glVertex2d(dx + dw, dy + dh);
353                 j2d_glTexCoord2d(tx1, ty2); j2d_glVertex2d(dx, dy + dh);
354                 j2d_glEnd();
355             } else {
356                 // this accounts for lower-left origin of the source region
357                 jint newsx = srcOps-&gt;xOffset + sx;
358                 jint newsy = srcOps-&gt;yOffset + srcOps-&gt;height - (sy + sh);
359                 j2d_glCopyTexSubImage2D(GL_TEXTURE_2D, 0,
360                                         0, 0, newsx, newsy, sw, sh);
361 
362                 // the texture image is &quot;upside down&quot; after the last step, so
363                 // we align the bottom-left texture corner with the upper-left
364                 // quad corner (and vice versa) to effectively flip the
</pre>
<hr />
<pre>
621             if (srcInfo.bounds.y1 != sy1) {
622                 dy1 += (srcInfo.bounds.y1 - sy1) * (dh / sh);
623                 sy1 = srcInfo.bounds.y1;
624             }
625             if (srcInfo.bounds.x2 != sx2) {
626                 dx2 += (srcInfo.bounds.x2 - sx2) * (dw / sw);
627                 sx2 = srcInfo.bounds.x2;
628             }
629             if (srcInfo.bounds.y2 != sy2) {
630                 dy2 += (srcInfo.bounds.y2 - sy2) * (dh / sh);
631                 sy2 = srcInfo.bounds.y2;
632             }
633 
634             J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;  texture=%d srctype=%d hint=%d&quot;,
635                         texture, srctype, hint);
636             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;,
637                         sx1, sy1, sx2, sy2);
638             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;,
639                         dx1, dy1, dx2, dy2);
640 
<span class="line-modified">641             j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, sx1);</span>
<span class="line-modified">642             j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, sy1);</span>

643             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH,
644                               srcInfo.scanStride / srcInfo.pixelStride);
645             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, pf.alignment);
646 
647             if (texture) {
648                 // These coordinates will always be integers since we
649                 // only ever do a straight copy from sw to texture.
650                 // Thus these casts are &quot;safe&quot; - no loss of precision.
651                 OGLBlitSwToTexture(&amp;srcInfo, &amp;pf, dstOps,
652                                    (jint)dx1, (jint)dy1, (jint)dx2, (jint)dy2);
653             } else {
654                 jboolean viaTexture;
655                 if (xform) {
656                     // we must use the via-texture codepath when there
657                     // is a xform
658                     viaTexture = JNI_TRUE;
659                 } else {
660                     // look at the vendor to see which codepath is faster
661                     // (this has been empirically determined; see 5020009)
662                     switch (OGLC_GET_VENDOR(oglc)) {
</pre>
<hr />
<pre>
679                         break;
680                     default:
681                         // just use the glDrawPixels() codepath
682                         viaTexture = JNI_FALSE;
683                         break;
684                     }
685                 }
686 
687                 if (viaTexture) {
688                     OGLBlitToSurfaceViaTexture(oglc, &amp;srcInfo, &amp;pf, NULL,
689                                                JNI_TRUE, hint,
690                                                sx1, sy1, sx2, sy2,
691                                                dx1, dy1, dx2, dy2);
692                 } else {
693                     OGLBlitSwToSurface(oglc, &amp;srcInfo, &amp;pf,
694                                        sx1, sy1, sx2, sy2,
695                                        dx1, dy1, dx2, dy2);
696                 }
697             }
698 
<span class="line-removed">699             j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);</span>
<span class="line-removed">700             j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);</span>
701             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
702             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
703         }
704         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
705     }
706     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
707 }
708 
709 /**
710  * This method makes vertical flip of the provided area of Surface and convert
711  * pixel&#39;s data from argbPre to argb format if requested.
712  */
713 void flip(void *pDst, juint w, juint h, jint scanStride, jboolean convert) {
714     const size_t clippedStride = 4 * w;
715     void *tempRow = (h &gt; 1 &amp;&amp; !convert) ? malloc(clippedStride) : NULL;
716     juint i = 0;
717     juint step = 0;
718     // vertical flip and convert argbpre to argb if necessary
719     for (; i &lt; h / 2; ++i) {
<span class="line-modified">720         juint *r1 = PtrAddBytes(pDst, (i * scanStride));</span>
<span class="line-modified">721         juint *r2 = PtrAddBytes(pDst, (h - i - 1) * scanStride);</span>
722         if (tempRow) {
723             // fast path
724             memcpy(tempRow, r1, clippedStride);
725             memcpy(r1, r2, clippedStride);
726             memcpy(r2, tempRow, clippedStride);
727         } else {
728             // slow path
729             for (step = 0; step &lt; w; ++step) {
730                 juint tmp = r1[step];
731                 if (convert) {
732                     LoadIntArgbPreTo1IntArgb(r2, 0, step, r1[step]);
733                     LoadIntArgbPreTo1IntArgb(&amp;tmp, 0, 0, r2[step]);
734                 } else {
735                     r1[step] = r2[step];
736                     r2[step] = tmp;
737                 }
738             }
739         }
740     }
741     // convert the middle line if necessary
742     if (convert &amp;&amp; h % 2) {
<span class="line-modified">743         juint *r1 = PtrAddBytes(pDst, (i * scanStride));</span>
744         for (step = 0; step &lt; w; ++step) {
745             LoadIntArgbPreTo1IntArgb(r1, 0, step, r1[step]);
746         }
747     }
748     if (tempRow) {
749         free(tempRow);
750     }
751 }
752 
753 /**
754  * Specialized blit method for copying a native OpenGL &quot;Surface&quot; (pbuffer,
755  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
756  */
757 void
758 OGLBlitLoops_SurfaceToSwBlit(JNIEnv *env, OGLContext *oglc,
759                              jlong pSrcOps, jlong pDstOps, jint dsttype,
760                              jint srcx, jint srcy, jint dstx, jint dsty,
761                              jint width, jint height)
762 {
763     OGLSDOps *srcOps = (OGLSDOps *)jlong_to_ptr(pSrcOps);
</pre>
<hr />
<pre>
796     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
797                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
798     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
799                                     srcx - dstx, srcy - dsty);
800 
801     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
802         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
803     {
804         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
805         if (dstInfo.rasBase) {
806             void *pDst = dstInfo.rasBase;
807 
808             srcx = srcInfo.bounds.x1;
809             srcy = srcInfo.bounds.y1;
810             dstx = dstInfo.bounds.x1;
811             dsty = dstInfo.bounds.y1;
812             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
813             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
814 
815             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
<span class="line-modified">816             pDst = PtrAddBytes(pDst, dsty * dstInfo.scanStride);</span>
817 
818             j2d_glPixelStorei(GL_PACK_ROW_LENGTH,
819                               dstInfo.scanStride / dstInfo.pixelStride);
820             j2d_glPixelStorei(GL_PACK_ALIGNMENT, pf.alignment);
821 #ifdef MACOSX
822             if (srcOps-&gt;isOpaque) {
823                 // For some reason Apple&#39;s OpenGL implementation will
824                 // read back zero values from the alpha channel of an
825                 // opaque surface when using glReadPixels(), so here we
826                 // force the resulting pixels to be fully opaque.
827                 j2d_glPixelTransferf(GL_ALPHA_BIAS, 1.0);
828             }
829 #endif
830 
831             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx=%d sy=%d w=%d h=%d&quot;,
832                         srcx, srcy, width, height);
833             J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;  dx=%d dy=%d&quot;,
834                         dstx, dsty);
835 
836             // this accounts for lower-left origin of the source region
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
191         // if the source surface does not have an alpha channel,
192         // we need to ensure that the alpha values are forced to
193         // the current extra alpha value (see OGLContext_SetExtraAlpha()
194         // for more information)
195         j2d_glPixelTransferf(GL_ALPHA_SCALE, 0.0f);
196         j2d_glPixelTransferf(GL_ALPHA_BIAS, oglc-&gt;extraAlpha);
197     }
198 
199     // This is a rather intriguing (yet totally valid) hack... If we were to
200     // specify a raster position that is outside the surface bounds, the raster
201     // position would be invalid and nothing would be rendered.  However, we
202     // can use a widely known trick to move the raster position outside the
203     // surface bounds while maintaining its status as valid.  The following
204     // call to glBitmap() renders a no-op bitmap, but offsets the current
205     // raster position from (0,0) to the desired location of (dx1,-dy1)...
206     j2d_glRasterPos2i(0, 0);
207     j2d_glBitmap(0, 0, 0, 0, (GLfloat)dx1, (GLfloat)-dy1, NULL);
208 
209     j2d_glPixelZoom(scalex, -scaley);
210 
<span class="line-added">211     GLvoid *pSrc = PtrCoord(srcInfo-&gt;rasBase, sx1, srcInfo-&gt;pixelStride,</span>
<span class="line-added">212                                               sy1, srcInfo-&gt;scanStride);</span>
<span class="line-added">213 </span>
214     // in case pixel stride is not a multiple of scanline stride the copy
215     // has to be done line by line (see 6207877)
216     if (srcInfo-&gt;scanStride % srcInfo-&gt;pixelStride != 0) {
217         jint width = sx2-sx1;
218         jint height = sy2-sy1;


219         while (height &gt; 0) {
220             j2d_glDrawPixels(width, 1, pf-&gt;format, pf-&gt;type, pSrc);
<span class="line-modified">221             j2d_glBitmap(0, 0, 0, 0, (GLfloat)0, (GLfloat)-scaley, NULL);</span>
222             pSrc = PtrAddBytes(pSrc, srcInfo-&gt;scanStride);
223             height--;
224         }
225     } else {
<span class="line-modified">226         j2d_glDrawPixels(sx2-sx1, sy2-sy1, pf-&gt;format, pf-&gt;type, pSrc);</span>
227     }
228 
229     j2d_glPixelZoom(1.0, 1.0);
230 
231     if (oglc-&gt;extraAlpha != 1.0f) {
232         OGLContext_SetExtraAlpha(1.0f);
233     }
234     if (!pf-&gt;hasAlpha) {
235         // restore scale/bias to their original values
236         j2d_glPixelTransferf(GL_ALPHA_SCALE, 1.0f);
237         j2d_glPixelTransferf(GL_ALPHA_BIAS, 0.0f);
238     }
239 }
240 
241 /**
242  * Inner loop used for copying a source system memory (&quot;Sw&quot;) surface or
243  * OpenGL &quot;Surface&quot; to a destination OpenGL &quot;Surface&quot;, using an OpenGL texture
244  * tile as an intermediate surface.  This method is invoked from
245  * OGLBlitLoops_Blit() for &quot;Sw&quot; surfaces and OGLBlitLoops_IsoBlit() for
246  * &quot;Surface&quot; surfaces.
</pre>
<hr />
<pre>
301         j2d_glPixelTransferf(GL_ALPHA_SCALE, 0.0f);
302         j2d_glPixelTransferf(GL_ALPHA_BIAS, 1.0f);
303     }
304 
305     // in case pixel stride is not a multiple of scanline stride the copy
306     // has to be done line by line (see 6207877)
307     slowPath = srcInfo-&gt;scanStride % srcInfo-&gt;pixelStride != 0;
308 
309     for (sy = sy1, dy = dy1; sy &lt; sy2; sy += th, dy += cdh) {
310         sh = ((sy + th) &gt; sy2) ? (sy2 - sy) : th;
311         dh = ((dy + cdh) &gt; dy2) ? (dy2 - dy) : cdh;
312 
313         for (sx = sx1, dx = dx1; sx &lt; sx2; sx += tw, dx += cdw) {
314             sw = ((sx + tw) &gt; sx2) ? (sx2 - sx) : tw;
315             dw = ((dx + cdw) &gt; dx2) ? (dx2 - dx) : cdw;
316 
317             tx2 = ((GLdouble)sw) / tw;
318             ty2 = ((GLdouble)sh) / th;
319 
320             if (swsurface) {
<span class="line-added">321                 GLvoid *pSrc = PtrCoord(srcInfo-&gt;rasBase,</span>
<span class="line-added">322                                         sx, srcInfo-&gt;pixelStride,</span>
<span class="line-added">323                                         sy, srcInfo-&gt;scanStride);</span>
324                 if (slowPath) {
325                     jint tmph = sh;




326                     while (tmph &gt; 0) {
327                         j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
328                                             0, sh - tmph, sw, 1,
329                                             pf-&gt;format, pf-&gt;type,
330                                             pSrc);
331                         pSrc = PtrAddBytes(pSrc, srcInfo-&gt;scanStride);
332                         tmph--;
333                     }
334                 } else {



335                     j2d_glTexSubImage2D(GL_TEXTURE_2D, 0,
336                                         0, 0, sw, sh,
337                                         pf-&gt;format, pf-&gt;type,
<span class="line-modified">338                                         pSrc);</span>



339                 }
340 
341                 // the texture image is &quot;right side up&quot;, so we align the
342                 // upper-left texture corner with the upper-left quad corner
343                 j2d_glBegin(GL_QUADS);
344                 j2d_glTexCoord2d(tx1, ty1); j2d_glVertex2d(dx, dy);
345                 j2d_glTexCoord2d(tx2, ty1); j2d_glVertex2d(dx + dw, dy);
346                 j2d_glTexCoord2d(tx2, ty2); j2d_glVertex2d(dx + dw, dy + dh);
347                 j2d_glTexCoord2d(tx1, ty2); j2d_glVertex2d(dx, dy + dh);
348                 j2d_glEnd();
349             } else {
350                 // this accounts for lower-left origin of the source region
351                 jint newsx = srcOps-&gt;xOffset + sx;
352                 jint newsy = srcOps-&gt;yOffset + srcOps-&gt;height - (sy + sh);
353                 j2d_glCopyTexSubImage2D(GL_TEXTURE_2D, 0,
354                                         0, 0, newsx, newsy, sw, sh);
355 
356                 // the texture image is &quot;upside down&quot; after the last step, so
357                 // we align the bottom-left texture corner with the upper-left
358                 // quad corner (and vice versa) to effectively flip the
</pre>
<hr />
<pre>
615             if (srcInfo.bounds.y1 != sy1) {
616                 dy1 += (srcInfo.bounds.y1 - sy1) * (dh / sh);
617                 sy1 = srcInfo.bounds.y1;
618             }
619             if (srcInfo.bounds.x2 != sx2) {
620                 dx2 += (srcInfo.bounds.x2 - sx2) * (dw / sw);
621                 sx2 = srcInfo.bounds.x2;
622             }
623             if (srcInfo.bounds.y2 != sy2) {
624                 dy2 += (srcInfo.bounds.y2 - sy2) * (dh / sh);
625                 sy2 = srcInfo.bounds.y2;
626             }
627 
628             J2dTraceLn3(J2D_TRACE_VERBOSE, &quot;  texture=%d srctype=%d hint=%d&quot;,
629                         texture, srctype, hint);
630             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx1=%d sy1=%d sx2=%d sy2=%d&quot;,
631                         sx1, sy1, sx2, sy2);
632             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  dx1=%f dy1=%f dx2=%f dy2=%f&quot;,
633                         dx1, dy1, dx2, dy2);
634 
<span class="line-modified">635             // Note: we will calculate x/y positions in the raster manually</span>
<span class="line-modified">636             j2d_glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);</span>
<span class="line-added">637             j2d_glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);</span>
638             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH,
639                               srcInfo.scanStride / srcInfo.pixelStride);
640             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, pf.alignment);
641 
642             if (texture) {
643                 // These coordinates will always be integers since we
644                 // only ever do a straight copy from sw to texture.
645                 // Thus these casts are &quot;safe&quot; - no loss of precision.
646                 OGLBlitSwToTexture(&amp;srcInfo, &amp;pf, dstOps,
647                                    (jint)dx1, (jint)dy1, (jint)dx2, (jint)dy2);
648             } else {
649                 jboolean viaTexture;
650                 if (xform) {
651                     // we must use the via-texture codepath when there
652                     // is a xform
653                     viaTexture = JNI_TRUE;
654                 } else {
655                     // look at the vendor to see which codepath is faster
656                     // (this has been empirically determined; see 5020009)
657                     switch (OGLC_GET_VENDOR(oglc)) {
</pre>
<hr />
<pre>
674                         break;
675                     default:
676                         // just use the glDrawPixels() codepath
677                         viaTexture = JNI_FALSE;
678                         break;
679                     }
680                 }
681 
682                 if (viaTexture) {
683                     OGLBlitToSurfaceViaTexture(oglc, &amp;srcInfo, &amp;pf, NULL,
684                                                JNI_TRUE, hint,
685                                                sx1, sy1, sx2, sy2,
686                                                dx1, dy1, dx2, dy2);
687                 } else {
688                     OGLBlitSwToSurface(oglc, &amp;srcInfo, &amp;pf,
689                                        sx1, sy1, sx2, sy2,
690                                        dx1, dy1, dx2, dy2);
691                 }
692             }
693 


694             j2d_glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
695             j2d_glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
696         }
697         SurfaceData_InvokeRelease(env, srcOps, &amp;srcInfo);
698     }
699     SurfaceData_InvokeUnlock(env, srcOps, &amp;srcInfo);
700 }
701 
702 /**
703  * This method makes vertical flip of the provided area of Surface and convert
704  * pixel&#39;s data from argbPre to argb format if requested.
705  */
706 void flip(void *pDst, juint w, juint h, jint scanStride, jboolean convert) {
707     const size_t clippedStride = 4 * w;
708     void *tempRow = (h &gt; 1 &amp;&amp; !convert) ? malloc(clippedStride) : NULL;
709     juint i = 0;
710     juint step = 0;
711     // vertical flip and convert argbpre to argb if necessary
712     for (; i &lt; h / 2; ++i) {
<span class="line-modified">713         juint *r1 = PtrPixelsRow(pDst, i, scanStride);</span>
<span class="line-modified">714         juint *r2 = PtrPixelsRow(pDst, h - i - 1, scanStride);</span>
715         if (tempRow) {
716             // fast path
717             memcpy(tempRow, r1, clippedStride);
718             memcpy(r1, r2, clippedStride);
719             memcpy(r2, tempRow, clippedStride);
720         } else {
721             // slow path
722             for (step = 0; step &lt; w; ++step) {
723                 juint tmp = r1[step];
724                 if (convert) {
725                     LoadIntArgbPreTo1IntArgb(r2, 0, step, r1[step]);
726                     LoadIntArgbPreTo1IntArgb(&amp;tmp, 0, 0, r2[step]);
727                 } else {
728                     r1[step] = r2[step];
729                     r2[step] = tmp;
730                 }
731             }
732         }
733     }
734     // convert the middle line if necessary
735     if (convert &amp;&amp; h % 2) {
<span class="line-modified">736         juint *r1 = PtrPixelsRow(pDst, i, scanStride);</span>
737         for (step = 0; step &lt; w; ++step) {
738             LoadIntArgbPreTo1IntArgb(r1, 0, step, r1[step]);
739         }
740     }
741     if (tempRow) {
742         free(tempRow);
743     }
744 }
745 
746 /**
747  * Specialized blit method for copying a native OpenGL &quot;Surface&quot; (pbuffer,
748  * window, etc.) to a system memory (&quot;Sw&quot;) surface.
749  */
750 void
751 OGLBlitLoops_SurfaceToSwBlit(JNIEnv *env, OGLContext *oglc,
752                              jlong pSrcOps, jlong pDstOps, jint dsttype,
753                              jint srcx, jint srcy, jint dstx, jint dsty,
754                              jint width, jint height)
755 {
756     OGLSDOps *srcOps = (OGLSDOps *)jlong_to_ptr(pSrcOps);
</pre>
<hr />
<pre>
789     SurfaceData_IntersectBoundsXYXY(&amp;srcInfo.bounds,
790                                     0, 0, srcOps-&gt;width, srcOps-&gt;height);
791     SurfaceData_IntersectBlitBounds(&amp;dstInfo.bounds, &amp;srcInfo.bounds,
792                                     srcx - dstx, srcy - dsty);
793 
794     if (srcInfo.bounds.x2 &gt; srcInfo.bounds.x1 &amp;&amp;
795         srcInfo.bounds.y2 &gt; srcInfo.bounds.y1)
796     {
797         dstOps-&gt;GetRasInfo(env, dstOps, &amp;dstInfo);
798         if (dstInfo.rasBase) {
799             void *pDst = dstInfo.rasBase;
800 
801             srcx = srcInfo.bounds.x1;
802             srcy = srcInfo.bounds.y1;
803             dstx = dstInfo.bounds.x1;
804             dsty = dstInfo.bounds.y1;
805             width = srcInfo.bounds.x2 - srcInfo.bounds.x1;
806             height = srcInfo.bounds.y2 - srcInfo.bounds.y1;
807 
808             pDst = PtrAddBytes(pDst, dstx * dstInfo.pixelStride);
<span class="line-modified">809             pDst = PtrPixelsRow(pDst, dsty, dstInfo.scanStride);</span>
810 
811             j2d_glPixelStorei(GL_PACK_ROW_LENGTH,
812                               dstInfo.scanStride / dstInfo.pixelStride);
813             j2d_glPixelStorei(GL_PACK_ALIGNMENT, pf.alignment);
814 #ifdef MACOSX
815             if (srcOps-&gt;isOpaque) {
816                 // For some reason Apple&#39;s OpenGL implementation will
817                 // read back zero values from the alpha channel of an
818                 // opaque surface when using glReadPixels(), so here we
819                 // force the resulting pixels to be fully opaque.
820                 j2d_glPixelTransferf(GL_ALPHA_BIAS, 1.0);
821             }
822 #endif
823 
824             J2dTraceLn4(J2D_TRACE_VERBOSE, &quot;  sx=%d sy=%d w=%d h=%d&quot;,
825                         srcx, srcy, width, height);
826             J2dTraceLn2(J2D_TRACE_VERBOSE, &quot;  dx=%d dy=%d&quot;,
827                         dstx, dsty);
828 
829             // this accounts for lower-left origin of the source region
</pre>
</td>
</tr>
</table>
<center><a href="J2D_GL/glext.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="OGLRenderQueue.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
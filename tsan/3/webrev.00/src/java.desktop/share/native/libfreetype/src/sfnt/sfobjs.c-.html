<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /***************************************************************************/
   2 /*                                                                         */
   3 /*  sfobjs.c                                                               */
   4 /*                                                                         */
   5 /*    SFNT object management (base).                                       */
   6 /*                                                                         */
   7 /*  Copyright 1996-2018 by                                                 */
   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
   9 /*                                                                         */
  10 /*  This file is part of the FreeType project, and may only be used,       */
  11 /*  modified, and distributed under the terms of the FreeType project      */
  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
  13 /*  this file you indicate that you have read the license and              */
  14 /*  understand and accept it fully.                                        */
  15 /*                                                                         */
  16 /***************************************************************************/
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;sfobjs.h&quot;
  21 #include &quot;ttload.h&quot;
  22 #include &quot;ttcmap.h&quot;
  23 #include &quot;ttkern.h&quot;
  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_INTERNAL_DEBUG_H
  26 #include FT_TRUETYPE_IDS_H
  27 #include FT_TRUETYPE_TAGS_H
  28 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  29 #include FT_SFNT_NAMES_H
  30 #include FT_GZIP_H
  31 
  32 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  33 #include FT_SERVICE_MULTIPLE_MASTERS_H
  34 #include FT_SERVICE_METRICS_VARIATIONS_H
  35 #endif
  36 
  37 #include &quot;sferrors.h&quot;
  38 
  39 #ifdef TT_CONFIG_OPTION_BDF
  40 #include &quot;ttbdf.h&quot;
  41 #endif
  42 
  43 
  44   /*************************************************************************/
  45   /*                                                                       */
  46   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
  47   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
  48   /* messages during execution.                                            */
  49   /*                                                                       */
  50 #undef  FT_COMPONENT
  51 #define FT_COMPONENT  trace_sfobjs
  52 
  53 
  54 
  55   /* convert a UTF-16 name entry to ASCII */
  56   static FT_String*
  57   tt_name_ascii_from_utf16( TT_Name    entry,
  58                             FT_Memory  memory )
  59   {
  60     FT_String*  string = NULL;
  61     FT_UInt     len, code, n;
  62     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  63     FT_Error    error;
  64 
  65 
  66     len = (FT_UInt)entry-&gt;stringLength / 2;
  67 
  68     if ( FT_NEW_ARRAY( string, len + 1 ) )
  69       return NULL;
  70 
  71     for ( n = 0; n &lt; len; n++ )
  72     {
  73       code = FT_NEXT_USHORT( read );
  74 
  75       if ( code == 0 )
  76         break;
  77 
  78       if ( code &lt; 32 || code &gt; 127 )
  79         code = &#39;?&#39;;
  80 
  81       string[n] = (char)code;
  82     }
  83 
  84     string[n] = 0;
  85 
  86     return string;
  87   }
  88 
  89 
  90   /* convert an Apple Roman or symbol name entry to ASCII */
  91   static FT_String*
  92   tt_name_ascii_from_other( TT_Name    entry,
  93                             FT_Memory  memory )
  94   {
  95     FT_String*  string = NULL;
  96     FT_UInt     len, code, n;
  97     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  98     FT_Error    error;
  99 
 100 
 101     len = (FT_UInt)entry-&gt;stringLength;
 102 
 103     if ( FT_NEW_ARRAY( string, len + 1 ) )
 104       return NULL;
 105 
 106     for ( n = 0; n &lt; len; n++ )
 107     {
 108       code = *read++;
 109 
 110       if ( code == 0 )
 111         break;
 112 
 113       if ( code &lt; 32 || code &gt; 127 )
 114         code = &#39;?&#39;;
 115 
 116       string[n] = (char)code;
 117     }
 118 
 119     string[n] = 0;
 120 
 121     return string;
 122   }
 123 
 124 
 125   typedef FT_String*  (*TT_Name_ConvertFunc)( TT_Name    entry,
 126                                               FT_Memory  memory );
 127 
 128 
 129   /* documentation is in sfnt.h */
 130 
 131   FT_LOCAL_DEF( FT_Error )
 132   tt_face_get_name( TT_Face      face,
 133                     FT_UShort    nameid,
 134                     FT_String**  name )
 135   {
 136     FT_Memory   memory = face-&gt;root.memory;
 137     FT_Error    error  = FT_Err_Ok;
 138     FT_String*  result = NULL;
 139     FT_UShort   n;
 140     TT_Name     rec;
 141 
 142     FT_Int  found_apple         = -1;
 143     FT_Int  found_apple_roman   = -1;
 144     FT_Int  found_apple_english = -1;
 145     FT_Int  found_win           = -1;
 146     FT_Int  found_unicode       = -1;
 147 
 148     FT_Bool  is_english = 0;
 149 
 150     TT_Name_ConvertFunc  convert;
 151 
 152 
 153     FT_ASSERT( name );
 154 
 155     rec = face-&gt;name_table.names;
 156     for ( n = 0; n &lt; face-&gt;num_names; n++, rec++ )
 157     {
 158       /* According to the OpenType 1.3 specification, only Microsoft or  */
 159       /* Apple platform IDs might be used in the `name&#39; table.  The      */
 160       /* `Unicode&#39; platform is reserved for the `cmap&#39; table, and the    */
 161       /* `ISO&#39; one is deprecated.                                        */
 162       /*                                                                 */
 163       /* However, the Apple TrueType specification doesn&#39;t say the same  */
 164       /* thing and goes to suggest that all Unicode `name&#39; table entries */
 165       /* should be coded in UTF-16 (in big-endian format I suppose).     */
 166       /*                                                                 */
 167       if ( rec-&gt;nameID == nameid &amp;&amp; rec-&gt;stringLength &gt; 0 )
 168       {
 169         switch ( rec-&gt;platformID )
 170         {
 171         case TT_PLATFORM_APPLE_UNICODE:
 172         case TT_PLATFORM_ISO:
 173           /* there is `languageID&#39; to check there.  We should use this */
 174           /* field only as a last solution when nothing else is        */
 175           /* available.                                                */
 176           /*                                                           */
 177           found_unicode = n;
 178           break;
 179 
 180         case TT_PLATFORM_MACINTOSH:
 181           /* This is a bit special because some fonts will use either    */
 182           /* an English language id, or a Roman encoding id, to indicate */
 183           /* the English version of its font name.                       */
 184           /*                                                             */
 185           if ( rec-&gt;languageID == TT_MAC_LANGID_ENGLISH )
 186             found_apple_english = n;
 187           else if ( rec-&gt;encodingID == TT_MAC_ID_ROMAN )
 188             found_apple_roman = n;
 189           break;
 190 
 191         case TT_PLATFORM_MICROSOFT:
 192           /* we only take a non-English name when there is nothing */
 193           /* else available in the font                            */
 194           /*                                                       */
 195           if ( found_win == -1 || ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 )
 196           {
 197             switch ( rec-&gt;encodingID )
 198             {
 199             case TT_MS_ID_SYMBOL_CS:
 200             case TT_MS_ID_UNICODE_CS:
 201             case TT_MS_ID_UCS_4:
 202               is_english = FT_BOOL( ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 );
 203               found_win  = n;
 204               break;
 205 
 206             default:
 207               ;
 208             }
 209           }
 210           break;
 211 
 212         default:
 213           ;
 214         }
 215       }
 216     }
 217 
 218     found_apple = found_apple_roman;
 219     if ( found_apple_english &gt;= 0 )
 220       found_apple = found_apple_english;
 221 
 222     /* some fonts contain invalid Unicode or Macintosh formatted entries; */
 223     /* we will thus favor names encoded in Windows formats if available   */
 224     /* (provided it is an English name)                                   */
 225     /*                                                                    */
 226     convert = NULL;
 227     if ( found_win &gt;= 0 &amp;&amp; !( found_apple &gt;= 0 &amp;&amp; !is_english ) )
 228     {
 229       rec = face-&gt;name_table.names + found_win;
 230       switch ( rec-&gt;encodingID )
 231       {
 232         /* all Unicode strings are encoded using UTF-16BE */
 233       case TT_MS_ID_UNICODE_CS:
 234       case TT_MS_ID_SYMBOL_CS:
 235         convert = tt_name_ascii_from_utf16;
 236         break;
 237 
 238       case TT_MS_ID_UCS_4:
 239         /* Apparently, if this value is found in a name table entry, it is */
 240         /* documented as `full Unicode repertoire&#39;.  Experience with the   */
 241         /* MsGothic font shipped with Windows Vista shows that this really */
 242         /* means UTF-16 encoded names (UCS-4 values are only used within   */
 243         /* charmaps).                                                      */
 244         convert = tt_name_ascii_from_utf16;
 245         break;
 246 
 247       default:
 248         ;
 249       }
 250     }
 251     else if ( found_apple &gt;= 0 )
 252     {
 253       rec     = face-&gt;name_table.names + found_apple;
 254       convert = tt_name_ascii_from_other;
 255     }
 256     else if ( found_unicode &gt;= 0 )
 257     {
 258       rec     = face-&gt;name_table.names + found_unicode;
 259       convert = tt_name_ascii_from_utf16;
 260     }
 261 
 262     if ( rec &amp;&amp; convert )
 263     {
 264       if ( !rec-&gt;string )
 265       {
 266         FT_Stream  stream = face-&gt;name_table.stream;
 267 
 268 
 269         if ( FT_QNEW_ARRAY ( rec-&gt;string, rec-&gt;stringLength ) ||
 270              FT_STREAM_SEEK( rec-&gt;stringOffset )              ||
 271              FT_STREAM_READ( rec-&gt;string, rec-&gt;stringLength ) )
 272         {
 273           FT_FREE( rec-&gt;string );
 274           rec-&gt;stringLength = 0;
 275           result            = NULL;
 276           goto Exit;
 277         }
 278       }
 279 
 280       result = convert( rec, memory );
 281     }
 282 
 283   Exit:
 284     *name = result;
 285     return error;
 286   }
 287 
 288 
 289   static FT_Encoding
 290   sfnt_find_encoding( int  platform_id,
 291                       int  encoding_id )
 292   {
 293     typedef struct  TEncoding_
 294     {
 295       int          platform_id;
 296       int          encoding_id;
 297       FT_Encoding  encoding;
 298 
 299     } TEncoding;
 300 
 301     static
 302     const TEncoding  tt_encodings[] =
 303     {
 304       { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },
 305 
 306       { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },
 307 
 308       { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },
 309 
 310       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },
 311       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },
 312       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },
 313       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },
 314       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_PRC,        FT_ENCODING_PRC },
 315       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },
 316       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },
 317       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }
 318     };
 319 
 320     const TEncoding  *cur, *limit;
 321 
 322 
 323     cur   = tt_encodings;
 324     limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );
 325 
 326     for ( ; cur &lt; limit; cur++ )
 327     {
 328       if ( cur-&gt;platform_id == platform_id )
 329       {
 330         if ( cur-&gt;encoding_id == encoding_id ||
 331              cur-&gt;encoding_id == -1          )
 332           return cur-&gt;encoding;
 333       }
 334     }
 335 
 336     return FT_ENCODING_NONE;
 337   }
 338 
 339 
 340 #define WRITE_USHORT( p, v )                \
 341           do                                \
 342           {                                 \
 343             *(p)++ = (FT_Byte)( (v) &gt;&gt; 8 ); \
 344             *(p)++ = (FT_Byte)( (v) &gt;&gt; 0 ); \
 345                                             \
 346           } while ( 0 )
 347 
 348 #define WRITE_ULONG( p, v )                  \
 349           do                                 \
 350           {                                  \
 351             *(p)++ = (FT_Byte)( (v) &gt;&gt; 24 ); \
 352             *(p)++ = (FT_Byte)( (v) &gt;&gt; 16 ); \
 353             *(p)++ = (FT_Byte)( (v) &gt;&gt;  8 ); \
 354             *(p)++ = (FT_Byte)( (v) &gt;&gt;  0 ); \
 355                                              \
 356           } while ( 0 )
 357 
 358 
 359   static void
 360   sfnt_stream_close( FT_Stream  stream )
 361   {
 362     FT_Memory  memory = stream-&gt;memory;
 363 
 364 
 365     FT_FREE( stream-&gt;base );
 366 
 367     stream-&gt;size  = 0;
 368     stream-&gt;base  = NULL;
 369     stream-&gt;close = NULL;
 370   }
 371 
 372 
 373   FT_CALLBACK_DEF( int )
 374   compare_offsets( const void*  a,
 375                    const void*  b )
 376   {
 377     WOFF_Table  table1 = *(WOFF_Table*)a;
 378     WOFF_Table  table2 = *(WOFF_Table*)b;
 379 
 380     FT_ULong  offset1 = table1-&gt;Offset;
 381     FT_ULong  offset2 = table2-&gt;Offset;
 382 
 383 
 384     if ( offset1 &gt; offset2 )
 385       return 1;
 386     else if ( offset1 &lt; offset2 )
 387       return -1;
 388     else
 389       return 0;
 390   }
 391 
 392 
 393   /* Replace `face-&gt;root.stream&#39; with a stream containing the extracted */
 394   /* SFNT of a WOFF font.                                               */
 395 
 396   static FT_Error
 397   woff_open_font( FT_Stream  stream,
 398                   TT_Face    face )
 399   {
 400     FT_Memory       memory = stream-&gt;memory;
 401     FT_Error        error  = FT_Err_Ok;
 402 
 403     WOFF_HeaderRec  woff;
 404     WOFF_Table      tables  = NULL;
 405     WOFF_Table*     indices = NULL;
 406 
 407     FT_ULong        woff_offset;
 408 
 409     FT_Byte*        sfnt        = NULL;
 410     FT_Stream       sfnt_stream = NULL;
 411 
 412     FT_Byte*        sfnt_header;
 413     FT_ULong        sfnt_offset;
 414 
 415     FT_Int          nn;
 416     FT_ULong        old_tag = 0;
 417 
 418     static const FT_Frame_Field  woff_header_fields[] =
 419     {
 420 #undef  FT_STRUCTURE
 421 #define FT_STRUCTURE  WOFF_HeaderRec
 422 
 423       FT_FRAME_START( 44 ),
 424         FT_FRAME_ULONG ( signature ),
 425         FT_FRAME_ULONG ( flavor ),
 426         FT_FRAME_ULONG ( length ),
 427         FT_FRAME_USHORT( num_tables ),
 428         FT_FRAME_USHORT( reserved ),
 429         FT_FRAME_ULONG ( totalSfntSize ),
 430         FT_FRAME_USHORT( majorVersion ),
 431         FT_FRAME_USHORT( minorVersion ),
 432         FT_FRAME_ULONG ( metaOffset ),
 433         FT_FRAME_ULONG ( metaLength ),
 434         FT_FRAME_ULONG ( metaOrigLength ),
 435         FT_FRAME_ULONG ( privOffset ),
 436         FT_FRAME_ULONG ( privLength ),
 437       FT_FRAME_END
 438     };
 439 
 440 
 441     FT_ASSERT( stream == face-&gt;root.stream );
 442     FT_ASSERT( FT_STREAM_POS() == 0 );
 443 
 444     if ( FT_STREAM_READ_FIELDS( woff_header_fields, &amp;woff ) )
 445       return error;
 446 
 447     /* Make sure we don&#39;t recurse back here or hit TTC code. */
 448     if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )
 449       return FT_THROW( Invalid_Table );
 450 
 451     /* Miscellaneous checks. */
 452     if ( woff.length != stream-&gt;size                              ||
 453          woff.num_tables == 0                                     ||
 454          44 + woff.num_tables * 20UL &gt;= woff.length               ||
 455          12 + woff.num_tables * 16UL &gt;= woff.totalSfntSize        ||
 456          ( woff.totalSfntSize &amp; 3 ) != 0                          ||
 457          ( woff.metaOffset == 0 &amp;&amp; ( woff.metaLength != 0     ||
 458                                      woff.metaOrigLength != 0 ) ) ||
 459          ( woff.metaLength != 0 &amp;&amp; woff.metaOrigLength == 0 )     ||
 460          ( woff.privOffset == 0 &amp;&amp; woff.privLength != 0 )         )
 461     {
 462       FT_ERROR(( &quot;woff_font_open: invalid WOFF header\n&quot; ));
 463       return FT_THROW( Invalid_Table );
 464     }
 465 
 466     /* Don&#39;t trust `totalSfntSize&#39; before thorough checks. */
 467     if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||
 468          FT_NEW( sfnt_stream )                         )
 469       goto Exit;
 470 
 471     sfnt_header = sfnt;
 472 
 473     /* Write sfnt header. */
 474     {
 475       FT_UInt  searchRange, entrySelector, rangeShift, x;
 476 
 477 
 478       x             = woff.num_tables;
 479       entrySelector = 0;
 480       while ( x )
 481       {
 482         x            &gt;&gt;= 1;
 483         entrySelector += 1;
 484       }
 485       entrySelector--;
 486 
 487       searchRange = ( 1 &lt;&lt; entrySelector ) * 16;
 488       rangeShift  = woff.num_tables * 16 - searchRange;
 489 
 490       WRITE_ULONG ( sfnt_header, woff.flavor );
 491       WRITE_USHORT( sfnt_header, woff.num_tables );
 492       WRITE_USHORT( sfnt_header, searchRange );
 493       WRITE_USHORT( sfnt_header, entrySelector );
 494       WRITE_USHORT( sfnt_header, rangeShift );
 495     }
 496 
 497     /* While the entries in the sfnt header must be sorted by the */
 498     /* tag value, the tables themselves are not.  We thus have to */
 499     /* sort them by offset and check that they don&#39;t overlap.     */
 500 
 501     if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||
 502          FT_NEW_ARRAY( indices, woff.num_tables ) )
 503       goto Exit;
 504 
 505     FT_TRACE2(( &quot;\n&quot;
 506                 &quot;  tag    offset    compLen  origLen  checksum\n&quot;
 507                 &quot;  -------------------------------------------\n&quot; ));
 508 
 509     if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )
 510       goto Exit;
 511 
 512     for ( nn = 0; nn &lt; woff.num_tables; nn++ )
 513     {
 514       WOFF_Table  table = tables + nn;
 515 
 516       table-&gt;Tag        = FT_GET_TAG4();
 517       table-&gt;Offset     = FT_GET_ULONG();
 518       table-&gt;CompLength = FT_GET_ULONG();
 519       table-&gt;OrigLength = FT_GET_ULONG();
 520       table-&gt;CheckSum   = FT_GET_ULONG();
 521 
 522       FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n&quot;,
 523                   (FT_Char)( table-&gt;Tag &gt;&gt; 24 ),
 524                   (FT_Char)( table-&gt;Tag &gt;&gt; 16 ),
 525                   (FT_Char)( table-&gt;Tag &gt;&gt; 8  ),
 526                   (FT_Char)( table-&gt;Tag       ),
 527                   table-&gt;Offset,
 528                   table-&gt;CompLength,
 529                   table-&gt;OrigLength,
 530                   table-&gt;CheckSum ));
 531 
 532       if ( table-&gt;Tag &lt;= old_tag )
 533       {
 534         FT_FRAME_EXIT();
 535 
 536         FT_ERROR(( &quot;woff_font_open: table tags are not sorted\n&quot; ));
 537         error = FT_THROW( Invalid_Table );
 538         goto Exit;
 539       }
 540 
 541       old_tag     = table-&gt;Tag;
 542       indices[nn] = table;
 543     }
 544 
 545     FT_FRAME_EXIT();
 546 
 547     /* Sort by offset. */
 548 
 549     ft_qsort( indices,
 550               woff.num_tables,
 551               sizeof ( WOFF_Table ),
 552               compare_offsets );
 553 
 554     /* Check offsets and lengths. */
 555 
 556     woff_offset = 44 + woff.num_tables * 20L;
 557     sfnt_offset = 12 + woff.num_tables * 16L;
 558 
 559     for ( nn = 0; nn &lt; woff.num_tables; nn++ )
 560     {
 561       WOFF_Table  table = indices[nn];
 562 
 563 
 564       if ( table-&gt;Offset != woff_offset                         ||
 565            table-&gt;CompLength &gt; woff.length                      ||
 566            table-&gt;Offset &gt; woff.length - table-&gt;CompLength      ||
 567            table-&gt;OrigLength &gt; woff.totalSfntSize               ||
 568            sfnt_offset &gt; woff.totalSfntSize - table-&gt;OrigLength ||
 569            table-&gt;CompLength &gt; table-&gt;OrigLength                )
 570       {
 571         FT_ERROR(( &quot;woff_font_open: invalid table offsets\n&quot; ));
 572         error = FT_THROW( Invalid_Table );
 573         goto Exit;
 574       }
 575 
 576       table-&gt;OrigOffset = sfnt_offset;
 577 
 578       /* The offsets must be multiples of 4. */
 579       woff_offset += ( table-&gt;CompLength + 3 ) &amp; ~3U;
 580       sfnt_offset += ( table-&gt;OrigLength + 3 ) &amp; ~3U;
 581     }
 582 
 583     /*
 584      * Final checks!
 585      *
 586      * We don&#39;t decode and check the metadata block.
 587      * We don&#39;t check table checksums either.
 588      * But other than those, I think we implement all
 589      * `MUST&#39; checks from the spec.
 590      */
 591 
 592     if ( woff.metaOffset )
 593     {
 594       if ( woff.metaOffset != woff_offset                  ||
 595            woff.metaOffset + woff.metaLength &gt; woff.length )
 596       {
 597         FT_ERROR(( &quot;woff_font_open:&quot;
 598                    &quot; invalid `metadata&#39; offset or length\n&quot; ));
 599         error = FT_THROW( Invalid_Table );
 600         goto Exit;
 601       }
 602 
 603       /* We have padding only ... */
 604       woff_offset += woff.metaLength;
 605     }
 606 
 607     if ( woff.privOffset )
 608     {
 609       /* ... if it isn&#39;t the last block. */
 610       woff_offset = ( woff_offset + 3 ) &amp; ~3U;
 611 
 612       if ( woff.privOffset != woff_offset                  ||
 613            woff.privOffset + woff.privLength &gt; woff.length )
 614       {
 615         FT_ERROR(( &quot;woff_font_open: invalid `private&#39; offset or length\n&quot; ));
 616         error = FT_THROW( Invalid_Table );
 617         goto Exit;
 618       }
 619 
 620       /* No padding for the last block. */
 621       woff_offset += woff.privLength;
 622     }
 623 
 624     if ( sfnt_offset != woff.totalSfntSize ||
 625          woff_offset != woff.length        )
 626     {
 627       FT_ERROR(( &quot;woff_font_open: invalid `sfnt&#39; table structure\n&quot; ));
 628       error = FT_THROW( Invalid_Table );
 629       goto Exit;
 630     }
 631 
 632     /* Now use `totalSfntSize&#39;. */
 633     if ( FT_REALLOC( sfnt,
 634                      12 + woff.num_tables * 16UL,
 635                      woff.totalSfntSize ) )
 636       goto Exit;
 637 
 638     sfnt_header = sfnt + 12;
 639 
 640     /* Write the tables. */
 641 
 642     for ( nn = 0; nn &lt; woff.num_tables; nn++ )
 643     {
 644       WOFF_Table  table = tables + nn;
 645 
 646 
 647       /* Write SFNT table entry. */
 648       WRITE_ULONG( sfnt_header, table-&gt;Tag );
 649       WRITE_ULONG( sfnt_header, table-&gt;CheckSum );
 650       WRITE_ULONG( sfnt_header, table-&gt;OrigOffset );
 651       WRITE_ULONG( sfnt_header, table-&gt;OrigLength );
 652 
 653       /* Write table data. */
 654       if ( FT_STREAM_SEEK( table-&gt;Offset )     ||
 655            FT_FRAME_ENTER( table-&gt;CompLength ) )
 656         goto Exit;
 657 
 658       if ( table-&gt;CompLength == table-&gt;OrigLength )
 659       {
 660         /* Uncompressed data; just copy. */
 661         ft_memcpy( sfnt + table-&gt;OrigOffset,
 662                    stream-&gt;cursor,
 663                    table-&gt;OrigLength );
 664       }
 665       else
 666       {
 667 #ifdef FT_CONFIG_OPTION_USE_ZLIB
 668 
 669         /* Uncompress with zlib. */
 670         FT_ULong  output_len = table-&gt;OrigLength;
 671 
 672 
 673         error = FT_Gzip_Uncompress( memory,
 674                                     sfnt + table-&gt;OrigOffset, &amp;output_len,
 675                                     stream-&gt;cursor, table-&gt;CompLength );
 676         if ( error )
 677           goto Exit;
 678         if ( output_len != table-&gt;OrigLength )
 679         {
 680           FT_ERROR(( &quot;woff_font_open: compressed table length mismatch\n&quot; ));
 681           error = FT_THROW( Invalid_Table );
 682           goto Exit;
 683         }
 684 
 685 #else /* !FT_CONFIG_OPTION_USE_ZLIB */
 686 
 687         error = FT_THROW( Unimplemented_Feature );
 688         goto Exit;
 689 
 690 #endif /* !FT_CONFIG_OPTION_USE_ZLIB */
 691       }
 692 
 693       FT_FRAME_EXIT();
 694 
 695       /* We don&#39;t check whether the padding bytes in the WOFF file are     */
 696       /* actually &#39;\0&#39;.  For the output, however, we do set them properly. */
 697       sfnt_offset = table-&gt;OrigOffset + table-&gt;OrigLength;
 698       while ( sfnt_offset &amp; 3 )
 699       {
 700         sfnt[sfnt_offset] = &#39;\0&#39;;
 701         sfnt_offset++;
 702       }
 703     }
 704 
 705     /* Ok!  Finally ready.  Swap out stream and return. */
 706     FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );
 707     sfnt_stream-&gt;memory = stream-&gt;memory;
 708     sfnt_stream-&gt;close  = sfnt_stream_close;
 709 
 710     FT_Stream_Free(
 711       face-&gt;root.stream,
 712       ( face-&gt;root.face_flags &amp; FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );
 713 
 714     face-&gt;root.stream = sfnt_stream;
 715 
 716     face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_EXTERNAL_STREAM;
 717 
 718   Exit:
 719     FT_FREE( tables );
 720     FT_FREE( indices );
 721 
 722     if ( error )
 723     {
 724       FT_FREE( sfnt );
 725       FT_Stream_Close( sfnt_stream );
 726       FT_FREE( sfnt_stream );
 727     }
 728 
 729     return error;
 730   }
 731 
 732 
 733 #undef WRITE_USHORT
 734 #undef WRITE_ULONG
 735 
 736 
 737   /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */
 738   /* synthesized into a TTC with one offset table.              */
 739   static FT_Error
 740   sfnt_open_font( FT_Stream  stream,
 741                   TT_Face    face )
 742   {
 743     FT_Memory  memory = stream-&gt;memory;
 744     FT_Error   error;
 745     FT_ULong   tag, offset;
 746 
 747     static const FT_Frame_Field  ttc_header_fields[] =
 748     {
 749 #undef  FT_STRUCTURE
 750 #define FT_STRUCTURE  TTC_HeaderRec
 751 
 752       FT_FRAME_START( 8 ),
 753         FT_FRAME_LONG( version ),
 754         FT_FRAME_LONG( count   ),  /* this is ULong in the specs */
 755       FT_FRAME_END
 756     };
 757 
 758 
 759     face-&gt;ttc_header.tag     = 0;
 760     face-&gt;ttc_header.version = 0;
 761     face-&gt;ttc_header.count   = 0;
 762 
 763   retry:
 764     offset = FT_STREAM_POS();
 765 
 766     if ( FT_READ_ULONG( tag ) )
 767       return error;
 768 
 769     if ( tag == TTAG_wOFF )
 770     {
 771       FT_TRACE2(( &quot;sfnt_open_font: file is a WOFF; synthesizing SFNT\n&quot; ));
 772 
 773       if ( FT_STREAM_SEEK( offset ) )
 774         return error;
 775 
 776       error = woff_open_font( stream, face );
 777       if ( error )
 778         return error;
 779 
 780       /* Swap out stream and retry! */
 781       stream = face-&gt;root.stream;
 782       goto retry;
 783     }
 784 
 785     if ( tag != 0x00010000UL &amp;&amp;
 786          tag != TTAG_ttcf    &amp;&amp;
 787          tag != TTAG_OTTO    &amp;&amp;
 788          tag != TTAG_true    &amp;&amp;
 789          tag != TTAG_typ1    &amp;&amp;
 790          tag != TTAG_0xA5kbd &amp;&amp;
 791          tag != TTAG_0xA5lst &amp;&amp;
 792          tag != 0x00020000UL )
 793     {
 794       FT_TRACE2(( &quot;  not a font using the SFNT container format\n&quot; ));
 795       return FT_THROW( Unknown_File_Format );
 796     }
 797 
 798     face-&gt;ttc_header.tag = TTAG_ttcf;
 799 
 800     if ( tag == TTAG_ttcf )
 801     {
 802       FT_Int  n;
 803 
 804 
 805       FT_TRACE3(( &quot;sfnt_open_font: file is a collection\n&quot; ));
 806 
 807       if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &amp;face-&gt;ttc_header ) )
 808         return error;
 809 
 810       FT_TRACE3(( &quot;                with %ld subfonts\n&quot;,
 811                   face-&gt;ttc_header.count ));
 812 
 813       if ( face-&gt;ttc_header.count == 0 )
 814         return FT_THROW( Invalid_Table );
 815 
 816       /* a rough size estimate: let&#39;s conservatively assume that there   */
 817       /* is just a single table info in each subfont header (12 + 16*1 = */
 818       /* 28 bytes), thus we have (at least) `12 + 4*count&#39; bytes for the */
 819       /* size of the TTC header plus `28*count&#39; bytes for all subfont    */
 820       /* headers                                                         */
 821       if ( (FT_ULong)face-&gt;ttc_header.count &gt; stream-&gt;size / ( 28 + 4 ) )
 822         return FT_THROW( Array_Too_Large );
 823 
 824       /* now read the offsets of each font in the file */
 825       if ( FT_NEW_ARRAY( face-&gt;ttc_header.offsets, face-&gt;ttc_header.count ) )
 826         return error;
 827 
 828       if ( FT_FRAME_ENTER( face-&gt;ttc_header.count * 4L ) )
 829         return error;
 830 
 831       for ( n = 0; n &lt; face-&gt;ttc_header.count; n++ )
 832         face-&gt;ttc_header.offsets[n] = FT_GET_ULONG();
 833 
 834       FT_FRAME_EXIT();
 835     }
 836     else
 837     {
 838       FT_TRACE3(( &quot;sfnt_open_font: synthesize TTC\n&quot; ));
 839 
 840       face-&gt;ttc_header.version = 1 &lt;&lt; 16;
 841       face-&gt;ttc_header.count   = 1;
 842 
 843       if ( FT_NEW( face-&gt;ttc_header.offsets ) )
 844         return error;
 845 
 846       face-&gt;ttc_header.offsets[0] = offset;
 847     }
 848 
 849     return error;
 850   }
 851 
 852 
 853   FT_LOCAL_DEF( FT_Error )
 854   sfnt_init_face( FT_Stream      stream,
 855                   TT_Face        face,
 856                   FT_Int         face_instance_index,
 857                   FT_Int         num_params,
 858                   FT_Parameter*  params )
 859   {
 860     FT_Error      error;
 861     FT_Library    library = face-&gt;root.driver-&gt;root.library;
 862     SFNT_Service  sfnt;
 863     FT_Int        face_index;
 864 
 865 
 866     /* for now, parameters are unused */
 867     FT_UNUSED( num_params );
 868     FT_UNUSED( params );
 869 
 870 
 871     sfnt = (SFNT_Service)face-&gt;sfnt;
 872     if ( !sfnt )
 873     {
 874       sfnt = (SFNT_Service)FT_Get_Module_Interface( library, &quot;sfnt&quot; );
 875       if ( !sfnt )
 876       {
 877         FT_ERROR(( &quot;sfnt_init_face: cannot access `sfnt&#39; module\n&quot; ));
 878         return FT_THROW( Missing_Module );
 879       }
 880 
 881       face-&gt;sfnt       = sfnt;
 882       face-&gt;goto_table = sfnt-&gt;goto_table;
 883     }
 884 
 885     FT_FACE_FIND_GLOBAL_SERVICE( face, face-&gt;psnames, POSTSCRIPT_CMAPS );
 886 
 887 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 888     if ( !face-&gt;mm )
 889     {
 890       /* we want the MM interface from the `truetype&#39; module only */
 891       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 892 
 893 
 894       face-&gt;mm = ft_module_get_service( tt_module,
 895                                         FT_SERVICE_ID_MULTI_MASTERS,
 896                                         0 );
 897     }
 898 
 899     if ( !face-&gt;var )
 900     {
 901       /* we want the metrics variations interface */
 902       /* from the `truetype&#39; module only          */
 903       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 904 
 905 
 906       face-&gt;var = ft_module_get_service( tt_module,
 907                                          FT_SERVICE_ID_METRICS_VARIATIONS,
 908                                          0 );
 909     }
 910 #endif
 911 
 912     FT_TRACE2(( &quot;SFNT driver\n&quot; ));
 913 
 914     error = sfnt_open_font( stream, face );
 915     if ( error )
 916       return error;
 917 
 918     /* Stream may have changed in sfnt_open_font. */
 919     stream = face-&gt;root.stream;
 920 
 921     FT_TRACE2(( &quot;sfnt_init_face: %08p, %d\n&quot;, face, face_instance_index ));
 922 
 923     face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;
 924 
 925     /* value -(N+1) requests information on index N */
 926     if ( face_instance_index &lt; 0 )
 927       face_index--;
 928 
 929     if ( face_index &gt;= face-&gt;ttc_header.count )
 930     {
 931       if ( face_instance_index &gt;= 0 )
 932         return FT_THROW( Invalid_Argument );
 933       else
 934         face_index = 0;
 935     }
 936 
 937     if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )
 938       return error;
 939 
 940     /* check whether we have a valid TrueType file */
 941     error = sfnt-&gt;load_font_dir( face, stream );
 942     if ( error )
 943       return error;
 944 
 945 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 946     {
 947       FT_Memory  memory = face-&gt;root.memory;
 948 
 949       FT_ULong  fvar_len;
 950 
 951       FT_ULong  version;
 952       FT_ULong  offset;
 953 
 954       FT_UShort  num_axes;
 955       FT_UShort  axis_size;
 956       FT_UShort  num_instances;
 957       FT_UShort  instance_size;
 958 
 959       FT_Int  instance_index;
 960 
 961       FT_Byte*  default_values  = NULL;
 962       FT_Byte*  instance_values = NULL;
 963 
 964 
 965       instance_index = FT_ABS( face_instance_index ) &gt;&gt; 16;
 966 
 967       /* test whether current face is a GX font with named instances */
 968       if ( face-&gt;goto_table( face, TTAG_fvar, stream, &amp;fvar_len ) ||
 969            fvar_len &lt; 20                                          ||
 970            FT_READ_ULONG( version )                               ||
 971            FT_READ_USHORT( offset )                               ||
 972            FT_STREAM_SKIP( 2 ) /* reserved */                     ||
 973            FT_READ_USHORT( num_axes )                             ||
 974            FT_READ_USHORT( axis_size )                            ||
 975            FT_READ_USHORT( num_instances )                        ||
 976            FT_READ_USHORT( instance_size )                        )
 977       {
 978         version       = 0;
 979         offset        = 0;
 980         num_axes      = 0;
 981         axis_size     = 0;
 982         num_instances = 0;
 983         instance_size = 0;
 984       }
 985 
 986       /* check that the data is bound by the table length */
 987       if ( version != 0x00010000UL                    ||
 988            axis_size != 20                            ||
 989            num_axes == 0                              ||
 990            /* `num_axes&#39; limit implied by 16-bit `instance_size&#39; */
 991            num_axes &gt; 0x3FFE                          ||
 992            !( instance_size == 4 + 4 * num_axes ||
 993               instance_size == 6 + 4 * num_axes )     ||
 994            /* `num_instances&#39; limit implied by limited range of name IDs */
 995            num_instances &gt; 0x7EFF                     ||
 996            offset                          +
 997              axis_size * num_axes          +
 998              instance_size * num_instances &gt; fvar_len )
 999         num_instances = 0;
1000       else
1001         face-&gt;variation_support |= TT_FACE_FLAG_VAR_FVAR;
1002 
1003       /*
1004        *  As documented in the OpenType specification, an entry for the
1005        *  default instance may be omitted in the named instance table.  In
1006        *  particular this means that even if there is no named instance
1007        *  table in the font we actually do have a named instance, namely the
1008        *  default instance.
1009        *
1010        *  For consistency, we always want the default instance in our list
1011        *  of named instances.  If it is missing, we try to synthesize it
1012        *  later on.  Here, we have to adjust `num_instances&#39; accordingly.
1013        */
1014 
1015       if ( ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR ) &amp;&amp;
1016            !( FT_ALLOC( default_values, num_axes * 4 )  ||
1017               FT_ALLOC( instance_values, num_axes * 4 ) )      )
1018       {
1019         /* the current stream position is 16 bytes after the table start */
1020         FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
1021         FT_ULong  default_value_offset, instance_offset;
1022 
1023         FT_Byte*  p;
1024         FT_UInt   i;
1025 
1026 
1027         default_value_offset = array_start + 8;
1028         p                    = default_values;
1029 
1030         for ( i = 0; i &lt; num_axes; i++ )
1031         {
1032           (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );
1033 
1034           default_value_offset += axis_size;
1035           p                    += 4;
1036         }
1037 
1038         instance_offset = array_start + axis_size * num_axes + 4;
1039 
1040         for ( i = 0; i &lt; num_instances; i++ )
1041         {
1042           (void)FT_STREAM_READ_AT( instance_offset,
1043                                    instance_values,
1044                                    num_axes * 4 );
1045 
1046           if ( !ft_memcmp( default_values, instance_values, num_axes * 4 ) )
1047             break;
1048 
1049           instance_offset += instance_size;
1050         }
1051 
1052         if ( i == num_instances )
1053         {
1054           /* no default instance in named instance table; */
1055           /* we thus have to synthesize it                */
1056           num_instances++;
1057         }
1058       }
1059 
1060       FT_FREE( default_values );
1061       FT_FREE( instance_values );
1062 
1063       /* we don&#39;t support Multiple Master CFFs yet; */
1064       /* note that `glyf&#39; or `CFF2&#39; have precedence */
1065       if ( face-&gt;goto_table( face, TTAG_glyf, stream, 0 ) &amp;&amp;
1066            face-&gt;goto_table( face, TTAG_CFF2, stream, 0 ) &amp;&amp;
1067            !face-&gt;goto_table( face, TTAG_CFF, stream, 0 ) )
1068         num_instances = 0;
1069 
1070       /* instance indices in `face_instance_index&#39; start with index 1, */
1071       /* thus `&gt;&#39; and not `&gt;=&#39;                                         */
1072       if ( instance_index &gt; num_instances )
1073       {
1074         if ( face_instance_index &gt;= 0 )
1075           return FT_THROW( Invalid_Argument );
1076         else
1077           num_instances = 0;
1078       }
1079 
1080       face-&gt;root.style_flags = (FT_Long)num_instances &lt;&lt; 16;
1081     }
1082 #endif
1083 
1084     face-&gt;root.num_faces  = face-&gt;ttc_header.count;
1085     face-&gt;root.face_index = face_instance_index;
1086 
1087     return error;
1088   }
1089 
1090 
1091 #define LOAD_( x )                                          \
1092   do                                                        \
1093   {                                                         \
1094     FT_TRACE2(( &quot;`&quot; #x &quot;&#39; &quot; ));                             \
1095     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
1096                                                             \
1097     error = sfnt-&gt;load_ ## x( face, stream );               \
1098                                                             \
1099     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
1100                         ? &quot;loaded&quot;                          \
1101                         : FT_ERR_EQ( error, Table_Missing ) \
1102                           ? &quot;missing&quot;                       \
1103                           : &quot;failed to load&quot; ));            \
1104     FT_TRACE3(( &quot;\n&quot; ));                                    \
1105   } while ( 0 )
1106 
1107 #define LOADM_( x, vertical )                               \
1108   do                                                        \
1109   {                                                         \
1110     FT_TRACE2(( &quot;`%s&quot; #x &quot;&#39; &quot;,                              \
1111                 vertical ? &quot;vertical &quot; : &quot;&quot; ));             \
1112     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
1113                                                             \
1114     error = sfnt-&gt;load_ ## x( face, stream, vertical );     \
1115                                                             \
1116     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
1117                         ? &quot;loaded&quot;                          \
1118                         : FT_ERR_EQ( error, Table_Missing ) \
1119                           ? &quot;missing&quot;                       \
1120                           : &quot;failed to load&quot; ));            \
1121     FT_TRACE3(( &quot;\n&quot; ));                                    \
1122   } while ( 0 )
1123 
1124 #define GET_NAME( id, field )                                   \
1125   do                                                            \
1126   {                                                             \
1127     error = tt_face_get_name( face, TT_NAME_ID_ ## id, field ); \
1128     if ( error )                                                \
1129       goto Exit;                                                \
1130   } while ( 0 )
1131 
1132 
1133   FT_LOCAL_DEF( FT_Error )
1134   sfnt_load_face( FT_Stream      stream,
1135                   TT_Face        face,
1136                   FT_Int         face_instance_index,
1137                   FT_Int         num_params,
1138                   FT_Parameter*  params )
1139   {
1140     FT_Error      error;
1141 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1142     FT_Error      psnames_error;
1143 #endif
1144     FT_Bool       has_outline;
1145     FT_Bool       is_apple_sbit;
1146     FT_Bool       is_apple_sbix;
1147     FT_Bool       has_CBLC;
1148     FT_Bool       has_CBDT;
1149     FT_Bool       ignore_typographic_family    = FALSE;
1150     FT_Bool       ignore_typographic_subfamily = FALSE;
1151 
1152     SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;
1153 
1154     FT_UNUSED( face_instance_index );
1155 
1156 
1157     /* Check parameters */
1158 
1159     {
1160       FT_Int  i;
1161 
1162 
1163       for ( i = 0; i &lt; num_params; i++ )
1164       {
1165         if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY )
1166           ignore_typographic_family = TRUE;
1167         else if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY )
1168           ignore_typographic_subfamily = TRUE;
1169       }
1170     }
1171 
1172     /* Load tables */
1173 
1174     /* We now support two SFNT-based bitmapped font formats.  They */
1175     /* are recognized easily as they do not include a `glyf&#39;       */
1176     /* table.                                                      */
1177     /*                                                             */
1178     /* The first format comes from Apple, and uses a table named   */
1179     /* `bhed&#39; instead of `head&#39; to store the font header (using    */
1180     /* the same format).  It also doesn&#39;t include horizontal and   */
1181     /* vertical metrics tables (i.e. `hhea&#39; and `vhea&#39; tables are  */
1182     /* missing).                                                   */
1183     /*                                                             */
1184     /* The other format comes from Microsoft, and is used with     */
1185     /* WinCE/PocketPC.  It looks like a standard TTF, except that  */
1186     /* it doesn&#39;t contain outlines.                                */
1187     /*                                                             */
1188 
1189     FT_TRACE2(( &quot;sfnt_load_face: %08p\n\n&quot;, face ));
1190 
1191     /* do we have outlines in there? */
1192 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1193     has_outline = FT_BOOL( face-&gt;root.internal-&gt;incremental_interface ||
1194                            tt_face_lookup_table( face, TTAG_glyf )    ||
1195                            tt_face_lookup_table( face, TTAG_CFF )     ||
1196                            tt_face_lookup_table( face, TTAG_CFF2 )    );
1197 #else
1198     has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) ||
1199                            tt_face_lookup_table( face, TTAG_CFF )  ||
1200                            tt_face_lookup_table( face, TTAG_CFF2 ) );
1201 #endif
1202 
1203     is_apple_sbit = 0;
1204     is_apple_sbix = !face-&gt;goto_table( face, TTAG_sbix, stream, 0 );
1205 
1206     /* Apple &#39;sbix&#39; color bitmaps are rendered scaled and then the &#39;glyf&#39;
1207      * outline rendered on top.  We don&#39;t support that yet, so just ignore
1208      * the &#39;glyf&#39; outline and advertise it as a bitmap-only font. */
1209     if ( is_apple_sbix )
1210       has_outline = FALSE;
1211 
1212     /* if this font doesn&#39;t contain outlines, we try to load */
1213     /* a `bhed&#39; table                                        */
1214     if ( !has_outline &amp;&amp; sfnt-&gt;load_bhed )
1215     {
1216       LOAD_( bhed );
1217       is_apple_sbit = FT_BOOL( !error );
1218     }
1219 
1220     /* load the font header (`head&#39; table) if this isn&#39;t an Apple */
1221     /* sbit font file                                             */
1222     if ( !is_apple_sbit || is_apple_sbix )
1223     {
1224       LOAD_( head );
1225       if ( error )
1226         goto Exit;
1227     }
1228 
1229     has_CBLC = !face-&gt;goto_table( face, TTAG_CBLC, stream, 0 );
1230     has_CBDT = !face-&gt;goto_table( face, TTAG_CBDT, stream, 0 );
1231 
1232     /* Ignore outlines for CBLC/CBDT fonts. */
1233     if ( has_CBLC || has_CBDT )
1234       has_outline = FALSE;
1235 
1236     /* OpenType 1.8.2 introduced limits to this value;    */
1237     /* however, they make sense for older SFNT fonts also */
1238     if ( face-&gt;header.Units_Per_EM &lt;    16 ||
1239          face-&gt;header.Units_Per_EM &gt; 16384 )
1240     {
1241       error = FT_THROW( Invalid_Table );
1242 
1243       goto Exit;
1244     }
1245 
1246     /* the following tables are often not present in embedded TrueType */
1247     /* fonts within PDF documents, so don&#39;t check for them.            */
1248     LOAD_( maxp );
1249     LOAD_( cmap );
1250 
1251     /* the following tables are optional in PCL fonts -- */
1252     /* don&#39;t check for errors                            */
1253     LOAD_( name );
1254     LOAD_( post );
1255 
1256 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1257     psnames_error = error;
1258 #endif
1259 
1260     /* do not load the metrics headers and tables if this is an Apple */
1261     /* sbit font file                                                 */
1262     if ( !is_apple_sbit )
1263     {
1264       /* load the `hhea&#39; and `hmtx&#39; tables */
1265       LOADM_( hhea, 0 );
1266       if ( !error )
1267       {
1268         LOADM_( hmtx, 0 );
1269         if ( FT_ERR_EQ( error, Table_Missing ) )
1270         {
1271           error = FT_THROW( Hmtx_Table_Missing );
1272 
1273 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1274           /* If this is an incrementally loaded font and there are */
1275           /* overriding metrics, tolerate a missing `hmtx&#39; table.  */
1276           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
1277                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
1278                  get_glyph_metrics                                 )
1279           {
1280             face-&gt;horizontal.number_Of_HMetrics = 0;
1281             error                               = FT_Err_Ok;
1282           }
1283 #endif
1284         }
1285       }
1286       else if ( FT_ERR_EQ( error, Table_Missing ) )
1287       {
1288         /* No `hhea&#39; table necessary for SFNT Mac fonts. */
1289         if ( face-&gt;format_tag == TTAG_true )
1290         {
1291           FT_TRACE2(( &quot;This is an SFNT Mac font.\n&quot; ));
1292 
1293           has_outline = 0;
1294           error       = FT_Err_Ok;
1295         }
1296         else
1297         {
1298           error = FT_THROW( Horiz_Header_Missing );
1299 
1300 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1301           /* If this is an incrementally loaded font and there are */
1302           /* overriding metrics, tolerate a missing `hhea&#39; table.  */
1303           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
1304                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
1305                  get_glyph_metrics                                 )
1306           {
1307             face-&gt;horizontal.number_Of_HMetrics = 0;
1308             error                               = FT_Err_Ok;
1309           }
1310 #endif
1311 
1312         }
1313       }
1314 
1315       if ( error )
1316         goto Exit;
1317 
1318       /* try to load the `vhea&#39; and `vmtx&#39; tables */
1319       LOADM_( hhea, 1 );
1320       if ( !error )
1321       {
1322         LOADM_( hmtx, 1 );
1323         if ( !error )
1324           face-&gt;vertical_info = 1;
1325       }
1326 
1327       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
1328         goto Exit;
1329 
1330       LOAD_( os2 );
1331       if ( error )
1332       {
1333         /* we treat the table as missing if there are any errors */
1334         face-&gt;os2.version = 0xFFFFU;
1335       }
1336     }
1337 
1338     /* the optional tables */
1339 
1340     /* embedded bitmap support */
1341     if ( sfnt-&gt;load_eblc )
1342       LOAD_( eblc );
1343 
1344     /* consider the pclt, kerning, and gasp tables as optional */
1345     LOAD_( pclt );
1346     LOAD_( gasp );
1347     LOAD_( kern );
1348 
1349     face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;
1350 
1351     /* Bit 8 of the `fsSelection&#39; field in the `OS/2&#39; table denotes  */
1352     /* a WWS-only font face.  `WWS&#39; stands for `weight&#39;, width&#39;, and */
1353     /* `slope&#39;, a term used by Microsoft&#39;s Windows Presentation      */
1354     /* Foundation (WPF).  This flag has been introduced in version   */
1355     /* 1.5 of the OpenType specification (May 2008).                 */
1356 
1357     face-&gt;root.family_name = NULL;
1358     face-&gt;root.style_name  = NULL;
1359     if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )
1360     {
1361       if ( !ignore_typographic_family )
1362         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1363       if ( !face-&gt;root.family_name )
1364         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
1365 
1366       if ( !ignore_typographic_subfamily )
1367         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
1368       if ( !face-&gt;root.style_name )
1369         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
1370     }
1371     else
1372     {
1373       GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );
1374       if ( !face-&gt;root.family_name &amp;&amp; !ignore_typographic_family )
1375         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1376       if ( !face-&gt;root.family_name )
1377         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
1378 
1379       GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );
1380       if ( !face-&gt;root.style_name &amp;&amp; !ignore_typographic_subfamily )
1381         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
1382       if ( !face-&gt;root.style_name )
1383         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
1384     }
1385 
1386     /* now set up root fields */
1387     {
1388       FT_Face  root  = &amp;face-&gt;root;
1389       FT_Long  flags = root-&gt;face_flags;
1390 
1391 
1392       /*********************************************************************/
1393       /*                                                                   */
1394       /* Compute face flags.                                               */
1395       /*                                                                   */
1396       if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
1397            face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )
1398         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
1399 
1400       if ( has_outline == TRUE )
1401         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
1402 
1403       /* The sfnt driver only supports bitmap fonts natively, thus we */
1404       /* don&#39;t set FT_FACE_FLAG_HINTER.                               */
1405       flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */
1406                FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */
1407 
1408 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1409       if ( !psnames_error                             &amp;&amp;
1410            face-&gt;postscript.FormatType != 0x00030000L )
1411         flags |= FT_FACE_FLAG_GLYPH_NAMES;
1412 #endif
1413 
1414       /* fixed width font? */
1415       if ( face-&gt;postscript.isFixedPitch )
1416         flags |= FT_FACE_FLAG_FIXED_WIDTH;
1417 
1418       /* vertical information? */
1419       if ( face-&gt;vertical_info )
1420         flags |= FT_FACE_FLAG_VERTICAL;
1421 
1422       /* kerning available ? */
1423       if ( TT_FACE_HAS_KERNING( face ) )
1424         flags |= FT_FACE_FLAG_KERNING;
1425 
1426 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1427       /* Don&#39;t bother to load the tables unless somebody asks for them. */
1428       /* No need to do work which will (probably) not be used.          */
1429       if ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR )
1430       {
1431         if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;
1432              tt_face_lookup_table( face, TTAG_gvar ) != 0 )
1433           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1434         if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )
1435           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1436       }
1437 #endif
1438 
1439       root-&gt;face_flags = flags;
1440 
1441       /*********************************************************************/
1442       /*                                                                   */
1443       /* Compute style flags.                                              */
1444       /*                                                                   */
1445 
1446       flags = 0;
1447       if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )
1448       {
1449         /* We have an OS/2 table; use the `fsSelection&#39; field.  Bit 9 */
1450         /* indicates an oblique font face.  This flag has been        */
1451         /* introduced in version 1.5 of the OpenType specification.   */
1452 
1453         if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */
1454           flags |= FT_STYLE_FLAG_ITALIC;
1455         else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */
1456           flags |= FT_STYLE_FLAG_ITALIC;
1457 
1458         if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */
1459           flags |= FT_STYLE_FLAG_BOLD;
1460       }
1461       else
1462       {
1463         /* this is an old Mac font, use the header field */
1464 
1465         if ( face-&gt;header.Mac_Style &amp; 1 )
1466           flags |= FT_STYLE_FLAG_BOLD;
1467 
1468         if ( face-&gt;header.Mac_Style &amp; 2 )
1469           flags |= FT_STYLE_FLAG_ITALIC;
1470       }
1471 
1472       root-&gt;style_flags |= flags;
1473 
1474       /*********************************************************************/
1475       /*                                                                   */
1476       /* Polish the charmaps.                                              */
1477       /*                                                                   */
1478       /*   Try to set the charmap encoding according to the platform &amp;     */
1479       /*   encoding ID of each charmap.  Emulate Unicode charmap if one    */
1480       /*   is missing.                                                     */
1481       /*                                                                   */
1482 
1483       tt_face_build_cmaps( face );  /* ignore errors */
1484 
1485 
1486       /* set the encoding fields */
1487       {
1488         FT_Int   m;
1489 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1490         FT_Bool  has_unicode = FALSE;
1491 #endif
1492 
1493 
1494         for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )
1495         {
1496           FT_CharMap  charmap = root-&gt;charmaps[m];
1497 
1498 
1499           charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,
1500                                                   charmap-&gt;encoding_id );
1501 
1502 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1503 
1504           if ( charmap-&gt;encoding == FT_ENCODING_UNICODE   ||
1505                charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL )  /* PUA */
1506             has_unicode = TRUE;
1507         }
1508 
1509         /* synthesize Unicode charmap if one is missing */
1510         if ( !has_unicode )
1511         {
1512           FT_CharMapRec cmaprec;
1513 
1514 
1515           cmaprec.face        = root;
1516           cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
1517           cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
1518           cmaprec.encoding    = FT_ENCODING_UNICODE;
1519 
1520 
1521           error = FT_CMap_New( (FT_CMap_Class)&amp;tt_cmap_unicode_class_rec,
1522                                NULL, &amp;cmaprec, NULL );
1523           if ( error                                      &amp;&amp;
1524                FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
1525             goto Exit;
1526           error = FT_Err_Ok;
1527 
1528 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
1529 
1530         }
1531       }
1532 
1533 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1534 
1535       /*
1536        *  Now allocate the root array of FT_Bitmap_Size records and
1537        *  populate them.  Unfortunately, it isn&#39;t possible to indicate bit
1538        *  depths in the FT_Bitmap_Size record.  This is a design error.
1539        */
1540       {
1541         FT_UInt  count;
1542 
1543 
1544         count = face-&gt;sbit_num_strikes;
1545 
1546         if ( count &gt; 0 )
1547         {
1548           FT_Memory        memory   = face-&gt;root.stream-&gt;memory;
1549           FT_UShort        em_size  = face-&gt;header.Units_Per_EM;
1550           FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;
1551           FT_Size_Metrics  metrics;
1552 
1553           FT_UInt*  sbit_strike_map = NULL;
1554           FT_UInt   strike_idx, bsize_idx;
1555 
1556 
1557           if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )
1558           {
1559             avgwidth = 1;
1560             em_size = 1;
1561           }
1562 
1563           /* to avoid invalid strike data in the `available_sizes&#39; field */
1564           /* of `FT_Face&#39;, we map `available_sizes&#39; indices to strike    */
1565           /* indices                                                     */
1566           if ( FT_NEW_ARRAY( root-&gt;available_sizes, count ) ||
1567                FT_NEW_ARRAY( sbit_strike_map, count ) )
1568             goto Exit;
1569 
1570           bsize_idx = 0;
1571           for ( strike_idx = 0; strike_idx &lt; count; strike_idx++ )
1572           {
1573             FT_Bitmap_Size*  bsize = root-&gt;available_sizes + bsize_idx;
1574 
1575 
1576             error = sfnt-&gt;load_strike_metrics( face, strike_idx, &amp;metrics );
1577             if ( error )
1578               continue;
1579 
1580             bsize-&gt;height = (FT_Short)( metrics.height &gt;&gt; 6 );
1581             bsize-&gt;width  = (FT_Short)(
1582               ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );
1583 
1584             bsize-&gt;x_ppem = metrics.x_ppem &lt;&lt; 6;
1585             bsize-&gt;y_ppem = metrics.y_ppem &lt;&lt; 6;
1586 
1587             /* assume 72dpi */
1588             bsize-&gt;size   = metrics.y_ppem &lt;&lt; 6;
1589 
1590             /* only use strikes with valid PPEM values */
1591             if ( bsize-&gt;x_ppem &amp;&amp; bsize-&gt;y_ppem )
1592               sbit_strike_map[bsize_idx++] = strike_idx;
1593           }
1594 
1595           /* reduce array size to the actually used elements */
1596           (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );
1597 
1598           /* from now on, all strike indices are mapped */
1599           /* using `sbit_strike_map&#39;                    */
1600           if ( bsize_idx )
1601           {
1602             face-&gt;sbit_strike_map = sbit_strike_map;
1603 
1604             root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;
1605             root-&gt;num_fixed_sizes = (FT_Int)bsize_idx;
1606           }
1607         }
1608       }
1609 
1610 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
1611 
1612       /* a font with no bitmaps and no outlines is scalable; */
1613       /* it has only empty glyphs then                       */
1614       if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )
1615         root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;
1616 
1617 
1618       /*********************************************************************/
1619       /*                                                                   */
1620       /*  Set up metrics.                                                  */
1621       /*                                                                   */
1622       if ( FT_IS_SCALABLE( root ) )
1623       {
1624         /* XXX What about if outline header is missing */
1625         /*     (e.g. sfnt wrapped bitmap)?             */
1626         root-&gt;bbox.xMin    = face-&gt;header.xMin;
1627         root-&gt;bbox.yMin    = face-&gt;header.yMin;
1628         root-&gt;bbox.xMax    = face-&gt;header.xMax;
1629         root-&gt;bbox.yMax    = face-&gt;header.yMax;
1630         root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;
1631 
1632 
1633         /* XXX: Computing the ascender/descender/height is very different */
1634         /*      from what the specification tells you.  Apparently, we    */
1635         /*      must be careful because                                   */
1636         /*                                                                */
1637         /*      - not all fonts have an OS/2 table; in this case, we take */
1638         /*        the values in the horizontal header.  However, these    */
1639         /*        values very often are not reliable.                     */
1640         /*                                                                */
1641         /*      - otherwise, the correct typographic values are in the    */
1642         /*        sTypoAscender, sTypoDescender &amp; sTypoLineGap fields.    */
1643         /*                                                                */
1644         /*        However, certain fonts have these fields set to 0.      */
1645         /*        Rather, they have usWinAscent &amp; usWinDescent correctly  */
1646         /*        set (but with different values).                        */
1647         /*                                                                */
1648         /*      As an example, Arial Narrow is implemented through four   */
1649         /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF &amp; ARIALNBI.TTF */
1650         /*                                                                */
1651         /*      Strangely, all fonts have the same values in their        */
1652         /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
1653         /*                                                                */
1654         /*      On the other hand, they all have different                */
1655         /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
1656         /*      table cannot be used to compute the text height reliably! */
1657         /*                                                                */
1658 
1659         /* The ascender and descender are taken from the `hhea&#39; table. */
1660         /* If zero, they are taken from the `OS/2&#39; table.              */
1661 
1662         root-&gt;ascender  = face-&gt;horizontal.Ascender;
1663         root-&gt;descender = face-&gt;horizontal.Descender;
1664 
1665         root-&gt;height = root-&gt;ascender - root-&gt;descender +
1666                        face-&gt;horizontal.Line_Gap;
1667 
1668         if ( !( root-&gt;ascender || root-&gt;descender ) )
1669         {
1670           if ( face-&gt;os2.version != 0xFFFFU )
1671           {
1672             if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )
1673             {
1674               root-&gt;ascender  = face-&gt;os2.sTypoAscender;
1675               root-&gt;descender = face-&gt;os2.sTypoDescender;
1676 
1677               root-&gt;height = root-&gt;ascender - root-&gt;descender +
1678                              face-&gt;os2.sTypoLineGap;
1679             }
1680             else
1681             {
1682               root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;
1683               root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;
1684 
1685               root-&gt;height = root-&gt;ascender - root-&gt;descender;
1686             }
1687           }
1688         }
1689 
1690         root-&gt;max_advance_width  =
1691           (FT_Short)face-&gt;horizontal.advance_Width_Max;
1692         root-&gt;max_advance_height =
1693           (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max
1694                                           : root-&gt;height );
1695 
1696         /* See https://www.microsoft.com/typography/otspec/post.htm -- */
1697         /* Adjust underline position from top edge to centre of        */
1698         /* stroke to convert TrueType meaning to FreeType meaning.     */
1699         root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1700                                     face-&gt;postscript.underlineThickness / 2;
1701         root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1702       }
1703 
1704     }
1705 
1706   Exit:
1707     FT_TRACE2(( &quot;sfnt_load_face: done\n&quot; ));
1708 
1709     return error;
1710   }
1711 
1712 
1713 #undef LOAD_
1714 #undef LOADM_
1715 #undef GET_NAME
1716 
1717 
1718   FT_LOCAL_DEF( void )
1719   sfnt_done_face( TT_Face  face )
1720   {
1721     FT_Memory     memory;
1722     SFNT_Service  sfnt;
1723 
1724 
1725     if ( !face )
1726       return;
1727 
1728     memory = face-&gt;root.memory;
1729     sfnt   = (SFNT_Service)face-&gt;sfnt;
1730 
1731     if ( sfnt )
1732     {
1733       /* destroy the postscript names table if it is loaded */
1734       if ( sfnt-&gt;free_psnames )
1735         sfnt-&gt;free_psnames( face );
1736 
1737       /* destroy the embedded bitmaps table if it is loaded */
1738       if ( sfnt-&gt;free_eblc )
1739         sfnt-&gt;free_eblc( face );
1740     }
1741 
1742 #ifdef TT_CONFIG_OPTION_BDF
1743     /* freeing the embedded BDF properties */
1744     tt_face_free_bdf_props( face );
1745 #endif
1746 
1747     /* freeing the kerning table */
1748     tt_face_done_kern( face );
1749 
1750     /* freeing the collection table */
1751     FT_FREE( face-&gt;ttc_header.offsets );
1752     face-&gt;ttc_header.count = 0;
1753 
1754     /* freeing table directory */
1755     FT_FREE( face-&gt;dir_tables );
1756     face-&gt;num_tables = 0;
1757 
1758     {
1759       FT_Stream  stream = FT_FACE_STREAM( face );
1760 
1761 
1762       /* simply release the &#39;cmap&#39; table frame */
1763       FT_FRAME_RELEASE( face-&gt;cmap_table );
1764       face-&gt;cmap_size = 0;
1765     }
1766 
1767     face-&gt;horz_metrics_size = 0;
1768     face-&gt;vert_metrics_size = 0;
1769 
1770     /* freeing vertical metrics, if any */
1771     if ( face-&gt;vertical_info )
1772     {
1773       FT_FREE( face-&gt;vertical.long_metrics  );
1774       FT_FREE( face-&gt;vertical.short_metrics );
1775       face-&gt;vertical_info = 0;
1776     }
1777 
1778     /* freeing the gasp table */
1779     FT_FREE( face-&gt;gasp.gaspRanges );
1780     face-&gt;gasp.numRanges = 0;
1781 
1782     /* freeing the name table */
1783     if ( sfnt )
1784       sfnt-&gt;free_name( face );
1785 
1786     /* freeing family and style name */
1787     FT_FREE( face-&gt;root.family_name );
1788     FT_FREE( face-&gt;root.style_name );
1789 
1790     /* freeing sbit size table */
1791     FT_FREE( face-&gt;root.available_sizes );
1792     FT_FREE( face-&gt;sbit_strike_map );
1793     face-&gt;root.num_fixed_sizes = 0;
1794 
1795 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1796     FT_FREE( face-&gt;postscript_name );
1797     FT_FREE( face-&gt;var_postscript_prefix );
1798 #endif
1799 
1800     face-&gt;sfnt = NULL;
1801   }
1802 
1803 
1804 /* END */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="t1cmap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1decode.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  t1decode.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    PostScript Type 1 decoding routines (body).                          */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2000-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_CALC_H
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_POSTSCRIPT_HINTS_H
  23 #include FT_INTERNAL_HASH_H
  24 #include FT_OUTLINE_H
  25 
  26 #include &quot;t1decode.h&quot;
  27 #include &quot;psobjs.h&quot;
  28 
  29 #include &quot;psauxerr.h&quot;
  30 
  31 /* ensure proper sign extension */
  32 #define Fix2Int( f )  ( (FT_Int)(FT_Short)( (f) &gt;&gt; 16 ) )
  33 
<span class="line-modified">  34   /*************************************************************************/</span>
<span class="line-modified">  35   /*                                                                       */</span>
<span class="line-modified">  36   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  37   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  38   /* messages during execution.                                            */</span>
<span class="line-modified">  39   /*                                                                       */</span>
  40 #undef  FT_COMPONENT
<span class="line-modified">  41 #define FT_COMPONENT  trace_t1decode</span>
  42 
  43 
  44   typedef enum  T1_Operator_
  45   {
  46     op_none = 0,
  47     op_endchar,
  48     op_hsbw,
  49     op_seac,
  50     op_sbw,
  51     op_closepath,
  52     op_hlineto,
  53     op_hmoveto,
  54     op_hvcurveto,
  55     op_rlineto,
  56     op_rmoveto,
  57     op_rrcurveto,
  58     op_vhcurveto,
  59     op_vlineto,
  60     op_vmoveto,
  61     op_dotsection,
</pre>
<hr />
<pre>
  92     2, /* rmoveto */
  93     6, /* rrcurveto */
  94     4, /* vhcurveto */
  95     1, /* vlineto */
  96     1, /* vmoveto */
  97     0, /* dotsection */
  98     2, /* hstem */
  99     6, /* hstem3 */
 100     2, /* vstem */
 101     6, /* vstem3 */
 102     2, /* div */
 103    -1, /* callothersubr */
 104     1, /* callsubr */
 105     0, /* pop */
 106     0, /* return */
 107     2, /* setcurrentpoint */
 108     2  /* opcode 15 (undocumented and obsolete) */
 109   };
 110 
 111 
<span class="line-modified"> 112   /*************************************************************************/</span>
<span class="line-modified"> 113   /*                                                                       */</span>
<span class="line-modified"> 114   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 115   /*    t1_lookup_glyph_by_stdcharcode_ps                                  */</span>
<span class="line-modified"> 116   /*                                                                       */</span>
<span class="line-modified"> 117   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 118   /*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */</span>
<span class="line-modified"> 119   /*    implement the SEAC Type 1 operator in the Adobe engine             */</span>
<span class="line-modified"> 120   /*                                                                       */</span>
<span class="line-modified"> 121   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 122   /*    face     :: The current face object.                               */</span>
<span class="line-modified"> 123   /*                                                                       */</span>
<span class="line-modified"> 124   /*    charcode :: The character code to look for.                        */</span>
<span class="line-modified"> 125   /*                                                                       */</span>
<span class="line-modified"> 126   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 127   /*    A glyph index in the font face.  Returns -1 if the corresponding   */</span>
<span class="line-modified"> 128   /*    glyph wasn&#39;t found.                                                */</span>
<span class="line-modified"> 129   /*                                                                       */</span>


 130   FT_LOCAL_DEF( FT_Int )
 131   t1_lookup_glyph_by_stdcharcode_ps( PS_Decoder*  decoder,
 132                                      FT_Int       charcode )
 133   {
 134     FT_UInt             n;
 135     const FT_String*    glyph_name;
 136     FT_Service_PsCMaps  psnames = decoder-&gt;psnames;
 137 
 138 
 139     /* check range of standard char code */
 140     if ( charcode &lt; 0 || charcode &gt; 255 )
 141       return -1;
 142 
 143     glyph_name = psnames-&gt;adobe_std_strings(
 144                    psnames-&gt;adobe_std_encoding[charcode]);
 145 
 146     for ( n = 0; n &lt; decoder-&gt;num_glyphs; n++ )
 147     {
 148       FT_String*  name = (FT_String*)decoder-&gt;glyph_names[n];
 149 
 150 
 151       if ( name                               &amp;&amp;
 152            name[0] == glyph_name[0]           &amp;&amp;
 153            ft_strcmp( name, glyph_name ) == 0 )
 154         return (FT_Int)n;
 155     }
 156 
 157     return -1;
 158   }
 159 
 160 
 161 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
<span class="line-modified"> 162   /*************************************************************************/</span>
<span class="line-modified"> 163   /*                                                                       */</span>
<span class="line-modified"> 164   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 165   /*    t1_lookup_glyph_by_stdcharcode                                     */</span>
<span class="line-modified"> 166   /*                                                                       */</span>
<span class="line-modified"> 167   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 168   /*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */</span>
<span class="line-modified"> 169   /*    implement the SEAC Type 1 operator.                                */</span>
<span class="line-modified"> 170   /*                                                                       */</span>
<span class="line-modified"> 171   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 172   /*    face     :: The current face object.                               */</span>
<span class="line-modified"> 173   /*                                                                       */</span>
<span class="line-modified"> 174   /*    charcode :: The character code to look for.                        */</span>
<span class="line-modified"> 175   /*                                                                       */</span>
<span class="line-modified"> 176   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 177   /*    A glyph index in the font face.  Returns -1 if the corresponding   */</span>
<span class="line-modified"> 178   /*    glyph wasn&#39;t found.                                                */</span>
<span class="line-modified"> 179   /*                                                                       */</span>



 180   static FT_Int
 181   t1_lookup_glyph_by_stdcharcode( T1_Decoder  decoder,
 182                                   FT_Int      charcode )
 183   {
 184     FT_UInt             n;
 185     const FT_String*    glyph_name;
 186     FT_Service_PsCMaps  psnames = decoder-&gt;psnames;
 187 
 188 
 189     /* check range of standard char code */
 190     if ( charcode &lt; 0 || charcode &gt; 255 )
 191       return -1;
 192 
 193     glyph_name = psnames-&gt;adobe_std_strings(
 194                    psnames-&gt;adobe_std_encoding[charcode]);
 195 
 196     for ( n = 0; n &lt; decoder-&gt;num_glyphs; n++ )
 197     {
 198       FT_String*  name = (FT_String*)decoder-&gt;glyph_names[n];
 199 
 200 
 201       if ( name                               &amp;&amp;
 202            name[0] == glyph_name[0]           &amp;&amp;
 203            ft_strcmp( name, glyph_name ) == 0 )
 204         return (FT_Int)n;
 205     }
 206 
 207     return -1;
 208   }
 209 
 210 
 211   /* parse a single Type 1 glyph */
 212   FT_LOCAL_DEF( FT_Error )
 213   t1_decoder_parse_glyph( T1_Decoder  decoder,
 214                           FT_UInt     glyph )
 215   {
 216     return decoder-&gt;parse_callback( decoder, glyph );
 217   }
 218 
 219 
<span class="line-modified"> 220   /*************************************************************************/</span>
<span class="line-modified"> 221   /*                                                                       */</span>
<span class="line-modified"> 222   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 223   /*    t1operator_seac                                                    */</span>
<span class="line-modified"> 224   /*                                                                       */</span>
<span class="line-modified"> 225   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 226   /*    Implements the `seac&#39; Type 1 operator for a Type 1 decoder.        */</span>
<span class="line-modified"> 227   /*                                                                       */</span>
<span class="line-modified"> 228   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 229   /*    decoder :: The current CID decoder.                                */</span>
<span class="line-modified"> 230   /*                                                                       */</span>
<span class="line-modified"> 231   /*    asb     :: The accent&#39;s side bearing.                              */</span>
<span class="line-modified"> 232   /*                                                                       */</span>
<span class="line-modified"> 233   /*    adx     :: The horizontal offset of the accent.                    */</span>
<span class="line-modified"> 234   /*                                                                       */</span>
<span class="line-modified"> 235   /*    ady     :: The vertical offset of the accent.                      */</span>
<span class="line-modified"> 236   /*                                                                       */</span>
<span class="line-modified"> 237   /*    bchar   :: The base character&#39;s StandardEncoding charcode.         */</span>
<span class="line-modified"> 238   /*                                                                       */</span>
<span class="line-modified"> 239   /*    achar   :: The accent character&#39;s StandardEncoding charcode.       */</span>
<span class="line-modified"> 240   /*                                                                       */</span>
<span class="line-modified"> 241   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 242   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 243   /*                                                                       */</span>






 244   static FT_Error
 245   t1operator_seac( T1_Decoder  decoder,
 246                    FT_Pos      asb,
 247                    FT_Pos      adx,
 248                    FT_Pos      ady,
 249                    FT_Int      bchar,
 250                    FT_Int      achar )
 251   {
 252     FT_Error     error;
 253     FT_Int       bchar_index, achar_index;
 254 #if 0
 255     FT_Int       n_base_points;
 256     FT_Outline*  base = decoder-&gt;builder.base;
 257 #endif
 258     FT_Vector    left_bearing, advance;
 259 
 260 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 261     T1_Face      face  = (T1_Face)decoder-&gt;builder.face;
 262 #endif
 263 
</pre>
<hr />
<pre>
 382     decoder-&gt;seac = TRUE;
 383     error = t1_decoder_parse_glyph( decoder, (FT_UInt)achar_index );
 384     decoder-&gt;seac = FALSE;
 385     if ( error )
 386       goto Exit;
 387 
 388     /* restore the left side bearing and   */
 389     /* advance width of the base character */
 390 
 391     decoder-&gt;builder.left_bearing = left_bearing;
 392     decoder-&gt;builder.advance      = advance;
 393 
 394     decoder-&gt;builder.pos_x = 0;
 395     decoder-&gt;builder.pos_y = 0;
 396 
 397   Exit:
 398     return error;
 399   }
 400 
 401 
<span class="line-modified"> 402   /*************************************************************************/</span>
<span class="line-modified"> 403   /*                                                                       */</span>
<span class="line-modified"> 404   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 405   /*    t1_decoder_parse_charstrings                                       */</span>
<span class="line-modified"> 406   /*                                                                       */</span>
<span class="line-modified"> 407   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 408   /*    Parses a given Type 1 charstrings program.                         */</span>
<span class="line-modified"> 409   /*                                                                       */</span>
<span class="line-modified"> 410   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 411   /*    decoder         :: The current Type 1 decoder.                     */</span>
<span class="line-modified"> 412   /*                                                                       */</span>
<span class="line-modified"> 413   /*    charstring_base :: The base address of the charstring stream.      */</span>
<span class="line-modified"> 414   /*                                                                       */</span>
<span class="line-modified"> 415   /*    charstring_len  :: The length in bytes of the charstring stream.   */</span>
<span class="line-modified"> 416   /*                                                                       */</span>
<span class="line-modified"> 417   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 418   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 419   /*                                                                       */</span>



 420   FT_LOCAL_DEF( FT_Error )
 421   t1_decoder_parse_charstrings( T1_Decoder  decoder,
 422                                 FT_Byte*    charstring_base,
 423                                 FT_UInt     charstring_len )
 424   {
 425     FT_Error         error;
 426     T1_Decoder_Zone  zone;
 427     FT_Byte*         ip;
 428     FT_Byte*         limit;
 429     T1_Builder       builder = &amp;decoder-&gt;builder;
 430     FT_Pos           x, y, orig_x, orig_y;
 431     FT_Int           known_othersubr_result_cnt   = 0;
 432     FT_Int           unknown_othersubr_result_cnt = 0;
 433     FT_Bool          large_int;
 434     FT_Fixed         seed;
 435 
 436     T1_Hints_Funcs   hinter;
 437 
 438 #ifdef FT_DEBUG_LEVEL_TRACE
 439     FT_Bool          bol = TRUE;
</pre>
<hr />
<pre>
 449     if ( seed == 0 )
 450       seed = 0x7384;
 451 
 452     /* First of all, initialize the decoder */
 453     decoder-&gt;top  = decoder-&gt;stack;
 454     decoder-&gt;zone = decoder-&gt;zones;
 455     zone          = decoder-&gt;zones;
 456 
 457     builder-&gt;parse_state = T1_Parse_Start;
 458 
 459     hinter = (T1_Hints_Funcs)builder-&gt;hints_funcs;
 460 
 461     /* a font that reads BuildCharArray without setting */
 462     /* its values first is buggy, but ...               */
 463     FT_ASSERT( ( decoder-&gt;len_buildchar == 0 ) ==
 464                ( decoder-&gt;buildchar == NULL )  );
 465 
 466     if ( decoder-&gt;buildchar &amp;&amp; decoder-&gt;len_buildchar &gt; 0 )
 467       FT_ARRAY_ZERO( decoder-&gt;buildchar, decoder-&gt;len_buildchar );
 468 
<span class="line-removed"> 469     FT_TRACE4(( &quot;\n&quot;</span>
<span class="line-removed"> 470                 &quot;Start charstring\n&quot; ));</span>
<span class="line-removed"> 471 </span>
 472     zone-&gt;base           = charstring_base;
 473     limit = zone-&gt;limit  = charstring_base + charstring_len;
 474     ip    = zone-&gt;cursor = zone-&gt;base;
 475 
 476     error = FT_Err_Ok;
 477 
 478     x = orig_x = builder-&gt;pos_x;
 479     y = orig_y = builder-&gt;pos_y;
 480 
 481     /* begin hints recording session, if any */
 482     if ( hinter )
 483       hinter-&gt;open( hinter-&gt;hints );
 484 
 485     large_int = FALSE;
 486 
 487     /* now, execute loop */
 488     while ( ip &lt; limit )
 489     {
 490       FT_Long*     top   = decoder-&gt;top;
 491       T1_Operator  op    = op_none;
 492       FT_Int32     value = 0;
 493 
 494 
 495       FT_ASSERT( known_othersubr_result_cnt == 0   ||
 496                  unknown_othersubr_result_cnt == 0 );
 497 
 498 #ifdef FT_DEBUG_LEVEL_TRACE
 499       if ( bol )
 500       {
 501         FT_TRACE5(( &quot; (%d)&quot;, decoder-&gt;top - decoder-&gt;stack ));
 502         bol = FALSE;
 503       }
 504 #endif
 505 
<span class="line-modified"> 506       /*********************************************************************/</span>
<span class="line-modified"> 507       /*                                                                   */</span>
<span class="line-modified"> 508       /* Decode operator or operand                                        */</span>
<span class="line-modified"> 509       /*                                                                   */</span>
<span class="line-modified"> 510       /*                                                                   */</span>
 511 
 512       /* first of all, decompress operator or value */
 513       switch ( *ip++ )
 514       {
 515       case 1:
 516         op = op_hstem;
 517         break;
 518 
 519       case 3:
 520         op = op_vstem;
 521         break;
 522       case 4:
 523         op = op_vmoveto;
 524         break;
 525       case 5:
 526         op = op_rlineto;
 527         break;
 528       case 6:
 529         op = op_hlineto;
 530         break;
</pre>
<hr />
<pre>
 693         case op_return:
 694         case op_none:
 695         case op_pop:
 696           break;
 697 
 698         default:
 699           /* all operands have been transferred by previous pops */
 700           unknown_othersubr_result_cnt = 0;
 701           break;
 702         }
 703       }
 704 
 705       if ( large_int &amp;&amp; !( op == op_none || op == op_div ) )
 706       {
 707         FT_ERROR(( &quot;t1_decoder_parse_charstrings:&quot;
 708                    &quot; no `div&#39; after large integer\n&quot; ));
 709 
 710         large_int = FALSE;
 711       }
 712 
<span class="line-modified"> 713       /*********************************************************************/</span>
<span class="line-modified"> 714       /*                                                                   */</span>
<span class="line-modified"> 715       /*  Push value on stack, or process operator                         */</span>
<span class="line-modified"> 716       /*                                                                   */</span>
<span class="line-modified"> 717       /*                                                                   */</span>
 718       if ( op == op_none )
 719       {
 720         if ( top - decoder-&gt;stack &gt;= T1_MAX_CHARSTRINGS_OPERANDS )
 721         {
 722           FT_ERROR(( &quot;t1_decoder_parse_charstrings: stack overflow\n&quot; ));
 723           goto Syntax_Error;
 724         }
 725 
 726 #ifdef FT_DEBUG_LEVEL_TRACE
 727         if ( large_int )
 728           FT_TRACE4(( &quot; %d&quot;, value ));
 729         else
 730           FT_TRACE4(( &quot; %d&quot;, value / 65536 ));
 731 #endif
 732 
 733         *top++       = value;
 734         decoder-&gt;top = top;
 735       }
 736       else if ( op == op_callothersubr )  /* callothersubr */
 737       {
 738         FT_Int  subr_no;
 739         FT_Int  arg_cnt;
 740 
 741 
 742 #ifdef FT_DEBUG_LEVEL_TRACE
 743         FT_TRACE4(( &quot; callothersubr\n&quot; ));
 744         bol = TRUE;
 745 #endif
 746 
 747         if ( top - decoder-&gt;stack &lt; 2 )
 748           goto Stack_Underflow;
 749 
 750         top -= 2;
 751 
 752         subr_no = Fix2Int( top[1] );
 753         arg_cnt = Fix2Int( top[0] );
 754 
<span class="line-modified"> 755         /***********************************************************/</span>
<span class="line-modified"> 756         /*                                                         */</span>
<span class="line-modified"> 757         /* remove all operands to callothersubr from the stack     */</span>
<span class="line-modified"> 758         /*                                                         */</span>
<span class="line-modified"> 759         /* for handled othersubrs, where we know the number of     */</span>
<span class="line-modified"> 760         /* arguments, we increase the stack by the value of        */</span>
<span class="line-modified"> 761         /* known_othersubr_result_cnt                              */</span>
<span class="line-modified"> 762         /*                                                         */</span>
<span class="line-modified"> 763         /* for unhandled othersubrs the following pops adjust the  */</span>
<span class="line-modified"> 764         /* stack pointer as necessary                              */</span>

 765 
 766         if ( arg_cnt &gt; top - decoder-&gt;stack )
 767           goto Stack_Underflow;
 768 
 769         top -= arg_cnt;
 770 
 771         known_othersubr_result_cnt   = 0;
 772         unknown_othersubr_result_cnt = 0;
 773 
 774         /* XXX TODO: The checks to `arg_count == &lt;whatever&gt;&#39;       */
 775         /* might not be correct; an othersubr expects a certain    */
 776         /* number of operands on the PostScript stack (as opposed  */
 777         /* to the T1 stack) but it doesn&#39;t have to put them there  */
 778         /* by itself; previous othersubrs might have left the      */
 779         /* operands there if they were not followed by an          */
 780         /* appropriate number of pops                              */
 781         /*                                                         */
 782         /* On the other hand, Adobe Reader 7.0.8 for Linux doesn&#39;t */
 783         /* accept a font that contains charstrings like            */
 784         /*                                                         */
</pre>
<hr />
<pre>
1206         case op_hsbw:
1207           FT_TRACE4(( &quot; hsbw&quot; ));
1208 
1209           builder-&gt;parse_state = T1_Parse_Have_Width;
1210 
1211           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1212                                               top[0] );
1213 
1214           builder-&gt;advance.x = top[1];
1215           builder-&gt;advance.y = 0;
1216 
1217           orig_x = x = ADD_LONG( builder-&gt;pos_x, top[0] );
1218           orig_y = y = builder-&gt;pos_y;
1219 
1220           FT_UNUSED( orig_y );
1221 
1222           /* the `metrics_only&#39; indicates that we only want to compute */
1223           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
1224           /* rest of it; so exit immediately                           */
1225           if ( builder-&gt;metrics_only )


1226             return FT_Err_Ok;

1227 
1228           break;
1229 
1230         case op_seac:
1231           return t1operator_seac( decoder,
1232                                   top[0],
1233                                   top[1],
1234                                   top[2],
1235                                   Fix2Int( top[3] ),
1236                                   Fix2Int( top[4] ) );
1237 
1238         case op_sbw:
1239           FT_TRACE4(( &quot; sbw&quot; ));
1240 
1241           builder-&gt;parse_state = T1_Parse_Have_Width;
1242 
1243           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1244                                               top[0] );
1245           builder-&gt;left_bearing.y = ADD_LONG( builder-&gt;left_bearing.y,
1246                                               top[1] );
1247 
1248           builder-&gt;advance.x = top[2];
1249           builder-&gt;advance.y = top[3];
1250 
1251           x = ADD_LONG( builder-&gt;pos_x, top[0] );
1252           y = ADD_LONG( builder-&gt;pos_y, top[1] );
1253 
1254           /* the `metrics_only&#39; indicates that we only want to compute */
1255           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
1256           /* rest of it; so exit immediately                           */
1257           if ( builder-&gt;metrics_only )


1258             return FT_Err_Ok;

1259 
1260           break;
1261 
1262         case op_closepath:
1263           FT_TRACE4(( &quot; closepath&quot; ));
1264 
1265           /* if there is no path, `closepath&#39; is a no-op */
1266           if ( builder-&gt;parse_state == T1_Parse_Have_Path   ||
1267                builder-&gt;parse_state == T1_Parse_Have_Moveto )
1268             t1_builder_close_contour( builder );
1269 
1270           builder-&gt;parse_state = T1_Parse_Have_Width;
1271           break;
1272 
1273         case op_hlineto:
1274           FT_TRACE4(( &quot; hlineto&quot; ));
1275 
1276           if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
1277             goto Fail;
1278 
</pre>
<hr />
<pre>
1621         FT_TRACE4(( &quot;\n&quot; ));
1622         bol = TRUE;
1623 #endif
1624 
1625       } /* general operator processing */
1626 
1627     } /* while ip &lt; limit */
1628 
1629     FT_TRACE4(( &quot;..end..\n\n&quot; ));
1630 
1631   Fail:
1632     return error;
1633 
1634   Syntax_Error:
1635     return FT_THROW( Syntax_Error );
1636 
1637   Stack_Underflow:
1638     return FT_THROW( Stack_Underflow );
1639   }
1640 
<span class="line-modified">1641 #else /* T1_CONFIG_OPTION_OLD_ENGINE */</span>
<span class="line-modified">1642 </span>
<span class="line-modified">1643   /*************************************************************************/</span>
<span class="line-modified">1644   /*                                                                       */</span>
<span class="line-modified">1645   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1646   /*    t1_decoder_parse_metrics                                           */</span>
<span class="line-modified">1647   /*                                                                       */</span>
<span class="line-modified">1648   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1649   /*    Parses a given Type 1 charstrings program to extract width         */</span>
<span class="line-modified">1650   /*                                                                       */</span>
<span class="line-modified">1651   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1652   /*    decoder         :: The current Type 1 decoder.                     */</span>
<span class="line-modified">1653   /*                                                                       */</span>
<span class="line-modified">1654   /*    charstring_base :: The base address of the charstring stream.      */</span>
<span class="line-modified">1655   /*                                                                       */</span>
<span class="line-modified">1656   /*    charstring_len  :: The length in bytes of the charstring stream.   */</span>
<span class="line-modified">1657   /*                                                                       */</span>
<span class="line-modified">1658   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1659   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1660   /*                                                                       */</span>





1661   FT_LOCAL_DEF( FT_Error )
1662   t1_decoder_parse_metrics( T1_Decoder  decoder,
1663                             FT_Byte*    charstring_base,
1664                             FT_UInt     charstring_len )
1665   {
1666     T1_Decoder_Zone  zone;
1667     FT_Byte*         ip;
1668     FT_Byte*         limit;
1669     T1_Builder       builder = &amp;decoder-&gt;builder;
1670 
1671 #ifdef FT_DEBUG_LEVEL_TRACE
1672     FT_Bool          bol = TRUE;
1673 #endif
1674 
1675 
1676     /* First of all, initialize the decoder */
1677     decoder-&gt;top  = decoder-&gt;stack;
1678     decoder-&gt;zone = decoder-&gt;zones;
1679     zone          = decoder-&gt;zones;
1680 
1681     builder-&gt;parse_state = T1_Parse_Start;
1682 
<span class="line-removed">1683     FT_TRACE4(( &quot;\n&quot;</span>
<span class="line-removed">1684                 &quot;Start charstring: get width\n&quot; ));</span>
<span class="line-removed">1685 </span>
1686     zone-&gt;base           = charstring_base;
1687     limit = zone-&gt;limit  = charstring_base + charstring_len;
1688     ip    = zone-&gt;cursor = zone-&gt;base;
1689 
1690     /* now, execute loop */
1691     while ( ip &lt; limit )
1692     {
1693       FT_Long*     top   = decoder-&gt;top;
1694       T1_Operator  op    = op_none;
1695       FT_Int32     value = 0;
1696 
1697 
1698 #ifdef FT_DEBUG_LEVEL_TRACE
1699       if ( bol )
1700       {
1701         FT_TRACE5(( &quot; (%d)&quot;, decoder-&gt;top - decoder-&gt;stack ));
1702         bol = FALSE;
1703       }
1704 #endif
1705 
<span class="line-modified">1706       /*********************************************************************/</span>
<span class="line-modified">1707       /*                                                                   */</span>
<span class="line-modified">1708       /* Decode operator or operand                                        */</span>
<span class="line-modified">1709       /*                                                                   */</span>
<span class="line-modified">1710       /*                                                                   */</span>
1711 
1712       /* first of all, decompress operator or value */
1713       switch ( *ip++ )
1714       {
1715       case 1:
1716       case 3:
1717       case 4:
1718       case 5:
1719       case 6:
1720       case 7:
1721       case 8:
1722       case 9:
1723       case 10:
1724       case 11:
1725       case 14:
1726       case 15:
1727       case 21:
1728       case 22:
1729       case 30:
1730       case 31:
</pre>
<hr />
<pre>
1800                          &quot; unexpected EOF in integer\n&quot; ));
1801               goto Syntax_Error;
1802             }
1803 
1804             if ( ip[-2] &lt; 251 )
1805               value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
1806             else
1807               value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
1808           }
1809 
1810           value = (FT_Int32)( (FT_UInt32)value &lt;&lt; 16 );
1811         }
1812         else
1813         {
1814           FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1815                      &quot; invalid byte (%d)\n&quot;, ip[-1] ));
1816           goto Syntax_Error;
1817         }
1818       }
1819 
<span class="line-modified">1820       /*********************************************************************/</span>
<span class="line-modified">1821       /*                                                                   */</span>
<span class="line-modified">1822       /*  Push value on stack, or process operator                         */</span>
<span class="line-modified">1823       /*                                                                   */</span>
<span class="line-modified">1824       /*                                                                   */</span>
1825       if ( op == op_none )
1826       {
1827         if ( top - decoder-&gt;stack &gt;= T1_MAX_CHARSTRINGS_OPERANDS )
1828         {
1829           FT_ERROR(( &quot;t1_decoder_parse_metrics: stack overflow\n&quot; ));
1830           goto Syntax_Error;
1831         }
1832 
1833 #ifdef FT_DEBUG_LEVEL_TRACE
1834           FT_TRACE4(( &quot; %d&quot;, value / 65536 ));
1835 #endif
1836 
1837         *top++       = value;
1838         decoder-&gt;top = top;
1839       }
1840       else  /* general operator */
1841       {
1842         FT_Int  num_args = t1_args_count[op];
1843 
1844 
</pre>
<hr />
<pre>
1858 #endif /* FT_DEBUG_LEVEL_TRACE */
1859 
1860         top -= num_args;
1861 
1862         switch ( op )
1863         {
1864         case op_hsbw:
1865           FT_TRACE4(( &quot; hsbw&quot; ));
1866 
1867           builder-&gt;parse_state = T1_Parse_Have_Width;
1868 
1869           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1870                                               top[0] );
1871 
1872           builder-&gt;advance.x = top[1];
1873           builder-&gt;advance.y = 0;
1874 
1875           /* we only want to compute the glyph&#39;s metrics */
1876           /* (lsb + advance width), not load the rest of */
1877           /* it; so exit immediately                     */

1878           return FT_Err_Ok;
1879 
1880         case op_sbw:
1881           FT_TRACE4(( &quot; sbw&quot; ));
1882 
1883           builder-&gt;parse_state = T1_Parse_Have_Width;
1884 
1885           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1886                                               top[0] );
1887           builder-&gt;left_bearing.y = ADD_LONG( builder-&gt;left_bearing.y,
1888                                               top[1] );
1889 
1890           builder-&gt;advance.x = top[2];
1891           builder-&gt;advance.y = top[3];
1892 
1893           /* we only want to compute the glyph&#39;s metrics */
1894           /* (lsb + advance width), not load the rest of */
1895           /* it; so exit immediately                     */

1896           return FT_Err_Ok;
1897 
1898         default:
1899           FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1900                      &quot; unhandled opcode %d\n&quot;, op ));
1901           goto Syntax_Error;
1902         }
1903 
1904       } /* general operator processing */
1905 
1906     } /* while ip &lt; limit */
1907 
1908     FT_TRACE4(( &quot;..end..\n\n&quot; ));
1909 
1910   No_Width:
1911     FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1912                &quot; no width, found op %d instead\n&quot;,
1913                ip[-1] ));
1914   Syntax_Error:
1915     return FT_THROW( Syntax_Error );
1916 
1917   Stack_Underflow:
1918     return FT_THROW( Stack_Underflow );
1919   }
<span class="line-modified">1920 #endif /* T1_CONFIG_OPTION_OLD_ENGINE */</span>

1921 
1922 
1923   /* initialize T1 decoder */
1924   FT_LOCAL_DEF( FT_Error )
1925   t1_decoder_init( T1_Decoder           decoder,
1926                    FT_Face              face,
1927                    FT_Size              size,
1928                    FT_GlyphSlot         slot,
1929                    FT_Byte**            glyph_names,
1930                    PS_Blend             blend,
1931                    FT_Bool              hinting,
1932                    FT_Render_Mode       hint_mode,
1933                    T1_Decoder_Callback  parse_callback )
1934   {
1935     FT_ZERO( decoder );
1936 
<span class="line-modified">1937     /* retrieve PSNames interface from list of current modules */</span>
1938     {
1939       FT_Service_PsCMaps  psnames;
1940 
1941 
1942       FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
1943       if ( !psnames )
1944       {
1945         FT_ERROR(( &quot;t1_decoder_init:&quot;
1946                    &quot; the `psnames&#39; module is not available\n&quot; ));
1947         return FT_THROW( Unimplemented_Feature );
1948       }
1949 
1950       decoder-&gt;psnames = psnames;
1951     }
1952 
1953     t1_builder_init( &amp;decoder-&gt;builder, face, size, slot, hinting );
1954 
1955     /* decoder-&gt;buildchar and decoder-&gt;len_buildchar have to be  */
1956     /* initialized by the caller since we cannot know the length */
1957     /* of the BuildCharArray                                     */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * t1decode.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   PostScript Type 1 decoding routines (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2000-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_CALC_H
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_POSTSCRIPT_HINTS_H
  23 #include FT_INTERNAL_HASH_H
  24 #include FT_OUTLINE_H
  25 
  26 #include &quot;t1decode.h&quot;
  27 #include &quot;psobjs.h&quot;
  28 
  29 #include &quot;psauxerr.h&quot;
  30 
  31 /* ensure proper sign extension */
  32 #define Fix2Int( f )  ( (FT_Int)(FT_Short)( (f) &gt;&gt; 16 ) )
  33 
<span class="line-modified">  34   /**************************************************************************</span>
<span class="line-modified">  35    *</span>
<span class="line-modified">  36    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  37    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  38    * messages during execution.</span>
<span class="line-modified">  39    */</span>
  40 #undef  FT_COMPONENT
<span class="line-modified">  41 #define FT_COMPONENT  t1decode</span>
  42 
  43 
  44   typedef enum  T1_Operator_
  45   {
  46     op_none = 0,
  47     op_endchar,
  48     op_hsbw,
  49     op_seac,
  50     op_sbw,
  51     op_closepath,
  52     op_hlineto,
  53     op_hmoveto,
  54     op_hvcurveto,
  55     op_rlineto,
  56     op_rmoveto,
  57     op_rrcurveto,
  58     op_vhcurveto,
  59     op_vlineto,
  60     op_vmoveto,
  61     op_dotsection,
</pre>
<hr />
<pre>
  92     2, /* rmoveto */
  93     6, /* rrcurveto */
  94     4, /* vhcurveto */
  95     1, /* vlineto */
  96     1, /* vmoveto */
  97     0, /* dotsection */
  98     2, /* hstem */
  99     6, /* hstem3 */
 100     2, /* vstem */
 101     6, /* vstem3 */
 102     2, /* div */
 103    -1, /* callothersubr */
 104     1, /* callsubr */
 105     0, /* pop */
 106     0, /* return */
 107     2, /* setcurrentpoint */
 108     2  /* opcode 15 (undocumented and obsolete) */
 109   };
 110 
 111 
<span class="line-modified"> 112   /**************************************************************************</span>
<span class="line-modified"> 113    *</span>
<span class="line-modified"> 114    * @Function:</span>
<span class="line-modified"> 115    *   t1_lookup_glyph_by_stdcharcode_ps</span>
<span class="line-modified"> 116    *</span>
<span class="line-modified"> 117    * @Description:</span>
<span class="line-modified"> 118    *   Looks up a given glyph by its StandardEncoding charcode.  Used to</span>
<span class="line-modified"> 119    *   implement the SEAC Type 1 operator in the Adobe engine</span>
<span class="line-modified"> 120    *</span>
<span class="line-modified"> 121    * @Input:</span>
<span class="line-modified"> 122    *   face ::</span>
<span class="line-modified"> 123    *     The current face object.</span>
<span class="line-modified"> 124    *</span>
<span class="line-modified"> 125    *   charcode ::</span>
<span class="line-modified"> 126    *     The character code to look for.</span>
<span class="line-modified"> 127    *</span>
<span class="line-modified"> 128    * @Return:</span>
<span class="line-modified"> 129    *   A glyph index in the font face.  Returns -1 if the corresponding</span>
<span class="line-added"> 130    *   glyph wasn&#39;t found.</span>
<span class="line-added"> 131    */</span>
 132   FT_LOCAL_DEF( FT_Int )
 133   t1_lookup_glyph_by_stdcharcode_ps( PS_Decoder*  decoder,
 134                                      FT_Int       charcode )
 135   {
 136     FT_UInt             n;
 137     const FT_String*    glyph_name;
 138     FT_Service_PsCMaps  psnames = decoder-&gt;psnames;
 139 
 140 
 141     /* check range of standard char code */
 142     if ( charcode &lt; 0 || charcode &gt; 255 )
 143       return -1;
 144 
 145     glyph_name = psnames-&gt;adobe_std_strings(
 146                    psnames-&gt;adobe_std_encoding[charcode]);
 147 
 148     for ( n = 0; n &lt; decoder-&gt;num_glyphs; n++ )
 149     {
 150       FT_String*  name = (FT_String*)decoder-&gt;glyph_names[n];
 151 
 152 
 153       if ( name                               &amp;&amp;
 154            name[0] == glyph_name[0]           &amp;&amp;
 155            ft_strcmp( name, glyph_name ) == 0 )
 156         return (FT_Int)n;
 157     }
 158 
 159     return -1;
 160   }
 161 
 162 
 163 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
<span class="line-modified"> 164 </span>
<span class="line-modified"> 165   /**************************************************************************</span>
<span class="line-modified"> 166    *</span>
<span class="line-modified"> 167    * @Function:</span>
<span class="line-modified"> 168    *   t1_lookup_glyph_by_stdcharcode</span>
<span class="line-modified"> 169    *</span>
<span class="line-modified"> 170    * @Description:</span>
<span class="line-modified"> 171    *   Looks up a given glyph by its StandardEncoding charcode.  Used to</span>
<span class="line-modified"> 172    *   implement the SEAC Type 1 operator.</span>
<span class="line-modified"> 173    *</span>
<span class="line-modified"> 174    * @Input:</span>
<span class="line-modified"> 175    *   face ::</span>
<span class="line-modified"> 176    *     The current face object.</span>
<span class="line-modified"> 177    *</span>
<span class="line-modified"> 178    *   charcode ::</span>
<span class="line-modified"> 179    *     The character code to look for.</span>
<span class="line-modified"> 180    *</span>
<span class="line-modified"> 181    * @Return:</span>
<span class="line-added"> 182    *   A glyph index in the font face.  Returns -1 if the corresponding</span>
<span class="line-added"> 183    *   glyph wasn&#39;t found.</span>
<span class="line-added"> 184    */</span>
 185   static FT_Int
 186   t1_lookup_glyph_by_stdcharcode( T1_Decoder  decoder,
 187                                   FT_Int      charcode )
 188   {
 189     FT_UInt             n;
 190     const FT_String*    glyph_name;
 191     FT_Service_PsCMaps  psnames = decoder-&gt;psnames;
 192 
 193 
 194     /* check range of standard char code */
 195     if ( charcode &lt; 0 || charcode &gt; 255 )
 196       return -1;
 197 
 198     glyph_name = psnames-&gt;adobe_std_strings(
 199                    psnames-&gt;adobe_std_encoding[charcode]);
 200 
 201     for ( n = 0; n &lt; decoder-&gt;num_glyphs; n++ )
 202     {
 203       FT_String*  name = (FT_String*)decoder-&gt;glyph_names[n];
 204 
 205 
 206       if ( name                               &amp;&amp;
 207            name[0] == glyph_name[0]           &amp;&amp;
 208            ft_strcmp( name, glyph_name ) == 0 )
 209         return (FT_Int)n;
 210     }
 211 
 212     return -1;
 213   }
 214 
 215 
 216   /* parse a single Type 1 glyph */
 217   FT_LOCAL_DEF( FT_Error )
 218   t1_decoder_parse_glyph( T1_Decoder  decoder,
 219                           FT_UInt     glyph )
 220   {
 221     return decoder-&gt;parse_callback( decoder, glyph );
 222   }
 223 
 224 
<span class="line-modified"> 225   /**************************************************************************</span>
<span class="line-modified"> 226    *</span>
<span class="line-modified"> 227    * @Function:</span>
<span class="line-modified"> 228    *   t1operator_seac</span>
<span class="line-modified"> 229    *</span>
<span class="line-modified"> 230    * @Description:</span>
<span class="line-modified"> 231    *   Implements the `seac&#39; Type 1 operator for a Type 1 decoder.</span>
<span class="line-modified"> 232    *</span>
<span class="line-modified"> 233    * @Input:</span>
<span class="line-modified"> 234    *   decoder ::</span>
<span class="line-modified"> 235    *     The current CID decoder.</span>
<span class="line-modified"> 236    *</span>
<span class="line-modified"> 237    *   asb ::</span>
<span class="line-modified"> 238    *     The accent&#39;s side bearing.</span>
<span class="line-modified"> 239    *</span>
<span class="line-modified"> 240    *   adx ::</span>
<span class="line-modified"> 241    *     The horizontal offset of the accent.</span>
<span class="line-modified"> 242    *</span>
<span class="line-modified"> 243    *   ady ::</span>
<span class="line-modified"> 244    *     The vertical offset of the accent.</span>
<span class="line-modified"> 245    *</span>
<span class="line-modified"> 246    *   bchar ::</span>
<span class="line-modified"> 247    *     The base character&#39;s StandardEncoding charcode.</span>
<span class="line-modified"> 248    *</span>
<span class="line-added"> 249    *   achar ::</span>
<span class="line-added"> 250    *     The accent character&#39;s StandardEncoding charcode.</span>
<span class="line-added"> 251    *</span>
<span class="line-added"> 252    * @Return:</span>
<span class="line-added"> 253    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 254    */</span>
 255   static FT_Error
 256   t1operator_seac( T1_Decoder  decoder,
 257                    FT_Pos      asb,
 258                    FT_Pos      adx,
 259                    FT_Pos      ady,
 260                    FT_Int      bchar,
 261                    FT_Int      achar )
 262   {
 263     FT_Error     error;
 264     FT_Int       bchar_index, achar_index;
 265 #if 0
 266     FT_Int       n_base_points;
 267     FT_Outline*  base = decoder-&gt;builder.base;
 268 #endif
 269     FT_Vector    left_bearing, advance;
 270 
 271 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 272     T1_Face      face  = (T1_Face)decoder-&gt;builder.face;
 273 #endif
 274 
</pre>
<hr />
<pre>
 393     decoder-&gt;seac = TRUE;
 394     error = t1_decoder_parse_glyph( decoder, (FT_UInt)achar_index );
 395     decoder-&gt;seac = FALSE;
 396     if ( error )
 397       goto Exit;
 398 
 399     /* restore the left side bearing and   */
 400     /* advance width of the base character */
 401 
 402     decoder-&gt;builder.left_bearing = left_bearing;
 403     decoder-&gt;builder.advance      = advance;
 404 
 405     decoder-&gt;builder.pos_x = 0;
 406     decoder-&gt;builder.pos_y = 0;
 407 
 408   Exit:
 409     return error;
 410   }
 411 
 412 
<span class="line-modified"> 413   /**************************************************************************</span>
<span class="line-modified"> 414    *</span>
<span class="line-modified"> 415    * @Function:</span>
<span class="line-modified"> 416    *   t1_decoder_parse_charstrings</span>
<span class="line-modified"> 417    *</span>
<span class="line-modified"> 418    * @Description:</span>
<span class="line-modified"> 419    *   Parses a given Type 1 charstrings program.</span>
<span class="line-modified"> 420    *</span>
<span class="line-modified"> 421    * @Input:</span>
<span class="line-modified"> 422    *   decoder ::</span>
<span class="line-modified"> 423    *     The current Type 1 decoder.</span>
<span class="line-modified"> 424    *</span>
<span class="line-modified"> 425    *   charstring_base ::</span>
<span class="line-modified"> 426    *     The base address of the charstring stream.</span>
<span class="line-modified"> 427    *</span>
<span class="line-modified"> 428    *   charstring_len ::</span>
<span class="line-modified"> 429    *     The length in bytes of the charstring stream.</span>
<span class="line-modified"> 430    *</span>
<span class="line-added"> 431    * @Return:</span>
<span class="line-added"> 432    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 433    */</span>
 434   FT_LOCAL_DEF( FT_Error )
 435   t1_decoder_parse_charstrings( T1_Decoder  decoder,
 436                                 FT_Byte*    charstring_base,
 437                                 FT_UInt     charstring_len )
 438   {
 439     FT_Error         error;
 440     T1_Decoder_Zone  zone;
 441     FT_Byte*         ip;
 442     FT_Byte*         limit;
 443     T1_Builder       builder = &amp;decoder-&gt;builder;
 444     FT_Pos           x, y, orig_x, orig_y;
 445     FT_Int           known_othersubr_result_cnt   = 0;
 446     FT_Int           unknown_othersubr_result_cnt = 0;
 447     FT_Bool          large_int;
 448     FT_Fixed         seed;
 449 
 450     T1_Hints_Funcs   hinter;
 451 
 452 #ifdef FT_DEBUG_LEVEL_TRACE
 453     FT_Bool          bol = TRUE;
</pre>
<hr />
<pre>
 463     if ( seed == 0 )
 464       seed = 0x7384;
 465 
 466     /* First of all, initialize the decoder */
 467     decoder-&gt;top  = decoder-&gt;stack;
 468     decoder-&gt;zone = decoder-&gt;zones;
 469     zone          = decoder-&gt;zones;
 470 
 471     builder-&gt;parse_state = T1_Parse_Start;
 472 
 473     hinter = (T1_Hints_Funcs)builder-&gt;hints_funcs;
 474 
 475     /* a font that reads BuildCharArray without setting */
 476     /* its values first is buggy, but ...               */
 477     FT_ASSERT( ( decoder-&gt;len_buildchar == 0 ) ==
 478                ( decoder-&gt;buildchar == NULL )  );
 479 
 480     if ( decoder-&gt;buildchar &amp;&amp; decoder-&gt;len_buildchar &gt; 0 )
 481       FT_ARRAY_ZERO( decoder-&gt;buildchar, decoder-&gt;len_buildchar );
 482 



 483     zone-&gt;base           = charstring_base;
 484     limit = zone-&gt;limit  = charstring_base + charstring_len;
 485     ip    = zone-&gt;cursor = zone-&gt;base;
 486 
 487     error = FT_Err_Ok;
 488 
 489     x = orig_x = builder-&gt;pos_x;
 490     y = orig_y = builder-&gt;pos_y;
 491 
 492     /* begin hints recording session, if any */
 493     if ( hinter )
 494       hinter-&gt;open( hinter-&gt;hints );
 495 
 496     large_int = FALSE;
 497 
 498     /* now, execute loop */
 499     while ( ip &lt; limit )
 500     {
 501       FT_Long*     top   = decoder-&gt;top;
 502       T1_Operator  op    = op_none;
 503       FT_Int32     value = 0;
 504 
 505 
 506       FT_ASSERT( known_othersubr_result_cnt == 0   ||
 507                  unknown_othersubr_result_cnt == 0 );
 508 
 509 #ifdef FT_DEBUG_LEVEL_TRACE
 510       if ( bol )
 511       {
 512         FT_TRACE5(( &quot; (%d)&quot;, decoder-&gt;top - decoder-&gt;stack ));
 513         bol = FALSE;
 514       }
 515 #endif
 516 
<span class="line-modified"> 517       /**********************************************************************</span>
<span class="line-modified"> 518        *</span>
<span class="line-modified"> 519        * Decode operator or operand</span>
<span class="line-modified"> 520        *</span>
<span class="line-modified"> 521        */</span>
 522 
 523       /* first of all, decompress operator or value */
 524       switch ( *ip++ )
 525       {
 526       case 1:
 527         op = op_hstem;
 528         break;
 529 
 530       case 3:
 531         op = op_vstem;
 532         break;
 533       case 4:
 534         op = op_vmoveto;
 535         break;
 536       case 5:
 537         op = op_rlineto;
 538         break;
 539       case 6:
 540         op = op_hlineto;
 541         break;
</pre>
<hr />
<pre>
 704         case op_return:
 705         case op_none:
 706         case op_pop:
 707           break;
 708 
 709         default:
 710           /* all operands have been transferred by previous pops */
 711           unknown_othersubr_result_cnt = 0;
 712           break;
 713         }
 714       }
 715 
 716       if ( large_int &amp;&amp; !( op == op_none || op == op_div ) )
 717       {
 718         FT_ERROR(( &quot;t1_decoder_parse_charstrings:&quot;
 719                    &quot; no `div&#39; after large integer\n&quot; ));
 720 
 721         large_int = FALSE;
 722       }
 723 
<span class="line-modified"> 724       /**********************************************************************</span>
<span class="line-modified"> 725        *</span>
<span class="line-modified"> 726        * Push value on stack, or process operator</span>
<span class="line-modified"> 727        *</span>
<span class="line-modified"> 728        */</span>
 729       if ( op == op_none )
 730       {
 731         if ( top - decoder-&gt;stack &gt;= T1_MAX_CHARSTRINGS_OPERANDS )
 732         {
 733           FT_ERROR(( &quot;t1_decoder_parse_charstrings: stack overflow\n&quot; ));
 734           goto Syntax_Error;
 735         }
 736 
 737 #ifdef FT_DEBUG_LEVEL_TRACE
 738         if ( large_int )
 739           FT_TRACE4(( &quot; %d&quot;, value ));
 740         else
 741           FT_TRACE4(( &quot; %d&quot;, value / 65536 ));
 742 #endif
 743 
 744         *top++       = value;
 745         decoder-&gt;top = top;
 746       }
 747       else if ( op == op_callothersubr )  /* callothersubr */
 748       {
 749         FT_Int  subr_no;
 750         FT_Int  arg_cnt;
 751 
 752 
 753 #ifdef FT_DEBUG_LEVEL_TRACE
 754         FT_TRACE4(( &quot; callothersubr\n&quot; ));
 755         bol = TRUE;
 756 #endif
 757 
 758         if ( top - decoder-&gt;stack &lt; 2 )
 759           goto Stack_Underflow;
 760 
 761         top -= 2;
 762 
 763         subr_no = Fix2Int( top[1] );
 764         arg_cnt = Fix2Int( top[0] );
 765 
<span class="line-modified"> 766         /************************************************************</span>
<span class="line-modified"> 767          *</span>
<span class="line-modified"> 768          * remove all operands to callothersubr from the stack</span>
<span class="line-modified"> 769          *</span>
<span class="line-modified"> 770          * for handled othersubrs, where we know the number of</span>
<span class="line-modified"> 771          * arguments, we increase the stack by the value of</span>
<span class="line-modified"> 772          * known_othersubr_result_cnt</span>
<span class="line-modified"> 773          *</span>
<span class="line-modified"> 774          * for unhandled othersubrs the following pops adjust the</span>
<span class="line-modified"> 775          * stack pointer as necessary</span>
<span class="line-added"> 776          */</span>
 777 
 778         if ( arg_cnt &gt; top - decoder-&gt;stack )
 779           goto Stack_Underflow;
 780 
 781         top -= arg_cnt;
 782 
 783         known_othersubr_result_cnt   = 0;
 784         unknown_othersubr_result_cnt = 0;
 785 
 786         /* XXX TODO: The checks to `arg_count == &lt;whatever&gt;&#39;       */
 787         /* might not be correct; an othersubr expects a certain    */
 788         /* number of operands on the PostScript stack (as opposed  */
 789         /* to the T1 stack) but it doesn&#39;t have to put them there  */
 790         /* by itself; previous othersubrs might have left the      */
 791         /* operands there if they were not followed by an          */
 792         /* appropriate number of pops                              */
 793         /*                                                         */
 794         /* On the other hand, Adobe Reader 7.0.8 for Linux doesn&#39;t */
 795         /* accept a font that contains charstrings like            */
 796         /*                                                         */
</pre>
<hr />
<pre>
1218         case op_hsbw:
1219           FT_TRACE4(( &quot; hsbw&quot; ));
1220 
1221           builder-&gt;parse_state = T1_Parse_Have_Width;
1222 
1223           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1224                                               top[0] );
1225 
1226           builder-&gt;advance.x = top[1];
1227           builder-&gt;advance.y = 0;
1228 
1229           orig_x = x = ADD_LONG( builder-&gt;pos_x, top[0] );
1230           orig_y = y = builder-&gt;pos_y;
1231 
1232           FT_UNUSED( orig_y );
1233 
1234           /* the `metrics_only&#39; indicates that we only want to compute */
1235           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
1236           /* rest of it; so exit immediately                           */
1237           if ( builder-&gt;metrics_only )
<span class="line-added">1238           {</span>
<span class="line-added">1239             FT_TRACE4(( &quot;\n&quot; ));</span>
1240             return FT_Err_Ok;
<span class="line-added">1241           }</span>
1242 
1243           break;
1244 
1245         case op_seac:
1246           return t1operator_seac( decoder,
1247                                   top[0],
1248                                   top[1],
1249                                   top[2],
1250                                   Fix2Int( top[3] ),
1251                                   Fix2Int( top[4] ) );
1252 
1253         case op_sbw:
1254           FT_TRACE4(( &quot; sbw&quot; ));
1255 
1256           builder-&gt;parse_state = T1_Parse_Have_Width;
1257 
1258           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1259                                               top[0] );
1260           builder-&gt;left_bearing.y = ADD_LONG( builder-&gt;left_bearing.y,
1261                                               top[1] );
1262 
1263           builder-&gt;advance.x = top[2];
1264           builder-&gt;advance.y = top[3];
1265 
1266           x = ADD_LONG( builder-&gt;pos_x, top[0] );
1267           y = ADD_LONG( builder-&gt;pos_y, top[1] );
1268 
1269           /* the `metrics_only&#39; indicates that we only want to compute */
1270           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
1271           /* rest of it; so exit immediately                           */
1272           if ( builder-&gt;metrics_only )
<span class="line-added">1273           {</span>
<span class="line-added">1274             FT_TRACE4(( &quot;\n&quot; ));</span>
1275             return FT_Err_Ok;
<span class="line-added">1276           }</span>
1277 
1278           break;
1279 
1280         case op_closepath:
1281           FT_TRACE4(( &quot; closepath&quot; ));
1282 
1283           /* if there is no path, `closepath&#39; is a no-op */
1284           if ( builder-&gt;parse_state == T1_Parse_Have_Path   ||
1285                builder-&gt;parse_state == T1_Parse_Have_Moveto )
1286             t1_builder_close_contour( builder );
1287 
1288           builder-&gt;parse_state = T1_Parse_Have_Width;
1289           break;
1290 
1291         case op_hlineto:
1292           FT_TRACE4(( &quot; hlineto&quot; ));
1293 
1294           if ( FT_SET_ERROR( t1_builder_start_point( builder, x, y ) ) )
1295             goto Fail;
1296 
</pre>
<hr />
<pre>
1639         FT_TRACE4(( &quot;\n&quot; ));
1640         bol = TRUE;
1641 #endif
1642 
1643       } /* general operator processing */
1644 
1645     } /* while ip &lt; limit */
1646 
1647     FT_TRACE4(( &quot;..end..\n\n&quot; ));
1648 
1649   Fail:
1650     return error;
1651 
1652   Syntax_Error:
1653     return FT_THROW( Syntax_Error );
1654 
1655   Stack_Underflow:
1656     return FT_THROW( Stack_Underflow );
1657   }
1658 
<span class="line-modified">1659 </span>
<span class="line-modified">1660 #else /* !T1_CONFIG_OPTION_OLD_ENGINE */</span>
<span class="line-modified">1661 </span>
<span class="line-modified">1662 </span>
<span class="line-modified">1663   /**************************************************************************</span>
<span class="line-modified">1664    *</span>
<span class="line-modified">1665    * @Function:</span>
<span class="line-modified">1666    *   t1_decoder_parse_metrics</span>
<span class="line-modified">1667    *</span>
<span class="line-modified">1668    * @Description:</span>
<span class="line-modified">1669    *   Parses a given Type 1 charstrings program to extract width</span>
<span class="line-modified">1670    *</span>
<span class="line-modified">1671    * @Input:</span>
<span class="line-modified">1672    *   decoder ::</span>
<span class="line-modified">1673    *     The current Type 1 decoder.</span>
<span class="line-modified">1674    *</span>
<span class="line-modified">1675    *   charstring_base ::</span>
<span class="line-modified">1676    *     The base address of the charstring stream.</span>
<span class="line-modified">1677    *</span>
<span class="line-modified">1678    *   charstring_len ::</span>
<span class="line-added">1679    *     The length in bytes of the charstring stream.</span>
<span class="line-added">1680    *</span>
<span class="line-added">1681    * @Return:</span>
<span class="line-added">1682    *   FreeType error code.  0 means success.</span>
<span class="line-added">1683    */</span>
1684   FT_LOCAL_DEF( FT_Error )
1685   t1_decoder_parse_metrics( T1_Decoder  decoder,
1686                             FT_Byte*    charstring_base,
1687                             FT_UInt     charstring_len )
1688   {
1689     T1_Decoder_Zone  zone;
1690     FT_Byte*         ip;
1691     FT_Byte*         limit;
1692     T1_Builder       builder = &amp;decoder-&gt;builder;
1693 
1694 #ifdef FT_DEBUG_LEVEL_TRACE
1695     FT_Bool          bol = TRUE;
1696 #endif
1697 
1698 
1699     /* First of all, initialize the decoder */
1700     decoder-&gt;top  = decoder-&gt;stack;
1701     decoder-&gt;zone = decoder-&gt;zones;
1702     zone          = decoder-&gt;zones;
1703 
1704     builder-&gt;parse_state = T1_Parse_Start;
1705 



1706     zone-&gt;base           = charstring_base;
1707     limit = zone-&gt;limit  = charstring_base + charstring_len;
1708     ip    = zone-&gt;cursor = zone-&gt;base;
1709 
1710     /* now, execute loop */
1711     while ( ip &lt; limit )
1712     {
1713       FT_Long*     top   = decoder-&gt;top;
1714       T1_Operator  op    = op_none;
1715       FT_Int32     value = 0;
1716 
1717 
1718 #ifdef FT_DEBUG_LEVEL_TRACE
1719       if ( bol )
1720       {
1721         FT_TRACE5(( &quot; (%d)&quot;, decoder-&gt;top - decoder-&gt;stack ));
1722         bol = FALSE;
1723       }
1724 #endif
1725 
<span class="line-modified">1726       /**********************************************************************</span>
<span class="line-modified">1727        *</span>
<span class="line-modified">1728        * Decode operator or operand</span>
<span class="line-modified">1729        *</span>
<span class="line-modified">1730        */</span>
1731 
1732       /* first of all, decompress operator or value */
1733       switch ( *ip++ )
1734       {
1735       case 1:
1736       case 3:
1737       case 4:
1738       case 5:
1739       case 6:
1740       case 7:
1741       case 8:
1742       case 9:
1743       case 10:
1744       case 11:
1745       case 14:
1746       case 15:
1747       case 21:
1748       case 22:
1749       case 30:
1750       case 31:
</pre>
<hr />
<pre>
1820                          &quot; unexpected EOF in integer\n&quot; ));
1821               goto Syntax_Error;
1822             }
1823 
1824             if ( ip[-2] &lt; 251 )
1825               value =    ( ( ip[-2] - 247 ) * 256 ) + ip[-1] + 108;
1826             else
1827               value = -( ( ( ip[-2] - 251 ) * 256 ) + ip[-1] + 108 );
1828           }
1829 
1830           value = (FT_Int32)( (FT_UInt32)value &lt;&lt; 16 );
1831         }
1832         else
1833         {
1834           FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1835                      &quot; invalid byte (%d)\n&quot;, ip[-1] ));
1836           goto Syntax_Error;
1837         }
1838       }
1839 
<span class="line-modified">1840       /**********************************************************************</span>
<span class="line-modified">1841        *</span>
<span class="line-modified">1842        * Push value on stack, or process operator</span>
<span class="line-modified">1843        *</span>
<span class="line-modified">1844        */</span>
1845       if ( op == op_none )
1846       {
1847         if ( top - decoder-&gt;stack &gt;= T1_MAX_CHARSTRINGS_OPERANDS )
1848         {
1849           FT_ERROR(( &quot;t1_decoder_parse_metrics: stack overflow\n&quot; ));
1850           goto Syntax_Error;
1851         }
1852 
1853 #ifdef FT_DEBUG_LEVEL_TRACE
1854           FT_TRACE4(( &quot; %d&quot;, value / 65536 ));
1855 #endif
1856 
1857         *top++       = value;
1858         decoder-&gt;top = top;
1859       }
1860       else  /* general operator */
1861       {
1862         FT_Int  num_args = t1_args_count[op];
1863 
1864 
</pre>
<hr />
<pre>
1878 #endif /* FT_DEBUG_LEVEL_TRACE */
1879 
1880         top -= num_args;
1881 
1882         switch ( op )
1883         {
1884         case op_hsbw:
1885           FT_TRACE4(( &quot; hsbw&quot; ));
1886 
1887           builder-&gt;parse_state = T1_Parse_Have_Width;
1888 
1889           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1890                                               top[0] );
1891 
1892           builder-&gt;advance.x = top[1];
1893           builder-&gt;advance.y = 0;
1894 
1895           /* we only want to compute the glyph&#39;s metrics */
1896           /* (lsb + advance width), not load the rest of */
1897           /* it; so exit immediately                     */
<span class="line-added">1898           FT_TRACE4(( &quot;\n&quot; ));</span>
1899           return FT_Err_Ok;
1900 
1901         case op_sbw:
1902           FT_TRACE4(( &quot; sbw&quot; ));
1903 
1904           builder-&gt;parse_state = T1_Parse_Have_Width;
1905 
1906           builder-&gt;left_bearing.x = ADD_LONG( builder-&gt;left_bearing.x,
1907                                               top[0] );
1908           builder-&gt;left_bearing.y = ADD_LONG( builder-&gt;left_bearing.y,
1909                                               top[1] );
1910 
1911           builder-&gt;advance.x = top[2];
1912           builder-&gt;advance.y = top[3];
1913 
1914           /* we only want to compute the glyph&#39;s metrics */
1915           /* (lsb + advance width), not load the rest of */
1916           /* it; so exit immediately                     */
<span class="line-added">1917           FT_TRACE4(( &quot;\n&quot; ));</span>
1918           return FT_Err_Ok;
1919 
1920         default:
1921           FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1922                      &quot; unhandled opcode %d\n&quot;, op ));
1923           goto Syntax_Error;
1924         }
1925 
1926       } /* general operator processing */
1927 
1928     } /* while ip &lt; limit */
1929 
1930     FT_TRACE4(( &quot;..end..\n\n&quot; ));
1931 
1932   No_Width:
1933     FT_ERROR(( &quot;t1_decoder_parse_metrics:&quot;
1934                &quot; no width, found op %d instead\n&quot;,
1935                ip[-1] ));
1936   Syntax_Error:
1937     return FT_THROW( Syntax_Error );
1938 
1939   Stack_Underflow:
1940     return FT_THROW( Stack_Underflow );
1941   }
<span class="line-modified">1942 </span>
<span class="line-added">1943 #endif /* !T1_CONFIG_OPTION_OLD_ENGINE */</span>
1944 
1945 
1946   /* initialize T1 decoder */
1947   FT_LOCAL_DEF( FT_Error )
1948   t1_decoder_init( T1_Decoder           decoder,
1949                    FT_Face              face,
1950                    FT_Size              size,
1951                    FT_GlyphSlot         slot,
1952                    FT_Byte**            glyph_names,
1953                    PS_Blend             blend,
1954                    FT_Bool              hinting,
1955                    FT_Render_Mode       hint_mode,
1956                    T1_Decoder_Callback  parse_callback )
1957   {
1958     FT_ZERO( decoder );
1959 
<span class="line-modified">1960     /* retrieve `psnames&#39; interface from list of current modules */</span>
1961     {
1962       FT_Service_PsCMaps  psnames;
1963 
1964 
1965       FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
1966       if ( !psnames )
1967       {
1968         FT_ERROR(( &quot;t1_decoder_init:&quot;
1969                    &quot; the `psnames&#39; module is not available\n&quot; ));
1970         return FT_THROW( Unimplemented_Feature );
1971       }
1972 
1973       decoder-&gt;psnames = psnames;
1974     }
1975 
1976     t1_builder_init( &amp;decoder-&gt;builder, face, size, slot, hinting );
1977 
1978     /* decoder-&gt;buildchar and decoder-&gt;len_buildchar have to be  */
1979     /* initialized by the caller since we cannot know the length */
1980     /* of the BuildCharArray                                     */
</pre>
</td>
</tr>
</table>
<center><a href="t1cmap.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1decode.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
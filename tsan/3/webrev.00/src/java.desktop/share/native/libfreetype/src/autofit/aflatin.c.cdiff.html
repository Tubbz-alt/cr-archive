<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afindic.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="aflatin.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,46 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  aflatin.c                                                              */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Auto-fitter hinting routines for latin writing system (body).        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_ADVANCES_H
  #include FT_INTERNAL_DEBUG_H
  
  #include &quot;afglobal.h&quot;
<span class="line-removed">- #include &quot;afpic.h&quot;</span>
  #include &quot;aflatin.h&quot;
  #include &quot;aferrors.h&quot;
  
  
  #ifdef AF_CONFIG_OPTION_USE_WARPER
  #include &quot;afwarp.h&quot;
  #endif
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_aflatin</span>
  
  
    /* needed for computation of round vs. flat segments */
  #define FLAT_THRESHOLD( x )  ( x / 14 )
  
<span class="line-new-header">--- 1,45 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * aflatin.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Auto-fitter hinting routines for latin writing system (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_ADVANCES_H
  #include FT_INTERNAL_DEBUG_H
  
  #include &quot;afglobal.h&quot;
  #include &quot;aflatin.h&quot;
  #include &quot;aferrors.h&quot;
  
  
  #ifdef AF_CONFIG_OPTION_USE_WARPER
  #include &quot;afwarp.h&quot;
  #endif
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  aflatin</span>
  
  
    /* needed for computation of round vs. flat segments */
  #define FLAT_THRESHOLD( x )  ( x / 14 )
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,28 ***</span>
        FT_ULong            glyph_index;
        int                 dim;
        AF_LatinMetricsRec  dummy[1];
        AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
        AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">!       AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-modified">!                                        [style_class-&gt;script];</span>
  
<span class="line-removed">-       void*        shaper_buf;</span>
        const char*  p;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_ULong  ch = 0;
  #endif
  
<span class="line-removed">-       p          = script_class-&gt;standard_charstring;</span>
<span class="line-removed">-       shaper_buf = af_shaper_buf_create( face );</span>
  
        /*
         * We check a list of standard characters to catch features like
         * `c2sc&#39; (small caps from caps) that don&#39;t contain lowercase letters
         * by definition, or other features that mainly operate on numerals.
         * The first match wins.
<span class="line-new-header">--- 80,34 ---</span>
        FT_ULong            glyph_index;
        int                 dim;
        AF_LatinMetricsRec  dummy[1];
        AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;
  
        AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">!       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="line-modified">! </span>
<span class="line-added">+       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+       /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+       void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+       FT_ULong  shaper_buf_;</span>
<span class="line-added">+       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
        const char*  p;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_ULong  ch = 0;
  #endif
  
  
<span class="line-added">+       p = script_class-&gt;standard_charstring;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+       shaper_buf = af_shaper_buf_create( face );</span>
<span class="line-added">+ #endif</span>
        /*
         * We check a list of standard characters to catch features like
         * `c2sc&#39; (small caps from caps) that don&#39;t contain lowercase letters
         * by definition, or other features that mainly operate on numerals.
         * The first match wins.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,11 ***</span>
<span class="line-new-header">--- 147,15 ---</span>
        }
  
        af_shaper_buf_destroy( face, shaper_buf );
  
        if ( !glyph_index )
<span class="line-added">+       {</span>
<span class="line-added">+         FT_TRACE5(( &quot;standard character missing;&quot;</span>
<span class="line-added">+                     &quot; using fallback stem widths\n&quot; ));</span>
          goto Exit;
<span class="line-added">+       }</span>
  
        FT_TRACE5(( &quot;standard character: U+%04lX (glyph index %d)\n&quot;,
                    ch, glyph_index ));
  
        error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 184,14 ***</span>
                                                   (AF_Dimension)dim );
          if ( error )
            goto Exit;
  
          /*
<span class="line-modified">!          *  We assume that the glyphs selected for the stem width</span>
<span class="line-modified">!          *  computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified">!          *  algorithm works fine without adjustments of its scoring</span>
<span class="line-modified">!          *  function.</span>
           */
          af_latin_hints_link_segments( hints,
                                        0,
                                        NULL,
                                        (AF_Dimension)dim );
<span class="line-new-header">--- 193,14 ---</span>
                                                   (AF_Dimension)dim );
          if ( error )
            goto Exit;
  
          /*
<span class="line-modified">!          * We assume that the glyphs selected for the stem width</span>
<span class="line-modified">!          * computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified">!          * algorithm works fine without adjustments of its scoring</span>
<span class="line-modified">!          * function.</span>
           */
          af_latin_hints_link_segments( hints,
                                        0,
                                        NULL,
                                        (AF_Dimension)dim );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,11 ***</span>
  
  
    /* Find all blue zones.  Flat segments give the reference points, */
    /* round segments the overshoot positions.                        */
  
<span class="line-modified">!   static void</span>
    af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
                                 FT_Face          face )
    {
      FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
      FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
<span class="line-new-header">--- 314,11 ---</span>
  
  
    /* Find all blue zones.  Flat segments give the reference points, */
    /* round segments the overshoot positions.                        */
  
<span class="line-modified">!   static int</span>
    af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
                                 FT_Face          face )
    {
      FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
      FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,21 ***</span>
      AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
      const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
  
      FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
  
<span class="line-modified">!     void*  shaper_buf;</span>
  
  
      /* we walk over the blue character strings as specified in the */
      /* style&#39;s entry in the `af_blue_stringset&#39; array              */
  
      FT_TRACE5(( &quot;latin blue zones computation\n&quot;
                  &quot;============================\n&quot;
                  &quot;\n&quot; ));
  
      shaper_buf = af_shaper_buf_create( face );
  
      for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char*  p = &amp;af_blue_strings[bs-&gt;string];
        FT_Pos*      blue_ref;
<span class="line-new-header">--- 336,30 ---</span>
      AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
      const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
  
      FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
  
<span class="line-modified">!     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+     /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+     void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     FT_ULong  shaper_buf_;</span>
<span class="line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
  
      /* we walk over the blue character strings as specified in the */
      /* style&#39;s entry in the `af_blue_stringset&#39; array              */
  
      FT_TRACE5(( &quot;latin blue zones computation\n&quot;
                  &quot;============================\n&quot;
                  &quot;\n&quot; ));
  
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="line-added">+ #endif</span>
  
      for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char*  p = &amp;af_blue_strings[bs-&gt;string];
        FT_Pos*      blue_ref;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 882,12 ***</span>
        } /* end while loop */
  
        if ( num_flats == 0 &amp;&amp; num_rounds == 0 )
        {
          /*
<span class="line-modified">!          *  we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified">!          *  we will simply ignore it then</span>
           */
          FT_TRACE5(( &quot;  empty\n&quot; ));
          continue;
        }
  
<span class="line-new-header">--- 900,12 ---</span>
        } /* end while loop */
  
        if ( num_flats == 0 &amp;&amp; num_rounds == 0 )
        {
          /*
<span class="line-modified">!          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified">!          * we will simply ignore it then</span>
           */
          FT_TRACE5(( &quot;  empty\n&quot; ));
          continue;
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,14 ***</span>
  
      } /* end for loop */
  
      af_shaper_buf_destroy( face, shaper_buf );
  
<span class="line-removed">-     /* we finally check whether blue zones are ordered; */</span>
<span class="line-removed">-     /* `ref&#39; and `shoot&#39; values of two blue zones must not overlap */</span>
      if ( axis-&gt;blue_count )
      {
        FT_UInt       i;
        AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
  
  
        for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
<span class="line-new-header">--- 983,15 ---</span>
  
      } /* end for loop */
  
      af_shaper_buf_destroy( face, shaper_buf );
  
      if ( axis-&gt;blue_count )
      {
<span class="line-added">+       /* we finally check whether blue zones are ordered;            */</span>
<span class="line-added">+       /* `ref&#39; and `shoot&#39; values of two blue zones must not overlap */</span>
<span class="line-added">+ </span>
        FT_UInt       i;
        AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
  
  
        for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1017,15 ***</span>
                        a_is_top ? &quot;overshoot&quot; : &quot;reference&quot;,
                        blue_sorted[i] - axis-&gt;blues,
                        *a ));
          }
        }
      }
  
<span class="line-modified">!     FT_TRACE5(( &quot;\n&quot; ));</span>
  
<span class="line-modified">!     return;</span>
    }
  
  
    /* Check whether all ASCII digits have the same advance width. */
  
<span class="line-new-header">--- 1036,38 ---</span>
                        a_is_top ? &quot;overshoot&quot; : &quot;reference&quot;,
                        blue_sorted[i] - axis-&gt;blues,
                        *a ));
          }
        }
<span class="line-added">+ </span>
<span class="line-added">+       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">+ </span>
<span class="line-added">+       return 0;</span>
      }
<span class="line-added">+     else</span>
<span class="line-added">+     {</span>
<span class="line-added">+       /* disable hinting for the current style if there are no blue zones */</span>
  
<span class="line-modified">!       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-added">+       FT_UShort*      gstyles = globals-&gt;glyph_styles;</span>
<span class="line-added">+ </span>
<span class="line-added">+       FT_Long  i;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+       FT_TRACE5(( &quot;no blue zones found:&quot;</span>
<span class="line-added">+                   &quot; hinting disabled for this style\n&quot; ));</span>
<span class="line-added">+ </span>
<span class="line-added">+       for ( i = 0; i &lt; globals-&gt;glyph_count; i++ )</span>
<span class="line-added">+       {</span>
<span class="line-added">+         if ( ( gstyles[i] &amp; AF_STYLE_MASK ) == sc-&gt;style )</span>
<span class="line-added">+           gstyles[i] = AF_STYLE_NONE_DFLT;</span>
<span class="line-added">+       }</span>
  
<span class="line-modified">!       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">+ </span>
<span class="line-added">+       return 1;</span>
<span class="line-added">+     }</span>
    }
  
  
    /* Check whether all ASCII digits have the same advance width. */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1034,19 ***</span>
                                   FT_Face          face )
    {
      FT_Bool   started = 0, same_width = 1;
      FT_Fixed  advance = 0, old_advance = 0;
  
<span class="line-modified">!     void*  shaper_buf;</span>
  
      /* in all supported charmaps, digits have character codes 0x30-0x39 */
      const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
      const char*  p;
  
  
<span class="line-modified">!     p          = digits;</span>
      shaper_buf = af_shaper_buf_create( face );
  
      while ( *p )
      {
        FT_ULong      glyph_index;
        unsigned int  num_idx;
<span class="line-new-header">--- 1076,29 ---</span>
                                   FT_Face          face )
    {
      FT_Bool   started = 0, same_width = 1;
      FT_Fixed  advance = 0, old_advance = 0;
  
<span class="line-modified">!     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+     /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+     void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     FT_ULong  shaper_buf_;</span>
<span class="line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
      /* in all supported charmaps, digits have character codes 0x30-0x39 */
      const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
      const char*  p;
  
  
<span class="line-modified">!     p = digits;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="line-added">+ #endif</span>
  
      while ( *p )
      {
        FT_ULong      glyph_index;
        unsigned int  num_idx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1090,24 ***</span>
  
    FT_LOCAL_DEF( FT_Error )
    af_latin_metrics_init( AF_LatinMetrics  metrics,
                           FT_Face          face )
    {
      FT_CharMap  oldmap = face-&gt;charmap;
  
  
      metrics-&gt;units_per_em = face-&gt;units_per_EM;
  
      if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
      {
        af_latin_metrics_init_widths( metrics, face );
<span class="line-modified">!       af_latin_metrics_init_blues( metrics, face );</span>
        af_latin_metrics_check_digits( metrics, face );
      }
  
      FT_Set_Charmap( face, oldmap );
<span class="line-modified">!     return FT_Err_Ok;</span>
    }
  
  
    /* Adjust scaling value, then scale and shift widths   */
    /* and blue zones (if applicable) for given dimension. */
<span class="line-new-header">--- 1142,32 ---</span>
  
    FT_LOCAL_DEF( FT_Error )
    af_latin_metrics_init( AF_LatinMetrics  metrics,
                           FT_Face          face )
    {
<span class="line-added">+     FT_Error  error = FT_Err_Ok;</span>
<span class="line-added">+ </span>
      FT_CharMap  oldmap = face-&gt;charmap;
  
  
      metrics-&gt;units_per_em = face-&gt;units_per_EM;
  
      if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
      {
        af_latin_metrics_init_widths( metrics, face );
<span class="line-modified">!       if ( af_latin_metrics_init_blues( metrics, face ) )</span>
<span class="line-added">+       {</span>
<span class="line-added">+         /* use internal error code to indicate missing blue zones */</span>
<span class="line-added">+         error = -1;</span>
<span class="line-added">+         goto Exit;</span>
<span class="line-added">+       }</span>
        af_latin_metrics_check_digits( metrics, face );
      }
  
<span class="line-added">+   Exit:</span>
      FT_Set_Charmap( face, oldmap );
<span class="line-modified">!     return error;</span>
    }
  
  
    /* Adjust scaling value, then scale and shift widths   */
    /* and blue zones (if applicable) for given dimension. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1281,11 ***</span>
      FT_TRACE5(( &quot;\n&quot; ));
  
      /* an extra-light axis corresponds to a standard width that is */
      /* smaller than 5/8 pixels                                     */
      axis-&gt;extra_light =
<span class="line-modified">!       (FT_Bool)( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
      if ( axis-&gt;extra_light )
        FT_TRACE5(( &quot;`%s&#39; style is extra light (at current resolution)\n&quot;
                    &quot;\n&quot;,
<span class="line-new-header">--- 1341,11 ---</span>
      FT_TRACE5(( &quot;\n&quot; ));
  
      /* an extra-light axis corresponds to a standard width that is */
      /* smaller than 5/8 pixels                                     */
      axis-&gt;extra_light =
<span class="line-modified">!       FT_BOOL( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
      if ( axis-&gt;extra_light )
        FT_TRACE5(( &quot;`%s&#39; style is extra light (at current resolution)\n&quot;
                    &quot;\n&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1417,17 ***</span>
          FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;
                      &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,
                      nn,
                      blue-&gt;ref.org,
                      blue-&gt;ref.fit / 64.0,
<span class="line-modified">!                     blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</span>
<span class="line-modified">!                                                        : &quot; (inactive)&quot;,</span>
                      nn,
                      blue-&gt;shoot.org,
                      blue-&gt;shoot.fit / 64.0,
<span class="line-modified">!                     blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</span>
<span class="line-modified">!                                                        : &quot; (inactive)&quot; ));</span>
        }
  #endif
      }
    }
  
<span class="line-new-header">--- 1477,17 ---</span>
          FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;
                      &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,
                      nn,
                      blue-&gt;ref.org,
                      blue-&gt;ref.fit / 64.0,
<span class="line-modified">!                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">!                                                            : &quot; (inactive)&quot;,</span>
                      nn,
                      blue-&gt;shoot.org,
                      blue-&gt;shoot.fit / 64.0,
<span class="line-modified">!                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">!                                                            : &quot; (inactive)&quot; ));</span>
        }
  #endif
      }
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1965,21 ***</span>
            /* (this is, how much they overlap)                          */
            len = max - min;
            if ( len &gt;= len_threshold )
            {
              /*
<span class="line-modified">!              *  The score is the sum of two demerits indicating the</span>
<span class="line-modified">!              *  `badness&#39; of a fit, measured along the segments&#39; main axis</span>
<span class="line-modified">!              *  and orthogonal to it, respectively.</span>
               *
<span class="line-modified">!              *  o The less overlapping along the main axis, the worse it</span>
<span class="line-modified">!              *    is, causing a larger demerit.</span>
               *
<span class="line-modified">!              *  o The nearer the orthogonal distance to a stem width, the</span>
<span class="line-modified">!              *    better it is, causing a smaller demerit.  For simplicity,</span>
<span class="line-modified">!              *    however, we only increase the demerit for values that</span>
<span class="line-modified">!              *    exceed the largest stem width.</span>
               */
  
              FT_Pos  dist = pos2 - pos1;
  
              FT_Pos  dist_demerit, score;
<span class="line-new-header">--- 2025,21 ---</span>
            /* (this is, how much they overlap)                          */
            len = max - min;
            if ( len &gt;= len_threshold )
            {
              /*
<span class="line-modified">!              * The score is the sum of two demerits indicating the</span>
<span class="line-modified">!              * `badness&#39; of a fit, measured along the segments&#39; main axis</span>
<span class="line-modified">!              * and orthogonal to it, respectively.</span>
               *
<span class="line-modified">!              * - The less overlapping along the main axis, the worse it</span>
<span class="line-modified">!              *   is, causing a larger demerit.</span>
               *
<span class="line-modified">!              * - The nearer the orthogonal distance to a stem width, the</span>
<span class="line-modified">!              *   better it is, causing a smaller demerit.  For simplicity,</span>
<span class="line-modified">!              *   however, we only increase the demerit for values that</span>
<span class="line-modified">!              *   exceed the largest stem width.</span>
               */
  
              FT_Pos  dist = pos2 - pos1;
  
              FT_Pos  dist_demerit, score;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2047,17 ***</span>
      AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
      FT_Error      error  = FT_Err_Ok;
      FT_Memory     memory = hints-&gt;memory;
      AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-     AF_FaceGlobals  globals = hints-&gt;metrics-&gt;globals;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">!     AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-removed">-                                      [style_class-&gt;script];</span>
  
      FT_Bool  top_to_bottom_hinting = 0;
  
      AF_Segment    segments      = axis-&gt;segments;
      AF_Segment    segment_limit = segments + axis-&gt;num_segments;
<span class="line-new-header">--- 2107,12 ---</span>
      AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
      FT_Error      error  = FT_Err_Ok;
      FT_Memory     memory = hints-&gt;memory;
      AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];
  
      AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">!     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
  
      FT_Bool  top_to_bottom_hinting = 0;
  
      AF_Segment    segments      = axis-&gt;segments;
      AF_Segment    segment_limit = segments + axis-&gt;num_segments;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2084,40 ***</span>
  
      if ( dim == AF_DIMENSION_VERT )
        top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
  
      /*
<span class="line-modified">!      *  We ignore all segments that are less than 1 pixel in length</span>
<span class="line-modified">!      *  to avoid many problems with serif fonts.  We compute the</span>
<span class="line-modified">!      *  corresponding threshold in font units.</span>
       */
      if ( dim == AF_DIMENSION_HORZ )
        segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );
      else
        segment_length_threshold = 0;
  
      /*
<span class="line-modified">!      *  Similarly, we ignore segments that have a width delta</span>
<span class="line-modified">!      *  larger than 0.5px (i.e., a width larger than 1px).</span>
       */
      segment_width_threshold = FT_DivFix( 32, scale );
  
<span class="line-modified">!     /*********************************************************************/</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* We begin by generating a sorted table of edges for the current    */</span>
<span class="line-modified">!     /* direction.  To do so, we simply scan each segment and try to find */</span>
<span class="line-modified">!     /* an edge in our table that corresponds to its position.            */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* If no edge is found, we create and insert a new edge in the       */</span>
<span class="line-modified">!     /* sorted table.  Otherwise, we simply add the segment to the edge&#39;s */</span>
<span class="line-modified">!     /* list which gets processed in the second step to compute the       */</span>
<span class="line-modified">!     /* edge&#39;s properties.                                                */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* Note that the table of edges is sorted along the segment/edge     */</span>
<span class="line-modified">!     /* position.                                                         */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /*********************************************************************/</span>
  
      /* assure that edge distance threshold is at most 0.25px */
      edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
                                           scale );
      if ( edge_distance_threshold &gt; 64 / 4 )
<span class="line-new-header">--- 2139,40 ---</span>
  
      if ( dim == AF_DIMENSION_VERT )
        top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
  
      /*
<span class="line-modified">!      * We ignore all segments that are less than 1 pixel in length</span>
<span class="line-modified">!      * to avoid many problems with serif fonts.  We compute the</span>
<span class="line-modified">!      * corresponding threshold in font units.</span>
       */
      if ( dim == AF_DIMENSION_HORZ )
        segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );
      else
        segment_length_threshold = 0;
  
      /*
<span class="line-modified">!      * Similarly, we ignore segments that have a width delta</span>
<span class="line-modified">!      * larger than 0.5px (i.e., a width larger than 1px).</span>
       */
      segment_width_threshold = FT_DivFix( 32, scale );
  
<span class="line-modified">!     /**********************************************************************</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * We begin by generating a sorted table of edges for the current</span>
<span class="line-modified">!      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="line-modified">!      * an edge in our table that corresponds to its position.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * If no edge is found, we create and insert a new edge in the</span>
<span class="line-modified">!      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="line-modified">!      * list which gets processed in the second step to compute the</span>
<span class="line-modified">!      * edge&#39;s properties.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Note that the table of edges is sorted along the segment/edge</span>
<span class="line-modified">!      * position.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      */</span>
  
      /* assure that edge distance threshold is at most 0.25px */
      edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
                                           scale );
      if ( edge_distance_threshold &gt; 64 / 4 )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2235,21 ***</span>
          found-&gt;last            = seg;
        }
      }
  
  
<span class="line-modified">!     /******************************************************************/</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /* Good, we now compute each edge&#39;s properties according to the   */</span>
<span class="line-modified">!     /* segments found on its position.  Basically, these are          */</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /*  - the edge&#39;s main direction                                   */</span>
<span class="line-modified">!     /*  - stem edge, serif edge or both (which defaults to stem then) */</span>
<span class="line-modified">!     /*  - rounded edge, straight or both (which defaults to straight) */</span>
<span class="line-modified">!     /*  - link for edge                                               */</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /******************************************************************/</span>
  
      /* first of all, set the `edge&#39; field in each segment -- this is */
      /* required in order to compute edge links                       */
  
      /*
<span class="line-new-header">--- 2290,21 ---</span>
          found-&gt;last            = seg;
        }
      }
  
  
<span class="line-modified">!     /*******************************************************************</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="line-modified">!      * segments found on its position.  Basically, these are</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * - the edge&#39;s main direction</span>
<span class="line-modified">!      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="line-modified">!      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="line-modified">!      * - link for edge</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      */</span>
  
      /* first of all, set the `edge&#39; field in each segment -- this is */
      /* required in order to compute edge links                       */
  
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2307,13 ***</span>
              downs += seg-&gt;max_coord - seg-&gt;min_coord;
  #endif
  
            /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
            /* be ignored                                                   */
<span class="line-modified">!           is_serif = (FT_Bool)( seg-&gt;serif               &amp;&amp;</span>
<span class="line-modified">!                                 seg-&gt;serif-&gt;edge         &amp;&amp;</span>
<span class="line-modified">!                                 seg-&gt;serif-&gt;edge != edge );</span>
  
            if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge ) || is_serif )
            {
              AF_Edge     edge2;
              AF_Segment  seg2;
<span class="line-new-header">--- 2362,13 ---</span>
              downs += seg-&gt;max_coord - seg-&gt;min_coord;
  #endif
  
            /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
            /* be ignored                                                   */
<span class="line-modified">!           is_serif = FT_BOOL( seg-&gt;serif               &amp;&amp;</span>
<span class="line-modified">!                               seg-&gt;serif-&gt;edge         &amp;&amp;</span>
<span class="line-modified">!                               seg-&gt;serif-&gt;edge != edge );</span>
  
            if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge ) || is_serif )
            {
              AF_Edge     edge2;
              AF_Segment  seg2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2544,12 ***</span>
  
  
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
  
      /*
<span class="line-modified">!      *  correct x_scale and y_scale if needed, since they may have</span>
<span class="line-modified">!      *  been modified by `af_latin_metrics_scale_dim&#39; above</span>
       */
      hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
      hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
      hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
      hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
<span class="line-new-header">--- 2599,12 ---</span>
  
  
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
  
      /*
<span class="line-modified">!      * correct x_scale and y_scale if needed, since they may have</span>
<span class="line-modified">!      * been modified by `af_latin_metrics_scale_dim&#39; above</span>
       */
      hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
      hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
      hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
      hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2564,38 ***</span>
  
      scaler_flags = hints-&gt;scaler_flags;
      other_flags  = 0;
  
      /*
<span class="line-modified">!      *  We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">!      *  horizontal LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
  
      /*
<span class="line-modified">!      *  We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">!      *  vertical LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
        other_flags |= AF_LATIN_HINTS_VERT_SNAP;
  
      /*
<span class="line-modified">!      *  We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
       */
      if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
  
      if ( mode == FT_RENDER_MODE_MONO )
        other_flags |= AF_LATIN_HINTS_MONO;
  
      /*
<span class="line-modified">!      *  In `light&#39; or `lcd&#39; mode we disable horizontal hinting completely.</span>
<span class="line-modified">!      *  We also do it if the face is italic.</span>
       *
<span class="line-modified">!      *  However, if warping is enabled (which only works in `light&#39; hinting</span>
<span class="line-modified">!      *  mode), advance widths get adjusted, too.</span>
       */
      if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
           ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0          )
        scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
  
<span class="line-new-header">--- 2619,38 ---</span>
  
      scaler_flags = hints-&gt;scaler_flags;
      other_flags  = 0;
  
      /*
<span class="line-modified">!      * We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">!      * horizontal LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
  
      /*
<span class="line-modified">!      * We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">!      * vertical LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
        other_flags |= AF_LATIN_HINTS_VERT_SNAP;
  
      /*
<span class="line-modified">!      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
       */
      if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
  
      if ( mode == FT_RENDER_MODE_MONO )
        other_flags |= AF_LATIN_HINTS_MONO;
  
      /*
<span class="line-modified">!      * In `light&#39; or `lcd&#39; mode we disable horizontal hinting completely.</span>
<span class="line-modified">!      * We also do it if the face is italic.</span>
       *
<span class="line-modified">!      * However, if warping is enabled (which only works in `light&#39; hinting</span>
<span class="line-modified">!      * mode), advance widths get adjusted, too.</span>
       */
      if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
           ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0          )
        scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2934,17 ***</span>
      FT_PtrDist    n_edges;
      AF_Edge       edge;
      AF_Edge       anchor     = NULL;
      FT_Int        has_serifs = 0;
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-     AF_FaceGlobals  globals = hints-&gt;metrics-&gt;globals;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">!     AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-removed">-                                      [style_class-&gt;script];</span>
  
      FT_Bool  top_to_bottom_hinting = 0;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
      FT_UInt  num_actions = 0;
<span class="line-new-header">--- 2989,12 ---</span>
      FT_PtrDist    n_edges;
      AF_Edge       edge;
      AF_Edge       anchor     = NULL;
      FT_Int        has_serifs = 0;
  
      AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">!     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
  
      FT_Bool  top_to_bottom_hinting = 0;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
      FT_UInt  num_actions = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2974,16 ***</span>
  
          edge1 = NULL;
          edge2 = edge-&gt;link;
  
          /*
<span class="line-modified">!          *  If a stem contains both a neutral and a non-neutral blue zone,</span>
<span class="line-modified">!          *  skip the neutral one.  Otherwise, outlines with different</span>
<span class="line-modified">!          *  directions might be incorrectly aligned at the same vertical</span>
<span class="line-modified">!          *  position.</span>
           *
<span class="line-modified">!          *  If we have two neutral blue zones, skip one of them.</span>
           *
           */
          if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )
          {
            FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;
<span class="line-new-header">--- 3024,16 ---</span>
  
          edge1 = NULL;
          edge2 = edge-&gt;link;
  
          /*
<span class="line-modified">!          * If a stem contains both a neutral and a non-neutral blue zone,</span>
<span class="line-modified">!          * skip the neutral one.  Otherwise, outlines with different</span>
<span class="line-modified">!          * directions might be incorrectly aligned at the same vertical</span>
<span class="line-modified">!          * position.</span>
           *
<span class="line-modified">!          * If we have two neutral blue zones, skip one of them.</span>
           *
           */
          if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )
          {
            FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3342,12 ***</span>
      }
  
      if ( has_serifs || !anchor )
      {
        /*
<span class="line-modified">!        *  now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">!        *  to complete our processing</span>
         */
        for ( edge = edges; edge &lt; edge_limit; edge++ )
        {
          FT_Pos  delta;
  
<span class="line-new-header">--- 3392,12 ---</span>
      }
  
      if ( has_serifs || !anchor )
      {
        /*
<span class="line-modified">!        * now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">!        * to complete our processing</span>
         */
        for ( edge = edges; edge &lt; edge_limit; edge++ )
        {
          FT_Pos  delta;
  
</pre>
<center><a href="afindic.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="aflatin.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
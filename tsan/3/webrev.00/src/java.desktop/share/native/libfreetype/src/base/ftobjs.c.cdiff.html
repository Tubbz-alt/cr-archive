<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/base/ftobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftmm.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftoutln.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftobjs.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,21 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ftobjs.c                                                               */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    The FreeType private base classes (body).                            */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_LIST_H
  #include FT_OUTLINE_H
<span class="line-new-header">--- 1,21 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ftobjs.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   The FreeType private base classes (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_LIST_H
  #include FT_OUTLINE_H
</pre>
<hr />
<pre>
<span class="line-old-header">*** 77,10 ***</span>
<span class="line-new-header">--- 77,22 ---</span>
  
  #if defined( _MSC_VER )
  #pragma warning( pop )
  #endif
  
<span class="line-added">+   static const char* const  pixel_modes[] =</span>
<span class="line-added">+   {</span>
<span class="line-added">+     &quot;none&quot;,</span>
<span class="line-added">+     &quot;monochrome bitmap&quot;,</span>
<span class="line-added">+     &quot;gray 8-bit bitmap&quot;,</span>
<span class="line-added">+     &quot;gray 2-bit bitmap&quot;,</span>
<span class="line-added">+     &quot;gray 4-bit bitmap&quot;,</span>
<span class="line-added">+     &quot;LCD 8-bit bitmap&quot;,</span>
<span class="line-added">+     &quot;vertical LCD 8-bit bitmap&quot;,</span>
<span class="line-added">+     &quot;BGRA 32-bit color image bitmap&quot;</span>
<span class="line-added">+   };</span>
<span class="line-added">+ </span>
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
  
  #define GRID_FIT_METRICS
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,18 ***</span>
          FT_FREE( stream );
      }
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_objs</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
<span class="line-new-header">--- 269,18 ---</span>
          FT_FREE( stream );
      }
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  objs</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,29 ***</span>
        slot-&gt;bitmap.buffer = NULL;
      }
    }
  
  
<span class="line-modified">!   FT_BASE_DEF( void )</span>
    ft_glyphslot_preset_bitmap( FT_GlyphSlot      slot,
                                FT_Render_Mode    mode,
                                const FT_Vector*  origin )
    {
      FT_Outline*  outline = &amp;slot-&gt;outline;
      FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
  
      FT_Pixel_Mode  pixel_mode;
  
<span class="line-modified">!     FT_BBox  cbox;</span>
      FT_Pos   x_shift = 0;
      FT_Pos   y_shift = 0;
      FT_Pos   x_left, y_top;
      FT_Pos   width, height, pitch;
  
  
<span class="line-modified">!     if ( slot-&gt;internal &amp;&amp; ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )</span>
<span class="line-modified">!       return;</span>
  
      if ( origin )
      {
        x_shift = origin-&gt;x;
        y_shift = origin-&gt;y;
<span class="line-new-header">--- 340,31 ---</span>
        slot-&gt;bitmap.buffer = NULL;
      }
    }
  
  
<span class="line-modified">!   /* overflow-resistant presetting of bitmap position and dimensions; */</span>
<span class="line-added">+   /* also check whether the size is too large for rendering           */</span>
<span class="line-added">+   FT_BASE_DEF( FT_Bool )</span>
    ft_glyphslot_preset_bitmap( FT_GlyphSlot      slot,
                                FT_Render_Mode    mode,
                                const FT_Vector*  origin )
    {
      FT_Outline*  outline = &amp;slot-&gt;outline;
      FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
  
      FT_Pixel_Mode  pixel_mode;
  
<span class="line-modified">!     FT_BBox  cbox, pbox;</span>
      FT_Pos   x_shift = 0;
      FT_Pos   y_shift = 0;
      FT_Pos   x_left, y_top;
      FT_Pos   width, height, pitch;
  
  
<span class="line-modified">!     if ( slot-&gt;format != FT_GLYPH_FORMAT_OUTLINE )</span>
<span class="line-modified">!       return 1;</span>
  
      if ( origin )
      {
        x_shift = origin-&gt;x;
        y_shift = origin-&gt;y;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,80 ***</span>
  
      /* compute the control box, and grid-fit it, */
      /* taking into account the origin shift      */
      FT_Outline_Get_CBox( outline, &amp;cbox );
  
<span class="line-modified">!     cbox.xMin += x_shift;</span>
<span class="line-modified">!     cbox.yMin += y_shift;</span>
<span class="line-modified">!     cbox.xMax += x_shift;</span>
<span class="line-modified">!     cbox.yMax += y_shift;</span>
  
      switch ( mode )
      {
      case FT_RENDER_MODE_MONO:
        pixel_mode = FT_PIXEL_MODE_MONO;
  #if 1
<span class="line-modified">!       /* undocumented but confirmed: bbox values get rounded    */</span>
<span class="line-modified">!       /* unless the rounded box can collapse for a narrow glyph */</span>
<span class="line-modified">!       if ( cbox.xMax - cbox.xMin &lt; 64 )</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-modified">!         cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!       else</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         cbox.xMin = FT_PIX_ROUND_LONG( cbox.xMin );</span>
<span class="line-removed">-         cbox.xMax = FT_PIX_ROUND_LONG( cbox.xMax );</span>
<span class="line-removed">-       }</span>
  
<span class="line-modified">!       if ( cbox.yMax - cbox.yMin &lt; 64 )</span>
        {
<span class="line-modified">!         cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-modified">!         cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>
        }
<span class="line-modified">!       else</span>
        {
<span class="line-modified">!         cbox.yMin = FT_PIX_ROUND_LONG( cbox.yMin );</span>
<span class="line-modified">!         cbox.yMax = FT_PIX_ROUND_LONG( cbox.yMax );</span>
        }
  #else
<span class="line-modified">!       cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-removed">-       cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-removed">-       cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-removed">-       cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>
  #endif
<span class="line-removed">-       break;</span>
  
      case FT_RENDER_MODE_LCD:
        pixel_mode = FT_PIXEL_MODE_LCD;
<span class="line-modified">!       ft_lcd_padding( &amp;cbox.xMin, &amp;cbox.xMax, slot );</span>
<span class="line-modified">!       goto Round;</span>
  
      case FT_RENDER_MODE_LCD_V:
        pixel_mode = FT_PIXEL_MODE_LCD_V;
<span class="line-modified">!       ft_lcd_padding( &amp;cbox.yMin, &amp;cbox.yMax, slot );</span>
<span class="line-modified">!       goto Round;</span>
  
      case FT_RENDER_MODE_NORMAL:
      case FT_RENDER_MODE_LIGHT:
      default:
        pixel_mode = FT_PIXEL_MODE_GRAY;
<span class="line-modified">!     Round:</span>
<span class="line-modified">!       cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-modified">!       cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-modified">!       cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-modified">!       cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>
      }
  
<span class="line-modified">!     x_shift = SUB_LONG( x_shift, cbox.xMin );</span>
<span class="line-modified">!     y_shift = SUB_LONG( y_shift, cbox.yMin );</span>
  
<span class="line-modified">!     x_left = cbox.xMin &gt;&gt; 6;</span>
<span class="line-modified">!     y_top  = cbox.yMax &gt;&gt; 6;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     width  = ( (FT_ULong)cbox.xMax - (FT_ULong)cbox.xMin ) &gt;&gt; 6;</span>
<span class="line-removed">-     height = ( (FT_ULong)cbox.yMax - (FT_ULong)cbox.yMin ) &gt;&gt; 6;</span>
  
      switch ( pixel_mode )
      {
      case FT_PIXEL_MODE_MONO:
        pitch = ( ( width + 15 ) &gt;&gt; 4 ) &lt;&lt; 1;
<span class="line-new-header">--- 372,93 ---</span>
  
      /* compute the control box, and grid-fit it, */
      /* taking into account the origin shift      */
      FT_Outline_Get_CBox( outline, &amp;cbox );
  
<span class="line-modified">!     /* rough estimate of pixel box */</span>
<span class="line-modified">!     pbox.xMin = ( cbox.xMin &gt;&gt; 6 ) + ( x_shift &gt;&gt; 6 );</span>
<span class="line-modified">!     pbox.yMin = ( cbox.yMin &gt;&gt; 6 ) + ( y_shift &gt;&gt; 6 );</span>
<span class="line-modified">!     pbox.xMax = ( cbox.xMax &gt;&gt; 6 ) + ( x_shift &gt;&gt; 6 );</span>
<span class="line-added">+     pbox.yMax = ( cbox.yMax &gt;&gt; 6 ) + ( y_shift &gt;&gt; 6 );</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* tiny remainder box */</span>
<span class="line-added">+     cbox.xMin = ( cbox.xMin &amp; 63 ) + ( x_shift &amp; 63 );</span>
<span class="line-added">+     cbox.yMin = ( cbox.yMin &amp; 63 ) + ( y_shift &amp; 63 );</span>
<span class="line-added">+     cbox.xMax = ( cbox.xMax &amp; 63 ) + ( x_shift &amp; 63 );</span>
<span class="line-added">+     cbox.yMax = ( cbox.yMax &amp; 63 ) + ( y_shift &amp; 63 );</span>
  
      switch ( mode )
      {
      case FT_RENDER_MODE_MONO:
        pixel_mode = FT_PIXEL_MODE_MONO;
  #if 1
<span class="line-modified">!       /* x */</span>
<span class="line-modified">! </span>
<span class="line-modified">!       /* undocumented but confirmed: bbox values get rounded;    */</span>
<span class="line-modified">!       /* we do asymmetric rounding so that the center of a pixel */</span>
<span class="line-modified">!       /* gets always included                                    */</span>
<span class="line-modified">! </span>
<span class="line-modified">!       pbox.xMin += ( cbox.xMin + 31 ) &gt;&gt; 6;</span>
<span class="line-modified">!       pbox.xMax += ( cbox.xMax + 32 ) &gt;&gt; 6;</span>
  
<span class="line-modified">!       /* if the bbox collapsed, we add a pixel based on the total */</span>
<span class="line-added">+       /* rounding remainder to cover most of the original cbox    */</span>
<span class="line-added">+ </span>
<span class="line-added">+       if ( pbox.xMin == pbox.xMax )</span>
        {
<span class="line-modified">!         if ( ( ( cbox.xMin + 31 ) &amp; 63 ) - 31 +</span>
<span class="line-modified">!              ( ( cbox.xMax + 32 ) &amp; 63 ) - 32 &lt; 0 )</span>
<span class="line-added">+           pbox.xMin -= 1;</span>
<span class="line-added">+         else</span>
<span class="line-added">+           pbox.xMax += 1;</span>
        }
<span class="line-modified">! </span>
<span class="line-added">+       /* y */</span>
<span class="line-added">+ </span>
<span class="line-added">+       pbox.yMin += ( cbox.yMin + 31 ) &gt;&gt; 6;</span>
<span class="line-added">+       pbox.yMax += ( cbox.yMax + 32 ) &gt;&gt; 6;</span>
<span class="line-added">+ </span>
<span class="line-added">+       if ( pbox.yMin == pbox.yMax )</span>
        {
<span class="line-modified">!         if ( ( ( cbox.yMin + 31 ) &amp; 63 ) - 31 +</span>
<span class="line-modified">!              ( ( cbox.yMax + 32 ) &amp; 63 ) - 32 &lt; 0 )</span>
<span class="line-added">+           pbox.yMin -= 1;</span>
<span class="line-added">+         else</span>
<span class="line-added">+           pbox.yMax += 1;</span>
        }
<span class="line-added">+ </span>
<span class="line-added">+       break;</span>
  #else
<span class="line-modified">!       goto Adjust;</span>
  #endif
  
      case FT_RENDER_MODE_LCD:
        pixel_mode = FT_PIXEL_MODE_LCD;
<span class="line-modified">!       ft_lcd_padding( &amp;cbox, slot, mode );</span>
<span class="line-modified">!       goto Adjust;</span>
  
      case FT_RENDER_MODE_LCD_V:
        pixel_mode = FT_PIXEL_MODE_LCD_V;
<span class="line-modified">!       ft_lcd_padding( &amp;cbox, slot, mode );</span>
<span class="line-modified">!       goto Adjust;</span>
  
      case FT_RENDER_MODE_NORMAL:
      case FT_RENDER_MODE_LIGHT:
      default:
        pixel_mode = FT_PIXEL_MODE_GRAY;
<span class="line-modified">!     Adjust:</span>
<span class="line-modified">!       pbox.xMin += cbox.xMin &gt;&gt; 6;</span>
<span class="line-modified">!       pbox.yMin += cbox.yMin &gt;&gt; 6;</span>
<span class="line-modified">!       pbox.xMax += ( cbox.xMax + 63 ) &gt;&gt; 6;</span>
<span class="line-modified">!       pbox.yMax += ( cbox.yMax + 63 ) &gt;&gt; 6;</span>
      }
  
<span class="line-modified">!     x_left = pbox.xMin;</span>
<span class="line-modified">!     y_top  = pbox.yMax;</span>
  
<span class="line-modified">!     width  = pbox.xMax - pbox.xMin;</span>
<span class="line-modified">!     height = pbox.yMax - pbox.yMin;</span>
  
      switch ( pixel_mode )
      {
      case FT_PIXEL_MODE_MONO:
        pitch = ( ( width + 15 ) &gt;&gt; 4 ) &lt;&lt; 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 457,10 ***</span>
<span class="line-new-header">--- 484,20 ---</span>
      bitmap-&gt;pixel_mode = (unsigned char)pixel_mode;
      bitmap-&gt;num_grays  = 256;
      bitmap-&gt;width      = (unsigned int)width;
      bitmap-&gt;rows       = (unsigned int)height;
      bitmap-&gt;pitch      = pitch;
<span class="line-added">+ </span>
<span class="line-added">+     if ( pbox.xMin &lt; -0x8000 || pbox.xMax &gt; 0x7FFF ||</span>
<span class="line-added">+          pbox.yMin &lt; -0x8000 || pbox.yMax &gt; 0x7FFF )</span>
<span class="line-added">+     {</span>
<span class="line-added">+       FT_TRACE3(( &quot;ft_glyphslot_preset_bitmap: [%ld %ld %ld %ld]\n&quot;,</span>
<span class="line-added">+                   pbox.xMin, pbox.yMin, pbox.xMax, pbox.yMax ));</span>
<span class="line-added">+       return 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return 0;</span>
    }
  
  
    FT_BASE_DEF( void )
    ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 805,11 ***</span>
       * The general rules are:
       *
       * - Do only auto-hinting if we have
       *
       *   - a hinter module,
<span class="line-modified">!      *   - a scalable font format dealing with outlines,</span>
       *   - not a tricky font, and
       *   - no transforms except simple slants and/or rotations by
       *     integer multiples of 90 degrees.
       *
       * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don&#39;t
<span class="line-new-header">--- 842,11 ---</span>
       * The general rules are:
       *
       * - Do only auto-hinting if we have
       *
       *   - a hinter module,
<span class="line-modified">!      *   - a scalable font,</span>
       *   - not a tricky font, and
       *   - no transforms except simple slants and/or rotations by
       *     integer multiples of 90 degrees.
       *
       * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don&#39;t
</pre>
<hr />
<pre>
<span class="line-old-header">*** 823,12 ***</span>
       */
  
      if ( hinter                                           &amp;&amp;
           !( load_flags &amp; FT_LOAD_NO_HINTING )             &amp;&amp;
           !( load_flags &amp; FT_LOAD_NO_AUTOHINT )            &amp;&amp;
<span class="line-modified">!          FT_DRIVER_IS_SCALABLE( driver )                  &amp;&amp;</span>
<span class="line-removed">-          FT_DRIVER_USES_OUTLINES( driver )                &amp;&amp;</span>
           !FT_IS_TRICKY( face )                            &amp;&amp;
           ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM )    ||
             ( face-&gt;internal-&gt;transform_matrix.yx == 0 &amp;&amp;
               face-&gt;internal-&gt;transform_matrix.xx != 0 ) ||
             ( face-&gt;internal-&gt;transform_matrix.xx == 0 &amp;&amp;
<span class="line-new-header">--- 860,11 ---</span>
       */
  
      if ( hinter                                           &amp;&amp;
           !( load_flags &amp; FT_LOAD_NO_HINTING )             &amp;&amp;
           !( load_flags &amp; FT_LOAD_NO_AUTOHINT )            &amp;&amp;
<span class="line-modified">!          FT_IS_SCALABLE( face )                           &amp;&amp;</span>
           !FT_IS_TRICKY( face )                            &amp;&amp;
           ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM )    ||
             ( face-&gt;internal-&gt;transform_matrix.yx == 0 &amp;&amp;
               face-&gt;internal-&gt;transform_matrix.xx != 0 ) ||
             ( face-&gt;internal-&gt;transform_matrix.xx == 0 &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 844,11 ***</span>
  
  
          /* only the new Adobe engine (for both CFF and Type 1) is `light&#39;; */
          /* we use `strstr&#39; to catch both `Type 1&#39; and `CID Type 1&#39;         */
          is_light_type1 =
<span class="line-modified">!           ft_strstr( FT_Get_Font_Format( face ), &quot;Type 1&quot; ) != NULL   &amp;&amp;</span>
            ((PS_Driver)driver)-&gt;hinting_engine == FT_HINTING_ADOBE;
  
          /* the check for `num_locations&#39; assures that we actually    */
          /* test for instructions in a TTF and not in a CFF-based OTF */
          /*                                                           */
<span class="line-new-header">--- 880,11 ---</span>
  
  
          /* only the new Adobe engine (for both CFF and Type 1) is `light&#39;; */
          /* we use `strstr&#39; to catch both `Type 1&#39; and `CID Type 1&#39;         */
          is_light_type1 =
<span class="line-modified">!           ft_strstr( FT_Get_Font_Format( face ), &quot;Type 1&quot; ) != NULL &amp;&amp;</span>
            ((PS_Driver)driver)-&gt;hinting_engine == FT_HINTING_ADOBE;
  
          /* the check for `num_locations&#39; assures that we actually    */
          /* test for instructions in a TTF and not in a CFF-based OTF */
          /*                                                           */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,12 ***</span>
          if ( error )
            goto Exit;
  
  #ifdef GRID_FIT_METRICS
          if ( !( load_flags &amp; FT_LOAD_NO_HINTING ) )
<span class="line-modified">!           ft_glyphslot_grid_fit_metrics( slot,</span>
<span class="line-modified">!               FT_BOOL( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT ) );</span>
  #endif
        }
      }
  
    Load_Ok:
<span class="line-new-header">--- 960,13 ---</span>
          if ( error )
            goto Exit;
  
  #ifdef GRID_FIT_METRICS
          if ( !( load_flags &amp; FT_LOAD_NO_HINTING ) )
<span class="line-modified">!           ft_glyphslot_grid_fit_metrics(</span>
<span class="line-modified">!             slot,</span>
<span class="line-added">+             FT_BOOL( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT ) );</span>
  #endif
        }
      }
  
    Load_Ok:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,10 ***</span>
<span class="line-new-header">--- 1030,13 ---</span>
          /* transform advance */
          FT_Vector_Transform( &amp;slot-&gt;advance, &amp;internal-&gt;transform_matrix );
        }
      }
  
<span class="line-added">+     slot-&gt;glyph_index          = glyph_index;</span>
<span class="line-added">+     slot-&gt;internal-&gt;load_flags = load_flags;</span>
<span class="line-added">+ </span>
      /* do we need to render the image or preset the bitmap now? */
      if ( !error                                    &amp;&amp;
           ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0    &amp;&amp;
           slot-&gt;format != FT_GLYPH_FORMAT_BITMAP    &amp;&amp;
           slot-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1012,21 ***</span>
          error = FT_Render_Glyph( slot, mode );
        else
          ft_glyphslot_preset_bitmap( slot, mode, NULL );
      }
  
<span class="line-modified">!     FT_TRACE5(( &quot;FT_Load_Glyph: index %d, flags %x\n&quot;,</span>
<span class="line-modified">!                 glyph_index, load_flags               ));</span>
      FT_TRACE5(( &quot;  x advance: %f\n&quot;, slot-&gt;advance.x / 64.0 ));
      FT_TRACE5(( &quot;  y advance: %f\n&quot;, slot-&gt;advance.y / 64.0 ));
      FT_TRACE5(( &quot;  linear x advance: %f\n&quot;,
                  slot-&gt;linearHoriAdvance / 65536.0 ));
      FT_TRACE5(( &quot;  linear y advance: %f\n&quot;,
                  slot-&gt;linearVertAdvance / 65536.0 ));
<span class="line-modified">!     FT_TRACE5(( &quot;  bitmap %dx%d, mode %d\n&quot;,</span>
<span class="line-modified">!                 slot-&gt;bitmap.width, slot-&gt;bitmap.rows,</span>
<span class="line-modified">!                 slot-&gt;bitmap.pixel_mode               ));</span>
  
    Exit:
      return error;
    }
  
<span class="line-new-header">--- 1052,25 ---</span>
          error = FT_Render_Glyph( slot, mode );
        else
          ft_glyphslot_preset_bitmap( slot, mode, NULL );
      }
  
<span class="line-modified">! #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-modified">!     FT_TRACE5(( &quot;FT_Load_Glyph: index %d, flags 0x%x\n&quot;,</span>
<span class="line-added">+                 glyph_index, load_flags ));</span>
      FT_TRACE5(( &quot;  x advance: %f\n&quot;, slot-&gt;advance.x / 64.0 ));
      FT_TRACE5(( &quot;  y advance: %f\n&quot;, slot-&gt;advance.y / 64.0 ));
      FT_TRACE5(( &quot;  linear x advance: %f\n&quot;,
                  slot-&gt;linearHoriAdvance / 65536.0 ));
      FT_TRACE5(( &quot;  linear y advance: %f\n&quot;,
                  slot-&gt;linearVertAdvance / 65536.0 ));
<span class="line-modified">!     FT_TRACE5(( &quot;  bitmap %dx%d, %s (mode %d)\n&quot;,</span>
<span class="line-modified">!                 slot-&gt;bitmap.width,</span>
<span class="line-modified">!                 slot-&gt;bitmap.rows,</span>
<span class="line-added">+                 pixel_modes[slot-&gt;bitmap.pixel_mode],</span>
<span class="line-added">+                 slot-&gt;bitmap.pixel_mode ));</span>
<span class="line-added">+ #endif</span>
  
    Exit:
      return error;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1160,24 ***</span>
                        driver-&gt;root.memory,
                        driver );
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    find_unicode_charmap                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    This function finds a Unicode charmap, if there is one.            */</span>
<span class="line-modified">!   /*    And if there is more than one, it tries to favour the more         */</span>
<span class="line-modified">!   /*    extensive one, i.e., one that supports UCS-4 against those which   */</span>
<span class="line-modified">!   /*    are limited to the BMP (said UCS-2 encoding.)                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    This function is called from open_face() (just below), and also    */</span>
<span class="line-modified">!   /*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    find_unicode_charmap( FT_Face  face )
    {
      FT_CharMap*  first;
      FT_CharMap*  cur;
<span class="line-new-header">--- 1204,24 ---</span>
                        driver-&gt;root.memory,
                        driver );
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   find_unicode_charmap</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   This function finds a Unicode charmap, if there is one.</span>
<span class="line-modified">!    *   And if there is more than one, it tries to favour the more</span>
<span class="line-modified">!    *   extensive one, i.e., one that supports UCS-4 against those which</span>
<span class="line-modified">!    *   are limited to the BMP (said UCS-2 encoding.)</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   This function is called from open_face() (just below), and also</span>
<span class="line-modified">!    *   from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).</span>
<span class="line-modified">!    */</span>
    static FT_Error
    find_unicode_charmap( FT_Face  face )
    {
      FT_CharMap*  first;
      FT_CharMap*  cur;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1190,30 ***</span>
  
      if ( !first )
        return FT_THROW( Invalid_CharMap_Handle );
  
      /*
<span class="line-modified">!      *  The original TrueType specification(s) only specified charmap</span>
<span class="line-modified">!      *  formats that are capable of mapping 8 or 16 bit character codes to</span>
<span class="line-modified">!      *  glyph indices.</span>
       *
<span class="line-modified">!      *  However, recent updates to the Apple and OpenType specifications</span>
<span class="line-modified">!      *  introduced new formats that are capable of mapping 32-bit character</span>
<span class="line-modified">!      *  codes as well.  And these are already used on some fonts, mainly to</span>
<span class="line-modified">!      *  map non-BMP Asian ideographs as defined in Unicode.</span>
       *
<span class="line-modified">!      *  For compatibility purposes, these fonts generally come with</span>
<span class="line-modified">!      *  *several* Unicode charmaps:</span>
       *
<span class="line-modified">!      *   - One of them in the &quot;old&quot; 16-bit format, that cannot access</span>
<span class="line-modified">!      *     all glyphs in the font.</span>
       *
<span class="line-modified">!      *   - Another one in the &quot;new&quot; 32-bit format, that can access all</span>
<span class="line-modified">!      *     the glyphs.</span>
       *
<span class="line-modified">!      *  This function has been written to always favor a 32-bit charmap</span>
<span class="line-modified">!      *  when found.  Otherwise, a 16-bit one is returned when found.</span>
       */
  
      /* Since the `interesting&#39; table, with IDs (3,10), is normally the */
      /* last one, we loop backwards.  This loses with type1 fonts with  */
      /* non-BMP characters (&lt;.0001%), this wins with .ttf with non-BMP  */
<span class="line-new-header">--- 1234,30 ---</span>
  
      if ( !first )
        return FT_THROW( Invalid_CharMap_Handle );
  
      /*
<span class="line-modified">!      * The original TrueType specification(s) only specified charmap</span>
<span class="line-modified">!      * formats that are capable of mapping 8 or 16 bit character codes to</span>
<span class="line-modified">!      * glyph indices.</span>
       *
<span class="line-modified">!      * However, recent updates to the Apple and OpenType specifications</span>
<span class="line-modified">!      * introduced new formats that are capable of mapping 32-bit character</span>
<span class="line-modified">!      * codes as well.  And these are already used on some fonts, mainly to</span>
<span class="line-modified">!      * map non-BMP Asian ideographs as defined in Unicode.</span>
       *
<span class="line-modified">!      * For compatibility purposes, these fonts generally come with</span>
<span class="line-modified">!      * *several* Unicode charmaps:</span>
       *
<span class="line-modified">!      * - One of them in the &quot;old&quot; 16-bit format, that cannot access</span>
<span class="line-modified">!      *   all glyphs in the font.</span>
       *
<span class="line-modified">!      * - Another one in the &quot;new&quot; 32-bit format, that can access all</span>
<span class="line-modified">!      *   the glyphs.</span>
       *
<span class="line-modified">!      * This function has been written to always favor a 32-bit charmap</span>
<span class="line-modified">!      * when found.  Otherwise, a 16-bit one is returned when found.</span>
       */
  
      /* Since the `interesting&#39; table, with IDs (3,10), is normally the */
      /* last one, we loop backwards.  This loses with type1 fonts with  */
      /* non-BMP characters (&lt;.0001%), this wins with .ttf with non-BMP  */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1253,19 ***</span>
  
      return FT_THROW( Invalid_CharMap_Handle );
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    find_variant_selector_charmap                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    This function finds the variant selector charmap, if there is one. */</span>
<span class="line-modified">!   /*    There can only be one (platform=0, specific=5, format=14).         */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_CharMap
    find_variant_selector_charmap( FT_Face  face )
    {
      FT_CharMap*  first;
      FT_CharMap*  end;
<span class="line-new-header">--- 1297,19 ---</span>
  
      return FT_THROW( Invalid_CharMap_Handle );
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   find_variant_selector_charmap</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   This function finds the variant selector charmap, if there is one.</span>
<span class="line-modified">!    *   There can only be one (platform=0, specific=5, format=14).</span>
<span class="line-modified">!    */</span>
    static FT_CharMap
    find_variant_selector_charmap( FT_Face  face )
    {
      FT_CharMap*  first;
      FT_CharMap*  end;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1292,18 ***</span>
  
      return NULL;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    open_face                                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    This function does some work for FT_Open_Face().                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    open_face( FT_Driver      driver,
               FT_Stream      *astream,
               FT_Bool        external_stream,
               FT_Long        face_index,
<span class="line-new-header">--- 1336,18 ---</span>
  
      return NULL;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   open_face</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   This function does some work for FT_Open_Face().</span>
<span class="line-modified">!    */</span>
    static FT_Error
    open_face( FT_Driver      driver,
               FT_Stream      *astream,
               FT_Bool        external_stream,
               FT_Long        face_index,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2174,17 ***</span>
                                 FT_Face             *aface,
                                 const FT_Open_Args  *args )
    {
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_raccess</span>
  
      FT_Memory  memory = library-&gt;memory;
      FT_Error   error  = FT_ERR( Unknown_File_Format );
      FT_UInt    i;
  
<span class="line-modified">!     char *     file_names[FT_RACCESS_N_RULES];</span>
      FT_Long    offsets[FT_RACCESS_N_RULES];
      FT_Error   errors[FT_RACCESS_N_RULES];
      FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */
  
      FT_Open_Args  args2;
<span class="line-new-header">--- 2218,17 ---</span>
                                 FT_Face             *aface,
                                 const FT_Open_Args  *args )
    {
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  raccess</span>
  
      FT_Memory  memory = library-&gt;memory;
      FT_Error   error  = FT_ERR( Unknown_File_Format );
      FT_UInt    i;
  
<span class="line-modified">!     char*      file_names[FT_RACCESS_N_RULES];</span>
      FT_Long    offsets[FT_RACCESS_N_RULES];
      FT_Error   errors[FT_RACCESS_N_RULES];
      FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */
  
      FT_Open_Args  args2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2252,11 ***</span>
        error = FT_ERR( Unknown_File_Format );
  
      return error;
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_objs</span>
  
    }
  
  
    /* Check for some macintosh formats without Carbon framework.    */
<span class="line-new-header">--- 2296,11 ---</span>
        error = FT_ERR( Unknown_File_Format );
  
      return error;
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  objs</span>
  
    }
  
  
    /* Check for some macintosh formats without Carbon framework.    */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2280,11 ***</span>
      error = IsMacBinary( library, stream, face_index, aface );
      if ( FT_ERR_EQ( error, Unknown_File_Format ) )
      {
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_raccess</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE3(( &quot;Try as dfont: &quot; ));
        if ( !( args-&gt;flags &amp; FT_OPEN_MEMORY ) )
          FT_TRACE3(( &quot;%s ...&quot;, args-&gt;pathname ));
<span class="line-new-header">--- 2324,11 ---</span>
      error = IsMacBinary( library, stream, face_index, aface );
      if ( FT_ERR_EQ( error, Unknown_File_Format ) )
      {
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  raccess</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_TRACE3(( &quot;Try as dfont: &quot; ));
        if ( !( args-&gt;flags &amp; FT_OPEN_MEMORY ) )
          FT_TRACE3(( &quot;%s ...&quot;, args-&gt;pathname ));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2293,11 ***</span>
        error = IsMacResource( library, stream, 0, face_index, aface );
  
        FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot; : &quot;successful&quot; ));
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_objs</span>
  
      }
  
      if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||
             FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &amp;&amp;
<span class="line-new-header">--- 2337,11 ---</span>
        error = IsMacResource( library, stream, 0, face_index, aface );
  
        FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot; : &quot;successful&quot; ));
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  objs</span>
  
      }
  
      if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||
             FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2691,12 ***</span>
      if ( clazz-&gt;attach_file )
        error = clazz-&gt;attach_file( face, stream );
  
      /* close the attached stream */
      FT_Stream_Free( stream,
<span class="line-modified">!                     (FT_Bool)( parameters-&gt;stream &amp;&amp;</span>
<span class="line-modified">!                                ( parameters-&gt;flags &amp; FT_OPEN_STREAM ) ) );</span>
  
    Exit:
      return error;
    }
  
<span class="line-new-header">--- 2735,12 ---</span>
      if ( clazz-&gt;attach_file )
        error = clazz-&gt;attach_file( face, stream );
  
      /* close the attached stream */
      FT_Stream_Free( stream,
<span class="line-modified">!                     FT_BOOL( parameters-&gt;stream                     &amp;&amp;</span>
<span class="line-modified">!                              ( parameters-&gt;flags &amp; FT_OPEN_STREAM ) ) );</span>
  
    Exit:
      return error;
    }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3462,11 ***</span>
  
  
      if ( !face )
        return FT_THROW( Invalid_Face_Handle );
  
<span class="line-modified">!     if ( encoding == FT_ENCODING_NONE )</span>
        return FT_THROW( Invalid_Argument );
  
      /* FT_ENCODING_UNICODE is special.  We try to find the `best&#39; Unicode */
      /* charmap available, i.e., one with UCS-4 characters, if possible.   */
      /*                                                                    */
<span class="line-new-header">--- 3506,12 ---</span>
  
  
      if ( !face )
        return FT_THROW( Invalid_Face_Handle );
  
<span class="line-modified">!     /* FT_ENCODING_NONE is a valid encoding for BDF, PCF, and Windows FNT */</span>
<span class="line-added">+     if ( encoding == FT_ENCODING_NONE &amp;&amp; !face-&gt;num_charmaps )</span>
        return FT_THROW( Invalid_Argument );
  
      /* FT_ENCODING_UNICODE is special.  We try to find the `best&#39; Unicode */
      /* charmap available, i.e., one with UCS-4 characters, if possible.   */
      /*                                                                    */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3483,11 ***</span>
      for ( ; cur &lt; limit; cur++ )
      {
        if ( cur[0]-&gt;encoding == encoding )
        {
          face-&gt;charmap = cur[0];
<span class="line-modified">!         return 0;</span>
        }
      }
  
      return FT_THROW( Invalid_Argument );
    }
<span class="line-new-header">--- 3528,11 ---</span>
      for ( ; cur &lt; limit; cur++ )
      {
        if ( cur[0]-&gt;encoding == encoding )
        {
          face-&gt;charmap = cur[0];
<span class="line-modified">!         return FT_Err_Ok;</span>
        }
      }
  
      return FT_THROW( Invalid_Argument );
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3508,18 ***</span>
  
      cur = face-&gt;charmaps;
      if ( !cur || !charmap )
        return FT_THROW( Invalid_CharMap_Handle );
  
<span class="line-removed">-     if ( FT_Get_CMap_Format( charmap ) == 14 )</span>
<span class="line-removed">-       return FT_THROW( Invalid_Argument );</span>
<span class="line-removed">- </span>
      limit = cur + face-&gt;num_charmaps;
  
      for ( ; cur &lt; limit; cur++ )
      {
<span class="line-modified">!       if ( cur[0] == charmap )</span>
        {
          face-&gt;charmap = cur[0];
          return FT_Err_Ok;
        }
      }
<span class="line-new-header">--- 3553,16 ---</span>
  
      cur = face-&gt;charmaps;
      if ( !cur || !charmap )
        return FT_THROW( Invalid_CharMap_Handle );
  
      limit = cur + face-&gt;num_charmaps;
  
      for ( ; cur &lt; limit; cur++ )
      {
<span class="line-modified">!       if ( cur[0] == charmap                    &amp;&amp;</span>
<span class="line-added">+            FT_Get_CMap_Format ( charmap ) != 14 )</span>
        {
          face-&gt;charmap = cur[0];
          return FT_Err_Ok;
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4014,12 ***</span>
  
  
    /* documentation is in freetype.h */
  
    FT_EXPORT_DEF( FT_UInt )
<span class="line-modified">!   FT_Get_Name_Index( FT_Face     face,</span>
<span class="line-modified">!                      FT_String*  glyph_name )</span>
    {
      FT_UInt  result = 0;
  
  
      if ( face                       &amp;&amp;
<span class="line-new-header">--- 4057,12 ---</span>
  
  
    /* documentation is in freetype.h */
  
    FT_EXPORT_DEF( FT_UInt )
<span class="line-modified">!   FT_Get_Name_Index( FT_Face           face,</span>
<span class="line-modified">!                      const FT_String*  glyph_name )</span>
    {
      FT_UInt  result = 0;
  
  
      if ( face                       &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4485,20 ***</span>
    FT_Render_Glyph_Internal( FT_Library      library,
                              FT_GlyphSlot    slot,
                              FT_Render_Mode  render_mode )
    {
      FT_Error     error = FT_Err_Ok;
      FT_Renderer  renderer;
  
  
<span class="line-removed">-     /* if it is already a bitmap, no need to do anything */</span>
      switch ( slot-&gt;format )
      {
      case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don&#39;t do anything */
        break;
  
      default:
        {
          FT_ListNode  node = NULL;
  
  
          /* small shortcut for the very common case */
<span class="line-new-header">--- 4528,93 ---</span>
    FT_Render_Glyph_Internal( FT_Library      library,
                              FT_GlyphSlot    slot,
                              FT_Render_Mode  render_mode )
    {
      FT_Error     error = FT_Err_Ok;
<span class="line-added">+     FT_Face      face  = slot-&gt;face;</span>
      FT_Renderer  renderer;
  
  
      switch ( slot-&gt;format )
      {
      case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don&#39;t do anything */
        break;
  
      default:
<span class="line-added">+       if ( slot-&gt;internal-&gt;load_flags &amp; FT_LOAD_COLOR )</span>
<span class="line-added">+       {</span>
<span class="line-added">+         FT_LayerIterator  iterator;</span>
<span class="line-added">+ </span>
<span class="line-added">+         FT_UInt  base_glyph = slot-&gt;glyph_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+         FT_Bool  have_layers;</span>
<span class="line-added">+         FT_UInt  glyph_index;</span>
<span class="line-added">+         FT_UInt  color_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+         /* check whether we have colored glyph layers */</span>
<span class="line-added">+         iterator.p  = NULL;</span>
<span class="line-added">+         have_layers = FT_Get_Color_Glyph_Layer( face,</span>
<span class="line-added">+                                                 base_glyph,</span>
<span class="line-added">+                                                 &amp;glyph_index,</span>
<span class="line-added">+                                                 &amp;color_index,</span>
<span class="line-added">+                                                 &amp;iterator );</span>
<span class="line-added">+         if ( have_layers )</span>
<span class="line-added">+         {</span>
<span class="line-added">+           error = FT_New_GlyphSlot( face, NULL );</span>
<span class="line-added">+           if ( !error )</span>
<span class="line-added">+           {</span>
<span class="line-added">+             TT_Face       ttface = (TT_Face)face;</span>
<span class="line-added">+             SFNT_Service  sfnt   = (SFNT_Service)ttface-&gt;sfnt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+             do</span>
<span class="line-added">+             {</span>
<span class="line-added">+               FT_Int32  load_flags = slot-&gt;internal-&gt;load_flags;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+               /* disable the `FT_LOAD_COLOR&#39; flag to avoid recursion */</span>
<span class="line-added">+               /* right here in this function                         */</span>
<span class="line-added">+               load_flags &amp;= ~FT_LOAD_COLOR;</span>
<span class="line-added">+ </span>
<span class="line-added">+               /* render into the new `face-&gt;glyph&#39; glyph slot */</span>
<span class="line-added">+               load_flags |= FT_LOAD_RENDER;</span>
<span class="line-added">+ </span>
<span class="line-added">+               error = FT_Load_Glyph( face, glyph_index, load_flags );</span>
<span class="line-added">+               if ( error )</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+               /* blend new `face-&gt;glyph&#39; into old `slot&#39;; */</span>
<span class="line-added">+               /* at the first call, `slot&#39; is still empty */</span>
<span class="line-added">+               error = sfnt-&gt;colr_blend( ttface,</span>
<span class="line-added">+                                         color_index,</span>
<span class="line-added">+                                         slot,</span>
<span class="line-added">+                                         face-&gt;glyph );</span>
<span class="line-added">+               if ( error )</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+ </span>
<span class="line-added">+             } while ( FT_Get_Color_Glyph_Layer( face,</span>
<span class="line-added">+                                                 base_glyph,</span>
<span class="line-added">+                                                 &amp;glyph_index,</span>
<span class="line-added">+                                                 &amp;color_index,</span>
<span class="line-added">+                                                 &amp;iterator ) );</span>
<span class="line-added">+ </span>
<span class="line-added">+             if ( !error )</span>
<span class="line-added">+               slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;</span>
<span class="line-added">+ </span>
<span class="line-added">+             /* this call also restores `slot&#39; as the glyph slot */</span>
<span class="line-added">+             FT_Done_GlyphSlot( face-&gt;glyph );</span>
<span class="line-added">+           }</span>
<span class="line-added">+ </span>
<span class="line-added">+           if ( !error )</span>
<span class="line-added">+             return error;</span>
<span class="line-added">+ </span>
<span class="line-added">+           /* Failed to do the colored layer.  Draw outline instead. */</span>
<span class="line-added">+           slot-&gt;format = FT_GLYPH_FORMAT_OUTLINE;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
        {
          FT_ListNode  node = NULL;
  
  
          /* small shortcut for the very common case */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4530,23 ***</span>
      }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_bitmap</span>
  
      /*
       * Computing the MD5 checksum is expensive, unnecessarily distorting a
       * possible profiling of FreeType if compiled with tracing support.  For
       * this reason, we execute the following code only if explicitly
       * requested.
       */
  
      /* we use FT_TRACE3 in this block */
<span class="line-modified">!     if ( !error                             &amp;&amp;</span>
<span class="line-modified">!          ft_trace_levels[trace_bitmap] &gt;= 3 &amp;&amp;</span>
<span class="line-modified">!          slot-&gt;bitmap.buffer                )</span>
      {
        FT_Bitmap  bitmap;
        FT_Error   err;
  
  
<span class="line-new-header">--- 4646,23 ---</span>
      }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  checksum</span>
  
      /*
       * Computing the MD5 checksum is expensive, unnecessarily distorting a
       * possible profiling of FreeType if compiled with tracing support.  For
       * this reason, we execute the following code only if explicitly
       * requested.
       */
  
      /* we use FT_TRACE3 in this block */
<span class="line-modified">!     if ( !error                               &amp;&amp;</span>
<span class="line-modified">!          ft_trace_levels[trace_checksum] &gt;= 3 &amp;&amp;</span>
<span class="line-modified">!          slot-&gt;bitmap.buffer                  )</span>
      {
        FT_Bitmap  bitmap;
        FT_Error   err;
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4563,12 ***</span>
          int            i, j;
          int            rows  = (int)bitmap.rows;
          int            pitch = bitmap.pitch;
  
  
<span class="line-modified">!         FT_TRACE3(( &quot;FT_Render_Glyph: bitmap %dx%d, mode %d\n&quot;,</span>
<span class="line-modified">!                     rows, pitch, slot-&gt;bitmap.pixel_mode ));</span>
  
          for ( i = 0; i &lt; rows; i++ )
            for ( j = 0; j &lt; pitch; j++ )
              coverage += bitmap.buffer[i * pitch + j];
  
<span class="line-new-header">--- 4679,15 ---</span>
          int            i, j;
          int            rows  = (int)bitmap.rows;
          int            pitch = bitmap.pitch;
  
  
<span class="line-modified">!         FT_TRACE3(( &quot;FT_Render_Glyph: bitmap %dx%d, %s (mode %d)\n&quot;,</span>
<span class="line-modified">!                     pitch,</span>
<span class="line-added">+                     rows,</span>
<span class="line-added">+                     pixel_modes[slot-&gt;bitmap.pixel_mode],</span>
<span class="line-added">+                     slot-&gt;bitmap.pixel_mode ));</span>
  
          for ( i = 0; i &lt; rows; i++ )
            for ( j = 0; j &lt; pitch; j++ )
              coverage += bitmap.buffer[i * pitch + j];
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4592,53 ***</span>
      /*
       * Dump bitmap in Netpbm format (PBM or PGM).
       */
  
      /* we use FT_TRACE7 in this block */
<span class="line-modified">!     if ( !error                             &amp;&amp;</span>
<span class="line-modified">!          ft_trace_levels[trace_bitmap] &gt;= 7 &amp;&amp;</span>
<span class="line-removed">-          slot-&gt;bitmap.rows  &lt; 128U          &amp;&amp;</span>
<span class="line-removed">-          slot-&gt;bitmap.width &lt; 128U          &amp;&amp;</span>
<span class="line-removed">-          slot-&gt;bitmap.buffer                )</span>
      {
<span class="line-modified">!       int  rows  = (int)slot-&gt;bitmap.rows;</span>
<span class="line-modified">!       int  width = (int)slot-&gt;bitmap.width;</span>
<span class="line-modified">!       int  pitch =      slot-&gt;bitmap.pitch;</span>
<span class="line-modified">!       int  i, j, m;</span>
<span class="line-modified">!       unsigned char*  topleft = slot-&gt;bitmap.buffer;</span>
  
<span class="line-modified">!       if ( pitch &lt; 0 )</span>
<span class="line-removed">-         topleft -= pitch * ( rows - 1 );</span>
  
<span class="line-removed">-       FT_TRACE7(( &quot;Netpbm image: start\n&quot; ));</span>
<span class="line-removed">-       switch ( slot-&gt;bitmap.pixel_mode )</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-       case FT_PIXEL_MODE_MONO:</span>
<span class="line-removed">-         FT_TRACE7(( &quot;P1 %d %d\n&quot;, width, rows ));</span>
<span class="line-removed">-         for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           for ( j = 0; j &lt; width; )</span>
<span class="line-removed">-             for ( m = 128; m &gt; 0 &amp;&amp; j &lt; width; m &gt;&gt;= 1, j++ )</span>
<span class="line-removed">-               FT_TRACE7(( &quot; %d&quot;, ( topleft[i * pitch + j / 8] &amp; m ) != 0 ));</span>
<span class="line-removed">-           FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         break;</span>
  
<span class="line-modified">!       default:</span>
<span class="line-modified">!         FT_TRACE7(( &quot;P2 %d %d 255\n&quot;, width, rows ));</span>
<span class="line-modified">!         for ( i = 0; i &lt; rows; i++ )</span>
          {
<span class="line-modified">!           for ( j = 0; j &lt; width; j += 1 )</span>
<span class="line-modified">!             FT_TRACE7(( &quot; %3u&quot;, topleft[i * pitch + j] ));</span>
<span class="line-modified">!           FT_TRACE7(( &quot;\n&quot; ));</span>
          }
        }
<span class="line-modified">!       FT_TRACE7(( &quot;Netpbm image: end\n&quot; ));</span>
      }
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_objs</span>
  
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
      return error;
    }
<span class="line-new-header">--- 4711,60 ---</span>
      /*
       * Dump bitmap in Netpbm format (PBM or PGM).
       */
  
      /* we use FT_TRACE7 in this block */
<span class="line-modified">!     if ( !error                               &amp;&amp;</span>
<span class="line-modified">!          ft_trace_levels[trace_checksum] &gt;= 7 )</span>
      {
<span class="line-modified">!       if ( slot-&gt;bitmap.rows  &lt; 128U &amp;&amp;</span>
<span class="line-modified">!            slot-&gt;bitmap.width &lt; 128U &amp;&amp;</span>
<span class="line-modified">!            slot-&gt;bitmap.buffer       )</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         int  rows  = (int)slot-&gt;bitmap.rows;</span>
<span class="line-added">+         int  width = (int)slot-&gt;bitmap.width;</span>
<span class="line-added">+         int  pitch =      slot-&gt;bitmap.pitch;</span>
<span class="line-added">+         int  i, j, m;</span>
  
<span class="line-modified">!         unsigned char*  topleft = slot-&gt;bitmap.buffer;</span>
  
  
<span class="line-modified">!         if ( pitch &lt; 0 )</span>
<span class="line-modified">!           topleft -= pitch * ( rows - 1 );</span>
<span class="line-modified">! </span>
<span class="line-added">+         FT_TRACE7(( &quot;Netpbm image: start\n&quot; ));</span>
<span class="line-added">+         switch ( slot-&gt;bitmap.pixel_mode )</span>
          {
<span class="line-modified">!         case FT_PIXEL_MODE_MONO:</span>
<span class="line-modified">!           FT_TRACE7(( &quot;P1 %d %d\n&quot;, width, rows ));</span>
<span class="line-modified">!           for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-added">+           {</span>
<span class="line-added">+             for ( j = 0; j &lt; width; )</span>
<span class="line-added">+               for ( m = 128; m &gt; 0 &amp;&amp; j &lt; width; m &gt;&gt;= 1, j++ )</span>
<span class="line-added">+                 FT_TRACE7(( &quot; %d&quot;,</span>
<span class="line-added">+                             ( topleft[i * pitch + j / 8] &amp; m ) != 0 ));</span>
<span class="line-added">+             FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-added">+           }</span>
<span class="line-added">+           break;</span>
<span class="line-added">+ </span>
<span class="line-added">+         default:</span>
<span class="line-added">+           FT_TRACE7(( &quot;P2 %d %d 255\n&quot;, width, rows ));</span>
<span class="line-added">+           for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-added">+           {</span>
<span class="line-added">+             for ( j = 0; j &lt; width; j += 1 )</span>
<span class="line-added">+               FT_TRACE7(( &quot; %3u&quot;, topleft[i * pitch + j] ));</span>
<span class="line-added">+             FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-added">+           }</span>
          }
<span class="line-added">+         FT_TRACE7(( &quot;Netpbm image: end\n&quot; ));</span>
        }
<span class="line-modified">!       else</span>
<span class="line-added">+         FT_TRACE7(( &quot;Netpbm image: too large, omitted\n&quot; ));</span>
      }
  
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  objs</span>
  
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
      return error;
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4673,25 ***</span>
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    Destroy_Module                                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Destroys a given module object.  For drivers, this also destroys   */</span>
<span class="line-modified">!   /*    all child faces.                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    module :: A handle to the target driver object.                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">!   /*    The driver _must_ be LOCKED!                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    Destroy_Module( FT_Module  module )
    {
      FT_Memory         memory  = module-&gt;memory;
      FT_Module_Class*  clazz   = module-&gt;clazz;
<span class="line-new-header">--- 4799,26 ---</span>
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   Destroy_Module</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Destroys a given module object.  For drivers, this also destroys</span>
<span class="line-modified">!    *   all child faces.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   module ::</span>
<span class="line-modified">!    *     A handle to the target driver object.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Note:</span>
<span class="line-modified">!    *   The driver _must_ be LOCKED!</span>
<span class="line-added">+    */</span>
    static void
    Destroy_Module( FT_Module  module )
    {
      FT_Memory         memory  = module-&gt;memory;
      FT_Module_Class*  clazz   = module-&gt;clazz;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5026,13 ***</span>
      }
  
      service = (FT_Service_Properties)interface;
  
      if ( set )
<span class="line-modified">!       missing_func = (FT_Bool)( !service-&gt;set_property );</span>
      else
<span class="line-modified">!       missing_func = (FT_Bool)( !service-&gt;get_property );</span>
  
      if ( missing_func )
      {
        FT_ERROR(( &quot;%s: property service of module `%s&#39; is broken\n&quot;,
                   func_name, module_name ));
<span class="line-new-header">--- 5153,13 ---</span>
      }
  
      service = (FT_Service_Properties)interface;
  
      if ( set )
<span class="line-modified">!       missing_func = FT_BOOL( !service-&gt;set_property );</span>
      else
<span class="line-modified">!       missing_func = FT_BOOL( !service-&gt;get_property );</span>
  
      if ( missing_func )
      {
        FT_ERROR(( &quot;%s: property service of module `%s&#39; is broken\n&quot;,
                   func_name, module_name ));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5154,34 ***</span>
      if ( FT_NEW( library ) )
        return error;
  
      library-&gt;memory = memory;
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-     /* initialize position independent code containers */</span>
<span class="line-removed">-     error = ft_pic_container_init( library );</span>
<span class="line-removed">-     if ( error )</span>
<span class="line-removed">-       goto Fail;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      library-&gt;version_major = FREETYPE_MAJOR;
      library-&gt;version_minor = FREETYPE_MINOR;
      library-&gt;version_patch = FREETYPE_PATCH;
  
      library-&gt;refcount = 1;
  
      /* That&#39;s ok now */
      *alibrary = library;
  
      return FT_Err_Ok;
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-   Fail:</span>
<span class="line-removed">-     ft_pic_container_destroy( library );</span>
<span class="line-removed">-     FT_FREE( library );</span>
<span class="line-removed">-     return error;</span>
<span class="line-removed">- #endif</span>
    }
  
  
    /* documentation is in freetype.h */
  
<span class="line-new-header">--- 5281,20 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5235,14 ***</span>
       * Close all faces in the library.  If we don&#39;t do this, we can have
       * some subtle memory leaks.
       *
       * Example:
       *
<span class="line-modified">!      *  - the cff font driver uses the pshinter module in cff_size_done</span>
<span class="line-modified">!      *  - if the pshinter module is destroyed before the cff font driver,</span>
<span class="line-modified">!      *    opened FT_Face objects managed by the driver are not properly</span>
<span class="line-modified">!      *    destroyed, resulting in a memory leak</span>
       *
       * Some faces are dependent on other faces, like Type42 faces that
       * depend on TrueType faces synthesized internally.
       *
       * The order of drivers should be specified in driver_name[].
<span class="line-new-header">--- 5348,14 ---</span>
       * Close all faces in the library.  If we don&#39;t do this, we can have
       * some subtle memory leaks.
       *
       * Example:
       *
<span class="line-modified">!      * - the cff font driver uses the pshinter module in cff_size_done</span>
<span class="line-modified">!      * - if the pshinter module is destroyed before the cff font driver,</span>
<span class="line-modified">!      *   opened FT_Face objects managed by the driver are not properly</span>
<span class="line-modified">!      *   destroyed, resulting in a memory leak</span>
       *
       * Some faces are dependent on other faces, like Type42 faces that
       * depend on TrueType faces synthesized internally.
       *
       * The order of drivers should be specified in driver_name[].
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5308,15 ***</span>
          }
        }
      }
  #endif
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-     /* Destroy pic container contents */</span>
<span class="line-removed">-     ft_pic_container_destroy( library );</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
      FT_FREE( library );
  
    Exit:
      return FT_Err_Ok;
    }
<span class="line-new-header">--- 5421,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5400,6 ***</span>
<span class="line-new-header">--- 5508,43 ---</span>
  
      return error;
    }
  
  
<span class="line-added">+   /* documentation is in freetype.h */</span>
<span class="line-added">+ </span>
<span class="line-added">+   FT_EXPORT_DEF( FT_Bool )</span>
<span class="line-added">+   FT_Get_Color_Glyph_Layer( FT_Face            face,</span>
<span class="line-added">+                             FT_UInt            base_glyph,</span>
<span class="line-added">+                             FT_UInt           *aglyph_index,</span>
<span class="line-added">+                             FT_UInt           *acolor_index,</span>
<span class="line-added">+                             FT_LayerIterator*  iterator )</span>
<span class="line-added">+   {</span>
<span class="line-added">+     TT_Face       ttface;</span>
<span class="line-added">+     SFNT_Service  sfnt;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     if ( !face                                   ||</span>
<span class="line-added">+          !aglyph_index                           ||</span>
<span class="line-added">+          !acolor_index                           ||</span>
<span class="line-added">+          !iterator                               ||</span>
<span class="line-added">+          base_glyph &gt;= (FT_UInt)face-&gt;num_glyphs )</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ( !FT_IS_SFNT( face ) )</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+     ttface = (TT_Face)face;</span>
<span class="line-added">+     sfnt   = (SFNT_Service)ttface-&gt;sfnt;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if ( sfnt-&gt;get_colr_layer )</span>
<span class="line-added">+       return sfnt-&gt;get_colr_layer( ttface,</span>
<span class="line-added">+                                    base_glyph,</span>
<span class="line-added">+                                    aglyph_index,</span>
<span class="line-added">+                                    acolor_index,</span>
<span class="line-added">+                                    iterator );</span>
<span class="line-added">+     else</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  /* END */
</pre>
<center><a href="ftmm.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftoutln.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/autofit/afloader.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="aflatin.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afloader.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afloader.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,29 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  afloader.c                                                             */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Auto-fitter glyph loading routines (body).                           */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #include &quot;afglobal.h&quot;
  #include &quot;afloader.h&quot;
  #include &quot;afhints.h&quot;
  #include &quot;aferrors.h&quot;
  #include &quot;afmodule.h&quot;
<span class="line-removed">- #include &quot;afpic.h&quot;</span>
  
  #include FT_INTERNAL_CALC_H
  
  
    /* Initialize glyph loader. */
<span class="line-new-header">--- 1,28 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * afloader.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Auto-fitter glyph loading routines (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #include &quot;afglobal.h&quot;
  #include &quot;afloader.h&quot;
  #include &quot;afhints.h&quot;
  #include &quot;aferrors.h&quot;
  #include &quot;afmodule.h&quot;
  
  #include FT_INTERNAL_CALC_H
  
  
    /* Initialize glyph loader. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,16 ***</span>
        error = FT_ERR( Corrupted_Font_Header );
        goto Exit;
      }
  
      /*
<span class="line-modified">!      *  We depend on the writing system (script analyzers) to supply</span>
<span class="line-modified">!      *  standard widths for the script of the glyph we are looking at.  If</span>
<span class="line-modified">!      *  it can&#39;t deliver, stem darkening is disabled.</span>
       */
      writing_system_class =
<span class="line-modified">!       AF_WRITING_SYSTEM_CLASSES_GET[style_metrics-&gt;style_class-&gt;writing_system];</span>
  
      if ( writing_system_class-&gt;style_metrics_getstdw )
        writing_system_class-&gt;style_metrics_getstdw( style_metrics,
                                                     &amp;stdHW,
                                                     &amp;stdVW );
<span class="line-new-header">--- 116,16 ---</span>
        error = FT_ERR( Corrupted_Font_Header );
        goto Exit;
      }
  
      /*
<span class="line-modified">!      * We depend on the writing system (script analyzers) to supply</span>
<span class="line-modified">!      * standard widths for the script of the glyph we are looking at.  If</span>
<span class="line-modified">!      * it can&#39;t deliver, stem darkening is disabled.</span>
       */
      writing_system_class =
<span class="line-modified">!       af_writing_system_classes[style_metrics-&gt;style_class-&gt;writing_system];</span>
  
      if ( writing_system_class-&gt;style_metrics_getstdw )
        writing_system_class-&gt;style_metrics_getstdw( style_metrics,
                                                     &amp;stdHW,
                                                     &amp;stdVW );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 172,26 ***</span>
        globals-&gt;standard_horizontal_width = stdHW;
        globals-&gt;stem_darkening_for_ppem   = size_metrics-&gt;x_ppem;
        globals-&gt;darken_y                  = af_fixedToInt( darken_y );
  
        /*
<span class="line-modified">!        *  Scale outlines down on the Y-axis to keep them inside their blue</span>
<span class="line-modified">!        *  zones.  The stronger the emboldening, the stronger the downscaling</span>
<span class="line-modified">!        *  (plus heuristical padding to prevent outlines still falling out</span>
<span class="line-modified">!        *  their zones due to rounding).</span>
         *
<span class="line-modified">!        *  Reason: `FT_Outline_Embolden&#39; works by shifting the rightmost</span>
<span class="line-modified">!        *  points of stems farther to the right, and topmost points farther</span>
<span class="line-modified">!        *  up.  This positions points on the Y-axis outside their</span>
<span class="line-modified">!        *  pre-computed blue zones and leads to distortion when applying the</span>
<span class="line-modified">!        *  hints in the code further below.  Code outside this emboldening</span>
<span class="line-modified">!        *  block doesn&#39;t know we are presenting it with modified outlines the</span>
<span class="line-modified">!        *  analyzer didn&#39;t see!</span>
         *
<span class="line-modified">!        *  An unfortunate side effect of downscaling is that the emboldening</span>
<span class="line-modified">!        *  effect is slightly decreased.  The loss becomes more pronounced</span>
<span class="line-modified">!        *  versus the CFF driver at smaller sizes, e.g., at 9ppem and below.</span>
         */
        globals-&gt;scale_down_factor =
          FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
                     em_size );
      }
<span class="line-new-header">--- 171,26 ---</span>
        globals-&gt;standard_horizontal_width = stdHW;
        globals-&gt;stem_darkening_for_ppem   = size_metrics-&gt;x_ppem;
        globals-&gt;darken_y                  = af_fixedToInt( darken_y );
  
        /*
<span class="line-modified">!        * Scale outlines down on the Y-axis to keep them inside their blue</span>
<span class="line-modified">!        * zones.  The stronger the emboldening, the stronger the downscaling</span>
<span class="line-modified">!        * (plus heuristical padding to prevent outlines still falling out</span>
<span class="line-modified">!        * their zones due to rounding).</span>
         *
<span class="line-modified">!        * Reason: `FT_Outline_Embolden&#39; works by shifting the rightmost</span>
<span class="line-modified">!        * points of stems farther to the right, and topmost points farther</span>
<span class="line-modified">!        * up.  This positions points on the Y-axis outside their</span>
<span class="line-modified">!        * pre-computed blue zones and leads to distortion when applying the</span>
<span class="line-modified">!        * hints in the code further below.  Code outside this emboldening</span>
<span class="line-modified">!        * block doesn&#39;t know we are presenting it with modified outlines the</span>
<span class="line-modified">!        * analyzer didn&#39;t see!</span>
         *
<span class="line-modified">!        * An unfortunate side effect of downscaling is that the emboldening</span>
<span class="line-modified">!        * effect is slightly decreased.  The loss becomes more pronounced</span>
<span class="line-modified">!        * versus the CFF driver at smaller sizes, e.g., at 9ppem and below.</span>
         */
        globals-&gt;scale_down_factor =
          FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
                     em_size );
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,14 ***</span>
      AF_StyleMetrics        style_metrics;
      FT_UInt                style_options = AF_STYLE_NONE_DFLT;
      AF_StyleClass          style_class;
      AF_WritingSystemClass  writing_system_class;
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-     AF_FaceGlobals  globals = loader-&gt;globals;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
  
      if ( !size )
        return FT_THROW( Invalid_Size_Handle );
  
      FT_ZERO( &amp;scaler );
<span class="line-new-header">--- 229,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 280,17 ***</span>
        }
  #endif /* AF_CONFIG_OPTION_TT_SIZE_METRICS */
      }
  
      /*
<span class="line-modified">!      *  TODO: This code currently doesn&#39;t support fractional advance widths,</span>
<span class="line-modified">!      *  i.e., placing hinted glyphs at anything other than integer</span>
<span class="line-modified">!      *  x-positions.  This is only relevant for the warper code, which</span>
<span class="line-modified">!      *  scales and shifts glyphs to optimize blackness of stems (hinting on</span>
<span class="line-modified">!      *  the x-axis by nature places things on pixel integers, hinting on the</span>
<span class="line-modified">!      *  y-axis only, i.e., LIGHT mode, doesn&#39;t touch the x-axis).  The delta</span>
<span class="line-modified">!      *  values of the scaler would need to be adjusted.</span>
       */
      scaler.face    = face;
      scaler.x_scale = size_internal-&gt;autohint_metrics.x_scale;
      scaler.x_delta = 0;
      scaler.y_scale = size_internal-&gt;autohint_metrics.y_scale;
<span class="line-new-header">--- 275,17 ---</span>
        }
  #endif /* AF_CONFIG_OPTION_TT_SIZE_METRICS */
      }
  
      /*
<span class="line-modified">!      * TODO: This code currently doesn&#39;t support fractional advance widths,</span>
<span class="line-modified">!      * i.e., placing hinted glyphs at anything other than integer</span>
<span class="line-modified">!      * x-positions.  This is only relevant for the warper code, which</span>
<span class="line-modified">!      * scales and shifts glyphs to optimize blackness of stems (hinting on</span>
<span class="line-modified">!      * the x-axis by nature places things on pixel integers, hinting on the</span>
<span class="line-modified">!      * y-axis only, i.e., LIGHT mode, doesn&#39;t touch the x-axis).  The delta</span>
<span class="line-modified">!      * values of the scaler would need to be adjusted.</span>
       */
      scaler.face    = face;
      scaler.x_scale = size_internal-&gt;autohint_metrics.x_scale;
      scaler.x_delta = 0;
      scaler.y_scale = size_internal-&gt;autohint_metrics.y_scale;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 310,23 ***</span>
      if ( load_flags &amp; ( 1UL &lt;&lt; 20 ) )
        style_options = AF_STYLE_LTN2_DFLT;
  #endif
  
      /*
<span class="line-modified">!      *  Glyphs (really code points) are assigned to scripts.  Script</span>
<span class="line-modified">!      *  analysis is done lazily: For each glyph that passes through here,</span>
<span class="line-modified">!      *  the corresponding script analyzer is called, but returns immediately</span>
<span class="line-modified">!      *  if it has been run already.</span>
       */
      error = af_face_globals_get_metrics( loader-&gt;globals, glyph_index,
                                           style_options, &amp;style_metrics );
      if ( error )
        goto Exit;
  
      style_class          = style_metrics-&gt;style_class;
      writing_system_class =
<span class="line-modified">!       AF_WRITING_SYSTEM_CLASSES_GET[style_class-&gt;writing_system];</span>
  
      loader-&gt;metrics = style_metrics;
  
      if ( writing_system_class-&gt;style_metrics_scale )
        writing_system_class-&gt;style_metrics_scale( style_metrics, &amp;scaler );
<span class="line-new-header">--- 305,23 ---</span>
      if ( load_flags &amp; ( 1UL &lt;&lt; 20 ) )
        style_options = AF_STYLE_LTN2_DFLT;
  #endif
  
      /*
<span class="line-modified">!      * Glyphs (really code points) are assigned to scripts.  Script</span>
<span class="line-modified">!      * analysis is done lazily: For each glyph that passes through here,</span>
<span class="line-modified">!      * the corresponding script analyzer is called, but returns immediately</span>
<span class="line-modified">!      * if it has been run already.</span>
       */
      error = af_face_globals_get_metrics( loader-&gt;globals, glyph_index,
                                           style_options, &amp;style_metrics );
      if ( error )
        goto Exit;
  
      style_class          = style_metrics-&gt;style_class;
      writing_system_class =
<span class="line-modified">!       af_writing_system_classes[style_class-&gt;writing_system];</span>
  
      loader-&gt;metrics = style_metrics;
  
      if ( writing_system_class-&gt;style_metrics_scale )
        writing_system_class-&gt;style_metrics_scale( style_metrics, &amp;scaler );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,15 ***</span>
        if ( error )
          goto Exit;
      }
  
      /*
<span class="line-modified">!      *  Do the main work of `af_loader_load_glyph&#39;.  Note that we never have</span>
<span class="line-modified">!      *  to deal with composite glyphs as those get loaded into</span>
<span class="line-modified">!      *  FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph&#39; function.</span>
<span class="line-modified">!      *  In the rare cases where FT_LOAD_NO_RECURSE is set, it implies</span>
<span class="line-modified">!      *  FT_LOAD_NO_SCALE and as such the auto-hinter is never called.</span>
       */
      load_flags |=  FT_LOAD_NO_SCALE         |
                     FT_LOAD_IGNORE_TRANSFORM |
                     FT_LOAD_LINEAR_DESIGN;
      load_flags &amp;= ~FT_LOAD_RENDER;
<span class="line-new-header">--- 335,15 ---</span>
        if ( error )
          goto Exit;
      }
  
      /*
<span class="line-modified">!      * Do the main work of `af_loader_load_glyph&#39;.  Note that we never have</span>
<span class="line-modified">!      * to deal with composite glyphs as those get loaded into</span>
<span class="line-modified">!      * FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph&#39; function.</span>
<span class="line-modified">!      * In the rare cases where FT_LOAD_NO_RECURSE is set, it implies</span>
<span class="line-modified">!      * FT_LOAD_NO_SCALE and as such the auto-hinter is never called.</span>
       */
      load_flags |=  FT_LOAD_NO_SCALE         |
                     FT_LOAD_IGNORE_TRANSFORM |
                     FT_LOAD_LINEAR_DESIGN;
      load_flags &amp;= ~FT_LOAD_RENDER;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,30 ***</span>
      error = FT_Load_Glyph( face, glyph_index, load_flags );
      if ( error )
        goto Exit;
  
      /*
<span class="line-modified">!      *  Apply stem darkening (emboldening) here before hints are applied to</span>
<span class="line-modified">!      *  the outline.  Glyphs are scaled down proportionally to the</span>
<span class="line-modified">!      *  emboldening so that curve points don&#39;t fall outside their</span>
<span class="line-modified">!      *  precomputed blue zones.</span>
       *
<span class="line-modified">!      *  Any emboldening done by the font driver (e.g., the CFF driver)</span>
<span class="line-modified">!      *  doesn&#39;t reach here because the autohinter loads the unprocessed</span>
<span class="line-modified">!      *  glyphs in font units for analysis (functions `af_*_metrics_init_*&#39;)</span>
<span class="line-modified">!      *  and then above to prepare it for the rasterizers by itself,</span>
<span class="line-modified">!      *  independently of the font driver.  So emboldening must be done here,</span>
<span class="line-modified">!      *  within the autohinter.</span>
       *
<span class="line-modified">!      *  All glyphs to be autohinted pass through here one by one.  The</span>
<span class="line-modified">!      *  standard widths can therefore change from one glyph to the next,</span>
<span class="line-modified">!      *  depending on what script a glyph is assigned to (each script has its</span>
<span class="line-modified">!      *  own set of standard widths and other metrics).  The darkening amount</span>
<span class="line-modified">!      *  must therefore be recomputed for each size and</span>
<span class="line-modified">!      *  `standard_{vertical,horizontal}_width&#39; change.</span>
       *
<span class="line-modified">!      *  Ignore errors and carry on without emboldening.</span>
       *
       */
  
      /* stem darkening only works well in `light&#39; mode */
      if ( scaler.render_mode == FT_RENDER_MODE_LIGHT    &amp;&amp;
<span class="line-new-header">--- 351,30 ---</span>
      error = FT_Load_Glyph( face, glyph_index, load_flags );
      if ( error )
        goto Exit;
  
      /*
<span class="line-modified">!      * Apply stem darkening (emboldening) here before hints are applied to</span>
<span class="line-modified">!      * the outline.  Glyphs are scaled down proportionally to the</span>
<span class="line-modified">!      * emboldening so that curve points don&#39;t fall outside their</span>
<span class="line-modified">!      * precomputed blue zones.</span>
       *
<span class="line-modified">!      * Any emboldening done by the font driver (e.g., the CFF driver)</span>
<span class="line-modified">!      * doesn&#39;t reach here because the autohinter loads the unprocessed</span>
<span class="line-modified">!      * glyphs in font units for analysis (functions `af_*_metrics_init_*&#39;)</span>
<span class="line-modified">!      * and then above to prepare it for the rasterizers by itself,</span>
<span class="line-modified">!      * independently of the font driver.  So emboldening must be done here,</span>
<span class="line-modified">!      * within the autohinter.</span>
       *
<span class="line-modified">!      * All glyphs to be autohinted pass through here one by one.  The</span>
<span class="line-modified">!      * standard widths can therefore change from one glyph to the next,</span>
<span class="line-modified">!      * depending on what script a glyph is assigned to (each script has its</span>
<span class="line-modified">!      * own set of standard widths and other metrics).  The darkening amount</span>
<span class="line-modified">!      * must therefore be recomputed for each size and</span>
<span class="line-modified">!      * `standard_{vertical,horizontal}_width&#39; change.</span>
       *
<span class="line-modified">!      * Ignore errors and carry on without emboldening.</span>
       *
       */
  
      /* stem darkening only works well in `light&#39; mode */
      if ( scaler.render_mode == FT_RENDER_MODE_LIGHT    &amp;&amp;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,39 ***</span>
          goto Hint_Metrics;
  
        /* now load the slot image into the auto-outline */
        /* and run the automatic hinting process         */
        if ( writing_system_class-&gt;style_hints_apply )
<span class="line-modified">!         writing_system_class-&gt;style_hints_apply( glyph_index,</span>
<span class="line-modified">!                                                  hints,</span>
<span class="line-modified">!                                                  &amp;gloader-&gt;base.outline,</span>
<span class="line-modified">!                                                  style_metrics );</span>
  
        /* we now need to adjust the metrics according to the change in */
        /* width/positioning that occurred during the hinting process   */
        if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
        {
<span class="line-removed">-         FT_Pos  old_rsb, old_lsb, new_lsb;</span>
<span class="line-removed">-         FT_Pos  pp1x_uh, pp2x_uh;</span>
<span class="line-removed">- </span>
          AF_AxisHints  axis  = &amp;hints-&gt;axis[AF_DIMENSION_HORZ];
<span class="line-removed">-         AF_Edge       edge1 = axis-&gt;edges;         /* leftmost edge  */</span>
<span class="line-removed">-         AF_Edge       edge2 = edge1 +</span>
<span class="line-removed">-                               axis-&gt;num_edges - 1; /* rightmost edge */</span>
  
  
          if ( axis-&gt;num_edges &gt; 1 &amp;&amp; AF_HINTS_DO_ADVANCE( hints ) )
          {
<span class="line-modified">!           old_rsb = loader-&gt;pp2.x - edge2-&gt;opos;</span>
            /* loader-&gt;pp1.x is always zero at this point of time */
<span class="line-modified">!           old_lsb = edge1-&gt;opos /* - loader-&gt;pp1.x */;</span>
<span class="line-modified">!           new_lsb = edge1-&gt;pos;</span>
  
            /* remember unhinted values to later account */
            /* for rounding errors                       */
<span class="line-modified">!           pp1x_uh = new_lsb    - old_lsb;</span>
<span class="line-modified">!           pp2x_uh = edge2-&gt;pos + old_rsb;</span>
  
            /* prefer too much space over too little space */
            /* for very small sizes                        */
  
            if ( old_lsb &lt; 24 )
<span class="line-new-header">--- 419,43 ---</span>
          goto Hint_Metrics;
  
        /* now load the slot image into the auto-outline */
        /* and run the automatic hinting process         */
        if ( writing_system_class-&gt;style_hints_apply )
<span class="line-modified">!       {</span>
<span class="line-modified">!         error = writing_system_class-&gt;style_hints_apply(</span>
<span class="line-modified">!                   glyph_index,</span>
<span class="line-modified">!                   hints,</span>
<span class="line-added">+                   &amp;gloader-&gt;base.outline,</span>
<span class="line-added">+                   style_metrics );</span>
<span class="line-added">+         if ( error )</span>
<span class="line-added">+           goto Exit;</span>
<span class="line-added">+       }</span>
  
        /* we now need to adjust the metrics according to the change in */
        /* width/positioning that occurred during the hinting process   */
        if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
        {
          AF_AxisHints  axis  = &amp;hints-&gt;axis[AF_DIMENSION_HORZ];
  
  
          if ( axis-&gt;num_edges &gt; 1 &amp;&amp; AF_HINTS_DO_ADVANCE( hints ) )
          {
<span class="line-modified">!           AF_Edge  edge1 = axis-&gt;edges;         /* leftmost edge  */</span>
<span class="line-added">+           AF_Edge  edge2 = edge1 +</span>
<span class="line-added">+                            axis-&gt;num_edges - 1; /* rightmost edge */</span>
<span class="line-added">+ </span>
<span class="line-added">+           FT_Pos  old_rsb = loader-&gt;pp2.x - edge2-&gt;opos;</span>
            /* loader-&gt;pp1.x is always zero at this point of time */
<span class="line-modified">!           FT_Pos  old_lsb = edge1-&gt;opos;     /* - loader-&gt;pp1.x */</span>
<span class="line-modified">!           FT_Pos  new_lsb = edge1-&gt;pos;</span>
  
            /* remember unhinted values to later account */
            /* for rounding errors                       */
<span class="line-modified">!           FT_Pos  pp1x_uh = new_lsb    - old_lsb;</span>
<span class="line-modified">!           FT_Pos  pp2x_uh = edge2-&gt;pos + old_rsb;</span>
<span class="line-added">+ </span>
  
            /* prefer too much space over too little space */
            /* for very small sizes                        */
  
            if ( old_lsb &lt; 24 )
</pre>
<center><a href="aflatin.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afloader.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
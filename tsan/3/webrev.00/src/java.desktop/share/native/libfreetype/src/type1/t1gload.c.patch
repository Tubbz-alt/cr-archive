diff a/src/java.desktop/share/native/libfreetype/src/type1/t1gload.c b/src/java.desktop/share/native/libfreetype/src/type1/t1gload.c
--- a/src/java.desktop/share/native/libfreetype/src/type1/t1gload.c
+++ b/src/java.desktop/share/native/libfreetype/src/type1/t1gload.c
@@ -1,21 +1,21 @@
-/***************************************************************************/
-/*                                                                         */
-/*  t1gload.c                                                              */
-/*                                                                         */
-/*    Type 1 Glyph Loader (body).                                          */
-/*                                                                         */
-/*  Copyright 1996-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * t1gload.c
+ *
+ *   Type 1 Glyph Loader (body).
+ *
+ * Copyright (C) 1996-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include "t1gload.h"
 #include FT_INTERNAL_CALC_H
@@ -27,18 +27,18 @@
 #include FT_DRIVER_H
 
 #include "t1errors.h"
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_t1gload
+#define FT_COMPONENT  t1gload
 
 
   static FT_Error
   T1_Parse_Glyph_And_Get_Char_String( T1_Decoder  decoder,
                                       FT_UInt     glyph_index,
@@ -60,10 +60,11 @@
 
 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
     PS_Driver  driver = (PS_Driver)FT_FACE_DRIVER( face );
 #endif
 
+
     decoder->font_matrix = type1->font_matrix;
     decoder->font_offset = type1->font_offset;
 
 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 
@@ -247,10 +248,12 @@
     decoder.buildchar     = face->buildchar;
     decoder.len_buildchar = face->len_buildchar;
 
     *max_advance = 0;
 
+    FT_TRACE6(( "T1_Compute_Max_Advance:\n" ));
+
     /* for each glyph, parse the glyph charstring and extract */
     /* the advance width                                      */
     for ( glyph_index = 0; glyph_index < type1->num_glyphs; glyph_index++ )
     {
       /* now get load the unscaled outline */
@@ -259,10 +262,13 @@
         *max_advance = decoder.builder.advance.x;
 
       /* ignore the error if one occurred - skip to next glyph */
     }
 
+    FT_TRACE6(( "T1_Compute_Max_Advance: max advance: %f\n",
+                *max_advance / 65536.0 ));
+
     psaux->t1_decoder_funcs->done( &decoder );
 
     return FT_Err_Ok;
   }
 
@@ -280,15 +286,22 @@
     PSAux_Service  psaux = (PSAux_Service)face->psaux;
     FT_UInt        nn;
     FT_Error       error;
 
 
+    FT_TRACE5(( "T1_Get_Advances:\n" ));
+
     if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
     {
       for ( nn = 0; nn < count; nn++ )
+      {
         advances[nn] = 0;
 
+        FT_TRACE5(( "  idx %d: advance height 0 font units\n",
+                    first + nn ));
+      }
+
       return FT_Err_Ok;
     }
 
     error = psaux->t1_decoder_funcs->init( &decoder,
                                            (FT_Face)face,
@@ -318,10 +331,15 @@
       error = T1_Parse_Glyph( &decoder, first + nn );
       if ( !error )
         advances[nn] = FIXED_TO_INT( decoder.builder.advance.x );
       else
         advances[nn] = 0;
+
+      FT_TRACE5(( "  idx %d: advance width %d font unit%s\n",
+                  first + nn,
+                  advances[nn],
+                  advances[nn] == 1 ? "" : "s" ));
     }
 
     return FT_Err_Ok;
   }
 
@@ -382,13 +400,13 @@
     }
 
     t1glyph->outline.n_points   = 0;
     t1glyph->outline.n_contours = 0;
 
-    hinting = FT_BOOL( ( load_flags & FT_LOAD_NO_SCALE   ) == 0 &&
-                       ( load_flags & FT_LOAD_NO_HINTING ) == 0 );
-    scaled  = FT_BOOL( ( load_flags & FT_LOAD_NO_SCALE   ) == 0 );
+    hinting = FT_BOOL( !( load_flags & FT_LOAD_NO_SCALE   ) &&
+                       !( load_flags & FT_LOAD_NO_HINTING ) );
+    scaled  = FT_BOOL( !( load_flags & FT_LOAD_NO_SCALE   ) );
 
     glyph->hint     = hinting;
     glyph->scaled   = scaled;
     t1glyph->format = FT_GLYPH_FORMAT_OUTLINE;
 
@@ -396,20 +414,19 @@
                                  t1glyph->face,
                                  t1size,
                                  t1glyph,
                                  (FT_Byte**)type1->glyph_names,
                                  face->blend,
-                                 FT_BOOL( hinting ),
+                                 hinting,
                                  FT_LOAD_TARGET_MODE( load_flags ),
                                  T1_Parse_Glyph );
     if ( error )
       goto Exit;
 
     must_finish_decoder = TRUE;
 
-    decoder.builder.no_recurse = FT_BOOL(
-                                   ( load_flags & FT_LOAD_NO_RECURSE ) != 0 );
+    decoder.builder.no_recurse = FT_BOOL( load_flags & FT_LOAD_NO_RECURSE );
 
     decoder.num_subrs     = type1->num_subrs;
     decoder.subrs         = type1->subrs;
     decoder.subrs_len     = type1->subrs_len;
     decoder.subrs_hash    = type1->subrs_hash;
@@ -526,11 +543,11 @@
           FT_Fixed     x_scale = glyph->x_scale;
           FT_Fixed     y_scale = glyph->y_scale;
 
 
           /* First of all, scale the points, if we are not hinting */
-          if ( !hinting || ! decoder.builder.hints_funcs )
+          if ( !hinting || !decoder.builder.hints_funcs )
             for ( n = cur->n_points; n > 0; n--, vec++ )
             {
               vec->x = FT_MulFix( vec->x, x_scale );
               vec->y = FT_MulFix( vec->y, y_scale );
             }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afglobal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,37 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  afhints.c                                                              */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Auto-fitter hinting routines (body).                                 */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #include &quot;afhints.h&quot;
  #include &quot;aferrors.h&quot;
  #include FT_INTERNAL_CALC_H
  #include FT_INTERNAL_DEBUG_H
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_afhints</span>
  
  
    /* Get new segment for given axis. */
  
    FT_LOCAL_DEF( FT_Error )
<span class="line-new-header">--- 1,37 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * afhints.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Auto-fitter hinting routines (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #include &quot;afhints.h&quot;
  #include &quot;aferrors.h&quot;
  #include FT_INTERNAL_CALC_H
  #include FT_INTERNAL_DEBUG_H
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  afhints</span>
  
  
    /* Get new segment for given axis. */
  
    FT_LOCAL_DEF( FT_Error )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,10 ***</span>
<span class="line-new-header">--- 295,23 ---</span>
  
      return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
    }
  
  
<span class="line-added">+   static int</span>
<span class="line-added">+   af_get_strong_edge_index( AF_GlyphHints  hints,</span>
<span class="line-added">+                             AF_Edge*       strong_edges,</span>
<span class="line-added">+                             int            dimension )</span>
<span class="line-added">+   {</span>
<span class="line-added">+     AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];</span>
<span class="line-added">+     AF_Edge       edges = axis-&gt;edges;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     return AF_INDEX_NUM( strong_edges[dimension], edges );</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #ifdef __cplusplus
    extern &quot;C&quot; {
  #endif
    void
    af_glyph_hints_dump_points( AF_GlyphHints  hints,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 315,12 ***</span>
  
      if ( hints-&gt;num_points )
      {
        AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
               /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<span class="line-modified">!                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit&quot; ));</span>
               /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
      }
      else
        AF_DUMP(( &quot;  (none)\n&quot; ));
  
      for ( point = points; point &lt; limit; point++ )
<span class="line-new-header">--- 328,14 ---</span>
  
      if ( hints-&gt;num_points )
      {
        AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
               /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<span class="line-modified">!                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit &quot;</span>
               /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
<span class="line-added">+                 &quot;  hbef  haft  vbef  vaft&quot; ));</span>
<span class="line-added">+              /* &quot; XXXXX XXXXX XXXXX XXXXX&quot; */</span>
      }
      else
        AF_DUMP(( &quot;  (none)\n&quot; ));
  
      for ( point = points; point &lt; limit; point++ )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,21 ***</span>
        int  point_idx     = AF_INDEX_NUM( point, points );
        int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
        int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
  
        char  buf1[16], buf2[16], buf3[16], buf4[16];
  
  
        /* insert extra newline at the beginning of a contour */
        if ( contour &lt; climit &amp;&amp; *contour == point )
        {
          AF_DUMP(( &quot;\n&quot; ));
          contour++;
        }
  
        AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<span class="line-modified">!                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f\n&quot;,</span>
                  point_idx,
                  af_print_idx( buf1,
                                af_get_edge_index( hints, segment_idx_1, 1 ) ),
                  af_print_idx( buf2, segment_idx_1 ),
                  af_print_idx( buf3,
<span class="line-new-header">--- 343,23 ---</span>
        int  point_idx     = AF_INDEX_NUM( point, points );
        int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
        int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
  
        char  buf1[16], buf2[16], buf3[16], buf4[16];
<span class="line-added">+       char  buf5[16], buf6[16], buf7[16], buf8[16];</span>
  
  
        /* insert extra newline at the beginning of a contour */
        if ( contour &lt; climit &amp;&amp; *contour == point )
        {
          AF_DUMP(( &quot;\n&quot; ));
          contour++;
        }
  
        AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<span class="line-modified">!                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f&quot;</span>
<span class="line-added">+                 &quot; %5s %5s %5s %5s\n&quot;,</span>
                  point_idx,
                  af_print_idx( buf1,
                                af_get_edge_index( hints, segment_idx_1, 1 ) ),
                  af_print_idx( buf2, segment_idx_1 ),
                  af_print_idx( buf3,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,11 ***</span>
                  point-&gt;fx,
                  point-&gt;fy,
                  point-&gt;ox / 64.0,
                  point-&gt;oy / 64.0,
                  point-&gt;x / 64.0,
<span class="line-modified">!                 point-&gt;y / 64.0 ));</span>
      }
      AF_DUMP(( &quot;\n&quot; ));
    }
  #ifdef __cplusplus
    }
<span class="line-new-header">--- 374,24 ---</span>
                  point-&gt;fx,
                  point-&gt;fy,
                  point-&gt;ox / 64.0,
                  point-&gt;oy / 64.0,
                  point-&gt;x / 64.0,
<span class="line-modified">!                 point-&gt;y / 64.0,</span>
<span class="line-added">+ </span>
<span class="line-added">+                 af_print_idx( buf5, af_get_strong_edge_index( hints,</span>
<span class="line-added">+                                                               point-&gt;before,</span>
<span class="line-added">+                                                               1 ) ),</span>
<span class="line-added">+                 af_print_idx( buf6, af_get_strong_edge_index( hints,</span>
<span class="line-added">+                                                               point-&gt;after,</span>
<span class="line-added">+                                                               1 ) ),</span>
<span class="line-added">+                 af_print_idx( buf7, af_get_strong_edge_index( hints,</span>
<span class="line-added">+                                                               point-&gt;before,</span>
<span class="line-added">+                                                               0 ) ),</span>
<span class="line-added">+                 af_print_idx( buf8, af_get_strong_edge_index( hints,</span>
<span class="line-added">+                                                               point-&gt;after,</span>
<span class="line-added">+                                                               0 ) ) ));</span>
      }
      AF_DUMP(( &quot;\n&quot; ));
    }
  #ifdef __cplusplus
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,11 ***</span>
  
      seg      = &amp;axis-&gt;segments[idx];
      *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
                                              : seg-&gt;first-&gt;fy;
      if ( seg-&gt;edge )
<span class="line-modified">!       *is_blue = (FT_Bool)( seg-&gt;edge-&gt;blue_edge != 0 );</span>
      else
        *is_blue = FALSE;
  
      if ( *is_blue )
        *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
<span class="line-new-header">--- 547,11 ---</span>
  
      seg      = &amp;axis-&gt;segments[idx];
      *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
                                              : seg-&gt;first-&gt;fy;
      if ( seg-&gt;edge )
<span class="line-modified">!       *is_blue = FT_BOOL( seg-&gt;edge-&gt;blue_edge );</span>
      else
        *is_blue = FALSE;
  
      if ( *is_blue )
        *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,12 ***</span>
  
        char  buf1[16], buf2[16];
  
  
        /*
<span class="line-modified">!        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified">!        *        since they have a constant X coordinate.</span>
         */
        if ( dimension == AF_DIMENSION_HORZ )
          AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
                    &quot;vertical&quot;,
                    65536.0 * 64.0 / hints-&gt;x_scale,
<span class="line-new-header">--- 586,12 ---</span>
  
        char  buf1[16], buf2[16];
  
  
        /*
<span class="line-modified">!        * note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified">!        *       since they have a constant X coordinate.</span>
         */
        if ( dimension == AF_DIMENSION_HORZ )
          AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
                    &quot;vertical&quot;,
                    65536.0 * 64.0 / hints-&gt;x_scale,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 679,12 ***</span>
        return;
  
      memory = hints-&gt;memory;
  
      /*
<span class="line-modified">!      *  note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified">!      *  buffers since they are really within the hints-&gt;points array</span>
       */
      for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
      {
        AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
  
<span class="line-new-header">--- 709,12 ---</span>
        return;
  
      memory = hints-&gt;memory;
  
      /*
<span class="line-modified">!      * note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified">!      * buffers since they are really within the hints-&gt;points array</span>
       */
      for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
      {
        AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 774,13 ***</span>
  
        hints-&gt;max_contours = (FT_Int)new_max;
      }
  
      /*
<span class="line-modified">!      *  then reallocate the points arrays if necessary --</span>
<span class="line-modified">!      *  note that we reserve two additional point positions, used to</span>
<span class="line-modified">!      *  hint metrics appropriately</span>
       */
      new_max = (FT_UInt)( outline-&gt;n_points + 2 );
      old_max = (FT_UInt)hints-&gt;max_points;
  
      if ( new_max &lt;= AF_POINTS_EMBEDDED )
<span class="line-new-header">--- 804,13 ---</span>
  
        hints-&gt;max_contours = (FT_Int)new_max;
      }
  
      /*
<span class="line-modified">!      * then reallocate the points arrays if necessary --</span>
<span class="line-modified">!      * note that we reserve two additional point positions, used to</span>
<span class="line-modified">!      * hint metrics appropriately</span>
       */
      new_max = (FT_UInt)( outline-&gt;n_points + 2 );
      old_max = (FT_UInt)hints-&gt;max_points;
  
      if ( new_max &lt;= AF_POINTS_EMBEDDED )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,10 ***</span>
<span class="line-new-header">--- 926,18 ---</span>
                endpoint = outline-&gt;contours[contour_index];
                end      = points + endpoint;
                prev     = end;
              }
            }
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+           point-&gt;before[0] = NULL;</span>
<span class="line-added">+           point-&gt;before[1] = NULL;</span>
<span class="line-added">+           point-&gt;after[0]  = NULL;</span>
<span class="line-added">+           point-&gt;after[1]  = NULL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
          }
        }
  
        /* set up the contours array */
        {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 916,19 ***</span>
          }
        }
  
        {
          /*
<span class="line-modified">!          *  Compute directions of `in&#39; and `out&#39; vectors.</span>
           *
<span class="line-modified">!          *  Note that distances between points that are very near to each</span>
<span class="line-modified">!          *  other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified">!          *  prepends the small vectors between near points to the first</span>
<span class="line-modified">!          *  non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified">!          *  threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified">!          *  points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified">!          *  be equal to the accumulated one.</span>
           */
  
          FT_Int  near_limit2 = 2 * near_limit - 1;
  
          AF_Point*  contour;
<span class="line-new-header">--- 954,19 ---</span>
          }
        }
  
        {
          /*
<span class="line-modified">!          * Compute directions of `in&#39; and `out&#39; vectors.</span>
           *
<span class="line-modified">!          * Note that distances between points that are very near to each</span>
<span class="line-modified">!          * other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified">!          * prepends the small vectors between near points to the first</span>
<span class="line-modified">!          * non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified">!          * threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified">!          * points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified">!          * be equal to the accumulated one.</span>
           */
  
          FT_Int  near_limit2 = 2 * near_limit - 1;
  
          AF_Point*  contour;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,16 ***</span>
            {
              out_x = point-&gt;fx - prev-&gt;fx;
              out_y = point-&gt;fy - prev-&gt;fy;
  
              /*
<span class="line-modified">!              *  We use Taxicab metrics to measure the vector length.</span>
               *
<span class="line-modified">!              *  Note that the accumulated distances so far could have the</span>
<span class="line-modified">!              *  opposite direction of the distance measured here.  For this</span>
<span class="line-modified">!              *  reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified">!              *  non-near point even in the worst case.</span>
               */
              if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
                break;
  
              point = prev;
<span class="line-new-header">--- 992,16 ---</span>
            {
              out_x = point-&gt;fx - prev-&gt;fx;
              out_y = point-&gt;fy - prev-&gt;fy;
  
              /*
<span class="line-modified">!              * We use Taxicab metrics to measure the vector length.</span>
               *
<span class="line-modified">!              * Note that the accumulated distances so far could have the</span>
<span class="line-modified">!              * opposite direction of the distance measured here.  For this</span>
<span class="line-modified">!              * reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified">!              * non-near point even in the worst case.</span>
               */
              if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
                break;
  
              point = prev;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 977,15 ***</span>
            /* `in&#39; and `out&#39; vector directions               */
  
            curr = first;
  
            /*
<span class="line-modified">!            *  We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified">!            *  next and previous non-near point, respectively.</span>
             *
<span class="line-modified">!            *  To avoid problems with not having non-near points, we point to</span>
<span class="line-modified">!            *  `first&#39; by default as the next non-near point.</span>
             *
             */
            curr-&gt;u  = (FT_Pos)( first - curr );
            first-&gt;v = -curr-&gt;u;
  
<span class="line-new-header">--- 1015,15 ---</span>
            /* `in&#39; and `out&#39; vector directions               */
  
            curr = first;
  
            /*
<span class="line-modified">!            * We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified">!            * next and previous non-near point, respectively.</span>
             *
<span class="line-modified">!            * To avoid problems with not having non-near points, we point to</span>
<span class="line-modified">!            * `first&#39; by default as the next non-near point.</span>
             *
             */
            curr-&gt;u  = (FT_Pos)( first - curr );
            first-&gt;v = -curr-&gt;u;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1033,16 ***</span>
  
            } while ( next != first );
          }
  
          /*
<span class="line-modified">!          *  The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">!          *  can identify local extrema more reliably: A series of</span>
<span class="line-modified">!          *  non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">!          *  quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">!          *  topological point of the view, the intermediate points are of no</span>
<span class="line-modified">!          *  interest and thus tagged as weak.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
<span class="line-new-header">--- 1071,16 ---</span>
  
            } while ( next != first );
          }
  
          /*
<span class="line-modified">!          * The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">!          * can identify local extrema more reliably: A series of</span>
<span class="line-modified">!          * non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">!          * quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">!          * topological point of the view, the intermediate points are of no</span>
<span class="line-modified">!          * interest and thus tagged as weak.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1078,13 ***</span>
              }
            }
          }
  
          /*
<span class="line-modified">!          *  Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">!          *  collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">!          *  points.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
<span class="line-new-header">--- 1116,13 ---</span>
              }
            }
          }
  
          /*
<span class="line-modified">!          * Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">!          * collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">!          * points.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1307,19 ***</span>
<span class="line-new-header">--- 1345,31 ---</span>
          edge  = edges;
          delta = edge-&gt;fpos - u;
          if ( delta &gt;= 0 )
          {
            u = edge-&gt;pos - ( edge-&gt;opos - ou );
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+           point-&gt;before[dim] = edge;</span>
<span class="line-added">+           point-&gt;after[dim]  = NULL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
            goto Store_Point;
          }
  
          /* is the point after the last edge? */
          edge  = edge_limit - 1;
          delta = u - edge-&gt;fpos;
          if ( delta &gt;= 0 )
          {
            u = edge-&gt;pos + ( ou - edge-&gt;opos );
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+           point-&gt;before[dim] = NULL;</span>
<span class="line-added">+           point-&gt;after[dim]  = edge;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
            goto Store_Point;
          }
  
          {
            FT_PtrDist  min, max, mid;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1362,20 ***</span>
<span class="line-new-header">--- 1412,31 ---</span>
                min = mid + 1;
              else
              {
                /* we are on the edge */
                u = edge-&gt;pos;
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+               point-&gt;before[dim] = NULL;</span>
<span class="line-added">+               point-&gt;after[dim]  = NULL;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
                goto Store_Point;
              }
            }
  
            /* point is not on an edge */
            {
              AF_Edge  before = edges + min - 1;
              AF_Edge  after  = edges + min + 0;
  
  
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+             point-&gt;before[dim] = before;</span>
<span class="line-added">+             point-&gt;after[dim]  = after;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
              /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
              if ( before-&gt;scale == 0 )
                before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
                                           after-&gt;fpos - before-&gt;fpos );
  
</pre>
<center><a href="afglobal.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
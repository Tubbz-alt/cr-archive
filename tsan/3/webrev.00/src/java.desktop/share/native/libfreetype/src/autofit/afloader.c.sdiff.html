<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/afloader.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="aflatin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afloader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afloader.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  afloader.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Auto-fitter glyph loading routines (body).                           */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &quot;afglobal.h&quot;
 20 #include &quot;afloader.h&quot;
 21 #include &quot;afhints.h&quot;
 22 #include &quot;aferrors.h&quot;
 23 #include &quot;afmodule.h&quot;
<span class="line-removed"> 24 #include &quot;afpic.h&quot;</span>
 25 
 26 #include FT_INTERNAL_CALC_H
 27 
 28 
 29   /* Initialize glyph loader. */
 30 
 31   FT_LOCAL_DEF( void )
 32   af_loader_init( AF_Loader      loader,
 33                   AF_GlyphHints  hints )
 34   {
 35     FT_ZERO( loader );
 36 
 37     loader-&gt;hints = hints;
 38   }
 39 
 40 
 41   /* Reset glyph loader and compute globals if necessary. */
 42 
 43   FT_LOCAL_DEF( FT_Error )
 44   af_loader_reset( AF_Loader  loader,
</pre>
<hr />
<pre>
102     FT_Pos  stdVW = 0;
103     FT_Pos  stdHW = 0;
104 
105     FT_Bool  size_changed = size_metrics-&gt;x_ppem !=
106                               globals-&gt;stem_darkening_for_ppem;
107 
108     FT_Fixed  em_size  = af_intToFixed( face-&gt;units_per_EM );
109     FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );
110 
111     FT_Matrix  scale_down_matrix = { 0x10000L, 0, 0, 0x10000L };
112 
113 
114     /* Skip stem darkening for broken fonts. */
115     if ( !face-&gt;units_per_EM )
116     {
117       error = FT_ERR( Corrupted_Font_Header );
118       goto Exit;
119     }
120 
121     /*
<span class="line-modified">122      *  We depend on the writing system (script analyzers) to supply</span>
<span class="line-modified">123      *  standard widths for the script of the glyph we are looking at.  If</span>
<span class="line-modified">124      *  it can&#39;t deliver, stem darkening is disabled.</span>
125      */
126     writing_system_class =
<span class="line-modified">127       AF_WRITING_SYSTEM_CLASSES_GET[style_metrics-&gt;style_class-&gt;writing_system];</span>
128 
129     if ( writing_system_class-&gt;style_metrics_getstdw )
130       writing_system_class-&gt;style_metrics_getstdw( style_metrics,
131                                                    &amp;stdHW,
132                                                    &amp;stdVW );
133     else
134     {
135       error = FT_ERR( Unimplemented_Feature );
136       goto Exit;
137     }
138 
139     if ( size_changed                                               ||
140          ( stdVW &gt; 0 &amp;&amp; stdVW != globals-&gt;standard_vertical_width ) )
141     {
142       FT_Fixed  darken_by_font_units_x, darken_x;
143 
144 
145       darken_by_font_units_x =
146         af_intToFixed( af_loader_compute_darkening( loader,
147                                                     face,
</pre>
<hr />
<pre>
157 
158     if ( size_changed                                                 ||
159          ( stdHW &gt; 0 &amp;&amp; stdHW != globals-&gt;standard_horizontal_width ) )
160     {
161       FT_Fixed  darken_by_font_units_y, darken_y;
162 
163 
164       darken_by_font_units_y =
165         af_intToFixed( af_loader_compute_darkening( loader,
166                                                     face,
167                                                     stdHW ) );
168       darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,
169                                        size_metrics-&gt;y_scale ),
170                             em_ratio );
171 
172       globals-&gt;standard_horizontal_width = stdHW;
173       globals-&gt;stem_darkening_for_ppem   = size_metrics-&gt;x_ppem;
174       globals-&gt;darken_y                  = af_fixedToInt( darken_y );
175 
176       /*
<span class="line-modified">177        *  Scale outlines down on the Y-axis to keep them inside their blue</span>
<span class="line-modified">178        *  zones.  The stronger the emboldening, the stronger the downscaling</span>
<span class="line-modified">179        *  (plus heuristical padding to prevent outlines still falling out</span>
<span class="line-modified">180        *  their zones due to rounding).</span>
181        *
<span class="line-modified">182        *  Reason: `FT_Outline_Embolden&#39; works by shifting the rightmost</span>
<span class="line-modified">183        *  points of stems farther to the right, and topmost points farther</span>
<span class="line-modified">184        *  up.  This positions points on the Y-axis outside their</span>
<span class="line-modified">185        *  pre-computed blue zones and leads to distortion when applying the</span>
<span class="line-modified">186        *  hints in the code further below.  Code outside this emboldening</span>
<span class="line-modified">187        *  block doesn&#39;t know we are presenting it with modified outlines the</span>
<span class="line-modified">188        *  analyzer didn&#39;t see!</span>
189        *
<span class="line-modified">190        *  An unfortunate side effect of downscaling is that the emboldening</span>
<span class="line-modified">191        *  effect is slightly decreased.  The loss becomes more pronounced</span>
<span class="line-modified">192        *  versus the CFF driver at smaller sizes, e.g., at 9ppem and below.</span>
193        */
194       globals-&gt;scale_down_factor =
195         FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
196                    em_size );
197     }
198 
199     FT_Outline_EmboldenXY( &amp;slot-&gt;outline,
200                            globals-&gt;darken_x,
201                            globals-&gt;darken_y );
202 
203     scale_down_matrix.yy = globals-&gt;scale_down_factor;
204     FT_Outline_Transform( &amp;slot-&gt;outline, &amp;scale_down_matrix );
205 
206   Exit:
207     return error;
208   }
209 
210 
211   /* Load the glyph at index into the current slot of a face and hint it. */
212 
</pre>
<hr />
<pre>
215                         AF_Module  module,
216                         FT_Face    face,
217                         FT_UInt    glyph_index,
218                         FT_Int32   load_flags )
219   {
220     FT_Error  error;
221 
222     FT_Size           size          = face-&gt;size;
223     FT_Size_Internal  size_internal = size-&gt;internal;
224     FT_GlyphSlot      slot          = face-&gt;glyph;
225     FT_Slot_Internal  slot_internal = slot-&gt;internal;
226     FT_GlyphLoader    gloader       = slot_internal-&gt;loader;
227 
228     AF_GlyphHints          hints         = loader-&gt;hints;
229     AF_ScalerRec           scaler;
230     AF_StyleMetrics        style_metrics;
231     FT_UInt                style_options = AF_STYLE_NONE_DFLT;
232     AF_StyleClass          style_class;
233     AF_WritingSystemClass  writing_system_class;
234 
<span class="line-removed">235 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">236     AF_FaceGlobals  globals = loader-&gt;globals;</span>
<span class="line-removed">237 #endif</span>
<span class="line-removed">238 </span>
239 
240     if ( !size )
241       return FT_THROW( Invalid_Size_Handle );
242 
243     FT_ZERO( &amp;scaler );
244 
245     if ( !size_internal-&gt;autohint_metrics.x_scale                          ||
246          size_internal-&gt;autohint_mode != FT_LOAD_TARGET_MODE( load_flags ) )
247     {
248       /* switching between hinting modes usually means different scaling */
249       /* values; this later on enforces recomputation of everything      */
250       /* related to the current size                                     */
251 
252       size_internal-&gt;autohint_mode    = FT_LOAD_TARGET_MODE( load_flags );
253       size_internal-&gt;autohint_metrics = size-&gt;metrics;
254 
255 #ifdef AF_CONFIG_OPTION_TT_SIZE_METRICS
256       {
257         FT_Size_Metrics*  size_metrics = &amp;size_internal-&gt;autohint_metrics;
258 
</pre>
<hr />
<pre>
265                                                size_metrics-&gt;y_scale ) );
266         size_metrics-&gt;descender = FT_PIX_ROUND(
267                                     FT_MulFix( face-&gt;descender,
268                                                size_metrics-&gt;y_scale ) );
269         size_metrics-&gt;height    = FT_PIX_ROUND(
270                                     FT_MulFix( face-&gt;height,
271                                                size_metrics-&gt;y_scale ) );
272 
273         size_metrics-&gt;x_scale     = FT_DivFix( size_metrics-&gt;x_ppem &lt;&lt; 6,
274                                                face-&gt;units_per_EM );
275         size_metrics-&gt;y_scale     = FT_DivFix( size_metrics-&gt;y_ppem &lt;&lt; 6,
276                                                face-&gt;units_per_EM );
277         size_metrics-&gt;max_advance = FT_PIX_ROUND(
278                                       FT_MulFix( face-&gt;max_advance_width,
279                                                  size_metrics-&gt;x_scale ) );
280       }
281 #endif /* AF_CONFIG_OPTION_TT_SIZE_METRICS */
282     }
283 
284     /*
<span class="line-modified">285      *  TODO: This code currently doesn&#39;t support fractional advance widths,</span>
<span class="line-modified">286      *  i.e., placing hinted glyphs at anything other than integer</span>
<span class="line-modified">287      *  x-positions.  This is only relevant for the warper code, which</span>
<span class="line-modified">288      *  scales and shifts glyphs to optimize blackness of stems (hinting on</span>
<span class="line-modified">289      *  the x-axis by nature places things on pixel integers, hinting on the</span>
<span class="line-modified">290      *  y-axis only, i.e., LIGHT mode, doesn&#39;t touch the x-axis).  The delta</span>
<span class="line-modified">291      *  values of the scaler would need to be adjusted.</span>
292      */
293     scaler.face    = face;
294     scaler.x_scale = size_internal-&gt;autohint_metrics.x_scale;
295     scaler.x_delta = 0;
296     scaler.y_scale = size_internal-&gt;autohint_metrics.y_scale;
297     scaler.y_delta = 0;
298 
299     scaler.render_mode = FT_LOAD_TARGET_MODE( load_flags );
300     scaler.flags       = 0;
301 
302     /* note that the fallback style can&#39;t be changed anymore */
303     /* after the first call of `af_loader_load_glyph&#39;        */
304     error = af_loader_reset( loader, module, face );
305     if ( error )
306       goto Exit;
307 
308 #ifdef FT_OPTION_AUTOFIT2
309     /* XXX: undocumented hook to activate the latin2 writing system. */
310     if ( load_flags &amp; ( 1UL &lt;&lt; 20 ) )
311       style_options = AF_STYLE_LTN2_DFLT;
312 #endif
313 
314     /*
<span class="line-modified">315      *  Glyphs (really code points) are assigned to scripts.  Script</span>
<span class="line-modified">316      *  analysis is done lazily: For each glyph that passes through here,</span>
<span class="line-modified">317      *  the corresponding script analyzer is called, but returns immediately</span>
<span class="line-modified">318      *  if it has been run already.</span>
319      */
320     error = af_face_globals_get_metrics( loader-&gt;globals, glyph_index,
321                                          style_options, &amp;style_metrics );
322     if ( error )
323       goto Exit;
324 
325     style_class          = style_metrics-&gt;style_class;
326     writing_system_class =
<span class="line-modified">327       AF_WRITING_SYSTEM_CLASSES_GET[style_class-&gt;writing_system];</span>
328 
329     loader-&gt;metrics = style_metrics;
330 
331     if ( writing_system_class-&gt;style_metrics_scale )
332       writing_system_class-&gt;style_metrics_scale( style_metrics, &amp;scaler );
333     else
334       style_metrics-&gt;scaler = scaler;
335 
336     if ( writing_system_class-&gt;style_hints_init )
337     {
338       error = writing_system_class-&gt;style_hints_init( hints,
339                                                       style_metrics );
340       if ( error )
341         goto Exit;
342     }
343 
344     /*
<span class="line-modified">345      *  Do the main work of `af_loader_load_glyph&#39;.  Note that we never have</span>
<span class="line-modified">346      *  to deal with composite glyphs as those get loaded into</span>
<span class="line-modified">347      *  FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph&#39; function.</span>
<span class="line-modified">348      *  In the rare cases where FT_LOAD_NO_RECURSE is set, it implies</span>
<span class="line-modified">349      *  FT_LOAD_NO_SCALE and as such the auto-hinter is never called.</span>
350      */
351     load_flags |=  FT_LOAD_NO_SCALE         |
352                    FT_LOAD_IGNORE_TRANSFORM |
353                    FT_LOAD_LINEAR_DESIGN;
354     load_flags &amp;= ~FT_LOAD_RENDER;
355 
356     error = FT_Load_Glyph( face, glyph_index, load_flags );
357     if ( error )
358       goto Exit;
359 
360     /*
<span class="line-modified">361      *  Apply stem darkening (emboldening) here before hints are applied to</span>
<span class="line-modified">362      *  the outline.  Glyphs are scaled down proportionally to the</span>
<span class="line-modified">363      *  emboldening so that curve points don&#39;t fall outside their</span>
<span class="line-modified">364      *  precomputed blue zones.</span>
365      *
<span class="line-modified">366      *  Any emboldening done by the font driver (e.g., the CFF driver)</span>
<span class="line-modified">367      *  doesn&#39;t reach here because the autohinter loads the unprocessed</span>
<span class="line-modified">368      *  glyphs in font units for analysis (functions `af_*_metrics_init_*&#39;)</span>
<span class="line-modified">369      *  and then above to prepare it for the rasterizers by itself,</span>
<span class="line-modified">370      *  independently of the font driver.  So emboldening must be done here,</span>
<span class="line-modified">371      *  within the autohinter.</span>
372      *
<span class="line-modified">373      *  All glyphs to be autohinted pass through here one by one.  The</span>
<span class="line-modified">374      *  standard widths can therefore change from one glyph to the next,</span>
<span class="line-modified">375      *  depending on what script a glyph is assigned to (each script has its</span>
<span class="line-modified">376      *  own set of standard widths and other metrics).  The darkening amount</span>
<span class="line-modified">377      *  must therefore be recomputed for each size and</span>
<span class="line-modified">378      *  `standard_{vertical,horizontal}_width&#39; change.</span>
379      *
<span class="line-modified">380      *  Ignore errors and carry on without emboldening.</span>
381      *
382      */
383 
384     /* stem darkening only works well in `light&#39; mode */
385     if ( scaler.render_mode == FT_RENDER_MODE_LIGHT    &amp;&amp;
386          ( !face-&gt;internal-&gt;no_stem_darkening        ||
387            ( face-&gt;internal-&gt;no_stem_darkening &lt; 0 &amp;&amp;
388              !module-&gt;no_stem_darkening            ) ) )
389       af_loader_embolden_glyph_in_slot( loader, face, style_metrics );
390 
391     loader-&gt;transformed = slot_internal-&gt;glyph_transformed;
392     if ( loader-&gt;transformed )
393     {
394       FT_Matrix  inverse;
395 
396 
397       loader-&gt;trans_matrix = slot_internal-&gt;glyph_matrix;
398       loader-&gt;trans_delta  = slot_internal-&gt;glyph_delta;
399 
400       inverse = loader-&gt;trans_matrix;
</pre>
<hr />
<pre>
409       if ( loader-&gt;transformed )
410         FT_Outline_Translate( &amp;slot-&gt;outline,
411                               loader-&gt;trans_delta.x,
412                               loader-&gt;trans_delta.y );
413 
414       /* compute original horizontal phantom points */
415       /* (and ignore vertical ones)                 */
416       loader-&gt;pp1.x = hints-&gt;x_delta;
417       loader-&gt;pp1.y = hints-&gt;y_delta;
418       loader-&gt;pp2.x = FT_MulFix( slot-&gt;metrics.horiAdvance,
419                                  hints-&gt;x_scale ) + hints-&gt;x_delta;
420       loader-&gt;pp2.y = hints-&gt;y_delta;
421 
422       /* be sure to check for spacing glyphs */
423       if ( slot-&gt;outline.n_points == 0 )
424         goto Hint_Metrics;
425 
426       /* now load the slot image into the auto-outline */
427       /* and run the automatic hinting process         */
428       if ( writing_system_class-&gt;style_hints_apply )
<span class="line-modified">429         writing_system_class-&gt;style_hints_apply( glyph_index,</span>
<span class="line-modified">430                                                  hints,</span>
<span class="line-modified">431                                                  &amp;gloader-&gt;base.outline,</span>
<span class="line-modified">432                                                  style_metrics );</span>





433 
434       /* we now need to adjust the metrics according to the change in */
435       /* width/positioning that occurred during the hinting process   */
436       if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
437       {
<span class="line-removed">438         FT_Pos  old_rsb, old_lsb, new_lsb;</span>
<span class="line-removed">439         FT_Pos  pp1x_uh, pp2x_uh;</span>
<span class="line-removed">440 </span>
441         AF_AxisHints  axis  = &amp;hints-&gt;axis[AF_DIMENSION_HORZ];
<span class="line-removed">442         AF_Edge       edge1 = axis-&gt;edges;         /* leftmost edge  */</span>
<span class="line-removed">443         AF_Edge       edge2 = edge1 +</span>
<span class="line-removed">444                               axis-&gt;num_edges - 1; /* rightmost edge */</span>
445 
446 
447         if ( axis-&gt;num_edges &gt; 1 &amp;&amp; AF_HINTS_DO_ADVANCE( hints ) )
448         {
<span class="line-modified">449           old_rsb = loader-&gt;pp2.x - edge2-&gt;opos;</span>




450           /* loader-&gt;pp1.x is always zero at this point of time */
<span class="line-modified">451           old_lsb = edge1-&gt;opos /* - loader-&gt;pp1.x */;</span>
<span class="line-modified">452           new_lsb = edge1-&gt;pos;</span>
453 
454           /* remember unhinted values to later account */
455           /* for rounding errors                       */
<span class="line-modified">456           pp1x_uh = new_lsb    - old_lsb;</span>
<span class="line-modified">457           pp2x_uh = edge2-&gt;pos + old_rsb;</span>

458 
459           /* prefer too much space over too little space */
460           /* for very small sizes                        */
461 
462           if ( old_lsb &lt; 24 )
463             pp1x_uh -= 8;
464 
465           if ( old_rsb &lt; 24 )
466             pp2x_uh += 8;
467 
468           loader-&gt;pp1.x = FT_PIX_ROUND( pp1x_uh );
469           loader-&gt;pp2.x = FT_PIX_ROUND( pp2x_uh );
470 
471           if ( loader-&gt;pp1.x &gt;= new_lsb &amp;&amp; old_lsb &gt; 0 )
472             loader-&gt;pp1.x -= 64;
473 
474           if ( loader-&gt;pp2.x &lt;= edge2-&gt;pos &amp;&amp; old_rsb &gt; 0 )
475             loader-&gt;pp2.x += 64;
476 
477           slot-&gt;lsb_delta = loader-&gt;pp1.x - pp1x_uh;
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * afloader.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Auto-fitter glyph loading routines (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &quot;afglobal.h&quot;
 20 #include &quot;afloader.h&quot;
 21 #include &quot;afhints.h&quot;
 22 #include &quot;aferrors.h&quot;
 23 #include &quot;afmodule.h&quot;

 24 
 25 #include FT_INTERNAL_CALC_H
 26 
 27 
 28   /* Initialize glyph loader. */
 29 
 30   FT_LOCAL_DEF( void )
 31   af_loader_init( AF_Loader      loader,
 32                   AF_GlyphHints  hints )
 33   {
 34     FT_ZERO( loader );
 35 
 36     loader-&gt;hints = hints;
 37   }
 38 
 39 
 40   /* Reset glyph loader and compute globals if necessary. */
 41 
 42   FT_LOCAL_DEF( FT_Error )
 43   af_loader_reset( AF_Loader  loader,
</pre>
<hr />
<pre>
101     FT_Pos  stdVW = 0;
102     FT_Pos  stdHW = 0;
103 
104     FT_Bool  size_changed = size_metrics-&gt;x_ppem !=
105                               globals-&gt;stem_darkening_for_ppem;
106 
107     FT_Fixed  em_size  = af_intToFixed( face-&gt;units_per_EM );
108     FT_Fixed  em_ratio = FT_DivFix( af_intToFixed( 1000 ), em_size );
109 
110     FT_Matrix  scale_down_matrix = { 0x10000L, 0, 0, 0x10000L };
111 
112 
113     /* Skip stem darkening for broken fonts. */
114     if ( !face-&gt;units_per_EM )
115     {
116       error = FT_ERR( Corrupted_Font_Header );
117       goto Exit;
118     }
119 
120     /*
<span class="line-modified">121      * We depend on the writing system (script analyzers) to supply</span>
<span class="line-modified">122      * standard widths for the script of the glyph we are looking at.  If</span>
<span class="line-modified">123      * it can&#39;t deliver, stem darkening is disabled.</span>
124      */
125     writing_system_class =
<span class="line-modified">126       af_writing_system_classes[style_metrics-&gt;style_class-&gt;writing_system];</span>
127 
128     if ( writing_system_class-&gt;style_metrics_getstdw )
129       writing_system_class-&gt;style_metrics_getstdw( style_metrics,
130                                                    &amp;stdHW,
131                                                    &amp;stdVW );
132     else
133     {
134       error = FT_ERR( Unimplemented_Feature );
135       goto Exit;
136     }
137 
138     if ( size_changed                                               ||
139          ( stdVW &gt; 0 &amp;&amp; stdVW != globals-&gt;standard_vertical_width ) )
140     {
141       FT_Fixed  darken_by_font_units_x, darken_x;
142 
143 
144       darken_by_font_units_x =
145         af_intToFixed( af_loader_compute_darkening( loader,
146                                                     face,
</pre>
<hr />
<pre>
156 
157     if ( size_changed                                                 ||
158          ( stdHW &gt; 0 &amp;&amp; stdHW != globals-&gt;standard_horizontal_width ) )
159     {
160       FT_Fixed  darken_by_font_units_y, darken_y;
161 
162 
163       darken_by_font_units_y =
164         af_intToFixed( af_loader_compute_darkening( loader,
165                                                     face,
166                                                     stdHW ) );
167       darken_y = FT_DivFix( FT_MulFix( darken_by_font_units_y,
168                                        size_metrics-&gt;y_scale ),
169                             em_ratio );
170 
171       globals-&gt;standard_horizontal_width = stdHW;
172       globals-&gt;stem_darkening_for_ppem   = size_metrics-&gt;x_ppem;
173       globals-&gt;darken_y                  = af_fixedToInt( darken_y );
174 
175       /*
<span class="line-modified">176        * Scale outlines down on the Y-axis to keep them inside their blue</span>
<span class="line-modified">177        * zones.  The stronger the emboldening, the stronger the downscaling</span>
<span class="line-modified">178        * (plus heuristical padding to prevent outlines still falling out</span>
<span class="line-modified">179        * their zones due to rounding).</span>
180        *
<span class="line-modified">181        * Reason: `FT_Outline_Embolden&#39; works by shifting the rightmost</span>
<span class="line-modified">182        * points of stems farther to the right, and topmost points farther</span>
<span class="line-modified">183        * up.  This positions points on the Y-axis outside their</span>
<span class="line-modified">184        * pre-computed blue zones and leads to distortion when applying the</span>
<span class="line-modified">185        * hints in the code further below.  Code outside this emboldening</span>
<span class="line-modified">186        * block doesn&#39;t know we are presenting it with modified outlines the</span>
<span class="line-modified">187        * analyzer didn&#39;t see!</span>
188        *
<span class="line-modified">189        * An unfortunate side effect of downscaling is that the emboldening</span>
<span class="line-modified">190        * effect is slightly decreased.  The loss becomes more pronounced</span>
<span class="line-modified">191        * versus the CFF driver at smaller sizes, e.g., at 9ppem and below.</span>
192        */
193       globals-&gt;scale_down_factor =
194         FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
195                    em_size );
196     }
197 
198     FT_Outline_EmboldenXY( &amp;slot-&gt;outline,
199                            globals-&gt;darken_x,
200                            globals-&gt;darken_y );
201 
202     scale_down_matrix.yy = globals-&gt;scale_down_factor;
203     FT_Outline_Transform( &amp;slot-&gt;outline, &amp;scale_down_matrix );
204 
205   Exit:
206     return error;
207   }
208 
209 
210   /* Load the glyph at index into the current slot of a face and hint it. */
211 
</pre>
<hr />
<pre>
214                         AF_Module  module,
215                         FT_Face    face,
216                         FT_UInt    glyph_index,
217                         FT_Int32   load_flags )
218   {
219     FT_Error  error;
220 
221     FT_Size           size          = face-&gt;size;
222     FT_Size_Internal  size_internal = size-&gt;internal;
223     FT_GlyphSlot      slot          = face-&gt;glyph;
224     FT_Slot_Internal  slot_internal = slot-&gt;internal;
225     FT_GlyphLoader    gloader       = slot_internal-&gt;loader;
226 
227     AF_GlyphHints          hints         = loader-&gt;hints;
228     AF_ScalerRec           scaler;
229     AF_StyleMetrics        style_metrics;
230     FT_UInt                style_options = AF_STYLE_NONE_DFLT;
231     AF_StyleClass          style_class;
232     AF_WritingSystemClass  writing_system_class;
233 




234 
235     if ( !size )
236       return FT_THROW( Invalid_Size_Handle );
237 
238     FT_ZERO( &amp;scaler );
239 
240     if ( !size_internal-&gt;autohint_metrics.x_scale                          ||
241          size_internal-&gt;autohint_mode != FT_LOAD_TARGET_MODE( load_flags ) )
242     {
243       /* switching between hinting modes usually means different scaling */
244       /* values; this later on enforces recomputation of everything      */
245       /* related to the current size                                     */
246 
247       size_internal-&gt;autohint_mode    = FT_LOAD_TARGET_MODE( load_flags );
248       size_internal-&gt;autohint_metrics = size-&gt;metrics;
249 
250 #ifdef AF_CONFIG_OPTION_TT_SIZE_METRICS
251       {
252         FT_Size_Metrics*  size_metrics = &amp;size_internal-&gt;autohint_metrics;
253 
</pre>
<hr />
<pre>
260                                                size_metrics-&gt;y_scale ) );
261         size_metrics-&gt;descender = FT_PIX_ROUND(
262                                     FT_MulFix( face-&gt;descender,
263                                                size_metrics-&gt;y_scale ) );
264         size_metrics-&gt;height    = FT_PIX_ROUND(
265                                     FT_MulFix( face-&gt;height,
266                                                size_metrics-&gt;y_scale ) );
267 
268         size_metrics-&gt;x_scale     = FT_DivFix( size_metrics-&gt;x_ppem &lt;&lt; 6,
269                                                face-&gt;units_per_EM );
270         size_metrics-&gt;y_scale     = FT_DivFix( size_metrics-&gt;y_ppem &lt;&lt; 6,
271                                                face-&gt;units_per_EM );
272         size_metrics-&gt;max_advance = FT_PIX_ROUND(
273                                       FT_MulFix( face-&gt;max_advance_width,
274                                                  size_metrics-&gt;x_scale ) );
275       }
276 #endif /* AF_CONFIG_OPTION_TT_SIZE_METRICS */
277     }
278 
279     /*
<span class="line-modified">280      * TODO: This code currently doesn&#39;t support fractional advance widths,</span>
<span class="line-modified">281      * i.e., placing hinted glyphs at anything other than integer</span>
<span class="line-modified">282      * x-positions.  This is only relevant for the warper code, which</span>
<span class="line-modified">283      * scales and shifts glyphs to optimize blackness of stems (hinting on</span>
<span class="line-modified">284      * the x-axis by nature places things on pixel integers, hinting on the</span>
<span class="line-modified">285      * y-axis only, i.e., LIGHT mode, doesn&#39;t touch the x-axis).  The delta</span>
<span class="line-modified">286      * values of the scaler would need to be adjusted.</span>
287      */
288     scaler.face    = face;
289     scaler.x_scale = size_internal-&gt;autohint_metrics.x_scale;
290     scaler.x_delta = 0;
291     scaler.y_scale = size_internal-&gt;autohint_metrics.y_scale;
292     scaler.y_delta = 0;
293 
294     scaler.render_mode = FT_LOAD_TARGET_MODE( load_flags );
295     scaler.flags       = 0;
296 
297     /* note that the fallback style can&#39;t be changed anymore */
298     /* after the first call of `af_loader_load_glyph&#39;        */
299     error = af_loader_reset( loader, module, face );
300     if ( error )
301       goto Exit;
302 
303 #ifdef FT_OPTION_AUTOFIT2
304     /* XXX: undocumented hook to activate the latin2 writing system. */
305     if ( load_flags &amp; ( 1UL &lt;&lt; 20 ) )
306       style_options = AF_STYLE_LTN2_DFLT;
307 #endif
308 
309     /*
<span class="line-modified">310      * Glyphs (really code points) are assigned to scripts.  Script</span>
<span class="line-modified">311      * analysis is done lazily: For each glyph that passes through here,</span>
<span class="line-modified">312      * the corresponding script analyzer is called, but returns immediately</span>
<span class="line-modified">313      * if it has been run already.</span>
314      */
315     error = af_face_globals_get_metrics( loader-&gt;globals, glyph_index,
316                                          style_options, &amp;style_metrics );
317     if ( error )
318       goto Exit;
319 
320     style_class          = style_metrics-&gt;style_class;
321     writing_system_class =
<span class="line-modified">322       af_writing_system_classes[style_class-&gt;writing_system];</span>
323 
324     loader-&gt;metrics = style_metrics;
325 
326     if ( writing_system_class-&gt;style_metrics_scale )
327       writing_system_class-&gt;style_metrics_scale( style_metrics, &amp;scaler );
328     else
329       style_metrics-&gt;scaler = scaler;
330 
331     if ( writing_system_class-&gt;style_hints_init )
332     {
333       error = writing_system_class-&gt;style_hints_init( hints,
334                                                       style_metrics );
335       if ( error )
336         goto Exit;
337     }
338 
339     /*
<span class="line-modified">340      * Do the main work of `af_loader_load_glyph&#39;.  Note that we never have</span>
<span class="line-modified">341      * to deal with composite glyphs as those get loaded into</span>
<span class="line-modified">342      * FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph&#39; function.</span>
<span class="line-modified">343      * In the rare cases where FT_LOAD_NO_RECURSE is set, it implies</span>
<span class="line-modified">344      * FT_LOAD_NO_SCALE and as such the auto-hinter is never called.</span>
345      */
346     load_flags |=  FT_LOAD_NO_SCALE         |
347                    FT_LOAD_IGNORE_TRANSFORM |
348                    FT_LOAD_LINEAR_DESIGN;
349     load_flags &amp;= ~FT_LOAD_RENDER;
350 
351     error = FT_Load_Glyph( face, glyph_index, load_flags );
352     if ( error )
353       goto Exit;
354 
355     /*
<span class="line-modified">356      * Apply stem darkening (emboldening) here before hints are applied to</span>
<span class="line-modified">357      * the outline.  Glyphs are scaled down proportionally to the</span>
<span class="line-modified">358      * emboldening so that curve points don&#39;t fall outside their</span>
<span class="line-modified">359      * precomputed blue zones.</span>
360      *
<span class="line-modified">361      * Any emboldening done by the font driver (e.g., the CFF driver)</span>
<span class="line-modified">362      * doesn&#39;t reach here because the autohinter loads the unprocessed</span>
<span class="line-modified">363      * glyphs in font units for analysis (functions `af_*_metrics_init_*&#39;)</span>
<span class="line-modified">364      * and then above to prepare it for the rasterizers by itself,</span>
<span class="line-modified">365      * independently of the font driver.  So emboldening must be done here,</span>
<span class="line-modified">366      * within the autohinter.</span>
367      *
<span class="line-modified">368      * All glyphs to be autohinted pass through here one by one.  The</span>
<span class="line-modified">369      * standard widths can therefore change from one glyph to the next,</span>
<span class="line-modified">370      * depending on what script a glyph is assigned to (each script has its</span>
<span class="line-modified">371      * own set of standard widths and other metrics).  The darkening amount</span>
<span class="line-modified">372      * must therefore be recomputed for each size and</span>
<span class="line-modified">373      * `standard_{vertical,horizontal}_width&#39; change.</span>
374      *
<span class="line-modified">375      * Ignore errors and carry on without emboldening.</span>
376      *
377      */
378 
379     /* stem darkening only works well in `light&#39; mode */
380     if ( scaler.render_mode == FT_RENDER_MODE_LIGHT    &amp;&amp;
381          ( !face-&gt;internal-&gt;no_stem_darkening        ||
382            ( face-&gt;internal-&gt;no_stem_darkening &lt; 0 &amp;&amp;
383              !module-&gt;no_stem_darkening            ) ) )
384       af_loader_embolden_glyph_in_slot( loader, face, style_metrics );
385 
386     loader-&gt;transformed = slot_internal-&gt;glyph_transformed;
387     if ( loader-&gt;transformed )
388     {
389       FT_Matrix  inverse;
390 
391 
392       loader-&gt;trans_matrix = slot_internal-&gt;glyph_matrix;
393       loader-&gt;trans_delta  = slot_internal-&gt;glyph_delta;
394 
395       inverse = loader-&gt;trans_matrix;
</pre>
<hr />
<pre>
404       if ( loader-&gt;transformed )
405         FT_Outline_Translate( &amp;slot-&gt;outline,
406                               loader-&gt;trans_delta.x,
407                               loader-&gt;trans_delta.y );
408 
409       /* compute original horizontal phantom points */
410       /* (and ignore vertical ones)                 */
411       loader-&gt;pp1.x = hints-&gt;x_delta;
412       loader-&gt;pp1.y = hints-&gt;y_delta;
413       loader-&gt;pp2.x = FT_MulFix( slot-&gt;metrics.horiAdvance,
414                                  hints-&gt;x_scale ) + hints-&gt;x_delta;
415       loader-&gt;pp2.y = hints-&gt;y_delta;
416 
417       /* be sure to check for spacing glyphs */
418       if ( slot-&gt;outline.n_points == 0 )
419         goto Hint_Metrics;
420 
421       /* now load the slot image into the auto-outline */
422       /* and run the automatic hinting process         */
423       if ( writing_system_class-&gt;style_hints_apply )
<span class="line-modified">424       {</span>
<span class="line-modified">425         error = writing_system_class-&gt;style_hints_apply(</span>
<span class="line-modified">426                   glyph_index,</span>
<span class="line-modified">427                   hints,</span>
<span class="line-added">428                   &amp;gloader-&gt;base.outline,</span>
<span class="line-added">429                   style_metrics );</span>
<span class="line-added">430         if ( error )</span>
<span class="line-added">431           goto Exit;</span>
<span class="line-added">432       }</span>
433 
434       /* we now need to adjust the metrics according to the change in */
435       /* width/positioning that occurred during the hinting process   */
436       if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
437       {



438         AF_AxisHints  axis  = &amp;hints-&gt;axis[AF_DIMENSION_HORZ];



439 
440 
441         if ( axis-&gt;num_edges &gt; 1 &amp;&amp; AF_HINTS_DO_ADVANCE( hints ) )
442         {
<span class="line-modified">443           AF_Edge  edge1 = axis-&gt;edges;         /* leftmost edge  */</span>
<span class="line-added">444           AF_Edge  edge2 = edge1 +</span>
<span class="line-added">445                            axis-&gt;num_edges - 1; /* rightmost edge */</span>
<span class="line-added">446 </span>
<span class="line-added">447           FT_Pos  old_rsb = loader-&gt;pp2.x - edge2-&gt;opos;</span>
448           /* loader-&gt;pp1.x is always zero at this point of time */
<span class="line-modified">449           FT_Pos  old_lsb = edge1-&gt;opos;     /* - loader-&gt;pp1.x */</span>
<span class="line-modified">450           FT_Pos  new_lsb = edge1-&gt;pos;</span>
451 
452           /* remember unhinted values to later account */
453           /* for rounding errors                       */
<span class="line-modified">454           FT_Pos  pp1x_uh = new_lsb    - old_lsb;</span>
<span class="line-modified">455           FT_Pos  pp2x_uh = edge2-&gt;pos + old_rsb;</span>
<span class="line-added">456 </span>
457 
458           /* prefer too much space over too little space */
459           /* for very small sizes                        */
460 
461           if ( old_lsb &lt; 24 )
462             pp1x_uh -= 8;
463 
464           if ( old_rsb &lt; 24 )
465             pp2x_uh += 8;
466 
467           loader-&gt;pp1.x = FT_PIX_ROUND( pp1x_uh );
468           loader-&gt;pp2.x = FT_PIX_ROUND( pp2x_uh );
469 
470           if ( loader-&gt;pp1.x &gt;= new_lsb &amp;&amp; old_lsb &gt; 0 )
471             loader-&gt;pp1.x -= 64;
472 
473           if ( loader-&gt;pp2.x &lt;= edge2-&gt;pos &amp;&amp; old_rsb &gt; 0 )
474             loader-&gt;pp2.x += 64;
475 
476           slot-&gt;lsb_delta = loader-&gt;pp1.x - pp1x_uh;
</pre>
</td>
</tr>
</table>
<center><a href="aflatin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afloader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/cff/cffgload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  cffgload.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    OpenType Glyph Loader (body).                                        */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_STREAM_H
 22 #include FT_INTERNAL_SFNT_H
 23 #include FT_INTERNAL_CALC_H
 24 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 25 #include FT_OUTLINE_H
 26 #include FT_DRIVER_H
 27 
 28 #include &quot;cffload.h&quot;
 29 #include &quot;cffgload.h&quot;
 30 
 31 #include &quot;cfferrs.h&quot;
 32 
 33 
<a name="2" id="anc2"></a><span class="line-modified"> 34   /*************************************************************************/</span>
<span class="line-modified"> 35   /*                                                                       */</span>
<span class="line-modified"> 36   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 37   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 38   /* messages during execution.                                            */</span>
<span class="line-modified"> 39   /*                                                                       */</span>
 40 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 41 #define FT_COMPONENT  trace_cffgload</span>
 42 
 43 
 44   FT_LOCAL_DEF( FT_Error )
 45   cff_get_glyph_data( TT_Face    face,
 46                       FT_UInt    glyph_index,
 47                       FT_Byte**  pointer,
 48                       FT_ULong*  length )
 49   {
 50 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 51     /* For incremental fonts get the character data using the */
 52     /* callback function.                                     */
 53     if ( face-&gt;root.internal-&gt;incremental_interface )
 54     {
 55       FT_Data   data;
 56       FT_Error  error =
 57                   face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_data(
 58                     face-&gt;root.internal-&gt;incremental_interface-&gt;object,
 59                     glyph_index, &amp;data );
 60 
 61 
 62       *pointer = (FT_Byte*)data.pointer;
 63       *length  = (FT_ULong)data.length;
 64 
 65       return error;
 66     }
 67     else
 68 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 69 
 70     {
 71       CFF_Font  cff = (CFF_Font)(face-&gt;extra.data);
 72 
 73 
 74       return cff_index_access_element( &amp;cff-&gt;charstrings_index, glyph_index,
 75                                        pointer, length );
 76     }
 77   }
 78 
 79 
 80   FT_LOCAL_DEF( void )
 81   cff_free_glyph_data( TT_Face    face,
 82                        FT_Byte**  pointer,
 83                        FT_ULong   length )
 84   {
 85 #ifndef FT_CONFIG_OPTION_INCREMENTAL
 86     FT_UNUSED( length );
 87 #endif
 88 
 89 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 90     /* For incremental fonts get the character data using the */
 91     /* callback function.                                     */
 92     if ( face-&gt;root.internal-&gt;incremental_interface )
 93     {
 94       FT_Data  data;
 95 
 96 
 97       data.pointer = *pointer;
 98       data.length  = (FT_Int)length;
 99 
100       face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;free_glyph_data(
101         face-&gt;root.internal-&gt;incremental_interface-&gt;object, &amp;data );
102     }
103     else
104 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
105 
106     {
107       CFF_Font  cff = (CFF_Font)(face-&gt;extra.data);
108 
109 
110       cff_index_forget_element( &amp;cff-&gt;charstrings_index, pointer );
111     }
112   }
113 
114 
115   /*************************************************************************/
116   /*************************************************************************/
117   /*************************************************************************/
118   /**********                                                      *********/
119   /**********                                                      *********/
120   /**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
121   /**********                                                      *********/
122   /**********    The following code is in charge of computing      *********/
123   /**********    the maximum advance width of the font.  It        *********/
124   /**********    quickly processes each glyph charstring to        *********/
125   /**********    extract the value from either a `sbw&#39; or `seac&#39;   *********/
126   /**********    operator.                                         *********/
127   /**********                                                      *********/
128   /*************************************************************************/
129   /*************************************************************************/
130   /*************************************************************************/
131 
132 
133 #if 0 /* unused until we support pure CFF fonts */
134 
135 
136   FT_LOCAL_DEF( FT_Error )
137   cff_compute_max_advance( TT_Face  face,
138                            FT_Int*  max_advance )
139   {
140     FT_Error     error = FT_Err_Ok;
141     CFF_Decoder  decoder;
142     FT_Int       glyph_index;
143     CFF_Font     cff = (CFF_Font)face-&gt;other;
144 
145     PSAux_Service            psaux         = (PSAux_Service)face-&gt;psaux;
146     const CFF_Decoder_Funcs  decoder_funcs = psaux-&gt;cff_decoder_funcs;
147 
148 
149     *max_advance = 0;
150 
151     /* Initialize load decoder */
152     decoder_funcs-&gt;init( &amp;decoder, face, 0, 0, 0, 0, 0, 0 );
153 
154     decoder.builder.metrics_only = 1;
155     decoder.builder.load_points  = 0;
156 
157     /* For each glyph, parse the glyph charstring and extract */
158     /* the advance width.                                     */
159     for ( glyph_index = 0; glyph_index &lt; face-&gt;root.num_glyphs;
160           glyph_index++ )
161     {
162       FT_Byte*  charstring;
163       FT_ULong  charstring_len;
164 
165 
166       /* now get load the unscaled outline */
167       error = cff_get_glyph_data( face, glyph_index,
168                                   &amp;charstring, &amp;charstring_len );
169       if ( !error )
170       {
171         error = decoder_funcs-&gt;prepare( &amp;decoder, size, glyph_index );
172         if ( !error )
173           error = decoder_funcs-&gt;parse_charstrings_old( &amp;decoder,
174                                                         charstring,
175                                                         charstring_len,
176                                                         0 );
177 
178         cff_free_glyph_data( face, &amp;charstring, &amp;charstring_len );
179       }
180 
181       /* ignore the error if one has occurred -- skip to next glyph */
182       error = FT_Err_Ok;
183     }
184 
185     *max_advance = decoder.builder.advance.x;
186 
187     return FT_Err_Ok;
188   }
189 
190 
191 #endif /* 0 */
192 
193 
194   FT_LOCAL_DEF( FT_Error )
195   cff_slot_load( CFF_GlyphSlot  glyph,
196                  CFF_Size       size,
197                  FT_UInt        glyph_index,
198                  FT_Int32       load_flags )
199   {
200     FT_Error     error;
201     CFF_Decoder  decoder;
202     PS_Decoder   psdecoder;
203     TT_Face      face = (TT_Face)glyph-&gt;root.face;
204     FT_Bool      hinting, scaled, force_scaling;
205     CFF_Font     cff  = (CFF_Font)face-&gt;extra.data;
206 
207     PSAux_Service            psaux         = (PSAux_Service)face-&gt;psaux;
208     const CFF_Decoder_Funcs  decoder_funcs = psaux-&gt;cff_decoder_funcs;
209 
210     FT_Matrix    font_matrix;
211     FT_Vector    font_offset;
212 
213 
214     force_scaling = FALSE;
215 
216     /* in a CID-keyed font, consider `glyph_index&#39; as a CID and map */
217     /* it immediately to the real glyph_index -- if it isn&#39;t a      */
218     /* subsetted font, glyph_indices and CIDs are identical, though */
219     if ( cff-&gt;top_font.font_dict.cid_registry != 0xFFFFU &amp;&amp;
220          cff-&gt;charset.cids                               )
221     {
222       /* don&#39;t handle CID 0 (.notdef) which is directly mapped to GID 0 */
223       if ( glyph_index != 0 )
224       {
225         glyph_index = cff_charset_cid_to_gindex( &amp;cff-&gt;charset,
226                                                  glyph_index );
227         if ( glyph_index == 0 )
228           return FT_THROW( Invalid_Argument );
229       }
230     }
231     else if ( glyph_index &gt;= cff-&gt;num_glyphs )
232       return FT_THROW( Invalid_Argument );
233 
234     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
235       load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
236 
237     glyph-&gt;x_scale = 0x10000L;
238     glyph-&gt;y_scale = 0x10000L;
239     if ( size )
240     {
241       glyph-&gt;x_scale = size-&gt;root.metrics.x_scale;
242       glyph-&gt;y_scale = size-&gt;root.metrics.y_scale;
243     }
244 
245 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
246 
247     /* try to load embedded bitmap if any              */
248     /*                                                 */
249     /* XXX: The convention should be emphasized in     */
250     /*      the documents because it can be confusing. */
251     if ( size )
252     {
253       CFF_Face      cff_face = (CFF_Face)size-&gt;root.face;
254       SFNT_Service  sfnt     = (SFNT_Service)cff_face-&gt;sfnt;
255       FT_Stream     stream   = cff_face-&gt;root.stream;
256 
257 
258       if ( size-&gt;strike_index != 0xFFFFFFFFUL      &amp;&amp;
259            sfnt-&gt;load_eblc                         &amp;&amp;
260            ( load_flags &amp; FT_LOAD_NO_BITMAP ) == 0 )
261       {
262         TT_SBit_MetricsRec  metrics;
263 
264 
265         error = sfnt-&gt;load_sbit_image( face,
266                                        size-&gt;strike_index,
267                                        glyph_index,
268                                        (FT_UInt)load_flags,
269                                        stream,
270                                        &amp;glyph-&gt;root.bitmap,
271                                        &amp;metrics );
272 
273         if ( !error )
274         {
275           FT_Bool    has_vertical_info;
276           FT_UShort  advance;
277           FT_Short   dummy;
278 
279 
280           glyph-&gt;root.outline.n_points   = 0;
281           glyph-&gt;root.outline.n_contours = 0;
282 
<a name="4" id="anc4"></a><span class="line-modified">283           glyph-&gt;root.metrics.width  = (FT_Pos)metrics.width  &lt;&lt; 6;</span>
<span class="line-modified">284           glyph-&gt;root.metrics.height = (FT_Pos)metrics.height &lt;&lt; 6;</span>
285 
<a name="5" id="anc5"></a><span class="line-modified">286           glyph-&gt;root.metrics.horiBearingX = (FT_Pos)metrics.horiBearingX &lt;&lt; 6;</span>
<span class="line-modified">287           glyph-&gt;root.metrics.horiBearingY = (FT_Pos)metrics.horiBearingY &lt;&lt; 6;</span>
<span class="line-modified">288           glyph-&gt;root.metrics.horiAdvance  = (FT_Pos)metrics.horiAdvance  &lt;&lt; 6;</span>
289 
<a name="6" id="anc6"></a><span class="line-modified">290           glyph-&gt;root.metrics.vertBearingX = (FT_Pos)metrics.vertBearingX &lt;&lt; 6;</span>
<span class="line-modified">291           glyph-&gt;root.metrics.vertBearingY = (FT_Pos)metrics.vertBearingY &lt;&lt; 6;</span>
<span class="line-modified">292           glyph-&gt;root.metrics.vertAdvance  = (FT_Pos)metrics.vertAdvance  &lt;&lt; 6;</span>
293 
294           glyph-&gt;root.format = FT_GLYPH_FORMAT_BITMAP;
295 
296           if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
297           {
298             glyph-&gt;root.bitmap_left = metrics.vertBearingX;
299             glyph-&gt;root.bitmap_top  = metrics.vertBearingY;
300           }
301           else
302           {
303             glyph-&gt;root.bitmap_left = metrics.horiBearingX;
304             glyph-&gt;root.bitmap_top  = metrics.horiBearingY;
305           }
306 
307           /* compute linear advance widths */
308 
309           (void)( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 0,
310                                                            glyph_index,
311                                                            &amp;dummy,
312                                                            &amp;advance );
313           glyph-&gt;root.linearHoriAdvance = advance;
314 
315           has_vertical_info = FT_BOOL(
316                                 face-&gt;vertical_info                   &amp;&amp;
317                                 face-&gt;vertical.number_Of_VMetrics &gt; 0 );
318 
319           /* get the vertical metrics from the vmtx table if we have one */
320           if ( has_vertical_info )
321           {
322             (void)( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 1,
323                                                              glyph_index,
324                                                              &amp;dummy,
325                                                              &amp;advance );
326             glyph-&gt;root.linearVertAdvance = advance;
327           }
328           else
329           {
330             /* make up vertical ones */
331             if ( face-&gt;os2.version != 0xFFFFU )
332               glyph-&gt;root.linearVertAdvance = (FT_Pos)
333                 ( face-&gt;os2.sTypoAscender - face-&gt;os2.sTypoDescender );
334             else
335               glyph-&gt;root.linearVertAdvance = (FT_Pos)
336                 ( face-&gt;horizontal.Ascender - face-&gt;horizontal.Descender );
337           }
338 
339           return error;
340         }
341       }
342     }
343 
344 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
345 
346     /* return immediately if we only want the embedded bitmaps */
347     if ( load_flags &amp; FT_LOAD_SBITS_ONLY )
348       return FT_THROW( Invalid_Argument );
349 
350     /* if we have a CID subfont, use its matrix (which has already */
351     /* been multiplied with the root matrix)                       */
352 
353     /* this scaling is only relevant if the PS hinter isn&#39;t active */
354     if ( cff-&gt;num_subfonts )
355     {
356       FT_Long  top_upm, sub_upm;
357       FT_Byte  fd_index = cff_fd_select_get( &amp;cff-&gt;fd_select,
358                                              glyph_index );
359 
360 
361       if ( fd_index &gt;= cff-&gt;num_subfonts )
362         fd_index = (FT_Byte)( cff-&gt;num_subfonts - 1 );
363 
364       top_upm = (FT_Long)cff-&gt;top_font.font_dict.units_per_em;
365       sub_upm = (FT_Long)cff-&gt;subfonts[fd_index]-&gt;font_dict.units_per_em;
366 
367 
368       font_matrix = cff-&gt;subfonts[fd_index]-&gt;font_dict.font_matrix;
369       font_offset = cff-&gt;subfonts[fd_index]-&gt;font_dict.font_offset;
370 
371       if ( top_upm != sub_upm )
372       {
373         glyph-&gt;x_scale = FT_MulDiv( glyph-&gt;x_scale, top_upm, sub_upm );
374         glyph-&gt;y_scale = FT_MulDiv( glyph-&gt;y_scale, top_upm, sub_upm );
375 
376         force_scaling = TRUE;
377       }
378     }
379     else
380     {
381       font_matrix = cff-&gt;top_font.font_dict.font_matrix;
382       font_offset = cff-&gt;top_font.font_dict.font_offset;
383     }
384 
385     glyph-&gt;root.outline.n_points   = 0;
386     glyph-&gt;root.outline.n_contours = 0;
387 
388     /* top-level code ensures that FT_LOAD_NO_HINTING is set */
389     /* if FT_LOAD_NO_SCALE is active                         */
390     hinting = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_HINTING ) == 0 );
391     scaled  = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 );
392 
393     glyph-&gt;hint        = hinting;
394     glyph-&gt;scaled      = scaled;
395     glyph-&gt;root.format = FT_GLYPH_FORMAT_OUTLINE;  /* by default */
396 
397     {
398 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
399       PS_Driver  driver = (PS_Driver)FT_FACE_DRIVER( face );
400 #endif
401 
402 
403       FT_Byte*  charstring;
404       FT_ULong  charstring_len;
405 
406 
407       decoder_funcs-&gt;init( &amp;decoder, face, size, glyph, hinting,
408                            FT_LOAD_TARGET_MODE( load_flags ),
409                            cff_get_glyph_data,
410                            cff_free_glyph_data );
411 
412       /* this is for pure CFFs */
413       if ( load_flags &amp; FT_LOAD_ADVANCE_ONLY )
414         decoder.width_only = TRUE;
415 
416       decoder.builder.no_recurse =
<a name="7" id="anc7"></a><span class="line-modified">417         (FT_Bool)( load_flags &amp; FT_LOAD_NO_RECURSE );</span>
418 
419       /* now load the unscaled outline */
420       error = cff_get_glyph_data( face, glyph_index,
421                                   &amp;charstring, &amp;charstring_len );
422       if ( error )
423         goto Glyph_Build_Finished;
424 
425       error = decoder_funcs-&gt;prepare( &amp;decoder, size, glyph_index );
426       if ( error )
427         goto Glyph_Build_Finished;
428 
429 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
430       /* choose which CFF renderer to use */
431       if ( driver-&gt;hinting_engine == FT_HINTING_FREETYPE )
432         error = decoder_funcs-&gt;parse_charstrings_old( &amp;decoder,
433                                                       charstring,
434                                                       charstring_len,
435                                                       0 );
436       else
437 #endif
438       {
439         psaux-&gt;ps_decoder_init( &amp;psdecoder, &amp;decoder, FALSE );
440 
441         error = decoder_funcs-&gt;parse_charstrings( &amp;psdecoder,
442                                                   charstring,
443                                                   charstring_len );
444 
445         /* Adobe&#39;s engine uses 16.16 numbers everywhere;              */
446         /* as a consequence, glyphs larger than 2000ppem get rejected */
447         if ( FT_ERR_EQ( error, Glyph_Too_Big ) )
448         {
449           /* this time, we retry unhinted and scale up the glyph later on */
450           /* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
451           /* 0x400 for both `x_scale&#39; and `y_scale&#39; in this case)         */
452           hinting       = FALSE;
453           force_scaling = TRUE;
454           glyph-&gt;hint   = hinting;
455 
456           error = decoder_funcs-&gt;parse_charstrings( &amp;psdecoder,
457                                                     charstring,
458                                                     charstring_len );
459         }
460       }
461 
462       cff_free_glyph_data( face, &amp;charstring, charstring_len );
463 
464       if ( error )
465         goto Glyph_Build_Finished;
466 
467 #ifdef FT_CONFIG_OPTION_INCREMENTAL
468       /* Control data and length may not be available for incremental */
469       /* fonts.                                                       */
470       if ( face-&gt;root.internal-&gt;incremental_interface )
471       {
472         glyph-&gt;root.control_data = NULL;
473         glyph-&gt;root.control_len = 0;
474       }
475       else
476 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
477 
478       /* We set control_data and control_len if charstrings is loaded. */
479       /* See how charstring loads at cff_index_access_element() in     */
480       /* cffload.c.                                                    */
481       {
482         CFF_Index  csindex = &amp;cff-&gt;charstrings_index;
483 
484 
485         if ( csindex-&gt;offsets )
486         {
487           glyph-&gt;root.control_data = csindex-&gt;bytes +
488                                      csindex-&gt;offsets[glyph_index] - 1;
489           glyph-&gt;root.control_len  = (FT_Long)charstring_len;
490         }
491       }
492 
493   Glyph_Build_Finished:
494       /* save new glyph tables, if no error */
495       if ( !error )
496         decoder.builder.funcs.done( &amp;decoder.builder );
497       /* XXX: anything to do for broken glyph entry? */
498     }
499 
500 #ifdef FT_CONFIG_OPTION_INCREMENTAL
501 
502     /* Incremental fonts can optionally override the metrics. */
503     if ( !error                                                               &amp;&amp;
504          face-&gt;root.internal-&gt;incremental_interface                           &amp;&amp;
505          face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_metrics )
506     {
507       FT_Incremental_MetricsRec  metrics;
508 
509 
510       metrics.bearing_x = decoder.builder.left_bearing.x;
511       metrics.bearing_y = 0;
512       metrics.advance   = decoder.builder.advance.x;
513       metrics.advance_v = decoder.builder.advance.y;
514 
515       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_metrics(
516                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
517                 glyph_index, FALSE, &amp;metrics );
518 
519       decoder.builder.left_bearing.x = metrics.bearing_x;
520       decoder.builder.advance.x      = metrics.advance;
521       decoder.builder.advance.y      = metrics.advance_v;
522     }
523 
524 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
525 
526     if ( !error )
527     {
528       /* Now, set the metrics -- this is rather simple, as   */
529       /* the left side bearing is the xMin, and the top side */
530       /* bearing the yMax.                                   */
531 
532       /* For composite glyphs, return only left side bearing and */
533       /* advance width.                                          */
534       if ( load_flags &amp; FT_LOAD_NO_RECURSE )
535       {
536         FT_Slot_Internal  internal = glyph-&gt;root.internal;
537 
538 
539         glyph-&gt;root.metrics.horiBearingX = decoder.builder.left_bearing.x;
540         glyph-&gt;root.metrics.horiAdvance  = decoder.glyph_width;
541         internal-&gt;glyph_matrix           = font_matrix;
542         internal-&gt;glyph_delta            = font_offset;
543         internal-&gt;glyph_transformed      = 1;
544       }
545       else
546       {
547         FT_BBox            cbox;
548         FT_Glyph_Metrics*  metrics = &amp;glyph-&gt;root.metrics;
549         FT_Bool            has_vertical_info;
550 
551 
552         if ( face-&gt;horizontal.number_Of_HMetrics )
553         {
554           FT_Short   horiBearingX = 0;
555           FT_UShort  horiAdvance  = 0;
556 
557 
558           ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 0,
559                                                      glyph_index,
560                                                      &amp;horiBearingX,
561                                                      &amp;horiAdvance );
562           metrics-&gt;horiAdvance          = horiAdvance;
563           metrics-&gt;horiBearingX         = horiBearingX;
564           glyph-&gt;root.linearHoriAdvance = horiAdvance;
565         }
566         else
567         {
568           /* copy the _unscaled_ advance width */
569           metrics-&gt;horiAdvance          = decoder.glyph_width;
570           glyph-&gt;root.linearHoriAdvance = decoder.glyph_width;
571         }
572 
573         glyph-&gt;root.internal-&gt;glyph_transformed = 0;
574 
575         has_vertical_info = FT_BOOL( face-&gt;vertical_info                   &amp;&amp;
576                                      face-&gt;vertical.number_Of_VMetrics &gt; 0 );
577 
578         /* get the vertical metrics from the vmtx table if we have one */
579         if ( has_vertical_info )
580         {
581           FT_Short   vertBearingY = 0;
582           FT_UShort  vertAdvance  = 0;
583 
584 
585           ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 1,
586                                                      glyph_index,
587                                                      &amp;vertBearingY,
588                                                      &amp;vertAdvance );
589           metrics-&gt;vertBearingY = vertBearingY;
590           metrics-&gt;vertAdvance  = vertAdvance;
591         }
592         else
593         {
594           /* make up vertical ones */
595           if ( face-&gt;os2.version != 0xFFFFU )
596             metrics-&gt;vertAdvance = (FT_Pos)( face-&gt;os2.sTypoAscender -
597                                              face-&gt;os2.sTypoDescender );
598           else
599             metrics-&gt;vertAdvance = (FT_Pos)( face-&gt;horizontal.Ascender -
600                                              face-&gt;horizontal.Descender );
601         }
602 
603         glyph-&gt;root.linearVertAdvance = metrics-&gt;vertAdvance;
604 
605         glyph-&gt;root.format = FT_GLYPH_FORMAT_OUTLINE;
606 
607         glyph-&gt;root.outline.flags = 0;
608         if ( size &amp;&amp; size-&gt;root.metrics.y_ppem &lt; 24 )
609           glyph-&gt;root.outline.flags |= FT_OUTLINE_HIGH_PRECISION;
610 
611         glyph-&gt;root.outline.flags |= FT_OUTLINE_REVERSE_FILL;
612 
613         /* apply the font matrix, if any */
614         if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
615              font_matrix.xy != 0        || font_matrix.yx != 0        )
616         {
617           FT_Outline_Transform( &amp;glyph-&gt;root.outline, &amp;font_matrix );
618 
619           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance,
620                                             font_matrix.xx );
621           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance,
622                                             font_matrix.yy );
623         }
624 
625         if ( font_offset.x || font_offset.y )
626         {
627           FT_Outline_Translate( &amp;glyph-&gt;root.outline,
628                                 font_offset.x,
629                                 font_offset.y );
630 
631           metrics-&gt;horiAdvance += font_offset.x;
632           metrics-&gt;vertAdvance += font_offset.y;
633         }
634 
635         if ( ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0 || force_scaling )
636         {
637           /* scale the outline and the metrics */
638           FT_Int       n;
639           FT_Outline*  cur     = &amp;glyph-&gt;root.outline;
640           FT_Vector*   vec     = cur-&gt;points;
641           FT_Fixed     x_scale = glyph-&gt;x_scale;
642           FT_Fixed     y_scale = glyph-&gt;y_scale;
643 
644 
645           /* First of all, scale the points */
646           if ( !hinting || !decoder.builder.hints_funcs )
647             for ( n = cur-&gt;n_points; n &gt; 0; n--, vec++ )
648             {
649               vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );
650               vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );
651             }
652 
653           /* Then scale the metrics */
654           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance, x_scale );
655           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance, y_scale );
656         }
657 
658         /* compute the other metrics */
659         FT_Outline_Get_CBox( &amp;glyph-&gt;root.outline, &amp;cbox );
660 
661         metrics-&gt;width  = cbox.xMax - cbox.xMin;
662         metrics-&gt;height = cbox.yMax - cbox.yMin;
663 
664         metrics-&gt;horiBearingX = cbox.xMin;
665         metrics-&gt;horiBearingY = cbox.yMax;
666 
667         if ( has_vertical_info )
668           metrics-&gt;vertBearingX = metrics-&gt;horiBearingX -
669                                     metrics-&gt;horiAdvance / 2;
670         else
671         {
672           if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
673             ft_synthesize_vertical_metrics( metrics,
674                                             metrics-&gt;vertAdvance );
675         }
676       }
677     }
678 
679     return error;
680   }
681 
682 
683 /* END */
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftmm.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftoutln.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftobjs.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ftobjs.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    The FreeType private base classes (body).                            */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_LIST_H
  21 #include FT_OUTLINE_H
  22 #include FT_FONT_FORMATS_H
  23 
  24 #include FT_INTERNAL_VALIDATE_H
  25 #include FT_INTERNAL_OBJECTS_H
  26 #include FT_INTERNAL_DEBUG_H
  27 #include FT_INTERNAL_RFORK_H
  28 #include FT_INTERNAL_STREAM_H
  29 #include FT_INTERNAL_SFNT_H            /* for SFNT_Load_Table_Func */
  30 #include FT_INTERNAL_POSTSCRIPT_AUX_H  /* for PS_Driver            */
  31 
  32 #include FT_TRUETYPE_TABLES_H
  33 #include FT_TRUETYPE_TAGS_H
  34 #include FT_TRUETYPE_IDS_H
  35 
  36 #include FT_SERVICE_PROPERTIES_H
</pre>
<hr />
<pre>
  62 #endif /* _MSC_VER */
  63 
  64   /* It&#39;s easiest to include `md5.c&#39; directly.  However, since OpenSSL */
  65   /* also provides the same functions, there might be conflicts if     */
  66   /* both FreeType and OpenSSL are built as static libraries.  For     */
  67   /* this reason, we put the MD5 stuff into the `FT_&#39; namespace.       */
  68 #define MD5_u32plus  FT_MD5_u32plus
  69 #define MD5_CTX      FT_MD5_CTX
  70 #define MD5_Init     FT_MD5_Init
  71 #define MD5_Update   FT_MD5_Update
  72 #define MD5_Final    FT_MD5_Final
  73 
  74 #undef  HAVE_OPENSSL
  75 
  76 #include &quot;md5.c&quot;
  77 
  78 #if defined( _MSC_VER )
  79 #pragma warning( pop )
  80 #endif
  81 












  82 #endif /* FT_DEBUG_LEVEL_TRACE */
  83 
  84 
  85 #define GRID_FIT_METRICS
  86 
  87 
  88   /* forward declaration */
  89   static FT_Error
  90   ft_open_face_internal( FT_Library           library,
  91                          const FT_Open_Args*  args,
  92                          FT_Long              face_index,
  93                          FT_Face             *aface,
  94                          FT_Bool              test_mac_fonts );
  95 
  96 
  97   FT_BASE_DEF( FT_Pointer )
  98   ft_service_list_lookup( FT_ServiceDesc  service_descriptors,
  99                           const char*     service_id )
 100   {
 101     FT_Pointer      result = NULL;
</pre>
<hr />
<pre>
 242   }
 243 
 244 
 245   FT_BASE_DEF( void )
 246   FT_Stream_Free( FT_Stream  stream,
 247                   FT_Int     external )
 248   {
 249     if ( stream )
 250     {
 251       FT_Memory  memory = stream-&gt;memory;
 252 
 253 
 254       FT_Stream_Close( stream );
 255 
 256       if ( !external )
 257         FT_FREE( stream );
 258     }
 259   }
 260 
 261 
<span class="line-modified"> 262   /*************************************************************************/</span>
<span class="line-modified"> 263   /*                                                                       */</span>
<span class="line-modified"> 264   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 265   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 266   /* messages during execution.                                            */</span>
<span class="line-modified"> 267   /*                                                                       */</span>
 268 #undef  FT_COMPONENT
<span class="line-modified"> 269 #define FT_COMPONENT  trace_objs</span>
 270 
 271 
 272   /*************************************************************************/
 273   /*************************************************************************/
 274   /*************************************************************************/
 275   /****                                                                 ****/
 276   /****                                                                 ****/
 277   /****               FACE, SIZE &amp; GLYPH SLOT OBJECTS                   ****/
 278   /****                                                                 ****/
 279   /****                                                                 ****/
 280   /*************************************************************************/
 281   /*************************************************************************/
 282   /*************************************************************************/
 283 
 284 
 285   static FT_Error
 286   ft_glyphslot_init( FT_GlyphSlot  slot )
 287   {
 288     FT_Driver         driver   = slot-&gt;face-&gt;driver;
 289     FT_Driver_Class   clazz    = driver-&gt;clazz;
</pre>
<hr />
<pre>
 313   FT_BASE_DEF( void )
 314   ft_glyphslot_free_bitmap( FT_GlyphSlot  slot )
 315   {
 316     if ( slot-&gt;internal &amp;&amp; ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )
 317     {
 318       FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );
 319 
 320 
 321       FT_FREE( slot-&gt;bitmap.buffer );
 322       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
 323     }
 324     else
 325     {
 326       /* assume that the bitmap buffer was stolen or not */
 327       /* allocated from the heap                         */
 328       slot-&gt;bitmap.buffer = NULL;
 329     }
 330   }
 331 
 332 
<span class="line-modified"> 333   FT_BASE_DEF( void )</span>


 334   ft_glyphslot_preset_bitmap( FT_GlyphSlot      slot,
 335                               FT_Render_Mode    mode,
 336                               const FT_Vector*  origin )
 337   {
 338     FT_Outline*  outline = &amp;slot-&gt;outline;
 339     FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
 340 
 341     FT_Pixel_Mode  pixel_mode;
 342 
<span class="line-modified"> 343     FT_BBox  cbox;</span>
 344     FT_Pos   x_shift = 0;
 345     FT_Pos   y_shift = 0;
 346     FT_Pos   x_left, y_top;
 347     FT_Pos   width, height, pitch;
 348 
 349 
<span class="line-modified"> 350     if ( slot-&gt;internal &amp;&amp; ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )</span>
<span class="line-modified"> 351       return;</span>
 352 
 353     if ( origin )
 354     {
 355       x_shift = origin-&gt;x;
 356       y_shift = origin-&gt;y;
 357     }
 358 
 359     /* compute the control box, and grid-fit it, */
 360     /* taking into account the origin shift      */
 361     FT_Outline_Get_CBox( outline, &amp;cbox );
 362 
<span class="line-modified"> 363     cbox.xMin += x_shift;</span>
<span class="line-modified"> 364     cbox.yMin += y_shift;</span>
<span class="line-modified"> 365     cbox.xMax += x_shift;</span>
<span class="line-modified"> 366     cbox.yMax += y_shift;</span>







 367 
 368     switch ( mode )
 369     {
 370     case FT_RENDER_MODE_MONO:
 371       pixel_mode = FT_PIXEL_MODE_MONO;
 372 #if 1
<span class="line-modified"> 373       /* undocumented but confirmed: bbox values get rounded    */</span>
<span class="line-modified"> 374       /* unless the rounded box can collapse for a narrow glyph */</span>
<span class="line-modified"> 375       if ( cbox.xMax - cbox.xMin &lt; 64 )</span>
<span class="line-modified"> 376       {</span>
<span class="line-modified"> 377         cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-modified"> 378         cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-modified"> 379       }</span>
<span class="line-modified"> 380       else</span>
<span class="line-removed"> 381       {</span>
<span class="line-removed"> 382         cbox.xMin = FT_PIX_ROUND_LONG( cbox.xMin );</span>
<span class="line-removed"> 383         cbox.xMax = FT_PIX_ROUND_LONG( cbox.xMax );</span>
<span class="line-removed"> 384       }</span>
 385 
<span class="line-modified"> 386       if ( cbox.yMax - cbox.yMin &lt; 64 )</span>



 387       {
<span class="line-modified"> 388         cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-modified"> 389         cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>



 390       }
<span class="line-modified"> 391       else</span>






 392       {
<span class="line-modified"> 393         cbox.yMin = FT_PIX_ROUND_LONG( cbox.yMin );</span>
<span class="line-modified"> 394         cbox.yMax = FT_PIX_ROUND_LONG( cbox.yMax );</span>



 395       }


 396 #else
<span class="line-modified"> 397       cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-removed"> 398       cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-removed"> 399       cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-removed"> 400       cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>
 401 #endif
<span class="line-removed"> 402       break;</span>
 403 
 404     case FT_RENDER_MODE_LCD:
 405       pixel_mode = FT_PIXEL_MODE_LCD;
<span class="line-modified"> 406       ft_lcd_padding( &amp;cbox.xMin, &amp;cbox.xMax, slot );</span>
<span class="line-modified"> 407       goto Round;</span>
 408 
 409     case FT_RENDER_MODE_LCD_V:
 410       pixel_mode = FT_PIXEL_MODE_LCD_V;
<span class="line-modified"> 411       ft_lcd_padding( &amp;cbox.yMin, &amp;cbox.yMax, slot );</span>
<span class="line-modified"> 412       goto Round;</span>
 413 
 414     case FT_RENDER_MODE_NORMAL:
 415     case FT_RENDER_MODE_LIGHT:
 416     default:
 417       pixel_mode = FT_PIXEL_MODE_GRAY;
<span class="line-modified"> 418     Round:</span>
<span class="line-modified"> 419       cbox.xMin = FT_PIX_FLOOR( cbox.xMin );</span>
<span class="line-modified"> 420       cbox.yMin = FT_PIX_FLOOR( cbox.yMin );</span>
<span class="line-modified"> 421       cbox.xMax = FT_PIX_CEIL_LONG( cbox.xMax );</span>
<span class="line-modified"> 422       cbox.yMax = FT_PIX_CEIL_LONG( cbox.yMax );</span>
 423     }
 424 
<span class="line-modified"> 425     x_shift = SUB_LONG( x_shift, cbox.xMin );</span>
<span class="line-modified"> 426     y_shift = SUB_LONG( y_shift, cbox.yMin );</span>
 427 
<span class="line-modified"> 428     x_left = cbox.xMin &gt;&gt; 6;</span>
<span class="line-modified"> 429     y_top  = cbox.yMax &gt;&gt; 6;</span>
<span class="line-removed"> 430 </span>
<span class="line-removed"> 431     width  = ( (FT_ULong)cbox.xMax - (FT_ULong)cbox.xMin ) &gt;&gt; 6;</span>
<span class="line-removed"> 432     height = ( (FT_ULong)cbox.yMax - (FT_ULong)cbox.yMin ) &gt;&gt; 6;</span>
 433 
 434     switch ( pixel_mode )
 435     {
 436     case FT_PIXEL_MODE_MONO:
 437       pitch = ( ( width + 15 ) &gt;&gt; 4 ) &lt;&lt; 1;
 438       break;
 439 
 440     case FT_PIXEL_MODE_LCD:
 441       width *= 3;
 442       pitch  = FT_PAD_CEIL( width, 4 );
 443       break;
 444 
 445     case FT_PIXEL_MODE_LCD_V:
 446       height *= 3;
 447       /* fall through */
 448 
 449     case FT_PIXEL_MODE_GRAY:
 450     default:
 451       pitch = width;
 452     }
 453 
 454     slot-&gt;bitmap_left = (FT_Int)x_left;
 455     slot-&gt;bitmap_top  = (FT_Int)y_top;
 456 
 457     bitmap-&gt;pixel_mode = (unsigned char)pixel_mode;
 458     bitmap-&gt;num_grays  = 256;
 459     bitmap-&gt;width      = (unsigned int)width;
 460     bitmap-&gt;rows       = (unsigned int)height;
 461     bitmap-&gt;pitch      = pitch;










 462   }
 463 
 464 
 465   FT_BASE_DEF( void )
 466   ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
 467                            FT_Byte*      buffer )
 468   {
 469     ft_glyphslot_free_bitmap( slot );
 470 
 471     slot-&gt;bitmap.buffer = buffer;
 472 
 473     FT_ASSERT( (slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP) == 0 );
 474   }
 475 
 476 
 477   FT_BASE_DEF( FT_Error )
 478   ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
 479                              FT_ULong      size )
 480   {
 481     FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );
</pre>
<hr />
<pre>
 790                     FT_LOAD_IGNORE_TRANSFORM;
 791 
 792     if ( load_flags &amp; FT_LOAD_NO_SCALE )
 793     {
 794       load_flags |= FT_LOAD_NO_HINTING |
 795                     FT_LOAD_NO_BITMAP;
 796 
 797       load_flags &amp;= ~FT_LOAD_RENDER;
 798     }
 799 
 800     if ( load_flags &amp; FT_LOAD_BITMAP_METRICS_ONLY )
 801       load_flags &amp;= ~FT_LOAD_RENDER;
 802 
 803     /*
 804      * Determine whether we need to auto-hint or not.
 805      * The general rules are:
 806      *
 807      * - Do only auto-hinting if we have
 808      *
 809      *   - a hinter module,
<span class="line-modified"> 810      *   - a scalable font format dealing with outlines,</span>
 811      *   - not a tricky font, and
 812      *   - no transforms except simple slants and/or rotations by
 813      *     integer multiples of 90 degrees.
 814      *
 815      * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don&#39;t
 816      *   have a native font hinter.
 817      *
 818      * - Otherwise, auto-hint for LIGHT hinting mode or if there isn&#39;t
 819      *   any hinting bytecode in the TrueType/OpenType font.
 820      *
 821      * - Exception: The font is `tricky&#39; and requires the native hinter to
 822      *   load properly.
 823      */
 824 
 825     if ( hinter                                           &amp;&amp;
 826          !( load_flags &amp; FT_LOAD_NO_HINTING )             &amp;&amp;
 827          !( load_flags &amp; FT_LOAD_NO_AUTOHINT )            &amp;&amp;
<span class="line-modified"> 828          FT_DRIVER_IS_SCALABLE( driver )                  &amp;&amp;</span>
<span class="line-removed"> 829          FT_DRIVER_USES_OUTLINES( driver )                &amp;&amp;</span>
 830          !FT_IS_TRICKY( face )                            &amp;&amp;
 831          ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM )    ||
 832            ( face-&gt;internal-&gt;transform_matrix.yx == 0 &amp;&amp;
 833              face-&gt;internal-&gt;transform_matrix.xx != 0 ) ||
 834            ( face-&gt;internal-&gt;transform_matrix.xx == 0 &amp;&amp;
 835              face-&gt;internal-&gt;transform_matrix.yx != 0 ) ) )
 836     {
 837       if ( ( load_flags &amp; FT_LOAD_FORCE_AUTOHINT ) ||
 838            !FT_DRIVER_HAS_HINTER( driver )         )
 839         autohint = TRUE;
 840       else
 841       {
 842         FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
 843         FT_Bool         is_light_type1;
 844 
 845 
 846         /* only the new Adobe engine (for both CFF and Type 1) is `light&#39;; */
 847         /* we use `strstr&#39; to catch both `Type 1&#39; and `CID Type 1&#39;         */
 848         is_light_type1 =
<span class="line-modified"> 849           ft_strstr( FT_Get_Font_Format( face ), &quot;Type 1&quot; ) != NULL   &amp;&amp;</span>
 850           ((PS_Driver)driver)-&gt;hinting_engine == FT_HINTING_ADOBE;
 851 
 852         /* the check for `num_locations&#39; assures that we actually    */
 853         /* test for instructions in a TTF and not in a CFF-based OTF */
 854         /*                                                           */
 855         /* since `maxSizeOfInstructions&#39; might be unreliable, we     */
 856         /* check the size of the `fpgm&#39; and `prep&#39; tables, too --    */
 857         /* the assumption is that there don&#39;t exist real TTFs where  */
 858         /* both `fpgm&#39; and `prep&#39; tables are missing                 */
 859         if ( ( mode == FT_RENDER_MODE_LIGHT           &amp;&amp;
 860                ( !FT_DRIVER_HINTS_LIGHTLY( driver ) &amp;&amp;
 861                  !is_light_type1                    ) )         ||
 862              ( FT_IS_SFNT( face )                             &amp;&amp;
 863                ttface-&gt;num_locations                          &amp;&amp;
 864                ttface-&gt;max_profile.maxSizeOfInstructions == 0 &amp;&amp;
 865                ttface-&gt;font_program_size == 0                 &amp;&amp;
 866                ttface-&gt;cvt_program_size == 0                  ) )
 867           autohint = TRUE;
 868       }
 869     }
</pre>
<hr />
<pre>
 909       }
 910     }
 911     else
 912     {
 913       error = driver-&gt;clazz-&gt;load_glyph( slot,
 914                                          face-&gt;size,
 915                                          glyph_index,
 916                                          load_flags );
 917       if ( error )
 918         goto Exit;
 919 
 920       if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
 921       {
 922         /* check that the loaded outline is correct */
 923         error = FT_Outline_Check( &amp;slot-&gt;outline );
 924         if ( error )
 925           goto Exit;
 926 
 927 #ifdef GRID_FIT_METRICS
 928         if ( !( load_flags &amp; FT_LOAD_NO_HINTING ) )
<span class="line-modified"> 929           ft_glyphslot_grid_fit_metrics( slot,</span>
<span class="line-modified"> 930               FT_BOOL( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT ) );</span>

 931 #endif
 932       }
 933     }
 934 
 935   Load_Ok:
 936     /* compute the advance */
 937     if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
 938     {
 939       slot-&gt;advance.x = 0;
 940       slot-&gt;advance.y = slot-&gt;metrics.vertAdvance;
 941     }
 942     else
 943     {
 944       slot-&gt;advance.x = slot-&gt;metrics.horiAdvance;
 945       slot-&gt;advance.y = 0;
 946     }
 947 
 948     /* compute the linear advance in 16.16 pixels */
 949     if ( ( load_flags &amp; FT_LOAD_LINEAR_DESIGN ) == 0 &amp;&amp;
 950          FT_IS_SCALABLE( face )                      )
</pre>
<hr />
<pre>
 978                                      &amp;internal-&gt;transform_matrix,
 979                                      &amp;internal-&gt;transform_delta );
 980         else if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
 981         {
 982           /* apply `standard&#39; transformation if no renderer is available */
 983           if ( internal-&gt;transform_flags &amp; 1 )
 984             FT_Outline_Transform( &amp;slot-&gt;outline,
 985                                   &amp;internal-&gt;transform_matrix );
 986 
 987           if ( internal-&gt;transform_flags &amp; 2 )
 988             FT_Outline_Translate( &amp;slot-&gt;outline,
 989                                   internal-&gt;transform_delta.x,
 990                                   internal-&gt;transform_delta.y );
 991         }
 992 
 993         /* transform advance */
 994         FT_Vector_Transform( &amp;slot-&gt;advance, &amp;internal-&gt;transform_matrix );
 995       }
 996     }
 997 



 998     /* do we need to render the image or preset the bitmap now? */
 999     if ( !error                                    &amp;&amp;
1000          ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0    &amp;&amp;
1001          slot-&gt;format != FT_GLYPH_FORMAT_BITMAP    &amp;&amp;
1002          slot-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
1003     {
1004       FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
1005 
1006 
1007       if ( mode == FT_RENDER_MODE_NORMAL   &amp;&amp;
1008            load_flags &amp; FT_LOAD_MONOCHROME )
1009         mode = FT_RENDER_MODE_MONO;
1010 
1011       if ( load_flags &amp; FT_LOAD_RENDER )
1012         error = FT_Render_Glyph( slot, mode );
1013       else
1014         ft_glyphslot_preset_bitmap( slot, mode, NULL );
1015     }
1016 
<span class="line-modified">1017     FT_TRACE5(( &quot;FT_Load_Glyph: index %d, flags %x\n&quot;,</span>
<span class="line-modified">1018                 glyph_index, load_flags               ));</span>

1019     FT_TRACE5(( &quot;  x advance: %f\n&quot;, slot-&gt;advance.x / 64.0 ));
1020     FT_TRACE5(( &quot;  y advance: %f\n&quot;, slot-&gt;advance.y / 64.0 ));
1021     FT_TRACE5(( &quot;  linear x advance: %f\n&quot;,
1022                 slot-&gt;linearHoriAdvance / 65536.0 ));
1023     FT_TRACE5(( &quot;  linear y advance: %f\n&quot;,
1024                 slot-&gt;linearVertAdvance / 65536.0 ));
<span class="line-modified">1025     FT_TRACE5(( &quot;  bitmap %dx%d, mode %d\n&quot;,</span>
<span class="line-modified">1026                 slot-&gt;bitmap.width, slot-&gt;bitmap.rows,</span>
<span class="line-modified">1027                 slot-&gt;bitmap.pixel_mode               ));</span>



1028 
1029   Exit:
1030     return error;
1031   }
1032 
1033 
1034   /* documentation is in freetype.h */
1035 
1036   FT_EXPORT_DEF( FT_Error )
1037   FT_Load_Char( FT_Face   face,
1038                 FT_ULong  char_code,
1039                 FT_Int32  load_flags )
1040   {
1041     FT_UInt  glyph_index;
1042 
1043 
1044     if ( !face )
1045       return FT_THROW( Invalid_Face_Handle );
1046 
1047     glyph_index = (FT_UInt)char_code;
</pre>
<hr />
<pre>
1145 
1146     /* get rid of it */
1147     if ( face-&gt;internal )
1148     {
1149       FT_FREE( face-&gt;internal );
1150     }
1151     FT_FREE( face );
1152   }
1153 
1154 
1155   static void
1156   Destroy_Driver( FT_Driver  driver )
1157   {
1158     FT_List_Finalize( &amp;driver-&gt;faces_list,
1159                       (FT_List_Destructor)destroy_face,
1160                       driver-&gt;root.memory,
1161                       driver );
1162   }
1163 
1164 
<span class="line-modified">1165   /*************************************************************************/</span>
<span class="line-modified">1166   /*                                                                       */</span>
<span class="line-modified">1167   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1168   /*    find_unicode_charmap                                               */</span>
<span class="line-modified">1169   /*                                                                       */</span>
<span class="line-modified">1170   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1171   /*    This function finds a Unicode charmap, if there is one.            */</span>
<span class="line-modified">1172   /*    And if there is more than one, it tries to favour the more         */</span>
<span class="line-modified">1173   /*    extensive one, i.e., one that supports UCS-4 against those which   */</span>
<span class="line-modified">1174   /*    are limited to the BMP (said UCS-2 encoding.)                      */</span>
<span class="line-modified">1175   /*                                                                       */</span>
<span class="line-modified">1176   /*    This function is called from open_face() (just below), and also    */</span>
<span class="line-modified">1177   /*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */</span>
<span class="line-modified">1178   /*                                                                       */</span>
1179   static FT_Error
1180   find_unicode_charmap( FT_Face  face )
1181   {
1182     FT_CharMap*  first;
1183     FT_CharMap*  cur;
1184 
1185 
1186     /* caller should have already checked that `face&#39; is valid */
1187     FT_ASSERT( face );
1188 
1189     first = face-&gt;charmaps;
1190 
1191     if ( !first )
1192       return FT_THROW( Invalid_CharMap_Handle );
1193 
1194     /*
<span class="line-modified">1195      *  The original TrueType specification(s) only specified charmap</span>
<span class="line-modified">1196      *  formats that are capable of mapping 8 or 16 bit character codes to</span>
<span class="line-modified">1197      *  glyph indices.</span>
1198      *
<span class="line-modified">1199      *  However, recent updates to the Apple and OpenType specifications</span>
<span class="line-modified">1200      *  introduced new formats that are capable of mapping 32-bit character</span>
<span class="line-modified">1201      *  codes as well.  And these are already used on some fonts, mainly to</span>
<span class="line-modified">1202      *  map non-BMP Asian ideographs as defined in Unicode.</span>
1203      *
<span class="line-modified">1204      *  For compatibility purposes, these fonts generally come with</span>
<span class="line-modified">1205      *  *several* Unicode charmaps:</span>
1206      *
<span class="line-modified">1207      *   - One of them in the &quot;old&quot; 16-bit format, that cannot access</span>
<span class="line-modified">1208      *     all glyphs in the font.</span>
1209      *
<span class="line-modified">1210      *   - Another one in the &quot;new&quot; 32-bit format, that can access all</span>
<span class="line-modified">1211      *     the glyphs.</span>
1212      *
<span class="line-modified">1213      *  This function has been written to always favor a 32-bit charmap</span>
<span class="line-modified">1214      *  when found.  Otherwise, a 16-bit one is returned when found.</span>
1215      */
1216 
1217     /* Since the `interesting&#39; table, with IDs (3,10), is normally the */
1218     /* last one, we loop backwards.  This loses with type1 fonts with  */
1219     /* non-BMP characters (&lt;.0001%), this wins with .ttf with non-BMP  */
1220     /* chars (.01% ?), and this is the same about 99.99% of the time!  */
1221 
1222     cur = first + face-&gt;num_charmaps;  /* points after the last one */
1223 
1224     for ( ; --cur &gt;= first; )
1225     {
1226       if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )
1227       {
1228         /* XXX If some new encodings to represent UCS-4 are added, */
1229         /*     they should be added here.                          */
1230         if ( ( cur[0]-&gt;platform_id == TT_PLATFORM_MICROSOFT &amp;&amp;
1231                cur[0]-&gt;encoding_id == TT_MS_ID_UCS_4        )     ||
1232              ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE &amp;&amp;
1233                cur[0]-&gt;encoding_id == TT_APPLE_ID_UNICODE_32    ) )
1234         {
</pre>
<hr />
<pre>
1238       }
1239     }
1240 
1241     /* We do not have any UCS-4 charmap.                */
1242     /* Do the loop again and search for UCS-2 charmaps. */
1243     cur = first + face-&gt;num_charmaps;
1244 
1245     for ( ; --cur &gt;= first; )
1246     {
1247       if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )
1248       {
1249         face-&gt;charmap = cur[0];
1250         return FT_Err_Ok;
1251       }
1252     }
1253 
1254     return FT_THROW( Invalid_CharMap_Handle );
1255   }
1256 
1257 
<span class="line-modified">1258   /*************************************************************************/</span>
<span class="line-modified">1259   /*                                                                       */</span>
<span class="line-modified">1260   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1261   /*    find_variant_selector_charmap                                      */</span>
<span class="line-modified">1262   /*                                                                       */</span>
<span class="line-modified">1263   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1264   /*    This function finds the variant selector charmap, if there is one. */</span>
<span class="line-modified">1265   /*    There can only be one (platform=0, specific=5, format=14).         */</span>
<span class="line-modified">1266   /*                                                                       */</span>
1267   static FT_CharMap
1268   find_variant_selector_charmap( FT_Face  face )
1269   {
1270     FT_CharMap*  first;
1271     FT_CharMap*  end;
1272     FT_CharMap*  cur;
1273 
1274 
1275     /* caller should have already checked that `face&#39; is valid */
1276     FT_ASSERT( face );
1277 
1278     first = face-&gt;charmaps;
1279 
1280     if ( !first )
1281       return NULL;
1282 
1283     end = first + face-&gt;num_charmaps;  /* points after the last one */
1284 
1285     for ( cur = first; cur &lt; end; cur++ )
1286     {
1287       if ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE    &amp;&amp;
1288            cur[0]-&gt;encoding_id == TT_APPLE_ID_VARIANT_SELECTOR &amp;&amp;
1289            FT_Get_CMap_Format( cur[0] ) == 14                  )
1290         return cur[0];
1291     }
1292 
1293     return NULL;
1294   }
1295 
1296 
<span class="line-modified">1297   /*************************************************************************/</span>
<span class="line-modified">1298   /*                                                                       */</span>
<span class="line-modified">1299   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1300   /*    open_face                                                          */</span>
<span class="line-modified">1301   /*                                                                       */</span>
<span class="line-modified">1302   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1303   /*    This function does some work for FT_Open_Face().                   */</span>
<span class="line-modified">1304   /*                                                                       */</span>
1305   static FT_Error
1306   open_face( FT_Driver      driver,
1307              FT_Stream      *astream,
1308              FT_Bool        external_stream,
1309              FT_Long        face_index,
1310              FT_Int         num_params,
1311              FT_Parameter*  params,
1312              FT_Face       *aface )
1313   {
1314     FT_Memory         memory;
1315     FT_Driver_Class   clazz;
1316     FT_Face           face     = NULL;
1317     FT_Face_Internal  internal = NULL;
1318 
1319     FT_Error          error, error2;
1320 
1321 
1322     clazz  = driver-&gt;clazz;
1323     memory = driver-&gt;root.memory;
1324 
</pre>
<hr />
<pre>
2159              header[0x5A];
2160 #endif /* 0 */
2161     offset = 128 + ( ( dlen + 127 ) &amp; ~127 );
2162 
2163     return IsMacResource( library, stream, offset, face_index, aface );
2164 
2165   Exit:
2166     return error;
2167   }
2168 
2169 
2170   static FT_Error
2171   load_face_in_embedded_rfork( FT_Library           library,
2172                                FT_Stream            stream,
2173                                FT_Long              face_index,
2174                                FT_Face             *aface,
2175                                const FT_Open_Args  *args )
2176   {
2177 
2178 #undef  FT_COMPONENT
<span class="line-modified">2179 #define FT_COMPONENT  trace_raccess</span>
2180 
2181     FT_Memory  memory = library-&gt;memory;
2182     FT_Error   error  = FT_ERR( Unknown_File_Format );
2183     FT_UInt    i;
2184 
<span class="line-modified">2185     char *     file_names[FT_RACCESS_N_RULES];</span>
2186     FT_Long    offsets[FT_RACCESS_N_RULES];
2187     FT_Error   errors[FT_RACCESS_N_RULES];
2188     FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */
2189 
2190     FT_Open_Args  args2;
2191     FT_Stream     stream2 = NULL;
2192 
2193 
2194     FT_Raccess_Guess( library, stream,
2195                       args-&gt;pathname, file_names, offsets, errors );
2196 
2197     for ( i = 0; i &lt; FT_RACCESS_N_RULES; i++ )
2198     {
2199       is_darwin_vfs = ft_raccess_rule_by_darwin_vfs( library, i );
2200       if ( is_darwin_vfs &amp;&amp; vfs_rfork_has_no_font )
2201       {
2202         FT_TRACE3(( &quot;Skip rule %d: darwin vfs resource fork&quot;
2203                     &quot; is already checked and&quot;
2204                     &quot; no font is found\n&quot;,
2205                     i ));
</pre>
<hr />
<pre>
2237 
2238       if ( !error )
2239           break;
2240       else if ( is_darwin_vfs )
2241           vfs_rfork_has_no_font = TRUE;
2242     }
2243 
2244     for (i = 0; i &lt; FT_RACCESS_N_RULES; i++)
2245     {
2246       if ( file_names[i] )
2247         FT_FREE( file_names[i] );
2248     }
2249 
2250     /* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
2251     if ( error )
2252       error = FT_ERR( Unknown_File_Format );
2253 
2254     return error;
2255 
2256 #undef  FT_COMPONENT
<span class="line-modified">2257 #define FT_COMPONENT  trace_objs</span>
2258 
2259   }
2260 
2261 
2262   /* Check for some macintosh formats without Carbon framework.    */
2263   /* Is this a macbinary file?  If so look at the resource fork.   */
2264   /* Is this a mac dfont file?                                     */
2265   /* Is this an old style resource fork? (in data)                 */
2266   /* Else call load_face_in_embedded_rfork to try extra rules      */
2267   /* (defined in `ftrfork.c&#39;).                                     */
2268   /*                                                               */
2269   static FT_Error
2270   load_mac_face( FT_Library           library,
2271                  FT_Stream            stream,
2272                  FT_Long              face_index,
2273                  FT_Face             *aface,
2274                  const FT_Open_Args  *args )
2275   {
2276     FT_Error error;
2277     FT_UNUSED( args );
2278 
2279 
2280     error = IsMacBinary( library, stream, face_index, aface );
2281     if ( FT_ERR_EQ( error, Unknown_File_Format ) )
2282     {
2283 
2284 #undef  FT_COMPONENT
<span class="line-modified">2285 #define FT_COMPONENT  trace_raccess</span>
2286 
2287 #ifdef FT_DEBUG_LEVEL_TRACE
2288       FT_TRACE3(( &quot;Try as dfont: &quot; ));
2289       if ( !( args-&gt;flags &amp; FT_OPEN_MEMORY ) )
2290         FT_TRACE3(( &quot;%s ...&quot;, args-&gt;pathname ));
2291 #endif
2292 
2293       error = IsMacResource( library, stream, 0, face_index, aface );
2294 
2295       FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot; : &quot;successful&quot; ));
2296 
2297 #undef  FT_COMPONENT
<span class="line-modified">2298 #define FT_COMPONENT  trace_objs</span>
2299 
2300     }
2301 
2302     if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||
2303            FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &amp;&amp;
2304          ( args-&gt;flags &amp; FT_OPEN_PATHNAME )               )
2305       error = load_face_in_embedded_rfork( library, stream,
2306                                            face_index, aface, args );
2307     return error;
2308   }
2309 #endif
2310 
2311 #endif  /* !FT_MACINTOSH &amp;&amp; FT_CONFIG_OPTION_MAC_FONTS */
2312 
2313 
2314   /* documentation is in freetype.h */
2315 
2316   FT_EXPORT_DEF( FT_Error )
2317   FT_Open_Face( FT_Library           library,
2318                 const FT_Open_Args*  args,
</pre>
<hr />
<pre>
2676       return FT_THROW( Invalid_Face_Handle );
2677 
2678     driver = face-&gt;driver;
2679     if ( !driver )
2680       return FT_THROW( Invalid_Driver_Handle );
2681 
2682     error = FT_Stream_New( driver-&gt;root.library, parameters, &amp;stream );
2683     if ( error )
2684       goto Exit;
2685 
2686     /* we implement FT_Attach_Stream in each driver through the */
2687     /* `attach_file&#39; interface                                  */
2688 
2689     error = FT_ERR( Unimplemented_Feature );
2690     clazz = driver-&gt;clazz;
2691     if ( clazz-&gt;attach_file )
2692       error = clazz-&gt;attach_file( face, stream );
2693 
2694     /* close the attached stream */
2695     FT_Stream_Free( stream,
<span class="line-modified">2696                     (FT_Bool)( parameters-&gt;stream &amp;&amp;</span>
<span class="line-modified">2697                                ( parameters-&gt;flags &amp; FT_OPEN_STREAM ) ) );</span>
2698 
2699   Exit:
2700     return error;
2701   }
2702 
2703 
2704   /* documentation is in freetype.h */
2705 
2706   FT_EXPORT_DEF( FT_Error )
2707   FT_Reference_Face( FT_Face  face )
2708   {
2709     if ( !face )
2710       return FT_THROW( Invalid_Face_Handle );
2711 
2712     face-&gt;internal-&gt;refcount++;
2713 
2714     return FT_Err_Ok;
2715   }
2716 
2717 
</pre>
<hr />
<pre>
3447                                 degree,
3448                                 akerning );
3449 
3450     return error;
3451   }
3452 
3453 
3454   /* documentation is in freetype.h */
3455 
3456   FT_EXPORT_DEF( FT_Error )
3457   FT_Select_Charmap( FT_Face      face,
3458                      FT_Encoding  encoding )
3459   {
3460     FT_CharMap*  cur;
3461     FT_CharMap*  limit;
3462 
3463 
3464     if ( !face )
3465       return FT_THROW( Invalid_Face_Handle );
3466 
<span class="line-modified">3467     if ( encoding == FT_ENCODING_NONE )</span>

3468       return FT_THROW( Invalid_Argument );
3469 
3470     /* FT_ENCODING_UNICODE is special.  We try to find the `best&#39; Unicode */
3471     /* charmap available, i.e., one with UCS-4 characters, if possible.   */
3472     /*                                                                    */
3473     /* This is done by find_unicode_charmap() above, to share code.       */
3474     if ( encoding == FT_ENCODING_UNICODE )
3475       return find_unicode_charmap( face );
3476 
3477     cur = face-&gt;charmaps;
3478     if ( !cur )
3479       return FT_THROW( Invalid_CharMap_Handle );
3480 
3481     limit = cur + face-&gt;num_charmaps;
3482 
3483     for ( ; cur &lt; limit; cur++ )
3484     {
3485       if ( cur[0]-&gt;encoding == encoding )
3486       {
3487         face-&gt;charmap = cur[0];
<span class="line-modified">3488         return 0;</span>
3489       }
3490     }
3491 
3492     return FT_THROW( Invalid_Argument );
3493   }
3494 
3495 
3496   /* documentation is in freetype.h */
3497 
3498   FT_EXPORT_DEF( FT_Error )
3499   FT_Set_Charmap( FT_Face     face,
3500                   FT_CharMap  charmap )
3501   {
3502     FT_CharMap*  cur;
3503     FT_CharMap*  limit;
3504 
3505 
3506     if ( !face )
3507       return FT_THROW( Invalid_Face_Handle );
3508 
3509     cur = face-&gt;charmaps;
3510     if ( !cur || !charmap )
3511       return FT_THROW( Invalid_CharMap_Handle );
3512 
<span class="line-removed">3513     if ( FT_Get_CMap_Format( charmap ) == 14 )</span>
<span class="line-removed">3514       return FT_THROW( Invalid_Argument );</span>
<span class="line-removed">3515 </span>
3516     limit = cur + face-&gt;num_charmaps;
3517 
3518     for ( ; cur &lt; limit; cur++ )
3519     {
<span class="line-modified">3520       if ( cur[0] == charmap )</span>

3521       {
3522         face-&gt;charmap = cur[0];
3523         return FT_Err_Ok;
3524       }
3525     }
3526 
3527     return FT_THROW( Invalid_Argument );
3528   }
3529 
3530 
3531   /* documentation is in freetype.h */
3532 
3533   FT_EXPORT_DEF( FT_Int )
3534   FT_Get_Charmap_Index( FT_CharMap  charmap )
3535   {
3536     FT_Int  i;
3537 
3538 
3539     if ( !charmap || !charmap-&gt;face )
3540       return -1;
</pre>
<hr />
<pre>
3999 
4000 
4001         if ( variantSelector &gt; 0xFFFFFFFFUL )
4002         {
4003           FT_TRACE1(( &quot;FT_Get_Char_Index: too large variantSelector&quot; ));
4004           FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, variantSelector ));
4005         }
4006 
4007         result = vcmap-&gt;clazz-&gt;variantchar_list( vcmap, memory,
4008                                                  (FT_UInt32)variantSelector );
4009       }
4010     }
4011 
4012     return result;
4013   }
4014 
4015 
4016   /* documentation is in freetype.h */
4017 
4018   FT_EXPORT_DEF( FT_UInt )
<span class="line-modified">4019   FT_Get_Name_Index( FT_Face     face,</span>
<span class="line-modified">4020                      FT_String*  glyph_name )</span>
4021   {
4022     FT_UInt  result = 0;
4023 
4024 
4025     if ( face                       &amp;&amp;
4026          FT_HAS_GLYPH_NAMES( face ) &amp;&amp;
4027          glyph_name                 )
4028     {
4029       FT_Service_GlyphDict  service;
4030 
4031 
4032       FT_FACE_LOOKUP_SERVICE( face,
4033                               service,
4034                               GLYPH_DICT );
4035 
4036       if ( service &amp;&amp; service-&gt;name_index )
4037         result = service-&gt;name_index( face, glyph_name );
4038     }
4039 
4040     return result;
</pre>
<hr />
<pre>
4470 
4471     for ( ; num_params &gt; 0; num_params-- )
4472     {
4473       error = set_mode( renderer, parameters-&gt;tag, parameters-&gt;data );
4474       if ( error )
4475         break;
4476       parameters++;
4477     }
4478 
4479   Exit:
4480     return error;
4481   }
4482 
4483 
4484   FT_BASE_DEF( FT_Error )
4485   FT_Render_Glyph_Internal( FT_Library      library,
4486                             FT_GlyphSlot    slot,
4487                             FT_Render_Mode  render_mode )
4488   {
4489     FT_Error     error = FT_Err_Ok;

4490     FT_Renderer  renderer;
4491 
4492 
<span class="line-removed">4493     /* if it is already a bitmap, no need to do anything */</span>
4494     switch ( slot-&gt;format )
4495     {
4496     case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don&#39;t do anything */
4497       break;
4498 
4499     default:









































































4500       {
4501         FT_ListNode  node = NULL;
4502 
4503 
4504         /* small shortcut for the very common case */
4505         if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
4506         {
4507           renderer = library-&gt;cur_renderer;
4508           node     = library-&gt;renderers.head;
4509         }
4510         else
4511           renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );
4512 
4513         error = FT_ERR( Unimplemented_Feature );
4514         while ( renderer )
4515         {
4516           error = renderer-&gt;render( renderer, slot, render_mode, NULL );
4517           if ( !error                                   ||
4518                FT_ERR_NEQ( error, Cannot_Render_Glyph ) )
4519             break;
4520 
4521           /* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
4522           /* is unsupported by the current renderer for this glyph image */
4523           /* format.                                                     */
4524 
4525           /* now, look for another renderer that supports the same */
4526           /* format.                                               */
4527           renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );
4528         }
4529       }
4530     }
4531 
4532 #ifdef FT_DEBUG_LEVEL_TRACE
4533 
4534 #undef  FT_COMPONENT
<span class="line-modified">4535 #define FT_COMPONENT  trace_bitmap</span>
4536 
4537     /*
4538      * Computing the MD5 checksum is expensive, unnecessarily distorting a
4539      * possible profiling of FreeType if compiled with tracing support.  For
4540      * this reason, we execute the following code only if explicitly
4541      * requested.
4542      */
4543 
4544     /* we use FT_TRACE3 in this block */
<span class="line-modified">4545     if ( !error                             &amp;&amp;</span>
<span class="line-modified">4546          ft_trace_levels[trace_bitmap] &gt;= 3 &amp;&amp;</span>
<span class="line-modified">4547          slot-&gt;bitmap.buffer                )</span>
4548     {
4549       FT_Bitmap  bitmap;
4550       FT_Error   err;
4551 
4552 
4553       FT_Bitmap_Init( &amp;bitmap );
4554 
4555       /* we convert to a single bitmap format for computing the checksum */
4556       /* this also converts the bitmap flow to `down&#39; (i.e., pitch &gt; 0)  */
4557       err = FT_Bitmap_Convert( library, &amp;slot-&gt;bitmap, &amp;bitmap, 1 );
4558       if ( !err )
4559       {
4560         MD5_CTX        ctx;
4561         unsigned char  md5[16];
4562         unsigned long  coverage = 0;
4563         int            i, j;
4564         int            rows  = (int)bitmap.rows;
4565         int            pitch = bitmap.pitch;
4566 
4567 
<span class="line-modified">4568         FT_TRACE3(( &quot;FT_Render_Glyph: bitmap %dx%d, mode %d\n&quot;,</span>
<span class="line-modified">4569                     rows, pitch, slot-&gt;bitmap.pixel_mode ));</span>



4570 
4571         for ( i = 0; i &lt; rows; i++ )
4572           for ( j = 0; j &lt; pitch; j++ )
4573             coverage += bitmap.buffer[i * pitch + j];
4574 
4575         FT_TRACE3(( &quot;  Total coverage: %lu\n&quot;, coverage ));
4576 
4577         MD5_Init( &amp;ctx );
4578         if ( bitmap.buffer )
4579           MD5_Update( &amp;ctx, bitmap.buffer,
4580                       (unsigned long)rows * (unsigned long)pitch );
4581         MD5_Final( md5, &amp;ctx );
4582 
4583         FT_TRACE3(( &quot;  MD5 checksum: &quot; ));
4584         for ( i = 0; i &lt; 16; i++ )
4585           FT_TRACE3(( &quot;%02X&quot;, md5[i] ));
4586         FT_TRACE3(( &quot;\n&quot; ));
4587       }
4588 
4589       FT_Bitmap_Done( library, &amp;bitmap );
4590     }
4591 
4592     /*
4593      * Dump bitmap in Netpbm format (PBM or PGM).
4594      */
4595 
4596     /* we use FT_TRACE7 in this block */
<span class="line-modified">4597     if ( !error                             &amp;&amp;</span>
<span class="line-modified">4598          ft_trace_levels[trace_bitmap] &gt;= 7 &amp;&amp;</span>
<span class="line-removed">4599          slot-&gt;bitmap.rows  &lt; 128U          &amp;&amp;</span>
<span class="line-removed">4600          slot-&gt;bitmap.width &lt; 128U          &amp;&amp;</span>
<span class="line-removed">4601          slot-&gt;bitmap.buffer                )</span>
4602     {
<span class="line-modified">4603       int  rows  = (int)slot-&gt;bitmap.rows;</span>
<span class="line-modified">4604       int  width = (int)slot-&gt;bitmap.width;</span>
<span class="line-modified">4605       int  pitch =      slot-&gt;bitmap.pitch;</span>
<span class="line-modified">4606       int  i, j, m;</span>
<span class="line-modified">4607       unsigned char*  topleft = slot-&gt;bitmap.buffer;</span>



4608 
<span class="line-modified">4609       if ( pitch &lt; 0 )</span>
<span class="line-removed">4610         topleft -= pitch * ( rows - 1 );</span>
4611 
<span class="line-removed">4612       FT_TRACE7(( &quot;Netpbm image: start\n&quot; ));</span>
<span class="line-removed">4613       switch ( slot-&gt;bitmap.pixel_mode )</span>
<span class="line-removed">4614       {</span>
<span class="line-removed">4615       case FT_PIXEL_MODE_MONO:</span>
<span class="line-removed">4616         FT_TRACE7(( &quot;P1 %d %d\n&quot;, width, rows ));</span>
<span class="line-removed">4617         for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-removed">4618         {</span>
<span class="line-removed">4619           for ( j = 0; j &lt; width; )</span>
<span class="line-removed">4620             for ( m = 128; m &gt; 0 &amp;&amp; j &lt; width; m &gt;&gt;= 1, j++ )</span>
<span class="line-removed">4621               FT_TRACE7(( &quot; %d&quot;, ( topleft[i * pitch + j / 8] &amp; m ) != 0 ));</span>
<span class="line-removed">4622           FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-removed">4623         }</span>
<span class="line-removed">4624         break;</span>
4625 
<span class="line-modified">4626       default:</span>
<span class="line-modified">4627         FT_TRACE7(( &quot;P2 %d %d 255\n&quot;, width, rows ));</span>
<span class="line-modified">4628         for ( i = 0; i &lt; rows; i++ )</span>


4629         {
<span class="line-modified">4630           for ( j = 0; j &lt; width; j += 1 )</span>
<span class="line-modified">4631             FT_TRACE7(( &quot; %3u&quot;, topleft[i * pitch + j] ));</span>
<span class="line-modified">4632           FT_TRACE7(( &quot;\n&quot; ));</span>

















4633         }

4634       }
<span class="line-modified">4635       FT_TRACE7(( &quot;Netpbm image: end\n&quot; ));</span>

4636     }
4637 
4638 #undef  FT_COMPONENT
<span class="line-modified">4639 #define FT_COMPONENT  trace_objs</span>
4640 
4641 #endif /* FT_DEBUG_LEVEL_TRACE */
4642 
4643     return error;
4644   }
4645 
4646 
4647   /* documentation is in freetype.h */
4648 
4649   FT_EXPORT_DEF( FT_Error )
4650   FT_Render_Glyph( FT_GlyphSlot    slot,
4651                    FT_Render_Mode  render_mode )
4652   {
4653     FT_Library  library;
4654 
4655 
4656     if ( !slot || !slot-&gt;face )
4657       return FT_THROW( Invalid_Argument );
4658 
4659     library = FT_FACE_LIBRARY( slot-&gt;face );
4660 
4661     return FT_Render_Glyph_Internal( library, slot, render_mode );
4662   }
4663 
4664 
4665   /*************************************************************************/
4666   /*************************************************************************/
4667   /*************************************************************************/
4668   /****                                                                 ****/
4669   /****                                                                 ****/
4670   /****                         M O D U L E S                           ****/
4671   /****                                                                 ****/
4672   /****                                                                 ****/
4673   /*************************************************************************/
4674   /*************************************************************************/
4675   /*************************************************************************/
4676 
4677 
<span class="line-modified">4678   /*************************************************************************/</span>
<span class="line-modified">4679   /*                                                                       */</span>
<span class="line-modified">4680   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">4681   /*    Destroy_Module                                                     */</span>
<span class="line-modified">4682   /*                                                                       */</span>
<span class="line-modified">4683   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">4684   /*    Destroys a given module object.  For drivers, this also destroys   */</span>
<span class="line-modified">4685   /*    all child faces.                                                   */</span>
<span class="line-modified">4686   /*                                                                       */</span>
<span class="line-modified">4687   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">4688   /*    module :: A handle to the target driver object.                    */</span>
<span class="line-modified">4689   /*                                                                       */</span>
<span class="line-modified">4690   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">4691   /*    The driver _must_ be LOCKED!                                       */</span>
<span class="line-modified">4692   /*                                                                       */</span>

4693   static void
4694   Destroy_Module( FT_Module  module )
4695   {
4696     FT_Memory         memory  = module-&gt;memory;
4697     FT_Module_Class*  clazz   = module-&gt;clazz;
4698     FT_Library        library = module-&gt;library;
4699 
4700 
4701     if ( library &amp;&amp; library-&gt;auto_hinter == module )
4702       library-&gt;auto_hinter = NULL;
4703 
4704     /* if the module is a renderer */
4705     if ( FT_MODULE_IS_RENDERER( module ) )
4706       ft_remove_renderer( module );
4707 
4708     /* if the module is a font driver, add some steps */
4709     if ( FT_MODULE_IS_DRIVER( module ) )
4710       Destroy_Driver( FT_DRIVER( module ) );
4711 
4712     /* finalize the module object */
</pre>
<hr />
<pre>
5011     if ( !cur[0]-&gt;clazz-&gt;get_interface )
5012     {
5013       FT_ERROR(( &quot;%s: module `%s&#39; doesn&#39;t support properties\n&quot;,
5014                  func_name, module_name ));
5015       return FT_THROW( Unimplemented_Feature );
5016     }
5017 
5018     /* search property service */
5019     interface = cur[0]-&gt;clazz-&gt;get_interface( cur[0],
5020                                               FT_SERVICE_ID_PROPERTIES );
5021     if ( !interface )
5022     {
5023       FT_ERROR(( &quot;%s: module `%s&#39; doesn&#39;t support properties\n&quot;,
5024                  func_name, module_name ));
5025       return FT_THROW( Unimplemented_Feature );
5026     }
5027 
5028     service = (FT_Service_Properties)interface;
5029 
5030     if ( set )
<span class="line-modified">5031       missing_func = (FT_Bool)( !service-&gt;set_property );</span>
5032     else
<span class="line-modified">5033       missing_func = (FT_Bool)( !service-&gt;get_property );</span>
5034 
5035     if ( missing_func )
5036     {
5037       FT_ERROR(( &quot;%s: property service of module `%s&#39; is broken\n&quot;,
5038                  func_name, module_name ));
5039       return FT_THROW( Unimplemented_Feature );
5040     }
5041 
5042     return set ? service-&gt;set_property( cur[0],
5043                                         property_name,
5044                                         value,
5045                                         value_is_string )
5046                : service-&gt;get_property( cur[0],
5047                                         property_name,
5048                                         value );
5049   }
5050 
5051 
5052   /* documentation is in ftmodapi.h */
5053 
</pre>
<hr />
<pre>
5139                   FT_Library  *alibrary )
5140   {
5141     FT_Library  library = NULL;
5142     FT_Error    error;
5143 
5144 
5145     if ( !memory || !alibrary )
5146       return FT_THROW( Invalid_Argument );
5147 
5148 #ifdef FT_DEBUG_LEVEL_ERROR
5149     /* init debugging support */
5150     ft_debug_init();
5151 #endif
5152 
5153     /* first of all, allocate the library object */
5154     if ( FT_NEW( library ) )
5155       return error;
5156 
5157     library-&gt;memory = memory;
5158 
<span class="line-removed">5159 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">5160     /* initialize position independent code containers */</span>
<span class="line-removed">5161     error = ft_pic_container_init( library );</span>
<span class="line-removed">5162     if ( error )</span>
<span class="line-removed">5163       goto Fail;</span>
<span class="line-removed">5164 #endif</span>
<span class="line-removed">5165 </span>
5166     library-&gt;version_major = FREETYPE_MAJOR;
5167     library-&gt;version_minor = FREETYPE_MINOR;
5168     library-&gt;version_patch = FREETYPE_PATCH;
5169 
5170     library-&gt;refcount = 1;
5171 
5172     /* That&#39;s ok now */
5173     *alibrary = library;
5174 
5175     return FT_Err_Ok;
<span class="line-removed">5176 </span>
<span class="line-removed">5177 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">5178   Fail:</span>
<span class="line-removed">5179     ft_pic_container_destroy( library );</span>
<span class="line-removed">5180     FT_FREE( library );</span>
<span class="line-removed">5181     return error;</span>
<span class="line-removed">5182 #endif</span>
5183   }
5184 
5185 
5186   /* documentation is in freetype.h */
5187 
5188   FT_EXPORT_DEF( void )
5189   FT_Library_Version( FT_Library   library,
5190                       FT_Int      *amajor,
5191                       FT_Int      *aminor,
5192                       FT_Int      *apatch )
5193   {
5194     FT_Int  major = 0;
5195     FT_Int  minor = 0;
5196     FT_Int  patch = 0;
5197 
5198 
5199     if ( library )
5200     {
5201       major = library-&gt;version_major;
5202       minor = library-&gt;version_minor;
</pre>
<hr />
<pre>
5220   FT_Done_Library( FT_Library  library )
5221   {
5222     FT_Memory  memory;
5223 
5224 
5225     if ( !library )
5226       return FT_THROW( Invalid_Library_Handle );
5227 
5228     library-&gt;refcount--;
5229     if ( library-&gt;refcount &gt; 0 )
5230       goto Exit;
5231 
5232     memory = library-&gt;memory;
5233 
5234     /*
5235      * Close all faces in the library.  If we don&#39;t do this, we can have
5236      * some subtle memory leaks.
5237      *
5238      * Example:
5239      *
<span class="line-modified">5240      *  - the cff font driver uses the pshinter module in cff_size_done</span>
<span class="line-modified">5241      *  - if the pshinter module is destroyed before the cff font driver,</span>
<span class="line-modified">5242      *    opened FT_Face objects managed by the driver are not properly</span>
<span class="line-modified">5243      *    destroyed, resulting in a memory leak</span>
5244      *
5245      * Some faces are dependent on other faces, like Type42 faces that
5246      * depend on TrueType faces synthesized internally.
5247      *
5248      * The order of drivers should be specified in driver_name[].
5249      */
5250     {
5251       FT_UInt      m, n;
5252       const char*  driver_name[] = { &quot;type42&quot;, NULL };
5253 
5254 
5255       for ( m = 0;
5256             m &lt; sizeof ( driver_name ) / sizeof ( driver_name[0] );
5257             m++ )
5258       {
5259         for ( n = 0; n &lt; library-&gt;num_modules; n++ )
5260         {
5261           FT_Module    module      = library-&gt;modules[n];
5262           const char*  module_name = module-&gt;clazz-&gt;module_name;
5263           FT_List      faces;
</pre>
<hr />
<pre>
5293                         library-&gt;modules[library-&gt;num_modules - 1] );
5294 #else
5295     {
5296       FT_UInt  n;
5297 
5298 
5299       for ( n = 0; n &lt; library-&gt;num_modules; n++ )
5300       {
5301         FT_Module  module = library-&gt;modules[n];
5302 
5303 
5304         if ( module )
5305         {
5306           Destroy_Module( module );
5307           library-&gt;modules[n] = NULL;
5308         }
5309       }
5310     }
5311 #endif
5312 
<span class="line-removed">5313 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">5314     /* Destroy pic container contents */</span>
<span class="line-removed">5315     ft_pic_container_destroy( library );</span>
<span class="line-removed">5316 #endif</span>
<span class="line-removed">5317 </span>
5318     FT_FREE( library );
5319 
5320   Exit:
5321     return FT_Err_Ok;
5322   }
5323 
5324 
5325   /* documentation is in ftmodapi.h */
5326 
5327   FT_EXPORT_DEF( void )
5328   FT_Set_Debug_Hook( FT_Library         library,
5329                      FT_UInt            hook_index,
5330                      FT_DebugHook_Func  debug_hook )
5331   {
5332     if ( library &amp;&amp; debug_hook &amp;&amp;
5333          hook_index &lt;
5334            ( sizeof ( library-&gt;debug_hooks ) / sizeof ( void* ) ) )
5335       library-&gt;debug_hooks[hook_index] = debug_hook;
5336   }
5337 
</pre>
<hr />
<pre>
5385          glyph-&gt;subglyphs                           &amp;&amp;
5386          glyph-&gt;format == FT_GLYPH_FORMAT_COMPOSITE &amp;&amp;
5387          sub_index &lt; glyph-&gt;num_subglyphs           )
5388     {
5389       FT_SubGlyph  subg = glyph-&gt;subglyphs + sub_index;
5390 
5391 
5392       *p_index     = subg-&gt;index;
5393       *p_flags     = subg-&gt;flags;
5394       *p_arg1      = subg-&gt;arg1;
5395       *p_arg2      = subg-&gt;arg2;
5396       *p_transform = subg-&gt;transform;
5397 
5398       error = FT_Err_Ok;
5399     }
5400 
5401     return error;
5402   }
5403 
5404 





































5405 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ftobjs.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   The FreeType private base classes (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_LIST_H
  21 #include FT_OUTLINE_H
  22 #include FT_FONT_FORMATS_H
  23 
  24 #include FT_INTERNAL_VALIDATE_H
  25 #include FT_INTERNAL_OBJECTS_H
  26 #include FT_INTERNAL_DEBUG_H
  27 #include FT_INTERNAL_RFORK_H
  28 #include FT_INTERNAL_STREAM_H
  29 #include FT_INTERNAL_SFNT_H            /* for SFNT_Load_Table_Func */
  30 #include FT_INTERNAL_POSTSCRIPT_AUX_H  /* for PS_Driver            */
  31 
  32 #include FT_TRUETYPE_TABLES_H
  33 #include FT_TRUETYPE_TAGS_H
  34 #include FT_TRUETYPE_IDS_H
  35 
  36 #include FT_SERVICE_PROPERTIES_H
</pre>
<hr />
<pre>
  62 #endif /* _MSC_VER */
  63 
  64   /* It&#39;s easiest to include `md5.c&#39; directly.  However, since OpenSSL */
  65   /* also provides the same functions, there might be conflicts if     */
  66   /* both FreeType and OpenSSL are built as static libraries.  For     */
  67   /* this reason, we put the MD5 stuff into the `FT_&#39; namespace.       */
  68 #define MD5_u32plus  FT_MD5_u32plus
  69 #define MD5_CTX      FT_MD5_CTX
  70 #define MD5_Init     FT_MD5_Init
  71 #define MD5_Update   FT_MD5_Update
  72 #define MD5_Final    FT_MD5_Final
  73 
  74 #undef  HAVE_OPENSSL
  75 
  76 #include &quot;md5.c&quot;
  77 
  78 #if defined( _MSC_VER )
  79 #pragma warning( pop )
  80 #endif
  81 
<span class="line-added">  82   static const char* const  pixel_modes[] =</span>
<span class="line-added">  83   {</span>
<span class="line-added">  84     &quot;none&quot;,</span>
<span class="line-added">  85     &quot;monochrome bitmap&quot;,</span>
<span class="line-added">  86     &quot;gray 8-bit bitmap&quot;,</span>
<span class="line-added">  87     &quot;gray 2-bit bitmap&quot;,</span>
<span class="line-added">  88     &quot;gray 4-bit bitmap&quot;,</span>
<span class="line-added">  89     &quot;LCD 8-bit bitmap&quot;,</span>
<span class="line-added">  90     &quot;vertical LCD 8-bit bitmap&quot;,</span>
<span class="line-added">  91     &quot;BGRA 32-bit color image bitmap&quot;</span>
<span class="line-added">  92   };</span>
<span class="line-added">  93 </span>
  94 #endif /* FT_DEBUG_LEVEL_TRACE */
  95 
  96 
  97 #define GRID_FIT_METRICS
  98 
  99 
 100   /* forward declaration */
 101   static FT_Error
 102   ft_open_face_internal( FT_Library           library,
 103                          const FT_Open_Args*  args,
 104                          FT_Long              face_index,
 105                          FT_Face             *aface,
 106                          FT_Bool              test_mac_fonts );
 107 
 108 
 109   FT_BASE_DEF( FT_Pointer )
 110   ft_service_list_lookup( FT_ServiceDesc  service_descriptors,
 111                           const char*     service_id )
 112   {
 113     FT_Pointer      result = NULL;
</pre>
<hr />
<pre>
 254   }
 255 
 256 
 257   FT_BASE_DEF( void )
 258   FT_Stream_Free( FT_Stream  stream,
 259                   FT_Int     external )
 260   {
 261     if ( stream )
 262     {
 263       FT_Memory  memory = stream-&gt;memory;
 264 
 265 
 266       FT_Stream_Close( stream );
 267 
 268       if ( !external )
 269         FT_FREE( stream );
 270     }
 271   }
 272 
 273 
<span class="line-modified"> 274   /**************************************************************************</span>
<span class="line-modified"> 275    *</span>
<span class="line-modified"> 276    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 277    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 278    * messages during execution.</span>
<span class="line-modified"> 279    */</span>
 280 #undef  FT_COMPONENT
<span class="line-modified"> 281 #define FT_COMPONENT  objs</span>
 282 
 283 
 284   /*************************************************************************/
 285   /*************************************************************************/
 286   /*************************************************************************/
 287   /****                                                                 ****/
 288   /****                                                                 ****/
 289   /****               FACE, SIZE &amp; GLYPH SLOT OBJECTS                   ****/
 290   /****                                                                 ****/
 291   /****                                                                 ****/
 292   /*************************************************************************/
 293   /*************************************************************************/
 294   /*************************************************************************/
 295 
 296 
 297   static FT_Error
 298   ft_glyphslot_init( FT_GlyphSlot  slot )
 299   {
 300     FT_Driver         driver   = slot-&gt;face-&gt;driver;
 301     FT_Driver_Class   clazz    = driver-&gt;clazz;
</pre>
<hr />
<pre>
 325   FT_BASE_DEF( void )
 326   ft_glyphslot_free_bitmap( FT_GlyphSlot  slot )
 327   {
 328     if ( slot-&gt;internal &amp;&amp; ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )
 329     {
 330       FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );
 331 
 332 
 333       FT_FREE( slot-&gt;bitmap.buffer );
 334       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
 335     }
 336     else
 337     {
 338       /* assume that the bitmap buffer was stolen or not */
 339       /* allocated from the heap                         */
 340       slot-&gt;bitmap.buffer = NULL;
 341     }
 342   }
 343 
 344 
<span class="line-modified"> 345   /* overflow-resistant presetting of bitmap position and dimensions; */</span>
<span class="line-added"> 346   /* also check whether the size is too large for rendering           */</span>
<span class="line-added"> 347   FT_BASE_DEF( FT_Bool )</span>
 348   ft_glyphslot_preset_bitmap( FT_GlyphSlot      slot,
 349                               FT_Render_Mode    mode,
 350                               const FT_Vector*  origin )
 351   {
 352     FT_Outline*  outline = &amp;slot-&gt;outline;
 353     FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
 354 
 355     FT_Pixel_Mode  pixel_mode;
 356 
<span class="line-modified"> 357     FT_BBox  cbox, pbox;</span>
 358     FT_Pos   x_shift = 0;
 359     FT_Pos   y_shift = 0;
 360     FT_Pos   x_left, y_top;
 361     FT_Pos   width, height, pitch;
 362 
 363 
<span class="line-modified"> 364     if ( slot-&gt;format != FT_GLYPH_FORMAT_OUTLINE )</span>
<span class="line-modified"> 365       return 1;</span>
 366 
 367     if ( origin )
 368     {
 369       x_shift = origin-&gt;x;
 370       y_shift = origin-&gt;y;
 371     }
 372 
 373     /* compute the control box, and grid-fit it, */
 374     /* taking into account the origin shift      */
 375     FT_Outline_Get_CBox( outline, &amp;cbox );
 376 
<span class="line-modified"> 377     /* rough estimate of pixel box */</span>
<span class="line-modified"> 378     pbox.xMin = ( cbox.xMin &gt;&gt; 6 ) + ( x_shift &gt;&gt; 6 );</span>
<span class="line-modified"> 379     pbox.yMin = ( cbox.yMin &gt;&gt; 6 ) + ( y_shift &gt;&gt; 6 );</span>
<span class="line-modified"> 380     pbox.xMax = ( cbox.xMax &gt;&gt; 6 ) + ( x_shift &gt;&gt; 6 );</span>
<span class="line-added"> 381     pbox.yMax = ( cbox.yMax &gt;&gt; 6 ) + ( y_shift &gt;&gt; 6 );</span>
<span class="line-added"> 382 </span>
<span class="line-added"> 383     /* tiny remainder box */</span>
<span class="line-added"> 384     cbox.xMin = ( cbox.xMin &amp; 63 ) + ( x_shift &amp; 63 );</span>
<span class="line-added"> 385     cbox.yMin = ( cbox.yMin &amp; 63 ) + ( y_shift &amp; 63 );</span>
<span class="line-added"> 386     cbox.xMax = ( cbox.xMax &amp; 63 ) + ( x_shift &amp; 63 );</span>
<span class="line-added"> 387     cbox.yMax = ( cbox.yMax &amp; 63 ) + ( y_shift &amp; 63 );</span>
 388 
 389     switch ( mode )
 390     {
 391     case FT_RENDER_MODE_MONO:
 392       pixel_mode = FT_PIXEL_MODE_MONO;
 393 #if 1
<span class="line-modified"> 394       /* x */</span>
<span class="line-modified"> 395 </span>
<span class="line-modified"> 396       /* undocumented but confirmed: bbox values get rounded;    */</span>
<span class="line-modified"> 397       /* we do asymmetric rounding so that the center of a pixel */</span>
<span class="line-modified"> 398       /* gets always included                                    */</span>
<span class="line-modified"> 399 </span>
<span class="line-modified"> 400       pbox.xMin += ( cbox.xMin + 31 ) &gt;&gt; 6;</span>
<span class="line-modified"> 401       pbox.xMax += ( cbox.xMax + 32 ) &gt;&gt; 6;</span>




 402 
<span class="line-modified"> 403       /* if the bbox collapsed, we add a pixel based on the total */</span>
<span class="line-added"> 404       /* rounding remainder to cover most of the original cbox    */</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406       if ( pbox.xMin == pbox.xMax )</span>
 407       {
<span class="line-modified"> 408         if ( ( ( cbox.xMin + 31 ) &amp; 63 ) - 31 +</span>
<span class="line-modified"> 409              ( ( cbox.xMax + 32 ) &amp; 63 ) - 32 &lt; 0 )</span>
<span class="line-added"> 410           pbox.xMin -= 1;</span>
<span class="line-added"> 411         else</span>
<span class="line-added"> 412           pbox.xMax += 1;</span>
 413       }
<span class="line-modified"> 414 </span>
<span class="line-added"> 415       /* y */</span>
<span class="line-added"> 416 </span>
<span class="line-added"> 417       pbox.yMin += ( cbox.yMin + 31 ) &gt;&gt; 6;</span>
<span class="line-added"> 418       pbox.yMax += ( cbox.yMax + 32 ) &gt;&gt; 6;</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420       if ( pbox.yMin == pbox.yMax )</span>
 421       {
<span class="line-modified"> 422         if ( ( ( cbox.yMin + 31 ) &amp; 63 ) - 31 +</span>
<span class="line-modified"> 423              ( ( cbox.yMax + 32 ) &amp; 63 ) - 32 &lt; 0 )</span>
<span class="line-added"> 424           pbox.yMin -= 1;</span>
<span class="line-added"> 425         else</span>
<span class="line-added"> 426           pbox.yMax += 1;</span>
 427       }
<span class="line-added"> 428 </span>
<span class="line-added"> 429       break;</span>
 430 #else
<span class="line-modified"> 431       goto Adjust;</span>



 432 #endif

 433 
 434     case FT_RENDER_MODE_LCD:
 435       pixel_mode = FT_PIXEL_MODE_LCD;
<span class="line-modified"> 436       ft_lcd_padding( &amp;cbox, slot, mode );</span>
<span class="line-modified"> 437       goto Adjust;</span>
 438 
 439     case FT_RENDER_MODE_LCD_V:
 440       pixel_mode = FT_PIXEL_MODE_LCD_V;
<span class="line-modified"> 441       ft_lcd_padding( &amp;cbox, slot, mode );</span>
<span class="line-modified"> 442       goto Adjust;</span>
 443 
 444     case FT_RENDER_MODE_NORMAL:
 445     case FT_RENDER_MODE_LIGHT:
 446     default:
 447       pixel_mode = FT_PIXEL_MODE_GRAY;
<span class="line-modified"> 448     Adjust:</span>
<span class="line-modified"> 449       pbox.xMin += cbox.xMin &gt;&gt; 6;</span>
<span class="line-modified"> 450       pbox.yMin += cbox.yMin &gt;&gt; 6;</span>
<span class="line-modified"> 451       pbox.xMax += ( cbox.xMax + 63 ) &gt;&gt; 6;</span>
<span class="line-modified"> 452       pbox.yMax += ( cbox.yMax + 63 ) &gt;&gt; 6;</span>
 453     }
 454 
<span class="line-modified"> 455     x_left = pbox.xMin;</span>
<span class="line-modified"> 456     y_top  = pbox.yMax;</span>
 457 
<span class="line-modified"> 458     width  = pbox.xMax - pbox.xMin;</span>
<span class="line-modified"> 459     height = pbox.yMax - pbox.yMin;</span>



 460 
 461     switch ( pixel_mode )
 462     {
 463     case FT_PIXEL_MODE_MONO:
 464       pitch = ( ( width + 15 ) &gt;&gt; 4 ) &lt;&lt; 1;
 465       break;
 466 
 467     case FT_PIXEL_MODE_LCD:
 468       width *= 3;
 469       pitch  = FT_PAD_CEIL( width, 4 );
 470       break;
 471 
 472     case FT_PIXEL_MODE_LCD_V:
 473       height *= 3;
 474       /* fall through */
 475 
 476     case FT_PIXEL_MODE_GRAY:
 477     default:
 478       pitch = width;
 479     }
 480 
 481     slot-&gt;bitmap_left = (FT_Int)x_left;
 482     slot-&gt;bitmap_top  = (FT_Int)y_top;
 483 
 484     bitmap-&gt;pixel_mode = (unsigned char)pixel_mode;
 485     bitmap-&gt;num_grays  = 256;
 486     bitmap-&gt;width      = (unsigned int)width;
 487     bitmap-&gt;rows       = (unsigned int)height;
 488     bitmap-&gt;pitch      = pitch;
<span class="line-added"> 489 </span>
<span class="line-added"> 490     if ( pbox.xMin &lt; -0x8000 || pbox.xMax &gt; 0x7FFF ||</span>
<span class="line-added"> 491          pbox.yMin &lt; -0x8000 || pbox.yMax &gt; 0x7FFF )</span>
<span class="line-added"> 492     {</span>
<span class="line-added"> 493       FT_TRACE3(( &quot;ft_glyphslot_preset_bitmap: [%ld %ld %ld %ld]\n&quot;,</span>
<span class="line-added"> 494                   pbox.xMin, pbox.yMin, pbox.xMax, pbox.yMax ));</span>
<span class="line-added"> 495       return 1;</span>
<span class="line-added"> 496     }</span>
<span class="line-added"> 497 </span>
<span class="line-added"> 498     return 0;</span>
 499   }
 500 
 501 
 502   FT_BASE_DEF( void )
 503   ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
 504                            FT_Byte*      buffer )
 505   {
 506     ft_glyphslot_free_bitmap( slot );
 507 
 508     slot-&gt;bitmap.buffer = buffer;
 509 
 510     FT_ASSERT( (slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP) == 0 );
 511   }
 512 
 513 
 514   FT_BASE_DEF( FT_Error )
 515   ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
 516                              FT_ULong      size )
 517   {
 518     FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );
</pre>
<hr />
<pre>
 827                     FT_LOAD_IGNORE_TRANSFORM;
 828 
 829     if ( load_flags &amp; FT_LOAD_NO_SCALE )
 830     {
 831       load_flags |= FT_LOAD_NO_HINTING |
 832                     FT_LOAD_NO_BITMAP;
 833 
 834       load_flags &amp;= ~FT_LOAD_RENDER;
 835     }
 836 
 837     if ( load_flags &amp; FT_LOAD_BITMAP_METRICS_ONLY )
 838       load_flags &amp;= ~FT_LOAD_RENDER;
 839 
 840     /*
 841      * Determine whether we need to auto-hint or not.
 842      * The general rules are:
 843      *
 844      * - Do only auto-hinting if we have
 845      *
 846      *   - a hinter module,
<span class="line-modified"> 847      *   - a scalable font,</span>
 848      *   - not a tricky font, and
 849      *   - no transforms except simple slants and/or rotations by
 850      *     integer multiples of 90 degrees.
 851      *
 852      * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don&#39;t
 853      *   have a native font hinter.
 854      *
 855      * - Otherwise, auto-hint for LIGHT hinting mode or if there isn&#39;t
 856      *   any hinting bytecode in the TrueType/OpenType font.
 857      *
 858      * - Exception: The font is `tricky&#39; and requires the native hinter to
 859      *   load properly.
 860      */
 861 
 862     if ( hinter                                           &amp;&amp;
 863          !( load_flags &amp; FT_LOAD_NO_HINTING )             &amp;&amp;
 864          !( load_flags &amp; FT_LOAD_NO_AUTOHINT )            &amp;&amp;
<span class="line-modified"> 865          FT_IS_SCALABLE( face )                           &amp;&amp;</span>

 866          !FT_IS_TRICKY( face )                            &amp;&amp;
 867          ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM )    ||
 868            ( face-&gt;internal-&gt;transform_matrix.yx == 0 &amp;&amp;
 869              face-&gt;internal-&gt;transform_matrix.xx != 0 ) ||
 870            ( face-&gt;internal-&gt;transform_matrix.xx == 0 &amp;&amp;
 871              face-&gt;internal-&gt;transform_matrix.yx != 0 ) ) )
 872     {
 873       if ( ( load_flags &amp; FT_LOAD_FORCE_AUTOHINT ) ||
 874            !FT_DRIVER_HAS_HINTER( driver )         )
 875         autohint = TRUE;
 876       else
 877       {
 878         FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
 879         FT_Bool         is_light_type1;
 880 
 881 
 882         /* only the new Adobe engine (for both CFF and Type 1) is `light&#39;; */
 883         /* we use `strstr&#39; to catch both `Type 1&#39; and `CID Type 1&#39;         */
 884         is_light_type1 =
<span class="line-modified"> 885           ft_strstr( FT_Get_Font_Format( face ), &quot;Type 1&quot; ) != NULL &amp;&amp;</span>
 886           ((PS_Driver)driver)-&gt;hinting_engine == FT_HINTING_ADOBE;
 887 
 888         /* the check for `num_locations&#39; assures that we actually    */
 889         /* test for instructions in a TTF and not in a CFF-based OTF */
 890         /*                                                           */
 891         /* since `maxSizeOfInstructions&#39; might be unreliable, we     */
 892         /* check the size of the `fpgm&#39; and `prep&#39; tables, too --    */
 893         /* the assumption is that there don&#39;t exist real TTFs where  */
 894         /* both `fpgm&#39; and `prep&#39; tables are missing                 */
 895         if ( ( mode == FT_RENDER_MODE_LIGHT           &amp;&amp;
 896                ( !FT_DRIVER_HINTS_LIGHTLY( driver ) &amp;&amp;
 897                  !is_light_type1                    ) )         ||
 898              ( FT_IS_SFNT( face )                             &amp;&amp;
 899                ttface-&gt;num_locations                          &amp;&amp;
 900                ttface-&gt;max_profile.maxSizeOfInstructions == 0 &amp;&amp;
 901                ttface-&gt;font_program_size == 0                 &amp;&amp;
 902                ttface-&gt;cvt_program_size == 0                  ) )
 903           autohint = TRUE;
 904       }
 905     }
</pre>
<hr />
<pre>
 945       }
 946     }
 947     else
 948     {
 949       error = driver-&gt;clazz-&gt;load_glyph( slot,
 950                                          face-&gt;size,
 951                                          glyph_index,
 952                                          load_flags );
 953       if ( error )
 954         goto Exit;
 955 
 956       if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
 957       {
 958         /* check that the loaded outline is correct */
 959         error = FT_Outline_Check( &amp;slot-&gt;outline );
 960         if ( error )
 961           goto Exit;
 962 
 963 #ifdef GRID_FIT_METRICS
 964         if ( !( load_flags &amp; FT_LOAD_NO_HINTING ) )
<span class="line-modified"> 965           ft_glyphslot_grid_fit_metrics(</span>
<span class="line-modified"> 966             slot,</span>
<span class="line-added"> 967             FT_BOOL( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT ) );</span>
 968 #endif
 969       }
 970     }
 971 
 972   Load_Ok:
 973     /* compute the advance */
 974     if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
 975     {
 976       slot-&gt;advance.x = 0;
 977       slot-&gt;advance.y = slot-&gt;metrics.vertAdvance;
 978     }
 979     else
 980     {
 981       slot-&gt;advance.x = slot-&gt;metrics.horiAdvance;
 982       slot-&gt;advance.y = 0;
 983     }
 984 
 985     /* compute the linear advance in 16.16 pixels */
 986     if ( ( load_flags &amp; FT_LOAD_LINEAR_DESIGN ) == 0 &amp;&amp;
 987          FT_IS_SCALABLE( face )                      )
</pre>
<hr />
<pre>
1015                                      &amp;internal-&gt;transform_matrix,
1016                                      &amp;internal-&gt;transform_delta );
1017         else if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
1018         {
1019           /* apply `standard&#39; transformation if no renderer is available */
1020           if ( internal-&gt;transform_flags &amp; 1 )
1021             FT_Outline_Transform( &amp;slot-&gt;outline,
1022                                   &amp;internal-&gt;transform_matrix );
1023 
1024           if ( internal-&gt;transform_flags &amp; 2 )
1025             FT_Outline_Translate( &amp;slot-&gt;outline,
1026                                   internal-&gt;transform_delta.x,
1027                                   internal-&gt;transform_delta.y );
1028         }
1029 
1030         /* transform advance */
1031         FT_Vector_Transform( &amp;slot-&gt;advance, &amp;internal-&gt;transform_matrix );
1032       }
1033     }
1034 
<span class="line-added">1035     slot-&gt;glyph_index          = glyph_index;</span>
<span class="line-added">1036     slot-&gt;internal-&gt;load_flags = load_flags;</span>
<span class="line-added">1037 </span>
1038     /* do we need to render the image or preset the bitmap now? */
1039     if ( !error                                    &amp;&amp;
1040          ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0    &amp;&amp;
1041          slot-&gt;format != FT_GLYPH_FORMAT_BITMAP    &amp;&amp;
1042          slot-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
1043     {
1044       FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
1045 
1046 
1047       if ( mode == FT_RENDER_MODE_NORMAL   &amp;&amp;
1048            load_flags &amp; FT_LOAD_MONOCHROME )
1049         mode = FT_RENDER_MODE_MONO;
1050 
1051       if ( load_flags &amp; FT_LOAD_RENDER )
1052         error = FT_Render_Glyph( slot, mode );
1053       else
1054         ft_glyphslot_preset_bitmap( slot, mode, NULL );
1055     }
1056 
<span class="line-modified">1057 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-modified">1058     FT_TRACE5(( &quot;FT_Load_Glyph: index %d, flags 0x%x\n&quot;,</span>
<span class="line-added">1059                 glyph_index, load_flags ));</span>
1060     FT_TRACE5(( &quot;  x advance: %f\n&quot;, slot-&gt;advance.x / 64.0 ));
1061     FT_TRACE5(( &quot;  y advance: %f\n&quot;, slot-&gt;advance.y / 64.0 ));
1062     FT_TRACE5(( &quot;  linear x advance: %f\n&quot;,
1063                 slot-&gt;linearHoriAdvance / 65536.0 ));
1064     FT_TRACE5(( &quot;  linear y advance: %f\n&quot;,
1065                 slot-&gt;linearVertAdvance / 65536.0 ));
<span class="line-modified">1066     FT_TRACE5(( &quot;  bitmap %dx%d, %s (mode %d)\n&quot;,</span>
<span class="line-modified">1067                 slot-&gt;bitmap.width,</span>
<span class="line-modified">1068                 slot-&gt;bitmap.rows,</span>
<span class="line-added">1069                 pixel_modes[slot-&gt;bitmap.pixel_mode],</span>
<span class="line-added">1070                 slot-&gt;bitmap.pixel_mode ));</span>
<span class="line-added">1071 #endif</span>
1072 
1073   Exit:
1074     return error;
1075   }
1076 
1077 
1078   /* documentation is in freetype.h */
1079 
1080   FT_EXPORT_DEF( FT_Error )
1081   FT_Load_Char( FT_Face   face,
1082                 FT_ULong  char_code,
1083                 FT_Int32  load_flags )
1084   {
1085     FT_UInt  glyph_index;
1086 
1087 
1088     if ( !face )
1089       return FT_THROW( Invalid_Face_Handle );
1090 
1091     glyph_index = (FT_UInt)char_code;
</pre>
<hr />
<pre>
1189 
1190     /* get rid of it */
1191     if ( face-&gt;internal )
1192     {
1193       FT_FREE( face-&gt;internal );
1194     }
1195     FT_FREE( face );
1196   }
1197 
1198 
1199   static void
1200   Destroy_Driver( FT_Driver  driver )
1201   {
1202     FT_List_Finalize( &amp;driver-&gt;faces_list,
1203                       (FT_List_Destructor)destroy_face,
1204                       driver-&gt;root.memory,
1205                       driver );
1206   }
1207 
1208 
<span class="line-modified">1209   /**************************************************************************</span>
<span class="line-modified">1210    *</span>
<span class="line-modified">1211    * @Function:</span>
<span class="line-modified">1212    *   find_unicode_charmap</span>
<span class="line-modified">1213    *</span>
<span class="line-modified">1214    * @Description:</span>
<span class="line-modified">1215    *   This function finds a Unicode charmap, if there is one.</span>
<span class="line-modified">1216    *   And if there is more than one, it tries to favour the more</span>
<span class="line-modified">1217    *   extensive one, i.e., one that supports UCS-4 against those which</span>
<span class="line-modified">1218    *   are limited to the BMP (said UCS-2 encoding.)</span>
<span class="line-modified">1219    *</span>
<span class="line-modified">1220    *   This function is called from open_face() (just below), and also</span>
<span class="line-modified">1221    *   from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).</span>
<span class="line-modified">1222    */</span>
1223   static FT_Error
1224   find_unicode_charmap( FT_Face  face )
1225   {
1226     FT_CharMap*  first;
1227     FT_CharMap*  cur;
1228 
1229 
1230     /* caller should have already checked that `face&#39; is valid */
1231     FT_ASSERT( face );
1232 
1233     first = face-&gt;charmaps;
1234 
1235     if ( !first )
1236       return FT_THROW( Invalid_CharMap_Handle );
1237 
1238     /*
<span class="line-modified">1239      * The original TrueType specification(s) only specified charmap</span>
<span class="line-modified">1240      * formats that are capable of mapping 8 or 16 bit character codes to</span>
<span class="line-modified">1241      * glyph indices.</span>
1242      *
<span class="line-modified">1243      * However, recent updates to the Apple and OpenType specifications</span>
<span class="line-modified">1244      * introduced new formats that are capable of mapping 32-bit character</span>
<span class="line-modified">1245      * codes as well.  And these are already used on some fonts, mainly to</span>
<span class="line-modified">1246      * map non-BMP Asian ideographs as defined in Unicode.</span>
1247      *
<span class="line-modified">1248      * For compatibility purposes, these fonts generally come with</span>
<span class="line-modified">1249      * *several* Unicode charmaps:</span>
1250      *
<span class="line-modified">1251      * - One of them in the &quot;old&quot; 16-bit format, that cannot access</span>
<span class="line-modified">1252      *   all glyphs in the font.</span>
1253      *
<span class="line-modified">1254      * - Another one in the &quot;new&quot; 32-bit format, that can access all</span>
<span class="line-modified">1255      *   the glyphs.</span>
1256      *
<span class="line-modified">1257      * This function has been written to always favor a 32-bit charmap</span>
<span class="line-modified">1258      * when found.  Otherwise, a 16-bit one is returned when found.</span>
1259      */
1260 
1261     /* Since the `interesting&#39; table, with IDs (3,10), is normally the */
1262     /* last one, we loop backwards.  This loses with type1 fonts with  */
1263     /* non-BMP characters (&lt;.0001%), this wins with .ttf with non-BMP  */
1264     /* chars (.01% ?), and this is the same about 99.99% of the time!  */
1265 
1266     cur = first + face-&gt;num_charmaps;  /* points after the last one */
1267 
1268     for ( ; --cur &gt;= first; )
1269     {
1270       if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )
1271       {
1272         /* XXX If some new encodings to represent UCS-4 are added, */
1273         /*     they should be added here.                          */
1274         if ( ( cur[0]-&gt;platform_id == TT_PLATFORM_MICROSOFT &amp;&amp;
1275                cur[0]-&gt;encoding_id == TT_MS_ID_UCS_4        )     ||
1276              ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE &amp;&amp;
1277                cur[0]-&gt;encoding_id == TT_APPLE_ID_UNICODE_32    ) )
1278         {
</pre>
<hr />
<pre>
1282       }
1283     }
1284 
1285     /* We do not have any UCS-4 charmap.                */
1286     /* Do the loop again and search for UCS-2 charmaps. */
1287     cur = first + face-&gt;num_charmaps;
1288 
1289     for ( ; --cur &gt;= first; )
1290     {
1291       if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )
1292       {
1293         face-&gt;charmap = cur[0];
1294         return FT_Err_Ok;
1295       }
1296     }
1297 
1298     return FT_THROW( Invalid_CharMap_Handle );
1299   }
1300 
1301 
<span class="line-modified">1302   /**************************************************************************</span>
<span class="line-modified">1303    *</span>
<span class="line-modified">1304    * @Function:</span>
<span class="line-modified">1305    *   find_variant_selector_charmap</span>
<span class="line-modified">1306    *</span>
<span class="line-modified">1307    * @Description:</span>
<span class="line-modified">1308    *   This function finds the variant selector charmap, if there is one.</span>
<span class="line-modified">1309    *   There can only be one (platform=0, specific=5, format=14).</span>
<span class="line-modified">1310    */</span>
1311   static FT_CharMap
1312   find_variant_selector_charmap( FT_Face  face )
1313   {
1314     FT_CharMap*  first;
1315     FT_CharMap*  end;
1316     FT_CharMap*  cur;
1317 
1318 
1319     /* caller should have already checked that `face&#39; is valid */
1320     FT_ASSERT( face );
1321 
1322     first = face-&gt;charmaps;
1323 
1324     if ( !first )
1325       return NULL;
1326 
1327     end = first + face-&gt;num_charmaps;  /* points after the last one */
1328 
1329     for ( cur = first; cur &lt; end; cur++ )
1330     {
1331       if ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE    &amp;&amp;
1332            cur[0]-&gt;encoding_id == TT_APPLE_ID_VARIANT_SELECTOR &amp;&amp;
1333            FT_Get_CMap_Format( cur[0] ) == 14                  )
1334         return cur[0];
1335     }
1336 
1337     return NULL;
1338   }
1339 
1340 
<span class="line-modified">1341   /**************************************************************************</span>
<span class="line-modified">1342    *</span>
<span class="line-modified">1343    * @Function:</span>
<span class="line-modified">1344    *   open_face</span>
<span class="line-modified">1345    *</span>
<span class="line-modified">1346    * @Description:</span>
<span class="line-modified">1347    *   This function does some work for FT_Open_Face().</span>
<span class="line-modified">1348    */</span>
1349   static FT_Error
1350   open_face( FT_Driver      driver,
1351              FT_Stream      *astream,
1352              FT_Bool        external_stream,
1353              FT_Long        face_index,
1354              FT_Int         num_params,
1355              FT_Parameter*  params,
1356              FT_Face       *aface )
1357   {
1358     FT_Memory         memory;
1359     FT_Driver_Class   clazz;
1360     FT_Face           face     = NULL;
1361     FT_Face_Internal  internal = NULL;
1362 
1363     FT_Error          error, error2;
1364 
1365 
1366     clazz  = driver-&gt;clazz;
1367     memory = driver-&gt;root.memory;
1368 
</pre>
<hr />
<pre>
2203              header[0x5A];
2204 #endif /* 0 */
2205     offset = 128 + ( ( dlen + 127 ) &amp; ~127 );
2206 
2207     return IsMacResource( library, stream, offset, face_index, aface );
2208 
2209   Exit:
2210     return error;
2211   }
2212 
2213 
2214   static FT_Error
2215   load_face_in_embedded_rfork( FT_Library           library,
2216                                FT_Stream            stream,
2217                                FT_Long              face_index,
2218                                FT_Face             *aface,
2219                                const FT_Open_Args  *args )
2220   {
2221 
2222 #undef  FT_COMPONENT
<span class="line-modified">2223 #define FT_COMPONENT  raccess</span>
2224 
2225     FT_Memory  memory = library-&gt;memory;
2226     FT_Error   error  = FT_ERR( Unknown_File_Format );
2227     FT_UInt    i;
2228 
<span class="line-modified">2229     char*      file_names[FT_RACCESS_N_RULES];</span>
2230     FT_Long    offsets[FT_RACCESS_N_RULES];
2231     FT_Error   errors[FT_RACCESS_N_RULES];
2232     FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */
2233 
2234     FT_Open_Args  args2;
2235     FT_Stream     stream2 = NULL;
2236 
2237 
2238     FT_Raccess_Guess( library, stream,
2239                       args-&gt;pathname, file_names, offsets, errors );
2240 
2241     for ( i = 0; i &lt; FT_RACCESS_N_RULES; i++ )
2242     {
2243       is_darwin_vfs = ft_raccess_rule_by_darwin_vfs( library, i );
2244       if ( is_darwin_vfs &amp;&amp; vfs_rfork_has_no_font )
2245       {
2246         FT_TRACE3(( &quot;Skip rule %d: darwin vfs resource fork&quot;
2247                     &quot; is already checked and&quot;
2248                     &quot; no font is found\n&quot;,
2249                     i ));
</pre>
<hr />
<pre>
2281 
2282       if ( !error )
2283           break;
2284       else if ( is_darwin_vfs )
2285           vfs_rfork_has_no_font = TRUE;
2286     }
2287 
2288     for (i = 0; i &lt; FT_RACCESS_N_RULES; i++)
2289     {
2290       if ( file_names[i] )
2291         FT_FREE( file_names[i] );
2292     }
2293 
2294     /* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
2295     if ( error )
2296       error = FT_ERR( Unknown_File_Format );
2297 
2298     return error;
2299 
2300 #undef  FT_COMPONENT
<span class="line-modified">2301 #define FT_COMPONENT  objs</span>
2302 
2303   }
2304 
2305 
2306   /* Check for some macintosh formats without Carbon framework.    */
2307   /* Is this a macbinary file?  If so look at the resource fork.   */
2308   /* Is this a mac dfont file?                                     */
2309   /* Is this an old style resource fork? (in data)                 */
2310   /* Else call load_face_in_embedded_rfork to try extra rules      */
2311   /* (defined in `ftrfork.c&#39;).                                     */
2312   /*                                                               */
2313   static FT_Error
2314   load_mac_face( FT_Library           library,
2315                  FT_Stream            stream,
2316                  FT_Long              face_index,
2317                  FT_Face             *aface,
2318                  const FT_Open_Args  *args )
2319   {
2320     FT_Error error;
2321     FT_UNUSED( args );
2322 
2323 
2324     error = IsMacBinary( library, stream, face_index, aface );
2325     if ( FT_ERR_EQ( error, Unknown_File_Format ) )
2326     {
2327 
2328 #undef  FT_COMPONENT
<span class="line-modified">2329 #define FT_COMPONENT  raccess</span>
2330 
2331 #ifdef FT_DEBUG_LEVEL_TRACE
2332       FT_TRACE3(( &quot;Try as dfont: &quot; ));
2333       if ( !( args-&gt;flags &amp; FT_OPEN_MEMORY ) )
2334         FT_TRACE3(( &quot;%s ...&quot;, args-&gt;pathname ));
2335 #endif
2336 
2337       error = IsMacResource( library, stream, 0, face_index, aface );
2338 
2339       FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot; : &quot;successful&quot; ));
2340 
2341 #undef  FT_COMPONENT
<span class="line-modified">2342 #define FT_COMPONENT  objs</span>
2343 
2344     }
2345 
2346     if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||
2347            FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &amp;&amp;
2348          ( args-&gt;flags &amp; FT_OPEN_PATHNAME )               )
2349       error = load_face_in_embedded_rfork( library, stream,
2350                                            face_index, aface, args );
2351     return error;
2352   }
2353 #endif
2354 
2355 #endif  /* !FT_MACINTOSH &amp;&amp; FT_CONFIG_OPTION_MAC_FONTS */
2356 
2357 
2358   /* documentation is in freetype.h */
2359 
2360   FT_EXPORT_DEF( FT_Error )
2361   FT_Open_Face( FT_Library           library,
2362                 const FT_Open_Args*  args,
</pre>
<hr />
<pre>
2720       return FT_THROW( Invalid_Face_Handle );
2721 
2722     driver = face-&gt;driver;
2723     if ( !driver )
2724       return FT_THROW( Invalid_Driver_Handle );
2725 
2726     error = FT_Stream_New( driver-&gt;root.library, parameters, &amp;stream );
2727     if ( error )
2728       goto Exit;
2729 
2730     /* we implement FT_Attach_Stream in each driver through the */
2731     /* `attach_file&#39; interface                                  */
2732 
2733     error = FT_ERR( Unimplemented_Feature );
2734     clazz = driver-&gt;clazz;
2735     if ( clazz-&gt;attach_file )
2736       error = clazz-&gt;attach_file( face, stream );
2737 
2738     /* close the attached stream */
2739     FT_Stream_Free( stream,
<span class="line-modified">2740                     FT_BOOL( parameters-&gt;stream                     &amp;&amp;</span>
<span class="line-modified">2741                              ( parameters-&gt;flags &amp; FT_OPEN_STREAM ) ) );</span>
2742 
2743   Exit:
2744     return error;
2745   }
2746 
2747 
2748   /* documentation is in freetype.h */
2749 
2750   FT_EXPORT_DEF( FT_Error )
2751   FT_Reference_Face( FT_Face  face )
2752   {
2753     if ( !face )
2754       return FT_THROW( Invalid_Face_Handle );
2755 
2756     face-&gt;internal-&gt;refcount++;
2757 
2758     return FT_Err_Ok;
2759   }
2760 
2761 
</pre>
<hr />
<pre>
3491                                 degree,
3492                                 akerning );
3493 
3494     return error;
3495   }
3496 
3497 
3498   /* documentation is in freetype.h */
3499 
3500   FT_EXPORT_DEF( FT_Error )
3501   FT_Select_Charmap( FT_Face      face,
3502                      FT_Encoding  encoding )
3503   {
3504     FT_CharMap*  cur;
3505     FT_CharMap*  limit;
3506 
3507 
3508     if ( !face )
3509       return FT_THROW( Invalid_Face_Handle );
3510 
<span class="line-modified">3511     /* FT_ENCODING_NONE is a valid encoding for BDF, PCF, and Windows FNT */</span>
<span class="line-added">3512     if ( encoding == FT_ENCODING_NONE &amp;&amp; !face-&gt;num_charmaps )</span>
3513       return FT_THROW( Invalid_Argument );
3514 
3515     /* FT_ENCODING_UNICODE is special.  We try to find the `best&#39; Unicode */
3516     /* charmap available, i.e., one with UCS-4 characters, if possible.   */
3517     /*                                                                    */
3518     /* This is done by find_unicode_charmap() above, to share code.       */
3519     if ( encoding == FT_ENCODING_UNICODE )
3520       return find_unicode_charmap( face );
3521 
3522     cur = face-&gt;charmaps;
3523     if ( !cur )
3524       return FT_THROW( Invalid_CharMap_Handle );
3525 
3526     limit = cur + face-&gt;num_charmaps;
3527 
3528     for ( ; cur &lt; limit; cur++ )
3529     {
3530       if ( cur[0]-&gt;encoding == encoding )
3531       {
3532         face-&gt;charmap = cur[0];
<span class="line-modified">3533         return FT_Err_Ok;</span>
3534       }
3535     }
3536 
3537     return FT_THROW( Invalid_Argument );
3538   }
3539 
3540 
3541   /* documentation is in freetype.h */
3542 
3543   FT_EXPORT_DEF( FT_Error )
3544   FT_Set_Charmap( FT_Face     face,
3545                   FT_CharMap  charmap )
3546   {
3547     FT_CharMap*  cur;
3548     FT_CharMap*  limit;
3549 
3550 
3551     if ( !face )
3552       return FT_THROW( Invalid_Face_Handle );
3553 
3554     cur = face-&gt;charmaps;
3555     if ( !cur || !charmap )
3556       return FT_THROW( Invalid_CharMap_Handle );
3557 



3558     limit = cur + face-&gt;num_charmaps;
3559 
3560     for ( ; cur &lt; limit; cur++ )
3561     {
<span class="line-modified">3562       if ( cur[0] == charmap                    &amp;&amp;</span>
<span class="line-added">3563            FT_Get_CMap_Format ( charmap ) != 14 )</span>
3564       {
3565         face-&gt;charmap = cur[0];
3566         return FT_Err_Ok;
3567       }
3568     }
3569 
3570     return FT_THROW( Invalid_Argument );
3571   }
3572 
3573 
3574   /* documentation is in freetype.h */
3575 
3576   FT_EXPORT_DEF( FT_Int )
3577   FT_Get_Charmap_Index( FT_CharMap  charmap )
3578   {
3579     FT_Int  i;
3580 
3581 
3582     if ( !charmap || !charmap-&gt;face )
3583       return -1;
</pre>
<hr />
<pre>
4042 
4043 
4044         if ( variantSelector &gt; 0xFFFFFFFFUL )
4045         {
4046           FT_TRACE1(( &quot;FT_Get_Char_Index: too large variantSelector&quot; ));
4047           FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, variantSelector ));
4048         }
4049 
4050         result = vcmap-&gt;clazz-&gt;variantchar_list( vcmap, memory,
4051                                                  (FT_UInt32)variantSelector );
4052       }
4053     }
4054 
4055     return result;
4056   }
4057 
4058 
4059   /* documentation is in freetype.h */
4060 
4061   FT_EXPORT_DEF( FT_UInt )
<span class="line-modified">4062   FT_Get_Name_Index( FT_Face           face,</span>
<span class="line-modified">4063                      const FT_String*  glyph_name )</span>
4064   {
4065     FT_UInt  result = 0;
4066 
4067 
4068     if ( face                       &amp;&amp;
4069          FT_HAS_GLYPH_NAMES( face ) &amp;&amp;
4070          glyph_name                 )
4071     {
4072       FT_Service_GlyphDict  service;
4073 
4074 
4075       FT_FACE_LOOKUP_SERVICE( face,
4076                               service,
4077                               GLYPH_DICT );
4078 
4079       if ( service &amp;&amp; service-&gt;name_index )
4080         result = service-&gt;name_index( face, glyph_name );
4081     }
4082 
4083     return result;
</pre>
<hr />
<pre>
4513 
4514     for ( ; num_params &gt; 0; num_params-- )
4515     {
4516       error = set_mode( renderer, parameters-&gt;tag, parameters-&gt;data );
4517       if ( error )
4518         break;
4519       parameters++;
4520     }
4521 
4522   Exit:
4523     return error;
4524   }
4525 
4526 
4527   FT_BASE_DEF( FT_Error )
4528   FT_Render_Glyph_Internal( FT_Library      library,
4529                             FT_GlyphSlot    slot,
4530                             FT_Render_Mode  render_mode )
4531   {
4532     FT_Error     error = FT_Err_Ok;
<span class="line-added">4533     FT_Face      face  = slot-&gt;face;</span>
4534     FT_Renderer  renderer;
4535 
4536 

4537     switch ( slot-&gt;format )
4538     {
4539     case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don&#39;t do anything */
4540       break;
4541 
4542     default:
<span class="line-added">4543       if ( slot-&gt;internal-&gt;load_flags &amp; FT_LOAD_COLOR )</span>
<span class="line-added">4544       {</span>
<span class="line-added">4545         FT_LayerIterator  iterator;</span>
<span class="line-added">4546 </span>
<span class="line-added">4547         FT_UInt  base_glyph = slot-&gt;glyph_index;</span>
<span class="line-added">4548 </span>
<span class="line-added">4549         FT_Bool  have_layers;</span>
<span class="line-added">4550         FT_UInt  glyph_index;</span>
<span class="line-added">4551         FT_UInt  color_index;</span>
<span class="line-added">4552 </span>
<span class="line-added">4553 </span>
<span class="line-added">4554         /* check whether we have colored glyph layers */</span>
<span class="line-added">4555         iterator.p  = NULL;</span>
<span class="line-added">4556         have_layers = FT_Get_Color_Glyph_Layer( face,</span>
<span class="line-added">4557                                                 base_glyph,</span>
<span class="line-added">4558                                                 &amp;glyph_index,</span>
<span class="line-added">4559                                                 &amp;color_index,</span>
<span class="line-added">4560                                                 &amp;iterator );</span>
<span class="line-added">4561         if ( have_layers )</span>
<span class="line-added">4562         {</span>
<span class="line-added">4563           error = FT_New_GlyphSlot( face, NULL );</span>
<span class="line-added">4564           if ( !error )</span>
<span class="line-added">4565           {</span>
<span class="line-added">4566             TT_Face       ttface = (TT_Face)face;</span>
<span class="line-added">4567             SFNT_Service  sfnt   = (SFNT_Service)ttface-&gt;sfnt;</span>
<span class="line-added">4568 </span>
<span class="line-added">4569 </span>
<span class="line-added">4570             do</span>
<span class="line-added">4571             {</span>
<span class="line-added">4572               FT_Int32  load_flags = slot-&gt;internal-&gt;load_flags;</span>
<span class="line-added">4573 </span>
<span class="line-added">4574 </span>
<span class="line-added">4575               /* disable the `FT_LOAD_COLOR&#39; flag to avoid recursion */</span>
<span class="line-added">4576               /* right here in this function                         */</span>
<span class="line-added">4577               load_flags &amp;= ~FT_LOAD_COLOR;</span>
<span class="line-added">4578 </span>
<span class="line-added">4579               /* render into the new `face-&gt;glyph&#39; glyph slot */</span>
<span class="line-added">4580               load_flags |= FT_LOAD_RENDER;</span>
<span class="line-added">4581 </span>
<span class="line-added">4582               error = FT_Load_Glyph( face, glyph_index, load_flags );</span>
<span class="line-added">4583               if ( error )</span>
<span class="line-added">4584                 break;</span>
<span class="line-added">4585 </span>
<span class="line-added">4586               /* blend new `face-&gt;glyph&#39; into old `slot&#39;; */</span>
<span class="line-added">4587               /* at the first call, `slot&#39; is still empty */</span>
<span class="line-added">4588               error = sfnt-&gt;colr_blend( ttface,</span>
<span class="line-added">4589                                         color_index,</span>
<span class="line-added">4590                                         slot,</span>
<span class="line-added">4591                                         face-&gt;glyph );</span>
<span class="line-added">4592               if ( error )</span>
<span class="line-added">4593                 break;</span>
<span class="line-added">4594 </span>
<span class="line-added">4595             } while ( FT_Get_Color_Glyph_Layer( face,</span>
<span class="line-added">4596                                                 base_glyph,</span>
<span class="line-added">4597                                                 &amp;glyph_index,</span>
<span class="line-added">4598                                                 &amp;color_index,</span>
<span class="line-added">4599                                                 &amp;iterator ) );</span>
<span class="line-added">4600 </span>
<span class="line-added">4601             if ( !error )</span>
<span class="line-added">4602               slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;</span>
<span class="line-added">4603 </span>
<span class="line-added">4604             /* this call also restores `slot&#39; as the glyph slot */</span>
<span class="line-added">4605             FT_Done_GlyphSlot( face-&gt;glyph );</span>
<span class="line-added">4606           }</span>
<span class="line-added">4607 </span>
<span class="line-added">4608           if ( !error )</span>
<span class="line-added">4609             return error;</span>
<span class="line-added">4610 </span>
<span class="line-added">4611           /* Failed to do the colored layer.  Draw outline instead. */</span>
<span class="line-added">4612           slot-&gt;format = FT_GLYPH_FORMAT_OUTLINE;</span>
<span class="line-added">4613         }</span>
<span class="line-added">4614       }</span>
<span class="line-added">4615 </span>
4616       {
4617         FT_ListNode  node = NULL;
4618 
4619 
4620         /* small shortcut for the very common case */
4621         if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )
4622         {
4623           renderer = library-&gt;cur_renderer;
4624           node     = library-&gt;renderers.head;
4625         }
4626         else
4627           renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );
4628 
4629         error = FT_ERR( Unimplemented_Feature );
4630         while ( renderer )
4631         {
4632           error = renderer-&gt;render( renderer, slot, render_mode, NULL );
4633           if ( !error                                   ||
4634                FT_ERR_NEQ( error, Cannot_Render_Glyph ) )
4635             break;
4636 
4637           /* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
4638           /* is unsupported by the current renderer for this glyph image */
4639           /* format.                                                     */
4640 
4641           /* now, look for another renderer that supports the same */
4642           /* format.                                               */
4643           renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );
4644         }
4645       }
4646     }
4647 
4648 #ifdef FT_DEBUG_LEVEL_TRACE
4649 
4650 #undef  FT_COMPONENT
<span class="line-modified">4651 #define FT_COMPONENT  checksum</span>
4652 
4653     /*
4654      * Computing the MD5 checksum is expensive, unnecessarily distorting a
4655      * possible profiling of FreeType if compiled with tracing support.  For
4656      * this reason, we execute the following code only if explicitly
4657      * requested.
4658      */
4659 
4660     /* we use FT_TRACE3 in this block */
<span class="line-modified">4661     if ( !error                               &amp;&amp;</span>
<span class="line-modified">4662          ft_trace_levels[trace_checksum] &gt;= 3 &amp;&amp;</span>
<span class="line-modified">4663          slot-&gt;bitmap.buffer                  )</span>
4664     {
4665       FT_Bitmap  bitmap;
4666       FT_Error   err;
4667 
4668 
4669       FT_Bitmap_Init( &amp;bitmap );
4670 
4671       /* we convert to a single bitmap format for computing the checksum */
4672       /* this also converts the bitmap flow to `down&#39; (i.e., pitch &gt; 0)  */
4673       err = FT_Bitmap_Convert( library, &amp;slot-&gt;bitmap, &amp;bitmap, 1 );
4674       if ( !err )
4675       {
4676         MD5_CTX        ctx;
4677         unsigned char  md5[16];
4678         unsigned long  coverage = 0;
4679         int            i, j;
4680         int            rows  = (int)bitmap.rows;
4681         int            pitch = bitmap.pitch;
4682 
4683 
<span class="line-modified">4684         FT_TRACE3(( &quot;FT_Render_Glyph: bitmap %dx%d, %s (mode %d)\n&quot;,</span>
<span class="line-modified">4685                     pitch,</span>
<span class="line-added">4686                     rows,</span>
<span class="line-added">4687                     pixel_modes[slot-&gt;bitmap.pixel_mode],</span>
<span class="line-added">4688                     slot-&gt;bitmap.pixel_mode ));</span>
4689 
4690         for ( i = 0; i &lt; rows; i++ )
4691           for ( j = 0; j &lt; pitch; j++ )
4692             coverage += bitmap.buffer[i * pitch + j];
4693 
4694         FT_TRACE3(( &quot;  Total coverage: %lu\n&quot;, coverage ));
4695 
4696         MD5_Init( &amp;ctx );
4697         if ( bitmap.buffer )
4698           MD5_Update( &amp;ctx, bitmap.buffer,
4699                       (unsigned long)rows * (unsigned long)pitch );
4700         MD5_Final( md5, &amp;ctx );
4701 
4702         FT_TRACE3(( &quot;  MD5 checksum: &quot; ));
4703         for ( i = 0; i &lt; 16; i++ )
4704           FT_TRACE3(( &quot;%02X&quot;, md5[i] ));
4705         FT_TRACE3(( &quot;\n&quot; ));
4706       }
4707 
4708       FT_Bitmap_Done( library, &amp;bitmap );
4709     }
4710 
4711     /*
4712      * Dump bitmap in Netpbm format (PBM or PGM).
4713      */
4714 
4715     /* we use FT_TRACE7 in this block */
<span class="line-modified">4716     if ( !error                               &amp;&amp;</span>
<span class="line-modified">4717          ft_trace_levels[trace_checksum] &gt;= 7 )</span>



4718     {
<span class="line-modified">4719       if ( slot-&gt;bitmap.rows  &lt; 128U &amp;&amp;</span>
<span class="line-modified">4720            slot-&gt;bitmap.width &lt; 128U &amp;&amp;</span>
<span class="line-modified">4721            slot-&gt;bitmap.buffer       )</span>
<span class="line-modified">4722       {</span>
<span class="line-modified">4723         int  rows  = (int)slot-&gt;bitmap.rows;</span>
<span class="line-added">4724         int  width = (int)slot-&gt;bitmap.width;</span>
<span class="line-added">4725         int  pitch =      slot-&gt;bitmap.pitch;</span>
<span class="line-added">4726         int  i, j, m;</span>
4727 
<span class="line-modified">4728         unsigned char*  topleft = slot-&gt;bitmap.buffer;</span>

4729 













4730 
<span class="line-modified">4731         if ( pitch &lt; 0 )</span>
<span class="line-modified">4732           topleft -= pitch * ( rows - 1 );</span>
<span class="line-modified">4733 </span>
<span class="line-added">4734         FT_TRACE7(( &quot;Netpbm image: start\n&quot; ));</span>
<span class="line-added">4735         switch ( slot-&gt;bitmap.pixel_mode )</span>
4736         {
<span class="line-modified">4737         case FT_PIXEL_MODE_MONO:</span>
<span class="line-modified">4738           FT_TRACE7(( &quot;P1 %d %d\n&quot;, width, rows ));</span>
<span class="line-modified">4739           for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-added">4740           {</span>
<span class="line-added">4741             for ( j = 0; j &lt; width; )</span>
<span class="line-added">4742               for ( m = 128; m &gt; 0 &amp;&amp; j &lt; width; m &gt;&gt;= 1, j++ )</span>
<span class="line-added">4743                 FT_TRACE7(( &quot; %d&quot;,</span>
<span class="line-added">4744                             ( topleft[i * pitch + j / 8] &amp; m ) != 0 ));</span>
<span class="line-added">4745             FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-added">4746           }</span>
<span class="line-added">4747           break;</span>
<span class="line-added">4748 </span>
<span class="line-added">4749         default:</span>
<span class="line-added">4750           FT_TRACE7(( &quot;P2 %d %d 255\n&quot;, width, rows ));</span>
<span class="line-added">4751           for ( i = 0; i &lt; rows; i++ )</span>
<span class="line-added">4752           {</span>
<span class="line-added">4753             for ( j = 0; j &lt; width; j += 1 )</span>
<span class="line-added">4754               FT_TRACE7(( &quot; %3u&quot;, topleft[i * pitch + j] ));</span>
<span class="line-added">4755             FT_TRACE7(( &quot;\n&quot; ));</span>
<span class="line-added">4756           }</span>
4757         }
<span class="line-added">4758         FT_TRACE7(( &quot;Netpbm image: end\n&quot; ));</span>
4759       }
<span class="line-modified">4760       else</span>
<span class="line-added">4761         FT_TRACE7(( &quot;Netpbm image: too large, omitted\n&quot; ));</span>
4762     }
4763 
4764 #undef  FT_COMPONENT
<span class="line-modified">4765 #define FT_COMPONENT  objs</span>
4766 
4767 #endif /* FT_DEBUG_LEVEL_TRACE */
4768 
4769     return error;
4770   }
4771 
4772 
4773   /* documentation is in freetype.h */
4774 
4775   FT_EXPORT_DEF( FT_Error )
4776   FT_Render_Glyph( FT_GlyphSlot    slot,
4777                    FT_Render_Mode  render_mode )
4778   {
4779     FT_Library  library;
4780 
4781 
4782     if ( !slot || !slot-&gt;face )
4783       return FT_THROW( Invalid_Argument );
4784 
4785     library = FT_FACE_LIBRARY( slot-&gt;face );
4786 
4787     return FT_Render_Glyph_Internal( library, slot, render_mode );
4788   }
4789 
4790 
4791   /*************************************************************************/
4792   /*************************************************************************/
4793   /*************************************************************************/
4794   /****                                                                 ****/
4795   /****                                                                 ****/
4796   /****                         M O D U L E S                           ****/
4797   /****                                                                 ****/
4798   /****                                                                 ****/
4799   /*************************************************************************/
4800   /*************************************************************************/
4801   /*************************************************************************/
4802 
4803 
<span class="line-modified">4804   /**************************************************************************</span>
<span class="line-modified">4805    *</span>
<span class="line-modified">4806    * @Function:</span>
<span class="line-modified">4807    *   Destroy_Module</span>
<span class="line-modified">4808    *</span>
<span class="line-modified">4809    * @Description:</span>
<span class="line-modified">4810    *   Destroys a given module object.  For drivers, this also destroys</span>
<span class="line-modified">4811    *   all child faces.</span>
<span class="line-modified">4812    *</span>
<span class="line-modified">4813    * @InOut:</span>
<span class="line-modified">4814    *   module ::</span>
<span class="line-modified">4815    *     A handle to the target driver object.</span>
<span class="line-modified">4816    *</span>
<span class="line-modified">4817    * @Note:</span>
<span class="line-modified">4818    *   The driver _must_ be LOCKED!</span>
<span class="line-added">4819    */</span>
4820   static void
4821   Destroy_Module( FT_Module  module )
4822   {
4823     FT_Memory         memory  = module-&gt;memory;
4824     FT_Module_Class*  clazz   = module-&gt;clazz;
4825     FT_Library        library = module-&gt;library;
4826 
4827 
4828     if ( library &amp;&amp; library-&gt;auto_hinter == module )
4829       library-&gt;auto_hinter = NULL;
4830 
4831     /* if the module is a renderer */
4832     if ( FT_MODULE_IS_RENDERER( module ) )
4833       ft_remove_renderer( module );
4834 
4835     /* if the module is a font driver, add some steps */
4836     if ( FT_MODULE_IS_DRIVER( module ) )
4837       Destroy_Driver( FT_DRIVER( module ) );
4838 
4839     /* finalize the module object */
</pre>
<hr />
<pre>
5138     if ( !cur[0]-&gt;clazz-&gt;get_interface )
5139     {
5140       FT_ERROR(( &quot;%s: module `%s&#39; doesn&#39;t support properties\n&quot;,
5141                  func_name, module_name ));
5142       return FT_THROW( Unimplemented_Feature );
5143     }
5144 
5145     /* search property service */
5146     interface = cur[0]-&gt;clazz-&gt;get_interface( cur[0],
5147                                               FT_SERVICE_ID_PROPERTIES );
5148     if ( !interface )
5149     {
5150       FT_ERROR(( &quot;%s: module `%s&#39; doesn&#39;t support properties\n&quot;,
5151                  func_name, module_name ));
5152       return FT_THROW( Unimplemented_Feature );
5153     }
5154 
5155     service = (FT_Service_Properties)interface;
5156 
5157     if ( set )
<span class="line-modified">5158       missing_func = FT_BOOL( !service-&gt;set_property );</span>
5159     else
<span class="line-modified">5160       missing_func = FT_BOOL( !service-&gt;get_property );</span>
5161 
5162     if ( missing_func )
5163     {
5164       FT_ERROR(( &quot;%s: property service of module `%s&#39; is broken\n&quot;,
5165                  func_name, module_name ));
5166       return FT_THROW( Unimplemented_Feature );
5167     }
5168 
5169     return set ? service-&gt;set_property( cur[0],
5170                                         property_name,
5171                                         value,
5172                                         value_is_string )
5173                : service-&gt;get_property( cur[0],
5174                                         property_name,
5175                                         value );
5176   }
5177 
5178 
5179   /* documentation is in ftmodapi.h */
5180 
</pre>
<hr />
<pre>
5266                   FT_Library  *alibrary )
5267   {
5268     FT_Library  library = NULL;
5269     FT_Error    error;
5270 
5271 
5272     if ( !memory || !alibrary )
5273       return FT_THROW( Invalid_Argument );
5274 
5275 #ifdef FT_DEBUG_LEVEL_ERROR
5276     /* init debugging support */
5277     ft_debug_init();
5278 #endif
5279 
5280     /* first of all, allocate the library object */
5281     if ( FT_NEW( library ) )
5282       return error;
5283 
5284     library-&gt;memory = memory;
5285 







5286     library-&gt;version_major = FREETYPE_MAJOR;
5287     library-&gt;version_minor = FREETYPE_MINOR;
5288     library-&gt;version_patch = FREETYPE_PATCH;
5289 
5290     library-&gt;refcount = 1;
5291 
5292     /* That&#39;s ok now */
5293     *alibrary = library;
5294 
5295     return FT_Err_Ok;







5296   }
5297 
5298 
5299   /* documentation is in freetype.h */
5300 
5301   FT_EXPORT_DEF( void )
5302   FT_Library_Version( FT_Library   library,
5303                       FT_Int      *amajor,
5304                       FT_Int      *aminor,
5305                       FT_Int      *apatch )
5306   {
5307     FT_Int  major = 0;
5308     FT_Int  minor = 0;
5309     FT_Int  patch = 0;
5310 
5311 
5312     if ( library )
5313     {
5314       major = library-&gt;version_major;
5315       minor = library-&gt;version_minor;
</pre>
<hr />
<pre>
5333   FT_Done_Library( FT_Library  library )
5334   {
5335     FT_Memory  memory;
5336 
5337 
5338     if ( !library )
5339       return FT_THROW( Invalid_Library_Handle );
5340 
5341     library-&gt;refcount--;
5342     if ( library-&gt;refcount &gt; 0 )
5343       goto Exit;
5344 
5345     memory = library-&gt;memory;
5346 
5347     /*
5348      * Close all faces in the library.  If we don&#39;t do this, we can have
5349      * some subtle memory leaks.
5350      *
5351      * Example:
5352      *
<span class="line-modified">5353      * - the cff font driver uses the pshinter module in cff_size_done</span>
<span class="line-modified">5354      * - if the pshinter module is destroyed before the cff font driver,</span>
<span class="line-modified">5355      *   opened FT_Face objects managed by the driver are not properly</span>
<span class="line-modified">5356      *   destroyed, resulting in a memory leak</span>
5357      *
5358      * Some faces are dependent on other faces, like Type42 faces that
5359      * depend on TrueType faces synthesized internally.
5360      *
5361      * The order of drivers should be specified in driver_name[].
5362      */
5363     {
5364       FT_UInt      m, n;
5365       const char*  driver_name[] = { &quot;type42&quot;, NULL };
5366 
5367 
5368       for ( m = 0;
5369             m &lt; sizeof ( driver_name ) / sizeof ( driver_name[0] );
5370             m++ )
5371       {
5372         for ( n = 0; n &lt; library-&gt;num_modules; n++ )
5373         {
5374           FT_Module    module      = library-&gt;modules[n];
5375           const char*  module_name = module-&gt;clazz-&gt;module_name;
5376           FT_List      faces;
</pre>
<hr />
<pre>
5406                         library-&gt;modules[library-&gt;num_modules - 1] );
5407 #else
5408     {
5409       FT_UInt  n;
5410 
5411 
5412       for ( n = 0; n &lt; library-&gt;num_modules; n++ )
5413       {
5414         FT_Module  module = library-&gt;modules[n];
5415 
5416 
5417         if ( module )
5418         {
5419           Destroy_Module( module );
5420           library-&gt;modules[n] = NULL;
5421         }
5422       }
5423     }
5424 #endif
5425 





5426     FT_FREE( library );
5427 
5428   Exit:
5429     return FT_Err_Ok;
5430   }
5431 
5432 
5433   /* documentation is in ftmodapi.h */
5434 
5435   FT_EXPORT_DEF( void )
5436   FT_Set_Debug_Hook( FT_Library         library,
5437                      FT_UInt            hook_index,
5438                      FT_DebugHook_Func  debug_hook )
5439   {
5440     if ( library &amp;&amp; debug_hook &amp;&amp;
5441          hook_index &lt;
5442            ( sizeof ( library-&gt;debug_hooks ) / sizeof ( void* ) ) )
5443       library-&gt;debug_hooks[hook_index] = debug_hook;
5444   }
5445 
</pre>
<hr />
<pre>
5493          glyph-&gt;subglyphs                           &amp;&amp;
5494          glyph-&gt;format == FT_GLYPH_FORMAT_COMPOSITE &amp;&amp;
5495          sub_index &lt; glyph-&gt;num_subglyphs           )
5496     {
5497       FT_SubGlyph  subg = glyph-&gt;subglyphs + sub_index;
5498 
5499 
5500       *p_index     = subg-&gt;index;
5501       *p_flags     = subg-&gt;flags;
5502       *p_arg1      = subg-&gt;arg1;
5503       *p_arg2      = subg-&gt;arg2;
5504       *p_transform = subg-&gt;transform;
5505 
5506       error = FT_Err_Ok;
5507     }
5508 
5509     return error;
5510   }
5511 
5512 
<span class="line-added">5513   /* documentation is in freetype.h */</span>
<span class="line-added">5514 </span>
<span class="line-added">5515   FT_EXPORT_DEF( FT_Bool )</span>
<span class="line-added">5516   FT_Get_Color_Glyph_Layer( FT_Face            face,</span>
<span class="line-added">5517                             FT_UInt            base_glyph,</span>
<span class="line-added">5518                             FT_UInt           *aglyph_index,</span>
<span class="line-added">5519                             FT_UInt           *acolor_index,</span>
<span class="line-added">5520                             FT_LayerIterator*  iterator )</span>
<span class="line-added">5521   {</span>
<span class="line-added">5522     TT_Face       ttface;</span>
<span class="line-added">5523     SFNT_Service  sfnt;</span>
<span class="line-added">5524 </span>
<span class="line-added">5525 </span>
<span class="line-added">5526     if ( !face                                   ||</span>
<span class="line-added">5527          !aglyph_index                           ||</span>
<span class="line-added">5528          !acolor_index                           ||</span>
<span class="line-added">5529          !iterator                               ||</span>
<span class="line-added">5530          base_glyph &gt;= (FT_UInt)face-&gt;num_glyphs )</span>
<span class="line-added">5531       return 0;</span>
<span class="line-added">5532 </span>
<span class="line-added">5533     if ( !FT_IS_SFNT( face ) )</span>
<span class="line-added">5534       return 0;</span>
<span class="line-added">5535 </span>
<span class="line-added">5536     ttface = (TT_Face)face;</span>
<span class="line-added">5537     sfnt   = (SFNT_Service)ttface-&gt;sfnt;</span>
<span class="line-added">5538 </span>
<span class="line-added">5539     if ( sfnt-&gt;get_colr_layer )</span>
<span class="line-added">5540       return sfnt-&gt;get_colr_layer( ttface,</span>
<span class="line-added">5541                                    base_glyph,</span>
<span class="line-added">5542                                    aglyph_index,</span>
<span class="line-added">5543                                    acolor_index,</span>
<span class="line-added">5544                                    iterator );</span>
<span class="line-added">5545     else</span>
<span class="line-added">5546       return 0;</span>
<span class="line-added">5547   }</span>
<span class="line-added">5548 </span>
<span class="line-added">5549 </span>
5550 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="ftmm.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftoutln.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
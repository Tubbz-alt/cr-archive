<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afglobal.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,37 +1,37 @@</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  afhints.c                                                              */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*    Auto-fitter hinting routines (body).                                 */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  Copyright 2003-2018 by                                                 */</span>
<span class="udiff-line-modified-removed">- /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="udiff-line-modified-removed">- /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="udiff-line-modified-removed">- /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="udiff-line-modified-removed">- /*  this file you indicate that you have read the license and              */</span>
<span class="udiff-line-modified-removed">- /*  understand and accept it fully.                                        */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-added">+ /****************************************************************************</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * afhints.c</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  *   Auto-fitter hinting routines (body).</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2003-2019 by</span>
<span class="udiff-line-modified-added">+  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * This file is part of the FreeType project, and may only be used,</span>
<span class="udiff-line-modified-added">+  * modified, and distributed under the terms of the FreeType project</span>
<span class="udiff-line-modified-added">+  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="udiff-line-modified-added">+  * this file you indicate that you have read the license and</span>
<span class="udiff-line-modified-added">+  * understand and accept it fully.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  */</span>
  
  
  #include &quot;afhints.h&quot;
  #include &quot;aferrors.h&quot;
  #include FT_INTERNAL_CALC_H
  #include FT_INTERNAL_DEBUG_H
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="udiff-line-modified-removed">-   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="udiff-line-modified-removed">-   /* messages during execution.                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="udiff-line-modified-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="udiff-line-modified-added">+    * messages during execution.</span>
<span class="udiff-line-modified-added">+    */</span>
  #undef  FT_COMPONENT
<span class="udiff-line-modified-removed">- #define FT_COMPONENT  trace_afhints</span>
<span class="udiff-line-modified-added">+ #define FT_COMPONENT  afhints</span>
  
  
    /* Get new segment for given axis. */
  
    FT_LOCAL_DEF( FT_Error )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -295,10 +295,23 @@</span>
  
      return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
    }
  
  
<span class="udiff-line-added">+   static int</span>
<span class="udiff-line-added">+   af_get_strong_edge_index( AF_GlyphHints  hints,</span>
<span class="udiff-line-added">+                             AF_Edge*       strong_edges,</span>
<span class="udiff-line-added">+                             int            dimension )</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];</span>
<span class="udiff-line-added">+     AF_Edge       edges = axis-&gt;edges;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return AF_INDEX_NUM( strong_edges[dimension], edges );</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  #ifdef __cplusplus
    extern &quot;C&quot; {
  #endif
    void
    af_glyph_hints_dump_points( AF_GlyphHints  hints,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,12 +328,14 @@</span>
  
      if ( hints-&gt;num_points )
      {
        AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
               /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<span class="udiff-line-modified-removed">-                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit&quot; ));</span>
<span class="udiff-line-modified-added">+                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit &quot;</span>
               /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
<span class="udiff-line-added">+                 &quot;  hbef  haft  vbef  vaft&quot; ));</span>
<span class="udiff-line-added">+              /* &quot; XXXXX XXXXX XXXXX XXXXX&quot; */</span>
      }
      else
        AF_DUMP(( &quot;  (none)\n&quot; ));
  
      for ( point = points; point &lt; limit; point++ )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,21 +343,23 @@</span>
        int  point_idx     = AF_INDEX_NUM( point, points );
        int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
        int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
  
        char  buf1[16], buf2[16], buf3[16], buf4[16];
<span class="udiff-line-added">+       char  buf5[16], buf6[16], buf7[16], buf8[16];</span>
  
  
        /* insert extra newline at the beginning of a contour */
        if ( contour &lt; climit &amp;&amp; *contour == point )
        {
          AF_DUMP(( &quot;\n&quot; ));
          contour++;
        }
  
        AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<span class="udiff-line-modified-removed">-                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f\n&quot;,</span>
<span class="udiff-line-modified-added">+                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f&quot;</span>
<span class="udiff-line-added">+                 &quot; %5s %5s %5s %5s\n&quot;,</span>
                  point_idx,
                  af_print_idx( buf1,
                                af_get_edge_index( hints, segment_idx_1, 1 ) ),
                  af_print_idx( buf2, segment_idx_1 ),
                  af_print_idx( buf3,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -357,11 +374,24 @@</span>
                  point-&gt;fx,
                  point-&gt;fy,
                  point-&gt;ox / 64.0,
                  point-&gt;oy / 64.0,
                  point-&gt;x / 64.0,
<span class="udiff-line-modified-removed">-                 point-&gt;y / 64.0 ));</span>
<span class="udiff-line-modified-added">+                 point-&gt;y / 64.0,</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 af_print_idx( buf5, af_get_strong_edge_index( hints,</span>
<span class="udiff-line-added">+                                                               point-&gt;before,</span>
<span class="udiff-line-added">+                                                               1 ) ),</span>
<span class="udiff-line-added">+                 af_print_idx( buf6, af_get_strong_edge_index( hints,</span>
<span class="udiff-line-added">+                                                               point-&gt;after,</span>
<span class="udiff-line-added">+                                                               1 ) ),</span>
<span class="udiff-line-added">+                 af_print_idx( buf7, af_get_strong_edge_index( hints,</span>
<span class="udiff-line-added">+                                                               point-&gt;before,</span>
<span class="udiff-line-added">+                                                               0 ) ),</span>
<span class="udiff-line-added">+                 af_print_idx( buf8, af_get_strong_edge_index( hints,</span>
<span class="udiff-line-added">+                                                               point-&gt;after,</span>
<span class="udiff-line-added">+                                                               0 ) ) ));</span>
      }
      AF_DUMP(( &quot;\n&quot; ));
    }
  #ifdef __cplusplus
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -517,11 +547,11 @@</span>
  
      seg      = &amp;axis-&gt;segments[idx];
      *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
                                              : seg-&gt;first-&gt;fy;
      if ( seg-&gt;edge )
<span class="udiff-line-modified-removed">-       *is_blue = (FT_Bool)( seg-&gt;edge-&gt;blue_edge != 0 );</span>
<span class="udiff-line-modified-added">+       *is_blue = FT_BOOL( seg-&gt;edge-&gt;blue_edge );</span>
      else
        *is_blue = FALSE;
  
      if ( *is_blue )
        *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -556,12 +586,12 @@</span>
  
        char  buf1[16], buf2[16];
  
  
        /*
<span class="udiff-line-modified-removed">-        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="udiff-line-modified-removed">-        *        since they have a constant X coordinate.</span>
<span class="udiff-line-modified-added">+        * note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="udiff-line-modified-added">+        *       since they have a constant X coordinate.</span>
         */
        if ( dimension == AF_DIMENSION_HORZ )
          AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
                    &quot;vertical&quot;,
                    65536.0 * 64.0 / hints-&gt;x_scale,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -679,12 +709,12 @@</span>
        return;
  
      memory = hints-&gt;memory;
  
      /*
<span class="udiff-line-modified-removed">-      *  note that we don&#39;t need to free the segment and edge</span>
<span class="udiff-line-modified-removed">-      *  buffers since they are really within the hints-&gt;points array</span>
<span class="udiff-line-modified-added">+      * note that we don&#39;t need to free the segment and edge</span>
<span class="udiff-line-modified-added">+      * buffers since they are really within the hints-&gt;points array</span>
       */
      for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
      {
        AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -774,13 +804,13 @@</span>
  
        hints-&gt;max_contours = (FT_Int)new_max;
      }
  
      /*
<span class="udiff-line-modified-removed">-      *  then reallocate the points arrays if necessary --</span>
<span class="udiff-line-modified-removed">-      *  note that we reserve two additional point positions, used to</span>
<span class="udiff-line-modified-removed">-      *  hint metrics appropriately</span>
<span class="udiff-line-modified-added">+      * then reallocate the points arrays if necessary --</span>
<span class="udiff-line-modified-added">+      * note that we reserve two additional point positions, used to</span>
<span class="udiff-line-modified-added">+      * hint metrics appropriately</span>
       */
      new_max = (FT_UInt)( outline-&gt;n_points + 2 );
      old_max = (FT_UInt)hints-&gt;max_points;
  
      if ( new_max &lt;= AF_POINTS_EMBEDDED )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -896,10 +926,18 @@</span>
                endpoint = outline-&gt;contours[contour_index];
                end      = points + endpoint;
                prev     = end;
              }
            }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="udiff-line-added">+           point-&gt;before[0] = NULL;</span>
<span class="udiff-line-added">+           point-&gt;before[1] = NULL;</span>
<span class="udiff-line-added">+           point-&gt;after[0]  = NULL;</span>
<span class="udiff-line-added">+           point-&gt;after[1]  = NULL;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
          }
        }
  
        /* set up the contours array */
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -916,19 +954,19 @@</span>
          }
        }
  
        {
          /*
<span class="udiff-line-modified-removed">-          *  Compute directions of `in&#39; and `out&#39; vectors.</span>
<span class="udiff-line-modified-added">+          * Compute directions of `in&#39; and `out&#39; vectors.</span>
           *
<span class="udiff-line-modified-removed">-          *  Note that distances between points that are very near to each</span>
<span class="udiff-line-modified-removed">-          *  other are accumulated.  In other words, the auto-hinter either</span>
<span class="udiff-line-modified-removed">-          *  prepends the small vectors between near points to the first</span>
<span class="udiff-line-modified-removed">-          *  non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="udiff-line-modified-removed">-          *  threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="udiff-line-modified-removed">-          *  points are tagged as weak; the directions are adjusted also to</span>
<span class="udiff-line-modified-removed">-          *  be equal to the accumulated one.</span>
<span class="udiff-line-modified-added">+          * Note that distances between points that are very near to each</span>
<span class="udiff-line-modified-added">+          * other are accumulated.  In other words, the auto-hinter either</span>
<span class="udiff-line-modified-added">+          * prepends the small vectors between near points to the first</span>
<span class="udiff-line-modified-added">+          * non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="udiff-line-modified-added">+          * threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="udiff-line-modified-added">+          * points are tagged as weak; the directions are adjusted also to</span>
<span class="udiff-line-modified-added">+          * be equal to the accumulated one.</span>
           */
  
          FT_Int  near_limit2 = 2 * near_limit - 1;
  
          AF_Point*  contour;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -954,16 +992,16 @@</span>
            {
              out_x = point-&gt;fx - prev-&gt;fx;
              out_y = point-&gt;fy - prev-&gt;fy;
  
              /*
<span class="udiff-line-modified-removed">-              *  We use Taxicab metrics to measure the vector length.</span>
<span class="udiff-line-modified-added">+              * We use Taxicab metrics to measure the vector length.</span>
               *
<span class="udiff-line-modified-removed">-              *  Note that the accumulated distances so far could have the</span>
<span class="udiff-line-modified-removed">-              *  opposite direction of the distance measured here.  For this</span>
<span class="udiff-line-modified-removed">-              *  reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="udiff-line-modified-removed">-              *  non-near point even in the worst case.</span>
<span class="udiff-line-modified-added">+              * Note that the accumulated distances so far could have the</span>
<span class="udiff-line-modified-added">+              * opposite direction of the distance measured here.  For this</span>
<span class="udiff-line-modified-added">+              * reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="udiff-line-modified-added">+              * non-near point even in the worst case.</span>
               */
              if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
                break;
  
              point = prev;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -977,15 +1015,15 @@</span>
            /* `in&#39; and `out&#39; vector directions               */
  
            curr = first;
  
            /*
<span class="udiff-line-modified-removed">-            *  We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="udiff-line-modified-removed">-            *  next and previous non-near point, respectively.</span>
<span class="udiff-line-modified-added">+            * We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="udiff-line-modified-added">+            * next and previous non-near point, respectively.</span>
             *
<span class="udiff-line-modified-removed">-            *  To avoid problems with not having non-near points, we point to</span>
<span class="udiff-line-modified-removed">-            *  `first&#39; by default as the next non-near point.</span>
<span class="udiff-line-modified-added">+            * To avoid problems with not having non-near points, we point to</span>
<span class="udiff-line-modified-added">+            * `first&#39; by default as the next non-near point.</span>
             *
             */
            curr-&gt;u  = (FT_Pos)( first - curr );
            first-&gt;v = -curr-&gt;u;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1033,16 +1071,16 @@</span>
  
            } while ( next != first );
          }
  
          /*
<span class="udiff-line-modified-removed">-          *  The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="udiff-line-modified-removed">-          *  can identify local extrema more reliably: A series of</span>
<span class="udiff-line-modified-removed">-          *  non-horizontal or non-vertical vectors pointing into the same</span>
<span class="udiff-line-modified-removed">-          *  quadrant are handled as a single, long vector.  From a</span>
<span class="udiff-line-modified-removed">-          *  topological point of the view, the intermediate points are of no</span>
<span class="udiff-line-modified-removed">-          *  interest and thus tagged as weak.</span>
<span class="udiff-line-modified-added">+          * The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="udiff-line-modified-added">+          * can identify local extrema more reliably: A series of</span>
<span class="udiff-line-modified-added">+          * non-horizontal or non-vertical vectors pointing into the same</span>
<span class="udiff-line-modified-added">+          * quadrant are handled as a single, long vector.  From a</span>
<span class="udiff-line-modified-added">+          * topological point of the view, the intermediate points are of no</span>
<span class="udiff-line-modified-added">+          * interest and thus tagged as weak.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1078,13 +1116,13 @@</span>
              }
            }
          }
  
          /*
<span class="udiff-line-modified-removed">-          *  Finally, check for remaining weak points.  Everything else not</span>
<span class="udiff-line-modified-removed">-          *  collected in edges so far is then implicitly classified as strong</span>
<span class="udiff-line-modified-removed">-          *  points.</span>
<span class="udiff-line-modified-added">+          * Finally, check for remaining weak points.  Everything else not</span>
<span class="udiff-line-modified-added">+          * collected in edges so far is then implicitly classified as strong</span>
<span class="udiff-line-modified-added">+          * points.</span>
           */
  
          for ( point = points; point &lt; point_limit; point++ )
          {
            if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1307,19 +1345,31 @@</span>
          edge  = edges;
          delta = edge-&gt;fpos - u;
          if ( delta &gt;= 0 )
          {
            u = edge-&gt;pos - ( edge-&gt;opos - ou );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="udiff-line-added">+           point-&gt;before[dim] = edge;</span>
<span class="udiff-line-added">+           point-&gt;after[dim]  = NULL;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
            goto Store_Point;
          }
  
          /* is the point after the last edge? */
          edge  = edge_limit - 1;
          delta = u - edge-&gt;fpos;
          if ( delta &gt;= 0 )
          {
            u = edge-&gt;pos + ( ou - edge-&gt;opos );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="udiff-line-added">+           point-&gt;before[dim] = NULL;</span>
<span class="udiff-line-added">+           point-&gt;after[dim]  = edge;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
            goto Store_Point;
          }
  
          {
            FT_PtrDist  min, max, mid;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1362,20 +1412,31 @@</span>
                min = mid + 1;
              else
              {
                /* we are on the edge */
                u = edge-&gt;pos;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="udiff-line-added">+               point-&gt;before[dim] = NULL;</span>
<span class="udiff-line-added">+               point-&gt;after[dim]  = NULL;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
                goto Store_Point;
              }
            }
  
            /* point is not on an edge */
            {
              AF_Edge  before = edges + min - 1;
              AF_Edge  after  = edges + min + 0;
  
  
<span class="udiff-line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="udiff-line-added">+             point-&gt;before[dim] = before;</span>
<span class="udiff-line-added">+             point-&gt;after[dim]  = after;</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
              /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
              if ( before-&gt;scale == 0 )
                before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
                                           after-&gt;fpos - before-&gt;fpos );
  
</pre>
<center><a href="afglobal.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
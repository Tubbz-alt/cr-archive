<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfreetype/include/freetype/internal/psaux.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /***************************************************************************/
   2 /*                                                                         */
   3 /*  psaux.h                                                                */
   4 /*                                                                         */
   5 /*    Auxiliary functions and data structures related to PostScript fonts  */
   6 /*    (specification).                                                     */
   7 /*                                                                         */
   8 /*  Copyright 1996-2018 by                                                 */
   9 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
  10 /*                                                                         */
  11 /*  This file is part of the FreeType project, and may only be used,       */
  12 /*  modified, and distributed under the terms of the FreeType project      */
  13 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
  14 /*  this file you indicate that you have read the license and              */
  15 /*  understand and accept it fully.                                        */
  16 /*                                                                         */
  17 /***************************************************************************/
  18 
  19 
  20 #ifndef PSAUX_H_
  21 #define PSAUX_H_
  22 
  23 
  24 #include &lt;ft2build.h&gt;
  25 #include FT_INTERNAL_OBJECTS_H
  26 #include FT_INTERNAL_TYPE1_TYPES_H
  27 #include FT_INTERNAL_HASH_H
  28 #include FT_INTERNAL_TRUETYPE_TYPES_H
  29 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  30 #include FT_INTERNAL_CFF_TYPES_H
  31 #include FT_INTERNAL_CFF_OBJECTS_TYPES_H
  32 
  33 
  34 
  35 FT_BEGIN_HEADER
  36 
  37 
  38   /***********************************************************************/
  39   /*                                                                     */
  40   /* PostScript modules driver class.                                    */
  41   /*                                                                     */
  42   typedef struct  PS_DriverRec_
  43   {
  44     FT_DriverRec  root;
  45 
  46     FT_UInt   hinting_engine;
  47     FT_Bool   no_stem_darkening;
  48     FT_Int    darken_params[8];
  49     FT_Int32  random_seed;
  50 
  51   } PS_DriverRec, *PS_Driver;
  52 
  53 
  54   /*************************************************************************/
  55   /*************************************************************************/
  56   /*****                                                               *****/
  57   /*****                             T1_TABLE                          *****/
  58   /*****                                                               *****/
  59   /*************************************************************************/
  60   /*************************************************************************/
  61 
  62 
  63   typedef struct PS_TableRec_*              PS_Table;
  64   typedef const struct PS_Table_FuncsRec_*  PS_Table_Funcs;
  65 
  66 
  67   /*************************************************************************/
  68   /*                                                                       */
  69   /* &lt;Struct&gt;                                                              */
  70   /*    PS_Table_FuncsRec                                                  */
  71   /*                                                                       */
  72   /* &lt;Description&gt;                                                         */
  73   /*    A set of function pointers to manage PS_Table objects.             */
  74   /*                                                                       */
  75   /* &lt;Fields&gt;                                                              */
  76   /*    table_init    :: Used to initialize a table.                       */
  77   /*                                                                       */
  78   /*    table_done    :: Finalizes resp. destroy a given table.            */
  79   /*                                                                       */
  80   /*    table_add     :: Adds a new object to a table.                     */
  81   /*                                                                       */
  82   /*    table_release :: Releases table data, then finalizes it.           */
  83   /*                                                                       */
  84   typedef struct  PS_Table_FuncsRec_
  85   {
  86     FT_Error
  87     (*init)( PS_Table   table,
  88              FT_Int     count,
  89              FT_Memory  memory );
  90 
  91     void
  92     (*done)( PS_Table  table );
  93 
  94     FT_Error
  95     (*add)( PS_Table  table,
  96             FT_Int    idx,
  97             void*     object,
  98             FT_UInt   length );
  99 
 100     void
 101     (*release)( PS_Table  table );
 102 
 103   } PS_Table_FuncsRec;
 104 
 105 
 106   /*************************************************************************/
 107   /*                                                                       */
 108   /* &lt;Struct&gt;                                                              */
 109   /*    PS_TableRec                                                        */
 110   /*                                                                       */
 111   /* &lt;Description&gt;                                                         */
 112   /*    A PS_Table is a simple object used to store an array of objects in */
 113   /*    a single memory block.                                             */
 114   /*                                                                       */
 115   /* &lt;Fields&gt;                                                              */
 116   /*    block     :: The address in memory of the growheap&#39;s block.  This  */
 117   /*                 can change between two object adds, due to            */
 118   /*                 reallocation.                                         */
 119   /*                                                                       */
 120   /*    cursor    :: The current top of the grow heap within its block.    */
 121   /*                                                                       */
 122   /*    capacity  :: The current size of the heap block.  Increments by    */
 123   /*                 1kByte chunks.                                        */
 124   /*                                                                       */
 125   /*    init      :: Set to 0xDEADBEEF if `elements&#39; and `lengths&#39; have    */
 126   /*                 been allocated.                                       */
 127   /*                                                                       */
 128   /*    max_elems :: The maximum number of elements in table.              */
 129   /*                                                                       */
 130   /*    num_elems :: The current number of elements in table.              */
 131   /*                                                                       */
 132   /*    elements  :: A table of element addresses within the block.        */
 133   /*                                                                       */
 134   /*    lengths   :: A table of element sizes within the block.            */
 135   /*                                                                       */
 136   /*    memory    :: The object used for memory operations                 */
 137   /*                 (alloc/realloc).                                      */
 138   /*                                                                       */
 139   /*    funcs     :: A table of method pointers for this object.           */
 140   /*                                                                       */
 141   typedef struct  PS_TableRec_
 142   {
 143     FT_Byte*           block;          /* current memory block           */
 144     FT_Offset          cursor;         /* current cursor in memory block */
 145     FT_Offset          capacity;       /* current size of memory block   */
 146     FT_ULong           init;
 147 
 148     FT_Int             max_elems;
 149     FT_Int             num_elems;
 150     FT_Byte**          elements;       /* addresses of table elements */
 151     FT_UInt*           lengths;        /* lengths of table elements   */
 152 
 153     FT_Memory          memory;
 154     PS_Table_FuncsRec  funcs;
 155 
 156   } PS_TableRec;
 157 
 158 
 159   /*************************************************************************/
 160   /*************************************************************************/
 161   /*****                                                               *****/
 162   /*****                       T1 FIELDS &amp; TOKENS                      *****/
 163   /*****                                                               *****/
 164   /*************************************************************************/
 165   /*************************************************************************/
 166 
 167   typedef struct PS_ParserRec_*  PS_Parser;
 168 
 169   typedef struct T1_TokenRec_*   T1_Token;
 170 
 171   typedef struct T1_FieldRec_*   T1_Field;
 172 
 173 
 174   /* simple enumeration type used to identify token types */
 175   typedef enum  T1_TokenType_
 176   {
 177     T1_TOKEN_TYPE_NONE = 0,
 178     T1_TOKEN_TYPE_ANY,
 179     T1_TOKEN_TYPE_STRING,
 180     T1_TOKEN_TYPE_ARRAY,
 181     T1_TOKEN_TYPE_KEY, /* aka `name&#39; */
 182 
 183     /* do not remove */
 184     T1_TOKEN_TYPE_MAX
 185 
 186   } T1_TokenType;
 187 
 188 
 189   /* a simple structure used to identify tokens */
 190   typedef struct  T1_TokenRec_
 191   {
 192     FT_Byte*      start;   /* first character of token in input stream */
 193     FT_Byte*      limit;   /* first character after the token          */
 194     T1_TokenType  type;    /* type of token                            */
 195 
 196   } T1_TokenRec;
 197 
 198 
 199   /* enumeration type used to identify object fields */
 200   typedef enum  T1_FieldType_
 201   {
 202     T1_FIELD_TYPE_NONE = 0,
 203     T1_FIELD_TYPE_BOOL,
 204     T1_FIELD_TYPE_INTEGER,
 205     T1_FIELD_TYPE_FIXED,
 206     T1_FIELD_TYPE_FIXED_1000,
 207     T1_FIELD_TYPE_STRING,
 208     T1_FIELD_TYPE_KEY,
 209     T1_FIELD_TYPE_BBOX,
 210     T1_FIELD_TYPE_MM_BBOX,
 211     T1_FIELD_TYPE_INTEGER_ARRAY,
 212     T1_FIELD_TYPE_FIXED_ARRAY,
 213     T1_FIELD_TYPE_CALLBACK,
 214 
 215     /* do not remove */
 216     T1_FIELD_TYPE_MAX
 217 
 218   } T1_FieldType;
 219 
 220 
 221   typedef enum  T1_FieldLocation_
 222   {
 223     T1_FIELD_LOCATION_CID_INFO,
 224     T1_FIELD_LOCATION_FONT_DICT,
 225     T1_FIELD_LOCATION_FONT_EXTRA,
 226     T1_FIELD_LOCATION_FONT_INFO,
 227     T1_FIELD_LOCATION_PRIVATE,
 228     T1_FIELD_LOCATION_BBOX,
 229     T1_FIELD_LOCATION_LOADER,
 230     T1_FIELD_LOCATION_FACE,
 231     T1_FIELD_LOCATION_BLEND,
 232 
 233     /* do not remove */
 234     T1_FIELD_LOCATION_MAX
 235 
 236   } T1_FieldLocation;
 237 
 238 
 239   typedef void
 240   (*T1_Field_ParseFunc)( FT_Face     face,
 241                          FT_Pointer  parser );
 242 
 243 
 244   /* structure type used to model object fields */
 245   typedef struct  T1_FieldRec_
 246   {
 247     const char*         ident;        /* field identifier               */
 248     T1_FieldLocation    location;
 249     T1_FieldType        type;         /* type of field                  */
 250     T1_Field_ParseFunc  reader;
 251     FT_UInt             offset;       /* offset of field in object      */
 252     FT_Byte             size;         /* size of field in bytes         */
 253     FT_UInt             array_max;    /* maximum number of elements for */
 254                                       /* array                          */
 255     FT_UInt             count_offset; /* offset of element count for    */
 256                                       /* arrays; must not be zero if in */
 257                                       /* use -- in other words, a       */
 258                                       /* `num_FOO&#39; element must not     */
 259                                       /* start the used structure if we */
 260                                       /* parse a `FOO&#39; array            */
 261     FT_UInt             dict;         /* where we expect it             */
 262   } T1_FieldRec;
 263 
 264 #define T1_FIELD_DICT_FONTDICT ( 1 &lt;&lt; 0 ) /* also FontInfo and FDArray */
 265 #define T1_FIELD_DICT_PRIVATE  ( 1 &lt;&lt; 1 )
 266 
 267 
 268 
 269 #define T1_NEW_SIMPLE_FIELD( _ident, _type, _fname, _dict ) \
 270           {                                                 \
 271             _ident, T1CODE, _type,                          \
 272             0,                                              \
 273             FT_FIELD_OFFSET( _fname ),                      \
 274             FT_FIELD_SIZE( _fname ),                        \
 275             0, 0,                                           \
 276             _dict                                           \
 277           },
 278 
 279 #define T1_NEW_CALLBACK_FIELD( _ident, _reader, _dict ) \
 280           {                                             \
 281             _ident, T1CODE, T1_FIELD_TYPE_CALLBACK,     \
 282             (T1_Field_ParseFunc)_reader,                \
 283             0, 0,                                       \
 284             0, 0,                                       \
 285             _dict                                       \
 286           },
 287 
 288 #define T1_NEW_TABLE_FIELD( _ident, _type, _fname, _max, _dict ) \
 289           {                                                      \
 290             _ident, T1CODE, _type,                               \
 291             0,                                                   \
 292             FT_FIELD_OFFSET( _fname ),                           \
 293             FT_FIELD_SIZE_DELTA( _fname ),                       \
 294             _max,                                                \
 295             FT_FIELD_OFFSET( num_ ## _fname ),                   \
 296             _dict                                                \
 297           },
 298 
 299 #define T1_NEW_TABLE_FIELD2( _ident, _type, _fname, _max, _dict ) \
 300           {                                                       \
 301             _ident, T1CODE, _type,                                \
 302             0,                                                    \
 303             FT_FIELD_OFFSET( _fname ),                            \
 304             FT_FIELD_SIZE_DELTA( _fname ),                        \
 305             _max, 0,                                              \
 306             _dict                                                 \
 307           },
 308 
 309 
 310 #define T1_FIELD_BOOL( _ident, _fname, _dict )                             \
 311           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BOOL, _fname, _dict )
 312 
 313 #define T1_FIELD_NUM( _ident, _fname, _dict )                                 \
 314           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER, _fname, _dict )
 315 
 316 #define T1_FIELD_FIXED( _ident, _fname, _dict )                             \
 317           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED, _fname, _dict )
 318 
 319 #define T1_FIELD_FIXED_1000( _ident, _fname, _dict )                     \
 320           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_1000, _fname, \
 321                                _dict )
 322 
 323 #define T1_FIELD_STRING( _ident, _fname, _dict )                             \
 324           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_STRING, _fname, _dict )
 325 
 326 #define T1_FIELD_KEY( _ident, _fname, _dict )                             \
 327           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_KEY, _fname, _dict )
 328 
 329 #define T1_FIELD_BBOX( _ident, _fname, _dict )                             \
 330           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BBOX, _fname, _dict )
 331 
 332 
 333 #define T1_FIELD_NUM_TABLE( _ident, _fname, _fmax, _dict )         \
 334           T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
 335                               _fname, _fmax, _dict )
 336 
 337 #define T1_FIELD_FIXED_TABLE( _ident, _fname, _fmax, _dict )     \
 338           T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
 339                               _fname, _fmax, _dict )
 340 
 341 #define T1_FIELD_NUM_TABLE2( _ident, _fname, _fmax, _dict )         \
 342           T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
 343                                _fname, _fmax, _dict )
 344 
 345 #define T1_FIELD_FIXED_TABLE2( _ident, _fname, _fmax, _dict )     \
 346           T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
 347                                _fname, _fmax, _dict )
 348 
 349 #define T1_FIELD_CALLBACK( _ident, _name, _dict )       \
 350           T1_NEW_CALLBACK_FIELD( _ident, _name, _dict )
 351 
 352 
 353   /*************************************************************************/
 354   /*************************************************************************/
 355   /*****                                                               *****/
 356   /*****                            T1 PARSER                          *****/
 357   /*****                                                               *****/
 358   /*************************************************************************/
 359   /*************************************************************************/
 360 
 361   typedef const struct PS_Parser_FuncsRec_*  PS_Parser_Funcs;
 362 
 363   typedef struct  PS_Parser_FuncsRec_
 364   {
 365     void
 366     (*init)( PS_Parser  parser,
 367              FT_Byte*   base,
 368              FT_Byte*   limit,
 369              FT_Memory  memory );
 370 
 371     void
 372     (*done)( PS_Parser  parser );
 373 
 374     void
 375     (*skip_spaces)( PS_Parser  parser );
 376     void
 377     (*skip_PS_token)( PS_Parser  parser );
 378 
 379     FT_Long
 380     (*to_int)( PS_Parser  parser );
 381     FT_Fixed
 382     (*to_fixed)( PS_Parser  parser,
 383                  FT_Int     power_ten );
 384 
 385     FT_Error
 386     (*to_bytes)( PS_Parser  parser,
 387                  FT_Byte*   bytes,
 388                  FT_Offset  max_bytes,
 389                  FT_ULong*  pnum_bytes,
 390                  FT_Bool    delimiters );
 391 
 392     FT_Int
 393     (*to_coord_array)( PS_Parser  parser,
 394                        FT_Int     max_coords,
 395                        FT_Short*  coords );
 396     FT_Int
 397     (*to_fixed_array)( PS_Parser  parser,
 398                        FT_Int     max_values,
 399                        FT_Fixed*  values,
 400                        FT_Int     power_ten );
 401 
 402     void
 403     (*to_token)( PS_Parser  parser,
 404                  T1_Token   token );
 405     void
 406     (*to_token_array)( PS_Parser  parser,
 407                        T1_Token   tokens,
 408                        FT_UInt    max_tokens,
 409                        FT_Int*    pnum_tokens );
 410 
 411     FT_Error
 412     (*load_field)( PS_Parser       parser,
 413                    const T1_Field  field,
 414                    void**          objects,
 415                    FT_UInt         max_objects,
 416                    FT_ULong*       pflags );
 417 
 418     FT_Error
 419     (*load_field_table)( PS_Parser       parser,
 420                          const T1_Field  field,
 421                          void**          objects,
 422                          FT_UInt         max_objects,
 423                          FT_ULong*       pflags );
 424 
 425   } PS_Parser_FuncsRec;
 426 
 427 
 428   /*************************************************************************/
 429   /*                                                                       */
 430   /* &lt;Struct&gt;                                                              */
 431   /*    PS_ParserRec                                                       */
 432   /*                                                                       */
 433   /* &lt;Description&gt;                                                         */
 434   /*    A PS_Parser is an object used to parse a Type 1 font very quickly. */
 435   /*                                                                       */
 436   /* &lt;Fields&gt;                                                              */
 437   /*    cursor :: The current position in the text.                        */
 438   /*                                                                       */
 439   /*    base   :: Start of the processed text.                             */
 440   /*                                                                       */
 441   /*    limit  :: End of the processed text.                               */
 442   /*                                                                       */
 443   /*    error  :: The last error returned.                                 */
 444   /*                                                                       */
 445   /*    memory :: The object used for memory operations (alloc/realloc).   */
 446   /*                                                                       */
 447   /*    funcs  :: A table of functions for the parser.                     */
 448   /*                                                                       */
 449   typedef struct  PS_ParserRec_
 450   {
 451     FT_Byte*   cursor;
 452     FT_Byte*   base;
 453     FT_Byte*   limit;
 454     FT_Error   error;
 455     FT_Memory  memory;
 456 
 457     PS_Parser_FuncsRec  funcs;
 458 
 459   } PS_ParserRec;
 460 
 461 
 462   /*************************************************************************/
 463   /*************************************************************************/
 464   /*****                                                               *****/
 465   /*****                         PS BUILDER                            *****/
 466   /*****                                                               *****/
 467   /*************************************************************************/
 468   /*************************************************************************/
 469 
 470 
 471   typedef struct PS_Builder_  PS_Builder;
 472   typedef const struct PS_Builder_FuncsRec_*  PS_Builder_Funcs;
 473 
 474   typedef struct  PS_Builder_FuncsRec_
 475   {
 476     void
 477     (*init)( PS_Builder*  ps_builder,
 478              void*        builder,
 479              FT_Bool      is_t1 );
 480 
 481     void
 482     (*done)( PS_Builder*  builder );
 483 
 484   } PS_Builder_FuncsRec;
 485 
 486 
 487   /*************************************************************************/
 488   /*                                                                       */
 489   /* &lt;Structure&gt;                                                           */
 490   /*    PS_Builder                                                         */
 491   /*                                                                       */
 492   /* &lt;Description&gt;                                                         */
 493   /*     A structure used during glyph loading to store its outline.       */
 494   /*                                                                       */
 495   /* &lt;Fields&gt;                                                              */
 496   /*    memory       :: The current memory object.                         */
 497   /*                                                                       */
 498   /*    face         :: The current face object.                           */
 499   /*                                                                       */
 500   /*    glyph        :: The current glyph slot.                            */
 501   /*                                                                       */
 502   /*    loader       :: XXX                                                */
 503   /*                                                                       */
 504   /*    base         :: The base glyph outline.                            */
 505   /*                                                                       */
 506   /*    current      :: The current glyph outline.                         */
 507   /*                                                                       */
 508   /*    pos_x        :: The horizontal translation (if composite glyph).   */
 509   /*                                                                       */
 510   /*    pos_y        :: The vertical translation (if composite glyph).     */
 511   /*                                                                       */
 512   /*    left_bearing :: The left side bearing point.                       */
 513   /*                                                                       */
 514   /*    advance      :: The horizontal advance vector.                     */
 515   /*                                                                       */
 516   /*    bbox         :: Unused.                                            */
 517   /*                                                                       */
 518   /*    path_begun   :: A flag which indicates that a new path has begun.  */
 519   /*                                                                       */
 520   /*    load_points  :: If this flag is not set, no points are loaded.     */
 521   /*                                                                       */
 522   /*    no_recurse   :: Set but not used.                                  */
 523   /*                                                                       */
 524   /*    metrics_only :: A boolean indicating that we only want to compute  */
 525   /*                    the metrics of a given glyph, not load all of its  */
 526   /*                    points.                                            */
 527   /*                                                                       */
 528   /*    is_t1        :: Set if current font type is Type 1.                */
 529   /*                                                                       */
 530   /*    funcs        :: An array of function pointers for the builder.     */
 531   /*                                                                       */
 532   struct  PS_Builder_
 533   {
 534     FT_Memory       memory;
 535     FT_Face         face;
 536     CFF_GlyphSlot   glyph;
 537     FT_GlyphLoader  loader;
 538     FT_Outline*     base;
 539     FT_Outline*     current;
 540 
 541     FT_Pos*  pos_x;
 542     FT_Pos*  pos_y;
 543 
 544     FT_Vector*  left_bearing;
 545     FT_Vector*  advance;
 546 
 547     FT_BBox*  bbox;          /* bounding box */
 548     FT_Bool   path_begun;
 549     FT_Bool   load_points;
 550     FT_Bool   no_recurse;
 551 
 552     FT_Bool  metrics_only;
 553     FT_Bool  is_t1;
 554 
 555     PS_Builder_FuncsRec  funcs;
 556 
 557   };
 558 
 559 
 560   /*************************************************************************/
 561   /*************************************************************************/
 562   /*****                                                               *****/
 563   /*****                            PS DECODER                         *****/
 564   /*****                                                               *****/
 565   /*************************************************************************/
 566   /*************************************************************************/
 567 
 568 #define PS_MAX_OPERANDS        48
 569 #define PS_MAX_SUBRS_CALLS     16   /* maximum subroutine nesting;         */
 570                                     /* only 10 are allowed but there exist */
 571                                     /* fonts like `HiraKakuProN-W3.ttf&#39;    */
 572                                     /* (Hiragino Kaku Gothic ProN W3;      */
 573                                     /* 8.2d6e1; 2014-12-19) that exceed    */
 574                                     /* this limit                          */
 575 
 576   /* execution context charstring zone */
 577 
 578   typedef struct  PS_Decoder_Zone_
 579   {
 580     FT_Byte*  base;
 581     FT_Byte*  limit;
 582     FT_Byte*  cursor;
 583 
 584   } PS_Decoder_Zone;
 585 
 586 
 587   typedef FT_Error
 588   (*CFF_Decoder_Get_Glyph_Callback)( TT_Face    face,
 589                                      FT_UInt    glyph_index,
 590                                      FT_Byte**  pointer,
 591                                      FT_ULong*  length );
 592 
 593   typedef void
 594   (*CFF_Decoder_Free_Glyph_Callback)( TT_Face    face,
 595                                       FT_Byte**  pointer,
 596                                       FT_ULong   length );
 597 
 598 
 599   typedef struct  PS_Decoder_
 600   {
 601     PS_Builder  builder;
 602 
 603     FT_Fixed   stack[PS_MAX_OPERANDS + 1];
 604     FT_Fixed*  top;
 605 
 606     PS_Decoder_Zone   zones[PS_MAX_SUBRS_CALLS + 1];
 607     PS_Decoder_Zone*  zone;
 608 
 609     FT_Int     flex_state;
 610     FT_Int     num_flex_vectors;
 611     FT_Vector  flex_vectors[7];
 612 
 613     CFF_Font     cff;
 614     CFF_SubFont  current_subfont; /* for current glyph_index */
 615     FT_Generic*  cf2_instance;
 616 
 617     FT_Pos*  glyph_width;
 618     FT_Bool  width_only;
 619     FT_Int   num_hints;
 620 
 621     FT_UInt  num_locals;
 622     FT_UInt  num_globals;
 623 
 624     FT_Int  locals_bias;
 625     FT_Int  globals_bias;
 626 
 627     FT_Byte**  locals;
 628     FT_Byte**  globals;
 629 
 630     FT_Byte**  glyph_names;   /* for pure CFF fonts only  */
 631     FT_UInt    num_glyphs;    /* number of glyphs in font */
 632 
 633     FT_Render_Mode  hint_mode;
 634 
 635     FT_Bool  seac;
 636 
 637     CFF_Decoder_Get_Glyph_Callback   get_glyph_callback;
 638     CFF_Decoder_Free_Glyph_Callback  free_glyph_callback;
 639 
 640     /* Type 1 stuff */
 641     FT_Service_PsCMaps  psnames;      /* for seac */
 642 
 643     FT_Int    lenIV;         /* internal for sub routine calls   */
 644     FT_UInt*  locals_len;    /* array of subrs length (optional) */
 645     FT_Hash   locals_hash;   /* used if `num_subrs&#39; was massaged */
 646 
 647     FT_Matrix  font_matrix;
 648     FT_Vector  font_offset;
 649 
 650     PS_Blend  blend;         /* for multiple master support */
 651 
 652     FT_Long*  buildchar;
 653     FT_UInt   len_buildchar;
 654 
 655   } PS_Decoder;
 656 
 657 
 658   /*************************************************************************/
 659   /*************************************************************************/
 660   /*****                                                               *****/
 661   /*****                         T1 BUILDER                            *****/
 662   /*****                                                               *****/
 663   /*************************************************************************/
 664   /*************************************************************************/
 665 
 666 
 667   typedef struct T1_BuilderRec_*  T1_Builder;
 668 
 669 
 670   typedef FT_Error
 671   (*T1_Builder_Check_Points_Func)( T1_Builder  builder,
 672                                    FT_Int      count );
 673 
 674   typedef void
 675   (*T1_Builder_Add_Point_Func)( T1_Builder  builder,
 676                                 FT_Pos      x,
 677                                 FT_Pos      y,
 678                                 FT_Byte     flag );
 679 
 680   typedef FT_Error
 681   (*T1_Builder_Add_Point1_Func)( T1_Builder  builder,
 682                                  FT_Pos      x,
 683                                  FT_Pos      y );
 684 
 685   typedef FT_Error
 686   (*T1_Builder_Add_Contour_Func)( T1_Builder  builder );
 687 
 688   typedef FT_Error
 689   (*T1_Builder_Start_Point_Func)( T1_Builder  builder,
 690                                   FT_Pos      x,
 691                                   FT_Pos      y );
 692 
 693   typedef void
 694   (*T1_Builder_Close_Contour_Func)( T1_Builder  builder );
 695 
 696 
 697   typedef const struct T1_Builder_FuncsRec_*  T1_Builder_Funcs;
 698 
 699   typedef struct  T1_Builder_FuncsRec_
 700   {
 701     void
 702     (*init)( T1_Builder    builder,
 703              FT_Face       face,
 704              FT_Size       size,
 705              FT_GlyphSlot  slot,
 706              FT_Bool       hinting );
 707 
 708     void
 709     (*done)( T1_Builder   builder );
 710 
 711     T1_Builder_Check_Points_Func   check_points;
 712     T1_Builder_Add_Point_Func      add_point;
 713     T1_Builder_Add_Point1_Func     add_point1;
 714     T1_Builder_Add_Contour_Func    add_contour;
 715     T1_Builder_Start_Point_Func    start_point;
 716     T1_Builder_Close_Contour_Func  close_contour;
 717 
 718   } T1_Builder_FuncsRec;
 719 
 720 
 721   /* an enumeration type to handle charstring parsing states */
 722   typedef enum  T1_ParseState_
 723   {
 724     T1_Parse_Start,
 725     T1_Parse_Have_Width,
 726     T1_Parse_Have_Moveto,
 727     T1_Parse_Have_Path
 728 
 729   } T1_ParseState;
 730 
 731 
 732   /*************************************************************************/
 733   /*                                                                       */
 734   /* &lt;Structure&gt;                                                           */
 735   /*    T1_BuilderRec                                                      */
 736   /*                                                                       */
 737   /* &lt;Description&gt;                                                         */
 738   /*     A structure used during glyph loading to store its outline.       */
 739   /*                                                                       */
 740   /* &lt;Fields&gt;                                                              */
 741   /*    memory       :: The current memory object.                         */
 742   /*                                                                       */
 743   /*    face         :: The current face object.                           */
 744   /*                                                                       */
 745   /*    glyph        :: The current glyph slot.                            */
 746   /*                                                                       */
 747   /*    loader       :: XXX                                                */
 748   /*                                                                       */
 749   /*    base         :: The base glyph outline.                            */
 750   /*                                                                       */
 751   /*    current      :: The current glyph outline.                         */
 752   /*                                                                       */
 753   /*    max_points   :: maximum points in builder outline                  */
 754   /*                                                                       */
 755   /*    max_contours :: Maximum number of contours in builder outline.     */
 756   /*                                                                       */
 757   /*    pos_x        :: The horizontal translation (if composite glyph).   */
 758   /*                                                                       */
 759   /*    pos_y        :: The vertical translation (if composite glyph).     */
 760   /*                                                                       */
 761   /*    left_bearing :: The left side bearing point.                       */
 762   /*                                                                       */
 763   /*    advance      :: The horizontal advance vector.                     */
 764   /*                                                                       */
 765   /*    bbox         :: Unused.                                            */
 766   /*                                                                       */
 767   /*    parse_state  :: An enumeration which controls the charstring       */
 768   /*                    parsing state.                                     */
 769   /*                                                                       */
 770   /*    load_points  :: If this flag is not set, no points are loaded.     */
 771   /*                                                                       */
 772   /*    no_recurse   :: Set but not used.                                  */
 773   /*                                                                       */
 774   /*    metrics_only :: A boolean indicating that we only want to compute  */
 775   /*                    the metrics of a given glyph, not load all of its  */
 776   /*                    points.                                            */
 777   /*                                                                       */
 778   /*    funcs        :: An array of function pointers for the builder.     */
 779   /*                                                                       */
 780   typedef struct  T1_BuilderRec_
 781   {
 782     FT_Memory       memory;
 783     FT_Face         face;
 784     FT_GlyphSlot    glyph;
 785     FT_GlyphLoader  loader;
 786     FT_Outline*     base;
 787     FT_Outline*     current;
 788 
 789     FT_Pos          pos_x;
 790     FT_Pos          pos_y;
 791 
 792     FT_Vector       left_bearing;
 793     FT_Vector       advance;
 794 
 795     FT_BBox         bbox;          /* bounding box */
 796     T1_ParseState   parse_state;
 797     FT_Bool         load_points;
 798     FT_Bool         no_recurse;
 799 
 800     FT_Bool         metrics_only;
 801 
 802     void*           hints_funcs;    /* hinter-specific */
 803     void*           hints_globals;  /* hinter-specific */
 804 
 805     T1_Builder_FuncsRec  funcs;
 806 
 807   } T1_BuilderRec;
 808 
 809 
 810   /*************************************************************************/
 811   /*************************************************************************/
 812   /*****                                                               *****/
 813   /*****                         T1 DECODER                            *****/
 814   /*****                                                               *****/
 815   /*************************************************************************/
 816   /*************************************************************************/
 817 
 818 #if 0
 819 
 820   /*************************************************************************/
 821   /*                                                                       */
 822   /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
 823   /* calls during glyph loading.                                           */
 824   /*                                                                       */
 825 #define T1_MAX_SUBRS_CALLS  8
 826 
 827 
 828   /*************************************************************************/
 829   /*                                                                       */
 830   /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack&#39;s capacity.  A     */
 831   /* minimum of 16 is required.                                            */
 832   /*                                                                       */
 833 #define T1_MAX_CHARSTRINGS_OPERANDS  32
 834 
 835 #endif /* 0 */
 836 
 837 
 838   typedef struct  T1_Decoder_ZoneRec_
 839   {
 840     FT_Byte*  cursor;
 841     FT_Byte*  base;
 842     FT_Byte*  limit;
 843 
 844   } T1_Decoder_ZoneRec, *T1_Decoder_Zone;
 845 
 846 
 847   typedef struct T1_DecoderRec_*              T1_Decoder;
 848   typedef const struct T1_Decoder_FuncsRec_*  T1_Decoder_Funcs;
 849 
 850 
 851   typedef FT_Error
 852   (*T1_Decoder_Callback)( T1_Decoder  decoder,
 853                           FT_UInt     glyph_index );
 854 
 855 
 856   typedef struct  T1_Decoder_FuncsRec_
 857   {
 858     FT_Error
 859     (*init)( T1_Decoder           decoder,
 860              FT_Face              face,
 861              FT_Size              size,
 862              FT_GlyphSlot         slot,
 863              FT_Byte**            glyph_names,
 864              PS_Blend             blend,
 865              FT_Bool              hinting,
 866              FT_Render_Mode       hint_mode,
 867              T1_Decoder_Callback  callback );
 868 
 869     void
 870     (*done)( T1_Decoder  decoder );
 871 
 872 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 873     FT_Error
 874     (*parse_charstrings_old)( T1_Decoder  decoder,
 875                               FT_Byte*    base,
 876                               FT_UInt     len );
 877 #else
 878     FT_Error
 879     (*parse_metrics)( T1_Decoder  decoder,
 880                       FT_Byte*    base,
 881                       FT_UInt     len );
 882 #endif
 883 
 884     FT_Error
 885     (*parse_charstrings)( PS_Decoder*  decoder,
 886                           FT_Byte*     charstring_base,
 887                           FT_ULong     charstring_len );
 888 
 889 
 890   } T1_Decoder_FuncsRec;
 891 
 892 
 893   typedef struct  T1_DecoderRec_
 894   {
 895     T1_BuilderRec        builder;
 896 
 897     FT_Long              stack[T1_MAX_CHARSTRINGS_OPERANDS];
 898     FT_Long*             top;
 899 
 900     T1_Decoder_ZoneRec   zones[T1_MAX_SUBRS_CALLS + 1];
 901     T1_Decoder_Zone      zone;
 902 
 903     FT_Service_PsCMaps   psnames;      /* for seac */
 904     FT_UInt              num_glyphs;
 905     FT_Byte**            glyph_names;
 906 
 907     FT_Int               lenIV;        /* internal for sub routine calls */
 908     FT_Int               num_subrs;
 909     FT_Byte**            subrs;
 910     FT_UInt*             subrs_len;    /* array of subrs length (optional) */
 911     FT_Hash              subrs_hash;   /* used if `num_subrs&#39; was massaged */
 912 
 913     FT_Matrix            font_matrix;
 914     FT_Vector            font_offset;
 915 
 916     FT_Int               flex_state;
 917     FT_Int               num_flex_vectors;
 918     FT_Vector            flex_vectors[7];
 919 
 920     PS_Blend             blend;       /* for multiple master support */
 921 
 922     FT_Render_Mode       hint_mode;
 923 
 924     T1_Decoder_Callback  parse_callback;
 925     T1_Decoder_FuncsRec  funcs;
 926 
 927     FT_Long*             buildchar;
 928     FT_UInt              len_buildchar;
 929 
 930     FT_Bool              seac;
 931 
 932     FT_Generic           cf2_instance;
 933 
 934   } T1_DecoderRec;
 935 
 936 
 937   /*************************************************************************/
 938   /*************************************************************************/
 939   /*****                                                               *****/
 940   /*****                        CFF BUILDER                            *****/
 941   /*****                                                               *****/
 942   /*************************************************************************/
 943   /*************************************************************************/
 944 
 945 
 946   typedef struct CFF_Builder_  CFF_Builder;
 947 
 948 
 949   typedef FT_Error
 950   (*CFF_Builder_Check_Points_Func)( CFF_Builder*  builder,
 951                                     FT_Int        count );
 952 
 953   typedef void
 954   (*CFF_Builder_Add_Point_Func)( CFF_Builder*  builder,
 955                                  FT_Pos        x,
 956                                  FT_Pos        y,
 957                                  FT_Byte       flag );
 958   typedef FT_Error
 959   (*CFF_Builder_Add_Point1_Func)( CFF_Builder*  builder,
 960                                   FT_Pos        x,
 961                                   FT_Pos        y );
 962   typedef FT_Error
 963   (*CFF_Builder_Start_Point_Func)( CFF_Builder*  builder,
 964                                    FT_Pos        x,
 965                                    FT_Pos        y );
 966   typedef void
 967   (*CFF_Builder_Close_Contour_Func)( CFF_Builder*  builder );
 968 
 969   typedef FT_Error
 970   (*CFF_Builder_Add_Contour_Func)( CFF_Builder*  builder );
 971 
 972   typedef const struct CFF_Builder_FuncsRec_*  CFF_Builder_Funcs;
 973 
 974   typedef struct  CFF_Builder_FuncsRec_
 975   {
 976     void
 977     (*init)( CFF_Builder*   builder,
 978              TT_Face        face,
 979              CFF_Size       size,
 980              CFF_GlyphSlot  glyph,
 981              FT_Bool        hinting );
 982 
 983     void
 984     (*done)( CFF_Builder*  builder );
 985 
 986     CFF_Builder_Check_Points_Func   check_points;
 987     CFF_Builder_Add_Point_Func      add_point;
 988     CFF_Builder_Add_Point1_Func     add_point1;
 989     CFF_Builder_Add_Contour_Func    add_contour;
 990     CFF_Builder_Start_Point_Func    start_point;
 991     CFF_Builder_Close_Contour_Func  close_contour;
 992 
 993   } CFF_Builder_FuncsRec;
 994 
 995 
 996   /*************************************************************************/
 997   /*                                                                       */
 998   /* &lt;Structure&gt;                                                           */
 999   /*    CFF_Builder                                                        */
1000   /*                                                                       */
1001   /* &lt;Description&gt;                                                         */
1002   /*     A structure used during glyph loading to store its outline.       */
1003   /*                                                                       */
1004   /* &lt;Fields&gt;                                                              */
1005   /*    memory        :: The current memory object.                        */
1006   /*                                                                       */
1007   /*    face          :: The current face object.                          */
1008   /*                                                                       */
1009   /*    glyph         :: The current glyph slot.                           */
1010   /*                                                                       */
1011   /*    loader        :: The current glyph loader.                         */
1012   /*                                                                       */
1013   /*    base          :: The base glyph outline.                           */
1014   /*                                                                       */
1015   /*    current       :: The current glyph outline.                        */
1016   /*                                                                       */
1017   /*    pos_x         :: The horizontal translation (if composite glyph).  */
1018   /*                                                                       */
1019   /*    pos_y         :: The vertical translation (if composite glyph).    */
1020   /*                                                                       */
1021   /*    left_bearing  :: The left side bearing point.                      */
1022   /*                                                                       */
1023   /*    advance       :: The horizontal advance vector.                    */
1024   /*                                                                       */
1025   /*    bbox          :: Unused.                                           */
1026   /*                                                                       */
1027   /*    path_begun    :: A flag which indicates that a new path has begun. */
1028   /*                                                                       */
1029   /*    load_points   :: If this flag is not set, no points are loaded.    */
1030   /*                                                                       */
1031   /*    no_recurse    :: Set but not used.                                 */
1032   /*                                                                       */
1033   /*    metrics_only  :: A boolean indicating that we only want to compute */
1034   /*                     the metrics of a given glyph, not load all of its */
1035   /*                     points.                                           */
1036   /*                                                                       */
1037   /*    hints_funcs   :: Auxiliary pointer for hinting.                    */
1038   /*                                                                       */
1039   /*    hints_globals :: Auxiliary pointer for hinting.                    */
1040   /*                                                                       */
1041   /*    funcs         :: A table of method pointers for this object.       */
1042   /*                                                                       */
1043   struct  CFF_Builder_
1044   {
1045     FT_Memory       memory;
1046     TT_Face         face;
1047     CFF_GlyphSlot   glyph;
1048     FT_GlyphLoader  loader;
1049     FT_Outline*     base;
1050     FT_Outline*     current;
1051 
1052     FT_Pos  pos_x;
1053     FT_Pos  pos_y;
1054 
1055     FT_Vector  left_bearing;
1056     FT_Vector  advance;
1057 
1058     FT_BBox  bbox;          /* bounding box */
1059 
1060     FT_Bool  path_begun;
1061     FT_Bool  load_points;
1062     FT_Bool  no_recurse;
1063 
1064     FT_Bool  metrics_only;
1065 
1066     void*  hints_funcs;     /* hinter-specific */
1067     void*  hints_globals;   /* hinter-specific */
1068 
1069     CFF_Builder_FuncsRec  funcs;
1070   };
1071 
1072 
1073   /*************************************************************************/
1074   /*************************************************************************/
1075   /*****                                                               *****/
1076   /*****                        CFF DECODER                            *****/
1077   /*****                                                               *****/
1078   /*************************************************************************/
1079   /*************************************************************************/
1080 
1081 
1082 #define CFF_MAX_OPERANDS        48
1083 #define CFF_MAX_SUBRS_CALLS     16  /* maximum subroutine nesting;         */
1084                                     /* only 10 are allowed but there exist */
1085                                     /* fonts like `HiraKakuProN-W3.ttf&#39;    */
1086                                     /* (Hiragino Kaku Gothic ProN W3;      */
1087                                     /* 8.2d6e1; 2014-12-19) that exceed    */
1088                                     /* this limit                          */
1089 #define CFF_MAX_TRANS_ELEMENTS  32
1090 
1091   /* execution context charstring zone */
1092 
1093   typedef struct  CFF_Decoder_Zone_
1094   {
1095     FT_Byte*  base;
1096     FT_Byte*  limit;
1097     FT_Byte*  cursor;
1098 
1099   } CFF_Decoder_Zone;
1100 
1101 
1102   typedef struct  CFF_Decoder_
1103   {
1104     CFF_Builder  builder;
1105     CFF_Font     cff;
1106 
1107     FT_Fixed   stack[CFF_MAX_OPERANDS + 1];
1108     FT_Fixed*  top;
1109 
1110     CFF_Decoder_Zone   zones[CFF_MAX_SUBRS_CALLS + 1];
1111     CFF_Decoder_Zone*  zone;
1112 
1113     FT_Int     flex_state;
1114     FT_Int     num_flex_vectors;
1115     FT_Vector  flex_vectors[7];
1116 
1117     FT_Pos  glyph_width;
1118     FT_Pos  nominal_width;
1119 
1120     FT_Bool   read_width;
1121     FT_Bool   width_only;
1122     FT_Int    num_hints;
1123     FT_Fixed  buildchar[CFF_MAX_TRANS_ELEMENTS];
1124 
1125     FT_UInt  num_locals;
1126     FT_UInt  num_globals;
1127 
1128     FT_Int  locals_bias;
1129     FT_Int  globals_bias;
1130 
1131     FT_Byte**  locals;
1132     FT_Byte**  globals;
1133 
1134     FT_Byte**  glyph_names;   /* for pure CFF fonts only  */
1135     FT_UInt    num_glyphs;    /* number of glyphs in font */
1136 
1137     FT_Render_Mode  hint_mode;
1138 
1139     FT_Bool  seac;
1140 
1141     CFF_SubFont  current_subfont; /* for current glyph_index */
1142 
1143     CFF_Decoder_Get_Glyph_Callback   get_glyph_callback;
1144     CFF_Decoder_Free_Glyph_Callback  free_glyph_callback;
1145 
1146   } CFF_Decoder;
1147 
1148 
1149   typedef const struct CFF_Decoder_FuncsRec_*  CFF_Decoder_Funcs;
1150 
1151   typedef struct  CFF_Decoder_FuncsRec_
1152   {
1153     void
1154     (*init)( CFF_Decoder*                     decoder,
1155              TT_Face                          face,
1156              CFF_Size                         size,
1157              CFF_GlyphSlot                    slot,
1158              FT_Bool                          hinting,
1159              FT_Render_Mode                   hint_mode,
1160              CFF_Decoder_Get_Glyph_Callback   get_callback,
1161              CFF_Decoder_Free_Glyph_Callback  free_callback );
1162 
1163     FT_Error
1164     (*prepare)( CFF_Decoder*  decoder,
1165                 CFF_Size      size,
1166                 FT_UInt       glyph_index );
1167 
1168 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1169     FT_Error
1170     (*parse_charstrings_old)( CFF_Decoder*  decoder,
1171                               FT_Byte*      charstring_base,
1172                               FT_ULong      charstring_len,
1173                               FT_Bool       in_dict );
1174 #endif
1175 
1176     FT_Error
1177     (*parse_charstrings)( PS_Decoder*  decoder,
1178                           FT_Byte*     charstring_base,
1179                           FT_ULong     charstring_len );
1180 
1181   } CFF_Decoder_FuncsRec;
1182 
1183 
1184   /*************************************************************************/
1185   /*************************************************************************/
1186   /*****                                                               *****/
1187   /*****                            AFM PARSER                         *****/
1188   /*****                                                               *****/
1189   /*************************************************************************/
1190   /*************************************************************************/
1191 
1192   typedef struct AFM_ParserRec_*  AFM_Parser;
1193 
1194   typedef struct  AFM_Parser_FuncsRec_
1195   {
1196     FT_Error
1197     (*init)( AFM_Parser  parser,
1198              FT_Memory   memory,
1199              FT_Byte*    base,
1200              FT_Byte*    limit );
1201 
1202     void
1203     (*done)( AFM_Parser  parser );
1204 
1205     FT_Error
1206     (*parse)( AFM_Parser  parser );
1207 
1208   } AFM_Parser_FuncsRec;
1209 
1210 
1211   typedef struct AFM_StreamRec_*  AFM_Stream;
1212 
1213 
1214   /*************************************************************************/
1215   /*                                                                       */
1216   /* &lt;Struct&gt;                                                              */
1217   /*    AFM_ParserRec                                                      */
1218   /*                                                                       */
1219   /* &lt;Description&gt;                                                         */
1220   /*    An AFM_Parser is a parser for the AFM files.                       */
1221   /*                                                                       */
1222   /* &lt;Fields&gt;                                                              */
1223   /*    memory    :: The object used for memory operations (alloc and      */
1224   /*                 realloc).                                             */
1225   /*                                                                       */
1226   /*    stream    :: This is an opaque object.                             */
1227   /*                                                                       */
1228   /*    FontInfo  :: The result will be stored here.                       */
1229   /*                                                                       */
1230   /*    get_index :: A user provided function to get a glyph index by its  */
1231   /*                 name.                                                 */
1232   /*                                                                       */
1233   typedef struct  AFM_ParserRec_
1234   {
1235     FT_Memory     memory;
1236     AFM_Stream    stream;
1237 
1238     AFM_FontInfo  FontInfo;
1239 
1240     FT_Int
1241     (*get_index)( const char*  name,
1242                   FT_Offset    len,
1243                   void*        user_data );
1244 
1245     void*         user_data;
1246 
1247   } AFM_ParserRec;
1248 
1249 
1250   /*************************************************************************/
1251   /*************************************************************************/
1252   /*****                                                               *****/
1253   /*****                     TYPE1 CHARMAPS                            *****/
1254   /*****                                                               *****/
1255   /*************************************************************************/
1256   /*************************************************************************/
1257 
1258   typedef const struct T1_CMap_ClassesRec_*  T1_CMap_Classes;
1259 
1260   typedef struct T1_CMap_ClassesRec_
1261   {
1262     FT_CMap_Class  standard;
1263     FT_CMap_Class  expert;
1264     FT_CMap_Class  custom;
1265     FT_CMap_Class  unicode;
1266 
1267   } T1_CMap_ClassesRec;
1268 
1269 
1270   /*************************************************************************/
1271   /*************************************************************************/
1272   /*****                                                               *****/
1273   /*****                        PSAux Module Interface                 *****/
1274   /*****                                                               *****/
1275   /*************************************************************************/
1276   /*************************************************************************/
1277 
1278   typedef struct  PSAux_ServiceRec_
1279   {
1280     /* don&#39;t use `PS_Table_Funcs&#39; and friends to avoid compiler warnings */
1281     const PS_Table_FuncsRec*    ps_table_funcs;
1282     const PS_Parser_FuncsRec*   ps_parser_funcs;
1283     const T1_Builder_FuncsRec*  t1_builder_funcs;
1284     const T1_Decoder_FuncsRec*  t1_decoder_funcs;
1285 
1286     void
1287     (*t1_decrypt)( FT_Byte*   buffer,
1288                    FT_Offset  length,
1289                    FT_UShort  seed );
1290 
1291     FT_UInt32
1292     (*cff_random)( FT_UInt32  r );
1293 
1294     void
1295     (*ps_decoder_init)( PS_Decoder*  ps_decoder,
1296                         void*        decoder,
1297                         FT_Bool      is_t1 );
1298 
1299     void
1300     (*t1_make_subfont)( FT_Face      face,
1301                         PS_Private   priv,
1302                         CFF_SubFont  subfont );
1303 
1304     T1_CMap_Classes  t1_cmap_classes;
1305 
1306     /* fields after this comment line were added after version 2.1.10 */
1307     const AFM_Parser_FuncsRec*  afm_parser_funcs;
1308 
1309     const CFF_Decoder_FuncsRec*  cff_decoder_funcs;
1310 
1311   } PSAux_ServiceRec, *PSAux_Service;
1312 
1313   /* backward compatible type definition */
1314   typedef PSAux_ServiceRec   PSAux_Interface;
1315 
1316 
1317   /*************************************************************************/
1318   /*************************************************************************/
1319   /*****                                                               *****/
1320   /*****                 Some convenience functions                    *****/
1321   /*****                                                               *****/
1322   /*************************************************************************/
1323   /*************************************************************************/
1324 
1325 #define IS_PS_NEWLINE( ch ) \
1326   ( (ch) == &#39;\r&#39; ||         \
1327     (ch) == &#39;\n&#39; )
1328 
1329 #define IS_PS_SPACE( ch )  \
1330   ( (ch) == &#39; &#39;         || \
1331     IS_PS_NEWLINE( ch ) || \
1332     (ch) == &#39;\t&#39;        || \
1333     (ch) == &#39;\f&#39;        || \
1334     (ch) == &#39;\0&#39; )
1335 
1336 #define IS_PS_SPECIAL( ch )       \
1337   ( (ch) == &#39;/&#39;                || \
1338     (ch) == &#39;(&#39; || (ch) == &#39;)&#39; || \
1339     (ch) == &#39;&lt;&#39; || (ch) == &#39;&gt;&#39; || \
1340     (ch) == &#39;[&#39; || (ch) == &#39;]&#39; || \
1341     (ch) == &#39;{&#39; || (ch) == &#39;}&#39; || \
1342     (ch) == &#39;%&#39;                )
1343 
1344 #define IS_PS_DELIM( ch )  \
1345   ( IS_PS_SPACE( ch )   || \
1346     IS_PS_SPECIAL( ch ) )
1347 
1348 #define IS_PS_DIGIT( ch )        \
1349   ( (ch) &gt;= &#39;0&#39; &amp;&amp; (ch) &lt;= &#39;9&#39; )
1350 
1351 #define IS_PS_XDIGIT( ch )            \
1352   ( IS_PS_DIGIT( ch )              || \
1353     ( (ch) &gt;= &#39;A&#39; &amp;&amp; (ch) &lt;= &#39;F&#39; ) || \
1354     ( (ch) &gt;= &#39;a&#39; &amp;&amp; (ch) &lt;= &#39;f&#39; ) )
1355 
1356 #define IS_PS_BASE85( ch )       \
1357   ( (ch) &gt;= &#39;!&#39; &amp;&amp; (ch) &lt;= &#39;u&#39; )
1358 
1359 #define IS_PS_TOKEN( cur, limit, token )                                \
1360   ( (char)(cur)[0] == (token)[0]                                     &amp;&amp; \
1361     ( (cur) + sizeof ( (token) ) == (limit) ||                          \
1362       ( (cur) + sizeof( (token) ) &lt; (limit)          &amp;&amp;                 \
1363         IS_PS_DELIM( (cur)[sizeof ( (token) ) - 1] ) ) )             &amp;&amp; \
1364     ft_strncmp( (char*)(cur), (token), sizeof ( (token) ) - 1 ) == 0 )
1365 
1366 
1367 FT_END_HEADER
1368 
1369 #endif /* PSAUX_H_ */
1370 
1371 
1372 /* END */
    </pre>
  </body>
</html>
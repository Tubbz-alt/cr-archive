<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/ttload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttload.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Load the basic TrueType tables, i.e., tables that can be either in   */</span>
<span class="line-modified">   6 /*    TTF or OTF fonts (body).                                             */</span>
<span class="line-modified">   7 /*                                                                         */</span>
<span class="line-modified">   8 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   9 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  10 /*                                                                         */</span>
<span class="line-modified">  11 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  12 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  13 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  14 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  15 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  16 /*                                                                         */</span>
<span class="line-modified">  17 /***************************************************************************/</span>
  18 
  19 
  20 #include &lt;ft2build.h&gt;
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_STREAM_H
  23 #include FT_TRUETYPE_TAGS_H
  24 #include &quot;ttload.h&quot;
  25 
  26 #include &quot;sferrors.h&quot;
  27 
  28 
<a name="2" id="anc2"></a><span class="line-modified">  29   /*************************************************************************/</span>
<span class="line-modified">  30   /*                                                                       */</span>
<span class="line-modified">  31   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  32   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  33   /* messages during execution.                                            */</span>
<span class="line-modified">  34   /*                                                                       */</span>
  35 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  36 #define FT_COMPONENT  trace_ttload</span>
<span class="line-modified">  37 </span>
<span class="line-modified">  38 </span>
<span class="line-modified">  39   /*************************************************************************/</span>
<span class="line-modified">  40   /*                                                                       */</span>
<span class="line-modified">  41   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">  42   /*    tt_face_lookup_table                                               */</span>
<span class="line-modified">  43   /*                                                                       */</span>
<span class="line-modified">  44   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">  45   /*    Looks for a TrueType table by name.                                */</span>
<span class="line-modified">  46   /*                                                                       */</span>
<span class="line-modified">  47   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">  48   /*    face :: A face object handle.                                      */</span>
<span class="line-modified">  49   /*                                                                       */</span>
<span class="line-modified">  50   /*    tag  :: The searched tag.                                          */</span>
<span class="line-modified">  51   /*                                                                       */</span>
<span class="line-modified">  52   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">  53   /*    A pointer to the table directory entry.  0 if not found.           */</span>
<span class="line-modified">  54   /*                                                                       */</span>


  55   FT_LOCAL_DEF( TT_Table  )
  56   tt_face_lookup_table( TT_Face   face,
  57                         FT_ULong  tag  )
  58   {
  59     TT_Table  entry;
  60     TT_Table  limit;
  61 #ifdef FT_DEBUG_LEVEL_TRACE
  62     FT_Bool   zero_length = FALSE;
  63 #endif
  64 
  65 
  66     FT_TRACE4(( &quot;tt_face_lookup_table: %08p, `%c%c%c%c&#39; -- &quot;,
  67                 face,
  68                 (FT_Char)( tag &gt;&gt; 24 ),
  69                 (FT_Char)( tag &gt;&gt; 16 ),
  70                 (FT_Char)( tag &gt;&gt; 8  ),
  71                 (FT_Char)( tag       ) ));
  72 
  73     entry = face-&gt;dir_tables;
  74     limit = entry + face-&gt;num_tables;
  75 
  76     for ( ; entry &lt; limit; entry++ )
  77     {
  78       /* For compatibility with Windows, we consider    */
  79       /* zero-length tables the same as missing tables. */
  80       if ( entry-&gt;Tag == tag )
  81       {
  82         if ( entry-&gt;Length != 0 )
  83         {
  84           FT_TRACE4(( &quot;found table.\n&quot; ));
  85           return entry;
  86         }
  87 #ifdef FT_DEBUG_LEVEL_TRACE
  88         zero_length = TRUE;
  89 #endif
  90       }
  91     }
  92 
  93 #ifdef FT_DEBUG_LEVEL_TRACE
  94     if ( zero_length )
  95       FT_TRACE4(( &quot;ignoring empty table\n&quot; ));
  96     else
  97       FT_TRACE4(( &quot;could not find table\n&quot; ));
  98 #endif
  99 
 100     return NULL;
 101   }
 102 
 103 
<a name="4" id="anc4"></a><span class="line-modified"> 104   /*************************************************************************/</span>
<span class="line-modified"> 105   /*                                                                       */</span>
<span class="line-modified"> 106   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 107   /*    tt_face_goto_table                                                 */</span>
<span class="line-modified"> 108   /*                                                                       */</span>
<span class="line-modified"> 109   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 110   /*    Looks for a TrueType table by name, then seek a stream to it.      */</span>
<span class="line-modified"> 111   /*                                                                       */</span>
<span class="line-modified"> 112   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 113   /*    face   :: A face object handle.                                    */</span>
<span class="line-modified"> 114   /*                                                                       */</span>
<span class="line-modified"> 115   /*    tag    :: The searched tag.                                        */</span>
<span class="line-modified"> 116   /*                                                                       */</span>
<span class="line-modified"> 117   /*    stream :: The stream to seek when the table is found.              */</span>
<span class="line-modified"> 118   /*                                                                       */</span>
<span class="line-modified"> 119   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified"> 120   /*    length :: The length of the table if found, undefined otherwise.   */</span>
<span class="line-modified"> 121   /*                                                                       */</span>
<span class="line-modified"> 122   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 123   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 124   /*                                                                       */</span>




 125   FT_LOCAL_DEF( FT_Error )
 126   tt_face_goto_table( TT_Face    face,
 127                       FT_ULong   tag,
 128                       FT_Stream  stream,
 129                       FT_ULong*  length )
 130   {
 131     TT_Table  table;
 132     FT_Error  error;
 133 
 134 
 135     table = tt_face_lookup_table( face, tag );
 136     if ( table )
 137     {
 138       if ( length )
 139         *length = table-&gt;Length;
 140 
 141       if ( FT_STREAM_SEEK( table-&gt;Offset ) )
 142         goto Exit;
 143     }
 144     else
 145       error = FT_THROW( Table_Missing );
 146 
 147   Exit:
 148     return error;
 149   }
 150 
 151 
 152   /* Here, we                                                         */
 153   /*                                                                  */
 154   /* - check that `num_tables&#39; is valid (and adjust it if necessary); */
 155   /*   also return the number of valid table entries                  */
 156   /*                                                                  */
 157   /* - look for a `head&#39; table, check its size, and parse it to check */
 158   /*   whether its `magic&#39; field is correctly set                     */
 159   /*                                                                  */
 160   /* - errors (except errors returned by stream handling)             */
 161   /*                                                                  */
 162   /*     SFNT_Err_Unknown_File_Format:                                */
 163   /*       no table is defined in directory, it is not sfnt-wrapped   */
 164   /*       data                                                       */
 165   /*     SFNT_Err_Table_Missing:                                      */
 166   /*       table directory is valid, but essential tables             */
 167   /*       (head/bhed/SING) are missing                               */
 168   /*                                                                  */
 169   static FT_Error
 170   check_table_dir( SFNT_Header  sfnt,
 171                    FT_Stream    stream,
 172                    FT_UShort*   valid )
 173   {
 174     FT_Error   error;
 175     FT_UShort  nn, valid_entries = 0;
 176     FT_UInt    has_head = 0, has_sing = 0, has_meta = 0;
 177     FT_ULong   offset = sfnt-&gt;offset + 12;
 178 
 179     static const FT_Frame_Field  table_dir_entry_fields[] =
 180     {
 181 #undef  FT_STRUCTURE
 182 #define FT_STRUCTURE  TT_TableRec
 183 
 184       FT_FRAME_START( 16 ),
 185         FT_FRAME_ULONG( Tag ),
 186         FT_FRAME_ULONG( CheckSum ),
 187         FT_FRAME_ULONG( Offset ),
 188         FT_FRAME_ULONG( Length ),
 189       FT_FRAME_END
 190     };
 191 
 192 
 193     if ( FT_STREAM_SEEK( offset ) )
 194       goto Exit;
 195 
 196     for ( nn = 0; nn &lt; sfnt-&gt;num_tables; nn++ )
 197     {
 198       TT_TableRec  table;
 199 
 200 
 201       if ( FT_STREAM_READ_FIELDS( table_dir_entry_fields, &amp;table ) )
 202       {
 203         nn--;
 204         FT_TRACE2(( &quot;check_table_dir:&quot;
 205                     &quot; can read only %d table%s in font (instead of %d)\n&quot;,
 206                     nn, nn == 1 ? &quot;&quot; : &quot;s&quot;, sfnt-&gt;num_tables ));
 207         sfnt-&gt;num_tables = nn;
 208         break;
 209       }
 210 
 211       /* we ignore invalid tables */
 212 
 213       if ( table.Offset &gt; stream-&gt;size )
 214       {
 215         FT_TRACE2(( &quot;check_table_dir: table entry %d invalid\n&quot;, nn ));
 216         continue;
 217       }
 218       else if ( table.Length &gt; stream-&gt;size - table.Offset )
 219       {
 220         /* Some tables have such a simple structure that clipping its     */
 221         /* contents is harmless.  This also makes FreeType less sensitive */
 222         /* to invalid table lengths (which programs like Acroread seem to */
 223         /* ignore in general).                                            */
 224 
 225         if ( table.Tag == TTAG_hmtx ||
 226              table.Tag == TTAG_vmtx )
 227           valid_entries++;
 228         else
 229         {
 230           FT_TRACE2(( &quot;check_table_dir: table entry %d invalid\n&quot;, nn ));
 231           continue;
 232         }
 233       }
 234       else
 235         valid_entries++;
 236 
 237       if ( table.Tag == TTAG_head || table.Tag == TTAG_bhed )
 238       {
 239         FT_UInt32  magic;
 240 
 241 
 242 #ifndef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 243         if ( table.Tag == TTAG_head )
 244 #endif
 245           has_head = 1;
 246 
 247         /*
 248          * The table length should be 0x36, but certain font tools make it
 249          * 0x38, so we will just check that it is greater.
 250          *
 251          * Note that according to the specification, the table must be
 252          * padded to 32-bit lengths, but this doesn&#39;t apply to the value of
 253          * its `Length&#39; field!
 254          *
 255          */
 256         if ( table.Length &lt; 0x36 )
 257         {
 258           FT_TRACE2(( &quot;check_table_dir:&quot;
 259                       &quot; `head&#39; or `bhed&#39; table too small\n&quot; ));
 260           error = FT_THROW( Table_Missing );
 261           goto Exit;
 262         }
 263 
 264         if ( FT_STREAM_SEEK( table.Offset + 12 ) ||
 265              FT_READ_ULONG( magic )              )
 266           goto Exit;
 267 
 268         if ( magic != 0x5F0F3CF5UL )
 269           FT_TRACE2(( &quot;check_table_dir:&quot;
 270                       &quot; invalid magic number in `head&#39; or `bhed&#39; table\n&quot;));
 271 
 272         if ( FT_STREAM_SEEK( offset + ( nn + 1 ) * 16 ) )
 273           goto Exit;
 274       }
 275       else if ( table.Tag == TTAG_SING )
 276         has_sing = 1;
 277       else if ( table.Tag == TTAG_META )
 278         has_meta = 1;
 279     }
 280 
 281     *valid = valid_entries;
 282 
 283     if ( !valid_entries )
 284     {
 285       FT_TRACE2(( &quot;check_table_dir: no valid tables found\n&quot; ));
 286       error = FT_THROW( Unknown_File_Format );
 287       goto Exit;
 288     }
 289 
 290     /* if `sing&#39; and `meta&#39; tables are present, there is no `head&#39; table */
 291     if ( has_head || ( has_sing &amp;&amp; has_meta ) )
 292     {
 293       error = FT_Err_Ok;
 294       goto Exit;
 295     }
 296     else
 297     {
 298       FT_TRACE2(( &quot;check_table_dir:&quot; ));
 299 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 300       FT_TRACE2(( &quot; neither `head&#39;, `bhed&#39;, nor `sing&#39; table found\n&quot; ));
 301 #else
 302       FT_TRACE2(( &quot; neither `head&#39; nor `sing&#39; table found\n&quot; ));
 303 #endif
 304       error = FT_THROW( Table_Missing );
 305     }
 306 
 307   Exit:
 308     return error;
 309   }
 310 
 311 
<a name="5" id="anc5"></a><span class="line-modified"> 312   /*************************************************************************/</span>
<span class="line-modified"> 313   /*                                                                       */</span>
<span class="line-modified"> 314   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 315   /*    tt_face_load_font_dir                                              */</span>
<span class="line-modified"> 316   /*                                                                       */</span>
<span class="line-modified"> 317   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 318   /*    Loads the header of a SFNT font file.                              */</span>
<span class="line-modified"> 319   /*                                                                       */</span>
<span class="line-modified"> 320   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 321   /*    face       :: A handle to the target face object.                  */</span>
<span class="line-modified"> 322   /*                                                                       */</span>
<span class="line-modified"> 323   /*    stream     :: The input stream.                                    */</span>
<span class="line-modified"> 324   /*                                                                       */</span>
<span class="line-modified"> 325   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified"> 326   /*    sfnt       :: The SFNT header.                                     */</span>
<span class="line-modified"> 327   /*                                                                       */</span>
<span class="line-modified"> 328   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 329   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 330   /*                                                                       */</span>
<span class="line-modified"> 331   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 332   /*    The stream cursor must be at the beginning of the font directory.  */</span>
<span class="line-modified"> 333   /*                                                                       */</span>



 334   FT_LOCAL_DEF( FT_Error )
 335   tt_face_load_font_dir( TT_Face    face,
 336                          FT_Stream  stream )
 337   {
 338     SFNT_HeaderRec  sfnt;
 339     FT_Error        error;
 340     FT_Memory       memory = stream-&gt;memory;
 341     FT_UShort       nn, valid_entries = 0;
 342 
 343     static const FT_Frame_Field  offset_table_fields[] =
 344     {
 345 #undef  FT_STRUCTURE
 346 #define FT_STRUCTURE  SFNT_HeaderRec
 347 
 348       FT_FRAME_START( 8 ),
 349         FT_FRAME_USHORT( num_tables ),
 350         FT_FRAME_USHORT( search_range ),
 351         FT_FRAME_USHORT( entry_selector ),
 352         FT_FRAME_USHORT( range_shift ),
 353       FT_FRAME_END
 354     };
 355 
 356 
 357     FT_TRACE2(( &quot;tt_face_load_font_dir: %08p\n&quot;, face ));
 358 
 359     /* read the offset table */
 360 
 361     sfnt.offset = FT_STREAM_POS();
 362 
 363     if ( FT_READ_ULONG( sfnt.format_tag )                    ||
 364          FT_STREAM_READ_FIELDS( offset_table_fields, &amp;sfnt ) )
 365       goto Exit;
 366 
 367     /* many fonts don&#39;t have these fields set correctly */
 368 #if 0
 369     if ( sfnt.search_range != 1 &lt;&lt; ( sfnt.entry_selector + 4 )        ||
 370          sfnt.search_range + sfnt.range_shift != sfnt.num_tables &lt;&lt; 4 )
 371       return FT_THROW( Unknown_File_Format );
 372 #endif
 373 
 374     /* load the table directory */
 375 
 376     FT_TRACE2(( &quot;-- Number of tables: %10u\n&quot;,    sfnt.num_tables ));
 377     FT_TRACE2(( &quot;-- Format version:   0x%08lx\n&quot;, sfnt.format_tag ));
 378 
 379     if ( sfnt.format_tag != TTAG_OTTO )
 380     {
 381       /* check first */
 382       error = check_table_dir( &amp;sfnt, stream, &amp;valid_entries );
 383       if ( error )
 384       {
 385         FT_TRACE2(( &quot;tt_face_load_font_dir:&quot;
 386                     &quot; invalid table directory for TrueType\n&quot; ));
 387         goto Exit;
 388       }
 389     }
 390     else
 391       valid_entries = sfnt.num_tables;
 392 
 393     face-&gt;num_tables = valid_entries;
 394     face-&gt;format_tag = sfnt.format_tag;
 395 
 396     if ( FT_QNEW_ARRAY( face-&gt;dir_tables, face-&gt;num_tables ) )
 397       goto Exit;
 398 
 399     if ( FT_STREAM_SEEK( sfnt.offset + 12 )      ||
 400          FT_FRAME_ENTER( sfnt.num_tables * 16L ) )
 401       goto Exit;
 402 
 403     FT_TRACE2(( &quot;\n&quot;
 404                 &quot;  tag    offset    length   checksum\n&quot;
 405                 &quot;  ----------------------------------\n&quot; ));
 406 
 407     valid_entries = 0;
 408     for ( nn = 0; nn &lt; sfnt.num_tables; nn++ )
 409     {
 410       TT_TableRec  entry;
 411       FT_UShort    i;
 412       FT_Bool      duplicate;
 413 
 414 
 415       entry.Tag      = FT_GET_TAG4();
 416       entry.CheckSum = FT_GET_ULONG();
 417       entry.Offset   = FT_GET_ULONG();
 418       entry.Length   = FT_GET_ULONG();
 419 
 420       /* ignore invalid tables that can&#39;t be sanitized */
 421 
 422       if ( entry.Offset &gt; stream-&gt;size )
 423         continue;
 424       else if ( entry.Length &gt; stream-&gt;size - entry.Offset )
 425       {
 426         if ( entry.Tag == TTAG_hmtx ||
 427              entry.Tag == TTAG_vmtx )
 428         {
 429 #ifdef FT_DEBUG_LEVEL_TRACE
 430           FT_ULong  old_length = entry.Length;
 431 #endif
 432 
 433 
 434           /* make metrics table length a multiple of 4 */
 435           entry.Length = ( stream-&gt;size - entry.Offset ) &amp; ~3U;
 436 
 437           FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx&quot;
 438                       &quot; (sanitized; original length %08lx)&quot;,
 439                       (FT_Char)( entry.Tag &gt;&gt; 24 ),
 440                       (FT_Char)( entry.Tag &gt;&gt; 16 ),
 441                       (FT_Char)( entry.Tag &gt;&gt; 8  ),
 442                       (FT_Char)( entry.Tag       ),
 443                       entry.Offset,
 444                       entry.Length,
 445                       entry.CheckSum,
 446                       old_length ));
 447         }
 448         else
 449           continue;
 450       }
 451 #ifdef FT_DEBUG_LEVEL_TRACE
 452       else
 453         FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx&quot;,
 454                     (FT_Char)( entry.Tag &gt;&gt; 24 ),
 455                     (FT_Char)( entry.Tag &gt;&gt; 16 ),
 456                     (FT_Char)( entry.Tag &gt;&gt; 8  ),
 457                     (FT_Char)( entry.Tag       ),
 458                     entry.Offset,
 459                     entry.Length,
 460                     entry.CheckSum ));
 461 #endif
 462 
 463       /* ignore duplicate tables – the first one wins */
 464       duplicate = 0;
 465       for ( i = 0; i &lt; valid_entries; i++ )
 466       {
 467         if ( face-&gt;dir_tables[i].Tag == entry.Tag )
 468         {
 469           duplicate = 1;
 470           break;
 471         }
 472       }
 473       if ( duplicate )
 474       {
 475         FT_TRACE2(( &quot;  (duplicate, ignored)\n&quot; ));
 476         continue;
 477       }
 478       else
 479       {
 480         FT_TRACE2(( &quot;\n&quot; ));
 481 
 482         /* we finally have a valid entry */
 483         face-&gt;dir_tables[valid_entries++] = entry;
 484       }
 485     }
 486 
 487     /* final adjustment to number of tables */
 488     face-&gt;num_tables = valid_entries;
 489 
 490     FT_FRAME_EXIT();
 491 
 492     FT_TRACE2(( &quot;table directory loaded\n\n&quot; ));
 493 
 494   Exit:
 495     return error;
 496   }
 497 
 498 
<a name="6" id="anc6"></a><span class="line-modified"> 499   /*************************************************************************/</span>
<span class="line-modified"> 500   /*                                                                       */</span>
<span class="line-modified"> 501   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 502   /*    tt_face_load_any                                                   */</span>
<span class="line-modified"> 503   /*                                                                       */</span>
<span class="line-modified"> 504   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 505   /*    Loads any font table into client memory.                           */</span>
<span class="line-modified"> 506   /*                                                                       */</span>
<span class="line-modified"> 507   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 508   /*    face   :: The face object to look for.                             */</span>
<span class="line-modified"> 509   /*                                                                       */</span>
<span class="line-modified"> 510   /*    tag    :: The tag of table to load.  Use the value 0 if you want   */</span>
<span class="line-modified"> 511   /*              to access the whole font file, else set this parameter   */</span>
<span class="line-modified"> 512   /*              to a valid TrueType table tag that you can forge with    */</span>
<span class="line-modified"> 513   /*              the MAKE_TT_TAG macro.                                   */</span>
<span class="line-modified"> 514   /*                                                                       */</span>
<span class="line-modified"> 515   /*    offset :: The starting offset in the table (or the file if         */</span>
<span class="line-modified"> 516   /*              tag == 0).                                               */</span>
<span class="line-modified"> 517   /*                                                                       */</span>
<span class="line-modified"> 518   /*    length :: The address of the decision variable:                    */</span>
<span class="line-modified"> 519   /*                                                                       */</span>
<span class="line-modified"> 520   /*                If length == NULL:                                     */</span>
<span class="line-modified"> 521   /*                  Loads the whole table.  Returns an error if          */</span>
<span class="line-modified"> 522   /*                  `offset&#39; == 0!                                       */</span>
<span class="line-modified"> 523   /*                                                                       */</span>
<span class="line-modified"> 524   /*                If *length == 0:                                       */</span>
<span class="line-modified"> 525   /*                  Exits immediately; returning the length of the given */</span>
<span class="line-modified"> 526   /*                  table or of the font file, depending on the value of */</span>
<span class="line-modified"> 527   /*                  `tag&#39;.                                               */</span>
<span class="line-modified"> 528   /*                                                                       */</span>
<span class="line-modified"> 529   /*                If *length != 0:                                       */</span>
<span class="line-modified"> 530   /*                  Loads the next `length&#39; bytes of table or font,      */</span>
<span class="line-modified"> 531   /*                  starting at offset `offset&#39; (in table or font too).  */</span>
<span class="line-modified"> 532   /*                                                                       */</span>
<span class="line-modified"> 533   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified"> 534   /*    buffer :: The address of target buffer.                            */</span>
<span class="line-modified"> 535   /*                                                                       */</span>
<span class="line-modified"> 536   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 537   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 538   /*                                                                       */</span>





 539   FT_LOCAL_DEF( FT_Error )
 540   tt_face_load_any( TT_Face    face,
 541                     FT_ULong   tag,
 542                     FT_Long    offset,
 543                     FT_Byte*   buffer,
 544                     FT_ULong*  length )
 545   {
 546     FT_Error   error;
 547     FT_Stream  stream;
 548     TT_Table   table;
 549     FT_ULong   size;
 550 
 551 
 552     if ( tag != 0 )
 553     {
 554       /* look for tag in font directory */
 555       table = tt_face_lookup_table( face, tag );
 556       if ( !table )
 557       {
 558         error = FT_THROW( Table_Missing );
 559         goto Exit;
 560       }
 561 
 562       offset += table-&gt;Offset;
 563       size    = table-&gt;Length;
 564     }
 565     else
 566       /* tag == 0 -- the user wants to access the font file directly */
 567       size = face-&gt;root.stream-&gt;size;
 568 
 569     if ( length &amp;&amp; *length == 0 )
 570     {
 571       *length = size;
 572 
 573       return FT_Err_Ok;
 574     }
 575 
 576     if ( length )
 577       size = *length;
 578 
 579     stream = face-&gt;root.stream;
 580     /* the `if&#39; is syntactic sugar for picky compilers */
 581     if ( FT_STREAM_READ_AT( offset, buffer, size ) )
 582       goto Exit;
 583 
 584   Exit:
 585     return error;
 586   }
 587 
 588 
<a name="7" id="anc7"></a><span class="line-modified"> 589   /*************************************************************************/</span>
<span class="line-modified"> 590   /*                                                                       */</span>
<span class="line-modified"> 591   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 592   /*    tt_face_load_generic_header                                        */</span>
<span class="line-modified"> 593   /*                                                                       */</span>
<span class="line-modified"> 594   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 595   /*    Loads the TrueType table `head&#39; or `bhed&#39;.                         */</span>
<span class="line-modified"> 596   /*                                                                       */</span>
<span class="line-modified"> 597   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 598   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified"> 599   /*                                                                       */</span>
<span class="line-modified"> 600   /*    stream :: The input stream.                                        */</span>
<span class="line-modified"> 601   /*                                                                       */</span>
<span class="line-modified"> 602   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 603   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 604   /*                                                                       */</span>


 605   static FT_Error
 606   tt_face_load_generic_header( TT_Face    face,
 607                                FT_Stream  stream,
 608                                FT_ULong   tag )
 609   {
 610     FT_Error    error;
 611     TT_Header*  header;
 612 
 613     static const FT_Frame_Field  header_fields[] =
 614     {
 615 #undef  FT_STRUCTURE
 616 #define FT_STRUCTURE  TT_Header
 617 
 618       FT_FRAME_START( 54 ),
 619         FT_FRAME_ULONG ( Table_Version ),
 620         FT_FRAME_ULONG ( Font_Revision ),
 621         FT_FRAME_LONG  ( CheckSum_Adjust ),
 622         FT_FRAME_LONG  ( Magic_Number ),
 623         FT_FRAME_USHORT( Flags ),
 624         FT_FRAME_USHORT( Units_Per_EM ),
<a name="8" id="anc8"></a><span class="line-modified"> 625         FT_FRAME_LONG  ( Created[0] ),</span>
<span class="line-modified"> 626         FT_FRAME_LONG  ( Created[1] ),</span>
<span class="line-modified"> 627         FT_FRAME_LONG  ( Modified[0] ),</span>
<span class="line-modified"> 628         FT_FRAME_LONG  ( Modified[1] ),</span>
 629         FT_FRAME_SHORT ( xMin ),
 630         FT_FRAME_SHORT ( yMin ),
 631         FT_FRAME_SHORT ( xMax ),
 632         FT_FRAME_SHORT ( yMax ),
 633         FT_FRAME_USHORT( Mac_Style ),
 634         FT_FRAME_USHORT( Lowest_Rec_PPEM ),
 635         FT_FRAME_SHORT ( Font_Direction ),
 636         FT_FRAME_SHORT ( Index_To_Loc_Format ),
 637         FT_FRAME_SHORT ( Glyph_Data_Format ),
 638       FT_FRAME_END
 639     };
 640 
 641 
 642     error = face-&gt;goto_table( face, tag, stream, 0 );
 643     if ( error )
 644       goto Exit;
 645 
 646     header = &amp;face-&gt;header;
 647 
 648     if ( FT_STREAM_READ_FIELDS( header_fields, header ) )
 649       goto Exit;
 650 
 651     FT_TRACE3(( &quot;Units per EM: %4u\n&quot;, header-&gt;Units_Per_EM ));
 652     FT_TRACE3(( &quot;IndexToLoc:   %4d\n&quot;, header-&gt;Index_To_Loc_Format ));
 653 
 654   Exit:
 655     return error;
 656   }
 657 
 658 
 659   FT_LOCAL_DEF( FT_Error )
 660   tt_face_load_head( TT_Face    face,
 661                      FT_Stream  stream )
 662   {
 663     return tt_face_load_generic_header( face, stream, TTAG_head );
 664   }
 665 
 666 
 667 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 668 
 669   FT_LOCAL_DEF( FT_Error )
 670   tt_face_load_bhed( TT_Face    face,
 671                      FT_Stream  stream )
 672   {
 673     return tt_face_load_generic_header( face, stream, TTAG_bhed );
 674   }
 675 
 676 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
 677 
 678 
<a name="9" id="anc9"></a><span class="line-modified"> 679   /*************************************************************************/</span>
<span class="line-modified"> 680   /*                                                                       */</span>
<span class="line-modified"> 681   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 682   /*    tt_face_load_maxp                                                  */</span>
<span class="line-modified"> 683   /*                                                                       */</span>
<span class="line-modified"> 684   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 685   /*    Loads the maximum profile into a face object.                      */</span>
<span class="line-modified"> 686   /*                                                                       */</span>
<span class="line-modified"> 687   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 688   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified"> 689   /*                                                                       */</span>
<span class="line-modified"> 690   /*    stream :: The input stream.                                        */</span>
<span class="line-modified"> 691   /*                                                                       */</span>
<span class="line-modified"> 692   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 693   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 694   /*                                                                       */</span>


 695   FT_LOCAL_DEF( FT_Error )
 696   tt_face_load_maxp( TT_Face    face,
 697                      FT_Stream  stream )
 698   {
 699     FT_Error        error;
 700     TT_MaxProfile*  maxProfile = &amp;face-&gt;max_profile;
 701 
 702     static const FT_Frame_Field  maxp_fields[] =
 703     {
 704 #undef  FT_STRUCTURE
 705 #define FT_STRUCTURE  TT_MaxProfile
 706 
 707       FT_FRAME_START( 6 ),
 708         FT_FRAME_LONG  ( version ),
 709         FT_FRAME_USHORT( numGlyphs ),
 710       FT_FRAME_END
 711     };
 712 
 713     static const FT_Frame_Field  maxp_fields_extra[] =
 714     {
 715       FT_FRAME_START( 26 ),
 716         FT_FRAME_USHORT( maxPoints ),
 717         FT_FRAME_USHORT( maxContours ),
 718         FT_FRAME_USHORT( maxCompositePoints ),
 719         FT_FRAME_USHORT( maxCompositeContours ),
 720         FT_FRAME_USHORT( maxZones ),
 721         FT_FRAME_USHORT( maxTwilightPoints ),
 722         FT_FRAME_USHORT( maxStorage ),
 723         FT_FRAME_USHORT( maxFunctionDefs ),
 724         FT_FRAME_USHORT( maxInstructionDefs ),
 725         FT_FRAME_USHORT( maxStackElements ),
 726         FT_FRAME_USHORT( maxSizeOfInstructions ),
 727         FT_FRAME_USHORT( maxComponentElements ),
 728         FT_FRAME_USHORT( maxComponentDepth ),
 729       FT_FRAME_END
 730     };
 731 
 732 
 733     error = face-&gt;goto_table( face, TTAG_maxp, stream, 0 );
 734     if ( error )
 735       goto Exit;
 736 
 737     if ( FT_STREAM_READ_FIELDS( maxp_fields, maxProfile ) )
 738       goto Exit;
 739 
 740     maxProfile-&gt;maxPoints             = 0;
 741     maxProfile-&gt;maxContours           = 0;
 742     maxProfile-&gt;maxCompositePoints    = 0;
 743     maxProfile-&gt;maxCompositeContours  = 0;
 744     maxProfile-&gt;maxZones              = 0;
 745     maxProfile-&gt;maxTwilightPoints     = 0;
 746     maxProfile-&gt;maxStorage            = 0;
 747     maxProfile-&gt;maxFunctionDefs       = 0;
 748     maxProfile-&gt;maxInstructionDefs    = 0;
 749     maxProfile-&gt;maxStackElements      = 0;
 750     maxProfile-&gt;maxSizeOfInstructions = 0;
 751     maxProfile-&gt;maxComponentElements  = 0;
 752     maxProfile-&gt;maxComponentDepth     = 0;
 753 
 754     if ( maxProfile-&gt;version &gt;= 0x10000L )
 755     {
 756       if ( FT_STREAM_READ_FIELDS( maxp_fields_extra, maxProfile ) )
 757         goto Exit;
 758 
 759       /* XXX: an adjustment that is necessary to load certain */
 760       /*      broken fonts like `Keystrokes MT&#39; :-(           */
 761       /*                                                      */
 762       /*   We allocate 64 function entries by default when    */
 763       /*   the maxFunctionDefs value is smaller.              */
 764 
 765       if ( maxProfile-&gt;maxFunctionDefs &lt; 64 )
 766         maxProfile-&gt;maxFunctionDefs = 64;
 767 
 768       /* we add 4 phantom points later */
 769       if ( maxProfile-&gt;maxTwilightPoints &gt; ( 0xFFFFU - 4 ) )
 770       {
 771         FT_TRACE0(( &quot;tt_face_load_maxp:&quot;
 772                     &quot; too much twilight points in `maxp&#39; table;\n&quot;
 773                     &quot;                  &quot;
 774                     &quot; some glyphs might be rendered incorrectly\n&quot; ));
 775 
 776         maxProfile-&gt;maxTwilightPoints = 0xFFFFU - 4;
 777       }
 778     }
 779 
 780     FT_TRACE3(( &quot;numGlyphs: %u\n&quot;, maxProfile-&gt;numGlyphs ));
 781 
 782   Exit:
 783     return error;
 784   }
 785 
 786 
<a name="10" id="anc10"></a><span class="line-modified"> 787   /*************************************************************************/</span>
<span class="line-modified"> 788   /*                                                                       */</span>
<span class="line-modified"> 789   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 790   /*    tt_face_load_name                                                  */</span>
<span class="line-modified"> 791   /*                                                                       */</span>
<span class="line-modified"> 792   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 793   /*    Loads the name records.                                            */</span>
<span class="line-modified"> 794   /*                                                                       */</span>
<span class="line-modified"> 795   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 796   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified"> 797   /*                                                                       */</span>
<span class="line-modified"> 798   /*    stream :: The input stream.                                        */</span>
<span class="line-modified"> 799   /*                                                                       */</span>
<span class="line-modified"> 800   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 801   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 802   /*                                                                       */</span>


 803   FT_LOCAL_DEF( FT_Error )
 804   tt_face_load_name( TT_Face    face,
 805                      FT_Stream  stream )
 806   {
 807     FT_Error      error;
 808     FT_Memory     memory = stream-&gt;memory;
 809     FT_ULong      table_pos, table_len;
 810     FT_ULong      storage_start, storage_limit;
 811     TT_NameTable  table;
 812 
 813     static const FT_Frame_Field  name_table_fields[] =
 814     {
 815 #undef  FT_STRUCTURE
 816 #define FT_STRUCTURE  TT_NameTableRec
 817 
 818       FT_FRAME_START( 6 ),
 819         FT_FRAME_USHORT( format ),
 820         FT_FRAME_USHORT( numNameRecords ),
 821         FT_FRAME_USHORT( storageOffset ),
 822       FT_FRAME_END
 823     };
 824 
 825     static const FT_Frame_Field  name_record_fields[] =
 826     {
 827 #undef  FT_STRUCTURE
 828 #define FT_STRUCTURE  TT_NameRec
 829 
 830       /* no FT_FRAME_START */
 831         FT_FRAME_USHORT( platformID ),
 832         FT_FRAME_USHORT( encodingID ),
 833         FT_FRAME_USHORT( languageID ),
 834         FT_FRAME_USHORT( nameID ),
 835         FT_FRAME_USHORT( stringLength ),
 836         FT_FRAME_USHORT( stringOffset ),
 837       FT_FRAME_END
 838     };
 839 
 840     static const FT_Frame_Field  langTag_record_fields[] =
 841     {
 842 #undef  FT_STRUCTURE
 843 #define FT_STRUCTURE  TT_LangTagRec
 844 
 845       /* no FT_FRAME_START */
 846         FT_FRAME_USHORT( stringLength ),
 847         FT_FRAME_USHORT( stringOffset ),
 848       FT_FRAME_END
 849     };
 850 
 851 
 852     table         = &amp;face-&gt;name_table;
 853     table-&gt;stream = stream;
 854 
 855     error = face-&gt;goto_table( face, TTAG_name, stream, &amp;table_len );
 856     if ( error )
 857       goto Exit;
 858 
 859     table_pos = FT_STREAM_POS();
 860 
 861     if ( FT_STREAM_READ_FIELDS( name_table_fields, table ) )
 862       goto Exit;
 863 
 864     /* Some popular Asian fonts have an invalid `storageOffset&#39; value (it */
 865     /* should be at least `6 + 12*numNameRecords&#39;).  However, the string  */
 866     /* offsets, computed as `storageOffset + entry-&gt;stringOffset&#39;, are    */
 867     /* valid pointers within the name table...                            */
 868     /*                                                                    */
 869     /* We thus can&#39;t check `storageOffset&#39; right now.                     */
 870     /*                                                                    */
 871     storage_start = table_pos + 6 + 12 * table-&gt;numNameRecords;
 872     storage_limit = table_pos + table_len;
 873 
 874     if ( storage_start &gt; storage_limit )
 875     {
 876       FT_ERROR(( &quot;tt_face_load_name: invalid `name&#39; table\n&quot; ));
 877       error = FT_THROW( Name_Table_Missing );
 878       goto Exit;
 879     }
 880 
 881     /* `name&#39; format 1 contains additional language tag records, */
 882     /* which we load first                                       */
 883     if ( table-&gt;format == 1 )
 884     {
 885       if ( FT_STREAM_SEEK( storage_start )            ||
 886            FT_READ_USHORT( table-&gt;numLangTagRecords ) )
 887         goto Exit;
 888 
 889       storage_start += 2 + 4 * table-&gt;numLangTagRecords;
 890 
 891       /* allocate language tag records array */
 892       if ( FT_NEW_ARRAY( table-&gt;langTags, table-&gt;numLangTagRecords ) ||
 893            FT_FRAME_ENTER( table-&gt;numLangTagRecords * 4 )            )
 894         goto Exit;
 895 
 896       /* load language tags */
 897       {
 898         TT_LangTag  entry = table-&gt;langTags;
 899         TT_LangTag  limit = entry + table-&gt;numLangTagRecords;
 900 
 901 
 902         for ( ; entry &lt; limit; entry++ )
 903         {
 904           (void)FT_STREAM_READ_FIELDS( langTag_record_fields, entry );
 905 
 906           /* check that the langTag string is within the table */
 907           entry-&gt;stringOffset += table_pos + table-&gt;storageOffset;
 908           if ( entry-&gt;stringOffset                       &lt; storage_start ||
 909                entry-&gt;stringOffset + entry-&gt;stringLength &gt; storage_limit )
 910           {
 911             /* invalid entry; ignore it */
 912             entry-&gt;stringLength = 0;
 913           }
 914         }
 915       }
 916 
 917       FT_FRAME_EXIT();
 918 
 919       (void)FT_STREAM_SEEK( table_pos + 6 );
 920     }
 921 
 922     /* allocate name records array */
 923     if ( FT_NEW_ARRAY( table-&gt;names, table-&gt;numNameRecords ) ||
 924          FT_FRAME_ENTER( table-&gt;numNameRecords * 12 )        )
 925       goto Exit;
 926 
 927     /* load name records */
 928     {
 929       TT_Name  entry = table-&gt;names;
 930       FT_UInt  count = table-&gt;numNameRecords;
 931 
 932 
 933       for ( ; count &gt; 0; count-- )
 934       {
 935         if ( FT_STREAM_READ_FIELDS( name_record_fields, entry ) )
 936           continue;
 937 
 938         /* check that the name is not empty */
 939         if ( entry-&gt;stringLength == 0 )
 940           continue;
 941 
 942         /* check that the name string is within the table */
 943         entry-&gt;stringOffset += table_pos + table-&gt;storageOffset;
 944         if ( entry-&gt;stringOffset                       &lt; storage_start ||
 945              entry-&gt;stringOffset + entry-&gt;stringLength &gt; storage_limit )
 946         {
 947           /* invalid entry; ignore it */
 948           continue;
 949         }
 950 
 951         /* assure that we have a valid language tag ID, and   */
 952         /* that the corresponding langTag entry is valid, too */
 953         if ( table-&gt;format == 1 &amp;&amp; entry-&gt;languageID &gt;= 0x8000U )
 954         {
 955           if ( entry-&gt;languageID - 0x8000U &gt;= table-&gt;numLangTagRecords    ||
 956                !table-&gt;langTags[entry-&gt;languageID - 0x8000U].stringLength )
 957           {
 958             /* invalid entry; ignore it */
 959             continue;
 960           }
 961         }
 962 
 963         entry++;
 964       }
 965 
 966       /* reduce array size to the actually used elements */
 967       count = (FT_UInt)( entry - table-&gt;names );
 968       (void)FT_RENEW_ARRAY( table-&gt;names,
 969                             table-&gt;numNameRecords,
 970                             count );
 971       table-&gt;numNameRecords = count;
 972     }
 973 
 974     FT_FRAME_EXIT();
 975 
 976     /* everything went well, update face-&gt;num_names */
 977     face-&gt;num_names = (FT_UShort)table-&gt;numNameRecords;
 978 
 979   Exit:
 980     return error;
 981   }
 982 
 983 
<a name="11" id="anc11"></a><span class="line-modified"> 984   /*************************************************************************/</span>
<span class="line-modified"> 985   /*                                                                       */</span>
<span class="line-modified"> 986   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 987   /*    tt_face_free_name                                                  */</span>
<span class="line-modified"> 988   /*                                                                       */</span>
<span class="line-modified"> 989   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 990   /*    Frees the name records.                                            */</span>
<span class="line-modified"> 991   /*                                                                       */</span>
<span class="line-modified"> 992   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 993   /*    face :: A handle to the target face object.                        */</span>
<span class="line-modified"> 994   /*                                                                       */</span>

 995   FT_LOCAL_DEF( void )
 996   tt_face_free_name( TT_Face  face )
 997   {
 998     FT_Memory     memory = face-&gt;root.driver-&gt;root.memory;
 999     TT_NameTable  table  = &amp;face-&gt;name_table;
1000 
1001 
1002     if ( table-&gt;names )
1003     {
1004       TT_Name  entry = table-&gt;names;
1005       TT_Name  limit = entry + table-&gt;numNameRecords;
1006 
1007 
1008       for ( ; entry &lt; limit; entry++ )
1009         FT_FREE( entry-&gt;string );
1010 
1011       FT_FREE( table-&gt;names );
1012     }
1013 
1014     if ( table-&gt;langTags )
1015     {
1016       TT_LangTag  entry = table-&gt;langTags;
1017       TT_LangTag  limit = entry + table-&gt;numLangTagRecords;
1018 
1019 
1020       for ( ; entry &lt; limit; entry++ )
1021         FT_FREE( entry-&gt;string );
1022 
1023       FT_FREE( table-&gt;langTags );
1024     }
1025 
1026     table-&gt;numNameRecords    = 0;
1027     table-&gt;numLangTagRecords = 0;
1028     table-&gt;format            = 0;
1029     table-&gt;storageOffset     = 0;
1030   }
1031 
1032 
<a name="12" id="anc12"></a><span class="line-modified">1033   /*************************************************************************/</span>
<span class="line-modified">1034   /*                                                                       */</span>
<span class="line-modified">1035   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1036   /*    tt_face_load_cmap                                                  */</span>
<span class="line-modified">1037   /*                                                                       */</span>
<span class="line-modified">1038   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1039   /*    Loads the cmap directory in a face object.  The cmaps themselves   */</span>
<span class="line-modified">1040   /*    are loaded on demand in the `ttcmap.c&#39; module.                     */</span>
<span class="line-modified">1041   /*                                                                       */</span>
<span class="line-modified">1042   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1043   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">1044   /*                                                                       */</span>
<span class="line-modified">1045   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">1046   /*                                                                       */</span>
<span class="line-modified">1047   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1048   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1049   /*                                                                       */</span>


1050 
1051   FT_LOCAL_DEF( FT_Error )
1052   tt_face_load_cmap( TT_Face    face,
1053                      FT_Stream  stream )
1054   {
1055     FT_Error  error;
1056 
1057 
1058     error = face-&gt;goto_table( face, TTAG_cmap, stream, &amp;face-&gt;cmap_size );
1059     if ( error )
1060       goto Exit;
1061 
1062     if ( FT_FRAME_EXTRACT( face-&gt;cmap_size, face-&gt;cmap_table ) )
1063       face-&gt;cmap_size = 0;
1064 
1065   Exit:
1066     return error;
1067   }
1068 
1069 
1070 
<a name="13" id="anc13"></a><span class="line-modified">1071   /*************************************************************************/</span>
<span class="line-modified">1072   /*                                                                       */</span>
<span class="line-modified">1073   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1074   /*    tt_face_load_os2                                                   */</span>
<span class="line-modified">1075   /*                                                                       */</span>
<span class="line-modified">1076   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1077   /*    Loads the OS2 table.                                               */</span>
<span class="line-modified">1078   /*                                                                       */</span>
<span class="line-modified">1079   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1080   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">1081   /*                                                                       */</span>
<span class="line-modified">1082   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">1083   /*                                                                       */</span>
<span class="line-modified">1084   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1085   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1086   /*                                                                       */</span>


1087   FT_LOCAL_DEF( FT_Error )
1088   tt_face_load_os2( TT_Face    face,
1089                     FT_Stream  stream )
1090   {
1091     FT_Error  error;
1092     TT_OS2*   os2;
1093 
1094     static const FT_Frame_Field  os2_fields[] =
1095     {
1096 #undef  FT_STRUCTURE
1097 #define FT_STRUCTURE  TT_OS2
1098 
1099       FT_FRAME_START( 78 ),
1100         FT_FRAME_USHORT( version ),
1101         FT_FRAME_SHORT ( xAvgCharWidth ),
1102         FT_FRAME_USHORT( usWeightClass ),
1103         FT_FRAME_USHORT( usWidthClass ),
1104         FT_FRAME_SHORT ( fsType ),
1105         FT_FRAME_SHORT ( ySubscriptXSize ),
1106         FT_FRAME_SHORT ( ySubscriptYSize ),
1107         FT_FRAME_SHORT ( ySubscriptXOffset ),
1108         FT_FRAME_SHORT ( ySubscriptYOffset ),
1109         FT_FRAME_SHORT ( ySuperscriptXSize ),
1110         FT_FRAME_SHORT ( ySuperscriptYSize ),
1111         FT_FRAME_SHORT ( ySuperscriptXOffset ),
1112         FT_FRAME_SHORT ( ySuperscriptYOffset ),
1113         FT_FRAME_SHORT ( yStrikeoutSize ),
1114         FT_FRAME_SHORT ( yStrikeoutPosition ),
1115         FT_FRAME_SHORT ( sFamilyClass ),
1116         FT_FRAME_BYTE  ( panose[0] ),
1117         FT_FRAME_BYTE  ( panose[1] ),
1118         FT_FRAME_BYTE  ( panose[2] ),
1119         FT_FRAME_BYTE  ( panose[3] ),
1120         FT_FRAME_BYTE  ( panose[4] ),
1121         FT_FRAME_BYTE  ( panose[5] ),
1122         FT_FRAME_BYTE  ( panose[6] ),
1123         FT_FRAME_BYTE  ( panose[7] ),
1124         FT_FRAME_BYTE  ( panose[8] ),
1125         FT_FRAME_BYTE  ( panose[9] ),
1126         FT_FRAME_ULONG ( ulUnicodeRange1 ),
1127         FT_FRAME_ULONG ( ulUnicodeRange2 ),
1128         FT_FRAME_ULONG ( ulUnicodeRange3 ),
1129         FT_FRAME_ULONG ( ulUnicodeRange4 ),
1130         FT_FRAME_BYTE  ( achVendID[0] ),
1131         FT_FRAME_BYTE  ( achVendID[1] ),
1132         FT_FRAME_BYTE  ( achVendID[2] ),
1133         FT_FRAME_BYTE  ( achVendID[3] ),
1134 
1135         FT_FRAME_USHORT( fsSelection ),
1136         FT_FRAME_USHORT( usFirstCharIndex ),
1137         FT_FRAME_USHORT( usLastCharIndex ),
1138         FT_FRAME_SHORT ( sTypoAscender ),
1139         FT_FRAME_SHORT ( sTypoDescender ),
1140         FT_FRAME_SHORT ( sTypoLineGap ),
1141         FT_FRAME_USHORT( usWinAscent ),
1142         FT_FRAME_USHORT( usWinDescent ),
1143       FT_FRAME_END
1144     };
1145 
1146     /* `OS/2&#39; version 1 and newer */
1147     static const FT_Frame_Field  os2_fields_extra1[] =
1148     {
1149       FT_FRAME_START( 8 ),
1150         FT_FRAME_ULONG( ulCodePageRange1 ),
1151         FT_FRAME_ULONG( ulCodePageRange2 ),
1152       FT_FRAME_END
1153     };
1154 
1155     /* `OS/2&#39; version 2 and newer */
1156     static const FT_Frame_Field  os2_fields_extra2[] =
1157     {
1158       FT_FRAME_START( 10 ),
1159         FT_FRAME_SHORT ( sxHeight ),
1160         FT_FRAME_SHORT ( sCapHeight ),
1161         FT_FRAME_USHORT( usDefaultChar ),
1162         FT_FRAME_USHORT( usBreakChar ),
1163         FT_FRAME_USHORT( usMaxContext ),
1164       FT_FRAME_END
1165     };
1166 
1167     /* `OS/2&#39; version 5 and newer */
1168     static const FT_Frame_Field  os2_fields_extra5[] =
1169     {
1170       FT_FRAME_START( 4 ),
1171         FT_FRAME_USHORT( usLowerOpticalPointSize ),
1172         FT_FRAME_USHORT( usUpperOpticalPointSize ),
1173       FT_FRAME_END
1174     };
1175 
1176 
1177     /* We now support old Mac fonts where the OS/2 table doesn&#39;t  */
1178     /* exist.  Simply put, we set the `version&#39; field to 0xFFFF   */
1179     /* and test this value each time we need to access the table. */
1180     error = face-&gt;goto_table( face, TTAG_OS2, stream, 0 );
1181     if ( error )
1182       goto Exit;
1183 
1184     os2 = &amp;face-&gt;os2;
1185 
1186     if ( FT_STREAM_READ_FIELDS( os2_fields, os2 ) )
1187       goto Exit;
1188 
1189     os2-&gt;ulCodePageRange1        = 0;
1190     os2-&gt;ulCodePageRange2        = 0;
1191     os2-&gt;sxHeight                = 0;
1192     os2-&gt;sCapHeight              = 0;
1193     os2-&gt;usDefaultChar           = 0;
1194     os2-&gt;usBreakChar             = 0;
1195     os2-&gt;usMaxContext            = 0;
1196     os2-&gt;usLowerOpticalPointSize = 0;
1197     os2-&gt;usUpperOpticalPointSize = 0xFFFF;
1198 
1199     if ( os2-&gt;version &gt;= 0x0001 )
1200     {
1201       /* only version 1 tables */
1202       if ( FT_STREAM_READ_FIELDS( os2_fields_extra1, os2 ) )
1203         goto Exit;
1204 
1205       if ( os2-&gt;version &gt;= 0x0002 )
1206       {
1207         /* only version 2 tables */
1208         if ( FT_STREAM_READ_FIELDS( os2_fields_extra2, os2 ) )
1209           goto Exit;
1210 
1211         if ( os2-&gt;version &gt;= 0x0005 )
1212         {
1213           /* only version 5 tables */
1214           if ( FT_STREAM_READ_FIELDS( os2_fields_extra5, os2 ) )
1215             goto Exit;
1216         }
1217       }
1218     }
1219 
1220     FT_TRACE3(( &quot;sTypoAscender:  %4d\n&quot;,   os2-&gt;sTypoAscender ));
1221     FT_TRACE3(( &quot;sTypoDescender: %4d\n&quot;,   os2-&gt;sTypoDescender ));
1222     FT_TRACE3(( &quot;usWinAscent:    %4u\n&quot;,   os2-&gt;usWinAscent ));
1223     FT_TRACE3(( &quot;usWinDescent:   %4u\n&quot;,   os2-&gt;usWinDescent ));
1224     FT_TRACE3(( &quot;fsSelection:    0x%2x\n&quot;, os2-&gt;fsSelection ));
1225 
1226   Exit:
1227     return error;
1228   }
1229 
1230 
<a name="14" id="anc14"></a><span class="line-modified">1231   /*************************************************************************/</span>
<span class="line-modified">1232   /*                                                                       */</span>
<span class="line-modified">1233   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1234   /*    tt_face_load_postscript                                            */</span>
<span class="line-modified">1235   /*                                                                       */</span>
<span class="line-modified">1236   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1237   /*    Loads the Postscript table.                                        */</span>
<span class="line-modified">1238   /*                                                                       */</span>
<span class="line-modified">1239   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1240   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">1241   /*                                                                       */</span>
<span class="line-modified">1242   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">1243   /*                                                                       */</span>
<span class="line-modified">1244   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1245   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1246   /*                                                                       */</span>


1247   FT_LOCAL_DEF( FT_Error )
1248   tt_face_load_post( TT_Face    face,
1249                      FT_Stream  stream )
1250   {
1251     FT_Error        error;
1252     TT_Postscript*  post = &amp;face-&gt;postscript;
1253 
1254     static const FT_Frame_Field  post_fields[] =
1255     {
1256 #undef  FT_STRUCTURE
1257 #define FT_STRUCTURE  TT_Postscript
1258 
1259       FT_FRAME_START( 32 ),
1260         FT_FRAME_LONG ( FormatType ),
1261         FT_FRAME_LONG ( italicAngle ),
1262         FT_FRAME_SHORT( underlinePosition ),
1263         FT_FRAME_SHORT( underlineThickness ),
1264         FT_FRAME_ULONG( isFixedPitch ),
1265         FT_FRAME_ULONG( minMemType42 ),
1266         FT_FRAME_ULONG( maxMemType42 ),
1267         FT_FRAME_ULONG( minMemType1 ),
1268         FT_FRAME_ULONG( maxMemType1 ),
1269       FT_FRAME_END
1270     };
1271 
1272 
1273     error = face-&gt;goto_table( face, TTAG_post, stream, 0 );
1274     if ( error )
1275       return error;
1276 
1277     if ( FT_STREAM_READ_FIELDS( post_fields, post ) )
1278       return error;
1279 
1280     /* we don&#39;t load the glyph names, we do that in another */
1281     /* module (ttpost).                                     */
1282 
1283     FT_TRACE3(( &quot;FormatType:   0x%x\n&quot;, post-&gt;FormatType ));
1284     FT_TRACE3(( &quot;isFixedPitch:   %s\n&quot;, post-&gt;isFixedPitch
1285                                         ? &quot;  yes&quot; : &quot;   no&quot; ));
1286 
1287     return FT_Err_Ok;
1288   }
1289 
1290 
<a name="15" id="anc15"></a><span class="line-modified">1291   /*************************************************************************/</span>
<span class="line-modified">1292   /*                                                                       */</span>
<span class="line-modified">1293   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1294   /*    tt_face_load_pclt                                                  */</span>
<span class="line-modified">1295   /*                                                                       */</span>
<span class="line-modified">1296   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1297   /*    Loads the PCL 5 Table.                                             */</span>
<span class="line-modified">1298   /*                                                                       */</span>
<span class="line-modified">1299   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1300   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">1301   /*                                                                       */</span>
<span class="line-modified">1302   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">1303   /*                                                                       */</span>
<span class="line-modified">1304   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1305   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1306   /*                                                                       */</span>


1307   FT_LOCAL_DEF( FT_Error )
1308   tt_face_load_pclt( TT_Face    face,
1309                      FT_Stream  stream )
1310   {
1311     static const FT_Frame_Field  pclt_fields[] =
1312     {
1313 #undef  FT_STRUCTURE
1314 #define FT_STRUCTURE  TT_PCLT
1315 
1316       FT_FRAME_START( 54 ),
1317         FT_FRAME_ULONG ( Version ),
1318         FT_FRAME_ULONG ( FontNumber ),
1319         FT_FRAME_USHORT( Pitch ),
1320         FT_FRAME_USHORT( xHeight ),
1321         FT_FRAME_USHORT( Style ),
1322         FT_FRAME_USHORT( TypeFamily ),
1323         FT_FRAME_USHORT( CapHeight ),
1324         FT_FRAME_USHORT( SymbolSet ),
1325         FT_FRAME_BYTES ( TypeFace, 16 ),
1326         FT_FRAME_BYTES ( CharacterComplement, 8 ),
1327         FT_FRAME_BYTES ( FileName, 6 ),
1328         FT_FRAME_CHAR  ( StrokeWeight ),
1329         FT_FRAME_CHAR  ( WidthType ),
1330         FT_FRAME_BYTE  ( SerifStyle ),
1331         FT_FRAME_BYTE  ( Reserved ),
1332       FT_FRAME_END
1333     };
1334 
1335     FT_Error  error;
1336     TT_PCLT*  pclt = &amp;face-&gt;pclt;
1337 
1338 
1339     /* optional table */
1340     error = face-&gt;goto_table( face, TTAG_PCLT, stream, 0 );
1341     if ( error )
1342       goto Exit;
1343 
1344     if ( FT_STREAM_READ_FIELDS( pclt_fields, pclt ) )
1345       goto Exit;
1346 
1347   Exit:
1348     return error;
1349   }
1350 
1351 
<a name="16" id="anc16"></a><span class="line-modified">1352   /*************************************************************************/</span>
<span class="line-modified">1353   /*                                                                       */</span>
<span class="line-modified">1354   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1355   /*    tt_face_load_gasp                                                  */</span>
<span class="line-modified">1356   /*                                                                       */</span>
<span class="line-modified">1357   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1358   /*    Loads the `gasp&#39; table into a face object.                         */</span>
<span class="line-modified">1359   /*                                                                       */</span>
<span class="line-modified">1360   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1361   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">1362   /*                                                                       */</span>
<span class="line-modified">1363   /*    stream :: The input stream.                                        */</span>
<span class="line-modified">1364   /*                                                                       */</span>
<span class="line-modified">1365   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1366   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1367   /*                                                                       */</span>


1368   FT_LOCAL_DEF( FT_Error )
1369   tt_face_load_gasp( TT_Face    face,
1370                      FT_Stream  stream )
1371   {
1372     FT_Error   error;
1373     FT_Memory  memory = stream-&gt;memory;
1374 
1375     FT_UInt        j,num_ranges;
1376     TT_GaspRange   gaspranges = NULL;
1377 
1378 
1379     /* the gasp table is optional */
1380     error = face-&gt;goto_table( face, TTAG_gasp, stream, 0 );
1381     if ( error )
1382       goto Exit;
1383 
1384     if ( FT_FRAME_ENTER( 4L ) )
1385       goto Exit;
1386 
1387     face-&gt;gasp.version   = FT_GET_USHORT();
1388     face-&gt;gasp.numRanges = FT_GET_USHORT();
1389 
1390     FT_FRAME_EXIT();
1391 
1392     /* only support versions 0 and 1 of the table */
1393     if ( face-&gt;gasp.version &gt;= 2 )
1394     {
1395       face-&gt;gasp.numRanges = 0;
1396       error = FT_THROW( Invalid_Table );
1397       goto Exit;
1398     }
1399 
1400     num_ranges = face-&gt;gasp.numRanges;
1401     FT_TRACE3(( &quot;numRanges: %u\n&quot;, num_ranges ));
1402 
1403     if ( FT_QNEW_ARRAY( face-&gt;gasp.gaspRanges, num_ranges ) ||
1404          FT_FRAME_ENTER( num_ranges * 4L )                  )
1405       goto Exit;
1406 
1407     gaspranges = face-&gt;gasp.gaspRanges;
1408 
1409     for ( j = 0; j &lt; num_ranges; j++ )
1410     {
1411       gaspranges[j].maxPPEM  = FT_GET_USHORT();
1412       gaspranges[j].gaspFlag = FT_GET_USHORT();
1413 
1414       FT_TRACE3(( &quot;gaspRange %d: rangeMaxPPEM %5d, rangeGaspBehavior 0x%x\n&quot;,
1415                   j,
1416                   gaspranges[j].maxPPEM,
1417                   gaspranges[j].gaspFlag ));
1418     }
1419 
1420     FT_FRAME_EXIT();
1421 
1422   Exit:
1423     return error;
1424   }
1425 
1426 
1427 /* END */
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
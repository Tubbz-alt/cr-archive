<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/type1/t1objs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  t1objs.c                                                               */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Type 1 objects manager (body).                                       */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_CALC_H
 21 #include FT_INTERNAL_DEBUG_H
 22 #include FT_INTERNAL_STREAM_H
 23 #include FT_TRUETYPE_IDS_H
 24 #include FT_DRIVER_H
 25 
 26 #include &quot;t1gload.h&quot;
 27 #include &quot;t1load.h&quot;
 28 
 29 #include &quot;t1errors.h&quot;
 30 
 31 #ifndef T1_CONFIG_OPTION_NO_AFM
 32 #include &quot;t1afm.h&quot;
 33 #endif
 34 
 35 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 36 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 37 
 38 
<a name="2" id="anc2"></a><span class="line-modified"> 39   /*************************************************************************/</span>
<span class="line-modified"> 40   /*                                                                       */</span>
<span class="line-modified"> 41   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 42   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 43   /* messages during execution.                                            */</span>
<span class="line-modified"> 44   /*                                                                       */</span>
 45 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 46 #define FT_COMPONENT  trace_t1objs</span>
 47 
 48 
<a name="4" id="anc4"></a><span class="line-modified"> 49   /*************************************************************************/</span>
<span class="line-modified"> 50   /*                                                                       */</span>
<span class="line-modified"> 51   /*                            SIZE FUNCTIONS                             */</span>
<span class="line-modified"> 52   /*                                                                       */</span>
<span class="line-modified"> 53   /*************************************************************************/</span>
 54 
 55 
 56   static PSH_Globals_Funcs
 57   T1_Size_Get_Globals_Funcs( T1_Size  size )
 58   {
 59     T1_Face           face     = (T1_Face)size-&gt;root.face;
 60     PSHinter_Service  pshinter = (PSHinter_Service)face-&gt;pshinter;
 61     FT_Module         module;
 62 
 63 
 64     module = FT_Get_Module( size-&gt;root.face-&gt;driver-&gt;root.library,
 65                             &quot;pshinter&quot; );
 66     return ( module &amp;&amp; pshinter &amp;&amp; pshinter-&gt;get_globals_funcs )
 67            ? pshinter-&gt;get_globals_funcs( module )
 68            : 0;
 69   }
 70 
 71 
 72   FT_LOCAL_DEF( void )
 73   T1_Size_Done( FT_Size  t1size )          /* T1_Size */
 74   {
 75     T1_Size  size = (T1_Size)t1size;
 76 
 77 
 78     if ( t1size-&gt;internal-&gt;module_data )
 79     {
 80       PSH_Globals_Funcs  funcs;
 81 
 82 
 83       funcs = T1_Size_Get_Globals_Funcs( size );
 84       if ( funcs )
 85         funcs-&gt;destroy( (PSH_Globals)t1size-&gt;internal-&gt;module_data );
 86 
 87       t1size-&gt;internal-&gt;module_data = NULL;
 88     }
 89   }
 90 
 91 
 92   FT_LOCAL_DEF( FT_Error )
 93   T1_Size_Init( FT_Size  t1size )      /* T1_Size */
 94   {
 95     T1_Size            size  = (T1_Size)t1size;
 96     FT_Error           error = FT_Err_Ok;
 97     PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );
 98 
 99 
100     if ( funcs )
101     {
102       PSH_Globals  globals;
103       T1_Face      face = (T1_Face)size-&gt;root.face;
104 
105 
106       error = funcs-&gt;create( size-&gt;root.face-&gt;memory,
107                              &amp;face-&gt;type1.private_dict, &amp;globals );
108       if ( !error )
109         t1size-&gt;internal-&gt;module_data = globals;
110     }
111 
112     return error;
113   }
114 
115 
116   FT_LOCAL_DEF( FT_Error )
117   T1_Size_Request( FT_Size          t1size,     /* T1_Size */
118                    FT_Size_Request  req )
119   {
120     T1_Size            size  = (T1_Size)t1size;
121     PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );
122 
123 
124     FT_Request_Metrics( size-&gt;root.face, req );
125 
126     if ( funcs )
127       funcs-&gt;set_scale( (PSH_Globals)t1size-&gt;internal-&gt;module_data,
128                         size-&gt;root.metrics.x_scale,
129                         size-&gt;root.metrics.y_scale,
130                         0, 0 );
131 
132     return FT_Err_Ok;
133   }
134 
135 
<a name="5" id="anc5"></a><span class="line-modified">136   /*************************************************************************/</span>
<span class="line-modified">137   /*                                                                       */</span>
<span class="line-modified">138   /*                            SLOT  FUNCTIONS                            */</span>
<span class="line-modified">139   /*                                                                       */</span>
<span class="line-modified">140   /*************************************************************************/</span>
141 
142   FT_LOCAL_DEF( void )
143   T1_GlyphSlot_Done( FT_GlyphSlot  slot )
144   {
145     slot-&gt;internal-&gt;glyph_hints = NULL;
146   }
147 
148 
149   FT_LOCAL_DEF( FT_Error )
150   T1_GlyphSlot_Init( FT_GlyphSlot  slot )
151   {
152     T1_Face           face;
153     PSHinter_Service  pshinter;
154 
155 
156     face     = (T1_Face)slot-&gt;face;
157     pshinter = (PSHinter_Service)face-&gt;pshinter;
158 
159     if ( pshinter )
160     {
161       FT_Module  module;
162 
163 
164       module = FT_Get_Module( slot-&gt;face-&gt;driver-&gt;root.library,
165                               &quot;pshinter&quot; );
166       if ( module )
167       {
168         T1_Hints_Funcs  funcs;
169 
170 
171         funcs = pshinter-&gt;get_t1_funcs( module );
172         slot-&gt;internal-&gt;glyph_hints = (void*)funcs;
173       }
174     }
175 
176     return 0;
177   }
178 
179 
<a name="6" id="anc6"></a><span class="line-modified">180   /*************************************************************************/</span>
<span class="line-modified">181   /*                                                                       */</span>
<span class="line-modified">182   /*                            FACE  FUNCTIONS                            */</span>
<span class="line-modified">183   /*                                                                       */</span>
<span class="line-modified">184   /*************************************************************************/</span>
<span class="line-modified">185 </span>
<span class="line-modified">186 </span>
<span class="line-modified">187   /*************************************************************************/</span>
<span class="line-modified">188   /*                                                                       */</span>
<span class="line-modified">189   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">190   /*    T1_Face_Done                                                       */</span>
<span class="line-modified">191   /*                                                                       */</span>
<span class="line-modified">192   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">193   /*    The face object destructor.                                        */</span>
<span class="line-modified">194   /*                                                                       */</span>
<span class="line-modified">195   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">196   /*    face :: A typeless pointer to the face object to destroy.          */</span>
<span class="line-modified">197   /*                                                                       */</span>

198   FT_LOCAL_DEF( void )
199   T1_Face_Done( FT_Face  t1face )         /* T1_Face */
200   {
201     T1_Face    face = (T1_Face)t1face;
202     FT_Memory  memory;
203     T1_Font    type1;
204 
205 
206     if ( !face )
207       return;
208 
209     memory = face-&gt;root.memory;
210     type1  = &amp;face-&gt;type1;
211 
212 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
213     /* release multiple masters information */
214     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
215 
216     if ( face-&gt;buildchar )
217     {
218       FT_FREE( face-&gt;buildchar );
219 
220       face-&gt;buildchar     = NULL;
221       face-&gt;len_buildchar = 0;
222     }
223 
224     T1_Done_Blend( face );
225     face-&gt;blend = NULL;
226 #endif
227 
228     /* release font info strings */
229     {
230       PS_FontInfo  info = &amp;type1-&gt;font_info;
231 
232 
233       FT_FREE( info-&gt;version );
234       FT_FREE( info-&gt;notice );
235       FT_FREE( info-&gt;full_name );
236       FT_FREE( info-&gt;family_name );
237       FT_FREE( info-&gt;weight );
238     }
239 
240     /* release top dictionary */
241     FT_FREE( type1-&gt;charstrings_len );
242     FT_FREE( type1-&gt;charstrings );
243     FT_FREE( type1-&gt;glyph_names );
244 
245     FT_FREE( type1-&gt;subrs );
246     FT_FREE( type1-&gt;subrs_len );
247 
248     ft_hash_num_free( type1-&gt;subrs_hash, memory );
249     FT_FREE( type1-&gt;subrs_hash );
250 
251     FT_FREE( type1-&gt;subrs_block );
252     FT_FREE( type1-&gt;charstrings_block );
253     FT_FREE( type1-&gt;glyph_names_block );
254 
255     FT_FREE( type1-&gt;encoding.char_index );
256     FT_FREE( type1-&gt;encoding.char_name );
257     FT_FREE( type1-&gt;font_name );
258 
259 #ifndef T1_CONFIG_OPTION_NO_AFM
260     /* release afm data if present */
261     if ( face-&gt;afm_data )
262       T1_Done_Metrics( memory, (AFM_FontInfo)face-&gt;afm_data );
263 #endif
264 
265     /* release unicode map, if any */
266 #if 0
267     FT_FREE( face-&gt;unicode_map_rec.maps );
268     face-&gt;unicode_map_rec.num_maps = 0;
269     face-&gt;unicode_map              = NULL;
270 #endif
271 
272     face-&gt;root.family_name = NULL;
273     face-&gt;root.style_name  = NULL;
274   }
275 
276 
<a name="7" id="anc7"></a><span class="line-modified">277   /*************************************************************************/</span>
<span class="line-modified">278   /*                                                                       */</span>
<span class="line-modified">279   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">280   /*    T1_Face_Init                                                       */</span>
<span class="line-modified">281   /*                                                                       */</span>
<span class="line-modified">282   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">283   /*    The face object constructor.                                       */</span>
<span class="line-modified">284   /*                                                                       */</span>
<span class="line-modified">285   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">286   /*    stream     ::  input stream where to load font data.               */</span>
<span class="line-modified">287   /*                                                                       */</span>
<span class="line-modified">288   /*    face_index :: The index of the font face in the resource.          */</span>
<span class="line-modified">289   /*                                                                       */</span>
<span class="line-modified">290   /*    num_params :: Number of additional generic parameters.  Ignored.   */</span>
<span class="line-modified">291   /*                                                                       */</span>
<span class="line-modified">292   /*    params     :: Additional generic parameters.  Ignored.             */</span>
<span class="line-modified">293   /*                                                                       */</span>
<span class="line-modified">294   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">295   /*    face       :: The face record to build.                            */</span>
<span class="line-modified">296   /*                                                                       */</span>
<span class="line-modified">297   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">298   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">299   /*                                                                       */</span>





300   FT_LOCAL_DEF( FT_Error )
301   T1_Face_Init( FT_Stream      stream,
302                 FT_Face        t1face,          /* T1_Face */
303                 FT_Int         face_index,
304                 FT_Int         num_params,
305                 FT_Parameter*  params )
306   {
307     T1_Face             face = (T1_Face)t1face;
308     FT_Error            error;
309     FT_Service_PsCMaps  psnames;
310     PSAux_Service       psaux;
311     T1_Font             type1 = &amp;face-&gt;type1;
312     PS_FontInfo         info = &amp;type1-&gt;font_info;
313 
314     FT_UNUSED( num_params );
315     FT_UNUSED( params );
316     FT_UNUSED( stream );
317 
318 
319     face-&gt;root.num_faces = 1;
320 
321     FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
322     face-&gt;psnames = psnames;
323 
324     face-&gt;psaux = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
325                                            &quot;psaux&quot; );
326     psaux = (PSAux_Service)face-&gt;psaux;
327     if ( !psaux )
328     {
329       FT_ERROR(( &quot;T1_Face_Init: cannot access `psaux&#39; module\n&quot; ));
330       error = FT_THROW( Missing_Module );
331       goto Exit;
332     }
333 
334     face-&gt;pshinter = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
335                                               &quot;pshinter&quot; );
336 
337     FT_TRACE2(( &quot;Type 1 driver\n&quot; ));
338 
339     /* open the tokenizer; this will also check the font format */
340     error = T1_Open_Face( face );
341     if ( error )
342       goto Exit;
343 
<a name="8" id="anc8"></a>



344     /* if we just wanted to check the format, leave successfully now */
345     if ( face_index &lt; 0 )
346       goto Exit;
347 
348     /* check the face index */
349     if ( ( face_index &amp; 0xFFFF ) &gt; 0 )
350     {
351       FT_ERROR(( &quot;T1_Face_Init: invalid face index\n&quot; ));
352       error = FT_THROW( Invalid_Argument );
353       goto Exit;
354     }
355 
356     /* now load the font program into the face object */
357 
358     /* initialize the face object fields */
359 
360     /* set up root face fields */
361     {
362       FT_Face  root = (FT_Face)&amp;face-&gt;root;
363 
364 
365       root-&gt;num_glyphs = type1-&gt;num_glyphs;
366       root-&gt;face_index = 0;
367 
368       root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE    |
369                           FT_FACE_FLAG_HORIZONTAL  |
370                           FT_FACE_FLAG_GLYPH_NAMES |
371                           FT_FACE_FLAG_HINTER;
372 
373       if ( info-&gt;is_fixed_pitch )
374         root-&gt;face_flags |= FT_FACE_FLAG_FIXED_WIDTH;
375 
376       if ( face-&gt;blend )
377         root-&gt;face_flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
378 
379       /* The following code to extract the family and the style is very   */
380       /* simplistic and might get some things wrong.  For a full-featured */
381       /* algorithm you might have a look at the whitepaper given at       */
382       /*                                                                  */
383       /*   https://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
384 
385       /* get style name -- be careful, some broken fonts only */
386       /* have a `/FontName&#39; dictionary entry!                 */
387       root-&gt;family_name = info-&gt;family_name;
388       root-&gt;style_name  = NULL;
389 
390       if ( root-&gt;family_name )
391       {
392         char*  full   = info-&gt;full_name;
393         char*  family = root-&gt;family_name;
394 
395 
396         if ( full )
397         {
398           FT_Bool  the_same = TRUE;
399 
400 
401           while ( *full )
402           {
403             if ( *full == *family )
404             {
405               family++;
406               full++;
407             }
408             else
409             {
410               if ( *full == &#39; &#39; || *full == &#39;-&#39; )
411                 full++;
412               else if ( *family == &#39; &#39; || *family == &#39;-&#39; )
413                 family++;
414               else
415               {
416                 the_same = FALSE;
417 
418                 if ( !*family )
419                   root-&gt;style_name = full;
420                 break;
421               }
422             }
423           }
424 
425           if ( the_same )
426             root-&gt;style_name = (char *)&quot;Regular&quot;;
427         }
428       }
429       else
430       {
431         /* do we have a `/FontName&#39;? */
432         if ( type1-&gt;font_name )
433           root-&gt;family_name = type1-&gt;font_name;
434       }
435 
436       if ( !root-&gt;style_name )
437       {
438         if ( info-&gt;weight )
439           root-&gt;style_name = info-&gt;weight;
440         else
441           /* assume `Regular&#39; style because we don&#39;t know better */
442           root-&gt;style_name = (char *)&quot;Regular&quot;;
443       }
444 
445       /* compute style flags */
446       root-&gt;style_flags = 0;
447       if ( info-&gt;italic_angle )
448         root-&gt;style_flags |= FT_STYLE_FLAG_ITALIC;
449       if ( info-&gt;weight )
450       {
451         if ( !ft_strcmp( info-&gt;weight, &quot;Bold&quot;  ) ||
452              !ft_strcmp( info-&gt;weight, &quot;Black&quot; ) )
453           root-&gt;style_flags |= FT_STYLE_FLAG_BOLD;
454       }
455 
456       /* no embedded bitmap support */
457       root-&gt;num_fixed_sizes = 0;
458       root-&gt;available_sizes = NULL;
459 
460       root-&gt;bbox.xMin =   type1-&gt;font_bbox.xMin            &gt;&gt; 16;
461       root-&gt;bbox.yMin =   type1-&gt;font_bbox.yMin            &gt;&gt; 16;
462       /* no `U&#39; suffix here to 0xFFFF! */
463       root-&gt;bbox.xMax = ( type1-&gt;font_bbox.xMax + 0xFFFF ) &gt;&gt; 16;
464       root-&gt;bbox.yMax = ( type1-&gt;font_bbox.yMax + 0xFFFF ) &gt;&gt; 16;
465 
466       /* Set units_per_EM if we didn&#39;t set it in t1_parse_font_matrix. */
467       if ( !root-&gt;units_per_EM )
468         root-&gt;units_per_EM = 1000;
469 
470       root-&gt;ascender  = (FT_Short)( root-&gt;bbox.yMax );
471       root-&gt;descender = (FT_Short)( root-&gt;bbox.yMin );
472 
473       root-&gt;height = (FT_Short)( ( root-&gt;units_per_EM * 12 ) / 10 );
474       if ( root-&gt;height &lt; root-&gt;ascender - root-&gt;descender )
475         root-&gt;height = (FT_Short)( root-&gt;ascender - root-&gt;descender );
476 
477       /* now compute the maximum advance width */
478       root-&gt;max_advance_width =
479         (FT_Short)( root-&gt;bbox.xMax );
480       {
481         FT_Pos  max_advance;
482 
483 
484         error = T1_Compute_Max_Advance( face, &amp;max_advance );
485 
486         /* in case of error, keep the standard width */
487         if ( !error )
488           root-&gt;max_advance_width = (FT_Short)FIXED_TO_INT( max_advance );
489         else
490           error = FT_Err_Ok;   /* clear error */
491       }
492 
493       root-&gt;max_advance_height = root-&gt;height;
494 
495       root-&gt;underline_position  = (FT_Short)info-&gt;underline_position;
496       root-&gt;underline_thickness = (FT_Short)info-&gt;underline_thickness;
497     }
498 
499     {
500       FT_Face  root = &amp;face-&gt;root;
501 
502 
503       if ( psnames )
504       {
505         FT_CharMapRec    charmap;
506         T1_CMap_Classes  cmap_classes = psaux-&gt;t1_cmap_classes;
507         FT_CMap_Class    clazz;
508 
509 
510         charmap.face = root;
511 
512         /* first of all, try to synthesize a Unicode charmap */
513         charmap.platform_id = TT_PLATFORM_MICROSOFT;
514         charmap.encoding_id = TT_MS_ID_UNICODE_CS;
515         charmap.encoding    = FT_ENCODING_UNICODE;
516 
517         error = FT_CMap_New( cmap_classes-&gt;unicode, NULL, &amp;charmap, NULL );
518         if ( error                                      &amp;&amp;
<a name="9" id="anc9"></a><span class="line-modified">519              FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )</span>

520           goto Exit;
521         error = FT_Err_Ok;
522 
523         /* now, generate an Adobe Standard encoding when appropriate */
524         charmap.platform_id = TT_PLATFORM_ADOBE;
525         clazz               = NULL;
526 
527         switch ( type1-&gt;encoding_type )
528         {
529         case T1_ENCODING_TYPE_STANDARD:
530           charmap.encoding    = FT_ENCODING_ADOBE_STANDARD;
531           charmap.encoding_id = TT_ADOBE_ID_STANDARD;
532           clazz               = cmap_classes-&gt;standard;
533           break;
534 
535         case T1_ENCODING_TYPE_EXPERT:
536           charmap.encoding    = FT_ENCODING_ADOBE_EXPERT;
537           charmap.encoding_id = TT_ADOBE_ID_EXPERT;
538           clazz               = cmap_classes-&gt;expert;
539           break;
540 
541         case T1_ENCODING_TYPE_ARRAY:
542           charmap.encoding    = FT_ENCODING_ADOBE_CUSTOM;
543           charmap.encoding_id = TT_ADOBE_ID_CUSTOM;
544           clazz               = cmap_classes-&gt;custom;
545           break;
546 
547         case T1_ENCODING_TYPE_ISOLATIN1:
548           charmap.encoding    = FT_ENCODING_ADOBE_LATIN_1;
549           charmap.encoding_id = TT_ADOBE_ID_LATIN_1;
550           clazz               = cmap_classes-&gt;unicode;
551           break;
552 
553         default:
554           ;
555         }
556 
557         if ( clazz )
558           error = FT_CMap_New( clazz, NULL, &amp;charmap, NULL );
559       }
560     }
561 
562   Exit:
563     return error;
564   }
565 
566 
<a name="10" id="anc10"></a><span class="line-modified">567   /*************************************************************************/</span>
<span class="line-modified">568   /*                                                                       */</span>
<span class="line-modified">569   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">570   /*    T1_Driver_Init                                                     */</span>
<span class="line-modified">571   /*                                                                       */</span>
<span class="line-modified">572   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">573   /*    Initializes a given Type 1 driver object.                          */</span>
<span class="line-modified">574   /*                                                                       */</span>
<span class="line-modified">575   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">576   /*    driver :: A handle to the target driver object.                    */</span>
<span class="line-modified">577   /*                                                                       */</span>
<span class="line-modified">578   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">579   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">580   /*                                                                       */</span>

581   FT_LOCAL_DEF( FT_Error )
582   T1_Driver_Init( FT_Module  module )
583   {
584     PS_Driver  driver = (PS_Driver)module;
585 
586     FT_UInt32  seed;
587 
588 
589     /* set default property values, cf. `ftt1drv.h&#39; */
590 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
591     driver-&gt;hinting_engine = FT_HINTING_FREETYPE;
592 #else
593     driver-&gt;hinting_engine = FT_HINTING_ADOBE;
594 #endif
595 
596     driver-&gt;no_stem_darkening = TRUE;
597 
598     driver-&gt;darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
599     driver-&gt;darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
600     driver-&gt;darken_params[2] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2;
601     driver-&gt;darken_params[3] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2;
602     driver-&gt;darken_params[4] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3;
603     driver-&gt;darken_params[5] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3;
604     driver-&gt;darken_params[6] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4;
605     driver-&gt;darken_params[7] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4;
606 
607     /* compute random seed from some memory addresses */
608     seed = (FT_UInt32)( (FT_Offset)(char*)&amp;seed          ^
609                         (FT_Offset)(char*)&amp;module        ^
610                         (FT_Offset)(char*)module-&gt;memory );
611     seed = seed ^ ( seed &gt;&gt; 10 ) ^ ( seed &gt;&gt; 20 );
612 
613     driver-&gt;random_seed = (FT_Int32)seed;
614     if ( driver-&gt;random_seed &lt; 0 )
615       driver-&gt;random_seed = -driver-&gt;random_seed;
616     else if ( driver-&gt;random_seed == 0 )
617       driver-&gt;random_seed = 123456789;
618 
619     return FT_Err_Ok;
620   }
621 
622 
<a name="11" id="anc11"></a><span class="line-modified">623   /*************************************************************************/</span>
<span class="line-modified">624   /*                                                                       */</span>
<span class="line-modified">625   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">626   /*    T1_Driver_Done                                                     */</span>
<span class="line-modified">627   /*                                                                       */</span>
<span class="line-modified">628   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">629   /*    Finalizes a given Type 1 driver.                                   */</span>
<span class="line-modified">630   /*                                                                       */</span>
<span class="line-modified">631   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">632   /*    driver :: A handle to the target Type 1 driver.                    */</span>
<span class="line-modified">633   /*                                                                       */</span>

634   FT_LOCAL_DEF( void )
635   T1_Driver_Done( FT_Module  driver )
636   {
637     FT_UNUSED( driver );
638   }
639 
640 
641 /* END */
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
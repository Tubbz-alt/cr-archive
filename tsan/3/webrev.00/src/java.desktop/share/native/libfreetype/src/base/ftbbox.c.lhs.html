<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/base/ftbbox.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftbbox.c                                                               */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    FreeType bbox computation (body).                                    */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used        */</span>
<span class="line-modified"> 11 /*  modified and distributed under the terms of the FreeType project       */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
<span class="line-modified"> 17 </span>
<span class="line-modified"> 18 </span>
<span class="line-modified"> 19   /*************************************************************************/</span>
<span class="line-modified"> 20   /*                                                                       */</span>
<span class="line-modified"> 21   /* This component has a _single_ role: to compute exact outline bounding */</span>
<span class="line-modified"> 22   /* boxes.                                                                */</span>
<span class="line-modified"> 23   /*                                                                       */</span>
<span class="line-modified"> 24   /*************************************************************************/</span>
 25 
 26 
 27 #include &lt;ft2build.h&gt;
 28 #include FT_INTERNAL_DEBUG_H
 29 
 30 #include FT_BBOX_H
 31 #include FT_IMAGE_H
 32 #include FT_OUTLINE_H
 33 #include FT_INTERNAL_CALC_H
 34 #include FT_INTERNAL_OBJECTS_H
 35 
 36 
 37   typedef struct  TBBox_Rec_
 38   {
 39     FT_Vector  last;
 40     FT_BBox    bbox;
 41 
 42   } TBBox_Rec;
 43 
 44 
 45 #define FT_UPDATE_BBOX( p, bbox ) \
 46   FT_BEGIN_STMNT                  \
 47     if ( p-&gt;x &lt; bbox.xMin )       \
 48       bbox.xMin = p-&gt;x;           \
 49     if ( p-&gt;x &gt; bbox.xMax )       \
 50       bbox.xMax = p-&gt;x;           \
 51     if ( p-&gt;y &lt; bbox.yMin )       \
 52       bbox.yMin = p-&gt;y;           \
 53     if ( p-&gt;y &gt; bbox.yMax )       \
 54       bbox.yMax = p-&gt;y;           \
 55   FT_END_STMNT
 56 
 57 #define CHECK_X( p, bbox )                         \
 58           ( p-&gt;x &lt; bbox.xMin || p-&gt;x &gt; bbox.xMax )
 59 
 60 #define CHECK_Y( p, bbox )                         \
 61           ( p-&gt;y &lt; bbox.yMin || p-&gt;y &gt; bbox.yMax )
 62 
 63 
<a name="2" id="anc2"></a><span class="line-modified"> 64   /*************************************************************************/</span>
<span class="line-modified"> 65   /*                                                                       */</span>
<span class="line-modified"> 66   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 67   /*    BBox_Move_To                                                       */</span>
<span class="line-modified"> 68   /*                                                                       */</span>
<span class="line-modified"> 69   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 70   /*    This function is used as a `move_to&#39; emitter during                */</span>
<span class="line-modified"> 71   /*    FT_Outline_Decompose().  It simply records the destination point   */</span>
<span class="line-modified"> 72   /*    in `user-&gt;last&#39;. We also update bbox in case contour starts with   */</span>
<span class="line-modified"> 73   /*    an implicit `on&#39; point.                                            */</span>
<span class="line-modified"> 74   /*                                                                       */</span>
<span class="line-modified"> 75   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 76   /*    to   :: A pointer to the destination vector.                       */</span>
<span class="line-modified"> 77   /*                                                                       */</span>
<span class="line-modified"> 78   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 79   /*    user :: A pointer to the current walk context.                     */</span>
<span class="line-modified"> 80   /*                                                                       */</span>
<span class="line-modified"> 81   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 82   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified"> 83   /*                                                                       */</span>


 84   static int
 85   BBox_Move_To( FT_Vector*  to,
 86                 TBBox_Rec*  user )
 87   {
 88     FT_UPDATE_BBOX( to, user-&gt;bbox );
 89 
 90     user-&gt;last = *to;
 91 
 92     return 0;
 93   }
 94 
 95 
<a name="3" id="anc3"></a><span class="line-modified"> 96   /*************************************************************************/</span>
<span class="line-modified"> 97   /*                                                                       */</span>
<span class="line-modified"> 98   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 99   /*    BBox_Line_To                                                       */</span>
<span class="line-modified">100   /*                                                                       */</span>
<span class="line-modified">101   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">102   /*    This function is used as a `line_to&#39; emitter during                */</span>
<span class="line-modified">103   /*    FT_Outline_Decompose().  It simply records the destination point   */</span>
<span class="line-modified">104   /*    in `user-&gt;last&#39;; no further computations are necessary because     */</span>
<span class="line-modified">105   /*    bbox already contains both explicit ends of the line segment.      */</span>
<span class="line-modified">106   /*                                                                       */</span>
<span class="line-modified">107   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">108   /*    to   :: A pointer to the destination vector.                       */</span>
<span class="line-modified">109   /*                                                                       */</span>
<span class="line-modified">110   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">111   /*    user :: A pointer to the current walk context.                     */</span>
<span class="line-modified">112   /*                                                                       */</span>
<span class="line-modified">113   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">114   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">115   /*                                                                       */</span>


116   static int
117   BBox_Line_To( FT_Vector*  to,
118                 TBBox_Rec*  user )
119   {
120     user-&gt;last = *to;
121 
122     return 0;
123   }
124 
125 
<a name="4" id="anc4"></a><span class="line-modified">126   /*************************************************************************/</span>
<span class="line-modified">127   /*                                                                       */</span>
<span class="line-modified">128   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">129   /*    BBox_Conic_Check                                                   */</span>
<span class="line-modified">130   /*                                                                       */</span>
<span class="line-modified">131   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">132   /*    Find the extrema of a 1-dimensional conic Bezier curve and update  */</span>
<span class="line-modified">133   /*    a bounding range.  This version uses direct computation, as it     */</span>
<span class="line-modified">134   /*    doesn&#39;t need square roots.                                         */</span>
<span class="line-modified">135   /*                                                                       */</span>
<span class="line-modified">136   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">137   /*    y1  :: The start coordinate.                                       */</span>
<span class="line-modified">138   /*                                                                       */</span>
<span class="line-modified">139   /*    y2  :: The coordinate of the control point.                        */</span>
<span class="line-modified">140   /*                                                                       */</span>
<span class="line-modified">141   /*    y3  :: The end coordinate.                                         */</span>
<span class="line-modified">142   /*                                                                       */</span>
<span class="line-modified">143   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">144   /*    min :: The address of the current minimum.                         */</span>
<span class="line-modified">145   /*                                                                       */</span>
<span class="line-modified">146   /*    max :: The address of the current maximum.                         */</span>
<span class="line-modified">147   /*                                                                       */</span>





148   static void
149   BBox_Conic_Check( FT_Pos   y1,
150                     FT_Pos   y2,
151                     FT_Pos   y3,
152                     FT_Pos*  min,
153                     FT_Pos*  max )
154   {
155     /* This function is only called when a control off-point is outside */
156     /* the bbox that contains all on-points.  It finds a local extremum */
157     /* within the segment, equal to (y1*y3 - y2*y2)/(y1 - 2*y2 + y3).   */
158     /* Or, offsetting from y2, we get                                   */
159 
160     y1 -= y2;
161     y3 -= y2;
162     y2 += FT_MulDiv( y1, y3, y1 + y3 );
163 
164     if ( y2 &lt; *min )
165       *min = y2;
166     if ( y2 &gt; *max )
167       *max = y2;
168   }
169 
170 
<a name="5" id="anc5"></a><span class="line-modified">171   /*************************************************************************/</span>
<span class="line-modified">172   /*                                                                       */</span>
<span class="line-modified">173   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">174   /*    BBox_Conic_To                                                      */</span>
<span class="line-modified">175   /*                                                                       */</span>
<span class="line-modified">176   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">177   /*    This function is used as a `conic_to&#39; emitter during               */</span>
<span class="line-modified">178   /*    FT_Outline_Decompose().  It checks a conic Bezier curve with the   */</span>
<span class="line-modified">179   /*    current bounding box, and computes its extrema if necessary to     */</span>
<span class="line-modified">180   /*    update it.                                                         */</span>
<span class="line-modified">181   /*                                                                       */</span>
<span class="line-modified">182   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">183   /*    control :: A pointer to a control point.                           */</span>
<span class="line-modified">184   /*                                                                       */</span>
<span class="line-modified">185   /*    to      :: A pointer to the destination vector.                    */</span>
<span class="line-modified">186   /*                                                                       */</span>
<span class="line-modified">187   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">188   /*    user    :: The address of the current walk context.                */</span>
<span class="line-modified">189   /*                                                                       */</span>
<span class="line-modified">190   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">191   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">192   /*                                                                       */</span>
<span class="line-modified">193   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">194   /*    In the case of a non-monotonous arc, we compute directly the       */</span>
<span class="line-modified">195   /*    extremum coordinates, as it is sufficiently fast.                  */</span>
<span class="line-modified">196   /*                                                                       */</span>



197   static int
198   BBox_Conic_To( FT_Vector*  control,
199                  FT_Vector*  to,
200                  TBBox_Rec*  user )
201   {
202     /* in case `to&#39; is implicit and not included in bbox yet */
203     FT_UPDATE_BBOX( to, user-&gt;bbox );
204 
205     if ( CHECK_X( control, user-&gt;bbox ) )
206       BBox_Conic_Check( user-&gt;last.x,
207                         control-&gt;x,
208                         to-&gt;x,
209                         &amp;user-&gt;bbox.xMin,
210                         &amp;user-&gt;bbox.xMax );
211 
212     if ( CHECK_Y( control, user-&gt;bbox ) )
213       BBox_Conic_Check( user-&gt;last.y,
214                         control-&gt;y,
215                         to-&gt;y,
216                         &amp;user-&gt;bbox.yMin,
217                         &amp;user-&gt;bbox.yMax );
218 
219     user-&gt;last = *to;
220 
221     return 0;
222   }
223 
224 
<a name="6" id="anc6"></a><span class="line-modified">225   /*************************************************************************/</span>
<span class="line-modified">226   /*                                                                       */</span>
<span class="line-modified">227   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">228   /*    BBox_Cubic_Check                                                   */</span>
<span class="line-modified">229   /*                                                                       */</span>
<span class="line-modified">230   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">231   /*    Find the extrema of a 1-dimensional cubic Bezier curve and         */</span>
<span class="line-modified">232   /*    update a bounding range.  This version uses iterative splitting    */</span>
<span class="line-modified">233   /*    because it is faster than the exact solution with square roots.    */</span>
<span class="line-modified">234   /*                                                                       */</span>
<span class="line-modified">235   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">236   /*    p1  :: The start coordinate.                                       */</span>
<span class="line-modified">237   /*                                                                       */</span>
<span class="line-modified">238   /*    p2  :: The coordinate of the first control point.                  */</span>
<span class="line-modified">239   /*                                                                       */</span>
<span class="line-modified">240   /*    p3  :: The coordinate of the second control point.                 */</span>
<span class="line-modified">241   /*                                                                       */</span>
<span class="line-modified">242   /*    p4  :: The end coordinate.                                         */</span>
<span class="line-modified">243   /*                                                                       */</span>
<span class="line-modified">244   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">245   /*    min :: The address of the current minimum.                         */</span>
<span class="line-modified">246   /*                                                                       */</span>
<span class="line-modified">247   /*    max :: The address of the current maximum.                         */</span>
<span class="line-modified">248   /*                                                                       */</span>






249   static FT_Pos
250   cubic_peak( FT_Pos  q1,
251               FT_Pos  q2,
252               FT_Pos  q3,
253               FT_Pos  q4 )
254   {
255     FT_Pos  peak = 0;
256     FT_Int  shift;
257 
258 
259     /* This function finds a peak of a cubic segment if it is above 0    */
260     /* using iterative bisection of the segment, or returns 0.           */
261     /* The fixed-point arithmetic of bisection is inherently stable      */
262     /* but may loose accuracy in the two lowest bits.  To compensate,    */
263     /* we upscale the segment if there is room.  Large values may need   */
264     /* to be downscaled to avoid overflows during bisection.             */
265     /* It is called with either q2 or q3 positive, which is necessary    */
266     /* for the peak to exist and avoids undefined FT_MSB.                */
267 
268     shift = 27 - FT_MSB( (FT_UInt32)( FT_ABS( q1 ) |
269                                       FT_ABS( q2 ) |
270                                       FT_ABS( q3 ) |
271                                       FT_ABS( q4 ) ) );
272 
273     if ( shift &gt; 0 )
274     {
275       /* upscaling too much just wastes time */
276       if ( shift &gt; 2 )
277         shift = 2;
278 
279       q1 &lt;&lt;=  shift;
280       q2 &lt;&lt;=  shift;
281       q3 &lt;&lt;=  shift;
282       q4 &lt;&lt;=  shift;
283     }
284     else
285     {
286       q1 &gt;&gt;= -shift;
287       q2 &gt;&gt;= -shift;
288       q3 &gt;&gt;= -shift;
289       q4 &gt;&gt;= -shift;
290     }
291 
292     /* for a peak to exist above 0, the cubic segment must have */
293     /* at least one of its control off-points above 0.          */
294     while ( q2 &gt; 0 || q3 &gt; 0 )
295     {
296       /* determine which half contains the maximum and split */
297       if ( q1 + q2 &gt; q3 + q4 ) /* first half */
298       {
299         q4 = q4 + q3;
300         q3 = q3 + q2;
301         q2 = q2 + q1;
302         q4 = q4 + q3;
303         q3 = q3 + q2;
<a name="7" id="anc7"></a><span class="line-modified">304         q4 = ( q4 + q3 ) / 8;</span>
<span class="line-modified">305         q3 = q3 / 4;</span>
<span class="line-modified">306         q2 = q2 / 2;</span>
307       }
308       else                     /* second half */
309       {
310         q1 = q1 + q2;
311         q2 = q2 + q3;
312         q3 = q3 + q4;
313         q1 = q1 + q2;
314         q2 = q2 + q3;
<a name="8" id="anc8"></a><span class="line-modified">315         q1 = ( q1 + q2 ) / 8;</span>
<span class="line-modified">316         q2 = q2 / 4;</span>
<span class="line-modified">317         q3 = q3 / 2;</span>
318       }
319 
320       /* check whether either end reached the maximum */
321       if ( q1 == q2 &amp;&amp; q1 &gt;= q3 )
322       {
323         peak = q1;
324         break;
325       }
326       if ( q3 == q4 &amp;&amp; q2 &lt;= q4 )
327       {
328         peak = q4;
329         break;
330       }
331     }
332 
333     if ( shift &gt; 0 )
334       peak &gt;&gt;=  shift;
335     else
336       peak &lt;&lt;= -shift;
337 
338     return peak;
339   }
340 
341 
342   static void
343   BBox_Cubic_Check( FT_Pos   p1,
344                     FT_Pos   p2,
345                     FT_Pos   p3,
346                     FT_Pos   p4,
347                     FT_Pos*  min,
348                     FT_Pos*  max )
349   {
350     /* This function is only called when a control off-point is outside  */
351     /* the bbox that contains all on-points.  So at least one of the     */
352     /* conditions below holds and cubic_peak is called with at least one */
353     /* non-zero argument.                                                */
354 
355     if ( p2 &gt; *max || p3 &gt; *max )
356       *max += cubic_peak( p1 - *max, p2 - *max, p3 - *max, p4 - *max );
357 
358     /* now flip the signs to update the minimum */
359     if ( p2 &lt; *min || p3 &lt; *min )
360       *min -= cubic_peak( *min - p1, *min - p2, *min - p3, *min - p4 );
361   }
362 
363 
<a name="9" id="anc9"></a><span class="line-modified">364   /*************************************************************************/</span>
<span class="line-modified">365   /*                                                                       */</span>
<span class="line-modified">366   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">367   /*    BBox_Cubic_To                                                      */</span>
<span class="line-modified">368   /*                                                                       */</span>
<span class="line-modified">369   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">370   /*    This function is used as a `cubic_to&#39; emitter during               */</span>
<span class="line-modified">371   /*    FT_Outline_Decompose().  It checks a cubic Bezier curve with the   */</span>
<span class="line-modified">372   /*    current bounding box, and computes its extrema if necessary to     */</span>
<span class="line-modified">373   /*    update it.                                                         */</span>
<span class="line-modified">374   /*                                                                       */</span>
<span class="line-modified">375   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">376   /*    control1 :: A pointer to the first control point.                  */</span>
<span class="line-modified">377   /*                                                                       */</span>
<span class="line-modified">378   /*    control2 :: A pointer to the second control point.                 */</span>
<span class="line-modified">379   /*                                                                       */</span>
<span class="line-modified">380   /*    to       :: A pointer to the destination vector.                   */</span>
<span class="line-modified">381   /*                                                                       */</span>
<span class="line-modified">382   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">383   /*    user     :: The address of the current walk context.               */</span>
<span class="line-modified">384   /*                                                                       */</span>
<span class="line-modified">385   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">386   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">387   /*                                                                       */</span>
<span class="line-modified">388   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">389   /*    In the case of a non-monotonous arc, we don&#39;t compute directly     */</span>
<span class="line-modified">390   /*    extremum coordinates, we subdivide instead.                        */</span>
<span class="line-modified">391   /*                                                                       */</span>




392   static int
393   BBox_Cubic_To( FT_Vector*  control1,
394                  FT_Vector*  control2,
395                  FT_Vector*  to,
396                  TBBox_Rec*  user )
397   {
398     /* We don&#39;t need to check `to&#39; since it is always an on-point,    */
399     /* thus within the bbox.  Only segments with an off-point outside */
400     /* the bbox can possibly reach new extreme values.                */
401 
402     if ( CHECK_X( control1, user-&gt;bbox ) ||
403          CHECK_X( control2, user-&gt;bbox ) )
404       BBox_Cubic_Check( user-&gt;last.x,
405                         control1-&gt;x,
406                         control2-&gt;x,
407                         to-&gt;x,
408                         &amp;user-&gt;bbox.xMin,
409                         &amp;user-&gt;bbox.xMax );
410 
411     if ( CHECK_Y( control1, user-&gt;bbox ) ||
412          CHECK_Y( control2, user-&gt;bbox ) )
413       BBox_Cubic_Check( user-&gt;last.y,
414                         control1-&gt;y,
415                         control2-&gt;y,
416                         to-&gt;y,
417                         &amp;user-&gt;bbox.yMin,
418                         &amp;user-&gt;bbox.yMax );
419 
420     user-&gt;last = *to;
421 
422     return 0;
423   }
424 
425 
426   FT_DEFINE_OUTLINE_FUNCS(
427     bbox_interface,
428 
429     (FT_Outline_MoveTo_Func) BBox_Move_To,   /* move_to  */
430     (FT_Outline_LineTo_Func) BBox_Line_To,   /* line_to  */
431     (FT_Outline_ConicTo_Func)BBox_Conic_To,  /* conic_to */
432     (FT_Outline_CubicTo_Func)BBox_Cubic_To,  /* cubic_to */
433     0,                                       /* shift    */
434     0                                        /* delta    */
435   )
436 
437 
438   /* documentation is in ftbbox.h */
439 
440   FT_EXPORT_DEF( FT_Error )
441   FT_Outline_Get_BBox( FT_Outline*  outline,
442                        FT_BBox     *abbox )
443   {
444     FT_BBox     cbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
445                          -0x7FFFFFFFL, -0x7FFFFFFFL };
446     FT_BBox     bbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
447                          -0x7FFFFFFFL, -0x7FFFFFFFL };
448     FT_Vector*  vec;
449     FT_UShort   n;
450 
451 
452     if ( !abbox )
453       return FT_THROW( Invalid_Argument );
454 
455     if ( !outline )
456       return FT_THROW( Invalid_Outline );
457 
458     /* if outline is empty, return (0,0,0,0) */
459     if ( outline-&gt;n_points == 0 || outline-&gt;n_contours &lt;= 0 )
460     {
461       abbox-&gt;xMin = abbox-&gt;xMax = 0;
462       abbox-&gt;yMin = abbox-&gt;yMax = 0;
463 
464       return 0;
465     }
466 
467     /* We compute the control box as well as the bounding box of  */
468     /* all `on&#39; points in the outline.  Then, if the two boxes    */
469     /* coincide, we exit immediately.                             */
470 
471     vec = outline-&gt;points;
472 
473     for ( n = 0; n &lt; outline-&gt;n_points; n++ )
474     {
475       FT_UPDATE_BBOX( vec, cbox );
476 
477       if ( FT_CURVE_TAG( outline-&gt;tags[n] ) == FT_CURVE_TAG_ON )
478         FT_UPDATE_BBOX( vec, bbox );
479 
480       vec++;
481     }
482 
483     /* test two boxes for equality */
484     if ( cbox.xMin &lt; bbox.xMin || cbox.xMax &gt; bbox.xMax ||
485          cbox.yMin &lt; bbox.yMin || cbox.yMax &gt; bbox.yMax )
486     {
487       /* the two boxes are different, now walk over the outline to */
488       /* get the Bezier arc extrema.                               */
489 
490       FT_Error   error;
491       TBBox_Rec  user;
492 
<a name="10" id="anc10"></a><span class="line-removed">493 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">494       FT_Outline_Funcs  bbox_interface;</span>
<span class="line-removed">495 </span>
<span class="line-removed">496 </span>
<span class="line-removed">497       Init_Class_bbox_interface( &amp;bbox_interface );</span>
<span class="line-removed">498 #endif</span>
499 
500       user.bbox = bbox;
501 
502       error = FT_Outline_Decompose( outline, &amp;bbox_interface, &amp;user );
503       if ( error )
504         return error;
505 
506       *abbox = user.bbox;
507     }
508     else
509       *abbox = bbox;
510 
511     return FT_Err_Ok;
512   }
513 
514 
515 /* END */
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afindic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="aflatin.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  aflatin.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Auto-fitter hinting routines for latin writing system (body).        */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_ADVANCES_H
  21 #include FT_INTERNAL_DEBUG_H
  22 
  23 #include &quot;afglobal.h&quot;
<span class="line-removed">  24 #include &quot;afpic.h&quot;</span>
  25 #include &quot;aflatin.h&quot;
  26 #include &quot;aferrors.h&quot;
  27 
  28 
  29 #ifdef AF_CONFIG_OPTION_USE_WARPER
  30 #include &quot;afwarp.h&quot;
  31 #endif
  32 
  33 
<span class="line-modified">  34   /*************************************************************************/</span>
<span class="line-modified">  35   /*                                                                       */</span>
<span class="line-modified">  36   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  37   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  38   /* messages during execution.                                            */</span>
<span class="line-modified">  39   /*                                                                       */</span>
  40 #undef  FT_COMPONENT
<span class="line-modified">  41 #define FT_COMPONENT  trace_aflatin</span>
  42 
  43 
  44   /* needed for computation of round vs. flat segments */
  45 #define FLAT_THRESHOLD( x )  ( x / 14 )
  46 
  47 
  48   /*************************************************************************/
  49   /*************************************************************************/
  50   /*****                                                               *****/
  51   /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  52   /*****                                                               *****/
  53   /*************************************************************************/
  54   /*************************************************************************/
  55 
  56 
  57   /* Find segments and links, compute all stem widths, and initialize */
  58   /* standard width and height for the glyph with given charcode.     */
  59 
  60   FT_LOCAL_DEF( void )
  61   af_latin_metrics_init_widths( AF_LatinMetrics  metrics,
</pre>
<hr />
<pre>
  66 
  67 
  68     FT_TRACE5(( &quot;\n&quot;
  69                 &quot;latin standard widths computation (style `%s&#39;)\n&quot;
  70                 &quot;=====================================================\n&quot;
  71                 &quot;\n&quot;,
  72                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
  73 
  74     af_glyph_hints_init( hints, face-&gt;memory );
  75 
  76     metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;
  77     metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;
  78 
  79     {
  80       FT_Error            error;
  81       FT_ULong            glyph_index;
  82       int                 dim;
  83       AF_LatinMetricsRec  dummy[1];
  84       AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;
  85 
<span class="line-removed">  86 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">  87       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-removed">  88 #endif</span>
<span class="line-removed">  89 </span>
  90       AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">  91       AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-modified">  92                                        [style_class-&gt;script];</span>








  93 
<span class="line-removed">  94       void*        shaper_buf;</span>
  95       const char*  p;
  96 
  97 #ifdef FT_DEBUG_LEVEL_TRACE
  98       FT_ULong  ch = 0;
  99 #endif
 100 
<span class="line-removed"> 101       p          = script_class-&gt;standard_charstring;</span>
<span class="line-removed"> 102       shaper_buf = af_shaper_buf_create( face );</span>
 103 





 104       /*
 105        * We check a list of standard characters to catch features like
 106        * `c2sc&#39; (small caps from caps) that don&#39;t contain lowercase letters
 107        * by definition, or other features that mainly operate on numerals.
 108        * The first match wins.
 109        */
 110 
 111       glyph_index = 0;
 112       while ( *p )
 113       {
 114         unsigned int  num_idx;
 115 
 116 #ifdef FT_DEBUG_LEVEL_TRACE
 117         const char*  p_old;
 118 #endif
 119 
 120 
 121         while ( *p == &#39; &#39; )
 122           p++;
 123 
</pre>
<hr />
<pre>
 127 #endif
 128 
 129         /* reject input that maps to more than a single glyph */
 130         p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 131         if ( num_idx &gt; 1 )
 132           continue;
 133 
 134         /* otherwise exit loop if we have a result */
 135         glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 136                                           shaper_buf,
 137                                           0,
 138                                           NULL,
 139                                           NULL );
 140         if ( glyph_index )
 141           break;
 142       }
 143 
 144       af_shaper_buf_destroy( face, shaper_buf );
 145 
 146       if ( !glyph_index )



 147         goto Exit;

 148 
 149       FT_TRACE5(( &quot;standard character: U+%04lX (glyph index %d)\n&quot;,
 150                   ch, glyph_index ));
 151 
 152       error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
 153       if ( error || face-&gt;glyph-&gt;outline.n_points &lt;= 0 )
 154         goto Exit;
 155 
 156       FT_ZERO( dummy );
 157 
 158       dummy-&gt;units_per_em = metrics-&gt;units_per_em;
 159 
 160       scaler-&gt;x_scale = 0x10000L;
 161       scaler-&gt;y_scale = 0x10000L;
 162       scaler-&gt;x_delta = 0;
 163       scaler-&gt;y_delta = 0;
 164 
 165       scaler-&gt;face        = face;
 166       scaler-&gt;render_mode = FT_RENDER_MODE_NORMAL;
 167       scaler-&gt;flags       = 0;
</pre>
<hr />
<pre>
 169       af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
 170 
 171       error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );
 172       if ( error )
 173         goto Exit;
 174 
 175       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 176       {
 177         AF_LatinAxis  axis    = &amp;metrics-&gt;axis[dim];
 178         AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];
 179         AF_Segment    seg, limit, link;
 180         FT_UInt       num_widths = 0;
 181 
 182 
 183         error = af_latin_hints_compute_segments( hints,
 184                                                  (AF_Dimension)dim );
 185         if ( error )
 186           goto Exit;
 187 
 188         /*
<span class="line-modified"> 189          *  We assume that the glyphs selected for the stem width</span>
<span class="line-modified"> 190          *  computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified"> 191          *  algorithm works fine without adjustments of its scoring</span>
<span class="line-modified"> 192          *  function.</span>
 193          */
 194         af_latin_hints_link_segments( hints,
 195                                       0,
 196                                       NULL,
 197                                       (AF_Dimension)dim );
 198 
 199         seg   = axhints-&gt;segments;
 200         limit = seg + axhints-&gt;num_segments;
 201 
 202         for ( ; seg &lt; limit; seg++ )
 203         {
 204           link = seg-&gt;link;
 205 
 206           /* we only consider stem segments there! */
 207           if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )
 208           {
 209             FT_Pos  dist;
 210 
 211 
 212             dist = seg-&gt;pos - link-&gt;pos;
</pre>
<hr />
<pre>
 290         if ( table[j]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
 291                                  AF_LATIN_BLUE_SUB_TOP ) )
 292           b = table[j]-&gt;ref.org;
 293         else
 294           b = table[j]-&gt;shoot.org;
 295 
 296         if ( b &gt;= a )
 297           break;
 298 
 299         swap         = table[j];
 300         table[j]     = table[j - 1];
 301         table[j - 1] = swap;
 302       }
 303     }
 304   }
 305 
 306 
 307   /* Find all blue zones.  Flat segments give the reference points, */
 308   /* round segments the overshoot positions.                        */
 309 
<span class="line-modified"> 310   static void</span>
 311   af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
 312                                FT_Face          face )
 313   {
 314     FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
 315     FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
 316 
 317     FT_UInt       num_flats;
 318     FT_UInt       num_rounds;
 319 
 320     AF_LatinBlue  blue;
 321     FT_Error      error;
 322     AF_LatinAxis  axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
 323     FT_Outline    outline;
 324 
 325     AF_StyleClass  sc = metrics-&gt;root.style_class;
 326 
 327     AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
 328     const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
 329 
 330     FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
 331 
<span class="line-modified"> 332     void*  shaper_buf;</span>







 333 
 334 
 335     /* we walk over the blue character strings as specified in the */
 336     /* style&#39;s entry in the `af_blue_stringset&#39; array              */
 337 
 338     FT_TRACE5(( &quot;latin blue zones computation\n&quot;
 339                 &quot;============================\n&quot;
 340                 &quot;\n&quot; ));
 341 

 342     shaper_buf = af_shaper_buf_create( face );

 343 
 344     for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
 345     {
 346       const char*  p = &amp;af_blue_strings[bs-&gt;string];
 347       FT_Pos*      blue_ref;
 348       FT_Pos*      blue_shoot;
 349       FT_Pos       ascender;
 350       FT_Pos       descender;
 351 
 352 
 353 #ifdef FT_DEBUG_LEVEL_TRACE
 354       {
 355         FT_Bool  have_flag = 0;
 356 
 357 
 358         FT_TRACE5(( &quot;blue zone %d&quot;, axis-&gt;blue_count ));
 359 
 360         if ( bs-&gt;properties )
 361         {
 362           FT_TRACE5(( &quot; (&quot; ));
</pre>
<hr />
<pre>
 867               best_round      = round;
 868             }
 869           }
 870 
 871         } /* end for loop */
 872 
 873         if ( !( best_y_extremum == FT_INT_MIN ||
 874                 best_y_extremum == FT_INT_MAX ) )
 875         {
 876           if ( best_round )
 877             rounds[num_rounds++] = best_y_extremum;
 878           else
 879             flats[num_flats++]   = best_y_extremum;
 880         }
 881 
 882       } /* end while loop */
 883 
 884       if ( num_flats == 0 &amp;&amp; num_rounds == 0 )
 885       {
 886         /*
<span class="line-modified"> 887          *  we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified"> 888          *  we will simply ignore it then</span>
 889          */
 890         FT_TRACE5(( &quot;  empty\n&quot; ));
 891         continue;
 892       }
 893 
 894       /* we have computed the contents of the `rounds&#39; and `flats&#39; tables, */
 895       /* now determine the reference and overshoot position of the blue -- */
 896       /* we simply take the median value after a simple sort               */
 897       af_sort_pos( num_rounds, rounds );
 898       af_sort_pos( num_flats,  flats );
 899 
 900       blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];
 901       blue_ref   = &amp;blue-&gt;ref.org;
 902       blue_shoot = &amp;blue-&gt;shoot.org;
 903 
 904       axis-&gt;blue_count++;
 905 
 906       if ( num_flats == 0 )
 907       {
 908         *blue_ref   =
</pre>
<hr />
<pre>
 950         blue-&gt;flags |= AF_LATIN_BLUE_SUB_TOP;
 951       if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
 952         blue-&gt;flags |= AF_LATIN_BLUE_NEUTRAL;
 953 
 954       /*
 955        * The following flag is used later to adjust the y and x scales
 956        * in order to optimize the pixel grid alignment of the top of small
 957        * letters.
 958        */
 959       if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
 960         blue-&gt;flags |= AF_LATIN_BLUE_ADJUSTMENT;
 961 
 962       FT_TRACE5(( &quot;    -&gt; reference = %ld\n&quot;
 963                   &quot;       overshoot = %ld\n&quot;,
 964                   *blue_ref, *blue_shoot ));
 965 
 966     } /* end for loop */
 967 
 968     af_shaper_buf_destroy( face, shaper_buf );
 969 
<span class="line-removed"> 970     /* we finally check whether blue zones are ordered; */</span>
<span class="line-removed"> 971     /* `ref&#39; and `shoot&#39; values of two blue zones must not overlap */</span>
 972     if ( axis-&gt;blue_count )
 973     {



 974       FT_UInt       i;
 975       AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
 976 
 977 
 978       for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
 979         blue_sorted[i] = &amp;axis-&gt;blues[i];
 980 
 981       /* sort bottoms of blue zones... */
 982       af_latin_sort_blue( axis-&gt;blue_count, blue_sorted );
 983 
 984       /* ...and adjust top values if necessary */
 985       for ( i = 0; i &lt; axis-&gt;blue_count - 1; i++ )
 986       {
 987         FT_Pos*  a;
 988         FT_Pos*  b;
 989 
 990 #ifdef FT_DEBUG_LEVEL_TRACE
 991         FT_Bool  a_is_top = 0;
 992 #endif
 993 
</pre>
<hr />
<pre>
1002         }
1003         else
1004           a = &amp;blue_sorted[i]-&gt;ref.org;
1005 
1006         if ( blue_sorted[i + 1]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
1007                                            AF_LATIN_BLUE_SUB_TOP ) )
1008           b = &amp;blue_sorted[i + 1]-&gt;shoot.org;
1009         else
1010           b = &amp;blue_sorted[i + 1]-&gt;ref.org;
1011 
1012         if ( *a &gt; *b )
1013         {
1014           *a = *b;
1015           FT_TRACE5(( &quot;blue zone overlap:&quot;
1016                       &quot; adjusting %s %d to %ld\n&quot;,
1017                       a_is_top ? &quot;overshoot&quot; : &quot;reference&quot;,
1018                       blue_sorted[i] - axis-&gt;blues,
1019                       *a ));
1020         }
1021       }




1022     }



1023 
<span class="line-modified">1024     FT_TRACE5(( &quot;\n&quot; ));</span>













1025 
<span class="line-modified">1026     return;</span>



1027   }
1028 
1029 
1030   /* Check whether all ASCII digits have the same advance width. */
1031 
1032   FT_LOCAL_DEF( void )
1033   af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
1034                                  FT_Face          face )
1035   {
1036     FT_Bool   started = 0, same_width = 1;
1037     FT_Fixed  advance = 0, old_advance = 0;
1038 
<span class="line-modified">1039     void*  shaper_buf;</span>







1040 
1041     /* in all supported charmaps, digits have character codes 0x30-0x39 */
1042     const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
1043     const char*  p;
1044 
1045 
<span class="line-modified">1046     p          = digits;</span>


1047     shaper_buf = af_shaper_buf_create( face );

1048 
1049     while ( *p )
1050     {
1051       FT_ULong      glyph_index;
1052       unsigned int  num_idx;
1053 
1054 
1055       /* reject input that maps to more than a single glyph */
1056       p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
1057       if ( num_idx &gt; 1 )
1058         continue;
1059 
1060       glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
1061                                         shaper_buf,
1062                                         0,
1063                                         &amp;advance,
1064                                         NULL );
1065       if ( !glyph_index )
1066         continue;
1067 
</pre>
<hr />
<pre>
1075       }
1076       else
1077       {
1078         old_advance = advance;
1079         started     = 1;
1080       }
1081     }
1082 
1083     af_shaper_buf_destroy( face, shaper_buf );
1084 
1085     metrics-&gt;root.digits_have_same_width = same_width;
1086   }
1087 
1088 
1089   /* Initialize global metrics. */
1090 
1091   FT_LOCAL_DEF( FT_Error )
1092   af_latin_metrics_init( AF_LatinMetrics  metrics,
1093                          FT_Face          face )
1094   {


1095     FT_CharMap  oldmap = face-&gt;charmap;
1096 
1097 
1098     metrics-&gt;units_per_em = face-&gt;units_per_EM;
1099 
1100     if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
1101     {
1102       af_latin_metrics_init_widths( metrics, face );
<span class="line-modified">1103       af_latin_metrics_init_blues( metrics, face );</span>





1104       af_latin_metrics_check_digits( metrics, face );
1105     }
1106 

1107     FT_Set_Charmap( face, oldmap );
<span class="line-modified">1108     return FT_Err_Ok;</span>
1109   }
1110 
1111 
1112   /* Adjust scaling value, then scale and shift widths   */
1113   /* and blue zones (if applicable) for given dimension. */
1114 
1115   static void
1116   af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
1117                               AF_Scaler        scaler,
1118                               AF_Dimension     dim )
1119   {
1120     FT_Fixed      scale;
1121     FT_Pos        delta;
1122     AF_LatinAxis  axis;
1123     FT_UInt       nn;
1124 
1125 
1126     if ( dim == AF_DIMENSION_HORZ )
1127     {
1128       scale = scaler-&gt;x_scale;
</pre>
<hr />
<pre>
1266 
1267     /* scale the widths */
1268     for ( nn = 0; nn &lt; axis-&gt;width_count; nn++ )
1269     {
1270       AF_Width  width = axis-&gt;widths + nn;
1271 
1272 
1273       width-&gt;cur = FT_MulFix( width-&gt;org, scale );
1274       width-&gt;fit = width-&gt;cur;
1275 
1276       FT_TRACE5(( &quot;  %d scaled to %.2f\n&quot;,
1277                   width-&gt;org,
1278                   width-&gt;cur / 64.0 ));
1279     }
1280 
1281     FT_TRACE5(( &quot;\n&quot; ));
1282 
1283     /* an extra-light axis corresponds to a standard width that is */
1284     /* smaller than 5/8 pixels                                     */
1285     axis-&gt;extra_light =
<span class="line-modified">1286       (FT_Bool)( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</span>
1287 
1288 #ifdef FT_DEBUG_LEVEL_TRACE
1289     if ( axis-&gt;extra_light )
1290       FT_TRACE5(( &quot;`%s&#39; style is extra light (at current resolution)\n&quot;
1291                   &quot;\n&quot;,
1292                   af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1293 #endif
1294 
1295     if ( dim == AF_DIMENSION_VERT )
1296     {
1297 #ifdef FT_DEBUG_LEVEL_TRACE
1298       if ( axis-&gt;blue_count )
1299         FT_TRACE5(( &quot;blue zones (style `%s&#39;)\n&quot;,
1300                     af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1301 #endif
1302 
1303       /* scale the blue zones */
1304       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1305       {
1306         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
</pre>
<hr />
<pre>
1402           if ( b-&gt;ref.fit &lt;= blue-&gt;shoot.fit &amp;&amp;
1403                b-&gt;shoot.fit &gt;= blue-&gt;ref.fit )
1404           {
1405             blue-&gt;flags &amp;= ~AF_LATIN_BLUE_ACTIVE;
1406             break;
1407           }
1408         }
1409       }
1410 
1411 #ifdef FT_DEBUG_LEVEL_TRACE
1412       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1413       {
1414         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
1415 
1416 
1417         FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;
1418                     &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,
1419                     nn,
1420                     blue-&gt;ref.org,
1421                     blue-&gt;ref.fit / 64.0,
<span class="line-modified">1422                     blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</span>
<span class="line-modified">1423                                                        : &quot; (inactive)&quot;,</span>
1424                     nn,
1425                     blue-&gt;shoot.org,
1426                     blue-&gt;shoot.fit / 64.0,
<span class="line-modified">1427                     blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</span>
<span class="line-modified">1428                                                        : &quot; (inactive)&quot; ));</span>
1429       }
1430 #endif
1431     }
1432   }
1433 
1434 
1435   /* Scale global values in both directions. */
1436 
1437   FT_LOCAL_DEF( void )
1438   af_latin_metrics_scale( AF_LatinMetrics  metrics,
1439                           AF_Scaler        scaler )
1440   {
1441     metrics-&gt;root.scaler.render_mode = scaler-&gt;render_mode;
1442     metrics-&gt;root.scaler.face        = scaler-&gt;face;
1443     metrics-&gt;root.scaler.flags       = scaler-&gt;flags;
1444 
1445     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
1446     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
1447   }
1448 
</pre>
<hr />
<pre>
1950         if ( seg1-&gt;dir + seg2-&gt;dir == 0 &amp;&amp; pos2 &gt; pos1 )
1951         {
1952           /* compute distance between the two segments */
1953           FT_Pos  min = seg1-&gt;min_coord;
1954           FT_Pos  max = seg1-&gt;max_coord;
1955           FT_Pos  len;
1956 
1957 
1958           if ( min &lt; seg2-&gt;min_coord )
1959             min = seg2-&gt;min_coord;
1960 
1961           if ( max &gt; seg2-&gt;max_coord )
1962             max = seg2-&gt;max_coord;
1963 
1964           /* compute maximum coordinate difference of the two segments */
1965           /* (this is, how much they overlap)                          */
1966           len = max - min;
1967           if ( len &gt;= len_threshold )
1968           {
1969             /*
<span class="line-modified">1970              *  The score is the sum of two demerits indicating the</span>
<span class="line-modified">1971              *  `badness&#39; of a fit, measured along the segments&#39; main axis</span>
<span class="line-modified">1972              *  and orthogonal to it, respectively.</span>
1973              *
<span class="line-modified">1974              *  o The less overlapping along the main axis, the worse it</span>
<span class="line-modified">1975              *    is, causing a larger demerit.</span>
1976              *
<span class="line-modified">1977              *  o The nearer the orthogonal distance to a stem width, the</span>
<span class="line-modified">1978              *    better it is, causing a smaller demerit.  For simplicity,</span>
<span class="line-modified">1979              *    however, we only increase the demerit for values that</span>
<span class="line-modified">1980              *    exceed the largest stem width.</span>
1981              */
1982 
1983             FT_Pos  dist = pos2 - pos1;
1984 
1985             FT_Pos  dist_demerit, score;
1986 
1987 
1988             if ( max_width )
1989             {
1990               /* distance demerits are based on multiples of `max_width&#39;; */
1991               /* we scale by 1024 for getting more precision              */
1992               FT_Pos  delta = ( dist &lt;&lt; 10 ) / max_width - ( 1 &lt;&lt; 10 );
1993 
1994 
1995               if ( delta &gt; 10000 )
1996                 dist_demerit = 32000;
1997               else if ( delta &gt; 0 )
1998                 dist_demerit = delta * delta / dist_score;
1999               else
2000                 dist_demerit = 0;
</pre>
<hr />
<pre>
2032         {
2033           seg1-&gt;link  = 0;
2034           seg1-&gt;serif = seg2-&gt;link;
2035         }
2036       }
2037     }
2038   }
2039 
2040 
2041   /* Link segments to edges, using feature analysis for selection. */
2042 
2043   FT_LOCAL_DEF( FT_Error )
2044   af_latin_hints_compute_edges( AF_GlyphHints  hints,
2045                                 AF_Dimension   dim )
2046   {
2047     AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
2048     FT_Error      error  = FT_Err_Ok;
2049     FT_Memory     memory = hints-&gt;memory;
2050     AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];
2051 
<span class="line-removed">2052 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">2053     AF_FaceGlobals  globals = hints-&gt;metrics-&gt;globals;</span>
<span class="line-removed">2054 #endif</span>
<span class="line-removed">2055 </span>
2056     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">2057     AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-removed">2058                                      [style_class-&gt;script];</span>
2059 
2060     FT_Bool  top_to_bottom_hinting = 0;
2061 
2062     AF_Segment    segments      = axis-&gt;segments;
2063     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
2064     AF_Segment    seg;
2065 
2066 #if 0
2067     AF_Direction  up_dir;
2068 #endif
2069     FT_Fixed      scale;
2070     FT_Pos        edge_distance_threshold;
2071     FT_Pos        segment_length_threshold;
2072     FT_Pos        segment_width_threshold;
2073 
2074 
2075     axis-&gt;num_edges = 0;
2076 
2077     scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
2078                                          : hints-&gt;y_scale;
2079 
2080 #if 0
2081     up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
2082                                           : AF_DIR_RIGHT;
2083 #endif
2084 
2085     if ( dim == AF_DIMENSION_VERT )
2086       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
2087 
2088     /*
<span class="line-modified">2089      *  We ignore all segments that are less than 1 pixel in length</span>
<span class="line-modified">2090      *  to avoid many problems with serif fonts.  We compute the</span>
<span class="line-modified">2091      *  corresponding threshold in font units.</span>
2092      */
2093     if ( dim == AF_DIMENSION_HORZ )
2094       segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );
2095     else
2096       segment_length_threshold = 0;
2097 
2098     /*
<span class="line-modified">2099      *  Similarly, we ignore segments that have a width delta</span>
<span class="line-modified">2100      *  larger than 0.5px (i.e., a width larger than 1px).</span>
2101      */
2102     segment_width_threshold = FT_DivFix( 32, scale );
2103 
<span class="line-modified">2104     /*********************************************************************/</span>
<span class="line-modified">2105     /*                                                                   */</span>
<span class="line-modified">2106     /* We begin by generating a sorted table of edges for the current    */</span>
<span class="line-modified">2107     /* direction.  To do so, we simply scan each segment and try to find */</span>
<span class="line-modified">2108     /* an edge in our table that corresponds to its position.            */</span>
<span class="line-modified">2109     /*                                                                   */</span>
<span class="line-modified">2110     /* If no edge is found, we create and insert a new edge in the       */</span>
<span class="line-modified">2111     /* sorted table.  Otherwise, we simply add the segment to the edge&#39;s */</span>
<span class="line-modified">2112     /* list which gets processed in the second step to compute the       */</span>
<span class="line-modified">2113     /* edge&#39;s properties.                                                */</span>
<span class="line-modified">2114     /*                                                                   */</span>
<span class="line-modified">2115     /* Note that the table of edges is sorted along the segment/edge     */</span>
<span class="line-modified">2116     /* position.                                                         */</span>
<span class="line-modified">2117     /*                                                                   */</span>
<span class="line-modified">2118     /*********************************************************************/</span>
2119 
2120     /* assure that edge distance threshold is at most 0.25px */
2121     edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
2122                                          scale );
2123     if ( edge_distance_threshold &gt; 64 / 4 )
2124       edge_distance_threshold = 64 / 4;
2125 
2126     edge_distance_threshold = FT_DivFix( edge_distance_threshold,
2127                                          scale );
2128 
2129     for ( seg = segments; seg &lt; segment_limit; seg++ )
2130     {
2131       AF_Edge  found = NULL;
2132       FT_Int   ee;
2133 
2134 
2135       /* ignore too short segments, too wide ones, and, in this loop, */
2136       /* one-point segments without a direction                       */
2137       if ( seg-&gt;height &lt; segment_length_threshold ||
2138            seg-&gt;delta &gt; segment_width_threshold   ||
</pre>
<hr />
<pre>
2220         if ( dist &lt; 0 )
2221           dist = -dist;
2222 
2223         if ( dist &lt; edge_distance_threshold )
2224         {
2225           found = edge;
2226           break;
2227         }
2228       }
2229 
2230       /* one-point segments without a match are ignored */
2231       if ( found )
2232       {
2233         seg-&gt;edge_next         = found-&gt;first;
2234         found-&gt;last-&gt;edge_next = seg;
2235         found-&gt;last            = seg;
2236       }
2237     }
2238 
2239 
<span class="line-modified">2240     /******************************************************************/</span>
<span class="line-modified">2241     /*                                                                */</span>
<span class="line-modified">2242     /* Good, we now compute each edge&#39;s properties according to the   */</span>
<span class="line-modified">2243     /* segments found on its position.  Basically, these are          */</span>
<span class="line-modified">2244     /*                                                                */</span>
<span class="line-modified">2245     /*  - the edge&#39;s main direction                                   */</span>
<span class="line-modified">2246     /*  - stem edge, serif edge or both (which defaults to stem then) */</span>
<span class="line-modified">2247     /*  - rounded edge, straight or both (which defaults to straight) */</span>
<span class="line-modified">2248     /*  - link for edge                                               */</span>
<span class="line-modified">2249     /*                                                                */</span>
<span class="line-modified">2250     /******************************************************************/</span>
2251 
2252     /* first of all, set the `edge&#39; field in each segment -- this is */
2253     /* required in order to compute edge links                       */
2254 
2255     /*
2256      * Note that removing this loop and setting the `edge&#39; field of each
2257      * segment directly in the code above slows down execution speed for
2258      * some reasons on platforms like the Sun.
2259      */
2260     {
2261       AF_Edge  edges      = axis-&gt;edges;
2262       AF_Edge  edge_limit = edges + axis-&gt;num_edges;
2263       AF_Edge  edge;
2264 
2265 
2266       for ( edge = edges; edge &lt; edge_limit; edge++ )
2267       {
2268         seg = edge-&gt;first;
2269         if ( seg )
2270           do
</pre>
<hr />
<pre>
2292         {
2293           FT_Bool  is_serif;
2294 
2295 
2296           /* check for roundness of segment */
2297           if ( seg-&gt;flags &amp; AF_EDGE_ROUND )
2298             is_round++;
2299           else
2300             is_straight++;
2301 
2302 #if 0
2303           /* check for segment direction */
2304           if ( seg-&gt;dir == up_dir )
2305             ups   += seg-&gt;max_coord - seg-&gt;min_coord;
2306           else
2307             downs += seg-&gt;max_coord - seg-&gt;min_coord;
2308 #endif
2309 
2310           /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
2311           /* be ignored                                                   */
<span class="line-modified">2312           is_serif = (FT_Bool)( seg-&gt;serif               &amp;&amp;</span>
<span class="line-modified">2313                                 seg-&gt;serif-&gt;edge         &amp;&amp;</span>
<span class="line-modified">2314                                 seg-&gt;serif-&gt;edge != edge );</span>
2315 
2316           if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge ) || is_serif )
2317           {
2318             AF_Edge     edge2;
2319             AF_Segment  seg2;
2320 
2321 
2322             edge2 = edge-&gt;link;
2323             seg2  = seg-&gt;link;
2324 
2325             if ( is_serif )
2326             {
2327               seg2  = seg-&gt;serif;
2328               edge2 = edge-&gt;serif;
2329             }
2330 
2331             if ( edge2 )
2332             {
2333               FT_Pos  edge_delta;
2334               FT_Pos  seg_delta;
</pre>
<hr />
<pre>
2529           edge-&gt;flags |= AF_EDGE_NEUTRAL;
2530       }
2531     }
2532   }
2533 
2534 
2535   /* Initalize hinting engine. */
2536 
2537   static FT_Error
2538   af_latin_hints_init( AF_GlyphHints    hints,
2539                        AF_LatinMetrics  metrics )
2540   {
2541     FT_Render_Mode  mode;
2542     FT_UInt32       scaler_flags, other_flags;
2543     FT_Face         face = metrics-&gt;root.scaler.face;
2544 
2545 
2546     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
2547 
2548     /*
<span class="line-modified">2549      *  correct x_scale and y_scale if needed, since they may have</span>
<span class="line-modified">2550      *  been modified by `af_latin_metrics_scale_dim&#39; above</span>
2551      */
2552     hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
2553     hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
2554     hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
2555     hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
2556 
2557     /* compute flags depending on render mode, etc. */
2558     mode = metrics-&gt;root.scaler.render_mode;
2559 
2560 #if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
2561     if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
2562       metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
2563 #endif
2564 
2565     scaler_flags = hints-&gt;scaler_flags;
2566     other_flags  = 0;
2567 
2568     /*
<span class="line-modified">2569      *  We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">2570      *  horizontal LCD rendering targets only.</span>
2571      */
2572     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
2573       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
2574 
2575     /*
<span class="line-modified">2576      *  We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">2577      *  vertical LCD rendering targets only.</span>
2578      */
2579     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
2580       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
2581 
2582     /*
<span class="line-modified">2583      *  We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
2584      */
2585     if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
2586       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
2587 
2588     if ( mode == FT_RENDER_MODE_MONO )
2589       other_flags |= AF_LATIN_HINTS_MONO;
2590 
2591     /*
<span class="line-modified">2592      *  In `light&#39; or `lcd&#39; mode we disable horizontal hinting completely.</span>
<span class="line-modified">2593      *  We also do it if the face is italic.</span>
2594      *
<span class="line-modified">2595      *  However, if warping is enabled (which only works in `light&#39; hinting</span>
<span class="line-modified">2596      *  mode), advance widths get adjusted, too.</span>
2597      */
2598     if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
2599          ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0          )
2600       scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
2601 
2602 #ifdef AF_CONFIG_OPTION_USE_WARPER
2603     /* get (global) warper flag */
2604     if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )
2605       scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
2606 #endif
2607 
2608     hints-&gt;scaler_flags = scaler_flags;
2609     hints-&gt;other_flags  = other_flags;
2610 
2611     return FT_Err_Ok;
2612   }
2613 
2614 
2615   /*************************************************************************/
2616   /*************************************************************************/
</pre>
<hr />
<pre>
2919   /****                                                                 ****/
2920   /*************************************************************************/
2921   /*************************************************************************/
2922   /*************************************************************************/
2923 
2924 
2925   /* The main grid-fitting routine. */
2926 
2927   static void
2928   af_latin_hint_edges( AF_GlyphHints  hints,
2929                        AF_Dimension   dim )
2930   {
2931     AF_AxisHints  axis       = &amp;hints-&gt;axis[dim];
2932     AF_Edge       edges      = axis-&gt;edges;
2933     AF_Edge       edge_limit = edges + axis-&gt;num_edges;
2934     FT_PtrDist    n_edges;
2935     AF_Edge       edge;
2936     AF_Edge       anchor     = NULL;
2937     FT_Int        has_serifs = 0;
2938 
<span class="line-removed">2939 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">2940     AF_FaceGlobals  globals = hints-&gt;metrics-&gt;globals;</span>
<span class="line-removed">2941 #endif</span>
<span class="line-removed">2942 </span>
2943     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">2944     AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-removed">2945                                      [style_class-&gt;script];</span>
2946 
2947     FT_Bool  top_to_bottom_hinting = 0;
2948 
2949 #ifdef FT_DEBUG_LEVEL_TRACE
2950     FT_UInt  num_actions = 0;
2951 #endif
2952 
2953 
2954     FT_TRACE5(( &quot;latin %s edge hinting (style `%s&#39;)\n&quot;,
2955                 dim == AF_DIMENSION_VERT ? &quot;horizontal&quot; : &quot;vertical&quot;,
2956                 af_style_names[hints-&gt;metrics-&gt;style_class-&gt;style] ));
2957 
2958     if ( dim == AF_DIMENSION_VERT )
2959       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
2960 
2961     /* we begin by aligning all stems relative to the blue zone */
2962     /* if needed -- that&#39;s only for horizontal edges            */
2963 
2964     if ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_BLUES( hints ) )
2965     {
2966       for ( edge = edges; edge &lt; edge_limit; edge++ )
2967       {
2968         AF_Width  blue;
2969         AF_Edge   edge1, edge2; /* these edges form the stem to check */
2970 
2971 
2972         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
2973           continue;
2974 
2975         edge1 = NULL;
2976         edge2 = edge-&gt;link;
2977 
2978         /*
<span class="line-modified">2979          *  If a stem contains both a neutral and a non-neutral blue zone,</span>
<span class="line-modified">2980          *  skip the neutral one.  Otherwise, outlines with different</span>
<span class="line-modified">2981          *  directions might be incorrectly aligned at the same vertical</span>
<span class="line-modified">2982          *  position.</span>
2983          *
<span class="line-modified">2984          *  If we have two neutral blue zones, skip one of them.</span>
2985          *
2986          */
2987         if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )
2988         {
2989           FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;
2990           FT_Byte  neutral2 = edge2-&gt;flags &amp; AF_EDGE_NEUTRAL;
2991 
2992 
2993           if ( neutral2 )
2994           {
2995             edge2-&gt;blue_edge = NULL;
2996             edge2-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
2997           }
2998           else if ( neutral )
2999           {
3000             edge-&gt;blue_edge = NULL;
3001             edge-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
3002           }
3003         }
3004 
</pre>
<hr />
<pre>
3327         edge3-&gt;pos -= delta;
3328         if ( edge3-&gt;link )
3329           edge3-&gt;link-&gt;pos -= delta;
3330 
3331         /* move the serifs along with the stem */
3332         if ( n_edges == 12 )
3333         {
3334           ( edges + 8 )-&gt;pos -= delta;
3335           ( edges + 11 )-&gt;pos -= delta;
3336         }
3337 
3338         edge3-&gt;flags |= AF_EDGE_DONE;
3339         if ( edge3-&gt;link )
3340           edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;
3341       }
3342     }
3343 
3344     if ( has_serifs || !anchor )
3345     {
3346       /*
<span class="line-modified">3347        *  now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">3348        *  to complete our processing</span>
3349        */
3350       for ( edge = edges; edge &lt; edge_limit; edge++ )
3351       {
3352         FT_Pos  delta;
3353 
3354 
3355         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3356           continue;
3357 
3358         delta = 1000;
3359 
3360         if ( edge-&gt;serif )
3361         {
3362           delta = edge-&gt;serif-&gt;opos - edge-&gt;opos;
3363           if ( delta &lt; 0 )
3364             delta = -delta;
3365         }
3366 
3367         if ( delta &lt; 64 + 16 )
3368         {
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * aflatin.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auto-fitter hinting routines for latin writing system (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_ADVANCES_H
  21 #include FT_INTERNAL_DEBUG_H
  22 
  23 #include &quot;afglobal.h&quot;

  24 #include &quot;aflatin.h&quot;
  25 #include &quot;aferrors.h&quot;
  26 
  27 
  28 #ifdef AF_CONFIG_OPTION_USE_WARPER
  29 #include &quot;afwarp.h&quot;
  30 #endif
  31 
  32 
<span class="line-modified">  33   /**************************************************************************</span>
<span class="line-modified">  34    *</span>
<span class="line-modified">  35    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  36    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  37    * messages during execution.</span>
<span class="line-modified">  38    */</span>
  39 #undef  FT_COMPONENT
<span class="line-modified">  40 #define FT_COMPONENT  aflatin</span>
  41 
  42 
  43   /* needed for computation of round vs. flat segments */
  44 #define FLAT_THRESHOLD( x )  ( x / 14 )
  45 
  46 
  47   /*************************************************************************/
  48   /*************************************************************************/
  49   /*****                                                               *****/
  50   /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  51   /*****                                                               *****/
  52   /*************************************************************************/
  53   /*************************************************************************/
  54 
  55 
  56   /* Find segments and links, compute all stem widths, and initialize */
  57   /* standard width and height for the glyph with given charcode.     */
  58 
  59   FT_LOCAL_DEF( void )
  60   af_latin_metrics_init_widths( AF_LatinMetrics  metrics,
</pre>
<hr />
<pre>
  65 
  66 
  67     FT_TRACE5(( &quot;\n&quot;
  68                 &quot;latin standard widths computation (style `%s&#39;)\n&quot;
  69                 &quot;=====================================================\n&quot;
  70                 &quot;\n&quot;,
  71                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
  72 
  73     af_glyph_hints_init( hints, face-&gt;memory );
  74 
  75     metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;
  76     metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;
  77 
  78     {
  79       FT_Error            error;
  80       FT_ULong            glyph_index;
  81       int                 dim;
  82       AF_LatinMetricsRec  dummy[1];
  83       AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;
  84 




  85       AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">  86       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="line-modified">  87 </span>
<span class="line-added">  88       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">  89       /* unsigned long value.                                        */</span>
<span class="line-added">  90 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">  91       void*     shaper_buf;</span>
<span class="line-added">  92 #else</span>
<span class="line-added">  93       FT_ULong  shaper_buf_;</span>
<span class="line-added">  94       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">  95 #endif</span>
  96 

  97       const char*  p;
  98 
  99 #ifdef FT_DEBUG_LEVEL_TRACE
 100       FT_ULong  ch = 0;
 101 #endif
 102 


 103 
<span class="line-added"> 104       p = script_class-&gt;standard_charstring;</span>
<span class="line-added"> 105 </span>
<span class="line-added"> 106 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 107       shaper_buf = af_shaper_buf_create( face );</span>
<span class="line-added"> 108 #endif</span>
 109       /*
 110        * We check a list of standard characters to catch features like
 111        * `c2sc&#39; (small caps from caps) that don&#39;t contain lowercase letters
 112        * by definition, or other features that mainly operate on numerals.
 113        * The first match wins.
 114        */
 115 
 116       glyph_index = 0;
 117       while ( *p )
 118       {
 119         unsigned int  num_idx;
 120 
 121 #ifdef FT_DEBUG_LEVEL_TRACE
 122         const char*  p_old;
 123 #endif
 124 
 125 
 126         while ( *p == &#39; &#39; )
 127           p++;
 128 
</pre>
<hr />
<pre>
 132 #endif
 133 
 134         /* reject input that maps to more than a single glyph */
 135         p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 136         if ( num_idx &gt; 1 )
 137           continue;
 138 
 139         /* otherwise exit loop if we have a result */
 140         glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 141                                           shaper_buf,
 142                                           0,
 143                                           NULL,
 144                                           NULL );
 145         if ( glyph_index )
 146           break;
 147       }
 148 
 149       af_shaper_buf_destroy( face, shaper_buf );
 150 
 151       if ( !glyph_index )
<span class="line-added"> 152       {</span>
<span class="line-added"> 153         FT_TRACE5(( &quot;standard character missing;&quot;</span>
<span class="line-added"> 154                     &quot; using fallback stem widths\n&quot; ));</span>
 155         goto Exit;
<span class="line-added"> 156       }</span>
 157 
 158       FT_TRACE5(( &quot;standard character: U+%04lX (glyph index %d)\n&quot;,
 159                   ch, glyph_index ));
 160 
 161       error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
 162       if ( error || face-&gt;glyph-&gt;outline.n_points &lt;= 0 )
 163         goto Exit;
 164 
 165       FT_ZERO( dummy );
 166 
 167       dummy-&gt;units_per_em = metrics-&gt;units_per_em;
 168 
 169       scaler-&gt;x_scale = 0x10000L;
 170       scaler-&gt;y_scale = 0x10000L;
 171       scaler-&gt;x_delta = 0;
 172       scaler-&gt;y_delta = 0;
 173 
 174       scaler-&gt;face        = face;
 175       scaler-&gt;render_mode = FT_RENDER_MODE_NORMAL;
 176       scaler-&gt;flags       = 0;
</pre>
<hr />
<pre>
 178       af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
 179 
 180       error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );
 181       if ( error )
 182         goto Exit;
 183 
 184       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 185       {
 186         AF_LatinAxis  axis    = &amp;metrics-&gt;axis[dim];
 187         AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];
 188         AF_Segment    seg, limit, link;
 189         FT_UInt       num_widths = 0;
 190 
 191 
 192         error = af_latin_hints_compute_segments( hints,
 193                                                  (AF_Dimension)dim );
 194         if ( error )
 195           goto Exit;
 196 
 197         /*
<span class="line-modified"> 198          * We assume that the glyphs selected for the stem width</span>
<span class="line-modified"> 199          * computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified"> 200          * algorithm works fine without adjustments of its scoring</span>
<span class="line-modified"> 201          * function.</span>
 202          */
 203         af_latin_hints_link_segments( hints,
 204                                       0,
 205                                       NULL,
 206                                       (AF_Dimension)dim );
 207 
 208         seg   = axhints-&gt;segments;
 209         limit = seg + axhints-&gt;num_segments;
 210 
 211         for ( ; seg &lt; limit; seg++ )
 212         {
 213           link = seg-&gt;link;
 214 
 215           /* we only consider stem segments there! */
 216           if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )
 217           {
 218             FT_Pos  dist;
 219 
 220 
 221             dist = seg-&gt;pos - link-&gt;pos;
</pre>
<hr />
<pre>
 299         if ( table[j]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
 300                                  AF_LATIN_BLUE_SUB_TOP ) )
 301           b = table[j]-&gt;ref.org;
 302         else
 303           b = table[j]-&gt;shoot.org;
 304 
 305         if ( b &gt;= a )
 306           break;
 307 
 308         swap         = table[j];
 309         table[j]     = table[j - 1];
 310         table[j - 1] = swap;
 311       }
 312     }
 313   }
 314 
 315 
 316   /* Find all blue zones.  Flat segments give the reference points, */
 317   /* round segments the overshoot positions.                        */
 318 
<span class="line-modified"> 319   static int</span>
 320   af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
 321                                FT_Face          face )
 322   {
 323     FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
 324     FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
 325 
 326     FT_UInt       num_flats;
 327     FT_UInt       num_rounds;
 328 
 329     AF_LatinBlue  blue;
 330     FT_Error      error;
 331     AF_LatinAxis  axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
 332     FT_Outline    outline;
 333 
 334     AF_StyleClass  sc = metrics-&gt;root.style_class;
 335 
 336     AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
 337     const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
 338 
 339     FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
 340 
<span class="line-modified"> 341     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added"> 342     /* unsigned long value.                                        */</span>
<span class="line-added"> 343 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 344     void*     shaper_buf;</span>
<span class="line-added"> 345 #else</span>
<span class="line-added"> 346     FT_ULong  shaper_buf_;</span>
<span class="line-added"> 347     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added"> 348 #endif</span>
 349 
 350 
 351     /* we walk over the blue character strings as specified in the */
 352     /* style&#39;s entry in the `af_blue_stringset&#39; array              */
 353 
 354     FT_TRACE5(( &quot;latin blue zones computation\n&quot;
 355                 &quot;============================\n&quot;
 356                 &quot;\n&quot; ));
 357 
<span class="line-added"> 358 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
 359     shaper_buf = af_shaper_buf_create( face );
<span class="line-added"> 360 #endif</span>
 361 
 362     for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
 363     {
 364       const char*  p = &amp;af_blue_strings[bs-&gt;string];
 365       FT_Pos*      blue_ref;
 366       FT_Pos*      blue_shoot;
 367       FT_Pos       ascender;
 368       FT_Pos       descender;
 369 
 370 
 371 #ifdef FT_DEBUG_LEVEL_TRACE
 372       {
 373         FT_Bool  have_flag = 0;
 374 
 375 
 376         FT_TRACE5(( &quot;blue zone %d&quot;, axis-&gt;blue_count ));
 377 
 378         if ( bs-&gt;properties )
 379         {
 380           FT_TRACE5(( &quot; (&quot; ));
</pre>
<hr />
<pre>
 885               best_round      = round;
 886             }
 887           }
 888 
 889         } /* end for loop */
 890 
 891         if ( !( best_y_extremum == FT_INT_MIN ||
 892                 best_y_extremum == FT_INT_MAX ) )
 893         {
 894           if ( best_round )
 895             rounds[num_rounds++] = best_y_extremum;
 896           else
 897             flats[num_flats++]   = best_y_extremum;
 898         }
 899 
 900       } /* end while loop */
 901 
 902       if ( num_flats == 0 &amp;&amp; num_rounds == 0 )
 903       {
 904         /*
<span class="line-modified"> 905          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified"> 906          * we will simply ignore it then</span>
 907          */
 908         FT_TRACE5(( &quot;  empty\n&quot; ));
 909         continue;
 910       }
 911 
 912       /* we have computed the contents of the `rounds&#39; and `flats&#39; tables, */
 913       /* now determine the reference and overshoot position of the blue -- */
 914       /* we simply take the median value after a simple sort               */
 915       af_sort_pos( num_rounds, rounds );
 916       af_sort_pos( num_flats,  flats );
 917 
 918       blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];
 919       blue_ref   = &amp;blue-&gt;ref.org;
 920       blue_shoot = &amp;blue-&gt;shoot.org;
 921 
 922       axis-&gt;blue_count++;
 923 
 924       if ( num_flats == 0 )
 925       {
 926         *blue_ref   =
</pre>
<hr />
<pre>
 968         blue-&gt;flags |= AF_LATIN_BLUE_SUB_TOP;
 969       if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
 970         blue-&gt;flags |= AF_LATIN_BLUE_NEUTRAL;
 971 
 972       /*
 973        * The following flag is used later to adjust the y and x scales
 974        * in order to optimize the pixel grid alignment of the top of small
 975        * letters.
 976        */
 977       if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
 978         blue-&gt;flags |= AF_LATIN_BLUE_ADJUSTMENT;
 979 
 980       FT_TRACE5(( &quot;    -&gt; reference = %ld\n&quot;
 981                   &quot;       overshoot = %ld\n&quot;,
 982                   *blue_ref, *blue_shoot ));
 983 
 984     } /* end for loop */
 985 
 986     af_shaper_buf_destroy( face, shaper_buf );
 987 


 988     if ( axis-&gt;blue_count )
 989     {
<span class="line-added"> 990       /* we finally check whether blue zones are ordered;            */</span>
<span class="line-added"> 991       /* `ref&#39; and `shoot&#39; values of two blue zones must not overlap */</span>
<span class="line-added"> 992 </span>
 993       FT_UInt       i;
 994       AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
 995 
 996 
 997       for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
 998         blue_sorted[i] = &amp;axis-&gt;blues[i];
 999 
1000       /* sort bottoms of blue zones... */
1001       af_latin_sort_blue( axis-&gt;blue_count, blue_sorted );
1002 
1003       /* ...and adjust top values if necessary */
1004       for ( i = 0; i &lt; axis-&gt;blue_count - 1; i++ )
1005       {
1006         FT_Pos*  a;
1007         FT_Pos*  b;
1008 
1009 #ifdef FT_DEBUG_LEVEL_TRACE
1010         FT_Bool  a_is_top = 0;
1011 #endif
1012 
</pre>
<hr />
<pre>
1021         }
1022         else
1023           a = &amp;blue_sorted[i]-&gt;ref.org;
1024 
1025         if ( blue_sorted[i + 1]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
1026                                            AF_LATIN_BLUE_SUB_TOP ) )
1027           b = &amp;blue_sorted[i + 1]-&gt;shoot.org;
1028         else
1029           b = &amp;blue_sorted[i + 1]-&gt;ref.org;
1030 
1031         if ( *a &gt; *b )
1032         {
1033           *a = *b;
1034           FT_TRACE5(( &quot;blue zone overlap:&quot;
1035                       &quot; adjusting %s %d to %ld\n&quot;,
1036                       a_is_top ? &quot;overshoot&quot; : &quot;reference&quot;,
1037                       blue_sorted[i] - axis-&gt;blues,
1038                       *a ));
1039         }
1040       }
<span class="line-added">1041 </span>
<span class="line-added">1042       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">1043 </span>
<span class="line-added">1044       return 0;</span>
1045     }
<span class="line-added">1046     else</span>
<span class="line-added">1047     {</span>
<span class="line-added">1048       /* disable hinting for the current style if there are no blue zones */</span>
1049 
<span class="line-modified">1050       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-added">1051       FT_UShort*      gstyles = globals-&gt;glyph_styles;</span>
<span class="line-added">1052 </span>
<span class="line-added">1053       FT_Long  i;</span>
<span class="line-added">1054 </span>
<span class="line-added">1055 </span>
<span class="line-added">1056       FT_TRACE5(( &quot;no blue zones found:&quot;</span>
<span class="line-added">1057                   &quot; hinting disabled for this style\n&quot; ));</span>
<span class="line-added">1058 </span>
<span class="line-added">1059       for ( i = 0; i &lt; globals-&gt;glyph_count; i++ )</span>
<span class="line-added">1060       {</span>
<span class="line-added">1061         if ( ( gstyles[i] &amp; AF_STYLE_MASK ) == sc-&gt;style )</span>
<span class="line-added">1062           gstyles[i] = AF_STYLE_NONE_DFLT;</span>
<span class="line-added">1063       }</span>
1064 
<span class="line-modified">1065       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">1066 </span>
<span class="line-added">1067       return 1;</span>
<span class="line-added">1068     }</span>
1069   }
1070 
1071 
1072   /* Check whether all ASCII digits have the same advance width. */
1073 
1074   FT_LOCAL_DEF( void )
1075   af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
1076                                  FT_Face          face )
1077   {
1078     FT_Bool   started = 0, same_width = 1;
1079     FT_Fixed  advance = 0, old_advance = 0;
1080 
<span class="line-modified">1081     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">1082     /* unsigned long value.                                        */</span>
<span class="line-added">1083 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">1084     void*     shaper_buf;</span>
<span class="line-added">1085 #else</span>
<span class="line-added">1086     FT_ULong  shaper_buf_;</span>
<span class="line-added">1087     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">1088 #endif</span>
1089 
1090     /* in all supported charmaps, digits have character codes 0x30-0x39 */
1091     const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
1092     const char*  p;
1093 
1094 
<span class="line-modified">1095     p = digits;</span>
<span class="line-added">1096 </span>
<span class="line-added">1097 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
1098     shaper_buf = af_shaper_buf_create( face );
<span class="line-added">1099 #endif</span>
1100 
1101     while ( *p )
1102     {
1103       FT_ULong      glyph_index;
1104       unsigned int  num_idx;
1105 
1106 
1107       /* reject input that maps to more than a single glyph */
1108       p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
1109       if ( num_idx &gt; 1 )
1110         continue;
1111 
1112       glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
1113                                         shaper_buf,
1114                                         0,
1115                                         &amp;advance,
1116                                         NULL );
1117       if ( !glyph_index )
1118         continue;
1119 
</pre>
<hr />
<pre>
1127       }
1128       else
1129       {
1130         old_advance = advance;
1131         started     = 1;
1132       }
1133     }
1134 
1135     af_shaper_buf_destroy( face, shaper_buf );
1136 
1137     metrics-&gt;root.digits_have_same_width = same_width;
1138   }
1139 
1140 
1141   /* Initialize global metrics. */
1142 
1143   FT_LOCAL_DEF( FT_Error )
1144   af_latin_metrics_init( AF_LatinMetrics  metrics,
1145                          FT_Face          face )
1146   {
<span class="line-added">1147     FT_Error  error = FT_Err_Ok;</span>
<span class="line-added">1148 </span>
1149     FT_CharMap  oldmap = face-&gt;charmap;
1150 
1151 
1152     metrics-&gt;units_per_em = face-&gt;units_per_EM;
1153 
1154     if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
1155     {
1156       af_latin_metrics_init_widths( metrics, face );
<span class="line-modified">1157       if ( af_latin_metrics_init_blues( metrics, face ) )</span>
<span class="line-added">1158       {</span>
<span class="line-added">1159         /* use internal error code to indicate missing blue zones */</span>
<span class="line-added">1160         error = -1;</span>
<span class="line-added">1161         goto Exit;</span>
<span class="line-added">1162       }</span>
1163       af_latin_metrics_check_digits( metrics, face );
1164     }
1165 
<span class="line-added">1166   Exit:</span>
1167     FT_Set_Charmap( face, oldmap );
<span class="line-modified">1168     return error;</span>
1169   }
1170 
1171 
1172   /* Adjust scaling value, then scale and shift widths   */
1173   /* and blue zones (if applicable) for given dimension. */
1174 
1175   static void
1176   af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
1177                               AF_Scaler        scaler,
1178                               AF_Dimension     dim )
1179   {
1180     FT_Fixed      scale;
1181     FT_Pos        delta;
1182     AF_LatinAxis  axis;
1183     FT_UInt       nn;
1184 
1185 
1186     if ( dim == AF_DIMENSION_HORZ )
1187     {
1188       scale = scaler-&gt;x_scale;
</pre>
<hr />
<pre>
1326 
1327     /* scale the widths */
1328     for ( nn = 0; nn &lt; axis-&gt;width_count; nn++ )
1329     {
1330       AF_Width  width = axis-&gt;widths + nn;
1331 
1332 
1333       width-&gt;cur = FT_MulFix( width-&gt;org, scale );
1334       width-&gt;fit = width-&gt;cur;
1335 
1336       FT_TRACE5(( &quot;  %d scaled to %.2f\n&quot;,
1337                   width-&gt;org,
1338                   width-&gt;cur / 64.0 ));
1339     }
1340 
1341     FT_TRACE5(( &quot;\n&quot; ));
1342 
1343     /* an extra-light axis corresponds to a standard width that is */
1344     /* smaller than 5/8 pixels                                     */
1345     axis-&gt;extra_light =
<span class="line-modified">1346       FT_BOOL( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</span>
1347 
1348 #ifdef FT_DEBUG_LEVEL_TRACE
1349     if ( axis-&gt;extra_light )
1350       FT_TRACE5(( &quot;`%s&#39; style is extra light (at current resolution)\n&quot;
1351                   &quot;\n&quot;,
1352                   af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1353 #endif
1354 
1355     if ( dim == AF_DIMENSION_VERT )
1356     {
1357 #ifdef FT_DEBUG_LEVEL_TRACE
1358       if ( axis-&gt;blue_count )
1359         FT_TRACE5(( &quot;blue zones (style `%s&#39;)\n&quot;,
1360                     af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1361 #endif
1362 
1363       /* scale the blue zones */
1364       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1365       {
1366         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
</pre>
<hr />
<pre>
1462           if ( b-&gt;ref.fit &lt;= blue-&gt;shoot.fit &amp;&amp;
1463                b-&gt;shoot.fit &gt;= blue-&gt;ref.fit )
1464           {
1465             blue-&gt;flags &amp;= ~AF_LATIN_BLUE_ACTIVE;
1466             break;
1467           }
1468         }
1469       }
1470 
1471 #ifdef FT_DEBUG_LEVEL_TRACE
1472       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1473       {
1474         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
1475 
1476 
1477         FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;
1478                     &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,
1479                     nn,
1480                     blue-&gt;ref.org,
1481                     blue-&gt;ref.fit / 64.0,
<span class="line-modified">1482                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">1483                                                            : &quot; (inactive)&quot;,</span>
1484                     nn,
1485                     blue-&gt;shoot.org,
1486                     blue-&gt;shoot.fit / 64.0,
<span class="line-modified">1487                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">1488                                                            : &quot; (inactive)&quot; ));</span>
1489       }
1490 #endif
1491     }
1492   }
1493 
1494 
1495   /* Scale global values in both directions. */
1496 
1497   FT_LOCAL_DEF( void )
1498   af_latin_metrics_scale( AF_LatinMetrics  metrics,
1499                           AF_Scaler        scaler )
1500   {
1501     metrics-&gt;root.scaler.render_mode = scaler-&gt;render_mode;
1502     metrics-&gt;root.scaler.face        = scaler-&gt;face;
1503     metrics-&gt;root.scaler.flags       = scaler-&gt;flags;
1504 
1505     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
1506     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
1507   }
1508 
</pre>
<hr />
<pre>
2010         if ( seg1-&gt;dir + seg2-&gt;dir == 0 &amp;&amp; pos2 &gt; pos1 )
2011         {
2012           /* compute distance between the two segments */
2013           FT_Pos  min = seg1-&gt;min_coord;
2014           FT_Pos  max = seg1-&gt;max_coord;
2015           FT_Pos  len;
2016 
2017 
2018           if ( min &lt; seg2-&gt;min_coord )
2019             min = seg2-&gt;min_coord;
2020 
2021           if ( max &gt; seg2-&gt;max_coord )
2022             max = seg2-&gt;max_coord;
2023 
2024           /* compute maximum coordinate difference of the two segments */
2025           /* (this is, how much they overlap)                          */
2026           len = max - min;
2027           if ( len &gt;= len_threshold )
2028           {
2029             /*
<span class="line-modified">2030              * The score is the sum of two demerits indicating the</span>
<span class="line-modified">2031              * `badness&#39; of a fit, measured along the segments&#39; main axis</span>
<span class="line-modified">2032              * and orthogonal to it, respectively.</span>
2033              *
<span class="line-modified">2034              * - The less overlapping along the main axis, the worse it</span>
<span class="line-modified">2035              *   is, causing a larger demerit.</span>
2036              *
<span class="line-modified">2037              * - The nearer the orthogonal distance to a stem width, the</span>
<span class="line-modified">2038              *   better it is, causing a smaller demerit.  For simplicity,</span>
<span class="line-modified">2039              *   however, we only increase the demerit for values that</span>
<span class="line-modified">2040              *   exceed the largest stem width.</span>
2041              */
2042 
2043             FT_Pos  dist = pos2 - pos1;
2044 
2045             FT_Pos  dist_demerit, score;
2046 
2047 
2048             if ( max_width )
2049             {
2050               /* distance demerits are based on multiples of `max_width&#39;; */
2051               /* we scale by 1024 for getting more precision              */
2052               FT_Pos  delta = ( dist &lt;&lt; 10 ) / max_width - ( 1 &lt;&lt; 10 );
2053 
2054 
2055               if ( delta &gt; 10000 )
2056                 dist_demerit = 32000;
2057               else if ( delta &gt; 0 )
2058                 dist_demerit = delta * delta / dist_score;
2059               else
2060                 dist_demerit = 0;
</pre>
<hr />
<pre>
2092         {
2093           seg1-&gt;link  = 0;
2094           seg1-&gt;serif = seg2-&gt;link;
2095         }
2096       }
2097     }
2098   }
2099 
2100 
2101   /* Link segments to edges, using feature analysis for selection. */
2102 
2103   FT_LOCAL_DEF( FT_Error )
2104   af_latin_hints_compute_edges( AF_GlyphHints  hints,
2105                                 AF_Dimension   dim )
2106   {
2107     AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
2108     FT_Error      error  = FT_Err_Ok;
2109     FT_Memory     memory = hints-&gt;memory;
2110     AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];
2111 




2112     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">2113     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>

2114 
2115     FT_Bool  top_to_bottom_hinting = 0;
2116 
2117     AF_Segment    segments      = axis-&gt;segments;
2118     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
2119     AF_Segment    seg;
2120 
2121 #if 0
2122     AF_Direction  up_dir;
2123 #endif
2124     FT_Fixed      scale;
2125     FT_Pos        edge_distance_threshold;
2126     FT_Pos        segment_length_threshold;
2127     FT_Pos        segment_width_threshold;
2128 
2129 
2130     axis-&gt;num_edges = 0;
2131 
2132     scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
2133                                          : hints-&gt;y_scale;
2134 
2135 #if 0
2136     up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
2137                                           : AF_DIR_RIGHT;
2138 #endif
2139 
2140     if ( dim == AF_DIMENSION_VERT )
2141       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
2142 
2143     /*
<span class="line-modified">2144      * We ignore all segments that are less than 1 pixel in length</span>
<span class="line-modified">2145      * to avoid many problems with serif fonts.  We compute the</span>
<span class="line-modified">2146      * corresponding threshold in font units.</span>
2147      */
2148     if ( dim == AF_DIMENSION_HORZ )
2149       segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );
2150     else
2151       segment_length_threshold = 0;
2152 
2153     /*
<span class="line-modified">2154      * Similarly, we ignore segments that have a width delta</span>
<span class="line-modified">2155      * larger than 0.5px (i.e., a width larger than 1px).</span>
2156      */
2157     segment_width_threshold = FT_DivFix( 32, scale );
2158 
<span class="line-modified">2159     /**********************************************************************</span>
<span class="line-modified">2160      *</span>
<span class="line-modified">2161      * We begin by generating a sorted table of edges for the current</span>
<span class="line-modified">2162      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="line-modified">2163      * an edge in our table that corresponds to its position.</span>
<span class="line-modified">2164      *</span>
<span class="line-modified">2165      * If no edge is found, we create and insert a new edge in the</span>
<span class="line-modified">2166      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="line-modified">2167      * list which gets processed in the second step to compute the</span>
<span class="line-modified">2168      * edge&#39;s properties.</span>
<span class="line-modified">2169      *</span>
<span class="line-modified">2170      * Note that the table of edges is sorted along the segment/edge</span>
<span class="line-modified">2171      * position.</span>
<span class="line-modified">2172      *</span>
<span class="line-modified">2173      */</span>
2174 
2175     /* assure that edge distance threshold is at most 0.25px */
2176     edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
2177                                          scale );
2178     if ( edge_distance_threshold &gt; 64 / 4 )
2179       edge_distance_threshold = 64 / 4;
2180 
2181     edge_distance_threshold = FT_DivFix( edge_distance_threshold,
2182                                          scale );
2183 
2184     for ( seg = segments; seg &lt; segment_limit; seg++ )
2185     {
2186       AF_Edge  found = NULL;
2187       FT_Int   ee;
2188 
2189 
2190       /* ignore too short segments, too wide ones, and, in this loop, */
2191       /* one-point segments without a direction                       */
2192       if ( seg-&gt;height &lt; segment_length_threshold ||
2193            seg-&gt;delta &gt; segment_width_threshold   ||
</pre>
<hr />
<pre>
2275         if ( dist &lt; 0 )
2276           dist = -dist;
2277 
2278         if ( dist &lt; edge_distance_threshold )
2279         {
2280           found = edge;
2281           break;
2282         }
2283       }
2284 
2285       /* one-point segments without a match are ignored */
2286       if ( found )
2287       {
2288         seg-&gt;edge_next         = found-&gt;first;
2289         found-&gt;last-&gt;edge_next = seg;
2290         found-&gt;last            = seg;
2291       }
2292     }
2293 
2294 
<span class="line-modified">2295     /*******************************************************************</span>
<span class="line-modified">2296      *</span>
<span class="line-modified">2297      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="line-modified">2298      * segments found on its position.  Basically, these are</span>
<span class="line-modified">2299      *</span>
<span class="line-modified">2300      * - the edge&#39;s main direction</span>
<span class="line-modified">2301      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="line-modified">2302      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="line-modified">2303      * - link for edge</span>
<span class="line-modified">2304      *</span>
<span class="line-modified">2305      */</span>
2306 
2307     /* first of all, set the `edge&#39; field in each segment -- this is */
2308     /* required in order to compute edge links                       */
2309 
2310     /*
2311      * Note that removing this loop and setting the `edge&#39; field of each
2312      * segment directly in the code above slows down execution speed for
2313      * some reasons on platforms like the Sun.
2314      */
2315     {
2316       AF_Edge  edges      = axis-&gt;edges;
2317       AF_Edge  edge_limit = edges + axis-&gt;num_edges;
2318       AF_Edge  edge;
2319 
2320 
2321       for ( edge = edges; edge &lt; edge_limit; edge++ )
2322       {
2323         seg = edge-&gt;first;
2324         if ( seg )
2325           do
</pre>
<hr />
<pre>
2347         {
2348           FT_Bool  is_serif;
2349 
2350 
2351           /* check for roundness of segment */
2352           if ( seg-&gt;flags &amp; AF_EDGE_ROUND )
2353             is_round++;
2354           else
2355             is_straight++;
2356 
2357 #if 0
2358           /* check for segment direction */
2359           if ( seg-&gt;dir == up_dir )
2360             ups   += seg-&gt;max_coord - seg-&gt;min_coord;
2361           else
2362             downs += seg-&gt;max_coord - seg-&gt;min_coord;
2363 #endif
2364 
2365           /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
2366           /* be ignored                                                   */
<span class="line-modified">2367           is_serif = FT_BOOL( seg-&gt;serif               &amp;&amp;</span>
<span class="line-modified">2368                               seg-&gt;serif-&gt;edge         &amp;&amp;</span>
<span class="line-modified">2369                               seg-&gt;serif-&gt;edge != edge );</span>
2370 
2371           if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge ) || is_serif )
2372           {
2373             AF_Edge     edge2;
2374             AF_Segment  seg2;
2375 
2376 
2377             edge2 = edge-&gt;link;
2378             seg2  = seg-&gt;link;
2379 
2380             if ( is_serif )
2381             {
2382               seg2  = seg-&gt;serif;
2383               edge2 = edge-&gt;serif;
2384             }
2385 
2386             if ( edge2 )
2387             {
2388               FT_Pos  edge_delta;
2389               FT_Pos  seg_delta;
</pre>
<hr />
<pre>
2584           edge-&gt;flags |= AF_EDGE_NEUTRAL;
2585       }
2586     }
2587   }
2588 
2589 
2590   /* Initalize hinting engine. */
2591 
2592   static FT_Error
2593   af_latin_hints_init( AF_GlyphHints    hints,
2594                        AF_LatinMetrics  metrics )
2595   {
2596     FT_Render_Mode  mode;
2597     FT_UInt32       scaler_flags, other_flags;
2598     FT_Face         face = metrics-&gt;root.scaler.face;
2599 
2600 
2601     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
2602 
2603     /*
<span class="line-modified">2604      * correct x_scale and y_scale if needed, since they may have</span>
<span class="line-modified">2605      * been modified by `af_latin_metrics_scale_dim&#39; above</span>
2606      */
2607     hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
2608     hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
2609     hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
2610     hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
2611 
2612     /* compute flags depending on render mode, etc. */
2613     mode = metrics-&gt;root.scaler.render_mode;
2614 
2615 #if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
2616     if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
2617       metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
2618 #endif
2619 
2620     scaler_flags = hints-&gt;scaler_flags;
2621     other_flags  = 0;
2622 
2623     /*
<span class="line-modified">2624      * We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">2625      * horizontal LCD rendering targets only.</span>
2626      */
2627     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
2628       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
2629 
2630     /*
<span class="line-modified">2631      * We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">2632      * vertical LCD rendering targets only.</span>
2633      */
2634     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
2635       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
2636 
2637     /*
<span class="line-modified">2638      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
2639      */
2640     if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
2641       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
2642 
2643     if ( mode == FT_RENDER_MODE_MONO )
2644       other_flags |= AF_LATIN_HINTS_MONO;
2645 
2646     /*
<span class="line-modified">2647      * In `light&#39; or `lcd&#39; mode we disable horizontal hinting completely.</span>
<span class="line-modified">2648      * We also do it if the face is italic.</span>
2649      *
<span class="line-modified">2650      * However, if warping is enabled (which only works in `light&#39; hinting</span>
<span class="line-modified">2651      * mode), advance widths get adjusted, too.</span>
2652      */
2653     if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
2654          ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0          )
2655       scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
2656 
2657 #ifdef AF_CONFIG_OPTION_USE_WARPER
2658     /* get (global) warper flag */
2659     if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )
2660       scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
2661 #endif
2662 
2663     hints-&gt;scaler_flags = scaler_flags;
2664     hints-&gt;other_flags  = other_flags;
2665 
2666     return FT_Err_Ok;
2667   }
2668 
2669 
2670   /*************************************************************************/
2671   /*************************************************************************/
</pre>
<hr />
<pre>
2974   /****                                                                 ****/
2975   /*************************************************************************/
2976   /*************************************************************************/
2977   /*************************************************************************/
2978 
2979 
2980   /* The main grid-fitting routine. */
2981 
2982   static void
2983   af_latin_hint_edges( AF_GlyphHints  hints,
2984                        AF_Dimension   dim )
2985   {
2986     AF_AxisHints  axis       = &amp;hints-&gt;axis[dim];
2987     AF_Edge       edges      = axis-&gt;edges;
2988     AF_Edge       edge_limit = edges + axis-&gt;num_edges;
2989     FT_PtrDist    n_edges;
2990     AF_Edge       edge;
2991     AF_Edge       anchor     = NULL;
2992     FT_Int        has_serifs = 0;
2993 




2994     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<span class="line-modified">2995     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>

2996 
2997     FT_Bool  top_to_bottom_hinting = 0;
2998 
2999 #ifdef FT_DEBUG_LEVEL_TRACE
3000     FT_UInt  num_actions = 0;
3001 #endif
3002 
3003 
3004     FT_TRACE5(( &quot;latin %s edge hinting (style `%s&#39;)\n&quot;,
3005                 dim == AF_DIMENSION_VERT ? &quot;horizontal&quot; : &quot;vertical&quot;,
3006                 af_style_names[hints-&gt;metrics-&gt;style_class-&gt;style] ));
3007 
3008     if ( dim == AF_DIMENSION_VERT )
3009       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
3010 
3011     /* we begin by aligning all stems relative to the blue zone */
3012     /* if needed -- that&#39;s only for horizontal edges            */
3013 
3014     if ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_BLUES( hints ) )
3015     {
3016       for ( edge = edges; edge &lt; edge_limit; edge++ )
3017       {
3018         AF_Width  blue;
3019         AF_Edge   edge1, edge2; /* these edges form the stem to check */
3020 
3021 
3022         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3023           continue;
3024 
3025         edge1 = NULL;
3026         edge2 = edge-&gt;link;
3027 
3028         /*
<span class="line-modified">3029          * If a stem contains both a neutral and a non-neutral blue zone,</span>
<span class="line-modified">3030          * skip the neutral one.  Otherwise, outlines with different</span>
<span class="line-modified">3031          * directions might be incorrectly aligned at the same vertical</span>
<span class="line-modified">3032          * position.</span>
3033          *
<span class="line-modified">3034          * If we have two neutral blue zones, skip one of them.</span>
3035          *
3036          */
3037         if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )
3038         {
3039           FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;
3040           FT_Byte  neutral2 = edge2-&gt;flags &amp; AF_EDGE_NEUTRAL;
3041 
3042 
3043           if ( neutral2 )
3044           {
3045             edge2-&gt;blue_edge = NULL;
3046             edge2-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
3047           }
3048           else if ( neutral )
3049           {
3050             edge-&gt;blue_edge = NULL;
3051             edge-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
3052           }
3053         }
3054 
</pre>
<hr />
<pre>
3377         edge3-&gt;pos -= delta;
3378         if ( edge3-&gt;link )
3379           edge3-&gt;link-&gt;pos -= delta;
3380 
3381         /* move the serifs along with the stem */
3382         if ( n_edges == 12 )
3383         {
3384           ( edges + 8 )-&gt;pos -= delta;
3385           ( edges + 11 )-&gt;pos -= delta;
3386         }
3387 
3388         edge3-&gt;flags |= AF_EDGE_DONE;
3389         if ( edge3-&gt;link )
3390           edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;
3391       }
3392     }
3393 
3394     if ( has_serifs || !anchor )
3395     {
3396       /*
<span class="line-modified">3397        * now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">3398        * to complete our processing</span>
3399        */
3400       for ( edge = edges; edge &lt; edge_limit; edge++ )
3401       {
3402         FT_Pos  delta;
3403 
3404 
3405         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3406           continue;
3407 
3408         delta = 1000;
3409 
3410         if ( edge-&gt;serif )
3411         {
3412           delta = edge-&gt;serif-&gt;opos - edge-&gt;opos;
3413           if ( delta &lt; 0 )
3414             delta = -delta;
3415         }
3416 
3417         if ( delta &lt; 64 + 16 )
3418         {
</pre>
</td>
</tr>
</table>
<center><a href="afindic.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="aflatin.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/truetype/ttgload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="tterrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgload.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/truetype/ttgload.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttgload.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    TrueType Glyph Loader (body).                                        */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_CONFIG_CONFIG_H
  22 #include FT_INTERNAL_CALC_H
  23 #include FT_INTERNAL_STREAM_H
  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_TRUETYPE_TAGS_H
  26 #include FT_OUTLINE_H
  27 #include FT_DRIVER_H
  28 #include FT_LIST_H
  29 
  30 #include &quot;ttgload.h&quot;
  31 #include &quot;ttpload.h&quot;
  32 
  33 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  34 #include &quot;ttgxvar.h&quot;
  35 #endif
  36 
  37 #include &quot;tterrors.h&quot;
  38 #include &quot;ttsubpix.h&quot;
  39 
  40 
<span class="line-modified">  41   /*************************************************************************/</span>
<span class="line-modified">  42   /*                                                                       */</span>
<span class="line-modified">  43   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  44   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  45   /* messages during execution.                                            */</span>
<span class="line-modified">  46   /*                                                                       */</span>
  47 #undef  FT_COMPONENT
<span class="line-modified">  48 #define FT_COMPONENT  trace_ttgload</span>
  49 
  50 
<span class="line-modified">  51   /*************************************************************************/</span>
<span class="line-modified">  52   /*                                                                       */</span>
<span class="line-modified">  53   /* Composite glyph flags.                                                */</span>
<span class="line-modified">  54   /*                                                                       */</span>















  55 #define ARGS_ARE_WORDS             0x0001
  56 #define ARGS_ARE_XY_VALUES         0x0002
  57 #define ROUND_XY_TO_GRID           0x0004
  58 #define WE_HAVE_A_SCALE            0x0008
  59 /* reserved                        0x0010 */
  60 #define MORE_COMPONENTS            0x0020
  61 #define WE_HAVE_AN_XY_SCALE        0x0040
  62 #define WE_HAVE_A_2X2              0x0080
  63 #define WE_HAVE_INSTR              0x0100
  64 #define USE_MY_METRICS             0x0200
<span class="line-modified">  65 #define OVERLAP_COMPOUND           0x0400</span>
  66 #define SCALED_COMPONENT_OFFSET    0x0800
  67 #define UNSCALED_COMPONENT_OFFSET  0x1000
  68 
  69 
<span class="line-modified">  70   /*************************************************************************/</span>
<span class="line-modified">  71   /*                                                                       */</span>
<span class="line-modified">  72   /* Return the horizontal metrics in font units for a given glyph.        */</span>
<span class="line-modified">  73   /*                                                                       */</span>









  74   FT_LOCAL_DEF( void )
  75   TT_Get_HMetrics( TT_Face     face,
  76                    FT_UInt     idx,
  77                    FT_Short*   lsb,
  78                    FT_UShort*  aw )
  79   {
  80     ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 0, idx, lsb, aw );
  81 
  82     FT_TRACE5(( &quot;  advance width (font units): %d\n&quot;, *aw ));
  83     FT_TRACE5(( &quot;  left side bearing (font units): %d\n&quot;, *lsb ));
  84   }
  85 
  86 
<span class="line-modified">  87   /*************************************************************************/</span>
<span class="line-modified">  88   /*                                                                       */</span>
<span class="line-modified">  89   /* Return the vertical metrics in font units for a given glyph.          */</span>
<span class="line-modified">  90   /* See function `tt_loader_set_pp&#39; below for explanations.               */</span>
<span class="line-modified">  91   /*                                                                       */</span>
  92   FT_LOCAL_DEF( void )
  93   TT_Get_VMetrics( TT_Face     face,
  94                    FT_UInt     idx,
  95                    FT_Pos      yMax,
  96                    FT_Short*   tsb,
  97                    FT_UShort*  ah )
  98   {
  99     if ( face-&gt;vertical_info )
 100       ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 1, idx, tsb, ah );
 101 
 102     else if ( face-&gt;os2.version != 0xFFFFU )
 103     {
 104       *tsb = (FT_Short)( face-&gt;os2.sTypoAscender - yMax );
 105       *ah  = (FT_UShort)FT_ABS( face-&gt;os2.sTypoAscender -
 106                                 face-&gt;os2.sTypoDescender );
 107     }
 108 
 109     else
 110     {
 111       *tsb = (FT_Short)( face-&gt;horizontal.Ascender - yMax );
</pre>
<hr />
<pre>
 233 
 234       loader-&gt;left_bearing = left_bearing;
 235       loader-&gt;advance      = advance_width;
 236       loader-&gt;top_bearing  = top_bearing;
 237       loader-&gt;vadvance     = advance_height;
 238 
 239       if ( !loader-&gt;linear_def )
 240       {
 241         loader-&gt;linear_def = 1;
 242         loader-&gt;linear     = advance_width;
 243       }
 244     }
 245 
 246   Exit:
 247     return;
 248   }
 249 
 250 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 251 
 252 
<span class="line-modified"> 253   /*************************************************************************/</span>
<span class="line-modified"> 254   /*                                                                       */</span>
<span class="line-modified"> 255   /* The following functions are used by default with TrueType fonts.      */</span>
<span class="line-modified"> 256   /* However, they can be replaced by alternatives if we need to support   */</span>
<span class="line-modified"> 257   /* TrueType-compressed formats (like MicroType) in the future.           */</span>
<span class="line-modified"> 258   /*                                                                       */</span>
<span class="line-modified"> 259   /*************************************************************************/</span>
 260 
 261   FT_CALLBACK_DEF( FT_Error )
 262   TT_Access_Glyph_Frame( TT_Loader  loader,
 263                          FT_UInt    glyph_index,
 264                          FT_ULong   offset,
 265                          FT_UInt    byte_count )
 266   {
 267     FT_Error   error;
 268     FT_Stream  stream = loader-&gt;stream;
 269 
<span class="line-removed"> 270     /* for non-debug mode */</span>
 271     FT_UNUSED( glyph_index );
 272 
 273 
<span class="line-removed"> 274     FT_TRACE4(( &quot;Glyph %ld\n&quot;, glyph_index ));</span>
<span class="line-removed"> 275 </span>
 276     /* the following line sets the `error&#39; variable through macros! */
 277     if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
 278       return error;
 279 
 280     loader-&gt;cursor = stream-&gt;cursor;
 281     loader-&gt;limit  = stream-&gt;limit;
 282 
 283     return FT_Err_Ok;
 284   }
 285 
 286 
 287   FT_CALLBACK_DEF( void )
 288   TT_Forget_Glyph_Frame( TT_Loader  loader )
 289   {
 290     FT_Stream  stream = loader-&gt;stream;
 291 
 292 
 293     FT_FRAME_EXIT();
 294   }
 295 
</pre>
<hr />
<pre>
 320 
 321     return FT_Err_Ok;
 322   }
 323 
 324 
 325   FT_CALLBACK_DEF( FT_Error )
 326   TT_Load_Simple_Glyph( TT_Loader  load )
 327   {
 328     FT_Error        error;
 329     FT_Byte*        p          = load-&gt;cursor;
 330     FT_Byte*        limit      = load-&gt;limit;
 331     FT_GlyphLoader  gloader    = load-&gt;gloader;
 332     FT_Int          n_contours = load-&gt;n_contours;
 333     FT_Outline*     outline;
 334     FT_UShort       n_ins;
 335     FT_Int          n_points;
 336 
 337     FT_Byte         *flag, *flag_limit;
 338     FT_Byte         c, count;
 339     FT_Vector       *vec, *vec_limit;
<span class="line-modified"> 340     FT_Pos          x;</span>
 341     FT_Short        *cont, *cont_limit, prev_cont;
 342     FT_Int          xy_size = 0;
 343 
 344 
 345     /* check that we can add the contours to the glyph */
 346     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
 347     if ( error )
 348       goto Fail;
 349 
 350     /* reading the contours&#39; endpoints &amp; number of points */
 351     cont       = gloader-&gt;current.outline.contours;
 352     cont_limit = cont + n_contours;
 353 
 354     /* check space for contours array + instructions count */
 355     if ( n_contours &gt;= 0xFFF || p + ( n_contours + 1 ) * 2 &gt; limit )
 356       goto Invalid_Outline;
 357 
 358     prev_cont = FT_NEXT_SHORT( p );
 359 
 360     if ( n_contours &gt; 0 )
</pre>
<hr />
<pre>
 365 
 366     for ( cont++; cont &lt; cont_limit; cont++ )
 367     {
 368       cont[0] = FT_NEXT_SHORT( p );
 369       if ( cont[0] &lt;= prev_cont )
 370       {
 371         /* unordered contours: this is invalid */
 372         goto Invalid_Outline;
 373       }
 374       prev_cont = cont[0];
 375     }
 376 
 377     n_points = 0;
 378     if ( n_contours &gt; 0 )
 379     {
 380       n_points = cont[-1] + 1;
 381       if ( n_points &lt; 0 )
 382         goto Invalid_Outline;
 383     }
 384 


 385     /* note that we will add four phantom points later */
 386     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
 387     if ( error )
 388       goto Fail;
 389 
 390     /* reading the bytecode instructions */
 391     load-&gt;glyph-&gt;control_len  = 0;
 392     load-&gt;glyph-&gt;control_data = NULL;
 393 
 394     if ( p + 2 &gt; limit )
 395       goto Invalid_Outline;
 396 
 397     n_ins = FT_NEXT_USHORT( p );
 398 
 399     FT_TRACE5(( &quot;  Instructions size: %u\n&quot;, n_ins ));
 400 
 401 #ifdef TT_USE_BYTECODE_INTERPRETER
 402 
 403     if ( IS_HINTED( load-&gt;load_flags ) )
 404     {
</pre>
<hr />
<pre>
 435     }
 436 
 437 #endif /* TT_USE_BYTECODE_INTERPRETER */
 438 
 439     p += n_ins;
 440 
 441     outline = &amp;gloader-&gt;current.outline;
 442 
 443     /* reading the point tags */
 444     flag       = (FT_Byte*)outline-&gt;tags;
 445     flag_limit = flag + n_points;
 446 
 447     FT_ASSERT( flag );
 448 
 449     while ( flag &lt; flag_limit )
 450     {
 451       if ( p + 1 &gt; limit )
 452         goto Invalid_Outline;
 453 
 454       *flag++ = c = FT_NEXT_BYTE( p );
<span class="line-modified"> 455       if ( c &amp; 8 )</span>
 456       {
 457         if ( p + 1 &gt; limit )
 458           goto Invalid_Outline;
 459 
 460         count = FT_NEXT_BYTE( p );
 461         if ( flag + (FT_Int)count &gt; flag_limit )
 462           goto Invalid_Outline;
 463 
 464         for ( ; count &gt; 0; count-- )
 465           *flag++ = c;
 466       }
 467     }
 468 
 469     /* reading the X coordinates */
 470 
 471     vec       = outline-&gt;points;
 472     vec_limit = vec + n_points;
 473     flag      = (FT_Byte*)outline-&gt;tags;
 474     x         = 0;
 475 
 476     if ( p + xy_size &gt; limit )
 477       goto Invalid_Outline;
 478 
 479     for ( ; vec &lt; vec_limit; vec++, flag++ )
 480     {
<span class="line-modified"> 481       FT_Pos   y = 0;</span>
<span class="line-modified"> 482       FT_Byte  f = *flag;</span>
 483 
 484 
<span class="line-modified"> 485       if ( f &amp; 2 )</span>
 486       {
 487         if ( p + 1 &gt; limit )
 488           goto Invalid_Outline;
 489 
<span class="line-modified"> 490         y = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 491         if ( ( f &amp; 16 ) == 0 )</span>
<span class="line-modified"> 492           y = -y;</span>
 493       }
<span class="line-modified"> 494       else if ( ( f &amp; 16 ) == 0 )</span>
 495       {
 496         if ( p + 2 &gt; limit )
 497           goto Invalid_Outline;
 498 
<span class="line-modified"> 499         y = (FT_Pos)FT_NEXT_SHORT( p );</span>
 500       }
 501 
<span class="line-modified"> 502       x     += y;</span>
 503       vec-&gt;x = x;
<span class="line-removed"> 504       /* the cast is for stupid compilers */</span>
<span class="line-removed"> 505       *flag  = (FT_Byte)( f &amp; ~( 2 | 16 ) );</span>
 506     }
 507 
 508     /* reading the Y coordinates */
 509 
 510     vec       = gloader-&gt;current.outline.points;
 511     vec_limit = vec + n_points;
 512     flag      = (FT_Byte*)outline-&gt;tags;
<span class="line-modified"> 513     x         = 0;</span>
 514 
 515     for ( ; vec &lt; vec_limit; vec++, flag++ )
 516     {
<span class="line-modified"> 517       FT_Pos   y = 0;</span>
<span class="line-modified"> 518       FT_Byte  f = *flag;</span>
 519 
 520 
<span class="line-modified"> 521       if ( f &amp; 4 )</span>
 522       {
 523         if ( p + 1 &gt; limit )
 524           goto Invalid_Outline;
 525 
<span class="line-modified"> 526         y = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 527         if ( ( f &amp; 32 ) == 0 )</span>
<span class="line-modified"> 528           y = -y;</span>
 529       }
<span class="line-modified"> 530       else if ( ( f &amp; 32 ) == 0 )</span>
 531       {
 532         if ( p + 2 &gt; limit )
 533           goto Invalid_Outline;
 534 
<span class="line-modified"> 535         y = (FT_Pos)FT_NEXT_SHORT( p );</span>
 536       }
 537 
<span class="line-modified"> 538       x     += y;</span>
<span class="line-modified"> 539       vec-&gt;y = x;</span>

 540       /* the cast is for stupid compilers */
<span class="line-modified"> 541       *flag  = (FT_Byte)( f &amp; FT_CURVE_TAG_ON );</span>
 542     }
 543 
 544     outline-&gt;n_points   = (FT_Short)n_points;
 545     outline-&gt;n_contours = (FT_Short)n_contours;
 546 
 547     load-&gt;cursor = p;
 548 
 549   Fail:
 550     return error;
 551 
 552   Invalid_Outline:
 553     error = FT_THROW( Invalid_Outline );
 554     goto Fail;
 555   }
 556 
 557 
 558   FT_CALLBACK_DEF( FT_Error )
 559   TT_Load_Composite_Glyph( TT_Loader  loader )
 560   {
 561     FT_Error        error;
<span class="line-modified"> 562     FT_Byte*        p       = loader-&gt;cursor;</span>
<span class="line-modified"> 563     FT_Byte*        limit   = loader-&gt;limit;</span>
<span class="line-modified"> 564     FT_GlyphLoader  gloader = loader-&gt;gloader;</span>

 565     FT_SubGlyph     subglyph;
 566     FT_UInt         num_subglyphs;
 567 
 568 
 569     num_subglyphs = 0;
 570 
 571     do
 572     {
 573       FT_Fixed  xx, xy, yy, yx;
 574       FT_UInt   count;
 575 
 576 
 577       /* check that we can load a new subglyph */
 578       error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
 579       if ( error )
 580         goto Fail;
 581 
 582       /* check space */
 583       if ( p + 4 &gt; limit )
 584         goto Invalid_Composite;
 585 
 586       subglyph = gloader-&gt;current.subglyphs + num_subglyphs;
 587 
 588       subglyph-&gt;arg1 = subglyph-&gt;arg2 = 0;
 589 
 590       subglyph-&gt;flags = FT_NEXT_USHORT( p );
 591       subglyph-&gt;index = FT_NEXT_USHORT( p );
 592 





 593       /* check space */
 594       count = 2;
 595       if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 596         count += 2;
 597       if ( subglyph-&gt;flags &amp; WE_HAVE_A_SCALE )
 598         count += 2;
 599       else if ( subglyph-&gt;flags &amp; WE_HAVE_AN_XY_SCALE )
 600         count += 4;
 601       else if ( subglyph-&gt;flags &amp; WE_HAVE_A_2X2 )
 602         count += 8;
 603 
 604       if ( p + count &gt; limit )
 605         goto Invalid_Composite;
 606 
 607       /* read arguments */
 608       if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
 609       {
 610         if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 611         {
 612           subglyph-&gt;arg1 = FT_NEXT_SHORT( p );
</pre>
<hr />
<pre>
 751 
 752   static void
 753   tt_prepare_zone( TT_GlyphZone  zone,
 754                    FT_GlyphLoad  load,
 755                    FT_UInt       start_point,
 756                    FT_UInt       start_contour )
 757   {
 758     zone-&gt;n_points    = (FT_UShort)load-&gt;outline.n_points -
 759                           (FT_UShort)start_point;
 760     zone-&gt;n_contours  = load-&gt;outline.n_contours -
 761                           (FT_Short)start_contour;
 762     zone-&gt;org         = load-&gt;extra_points + start_point;
 763     zone-&gt;cur         = load-&gt;outline.points + start_point;
 764     zone-&gt;orus        = load-&gt;extra_points2 + start_point;
 765     zone-&gt;tags        = (FT_Byte*)load-&gt;outline.tags + start_point;
 766     zone-&gt;contours    = (FT_UShort*)load-&gt;outline.contours + start_contour;
 767     zone-&gt;first_point = (FT_UShort)start_point;
 768   }
 769 
 770 
<span class="line-modified"> 771   /*************************************************************************/</span>
<span class="line-modified"> 772   /*                                                                       */</span>
<span class="line-modified"> 773   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 774   /*    TT_Hint_Glyph                                                      */</span>
<span class="line-modified"> 775   /*                                                                       */</span>
<span class="line-modified"> 776   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 777   /*    Hint the glyph using the zone prepared by the caller.  Note that   */</span>
<span class="line-modified"> 778   /*    the zone is supposed to include four phantom points.               */</span>
<span class="line-modified"> 779   /*                                                                       */</span>
 780   static FT_Error
 781   TT_Hint_Glyph( TT_Loader  loader,
 782                  FT_Bool    is_composite )
 783   {
 784 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
 785     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 786     TT_Face    face   = loader-&gt;face;
 787     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 788 #endif
 789 
 790     TT_GlyphZone  zone = &amp;loader-&gt;zone;
 791 
 792 #ifdef TT_USE_BYTECODE_INTERPRETER
 793     FT_Long       n_ins;
 794 #else
 795     FT_UNUSED( is_composite );
 796 #endif
 797 
 798 
 799 #ifdef TT_USE_BYTECODE_INTERPRETER
<span class="line-removed"> 800     if ( loader-&gt;glyph-&gt;control_len &gt; 0xFFFFL )</span>
<span class="line-removed"> 801     {</span>
<span class="line-removed"> 802       FT_TRACE1(( &quot;TT_Hint_Glyph: too long instructions&quot; ));</span>
<span class="line-removed"> 803       FT_TRACE1(( &quot; (0x%lx byte) is truncated\n&quot;,</span>
<span class="line-removed"> 804                   loader-&gt;glyph-&gt;control_len ));</span>
<span class="line-removed"> 805     }</span>
 806     n_ins = loader-&gt;glyph-&gt;control_len;
 807 
<span class="line-modified"> 808     /* save original point position in org */</span>
 809     if ( n_ins &gt; 0 )
 810       FT_ARRAY_COPY( zone-&gt;org, zone-&gt;cur, zone-&gt;n_points );
 811 
 812     /* Reset graphics state. */
 813     loader-&gt;exec-&gt;GS = loader-&gt;size-&gt;GS;
 814 
 815     /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
 816     /*      completely refer to the (already) hinted subglyphs.     */
 817     if ( is_composite )
 818     {
 819       loader-&gt;exec-&gt;metrics.x_scale = 1 &lt;&lt; 16;
 820       loader-&gt;exec-&gt;metrics.y_scale = 1 &lt;&lt; 16;
 821 
 822       FT_ARRAY_COPY( zone-&gt;orus, zone-&gt;cur, zone-&gt;n_points );
 823     }
 824     else
 825     {
 826       loader-&gt;exec-&gt;metrics.x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
 827       loader-&gt;exec-&gt;metrics.y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
 828     }
</pre>
<hr />
<pre>
 879       loader-&gt;pp4 = zone-&gt;cur[zone-&gt;n_points - 1];
 880 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 881     }
 882 #endif
 883 
 884 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 885     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
 886     {
 887       if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_DEEMBOLDEN )
 888         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, -24, 0 );
 889 
 890       else if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_EMBOLDEN )
 891         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, 24, 0 );
 892     }
 893 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 894 
 895     return FT_Err_Ok;
 896   }
 897 
 898 
<span class="line-modified"> 899   /*************************************************************************/</span>
<span class="line-modified"> 900   /*                                                                       */</span>
<span class="line-modified"> 901   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 902   /*    TT_Process_Simple_Glyph                                            */</span>
<span class="line-modified"> 903   /*                                                                       */</span>
<span class="line-modified"> 904   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 905   /*    Once a simple glyph has been loaded, it needs to be processed.     */</span>
<span class="line-modified"> 906   /*    Usually, this means scaling and hinting through bytecode           */</span>
<span class="line-modified"> 907   /*    interpretation.                                                    */</span>
<span class="line-modified"> 908   /*                                                                       */</span>
 909   static FT_Error
 910   TT_Process_Simple_Glyph( TT_Loader  loader )
 911   {
 912     FT_GlyphLoader  gloader = loader-&gt;gloader;
 913     FT_Error        error   = FT_Err_Ok;
 914     FT_Outline*     outline;
 915     FT_Int          n_points;
 916 





 917 
 918     outline  = &amp;gloader-&gt;current.outline;
 919     n_points = outline-&gt;n_points;
 920 
 921     /* set phantom points */
 922 
 923     outline-&gt;points[n_points    ] = loader-&gt;pp1;
 924     outline-&gt;points[n_points + 1] = loader-&gt;pp2;
 925     outline-&gt;points[n_points + 2] = loader-&gt;pp3;
 926     outline-&gt;points[n_points + 3] = loader-&gt;pp4;
 927 
 928     outline-&gt;tags[n_points    ] = 0;
 929     outline-&gt;tags[n_points + 1] = 0;
 930     outline-&gt;tags[n_points + 2] = 0;
 931     outline-&gt;tags[n_points + 3] = 0;
 932 
 933     n_points += 4;
 934 
 935 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 936 
<span class="line-modified"> 937     if ( FT_IS_NAMED_INSTANCE( FT_FACE( loader-&gt;face ) ) ||</span>
<span class="line-removed"> 938          FT_IS_VARIATION( FT_FACE( loader-&gt;face ) )      )</span>
 939     {



 940       /* Deltas apply to the unscaled data. */
 941       error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
 942                                           loader-&gt;glyph_index,
 943                                           outline,

 944                                           (FT_UInt)n_points );
 945 
 946       /* recalculate linear horizontal and vertical advances */
 947       /* if we don&#39;t have HVAR and VVAR, respectively        */



 948       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified"> 949         loader-&gt;linear = outline-&gt;points[n_points - 3].x -</span>
<span class="line-modified"> 950                          outline-&gt;points[n_points - 4].x;</span>
 951       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified"> 952         loader-&gt;vadvance = outline-&gt;points[n_points - 1].x -</span>
<span class="line-modified"> 953                            outline-&gt;points[n_points - 2].x;</span>
 954 
 955       if ( error )
<span class="line-modified"> 956         return error;</span>
 957     }
 958 
 959 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 960 
 961     if ( IS_HINTED( loader-&gt;load_flags ) )
 962     {
 963       tt_prepare_zone( &amp;loader-&gt;zone, &amp;gloader-&gt;current, 0, 0 );
 964 
 965       FT_ARRAY_COPY( loader-&gt;zone.orus, loader-&gt;zone.cur,
 966                      loader-&gt;zone.n_points + 4 );
 967     }
 968 
 969     {
 970 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 971       TT_Face    face   = loader-&gt;face;
 972       TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 973 
 974       FT_String*  family         = face-&gt;root.family_name;
 975       FT_UInt     ppem           = loader-&gt;size-&gt;metrics-&gt;x_ppem;
 976       FT_String*  style          = face-&gt;root.style_name;
</pre>
<hr />
<pre>
 991       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
 992       {
 993         /* scale, but only if enabled and only if TT hinting is being used */
 994         if ( IS_HINTED( loader-&gt;load_flags ) )
 995           x_scale_factor = sph_test_tweak_x_scaling( face,
 996                                                      family,
 997                                                      ppem,
 998                                                      style,
 999                                                      loader-&gt;glyph_index );
1000         /* scale the glyph */
1001         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 ||
1002              x_scale_factor != 1000                         )
1003         {
1004           x_scale = FT_MulDiv( loader-&gt;size-&gt;metrics-&gt;x_scale,
1005                                (FT_Long)x_scale_factor, 1000 );
1006           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1007 
1008           /* compensate for any scaling by de/emboldening; */
1009           /* the amount was determined via experimentation */
1010           if ( x_scale_factor != 1000 &amp;&amp; ppem &gt; 11 )








1011             FT_Outline_EmboldenXY( outline,
1012                                    FT_MulFix( 1280 * ppem,
1013                                               1000 - x_scale_factor ),
1014                                    0 );





1015           do_scale = TRUE;
1016         }
1017       }
1018       else
1019 
1020 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
1021 
1022       {
1023         /* scale the glyph */
1024         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1025         {
1026           x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1027           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1028 
1029           do_scale = TRUE;
1030         }
1031       }
1032 
1033       if ( do_scale )
1034       {
<span class="line-modified">1035         for ( ; vec &lt; limit; vec++ )</span>

1036         {
<span class="line-modified">1037           vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );</span>
<span class="line-modified">1038           vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );</span>















1039         }
1040       }
1041 
1042 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1043       /* if we have a HVAR table, `pp1&#39; and/or `pp2&#39; are already adjusted */
1044       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) ||
1045            !IS_HINTED( loader-&gt;load_flags )                                 )
1046 #endif
1047       {
1048         loader-&gt;pp1 = outline-&gt;points[n_points - 4];
1049         loader-&gt;pp2 = outline-&gt;points[n_points - 3];
1050       }
1051 
1052 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1053       /* if we have a VVAR table, `pp3&#39; and/or `pp4&#39; are already adjusted */
1054       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) ||
1055            !IS_HINTED( loader-&gt;load_flags )                                 )
1056 #endif
1057       {
1058         loader-&gt;pp3 = outline-&gt;points[n_points - 2];
1059         loader-&gt;pp4 = outline-&gt;points[n_points - 1];
1060       }
1061     }
1062 
1063     if ( IS_HINTED( loader-&gt;load_flags ) )
1064     {
1065       loader-&gt;zone.n_points += 4;
1066 
1067       error = TT_Hint_Glyph( loader, 0 );
1068     }
1069 





1070     return error;
1071   }
1072 
1073 
<span class="line-modified">1074   /*************************************************************************/</span>
<span class="line-modified">1075   /*                                                                       */</span>
<span class="line-modified">1076   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1077   /*    TT_Process_Composite_Component                                     */</span>
<span class="line-modified">1078   /*                                                                       */</span>
<span class="line-modified">1079   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1080   /*    Once a composite component has been loaded, it needs to be         */</span>
<span class="line-modified">1081   /*    processed.  Usually, this means transforming and translating.      */</span>
<span class="line-modified">1082   /*                                                                       */</span>
1083   static FT_Error
1084   TT_Process_Composite_Component( TT_Loader    loader,
1085                                   FT_SubGlyph  subglyph,
1086                                   FT_UInt      start_point,
1087                                   FT_UInt      num_base_points )
1088   {
1089     FT_GlyphLoader  gloader = loader-&gt;gloader;
1090     FT_Outline      current;
1091     FT_Bool         have_scale;
1092     FT_Pos          x, y;
1093 
1094 
1095     current.points   = gloader-&gt;base.outline.points +
1096                          num_base_points;
1097     current.n_points = gloader-&gt;base.outline.n_points -
1098                          (short)num_base_points;
1099 
1100     have_scale = FT_BOOL( subglyph-&gt;flags &amp; ( WE_HAVE_A_SCALE     |
1101                                               WE_HAVE_AN_XY_SCALE |
1102                                               WE_HAVE_A_2X2       ) );
</pre>
<hr />
<pre>
1136       x = subglyph-&gt;arg1;
1137       y = subglyph-&gt;arg2;
1138 
1139       if ( !x &amp;&amp; !y )
1140         return FT_Err_Ok;
1141 
1142       /* Use a default value dependent on                                  */
1143       /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
1144       /* TT fonts which don&#39;t set the xxx_COMPONENT_OFFSET bit.            */
1145 
1146       if ( have_scale &amp;&amp;
1147 #ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
1148            !( subglyph-&gt;flags &amp; UNSCALED_COMPONENT_OFFSET ) )
1149 #else
1150             ( subglyph-&gt;flags &amp; SCALED_COMPONENT_OFFSET ) )
1151 #endif
1152       {
1153 
1154 #if 0
1155 
<span class="line-modified">1156         /*******************************************************************/</span>
<span class="line-modified">1157         /*                                                                 */</span>
<span class="line-modified">1158         /* This algorithm is what Apple documents.  But it doesn&#39;t work.   */</span>
<span class="line-modified">1159         /*                                                                 */</span>
1160         int  a = subglyph-&gt;transform.xx &gt; 0 ?  subglyph-&gt;transform.xx
1161                                             : -subglyph-&gt;transform.xx;
1162         int  b = subglyph-&gt;transform.yx &gt; 0 ?  subglyph-&gt;transform.yx
1163                                             : -subglyph-&gt;transform.yx;
1164         int  c = subglyph-&gt;transform.xy &gt; 0 ?  subglyph-&gt;transform.xy
1165                                             : -subglyph-&gt;transform.xy;
1166         int  d = subglyph-&gt;transform.yy &gt; 0 ?  subglyph-&gt;transform.yy
1167                                             : -subglyph-&gt;transform.yy;
1168         int  m = a &gt; b ? a : b;
1169         int  n = c &gt; d ? c : d;
1170 
1171 
1172         if ( a - b &lt;= 33 &amp;&amp; a - b &gt;= -33 )
1173           m *= 2;
1174         if ( c - d &lt;= 33 &amp;&amp; c - d &gt;= -33 )
1175           n *= 2;
1176         x = FT_MulFix( x, m );
1177         y = FT_MulFix( y, n );
1178 
1179 #else /* 1 */
1180 
<span class="line-modified">1181         /*******************************************************************/</span>
<span class="line-modified">1182         /*                                                                 */</span>
<span class="line-modified">1183         /* This algorithm is a guess and works much better than the above. */</span>
<span class="line-modified">1184         /*                                                                 */</span>
1185         FT_Fixed  mac_xscale = FT_Hypot( subglyph-&gt;transform.xx,
1186                                          subglyph-&gt;transform.xy );
1187         FT_Fixed  mac_yscale = FT_Hypot( subglyph-&gt;transform.yy,
1188                                          subglyph-&gt;transform.yx );
1189 
1190 
1191         x = FT_MulFix( x, mac_xscale );
1192         y = FT_MulFix( y, mac_yscale );
1193 
1194 #endif /* 1 */
1195 
1196       }
1197 
1198       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
1199       {
1200         FT_Fixed  x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1201         FT_Fixed  y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1202 
1203 
1204         x = FT_MulFix( x, x_scale );
</pre>
<hr />
<pre>
1222              * neither allow nor expect modified advance widths if subpixel
1223              * rendering is active.
1224              *
1225              */
1226             if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_35 )
1227               x = FT_PIX_ROUND( x );
1228 
1229             y = FT_PIX_ROUND( y );
1230           }
1231         }
1232       }
1233     }
1234 
1235     if ( x || y )
1236       FT_Outline_Translate( &amp;current, x, y );
1237 
1238     return FT_Err_Ok;
1239   }
1240 
1241 
<span class="line-modified">1242   /*************************************************************************/</span>
<span class="line-modified">1243   /*                                                                       */</span>
<span class="line-modified">1244   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1245   /*    TT_Process_Composite_Glyph                                         */</span>
<span class="line-modified">1246   /*                                                                       */</span>
<span class="line-modified">1247   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1248   /*    This is slightly different from TT_Process_Simple_Glyph, in that   */</span>
<span class="line-modified">1249   /*    its sole purpose is to hint the glyph.  Thus this function is      */</span>
<span class="line-modified">1250   /*    only available when bytecode interpreter is enabled.               */</span>
<span class="line-modified">1251   /*                                                                       */</span>
1252   static FT_Error
1253   TT_Process_Composite_Glyph( TT_Loader  loader,
1254                               FT_UInt    start_point,
1255                               FT_UInt    start_contour )
1256   {
1257     FT_Error     error;
1258     FT_Outline*  outline;
1259     FT_UInt      i;
1260 
1261 
1262     outline = &amp;loader-&gt;gloader-&gt;base.outline;
1263 
1264     /* make room for phantom points */
1265     error = FT_GLYPHLOADER_CHECK_POINTS( loader-&gt;gloader,
1266                                          outline-&gt;n_points + 4,
1267                                          0 );
1268     if ( error )
1269       return error;
1270 
1271     outline-&gt;points[outline-&gt;n_points    ] = loader-&gt;pp1;
</pre>
<hr />
<pre>
1443 
1444 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1445     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
1446     {
1447       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting
1448                                       : 0;
1449       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale
1450                                       : 0;
1451     }
1452 #endif
1453 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1454     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
1455     {
1456       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting_lean
1457                                       : 0;
1458       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale_cleartype
1459                                       : 0;
1460     }
1461 #endif
1462 
<span class="line-modified">1463     use_aw_2 = (FT_Bool)( subpixel_hinting &amp;&amp; grayscale );</span>
1464 
1465     loader-&gt;pp1.x = loader-&gt;bbox.xMin - loader-&gt;left_bearing;
1466     loader-&gt;pp1.y = 0;
1467     loader-&gt;pp2.x = loader-&gt;pp1.x + loader-&gt;advance;
1468     loader-&gt;pp2.y = 0;
1469 
1470     loader-&gt;pp3.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1471     loader-&gt;pp3.y = loader-&gt;bbox.yMax + loader-&gt;top_bearing;
1472     loader-&gt;pp4.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1473     loader-&gt;pp4.y = loader-&gt;pp3.y - loader-&gt;vadvance;
1474   }
1475 
1476 
1477   /* a utility function to retrieve i-th node from given FT_List */
1478   static FT_ListNode
1479   ft_list_get_node_at( FT_List  list,
1480                        FT_UInt  idx )
1481   {
1482     FT_ListNode  cur;
1483 
1484 
1485     if ( !list )
1486       return NULL;
1487 
1488     for ( cur = list-&gt;head; cur; cur = cur-&gt;next )
1489     {
1490       if ( !idx )
1491         return cur;
1492 
1493       idx--;
1494     }
1495 
1496     return NULL;
1497   }
1498 
1499 
<span class="line-modified">1500   /*************************************************************************/</span>
<span class="line-modified">1501   /*                                                                       */</span>
<span class="line-modified">1502   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1503   /*    load_truetype_glyph                                                */</span>
<span class="line-modified">1504   /*                                                                       */</span>
<span class="line-modified">1505   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1506   /*    Loads a given truetype glyph.  Handles composites and uses a       */</span>
<span class="line-modified">1507   /*    TT_Loader object.                                                  */</span>
<span class="line-modified">1508   /*                                                                       */</span>
1509   static FT_Error
1510   load_truetype_glyph( TT_Loader  loader,
1511                        FT_UInt    glyph_index,
1512                        FT_UInt    recurse_count,
1513                        FT_Bool    header_only )
1514   {
<span class="line-modified">1515     FT_Error        error        = FT_Err_Ok;</span>
1516     FT_Fixed        x_scale, y_scale;
1517     FT_ULong        offset;
<span class="line-modified">1518     TT_Face         face         = loader-&gt;face;</span>
<span class="line-modified">1519     FT_GlyphLoader  gloader      = loader-&gt;gloader;</span>
<span class="line-modified">1520     FT_Bool         opened_frame = 0;</span>

1521 
1522 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1523     FT_StreamRec    inc_stream;
1524     FT_Data         glyph_data;
1525     FT_Bool         glyph_data_loaded = 0;
1526 #endif
1527 
1528 
1529 #ifdef FT_DEBUG_LEVEL_TRACE
1530     if ( recurse_count )
1531       FT_TRACE5(( &quot;  nesting level: %d\n&quot;, recurse_count ));
1532 #endif
1533 
1534     /* some fonts have an incorrect value of `maxComponentDepth&#39; */
1535     if ( recurse_count &gt; face-&gt;max_profile.maxComponentDepth )
1536     {
1537       FT_TRACE1(( &quot;load_truetype_glyph: maxComponentDepth set to %d\n&quot;,
1538                   recurse_count ));
1539       face-&gt;max_profile.maxComponentDepth = (FT_UShort)recurse_count;
1540     }
1541 
1542 #ifndef FT_CONFIG_OPTION_INCREMENTAL
1543     /* check glyph index */
1544     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs )
1545     {
1546       error = FT_THROW( Invalid_Glyph_Index );
1547       goto Exit;
1548     }
1549 #endif
1550 
1551     loader-&gt;glyph_index = glyph_index;
1552 
<span class="line-modified">1553     if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )</span>
1554     {
<span class="line-modified">1555       x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;</span>
<span class="line-modified">1556       y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;</span>
1557     }
1558     else
1559     {
<span class="line-modified">1560       x_scale = 0x10000L;</span>
<span class="line-modified">1561       y_scale = 0x10000L;</span>
1562     }
1563 
1564     /* Set `offset&#39; to the start of the glyph relative to the start of */
1565     /* the `glyf&#39; table, and `byte_len&#39; to the length of the glyph in  */
1566     /* bytes.                                                          */
1567 
1568 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1569 
1570     /* If we are loading glyph data via the incremental interface, set */
1571     /* the loader stream to a memory stream reading the data returned  */
1572     /* by the interface.                                               */
1573     if ( face-&gt;root.internal-&gt;incremental_interface )
1574     {
1575       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_data(
1576                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
1577                 glyph_index, &amp;glyph_data );
1578       if ( error )
1579         goto Exit;
1580 
1581       glyph_data_loaded = 1;
</pre>
<hr />
<pre>
1600     {
1601 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1602       /* for the incremental interface, `glyf_offset&#39; is always zero */
1603       if ( !face-&gt;glyf_offset                          &amp;&amp;
1604            !face-&gt;root.internal-&gt;incremental_interface )
1605 #else
1606       if ( !face-&gt;glyf_offset )
1607 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
1608       {
1609         FT_TRACE2(( &quot;no `glyf&#39; table but non-zero `loca&#39; entry\n&quot; ));
1610         error = FT_THROW( Invalid_Table );
1611         goto Exit;
1612       }
1613 
1614       error = face-&gt;access_glyph_frame( loader, glyph_index,
1615                                         face-&gt;glyf_offset + offset,
1616                                         (FT_UInt)loader-&gt;byte_len );
1617       if ( error )
1618         goto Exit;
1619 
<span class="line-removed">1620       opened_frame = 1;</span>
<span class="line-removed">1621 </span>
1622       /* read glyph header first */
1623       error = face-&gt;read_glyph_header( loader );
<span class="line-removed">1624       if ( error )</span>
<span class="line-removed">1625         goto Exit;</span>
1626 
<span class="line-modified">1627       /* the metrics must be computed after loading the glyph header */</span>
<span class="line-removed">1628       /* since we need the glyph&#39;s `yMax&#39; value in case the vertical */</span>
<span class="line-removed">1629       /* metrics must be emulated                                    */</span>
<span class="line-removed">1630       error = tt_get_metrics( loader, glyph_index );</span>
<span class="line-removed">1631       if ( error )</span>
<span class="line-removed">1632         goto Exit;</span>
1633 
<span class="line-modified">1634       if ( header_only )</span>
1635         goto Exit;
1636     }
1637 

1638     if ( loader-&gt;byte_len == 0 || loader-&gt;n_contours == 0 )
1639     {
1640       loader-&gt;bbox.xMin = 0;
1641       loader-&gt;bbox.xMax = 0;
1642       loader-&gt;bbox.yMin = 0;
1643       loader-&gt;bbox.yMax = 0;

1644 
<span class="line-modified">1645       error = tt_get_metrics( loader, glyph_index );</span>
<span class="line-modified">1646       if ( error )</span>
<span class="line-modified">1647         goto Exit;</span>



1648 
<span class="line-modified">1649       if ( header_only )</span>
<span class="line-modified">1650         goto Exit;</span>
1651 


1652       /* must initialize points before (possibly) overriding */
1653       /* glyph metrics from the incremental interface        */
1654       tt_loader_set_pp( loader );
1655 
1656 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1657       tt_get_metrics_incr_overrides( loader, glyph_index );
1658 #endif
1659 
1660 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1661 
1662       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1663            FT_IS_VARIATION( FT_FACE( face ) )      )
1664       {
1665         /* a small outline structure with four elements for */
1666         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39;  */
1667         FT_Vector   points[4];
1668         char        tags[4]     = { 1, 1, 1, 1 };
1669         short       contours[4] = { 0, 1, 2, 3 };
1670         FT_Outline  outline;
1671 



1672 
1673         points[0].x = loader-&gt;pp1.x;
1674         points[0].y = loader-&gt;pp1.y;
1675         points[1].x = loader-&gt;pp2.x;
1676         points[1].y = loader-&gt;pp2.y;
1677 
1678         points[2].x = loader-&gt;pp3.x;
1679         points[2].y = loader-&gt;pp3.y;
1680         points[3].x = loader-&gt;pp4.x;
1681         points[3].y = loader-&gt;pp4.y;
1682 
1683         outline.n_points   = 4;
1684         outline.n_contours = 4;
1685         outline.points     = points;
1686         outline.tags       = tags;
1687         outline.contours   = contours;
1688 
1689         /* this must be done before scaling */
1690         error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
1691                                             glyph_index,
1692                                             &amp;outline,

1693                                             (FT_UInt)outline.n_points );
1694         if ( error )
1695           goto Exit;
1696 
1697         loader-&gt;pp1.x = points[0].x;
1698         loader-&gt;pp1.y = points[0].y;
1699         loader-&gt;pp2.x = points[1].x;
1700         loader-&gt;pp2.y = points[1].y;
1701 
1702         loader-&gt;pp3.x = points[2].x;
1703         loader-&gt;pp3.y = points[2].y;
1704         loader-&gt;pp4.x = points[3].x;
1705         loader-&gt;pp4.y = points[3].y;
1706 
<span class="line-removed">1707 </span>
1708         /* recalculate linear horizontal and vertical advances */
1709         /* if we don&#39;t have HVAR and VVAR, respectively        */
1710         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">1711           loader-&gt;linear = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>

1712         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">1713           loader-&gt;vadvance = loader-&gt;pp4.x - loader-&gt;pp3.x;</span>

1714       }
1715 
1716 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1717 
1718       /* scale phantom points, if necessary; */
1719       /* they get rounded in `TT_Hint_Glyph&#39; */
1720       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1721       {
1722         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
1723         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
1724         /* pp1.y and pp2.y are always zero */
1725 
1726         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
1727         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
1728         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
1729         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
1730       }
1731 
1732       error = FT_Err_Ok;
1733       goto Exit;
1734     }
1735 
1736     /* must initialize phantom points before (possibly) overriding */
1737     /* glyph metrics from the incremental interface                */
1738     tt_loader_set_pp( loader );
1739 
1740 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1741     tt_get_metrics_incr_overrides( loader, glyph_index );
1742 #endif
1743 
1744     /***********************************************************************/
1745     /***********************************************************************/
1746     /***********************************************************************/
1747 










1748     /* if it is a simple glyph, load it */
1749 
1750     if ( loader-&gt;n_contours &gt; 0 )
1751     {
1752       error = face-&gt;read_simple_glyph( loader );
1753       if ( error )
1754         goto Exit;
1755 
1756       /* all data have been read */
1757       face-&gt;forget_glyph_frame( loader );
1758       opened_frame = 0;
1759 
1760       error = TT_Process_Simple_Glyph( loader );
1761       if ( error )
1762         goto Exit;
1763 
1764       FT_GlyphLoader_Add( gloader );
1765     }
1766 
1767     /***********************************************************************/
</pre>
<hr />
<pre>
1773     {
1774       FT_Memory  memory = face-&gt;root.memory;
1775 
1776       FT_UInt   start_point;
1777       FT_UInt   start_contour;
1778       FT_ULong  ins_pos;  /* position of composite instructions, if any */
1779 
1780       FT_ListNode  node, node2;
1781 
1782 
1783       /* normalize the `n_contours&#39; value */
1784       loader-&gt;n_contours = -1;
1785 
1786       /*
1787        * We store the glyph index directly in the `node-&gt;data&#39; pointer,
1788        * following the glib solution (cf. macro `GUINT_TO_POINTER&#39;) with a
1789        * double cast to make this portable.  Note, however, that this needs
1790        * pointers with a width of at least 32 bits.
1791        */
1792 
<span class="line-removed">1793 </span>
1794       /* clear the nodes filled by sibling chains */
1795       node = ft_list_get_node_at( &amp;loader-&gt;composites, recurse_count );
1796       for ( node2 = node; node2; node2 = node2-&gt;next )
1797         node2-&gt;data = (void*)FT_ULONG_MAX;
1798 
1799       /* check whether we already have a composite glyph with this index */
1800       if ( FT_List_Find( &amp;loader-&gt;composites,
1801                          FT_UINT_TO_POINTER( glyph_index ) ) )
1802       {
1803         FT_TRACE1(( &quot;TT_Load_Composite_Glyph:&quot;
1804                     &quot; infinite recursion detected\n&quot; ));
1805         error = FT_THROW( Invalid_Composite );
1806         goto Exit;
1807       }
1808 
1809       else if ( node )
1810         node-&gt;data = FT_UINT_TO_POINTER( glyph_index );
1811 
1812       else
1813       {
</pre>
<hr />
<pre>
1824       error = face-&gt;read_composite_glyph( loader );
1825       if ( error )
1826         goto Exit;
1827 
1828       /* store the offset of instructions */
1829       ins_pos = loader-&gt;ins_pos;
1830 
1831       /* all data we need are read */
1832       face-&gt;forget_glyph_frame( loader );
1833       opened_frame = 0;
1834 
1835 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1836 
1837       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1838            FT_IS_VARIATION( FT_FACE( face ) )      )
1839       {
1840         short        i, limit;
1841         FT_SubGlyph  subglyph;
1842 
1843         FT_Outline  outline;
<span class="line-modified">1844         FT_Vector*  points   = NULL;</span>
<span class="line-modified">1845         char*       tags     = NULL;</span>
<span class="line-modified">1846         short*      contours = NULL;</span>

1847 
1848 
1849         limit = (short)gloader-&gt;current.num_subglyphs;
1850 
1851         /* construct an outline structure for              */
1852         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39; */
1853         outline.n_points   = (short)( gloader-&gt;current.num_subglyphs + 4 );
1854         outline.n_contours = outline.n_points;
1855 
1856         outline.points   = NULL;
1857         outline.tags     = NULL;
1858         outline.contours = NULL;
1859 
<span class="line-modified">1860         if ( FT_NEW_ARRAY( points, outline.n_points )   ||</span>
<span class="line-modified">1861              FT_NEW_ARRAY( tags, outline.n_points )     ||</span>
<span class="line-modified">1862              FT_NEW_ARRAY( contours, outline.n_points ) )</span>

1863           goto Exit1;
1864 
1865         subglyph = gloader-&gt;current.subglyphs;
1866 
1867         for ( i = 0; i &lt; limit; i++, subglyph++ )
1868         {
1869           /* applying deltas for anchor points doesn&#39;t make sense, */
1870           /* but we don&#39;t have to specially check this since       */
1871           /* unused delta values are zero anyways                  */
1872           points[i].x = subglyph-&gt;arg1;
1873           points[i].y = subglyph-&gt;arg2;
1874           tags[i]     = 1;
1875           contours[i] = i;
1876         }
1877 
1878         points[i].x = loader-&gt;pp1.x;
1879         points[i].y = loader-&gt;pp1.y;
1880         tags[i]     = 1;
1881         contours[i] = i;
1882 
</pre>
<hr />
<pre>
1891         points[i].y = loader-&gt;pp3.y;
1892         tags[i]     = 1;
1893         contours[i] = i;
1894 
1895         i++;
1896         points[i].x = loader-&gt;pp4.x;
1897         points[i].y = loader-&gt;pp4.y;
1898         tags[i]     = 1;
1899         contours[i] = i;
1900 
1901         outline.points   = points;
1902         outline.tags     = tags;
1903         outline.contours = contours;
1904 
1905         /* this call provides additional offsets */
1906         /* for each component&#39;s translation      */
1907         if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
1908                              face,
1909                              glyph_index,
1910                              &amp;outline,

1911                              (FT_UInt)outline.n_points ) ) )
1912           goto Exit1;
1913 
1914         subglyph = gloader-&gt;current.subglyphs;
1915 
1916         for ( i = 0; i &lt; limit; i++, subglyph++ )
1917         {
1918           if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
1919           {
1920             subglyph-&gt;arg1 = (FT_Int16)points[i].x;
1921             subglyph-&gt;arg2 = (FT_Int16)points[i].y;
1922           }
1923         }
1924 
1925         loader-&gt;pp1.x = points[i + 0].x;
1926         loader-&gt;pp1.y = points[i + 0].y;
1927         loader-&gt;pp2.x = points[i + 1].x;
1928         loader-&gt;pp2.y = points[i + 1].y;
1929 
1930         loader-&gt;pp3.x = points[i + 2].x;
1931         loader-&gt;pp3.y = points[i + 2].y;
1932         loader-&gt;pp4.x = points[i + 3].x;
1933         loader-&gt;pp4.y = points[i + 3].y;
1934 
1935         /* recalculate linear horizontal and vertical advances */
1936         /* if we don&#39;t have HVAR and VVAR, respectively        */
1937         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">1938           loader-&gt;linear = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>


1939         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">1940           loader-&gt;vadvance = loader-&gt;pp4.x - loader-&gt;pp3.x;</span>


1941 
1942       Exit1:
1943         FT_FREE( outline.points );
1944         FT_FREE( outline.tags );
1945         FT_FREE( outline.contours );

1946 
1947         if ( error )
1948           goto Exit;
1949       }
1950 
1951 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1952 
1953       /* scale phantom points, if necessary; */
1954       /* they get rounded in `TT_Hint_Glyph&#39; */
1955       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1956       {
1957         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
1958         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
1959         /* pp1.y and pp2.y are always zero */
1960 
1961         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
1962         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
1963         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
1964         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
1965       }
</pre>
<hr />
<pre>
1985 
1986         FT_UInt      num_points     = start_point;
1987         FT_UInt      num_subglyphs  = gloader-&gt;current.num_subglyphs;
1988         FT_UInt      num_base_subgs = gloader-&gt;base.num_subglyphs;
1989 
1990         FT_Stream    old_stream     = loader-&gt;stream;
1991         FT_Int       old_byte_len   = loader-&gt;byte_len;
1992 
1993 
1994         FT_GlyphLoader_Add( gloader );
1995 
1996         /* read each subglyph independently */
1997         for ( n = 0; n &lt; num_subglyphs; n++ )
1998         {
1999           FT_Vector  pp[4];
2000 
2001           FT_Int  linear_hadvance;
2002           FT_Int  linear_vadvance;
2003 
2004 
<span class="line-modified">2005           /* Each time we call load_truetype_glyph in this loop, the   */</span>
2006           /* value of `gloader.base.subglyphs&#39; can change due to table */
2007           /* reallocations.  We thus need to recompute the subglyph    */
2008           /* pointer on each iteration.                                */
2009           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2010 
2011           pp[0] = loader-&gt;pp1;
2012           pp[1] = loader-&gt;pp2;
2013           pp[2] = loader-&gt;pp3;
2014           pp[3] = loader-&gt;pp4;
2015 
2016           linear_hadvance = loader-&gt;linear;
2017           linear_vadvance = loader-&gt;vadvance;
2018 
2019           num_base_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2020 
2021           error = load_truetype_glyph( loader,
2022                                        (FT_UInt)subglyph-&gt;index,
2023                                        recurse_count + 1,
2024                                        FALSE );
2025           if ( error )
</pre>
<hr />
<pre>
2028           /* restore subglyph pointer */
2029           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2030 
2031           /* restore phantom points if necessary */
2032           if ( !( subglyph-&gt;flags &amp; USE_MY_METRICS ) )
2033           {
2034             loader-&gt;pp1 = pp[0];
2035             loader-&gt;pp2 = pp[1];
2036             loader-&gt;pp3 = pp[2];
2037             loader-&gt;pp4 = pp[3];
2038 
2039             loader-&gt;linear   = linear_hadvance;
2040             loader-&gt;vadvance = linear_vadvance;
2041           }
2042 
2043           num_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2044 
2045           if ( num_points == num_base_points )
2046             continue;
2047 
<span class="line-modified">2048           /* gloader-&gt;base.outline consists of three parts:               */</span>
<span class="line-modified">2049           /* 0 -(1)-&gt; start_point -(2)-&gt; num_base_points -(3)-&gt; n_points. */</span>
<span class="line-modified">2050           /*                                                              */</span>
<span class="line-modified">2051           /* (1): exists from the beginning                               */</span>
<span class="line-modified">2052           /* (2): components that have been loaded so far                 */</span>
<span class="line-modified">2053           /* (3): the newly loaded component                              */</span>


2054           error = TT_Process_Composite_Component( loader,
2055                                                   subglyph,
2056                                                   start_point,
2057                                                   num_base_points );
2058           if ( error )
2059             goto Exit;
2060         }
2061 
2062         loader-&gt;stream   = old_stream;
2063         loader-&gt;byte_len = old_byte_len;
2064 
2065         /* process the glyph */
2066         loader-&gt;ins_pos = ins_pos;
2067         if ( IS_HINTED( loader-&gt;load_flags ) &amp;&amp;
2068 #ifdef TT_USE_BYTECODE_INTERPRETER

2069              subglyph-&gt;flags &amp; WE_HAVE_INSTR &amp;&amp;
2070 #endif
2071              num_points &gt; start_point )
2072         {
2073           error = TT_Process_Composite_Glyph( loader,
2074                                               start_point,
2075                                               start_contour );
2076           if ( error )
2077             goto Exit;
2078         }
2079       }
2080     }
2081 
2082     /***********************************************************************/
2083     /***********************************************************************/
2084     /***********************************************************************/
2085 
2086   Exit:
2087 
2088     if ( opened_frame )
</pre>
<hr />
<pre>
2115     FT_Fixed      y_scale;
2116     TT_GlyphSlot  glyph = loader-&gt;glyph;
2117     TT_Size       size  = loader-&gt;size;
2118 
2119 
2120     y_scale = 0x10000L;
2121     if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
2122       y_scale = size-&gt;metrics-&gt;y_scale;
2123 
2124     if ( glyph-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
2125       FT_Outline_Get_CBox( &amp;glyph-&gt;outline, &amp;bbox );
2126     else
2127       bbox = loader-&gt;bbox;
2128 
2129     /* get the device-independent horizontal advance; it is scaled later */
2130     /* by the base layer.                                                */
2131     glyph-&gt;linearHoriAdvance = loader-&gt;linear;
2132 
2133     glyph-&gt;metrics.horiBearingX = bbox.xMin;
2134     glyph-&gt;metrics.horiBearingY = bbox.yMax;
<span class="line-modified">2135     glyph-&gt;metrics.horiAdvance  = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>
2136 
2137     /* Adjust advance width to the value contained in the hdmx table   */
2138     /* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility */
2139     /* mode of the v40 interpreter is active.  See `ttinterp.h&#39; for    */
2140     /* details on backward compatibility mode.                         */
2141     if (
2142 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2143          !( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40  &amp;&amp;
2144             ( loader-&gt;exec &amp;&amp; loader-&gt;exec-&gt;backward_compatibility  ) ) &amp;&amp;
2145 #endif
2146          !face-&gt;postscript.isFixedPitch                                 &amp;&amp;
2147          IS_HINTED( loader-&gt;load_flags )                                &amp;&amp;
2148          !( loader-&gt;load_flags &amp; FT_LOAD_COMPUTE_METRICS )              )
2149     {
2150       FT_Byte*  widthp;
2151 
2152 
2153       widthp = tt_face_get_device_metrics( face,
2154                                            size-&gt;metrics-&gt;x_ppem,
2155                                            glyph_index );
</pre>
<hr />
<pre>
2259           advance = incr_metrics.advance;
2260         }
2261       }
2262 
2263       /* GWW: Do vertical metrics get loaded incrementally too? */
2264 
2265 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
2266 
2267       glyph-&gt;linearVertAdvance = advance;
2268 
2269       /* scale the metrics */
2270       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
2271       {
2272         top     = FT_MulFix( top,     y_scale );
2273         advance = FT_MulFix( advance, y_scale );
2274       }
2275 
2276       /* XXX: for now, we have no better algorithm for the lsb, but it */
2277       /*      should work fine.                                        */
2278       /*                                                               */
<span class="line-modified">2279       glyph-&gt;metrics.vertBearingX = glyph-&gt;metrics.horiBearingX -</span>
<span class="line-modified">2280                                       glyph-&gt;metrics.horiAdvance / 2;</span>
2281       glyph-&gt;metrics.vertBearingY = top;
2282       glyph-&gt;metrics.vertAdvance  = advance;
2283     }
2284 
<span class="line-modified">2285     return 0;</span>
2286   }
2287 
2288 
2289 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2290 
2291   static FT_Error
2292   load_sbit_image( TT_Size       size,
2293                    TT_GlyphSlot  glyph,
2294                    FT_UInt       glyph_index,
2295                    FT_Int32      load_flags )
2296   {
2297     TT_Face             face;
2298     SFNT_Service        sfnt;
2299     FT_Stream           stream;
2300     FT_Error            error;
2301     TT_SBit_MetricsRec  sbit_metrics;
2302 
2303 
2304     face   = (TT_Face)glyph-&gt;face;
2305     sfnt   = (SFNT_Service)face-&gt;sfnt;
</pre>
<hr />
<pre>
2572             exec-&gt;grayscale_cleartype = grayscale_cleartype;
2573             reexecute                 = TRUE;
2574           }
2575         }
2576 #endif
2577 
2578         /* a change from mono to grayscale rendering (and vice versa) */
2579         /* requires a re-execution of the CVT program                 */
2580         if ( grayscale != exec-&gt;grayscale )
2581         {
2582           FT_TRACE4(( &quot;tt_loader_init: grayscale hinting change,&quot;
2583                       &quot; re-executing `prep&#39; table\n&quot; ));
2584 
2585           exec-&gt;grayscale = grayscale;
2586           reexecute       = TRUE;
2587         }
2588       }
2589 
2590       if ( reexecute )
2591       {
<span class="line-removed">2592         FT_UInt  i;</span>
<span class="line-removed">2593 </span>
<span class="line-removed">2594 </span>
<span class="line-removed">2595         for ( i = 0; i &lt; size-&gt;cvt_size; i++ )</span>
<span class="line-removed">2596           size-&gt;cvt[i] = FT_MulFix( face-&gt;cvt[i], size-&gt;ttmetrics.scale );</span>
2597         error = tt_size_run_prep( size, pedantic );
2598         if ( error )
2599           return error;
2600       }
2601 
2602       /* check whether the cvt program has disabled hinting */
2603       if ( exec-&gt;GS.instruct_control &amp; 1 )
2604         load_flags |= FT_LOAD_NO_HINTING;
2605 
2606       /* load default graphics state -- if needed */
2607       if ( exec-&gt;GS.instruct_control &amp; 2 )
2608         exec-&gt;GS = tt_default_graphics_state;
2609 
2610 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2611       /* check whether we have a font hinted for ClearType --           */
2612       /* note that this flag can also be modified in a glyph&#39;s bytecode */
2613       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 &amp;&amp;
2614            exec-&gt;GS.instruct_control &amp; 4                            )
2615         exec-&gt;ignore_x_mode = 0;
2616 #endif
</pre>
<hr />
<pre>
2639     loader-&gt;glyph  = (FT_GlyphSlot)glyph;
2640     loader-&gt;stream = stream;
2641 
2642     loader-&gt;composites.head = NULL;
2643     loader-&gt;composites.tail = NULL;
2644 
2645     return FT_Err_Ok;
2646   }
2647 
2648 
2649   static void
2650   tt_loader_done( TT_Loader  loader )
2651   {
2652     FT_List_Finalize( &amp;loader-&gt;composites,
2653                       NULL,
2654                       loader-&gt;face-&gt;root.memory,
2655                       NULL );
2656   }
2657 
2658 
<span class="line-modified">2659   /*************************************************************************/</span>
<span class="line-modified">2660   /*                                                                       */</span>
<span class="line-modified">2661   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2662   /*    TT_Load_Glyph                                                      */</span>
<span class="line-modified">2663   /*                                                                       */</span>
<span class="line-modified">2664   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2665   /*    A function used to load a single glyph within a given glyph slot,  */</span>
<span class="line-modified">2666   /*    for a given size.                                                  */</span>
<span class="line-modified">2667   /*                                                                       */</span>
<span class="line-modified">2668   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2669   /*    glyph       :: A handle to a target slot object where the glyph    */</span>
<span class="line-modified">2670   /*                   will be loaded.                                     */</span>
<span class="line-modified">2671   /*                                                                       */</span>
<span class="line-modified">2672   /*    size        :: A handle to the source face size at which the glyph */</span>
<span class="line-modified">2673   /*                   must be scaled/loaded.                              */</span>
<span class="line-modified">2674   /*                                                                       */</span>
<span class="line-modified">2675   /*    glyph_index :: The index of the glyph in the font file.            */</span>
<span class="line-modified">2676   /*                                                                       */</span>
<span class="line-modified">2677   /*    load_flags  :: A flag indicating what to load for this glyph.  The */</span>
<span class="line-modified">2678   /*                   FT_LOAD_XXX constants can be used to control the    */</span>
<span class="line-modified">2679   /*                   glyph loading process (e.g., whether the outline    */</span>
<span class="line-modified">2680   /*                   should be scaled, whether to load bitmaps or not,   */</span>
<span class="line-modified">2681   /*                   whether to hint the outline, etc).                  */</span>
<span class="line-modified">2682   /*                                                                       */</span>
<span class="line-modified">2683   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2684   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2685   /*                                                                       */</span>




2686   FT_LOCAL_DEF( FT_Error )
2687   TT_Load_Glyph( TT_Size       size,
2688                  TT_GlyphSlot  glyph,
2689                  FT_UInt       glyph_index,
2690                  FT_Int32      load_flags )
2691   {
2692     FT_Error      error;
2693     TT_LoaderRec  loader;
2694 
<span class="line-removed">2695 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-removed">2696 #define IS_DEFAULT_INSTANCE  ( !( FT_IS_NAMED_INSTANCE( glyph-&gt;face ) ||  \</span>
<span class="line-removed">2697                                   FT_IS_VARIATION( glyph-&gt;face )      ) )</span>
<span class="line-removed">2698 #else</span>
<span class="line-removed">2699 #define IS_DEFAULT_INSTANCE  1</span>
<span class="line-removed">2700 #endif</span>
<span class="line-removed">2701 </span>
2702 
2703     FT_TRACE1(( &quot;TT_Load_Glyph: glyph index %d\n&quot;, glyph_index ));
2704 
2705 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2706 
2707     /* try to load embedded bitmap (if any) */
2708     if ( size-&gt;strike_index != 0xFFFFFFFFUL      &amp;&amp;
2709          ( load_flags &amp; FT_LOAD_NO_BITMAP ) == 0 &amp;&amp;
<span class="line-modified">2710          IS_DEFAULT_INSTANCE                     )</span>
2711     {
2712       FT_Fixed  x_scale = size-&gt;root.metrics.x_scale;
2713       FT_Fixed  y_scale = size-&gt;root.metrics.y_scale;
2714 
2715 
2716       error = load_sbit_image( size, glyph, glyph_index, load_flags );
2717       if ( FT_ERR_EQ( error, Missing_Bitmap ) )
2718       {
2719         /* the bitmap strike is incomplete and misses the requested glyph; */
2720         /* if we have a bitmap-only font, return an empty glyph            */
2721         if ( !FT_IS_SCALABLE( glyph-&gt;face ) )
2722         {
2723           TT_Face  face = (TT_Face)glyph-&gt;face;
2724 
2725           FT_Short  left_bearing = 0;
2726           FT_Short  top_bearing  = 0;
2727 
2728           FT_UShort  advance_width  = 0;
2729           FT_UShort  advance_height = 0;
2730 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ttgload.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   TrueType Glyph Loader (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_CONFIG_CONFIG_H
  22 #include FT_INTERNAL_CALC_H
  23 #include FT_INTERNAL_STREAM_H
  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_TRUETYPE_TAGS_H
  26 #include FT_OUTLINE_H
  27 #include FT_DRIVER_H
  28 #include FT_LIST_H
  29 
  30 #include &quot;ttgload.h&quot;
  31 #include &quot;ttpload.h&quot;
  32 
  33 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  34 #include &quot;ttgxvar.h&quot;
  35 #endif
  36 
  37 #include &quot;tterrors.h&quot;
  38 #include &quot;ttsubpix.h&quot;
  39 
  40 
<span class="line-modified">  41   /**************************************************************************</span>
<span class="line-modified">  42    *</span>
<span class="line-modified">  43    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  44    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  45    * messages during execution.</span>
<span class="line-modified">  46    */</span>
  47 #undef  FT_COMPONENT
<span class="line-modified">  48 #define FT_COMPONENT  ttgload</span>
  49 
  50 
<span class="line-modified">  51   /**************************************************************************</span>
<span class="line-modified">  52    *</span>
<span class="line-modified">  53    * Simple glyph flags.</span>
<span class="line-modified">  54    */</span>
<span class="line-added">  55 #define ON_CURVE_POINT  0x01  /* same value as FT_CURVE_TAG_ON            */</span>
<span class="line-added">  56 #define X_SHORT_VECTOR  0x02</span>
<span class="line-added">  57 #define Y_SHORT_VECTOR  0x04</span>
<span class="line-added">  58 #define REPEAT_FLAG     0x08</span>
<span class="line-added">  59 #define X_POSITIVE      0x10  /* two meanings depending on X_SHORT_VECTOR */</span>
<span class="line-added">  60 #define SAME_X          0x10</span>
<span class="line-added">  61 #define Y_POSITIVE      0x20  /* two meanings depending on Y_SHORT_VECTOR */</span>
<span class="line-added">  62 #define SAME_Y          0x20</span>
<span class="line-added">  63 #define OVERLAP_SIMPLE  0x40  /* we ignore this value                     */</span>
<span class="line-added">  64 </span>
<span class="line-added">  65 </span>
<span class="line-added">  66   /**************************************************************************</span>
<span class="line-added">  67    *</span>
<span class="line-added">  68    * Composite glyph flags.</span>
<span class="line-added">  69    */</span>
  70 #define ARGS_ARE_WORDS             0x0001
  71 #define ARGS_ARE_XY_VALUES         0x0002
  72 #define ROUND_XY_TO_GRID           0x0004
  73 #define WE_HAVE_A_SCALE            0x0008
  74 /* reserved                        0x0010 */
  75 #define MORE_COMPONENTS            0x0020
  76 #define WE_HAVE_AN_XY_SCALE        0x0040
  77 #define WE_HAVE_A_2X2              0x0080
  78 #define WE_HAVE_INSTR              0x0100
  79 #define USE_MY_METRICS             0x0200
<span class="line-modified">  80 #define OVERLAP_COMPOUND           0x0400  /* we ignore this value */</span>
  81 #define SCALED_COMPONENT_OFFSET    0x0800
  82 #define UNSCALED_COMPONENT_OFFSET  0x1000
  83 
  84 
<span class="line-modified">  85 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-modified">  86 #define IS_DEFAULT_INSTANCE( _face )             \</span>
<span class="line-modified">  87           ( !( FT_IS_NAMED_INSTANCE( _face ) ||  \</span>
<span class="line-modified">  88                FT_IS_VARIATION( _face )      ) )</span>
<span class="line-added">  89 #else</span>
<span class="line-added">  90 #define IS_DEFAULT_INSTANCE( _face )  1</span>
<span class="line-added">  91 #endif</span>
<span class="line-added">  92 </span>
<span class="line-added">  93 </span>
<span class="line-added">  94   /**************************************************************************</span>
<span class="line-added">  95    *</span>
<span class="line-added">  96    * Return the horizontal metrics in font units for a given glyph.</span>
<span class="line-added">  97    */</span>
  98   FT_LOCAL_DEF( void )
  99   TT_Get_HMetrics( TT_Face     face,
 100                    FT_UInt     idx,
 101                    FT_Short*   lsb,
 102                    FT_UShort*  aw )
 103   {
 104     ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 0, idx, lsb, aw );
 105 
 106     FT_TRACE5(( &quot;  advance width (font units): %d\n&quot;, *aw ));
 107     FT_TRACE5(( &quot;  left side bearing (font units): %d\n&quot;, *lsb ));
 108   }
 109 
 110 
<span class="line-modified"> 111   /**************************************************************************</span>
<span class="line-modified"> 112    *</span>
<span class="line-modified"> 113    * Return the vertical metrics in font units for a given glyph.</span>
<span class="line-modified"> 114    * See function `tt_loader_set_pp&#39; below for explanations.</span>
<span class="line-modified"> 115    */</span>
 116   FT_LOCAL_DEF( void )
 117   TT_Get_VMetrics( TT_Face     face,
 118                    FT_UInt     idx,
 119                    FT_Pos      yMax,
 120                    FT_Short*   tsb,
 121                    FT_UShort*  ah )
 122   {
 123     if ( face-&gt;vertical_info )
 124       ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 1, idx, tsb, ah );
 125 
 126     else if ( face-&gt;os2.version != 0xFFFFU )
 127     {
 128       *tsb = (FT_Short)( face-&gt;os2.sTypoAscender - yMax );
 129       *ah  = (FT_UShort)FT_ABS( face-&gt;os2.sTypoAscender -
 130                                 face-&gt;os2.sTypoDescender );
 131     }
 132 
 133     else
 134     {
 135       *tsb = (FT_Short)( face-&gt;horizontal.Ascender - yMax );
</pre>
<hr />
<pre>
 257 
 258       loader-&gt;left_bearing = left_bearing;
 259       loader-&gt;advance      = advance_width;
 260       loader-&gt;top_bearing  = top_bearing;
 261       loader-&gt;vadvance     = advance_height;
 262 
 263       if ( !loader-&gt;linear_def )
 264       {
 265         loader-&gt;linear_def = 1;
 266         loader-&gt;linear     = advance_width;
 267       }
 268     }
 269 
 270   Exit:
 271     return;
 272   }
 273 
 274 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 275 
 276 
<span class="line-modified"> 277   /**************************************************************************</span>
<span class="line-modified"> 278    *</span>
<span class="line-modified"> 279    * The following functions are used by default with TrueType fonts.</span>
<span class="line-modified"> 280    * However, they can be replaced by alternatives if we need to support</span>
<span class="line-modified"> 281    * TrueType-compressed formats (like MicroType) in the future.</span>
<span class="line-modified"> 282    *</span>
<span class="line-modified"> 283    */</span>
 284 
 285   FT_CALLBACK_DEF( FT_Error )
 286   TT_Access_Glyph_Frame( TT_Loader  loader,
 287                          FT_UInt    glyph_index,
 288                          FT_ULong   offset,
 289                          FT_UInt    byte_count )
 290   {
 291     FT_Error   error;
 292     FT_Stream  stream = loader-&gt;stream;
 293 

 294     FT_UNUSED( glyph_index );
 295 
 296 


 297     /* the following line sets the `error&#39; variable through macros! */
 298     if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
 299       return error;
 300 
 301     loader-&gt;cursor = stream-&gt;cursor;
 302     loader-&gt;limit  = stream-&gt;limit;
 303 
 304     return FT_Err_Ok;
 305   }
 306 
 307 
 308   FT_CALLBACK_DEF( void )
 309   TT_Forget_Glyph_Frame( TT_Loader  loader )
 310   {
 311     FT_Stream  stream = loader-&gt;stream;
 312 
 313 
 314     FT_FRAME_EXIT();
 315   }
 316 
</pre>
<hr />
<pre>
 341 
 342     return FT_Err_Ok;
 343   }
 344 
 345 
 346   FT_CALLBACK_DEF( FT_Error )
 347   TT_Load_Simple_Glyph( TT_Loader  load )
 348   {
 349     FT_Error        error;
 350     FT_Byte*        p          = load-&gt;cursor;
 351     FT_Byte*        limit      = load-&gt;limit;
 352     FT_GlyphLoader  gloader    = load-&gt;gloader;
 353     FT_Int          n_contours = load-&gt;n_contours;
 354     FT_Outline*     outline;
 355     FT_UShort       n_ins;
 356     FT_Int          n_points;
 357 
 358     FT_Byte         *flag, *flag_limit;
 359     FT_Byte         c, count;
 360     FT_Vector       *vec, *vec_limit;
<span class="line-modified"> 361     FT_Pos          x, y;</span>
 362     FT_Short        *cont, *cont_limit, prev_cont;
 363     FT_Int          xy_size = 0;
 364 
 365 
 366     /* check that we can add the contours to the glyph */
 367     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
 368     if ( error )
 369       goto Fail;
 370 
 371     /* reading the contours&#39; endpoints &amp; number of points */
 372     cont       = gloader-&gt;current.outline.contours;
 373     cont_limit = cont + n_contours;
 374 
 375     /* check space for contours array + instructions count */
 376     if ( n_contours &gt;= 0xFFF || p + ( n_contours + 1 ) * 2 &gt; limit )
 377       goto Invalid_Outline;
 378 
 379     prev_cont = FT_NEXT_SHORT( p );
 380 
 381     if ( n_contours &gt; 0 )
</pre>
<hr />
<pre>
 386 
 387     for ( cont++; cont &lt; cont_limit; cont++ )
 388     {
 389       cont[0] = FT_NEXT_SHORT( p );
 390       if ( cont[0] &lt;= prev_cont )
 391       {
 392         /* unordered contours: this is invalid */
 393         goto Invalid_Outline;
 394       }
 395       prev_cont = cont[0];
 396     }
 397 
 398     n_points = 0;
 399     if ( n_contours &gt; 0 )
 400     {
 401       n_points = cont[-1] + 1;
 402       if ( n_points &lt; 0 )
 403         goto Invalid_Outline;
 404     }
 405 
<span class="line-added"> 406     FT_TRACE5(( &quot;  # of points: %d\n&quot;, n_points ));</span>
<span class="line-added"> 407 </span>
 408     /* note that we will add four phantom points later */
 409     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
 410     if ( error )
 411       goto Fail;
 412 
 413     /* reading the bytecode instructions */
 414     load-&gt;glyph-&gt;control_len  = 0;
 415     load-&gt;glyph-&gt;control_data = NULL;
 416 
 417     if ( p + 2 &gt; limit )
 418       goto Invalid_Outline;
 419 
 420     n_ins = FT_NEXT_USHORT( p );
 421 
 422     FT_TRACE5(( &quot;  Instructions size: %u\n&quot;, n_ins ));
 423 
 424 #ifdef TT_USE_BYTECODE_INTERPRETER
 425 
 426     if ( IS_HINTED( load-&gt;load_flags ) )
 427     {
</pre>
<hr />
<pre>
 458     }
 459 
 460 #endif /* TT_USE_BYTECODE_INTERPRETER */
 461 
 462     p += n_ins;
 463 
 464     outline = &amp;gloader-&gt;current.outline;
 465 
 466     /* reading the point tags */
 467     flag       = (FT_Byte*)outline-&gt;tags;
 468     flag_limit = flag + n_points;
 469 
 470     FT_ASSERT( flag );
 471 
 472     while ( flag &lt; flag_limit )
 473     {
 474       if ( p + 1 &gt; limit )
 475         goto Invalid_Outline;
 476 
 477       *flag++ = c = FT_NEXT_BYTE( p );
<span class="line-modified"> 478       if ( c &amp; REPEAT_FLAG )</span>
 479       {
 480         if ( p + 1 &gt; limit )
 481           goto Invalid_Outline;
 482 
 483         count = FT_NEXT_BYTE( p );
 484         if ( flag + (FT_Int)count &gt; flag_limit )
 485           goto Invalid_Outline;
 486 
 487         for ( ; count &gt; 0; count-- )
 488           *flag++ = c;
 489       }
 490     }
 491 
 492     /* reading the X coordinates */
 493 
 494     vec       = outline-&gt;points;
 495     vec_limit = vec + n_points;
 496     flag      = (FT_Byte*)outline-&gt;tags;
 497     x         = 0;
 498 
 499     if ( p + xy_size &gt; limit )
 500       goto Invalid_Outline;
 501 
 502     for ( ; vec &lt; vec_limit; vec++, flag++ )
 503     {
<span class="line-modified"> 504       FT_Pos   delta = 0;</span>
<span class="line-modified"> 505       FT_Byte  f     = *flag;</span>
 506 
 507 
<span class="line-modified"> 508       if ( f &amp; X_SHORT_VECTOR )</span>
 509       {
 510         if ( p + 1 &gt; limit )
 511           goto Invalid_Outline;
 512 
<span class="line-modified"> 513         delta = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 514         if ( !( f &amp; X_POSITIVE ) )</span>
<span class="line-modified"> 515           delta = -delta;</span>
 516       }
<span class="line-modified"> 517       else if ( !( f &amp; SAME_X ) )</span>
 518       {
 519         if ( p + 2 &gt; limit )
 520           goto Invalid_Outline;
 521 
<span class="line-modified"> 522         delta = (FT_Pos)FT_NEXT_SHORT( p );</span>
 523       }
 524 
<span class="line-modified"> 525       x     += delta;</span>
 526       vec-&gt;x = x;


 527     }
 528 
 529     /* reading the Y coordinates */
 530 
 531     vec       = gloader-&gt;current.outline.points;
 532     vec_limit = vec + n_points;
 533     flag      = (FT_Byte*)outline-&gt;tags;
<span class="line-modified"> 534     y         = 0;</span>
 535 
 536     for ( ; vec &lt; vec_limit; vec++, flag++ )
 537     {
<span class="line-modified"> 538       FT_Pos   delta = 0;</span>
<span class="line-modified"> 539       FT_Byte  f     = *flag;</span>
 540 
 541 
<span class="line-modified"> 542       if ( f &amp; Y_SHORT_VECTOR )</span>
 543       {
 544         if ( p + 1 &gt; limit )
 545           goto Invalid_Outline;
 546 
<span class="line-modified"> 547         delta = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 548         if ( !( f &amp; Y_POSITIVE ) )</span>
<span class="line-modified"> 549           delta = -delta;</span>
 550       }
<span class="line-modified"> 551       else if ( !( f &amp; SAME_Y ) )</span>
 552       {
 553         if ( p + 2 &gt; limit )
 554           goto Invalid_Outline;
 555 
<span class="line-modified"> 556         delta = (FT_Pos)FT_NEXT_SHORT( p );</span>
 557       }
 558 
<span class="line-modified"> 559       y     += delta;</span>
<span class="line-modified"> 560       vec-&gt;y = y;</span>
<span class="line-added"> 561 </span>
 562       /* the cast is for stupid compilers */
<span class="line-modified"> 563       *flag  = (FT_Byte)( f &amp; ON_CURVE_POINT );</span>
 564     }
 565 
 566     outline-&gt;n_points   = (FT_Short)n_points;
 567     outline-&gt;n_contours = (FT_Short)n_contours;
 568 
 569     load-&gt;cursor = p;
 570 
 571   Fail:
 572     return error;
 573 
 574   Invalid_Outline:
 575     error = FT_THROW( Invalid_Outline );
 576     goto Fail;
 577   }
 578 
 579 
 580   FT_CALLBACK_DEF( FT_Error )
 581   TT_Load_Composite_Glyph( TT_Loader  loader )
 582   {
 583     FT_Error        error;
<span class="line-modified"> 584     FT_Byte*        p          = loader-&gt;cursor;</span>
<span class="line-modified"> 585     FT_Byte*        limit      = loader-&gt;limit;</span>
<span class="line-modified"> 586     FT_GlyphLoader  gloader    = loader-&gt;gloader;</span>
<span class="line-added"> 587     FT_Long         num_glyphs = loader-&gt;face-&gt;root.num_glyphs;</span>
 588     FT_SubGlyph     subglyph;
 589     FT_UInt         num_subglyphs;
 590 
 591 
 592     num_subglyphs = 0;
 593 
 594     do
 595     {
 596       FT_Fixed  xx, xy, yy, yx;
 597       FT_UInt   count;
 598 
 599 
 600       /* check that we can load a new subglyph */
 601       error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
 602       if ( error )
 603         goto Fail;
 604 
 605       /* check space */
 606       if ( p + 4 &gt; limit )
 607         goto Invalid_Composite;
 608 
 609       subglyph = gloader-&gt;current.subglyphs + num_subglyphs;
 610 
 611       subglyph-&gt;arg1 = subglyph-&gt;arg2 = 0;
 612 
 613       subglyph-&gt;flags = FT_NEXT_USHORT( p );
 614       subglyph-&gt;index = FT_NEXT_USHORT( p );
 615 
<span class="line-added"> 616       /* we reject composites that have components */</span>
<span class="line-added"> 617       /* with invalid glyph indices                */</span>
<span class="line-added"> 618       if ( subglyph-&gt;index &gt;= num_glyphs )</span>
<span class="line-added"> 619         goto Invalid_Composite;</span>
<span class="line-added"> 620 </span>
 621       /* check space */
 622       count = 2;
 623       if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 624         count += 2;
 625       if ( subglyph-&gt;flags &amp; WE_HAVE_A_SCALE )
 626         count += 2;
 627       else if ( subglyph-&gt;flags &amp; WE_HAVE_AN_XY_SCALE )
 628         count += 4;
 629       else if ( subglyph-&gt;flags &amp; WE_HAVE_A_2X2 )
 630         count += 8;
 631 
 632       if ( p + count &gt; limit )
 633         goto Invalid_Composite;
 634 
 635       /* read arguments */
 636       if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
 637       {
 638         if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 639         {
 640           subglyph-&gt;arg1 = FT_NEXT_SHORT( p );
</pre>
<hr />
<pre>
 779 
 780   static void
 781   tt_prepare_zone( TT_GlyphZone  zone,
 782                    FT_GlyphLoad  load,
 783                    FT_UInt       start_point,
 784                    FT_UInt       start_contour )
 785   {
 786     zone-&gt;n_points    = (FT_UShort)load-&gt;outline.n_points -
 787                           (FT_UShort)start_point;
 788     zone-&gt;n_contours  = load-&gt;outline.n_contours -
 789                           (FT_Short)start_contour;
 790     zone-&gt;org         = load-&gt;extra_points + start_point;
 791     zone-&gt;cur         = load-&gt;outline.points + start_point;
 792     zone-&gt;orus        = load-&gt;extra_points2 + start_point;
 793     zone-&gt;tags        = (FT_Byte*)load-&gt;outline.tags + start_point;
 794     zone-&gt;contours    = (FT_UShort*)load-&gt;outline.contours + start_contour;
 795     zone-&gt;first_point = (FT_UShort)start_point;
 796   }
 797 
 798 
<span class="line-modified"> 799   /**************************************************************************</span>
<span class="line-modified"> 800    *</span>
<span class="line-modified"> 801    * @Function:</span>
<span class="line-modified"> 802    *   TT_Hint_Glyph</span>
<span class="line-modified"> 803    *</span>
<span class="line-modified"> 804    * @Description:</span>
<span class="line-modified"> 805    *   Hint the glyph using the zone prepared by the caller.  Note that</span>
<span class="line-modified"> 806    *   the zone is supposed to include four phantom points.</span>
<span class="line-modified"> 807    */</span>
 808   static FT_Error
 809   TT_Hint_Glyph( TT_Loader  loader,
 810                  FT_Bool    is_composite )
 811   {
 812 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
 813     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 814     TT_Face    face   = loader-&gt;face;
 815     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 816 #endif
 817 
 818     TT_GlyphZone  zone = &amp;loader-&gt;zone;
 819 
 820 #ifdef TT_USE_BYTECODE_INTERPRETER
 821     FT_Long       n_ins;
 822 #else
 823     FT_UNUSED( is_composite );
 824 #endif
 825 
 826 
 827 #ifdef TT_USE_BYTECODE_INTERPRETER






 828     n_ins = loader-&gt;glyph-&gt;control_len;
 829 
<span class="line-modified"> 830     /* save original point positions in `org&#39; array */</span>
 831     if ( n_ins &gt; 0 )
 832       FT_ARRAY_COPY( zone-&gt;org, zone-&gt;cur, zone-&gt;n_points );
 833 
 834     /* Reset graphics state. */
 835     loader-&gt;exec-&gt;GS = loader-&gt;size-&gt;GS;
 836 
 837     /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
 838     /*      completely refer to the (already) hinted subglyphs.     */
 839     if ( is_composite )
 840     {
 841       loader-&gt;exec-&gt;metrics.x_scale = 1 &lt;&lt; 16;
 842       loader-&gt;exec-&gt;metrics.y_scale = 1 &lt;&lt; 16;
 843 
 844       FT_ARRAY_COPY( zone-&gt;orus, zone-&gt;cur, zone-&gt;n_points );
 845     }
 846     else
 847     {
 848       loader-&gt;exec-&gt;metrics.x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
 849       loader-&gt;exec-&gt;metrics.y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
 850     }
</pre>
<hr />
<pre>
 901       loader-&gt;pp4 = zone-&gt;cur[zone-&gt;n_points - 1];
 902 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 903     }
 904 #endif
 905 
 906 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 907     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
 908     {
 909       if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_DEEMBOLDEN )
 910         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, -24, 0 );
 911 
 912       else if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_EMBOLDEN )
 913         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, 24, 0 );
 914     }
 915 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 916 
 917     return FT_Err_Ok;
 918   }
 919 
 920 
<span class="line-modified"> 921   /**************************************************************************</span>
<span class="line-modified"> 922    *</span>
<span class="line-modified"> 923    * @Function:</span>
<span class="line-modified"> 924    *   TT_Process_Simple_Glyph</span>
<span class="line-modified"> 925    *</span>
<span class="line-modified"> 926    * @Description:</span>
<span class="line-modified"> 927    *   Once a simple glyph has been loaded, it needs to be processed.</span>
<span class="line-modified"> 928    *   Usually, this means scaling and hinting through bytecode</span>
<span class="line-modified"> 929    *   interpretation.</span>
<span class="line-modified"> 930    */</span>
 931   static FT_Error
 932   TT_Process_Simple_Glyph( TT_Loader  loader )
 933   {
 934     FT_GlyphLoader  gloader = loader-&gt;gloader;
 935     FT_Error        error   = FT_Err_Ok;
 936     FT_Outline*     outline;
 937     FT_Int          n_points;
 938 
<span class="line-added"> 939 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-added"> 940     FT_Memory   memory    = loader-&gt;face-&gt;root.memory;</span>
<span class="line-added"> 941     FT_Vector*  unrounded = NULL;</span>
<span class="line-added"> 942 #endif</span>
<span class="line-added"> 943 </span>
 944 
 945     outline  = &amp;gloader-&gt;current.outline;
 946     n_points = outline-&gt;n_points;
 947 
 948     /* set phantom points */
 949 
 950     outline-&gt;points[n_points    ] = loader-&gt;pp1;
 951     outline-&gt;points[n_points + 1] = loader-&gt;pp2;
 952     outline-&gt;points[n_points + 2] = loader-&gt;pp3;
 953     outline-&gt;points[n_points + 3] = loader-&gt;pp4;
 954 
 955     outline-&gt;tags[n_points    ] = 0;
 956     outline-&gt;tags[n_points + 1] = 0;
 957     outline-&gt;tags[n_points + 2] = 0;
 958     outline-&gt;tags[n_points + 3] = 0;
 959 
 960     n_points += 4;
 961 
 962 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 963 
<span class="line-modified"> 964     if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader-&gt;face ) ) )</span>

 965     {
<span class="line-added"> 966       if ( FT_NEW_ARRAY( unrounded, n_points ) )</span>
<span class="line-added"> 967         goto Exit;</span>
<span class="line-added"> 968 </span>
 969       /* Deltas apply to the unscaled data. */
 970       error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
 971                                           loader-&gt;glyph_index,
 972                                           outline,
<span class="line-added"> 973                                           unrounded,</span>
 974                                           (FT_UInt)n_points );
 975 
 976       /* recalculate linear horizontal and vertical advances */
 977       /* if we don&#39;t have HVAR and VVAR, respectively        */
<span class="line-added"> 978 </span>
<span class="line-added"> 979       /* XXX: change all FreeType modules to store `linear&#39; and `vadvance&#39; */</span>
<span class="line-added"> 980       /*      in 26.6 format before the `base&#39; module scales them to 16.16 */</span>
 981       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified"> 982         loader-&gt;linear = FT_PIX_ROUND( unrounded[n_points - 3].x -</span>
<span class="line-modified"> 983                                        unrounded[n_points - 4].x ) / 64;</span>
 984       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified"> 985         loader-&gt;vadvance = FT_PIX_ROUND( unrounded[n_points - 1].x -</span>
<span class="line-modified"> 986                                          unrounded[n_points - 2].x ) / 64;</span>
 987 
 988       if ( error )
<span class="line-modified"> 989         goto Exit;</span>
 990     }
 991 
 992 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 993 
 994     if ( IS_HINTED( loader-&gt;load_flags ) )
 995     {
 996       tt_prepare_zone( &amp;loader-&gt;zone, &amp;gloader-&gt;current, 0, 0 );
 997 
 998       FT_ARRAY_COPY( loader-&gt;zone.orus, loader-&gt;zone.cur,
 999                      loader-&gt;zone.n_points + 4 );
1000     }
1001 
1002     {
1003 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1004       TT_Face    face   = loader-&gt;face;
1005       TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
1006 
1007       FT_String*  family         = face-&gt;root.family_name;
1008       FT_UInt     ppem           = loader-&gt;size-&gt;metrics-&gt;x_ppem;
1009       FT_String*  style          = face-&gt;root.style_name;
</pre>
<hr />
<pre>
1024       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
1025       {
1026         /* scale, but only if enabled and only if TT hinting is being used */
1027         if ( IS_HINTED( loader-&gt;load_flags ) )
1028           x_scale_factor = sph_test_tweak_x_scaling( face,
1029                                                      family,
1030                                                      ppem,
1031                                                      style,
1032                                                      loader-&gt;glyph_index );
1033         /* scale the glyph */
1034         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 ||
1035              x_scale_factor != 1000                         )
1036         {
1037           x_scale = FT_MulDiv( loader-&gt;size-&gt;metrics-&gt;x_scale,
1038                                (FT_Long)x_scale_factor, 1000 );
1039           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1040 
1041           /* compensate for any scaling by de/emboldening; */
1042           /* the amount was determined via experimentation */
1043           if ( x_scale_factor != 1000 &amp;&amp; ppem &gt; 11 )
<span class="line-added">1044           {</span>
<span class="line-added">1045 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-added">1046             FT_Vector*  orig_points = outline-&gt;points;</span>
<span class="line-added">1047 </span>
<span class="line-added">1048 </span>
<span class="line-added">1049             if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader-&gt;face ) ) )</span>
<span class="line-added">1050               outline-&gt;points = unrounded;</span>
<span class="line-added">1051 #endif</span>
1052             FT_Outline_EmboldenXY( outline,
1053                                    FT_MulFix( 1280 * ppem,
1054                                               1000 - x_scale_factor ),
1055                                    0 );
<span class="line-added">1056 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-added">1057             if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader-&gt;face ) ) )</span>
<span class="line-added">1058               outline-&gt;points = orig_points;</span>
<span class="line-added">1059 #endif</span>
<span class="line-added">1060           }</span>
1061           do_scale = TRUE;
1062         }
1063       }
1064       else
1065 
1066 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
1067 
1068       {
1069         /* scale the glyph */
1070         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1071         {
1072           x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1073           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1074 
1075           do_scale = TRUE;
1076         }
1077       }
1078 
1079       if ( do_scale )
1080       {
<span class="line-modified">1081 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-added">1082         if ( !IS_DEFAULT_INSTANCE( FT_FACE( loader-&gt;face ) ) )</span>
1083         {
<span class="line-modified">1084           FT_Vector*  u = unrounded;</span>
<span class="line-modified">1085 </span>
<span class="line-added">1086 </span>
<span class="line-added">1087           for ( ; vec &lt; limit; vec++, u++ )</span>
<span class="line-added">1088           {</span>
<span class="line-added">1089             vec-&gt;x = ( FT_MulFix( u-&gt;x, x_scale ) + 32 ) &gt;&gt; 6;</span>
<span class="line-added">1090             vec-&gt;y = ( FT_MulFix( u-&gt;y, y_scale ) + 32 ) &gt;&gt; 6;</span>
<span class="line-added">1091           }</span>
<span class="line-added">1092         }</span>
<span class="line-added">1093         else</span>
<span class="line-added">1094 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */</span>
<span class="line-added">1095         {</span>
<span class="line-added">1096           for ( ; vec &lt; limit; vec++ )</span>
<span class="line-added">1097           {</span>
<span class="line-added">1098             vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );</span>
<span class="line-added">1099             vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );</span>
<span class="line-added">1100           }</span>
1101         }
1102       }
1103 
1104 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1105       /* if we have a HVAR table, `pp1&#39; and/or `pp2&#39; are already adjusted */
1106       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) ||
1107            !IS_HINTED( loader-&gt;load_flags )                                 )
1108 #endif
1109       {
1110         loader-&gt;pp1 = outline-&gt;points[n_points - 4];
1111         loader-&gt;pp2 = outline-&gt;points[n_points - 3];
1112       }
1113 
1114 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1115       /* if we have a VVAR table, `pp3&#39; and/or `pp4&#39; are already adjusted */
1116       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) ||
1117            !IS_HINTED( loader-&gt;load_flags )                                 )
1118 #endif
1119       {
1120         loader-&gt;pp3 = outline-&gt;points[n_points - 2];
1121         loader-&gt;pp4 = outline-&gt;points[n_points - 1];
1122       }
1123     }
1124 
1125     if ( IS_HINTED( loader-&gt;load_flags ) )
1126     {
1127       loader-&gt;zone.n_points += 4;
1128 
1129       error = TT_Hint_Glyph( loader, 0 );
1130     }
1131 
<span class="line-added">1132 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-added">1133   Exit:</span>
<span class="line-added">1134     FT_FREE( unrounded );</span>
<span class="line-added">1135 #endif</span>
<span class="line-added">1136 </span>
1137     return error;
1138   }
1139 
1140 
<span class="line-modified">1141   /**************************************************************************</span>
<span class="line-modified">1142    *</span>
<span class="line-modified">1143    * @Function:</span>
<span class="line-modified">1144    *   TT_Process_Composite_Component</span>
<span class="line-modified">1145    *</span>
<span class="line-modified">1146    * @Description:</span>
<span class="line-modified">1147    *   Once a composite component has been loaded, it needs to be</span>
<span class="line-modified">1148    *   processed.  Usually, this means transforming and translating.</span>
<span class="line-modified">1149    */</span>
1150   static FT_Error
1151   TT_Process_Composite_Component( TT_Loader    loader,
1152                                   FT_SubGlyph  subglyph,
1153                                   FT_UInt      start_point,
1154                                   FT_UInt      num_base_points )
1155   {
1156     FT_GlyphLoader  gloader = loader-&gt;gloader;
1157     FT_Outline      current;
1158     FT_Bool         have_scale;
1159     FT_Pos          x, y;
1160 
1161 
1162     current.points   = gloader-&gt;base.outline.points +
1163                          num_base_points;
1164     current.n_points = gloader-&gt;base.outline.n_points -
1165                          (short)num_base_points;
1166 
1167     have_scale = FT_BOOL( subglyph-&gt;flags &amp; ( WE_HAVE_A_SCALE     |
1168                                               WE_HAVE_AN_XY_SCALE |
1169                                               WE_HAVE_A_2X2       ) );
</pre>
<hr />
<pre>
1203       x = subglyph-&gt;arg1;
1204       y = subglyph-&gt;arg2;
1205 
1206       if ( !x &amp;&amp; !y )
1207         return FT_Err_Ok;
1208 
1209       /* Use a default value dependent on                                  */
1210       /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
1211       /* TT fonts which don&#39;t set the xxx_COMPONENT_OFFSET bit.            */
1212 
1213       if ( have_scale &amp;&amp;
1214 #ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
1215            !( subglyph-&gt;flags &amp; UNSCALED_COMPONENT_OFFSET ) )
1216 #else
1217             ( subglyph-&gt;flags &amp; SCALED_COMPONENT_OFFSET ) )
1218 #endif
1219       {
1220 
1221 #if 0
1222 
<span class="line-modified">1223         /********************************************************************</span>
<span class="line-modified">1224          *</span>
<span class="line-modified">1225          * This algorithm is what Apple documents.  But it doesn&#39;t work.</span>
<span class="line-modified">1226          */</span>
1227         int  a = subglyph-&gt;transform.xx &gt; 0 ?  subglyph-&gt;transform.xx
1228                                             : -subglyph-&gt;transform.xx;
1229         int  b = subglyph-&gt;transform.yx &gt; 0 ?  subglyph-&gt;transform.yx
1230                                             : -subglyph-&gt;transform.yx;
1231         int  c = subglyph-&gt;transform.xy &gt; 0 ?  subglyph-&gt;transform.xy
1232                                             : -subglyph-&gt;transform.xy;
1233         int  d = subglyph-&gt;transform.yy &gt; 0 ?  subglyph-&gt;transform.yy
1234                                             : -subglyph-&gt;transform.yy;
1235         int  m = a &gt; b ? a : b;
1236         int  n = c &gt; d ? c : d;
1237 
1238 
1239         if ( a - b &lt;= 33 &amp;&amp; a - b &gt;= -33 )
1240           m *= 2;
1241         if ( c - d &lt;= 33 &amp;&amp; c - d &gt;= -33 )
1242           n *= 2;
1243         x = FT_MulFix( x, m );
1244         y = FT_MulFix( y, n );
1245 
1246 #else /* 1 */
1247 
<span class="line-modified">1248         /********************************************************************</span>
<span class="line-modified">1249          *</span>
<span class="line-modified">1250          * This algorithm is a guess and works much better than the above.</span>
<span class="line-modified">1251          */</span>
1252         FT_Fixed  mac_xscale = FT_Hypot( subglyph-&gt;transform.xx,
1253                                          subglyph-&gt;transform.xy );
1254         FT_Fixed  mac_yscale = FT_Hypot( subglyph-&gt;transform.yy,
1255                                          subglyph-&gt;transform.yx );
1256 
1257 
1258         x = FT_MulFix( x, mac_xscale );
1259         y = FT_MulFix( y, mac_yscale );
1260 
1261 #endif /* 1 */
1262 
1263       }
1264 
1265       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
1266       {
1267         FT_Fixed  x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1268         FT_Fixed  y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1269 
1270 
1271         x = FT_MulFix( x, x_scale );
</pre>
<hr />
<pre>
1289              * neither allow nor expect modified advance widths if subpixel
1290              * rendering is active.
1291              *
1292              */
1293             if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_35 )
1294               x = FT_PIX_ROUND( x );
1295 
1296             y = FT_PIX_ROUND( y );
1297           }
1298         }
1299       }
1300     }
1301 
1302     if ( x || y )
1303       FT_Outline_Translate( &amp;current, x, y );
1304 
1305     return FT_Err_Ok;
1306   }
1307 
1308 
<span class="line-modified">1309   /**************************************************************************</span>
<span class="line-modified">1310    *</span>
<span class="line-modified">1311    * @Function:</span>
<span class="line-modified">1312    *   TT_Process_Composite_Glyph</span>
<span class="line-modified">1313    *</span>
<span class="line-modified">1314    * @Description:</span>
<span class="line-modified">1315    *   This is slightly different from TT_Process_Simple_Glyph, in that</span>
<span class="line-modified">1316    *   its sole purpose is to hint the glyph.  Thus this function is</span>
<span class="line-modified">1317    *   only available when bytecode interpreter is enabled.</span>
<span class="line-modified">1318    */</span>
1319   static FT_Error
1320   TT_Process_Composite_Glyph( TT_Loader  loader,
1321                               FT_UInt    start_point,
1322                               FT_UInt    start_contour )
1323   {
1324     FT_Error     error;
1325     FT_Outline*  outline;
1326     FT_UInt      i;
1327 
1328 
1329     outline = &amp;loader-&gt;gloader-&gt;base.outline;
1330 
1331     /* make room for phantom points */
1332     error = FT_GLYPHLOADER_CHECK_POINTS( loader-&gt;gloader,
1333                                          outline-&gt;n_points + 4,
1334                                          0 );
1335     if ( error )
1336       return error;
1337 
1338     outline-&gt;points[outline-&gt;n_points    ] = loader-&gt;pp1;
</pre>
<hr />
<pre>
1510 
1511 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1512     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
1513     {
1514       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting
1515                                       : 0;
1516       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale
1517                                       : 0;
1518     }
1519 #endif
1520 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1521     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
1522     {
1523       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting_lean
1524                                       : 0;
1525       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale_cleartype
1526                                       : 0;
1527     }
1528 #endif
1529 
<span class="line-modified">1530     use_aw_2 = FT_BOOL( subpixel_hinting &amp;&amp; grayscale );</span>
1531 
1532     loader-&gt;pp1.x = loader-&gt;bbox.xMin - loader-&gt;left_bearing;
1533     loader-&gt;pp1.y = 0;
1534     loader-&gt;pp2.x = loader-&gt;pp1.x + loader-&gt;advance;
1535     loader-&gt;pp2.y = 0;
1536 
1537     loader-&gt;pp3.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1538     loader-&gt;pp3.y = loader-&gt;bbox.yMax + loader-&gt;top_bearing;
1539     loader-&gt;pp4.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1540     loader-&gt;pp4.y = loader-&gt;pp3.y - loader-&gt;vadvance;
1541   }
1542 
1543 
1544   /* a utility function to retrieve i-th node from given FT_List */
1545   static FT_ListNode
1546   ft_list_get_node_at( FT_List  list,
1547                        FT_UInt  idx )
1548   {
1549     FT_ListNode  cur;
1550 
1551 
1552     if ( !list )
1553       return NULL;
1554 
1555     for ( cur = list-&gt;head; cur; cur = cur-&gt;next )
1556     {
1557       if ( !idx )
1558         return cur;
1559 
1560       idx--;
1561     }
1562 
1563     return NULL;
1564   }
1565 
1566 
<span class="line-modified">1567   /**************************************************************************</span>
<span class="line-modified">1568    *</span>
<span class="line-modified">1569    * @Function:</span>
<span class="line-modified">1570    *   load_truetype_glyph</span>
<span class="line-modified">1571    *</span>
<span class="line-modified">1572    * @Description:</span>
<span class="line-modified">1573    *   Loads a given truetype glyph.  Handles composites and uses a</span>
<span class="line-modified">1574    *   TT_Loader object.</span>
<span class="line-modified">1575    */</span>
1576   static FT_Error
1577   load_truetype_glyph( TT_Loader  loader,
1578                        FT_UInt    glyph_index,
1579                        FT_UInt    recurse_count,
1580                        FT_Bool    header_only )
1581   {
<span class="line-modified">1582     FT_Error        error   = FT_Err_Ok;</span>
1583     FT_Fixed        x_scale, y_scale;
1584     FT_ULong        offset;
<span class="line-modified">1585     TT_Face         face    = loader-&gt;face;</span>
<span class="line-modified">1586     FT_GlyphLoader  gloader = loader-&gt;gloader;</span>
<span class="line-modified">1587 </span>
<span class="line-added">1588     FT_Bool  opened_frame = 0;</span>
1589 
1590 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1591     FT_StreamRec    inc_stream;
1592     FT_Data         glyph_data;
1593     FT_Bool         glyph_data_loaded = 0;
1594 #endif
1595 
1596 
1597 #ifdef FT_DEBUG_LEVEL_TRACE
1598     if ( recurse_count )
1599       FT_TRACE5(( &quot;  nesting level: %d\n&quot;, recurse_count ));
1600 #endif
1601 
1602     /* some fonts have an incorrect value of `maxComponentDepth&#39; */
1603     if ( recurse_count &gt; face-&gt;max_profile.maxComponentDepth )
1604     {
1605       FT_TRACE1(( &quot;load_truetype_glyph: maxComponentDepth set to %d\n&quot;,
1606                   recurse_count ));
1607       face-&gt;max_profile.maxComponentDepth = (FT_UShort)recurse_count;
1608     }
1609 
1610 #ifndef FT_CONFIG_OPTION_INCREMENTAL
1611     /* check glyph index */
1612     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs )
1613     {
1614       error = FT_THROW( Invalid_Glyph_Index );
1615       goto Exit;
1616     }
1617 #endif
1618 
1619     loader-&gt;glyph_index = glyph_index;
1620 
<span class="line-modified">1621     if ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE )</span>
1622     {
<span class="line-modified">1623       x_scale = 0x10000L;</span>
<span class="line-modified">1624       y_scale = 0x10000L;</span>
1625     }
1626     else
1627     {
<span class="line-modified">1628       x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;</span>
<span class="line-modified">1629       y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;</span>
1630     }
1631 
1632     /* Set `offset&#39; to the start of the glyph relative to the start of */
1633     /* the `glyf&#39; table, and `byte_len&#39; to the length of the glyph in  */
1634     /* bytes.                                                          */
1635 
1636 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1637 
1638     /* If we are loading glyph data via the incremental interface, set */
1639     /* the loader stream to a memory stream reading the data returned  */
1640     /* by the interface.                                               */
1641     if ( face-&gt;root.internal-&gt;incremental_interface )
1642     {
1643       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_data(
1644                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
1645                 glyph_index, &amp;glyph_data );
1646       if ( error )
1647         goto Exit;
1648 
1649       glyph_data_loaded = 1;
</pre>
<hr />
<pre>
1668     {
1669 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1670       /* for the incremental interface, `glyf_offset&#39; is always zero */
1671       if ( !face-&gt;glyf_offset                          &amp;&amp;
1672            !face-&gt;root.internal-&gt;incremental_interface )
1673 #else
1674       if ( !face-&gt;glyf_offset )
1675 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
1676       {
1677         FT_TRACE2(( &quot;no `glyf&#39; table but non-zero `loca&#39; entry\n&quot; ));
1678         error = FT_THROW( Invalid_Table );
1679         goto Exit;
1680       }
1681 
1682       error = face-&gt;access_glyph_frame( loader, glyph_index,
1683                                         face-&gt;glyf_offset + offset,
1684                                         (FT_UInt)loader-&gt;byte_len );
1685       if ( error )
1686         goto Exit;
1687 


1688       /* read glyph header first */
1689       error = face-&gt;read_glyph_header( loader );


1690 
<span class="line-modified">1691       face-&gt;forget_glyph_frame( loader );</span>





1692 
<span class="line-modified">1693       if ( error )</span>
1694         goto Exit;
1695     }
1696 
<span class="line-added">1697     /* a space glyph */</span>
1698     if ( loader-&gt;byte_len == 0 || loader-&gt;n_contours == 0 )
1699     {
1700       loader-&gt;bbox.xMin = 0;
1701       loader-&gt;bbox.xMax = 0;
1702       loader-&gt;bbox.yMin = 0;
1703       loader-&gt;bbox.yMax = 0;
<span class="line-added">1704     }</span>
1705 
<span class="line-modified">1706     /* the metrics must be computed after loading the glyph header */</span>
<span class="line-modified">1707     /* since we need the glyph&#39;s `yMax&#39; value in case the vertical */</span>
<span class="line-modified">1708     /* metrics must be emulated                                    */</span>
<span class="line-added">1709     error = tt_get_metrics( loader, glyph_index );</span>
<span class="line-added">1710     if ( error )</span>
<span class="line-added">1711       goto Exit;</span>
1712 
<span class="line-modified">1713     if ( header_only )</span>
<span class="line-modified">1714       goto Exit;</span>
1715 
<span class="line-added">1716     if ( loader-&gt;byte_len == 0 || loader-&gt;n_contours == 0 )</span>
<span class="line-added">1717     {</span>
1718       /* must initialize points before (possibly) overriding */
1719       /* glyph metrics from the incremental interface        */
1720       tt_loader_set_pp( loader );
1721 
1722 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1723       tt_get_metrics_incr_overrides( loader, glyph_index );
1724 #endif
1725 
1726 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1727 
1728       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1729            FT_IS_VARIATION( FT_FACE( face ) )      )
1730       {
1731         /* a small outline structure with four elements for */
1732         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39;  */
1733         FT_Vector   points[4];
1734         char        tags[4]     = { 1, 1, 1, 1 };
1735         short       contours[4] = { 0, 1, 2, 3 };
1736         FT_Outline  outline;
1737 
<span class="line-added">1738         /* unrounded values */</span>
<span class="line-added">1739         FT_Vector  unrounded[4] = { {0, 0}, {0, 0}, {0, 0}, {0, 0} };</span>
<span class="line-added">1740 </span>
1741 
1742         points[0].x = loader-&gt;pp1.x;
1743         points[0].y = loader-&gt;pp1.y;
1744         points[1].x = loader-&gt;pp2.x;
1745         points[1].y = loader-&gt;pp2.y;
1746 
1747         points[2].x = loader-&gt;pp3.x;
1748         points[2].y = loader-&gt;pp3.y;
1749         points[3].x = loader-&gt;pp4.x;
1750         points[3].y = loader-&gt;pp4.y;
1751 
1752         outline.n_points   = 4;
1753         outline.n_contours = 4;
1754         outline.points     = points;
1755         outline.tags       = tags;
1756         outline.contours   = contours;
1757 
1758         /* this must be done before scaling */
1759         error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
1760                                             glyph_index,
1761                                             &amp;outline,
<span class="line-added">1762                                             unrounded,</span>
1763                                             (FT_UInt)outline.n_points );
1764         if ( error )
1765           goto Exit;
1766 
1767         loader-&gt;pp1.x = points[0].x;
1768         loader-&gt;pp1.y = points[0].y;
1769         loader-&gt;pp2.x = points[1].x;
1770         loader-&gt;pp2.y = points[1].y;
1771 
1772         loader-&gt;pp3.x = points[2].x;
1773         loader-&gt;pp3.y = points[2].y;
1774         loader-&gt;pp4.x = points[3].x;
1775         loader-&gt;pp4.y = points[3].y;
1776 

1777         /* recalculate linear horizontal and vertical advances */
1778         /* if we don&#39;t have HVAR and VVAR, respectively        */
1779         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">1780           loader-&gt;linear = FT_PIX_ROUND( unrounded[1].x -</span>
<span class="line-added">1781                                          unrounded[0].x ) / 64;</span>
1782         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">1783           loader-&gt;vadvance = FT_PIX_ROUND( unrounded[3].x -</span>
<span class="line-added">1784                                            unrounded[2].x ) / 64;</span>
1785       }
1786 
1787 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1788 
1789       /* scale phantom points, if necessary; */
1790       /* they get rounded in `TT_Hint_Glyph&#39; */
1791       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1792       {
1793         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
1794         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
1795         /* pp1.y and pp2.y are always zero */
1796 
1797         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
1798         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
1799         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
1800         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
1801       }
1802 
1803       error = FT_Err_Ok;
1804       goto Exit;
1805     }
1806 
1807     /* must initialize phantom points before (possibly) overriding */
1808     /* glyph metrics from the incremental interface                */
1809     tt_loader_set_pp( loader );
1810 
1811 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1812     tt_get_metrics_incr_overrides( loader, glyph_index );
1813 #endif
1814 
1815     /***********************************************************************/
1816     /***********************************************************************/
1817     /***********************************************************************/
1818 
<span class="line-added">1819     /* we now open a frame again, right after the glyph header */</span>
<span class="line-added">1820     /* (which consists of 10 bytes)                            */</span>
<span class="line-added">1821     error = face-&gt;access_glyph_frame( loader, glyph_index,</span>
<span class="line-added">1822                                       face-&gt;glyf_offset + offset + 10,</span>
<span class="line-added">1823                                       (FT_UInt)loader-&gt;byte_len - 10 );</span>
<span class="line-added">1824     if ( error )</span>
<span class="line-added">1825       goto Exit;</span>
<span class="line-added">1826 </span>
<span class="line-added">1827     opened_frame = 1;</span>
<span class="line-added">1828 </span>
1829     /* if it is a simple glyph, load it */
1830 
1831     if ( loader-&gt;n_contours &gt; 0 )
1832     {
1833       error = face-&gt;read_simple_glyph( loader );
1834       if ( error )
1835         goto Exit;
1836 
1837       /* all data have been read */
1838       face-&gt;forget_glyph_frame( loader );
1839       opened_frame = 0;
1840 
1841       error = TT_Process_Simple_Glyph( loader );
1842       if ( error )
1843         goto Exit;
1844 
1845       FT_GlyphLoader_Add( gloader );
1846     }
1847 
1848     /***********************************************************************/
</pre>
<hr />
<pre>
1854     {
1855       FT_Memory  memory = face-&gt;root.memory;
1856 
1857       FT_UInt   start_point;
1858       FT_UInt   start_contour;
1859       FT_ULong  ins_pos;  /* position of composite instructions, if any */
1860 
1861       FT_ListNode  node, node2;
1862 
1863 
1864       /* normalize the `n_contours&#39; value */
1865       loader-&gt;n_contours = -1;
1866 
1867       /*
1868        * We store the glyph index directly in the `node-&gt;data&#39; pointer,
1869        * following the glib solution (cf. macro `GUINT_TO_POINTER&#39;) with a
1870        * double cast to make this portable.  Note, however, that this needs
1871        * pointers with a width of at least 32 bits.
1872        */
1873 

1874       /* clear the nodes filled by sibling chains */
1875       node = ft_list_get_node_at( &amp;loader-&gt;composites, recurse_count );
1876       for ( node2 = node; node2; node2 = node2-&gt;next )
1877         node2-&gt;data = (void*)FT_ULONG_MAX;
1878 
1879       /* check whether we already have a composite glyph with this index */
1880       if ( FT_List_Find( &amp;loader-&gt;composites,
1881                          FT_UINT_TO_POINTER( glyph_index ) ) )
1882       {
1883         FT_TRACE1(( &quot;TT_Load_Composite_Glyph:&quot;
1884                     &quot; infinite recursion detected\n&quot; ));
1885         error = FT_THROW( Invalid_Composite );
1886         goto Exit;
1887       }
1888 
1889       else if ( node )
1890         node-&gt;data = FT_UINT_TO_POINTER( glyph_index );
1891 
1892       else
1893       {
</pre>
<hr />
<pre>
1904       error = face-&gt;read_composite_glyph( loader );
1905       if ( error )
1906         goto Exit;
1907 
1908       /* store the offset of instructions */
1909       ins_pos = loader-&gt;ins_pos;
1910 
1911       /* all data we need are read */
1912       face-&gt;forget_glyph_frame( loader );
1913       opened_frame = 0;
1914 
1915 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1916 
1917       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1918            FT_IS_VARIATION( FT_FACE( face ) )      )
1919       {
1920         short        i, limit;
1921         FT_SubGlyph  subglyph;
1922 
1923         FT_Outline  outline;
<span class="line-modified">1924         FT_Vector*  points    = NULL;</span>
<span class="line-modified">1925         char*       tags      = NULL;</span>
<span class="line-modified">1926         short*      contours  = NULL;</span>
<span class="line-added">1927         FT_Vector*  unrounded = NULL;</span>
1928 
1929 
1930         limit = (short)gloader-&gt;current.num_subglyphs;
1931 
1932         /* construct an outline structure for              */
1933         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39; */
1934         outline.n_points   = (short)( gloader-&gt;current.num_subglyphs + 4 );
1935         outline.n_contours = outline.n_points;
1936 
1937         outline.points   = NULL;
1938         outline.tags     = NULL;
1939         outline.contours = NULL;
1940 
<span class="line-modified">1941         if ( FT_NEW_ARRAY( points, outline.n_points )    ||</span>
<span class="line-modified">1942              FT_NEW_ARRAY( tags, outline.n_points )      ||</span>
<span class="line-modified">1943              FT_NEW_ARRAY( contours, outline.n_points )  ||</span>
<span class="line-added">1944              FT_NEW_ARRAY( unrounded, outline.n_points ) )</span>
1945           goto Exit1;
1946 
1947         subglyph = gloader-&gt;current.subglyphs;
1948 
1949         for ( i = 0; i &lt; limit; i++, subglyph++ )
1950         {
1951           /* applying deltas for anchor points doesn&#39;t make sense, */
1952           /* but we don&#39;t have to specially check this since       */
1953           /* unused delta values are zero anyways                  */
1954           points[i].x = subglyph-&gt;arg1;
1955           points[i].y = subglyph-&gt;arg2;
1956           tags[i]     = 1;
1957           contours[i] = i;
1958         }
1959 
1960         points[i].x = loader-&gt;pp1.x;
1961         points[i].y = loader-&gt;pp1.y;
1962         tags[i]     = 1;
1963         contours[i] = i;
1964 
</pre>
<hr />
<pre>
1973         points[i].y = loader-&gt;pp3.y;
1974         tags[i]     = 1;
1975         contours[i] = i;
1976 
1977         i++;
1978         points[i].x = loader-&gt;pp4.x;
1979         points[i].y = loader-&gt;pp4.y;
1980         tags[i]     = 1;
1981         contours[i] = i;
1982 
1983         outline.points   = points;
1984         outline.tags     = tags;
1985         outline.contours = contours;
1986 
1987         /* this call provides additional offsets */
1988         /* for each component&#39;s translation      */
1989         if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
1990                              face,
1991                              glyph_index,
1992                              &amp;outline,
<span class="line-added">1993                              unrounded,</span>
1994                              (FT_UInt)outline.n_points ) ) )
1995           goto Exit1;
1996 
1997         subglyph = gloader-&gt;current.subglyphs;
1998 
1999         for ( i = 0; i &lt; limit; i++, subglyph++ )
2000         {
2001           if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
2002           {
2003             subglyph-&gt;arg1 = (FT_Int16)points[i].x;
2004             subglyph-&gt;arg2 = (FT_Int16)points[i].y;
2005           }
2006         }
2007 
2008         loader-&gt;pp1.x = points[i + 0].x;
2009         loader-&gt;pp1.y = points[i + 0].y;
2010         loader-&gt;pp2.x = points[i + 1].x;
2011         loader-&gt;pp2.y = points[i + 1].y;
2012 
2013         loader-&gt;pp3.x = points[i + 2].x;
2014         loader-&gt;pp3.y = points[i + 2].y;
2015         loader-&gt;pp4.x = points[i + 3].x;
2016         loader-&gt;pp4.y = points[i + 3].y;
2017 
2018         /* recalculate linear horizontal and vertical advances */
2019         /* if we don&#39;t have HVAR and VVAR, respectively        */
2020         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">2021           loader-&gt;linear =</span>
<span class="line-added">2022             FT_PIX_ROUND( unrounded[outline.n_points - 3].x -</span>
<span class="line-added">2023                           unrounded[outline.n_points - 4].x ) / 64;</span>
2024         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">2025           loader-&gt;vadvance =</span>
<span class="line-added">2026             FT_PIX_ROUND( unrounded[outline.n_points - 1].x -</span>
<span class="line-added">2027                           unrounded[outline.n_points - 2].x ) / 64;</span>
2028 
2029       Exit1:
2030         FT_FREE( outline.points );
2031         FT_FREE( outline.tags );
2032         FT_FREE( outline.contours );
<span class="line-added">2033         FT_FREE( unrounded );</span>
2034 
2035         if ( error )
2036           goto Exit;
2037       }
2038 
2039 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
2040 
2041       /* scale phantom points, if necessary; */
2042       /* they get rounded in `TT_Hint_Glyph&#39; */
2043       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
2044       {
2045         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
2046         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
2047         /* pp1.y and pp2.y are always zero */
2048 
2049         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
2050         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
2051         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
2052         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
2053       }
</pre>
<hr />
<pre>
2073 
2074         FT_UInt      num_points     = start_point;
2075         FT_UInt      num_subglyphs  = gloader-&gt;current.num_subglyphs;
2076         FT_UInt      num_base_subgs = gloader-&gt;base.num_subglyphs;
2077 
2078         FT_Stream    old_stream     = loader-&gt;stream;
2079         FT_Int       old_byte_len   = loader-&gt;byte_len;
2080 
2081 
2082         FT_GlyphLoader_Add( gloader );
2083 
2084         /* read each subglyph independently */
2085         for ( n = 0; n &lt; num_subglyphs; n++ )
2086         {
2087           FT_Vector  pp[4];
2088 
2089           FT_Int  linear_hadvance;
2090           FT_Int  linear_vadvance;
2091 
2092 
<span class="line-modified">2093           /* Each time we call `load_truetype_glyph&#39; in this loop, the */</span>
2094           /* value of `gloader.base.subglyphs&#39; can change due to table */
2095           /* reallocations.  We thus need to recompute the subglyph    */
2096           /* pointer on each iteration.                                */
2097           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2098 
2099           pp[0] = loader-&gt;pp1;
2100           pp[1] = loader-&gt;pp2;
2101           pp[2] = loader-&gt;pp3;
2102           pp[3] = loader-&gt;pp4;
2103 
2104           linear_hadvance = loader-&gt;linear;
2105           linear_vadvance = loader-&gt;vadvance;
2106 
2107           num_base_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2108 
2109           error = load_truetype_glyph( loader,
2110                                        (FT_UInt)subglyph-&gt;index,
2111                                        recurse_count + 1,
2112                                        FALSE );
2113           if ( error )
</pre>
<hr />
<pre>
2116           /* restore subglyph pointer */
2117           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2118 
2119           /* restore phantom points if necessary */
2120           if ( !( subglyph-&gt;flags &amp; USE_MY_METRICS ) )
2121           {
2122             loader-&gt;pp1 = pp[0];
2123             loader-&gt;pp2 = pp[1];
2124             loader-&gt;pp3 = pp[2];
2125             loader-&gt;pp4 = pp[3];
2126 
2127             loader-&gt;linear   = linear_hadvance;
2128             loader-&gt;vadvance = linear_vadvance;
2129           }
2130 
2131           num_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2132 
2133           if ( num_points == num_base_points )
2134             continue;
2135 
<span class="line-modified">2136           /* gloader-&gt;base.outline consists of three parts:           */</span>
<span class="line-modified">2137           /*                                                          */</span>
<span class="line-modified">2138           /* 0 ----&gt; start_point ----&gt; num_base_points ----&gt; n_points */</span>
<span class="line-modified">2139           /*    (1)               (2)                   (3)           */</span>
<span class="line-modified">2140           /*                                                          */</span>
<span class="line-modified">2141           /* (1) points that exist from the beginning                 */</span>
<span class="line-added">2142           /* (2) component points that have been loaded so far        */</span>
<span class="line-added">2143           /* (3) points of the newly loaded component                 */</span>
2144           error = TT_Process_Composite_Component( loader,
2145                                                   subglyph,
2146                                                   start_point,
2147                                                   num_base_points );
2148           if ( error )
2149             goto Exit;
2150         }
2151 
2152         loader-&gt;stream   = old_stream;
2153         loader-&gt;byte_len = old_byte_len;
2154 
2155         /* process the glyph */
2156         loader-&gt;ins_pos = ins_pos;
2157         if ( IS_HINTED( loader-&gt;load_flags ) &amp;&amp;
2158 #ifdef TT_USE_BYTECODE_INTERPRETER
<span class="line-added">2159              subglyph                        &amp;&amp;</span>
2160              subglyph-&gt;flags &amp; WE_HAVE_INSTR &amp;&amp;
2161 #endif
2162              num_points &gt; start_point )
2163         {
2164           error = TT_Process_Composite_Glyph( loader,
2165                                               start_point,
2166                                               start_contour );
2167           if ( error )
2168             goto Exit;
2169         }
2170       }
2171     }
2172 
2173     /***********************************************************************/
2174     /***********************************************************************/
2175     /***********************************************************************/
2176 
2177   Exit:
2178 
2179     if ( opened_frame )
</pre>
<hr />
<pre>
2206     FT_Fixed      y_scale;
2207     TT_GlyphSlot  glyph = loader-&gt;glyph;
2208     TT_Size       size  = loader-&gt;size;
2209 
2210 
2211     y_scale = 0x10000L;
2212     if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
2213       y_scale = size-&gt;metrics-&gt;y_scale;
2214 
2215     if ( glyph-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
2216       FT_Outline_Get_CBox( &amp;glyph-&gt;outline, &amp;bbox );
2217     else
2218       bbox = loader-&gt;bbox;
2219 
2220     /* get the device-independent horizontal advance; it is scaled later */
2221     /* by the base layer.                                                */
2222     glyph-&gt;linearHoriAdvance = loader-&gt;linear;
2223 
2224     glyph-&gt;metrics.horiBearingX = bbox.xMin;
2225     glyph-&gt;metrics.horiBearingY = bbox.yMax;
<span class="line-modified">2226     glyph-&gt;metrics.horiAdvance  = SUB_LONG(loader-&gt;pp2.x, loader-&gt;pp1.x);</span>
2227 
2228     /* Adjust advance width to the value contained in the hdmx table   */
2229     /* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility */
2230     /* mode of the v40 interpreter is active.  See `ttinterp.h&#39; for    */
2231     /* details on backward compatibility mode.                         */
2232     if (
2233 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2234          !( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40  &amp;&amp;
2235             ( loader-&gt;exec &amp;&amp; loader-&gt;exec-&gt;backward_compatibility  ) ) &amp;&amp;
2236 #endif
2237          !face-&gt;postscript.isFixedPitch                                 &amp;&amp;
2238          IS_HINTED( loader-&gt;load_flags )                                &amp;&amp;
2239          !( loader-&gt;load_flags &amp; FT_LOAD_COMPUTE_METRICS )              )
2240     {
2241       FT_Byte*  widthp;
2242 
2243 
2244       widthp = tt_face_get_device_metrics( face,
2245                                            size-&gt;metrics-&gt;x_ppem,
2246                                            glyph_index );
</pre>
<hr />
<pre>
2350           advance = incr_metrics.advance;
2351         }
2352       }
2353 
2354       /* GWW: Do vertical metrics get loaded incrementally too? */
2355 
2356 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
2357 
2358       glyph-&gt;linearVertAdvance = advance;
2359 
2360       /* scale the metrics */
2361       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
2362       {
2363         top     = FT_MulFix( top,     y_scale );
2364         advance = FT_MulFix( advance, y_scale );
2365       }
2366 
2367       /* XXX: for now, we have no better algorithm for the lsb, but it */
2368       /*      should work fine.                                        */
2369       /*                                                               */
<span class="line-modified">2370       glyph-&gt;metrics.vertBearingX = SUB_LONG( glyph-&gt;metrics.horiBearingX,</span>
<span class="line-modified">2371                                               glyph-&gt;metrics.horiAdvance / 2 );</span>
2372       glyph-&gt;metrics.vertBearingY = top;
2373       glyph-&gt;metrics.vertAdvance  = advance;
2374     }
2375 
<span class="line-modified">2376     return FT_Err_Ok;</span>
2377   }
2378 
2379 
2380 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2381 
2382   static FT_Error
2383   load_sbit_image( TT_Size       size,
2384                    TT_GlyphSlot  glyph,
2385                    FT_UInt       glyph_index,
2386                    FT_Int32      load_flags )
2387   {
2388     TT_Face             face;
2389     SFNT_Service        sfnt;
2390     FT_Stream           stream;
2391     FT_Error            error;
2392     TT_SBit_MetricsRec  sbit_metrics;
2393 
2394 
2395     face   = (TT_Face)glyph-&gt;face;
2396     sfnt   = (SFNT_Service)face-&gt;sfnt;
</pre>
<hr />
<pre>
2663             exec-&gt;grayscale_cleartype = grayscale_cleartype;
2664             reexecute                 = TRUE;
2665           }
2666         }
2667 #endif
2668 
2669         /* a change from mono to grayscale rendering (and vice versa) */
2670         /* requires a re-execution of the CVT program                 */
2671         if ( grayscale != exec-&gt;grayscale )
2672         {
2673           FT_TRACE4(( &quot;tt_loader_init: grayscale hinting change,&quot;
2674                       &quot; re-executing `prep&#39; table\n&quot; ));
2675 
2676           exec-&gt;grayscale = grayscale;
2677           reexecute       = TRUE;
2678         }
2679       }
2680 
2681       if ( reexecute )
2682       {





2683         error = tt_size_run_prep( size, pedantic );
2684         if ( error )
2685           return error;
2686       }
2687 
2688       /* check whether the cvt program has disabled hinting */
2689       if ( exec-&gt;GS.instruct_control &amp; 1 )
2690         load_flags |= FT_LOAD_NO_HINTING;
2691 
2692       /* load default graphics state -- if needed */
2693       if ( exec-&gt;GS.instruct_control &amp; 2 )
2694         exec-&gt;GS = tt_default_graphics_state;
2695 
2696 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2697       /* check whether we have a font hinted for ClearType --           */
2698       /* note that this flag can also be modified in a glyph&#39;s bytecode */
2699       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 &amp;&amp;
2700            exec-&gt;GS.instruct_control &amp; 4                            )
2701         exec-&gt;ignore_x_mode = 0;
2702 #endif
</pre>
<hr />
<pre>
2725     loader-&gt;glyph  = (FT_GlyphSlot)glyph;
2726     loader-&gt;stream = stream;
2727 
2728     loader-&gt;composites.head = NULL;
2729     loader-&gt;composites.tail = NULL;
2730 
2731     return FT_Err_Ok;
2732   }
2733 
2734 
2735   static void
2736   tt_loader_done( TT_Loader  loader )
2737   {
2738     FT_List_Finalize( &amp;loader-&gt;composites,
2739                       NULL,
2740                       loader-&gt;face-&gt;root.memory,
2741                       NULL );
2742   }
2743 
2744 
<span class="line-modified">2745   /**************************************************************************</span>
<span class="line-modified">2746    *</span>
<span class="line-modified">2747    * @Function:</span>
<span class="line-modified">2748    *   TT_Load_Glyph</span>
<span class="line-modified">2749    *</span>
<span class="line-modified">2750    * @Description:</span>
<span class="line-modified">2751    *   A function used to load a single glyph within a given glyph slot,</span>
<span class="line-modified">2752    *   for a given size.</span>
<span class="line-modified">2753    *</span>
<span class="line-modified">2754    * @Input:</span>
<span class="line-modified">2755    *   glyph ::</span>
<span class="line-modified">2756    *     A handle to a target slot object where the glyph</span>
<span class="line-modified">2757    *     will be loaded.</span>
<span class="line-modified">2758    *</span>
<span class="line-modified">2759    *   size ::</span>
<span class="line-modified">2760    *     A handle to the source face size at which the glyph</span>
<span class="line-modified">2761    *     must be scaled/loaded.</span>
<span class="line-modified">2762    *</span>
<span class="line-modified">2763    *   glyph_index ::</span>
<span class="line-modified">2764    *     The index of the glyph in the font file.</span>
<span class="line-modified">2765    *</span>
<span class="line-modified">2766    *   load_flags ::</span>
<span class="line-modified">2767    *     A flag indicating what to load for this glyph.  The</span>
<span class="line-modified">2768    *     FT_LOAD_XXX constants can be used to control the</span>
<span class="line-modified">2769    *     glyph loading process (e.g., whether the outline</span>
<span class="line-modified">2770    *     should be scaled, whether to load bitmaps or not,</span>
<span class="line-modified">2771    *     whether to hint the outline, etc).</span>
<span class="line-added">2772    *</span>
<span class="line-added">2773    * @Return:</span>
<span class="line-added">2774    *   FreeType error code.  0 means success.</span>
<span class="line-added">2775    */</span>
2776   FT_LOCAL_DEF( FT_Error )
2777   TT_Load_Glyph( TT_Size       size,
2778                  TT_GlyphSlot  glyph,
2779                  FT_UInt       glyph_index,
2780                  FT_Int32      load_flags )
2781   {
2782     FT_Error      error;
2783     TT_LoaderRec  loader;
2784 







2785 
2786     FT_TRACE1(( &quot;TT_Load_Glyph: glyph index %d\n&quot;, glyph_index ));
2787 
2788 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2789 
2790     /* try to load embedded bitmap (if any) */
2791     if ( size-&gt;strike_index != 0xFFFFFFFFUL      &amp;&amp;
2792          ( load_flags &amp; FT_LOAD_NO_BITMAP ) == 0 &amp;&amp;
<span class="line-modified">2793          IS_DEFAULT_INSTANCE( glyph-&gt;face )      )</span>
2794     {
2795       FT_Fixed  x_scale = size-&gt;root.metrics.x_scale;
2796       FT_Fixed  y_scale = size-&gt;root.metrics.y_scale;
2797 
2798 
2799       error = load_sbit_image( size, glyph, glyph_index, load_flags );
2800       if ( FT_ERR_EQ( error, Missing_Bitmap ) )
2801       {
2802         /* the bitmap strike is incomplete and misses the requested glyph; */
2803         /* if we have a bitmap-only font, return an empty glyph            */
2804         if ( !FT_IS_SCALABLE( glyph-&gt;face ) )
2805         {
2806           TT_Face  face = (TT_Face)glyph-&gt;face;
2807 
2808           FT_Short  left_bearing = 0;
2809           FT_Short  top_bearing  = 0;
2810 
2811           FT_UShort  advance_width  = 0;
2812           FT_UShort  advance_height = 0;
2813 
</pre>
</td>
</tr>
</table>
<center><a href="tterrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgload.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
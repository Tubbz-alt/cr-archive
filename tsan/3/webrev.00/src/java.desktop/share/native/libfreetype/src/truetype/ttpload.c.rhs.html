<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/truetype/ttpload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ttpload.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   TrueType-specific tables loader (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_OBJECTS_H
 22 #include FT_INTERNAL_STREAM_H
 23 #include FT_TRUETYPE_TAGS_H
 24 
 25 #include &quot;ttpload.h&quot;
 26 
 27 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 28 #include &quot;ttgxvar.h&quot;
 29 #endif
 30 
 31 #include &quot;tterrors.h&quot;
 32 
 33 
<a name="2" id="anc2"></a><span class="line-modified"> 34   /**************************************************************************</span>
<span class="line-modified"> 35    *</span>
<span class="line-modified"> 36    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 37    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 38    * messages during execution.</span>
<span class="line-modified"> 39    */</span>
 40 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 41 #define FT_COMPONENT  ttpload</span>
<span class="line-modified"> 42 </span>
<span class="line-modified"> 43 </span>
<span class="line-modified"> 44   /**************************************************************************</span>
<span class="line-modified"> 45    *</span>
<span class="line-modified"> 46    * @Function:</span>
<span class="line-modified"> 47    *   tt_face_load_loca</span>
<span class="line-modified"> 48    *</span>
<span class="line-modified"> 49    * @Description:</span>
<span class="line-modified"> 50    *   Load the locations table.</span>
<span class="line-modified"> 51    *</span>
<span class="line-modified"> 52    * @InOut:</span>
<span class="line-modified"> 53    *   face ::</span>
<span class="line-modified"> 54    *     A handle to the target face object.</span>
<span class="line-modified"> 55    *</span>
<span class="line-modified"> 56    * @Input:</span>
<span class="line-modified"> 57    *   stream ::</span>
<span class="line-modified"> 58    *     The input stream.</span>
<span class="line-modified"> 59    *</span>
<span class="line-modified"> 60    * @Return:</span>
<span class="line-added"> 61    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 62    */</span>
 63   FT_LOCAL_DEF( FT_Error )
 64   tt_face_load_loca( TT_Face    face,
 65                      FT_Stream  stream )
 66   {
 67     FT_Error  error;
 68     FT_ULong  table_len;
 69     FT_Int    shift;
 70 
 71 
 72     /* we need the size of the `glyf&#39; table for malformed `loca&#39; tables */
 73     error = face-&gt;goto_table( face, TTAG_glyf, stream, &amp;face-&gt;glyf_len );
 74 
 75     /* it is possible that a font doesn&#39;t have a glyf table at all */
 76     /* or its size is zero                                         */
 77     if ( FT_ERR_EQ( error, Table_Missing ) )
 78     {
 79       face-&gt;glyf_len    = 0;
 80       face-&gt;glyf_offset = 0;
 81     }
 82     else if ( error )
 83       goto Exit;
 84     else
 85     {
 86 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 87       if ( face-&gt;root.internal-&gt;incremental_interface )
 88         face-&gt;glyf_offset = 0;
 89       else
 90 #endif
 91         face-&gt;glyf_offset = FT_STREAM_POS();
 92     }
 93 
 94     FT_TRACE2(( &quot;Locations &quot; ));
 95     error = face-&gt;goto_table( face, TTAG_loca, stream, &amp;table_len );
 96     if ( error )
 97     {
 98       error = FT_THROW( Locations_Missing );
 99       goto Exit;
100     }
101 
102     if ( face-&gt;header.Index_To_Loc_Format != 0 )
103     {
104       shift = 2;
105 
106       if ( table_len &gt;= 0x40000L )
107       {
108         FT_TRACE2(( &quot;table too large\n&quot; ));
109         table_len = 0x3FFFFL;
110       }
111       face-&gt;num_locations = table_len &gt;&gt; shift;
112     }
113     else
114     {
115       shift = 1;
116 
117       if ( table_len &gt;= 0x20000L )
118       {
119         FT_TRACE2(( &quot;table too large\n&quot; ));
120         table_len = 0x1FFFFL;
121       }
122       face-&gt;num_locations = table_len &gt;&gt; shift;
123     }
124 
125     if ( face-&gt;num_locations != (FT_ULong)face-&gt;root.num_glyphs + 1 )
126     {
127       FT_TRACE2(( &quot;glyph count mismatch!  loca: %d, maxp: %d\n&quot;,
128                   face-&gt;num_locations - 1, face-&gt;root.num_glyphs ));
129 
130       /* we only handle the case where `maxp&#39; gives a larger value */
131       if ( face-&gt;num_locations &lt;= (FT_ULong)face-&gt;root.num_glyphs )
132       {
133         FT_ULong  new_loca_len =
134                     ( (FT_ULong)face-&gt;root.num_glyphs + 1 ) &lt;&lt; shift;
135 
136         TT_Table  entry = face-&gt;dir_tables;
137         TT_Table  limit = entry + face-&gt;num_tables;
138 
139         FT_Long  pos   = (FT_Long)FT_STREAM_POS();
140         FT_Long  dist  = 0x7FFFFFFFL;
141         FT_Bool  found = 0;
142 
143 
144         /* compute the distance to next table in font file */
145         for ( ; entry &lt; limit; entry++ )
146         {
147           FT_Long  diff = (FT_Long)entry-&gt;Offset - pos;
148 
149 
150           if ( diff &gt; 0 &amp;&amp; diff &lt; dist )
151           {
152             dist  = diff;
153             found = 1;
154           }
155         }
156 
157         if ( !found )
158         {
159           /* `loca&#39; is the last table */
160           dist = (FT_Long)stream-&gt;size - pos;
161         }
162 
163         if ( new_loca_len &lt;= (FT_ULong)dist )
164         {
165           face-&gt;num_locations = (FT_ULong)face-&gt;root.num_glyphs + 1;
166           table_len           = new_loca_len;
167 
168           FT_TRACE2(( &quot;adjusting num_locations to %d\n&quot;,
169                       face-&gt;num_locations ));
170         }
171         else
172         {
173           face-&gt;root.num_glyphs = face-&gt;num_locations
174                                     ? (FT_Long)face-&gt;num_locations - 1 : 0;
175 
176           FT_TRACE2(( &quot;adjusting num_glyphs to %d\n&quot;,
177                       face-&gt;root.num_glyphs ));
178         }
179       }
180     }
181 
182     /*
183      * Extract the frame.  We don&#39;t need to decompress it since
184      * we are able to parse it directly.
185      */
186     if ( FT_FRAME_EXTRACT( table_len, face-&gt;glyph_locations ) )
187       goto Exit;
188 
189     FT_TRACE2(( &quot;loaded\n&quot; ));
190 
191   Exit:
192     return error;
193   }
194 
195 
196   FT_LOCAL_DEF( FT_ULong )
197   tt_face_get_location( TT_Face   face,
198                         FT_UInt   gindex,
199                         FT_UInt  *asize )
200   {
201     FT_ULong  pos1, pos2;
202     FT_Byte*  p;
203     FT_Byte*  p_limit;
204 
205 
206     pos1 = pos2 = 0;
207 
208     if ( gindex &lt; face-&gt;num_locations )
209     {
210       if ( face-&gt;header.Index_To_Loc_Format != 0 )
211       {
212         p       = face-&gt;glyph_locations + gindex * 4;
213         p_limit = face-&gt;glyph_locations + face-&gt;num_locations * 4;
214 
215         pos1 = FT_NEXT_ULONG( p );
216         pos2 = pos1;
217 
218         if ( p + 4 &lt;= p_limit )
219           pos2 = FT_NEXT_ULONG( p );
220       }
221       else
222       {
223         p       = face-&gt;glyph_locations + gindex * 2;
224         p_limit = face-&gt;glyph_locations + face-&gt;num_locations * 2;
225 
226         pos1 = FT_NEXT_USHORT( p );
227         pos2 = pos1;
228 
229         if ( p + 2 &lt;= p_limit )
230           pos2 = FT_NEXT_USHORT( p );
231 
232         pos1 &lt;&lt;= 1;
233         pos2 &lt;&lt;= 1;
234       }
235     }
236 
237     /* Check broken location data. */
238     if ( pos1 &gt; face-&gt;glyf_len )
239     {
240       FT_TRACE1(( &quot;tt_face_get_location:&quot;
241                   &quot; too large offset (0x%08lx) found for glyph index %ld,\n&quot;
242                   &quot;                     &quot;
243                   &quot; exceeding the end of `glyf&#39; table (0x%08lx)\n&quot;,
244                   pos1, gindex, face-&gt;glyf_len ));
245       *asize = 0;
246       return 0;
247     }
248 
249     if ( pos2 &gt; face-&gt;glyf_len )
250     {
251       /* We try to sanitize the last `loca&#39; entry. */
252       if ( gindex == face-&gt;num_locations - 2 )
253       {
254         FT_TRACE1(( &quot;tt_face_get_location:&quot;
255                     &quot; too large size (%ld bytes) found for glyph index %ld,\n&quot;
256                     &quot;                     &quot;
257                     &quot; truncating at the end of `glyf&#39; table to %ld bytes\n&quot;,
258                     pos2 - pos1, gindex, face-&gt;glyf_len - pos1 ));
259         pos2 = face-&gt;glyf_len;
260       }
261       else
262       {
263         FT_TRACE1(( &quot;tt_face_get_location:&quot;
264                     &quot; too large offset (0x%08lx) found for glyph index %ld,\n&quot;
265                     &quot;                     &quot;
266                     &quot; exceeding the end of `glyf&#39; table (0x%08lx)\n&quot;,
267                     pos2, gindex + 1, face-&gt;glyf_len ));
268         *asize = 0;
269         return 0;
270       }
271     }
272 
273     /* The `loca&#39; table must be ordered; it refers to the length of */
274     /* an entry as the difference between the current and the next  */
275     /* position.  However, there do exist (malformed) fonts which   */
276     /* don&#39;t obey this rule, so we are only able to provide an      */
277     /* upper bound for the size.                                    */
278     /*                                                              */
279     /* We get (intentionally) a wrong, non-zero result in case the  */
280     /* `glyf&#39; table is missing.                                     */
281     if ( pos2 &gt;= pos1 )
282       *asize = (FT_UInt)( pos2 - pos1 );
283     else
284       *asize = (FT_UInt)( face-&gt;glyf_len - pos1 );
285 
286     return pos1;
287   }
288 
289 
290   FT_LOCAL_DEF( void )
291   tt_face_done_loca( TT_Face  face )
292   {
293     FT_Stream  stream = face-&gt;root.stream;
294 
295 
296     FT_FRAME_RELEASE( face-&gt;glyph_locations );
297     face-&gt;num_locations = 0;
298   }
299 
300 
301 
<a name="4" id="anc4"></a><span class="line-modified">302   /**************************************************************************</span>
<span class="line-modified">303    *</span>
<span class="line-modified">304    * @Function:</span>
<span class="line-modified">305    *   tt_face_load_cvt</span>
<span class="line-modified">306    *</span>
<span class="line-modified">307    * @Description:</span>
<span class="line-modified">308    *   Load the control value table into a face object.</span>
<span class="line-modified">309    *</span>
<span class="line-modified">310    * @InOut:</span>
<span class="line-modified">311    *   face ::</span>
<span class="line-modified">312    *     A handle to the target face object.</span>
<span class="line-modified">313    *</span>
<span class="line-modified">314    * @Input:</span>
<span class="line-modified">315    *   stream ::</span>
<span class="line-modified">316    *     A handle to the input stream.</span>
<span class="line-modified">317    *</span>
<span class="line-modified">318    * @Return:</span>
<span class="line-added">319    *   FreeType error code.  0 means success.</span>
<span class="line-added">320    */</span>
321   FT_LOCAL_DEF( FT_Error )
322   tt_face_load_cvt( TT_Face    face,
323                     FT_Stream  stream )
324   {
325 #ifdef TT_USE_BYTECODE_INTERPRETER
326 
327     FT_Error   error;
328     FT_Memory  memory = stream-&gt;memory;
329     FT_ULong   table_len;
330 
331 
332     FT_TRACE2(( &quot;CVT &quot; ));
333 
334     error = face-&gt;goto_table( face, TTAG_cvt, stream, &amp;table_len );
335     if ( error )
336     {
337       FT_TRACE2(( &quot;is missing\n&quot; ));
338 
339       face-&gt;cvt_size = 0;
340       face-&gt;cvt      = NULL;
341       error          = FT_Err_Ok;
342 
343       goto Exit;
344     }
345 
346     face-&gt;cvt_size = table_len / 2;
347 
348     if ( FT_NEW_ARRAY( face-&gt;cvt, face-&gt;cvt_size ) )
349       goto Exit;
350 
351     if ( FT_FRAME_ENTER( face-&gt;cvt_size * 2L ) )
352       goto Exit;
353 
354     {
<a name="5" id="anc5"></a><span class="line-modified">355       FT_Int32*  cur   = face-&gt;cvt;</span>
<span class="line-modified">356       FT_Int32*  limit = cur + face-&gt;cvt_size;</span>
357 
358 
359       for ( ; cur &lt; limit; cur++ )
<a name="6" id="anc6"></a><span class="line-modified">360         *cur = FT_GET_SHORT() * 64;</span>
361     }
362 
363     FT_FRAME_EXIT();
364     FT_TRACE2(( &quot;loaded\n&quot; ));
365 
366 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
367     if ( face-&gt;doblend )
368       error = tt_face_vary_cvt( face, stream );
369 #endif
370 
371   Exit:
372     return error;
373 
374 #else /* !TT_USE_BYTECODE_INTERPRETER */
375 
376     FT_UNUSED( face   );
377     FT_UNUSED( stream );
378 
379     return FT_Err_Ok;
380 
381 #endif
382   }
383 
384 
<a name="7" id="anc7"></a><span class="line-modified">385   /**************************************************************************</span>
<span class="line-modified">386    *</span>
<span class="line-modified">387    * @Function:</span>
<span class="line-modified">388    *   tt_face_load_fpgm</span>
<span class="line-modified">389    *</span>
<span class="line-modified">390    * @Description:</span>
<span class="line-modified">391    *   Load the font program.</span>
<span class="line-modified">392    *</span>
<span class="line-modified">393    * @InOut:</span>
<span class="line-modified">394    *   face ::</span>
<span class="line-modified">395    *     A handle to the target face object.</span>
<span class="line-modified">396    *</span>
<span class="line-modified">397    * @Input:</span>
<span class="line-modified">398    *   stream ::</span>
<span class="line-modified">399    *     A handle to the input stream.</span>
<span class="line-modified">400    *</span>
<span class="line-modified">401    * @Return:</span>
<span class="line-added">402    *   FreeType error code.  0 means success.</span>
<span class="line-added">403    */</span>
404   FT_LOCAL_DEF( FT_Error )
405   tt_face_load_fpgm( TT_Face    face,
406                      FT_Stream  stream )
407   {
408 #ifdef TT_USE_BYTECODE_INTERPRETER
409 
410     FT_Error  error;
411     FT_ULong  table_len;
412 
413 
414     FT_TRACE2(( &quot;Font program &quot; ));
415 
416     /* The font program is optional */
417     error = face-&gt;goto_table( face, TTAG_fpgm, stream, &amp;table_len );
418     if ( error )
419     {
420       face-&gt;font_program      = NULL;
421       face-&gt;font_program_size = 0;
422       error                   = FT_Err_Ok;
423 
424       FT_TRACE2(( &quot;is missing\n&quot; ));
425     }
426     else
427     {
428       face-&gt;font_program_size = table_len;
429       if ( FT_FRAME_EXTRACT( table_len, face-&gt;font_program ) )
430         goto Exit;
431 
432       FT_TRACE2(( &quot;loaded, %12d bytes\n&quot;, face-&gt;font_program_size ));
433     }
434 
435   Exit:
436     return error;
437 
438 #else /* !TT_USE_BYTECODE_INTERPRETER */
439 
440     FT_UNUSED( face   );
441     FT_UNUSED( stream );
442 
443     return FT_Err_Ok;
444 
445 #endif
446   }
447 
448 
<a name="8" id="anc8"></a><span class="line-modified">449   /**************************************************************************</span>
<span class="line-modified">450    *</span>
<span class="line-modified">451    * @Function:</span>
<span class="line-modified">452    *   tt_face_load_prep</span>
<span class="line-modified">453    *</span>
<span class="line-modified">454    * @Description:</span>
<span class="line-modified">455    *   Load the cvt program.</span>
<span class="line-modified">456    *</span>
<span class="line-modified">457    * @InOut:</span>
<span class="line-modified">458    *   face ::</span>
<span class="line-modified">459    *     A handle to the target face object.</span>
<span class="line-modified">460    *</span>
<span class="line-modified">461    * @Input:</span>
<span class="line-modified">462    *   stream ::</span>
<span class="line-modified">463    *     A handle to the input stream.</span>
<span class="line-modified">464    *</span>
<span class="line-modified">465    * @Return:</span>
<span class="line-added">466    *   FreeType error code.  0 means success.</span>
<span class="line-added">467    */</span>
468   FT_LOCAL_DEF( FT_Error )
469   tt_face_load_prep( TT_Face    face,
470                      FT_Stream  stream )
471   {
472 #ifdef TT_USE_BYTECODE_INTERPRETER
473 
474     FT_Error  error;
475     FT_ULong  table_len;
476 
477 
478     FT_TRACE2(( &quot;Prep program &quot; ));
479 
480     error = face-&gt;goto_table( face, TTAG_prep, stream, &amp;table_len );
481     if ( error )
482     {
483       face-&gt;cvt_program      = NULL;
484       face-&gt;cvt_program_size = 0;
485       error                  = FT_Err_Ok;
486 
487       FT_TRACE2(( &quot;is missing\n&quot; ));
488     }
489     else
490     {
491       face-&gt;cvt_program_size = table_len;
492       if ( FT_FRAME_EXTRACT( table_len, face-&gt;cvt_program ) )
493         goto Exit;
494 
495       FT_TRACE2(( &quot;loaded, %12d bytes\n&quot;, face-&gt;cvt_program_size ));
496     }
497 
498   Exit:
499     return error;
500 
501 #else /* !TT_USE_BYTECODE_INTERPRETER */
502 
503     FT_UNUSED( face   );
504     FT_UNUSED( stream );
505 
506     return FT_Err_Ok;
507 
508 #endif
509   }
510 
511 
<a name="9" id="anc9"></a><span class="line-modified">512   /**************************************************************************</span>
<span class="line-modified">513    *</span>
<span class="line-modified">514    * @Function:</span>
<span class="line-modified">515    *   tt_face_load_hdmx</span>
<span class="line-modified">516    *</span>
<span class="line-modified">517    * @Description:</span>
<span class="line-modified">518    *   Load the `hdmx&#39; table into the face object.</span>
<span class="line-modified">519    *</span>
<span class="line-modified">520    * @Input:</span>
<span class="line-modified">521    *   face ::</span>
<span class="line-modified">522    *     A handle to the target face object.</span>
<span class="line-modified">523    *</span>
<span class="line-modified">524    *   stream ::</span>
<span class="line-modified">525    *     A handle to the input stream.</span>
<span class="line-modified">526    *</span>
<span class="line-modified">527    * @Return:</span>
<span class="line-added">528    *   FreeType error code.  0 means success.</span>
<span class="line-added">529    */</span>
530 
531   FT_LOCAL_DEF( FT_Error )
532   tt_face_load_hdmx( TT_Face    face,
533                      FT_Stream  stream )
534   {
535     FT_Error   error;
536     FT_Memory  memory = stream-&gt;memory;
537     FT_UInt    nn, num_records;
538     FT_ULong   table_size, record_size;
539     FT_Byte*   p;
540     FT_Byte*   limit;
541 
542 
543     /* this table is optional */
544     error = face-&gt;goto_table( face, TTAG_hdmx, stream, &amp;table_size );
545     if ( error || table_size &lt; 8 )
546       return FT_Err_Ok;
547 
548     if ( FT_FRAME_EXTRACT( table_size, face-&gt;hdmx_table ) )
549       goto Exit;
550 
551     p     = face-&gt;hdmx_table;
552     limit = p + table_size;
553 
554     /* Given that `hdmx&#39; tables are losing its importance (for example, */
555     /* variation fonts introduced in OpenType 1.8 must not have this    */
556     /* table) we no longer test for a correct `version&#39; field.          */
557     p          += 2;
558     num_records = FT_NEXT_USHORT( p );
559     record_size = FT_NEXT_ULONG( p );
560 
561     /* The maximum number of bytes in an hdmx device record is the */
562     /* maximum number of glyphs + 2; this is 0xFFFF + 2, thus      */
563     /* explaining why `record_size&#39; is a long (which we read as    */
564     /* unsigned long for convenience).  In practice, two bytes are */
565     /* sufficient to hold the size value.                          */
566     /*                                                             */
567     /* There are at least two fonts, HANNOM-A and HANNOM-B version */
568     /* 2.0 (2005), which get this wrong: The upper two bytes of    */
569     /* the size value are set to 0xFF instead of 0x00.  We catch   */
570     /* and fix this.                                               */
571 
572     if ( record_size &gt;= 0xFFFF0000UL )
573       record_size &amp;= 0xFFFFU;
574 
575     /* The limit for `num_records&#39; is a heuristic value. */
576     if ( num_records &gt; 255              ||
577          ( num_records &gt; 0            &amp;&amp;
578            ( record_size &gt; 0x10001L ||
579              record_size &lt; 4        ) ) )
580     {
581       error = FT_THROW( Invalid_File_Format );
582       goto Fail;
583     }
584 
585     if ( FT_NEW_ARRAY( face-&gt;hdmx_record_sizes, num_records ) )
586       goto Fail;
587 
588     for ( nn = 0; nn &lt; num_records; nn++ )
589     {
590       if ( p + record_size &gt; limit )
591         break;
592 
593       face-&gt;hdmx_record_sizes[nn] = p[0];
594       p                          += record_size;
595     }
596 
597     face-&gt;hdmx_record_count = nn;
598     face-&gt;hdmx_table_size   = table_size;
599     face-&gt;hdmx_record_size  = record_size;
600 
601   Exit:
602     return error;
603 
604   Fail:
605     FT_FRAME_RELEASE( face-&gt;hdmx_table );
606     face-&gt;hdmx_table_size = 0;
607     goto Exit;
608   }
609 
610 
611   FT_LOCAL_DEF( void )
612   tt_face_free_hdmx( TT_Face  face )
613   {
614     FT_Stream  stream = face-&gt;root.stream;
615     FT_Memory  memory = stream-&gt;memory;
616 
617 
618     FT_FREE( face-&gt;hdmx_record_sizes );
619     FT_FRAME_RELEASE( face-&gt;hdmx_table );
620   }
621 
622 
<a name="10" id="anc10"></a><span class="line-modified">623   /**************************************************************************</span>
<span class="line-modified">624    *</span>
<span class="line-modified">625    * Return the advance width table for a given pixel size if it is found</span>
<span class="line-modified">626    * in the font&#39;s `hdmx&#39; table (if any).</span>
<span class="line-modified">627    */</span>
628   FT_LOCAL_DEF( FT_Byte* )
629   tt_face_get_device_metrics( TT_Face  face,
630                               FT_UInt  ppem,
631                               FT_UInt  gindex )
632   {
633     FT_UInt   nn;
634     FT_Byte*  result      = NULL;
635     FT_ULong  record_size = face-&gt;hdmx_record_size;
636     FT_Byte*  record      = face-&gt;hdmx_table + 8;
637 
638 
639     for ( nn = 0; nn &lt; face-&gt;hdmx_record_count; nn++ )
640       if ( face-&gt;hdmx_record_sizes[nn] == ppem )
641       {
642         gindex += 2;
643         if ( gindex &lt; record_size )
644           result = record + nn * record_size + gindex;
645         break;
646       }
647 
648     return result;
649   }
650 
651 
652 /* END */
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/psaux/psft.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  psft.c                                                                 */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    FreeType Glue Component to Adobe&#39;s Interpreter (body).               */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2013-2014 Adobe Systems Incorporated.                        */</span>
<span class="line-modified">  8 /*                                                                         */</span>
<span class="line-modified">  9 /*  This software, and all works of authorship, whether in source or       */</span>
<span class="line-modified"> 10 /*  object code form as indicated by the copyright notice(s) included      */</span>
<span class="line-modified"> 11 /*  herein (collectively, the &quot;Work&quot;) is made available, and may only be   */</span>
<span class="line-modified"> 12 /*  used, modified, and distributed under the FreeType Project License,    */</span>
<span class="line-modified"> 13 /*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */</span>
<span class="line-modified"> 14 /*  FreeType Project License, each contributor to the Work hereby grants   */</span>
<span class="line-modified"> 15 /*  to any individual or legal entity exercising permissions granted by    */</span>
<span class="line-modified"> 16 /*  the FreeType Project License and this section (hereafter, &quot;You&quot; or     */</span>
<span class="line-modified"> 17 /*  &quot;Your&quot;) a perpetual, worldwide, non-exclusive, no-charge,              */</span>
<span class="line-modified"> 18 /*  royalty-free, irrevocable (except as stated in this section) patent    */</span>
<span class="line-modified"> 19 /*  license to make, have made, use, offer to sell, sell, import, and      */</span>
<span class="line-modified"> 20 /*  otherwise transfer the Work, where such license applies only to those  */</span>
<span class="line-modified"> 21 /*  patent claims licensable by such contributor that are necessarily      */</span>
<span class="line-modified"> 22 /*  infringed by their contribution(s) alone or by combination of their    */</span>
<span class="line-modified"> 23 /*  contribution(s) with the Work to which such contribution(s) was        */</span>
<span class="line-modified"> 24 /*  submitted.  If You institute patent litigation against any entity      */</span>
<span class="line-modified"> 25 /*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */</span>
<span class="line-modified"> 26 /*  the Work or a contribution incorporated within the Work constitutes    */</span>
<span class="line-modified"> 27 /*  direct or contributory patent infringement, then any patent licenses   */</span>
<span class="line-modified"> 28 /*  granted to You under this License for that Work shall terminate as of  */</span>
<span class="line-modified"> 29 /*  the date such litigation is filed.                                     */</span>
<span class="line-modified"> 30 /*                                                                         */</span>
<span class="line-modified"> 31 /*  By using, modifying, or distributing the Work you indicate that you    */</span>
<span class="line-modified"> 32 /*  have read and understood the terms and conditions of the               */</span>
<span class="line-modified"> 33 /*  FreeType Project License as well as those provided in this section,    */</span>
<span class="line-modified"> 34 /*  and you accept them fully.                                             */</span>
<span class="line-modified"> 35 /*                                                                         */</span>
<span class="line-modified"> 36 /***************************************************************************/</span>
 37 
 38 
 39 #include &quot;psft.h&quot;
 40 #include FT_INTERNAL_DEBUG_H
 41 
 42 #include &quot;psfont.h&quot;
 43 #include &quot;pserror.h&quot;
 44 #include &quot;psobjs.h&quot;
 45 #include &quot;cffdecode.h&quot;
 46 
 47 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 48 #include FT_MULTIPLE_MASTERS_H
 49 #include FT_SERVICE_MULTIPLE_MASTERS_H
 50 #endif
 51 
 52 #include FT_SERVICE_CFF_TABLE_LOAD_H
 53 
 54 
 55 #define CF2_MAX_SIZE  cf2_intToFixed( 2000 )    /* max ppem */
 56 
 57 
 58   /*
 59    * This check should avoid most internal overflow cases.  Clients should
 60    * generally respond to `Glyph_Too_Big&#39; by getting a glyph outline
 61    * at EM size, scaling it and filling it as a graphics operation.
 62    *
 63    */
 64   static FT_Error
 65   cf2_checkTransform( const CF2_Matrix*  transform,
 66                       CF2_Int            unitsPerEm )
 67   {
 68     CF2_Fixed  maxScale;
 69 
 70 
 71     FT_ASSERT( unitsPerEm &gt; 0 );
 72 
 73     if ( transform-&gt;a &lt;= 0 || transform-&gt;d &lt;= 0 )
 74       return FT_THROW( Invalid_Size_Handle );
 75 
 76     FT_ASSERT( transform-&gt;b == 0 &amp;&amp; transform-&gt;c == 0 );
 77     FT_ASSERT( transform-&gt;tx == 0 &amp;&amp; transform-&gt;ty == 0 );
 78 
 79     if ( unitsPerEm &gt; 0x7FFF )
 80       return FT_THROW( Glyph_Too_Big );
 81 
 82     maxScale = FT_DivFix( CF2_MAX_SIZE, cf2_intToFixed( unitsPerEm ) );
 83 
 84     if ( transform-&gt;a &gt; maxScale || transform-&gt;d &gt; maxScale )
 85       return FT_THROW( Glyph_Too_Big );
 86 
 87     return FT_Err_Ok;
 88   }
 89 
 90 
 91   static void
 92   cf2_setGlyphWidth( CF2_Outline  outline,
 93                      CF2_Fixed    width )
 94   {
 95     PS_Decoder*  decoder = outline-&gt;decoder;
 96 
 97 
 98     FT_ASSERT( decoder );
 99 
100     if ( !decoder-&gt;builder.is_t1 )
101       *decoder-&gt;glyph_width = cf2_fixedToInt( width );
102   }
103 
104 
105   /* Clean up font instance. */
106   static void
107   cf2_free_instance( void*  ptr )
108   {
109     CF2_Font  font = (CF2_Font)ptr;
110 
111 
112     if ( font )
113     {
114       FT_Memory  memory = font-&gt;memory;
115 
116 
117       FT_FREE( font-&gt;blend.lastNDV );
118       FT_FREE( font-&gt;blend.BV );
119     }
120   }
121 
122 
<a name="2" id="anc2"></a><span class="line-modified">123   /********************************************/</span>
<span class="line-modified">124   /*                                          */</span>
<span class="line-modified">125   /* functions for handling client outline;   */</span>
<span class="line-modified">126   /* FreeType uses coordinates in 26.6 format */</span>
<span class="line-modified">127   /*                                          */</span>
<span class="line-modified">128   /********************************************/</span>
129 
130   static void
131   cf2_builder_moveTo( CF2_OutlineCallbacks      callbacks,
132                       const CF2_CallbackParams  params )
133   {
134     /* downcast the object pointer */
135     CF2_Outline  outline = (CF2_Outline)callbacks;
136     PS_Builder*  builder;
137 
138     (void)params;        /* only used in debug mode */
139 
140 
141     FT_ASSERT( outline &amp;&amp; outline-&gt;decoder );
142     FT_ASSERT( params-&gt;op == CF2_PathOpMoveTo );
143 
144     builder = &amp;outline-&gt;decoder-&gt;builder;
145 
146     /* note: two successive moves simply close the contour twice */
147     ps_builder_close_contour( builder );
148     builder-&gt;path_begun = 0;
149   }
150 
151 
152   static void
153   cf2_builder_lineTo( CF2_OutlineCallbacks      callbacks,
154                       const CF2_CallbackParams  params )
155   {
156     FT_Error  error;
157 
158     /* downcast the object pointer */
159     CF2_Outline  outline = (CF2_Outline)callbacks;
160     PS_Builder*  builder;
161 
162 
163     FT_ASSERT( outline &amp;&amp; outline-&gt;decoder );
164     FT_ASSERT( params-&gt;op == CF2_PathOpLineTo );
165 
166     builder = &amp;outline-&gt;decoder-&gt;builder;
167 
168     if ( !builder-&gt;path_begun )
169     {
170       /* record the move before the line; also check points and set */
171       /* `path_begun&#39;                                               */
172       error = ps_builder_start_point( builder,
173                                       params-&gt;pt0.x,
174                                       params-&gt;pt0.y );
175       if ( error )
176       {
177         if ( !*callbacks-&gt;error )
178           *callbacks-&gt;error =  error;
179         return;
180       }
181     }
182 
183     /* `ps_builder_add_point1&#39; includes a check_points call for one point */
184     error = ps_builder_add_point1( builder,
185                                    params-&gt;pt1.x,
186                                    params-&gt;pt1.y );
187     if ( error )
188     {
189       if ( !*callbacks-&gt;error )
190         *callbacks-&gt;error =  error;
191       return;
192     }
193   }
194 
195 
196   static void
197   cf2_builder_cubeTo( CF2_OutlineCallbacks      callbacks,
198                       const CF2_CallbackParams  params )
199   {
200     FT_Error  error;
201 
202     /* downcast the object pointer */
203     CF2_Outline  outline = (CF2_Outline)callbacks;
204     PS_Builder*  builder;
205 
206 
207     FT_ASSERT( outline &amp;&amp; outline-&gt;decoder );
208     FT_ASSERT( params-&gt;op == CF2_PathOpCubeTo );
209 
210     builder = &amp;outline-&gt;decoder-&gt;builder;
211 
212     if ( !builder-&gt;path_begun )
213     {
214       /* record the move before the line; also check points and set */
215       /* `path_begun&#39;                                               */
216       error = ps_builder_start_point( builder,
217                                       params-&gt;pt0.x,
218                                       params-&gt;pt0.y );
219       if ( error )
220       {
221         if ( !*callbacks-&gt;error )
222           *callbacks-&gt;error =  error;
223         return;
224       }
225     }
226 
227     /* prepare room for 3 points: 2 off-curve, 1 on-curve */
228     error = ps_builder_check_points( builder, 3 );
229     if ( error )
230     {
231       if ( !*callbacks-&gt;error )
232         *callbacks-&gt;error =  error;
233       return;
234     }
235 
236     ps_builder_add_point( builder,
237                           params-&gt;pt1.x,
238                           params-&gt;pt1.y, 0 );
239     ps_builder_add_point( builder,
240                           params-&gt;pt2.x,
241                           params-&gt;pt2.y, 0 );
242     ps_builder_add_point( builder,
243                           params-&gt;pt3.x,
244                           params-&gt;pt3.y, 1 );
245   }
246 
247 
248   static void
249   cf2_outline_init( CF2_Outline  outline,
250                     FT_Memory    memory,
251                     FT_Error*    error )
252   {
253     FT_ZERO( outline );
254 
255     outline-&gt;root.memory = memory;
256     outline-&gt;root.error  = error;
257 
258     outline-&gt;root.moveTo = cf2_builder_moveTo;
259     outline-&gt;root.lineTo = cf2_builder_lineTo;
260     outline-&gt;root.cubeTo = cf2_builder_cubeTo;
261   }
262 
263 
264   /* get scaling and hint flag from GlyphSlot */
265   static void
266   cf2_getScaleAndHintFlag( PS_Decoder*  decoder,
267                            CF2_Fixed*   x_scale,
268                            CF2_Fixed*   y_scale,
269                            FT_Bool*     hinted,
270                            FT_Bool*     scaled )
271   {
272     FT_ASSERT( decoder &amp;&amp; decoder-&gt;builder.glyph );
273 
274     /* note: FreeType scale includes a factor of 64 */
275     *hinted = decoder-&gt;builder.glyph-&gt;hint;
276     *scaled = decoder-&gt;builder.glyph-&gt;scaled;
277 
278     if ( *hinted )
279     {
280       *x_scale = ADD_INT32( decoder-&gt;builder.glyph-&gt;x_scale, 32 ) / 64;
281       *y_scale = ADD_INT32( decoder-&gt;builder.glyph-&gt;y_scale, 32 ) / 64;
282     }
283     else
284     {
285       /* for unhinted outlines, `cff_slot_load&#39; does the scaling, */
286       /* thus render at `unity&#39; scale                             */
287 
288       *x_scale = 0x0400;   /* 1/64 as 16.16 */
289       *y_scale = 0x0400;
290     }
291   }
292 
293 
294   /* get units per em from `FT_Face&#39; */
295   /* TODO: should handle font matrix concatenation? */
296   static FT_UShort
297   cf2_getUnitsPerEm( PS_Decoder*  decoder )
298   {
299     FT_ASSERT( decoder &amp;&amp; decoder-&gt;builder.face );
300     FT_ASSERT( decoder-&gt;builder.face-&gt;units_per_EM );
301 
302     return decoder-&gt;builder.face-&gt;units_per_EM;
303   }
304 
305 
306   /* Main entry point: Render one glyph. */
307   FT_LOCAL_DEF( FT_Error )
308   cf2_decoder_parse_charstrings( PS_Decoder*  decoder,
309                                  FT_Byte*     charstring_base,
310                                  FT_ULong     charstring_len )
311   {
312     FT_Memory  memory;
313     FT_Error   error = FT_Err_Ok;
314     CF2_Font   font;
315 
316     FT_Bool    is_t1 = decoder-&gt;builder.is_t1;
317 
318 
319     FT_ASSERT( decoder &amp;&amp;
320                ( is_t1 || decoder-&gt;cff ) );
321 
322     if ( is_t1 &amp;&amp; !decoder-&gt;current_subfont )
323     {
324       FT_ERROR(( &quot;cf2_decoder_parse_charstrings (Type 1): &quot;
325                  &quot;SubFont missing. Use `t1_make_subfont&#39; first\n&quot; ));
326       return FT_THROW( Invalid_Table );
327     }
328 
329     memory = decoder-&gt;builder.memory;
330 
331     /* CF2 data is saved here across glyphs */
332     font = (CF2_Font)decoder-&gt;cf2_instance-&gt;data;
333 
334     /* on first glyph, allocate instance structure */
335     if ( !decoder-&gt;cf2_instance-&gt;data )
336     {
337       decoder-&gt;cf2_instance-&gt;finalizer =
338         (FT_Generic_Finalizer)cf2_free_instance;
339 
340       if ( FT_ALLOC( decoder-&gt;cf2_instance-&gt;data,
341                      sizeof ( CF2_FontRec ) ) )
342         return FT_THROW( Out_Of_Memory );
343 
344       font = (CF2_Font)decoder-&gt;cf2_instance-&gt;data;
345 
346       font-&gt;memory = memory;
347 
348       if ( !is_t1 )
349         font-&gt;cffload = (FT_Service_CFFLoad)decoder-&gt;cff-&gt;cffload;
350 
351       /* initialize a client outline, to be shared by each glyph rendered */
352       cf2_outline_init( &amp;font-&gt;outline, font-&gt;memory, &amp;font-&gt;error );
353     }
354 
355     /* save decoder; it is a stack variable and will be different on each */
356     /* call                                                               */
357     font-&gt;decoder         = decoder;
358     font-&gt;outline.decoder = decoder;
359 
360     {
361       /* build parameters for Adobe engine */
362 
363       PS_Builder*  builder = &amp;decoder-&gt;builder;
364       PS_Driver    driver  = (PS_Driver)FT_FACE_DRIVER( builder-&gt;face );
365 
366       FT_Bool  no_stem_darkening_driver =
367                  driver-&gt;no_stem_darkening;
368       FT_Char  no_stem_darkening_font =
369                  builder-&gt;face-&gt;internal-&gt;no_stem_darkening;
370 
371       /* local error */
372       FT_Error       error2 = FT_Err_Ok;
373       CF2_BufferRec  buf;
374       CF2_Matrix     transform;
375       CF2_F16Dot16   glyphWidth;
376 
377       FT_Bool  hinted;
378       FT_Bool  scaled;
379 
380 
381       /* FreeType has already looked up the GID; convert to         */
382       /* `RegionBuffer&#39;, assuming that the input has been validated */
383       FT_ASSERT( charstring_base + charstring_len &gt;= charstring_base );
384 
385       FT_ZERO( &amp;buf );
386       buf.start =
387       buf.ptr   = charstring_base;
388       buf.end   = charstring_base + charstring_len;
389 
390       FT_ZERO( &amp;transform );
391 
392       cf2_getScaleAndHintFlag( decoder,
393                                &amp;transform.a,
394                                &amp;transform.d,
395                                &amp;hinted,
396                                &amp;scaled );
397 
398       if ( is_t1 )
399         font-&gt;isCFF2 = FALSE;
400       else
401       {
402         /* copy isCFF2 boolean from TT_Face to CF2_Font */
403         font-&gt;isCFF2 = ((TT_Face)builder-&gt;face)-&gt;is_cff2;
404       }
405       font-&gt;isT1 = is_t1;
406 
407       font-&gt;renderingFlags = 0;
408       if ( hinted )
409         font-&gt;renderingFlags |= CF2_FlagsHinted;
410       if ( scaled &amp;&amp; ( !no_stem_darkening_font        ||
411                        ( no_stem_darkening_font &lt; 0 &amp;&amp;
412                          !no_stem_darkening_driver  ) ) )
413         font-&gt;renderingFlags |= CF2_FlagsDarkened;
414 
415       font-&gt;darkenParams[0] = driver-&gt;darken_params[0];
416       font-&gt;darkenParams[1] = driver-&gt;darken_params[1];
417       font-&gt;darkenParams[2] = driver-&gt;darken_params[2];
418       font-&gt;darkenParams[3] = driver-&gt;darken_params[3];
419       font-&gt;darkenParams[4] = driver-&gt;darken_params[4];
420       font-&gt;darkenParams[5] = driver-&gt;darken_params[5];
421       font-&gt;darkenParams[6] = driver-&gt;darken_params[6];
422       font-&gt;darkenParams[7] = driver-&gt;darken_params[7];
423 
424       /* now get an outline for this glyph;      */
425       /* also get units per em to validate scale */
426       font-&gt;unitsPerEm = (CF2_Int)cf2_getUnitsPerEm( decoder );
427 
428       if ( scaled )
429       {
430         error2 = cf2_checkTransform( &amp;transform, font-&gt;unitsPerEm );
431         if ( error2 )
432           return error2;
433       }
434 
435       error2 = cf2_getGlyphOutline( font, &amp;buf, &amp;transform, &amp;glyphWidth );
436       if ( error2 )
437         return FT_ERR( Invalid_File_Format );
438 
439       cf2_setGlyphWidth( &amp;font-&gt;outline, glyphWidth );
440 
441       return FT_Err_Ok;
442     }
443   }
444 
445 
446   /* get pointer to current FreeType subfont (based on current glyphID) */
447   FT_LOCAL_DEF( CFF_SubFont )
448   cf2_getSubfont( PS_Decoder*  decoder )
449   {
450     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
451 
452     return decoder-&gt;current_subfont;
453   }
454 
455 
456   /* get pointer to VStore structure */
457   FT_LOCAL_DEF( CFF_VStore )
458   cf2_getVStore( PS_Decoder*  decoder )
459   {
460     FT_ASSERT( decoder &amp;&amp; decoder-&gt;cff );
461 
462     return &amp;decoder-&gt;cff-&gt;vstore;
463   }
464 
465 
466   /* get maxstack value from CFF2 Top DICT */
467   FT_LOCAL_DEF( FT_UInt )
468   cf2_getMaxstack( PS_Decoder*  decoder )
469   {
470     FT_ASSERT( decoder &amp;&amp; decoder-&gt;cff );
471 
472     return decoder-&gt;cff-&gt;top_font.font_dict.maxstack;
473   }
474 
475 
476 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
477   /* Get normalized design vector for current render request; */
478   /* return pointer and length.                               */
479   /*                                                          */
480   /* Note: Uses FT_Fixed not CF2_Fixed for the vector.        */
481   FT_LOCAL_DEF( FT_Error )
482   cf2_getNormalizedVector( PS_Decoder*  decoder,
483                            CF2_UInt     *len,
484                            FT_Fixed*    *vec )
485   {
486     TT_Face                  face;
487     FT_Service_MultiMasters  mm;
488 
489 
490     FT_ASSERT( decoder &amp;&amp; decoder-&gt;builder.face );
491     FT_ASSERT( vec &amp;&amp; len );
492     FT_ASSERT( !decoder-&gt;builder.is_t1 );
493 
494     face = (TT_Face)decoder-&gt;builder.face;
495     mm   = (FT_Service_MultiMasters)face-&gt;mm;
496 
497     return mm-&gt;get_var_blend( FT_FACE( face ), len, NULL, vec, NULL );
498   }
499 #endif
500 
501 
502   /* get `y_ppem&#39; from `CFF_Size&#39; */
503   FT_LOCAL_DEF( CF2_Fixed )
504   cf2_getPpemY( PS_Decoder*  decoder )
505   {
506     FT_ASSERT( decoder                     &amp;&amp;
507                decoder-&gt;builder.face       &amp;&amp;
508                decoder-&gt;builder.face-&gt;size );
509 
510     /*
511      * Note that `y_ppem&#39; can be zero if there wasn&#39;t a call to
512      * `FT_Set_Char_Size&#39; or something similar.  However, this isn&#39;t a
513      * problem since we come to this place in the code only if
514      * FT_LOAD_NO_SCALE is set (the other case gets caught by
515      * `cf2_checkTransform&#39;).  The ppem value is needed to compute the stem
516      * darkening, which is disabled for getting the unscaled outline.
517      *
518      */
519     return cf2_intToFixed(
520              decoder-&gt;builder.face-&gt;size-&gt;metrics.y_ppem );
521   }
522 
523 
524   /* get standard stem widths for the current subfont; */
525   /* FreeType stores these as integer font units       */
526   /* (note: variable names seem swapped)               */
527   FT_LOCAL_DEF( CF2_Fixed )
528   cf2_getStdVW( PS_Decoder*  decoder )
529   {
530     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
531 
532     return cf2_intToFixed(
533              decoder-&gt;current_subfont-&gt;private_dict.standard_height );
534   }
535 
536 
537   FT_LOCAL_DEF( CF2_Fixed )
538   cf2_getStdHW( PS_Decoder*  decoder )
539   {
540     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
541 
542     return cf2_intToFixed(
543              decoder-&gt;current_subfont-&gt;private_dict.standard_width );
544   }
545 
546 
547   /* note: FreeType stores 1000 times the actual value for `BlueScale&#39; */
548   FT_LOCAL_DEF( void )
549   cf2_getBlueMetrics( PS_Decoder*  decoder,
550                       CF2_Fixed*   blueScale,
551                       CF2_Fixed*   blueShift,
552                       CF2_Fixed*   blueFuzz )
553   {
554     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
555 
556     *blueScale = FT_DivFix(
557                    decoder-&gt;current_subfont-&gt;private_dict.blue_scale,
558                    cf2_intToFixed( 1000 ) );
559     *blueShift = cf2_intToFixed(
560                    decoder-&gt;current_subfont-&gt;private_dict.blue_shift );
561     *blueFuzz  = cf2_intToFixed(
562                    decoder-&gt;current_subfont-&gt;private_dict.blue_fuzz );
563   }
564 
565 
566   /* get blue values counts and arrays; the FreeType parser has validated */
567   /* the counts and verified that each is an even number                  */
568   FT_LOCAL_DEF( void )
569   cf2_getBlueValues( PS_Decoder*  decoder,
570                      size_t*      count,
571                      FT_Pos*     *data )
572   {
573     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
574 
575     *count = decoder-&gt;current_subfont-&gt;private_dict.num_blue_values;
576     *data  = (FT_Pos*)
577                &amp;decoder-&gt;current_subfont-&gt;private_dict.blue_values;
578   }
579 
580 
581   FT_LOCAL_DEF( void )
582   cf2_getOtherBlues( PS_Decoder*  decoder,
583                      size_t*      count,
584                      FT_Pos*     *data )
585   {
586     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
587 
588     *count = decoder-&gt;current_subfont-&gt;private_dict.num_other_blues;
589     *data  = (FT_Pos*)
590                &amp;decoder-&gt;current_subfont-&gt;private_dict.other_blues;
591   }
592 
593 
594   FT_LOCAL_DEF( void )
595   cf2_getFamilyBlues( PS_Decoder*  decoder,
596                       size_t*      count,
597                       FT_Pos*     *data )
598   {
599     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
600 
601     *count = decoder-&gt;current_subfont-&gt;private_dict.num_family_blues;
602     *data  = (FT_Pos*)
603                &amp;decoder-&gt;current_subfont-&gt;private_dict.family_blues;
604   }
605 
606 
607   FT_LOCAL_DEF( void )
608   cf2_getFamilyOtherBlues( PS_Decoder*  decoder,
609                            size_t*      count,
610                            FT_Pos*     *data )
611   {
612     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
613 
614     *count = decoder-&gt;current_subfont-&gt;private_dict.num_family_other_blues;
615     *data  = (FT_Pos*)
616                &amp;decoder-&gt;current_subfont-&gt;private_dict.family_other_blues;
617   }
618 
619 
620   FT_LOCAL_DEF( CF2_Int )
621   cf2_getLanguageGroup( PS_Decoder*  decoder )
622   {
623     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
624 
625     return decoder-&gt;current_subfont-&gt;private_dict.language_group;
626   }
627 
628 
629   /* convert unbiased subroutine index to `CF2_Buffer&#39; and */
630   /* return 0 on success                                   */
631   FT_LOCAL_DEF( CF2_Int )
632   cf2_initGlobalRegionBuffer( PS_Decoder*  decoder,
633                               CF2_Int      subrNum,
634                               CF2_Buffer   buf )
635   {
636     CF2_UInt  idx;
637 
638 
639     FT_ASSERT( decoder );
640 
641     FT_ZERO( buf );
642 
643     idx = (CF2_UInt)( subrNum + decoder-&gt;globals_bias );
644     if ( idx &gt;= decoder-&gt;num_globals )
645       return TRUE;     /* error */
646 
647     FT_ASSERT( decoder-&gt;globals );
648 
649     buf-&gt;start =
650     buf-&gt;ptr   = decoder-&gt;globals[idx];
651     buf-&gt;end   = decoder-&gt;globals[idx + 1];
652 
653     return FALSE;      /* success */
654   }
655 
656 
657   /* convert AdobeStandardEncoding code to CF2_Buffer; */
658   /* used for seac component                           */
659   FT_LOCAL_DEF( FT_Error )
660   cf2_getSeacComponent( PS_Decoder*  decoder,
661                         CF2_Int      code,
662                         CF2_Buffer   buf )
663   {
664     CF2_Int   gid;
665     FT_Byte*  charstring;
666     FT_ULong  len;
667     FT_Error  error;
668 
669 
670     FT_ASSERT( decoder );
671     FT_ASSERT( !decoder-&gt;builder.is_t1 );
672 
673     FT_ZERO( buf );
674 
675 #ifdef FT_CONFIG_OPTION_INCREMENTAL
676     /* Incremental fonts don&#39;t necessarily have valid charsets.        */
677     /* They use the character code, not the glyph index, in this case. */
678     if ( decoder-&gt;builder.face-&gt;internal-&gt;incremental_interface )
679       gid = code;
680     else
681 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
682     {
683       gid = cff_lookup_glyph_by_stdcharcode( decoder-&gt;cff, code );
684       if ( gid &lt; 0 )
685         return FT_THROW( Invalid_Glyph_Format );
686     }
687 
688     error = decoder-&gt;get_glyph_callback( (TT_Face)decoder-&gt;builder.face,
689                                          (CF2_UInt)gid,
690                                          &amp;charstring,
691                                          &amp;len );
692     /* TODO: for now, just pass the FreeType error through */
693     if ( error )
694       return error;
695 
696     /* assume input has been validated */
697     FT_ASSERT( charstring + len &gt;= charstring );
698 
699     buf-&gt;start = charstring;
700     buf-&gt;end   = charstring + len;
701     buf-&gt;ptr   = buf-&gt;start;
702 
703     return FT_Err_Ok;
704   }
705 
706 
707   FT_LOCAL_DEF( void )
708   cf2_freeSeacComponent( PS_Decoder*  decoder,
709                          CF2_Buffer   buf )
710   {
711     FT_ASSERT( decoder );
712     FT_ASSERT( !decoder-&gt;builder.is_t1 );
713 
714     decoder-&gt;free_glyph_callback( (TT_Face)decoder-&gt;builder.face,
715                                   (FT_Byte**)&amp;buf-&gt;start,
716                                   (FT_ULong)( buf-&gt;end - buf-&gt;start ) );
717   }
718 
719 
720   FT_LOCAL_DEF( FT_Error )
721   cf2_getT1SeacComponent( PS_Decoder*  decoder,
722                           FT_UInt      glyph_index,
723                           CF2_Buffer   buf )
724   {
725     FT_Data   glyph_data;
726     FT_Error  error = FT_Err_Ok;
727     T1_Face   face  = (T1_Face)decoder-&gt;builder.face;
728     T1_Font   type1 = &amp;face-&gt;type1;
729 
730 #ifdef FT_CONFIG_OPTION_INCREMENTAL
731     FT_Incremental_InterfaceRec  *inc =
732       face-&gt;root.internal-&gt;incremental_interface;
733 
734 
735     /* For incremental fonts get the character data using the */
736     /* callback function.                                     */
737     if ( inc )
738       error = inc-&gt;funcs-&gt;get_glyph_data( inc-&gt;object,
739                                           glyph_index, &amp;glyph_data );
740     else
741 #endif
742     /* For ordinary fonts get the character data stored in the face record. */
743     {
744       glyph_data.pointer = type1-&gt;charstrings[glyph_index];
745       glyph_data.length  = (FT_Int)type1-&gt;charstrings_len[glyph_index];
746     }
747 
748     if ( !error )
749     {
750       FT_Byte*  charstring_base = (FT_Byte*)glyph_data.pointer;
751       FT_ULong  charstring_len  = (FT_ULong)glyph_data.length;
752 
753 
754       FT_ASSERT( charstring_base + charstring_len &gt;= charstring_base );
755 
756       FT_ZERO( buf );
757       buf-&gt;start =
758       buf-&gt;ptr   = charstring_base;
759       buf-&gt;end   = charstring_base + charstring_len;
760     }
761 
762     return error;
763   }
764 
765 
766   FT_LOCAL_DEF( void )
767   cf2_freeT1SeacComponent( PS_Decoder*  decoder,
768                            CF2_Buffer   buf )
769   {
<a name="3" id="anc3"></a>

770     T1_Face  face;
771     FT_Data  data;
772 
773 
774     FT_ASSERT( decoder );
775 
<a name="4" id="anc4"></a><span class="line-removed">776 #ifdef FT_CONFIG_OPTION_INCREMENTAL</span>
777     face = (T1_Face)decoder-&gt;builder.face;
778 
779     data.pointer = buf-&gt;start;
780     data.length  = (FT_Int)( buf-&gt;end - buf-&gt;start );
781 
782     if ( face-&gt;root.internal-&gt;incremental_interface )
783       face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;free_glyph_data(
784         face-&gt;root.internal-&gt;incremental_interface-&gt;object,
785         &amp;data );
<a name="5" id="anc5"></a><span class="line-modified">786 #endif /* FT_CONFIG_OPTION_INCREMENTAL */</span>






787   }
788 
789 
790   FT_LOCAL_DEF( CF2_Int )
791   cf2_initLocalRegionBuffer( PS_Decoder*  decoder,
792                              CF2_Int      subrNum,
793                              CF2_Buffer   buf )
794   {
795     CF2_UInt  idx;
796 
797 
798     FT_ASSERT( decoder );
799 
800     FT_ZERO( buf );
801 
802     idx = (CF2_UInt)( subrNum + decoder-&gt;locals_bias );
803     if ( idx &gt;= decoder-&gt;num_locals )
804       return TRUE;     /* error */
805 
806     FT_ASSERT( decoder-&gt;locals );
807 
808     buf-&gt;start = decoder-&gt;locals[idx];
809 
810     if ( decoder-&gt;builder.is_t1 )
811     {
812       /* The Type 1 driver stores subroutines without the seed bytes. */
813       /* The CID driver stores subroutines with seed bytes.  This     */
814       /* case is taken care of when decoder-&gt;subrs_len == 0.          */
815       if ( decoder-&gt;locals_len )
816         buf-&gt;end = buf-&gt;start + decoder-&gt;locals_len[idx];
817       else
818       {
819         /* We are using subroutines from a CID font.  We must adjust */
820         /* for the seed bytes.                                       */
821         buf-&gt;start += ( decoder-&gt;lenIV &gt;= 0 ? decoder-&gt;lenIV : 0 );
822         buf-&gt;end    = decoder-&gt;locals[idx + 1];
823       }
824 
825       if ( !buf-&gt;start )
826       {
827         FT_ERROR(( &quot;cf2_initLocalRegionBuffer (Type 1 mode):&quot;
828                    &quot; invoking empty subrs\n&quot; ));
829       }
830     }
831     else
832     {
833       buf-&gt;end = decoder-&gt;locals[idx + 1];
834     }
835 
836     buf-&gt;ptr = buf-&gt;start;
837 
838     return FALSE;      /* success */
839   }
840 
841 
842   FT_LOCAL_DEF( CF2_Fixed )
843   cf2_getDefaultWidthX( PS_Decoder*  decoder )
844   {
845     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
846 
847     return cf2_intToFixed(
848              decoder-&gt;current_subfont-&gt;private_dict.default_width );
849   }
850 
851 
852   FT_LOCAL_DEF( CF2_Fixed )
853   cf2_getNominalWidthX( PS_Decoder*  decoder )
854   {
855     FT_ASSERT( decoder &amp;&amp; decoder-&gt;current_subfont );
856 
857     return cf2_intToFixed(
858              decoder-&gt;current_subfont-&gt;private_dict.nominal_width );
859   }
860 
861 
862   FT_LOCAL_DEF( void )
863   cf2_outline_reset( CF2_Outline  outline )
864   {
865     PS_Decoder*  decoder = outline-&gt;decoder;
866 
867 
868     FT_ASSERT( decoder );
869 
870     outline-&gt;root.windingMomentum = 0;
871 
872     FT_GlyphLoader_Rewind( decoder-&gt;builder.loader );
873   }
874 
875 
876   FT_LOCAL_DEF( void )
877   cf2_outline_close( CF2_Outline  outline )
878   {
879     PS_Decoder*  decoder = outline-&gt;decoder;
880 
881 
882     FT_ASSERT( decoder );
883 
884     ps_builder_close_contour( &amp;decoder-&gt;builder );
885 
886     FT_GlyphLoader_Add( decoder-&gt;builder.loader );
887   }
888 
889 
890 /* END */
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
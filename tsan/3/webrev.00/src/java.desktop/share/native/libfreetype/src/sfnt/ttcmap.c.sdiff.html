<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/sfnt/ttcmap.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="sfobjs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttcmap.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/sfnt/ttcmap.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttcmap.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    TrueType character mapping table (cmap) support (body).              */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2002-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 
  22 #include &quot;sferrors.h&quot;           /* must come before FT_INTERNAL_VALIDATE_H */
  23 
  24 #include FT_INTERNAL_VALIDATE_H
  25 #include FT_INTERNAL_STREAM_H
  26 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  27 #include &quot;ttload.h&quot;
  28 #include &quot;ttcmap.h&quot;
  29 #include &quot;ttpost.h&quot;
<span class="line-removed">  30 #include &quot;sfntpic.h&quot;</span>
  31 
  32 
<span class="line-modified">  33   /*************************************************************************/</span>
<span class="line-modified">  34   /*                                                                       */</span>
<span class="line-modified">  35   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  36   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  37   /* messages during execution.                                            */</span>
<span class="line-modified">  38   /*                                                                       */</span>
  39 #undef  FT_COMPONENT
<span class="line-modified">  40 #define FT_COMPONENT  trace_ttcmap</span>
  41 
  42 
  43 #define TT_PEEK_SHORT   FT_PEEK_SHORT
  44 #define TT_PEEK_USHORT  FT_PEEK_USHORT
  45 #define TT_PEEK_UINT24  FT_PEEK_UOFF3
  46 #define TT_PEEK_LONG    FT_PEEK_LONG
  47 #define TT_PEEK_ULONG   FT_PEEK_ULONG
  48 
  49 #define TT_NEXT_SHORT   FT_NEXT_SHORT
  50 #define TT_NEXT_USHORT  FT_NEXT_USHORT
  51 #define TT_NEXT_UINT24  FT_NEXT_UOFF3
  52 #define TT_NEXT_LONG    FT_NEXT_LONG
  53 #define TT_NEXT_ULONG   FT_NEXT_ULONG
  54 
  55 
  56   /* Too large glyph index return values are caught in `FT_Get_Char_Index&#39; */
  57   /* and `FT_Get_Next_Char&#39; (the latter calls the internal `next&#39; function */
  58   /* again in this case).  To mark character code return values as invalid */
  59   /* it is sufficient to set the corresponding glyph index return value to */
  60   /* zero.                                                                 */
  61 
  62 
  63   FT_CALLBACK_DEF( FT_Error )
  64   tt_cmap_init( TT_CMap   cmap,
  65                 FT_Byte*  table )
  66   {
  67     cmap-&gt;data = table;
  68     return FT_Err_Ok;
  69   }
  70 
  71 
  72   /*************************************************************************/
  73   /*************************************************************************/
  74   /*****                                                               *****/
  75   /*****                           FORMAT 0                            *****/
  76   /*****                                                               *****/
  77   /*************************************************************************/
  78   /*************************************************************************/
  79 
<span class="line-modified">  80   /*************************************************************************/</span>
<span class="line-modified">  81   /*                                                                       */</span>
<span class="line-modified">  82   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">  83   /* --------------                                                        */</span>
<span class="line-modified">  84   /*                                                                       */</span>
<span class="line-modified">  85   /*   NAME        OFFSET         TYPE          DESCRIPTION                */</span>
<span class="line-modified">  86   /*                                                                       */</span>
<span class="line-modified">  87   /*   format      0              USHORT        must be 0                  */</span>
<span class="line-modified">  88   /*   length      2              USHORT        table length in bytes      */</span>
<span class="line-modified">  89   /*   language    4              USHORT        Mac language code          */</span>
<span class="line-modified">  90   /*   glyph_ids   6              BYTE[256]     array of glyph indices     */</span>
<span class="line-modified">  91   /*               262                                                     */</span>
<span class="line-modified">  92   /*                                                                       */</span>
  93 
  94 #ifdef TT_CONFIG_CMAP_FORMAT_0
  95 
  96   FT_CALLBACK_DEF( FT_Error )
  97   tt_cmap0_validate( FT_Byte*      table,
  98                      FT_Validator  valid )
  99   {
 100     FT_Byte*  p;
 101     FT_UInt   length;
 102 
 103 
 104     if ( table + 2 + 2 &gt; valid-&gt;limit )
 105       FT_INVALID_TOO_SHORT;
 106 
 107     p      = table + 2;           /* skip format */
 108     length = TT_NEXT_USHORT( p );
 109 
 110     if ( table + length &gt; valid-&gt;limit || length &lt; 262 )
 111       FT_INVALID_TOO_SHORT;
 112 
</pre>
<hr />
<pre>
 221   /*****                                                               *****/
 222   /***** The following charmap lookup and iteration functions all      *****/
 223   /***** assume that the value `charcode&#39; fulfills the following.      *****/
 224   /*****                                                               *****/
 225   /*****   - For one-byte characters, `charcode&#39; is simply the         *****/
 226   /*****     character code.                                           *****/
 227   /*****                                                               *****/
 228   /*****   - For two-byte characters, `charcode&#39; is the 2-byte         *****/
 229   /*****     character code in big endian format.  More precisely:     *****/
 230   /*****                                                               *****/
 231   /*****       (charcode &gt;&gt; 8)    is the first byte value              *****/
 232   /*****       (charcode &amp; 0xFF)  is the second byte value             *****/
 233   /*****                                                               *****/
 234   /***** Note that not all values of `charcode&#39; are valid according    *****/
 235   /***** to these rules, and the function moderately checks the        *****/
 236   /***** arguments.                                                    *****/
 237   /*****                                                               *****/
 238   /*************************************************************************/
 239   /*************************************************************************/
 240 
<span class="line-modified"> 241   /*************************************************************************/</span>
<span class="line-modified"> 242   /*                                                                       */</span>
<span class="line-modified"> 243   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified"> 244   /* --------------                                                        */</span>
<span class="line-modified"> 245   /*                                                                       */</span>
<span class="line-modified"> 246   /*   NAME        OFFSET         TYPE            DESCRIPTION              */</span>
<span class="line-modified"> 247   /*                                                                       */</span>
<span class="line-modified"> 248   /*   format      0              USHORT          must be 2                */</span>
<span class="line-modified"> 249   /*   length      2              USHORT          table length in bytes    */</span>
<span class="line-modified"> 250   /*   language    4              USHORT          Mac language code        */</span>
<span class="line-modified"> 251   /*   keys        6              USHORT[256]     sub-header keys          */</span>
<span class="line-modified"> 252   /*   subs        518            SUBHEAD[NSUBS]  sub-headers array        */</span>
<span class="line-modified"> 253   /*   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array           */</span>
<span class="line-modified"> 254   /*                                                                       */</span>
<span class="line-modified"> 255   /* The `keys&#39; table is used to map charcode high bytes to sub-headers.   */</span>
<span class="line-modified"> 256   /* The value of `NSUBS&#39; is the number of sub-headers defined in the      */</span>
<span class="line-modified"> 257   /* table and is computed by finding the maximum of the `keys&#39; table.     */</span>
<span class="line-modified"> 258   /*                                                                       */</span>
<span class="line-modified"> 259   /* Note that for any `n&#39;, `keys[n]&#39; is a byte offset within the `subs&#39;   */</span>
<span class="line-modified"> 260   /* table, i.e., it is the corresponding sub-header index multiplied      */</span>
<span class="line-modified"> 261   /* by 8.                                                                 */</span>
<span class="line-modified"> 262   /*                                                                       */</span>
<span class="line-modified"> 263   /* Each sub-header has the following format.                             */</span>
<span class="line-modified"> 264   /*                                                                       */</span>
<span class="line-modified"> 265   /*   NAME        OFFSET      TYPE            DESCRIPTION                 */</span>
<span class="line-modified"> 266   /*                                                                       */</span>
<span class="line-modified"> 267   /*   first       0           USHORT          first valid low-byte        */</span>
<span class="line-modified"> 268   /*   count       2           USHORT          number of valid low-bytes   */</span>
<span class="line-modified"> 269   /*   delta       4           SHORT           see below                   */</span>
<span class="line-modified"> 270   /*   offset      6           USHORT          see below                   */</span>
<span class="line-modified"> 271   /*                                                                       */</span>
<span class="line-modified"> 272   /* A sub-header defines, for each high byte, the range of valid          */</span>
<span class="line-modified"> 273   /* low bytes within the charmap.  Note that the range defined by `first&#39; */</span>
<span class="line-modified"> 274   /* and `count&#39; must be completely included in the interval [0..255]      */</span>
<span class="line-modified"> 275   /* according to the specification.                                       */</span>
<span class="line-modified"> 276   /*                                                                       */</span>
<span class="line-modified"> 277   /* If a character code is contained within a given sub-header, then      */</span>
<span class="line-modified"> 278   /* mapping it to a glyph index is done as follows.                       */</span>
<span class="line-modified"> 279   /*                                                                       */</span>
<span class="line-modified"> 280   /* * The value of `offset&#39; is read.  This is a _byte_ distance from the  */</span>
<span class="line-modified"> 281   /*   location of the `offset&#39; field itself into a slice of the           */</span>
<span class="line-modified"> 282   /*   `glyph_ids&#39; table.  Let&#39;s call it `slice&#39; (it is a USHORT[], too).  */</span>
<span class="line-modified"> 283   /*                                                                       */</span>
<span class="line-modified"> 284   /* * The value `slice[char.lo - first]&#39; is read.  If it is 0, there is   */</span>
<span class="line-modified"> 285   /*   no glyph for the charcode.  Otherwise, the value of `delta&#39; is      */</span>
<span class="line-modified"> 286   /*   added to it (modulo 65536) to form a new glyph index.               */</span>
<span class="line-modified"> 287   /*                                                                       */</span>
<span class="line-modified"> 288   /* It is up to the validation routine to check that all offsets fall     */</span>
<span class="line-modified"> 289   /* within the glyph IDs table (and not within the `subs&#39; table itself or */</span>
<span class="line-modified"> 290   /* outside of the CMap).                                                 */</span>
<span class="line-modified"> 291   /*                                                                       */</span>
 292 
 293 #ifdef TT_CONFIG_CMAP_FORMAT_2
 294 
 295   FT_CALLBACK_DEF( FT_Error )
 296   tt_cmap2_validate( FT_Byte*      table,
 297                      FT_Validator  valid )
 298   {
 299     FT_Byte*  p;
 300     FT_UInt   length;
 301 
 302     FT_UInt   n, max_subs;
 303     FT_Byte*  keys;        /* keys table     */
 304     FT_Byte*  subs;        /* sub-headers    */
 305     FT_Byte*  glyph_ids;   /* glyph ID array */
 306 
 307 
 308     if ( table + 2 + 2 &gt; valid-&gt;limit )
 309       FT_INVALID_TOO_SHORT;
 310 
 311     p      = table + 2;           /* skip format */
</pre>
<hr />
<pre>
 609       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
 610       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
 611       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
 612 
 613     2,
 614     (TT_CMap_ValidateFunc)tt_cmap2_validate,  /* validate      */
 615     (TT_CMap_Info_GetFunc)tt_cmap2_get_info   /* get_cmap_info */
 616   )
 617 
 618 #endif /* TT_CONFIG_CMAP_FORMAT_2 */
 619 
 620 
 621   /*************************************************************************/
 622   /*************************************************************************/
 623   /*****                                                               *****/
 624   /*****                           FORMAT 4                            *****/
 625   /*****                                                               *****/
 626   /*************************************************************************/
 627   /*************************************************************************/
 628 
<span class="line-modified"> 629   /*************************************************************************/</span>
<span class="line-modified"> 630   /*                                                                       */</span>
<span class="line-modified"> 631   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified"> 632   /* --------------                                                        */</span>
<span class="line-modified"> 633   /*                                                                       */</span>
<span class="line-modified"> 634   /*   NAME          OFFSET         TYPE              DESCRIPTION          */</span>
<span class="line-modified"> 635   /*                                                                       */</span>
<span class="line-modified"> 636   /*   format        0              USHORT            must be 4            */</span>
<span class="line-modified"> 637   /*   length        2              USHORT            table length         */</span>
<span class="line-modified"> 638   /*                                                  in bytes             */</span>
<span class="line-modified"> 639   /*   language      4              USHORT            Mac language code    */</span>
<span class="line-modified"> 640   /*                                                                       */</span>
<span class="line-modified"> 641   /*   segCountX2    6              USHORT            2*NUM_SEGS           */</span>
<span class="line-modified"> 642   /*   searchRange   8              USHORT            2*(1 &lt;&lt; LOG_SEGS)    */</span>
<span class="line-modified"> 643   /*   entrySelector 10             USHORT            LOG_SEGS             */</span>
<span class="line-modified"> 644   /*   rangeShift    12             USHORT            segCountX2 -         */</span>
<span class="line-modified"> 645   /*                                                    searchRange        */</span>
<span class="line-modified"> 646   /*                                                                       */</span>
<span class="line-modified"> 647   /*   endCount      14             USHORT[NUM_SEGS]  end charcode for     */</span>
<span class="line-modified"> 648   /*                                                  each segment; last   */</span>
<span class="line-modified"> 649   /*                                                  is 0xFFFF            */</span>
<span class="line-modified"> 650   /*                                                                       */</span>
<span class="line-modified"> 651   /*   pad           14+NUM_SEGS*2  USHORT            padding              */</span>
<span class="line-modified"> 652   /*                                                                       */</span>
<span class="line-modified"> 653   /*   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for   */</span>
<span class="line-modified"> 654   /*                                                  each segment         */</span>
<span class="line-modified"> 655   /*                                                                       */</span>
<span class="line-modified"> 656   /*   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each       */</span>
<span class="line-modified"> 657   /*                                                  segment              */</span>
<span class="line-modified"> 658   /*   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for     */</span>
<span class="line-modified"> 659   /*                                                  each segment; can be */</span>
<span class="line-modified"> 660   /*                                                  zero                 */</span>
<span class="line-modified"> 661   /*                                                                       */</span>
<span class="line-modified"> 662   /*   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID    */</span>
<span class="line-modified"> 663   /*                                                  ranges               */</span>
<span class="line-modified"> 664   /*                                                                       */</span>
<span class="line-modified"> 665   /* Character codes are modelled by a series of ordered (increasing)      */</span>
<span class="line-modified"> 666   /* intervals called segments.  Each segment has start and end codes,     */</span>
<span class="line-modified"> 667   /* provided by the `startCount&#39; and `endCount&#39; arrays.  Segments must    */</span>
<span class="line-modified"> 668   /* not overlap, and the last segment should always contain the value     */</span>
<span class="line-modified"> 669   /* 0xFFFF for `endCount&#39;.                                                */</span>
<span class="line-modified"> 670   /*                                                                       */</span>
<span class="line-modified"> 671   /* The fields `searchRange&#39;, `entrySelector&#39; and `rangeShift&#39; are better */</span>
<span class="line-modified"> 672   /* ignored (they are traces of over-engineering in the TrueType          */</span>
<span class="line-modified"> 673   /* specification).                                                       */</span>
<span class="line-modified"> 674   /*                                                                       */</span>
<span class="line-modified"> 675   /* Each segment also has a signed `delta&#39;, as well as an optional offset */</span>
<span class="line-modified"> 676   /* within the `glyphIds&#39; table.                                          */</span>
<span class="line-modified"> 677   /*                                                                       */</span>
<span class="line-modified"> 678   /* If a segment&#39;s idOffset is 0, the glyph index corresponding to any    */</span>
<span class="line-modified"> 679   /* charcode within the segment is obtained by adding the value of        */</span>
<span class="line-modified"> 680   /* `idDelta&#39; directly to the charcode, modulo 65536.                     */</span>
<span class="line-modified"> 681   /*                                                                       */</span>
<span class="line-modified"> 682   /* Otherwise, a glyph index is taken from the glyph IDs sub-array for    */</span>
<span class="line-modified"> 683   /* the segment, and the value of `idDelta&#39; is added to it.               */</span>
<span class="line-modified"> 684   /*                                                                       */</span>
<span class="line-modified"> 685   /*                                                                       */</span>
<span class="line-modified"> 686   /* Finally, note that a lot of fonts contain an invalid last segment,    */</span>
<span class="line-modified"> 687   /* where `start&#39; and `end&#39; are correctly set to 0xFFFF but both `delta&#39;  */</span>
<span class="line-modified"> 688   /* and `offset&#39; are incorrect (e.g., `opens___.ttf&#39; which comes with     */</span>
<span class="line-modified"> 689   /* OpenOffice.org).  We need special code to deal with them correctly.   */</span>
<span class="line-modified"> 690   /*                                                                       */</span>
 691 
 692 #ifdef TT_CONFIG_CMAP_FORMAT_4
 693 
 694   typedef struct  TT_CMap4Rec_
 695   {
 696     TT_CMapRec  cmap;
 697     FT_UInt32   cur_charcode;   /* current charcode */
 698     FT_UInt     cur_gindex;     /* current glyph index */
 699 
 700     FT_UInt     num_ranges;
 701     FT_UInt     cur_range;
 702     FT_UInt     cur_start;
 703     FT_UInt     cur_end;
 704     FT_Int      cur_delta;
 705     FT_Byte*    cur_values;
 706 
 707   } TT_CMap4Rec, *TT_CMap4;
 708 
 709 
 710   FT_CALLBACK_DEF( FT_Error )
</pre>
<hr />
<pre>
1556       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
1557       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
1558       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
1559 
1560     4,
1561     (TT_CMap_ValidateFunc)tt_cmap4_validate,  /* validate      */
1562     (TT_CMap_Info_GetFunc)tt_cmap4_get_info   /* get_cmap_info */
1563   )
1564 
1565 #endif /* TT_CONFIG_CMAP_FORMAT_4 */
1566 
1567 
1568   /*************************************************************************/
1569   /*************************************************************************/
1570   /*****                                                               *****/
1571   /*****                          FORMAT 6                             *****/
1572   /*****                                                               *****/
1573   /*************************************************************************/
1574   /*************************************************************************/
1575 
<span class="line-modified">1576   /*************************************************************************/</span>
<span class="line-modified">1577   /*                                                                       */</span>
<span class="line-modified">1578   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">1579   /* --------------                                                        */</span>
<span class="line-modified">1580   /*                                                                       */</span>
<span class="line-modified">1581   /*   NAME        OFFSET          TYPE             DESCRIPTION            */</span>
<span class="line-modified">1582   /*                                                                       */</span>
<span class="line-modified">1583   /*   format       0              USHORT           must be 6              */</span>
<span class="line-modified">1584   /*   length       2              USHORT           table length in bytes  */</span>
<span class="line-modified">1585   /*   language     4              USHORT           Mac language code      */</span>
<span class="line-modified">1586   /*                                                                       */</span>
<span class="line-modified">1587   /*   first        6              USHORT           first segment code     */</span>
<span class="line-modified">1588   /*   count        8              USHORT           segment size in chars  */</span>
<span class="line-modified">1589   /*   glyphIds     10             USHORT[count]    glyph IDs              */</span>
<span class="line-modified">1590   /*                                                                       */</span>
<span class="line-modified">1591   /* A very simplified segment mapping.                                    */</span>
<span class="line-modified">1592   /*                                                                       */</span>
1593 
1594 #ifdef TT_CONFIG_CMAP_FORMAT_6
1595 
1596   FT_CALLBACK_DEF( FT_Error )
1597   tt_cmap6_validate( FT_Byte*      table,
1598                      FT_Validator  valid )
1599   {
1600     FT_Byte*  p;
1601     FT_UInt   length, count;
1602 
1603 
1604     if ( table + 10 &gt; valid-&gt;limit )
1605       FT_INVALID_TOO_SHORT;
1606 
1607     p      = table + 2;
1608     length = TT_NEXT_USHORT( p );
1609 
1610     p      = table + 8;             /* skip language and start index */
1611     count  = TT_NEXT_USHORT( p );
1612 
</pre>
<hr />
<pre>
1751   /*****     Area (i.e. U+D800-U+DFFF).                                *****/
1752   /*****                                                               *****/
1753   /*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/
1754   /*****     `char_code = (char_hi &lt;&lt; 16) | char_lo&#39;, then both        *****/
1755   /*****     `char_hi&#39; and `char_lo&#39; must be in the Surrogates Area.   *****/
1756   /*****      Area.                                                    *****/
1757   /*****                                                               *****/
1758   /***** The `is32&#39; table embedded in the charmap indicates whether a  *****/
1759   /***** given 16-bit value is in the surrogates area or not.          *****/
1760   /*****                                                               *****/
1761   /***** So, for any given `char_code&#39;, we can assert the following.   *****/
1762   /*****                                                               *****/
1763   /*****   If `char_hi == 0&#39; then we must have `is32[char_lo] == 0&#39;.   *****/
1764   /*****                                                               *****/
1765   /*****   If `char_hi != 0&#39; then we must have both                    *****/
1766   /*****   `is32[char_hi] != 0&#39; and `is32[char_lo] != 0&#39;.              *****/
1767   /*****                                                               *****/
1768   /*************************************************************************/
1769   /*************************************************************************/
1770 
<span class="line-modified">1771   /*************************************************************************/</span>
<span class="line-modified">1772   /*                                                                       */</span>
<span class="line-modified">1773   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">1774   /* --------------                                                        */</span>
<span class="line-modified">1775   /*                                                                       */</span>
<span class="line-modified">1776   /*   NAME        OFFSET         TYPE        DESCRIPTION                  */</span>
<span class="line-modified">1777   /*                                                                       */</span>
<span class="line-modified">1778   /*   format      0              USHORT      must be 8                    */</span>
<span class="line-modified">1779   /*   reserved    2              USHORT      reserved                     */</span>
<span class="line-modified">1780   /*   length      4              ULONG       length in bytes              */</span>
<span class="line-modified">1781   /*   language    8              ULONG       Mac language code            */</span>
<span class="line-modified">1782   /*   is32        12             BYTE[8192]  32-bitness bitmap            */</span>
<span class="line-modified">1783   /*   count       8204           ULONG       number of groups             */</span>
<span class="line-modified">1784   /*                                                                       */</span>
<span class="line-modified">1785   /* This header is followed by `count&#39; groups of the following format:    */</span>
<span class="line-modified">1786   /*                                                                       */</span>
<span class="line-modified">1787   /*   start       0              ULONG       first charcode               */</span>
<span class="line-modified">1788   /*   end         4              ULONG       last charcode                */</span>
<span class="line-modified">1789   /*   startId     8              ULONG       start glyph ID for the group */</span>
<span class="line-modified">1790   /*                                                                       */</span>
1791 
1792 #ifdef TT_CONFIG_CMAP_FORMAT_8
1793 
1794   FT_CALLBACK_DEF( FT_Error )
1795   tt_cmap8_validate( FT_Byte*      table,
1796                      FT_Validator  valid )
1797   {
1798     FT_Byte*   p = table + 4;
1799     FT_Byte*   is32;
1800     FT_UInt32  length;
1801     FT_UInt32  num_groups;
1802 
1803 
1804     if ( table + 16 + 8192 &gt; valid-&gt;limit )
1805       FT_INVALID_TOO_SHORT;
1806 
1807     length = TT_NEXT_ULONG( p );
1808     if ( length &gt; (FT_UInt32)( valid-&gt;limit - table ) || length &lt; 8192 + 16 )
1809       FT_INVALID_TOO_SHORT;
1810 
</pre>
<hr />
<pre>
2020       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2021       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2022       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2023 
2024     8,
2025     (TT_CMap_ValidateFunc)tt_cmap8_validate,  /* validate      */
2026     (TT_CMap_Info_GetFunc)tt_cmap8_get_info   /* get_cmap_info */
2027   )
2028 
2029 #endif /* TT_CONFIG_CMAP_FORMAT_8 */
2030 
2031 
2032   /*************************************************************************/
2033   /*************************************************************************/
2034   /*****                                                               *****/
2035   /*****                          FORMAT 10                            *****/
2036   /*****                                                               *****/
2037   /*************************************************************************/
2038   /*************************************************************************/
2039 
<span class="line-modified">2040   /*************************************************************************/</span>
<span class="line-modified">2041   /*                                                                       */</span>
<span class="line-modified">2042   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">2043   /* --------------                                                        */</span>
<span class="line-modified">2044   /*                                                                       */</span>
<span class="line-modified">2045   /*   NAME      OFFSET  TYPE               DESCRIPTION                    */</span>
<span class="line-modified">2046   /*                                                                       */</span>
<span class="line-modified">2047   /*   format     0      USHORT             must be 10                     */</span>
<span class="line-modified">2048   /*   reserved   2      USHORT             reserved                       */</span>
<span class="line-modified">2049   /*   length     4      ULONG              length in bytes                */</span>
<span class="line-modified">2050   /*   language   8      ULONG              Mac language code              */</span>
<span class="line-modified">2051   /*                                                                       */</span>
<span class="line-modified">2052   /*   start     12      ULONG              first char in range            */</span>
<span class="line-modified">2053   /*   count     16      ULONG              number of chars in range       */</span>
<span class="line-modified">2054   /*   glyphIds  20      USHORT[count]      glyph indices covered          */</span>
<span class="line-modified">2055   /*                                                                       */</span>
2056 
2057 #ifdef TT_CONFIG_CMAP_FORMAT_10
2058 
2059   FT_CALLBACK_DEF( FT_Error )
2060   tt_cmap10_validate( FT_Byte*      table,
2061                       FT_Validator  valid )
2062   {
2063     FT_Byte*  p = table + 4;
2064     FT_ULong  length, count;
2065 
2066 
2067     if ( table + 20 &gt; valid-&gt;limit )
2068       FT_INVALID_TOO_SHORT;
2069 
2070     length = TT_NEXT_ULONG( p );
2071     p      = table + 16;
2072     count  = TT_NEXT_ULONG( p );
2073 
2074     if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||
2075          /* length &lt; 20 + count * 2 ? */
</pre>
<hr />
<pre>
2192       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2193       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2194       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2195 
2196     10,
2197     (TT_CMap_ValidateFunc)tt_cmap10_validate,  /* validate      */
2198     (TT_CMap_Info_GetFunc)tt_cmap10_get_info   /* get_cmap_info */
2199   )
2200 
2201 #endif /* TT_CONFIG_CMAP_FORMAT_10 */
2202 
2203 
2204   /*************************************************************************/
2205   /*************************************************************************/
2206   /*****                                                               *****/
2207   /*****                          FORMAT 12                            *****/
2208   /*****                                                               *****/
2209   /*************************************************************************/
2210   /*************************************************************************/
2211 
<span class="line-modified">2212   /*************************************************************************/</span>
<span class="line-modified">2213   /*                                                                       */</span>
<span class="line-modified">2214   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">2215   /* --------------                                                        */</span>
<span class="line-modified">2216   /*                                                                       */</span>
<span class="line-modified">2217   /*   NAME        OFFSET     TYPE       DESCRIPTION                       */</span>
<span class="line-modified">2218   /*                                                                       */</span>
<span class="line-modified">2219   /*   format      0          USHORT     must be 12                        */</span>
<span class="line-modified">2220   /*   reserved    2          USHORT     reserved                          */</span>
<span class="line-modified">2221   /*   length      4          ULONG      length in bytes                   */</span>
<span class="line-modified">2222   /*   language    8          ULONG      Mac language code                 */</span>
<span class="line-modified">2223   /*   count       12         ULONG      number of groups                  */</span>
<span class="line-modified">2224   /*               16                                                      */</span>
<span class="line-modified">2225   /*                                                                       */</span>
<span class="line-modified">2226   /* This header is followed by `count&#39; groups of the following format:    */</span>
<span class="line-modified">2227   /*                                                                       */</span>
<span class="line-modified">2228   /*   start       0          ULONG      first charcode                    */</span>
<span class="line-modified">2229   /*   end         4          ULONG      last charcode                     */</span>
<span class="line-modified">2230   /*   startId     8          ULONG      start glyph ID for the group      */</span>
<span class="line-modified">2231   /*                                                                       */</span>
2232 
2233 #ifdef TT_CONFIG_CMAP_FORMAT_12
2234 
2235   typedef struct  TT_CMap12Rec_
2236   {
2237     TT_CMapRec  cmap;
2238     FT_Bool     valid;
2239     FT_ULong    cur_charcode;
2240     FT_UInt     cur_gindex;
2241     FT_ULong    cur_group;
2242     FT_ULong    num_groups;
2243 
2244   } TT_CMap12Rec, *TT_CMap12;
2245 
2246 
2247   FT_CALLBACK_DEF( FT_Error )
2248   tt_cmap12_init( TT_CMap12  cmap,
2249                   FT_Byte*   table )
2250   {
2251     cmap-&gt;cmap.data  = table;
</pre>
<hr />
<pre>
2352       {
2353         /* ignore invalid group */
2354         if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )
2355           continue;
2356 
2357         gindex = (FT_UInt)( start_id + ( char_code - start ) );
2358 
2359         /* does first element of group point to `.notdef&#39; glyph? */
2360         if ( gindex == 0 )
2361         {
2362           if ( char_code &gt;= 0xFFFFFFFFUL )
2363             goto Fail;
2364 
2365           char_code++;
2366           goto Again;
2367         }
2368 
2369         /* if `gindex&#39; is invalid, the remaining values */
2370         /* in this group are invalid, too               */
2371         if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )
<span class="line-removed">2372         {</span>
<span class="line-removed">2373           gindex = 0;</span>
2374           continue;
<span class="line-removed">2375         }</span>
2376 
2377         cmap-&gt;cur_charcode = char_code;
2378         cmap-&gt;cur_gindex   = gindex;
2379         cmap-&gt;cur_group    = n;
2380 
2381         return;
2382       }
2383     }
2384 
2385   Fail:
2386     cmap-&gt;valid = 0;
2387   }
2388 
2389 
2390   static FT_UInt
2391   tt_cmap12_char_map_binary( TT_CMap     cmap,
2392                              FT_UInt32*  pchar_code,
2393                              FT_Bool     next )
2394   {
2395     FT_UInt    gindex     = 0;
</pre>
<hr />
<pre>
2548       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2549       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2550       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2551 
2552     12,
2553     (TT_CMap_ValidateFunc)tt_cmap12_validate,  /* validate      */
2554     (TT_CMap_Info_GetFunc)tt_cmap12_get_info   /* get_cmap_info */
2555   )
2556 
2557 #endif /* TT_CONFIG_CMAP_FORMAT_12 */
2558 
2559 
2560   /*************************************************************************/
2561   /*************************************************************************/
2562   /*****                                                               *****/
2563   /*****                          FORMAT 13                            *****/
2564   /*****                                                               *****/
2565   /*************************************************************************/
2566   /*************************************************************************/
2567 
<span class="line-modified">2568   /*************************************************************************/</span>
<span class="line-modified">2569   /*                                                                       */</span>
<span class="line-modified">2570   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">2571   /* --------------                                                        */</span>
<span class="line-modified">2572   /*                                                                       */</span>
<span class="line-modified">2573   /*   NAME        OFFSET     TYPE       DESCRIPTION                       */</span>
<span class="line-modified">2574   /*                                                                       */</span>
<span class="line-modified">2575   /*   format      0          USHORT     must be 13                        */</span>
<span class="line-modified">2576   /*   reserved    2          USHORT     reserved                          */</span>
<span class="line-modified">2577   /*   length      4          ULONG      length in bytes                   */</span>
<span class="line-modified">2578   /*   language    8          ULONG      Mac language code                 */</span>
<span class="line-modified">2579   /*   count       12         ULONG      number of groups                  */</span>
<span class="line-modified">2580   /*               16                                                      */</span>
<span class="line-modified">2581   /*                                                                       */</span>
<span class="line-modified">2582   /* This header is followed by `count&#39; groups of the following format:    */</span>
<span class="line-modified">2583   /*                                                                       */</span>
<span class="line-modified">2584   /*   start       0          ULONG      first charcode                    */</span>
<span class="line-modified">2585   /*   end         4          ULONG      last charcode                     */</span>
<span class="line-modified">2586   /*   glyphId     8          ULONG      glyph ID for the whole group      */</span>
<span class="line-modified">2587   /*                                                                       */</span>
2588 
2589 #ifdef TT_CONFIG_CMAP_FORMAT_13
2590 
2591   typedef struct  TT_CMap13Rec_
2592   {
2593     TT_CMapRec  cmap;
2594     FT_Bool     valid;
2595     FT_ULong    cur_charcode;
2596     FT_UInt     cur_gindex;
2597     FT_ULong    cur_group;
2598     FT_ULong    num_groups;
2599 
2600   } TT_CMap13Rec, *TT_CMap13;
2601 
2602 
2603   FT_CALLBACK_DEF( FT_Error )
2604   tt_cmap13_init( TT_CMap13  cmap,
2605                   FT_Byte*   table )
2606   {
2607     cmap-&gt;cmap.data  = table;
</pre>
<hr />
<pre>
2874       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2875       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2876       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2877 
2878     13,
2879     (TT_CMap_ValidateFunc)tt_cmap13_validate,  /* validate      */
2880     (TT_CMap_Info_GetFunc)tt_cmap13_get_info   /* get_cmap_info */
2881   )
2882 
2883 #endif /* TT_CONFIG_CMAP_FORMAT_13 */
2884 
2885 
2886   /*************************************************************************/
2887   /*************************************************************************/
2888   /*****                                                               *****/
2889   /*****                           FORMAT 14                           *****/
2890   /*****                                                               *****/
2891   /*************************************************************************/
2892   /*************************************************************************/
2893 
<span class="line-modified">2894   /*************************************************************************/</span>
<span class="line-modified">2895   /*                                                                       */</span>
<span class="line-modified">2896   /* TABLE OVERVIEW                                                        */</span>
<span class="line-modified">2897   /* --------------                                                        */</span>
<span class="line-modified">2898   /*                                                                       */</span>
<span class="line-modified">2899   /*   NAME         OFFSET  TYPE    DESCRIPTION                            */</span>
<span class="line-modified">2900   /*                                                                       */</span>
<span class="line-modified">2901   /*   format         0     USHORT  must be 14                             */</span>
<span class="line-modified">2902   /*   length         2     ULONG   table length in bytes                  */</span>
<span class="line-modified">2903   /*   numSelector    6     ULONG   number of variation sel. records       */</span>
<span class="line-modified">2904   /*                                                                       */</span>
<span class="line-modified">2905   /* Followed by numSelector records, each of which looks like             */</span>
<span class="line-modified">2906   /*                                                                       */</span>
<span class="line-modified">2907   /*   varSelector    0     UINT24  Unicode codepoint of sel.              */</span>
<span class="line-modified">2908   /*   defaultOff     3     ULONG   offset to a default UVS table          */</span>
<span class="line-modified">2909   /*                                describing any variants to be found in */</span>
<span class="line-modified">2910   /*                                the normal Unicode subtable.           */</span>
<span class="line-modified">2911   /*   nonDefOff      7     ULONG   offset to a non-default UVS table      */</span>
<span class="line-modified">2912   /*                                describing any variants not in the     */</span>
<span class="line-modified">2913   /*                                standard cmap, with GIDs here          */</span>
<span class="line-modified">2914   /* (either offset may be 0 NULL)                                         */</span>
<span class="line-modified">2915   /*                                                                       */</span>
<span class="line-modified">2916   /* Selectors are sorted by code point.                                   */</span>
<span class="line-modified">2917   /*                                                                       */</span>
<span class="line-modified">2918   /* A default Unicode Variation Selector (UVS) subtable is just a list of */</span>
<span class="line-modified">2919   /* ranges of code points which are to be found in the standard cmap.  No */</span>
<span class="line-modified">2920   /* glyph IDs (GIDs) here.                                                */</span>
<span class="line-modified">2921   /*                                                                       */</span>
<span class="line-modified">2922   /*   numRanges      0     ULONG   number of ranges following             */</span>
<span class="line-modified">2923   /*                                                                       */</span>
<span class="line-modified">2924   /* A range looks like                                                    */</span>
<span class="line-modified">2925   /*                                                                       */</span>
<span class="line-modified">2926   /*   uniStart       0     UINT24  code point of the first character in   */</span>
<span class="line-modified">2927   /*                                this range                             */</span>
<span class="line-modified">2928   /*   additionalCnt  3     UBYTE   count of additional characters in this */</span>
<span class="line-modified">2929   /*                                range (zero means a range of a single  */</span>
<span class="line-modified">2930   /*                                character)                             */</span>
<span class="line-modified">2931   /*                                                                       */</span>
<span class="line-modified">2932   /* Ranges are sorted by `uniStart&#39;.                                      */</span>
<span class="line-modified">2933   /*                                                                       */</span>
<span class="line-modified">2934   /* A non-default Unicode Variation Selector (UVS) subtable is a list of  */</span>
<span class="line-modified">2935   /* mappings from codepoint to GID.                                       */</span>
<span class="line-modified">2936   /*                                                                       */</span>
<span class="line-modified">2937   /*   numMappings    0     ULONG   number of mappings                     */</span>
<span class="line-modified">2938   /*                                                                       */</span>
<span class="line-modified">2939   /* A range looks like                                                    */</span>
<span class="line-modified">2940   /*                                                                       */</span>
<span class="line-modified">2941   /*   uniStart       0     UINT24  code point of the first character in   */</span>
<span class="line-modified">2942   /*                                this range                             */</span>
<span class="line-modified">2943   /*   GID            3     USHORT  and its GID                            */</span>
<span class="line-modified">2944   /*                                                                       */</span>
<span class="line-modified">2945   /* Ranges are sorted by `uniStart&#39;.                                      */</span>

2946 
2947 #ifdef TT_CONFIG_CMAP_FORMAT_14
2948 
2949   typedef struct  TT_CMap14Rec_
2950   {
2951     TT_CMapRec  cmap;
2952     FT_ULong    num_selectors;
2953 
2954     /* This array is used to store the results of various
2955      * cmap 14 query functions.  The data is overwritten
2956      * on each call to these functions.
2957      */
2958     FT_UInt32   max_results;
2959     FT_UInt32*  results;
2960     FT_Memory   memory;
2961 
2962   } TT_CMap14Rec, *TT_CMap14;
2963 
2964 
2965   FT_CALLBACK_DEF( void )
</pre>
<hr />
<pre>
3644 
3645 #endif /* TT_CONFIG_CMAP_FORMAT_14 */
3646 
3647 
3648   /*************************************************************************/
3649   /*************************************************************************/
3650   /*****                                                               *****/
3651   /*****                       SYNTHETIC UNICODE                       *****/
3652   /*****                                                               *****/
3653   /*************************************************************************/
3654   /*************************************************************************/
3655 
3656   /*        This charmap is generated using postscript glyph names.        */
3657 
3658 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
3659 
3660   FT_CALLBACK_DEF( const char * )
3661   tt_get_glyph_name( TT_Face  face,
3662                      FT_UInt  idx )
3663   {
<span class="line-modified">3664     FT_String*  PSname;</span>
3665 
3666 
3667     tt_face_get_ps_name( face, idx, &amp;PSname );
3668 
3669     return PSname;
3670   }
3671 
3672 
3673   FT_CALLBACK_DEF( FT_Error )
3674   tt_cmap_unicode_init( PS_Unicodes  unicodes,
3675                         FT_Pointer   pointer )
3676   {
3677     TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );
3678     FT_Memory           memory  = FT_FACE_MEMORY( face );
3679     FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face-&gt;psnames;
3680 
3681     FT_UNUSED( pointer );
3682 
3683 



3684     return psnames-&gt;unicodes_init( memory,
3685                                    unicodes,
3686                                    face-&gt;root.num_glyphs,
3687                                    (PS_GetGlyphNameFunc)&amp;tt_get_glyph_name,
3688                                    (PS_FreeGlyphNameFunc)NULL,
3689                                    (FT_Pointer)face );
3690   }
3691 
3692 
3693   FT_CALLBACK_DEF( void )
3694   tt_cmap_unicode_done( PS_Unicodes  unicodes )
3695   {
3696     FT_Face    face   = FT_CMAP_FACE( unicodes );
3697     FT_Memory  memory = FT_FACE_MEMORY( face );
3698 
3699 
3700     FT_FREE( unicodes-&gt;maps );
3701     unicodes-&gt;num_maps = 0;
3702   }
3703 
</pre>
<hr />
<pre>
3732       sizeof ( PS_UnicodesRec ),
3733 
3734       (FT_CMap_InitFunc)     tt_cmap_unicode_init,        /* init       */
3735       (FT_CMap_DoneFunc)     tt_cmap_unicode_done,        /* done       */
3736       (FT_CMap_CharIndexFunc)tt_cmap_unicode_char_index,  /* char_index */
3737       (FT_CMap_CharNextFunc) tt_cmap_unicode_char_next,   /* char_next  */
3738 
3739       (FT_CMap_CharVarIndexFunc)    NULL,  /* char_var_index   */
3740       (FT_CMap_CharVarIsDefaultFunc)NULL,  /* char_var_default */
3741       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
3742       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
3743       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
3744 
3745     ~0U,
3746     (TT_CMap_ValidateFunc)NULL,  /* validate      */
3747     (TT_CMap_Info_GetFunc)NULL   /* get_cmap_info */
3748   )
3749 
3750 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
3751 
<span class="line-removed">3752 #ifndef FT_CONFIG_OPTION_PIC</span>
3753 
3754   static const TT_CMap_Class  tt_cmap_classes[] =
3755   {
3756 #define TTCMAPCITEM( a )  &amp;a,
3757 #include &quot;ttcmapc.h&quot;
3758     NULL,
3759   };
3760 
<span class="line-removed">3761 #else /*FT_CONFIG_OPTION_PIC*/</span>
<span class="line-removed">3762 </span>
<span class="line-removed">3763   void</span>
<span class="line-removed">3764   FT_Destroy_Class_tt_cmap_classes( FT_Library      library,</span>
<span class="line-removed">3765                                     TT_CMap_Class*  clazz )</span>
<span class="line-removed">3766   {</span>
<span class="line-removed">3767     FT_Memory  memory = library-&gt;memory;</span>
<span class="line-removed">3768 </span>
<span class="line-removed">3769 </span>
<span class="line-removed">3770     if ( clazz )</span>
<span class="line-removed">3771       FT_FREE( clazz );</span>
<span class="line-removed">3772   }</span>
<span class="line-removed">3773 </span>
<span class="line-removed">3774 </span>
<span class="line-removed">3775   FT_Error</span>
<span class="line-removed">3776   FT_Create_Class_tt_cmap_classes( FT_Library       library,</span>
<span class="line-removed">3777                                    TT_CMap_Class**  output_class )</span>
<span class="line-removed">3778   {</span>
<span class="line-removed">3779     TT_CMap_Class*     clazz  = NULL;</span>
<span class="line-removed">3780     TT_CMap_ClassRec*  recs;</span>
<span class="line-removed">3781     FT_Error           error;</span>
<span class="line-removed">3782     FT_Memory          memory = library-&gt;memory;</span>
<span class="line-removed">3783 </span>
<span class="line-removed">3784     int  i = 0;</span>
<span class="line-removed">3785 </span>
<span class="line-removed">3786 </span>
<span class="line-removed">3787 #define TTCMAPCITEM( a ) i++;</span>
<span class="line-removed">3788 #include &quot;ttcmapc.h&quot;</span>
<span class="line-removed">3789 </span>
<span class="line-removed">3790     /* allocate enough space for both the pointers */</span>
<span class="line-removed">3791     /* plus terminator and the class instances     */</span>
<span class="line-removed">3792     if ( FT_ALLOC( clazz, sizeof ( *clazz ) * ( i + 1 ) +</span>
<span class="line-removed">3793                           sizeof ( TT_CMap_ClassRec ) * i ) )</span>
<span class="line-removed">3794       return error;</span>
<span class="line-removed">3795 </span>
<span class="line-removed">3796     /* the location of the class instances follows the array of pointers */</span>
<span class="line-removed">3797     recs = (TT_CMap_ClassRec*)( (char*)clazz +</span>
<span class="line-removed">3798                                 sizeof ( *clazz ) * ( i + 1 ) );</span>
<span class="line-removed">3799     i    = 0;</span>
<span class="line-removed">3800 </span>
<span class="line-removed">3801 #undef TTCMAPCITEM</span>
<span class="line-removed">3802 #define  TTCMAPCITEM( a )             \</span>
<span class="line-removed">3803     FT_Init_Class_ ## a( &amp;recs[i] );  \</span>
<span class="line-removed">3804     clazz[i] = &amp;recs[i];              \</span>
<span class="line-removed">3805     i++;</span>
<span class="line-removed">3806 #include &quot;ttcmapc.h&quot;</span>
<span class="line-removed">3807 </span>
<span class="line-removed">3808     clazz[i] = NULL;</span>
<span class="line-removed">3809 </span>
<span class="line-removed">3810     *output_class = clazz;</span>
<span class="line-removed">3811     return FT_Err_Ok;</span>
<span class="line-removed">3812   }</span>
<span class="line-removed">3813 </span>
<span class="line-removed">3814 #endif /*FT_CONFIG_OPTION_PIC*/</span>
<span class="line-removed">3815 </span>
3816 
3817   /* parse the `cmap&#39; table and build the corresponding TT_CMap objects */
3818   /* in the current face                                                */
3819   /*                                                                    */
3820   FT_LOCAL_DEF( FT_Error )
3821   tt_face_build_cmaps( TT_Face  face )
3822   {
3823     FT_Byte*           table = face-&gt;cmap_table;
3824     FT_Byte*           limit = table + face-&gt;cmap_size;
3825     FT_UInt volatile   num_cmaps;
3826     FT_Byte* volatile  p     = table;
3827     FT_Library         library = FT_FACE_LIBRARY( face );
3828 
3829     FT_UNUSED( library );
3830 
3831 
3832     if ( !p || p + 4 &gt; limit )
3833       return FT_THROW( Invalid_Table );
3834 
3835     /* only recognize format 0 */
</pre>
<hr />
<pre>
3842     }
3843 
3844     num_cmaps = TT_NEXT_USHORT( p );
3845 
3846     for ( ; num_cmaps &gt; 0 &amp;&amp; p + 8 &lt;= limit; num_cmaps-- )
3847     {
3848       FT_CharMapRec  charmap;
3849       FT_UInt32      offset;
3850 
3851 
3852       charmap.platform_id = TT_NEXT_USHORT( p );
3853       charmap.encoding_id = TT_NEXT_USHORT( p );
3854       charmap.face        = FT_FACE( face );
3855       charmap.encoding    = FT_ENCODING_NONE;  /* will be filled later */
3856       offset              = TT_NEXT_ULONG( p );
3857 
3858       if ( offset &amp;&amp; offset &lt;= face-&gt;cmap_size - 2 )
3859       {
3860         FT_Byte* volatile              cmap   = table + offset;
3861         volatile FT_UInt               format = TT_PEEK_USHORT( cmap );
<span class="line-modified">3862         const TT_CMap_Class* volatile  pclazz = TT_CMAP_CLASSES_GET;</span>
3863         TT_CMap_Class volatile         clazz;
3864 
3865 
3866         for ( ; *pclazz; pclazz++ )
3867         {
3868           clazz = *pclazz;
3869           if ( clazz-&gt;format == format )
3870           {
3871             volatile TT_ValidatorRec  valid;
3872             volatile FT_Error         error = FT_Err_Ok;
3873 
3874 
3875             ft_validator_init( FT_VALIDATOR( &amp;valid ), cmap, limit,
3876                                FT_VALIDATE_DEFAULT );
3877 
3878             valid.num_glyphs = (FT_UInt)face-&gt;max_profile.numGlyphs;
3879 
3880             if ( ft_setjmp( FT_VALIDATOR( &amp;valid )-&gt;jump_buffer) == 0 )
3881             {
3882               /* validate this cmap sub-table */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ttcmap.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   TrueType character mapping table (cmap) support (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2002-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 
  22 #include &quot;sferrors.h&quot;           /* must come before FT_INTERNAL_VALIDATE_H */
  23 
  24 #include FT_INTERNAL_VALIDATE_H
  25 #include FT_INTERNAL_STREAM_H
  26 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  27 #include &quot;ttload.h&quot;
  28 #include &quot;ttcmap.h&quot;
  29 #include &quot;ttpost.h&quot;

  30 
  31 
<span class="line-modified">  32   /**************************************************************************</span>
<span class="line-modified">  33    *</span>
<span class="line-modified">  34    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  35    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  36    * messages during execution.</span>
<span class="line-modified">  37    */</span>
  38 #undef  FT_COMPONENT
<span class="line-modified">  39 #define FT_COMPONENT  ttcmap</span>
  40 
  41 
  42 #define TT_PEEK_SHORT   FT_PEEK_SHORT
  43 #define TT_PEEK_USHORT  FT_PEEK_USHORT
  44 #define TT_PEEK_UINT24  FT_PEEK_UOFF3
  45 #define TT_PEEK_LONG    FT_PEEK_LONG
  46 #define TT_PEEK_ULONG   FT_PEEK_ULONG
  47 
  48 #define TT_NEXT_SHORT   FT_NEXT_SHORT
  49 #define TT_NEXT_USHORT  FT_NEXT_USHORT
  50 #define TT_NEXT_UINT24  FT_NEXT_UOFF3
  51 #define TT_NEXT_LONG    FT_NEXT_LONG
  52 #define TT_NEXT_ULONG   FT_NEXT_ULONG
  53 
  54 
  55   /* Too large glyph index return values are caught in `FT_Get_Char_Index&#39; */
  56   /* and `FT_Get_Next_Char&#39; (the latter calls the internal `next&#39; function */
  57   /* again in this case).  To mark character code return values as invalid */
  58   /* it is sufficient to set the corresponding glyph index return value to */
  59   /* zero.                                                                 */
  60 
  61 
  62   FT_CALLBACK_DEF( FT_Error )
  63   tt_cmap_init( TT_CMap   cmap,
  64                 FT_Byte*  table )
  65   {
  66     cmap-&gt;data = table;
  67     return FT_Err_Ok;
  68   }
  69 
  70 
  71   /*************************************************************************/
  72   /*************************************************************************/
  73   /*****                                                               *****/
  74   /*****                           FORMAT 0                            *****/
  75   /*****                                                               *****/
  76   /*************************************************************************/
  77   /*************************************************************************/
  78 
<span class="line-modified">  79   /**************************************************************************</span>
<span class="line-modified">  80    *</span>
<span class="line-modified">  81    * TABLE OVERVIEW</span>
<span class="line-modified">  82    * --------------</span>
<span class="line-modified">  83    *</span>
<span class="line-modified">  84    *   NAME        OFFSET         TYPE          DESCRIPTION</span>
<span class="line-modified">  85    *</span>
<span class="line-modified">  86    *   format      0              USHORT        must be 0</span>
<span class="line-modified">  87    *   length      2              USHORT        table length in bytes</span>
<span class="line-modified">  88    *   language    4              USHORT        Mac language code</span>
<span class="line-modified">  89    *   glyph_ids   6              BYTE[256]     array of glyph indices</span>
<span class="line-modified">  90    *               262</span>
<span class="line-modified">  91    */</span>
  92 
  93 #ifdef TT_CONFIG_CMAP_FORMAT_0
  94 
  95   FT_CALLBACK_DEF( FT_Error )
  96   tt_cmap0_validate( FT_Byte*      table,
  97                      FT_Validator  valid )
  98   {
  99     FT_Byte*  p;
 100     FT_UInt   length;
 101 
 102 
 103     if ( table + 2 + 2 &gt; valid-&gt;limit )
 104       FT_INVALID_TOO_SHORT;
 105 
 106     p      = table + 2;           /* skip format */
 107     length = TT_NEXT_USHORT( p );
 108 
 109     if ( table + length &gt; valid-&gt;limit || length &lt; 262 )
 110       FT_INVALID_TOO_SHORT;
 111 
</pre>
<hr />
<pre>
 220   /*****                                                               *****/
 221   /***** The following charmap lookup and iteration functions all      *****/
 222   /***** assume that the value `charcode&#39; fulfills the following.      *****/
 223   /*****                                                               *****/
 224   /*****   - For one-byte characters, `charcode&#39; is simply the         *****/
 225   /*****     character code.                                           *****/
 226   /*****                                                               *****/
 227   /*****   - For two-byte characters, `charcode&#39; is the 2-byte         *****/
 228   /*****     character code in big endian format.  More precisely:     *****/
 229   /*****                                                               *****/
 230   /*****       (charcode &gt;&gt; 8)    is the first byte value              *****/
 231   /*****       (charcode &amp; 0xFF)  is the second byte value             *****/
 232   /*****                                                               *****/
 233   /***** Note that not all values of `charcode&#39; are valid according    *****/
 234   /***** to these rules, and the function moderately checks the        *****/
 235   /***** arguments.                                                    *****/
 236   /*****                                                               *****/
 237   /*************************************************************************/
 238   /*************************************************************************/
 239 
<span class="line-modified"> 240   /**************************************************************************</span>
<span class="line-modified"> 241    *</span>
<span class="line-modified"> 242    * TABLE OVERVIEW</span>
<span class="line-modified"> 243    * --------------</span>
<span class="line-modified"> 244    *</span>
<span class="line-modified"> 245    *   NAME        OFFSET         TYPE            DESCRIPTION</span>
<span class="line-modified"> 246    *</span>
<span class="line-modified"> 247    *   format      0              USHORT          must be 2</span>
<span class="line-modified"> 248    *   length      2              USHORT          table length in bytes</span>
<span class="line-modified"> 249    *   language    4              USHORT          Mac language code</span>
<span class="line-modified"> 250    *   keys        6              USHORT[256]     sub-header keys</span>
<span class="line-modified"> 251    *   subs        518            SUBHEAD[NSUBS]  sub-headers array</span>
<span class="line-modified"> 252    *   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array</span>
<span class="line-modified"> 253    *</span>
<span class="line-modified"> 254    * The `keys&#39; table is used to map charcode high bytes to sub-headers.</span>
<span class="line-modified"> 255    * The value of `NSUBS&#39; is the number of sub-headers defined in the</span>
<span class="line-modified"> 256    * table and is computed by finding the maximum of the `keys&#39; table.</span>
<span class="line-modified"> 257    *</span>
<span class="line-modified"> 258    * Note that for any `n&#39;, `keys[n]&#39; is a byte offset within the `subs&#39;</span>
<span class="line-modified"> 259    * table, i.e., it is the corresponding sub-header index multiplied</span>
<span class="line-modified"> 260    * by 8.</span>
<span class="line-modified"> 261    *</span>
<span class="line-modified"> 262    * Each sub-header has the following format.</span>
<span class="line-modified"> 263    *</span>
<span class="line-modified"> 264    *   NAME        OFFSET      TYPE            DESCRIPTION</span>
<span class="line-modified"> 265    *</span>
<span class="line-modified"> 266    *   first       0           USHORT          first valid low-byte</span>
<span class="line-modified"> 267    *   count       2           USHORT          number of valid low-bytes</span>
<span class="line-modified"> 268    *   delta       4           SHORT           see below</span>
<span class="line-modified"> 269    *   offset      6           USHORT          see below</span>
<span class="line-modified"> 270    *</span>
<span class="line-modified"> 271    * A sub-header defines, for each high byte, the range of valid</span>
<span class="line-modified"> 272    * low bytes within the charmap.  Note that the range defined by `first&#39;</span>
<span class="line-modified"> 273    * and `count&#39; must be completely included in the interval [0..255]</span>
<span class="line-modified"> 274    * according to the specification.</span>
<span class="line-modified"> 275    *</span>
<span class="line-modified"> 276    * If a character code is contained within a given sub-header, then</span>
<span class="line-modified"> 277    * mapping it to a glyph index is done as follows.</span>
<span class="line-modified"> 278    *</span>
<span class="line-modified"> 279    * - The value of `offset&#39; is read.  This is a _byte_ distance from the</span>
<span class="line-modified"> 280    *   location of the `offset&#39; field itself into a slice of the</span>
<span class="line-modified"> 281    *   `glyph_ids&#39; table.  Let&#39;s call it `slice&#39; (it is a USHORT[], too).</span>
<span class="line-modified"> 282    *</span>
<span class="line-modified"> 283    * - The value `slice[char.lo - first]&#39; is read.  If it is 0, there is</span>
<span class="line-modified"> 284    *   no glyph for the charcode.  Otherwise, the value of `delta&#39; is</span>
<span class="line-modified"> 285    *   added to it (modulo 65536) to form a new glyph index.</span>
<span class="line-modified"> 286    *</span>
<span class="line-modified"> 287    * It is up to the validation routine to check that all offsets fall</span>
<span class="line-modified"> 288    * within the glyph IDs table (and not within the `subs&#39; table itself or</span>
<span class="line-modified"> 289    * outside of the CMap).</span>
<span class="line-modified"> 290    */</span>
 291 
 292 #ifdef TT_CONFIG_CMAP_FORMAT_2
 293 
 294   FT_CALLBACK_DEF( FT_Error )
 295   tt_cmap2_validate( FT_Byte*      table,
 296                      FT_Validator  valid )
 297   {
 298     FT_Byte*  p;
 299     FT_UInt   length;
 300 
 301     FT_UInt   n, max_subs;
 302     FT_Byte*  keys;        /* keys table     */
 303     FT_Byte*  subs;        /* sub-headers    */
 304     FT_Byte*  glyph_ids;   /* glyph ID array */
 305 
 306 
 307     if ( table + 2 + 2 &gt; valid-&gt;limit )
 308       FT_INVALID_TOO_SHORT;
 309 
 310     p      = table + 2;           /* skip format */
</pre>
<hr />
<pre>
 608       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
 609       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
 610       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
 611 
 612     2,
 613     (TT_CMap_ValidateFunc)tt_cmap2_validate,  /* validate      */
 614     (TT_CMap_Info_GetFunc)tt_cmap2_get_info   /* get_cmap_info */
 615   )
 616 
 617 #endif /* TT_CONFIG_CMAP_FORMAT_2 */
 618 
 619 
 620   /*************************************************************************/
 621   /*************************************************************************/
 622   /*****                                                               *****/
 623   /*****                           FORMAT 4                            *****/
 624   /*****                                                               *****/
 625   /*************************************************************************/
 626   /*************************************************************************/
 627 
<span class="line-modified"> 628   /**************************************************************************</span>
<span class="line-modified"> 629    *</span>
<span class="line-modified"> 630    * TABLE OVERVIEW</span>
<span class="line-modified"> 631    * --------------</span>
<span class="line-modified"> 632    *</span>
<span class="line-modified"> 633    *   NAME          OFFSET         TYPE              DESCRIPTION</span>
<span class="line-modified"> 634    *</span>
<span class="line-modified"> 635    *   format        0              USHORT            must be 4</span>
<span class="line-modified"> 636    *   length        2              USHORT            table length</span>
<span class="line-modified"> 637    *                                                  in bytes</span>
<span class="line-modified"> 638    *   language      4              USHORT            Mac language code</span>
<span class="line-modified"> 639    *</span>
<span class="line-modified"> 640    *   segCountX2    6              USHORT            2*NUM_SEGS</span>
<span class="line-modified"> 641    *   searchRange   8              USHORT            2*(1 &lt;&lt; LOG_SEGS)</span>
<span class="line-modified"> 642    *   entrySelector 10             USHORT            LOG_SEGS</span>
<span class="line-modified"> 643    *   rangeShift    12             USHORT            segCountX2 -</span>
<span class="line-modified"> 644    *                                                    searchRange</span>
<span class="line-modified"> 645    *</span>
<span class="line-modified"> 646    *   endCount      14             USHORT[NUM_SEGS]  end charcode for</span>
<span class="line-modified"> 647    *                                                  each segment; last</span>
<span class="line-modified"> 648    *                                                  is 0xFFFF</span>
<span class="line-modified"> 649    *</span>
<span class="line-modified"> 650    *   pad           14+NUM_SEGS*2  USHORT            padding</span>
<span class="line-modified"> 651    *</span>
<span class="line-modified"> 652    *   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for</span>
<span class="line-modified"> 653    *                                                  each segment</span>
<span class="line-modified"> 654    *</span>
<span class="line-modified"> 655    *   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each</span>
<span class="line-modified"> 656    *                                                  segment</span>
<span class="line-modified"> 657    *   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for</span>
<span class="line-modified"> 658    *                                                  each segment; can be</span>
<span class="line-modified"> 659    *                                                  zero</span>
<span class="line-modified"> 660    *</span>
<span class="line-modified"> 661    *   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID</span>
<span class="line-modified"> 662    *                                                  ranges</span>
<span class="line-modified"> 663    *</span>
<span class="line-modified"> 664    * Character codes are modelled by a series of ordered (increasing)</span>
<span class="line-modified"> 665    * intervals called segments.  Each segment has start and end codes,</span>
<span class="line-modified"> 666    * provided by the `startCount&#39; and `endCount&#39; arrays.  Segments must</span>
<span class="line-modified"> 667    * not overlap, and the last segment should always contain the value</span>
<span class="line-modified"> 668    * 0xFFFF for `endCount&#39;.</span>
<span class="line-modified"> 669    *</span>
<span class="line-modified"> 670    * The fields `searchRange&#39;, `entrySelector&#39; and `rangeShift&#39; are better</span>
<span class="line-modified"> 671    * ignored (they are traces of over-engineering in the TrueType</span>
<span class="line-modified"> 672    * specification).</span>
<span class="line-modified"> 673    *</span>
<span class="line-modified"> 674    * Each segment also has a signed `delta&#39;, as well as an optional offset</span>
<span class="line-modified"> 675    * within the `glyphIds&#39; table.</span>
<span class="line-modified"> 676    *</span>
<span class="line-modified"> 677    * If a segment&#39;s idOffset is 0, the glyph index corresponding to any</span>
<span class="line-modified"> 678    * charcode within the segment is obtained by adding the value of</span>
<span class="line-modified"> 679    * `idDelta&#39; directly to the charcode, modulo 65536.</span>
<span class="line-modified"> 680    *</span>
<span class="line-modified"> 681    * Otherwise, a glyph index is taken from the glyph IDs sub-array for</span>
<span class="line-modified"> 682    * the segment, and the value of `idDelta&#39; is added to it.</span>
<span class="line-modified"> 683    *</span>
<span class="line-modified"> 684    *</span>
<span class="line-modified"> 685    * Finally, note that a lot of fonts contain an invalid last segment,</span>
<span class="line-modified"> 686    * where `start&#39; and `end&#39; are correctly set to 0xFFFF but both `delta&#39;</span>
<span class="line-modified"> 687    * and `offset&#39; are incorrect (e.g., `opens___.ttf&#39; which comes with</span>
<span class="line-modified"> 688    * OpenOffice.org).  We need special code to deal with them correctly.</span>
<span class="line-modified"> 689    */</span>
 690 
 691 #ifdef TT_CONFIG_CMAP_FORMAT_4
 692 
 693   typedef struct  TT_CMap4Rec_
 694   {
 695     TT_CMapRec  cmap;
 696     FT_UInt32   cur_charcode;   /* current charcode */
 697     FT_UInt     cur_gindex;     /* current glyph index */
 698 
 699     FT_UInt     num_ranges;
 700     FT_UInt     cur_range;
 701     FT_UInt     cur_start;
 702     FT_UInt     cur_end;
 703     FT_Int      cur_delta;
 704     FT_Byte*    cur_values;
 705 
 706   } TT_CMap4Rec, *TT_CMap4;
 707 
 708 
 709   FT_CALLBACK_DEF( FT_Error )
</pre>
<hr />
<pre>
1555       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
1556       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
1557       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
1558 
1559     4,
1560     (TT_CMap_ValidateFunc)tt_cmap4_validate,  /* validate      */
1561     (TT_CMap_Info_GetFunc)tt_cmap4_get_info   /* get_cmap_info */
1562   )
1563 
1564 #endif /* TT_CONFIG_CMAP_FORMAT_4 */
1565 
1566 
1567   /*************************************************************************/
1568   /*************************************************************************/
1569   /*****                                                               *****/
1570   /*****                          FORMAT 6                             *****/
1571   /*****                                                               *****/
1572   /*************************************************************************/
1573   /*************************************************************************/
1574 
<span class="line-modified">1575   /**************************************************************************</span>
<span class="line-modified">1576    *</span>
<span class="line-modified">1577    * TABLE OVERVIEW</span>
<span class="line-modified">1578    * --------------</span>
<span class="line-modified">1579    *</span>
<span class="line-modified">1580    *   NAME        OFFSET          TYPE             DESCRIPTION</span>
<span class="line-modified">1581    *</span>
<span class="line-modified">1582    *   format       0              USHORT           must be 6</span>
<span class="line-modified">1583    *   length       2              USHORT           table length in bytes</span>
<span class="line-modified">1584    *   language     4              USHORT           Mac language code</span>
<span class="line-modified">1585    *</span>
<span class="line-modified">1586    *   first        6              USHORT           first segment code</span>
<span class="line-modified">1587    *   count        8              USHORT           segment size in chars</span>
<span class="line-modified">1588    *   glyphIds     10             USHORT[count]    glyph IDs</span>
<span class="line-modified">1589    *</span>
<span class="line-modified">1590    * A very simplified segment mapping.</span>
<span class="line-modified">1591    */</span>
1592 
1593 #ifdef TT_CONFIG_CMAP_FORMAT_6
1594 
1595   FT_CALLBACK_DEF( FT_Error )
1596   tt_cmap6_validate( FT_Byte*      table,
1597                      FT_Validator  valid )
1598   {
1599     FT_Byte*  p;
1600     FT_UInt   length, count;
1601 
1602 
1603     if ( table + 10 &gt; valid-&gt;limit )
1604       FT_INVALID_TOO_SHORT;
1605 
1606     p      = table + 2;
1607     length = TT_NEXT_USHORT( p );
1608 
1609     p      = table + 8;             /* skip language and start index */
1610     count  = TT_NEXT_USHORT( p );
1611 
</pre>
<hr />
<pre>
1750   /*****     Area (i.e. U+D800-U+DFFF).                                *****/
1751   /*****                                                               *****/
1752   /*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/
1753   /*****     `char_code = (char_hi &lt;&lt; 16) | char_lo&#39;, then both        *****/
1754   /*****     `char_hi&#39; and `char_lo&#39; must be in the Surrogates Area.   *****/
1755   /*****      Area.                                                    *****/
1756   /*****                                                               *****/
1757   /***** The `is32&#39; table embedded in the charmap indicates whether a  *****/
1758   /***** given 16-bit value is in the surrogates area or not.          *****/
1759   /*****                                                               *****/
1760   /***** So, for any given `char_code&#39;, we can assert the following.   *****/
1761   /*****                                                               *****/
1762   /*****   If `char_hi == 0&#39; then we must have `is32[char_lo] == 0&#39;.   *****/
1763   /*****                                                               *****/
1764   /*****   If `char_hi != 0&#39; then we must have both                    *****/
1765   /*****   `is32[char_hi] != 0&#39; and `is32[char_lo] != 0&#39;.              *****/
1766   /*****                                                               *****/
1767   /*************************************************************************/
1768   /*************************************************************************/
1769 
<span class="line-modified">1770   /**************************************************************************</span>
<span class="line-modified">1771    *</span>
<span class="line-modified">1772    * TABLE OVERVIEW</span>
<span class="line-modified">1773    * --------------</span>
<span class="line-modified">1774    *</span>
<span class="line-modified">1775    *   NAME        OFFSET         TYPE        DESCRIPTION</span>
<span class="line-modified">1776    *</span>
<span class="line-modified">1777    *   format      0              USHORT      must be 8</span>
<span class="line-modified">1778    *   reserved    2              USHORT      reserved</span>
<span class="line-modified">1779    *   length      4              ULONG       length in bytes</span>
<span class="line-modified">1780    *   language    8              ULONG       Mac language code</span>
<span class="line-modified">1781    *   is32        12             BYTE[8192]  32-bitness bitmap</span>
<span class="line-modified">1782    *   count       8204           ULONG       number of groups</span>
<span class="line-modified">1783    *</span>
<span class="line-modified">1784    * This header is followed by `count&#39; groups of the following format:</span>
<span class="line-modified">1785    *</span>
<span class="line-modified">1786    *   start       0              ULONG       first charcode</span>
<span class="line-modified">1787    *   end         4              ULONG       last charcode</span>
<span class="line-modified">1788    *   startId     8              ULONG       start glyph ID for the group</span>
<span class="line-modified">1789    */</span>
1790 
1791 #ifdef TT_CONFIG_CMAP_FORMAT_8
1792 
1793   FT_CALLBACK_DEF( FT_Error )
1794   tt_cmap8_validate( FT_Byte*      table,
1795                      FT_Validator  valid )
1796   {
1797     FT_Byte*   p = table + 4;
1798     FT_Byte*   is32;
1799     FT_UInt32  length;
1800     FT_UInt32  num_groups;
1801 
1802 
1803     if ( table + 16 + 8192 &gt; valid-&gt;limit )
1804       FT_INVALID_TOO_SHORT;
1805 
1806     length = TT_NEXT_ULONG( p );
1807     if ( length &gt; (FT_UInt32)( valid-&gt;limit - table ) || length &lt; 8192 + 16 )
1808       FT_INVALID_TOO_SHORT;
1809 
</pre>
<hr />
<pre>
2019       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2020       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2021       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2022 
2023     8,
2024     (TT_CMap_ValidateFunc)tt_cmap8_validate,  /* validate      */
2025     (TT_CMap_Info_GetFunc)tt_cmap8_get_info   /* get_cmap_info */
2026   )
2027 
2028 #endif /* TT_CONFIG_CMAP_FORMAT_8 */
2029 
2030 
2031   /*************************************************************************/
2032   /*************************************************************************/
2033   /*****                                                               *****/
2034   /*****                          FORMAT 10                            *****/
2035   /*****                                                               *****/
2036   /*************************************************************************/
2037   /*************************************************************************/
2038 
<span class="line-modified">2039   /**************************************************************************</span>
<span class="line-modified">2040    *</span>
<span class="line-modified">2041    * TABLE OVERVIEW</span>
<span class="line-modified">2042    * --------------</span>
<span class="line-modified">2043    *</span>
<span class="line-modified">2044    *   NAME      OFFSET  TYPE               DESCRIPTION</span>
<span class="line-modified">2045    *</span>
<span class="line-modified">2046    *   format     0      USHORT             must be 10</span>
<span class="line-modified">2047    *   reserved   2      USHORT             reserved</span>
<span class="line-modified">2048    *   length     4      ULONG              length in bytes</span>
<span class="line-modified">2049    *   language   8      ULONG              Mac language code</span>
<span class="line-modified">2050    *</span>
<span class="line-modified">2051    *   start     12      ULONG              first char in range</span>
<span class="line-modified">2052    *   count     16      ULONG              number of chars in range</span>
<span class="line-modified">2053    *   glyphIds  20      USHORT[count]      glyph indices covered</span>
<span class="line-modified">2054    */</span>
2055 
2056 #ifdef TT_CONFIG_CMAP_FORMAT_10
2057 
2058   FT_CALLBACK_DEF( FT_Error )
2059   tt_cmap10_validate( FT_Byte*      table,
2060                       FT_Validator  valid )
2061   {
2062     FT_Byte*  p = table + 4;
2063     FT_ULong  length, count;
2064 
2065 
2066     if ( table + 20 &gt; valid-&gt;limit )
2067       FT_INVALID_TOO_SHORT;
2068 
2069     length = TT_NEXT_ULONG( p );
2070     p      = table + 16;
2071     count  = TT_NEXT_ULONG( p );
2072 
2073     if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||
2074          /* length &lt; 20 + count * 2 ? */
</pre>
<hr />
<pre>
2191       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2192       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2193       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2194 
2195     10,
2196     (TT_CMap_ValidateFunc)tt_cmap10_validate,  /* validate      */
2197     (TT_CMap_Info_GetFunc)tt_cmap10_get_info   /* get_cmap_info */
2198   )
2199 
2200 #endif /* TT_CONFIG_CMAP_FORMAT_10 */
2201 
2202 
2203   /*************************************************************************/
2204   /*************************************************************************/
2205   /*****                                                               *****/
2206   /*****                          FORMAT 12                            *****/
2207   /*****                                                               *****/
2208   /*************************************************************************/
2209   /*************************************************************************/
2210 
<span class="line-modified">2211   /**************************************************************************</span>
<span class="line-modified">2212    *</span>
<span class="line-modified">2213    * TABLE OVERVIEW</span>
<span class="line-modified">2214    * --------------</span>
<span class="line-modified">2215    *</span>
<span class="line-modified">2216    *   NAME        OFFSET     TYPE       DESCRIPTION</span>
<span class="line-modified">2217    *</span>
<span class="line-modified">2218    *   format      0          USHORT     must be 12</span>
<span class="line-modified">2219    *   reserved    2          USHORT     reserved</span>
<span class="line-modified">2220    *   length      4          ULONG      length in bytes</span>
<span class="line-modified">2221    *   language    8          ULONG      Mac language code</span>
<span class="line-modified">2222    *   count       12         ULONG      number of groups</span>
<span class="line-modified">2223    *               16</span>
<span class="line-modified">2224    *</span>
<span class="line-modified">2225    * This header is followed by `count&#39; groups of the following format:</span>
<span class="line-modified">2226    *</span>
<span class="line-modified">2227    *   start       0          ULONG      first charcode</span>
<span class="line-modified">2228    *   end         4          ULONG      last charcode</span>
<span class="line-modified">2229    *   startId     8          ULONG      start glyph ID for the group</span>
<span class="line-modified">2230    */</span>
2231 
2232 #ifdef TT_CONFIG_CMAP_FORMAT_12
2233 
2234   typedef struct  TT_CMap12Rec_
2235   {
2236     TT_CMapRec  cmap;
2237     FT_Bool     valid;
2238     FT_ULong    cur_charcode;
2239     FT_UInt     cur_gindex;
2240     FT_ULong    cur_group;
2241     FT_ULong    num_groups;
2242 
2243   } TT_CMap12Rec, *TT_CMap12;
2244 
2245 
2246   FT_CALLBACK_DEF( FT_Error )
2247   tt_cmap12_init( TT_CMap12  cmap,
2248                   FT_Byte*   table )
2249   {
2250     cmap-&gt;cmap.data  = table;
</pre>
<hr />
<pre>
2351       {
2352         /* ignore invalid group */
2353         if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )
2354           continue;
2355 
2356         gindex = (FT_UInt)( start_id + ( char_code - start ) );
2357 
2358         /* does first element of group point to `.notdef&#39; glyph? */
2359         if ( gindex == 0 )
2360         {
2361           if ( char_code &gt;= 0xFFFFFFFFUL )
2362             goto Fail;
2363 
2364           char_code++;
2365           goto Again;
2366         }
2367 
2368         /* if `gindex&#39; is invalid, the remaining values */
2369         /* in this group are invalid, too               */
2370         if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )


2371           continue;

2372 
2373         cmap-&gt;cur_charcode = char_code;
2374         cmap-&gt;cur_gindex   = gindex;
2375         cmap-&gt;cur_group    = n;
2376 
2377         return;
2378       }
2379     }
2380 
2381   Fail:
2382     cmap-&gt;valid = 0;
2383   }
2384 
2385 
2386   static FT_UInt
2387   tt_cmap12_char_map_binary( TT_CMap     cmap,
2388                              FT_UInt32*  pchar_code,
2389                              FT_Bool     next )
2390   {
2391     FT_UInt    gindex     = 0;
</pre>
<hr />
<pre>
2544       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2545       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2546       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2547 
2548     12,
2549     (TT_CMap_ValidateFunc)tt_cmap12_validate,  /* validate      */
2550     (TT_CMap_Info_GetFunc)tt_cmap12_get_info   /* get_cmap_info */
2551   )
2552 
2553 #endif /* TT_CONFIG_CMAP_FORMAT_12 */
2554 
2555 
2556   /*************************************************************************/
2557   /*************************************************************************/
2558   /*****                                                               *****/
2559   /*****                          FORMAT 13                            *****/
2560   /*****                                                               *****/
2561   /*************************************************************************/
2562   /*************************************************************************/
2563 
<span class="line-modified">2564   /**************************************************************************</span>
<span class="line-modified">2565    *</span>
<span class="line-modified">2566    * TABLE OVERVIEW</span>
<span class="line-modified">2567    * --------------</span>
<span class="line-modified">2568    *</span>
<span class="line-modified">2569    *   NAME        OFFSET     TYPE       DESCRIPTION</span>
<span class="line-modified">2570    *</span>
<span class="line-modified">2571    *   format      0          USHORT     must be 13</span>
<span class="line-modified">2572    *   reserved    2          USHORT     reserved</span>
<span class="line-modified">2573    *   length      4          ULONG      length in bytes</span>
<span class="line-modified">2574    *   language    8          ULONG      Mac language code</span>
<span class="line-modified">2575    *   count       12         ULONG      number of groups</span>
<span class="line-modified">2576    *               16</span>
<span class="line-modified">2577    *</span>
<span class="line-modified">2578    * This header is followed by `count&#39; groups of the following format:</span>
<span class="line-modified">2579    *</span>
<span class="line-modified">2580    *   start       0          ULONG      first charcode</span>
<span class="line-modified">2581    *   end         4          ULONG      last charcode</span>
<span class="line-modified">2582    *   glyphId     8          ULONG      glyph ID for the whole group</span>
<span class="line-modified">2583    */</span>
2584 
2585 #ifdef TT_CONFIG_CMAP_FORMAT_13
2586 
2587   typedef struct  TT_CMap13Rec_
2588   {
2589     TT_CMapRec  cmap;
2590     FT_Bool     valid;
2591     FT_ULong    cur_charcode;
2592     FT_UInt     cur_gindex;
2593     FT_ULong    cur_group;
2594     FT_ULong    num_groups;
2595 
2596   } TT_CMap13Rec, *TT_CMap13;
2597 
2598 
2599   FT_CALLBACK_DEF( FT_Error )
2600   tt_cmap13_init( TT_CMap13  cmap,
2601                   FT_Byte*   table )
2602   {
2603     cmap-&gt;cmap.data  = table;
</pre>
<hr />
<pre>
2870       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
2871       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
2872       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
2873 
2874     13,
2875     (TT_CMap_ValidateFunc)tt_cmap13_validate,  /* validate      */
2876     (TT_CMap_Info_GetFunc)tt_cmap13_get_info   /* get_cmap_info */
2877   )
2878 
2879 #endif /* TT_CONFIG_CMAP_FORMAT_13 */
2880 
2881 
2882   /*************************************************************************/
2883   /*************************************************************************/
2884   /*****                                                               *****/
2885   /*****                           FORMAT 14                           *****/
2886   /*****                                                               *****/
2887   /*************************************************************************/
2888   /*************************************************************************/
2889 
<span class="line-modified">2890   /**************************************************************************</span>
<span class="line-modified">2891    *</span>
<span class="line-modified">2892    * TABLE OVERVIEW</span>
<span class="line-modified">2893    * --------------</span>
<span class="line-modified">2894    *</span>
<span class="line-modified">2895    *   NAME         OFFSET  TYPE    DESCRIPTION</span>
<span class="line-modified">2896    *</span>
<span class="line-modified">2897    *   format         0     USHORT  must be 14</span>
<span class="line-modified">2898    *   length         2     ULONG   table length in bytes</span>
<span class="line-modified">2899    *   numSelector    6     ULONG   number of variation sel. records</span>
<span class="line-modified">2900    *</span>
<span class="line-modified">2901    * Followed by numSelector records, each of which looks like</span>
<span class="line-modified">2902    *</span>
<span class="line-modified">2903    *   varSelector    0     UINT24  Unicode codepoint of sel.</span>
<span class="line-modified">2904    *   defaultOff     3     ULONG   offset to a default UVS table</span>
<span class="line-modified">2905    *                                describing any variants to be found in</span>
<span class="line-modified">2906    *                                the normal Unicode subtable.</span>
<span class="line-modified">2907    *   nonDefOff      7     ULONG   offset to a non-default UVS table</span>
<span class="line-modified">2908    *                                describing any variants not in the</span>
<span class="line-modified">2909    *                                standard cmap, with GIDs here</span>
<span class="line-modified">2910    * (either offset may be 0 NULL)</span>
<span class="line-modified">2911    *</span>
<span class="line-modified">2912    * Selectors are sorted by code point.</span>
<span class="line-modified">2913    *</span>
<span class="line-modified">2914    * A default Unicode Variation Selector (UVS) subtable is just a list of</span>
<span class="line-modified">2915    * ranges of code points which are to be found in the standard cmap.  No</span>
<span class="line-modified">2916    * glyph IDs (GIDs) here.</span>
<span class="line-modified">2917    *</span>
<span class="line-modified">2918    *   numRanges      0     ULONG   number of ranges following</span>
<span class="line-modified">2919    *</span>
<span class="line-modified">2920    * A range looks like</span>
<span class="line-modified">2921    *</span>
<span class="line-modified">2922    *   uniStart       0     UINT24  code point of the first character in</span>
<span class="line-modified">2923    *                                this range</span>
<span class="line-modified">2924    *   additionalCnt  3     UBYTE   count of additional characters in this</span>
<span class="line-modified">2925    *                                range (zero means a range of a single</span>
<span class="line-modified">2926    *                                character)</span>
<span class="line-modified">2927    *</span>
<span class="line-modified">2928    * Ranges are sorted by `uniStart&#39;.</span>
<span class="line-modified">2929    *</span>
<span class="line-modified">2930    * A non-default Unicode Variation Selector (UVS) subtable is a list of</span>
<span class="line-modified">2931    * mappings from codepoint to GID.</span>
<span class="line-modified">2932    *</span>
<span class="line-modified">2933    *   numMappings    0     ULONG   number of mappings</span>
<span class="line-modified">2934    *</span>
<span class="line-modified">2935    * A range looks like</span>
<span class="line-modified">2936    *</span>
<span class="line-modified">2937    *   uniStart       0     UINT24  code point of the first character in</span>
<span class="line-modified">2938    *                                this range</span>
<span class="line-modified">2939    *   GID            3     USHORT  and its GID</span>
<span class="line-modified">2940    *</span>
<span class="line-modified">2941    * Ranges are sorted by `uniStart&#39;.</span>
<span class="line-added">2942    */</span>
2943 
2944 #ifdef TT_CONFIG_CMAP_FORMAT_14
2945 
2946   typedef struct  TT_CMap14Rec_
2947   {
2948     TT_CMapRec  cmap;
2949     FT_ULong    num_selectors;
2950 
2951     /* This array is used to store the results of various
2952      * cmap 14 query functions.  The data is overwritten
2953      * on each call to these functions.
2954      */
2955     FT_UInt32   max_results;
2956     FT_UInt32*  results;
2957     FT_Memory   memory;
2958 
2959   } TT_CMap14Rec, *TT_CMap14;
2960 
2961 
2962   FT_CALLBACK_DEF( void )
</pre>
<hr />
<pre>
3641 
3642 #endif /* TT_CONFIG_CMAP_FORMAT_14 */
3643 
3644 
3645   /*************************************************************************/
3646   /*************************************************************************/
3647   /*****                                                               *****/
3648   /*****                       SYNTHETIC UNICODE                       *****/
3649   /*****                                                               *****/
3650   /*************************************************************************/
3651   /*************************************************************************/
3652 
3653   /*        This charmap is generated using postscript glyph names.        */
3654 
3655 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
3656 
3657   FT_CALLBACK_DEF( const char * )
3658   tt_get_glyph_name( TT_Face  face,
3659                      FT_UInt  idx )
3660   {
<span class="line-modified">3661     FT_String*  PSname = NULL;</span>
3662 
3663 
3664     tt_face_get_ps_name( face, idx, &amp;PSname );
3665 
3666     return PSname;
3667   }
3668 
3669 
3670   FT_CALLBACK_DEF( FT_Error )
3671   tt_cmap_unicode_init( PS_Unicodes  unicodes,
3672                         FT_Pointer   pointer )
3673   {
3674     TT_Face             face    = (TT_Face)FT_CMAP_FACE( unicodes );
3675     FT_Memory           memory  = FT_FACE_MEMORY( face );
3676     FT_Service_PsCMaps  psnames = (FT_Service_PsCMaps)face-&gt;psnames;
3677 
3678     FT_UNUSED( pointer );
3679 
3680 
<span class="line-added">3681     if ( !psnames-&gt;unicodes_init )</span>
<span class="line-added">3682       return FT_THROW( Unimplemented_Feature );</span>
<span class="line-added">3683 </span>
3684     return psnames-&gt;unicodes_init( memory,
3685                                    unicodes,
3686                                    face-&gt;root.num_glyphs,
3687                                    (PS_GetGlyphNameFunc)&amp;tt_get_glyph_name,
3688                                    (PS_FreeGlyphNameFunc)NULL,
3689                                    (FT_Pointer)face );
3690   }
3691 
3692 
3693   FT_CALLBACK_DEF( void )
3694   tt_cmap_unicode_done( PS_Unicodes  unicodes )
3695   {
3696     FT_Face    face   = FT_CMAP_FACE( unicodes );
3697     FT_Memory  memory = FT_FACE_MEMORY( face );
3698 
3699 
3700     FT_FREE( unicodes-&gt;maps );
3701     unicodes-&gt;num_maps = 0;
3702   }
3703 
</pre>
<hr />
<pre>
3732       sizeof ( PS_UnicodesRec ),
3733 
3734       (FT_CMap_InitFunc)     tt_cmap_unicode_init,        /* init       */
3735       (FT_CMap_DoneFunc)     tt_cmap_unicode_done,        /* done       */
3736       (FT_CMap_CharIndexFunc)tt_cmap_unicode_char_index,  /* char_index */
3737       (FT_CMap_CharNextFunc) tt_cmap_unicode_char_next,   /* char_next  */
3738 
3739       (FT_CMap_CharVarIndexFunc)    NULL,  /* char_var_index   */
3740       (FT_CMap_CharVarIsDefaultFunc)NULL,  /* char_var_default */
3741       (FT_CMap_VariantListFunc)     NULL,  /* variant_list     */
3742       (FT_CMap_CharVariantListFunc) NULL,  /* charvariant_list */
3743       (FT_CMap_VariantCharListFunc) NULL,  /* variantchar_list */
3744 
3745     ~0U,
3746     (TT_CMap_ValidateFunc)NULL,  /* validate      */
3747     (TT_CMap_Info_GetFunc)NULL   /* get_cmap_info */
3748   )
3749 
3750 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
3751 

3752 
3753   static const TT_CMap_Class  tt_cmap_classes[] =
3754   {
3755 #define TTCMAPCITEM( a )  &amp;a,
3756 #include &quot;ttcmapc.h&quot;
3757     NULL,
3758   };
3759 























































3760 
3761   /* parse the `cmap&#39; table and build the corresponding TT_CMap objects */
3762   /* in the current face                                                */
3763   /*                                                                    */
3764   FT_LOCAL_DEF( FT_Error )
3765   tt_face_build_cmaps( TT_Face  face )
3766   {
3767     FT_Byte*           table = face-&gt;cmap_table;
3768     FT_Byte*           limit = table + face-&gt;cmap_size;
3769     FT_UInt volatile   num_cmaps;
3770     FT_Byte* volatile  p     = table;
3771     FT_Library         library = FT_FACE_LIBRARY( face );
3772 
3773     FT_UNUSED( library );
3774 
3775 
3776     if ( !p || p + 4 &gt; limit )
3777       return FT_THROW( Invalid_Table );
3778 
3779     /* only recognize format 0 */
</pre>
<hr />
<pre>
3786     }
3787 
3788     num_cmaps = TT_NEXT_USHORT( p );
3789 
3790     for ( ; num_cmaps &gt; 0 &amp;&amp; p + 8 &lt;= limit; num_cmaps-- )
3791     {
3792       FT_CharMapRec  charmap;
3793       FT_UInt32      offset;
3794 
3795 
3796       charmap.platform_id = TT_NEXT_USHORT( p );
3797       charmap.encoding_id = TT_NEXT_USHORT( p );
3798       charmap.face        = FT_FACE( face );
3799       charmap.encoding    = FT_ENCODING_NONE;  /* will be filled later */
3800       offset              = TT_NEXT_ULONG( p );
3801 
3802       if ( offset &amp;&amp; offset &lt;= face-&gt;cmap_size - 2 )
3803       {
3804         FT_Byte* volatile              cmap   = table + offset;
3805         volatile FT_UInt               format = TT_PEEK_USHORT( cmap );
<span class="line-modified">3806         const TT_CMap_Class* volatile  pclazz = tt_cmap_classes;</span>
3807         TT_CMap_Class volatile         clazz;
3808 
3809 
3810         for ( ; *pclazz; pclazz++ )
3811         {
3812           clazz = *pclazz;
3813           if ( clazz-&gt;format == format )
3814           {
3815             volatile TT_ValidatorRec  valid;
3816             volatile FT_Error         error = FT_Err_Ok;
3817 
3818 
3819             ft_validator_init( FT_VALIDATOR( &amp;valid ), cmap, limit,
3820                                FT_VALIDATE_DEFAULT );
3821 
3822             valid.num_glyphs = (FT_UInt)face-&gt;max_profile.numGlyphs;
3823 
3824             if ( ft_setjmp( FT_VALIDATOR( &amp;valid )-&gt;jump_buffer) == 0 )
3825             {
3826               /* validate this cmap sub-table */
</pre>
</td>
</tr>
</table>
<center><a href="sfobjs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttcmap.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
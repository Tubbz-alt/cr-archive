<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/include/freetype/internal/t1types.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /****************************************************************************
  2  *
  3  * t1types.h
  4  *
  5  *   Basic Type1/Type2 type definitions and interface (specification
  6  *   only).
  7  *
  8  * Copyright (C) 1996-2019 by
  9  * David Turner, Robert Wilhelm, and Werner Lemberg.
 10  *
 11  * This file is part of the FreeType project, and may only be used,
 12  * modified, and distributed under the terms of the FreeType project
 13  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 14  * this file you indicate that you have read the license and
 15  * understand and accept it fully.
 16  *
 17  */
 18 
 19 
 20 #ifndef T1TYPES_H_
 21 #define T1TYPES_H_
 22 
 23 
 24 #include &lt;ft2build.h&gt;
 25 #include FT_TYPE1_TABLES_H
 26 #include FT_INTERNAL_POSTSCRIPT_HINTS_H
 27 #include FT_INTERNAL_SERVICE_H
 28 #include FT_INTERNAL_HASH_H
 29 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 30 
 31 
 32 FT_BEGIN_HEADER
 33 
 34 
 35   /*************************************************************************/
 36   /*************************************************************************/
 37   /*************************************************************************/
 38   /***                                                                   ***/
 39   /***                                                                   ***/
 40   /***              REQUIRED TYPE1/TYPE2 TABLES DEFINITIONS              ***/
 41   /***                                                                   ***/
 42   /***                                                                   ***/
 43   /*************************************************************************/
 44   /*************************************************************************/
 45   /*************************************************************************/
 46 
 47 
 48   /**************************************************************************
 49    *
 50    * @struct:
 51    *   T1_EncodingRec
 52    *
 53    * @description:
 54    *   A structure modeling a custom encoding.
 55    *
 56    * @fields:
 57    *   num_chars ::
 58    *     The number of character codes in the encoding.  Usually 256.
 59    *
 60    *   code_first ::
 61    *     The lowest valid character code in the encoding.
 62    *
 63    *   code_last ::
 64    *     The highest valid character code in the encoding + 1. When equal to
 65    *     code_first there are no valid character codes.
 66    *
 67    *   char_index ::
 68    *     An array of corresponding glyph indices.
 69    *
 70    *   char_name ::
 71    *     An array of corresponding glyph names.
 72    */
 73   typedef struct  T1_EncodingRecRec_
 74   {
 75     FT_Int       num_chars;
 76     FT_Int       code_first;
 77     FT_Int       code_last;
 78 
 79     FT_UShort*         char_index;
 80     const FT_String**  char_name;
 81 
 82   } T1_EncodingRec, *T1_Encoding;
 83 
 84 
 85   /* used to hold extra data of PS_FontInfoRec that
 86    * cannot be stored in the publicly defined structure.
 87    *
 88    * Note these can&#39;t be blended with multiple-masters.
 89    */
 90   typedef struct  PS_FontExtraRec_
 91   {
 92     FT_UShort  fs_type;
 93 
 94   } PS_FontExtraRec;
 95 
 96 
 97   typedef struct  T1_FontRec_
 98   {
 99     PS_FontInfoRec   font_info;         /* font info dictionary   */
100     PS_FontExtraRec  font_extra;        /* font info extra fields */
101     PS_PrivateRec    private_dict;      /* private dictionary     */
102     FT_String*       font_name;         /* top-level dictionary   */
103 
104     T1_EncodingType  encoding_type;
105     T1_EncodingRec   encoding;
106 
107     FT_Byte*         subrs_block;
108     FT_Byte*         charstrings_block;
109     FT_Byte*         glyph_names_block;
110 
111     FT_Int           num_subrs;
112     FT_Byte**        subrs;
113     FT_UInt*         subrs_len;
114     FT_Hash          subrs_hash;
115 
116     FT_Int           num_glyphs;
117     FT_String**      glyph_names;       /* array of glyph names       */
118     FT_Byte**        charstrings;       /* array of glyph charstrings */
119     FT_UInt*         charstrings_len;
120 
121     FT_Byte          paint_type;
122     FT_Byte          font_type;
123     FT_Matrix        font_matrix;
124     FT_Vector        font_offset;
125     FT_BBox          font_bbox;
126     FT_Long          font_id;
127 
128     FT_Fixed         stroke_width;
129 
130   } T1_FontRec, *T1_Font;
131 
132 
133   typedef struct  CID_SubrsRec_
134   {
135     FT_Int     num_subrs;
136     FT_Byte**  code;
137 
138   } CID_SubrsRec, *CID_Subrs;
139 
140 
141   /*************************************************************************/
142   /*************************************************************************/
143   /*************************************************************************/
144   /***                                                                   ***/
145   /***                                                                   ***/
146   /***                AFM FONT INFORMATION STRUCTURES                    ***/
147   /***                                                                   ***/
148   /***                                                                   ***/
149   /*************************************************************************/
150   /*************************************************************************/
151   /*************************************************************************/
152 
153   typedef struct  AFM_TrackKernRec_
154   {
155     FT_Int    degree;
156     FT_Fixed  min_ptsize;
157     FT_Fixed  min_kern;
158     FT_Fixed  max_ptsize;
159     FT_Fixed  max_kern;
160 
161   } AFM_TrackKernRec, *AFM_TrackKern;
162 
163   typedef struct  AFM_KernPairRec_
164   {
165     FT_UInt  index1;
166     FT_UInt  index2;
167     FT_Int   x;
168     FT_Int   y;
169 
170   } AFM_KernPairRec, *AFM_KernPair;
171 
172   typedef struct  AFM_FontInfoRec_
173   {
174     FT_Bool        IsCIDFont;
175     FT_BBox        FontBBox;
176     FT_Fixed       Ascender;
177     FT_Fixed       Descender;
178     AFM_TrackKern  TrackKerns;   /* free if non-NULL */
179     FT_UInt        NumTrackKern;
180     AFM_KernPair   KernPairs;    /* free if non-NULL */
181     FT_UInt        NumKernPair;
182 
183   } AFM_FontInfoRec, *AFM_FontInfo;
184 
185 
186   /*************************************************************************/
187   /*************************************************************************/
188   /*************************************************************************/
189   /***                                                                   ***/
190   /***                                                                   ***/
191   /***                ORIGINAL T1_FACE CLASS DEFINITION                  ***/
192   /***                                                                   ***/
193   /***                                                                   ***/
194   /*************************************************************************/
195   /*************************************************************************/
196   /*************************************************************************/
197 
198 
199   typedef struct T1_FaceRec_*   T1_Face;
200   typedef struct CID_FaceRec_*  CID_Face;
201 
202 
203   typedef struct  T1_FaceRec_
204   {
205     FT_FaceRec      root;
206     T1_FontRec      type1;
207     const void*     psnames;
208     const void*     psaux;
209     const void*     afm_data;
210     FT_CharMapRec   charmaprecs[2];
211     FT_CharMap      charmaps[2];
212 
213     /* support for Multiple Masters fonts */
214     PS_Blend        blend;
215 
216     /* undocumented, optional: indices of subroutines that express      */
217     /* the NormalizeDesignVector and the ConvertDesignVector procedure, */
218     /* respectively, as Type 2 charstrings; -1 if keywords not present  */
219     FT_Int           ndv_idx;
220     FT_Int           cdv_idx;
221 
222     /* undocumented, optional: has the same meaning as len_buildchar */
223     /* for Type 2 fonts; manipulated by othersubrs 19, 24, and 25    */
224     FT_UInt          len_buildchar;
225     FT_Long*         buildchar;
226 
227     /* since version 2.1 - interface to PostScript hinter */
228     const void*     pshinter;
229 
230   } T1_FaceRec;
231 
232 
233   typedef struct  CID_FaceRec_
234   {
235     FT_FaceRec       root;
236     void*            psnames;
237     void*            psaux;
238     CID_FaceInfoRec  cid;
239     PS_FontExtraRec  font_extra;
240 #if 0
241     void*            afm_data;
242 #endif
243     CID_Subrs        subrs;
244 
245     /* since version 2.1 - interface to PostScript hinter */
246     void*            pshinter;
247 
248     /* since version 2.1.8, but was originally positioned after `afm_data&#39; */
249     FT_Byte*         binary_data; /* used if hex data has been converted */
250     FT_Stream        cid_stream;
251 
252   } CID_FaceRec;
253 
254 
255 FT_END_HEADER
256 
257 #endif /* T1TYPES_H_ */
258 
259 
260 /* END */
    </pre>
  </body>
</html>
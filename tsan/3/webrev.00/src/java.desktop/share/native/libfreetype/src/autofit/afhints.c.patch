diff a/src/java.desktop/share/native/libfreetype/src/autofit/afhints.c b/src/java.desktop/share/native/libfreetype/src/autofit/afhints.c
--- a/src/java.desktop/share/native/libfreetype/src/autofit/afhints.c
+++ b/src/java.desktop/share/native/libfreetype/src/autofit/afhints.c
@@ -1,37 +1,37 @@
-/***************************************************************************/
-/*                                                                         */
-/*  afhints.c                                                              */
-/*                                                                         */
-/*    Auto-fitter hinting routines (body).                                 */
-/*                                                                         */
-/*  Copyright 2003-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * afhints.c
+ *
+ *   Auto-fitter hinting routines (body).
+ *
+ * Copyright (C) 2003-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include "afhints.h"
 #include "aferrors.h"
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_DEBUG_H
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_afhints
+#define FT_COMPONENT  afhints
 
 
   /* Get new segment for given axis. */
 
   FT_LOCAL_DEF( FT_Error )
@@ -295,10 +295,23 @@
 
     return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment->edge, edges );
   }
 
 
+  static int
+  af_get_strong_edge_index( AF_GlyphHints  hints,
+                            AF_Edge*       strong_edges,
+                            int            dimension )
+  {
+    AF_AxisHints  axis  = &hints->axis[dimension];
+    AF_Edge       edges = axis->edges;
+
+
+    return AF_INDEX_NUM( strong_edges[dimension], edges );
+  }
+
+
 #ifdef __cplusplus
   extern "C" {
 #endif
   void
   af_glyph_hints_dump_points( AF_GlyphHints  hints,
@@ -315,12 +328,14 @@
 
     if ( hints->num_points )
     {
       AF_DUMP(( "  index  hedge  hseg  vedge  vseg  flags "
              /* "  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX" */
-                "  xorg  yorg  xscale  yscale   xfit    yfit" ));
+                "  xorg  yorg  xscale  yscale   xfit    yfit "
              /* " XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX" */
+                "  hbef  haft  vbef  vaft" ));
+             /* " XXXXX XXXXX XXXXX XXXXX" */
     }
     else
       AF_DUMP(( "  (none)\n" ));
 
     for ( point = points; point < limit; point++ )
@@ -328,21 +343,23 @@
       int  point_idx     = AF_INDEX_NUM( point, points );
       int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
       int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
 
       char  buf1[16], buf2[16], buf3[16], buf4[16];
+      char  buf5[16], buf6[16], buf7[16], buf8[16];
 
 
       /* insert extra newline at the beginning of a contour */
       if ( contour < climit && *contour == point )
       {
         AF_DUMP(( "\n" ));
         contour++;
       }
 
       AF_DUMP(( "  %5d  %5s %5s  %5s %5s  %s"
-                " %5d %5d %7.2f %7.2f %7.2f %7.2f\n",
+                " %5d %5d %7.2f %7.2f %7.2f %7.2f"
+                " %5s %5s %5s %5s\n",
                 point_idx,
                 af_print_idx( buf1,
                               af_get_edge_index( hints, segment_idx_1, 1 ) ),
                 af_print_idx( buf2, segment_idx_1 ),
                 af_print_idx( buf3,
@@ -357,11 +374,24 @@
                 point->fx,
                 point->fy,
                 point->ox / 64.0,
                 point->oy / 64.0,
                 point->x / 64.0,
-                point->y / 64.0 ));
+                point->y / 64.0,
+
+                af_print_idx( buf5, af_get_strong_edge_index( hints,
+                                                              point->before,
+                                                              1 ) ),
+                af_print_idx( buf6, af_get_strong_edge_index( hints,
+                                                              point->after,
+                                                              1 ) ),
+                af_print_idx( buf7, af_get_strong_edge_index( hints,
+                                                              point->before,
+                                                              0 ) ),
+                af_print_idx( buf8, af_get_strong_edge_index( hints,
+                                                              point->after,
+                                                              0 ) ) ));
     }
     AF_DUMP(( "\n" ));
   }
 #ifdef __cplusplus
   }
@@ -517,11 +547,11 @@
 
     seg      = &axis->segments[idx];
     *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg->first->fx
                                             : seg->first->fy;
     if ( seg->edge )
-      *is_blue = (FT_Bool)( seg->edge->blue_edge != 0 );
+      *is_blue = FT_BOOL( seg->edge->blue_edge );
     else
       *is_blue = FALSE;
 
     if ( *is_blue )
       *blue_offset = seg->edge->blue_edge->org;
@@ -556,12 +586,12 @@
 
       char  buf1[16], buf2[16];
 
 
       /*
-       *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
-       *        since they have a constant X coordinate.
+       * note: AF_DIMENSION_HORZ corresponds to _vertical_ edges
+       *       since they have a constant X coordinate.
        */
       if ( dimension == AF_DIMENSION_HORZ )
         AF_DUMP(( "Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n",
                   "vertical",
                   65536.0 * 64.0 / hints->x_scale,
@@ -679,12 +709,12 @@
       return;
 
     memory = hints->memory;
 
     /*
-     *  note that we don't need to free the segment and edge
-     *  buffers since they are really within the hints->points array
+     * note that we don't need to free the segment and edge
+     * buffers since they are really within the hints->points array
      */
     for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
     {
       AF_AxisHints  axis = &hints->axis[dim];
 
@@ -774,13 +804,13 @@
 
       hints->max_contours = (FT_Int)new_max;
     }
 
     /*
-     *  then reallocate the points arrays if necessary --
-     *  note that we reserve two additional point positions, used to
-     *  hint metrics appropriately
+     * then reallocate the points arrays if necessary --
+     * note that we reserve two additional point positions, used to
+     * hint metrics appropriately
      */
     new_max = (FT_UInt)( outline->n_points + 2 );
     old_max = (FT_UInt)hints->max_points;
 
     if ( new_max <= AF_POINTS_EMBEDDED )
@@ -896,10 +926,18 @@
               endpoint = outline->contours[contour_index];
               end      = points + endpoint;
               prev     = end;
             }
           }
+
+#ifdef FT_DEBUG_AUTOFIT
+          point->before[0] = NULL;
+          point->before[1] = NULL;
+          point->after[0]  = NULL;
+          point->after[1]  = NULL;
+#endif
+
         }
       }
 
       /* set up the contours array */
       {
@@ -916,19 +954,19 @@
         }
       }
 
       {
         /*
-         *  Compute directions of `in' and `out' vectors.
+         * Compute directions of `in' and `out' vectors.
          *
-         *  Note that distances between points that are very near to each
-         *  other are accumulated.  In other words, the auto-hinter either
-         *  prepends the small vectors between near points to the first
-         *  non-near vector, or the sum of small vector lengths exceeds a
-         *  threshold, thus `grouping' the small vectors.  All intermediate
-         *  points are tagged as weak; the directions are adjusted also to
-         *  be equal to the accumulated one.
+         * Note that distances between points that are very near to each
+         * other are accumulated.  In other words, the auto-hinter either
+         * prepends the small vectors between near points to the first
+         * non-near vector, or the sum of small vector lengths exceeds a
+         * threshold, thus `grouping' the small vectors.  All intermediate
+         * points are tagged as weak; the directions are adjusted also to
+         * be equal to the accumulated one.
          */
 
         FT_Int  near_limit2 = 2 * near_limit - 1;
 
         AF_Point*  contour;
@@ -954,16 +992,16 @@
           {
             out_x = point->fx - prev->fx;
             out_y = point->fy - prev->fy;
 
             /*
-             *  We use Taxicab metrics to measure the vector length.
+             * We use Taxicab metrics to measure the vector length.
              *
-             *  Note that the accumulated distances so far could have the
-             *  opposite direction of the distance measured here.  For this
-             *  reason we use `near_limit2' for the comparison to get a
-             *  non-near point even in the worst case.
+             * Note that the accumulated distances so far could have the
+             * opposite direction of the distance measured here.  For this
+             * reason we use `near_limit2' for the comparison to get a
+             * non-near point even in the worst case.
              */
             if ( FT_ABS( out_x ) + FT_ABS( out_y ) >= near_limit2 )
               break;
 
             point = prev;
@@ -977,15 +1015,15 @@
           /* `in' and `out' vector directions               */
 
           curr = first;
 
           /*
-           *  We abuse the `u' and `v' fields to store index deltas to the
-           *  next and previous non-near point, respectively.
+           * We abuse the `u' and `v' fields to store index deltas to the
+           * next and previous non-near point, respectively.
            *
-           *  To avoid problems with not having non-near points, we point to
-           *  `first' by default as the next non-near point.
+           * To avoid problems with not having non-near points, we point to
+           * `first' by default as the next non-near point.
            *
            */
           curr->u  = (FT_Pos)( first - curr );
           first->v = -curr->u;
 
@@ -1033,16 +1071,16 @@
 
           } while ( next != first );
         }
 
         /*
-         *  The next step is to `simplify' an outline's topology so that we
-         *  can identify local extrema more reliably: A series of
-         *  non-horizontal or non-vertical vectors pointing into the same
-         *  quadrant are handled as a single, long vector.  From a
-         *  topological point of the view, the intermediate points are of no
-         *  interest and thus tagged as weak.
+         * The next step is to `simplify' an outline's topology so that we
+         * can identify local extrema more reliably: A series of
+         * non-horizontal or non-vertical vectors pointing into the same
+         * quadrant are handled as a single, long vector.  From a
+         * topological point of the view, the intermediate points are of no
+         * interest and thus tagged as weak.
          */
 
         for ( point = points; point < point_limit; point++ )
         {
           if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
@@ -1078,13 +1116,13 @@
             }
           }
         }
 
         /*
-         *  Finally, check for remaining weak points.  Everything else not
-         *  collected in edges so far is then implicitly classified as strong
-         *  points.
+         * Finally, check for remaining weak points.  Everything else not
+         * collected in edges so far is then implicitly classified as strong
+         * points.
          */
 
         for ( point = points; point < point_limit; point++ )
         {
           if ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
@@ -1307,19 +1345,31 @@
         edge  = edges;
         delta = edge->fpos - u;
         if ( delta >= 0 )
         {
           u = edge->pos - ( edge->opos - ou );
+
+#ifdef FT_DEBUG_AUTOFIT
+          point->before[dim] = edge;
+          point->after[dim]  = NULL;
+#endif
+
           goto Store_Point;
         }
 
         /* is the point after the last edge? */
         edge  = edge_limit - 1;
         delta = u - edge->fpos;
         if ( delta >= 0 )
         {
           u = edge->pos + ( ou - edge->opos );
+
+#ifdef FT_DEBUG_AUTOFIT
+          point->before[dim] = NULL;
+          point->after[dim]  = edge;
+#endif
+
           goto Store_Point;
         }
 
         {
           FT_PtrDist  min, max, mid;
@@ -1362,20 +1412,31 @@
               min = mid + 1;
             else
             {
               /* we are on the edge */
               u = edge->pos;
+
+#ifdef FT_DEBUG_AUTOFIT
+              point->before[dim] = NULL;
+              point->after[dim]  = NULL;
+#endif
+
               goto Store_Point;
             }
           }
 
           /* point is not on an edge */
           {
             AF_Edge  before = edges + min - 1;
             AF_Edge  after  = edges + min + 0;
 
 
+#ifdef FT_DEBUG_AUTOFIT
+            point->before[dim] = before;
+            point->after[dim]  = after;
+#endif
+
             /* assert( before && after && before != after ) */
             if ( before->scale == 0 )
               before->scale = FT_DivFix( after->pos - before->pos,
                                          after->fpos - before->fpos );
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/psaux/cffdecode.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afmparse.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cffdecode.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/psaux/cffdecode.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,21 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  cffdecode.c                                                            */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    PostScript CFF (Type 2) decoding routines (body).                    */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2017-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_FREETYPE_H
  #include FT_INTERNAL_DEBUG_H
<span class="line-new-header">--- 1,21 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * cffdecode.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   PostScript CFF (Type 2) decoding routines (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2017-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_FREETYPE_H
  #include FT_INTERNAL_DEBUG_H
</pre>
<hr />
<pre>
<span class="line-old-header">*** 26,18 ***</span>
  #include &quot;psobjs.h&quot;
  
  #include &quot;psauxerr.h&quot;
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_cffdecode</span>
  
  
  #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
  
    typedef enum  CFF_Operator_
<span class="line-new-header">--- 26,18 ---</span>
  #include &quot;psobjs.h&quot;
  
  #include &quot;psauxerr.h&quot;
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  cffdecode</span>
  
  
  #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
  
    typedef enum  CFF_Operator_
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,12 ***</span>
      {
        FT_ERROR(( &quot;cff_operator_seac: invalid nested seac\n&quot; ));
        return FT_THROW( Syntax_Error );
      }
  
<span class="line-modified">!     adx += decoder-&gt;builder.left_bearing.x;</span>
<span class="line-modified">!     ady += decoder-&gt;builder.left_bearing.y;</span>
  
  #ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* Incremental fonts don&#39;t necessarily have valid charsets.        */
      /* They use the character code, not the glyph index, in this case. */
      if ( face-&gt;root.internal-&gt;incremental_interface )
<span class="line-new-header">--- 233,12 ---</span>
      {
        FT_ERROR(( &quot;cff_operator_seac: invalid nested seac\n&quot; ));
        return FT_THROW( Syntax_Error );
      }
  
<span class="line-modified">!     adx = ADD_LONG( adx, decoder-&gt;builder.left_bearing.x );</span>
<span class="line-modified">!     ady = ADD_LONG( ady, decoder-&gt;builder.left_bearing.y );</span>
  
  #ifdef FT_CONFIG_OPTION_INCREMENTAL
      /* Incremental fonts don&#39;t necessarily have valid charsets.        */
      /* They use the character code, not the glyph index, in this case. */
      if ( face-&gt;root.internal-&gt;incremental_interface )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 376,27 ***</span>
    /**********                                                      *********/
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    cff_compute_bias                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Computes the bias value in dependence of the number of glyph       */</span>
<span class="line-modified">!   /*    subroutines.                                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    in_charstring_type :: The `CharstringType&#39; value of the top DICT   */</span>
<span class="line-modified">!   /*                          dictionary.                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    num_subrs          :: The number of glyph subroutines.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    The bias value.                                                    */</span>
    static FT_Int
    cff_compute_bias( FT_Int   in_charstring_type,
                      FT_UInt  num_subrs )
    {
      FT_Int  result;
<span class="line-new-header">--- 376,30 ---</span>
    /**********                                                      *********/
    /*************************************************************************/
    /*************************************************************************/
    /*************************************************************************/
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   cff_compute_bias</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Computes the bias value in dependence of the number of glyph</span>
<span class="line-modified">!    *   subroutines.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   in_charstring_type ::</span>
<span class="line-modified">!    *     The `CharstringType&#39; value of the top DICT</span>
<span class="line-modified">!    *     dictionary.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   num_subrs ::</span>
<span class="line-modified">!    *     The number of glyph subroutines.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   The bias value.</span>
<span class="line-added">+    */</span>
    static FT_Int
    cff_compute_bias( FT_Int   in_charstring_type,
                      FT_UInt  num_subrs )
    {
      FT_Int  result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 462,32 ***</span>
    }
  
  
  #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    cff_decoder_parse_charstrings                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Parses a given Type 2 charstrings program.                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    decoder         :: The current Type 1 decoder.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    charstring_base :: The base of the charstring stream.              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    charstring_len  :: The length in bytes of the charstring stream.   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    in_dict         :: Set to 1 if function is called from top or      */</span>
<span class="line-modified">!   /*                       private DICT (needed for Multiple Master CFFs). */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    cff_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                   FT_Byte*      charstring_base,
                                   FT_ULong      charstring_len,
                                   FT_Bool       in_dict )
<span class="line-new-header">--- 465,36 ---</span>
    }
  
  
  #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   cff_decoder_parse_charstrings</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Parses a given Type 2 charstrings program.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   decoder ::</span>
<span class="line-modified">!    *     The current Type 1 decoder.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   charstring_base ::</span>
<span class="line-modified">!    *     The base of the charstring stream.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   charstring_len ::</span>
<span class="line-modified">!    *     The length in bytes of the charstring stream.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   in_dict ::</span>
<span class="line-modified">!    *     Set to 1 if function is called from top or</span>
<span class="line-modified">!    *     private DICT (needed for Multiple Master CFFs).</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    cff_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                   FT_Byte*      charstring_base,
                                   FT_ULong      charstring_len,
                                   FT_Bool       in_dict )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 541,14 ***</span>
      {
        CFF_Operator  op;
        FT_Byte       v;
  
  
<span class="line-modified">!       /********************************************************************/</span>
<span class="line-modified">!       /*                                                                  */</span>
<span class="line-modified">!       /* Decode operator or operand                                       */</span>
<span class="line-modified">!       /*                                                                  */</span>
        v = *ip++;
        if ( v &gt;= 32 || v == 28 )
        {
          FT_Int    shift = 16;
          FT_Int32  val;
<span class="line-new-header">--- 548,14 ---</span>
      {
        CFF_Operator  op;
        FT_Byte       v;
  
  
<span class="line-modified">!       /*********************************************************************</span>
<span class="line-modified">!        *</span>
<span class="line-modified">!        * Decode operator or operand</span>
<span class="line-modified">!        */</span>
        v = *ip++;
        if ( v &gt;= 32 || v == 28 )
        {
          FT_Int    shift = 16;
          FT_Int32  val;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 851,10 ***</span>
<span class="line-new-header">--- 858,19 ---</span>
            case cff_op_flex:
            case cff_op_hflex1:
            case cff_op_flex1:
            case cff_op_callsubr:
            case cff_op_callgsubr:
<span class="line-added">+             /* deprecated opcodes */</span>
<span class="line-added">+           case cff_op_dotsection:</span>
<span class="line-added">+             /* invalid Type 1 opcodes */</span>
<span class="line-added">+           case cff_op_hsbw:</span>
<span class="line-added">+           case cff_op_closepath:</span>
<span class="line-added">+           case cff_op_callothersubr:</span>
<span class="line-added">+           case cff_op_seac:</span>
<span class="line-added">+           case cff_op_sbw:</span>
<span class="line-added">+           case cff_op_setcurrentpoint:</span>
              goto MM_Error;
  
            default:
              break;
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 946,14 ***</span>
          case cff_op_hstem:
          case cff_op_vstem:
          case cff_op_hstemhm:
          case cff_op_vstemhm:
            /* the number of arguments is always even here */
<span class="line-modified">!           FT_TRACE4((</span>
<span class="line-modified">!               op == cff_op_hstem   ? &quot; hstem\n&quot;   :</span>
<span class="line-modified">!             ( op == cff_op_vstem   ? &quot; vstem\n&quot;   :</span>
<span class="line-modified">!             ( op == cff_op_hstemhm ? &quot; hstemhm\n&quot; : &quot; vstemhm\n&quot; ) ) ));</span>
  
            if ( hinter )
              hinter-&gt;stems( hinter-&gt;hints,
                             ( op == cff_op_hstem || op == cff_op_hstemhm ),
                             num_args / 2,
<span class="line-new-header">--- 962,14 ---</span>
          case cff_op_hstem:
          case cff_op_vstem:
          case cff_op_hstemhm:
          case cff_op_vstemhm:
            /* the number of arguments is always even here */
<span class="line-modified">!           FT_TRACE4(( &quot;%s\n&quot;,</span>
<span class="line-modified">!               op == cff_op_hstem   ? &quot; hstem&quot;   :</span>
<span class="line-modified">!             ( op == cff_op_vstem   ? &quot; vstem&quot;   :</span>
<span class="line-modified">!             ( op == cff_op_hstemhm ? &quot; hstemhm&quot; : &quot; vstemhm&quot; ) ) ));</span>
  
            if ( hinter )
              hinter-&gt;stems( hinter-&gt;hints,
                             ( op == cff_op_hstem || op == cff_op_hstemhm ),
                             num_args / 2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 963,11 ***</span>
            args = stack;
            break;
  
          case cff_op_hintmask:
          case cff_op_cntrmask:
<span class="line-modified">!           FT_TRACE4(( op == cff_op_hintmask ? &quot; hintmask&quot; : &quot; cntrmask&quot; ));</span>
  
            /* implement vstem when needed --                        */
            /* the specification doesn&#39;t say it, but this also works */
            /* with the &#39;cntrmask&#39; operator                          */
            /*                                                       */
<span class="line-new-header">--- 979,12 ---</span>
            args = stack;
            break;
  
          case cff_op_hintmask:
          case cff_op_cntrmask:
<span class="line-modified">!           FT_TRACE4(( &quot;%s&quot;, op == cff_op_hintmask ? &quot; hintmask&quot;</span>
<span class="line-added">+                                                   : &quot; cntrmask&quot; ));</span>
  
            /* implement vstem when needed --                        */
            /* the specification doesn&#39;t say it, but this also works */
            /* with the &#39;cntrmask&#39; operator                          */
            /*                                                       */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1076,12 ***</span>
          case cff_op_vlineto:
            {
              FT_Int  phase = ( op == cff_op_hlineto );
  
  
<span class="line-modified">!             FT_TRACE4(( op == cff_op_hlineto ? &quot; hlineto\n&quot;</span>
<span class="line-modified">!                                              : &quot; vlineto\n&quot; ));</span>
  
              if ( num_args &lt; 0 )
                goto Stack_Underflow;
  
              /* there exist subsetted fonts (found in PDFs) */
<span class="line-new-header">--- 1093,12 ---</span>
          case cff_op_vlineto:
            {
              FT_Int  phase = ( op == cff_op_hlineto );
  
  
<span class="line-modified">!             FT_TRACE4(( &quot;%s\n&quot;, op == cff_op_hlineto ? &quot; hlineto&quot;</span>
<span class="line-modified">!                                                      : &quot; vlineto&quot; ));</span>
  
              if ( num_args &lt; 0 )
                goto Stack_Underflow;
  
              /* there exist subsetted fonts (found in PDFs) */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1248,12 ***</span>
            {
              FT_Int  phase;
              FT_Int  nargs;
  
  
<span class="line-modified">!             FT_TRACE4(( op == cff_op_vhcurveto ? &quot; vhcurveto\n&quot;</span>
<span class="line-modified">!                                                : &quot; hvcurveto\n&quot; ));</span>
  
              if ( cff_builder_start_point( builder, x, y ) )
                goto Fail;
  
              if ( num_args &lt; 4 )
<span class="line-new-header">--- 1265,12 ---</span>
            {
              FT_Int  phase;
              FT_Int  nargs;
  
  
<span class="line-modified">!             FT_TRACE4(( &quot;%s\n&quot;, op == cff_op_vhcurveto ? &quot; vhcurveto&quot;</span>
<span class="line-modified">!                                                        : &quot; hvcurveto&quot; ));</span>
  
              if ( cff_builder_start_point( builder, x, y ) )
                goto Fail;
  
              if ( num_args &lt; 4 )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1537,23 ***</span>
                dy    = ADD_LONG( dy, temp[1] );
                temp += 2;
              }
  
              if ( dx &lt; 0 )
<span class="line-modified">!               dx = -dx;</span>
              if ( dy &lt; 0 )
<span class="line-modified">!               dy = -dy;</span>
  
              /* strange test, but here it is... */
              horizontal = ( dx &gt; dy );
  
              for ( count = 5; count &gt; 0; count-- )
              {
                x = ADD_LONG( x, args[0] );
                y = ADD_LONG( y, args[1] );
                cff_builder_add_point( builder, x, y,
<span class="line-modified">!                                      (FT_Bool)( count == 3 ) );</span>
                args += 2;
              }
  
              /* is last operand an x- or y-delta? */
              if ( horizontal )
<span class="line-new-header">--- 1554,23 ---</span>
                dy    = ADD_LONG( dy, temp[1] );
                temp += 2;
              }
  
              if ( dx &lt; 0 )
<span class="line-modified">!               dx = NEG_LONG( dx );</span>
              if ( dy &lt; 0 )
<span class="line-modified">!               dy = NEG_LONG( dy );</span>
  
              /* strange test, but here it is... */
              horizontal = ( dx &gt; dy );
  
              for ( count = 5; count &gt; 0; count-- )
              {
                x = ADD_LONG( x, args[0] );
                y = ADD_LONG( y, args[1] );
                cff_builder_add_point( builder, x, y,
<span class="line-modified">!                                      FT_BOOL( count == 3 ) );</span>
                args += 2;
              }
  
              /* is last operand an x- or y-delta? */
              if ( horizontal )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1587,11 ***</span>
              for ( count = 6; count &gt; 0; count-- )
              {
                x = ADD_LONG( x, args[0] );
                y = ADD_LONG( y, args[1] );
                cff_builder_add_point( builder, x, y,
<span class="line-modified">!                                      (FT_Bool)( count == 4 || count == 1 ) );</span>
                args += 2;
              }
  
              args = stack;
            }
<span class="line-new-header">--- 1604,11 ---</span>
              for ( count = 6; count &gt; 0; count-- )
              {
                x = ADD_LONG( x, args[0] );
                y = ADD_LONG( y, args[1] );
                cff_builder_add_point( builder, x, y,
<span class="line-modified">!                                      FT_BOOL( count == 4 || count == 1 ) );</span>
                args += 2;
              }
  
              args = stack;
            }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1703,20 ***</span>
            args[0] = -args[0];
            args++;
            break;
  
          case cff_op_random:
<span class="line-modified">!           FT_TRACE4(( &quot; random\n&quot; ));</span>
  
<span class="line-removed">-           /* only use the lower 16 bits of `random&#39;  */</span>
<span class="line-removed">-           /* to generate a number in the range (0;1] */</span>
<span class="line-removed">-           args[0] = (FT_Fixed)</span>
<span class="line-removed">-                       ( ( decoder-&gt;current_subfont-&gt;random &amp; 0xFFFF ) + 1 );</span>
<span class="line-removed">-           args++;</span>
  
<span class="line-modified">!           decoder-&gt;current_subfont-&gt;random =</span>
<span class="line-modified">!             cff_random( decoder-&gt;current_subfont-&gt;random );</span>
            break;
  
          case cff_op_mul:
            FT_TRACE4(( &quot; mul\n&quot; ));
  
<span class="line-new-header">--- 1720,24 ---</span>
            args[0] = -args[0];
            args++;
            break;
  
          case cff_op_random:
<span class="line-modified">!           {</span>
<span class="line-added">+             FT_UInt32*  randval = in_dict ? &amp;decoder-&gt;cff-&gt;top_font.random</span>
<span class="line-added">+                                           : &amp;decoder-&gt;current_subfont-&gt;random;</span>
  
  
<span class="line-modified">!             FT_TRACE4(( &quot; random\n&quot; ));</span>
<span class="line-modified">! </span>
<span class="line-added">+             /* only use the lower 16 bits of `random&#39;  */</span>
<span class="line-added">+             /* to generate a number in the range (0;1] */</span>
<span class="line-added">+             args[0] = (FT_Fixed)( ( *randval &amp; 0xFFFF ) + 1 );</span>
<span class="line-added">+             args++;</span>
<span class="line-added">+ </span>
<span class="line-added">+             *randval = cff_random( *randval );</span>
<span class="line-added">+           }</span>
            break;
  
          case cff_op_mul:
            FT_TRACE4(( &quot; mul\n&quot; ));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1725,11 ***</span>
            break;
  
          case cff_op_sqrt:
            FT_TRACE4(( &quot; sqrt\n&quot; ));
  
<span class="line-modified">!           if ( args[0] &gt; 0 )</span>
            {
              FT_Fixed  root = args[0];
              FT_Fixed  new_root;
  
  
<span class="line-new-header">--- 1746,14 ---</span>
            break;
  
          case cff_op_sqrt:
            FT_TRACE4(( &quot; sqrt\n&quot; ));
  
<span class="line-modified">!           /* without upper limit the loop below might not finish */</span>
<span class="line-added">+           if ( args[0] &gt; 0x7FFFFFFFL )</span>
<span class="line-added">+             args[0] = 46341;</span>
<span class="line-added">+           else if ( args[0] &gt; 0 )</span>
            {
              FT_Fixed  root = args[0];
              FT_Fixed  new_root;
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1798,10 ***</span>
<span class="line-new-header">--- 1822,11 ---</span>
              if ( args &lt; stack )
                goto Stack_Underflow;
  
              if ( idx &gt;= 0 )
              {
<span class="line-added">+               idx = idx % count;</span>
                while ( idx &gt; 0 )
                {
                  FT_Fixed  tmp = args[count - 1];
                  FT_Int    i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1812,10 ***</span>
<span class="line-new-header">--- 1837,14 ---</span>
                  idx--;
                }
              }
              else
              {
<span class="line-added">+               /* before C99 it is implementation-defined whether    */</span>
<span class="line-added">+               /* the result of `%&#39; is negative if the first operand */</span>
<span class="line-added">+               /* is negative                                        */</span>
<span class="line-added">+               idx = -( NEG_INT( idx ) % count );</span>
                while ( idx &lt; 0 )
                {
                  FT_Fixed  tmp = args[0];
                  FT_Int    i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1912,28 ***</span>
            break;
  
          case cff_op_blend:
            /* this operator was removed from the Type2 specification */
            /* in version 16-March-2000                               */
            {
              FT_Int  num_results = (FT_Int)( args[0] &gt;&gt; 16 );
  
  
              FT_TRACE4(( &quot; blend\n&quot; ));
  
              if ( num_results &lt; 0 )
                goto Syntax_Error;
  
<span class="line-modified">!             if ( num_results * (FT_Int)num_designs &gt; num_args )</span>
                goto Stack_Underflow;
  
              /* since we currently don&#39;t handle interpolation of multiple */
              /* master fonts, return the `num_results&#39; values of the      */
              /* first master                                              */
              args     -= num_results * ( num_designs - 1 );
              num_args -= num_results * ( num_designs - 1 );
            }
            break;
  
          case cff_op_dotsection:
            /* this operator is deprecated and ignored by the parser */
            FT_TRACE4(( &quot; dotsection\n&quot; ));
<span class="line-new-header">--- 1941,32 ---</span>
            break;
  
          case cff_op_blend:
            /* this operator was removed from the Type2 specification */
            /* in version 16-March-2000                               */
<span class="line-added">+           if ( num_designs )</span>
            {
              FT_Int  num_results = (FT_Int)( args[0] &gt;&gt; 16 );
  
  
              FT_TRACE4(( &quot; blend\n&quot; ));
  
              if ( num_results &lt; 0 )
                goto Syntax_Error;
  
<span class="line-modified">!             if ( num_results &gt; num_args                       ||</span>
<span class="line-added">+                  num_results * (FT_Int)num_designs &gt; num_args )</span>
                goto Stack_Underflow;
  
              /* since we currently don&#39;t handle interpolation of multiple */
              /* master fonts, return the `num_results&#39; values of the      */
              /* first master                                              */
              args     -= num_results * ( num_designs - 1 );
              num_args -= num_results * ( num_designs - 1 );
            }
<span class="line-added">+           else</span>
<span class="line-added">+             goto Syntax_Error;</span>
            break;
  
          case cff_op_dotsection:
            /* this operator is deprecated and ignored by the parser */
            FT_TRACE4(( &quot; dotsection\n&quot; ));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1996,24 ***</span>
            y    = ADD_LONG( decoder-&gt;builder.pos_y, args[1] );
            args = stack;
            break;
  
          case cff_op_callothersubr:
<span class="line-modified">!           /* this is an invalid Type 2 operator; however, there        */</span>
<span class="line-modified">!           /* exist fonts which are incorrectly converted from probably */</span>
<span class="line-removed">-           /* Type 1 to CFF, and some parsers seem to accept it         */</span>
  
<span class="line-removed">-           FT_TRACE4(( &quot; callothersubr (invalid op)\n&quot; ));</span>
  
<span class="line-modified">!           /* subsequent `pop&#39; operands should add the arguments,       */</span>
<span class="line-modified">!           /* this is the implementation described for `unknown&#39; other  */</span>
<span class="line-modified">!           /* subroutines in the Type1 spec.                            */</span>
<span class="line-modified">!           /*                                                           */</span>
<span class="line-modified">!           /* XXX Fix return arguments (see discussion below).          */</span>
<span class="line-modified">!           args -= 2 + ( args[-2] &gt;&gt; 16 );</span>
<span class="line-modified">!           if ( args &lt; stack )</span>
<span class="line-modified">!             goto Stack_Underflow;</span>
            break;
  
          case cff_op_pop:
            /* this is an invalid Type 2 operator; however, there        */
            /* exist fonts which are incorrectly converted from probably */
<span class="line-new-header">--- 2029,35 ---</span>
            y    = ADD_LONG( decoder-&gt;builder.pos_y, args[1] );
            args = stack;
            break;
  
          case cff_op_callothersubr:
<span class="line-modified">!           {</span>
<span class="line-modified">!             FT_Fixed  arg;</span>
  
  
<span class="line-modified">!             /* this is an invalid Type 2 operator; however, there      */</span>
<span class="line-modified">!             /* exist fonts which are incorrectly converted from        */</span>
<span class="line-modified">!             /* probably Type 1 to CFF, and some parsers seem to accept */</span>
<span class="line-modified">!             /* it                                                      */</span>
<span class="line-modified">! </span>
<span class="line-modified">!             FT_TRACE4(( &quot; callothersubr (invalid op)\n&quot; ));</span>
<span class="line-modified">! </span>
<span class="line-modified">!             /* subsequent `pop&#39; operands should add the arguments,     */</span>
<span class="line-added">+             /* this is the implementation described for `unknown&#39;      */</span>
<span class="line-added">+             /* other subroutines in the Type1 spec.                    */</span>
<span class="line-added">+             /*                                                         */</span>
<span class="line-added">+             /* XXX Fix return arguments (see discussion below).        */</span>
<span class="line-added">+ </span>
<span class="line-added">+             arg = 2 + ( args[-2] &gt;&gt; 16 );</span>
<span class="line-added">+             if ( arg &gt;= CFF_MAX_OPERANDS )</span>
<span class="line-added">+               goto Stack_Underflow;</span>
<span class="line-added">+ </span>
<span class="line-added">+             args -= arg;</span>
<span class="line-added">+             if ( args &lt; stack )</span>
<span class="line-added">+               goto Stack_Underflow;</span>
<span class="line-added">+           }</span>
            break;
  
          case cff_op_pop:
            /* this is an invalid Type 2 operator; however, there        */
            /* exist fonts which are incorrectly converted from probably */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2249,32 ***</span>
    }
  
  #endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    cff_decoder_init                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Initializes a given glyph decoder.                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    decoder :: A pointer to the glyph builder to initialize.           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    face      :: The current face object.                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    size      :: The current size object.                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    slot      :: The current glyph object.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    hinting   :: Whether hinting is active.                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    hint_mode :: The hinting mode.                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( void )
    cff_decoder_init( CFF_Decoder*                     decoder,
                      TT_Face                          face,
                      CFF_Size                         size,
                      CFF_GlyphSlot                    slot,
<span class="line-new-header">--- 2293,38 ---</span>
    }
  
  #endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   cff_decoder_init</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Initializes a given glyph decoder.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   decoder ::</span>
<span class="line-modified">!    *     A pointer to the glyph builder to initialize.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The current face object.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   size ::</span>
<span class="line-modified">!    *     The current size object.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   slot ::</span>
<span class="line-modified">!    *     The current glyph object.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    *   hinting ::</span>
<span class="line-added">+    *     Whether hinting is active.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   hint_mode ::</span>
<span class="line-added">+    *     The hinting mode.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( void )
    cff_decoder_init( CFF_Decoder*                     decoder,
                      TT_Face                          face,
                      CFF_Size                         size,
                      CFF_GlyphSlot                    slot,
</pre>
<center><a href="afmparse.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cffdecode.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
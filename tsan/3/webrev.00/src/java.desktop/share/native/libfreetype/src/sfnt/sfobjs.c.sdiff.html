<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="sferrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="sfobjs.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  sfobjs.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    SFNT object management (base).                                       */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;sfobjs.h&quot;
  21 #include &quot;ttload.h&quot;
  22 #include &quot;ttcmap.h&quot;
  23 #include &quot;ttkern.h&quot;

  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_INTERNAL_DEBUG_H
  26 #include FT_TRUETYPE_IDS_H
  27 #include FT_TRUETYPE_TAGS_H
  28 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  29 #include FT_SFNT_NAMES_H
<span class="line-removed">  30 #include FT_GZIP_H</span>
  31 
  32 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  33 #include FT_SERVICE_MULTIPLE_MASTERS_H
  34 #include FT_SERVICE_METRICS_VARIATIONS_H
  35 #endif
  36 
  37 #include &quot;sferrors.h&quot;
  38 
  39 #ifdef TT_CONFIG_OPTION_BDF
  40 #include &quot;ttbdf.h&quot;
  41 #endif
  42 
  43 
<span class="line-modified">  44   /*************************************************************************/</span>
<span class="line-modified">  45   /*                                                                       */</span>
<span class="line-modified">  46   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  47   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  48   /* messages during execution.                                            */</span>
<span class="line-modified">  49   /*                                                                       */</span>
  50 #undef  FT_COMPONENT
<span class="line-modified">  51 #define FT_COMPONENT  trace_sfobjs</span>
  52 
  53 
  54 
  55   /* convert a UTF-16 name entry to ASCII */
  56   static FT_String*
  57   tt_name_ascii_from_utf16( TT_Name    entry,
  58                             FT_Memory  memory )
  59   {
  60     FT_String*  string = NULL;
  61     FT_UInt     len, code, n;
  62     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  63     FT_Error    error;
  64 
  65 
  66     len = (FT_UInt)entry-&gt;stringLength / 2;
  67 
  68     if ( FT_NEW_ARRAY( string, len + 1 ) )
  69       return NULL;
  70 
  71     for ( n = 0; n &lt; len; n++ )
</pre>
<hr />
<pre>
 320     const TEncoding  *cur, *limit;
 321 
 322 
 323     cur   = tt_encodings;
 324     limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );
 325 
 326     for ( ; cur &lt; limit; cur++ )
 327     {
 328       if ( cur-&gt;platform_id == platform_id )
 329       {
 330         if ( cur-&gt;encoding_id == encoding_id ||
 331              cur-&gt;encoding_id == -1          )
 332           return cur-&gt;encoding;
 333       }
 334     }
 335 
 336     return FT_ENCODING_NONE;
 337   }
 338 
 339 
<span class="line-removed"> 340 #define WRITE_USHORT( p, v )                \</span>
<span class="line-removed"> 341           do                                \</span>
<span class="line-removed"> 342           {                                 \</span>
<span class="line-removed"> 343             *(p)++ = (FT_Byte)( (v) &gt;&gt; 8 ); \</span>
<span class="line-removed"> 344             *(p)++ = (FT_Byte)( (v) &gt;&gt; 0 ); \</span>
<span class="line-removed"> 345                                             \</span>
<span class="line-removed"> 346           } while ( 0 )</span>
<span class="line-removed"> 347 </span>
<span class="line-removed"> 348 #define WRITE_ULONG( p, v )                  \</span>
<span class="line-removed"> 349           do                                 \</span>
<span class="line-removed"> 350           {                                  \</span>
<span class="line-removed"> 351             *(p)++ = (FT_Byte)( (v) &gt;&gt; 24 ); \</span>
<span class="line-removed"> 352             *(p)++ = (FT_Byte)( (v) &gt;&gt; 16 ); \</span>
<span class="line-removed"> 353             *(p)++ = (FT_Byte)( (v) &gt;&gt;  8 ); \</span>
<span class="line-removed"> 354             *(p)++ = (FT_Byte)( (v) &gt;&gt;  0 ); \</span>
<span class="line-removed"> 355                                              \</span>
<span class="line-removed"> 356           } while ( 0 )</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358 </span>
<span class="line-removed"> 359   static void</span>
<span class="line-removed"> 360   sfnt_stream_close( FT_Stream  stream )</span>
<span class="line-removed"> 361   {</span>
<span class="line-removed"> 362     FT_Memory  memory = stream-&gt;memory;</span>
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365     FT_FREE( stream-&gt;base );</span>
<span class="line-removed"> 366 </span>
<span class="line-removed"> 367     stream-&gt;size  = 0;</span>
<span class="line-removed"> 368     stream-&gt;base  = NULL;</span>
<span class="line-removed"> 369     stream-&gt;close = NULL;</span>
<span class="line-removed"> 370   }</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372 </span>
<span class="line-removed"> 373   FT_CALLBACK_DEF( int )</span>
<span class="line-removed"> 374   compare_offsets( const void*  a,</span>
<span class="line-removed"> 375                    const void*  b )</span>
<span class="line-removed"> 376   {</span>
<span class="line-removed"> 377     WOFF_Table  table1 = *(WOFF_Table*)a;</span>
<span class="line-removed"> 378     WOFF_Table  table2 = *(WOFF_Table*)b;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380     FT_ULong  offset1 = table1-&gt;Offset;</span>
<span class="line-removed"> 381     FT_ULong  offset2 = table2-&gt;Offset;</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383 </span>
<span class="line-removed"> 384     if ( offset1 &gt; offset2 )</span>
<span class="line-removed"> 385       return 1;</span>
<span class="line-removed"> 386     else if ( offset1 &lt; offset2 )</span>
<span class="line-removed"> 387       return -1;</span>
<span class="line-removed"> 388     else</span>
<span class="line-removed"> 389       return 0;</span>
<span class="line-removed"> 390   }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393   /* Replace `face-&gt;root.stream&#39; with a stream containing the extracted */</span>
<span class="line-removed"> 394   /* SFNT of a WOFF font.                                               */</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   static FT_Error</span>
<span class="line-removed"> 397   woff_open_font( FT_Stream  stream,</span>
<span class="line-removed"> 398                   TT_Face    face )</span>
<span class="line-removed"> 399   {</span>
<span class="line-removed"> 400     FT_Memory       memory = stream-&gt;memory;</span>
<span class="line-removed"> 401     FT_Error        error  = FT_Err_Ok;</span>
<span class="line-removed"> 402 </span>
<span class="line-removed"> 403     WOFF_HeaderRec  woff;</span>
<span class="line-removed"> 404     WOFF_Table      tables  = NULL;</span>
<span class="line-removed"> 405     WOFF_Table*     indices = NULL;</span>
<span class="line-removed"> 406 </span>
<span class="line-removed"> 407     FT_ULong        woff_offset;</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409     FT_Byte*        sfnt        = NULL;</span>
<span class="line-removed"> 410     FT_Stream       sfnt_stream = NULL;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412     FT_Byte*        sfnt_header;</span>
<span class="line-removed"> 413     FT_ULong        sfnt_offset;</span>
<span class="line-removed"> 414 </span>
<span class="line-removed"> 415     FT_Int          nn;</span>
<span class="line-removed"> 416     FT_ULong        old_tag = 0;</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418     static const FT_Frame_Field  woff_header_fields[] =</span>
<span class="line-removed"> 419     {</span>
<span class="line-removed"> 420 #undef  FT_STRUCTURE</span>
<span class="line-removed"> 421 #define FT_STRUCTURE  WOFF_HeaderRec</span>
<span class="line-removed"> 422 </span>
<span class="line-removed"> 423       FT_FRAME_START( 44 ),</span>
<span class="line-removed"> 424         FT_FRAME_ULONG ( signature ),</span>
<span class="line-removed"> 425         FT_FRAME_ULONG ( flavor ),</span>
<span class="line-removed"> 426         FT_FRAME_ULONG ( length ),</span>
<span class="line-removed"> 427         FT_FRAME_USHORT( num_tables ),</span>
<span class="line-removed"> 428         FT_FRAME_USHORT( reserved ),</span>
<span class="line-removed"> 429         FT_FRAME_ULONG ( totalSfntSize ),</span>
<span class="line-removed"> 430         FT_FRAME_USHORT( majorVersion ),</span>
<span class="line-removed"> 431         FT_FRAME_USHORT( minorVersion ),</span>
<span class="line-removed"> 432         FT_FRAME_ULONG ( metaOffset ),</span>
<span class="line-removed"> 433         FT_FRAME_ULONG ( metaLength ),</span>
<span class="line-removed"> 434         FT_FRAME_ULONG ( metaOrigLength ),</span>
<span class="line-removed"> 435         FT_FRAME_ULONG ( privOffset ),</span>
<span class="line-removed"> 436         FT_FRAME_ULONG ( privLength ),</span>
<span class="line-removed"> 437       FT_FRAME_END</span>
<span class="line-removed"> 438     };</span>
<span class="line-removed"> 439 </span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441     FT_ASSERT( stream == face-&gt;root.stream );</span>
<span class="line-removed"> 442     FT_ASSERT( FT_STREAM_POS() == 0 );</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444     if ( FT_STREAM_READ_FIELDS( woff_header_fields, &amp;woff ) )</span>
<span class="line-removed"> 445       return error;</span>
<span class="line-removed"> 446 </span>
<span class="line-removed"> 447     /* Make sure we don&#39;t recurse back here or hit TTC code. */</span>
<span class="line-removed"> 448     if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )</span>
<span class="line-removed"> 449       return FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 450 </span>
<span class="line-removed"> 451     /* Miscellaneous checks. */</span>
<span class="line-removed"> 452     if ( woff.length != stream-&gt;size                              ||</span>
<span class="line-removed"> 453          woff.num_tables == 0                                     ||</span>
<span class="line-removed"> 454          44 + woff.num_tables * 20UL &gt;= woff.length               ||</span>
<span class="line-removed"> 455          12 + woff.num_tables * 16UL &gt;= woff.totalSfntSize        ||</span>
<span class="line-removed"> 456          ( woff.totalSfntSize &amp; 3 ) != 0                          ||</span>
<span class="line-removed"> 457          ( woff.metaOffset == 0 &amp;&amp; ( woff.metaLength != 0     ||</span>
<span class="line-removed"> 458                                      woff.metaOrigLength != 0 ) ) ||</span>
<span class="line-removed"> 459          ( woff.metaLength != 0 &amp;&amp; woff.metaOrigLength == 0 )     ||</span>
<span class="line-removed"> 460          ( woff.privOffset == 0 &amp;&amp; woff.privLength != 0 )         )</span>
<span class="line-removed"> 461     {</span>
<span class="line-removed"> 462       FT_ERROR(( &quot;woff_font_open: invalid WOFF header\n&quot; ));</span>
<span class="line-removed"> 463       return FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 464     }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466     /* Don&#39;t trust `totalSfntSize&#39; before thorough checks. */</span>
<span class="line-removed"> 467     if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||</span>
<span class="line-removed"> 468          FT_NEW( sfnt_stream )                         )</span>
<span class="line-removed"> 469       goto Exit;</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471     sfnt_header = sfnt;</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473     /* Write sfnt header. */</span>
<span class="line-removed"> 474     {</span>
<span class="line-removed"> 475       FT_UInt  searchRange, entrySelector, rangeShift, x;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477 </span>
<span class="line-removed"> 478       x             = woff.num_tables;</span>
<span class="line-removed"> 479       entrySelector = 0;</span>
<span class="line-removed"> 480       while ( x )</span>
<span class="line-removed"> 481       {</span>
<span class="line-removed"> 482         x            &gt;&gt;= 1;</span>
<span class="line-removed"> 483         entrySelector += 1;</span>
<span class="line-removed"> 484       }</span>
<span class="line-removed"> 485       entrySelector--;</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487       searchRange = ( 1 &lt;&lt; entrySelector ) * 16;</span>
<span class="line-removed"> 488       rangeShift  = woff.num_tables * 16 - searchRange;</span>
<span class="line-removed"> 489 </span>
<span class="line-removed"> 490       WRITE_ULONG ( sfnt_header, woff.flavor );</span>
<span class="line-removed"> 491       WRITE_USHORT( sfnt_header, woff.num_tables );</span>
<span class="line-removed"> 492       WRITE_USHORT( sfnt_header, searchRange );</span>
<span class="line-removed"> 493       WRITE_USHORT( sfnt_header, entrySelector );</span>
<span class="line-removed"> 494       WRITE_USHORT( sfnt_header, rangeShift );</span>
<span class="line-removed"> 495     }</span>
<span class="line-removed"> 496 </span>
<span class="line-removed"> 497     /* While the entries in the sfnt header must be sorted by the */</span>
<span class="line-removed"> 498     /* tag value, the tables themselves are not.  We thus have to */</span>
<span class="line-removed"> 499     /* sort them by offset and check that they don&#39;t overlap.     */</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||</span>
<span class="line-removed"> 502          FT_NEW_ARRAY( indices, woff.num_tables ) )</span>
<span class="line-removed"> 503       goto Exit;</span>
<span class="line-removed"> 504 </span>
<span class="line-removed"> 505     FT_TRACE2(( &quot;\n&quot;</span>
<span class="line-removed"> 506                 &quot;  tag    offset    compLen  origLen  checksum\n&quot;</span>
<span class="line-removed"> 507                 &quot;  -------------------------------------------\n&quot; ));</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509     if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )</span>
<span class="line-removed"> 510       goto Exit;</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 513     {</span>
<span class="line-removed"> 514       WOFF_Table  table = tables + nn;</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516       table-&gt;Tag        = FT_GET_TAG4();</span>
<span class="line-removed"> 517       table-&gt;Offset     = FT_GET_ULONG();</span>
<span class="line-removed"> 518       table-&gt;CompLength = FT_GET_ULONG();</span>
<span class="line-removed"> 519       table-&gt;OrigLength = FT_GET_ULONG();</span>
<span class="line-removed"> 520       table-&gt;CheckSum   = FT_GET_ULONG();</span>
<span class="line-removed"> 521 </span>
<span class="line-removed"> 522       FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n&quot;,</span>
<span class="line-removed"> 523                   (FT_Char)( table-&gt;Tag &gt;&gt; 24 ),</span>
<span class="line-removed"> 524                   (FT_Char)( table-&gt;Tag &gt;&gt; 16 ),</span>
<span class="line-removed"> 525                   (FT_Char)( table-&gt;Tag &gt;&gt; 8  ),</span>
<span class="line-removed"> 526                   (FT_Char)( table-&gt;Tag       ),</span>
<span class="line-removed"> 527                   table-&gt;Offset,</span>
<span class="line-removed"> 528                   table-&gt;CompLength,</span>
<span class="line-removed"> 529                   table-&gt;OrigLength,</span>
<span class="line-removed"> 530                   table-&gt;CheckSum ));</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532       if ( table-&gt;Tag &lt;= old_tag )</span>
<span class="line-removed"> 533       {</span>
<span class="line-removed"> 534         FT_FRAME_EXIT();</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536         FT_ERROR(( &quot;woff_font_open: table tags are not sorted\n&quot; ));</span>
<span class="line-removed"> 537         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 538         goto Exit;</span>
<span class="line-removed"> 539       }</span>
<span class="line-removed"> 540 </span>
<span class="line-removed"> 541       old_tag     = table-&gt;Tag;</span>
<span class="line-removed"> 542       indices[nn] = table;</span>
<span class="line-removed"> 543     }</span>
<span class="line-removed"> 544 </span>
<span class="line-removed"> 545     FT_FRAME_EXIT();</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547     /* Sort by offset. */</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549     ft_qsort( indices,</span>
<span class="line-removed"> 550               woff.num_tables,</span>
<span class="line-removed"> 551               sizeof ( WOFF_Table ),</span>
<span class="line-removed"> 552               compare_offsets );</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554     /* Check offsets and lengths. */</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     woff_offset = 44 + woff.num_tables * 20L;</span>
<span class="line-removed"> 557     sfnt_offset = 12 + woff.num_tables * 16L;</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 560     {</span>
<span class="line-removed"> 561       WOFF_Table  table = indices[nn];</span>
<span class="line-removed"> 562 </span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564       if ( table-&gt;Offset != woff_offset                         ||</span>
<span class="line-removed"> 565            table-&gt;CompLength &gt; woff.length                      ||</span>
<span class="line-removed"> 566            table-&gt;Offset &gt; woff.length - table-&gt;CompLength      ||</span>
<span class="line-removed"> 567            table-&gt;OrigLength &gt; woff.totalSfntSize               ||</span>
<span class="line-removed"> 568            sfnt_offset &gt; woff.totalSfntSize - table-&gt;OrigLength ||</span>
<span class="line-removed"> 569            table-&gt;CompLength &gt; table-&gt;OrigLength                )</span>
<span class="line-removed"> 570       {</span>
<span class="line-removed"> 571         FT_ERROR(( &quot;woff_font_open: invalid table offsets\n&quot; ));</span>
<span class="line-removed"> 572         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 573         goto Exit;</span>
<span class="line-removed"> 574       }</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576       table-&gt;OrigOffset = sfnt_offset;</span>
<span class="line-removed"> 577 </span>
<span class="line-removed"> 578       /* The offsets must be multiples of 4. */</span>
<span class="line-removed"> 579       woff_offset += ( table-&gt;CompLength + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 580       sfnt_offset += ( table-&gt;OrigLength + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 581     }</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     /*</span>
<span class="line-removed"> 584      * Final checks!</span>
<span class="line-removed"> 585      *</span>
<span class="line-removed"> 586      * We don&#39;t decode and check the metadata block.</span>
<span class="line-removed"> 587      * We don&#39;t check table checksums either.</span>
<span class="line-removed"> 588      * But other than those, I think we implement all</span>
<span class="line-removed"> 589      * `MUST&#39; checks from the spec.</span>
<span class="line-removed"> 590      */</span>
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592     if ( woff.metaOffset )</span>
<span class="line-removed"> 593     {</span>
<span class="line-removed"> 594       if ( woff.metaOffset != woff_offset                  ||</span>
<span class="line-removed"> 595            woff.metaOffset + woff.metaLength &gt; woff.length )</span>
<span class="line-removed"> 596       {</span>
<span class="line-removed"> 597         FT_ERROR(( &quot;woff_font_open:&quot;</span>
<span class="line-removed"> 598                    &quot; invalid `metadata&#39; offset or length\n&quot; ));</span>
<span class="line-removed"> 599         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 600         goto Exit;</span>
<span class="line-removed"> 601       }</span>
<span class="line-removed"> 602 </span>
<span class="line-removed"> 603       /* We have padding only ... */</span>
<span class="line-removed"> 604       woff_offset += woff.metaLength;</span>
<span class="line-removed"> 605     }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607     if ( woff.privOffset )</span>
<span class="line-removed"> 608     {</span>
<span class="line-removed"> 609       /* ... if it isn&#39;t the last block. */</span>
<span class="line-removed"> 610       woff_offset = ( woff_offset + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612       if ( woff.privOffset != woff_offset                  ||</span>
<span class="line-removed"> 613            woff.privOffset + woff.privLength &gt; woff.length )</span>
<span class="line-removed"> 614       {</span>
<span class="line-removed"> 615         FT_ERROR(( &quot;woff_font_open: invalid `private&#39; offset or length\n&quot; ));</span>
<span class="line-removed"> 616         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 617         goto Exit;</span>
<span class="line-removed"> 618       }</span>
<span class="line-removed"> 619 </span>
<span class="line-removed"> 620       /* No padding for the last block. */</span>
<span class="line-removed"> 621       woff_offset += woff.privLength;</span>
<span class="line-removed"> 622     }</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624     if ( sfnt_offset != woff.totalSfntSize ||</span>
<span class="line-removed"> 625          woff_offset != woff.length        )</span>
<span class="line-removed"> 626     {</span>
<span class="line-removed"> 627       FT_ERROR(( &quot;woff_font_open: invalid `sfnt&#39; table structure\n&quot; ));</span>
<span class="line-removed"> 628       error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 629       goto Exit;</span>
<span class="line-removed"> 630     }</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632     /* Now use `totalSfntSize&#39;. */</span>
<span class="line-removed"> 633     if ( FT_REALLOC( sfnt,</span>
<span class="line-removed"> 634                      12 + woff.num_tables * 16UL,</span>
<span class="line-removed"> 635                      woff.totalSfntSize ) )</span>
<span class="line-removed"> 636       goto Exit;</span>
<span class="line-removed"> 637 </span>
<span class="line-removed"> 638     sfnt_header = sfnt + 12;</span>
<span class="line-removed"> 639 </span>
<span class="line-removed"> 640     /* Write the tables. */</span>
<span class="line-removed"> 641 </span>
<span class="line-removed"> 642     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 643     {</span>
<span class="line-removed"> 644       WOFF_Table  table = tables + nn;</span>
<span class="line-removed"> 645 </span>
<span class="line-removed"> 646 </span>
<span class="line-removed"> 647       /* Write SFNT table entry. */</span>
<span class="line-removed"> 648       WRITE_ULONG( sfnt_header, table-&gt;Tag );</span>
<span class="line-removed"> 649       WRITE_ULONG( sfnt_header, table-&gt;CheckSum );</span>
<span class="line-removed"> 650       WRITE_ULONG( sfnt_header, table-&gt;OrigOffset );</span>
<span class="line-removed"> 651       WRITE_ULONG( sfnt_header, table-&gt;OrigLength );</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653       /* Write table data. */</span>
<span class="line-removed"> 654       if ( FT_STREAM_SEEK( table-&gt;Offset )     ||</span>
<span class="line-removed"> 655            FT_FRAME_ENTER( table-&gt;CompLength ) )</span>
<span class="line-removed"> 656         goto Exit;</span>
<span class="line-removed"> 657 </span>
<span class="line-removed"> 658       if ( table-&gt;CompLength == table-&gt;OrigLength )</span>
<span class="line-removed"> 659       {</span>
<span class="line-removed"> 660         /* Uncompressed data; just copy. */</span>
<span class="line-removed"> 661         ft_memcpy( sfnt + table-&gt;OrigOffset,</span>
<span class="line-removed"> 662                    stream-&gt;cursor,</span>
<span class="line-removed"> 663                    table-&gt;OrigLength );</span>
<span class="line-removed"> 664       }</span>
<span class="line-removed"> 665       else</span>
<span class="line-removed"> 666       {</span>
<span class="line-removed"> 667 #ifdef FT_CONFIG_OPTION_USE_ZLIB</span>
<span class="line-removed"> 668 </span>
<span class="line-removed"> 669         /* Uncompress with zlib. */</span>
<span class="line-removed"> 670         FT_ULong  output_len = table-&gt;OrigLength;</span>
<span class="line-removed"> 671 </span>
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673         error = FT_Gzip_Uncompress( memory,</span>
<span class="line-removed"> 674                                     sfnt + table-&gt;OrigOffset, &amp;output_len,</span>
<span class="line-removed"> 675                                     stream-&gt;cursor, table-&gt;CompLength );</span>
<span class="line-removed"> 676         if ( error )</span>
<span class="line-removed"> 677           goto Exit;</span>
<span class="line-removed"> 678         if ( output_len != table-&gt;OrigLength )</span>
<span class="line-removed"> 679         {</span>
<span class="line-removed"> 680           FT_ERROR(( &quot;woff_font_open: compressed table length mismatch\n&quot; ));</span>
<span class="line-removed"> 681           error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 682           goto Exit;</span>
<span class="line-removed"> 683         }</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685 #else /* !FT_CONFIG_OPTION_USE_ZLIB */</span>
<span class="line-removed"> 686 </span>
<span class="line-removed"> 687         error = FT_THROW( Unimplemented_Feature );</span>
<span class="line-removed"> 688         goto Exit;</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690 #endif /* !FT_CONFIG_OPTION_USE_ZLIB */</span>
<span class="line-removed"> 691       }</span>
<span class="line-removed"> 692 </span>
<span class="line-removed"> 693       FT_FRAME_EXIT();</span>
<span class="line-removed"> 694 </span>
<span class="line-removed"> 695       /* We don&#39;t check whether the padding bytes in the WOFF file are     */</span>
<span class="line-removed"> 696       /* actually &#39;\0&#39;.  For the output, however, we do set them properly. */</span>
<span class="line-removed"> 697       sfnt_offset = table-&gt;OrigOffset + table-&gt;OrigLength;</span>
<span class="line-removed"> 698       while ( sfnt_offset &amp; 3 )</span>
<span class="line-removed"> 699       {</span>
<span class="line-removed"> 700         sfnt[sfnt_offset] = &#39;\0&#39;;</span>
<span class="line-removed"> 701         sfnt_offset++;</span>
<span class="line-removed"> 702       }</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705     /* Ok!  Finally ready.  Swap out stream and return. */</span>
<span class="line-removed"> 706     FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );</span>
<span class="line-removed"> 707     sfnt_stream-&gt;memory = stream-&gt;memory;</span>
<span class="line-removed"> 708     sfnt_stream-&gt;close  = sfnt_stream_close;</span>
<span class="line-removed"> 709 </span>
<span class="line-removed"> 710     FT_Stream_Free(</span>
<span class="line-removed"> 711       face-&gt;root.stream,</span>
<span class="line-removed"> 712       ( face-&gt;root.face_flags &amp; FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714     face-&gt;root.stream = sfnt_stream;</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716     face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_EXTERNAL_STREAM;</span>
<span class="line-removed"> 717 </span>
<span class="line-removed"> 718   Exit:</span>
<span class="line-removed"> 719     FT_FREE( tables );</span>
<span class="line-removed"> 720     FT_FREE( indices );</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722     if ( error )</span>
<span class="line-removed"> 723     {</span>
<span class="line-removed"> 724       FT_FREE( sfnt );</span>
<span class="line-removed"> 725       FT_Stream_Close( sfnt_stream );</span>
<span class="line-removed"> 726       FT_FREE( sfnt_stream );</span>
<span class="line-removed"> 727     }</span>
<span class="line-removed"> 728 </span>
<span class="line-removed"> 729     return error;</span>
<span class="line-removed"> 730   }</span>
<span class="line-removed"> 731 </span>
<span class="line-removed"> 732 </span>
<span class="line-removed"> 733 #undef WRITE_USHORT</span>
<span class="line-removed"> 734 #undef WRITE_ULONG</span>
<span class="line-removed"> 735 </span>
<span class="line-removed"> 736 </span>
 737   /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */
 738   /* synthesized into a TTC with one offset table.              */
 739   static FT_Error
 740   sfnt_open_font( FT_Stream  stream,
 741                   TT_Face    face )
 742   {
 743     FT_Memory  memory = stream-&gt;memory;
 744     FT_Error   error;
 745     FT_ULong   tag, offset;
 746 
 747     static const FT_Frame_Field  ttc_header_fields[] =
 748     {
 749 #undef  FT_STRUCTURE
 750 #define FT_STRUCTURE  TTC_HeaderRec
 751 
 752       FT_FRAME_START( 8 ),
 753         FT_FRAME_LONG( version ),
 754         FT_FRAME_LONG( count   ),  /* this is ULong in the specs */
 755       FT_FRAME_END
 756     };
</pre>
<hr />
<pre>
 901       /* we want the metrics variations interface */
 902       /* from the `truetype&#39; module only          */
 903       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 904 
 905 
 906       face-&gt;var = ft_module_get_service( tt_module,
 907                                          FT_SERVICE_ID_METRICS_VARIATIONS,
 908                                          0 );
 909     }
 910 #endif
 911 
 912     FT_TRACE2(( &quot;SFNT driver\n&quot; ));
 913 
 914     error = sfnt_open_font( stream, face );
 915     if ( error )
 916       return error;
 917 
 918     /* Stream may have changed in sfnt_open_font. */
 919     stream = face-&gt;root.stream;
 920 
<span class="line-modified"> 921     FT_TRACE2(( &quot;sfnt_init_face: %08p, %d\n&quot;, face, face_instance_index ));</span>


 922 
 923     face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;
 924 
 925     /* value -(N+1) requests information on index N */
 926     if ( face_instance_index &lt; 0 )
 927       face_index--;
 928 
 929     if ( face_index &gt;= face-&gt;ttc_header.count )
 930     {
 931       if ( face_instance_index &gt;= 0 )
 932         return FT_THROW( Invalid_Argument );
 933       else
 934         face_index = 0;
 935     }
 936 
 937     if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )
 938       return error;
 939 
 940     /* check whether we have a valid TrueType file */
 941     error = sfnt-&gt;load_font_dir( face, stream );
</pre>
<hr />
<pre>
 984       }
 985 
 986       /* check that the data is bound by the table length */
 987       if ( version != 0x00010000UL                    ||
 988            axis_size != 20                            ||
 989            num_axes == 0                              ||
 990            /* `num_axes&#39; limit implied by 16-bit `instance_size&#39; */
 991            num_axes &gt; 0x3FFE                          ||
 992            !( instance_size == 4 + 4 * num_axes ||
 993               instance_size == 6 + 4 * num_axes )     ||
 994            /* `num_instances&#39; limit implied by limited range of name IDs */
 995            num_instances &gt; 0x7EFF                     ||
 996            offset                          +
 997              axis_size * num_axes          +
 998              instance_size * num_instances &gt; fvar_len )
 999         num_instances = 0;
1000       else
1001         face-&gt;variation_support |= TT_FACE_FLAG_VAR_FVAR;
1002 
1003       /*
<span class="line-modified">1004        *  As documented in the OpenType specification, an entry for the</span>
<span class="line-modified">1005        *  default instance may be omitted in the named instance table.  In</span>
<span class="line-modified">1006        *  particular this means that even if there is no named instance</span>
<span class="line-modified">1007        *  table in the font we actually do have a named instance, namely the</span>
<span class="line-modified">1008        *  default instance.</span>
1009        *
<span class="line-modified">1010        *  For consistency, we always want the default instance in our list</span>
<span class="line-modified">1011        *  of named instances.  If it is missing, we try to synthesize it</span>
<span class="line-modified">1012        *  later on.  Here, we have to adjust `num_instances&#39; accordingly.</span>
1013        */
1014 
1015       if ( ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR ) &amp;&amp;
1016            !( FT_ALLOC( default_values, num_axes * 4 )  ||
1017               FT_ALLOC( instance_values, num_axes * 4 ) )      )
1018       {
1019         /* the current stream position is 16 bytes after the table start */
1020         FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
1021         FT_ULong  default_value_offset, instance_offset;
1022 
1023         FT_Byte*  p;
1024         FT_UInt   i;
1025 
1026 
1027         default_value_offset = array_start + 8;
1028         p                    = default_values;
1029 
1030         for ( i = 0; i &lt; num_axes; i++ )
1031         {
1032           (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );
</pre>
<hr />
<pre>
1324           face-&gt;vertical_info = 1;
1325       }
1326 
1327       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
1328         goto Exit;
1329 
1330       LOAD_( os2 );
1331       if ( error )
1332       {
1333         /* we treat the table as missing if there are any errors */
1334         face-&gt;os2.version = 0xFFFFU;
1335       }
1336     }
1337 
1338     /* the optional tables */
1339 
1340     /* embedded bitmap support */
1341     if ( sfnt-&gt;load_eblc )
1342       LOAD_( eblc );
1343 







1344     /* consider the pclt, kerning, and gasp tables as optional */
1345     LOAD_( pclt );
1346     LOAD_( gasp );
1347     LOAD_( kern );
1348 
1349     face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;
1350 
1351     /* Bit 8 of the `fsSelection&#39; field in the `OS/2&#39; table denotes  */
1352     /* a WWS-only font face.  `WWS&#39; stands for `weight&#39;, width&#39;, and */
1353     /* `slope&#39;, a term used by Microsoft&#39;s Windows Presentation      */
1354     /* Foundation (WPF).  This flag has been introduced in version   */
1355     /* 1.5 of the OpenType specification (May 2008).                 */
1356 
1357     face-&gt;root.family_name = NULL;
1358     face-&gt;root.style_name  = NULL;
1359     if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )
1360     {
1361       if ( !ignore_typographic_family )
1362         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1363       if ( !face-&gt;root.family_name )
</pre>
<hr />
<pre>
1372     {
1373       GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );
1374       if ( !face-&gt;root.family_name &amp;&amp; !ignore_typographic_family )
1375         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1376       if ( !face-&gt;root.family_name )
1377         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
1378 
1379       GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );
1380       if ( !face-&gt;root.style_name &amp;&amp; !ignore_typographic_subfamily )
1381         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
1382       if ( !face-&gt;root.style_name )
1383         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
1384     }
1385 
1386     /* now set up root fields */
1387     {
1388       FT_Face  root  = &amp;face-&gt;root;
1389       FT_Long  flags = root-&gt;face_flags;
1390 
1391 
<span class="line-modified">1392       /*********************************************************************/</span>
<span class="line-modified">1393       /*                                                                   */</span>
<span class="line-modified">1394       /* Compute face flags.                                               */</span>
<span class="line-modified">1395       /*                                                                   */</span>
1396       if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
<span class="line-modified">1397            face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )</span>

1398         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
1399 
1400       if ( has_outline == TRUE )
1401         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
1402 
1403       /* The sfnt driver only supports bitmap fonts natively, thus we */
1404       /* don&#39;t set FT_FACE_FLAG_HINTER.                               */
1405       flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */
1406                FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */
1407 
1408 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1409       if ( !psnames_error                             &amp;&amp;
1410            face-&gt;postscript.FormatType != 0x00030000L )
1411         flags |= FT_FACE_FLAG_GLYPH_NAMES;
1412 #endif
1413 
1414       /* fixed width font? */
1415       if ( face-&gt;postscript.isFixedPitch )
1416         flags |= FT_FACE_FLAG_FIXED_WIDTH;
1417 
</pre>
<hr />
<pre>
1421 
1422       /* kerning available ? */
1423       if ( TT_FACE_HAS_KERNING( face ) )
1424         flags |= FT_FACE_FLAG_KERNING;
1425 
1426 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1427       /* Don&#39;t bother to load the tables unless somebody asks for them. */
1428       /* No need to do work which will (probably) not be used.          */
1429       if ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR )
1430       {
1431         if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;
1432              tt_face_lookup_table( face, TTAG_gvar ) != 0 )
1433           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1434         if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )
1435           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1436       }
1437 #endif
1438 
1439       root-&gt;face_flags = flags;
1440 
<span class="line-modified">1441       /*********************************************************************/</span>
<span class="line-modified">1442       /*                                                                   */</span>
<span class="line-modified">1443       /* Compute style flags.                                              */</span>
<span class="line-modified">1444       /*                                                                   */</span>
1445 
1446       flags = 0;
1447       if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )
1448       {
1449         /* We have an OS/2 table; use the `fsSelection&#39; field.  Bit 9 */
1450         /* indicates an oblique font face.  This flag has been        */
1451         /* introduced in version 1.5 of the OpenType specification.   */
1452 
1453         if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */
1454           flags |= FT_STYLE_FLAG_ITALIC;
1455         else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */
1456           flags |= FT_STYLE_FLAG_ITALIC;
1457 
1458         if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */
1459           flags |= FT_STYLE_FLAG_BOLD;
1460       }
1461       else
1462       {
1463         /* this is an old Mac font, use the header field */
1464 
1465         if ( face-&gt;header.Mac_Style &amp; 1 )
1466           flags |= FT_STYLE_FLAG_BOLD;
1467 
1468         if ( face-&gt;header.Mac_Style &amp; 2 )
1469           flags |= FT_STYLE_FLAG_ITALIC;
1470       }
1471 
1472       root-&gt;style_flags |= flags;
1473 
<span class="line-modified">1474       /*********************************************************************/</span>
<span class="line-modified">1475       /*                                                                   */</span>
<span class="line-modified">1476       /* Polish the charmaps.                                              */</span>
<span class="line-modified">1477       /*                                                                   */</span>
<span class="line-modified">1478       /*   Try to set the charmap encoding according to the platform &amp;     */</span>
<span class="line-modified">1479       /*   encoding ID of each charmap.  Emulate Unicode charmap if one    */</span>
<span class="line-modified">1480       /*   is missing.                                                     */</span>
<span class="line-modified">1481       /*                                                                   */</span>
1482 
1483       tt_face_build_cmaps( face );  /* ignore errors */
1484 
1485 
1486       /* set the encoding fields */
1487       {
1488         FT_Int   m;
1489 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1490         FT_Bool  has_unicode = FALSE;
1491 #endif
1492 
1493 
1494         for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )
1495         {
1496           FT_CharMap  charmap = root-&gt;charmaps[m];
1497 
1498 
1499           charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,
1500                                                   charmap-&gt;encoding_id );
1501 
</pre>
<hr />
<pre>
1504           if ( charmap-&gt;encoding == FT_ENCODING_UNICODE   ||
1505                charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL )  /* PUA */
1506             has_unicode = TRUE;
1507         }
1508 
1509         /* synthesize Unicode charmap if one is missing */
1510         if ( !has_unicode )
1511         {
1512           FT_CharMapRec cmaprec;
1513 
1514 
1515           cmaprec.face        = root;
1516           cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
1517           cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
1518           cmaprec.encoding    = FT_ENCODING_UNICODE;
1519 
1520 
1521           error = FT_CMap_New( (FT_CMap_Class)&amp;tt_cmap_unicode_class_rec,
1522                                NULL, &amp;cmaprec, NULL );
1523           if ( error                                      &amp;&amp;
<span class="line-modified">1524                FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )</span>

1525             goto Exit;
1526           error = FT_Err_Ok;
1527 
1528 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
1529 
1530         }
1531       }
1532 
1533 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1534 
1535       /*
<span class="line-modified">1536        *  Now allocate the root array of FT_Bitmap_Size records and</span>
<span class="line-modified">1537        *  populate them.  Unfortunately, it isn&#39;t possible to indicate bit</span>
<span class="line-modified">1538        *  depths in the FT_Bitmap_Size record.  This is a design error.</span>
1539        */
1540       {
1541         FT_UInt  count;
1542 
1543 
1544         count = face-&gt;sbit_num_strikes;
1545 
1546         if ( count &gt; 0 )
1547         {
1548           FT_Memory        memory   = face-&gt;root.stream-&gt;memory;
1549           FT_UShort        em_size  = face-&gt;header.Units_Per_EM;
1550           FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;
1551           FT_Size_Metrics  metrics;
1552 
1553           FT_UInt*  sbit_strike_map = NULL;
1554           FT_UInt   strike_idx, bsize_idx;
1555 
1556 
1557           if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )
1558           {
</pre>
<hr />
<pre>
1598           /* from now on, all strike indices are mapped */
1599           /* using `sbit_strike_map&#39;                    */
1600           if ( bsize_idx )
1601           {
1602             face-&gt;sbit_strike_map = sbit_strike_map;
1603 
1604             root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;
1605             root-&gt;num_fixed_sizes = (FT_Int)bsize_idx;
1606           }
1607         }
1608       }
1609 
1610 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
1611 
1612       /* a font with no bitmaps and no outlines is scalable; */
1613       /* it has only empty glyphs then                       */
1614       if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )
1615         root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;
1616 
1617 
<span class="line-modified">1618       /*********************************************************************/</span>
<span class="line-modified">1619       /*                                                                   */</span>
<span class="line-modified">1620       /*  Set up metrics.                                                  */</span>
<span class="line-modified">1621       /*                                                                   */</span>
1622       if ( FT_IS_SCALABLE( root ) )
1623       {
1624         /* XXX What about if outline header is missing */
1625         /*     (e.g. sfnt wrapped bitmap)?             */
1626         root-&gt;bbox.xMin    = face-&gt;header.xMin;
1627         root-&gt;bbox.yMin    = face-&gt;header.yMin;
1628         root-&gt;bbox.xMax    = face-&gt;header.xMax;
1629         root-&gt;bbox.yMax    = face-&gt;header.yMax;
1630         root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;
1631 
1632 
<span class="line-modified">1633         /* XXX: Computing the ascender/descender/height is very different */</span>
<span class="line-modified">1634         /*      from what the specification tells you.  Apparently, we    */</span>
<span class="line-modified">1635         /*      must be careful because                                   */</span>
<span class="line-modified">1636         /*                                                                */</span>
<span class="line-modified">1637         /*      - not all fonts have an OS/2 table; in this case, we take */</span>
<span class="line-modified">1638         /*        the values in the horizontal header.  However, these    */</span>
<span class="line-modified">1639         /*        values very often are not reliable.                     */</span>
<span class="line-modified">1640         /*                                                                */</span>
<span class="line-modified">1641         /*      - otherwise, the correct typographic values are in the    */</span>
<span class="line-modified">1642         /*        sTypoAscender, sTypoDescender &amp; sTypoLineGap fields.    */</span>
<span class="line-modified">1643         /*                                                                */</span>
<span class="line-modified">1644         /*        However, certain fonts have these fields set to 0.      */</span>
<span class="line-modified">1645         /*        Rather, they have usWinAscent &amp; usWinDescent correctly  */</span>
<span class="line-modified">1646         /*        set (but with different values).                        */</span>
<span class="line-modified">1647         /*                                                                */</span>
<span class="line-modified">1648         /*      As an example, Arial Narrow is implemented through four   */</span>
<span class="line-modified">1649         /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF &amp; ARIALNBI.TTF */</span>
<span class="line-modified">1650         /*                                                                */</span>
<span class="line-modified">1651         /*      Strangely, all fonts have the same values in their        */</span>
<span class="line-modified">1652         /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */</span>
<span class="line-modified">1653         /*                                                                */</span>
<span class="line-modified">1654         /*      On the other hand, they all have different                */</span>
<span class="line-modified">1655         /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */</span>
<span class="line-modified">1656         /*      table cannot be used to compute the text height reliably! */</span>
<span class="line-modified">1657         /*                                                                */</span>
<span class="line-modified">1658 </span>
<span class="line-modified">1659         /* The ascender and descender are taken from the `hhea&#39; table. */</span>
<span class="line-modified">1660         /* If zero, they are taken from the `OS/2&#39; table.              */</span>
<span class="line-modified">1661 </span>
<span class="line-modified">1662         root-&gt;ascender  = face-&gt;horizontal.Ascender;</span>
<span class="line-modified">1663         root-&gt;descender = face-&gt;horizontal.Descender;</span>
<span class="line-modified">1664 </span>
<span class="line-modified">1665         root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1666                        face-&gt;horizontal.Line_Gap;</span>
<span class="line-modified">1667 </span>
<span class="line-modified">1668         if ( !( root-&gt;ascender || root-&gt;descender ) )</span>

1669         {
<span class="line-modified">1670           if ( face-&gt;os2.version != 0xFFFFU )</span>
<span class="line-modified">1671           {</span>
<span class="line-modified">1672             if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">1673             {</span>
<span class="line-modified">1674               root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1675               root-&gt;descender = face-&gt;os2.sTypoDescender;</span>





1676 
<span class="line-modified">1677               root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1678                              face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">1679             }</span>
<span class="line-removed">1680             else</span>
1681             {
<span class="line-modified">1682               root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-modified">1683               root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-modified">1684 </span>
<span class="line-modified">1685               root-&gt;height = root-&gt;ascender - root-&gt;descender;</span>









1686             }
1687           }
1688         }
1689 
1690         root-&gt;max_advance_width  =
1691           (FT_Short)face-&gt;horizontal.advance_Width_Max;
1692         root-&gt;max_advance_height =
1693           (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max
1694                                           : root-&gt;height );
1695 
1696         /* See https://www.microsoft.com/typography/otspec/post.htm -- */
1697         /* Adjust underline position from top edge to centre of        */
1698         /* stroke to convert TrueType meaning to FreeType meaning.     */
1699         root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1700                                     face-&gt;postscript.underlineThickness / 2;
1701         root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1702       }
1703 
1704     }
1705 
</pre>
<hr />
<pre>
1720   {
1721     FT_Memory     memory;
1722     SFNT_Service  sfnt;
1723 
1724 
1725     if ( !face )
1726       return;
1727 
1728     memory = face-&gt;root.memory;
1729     sfnt   = (SFNT_Service)face-&gt;sfnt;
1730 
1731     if ( sfnt )
1732     {
1733       /* destroy the postscript names table if it is loaded */
1734       if ( sfnt-&gt;free_psnames )
1735         sfnt-&gt;free_psnames( face );
1736 
1737       /* destroy the embedded bitmaps table if it is loaded */
1738       if ( sfnt-&gt;free_eblc )
1739         sfnt-&gt;free_eblc( face );







1740     }
1741 
1742 #ifdef TT_CONFIG_OPTION_BDF
1743     /* freeing the embedded BDF properties */
1744     tt_face_free_bdf_props( face );
1745 #endif
1746 
1747     /* freeing the kerning table */
1748     tt_face_done_kern( face );
1749 
1750     /* freeing the collection table */
1751     FT_FREE( face-&gt;ttc_header.offsets );
1752     face-&gt;ttc_header.count = 0;
1753 
1754     /* freeing table directory */
1755     FT_FREE( face-&gt;dir_tables );
1756     face-&gt;num_tables = 0;
1757 
1758     {
1759       FT_Stream  stream = FT_FACE_STREAM( face );
</pre>
<hr />
<pre>
1775       face-&gt;vertical_info = 0;
1776     }
1777 
1778     /* freeing the gasp table */
1779     FT_FREE( face-&gt;gasp.gaspRanges );
1780     face-&gt;gasp.numRanges = 0;
1781 
1782     /* freeing the name table */
1783     if ( sfnt )
1784       sfnt-&gt;free_name( face );
1785 
1786     /* freeing family and style name */
1787     FT_FREE( face-&gt;root.family_name );
1788     FT_FREE( face-&gt;root.style_name );
1789 
1790     /* freeing sbit size table */
1791     FT_FREE( face-&gt;root.available_sizes );
1792     FT_FREE( face-&gt;sbit_strike_map );
1793     face-&gt;root.num_fixed_sizes = 0;
1794 
<span class="line-removed">1795 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
1796     FT_FREE( face-&gt;postscript_name );


1797     FT_FREE( face-&gt;var_postscript_prefix );
1798 #endif
1799 






1800     face-&gt;sfnt = NULL;
1801   }
1802 
1803 
1804 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * sfobjs.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   SFNT object management (base).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;sfobjs.h&quot;
  21 #include &quot;ttload.h&quot;
  22 #include &quot;ttcmap.h&quot;
  23 #include &quot;ttkern.h&quot;
<span class="line-added">  24 #include &quot;sfwoff.h&quot;</span>
  25 #include FT_INTERNAL_SFNT_H
  26 #include FT_INTERNAL_DEBUG_H
  27 #include FT_TRUETYPE_IDS_H
  28 #include FT_TRUETYPE_TAGS_H
  29 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  30 #include FT_SFNT_NAMES_H

  31 
  32 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  33 #include FT_SERVICE_MULTIPLE_MASTERS_H
  34 #include FT_SERVICE_METRICS_VARIATIONS_H
  35 #endif
  36 
  37 #include &quot;sferrors.h&quot;
  38 
  39 #ifdef TT_CONFIG_OPTION_BDF
  40 #include &quot;ttbdf.h&quot;
  41 #endif
  42 
  43 
<span class="line-modified">  44   /**************************************************************************</span>
<span class="line-modified">  45    *</span>
<span class="line-modified">  46    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  47    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  48    * messages during execution.</span>
<span class="line-modified">  49    */</span>
  50 #undef  FT_COMPONENT
<span class="line-modified">  51 #define FT_COMPONENT  sfobjs</span>
  52 
  53 
  54 
  55   /* convert a UTF-16 name entry to ASCII */
  56   static FT_String*
  57   tt_name_ascii_from_utf16( TT_Name    entry,
  58                             FT_Memory  memory )
  59   {
  60     FT_String*  string = NULL;
  61     FT_UInt     len, code, n;
  62     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  63     FT_Error    error;
  64 
  65 
  66     len = (FT_UInt)entry-&gt;stringLength / 2;
  67 
  68     if ( FT_NEW_ARRAY( string, len + 1 ) )
  69       return NULL;
  70 
  71     for ( n = 0; n &lt; len; n++ )
</pre>
<hr />
<pre>
 320     const TEncoding  *cur, *limit;
 321 
 322 
 323     cur   = tt_encodings;
 324     limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );
 325 
 326     for ( ; cur &lt; limit; cur++ )
 327     {
 328       if ( cur-&gt;platform_id == platform_id )
 329       {
 330         if ( cur-&gt;encoding_id == encoding_id ||
 331              cur-&gt;encoding_id == -1          )
 332           return cur-&gt;encoding;
 333       }
 334     }
 335 
 336     return FT_ENCODING_NONE;
 337   }
 338 
 339 













































































































































































































































































































































































































 340   /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */
 341   /* synthesized into a TTC with one offset table.              */
 342   static FT_Error
 343   sfnt_open_font( FT_Stream  stream,
 344                   TT_Face    face )
 345   {
 346     FT_Memory  memory = stream-&gt;memory;
 347     FT_Error   error;
 348     FT_ULong   tag, offset;
 349 
 350     static const FT_Frame_Field  ttc_header_fields[] =
 351     {
 352 #undef  FT_STRUCTURE
 353 #define FT_STRUCTURE  TTC_HeaderRec
 354 
 355       FT_FRAME_START( 8 ),
 356         FT_FRAME_LONG( version ),
 357         FT_FRAME_LONG( count   ),  /* this is ULong in the specs */
 358       FT_FRAME_END
 359     };
</pre>
<hr />
<pre>
 504       /* we want the metrics variations interface */
 505       /* from the `truetype&#39; module only          */
 506       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 507 
 508 
 509       face-&gt;var = ft_module_get_service( tt_module,
 510                                          FT_SERVICE_ID_METRICS_VARIATIONS,
 511                                          0 );
 512     }
 513 #endif
 514 
 515     FT_TRACE2(( &quot;SFNT driver\n&quot; ));
 516 
 517     error = sfnt_open_font( stream, face );
 518     if ( error )
 519       return error;
 520 
 521     /* Stream may have changed in sfnt_open_font. */
 522     stream = face-&gt;root.stream;
 523 
<span class="line-modified"> 524     FT_TRACE2(( &quot;sfnt_init_face: %08p (index %d)\n&quot;,</span>
<span class="line-added"> 525                 face,</span>
<span class="line-added"> 526                 face_instance_index ));</span>
 527 
 528     face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;
 529 
 530     /* value -(N+1) requests information on index N */
 531     if ( face_instance_index &lt; 0 )
 532       face_index--;
 533 
 534     if ( face_index &gt;= face-&gt;ttc_header.count )
 535     {
 536       if ( face_instance_index &gt;= 0 )
 537         return FT_THROW( Invalid_Argument );
 538       else
 539         face_index = 0;
 540     }
 541 
 542     if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )
 543       return error;
 544 
 545     /* check whether we have a valid TrueType file */
 546     error = sfnt-&gt;load_font_dir( face, stream );
</pre>
<hr />
<pre>
 589       }
 590 
 591       /* check that the data is bound by the table length */
 592       if ( version != 0x00010000UL                    ||
 593            axis_size != 20                            ||
 594            num_axes == 0                              ||
 595            /* `num_axes&#39; limit implied by 16-bit `instance_size&#39; */
 596            num_axes &gt; 0x3FFE                          ||
 597            !( instance_size == 4 + 4 * num_axes ||
 598               instance_size == 6 + 4 * num_axes )     ||
 599            /* `num_instances&#39; limit implied by limited range of name IDs */
 600            num_instances &gt; 0x7EFF                     ||
 601            offset                          +
 602              axis_size * num_axes          +
 603              instance_size * num_instances &gt; fvar_len )
 604         num_instances = 0;
 605       else
 606         face-&gt;variation_support |= TT_FACE_FLAG_VAR_FVAR;
 607 
 608       /*
<span class="line-modified"> 609        * As documented in the OpenType specification, an entry for the</span>
<span class="line-modified"> 610        * default instance may be omitted in the named instance table.  In</span>
<span class="line-modified"> 611        * particular this means that even if there is no named instance</span>
<span class="line-modified"> 612        * table in the font we actually do have a named instance, namely the</span>
<span class="line-modified"> 613        * default instance.</span>
 614        *
<span class="line-modified"> 615        * For consistency, we always want the default instance in our list</span>
<span class="line-modified"> 616        * of named instances.  If it is missing, we try to synthesize it</span>
<span class="line-modified"> 617        * later on.  Here, we have to adjust `num_instances&#39; accordingly.</span>
 618        */
 619 
 620       if ( ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR ) &amp;&amp;
 621            !( FT_ALLOC( default_values, num_axes * 4 )  ||
 622               FT_ALLOC( instance_values, num_axes * 4 ) )      )
 623       {
 624         /* the current stream position is 16 bytes after the table start */
 625         FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
 626         FT_ULong  default_value_offset, instance_offset;
 627 
 628         FT_Byte*  p;
 629         FT_UInt   i;
 630 
 631 
 632         default_value_offset = array_start + 8;
 633         p                    = default_values;
 634 
 635         for ( i = 0; i &lt; num_axes; i++ )
 636         {
 637           (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );
</pre>
<hr />
<pre>
 929           face-&gt;vertical_info = 1;
 930       }
 931 
 932       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
 933         goto Exit;
 934 
 935       LOAD_( os2 );
 936       if ( error )
 937       {
 938         /* we treat the table as missing if there are any errors */
 939         face-&gt;os2.version = 0xFFFFU;
 940       }
 941     }
 942 
 943     /* the optional tables */
 944 
 945     /* embedded bitmap support */
 946     if ( sfnt-&gt;load_eblc )
 947       LOAD_( eblc );
 948 
<span class="line-added"> 949     /* colored glyph support */</span>
<span class="line-added"> 950     if ( sfnt-&gt;load_cpal )</span>
<span class="line-added"> 951     {</span>
<span class="line-added"> 952       LOAD_( cpal );</span>
<span class="line-added"> 953       LOAD_( colr );</span>
<span class="line-added"> 954     }</span>
<span class="line-added"> 955 </span>
 956     /* consider the pclt, kerning, and gasp tables as optional */
 957     LOAD_( pclt );
 958     LOAD_( gasp );
 959     LOAD_( kern );
 960 
 961     face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;
 962 
 963     /* Bit 8 of the `fsSelection&#39; field in the `OS/2&#39; table denotes  */
 964     /* a WWS-only font face.  `WWS&#39; stands for `weight&#39;, width&#39;, and */
 965     /* `slope&#39;, a term used by Microsoft&#39;s Windows Presentation      */
 966     /* Foundation (WPF).  This flag has been introduced in version   */
 967     /* 1.5 of the OpenType specification (May 2008).                 */
 968 
 969     face-&gt;root.family_name = NULL;
 970     face-&gt;root.style_name  = NULL;
 971     if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )
 972     {
 973       if ( !ignore_typographic_family )
 974         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
 975       if ( !face-&gt;root.family_name )
</pre>
<hr />
<pre>
 984     {
 985       GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );
 986       if ( !face-&gt;root.family_name &amp;&amp; !ignore_typographic_family )
 987         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
 988       if ( !face-&gt;root.family_name )
 989         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
 990 
 991       GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );
 992       if ( !face-&gt;root.style_name &amp;&amp; !ignore_typographic_subfamily )
 993         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
 994       if ( !face-&gt;root.style_name )
 995         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
 996     }
 997 
 998     /* now set up root fields */
 999     {
1000       FT_Face  root  = &amp;face-&gt;root;
1001       FT_Long  flags = root-&gt;face_flags;
1002 
1003 
<span class="line-modified">1004       /**********************************************************************</span>
<span class="line-modified">1005        *</span>
<span class="line-modified">1006        * Compute face flags.</span>
<span class="line-modified">1007        */</span>
1008       if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
<span class="line-modified">1009            face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX ||</span>
<span class="line-added">1010            face-&gt;colr                                       )</span>
1011         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
1012 
1013       if ( has_outline == TRUE )
1014         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
1015 
1016       /* The sfnt driver only supports bitmap fonts natively, thus we */
1017       /* don&#39;t set FT_FACE_FLAG_HINTER.                               */
1018       flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */
1019                FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */
1020 
1021 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1022       if ( !psnames_error                             &amp;&amp;
1023            face-&gt;postscript.FormatType != 0x00030000L )
1024         flags |= FT_FACE_FLAG_GLYPH_NAMES;
1025 #endif
1026 
1027       /* fixed width font? */
1028       if ( face-&gt;postscript.isFixedPitch )
1029         flags |= FT_FACE_FLAG_FIXED_WIDTH;
1030 
</pre>
<hr />
<pre>
1034 
1035       /* kerning available ? */
1036       if ( TT_FACE_HAS_KERNING( face ) )
1037         flags |= FT_FACE_FLAG_KERNING;
1038 
1039 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1040       /* Don&#39;t bother to load the tables unless somebody asks for them. */
1041       /* No need to do work which will (probably) not be used.          */
1042       if ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR )
1043       {
1044         if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;
1045              tt_face_lookup_table( face, TTAG_gvar ) != 0 )
1046           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1047         if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )
1048           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1049       }
1050 #endif
1051 
1052       root-&gt;face_flags = flags;
1053 
<span class="line-modified">1054       /**********************************************************************</span>
<span class="line-modified">1055        *</span>
<span class="line-modified">1056        * Compute style flags.</span>
<span class="line-modified">1057        */</span>
1058 
1059       flags = 0;
1060       if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )
1061       {
1062         /* We have an OS/2 table; use the `fsSelection&#39; field.  Bit 9 */
1063         /* indicates an oblique font face.  This flag has been        */
1064         /* introduced in version 1.5 of the OpenType specification.   */
1065 
1066         if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */
1067           flags |= FT_STYLE_FLAG_ITALIC;
1068         else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */
1069           flags |= FT_STYLE_FLAG_ITALIC;
1070 
1071         if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */
1072           flags |= FT_STYLE_FLAG_BOLD;
1073       }
1074       else
1075       {
1076         /* this is an old Mac font, use the header field */
1077 
1078         if ( face-&gt;header.Mac_Style &amp; 1 )
1079           flags |= FT_STYLE_FLAG_BOLD;
1080 
1081         if ( face-&gt;header.Mac_Style &amp; 2 )
1082           flags |= FT_STYLE_FLAG_ITALIC;
1083       }
1084 
1085       root-&gt;style_flags |= flags;
1086 
<span class="line-modified">1087       /**********************************************************************</span>
<span class="line-modified">1088        *</span>
<span class="line-modified">1089        * Polish the charmaps.</span>
<span class="line-modified">1090        *</span>
<span class="line-modified">1091        *   Try to set the charmap encoding according to the platform &amp;</span>
<span class="line-modified">1092        *   encoding ID of each charmap.  Emulate Unicode charmap if one</span>
<span class="line-modified">1093        *   is missing.</span>
<span class="line-modified">1094        */</span>
1095 
1096       tt_face_build_cmaps( face );  /* ignore errors */
1097 
1098 
1099       /* set the encoding fields */
1100       {
1101         FT_Int   m;
1102 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1103         FT_Bool  has_unicode = FALSE;
1104 #endif
1105 
1106 
1107         for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )
1108         {
1109           FT_CharMap  charmap = root-&gt;charmaps[m];
1110 
1111 
1112           charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,
1113                                                   charmap-&gt;encoding_id );
1114 
</pre>
<hr />
<pre>
1117           if ( charmap-&gt;encoding == FT_ENCODING_UNICODE   ||
1118                charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL )  /* PUA */
1119             has_unicode = TRUE;
1120         }
1121 
1122         /* synthesize Unicode charmap if one is missing */
1123         if ( !has_unicode )
1124         {
1125           FT_CharMapRec cmaprec;
1126 
1127 
1128           cmaprec.face        = root;
1129           cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
1130           cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
1131           cmaprec.encoding    = FT_ENCODING_UNICODE;
1132 
1133 
1134           error = FT_CMap_New( (FT_CMap_Class)&amp;tt_cmap_unicode_class_rec,
1135                                NULL, &amp;cmaprec, NULL );
1136           if ( error                                      &amp;&amp;
<span class="line-modified">1137                FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &amp;&amp;</span>
<span class="line-added">1138                FT_ERR_NEQ( error, Unimplemented_Feature ) )</span>
1139             goto Exit;
1140           error = FT_Err_Ok;
1141 
1142 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
1143 
1144         }
1145       }
1146 
1147 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1148 
1149       /*
<span class="line-modified">1150        * Now allocate the root array of FT_Bitmap_Size records and</span>
<span class="line-modified">1151        * populate them.  Unfortunately, it isn&#39;t possible to indicate bit</span>
<span class="line-modified">1152        * depths in the FT_Bitmap_Size record.  This is a design error.</span>
1153        */
1154       {
1155         FT_UInt  count;
1156 
1157 
1158         count = face-&gt;sbit_num_strikes;
1159 
1160         if ( count &gt; 0 )
1161         {
1162           FT_Memory        memory   = face-&gt;root.stream-&gt;memory;
1163           FT_UShort        em_size  = face-&gt;header.Units_Per_EM;
1164           FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;
1165           FT_Size_Metrics  metrics;
1166 
1167           FT_UInt*  sbit_strike_map = NULL;
1168           FT_UInt   strike_idx, bsize_idx;
1169 
1170 
1171           if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )
1172           {
</pre>
<hr />
<pre>
1212           /* from now on, all strike indices are mapped */
1213           /* using `sbit_strike_map&#39;                    */
1214           if ( bsize_idx )
1215           {
1216             face-&gt;sbit_strike_map = sbit_strike_map;
1217 
1218             root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;
1219             root-&gt;num_fixed_sizes = (FT_Int)bsize_idx;
1220           }
1221         }
1222       }
1223 
1224 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
1225 
1226       /* a font with no bitmaps and no outlines is scalable; */
1227       /* it has only empty glyphs then                       */
1228       if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )
1229         root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;
1230 
1231 
<span class="line-modified">1232       /**********************************************************************</span>
<span class="line-modified">1233        *</span>
<span class="line-modified">1234        * Set up metrics.</span>
<span class="line-modified">1235        */</span>
1236       if ( FT_IS_SCALABLE( root ) )
1237       {
1238         /* XXX What about if outline header is missing */
1239         /*     (e.g. sfnt wrapped bitmap)?             */
1240         root-&gt;bbox.xMin    = face-&gt;header.xMin;
1241         root-&gt;bbox.yMin    = face-&gt;header.yMin;
1242         root-&gt;bbox.xMax    = face-&gt;header.xMax;
1243         root-&gt;bbox.yMax    = face-&gt;header.yMax;
1244         root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;
1245 
1246 
<span class="line-modified">1247         /*</span>
<span class="line-modified">1248          * Computing the ascender/descender/height is tricky.</span>
<span class="line-modified">1249          *</span>
<span class="line-modified">1250          * The OpenType specification v1.8.3 says:</span>
<span class="line-modified">1251          *</span>
<span class="line-modified">1252          *   [OS/2&#39;s] sTypoAscender, sTypoDescender and sTypoLineGap fields</span>
<span class="line-modified">1253          *   are intended to allow applications to lay out documents in a</span>
<span class="line-modified">1254          *   typographically-correct and portable fashion.</span>
<span class="line-modified">1255          *</span>
<span class="line-modified">1256          * This is somewhat at odds with the decades of backwards</span>
<span class="line-modified">1257          * compatibility, operating systems and applications doing whatever</span>
<span class="line-modified">1258          * they want, not to mention broken fonts.</span>
<span class="line-modified">1259          *</span>
<span class="line-modified">1260          * Not all fonts have an OS/2 table; in this case, we take the values</span>
<span class="line-modified">1261          * in the horizontal header, although there is nothing stopping the</span>
<span class="line-modified">1262          * values from being unreliable. Even with a OS/2 table, certain fonts</span>
<span class="line-modified">1263          * set the sTypoAscender, sTypoDescender and sTypoLineGap fields to 0</span>
<span class="line-modified">1264          * and instead correctly set usWinAscent and usWinDescent.</span>
<span class="line-modified">1265          *</span>
<span class="line-modified">1266          * As an example, Arial Narrow is shipped as four files ARIALN.TTF,</span>
<span class="line-modified">1267          * ARIALNI.TTF, ARIALNB.TTF and ARIALNBI.TTF. Strangely, all fonts have</span>
<span class="line-modified">1268          * the same values in their sTypo* fields, except ARIALNB.ttf which</span>
<span class="line-modified">1269          * sets them to 0. All of them have different usWinAscent/Descent</span>
<span class="line-modified">1270          * values. The OS/2 table therefore cannot be trusted for computing the</span>
<span class="line-modified">1271          * text height reliably.</span>
<span class="line-modified">1272          *</span>
<span class="line-modified">1273          * As a compromise, do the following:</span>
<span class="line-modified">1274          *</span>
<span class="line-modified">1275          * 1. If the OS/2 table exists and the fsSelection bit 7 is set</span>
<span class="line-modified">1276          *    (USE_TYPO_METRICS), trust the font and use the sTypo* metrics.</span>
<span class="line-modified">1277          * 2. Otherwise, use the `hhea&#39; table&#39;s metrics.</span>
<span class="line-modified">1278          * 3. If they are zero and the OS/2 table exists,</span>
<span class="line-modified">1279          *    1. use the OS/2 table&#39;s sTypo* metrics if they are non-zero.</span>
<span class="line-modified">1280          *    2. Otherwise, use the OS/2 table&#39;s usWin* metrics.</span>
<span class="line-modified">1281          */</span>
<span class="line-modified">1282 </span>
<span class="line-added">1283         if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 128 )</span>
1284         {
<span class="line-modified">1285           root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1286           root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-modified">1287           root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1288                             face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">1289         }</span>
<span class="line-modified">1290         else</span>
<span class="line-added">1291         {</span>
<span class="line-added">1292           root-&gt;ascender  = face-&gt;horizontal.Ascender;</span>
<span class="line-added">1293           root-&gt;descender = face-&gt;horizontal.Descender;</span>
<span class="line-added">1294           root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">1295                             face-&gt;horizontal.Line_Gap;</span>
1296 
<span class="line-modified">1297           if ( !( root-&gt;ascender || root-&gt;descender ) )</span>
<span class="line-modified">1298           {</span>
<span class="line-modified">1299             if ( face-&gt;os2.version != 0xFFFFU )</span>

1300             {
<span class="line-modified">1301               if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">1302               {</span>
<span class="line-modified">1303                 root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1304                 root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-added">1305                 root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">1306                                   face-&gt;os2.sTypoLineGap;</span>
<span class="line-added">1307               }</span>
<span class="line-added">1308               else</span>
<span class="line-added">1309               {</span>
<span class="line-added">1310                 root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-added">1311                 root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-added">1312                 root-&gt;height    =  root-&gt;ascender - root-&gt;descender;</span>
<span class="line-added">1313               }</span>
1314             }
1315           }
1316         }
1317 
1318         root-&gt;max_advance_width  =
1319           (FT_Short)face-&gt;horizontal.advance_Width_Max;
1320         root-&gt;max_advance_height =
1321           (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max
1322                                           : root-&gt;height );
1323 
1324         /* See https://www.microsoft.com/typography/otspec/post.htm -- */
1325         /* Adjust underline position from top edge to centre of        */
1326         /* stroke to convert TrueType meaning to FreeType meaning.     */
1327         root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1328                                     face-&gt;postscript.underlineThickness / 2;
1329         root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1330       }
1331 
1332     }
1333 
</pre>
<hr />
<pre>
1348   {
1349     FT_Memory     memory;
1350     SFNT_Service  sfnt;
1351 
1352 
1353     if ( !face )
1354       return;
1355 
1356     memory = face-&gt;root.memory;
1357     sfnt   = (SFNT_Service)face-&gt;sfnt;
1358 
1359     if ( sfnt )
1360     {
1361       /* destroy the postscript names table if it is loaded */
1362       if ( sfnt-&gt;free_psnames )
1363         sfnt-&gt;free_psnames( face );
1364 
1365       /* destroy the embedded bitmaps table if it is loaded */
1366       if ( sfnt-&gt;free_eblc )
1367         sfnt-&gt;free_eblc( face );
<span class="line-added">1368 </span>
<span class="line-added">1369       /* destroy color table data if it is loaded */</span>
<span class="line-added">1370       if ( sfnt-&gt;free_cpal )</span>
<span class="line-added">1371       {</span>
<span class="line-added">1372         sfnt-&gt;free_cpal( face );</span>
<span class="line-added">1373         sfnt-&gt;free_colr( face );</span>
<span class="line-added">1374       }</span>
1375     }
1376 
1377 #ifdef TT_CONFIG_OPTION_BDF
1378     /* freeing the embedded BDF properties */
1379     tt_face_free_bdf_props( face );
1380 #endif
1381 
1382     /* freeing the kerning table */
1383     tt_face_done_kern( face );
1384 
1385     /* freeing the collection table */
1386     FT_FREE( face-&gt;ttc_header.offsets );
1387     face-&gt;ttc_header.count = 0;
1388 
1389     /* freeing table directory */
1390     FT_FREE( face-&gt;dir_tables );
1391     face-&gt;num_tables = 0;
1392 
1393     {
1394       FT_Stream  stream = FT_FACE_STREAM( face );
</pre>
<hr />
<pre>
1410       face-&gt;vertical_info = 0;
1411     }
1412 
1413     /* freeing the gasp table */
1414     FT_FREE( face-&gt;gasp.gaspRanges );
1415     face-&gt;gasp.numRanges = 0;
1416 
1417     /* freeing the name table */
1418     if ( sfnt )
1419       sfnt-&gt;free_name( face );
1420 
1421     /* freeing family and style name */
1422     FT_FREE( face-&gt;root.family_name );
1423     FT_FREE( face-&gt;root.style_name );
1424 
1425     /* freeing sbit size table */
1426     FT_FREE( face-&gt;root.available_sizes );
1427     FT_FREE( face-&gt;sbit_strike_map );
1428     face-&gt;root.num_fixed_sizes = 0;
1429 

1430     FT_FREE( face-&gt;postscript_name );
<span class="line-added">1431 </span>
<span class="line-added">1432 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
1433     FT_FREE( face-&gt;var_postscript_prefix );
1434 #endif
1435 
<span class="line-added">1436     /* freeing glyph color palette data */</span>
<span class="line-added">1437     FT_FREE( face-&gt;palette_data.palette_name_ids );</span>
<span class="line-added">1438     FT_FREE( face-&gt;palette_data.palette_flags );</span>
<span class="line-added">1439     FT_FREE( face-&gt;palette_data.palette_entry_name_ids );</span>
<span class="line-added">1440     FT_FREE( face-&gt;palette );</span>
<span class="line-added">1441 </span>
1442     face-&gt;sfnt = NULL;
1443   }
1444 
1445 
1446 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="sferrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="sfobjs.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
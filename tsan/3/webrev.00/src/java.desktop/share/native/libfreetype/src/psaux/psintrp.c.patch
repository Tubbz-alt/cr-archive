diff a/src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c b/src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c
--- a/src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c
+++ b/src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c
@@ -1,41 +1,41 @@
-/***************************************************************************/
-/*                                                                         */
-/*  psintrp.c                                                              */
-/*                                                                         */
-/*    Adobe's CFF Interpreter (body).                                      */
-/*                                                                         */
-/*  Copyright 2007-2014 Adobe Systems Incorporated.                        */
-/*                                                                         */
-/*  This software, and all works of authorship, whether in source or       */
-/*  object code form as indicated by the copyright notice(s) included      */
-/*  herein (collectively, the "Work") is made available, and may only be   */
-/*  used, modified, and distributed under the FreeType Project License,    */
-/*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */
-/*  FreeType Project License, each contributor to the Work hereby grants   */
-/*  to any individual or legal entity exercising permissions granted by    */
-/*  the FreeType Project License and this section (hereafter, "You" or     */
-/*  "Your") a perpetual, worldwide, non-exclusive, no-charge,              */
-/*  royalty-free, irrevocable (except as stated in this section) patent    */
-/*  license to make, have made, use, offer to sell, sell, import, and      */
-/*  otherwise transfer the Work, where such license applies only to those  */
-/*  patent claims licensable by such contributor that are necessarily      */
-/*  infringed by their contribution(s) alone or by combination of their    */
-/*  contribution(s) with the Work to which such contribution(s) was        */
-/*  submitted.  If You institute patent litigation against any entity      */
-/*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */
-/*  the Work or a contribution incorporated within the Work constitutes    */
-/*  direct or contributory patent infringement, then any patent licenses   */
-/*  granted to You under this License for that Work shall terminate as of  */
-/*  the date such litigation is filed.                                     */
-/*                                                                         */
-/*  By using, modifying, or distributing the Work you indicate that you    */
-/*  have read and understood the terms and conditions of the               */
-/*  FreeType Project License as well as those provided in this section,    */
-/*  and you accept them fully.                                             */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * psintrp.c
+ *
+ *   Adobe's CFF Interpreter (body).
+ *
+ * Copyright 2007-2014 Adobe Systems Incorporated.
+ *
+ * This software, and all works of authorship, whether in source or
+ * object code form as indicated by the copyright notice(s) included
+ * herein (collectively, the "Work") is made available, and may only be
+ * used, modified, and distributed under the FreeType Project License,
+ * LICENSE.TXT.  Additionally, subject to the terms and conditions of the
+ * FreeType Project License, each contributor to the Work hereby grants
+ * to any individual or legal entity exercising permissions granted by
+ * the FreeType Project License and this section (hereafter, "You" or
+ * "Your") a perpetual, worldwide, non-exclusive, no-charge,
+ * royalty-free, irrevocable (except as stated in this section) patent
+ * license to make, have made, use, offer to sell, sell, import, and
+ * otherwise transfer the Work, where such license applies only to those
+ * patent claims licensable by such contributor that are necessarily
+ * infringed by their contribution(s) alone or by combination of their
+ * contribution(s) with the Work to which such contribution(s) was
+ * submitted.  If You institute patent litigation against any entity
+ * (including a cross-claim or counterclaim in a lawsuit) alleging that
+ * the Work or a contribution incorporated within the Work constitutes
+ * direct or contributory patent infringement, then any patent licenses
+ * granted to You under this License for that Work shall terminate as of
+ * the date such litigation is filed.
+ *
+ * By using, modifying, or distributing the Work you indicate that you
+ * have read and understood the terms and conditions of the
+ * FreeType Project License as well as those provided in this section,
+ * and you accept them fully.
+ *
+ */
 
 
 #include "psft.h"
 #include FT_INTERNAL_DEBUG_H
 #include FT_SERVICE_CFF_TABLE_LOAD_H
@@ -50,18 +50,18 @@
 
 #include "psobjs.h"   /* for cff_random */
 #include "t1decode.h" /* for t1 seac    */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_cf2interp
+#define FT_COMPONENT  cf2interp
 
 
   FT_LOCAL_DEF( void )
   cf2_hintmask_init( CF2_HintMask  hintmask,
                      FT_Error*     error )
@@ -285,11 +285,11 @@
                FT_Bool*        haveWidth,
                CF2_Fixed       hintOffset )
   {
     CF2_UInt  i;
     CF2_UInt  count       = cf2_stack_count( opStack );
-    FT_Bool   hasWidthArg = (FT_Bool)( count & 1 );
+    FT_Bool   hasWidthArg = FT_BOOL( count & 1 );
 
     /* variable accumulates delta values from operand stack */
     CF2_Fixed  position = hintOffset;
 
     if ( font->isT1 && !font->decoder->flex_state && !*haveWidth )
@@ -362,11 +362,11 @@
     if ( isHFlex )
       vals[9 + 2] = *curY;
 
     if ( doConditionalLastRead )
     {
-      FT_Bool    lastIsX = (FT_Bool)(
+      FT_Bool    lastIsX = FT_BOOL(
                              cf2_fixedAbs( SUB_INT32( vals[10], *curX ) ) >
                              cf2_fixedAbs( SUB_INT32( vals[11], *curY ) ) );
       CF2_Fixed  lastVal = cf2_stack_getReal( opStack, idx );
 
 
@@ -610,18 +610,18 @@
     /* Note: Caller owns and must finalize the first charstring.      */
     /*       Our copy of it does not change that requirement.         */
     cf2_arrstack_setCount( &subrStack, CF2_MAX_SUBR + 1 );
 
     charstring  = (CF2_Buffer)cf2_arrstack_getBuffer( &subrStack );
-    *charstring = *buf;    /* structure copy */
-
-    charstringIndex = 0;       /* entry is valid now */
 
     /* catch errors so far */
     if ( *error )
       goto exit;
 
+    *charstring     = *buf;    /* structure copy     */
+    charstringIndex = 0;       /* entry is valid now */
+
     /* main interpreter loop */
     while ( 1 )
     {
       if ( font->isT1 )
         FT_ASSERT( known_othersubr_result_cnt == 0 ||
@@ -661,10 +661,11 @@
                 op1 >= 32 /* Numbers */ ) )
         {
           /* Skip outline commands first time round.       */
           /* `endchar' will trigger initial hintmap build  */
           /* and rewind the charstring.                    */
+          FT_TRACE4(( " <outline command skipped>\n" ));
           cf2_stack_clear( opStack );
           continue;
         }
 
         if ( result_cnt > 0               &&
@@ -773,11 +774,12 @@
         }
         continue;     /* do not clear the stack */
 
       case cf2_cmdHSTEMHM:
       case cf2_cmdHSTEM:
-        FT_TRACE4(( op1 == cf2_cmdHSTEMHM ? " hstemhm\n" : " hstem\n" ));
+        FT_TRACE4(( "%s\n", op1 == cf2_cmdHSTEMHM ? " hstemhm"
+                                                  : " hstem" ));
 
         if ( !font->isT1 )
         {
           /* never add hints after the mask is computed */
           /* except if in Type 1 mode (no hintmask op)  */
@@ -803,11 +805,12 @@
 
         break;
 
       case cf2_cmdVSTEMHM:
       case cf2_cmdVSTEM:
-        FT_TRACE4(( op1 == cf2_cmdVSTEMHM ? " vstemhm\n" : " vstem\n" ));
+        FT_TRACE4(( "%s\n", op1 == cf2_cmdVSTEMHM ? " vstemhm"
+                                                  : " vstem" ));
 
         if ( !font->isT1 )
         {
           /* never add hints after the mask is computed */
           /* except if in Type 1 mode (no hintmask op)  */
@@ -886,11 +889,11 @@
           CF2_UInt  count = cf2_stack_count( opStack );
 
           FT_Bool  isX = FT_BOOL( op1 == cf2_cmdHLINETO );
 
 
-          FT_TRACE4(( isX ? " hlineto\n" : " vlineto\n" ));
+          FT_TRACE4(( "%s\n", isX ? " hlineto" : " vlineto" ));
 
           for ( idx = 0; idx < count; idx++ )
           {
             CF2_Fixed  v = cf2_stack_getReal( opStack, idx );
 
@@ -914,12 +917,12 @@
         {
           CF2_UInt  count = cf2_stack_count( opStack );
           CF2_UInt  idx   = 0;
 
 
-          FT_TRACE4(( op1 == cf2_cmdRCURVELINE ? " rcurveline\n"
-                                               : " rrcurveto\n" ));
+          FT_TRACE4(( "%s\n", op1 == cf2_cmdRCURVELINE ? " rcurveline"
+                                                       : " rrcurveto" ));
 
           while ( idx + 6 <= count )
           {
             CF2_Fixed  x1, y1, x2, y2, x3, y3;
 
@@ -955,14 +958,14 @@
       case cf2_cmdCLOSEPATH:
         if ( !font->isT1 )
           FT_TRACE4(( " unknown op (%d)\n", op1 ));
         else
         {
-          FT_TRACE4(( " closepath" ));
+          FT_TRACE4(( " closepath\n" ));
 
           /* if there is no path, `closepath' is a no-op */
-          ps_builder_close_contour( &decoder->builder );
+          cf2_glyphpath_closeOpenPath( &glyphPath );
 
           haveWidth = TRUE;
         }
         break;
 
@@ -970,12 +973,12 @@
       case cf2_cmdCALLSUBR:
         {
           CF2_Int  subrNum;
 
 
-          FT_TRACE4(( op1 == cf2_cmdCALLGSUBR ? " callgsubr"
-                                              : " callsubr" ));
+          FT_TRACE4(( "%s", op1 == cf2_cmdCALLGSUBR ? " callgsubr"
+                                                    : " callsubr" ));
 
           if ( ( !font->isT1 && charstringIndex > CF2_MAX_SUBR )       ||
                (  font->isT1 && charstringIndex > T1_MAX_SUBRS_CALLS ) )
           {
             /* max subr plus one for charstring */
@@ -1210,12 +1213,12 @@
                       CF2_F16Dot16  v0, v1, v2;
 
                       FT_Bool  isV = FT_BOOL( op2 == cf2_escVSTEM3 );
 
 
-                      FT_TRACE4(( isV ? " vstem3\n"
-                                      : " hstem3\n" ));
+                      FT_TRACE4(( "%s\n", isV ? " vstem3"
+                                              : " hstem3" ));
 
                       FT_ASSERT( cf2_stack_count( opStack ) == 6 );
 
                       v0 = cf2_stack_getReal( opStack, 0 );
                       v1 = cf2_stack_getReal( opStack, 2 );
@@ -1642,20 +1645,21 @@
                     FT_TRACE4(( " callothersubr\n" ));
 
                     subr_no = cf2_stack_popInt( opStack );
                     arg_cnt = cf2_stack_popInt( opStack );
 
-                    /*******************************************************/
-                    /*                                                     */
-                    /* remove all operands to callothersubr from the stack */
-                    /*                                                     */
-                    /* for handled othersubrs, where we know the number of */
-                    /* arguments, we increase the stack by the value of    */
-                    /* known_othersubr_result_cnt                          */
-                    /*                                                     */
-                    /* for unhandled othersubrs the following pops adjust  */
-                    /* the stack pointer as necessary                      */
+                    /********************************************************
+                     *
+                     * remove all operands to callothersubr from the stack
+                     *
+                     * for handled othersubrs, where we know the number of
+                     * arguments, we increase the stack by the value of
+                     * known_othersubr_result_cnt
+                     *
+                     * for unhandled othersubrs the following pops adjust
+                     * the stack pointer as necessary
+                     */
 
                     count = cf2_stack_count( opStack );
                     FT_ASSERT( (CF2_UInt)arg_cnt <= count );
 
                     opIdx += count - (CF2_UInt)arg_cnt;
@@ -2414,11 +2418,11 @@
         {
           CF2_Fixed    lsb_x;
           PS_Builder*  builder;
 
 
-          FT_TRACE4(( " hsbw" ));
+          FT_TRACE4(( " hsbw\n" ));
 
           builder = &decoder->builder;
 
           builder->advance->x = cf2_stack_popFixed( opStack );
           builder->advance->y = 0;
@@ -2560,11 +2564,11 @@
 
       case cf2_cmdCNTRMASK:
       case cf2_cmdHINTMASK:
         /* the final \n in the tracing message gets added in      */
         /* `cf2_hintmask_read' (which also traces the mask bytes) */
-        FT_TRACE4(( op1 == cf2_cmdCNTRMASK ? " cntrmask" : " hintmask" ));
+        FT_TRACE4(( "%s", op1 == cf2_cmdCNTRMASK ? " cntrmask" : " hintmask" ));
 
         /* never add hints after the mask is computed */
         if ( cf2_stack_count( opStack ) > 1    &&
              cf2_hintmask_isValid( &hintMask ) )
         {
@@ -2826,11 +2830,11 @@
           /* second bit                                       */
           /* (and sorting the stack indexing to suit)         */
           count = count1 & ~2U;
           idx  += count1 - count;
 
-          FT_TRACE4(( alternate ? " hvcurveto\n" : " vhcurveto\n" ));
+          FT_TRACE4(( "%s\n", alternate ? " hvcurveto" : " vhcurveto" ));
 
           while ( idx < count )
           {
             CF2_Fixed x1, x2, x3, y1, y2, y3;
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afglobal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  afhints.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Auto-fitter hinting routines (body).                                 */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &quot;afhints.h&quot;
  20 #include &quot;aferrors.h&quot;
  21 #include FT_INTERNAL_CALC_H
  22 #include FT_INTERNAL_DEBUG_H
  23 
  24 
<span class="line-modified">  25   /*************************************************************************/</span>
<span class="line-modified">  26   /*                                                                       */</span>
<span class="line-modified">  27   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  28   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  29   /* messages during execution.                                            */</span>
<span class="line-modified">  30   /*                                                                       */</span>
  31 #undef  FT_COMPONENT
<span class="line-modified">  32 #define FT_COMPONENT  trace_afhints</span>
  33 
  34 
  35   /* Get new segment for given axis. */
  36 
  37   FT_LOCAL_DEF( FT_Error )
  38   af_axis_hints_new_segment( AF_AxisHints  axis,
  39                              FT_Memory     memory,
  40                              AF_Segment   *asegment )
  41   {
  42     FT_Error    error   = FT_Err_Ok;
  43     AF_Segment  segment = NULL;
  44 
  45 
  46     if ( axis-&gt;num_segments &lt; AF_SEGMENTS_EMBEDDED )
  47     {
  48       if ( !axis-&gt;segments )
  49       {
  50         axis-&gt;segments     = axis-&gt;embedded.segments;
  51         axis-&gt;max_segments = AF_SEGMENTS_EMBEDDED;
  52       }
</pre>
<hr />
<pre>
 280       return -1;
 281 
 282     return (int)( segment - segments );
 283   }
 284 
 285 
 286   static int
 287   af_get_edge_index( AF_GlyphHints  hints,
 288                      int            segment_idx,
 289                      int            dimension )
 290   {
 291     AF_AxisHints  axis    = &amp;hints-&gt;axis[dimension];
 292     AF_Edge       edges   = axis-&gt;edges;
 293     AF_Segment    segment = axis-&gt;segments + segment_idx;
 294 
 295 
 296     return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
 297   }
 298 
 299 













 300 #ifdef __cplusplus
 301   extern &quot;C&quot; {
 302 #endif
 303   void
 304   af_glyph_hints_dump_points( AF_GlyphHints  hints,
 305                               FT_Bool        to_stdout )
 306   {
 307     AF_Point   points  = hints-&gt;points;
 308     AF_Point   limit   = points + hints-&gt;num_points;
 309     AF_Point*  contour = hints-&gt;contours;
 310     AF_Point*  climit  = contour + hints-&gt;num_contours;
 311     AF_Point   point;
 312 
 313 
 314     AF_DUMP(( &quot;Table of points:\n&quot; ));
 315 
 316     if ( hints-&gt;num_points )
 317     {
 318       AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
 319              /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<span class="line-modified"> 320                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit&quot; ));</span>
 321              /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */


 322     }
 323     else
 324       AF_DUMP(( &quot;  (none)\n&quot; ));
 325 
 326     for ( point = points; point &lt; limit; point++ )
 327     {
 328       int  point_idx     = AF_INDEX_NUM( point, points );
 329       int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
 330       int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
 331 
 332       char  buf1[16], buf2[16], buf3[16], buf4[16];

 333 
 334 
 335       /* insert extra newline at the beginning of a contour */
 336       if ( contour &lt; climit &amp;&amp; *contour == point )
 337       {
 338         AF_DUMP(( &quot;\n&quot; ));
 339         contour++;
 340       }
 341 
 342       AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<span class="line-modified"> 343                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f\n&quot;,</span>

 344                 point_idx,
 345                 af_print_idx( buf1,
 346                               af_get_edge_index( hints, segment_idx_1, 1 ) ),
 347                 af_print_idx( buf2, segment_idx_1 ),
 348                 af_print_idx( buf3,
 349                               af_get_edge_index( hints, segment_idx_0, 0 ) ),
 350                 af_print_idx( buf4, segment_idx_0 ),
 351                 ( point-&gt;flags &amp; AF_FLAG_NEAR )
 352                   ? &quot; near &quot;
 353                   : ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
 354                     ? &quot; weak &quot;
 355                     : &quot;strong&quot;,
 356 
 357                 point-&gt;fx,
 358                 point-&gt;fy,
 359                 point-&gt;ox / 64.0,
 360                 point-&gt;oy / 64.0,
 361                 point-&gt;x / 64.0,
<span class="line-modified"> 362                 point-&gt;y / 64.0 ));</span>













 363     }
 364     AF_DUMP(( &quot;\n&quot; ));
 365   }
 366 #ifdef __cplusplus
 367   }
 368 #endif
 369 
 370 
 371   static const char*
 372   af_edge_flags_to_string( FT_UInt  flags )
 373   {
 374     static char  temp[32];
 375     int          pos = 0;
 376 
 377 
 378     if ( flags &amp; AF_EDGE_ROUND )
 379     {
 380       ft_memcpy( temp + pos, &quot;round&quot;, 5 );
 381       pos += 5;
 382     }
</pre>
<hr />
<pre>
 502   {
 503     AF_Dimension  dim;
 504     AF_AxisHints  axis;
 505     AF_Segment    seg;
 506 
 507 
 508     if ( !offset )
 509       return FT_THROW( Invalid_Argument );
 510 
 511     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 512 
 513     axis = &amp;hints-&gt;axis[dim];
 514 
 515     if ( idx &lt; 0 || idx &gt;= axis-&gt;num_segments )
 516       return FT_THROW( Invalid_Argument );
 517 
 518     seg      = &amp;axis-&gt;segments[idx];
 519     *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
 520                                             : seg-&gt;first-&gt;fy;
 521     if ( seg-&gt;edge )
<span class="line-modified"> 522       *is_blue = (FT_Bool)( seg-&gt;edge-&gt;blue_edge != 0 );</span>
 523     else
 524       *is_blue = FALSE;
 525 
 526     if ( *is_blue )
 527       *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
 528     else
 529       *blue_offset = 0;
 530 
 531     return FT_Err_Ok;
 532   }
 533 #ifdef __cplusplus
 534   }
 535 #endif
 536 
 537 
 538   /* Dump the array of linked edges. */
 539 
 540 #ifdef __cplusplus
 541   extern &quot;C&quot; {
 542 #endif
 543   void
 544   af_glyph_hints_dump_edges( AF_GlyphHints  hints,
 545                              FT_Bool        to_stdout )
 546   {
 547     FT_Int  dimension;
 548 
 549 
 550     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 551     {
 552       AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];
 553       AF_Edge       edges = axis-&gt;edges;
 554       AF_Edge       limit = edges + axis-&gt;num_edges;
 555       AF_Edge       edge;
 556 
 557       char  buf1[16], buf2[16];
 558 
 559 
 560       /*
<span class="line-modified"> 561        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified"> 562        *        since they have a constant X coordinate.</span>
 563        */
 564       if ( dimension == AF_DIMENSION_HORZ )
 565         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 566                   &quot;vertical&quot;,
 567                   65536.0 * 64.0 / hints-&gt;x_scale,
 568                   10.0 * hints-&gt;x_scale / 65536.0 / 64.0 ));
 569       else
 570         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 571                   &quot;horizontal&quot;,
 572                   65536.0 * 64.0 / hints-&gt;y_scale,
 573                   10.0 * hints-&gt;y_scale / 65536.0 / 64.0 ));
 574 
 575       if ( axis-&gt;num_edges )
 576       {
 577         AF_DUMP(( &quot;  index    pos     dir   link  serif&quot;
 578                /* &quot;  XXXXX  XXXX.XX  XXXXX  XXXX  XXXXX&quot; */
 579                   &quot;  blue    opos     pos       flags\n&quot; ));
 580                /* &quot;    X   XXXX.XX  XXXX.XX  XXXXXXXXXXX&quot; */
 581       }
 582       else
</pre>
<hr />
<pre>
 664   {
 665     /* no need to initialize the embedded items */
 666     FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints-&gt;embedded ) );
 667     hints-&gt;memory = memory;
 668   }
 669 
 670 
 671   FT_LOCAL_DEF( void )
 672   af_glyph_hints_done( AF_GlyphHints  hints )
 673   {
 674     FT_Memory  memory;
 675     int        dim;
 676 
 677 
 678     if ( !( hints &amp;&amp; hints-&gt;memory ) )
 679       return;
 680 
 681     memory = hints-&gt;memory;
 682 
 683     /*
<span class="line-modified"> 684      *  note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified"> 685      *  buffers since they are really within the hints-&gt;points array</span>
 686      */
 687     for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 688     {
 689       AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
 690 
 691 
 692       axis-&gt;num_segments = 0;
 693       axis-&gt;max_segments = 0;
 694       if ( axis-&gt;segments != axis-&gt;embedded.segments )
 695         FT_FREE( axis-&gt;segments );
 696 
 697       axis-&gt;num_edges = 0;
 698       axis-&gt;max_edges = 0;
 699       if ( axis-&gt;edges != axis-&gt;embedded.edges )
 700         FT_FREE( axis-&gt;edges );
 701     }
 702 
 703     if ( hints-&gt;contours != hints-&gt;embedded.contours )
 704       FT_FREE( hints-&gt;contours );
 705     hints-&gt;max_contours = 0;
</pre>
<hr />
<pre>
 759       if ( !hints-&gt;contours )
 760       {
 761         hints-&gt;contours     = hints-&gt;embedded.contours;
 762         hints-&gt;max_contours = AF_CONTOURS_EMBEDDED;
 763       }
 764     }
 765     else if ( new_max &gt; old_max )
 766     {
 767       if ( hints-&gt;contours == hints-&gt;embedded.contours )
 768         hints-&gt;contours = NULL;
 769 
 770       new_max = ( new_max + 3 ) &amp; ~3U; /* round up to a multiple of 4 */
 771 
 772       if ( FT_RENEW_ARRAY( hints-&gt;contours, old_max, new_max ) )
 773         goto Exit;
 774 
 775       hints-&gt;max_contours = (FT_Int)new_max;
 776     }
 777 
 778     /*
<span class="line-modified"> 779      *  then reallocate the points arrays if necessary --</span>
<span class="line-modified"> 780      *  note that we reserve two additional point positions, used to</span>
<span class="line-modified"> 781      *  hint metrics appropriately</span>
 782      */
 783     new_max = (FT_UInt)( outline-&gt;n_points + 2 );
 784     old_max = (FT_UInt)hints-&gt;max_points;
 785 
 786     if ( new_max &lt;= AF_POINTS_EMBEDDED )
 787     {
 788       if ( !hints-&gt;points )
 789       {
 790         hints-&gt;points     = hints-&gt;embedded.points;
 791         hints-&gt;max_points = AF_POINTS_EMBEDDED;
 792       }
 793     }
 794     else if ( new_max &gt; old_max )
 795     {
 796       if ( hints-&gt;points == hints-&gt;embedded.points )
 797         hints-&gt;points = NULL;
 798 
 799       new_max = ( new_max + 2 + 7 ) &amp; ~7U; /* round up to a multiple of 8 */
 800 
 801       if ( FT_RENEW_ARRAY( hints-&gt;points, old_max, new_max ) )
</pre>
<hr />
<pre>
 881 
 882           out_x = point-&gt;fx - prev-&gt;fx;
 883           out_y = point-&gt;fy - prev-&gt;fy;
 884 
 885           if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
 886             prev-&gt;flags |= AF_FLAG_NEAR;
 887 
 888           point-&gt;prev = prev;
 889           prev-&gt;next  = point;
 890           prev        = point;
 891 
 892           if ( point == end )
 893           {
 894             if ( ++contour_index &lt; outline-&gt;n_contours )
 895             {
 896               endpoint = outline-&gt;contours[contour_index];
 897               end      = points + endpoint;
 898               prev     = end;
 899             }
 900           }








 901         }
 902       }
 903 
 904       /* set up the contours array */
 905       {
 906         AF_Point*  contour       = hints-&gt;contours;
 907         AF_Point*  contour_limit = contour + hints-&gt;num_contours;
 908         short*     end           = outline-&gt;contours;
 909         short      idx           = 0;
 910 
 911 
 912         for ( ; contour &lt; contour_limit; contour++, end++ )
 913         {
 914           contour[0] = points + idx;
 915           idx        = (short)( end[0] + 1 );
 916         }
 917       }
 918 
 919       {
 920         /*
<span class="line-modified"> 921          *  Compute directions of `in&#39; and `out&#39; vectors.</span>
 922          *
<span class="line-modified"> 923          *  Note that distances between points that are very near to each</span>
<span class="line-modified"> 924          *  other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified"> 925          *  prepends the small vectors between near points to the first</span>
<span class="line-modified"> 926          *  non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified"> 927          *  threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified"> 928          *  points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified"> 929          *  be equal to the accumulated one.</span>
 930          */
 931 
 932         FT_Int  near_limit2 = 2 * near_limit - 1;
 933 
 934         AF_Point*  contour;
 935         AF_Point*  contour_limit = hints-&gt;contours + hints-&gt;num_contours;
 936 
 937 
 938         for ( contour = hints-&gt;contours; contour &lt; contour_limit; contour++ )
 939         {
 940           AF_Point  first = *contour;
 941           AF_Point  next, prev, curr;
 942 
 943           FT_Pos  out_x, out_y;
 944 
 945 
 946           /* since the first point of a contour could be part of a */
 947           /* series of near points, go backwards to find the first */
 948           /* non-near point and adjust `first&#39;                     */
 949 
 950           point = first;
 951           prev  = first-&gt;prev;
 952 
 953           while ( prev != first )
 954           {
 955             out_x = point-&gt;fx - prev-&gt;fx;
 956             out_y = point-&gt;fy - prev-&gt;fy;
 957 
 958             /*
<span class="line-modified"> 959              *  We use Taxicab metrics to measure the vector length.</span>
 960              *
<span class="line-modified"> 961              *  Note that the accumulated distances so far could have the</span>
<span class="line-modified"> 962              *  opposite direction of the distance measured here.  For this</span>
<span class="line-modified"> 963              *  reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified"> 964              *  non-near point even in the worst case.</span>
 965              */
 966             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
 967               break;
 968 
 969             point = prev;
 970             prev  = prev-&gt;prev;
 971           }
 972 
 973           /* adjust first point */
 974           first = point;
 975 
 976           /* now loop over all points of the contour to get */
 977           /* `in&#39; and `out&#39; vector directions               */
 978 
 979           curr = first;
 980 
 981           /*
<span class="line-modified"> 982            *  We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified"> 983            *  next and previous non-near point, respectively.</span>
 984            *
<span class="line-modified"> 985            *  To avoid problems with not having non-near points, we point to</span>
<span class="line-modified"> 986            *  `first&#39; by default as the next non-near point.</span>
 987            *
 988            */
 989           curr-&gt;u  = (FT_Pos)( first - curr );
 990           first-&gt;v = -curr-&gt;u;
 991 
 992           out_x = 0;
 993           out_y = 0;
 994 
 995           next = first;
 996           do
 997           {
 998             AF_Direction  out_dir;
 999 
1000 
1001             point = next;
1002             next  = point-&gt;next;
1003 
1004             out_x += next-&gt;fx - point-&gt;fx;
1005             out_y += next-&gt;fy - point-&gt;fy;
1006 
</pre>
<hr />
<pre>
1018             /* adjust directions for all points inbetween; */
1019             /* the loop also updates position of `curr&#39;    */
1020             curr-&gt;out_dir = (FT_Char)out_dir;
1021             for ( curr = curr-&gt;next; curr != next; curr = curr-&gt;next )
1022             {
1023               curr-&gt;in_dir  = (FT_Char)out_dir;
1024               curr-&gt;out_dir = (FT_Char)out_dir;
1025             }
1026             next-&gt;in_dir = (FT_Char)out_dir;
1027 
1028             curr-&gt;u  = (FT_Pos)( first - curr );
1029             first-&gt;v = -curr-&gt;u;
1030 
1031             out_x = 0;
1032             out_y = 0;
1033 
1034           } while ( next != first );
1035         }
1036 
1037         /*
<span class="line-modified">1038          *  The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">1039          *  can identify local extrema more reliably: A series of</span>
<span class="line-modified">1040          *  non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">1041          *  quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">1042          *  topological point of the view, the intermediate points are of no</span>
<span class="line-modified">1043          *  interest and thus tagged as weak.</span>
1044          */
1045 
1046         for ( point = points; point &lt; point_limit; point++ )
1047         {
1048           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1049             continue;
1050 
1051           if ( point-&gt;in_dir  == AF_DIR_NONE &amp;&amp;
1052                point-&gt;out_dir == AF_DIR_NONE )
1053           {
1054             /* check whether both vectors point into the same quadrant */
1055 
1056             FT_Pos  in_x, in_y;
1057             FT_Pos  out_x, out_y;
1058 
1059             AF_Point  next_u = point + point-&gt;u;
1060             AF_Point  prev_v = point + point-&gt;v;
1061 
1062 
1063             in_x = point-&gt;fx - prev_v-&gt;fx;
1064             in_y = point-&gt;fy - prev_v-&gt;fy;
1065 
1066             out_x = next_u-&gt;fx - point-&gt;fx;
1067             out_y = next_u-&gt;fy - point-&gt;fy;
1068 
1069             if ( ( in_x ^ out_x ) &gt;= 0 &amp;&amp; ( in_y ^ out_y ) &gt;= 0 )
1070             {
1071               /* yes, so tag current point as weak */
1072               /* and update index deltas           */
1073 
1074               point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1075 
1076               prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1077               next_u-&gt;v = -prev_v-&gt;u;
1078             }
1079           }
1080         }
1081 
1082         /*
<span class="line-modified">1083          *  Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">1084          *  collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">1085          *  points.</span>
1086          */
1087 
1088         for ( point = points; point &lt; point_limit; point++ )
1089         {
1090           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1091             continue;
1092 
1093           if ( point-&gt;flags &amp; AF_FLAG_CONTROL )
1094           {
1095             /* control points are always weak */
1096           Is_Weak_Point:
1097             point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1098           }
1099           else if ( point-&gt;out_dir == point-&gt;in_dir )
1100           {
1101             if ( point-&gt;out_dir != AF_DIR_NONE )
1102             {
1103               /* current point lies on a horizontal or          */
1104               /* vertical segment (but doesn&#39;t start or end it) */
1105               goto Is_Weak_Point;
</pre>
<hr />
<pre>
1292 
1293         if ( dim == AF_DIMENSION_VERT )
1294         {
1295           u  = point-&gt;fy;
1296           ou = point-&gt;oy;
1297         }
1298         else
1299         {
1300           u  = point-&gt;fx;
1301           ou = point-&gt;ox;
1302         }
1303 
1304         fu = u;
1305 
1306         /* is the point before the first edge? */
1307         edge  = edges;
1308         delta = edge-&gt;fpos - u;
1309         if ( delta &gt;= 0 )
1310         {
1311           u = edge-&gt;pos - ( edge-&gt;opos - ou );






1312           goto Store_Point;
1313         }
1314 
1315         /* is the point after the last edge? */
1316         edge  = edge_limit - 1;
1317         delta = u - edge-&gt;fpos;
1318         if ( delta &gt;= 0 )
1319         {
1320           u = edge-&gt;pos + ( ou - edge-&gt;opos );






1321           goto Store_Point;
1322         }
1323 
1324         {
1325           FT_PtrDist  min, max, mid;
1326           FT_Pos      fpos;
1327 
1328 
1329           /* find enclosing edges */
1330           min = 0;
1331           max = edge_limit - edges;
1332 
1333 #if 1
1334           /* for a small number of edges, a linear search is better */
1335           if ( max &lt;= 8 )
1336           {
1337             FT_PtrDist  nn;
1338 
1339 
1340             for ( nn = 0; nn &lt; max; nn++ )
</pre>
<hr />
<pre>
1347               goto Store_Point;
1348             }
1349             min = nn;
1350           }
1351           else
1352 #endif
1353           while ( min &lt; max )
1354           {
1355             mid  = ( max + min ) &gt;&gt; 1;
1356             edge = edges + mid;
1357             fpos = edge-&gt;fpos;
1358 
1359             if ( u &lt; fpos )
1360               max = mid;
1361             else if ( u &gt; fpos )
1362               min = mid + 1;
1363             else
1364             {
1365               /* we are on the edge */
1366               u = edge-&gt;pos;






1367               goto Store_Point;
1368             }
1369           }
1370 
1371           /* point is not on an edge */
1372           {
1373             AF_Edge  before = edges + min - 1;
1374             AF_Edge  after  = edges + min + 0;
1375 
1376 





1377             /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
1378             if ( before-&gt;scale == 0 )
1379               before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
1380                                          after-&gt;fpos - before-&gt;fpos );
1381 
1382             u = before-&gt;pos + FT_MulFix( fu - before-&gt;fpos,
1383                                          before-&gt;scale );
1384           }
1385         }
1386 
1387       Store_Point:
1388         /* save the point position */
1389         if ( dim == AF_DIMENSION_HORZ )
1390           point-&gt;x = u;
1391         else
1392           point-&gt;y = u;
1393 
1394         point-&gt;flags |= touch_flag;
1395       }
1396     }
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * afhints.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auto-fitter hinting routines (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &quot;afhints.h&quot;
  20 #include &quot;aferrors.h&quot;
  21 #include FT_INTERNAL_CALC_H
  22 #include FT_INTERNAL_DEBUG_H
  23 
  24 
<span class="line-modified">  25   /**************************************************************************</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  28    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  29    * messages during execution.</span>
<span class="line-modified">  30    */</span>
  31 #undef  FT_COMPONENT
<span class="line-modified">  32 #define FT_COMPONENT  afhints</span>
  33 
  34 
  35   /* Get new segment for given axis. */
  36 
  37   FT_LOCAL_DEF( FT_Error )
  38   af_axis_hints_new_segment( AF_AxisHints  axis,
  39                              FT_Memory     memory,
  40                              AF_Segment   *asegment )
  41   {
  42     FT_Error    error   = FT_Err_Ok;
  43     AF_Segment  segment = NULL;
  44 
  45 
  46     if ( axis-&gt;num_segments &lt; AF_SEGMENTS_EMBEDDED )
  47     {
  48       if ( !axis-&gt;segments )
  49       {
  50         axis-&gt;segments     = axis-&gt;embedded.segments;
  51         axis-&gt;max_segments = AF_SEGMENTS_EMBEDDED;
  52       }
</pre>
<hr />
<pre>
 280       return -1;
 281 
 282     return (int)( segment - segments );
 283   }
 284 
 285 
 286   static int
 287   af_get_edge_index( AF_GlyphHints  hints,
 288                      int            segment_idx,
 289                      int            dimension )
 290   {
 291     AF_AxisHints  axis    = &amp;hints-&gt;axis[dimension];
 292     AF_Edge       edges   = axis-&gt;edges;
 293     AF_Segment    segment = axis-&gt;segments + segment_idx;
 294 
 295 
 296     return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
 297   }
 298 
 299 
<span class="line-added"> 300   static int</span>
<span class="line-added"> 301   af_get_strong_edge_index( AF_GlyphHints  hints,</span>
<span class="line-added"> 302                             AF_Edge*       strong_edges,</span>
<span class="line-added"> 303                             int            dimension )</span>
<span class="line-added"> 304   {</span>
<span class="line-added"> 305     AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];</span>
<span class="line-added"> 306     AF_Edge       edges = axis-&gt;edges;</span>
<span class="line-added"> 307 </span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309     return AF_INDEX_NUM( strong_edges[dimension], edges );</span>
<span class="line-added"> 310   }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312 </span>
 313 #ifdef __cplusplus
 314   extern &quot;C&quot; {
 315 #endif
 316   void
 317   af_glyph_hints_dump_points( AF_GlyphHints  hints,
 318                               FT_Bool        to_stdout )
 319   {
 320     AF_Point   points  = hints-&gt;points;
 321     AF_Point   limit   = points + hints-&gt;num_points;
 322     AF_Point*  contour = hints-&gt;contours;
 323     AF_Point*  climit  = contour + hints-&gt;num_contours;
 324     AF_Point   point;
 325 
 326 
 327     AF_DUMP(( &quot;Table of points:\n&quot; ));
 328 
 329     if ( hints-&gt;num_points )
 330     {
 331       AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
 332              /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<span class="line-modified"> 333                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit &quot;</span>
 334              /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
<span class="line-added"> 335                 &quot;  hbef  haft  vbef  vaft&quot; ));</span>
<span class="line-added"> 336              /* &quot; XXXXX XXXXX XXXXX XXXXX&quot; */</span>
 337     }
 338     else
 339       AF_DUMP(( &quot;  (none)\n&quot; ));
 340 
 341     for ( point = points; point &lt; limit; point++ )
 342     {
 343       int  point_idx     = AF_INDEX_NUM( point, points );
 344       int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
 345       int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
 346 
 347       char  buf1[16], buf2[16], buf3[16], buf4[16];
<span class="line-added"> 348       char  buf5[16], buf6[16], buf7[16], buf8[16];</span>
 349 
 350 
 351       /* insert extra newline at the beginning of a contour */
 352       if ( contour &lt; climit &amp;&amp; *contour == point )
 353       {
 354         AF_DUMP(( &quot;\n&quot; ));
 355         contour++;
 356       }
 357 
 358       AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<span class="line-modified"> 359                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f&quot;</span>
<span class="line-added"> 360                 &quot; %5s %5s %5s %5s\n&quot;,</span>
 361                 point_idx,
 362                 af_print_idx( buf1,
 363                               af_get_edge_index( hints, segment_idx_1, 1 ) ),
 364                 af_print_idx( buf2, segment_idx_1 ),
 365                 af_print_idx( buf3,
 366                               af_get_edge_index( hints, segment_idx_0, 0 ) ),
 367                 af_print_idx( buf4, segment_idx_0 ),
 368                 ( point-&gt;flags &amp; AF_FLAG_NEAR )
 369                   ? &quot; near &quot;
 370                   : ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
 371                     ? &quot; weak &quot;
 372                     : &quot;strong&quot;,
 373 
 374                 point-&gt;fx,
 375                 point-&gt;fy,
 376                 point-&gt;ox / 64.0,
 377                 point-&gt;oy / 64.0,
 378                 point-&gt;x / 64.0,
<span class="line-modified"> 379                 point-&gt;y / 64.0,</span>
<span class="line-added"> 380 </span>
<span class="line-added"> 381                 af_print_idx( buf5, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 382                                                               point-&gt;before,</span>
<span class="line-added"> 383                                                               1 ) ),</span>
<span class="line-added"> 384                 af_print_idx( buf6, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 385                                                               point-&gt;after,</span>
<span class="line-added"> 386                                                               1 ) ),</span>
<span class="line-added"> 387                 af_print_idx( buf7, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 388                                                               point-&gt;before,</span>
<span class="line-added"> 389                                                               0 ) ),</span>
<span class="line-added"> 390                 af_print_idx( buf8, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 391                                                               point-&gt;after,</span>
<span class="line-added"> 392                                                               0 ) ) ));</span>
 393     }
 394     AF_DUMP(( &quot;\n&quot; ));
 395   }
 396 #ifdef __cplusplus
 397   }
 398 #endif
 399 
 400 
 401   static const char*
 402   af_edge_flags_to_string( FT_UInt  flags )
 403   {
 404     static char  temp[32];
 405     int          pos = 0;
 406 
 407 
 408     if ( flags &amp; AF_EDGE_ROUND )
 409     {
 410       ft_memcpy( temp + pos, &quot;round&quot;, 5 );
 411       pos += 5;
 412     }
</pre>
<hr />
<pre>
 532   {
 533     AF_Dimension  dim;
 534     AF_AxisHints  axis;
 535     AF_Segment    seg;
 536 
 537 
 538     if ( !offset )
 539       return FT_THROW( Invalid_Argument );
 540 
 541     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 542 
 543     axis = &amp;hints-&gt;axis[dim];
 544 
 545     if ( idx &lt; 0 || idx &gt;= axis-&gt;num_segments )
 546       return FT_THROW( Invalid_Argument );
 547 
 548     seg      = &amp;axis-&gt;segments[idx];
 549     *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
 550                                             : seg-&gt;first-&gt;fy;
 551     if ( seg-&gt;edge )
<span class="line-modified"> 552       *is_blue = FT_BOOL( seg-&gt;edge-&gt;blue_edge );</span>
 553     else
 554       *is_blue = FALSE;
 555 
 556     if ( *is_blue )
 557       *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
 558     else
 559       *blue_offset = 0;
 560 
 561     return FT_Err_Ok;
 562   }
 563 #ifdef __cplusplus
 564   }
 565 #endif
 566 
 567 
 568   /* Dump the array of linked edges. */
 569 
 570 #ifdef __cplusplus
 571   extern &quot;C&quot; {
 572 #endif
 573   void
 574   af_glyph_hints_dump_edges( AF_GlyphHints  hints,
 575                              FT_Bool        to_stdout )
 576   {
 577     FT_Int  dimension;
 578 
 579 
 580     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 581     {
 582       AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];
 583       AF_Edge       edges = axis-&gt;edges;
 584       AF_Edge       limit = edges + axis-&gt;num_edges;
 585       AF_Edge       edge;
 586 
 587       char  buf1[16], buf2[16];
 588 
 589 
 590       /*
<span class="line-modified"> 591        * note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified"> 592        *       since they have a constant X coordinate.</span>
 593        */
 594       if ( dimension == AF_DIMENSION_HORZ )
 595         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 596                   &quot;vertical&quot;,
 597                   65536.0 * 64.0 / hints-&gt;x_scale,
 598                   10.0 * hints-&gt;x_scale / 65536.0 / 64.0 ));
 599       else
 600         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 601                   &quot;horizontal&quot;,
 602                   65536.0 * 64.0 / hints-&gt;y_scale,
 603                   10.0 * hints-&gt;y_scale / 65536.0 / 64.0 ));
 604 
 605       if ( axis-&gt;num_edges )
 606       {
 607         AF_DUMP(( &quot;  index    pos     dir   link  serif&quot;
 608                /* &quot;  XXXXX  XXXX.XX  XXXXX  XXXX  XXXXX&quot; */
 609                   &quot;  blue    opos     pos       flags\n&quot; ));
 610                /* &quot;    X   XXXX.XX  XXXX.XX  XXXXXXXXXXX&quot; */
 611       }
 612       else
</pre>
<hr />
<pre>
 694   {
 695     /* no need to initialize the embedded items */
 696     FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints-&gt;embedded ) );
 697     hints-&gt;memory = memory;
 698   }
 699 
 700 
 701   FT_LOCAL_DEF( void )
 702   af_glyph_hints_done( AF_GlyphHints  hints )
 703   {
 704     FT_Memory  memory;
 705     int        dim;
 706 
 707 
 708     if ( !( hints &amp;&amp; hints-&gt;memory ) )
 709       return;
 710 
 711     memory = hints-&gt;memory;
 712 
 713     /*
<span class="line-modified"> 714      * note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified"> 715      * buffers since they are really within the hints-&gt;points array</span>
 716      */
 717     for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 718     {
 719       AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
 720 
 721 
 722       axis-&gt;num_segments = 0;
 723       axis-&gt;max_segments = 0;
 724       if ( axis-&gt;segments != axis-&gt;embedded.segments )
 725         FT_FREE( axis-&gt;segments );
 726 
 727       axis-&gt;num_edges = 0;
 728       axis-&gt;max_edges = 0;
 729       if ( axis-&gt;edges != axis-&gt;embedded.edges )
 730         FT_FREE( axis-&gt;edges );
 731     }
 732 
 733     if ( hints-&gt;contours != hints-&gt;embedded.contours )
 734       FT_FREE( hints-&gt;contours );
 735     hints-&gt;max_contours = 0;
</pre>
<hr />
<pre>
 789       if ( !hints-&gt;contours )
 790       {
 791         hints-&gt;contours     = hints-&gt;embedded.contours;
 792         hints-&gt;max_contours = AF_CONTOURS_EMBEDDED;
 793       }
 794     }
 795     else if ( new_max &gt; old_max )
 796     {
 797       if ( hints-&gt;contours == hints-&gt;embedded.contours )
 798         hints-&gt;contours = NULL;
 799 
 800       new_max = ( new_max + 3 ) &amp; ~3U; /* round up to a multiple of 4 */
 801 
 802       if ( FT_RENEW_ARRAY( hints-&gt;contours, old_max, new_max ) )
 803         goto Exit;
 804 
 805       hints-&gt;max_contours = (FT_Int)new_max;
 806     }
 807 
 808     /*
<span class="line-modified"> 809      * then reallocate the points arrays if necessary --</span>
<span class="line-modified"> 810      * note that we reserve two additional point positions, used to</span>
<span class="line-modified"> 811      * hint metrics appropriately</span>
 812      */
 813     new_max = (FT_UInt)( outline-&gt;n_points + 2 );
 814     old_max = (FT_UInt)hints-&gt;max_points;
 815 
 816     if ( new_max &lt;= AF_POINTS_EMBEDDED )
 817     {
 818       if ( !hints-&gt;points )
 819       {
 820         hints-&gt;points     = hints-&gt;embedded.points;
 821         hints-&gt;max_points = AF_POINTS_EMBEDDED;
 822       }
 823     }
 824     else if ( new_max &gt; old_max )
 825     {
 826       if ( hints-&gt;points == hints-&gt;embedded.points )
 827         hints-&gt;points = NULL;
 828 
 829       new_max = ( new_max + 2 + 7 ) &amp; ~7U; /* round up to a multiple of 8 */
 830 
 831       if ( FT_RENEW_ARRAY( hints-&gt;points, old_max, new_max ) )
</pre>
<hr />
<pre>
 911 
 912           out_x = point-&gt;fx - prev-&gt;fx;
 913           out_y = point-&gt;fy - prev-&gt;fy;
 914 
 915           if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
 916             prev-&gt;flags |= AF_FLAG_NEAR;
 917 
 918           point-&gt;prev = prev;
 919           prev-&gt;next  = point;
 920           prev        = point;
 921 
 922           if ( point == end )
 923           {
 924             if ( ++contour_index &lt; outline-&gt;n_contours )
 925             {
 926               endpoint = outline-&gt;contours[contour_index];
 927               end      = points + endpoint;
 928               prev     = end;
 929             }
 930           }
<span class="line-added"> 931 </span>
<span class="line-added"> 932 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added"> 933           point-&gt;before[0] = NULL;</span>
<span class="line-added"> 934           point-&gt;before[1] = NULL;</span>
<span class="line-added"> 935           point-&gt;after[0]  = NULL;</span>
<span class="line-added"> 936           point-&gt;after[1]  = NULL;</span>
<span class="line-added"> 937 #endif</span>
<span class="line-added"> 938 </span>
 939         }
 940       }
 941 
 942       /* set up the contours array */
 943       {
 944         AF_Point*  contour       = hints-&gt;contours;
 945         AF_Point*  contour_limit = contour + hints-&gt;num_contours;
 946         short*     end           = outline-&gt;contours;
 947         short      idx           = 0;
 948 
 949 
 950         for ( ; contour &lt; contour_limit; contour++, end++ )
 951         {
 952           contour[0] = points + idx;
 953           idx        = (short)( end[0] + 1 );
 954         }
 955       }
 956 
 957       {
 958         /*
<span class="line-modified"> 959          * Compute directions of `in&#39; and `out&#39; vectors.</span>
 960          *
<span class="line-modified"> 961          * Note that distances between points that are very near to each</span>
<span class="line-modified"> 962          * other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified"> 963          * prepends the small vectors between near points to the first</span>
<span class="line-modified"> 964          * non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified"> 965          * threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified"> 966          * points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified"> 967          * be equal to the accumulated one.</span>
 968          */
 969 
 970         FT_Int  near_limit2 = 2 * near_limit - 1;
 971 
 972         AF_Point*  contour;
 973         AF_Point*  contour_limit = hints-&gt;contours + hints-&gt;num_contours;
 974 
 975 
 976         for ( contour = hints-&gt;contours; contour &lt; contour_limit; contour++ )
 977         {
 978           AF_Point  first = *contour;
 979           AF_Point  next, prev, curr;
 980 
 981           FT_Pos  out_x, out_y;
 982 
 983 
 984           /* since the first point of a contour could be part of a */
 985           /* series of near points, go backwards to find the first */
 986           /* non-near point and adjust `first&#39;                     */
 987 
 988           point = first;
 989           prev  = first-&gt;prev;
 990 
 991           while ( prev != first )
 992           {
 993             out_x = point-&gt;fx - prev-&gt;fx;
 994             out_y = point-&gt;fy - prev-&gt;fy;
 995 
 996             /*
<span class="line-modified"> 997              * We use Taxicab metrics to measure the vector length.</span>
 998              *
<span class="line-modified"> 999              * Note that the accumulated distances so far could have the</span>
<span class="line-modified">1000              * opposite direction of the distance measured here.  For this</span>
<span class="line-modified">1001              * reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified">1002              * non-near point even in the worst case.</span>
1003              */
1004             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
1005               break;
1006 
1007             point = prev;
1008             prev  = prev-&gt;prev;
1009           }
1010 
1011           /* adjust first point */
1012           first = point;
1013 
1014           /* now loop over all points of the contour to get */
1015           /* `in&#39; and `out&#39; vector directions               */
1016 
1017           curr = first;
1018 
1019           /*
<span class="line-modified">1020            * We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified">1021            * next and previous non-near point, respectively.</span>
1022            *
<span class="line-modified">1023            * To avoid problems with not having non-near points, we point to</span>
<span class="line-modified">1024            * `first&#39; by default as the next non-near point.</span>
1025            *
1026            */
1027           curr-&gt;u  = (FT_Pos)( first - curr );
1028           first-&gt;v = -curr-&gt;u;
1029 
1030           out_x = 0;
1031           out_y = 0;
1032 
1033           next = first;
1034           do
1035           {
1036             AF_Direction  out_dir;
1037 
1038 
1039             point = next;
1040             next  = point-&gt;next;
1041 
1042             out_x += next-&gt;fx - point-&gt;fx;
1043             out_y += next-&gt;fy - point-&gt;fy;
1044 
</pre>
<hr />
<pre>
1056             /* adjust directions for all points inbetween; */
1057             /* the loop also updates position of `curr&#39;    */
1058             curr-&gt;out_dir = (FT_Char)out_dir;
1059             for ( curr = curr-&gt;next; curr != next; curr = curr-&gt;next )
1060             {
1061               curr-&gt;in_dir  = (FT_Char)out_dir;
1062               curr-&gt;out_dir = (FT_Char)out_dir;
1063             }
1064             next-&gt;in_dir = (FT_Char)out_dir;
1065 
1066             curr-&gt;u  = (FT_Pos)( first - curr );
1067             first-&gt;v = -curr-&gt;u;
1068 
1069             out_x = 0;
1070             out_y = 0;
1071 
1072           } while ( next != first );
1073         }
1074 
1075         /*
<span class="line-modified">1076          * The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">1077          * can identify local extrema more reliably: A series of</span>
<span class="line-modified">1078          * non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">1079          * quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">1080          * topological point of the view, the intermediate points are of no</span>
<span class="line-modified">1081          * interest and thus tagged as weak.</span>
1082          */
1083 
1084         for ( point = points; point &lt; point_limit; point++ )
1085         {
1086           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1087             continue;
1088 
1089           if ( point-&gt;in_dir  == AF_DIR_NONE &amp;&amp;
1090                point-&gt;out_dir == AF_DIR_NONE )
1091           {
1092             /* check whether both vectors point into the same quadrant */
1093 
1094             FT_Pos  in_x, in_y;
1095             FT_Pos  out_x, out_y;
1096 
1097             AF_Point  next_u = point + point-&gt;u;
1098             AF_Point  prev_v = point + point-&gt;v;
1099 
1100 
1101             in_x = point-&gt;fx - prev_v-&gt;fx;
1102             in_y = point-&gt;fy - prev_v-&gt;fy;
1103 
1104             out_x = next_u-&gt;fx - point-&gt;fx;
1105             out_y = next_u-&gt;fy - point-&gt;fy;
1106 
1107             if ( ( in_x ^ out_x ) &gt;= 0 &amp;&amp; ( in_y ^ out_y ) &gt;= 0 )
1108             {
1109               /* yes, so tag current point as weak */
1110               /* and update index deltas           */
1111 
1112               point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1113 
1114               prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1115               next_u-&gt;v = -prev_v-&gt;u;
1116             }
1117           }
1118         }
1119 
1120         /*
<span class="line-modified">1121          * Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">1122          * collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">1123          * points.</span>
1124          */
1125 
1126         for ( point = points; point &lt; point_limit; point++ )
1127         {
1128           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1129             continue;
1130 
1131           if ( point-&gt;flags &amp; AF_FLAG_CONTROL )
1132           {
1133             /* control points are always weak */
1134           Is_Weak_Point:
1135             point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1136           }
1137           else if ( point-&gt;out_dir == point-&gt;in_dir )
1138           {
1139             if ( point-&gt;out_dir != AF_DIR_NONE )
1140             {
1141               /* current point lies on a horizontal or          */
1142               /* vertical segment (but doesn&#39;t start or end it) */
1143               goto Is_Weak_Point;
</pre>
<hr />
<pre>
1330 
1331         if ( dim == AF_DIMENSION_VERT )
1332         {
1333           u  = point-&gt;fy;
1334           ou = point-&gt;oy;
1335         }
1336         else
1337         {
1338           u  = point-&gt;fx;
1339           ou = point-&gt;ox;
1340         }
1341 
1342         fu = u;
1343 
1344         /* is the point before the first edge? */
1345         edge  = edges;
1346         delta = edge-&gt;fpos - u;
1347         if ( delta &gt;= 0 )
1348         {
1349           u = edge-&gt;pos - ( edge-&gt;opos - ou );
<span class="line-added">1350 </span>
<span class="line-added">1351 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1352           point-&gt;before[dim] = edge;</span>
<span class="line-added">1353           point-&gt;after[dim]  = NULL;</span>
<span class="line-added">1354 #endif</span>
<span class="line-added">1355 </span>
1356           goto Store_Point;
1357         }
1358 
1359         /* is the point after the last edge? */
1360         edge  = edge_limit - 1;
1361         delta = u - edge-&gt;fpos;
1362         if ( delta &gt;= 0 )
1363         {
1364           u = edge-&gt;pos + ( ou - edge-&gt;opos );
<span class="line-added">1365 </span>
<span class="line-added">1366 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1367           point-&gt;before[dim] = NULL;</span>
<span class="line-added">1368           point-&gt;after[dim]  = edge;</span>
<span class="line-added">1369 #endif</span>
<span class="line-added">1370 </span>
1371           goto Store_Point;
1372         }
1373 
1374         {
1375           FT_PtrDist  min, max, mid;
1376           FT_Pos      fpos;
1377 
1378 
1379           /* find enclosing edges */
1380           min = 0;
1381           max = edge_limit - edges;
1382 
1383 #if 1
1384           /* for a small number of edges, a linear search is better */
1385           if ( max &lt;= 8 )
1386           {
1387             FT_PtrDist  nn;
1388 
1389 
1390             for ( nn = 0; nn &lt; max; nn++ )
</pre>
<hr />
<pre>
1397               goto Store_Point;
1398             }
1399             min = nn;
1400           }
1401           else
1402 #endif
1403           while ( min &lt; max )
1404           {
1405             mid  = ( max + min ) &gt;&gt; 1;
1406             edge = edges + mid;
1407             fpos = edge-&gt;fpos;
1408 
1409             if ( u &lt; fpos )
1410               max = mid;
1411             else if ( u &gt; fpos )
1412               min = mid + 1;
1413             else
1414             {
1415               /* we are on the edge */
1416               u = edge-&gt;pos;
<span class="line-added">1417 </span>
<span class="line-added">1418 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1419               point-&gt;before[dim] = NULL;</span>
<span class="line-added">1420               point-&gt;after[dim]  = NULL;</span>
<span class="line-added">1421 #endif</span>
<span class="line-added">1422 </span>
1423               goto Store_Point;
1424             }
1425           }
1426 
1427           /* point is not on an edge */
1428           {
1429             AF_Edge  before = edges + min - 1;
1430             AF_Edge  after  = edges + min + 0;
1431 
1432 
<span class="line-added">1433 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1434             point-&gt;before[dim] = before;</span>
<span class="line-added">1435             point-&gt;after[dim]  = after;</span>
<span class="line-added">1436 #endif</span>
<span class="line-added">1437 </span>
1438             /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
1439             if ( before-&gt;scale == 0 )
1440               before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
1441                                          after-&gt;fpos - before-&gt;fpos );
1442 
1443             u = before-&gt;pos + FT_MulFix( fu - before-&gt;fpos,
1444                                          before-&gt;scale );
1445           }
1446         }
1447 
1448       Store_Point:
1449         /* save the point position */
1450         if ( dim == AF_DIMENSION_HORZ )
1451           point-&gt;x = u;
1452         else
1453           point-&gt;y = u;
1454 
1455         point-&gt;flags |= touch_flag;
1456       }
1457     }
</pre>
</td>
</tr>
</table>
<center><a href="afglobal.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afhints.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/smooth/ftsmooth.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftsmerrs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftsmooth.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/smooth/ftsmooth.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftsmooth.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Anti-aliasing renderer interface (body).                             */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2000-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_OBJECTS_H
 22 #include FT_OUTLINE_H
 23 #include &quot;ftsmooth.h&quot;
 24 #include &quot;ftgrays.h&quot;
<span class="line-removed"> 25 #include &quot;ftspic.h&quot;</span>
 26 
 27 #include &quot;ftsmerrs.h&quot;
 28 
 29 
 30   /* initialize renderer -- init its raster */
 31   static FT_Error
 32   ft_smooth_init( FT_Renderer  render )
 33   {




















 34     render-&gt;clazz-&gt;raster_class-&gt;raster_reset( render-&gt;raster, NULL, 0 );
 35 
 36     return 0;
 37   }
 38 
 39 
 40   /* sets render-specific mode */
 41   static FT_Error
 42   ft_smooth_set_mode( FT_Renderer  render,
 43                       FT_ULong     mode_tag,
 44                       FT_Pointer   data )
 45   {
 46     /* we simply pass it to the raster */
 47     return render-&gt;clazz-&gt;raster_class-&gt;raster_set_mode( render-&gt;raster,
 48                                                          mode_tag,
 49                                                          data );
 50   }
 51 
 52   /* transform a given glyph image */
 53   static FT_Error
</pre>
<hr />
<pre>
113     if ( slot-&gt;format != render-&gt;glyph_format )
114     {
115       error = FT_THROW( Invalid_Argument );
116       goto Exit;
117     }
118 
119     /* check mode */
120     if ( mode != required_mode )
121     {
122       error = FT_THROW( Cannot_Render_Glyph );
123       goto Exit;
124     }
125 
126     /* release old bitmap buffer */
127     if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
128     {
129       FT_FREE( bitmap-&gt;buffer );
130       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
131     }
132 
<span class="line-modified">133     ft_glyphslot_preset_bitmap( slot, mode, origin );</span>




134 
135     /* allocate new one */
136     if ( FT_ALLOC_MULT( bitmap-&gt;buffer, bitmap-&gt;rows, bitmap-&gt;pitch ) )
137       goto Exit;
138 
139     slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;
140 
141     x_shift = 64 * -slot-&gt;bitmap_left;
142     y_shift = 64 * -slot-&gt;bitmap_top;
143     if ( bitmap-&gt;pixel_mode == FT_PIXEL_MODE_LCD_V )
144       y_shift += 64 * (FT_Int)bitmap-&gt;rows / 3;
145     else
146       y_shift += 64 * (FT_Int)bitmap-&gt;rows;
147 
148     if ( origin )
149     {
150       x_shift += origin-&gt;x;
151       y_shift += origin-&gt;y;
152     }
153 
</pre>
<hr />
<pre>
203     /* finally apply filtering */
204     if ( hmul || vmul )
205     {
206       FT_Byte*                 lcd_weights;
207       FT_Bitmap_LcdFilterFunc  lcd_filter_func;
208 
209 
210       /* Per-face LCD filtering takes priority if set up. */
211       if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
212       {
213         lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
214         lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
215       }
216       else
217       {
218         lcd_weights     = slot-&gt;library-&gt;lcd_weights;
219         lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
220       }
221 
222       if ( lcd_filter_func )
<span class="line-modified">223         lcd_filter_func( bitmap, mode, lcd_weights );</span>
224     }
225 
226 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
227 
228     if ( hmul )  /* lcd */
229     {
230       FT_Byte*  line;
231       FT_Byte*  temp = NULL;
232       FT_UInt   i, j;
233 
234       unsigned int  height = bitmap-&gt;rows;
235       unsigned int  width  = bitmap-&gt;width;
236       int           pitch  = bitmap-&gt;pitch;
237 

238 
<span class="line-removed">239       /* Render 3 separate monochrome bitmaps, shifting the outline  */</span>
<span class="line-removed">240       /* by 1/3 pixel.                                               */</span>
<span class="line-removed">241       width /= 3;</span>
242 
<span class="line-modified">243       bitmap-&gt;buffer += width;</span>

244 



245       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
246       if ( error )
247         goto Exit;
248 
<span class="line-removed">249       FT_Outline_Translate( outline, -21, 0 );</span>
<span class="line-removed">250       x_shift        -= 21;</span>
251       bitmap-&gt;buffer += width;
<span class="line-modified">252 </span>


253       error = render-&gt;raster_render( render-&gt;raster, &amp;params );

254       if ( error )
255         goto Exit;
256 
<span class="line-modified">257       FT_Outline_Translate( outline,  42, 0 );</span>
<span class="line-modified">258       x_shift        += 42;</span>
<span class="line-modified">259       bitmap-&gt;buffer -= 2 * width;</span>
<span class="line-modified">260 </span>
261       error = render-&gt;raster_render( render-&gt;raster, &amp;params );

262       if ( error )
263         goto Exit;
264 



265       /* XXX: Rearrange the bytes according to FT_PIXEL_MODE_LCD.    */
266       /* XXX: It is more efficient to render every third byte above. */
267 
268       if ( FT_ALLOC( temp, (FT_ULong)pitch ) )
269         goto Exit;
270 
271       for ( i = 0; i &lt; height; i++ )
272       {
273         line = bitmap-&gt;buffer + i * (FT_ULong)pitch;
274         for ( j = 0; j &lt; width; j++ )
275         {
276           temp[3 * j    ] = line[j];
277           temp[3 * j + 1] = line[j + width];
278           temp[3 * j + 2] = line[j + width + width];
279         }
280         FT_MEM_COPY( line, temp, pitch );
281       }
282 
283       FT_FREE( temp );
284     }
285     else if ( vmul )  /* lcd_v */
286     {
287       int  pitch  = bitmap-&gt;pitch;
288 


289 
<span class="line-modified">290       /* Render 3 separate monochrome bitmaps, shifting the outline  */</span>
<span class="line-modified">291       /* by 1/3 pixel. Triple the pitch to render on each third row. */</span>

292       bitmap-&gt;pitch *= 3;
293       bitmap-&gt;rows  /= 3;
294 
<span class="line-modified">295       bitmap-&gt;buffer += pitch;</span>
<span class="line-modified">296 </span>

297       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
298       if ( error )
299         goto Exit;
300 
<span class="line-removed">301       FT_Outline_Translate( outline, 0,  21 );</span>
<span class="line-removed">302       y_shift        += 21;</span>
303       bitmap-&gt;buffer += pitch;
<span class="line-modified">304 </span>


305       error = render-&gt;raster_render( render-&gt;raster, &amp;params );

306       if ( error )
307         goto Exit;
308 
<span class="line-modified">309       FT_Outline_Translate( outline, 0, -42 );</span>
<span class="line-modified">310       y_shift        -= 42;</span>
<span class="line-modified">311       bitmap-&gt;buffer -= 2 * pitch;</span>
<span class="line-modified">312 </span>
313       error = render-&gt;raster_render( render-&gt;raster, &amp;params );

314       if ( error )
315         goto Exit;
316 



317       bitmap-&gt;pitch /= 3;
318       bitmap-&gt;rows  *= 3;
319     }
320     else  /* grayscale */
321       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
322 
323 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
324 
325   Exit:
326     if ( !error )
327     {
328       /* everything is fine; the glyph is now officially a bitmap */
329       slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;
330     }
331     else if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
332     {
333       FT_FREE( bitmap-&gt;buffer );
334       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
335     }
336 
</pre>
<hr />
<pre>
386       FT_MODULE_RENDERER,
387       sizeof ( FT_RendererRec ),
388 
389       &quot;smooth&quot;,
390       0x10000L,
391       0x20000L,
392 
393       NULL,    /* module specific interface */
394 
395       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
396       (FT_Module_Destructor) NULL,            /* module_done   */
397       (FT_Module_Requester)  NULL,            /* get_interface */
398 
399     FT_GLYPH_FORMAT_OUTLINE,
400 
401     (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
402     (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
403     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
404     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */
405 
<span class="line-modified">406     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET           /* raster_class    */</span>
407   )
408 
409 
410   FT_DEFINE_RENDERER(
411     ft_smooth_lcd_renderer_class,
412 
413       FT_MODULE_RENDERER,
414       sizeof ( FT_RendererRec ),
415 
416       &quot;smooth-lcd&quot;,
417       0x10000L,
418       0x20000L,
419 
420       NULL,    /* module specific interface */
421 
422       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
423       (FT_Module_Destructor) NULL,            /* module_done   */
424       (FT_Module_Requester)  NULL,            /* get_interface */
425 
426     FT_GLYPH_FORMAT_OUTLINE,
427 
428     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
429     (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
430     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
431     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */
432 
<span class="line-modified">433     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET            /* raster_class    */</span>
434   )
435 
436 
437   FT_DEFINE_RENDERER(
438     ft_smooth_lcdv_renderer_class,
439 
440       FT_MODULE_RENDERER,
441       sizeof ( FT_RendererRec ),
442 
443       &quot;smooth-lcdv&quot;,
444       0x10000L,
445       0x20000L,
446 
447       NULL,    /* module specific interface */
448 
449       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
450       (FT_Module_Destructor) NULL,            /* module_done   */
451       (FT_Module_Requester)  NULL,            /* get_interface */
452 
453     FT_GLYPH_FORMAT_OUTLINE,
454 
455     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
456     (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
457     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
458     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */
459 
<span class="line-modified">460     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET              /* raster_class    */</span>
461   )
462 
463 
464 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftsmooth.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Anti-aliasing renderer interface (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2000-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_OBJECTS_H
 22 #include FT_OUTLINE_H
 23 #include &quot;ftsmooth.h&quot;
 24 #include &quot;ftgrays.h&quot;

 25 
 26 #include &quot;ftsmerrs.h&quot;
 27 
 28 
 29   /* initialize renderer -- init its raster */
 30   static FT_Error
 31   ft_smooth_init( FT_Renderer  render )
 32   {
<span class="line-added"> 33 </span>
<span class="line-added"> 34 #ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING</span>
<span class="line-added"> 35 </span>
<span class="line-added"> 36     FT_Vector*  sub = render-&gt;root.library-&gt;lcd_geometry;</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38 </span>
<span class="line-added"> 39     /* set up default subpixel geometry for striped RGB panels. */</span>
<span class="line-added"> 40     sub[0].x = -21;</span>
<span class="line-added"> 41     sub[0].y = 0;</span>
<span class="line-added"> 42     sub[1].x = 0;</span>
<span class="line-added"> 43     sub[1].y = 0;</span>
<span class="line-added"> 44     sub[2].x = 21;</span>
<span class="line-added"> 45     sub[2].y = 0;</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 #elif 0   /* or else, once ClearType patents expire */</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49     FT_Library_SetLcdFilter( render-&gt;root.library, FT_LCD_FILTER_DEFAULT );</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 #endif</span>
<span class="line-added"> 52 </span>
 53     render-&gt;clazz-&gt;raster_class-&gt;raster_reset( render-&gt;raster, NULL, 0 );
 54 
 55     return 0;
 56   }
 57 
 58 
 59   /* sets render-specific mode */
 60   static FT_Error
 61   ft_smooth_set_mode( FT_Renderer  render,
 62                       FT_ULong     mode_tag,
 63                       FT_Pointer   data )
 64   {
 65     /* we simply pass it to the raster */
 66     return render-&gt;clazz-&gt;raster_class-&gt;raster_set_mode( render-&gt;raster,
 67                                                          mode_tag,
 68                                                          data );
 69   }
 70 
 71   /* transform a given glyph image */
 72   static FT_Error
</pre>
<hr />
<pre>
132     if ( slot-&gt;format != render-&gt;glyph_format )
133     {
134       error = FT_THROW( Invalid_Argument );
135       goto Exit;
136     }
137 
138     /* check mode */
139     if ( mode != required_mode )
140     {
141       error = FT_THROW( Cannot_Render_Glyph );
142       goto Exit;
143     }
144 
145     /* release old bitmap buffer */
146     if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
147     {
148       FT_FREE( bitmap-&gt;buffer );
149       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
150     }
151 
<span class="line-modified">152     if ( ft_glyphslot_preset_bitmap( slot, mode, origin ) )</span>
<span class="line-added">153     {</span>
<span class="line-added">154       error = FT_THROW( Raster_Overflow );</span>
<span class="line-added">155       goto Exit;</span>
<span class="line-added">156     }</span>
157 
158     /* allocate new one */
159     if ( FT_ALLOC_MULT( bitmap-&gt;buffer, bitmap-&gt;rows, bitmap-&gt;pitch ) )
160       goto Exit;
161 
162     slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;
163 
164     x_shift = 64 * -slot-&gt;bitmap_left;
165     y_shift = 64 * -slot-&gt;bitmap_top;
166     if ( bitmap-&gt;pixel_mode == FT_PIXEL_MODE_LCD_V )
167       y_shift += 64 * (FT_Int)bitmap-&gt;rows / 3;
168     else
169       y_shift += 64 * (FT_Int)bitmap-&gt;rows;
170 
171     if ( origin )
172     {
173       x_shift += origin-&gt;x;
174       y_shift += origin-&gt;y;
175     }
176 
</pre>
<hr />
<pre>
226     /* finally apply filtering */
227     if ( hmul || vmul )
228     {
229       FT_Byte*                 lcd_weights;
230       FT_Bitmap_LcdFilterFunc  lcd_filter_func;
231 
232 
233       /* Per-face LCD filtering takes priority if set up. */
234       if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
235       {
236         lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
237         lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
238       }
239       else
240       {
241         lcd_weights     = slot-&gt;library-&gt;lcd_weights;
242         lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
243       }
244 
245       if ( lcd_filter_func )
<span class="line-modified">246         lcd_filter_func( bitmap, lcd_weights );</span>
247     }
248 
249 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
250 
251     if ( hmul )  /* lcd */
252     {
253       FT_Byte*  line;
254       FT_Byte*  temp = NULL;
255       FT_UInt   i, j;
256 
257       unsigned int  height = bitmap-&gt;rows;
258       unsigned int  width  = bitmap-&gt;width;
259       int           pitch  = bitmap-&gt;pitch;
260 
<span class="line-added">261       FT_Vector*  sub = slot-&gt;library-&gt;lcd_geometry;</span>
262 



263 
<span class="line-modified">264       /* Render 3 separate monochrome bitmaps, shifting the outline.  */</span>
<span class="line-added">265       width /= 3;</span>
266 
<span class="line-added">267       FT_Outline_Translate( outline,</span>
<span class="line-added">268                             -sub[0].x,</span>
<span class="line-added">269                             -sub[0].y );</span>
270       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
271       if ( error )
272         goto Exit;
273 


274       bitmap-&gt;buffer += width;
<span class="line-modified">275       FT_Outline_Translate( outline,</span>
<span class="line-added">276                             sub[0].x - sub[1].x,</span>
<span class="line-added">277                             sub[0].y - sub[1].y );</span>
278       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<span class="line-added">279       bitmap-&gt;buffer -= width;</span>
280       if ( error )
281         goto Exit;
282 
<span class="line-modified">283       bitmap-&gt;buffer += 2 * width;</span>
<span class="line-modified">284       FT_Outline_Translate( outline,</span>
<span class="line-modified">285                             sub[1].x - sub[2].x,</span>
<span class="line-modified">286                             sub[1].y - sub[2].y );</span>
287       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<span class="line-added">288       bitmap-&gt;buffer -= 2 * width;</span>
289       if ( error )
290         goto Exit;
291 
<span class="line-added">292       x_shift -= sub[2].x;</span>
<span class="line-added">293       y_shift -= sub[2].y;</span>
<span class="line-added">294 </span>
295       /* XXX: Rearrange the bytes according to FT_PIXEL_MODE_LCD.    */
296       /* XXX: It is more efficient to render every third byte above. */
297 
298       if ( FT_ALLOC( temp, (FT_ULong)pitch ) )
299         goto Exit;
300 
301       for ( i = 0; i &lt; height; i++ )
302       {
303         line = bitmap-&gt;buffer + i * (FT_ULong)pitch;
304         for ( j = 0; j &lt; width; j++ )
305         {
306           temp[3 * j    ] = line[j];
307           temp[3 * j + 1] = line[j + width];
308           temp[3 * j + 2] = line[j + width + width];
309         }
310         FT_MEM_COPY( line, temp, pitch );
311       }
312 
313       FT_FREE( temp );
314     }
315     else if ( vmul )  /* lcd_v */
316     {
317       int  pitch  = bitmap-&gt;pitch;
318 
<span class="line-added">319       FT_Vector*  sub = slot-&gt;library-&gt;lcd_geometry;</span>
<span class="line-added">320 </span>
321 
<span class="line-modified">322       /* Render 3 separate monochrome bitmaps, shifting the outline. */</span>
<span class="line-modified">323       /* Notice that the subpixel geometry vectors are rotated.      */</span>
<span class="line-added">324       /* Triple the pitch to render on each third row.               */</span>
325       bitmap-&gt;pitch *= 3;
326       bitmap-&gt;rows  /= 3;
327 
<span class="line-modified">328       FT_Outline_Translate( outline,</span>
<span class="line-modified">329                             -sub[0].y,</span>
<span class="line-added">330                             sub[0].x );</span>
331       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
332       if ( error )
333         goto Exit;
334 


335       bitmap-&gt;buffer += pitch;
<span class="line-modified">336       FT_Outline_Translate( outline,</span>
<span class="line-added">337                             sub[0].y - sub[1].y,</span>
<span class="line-added">338                             sub[1].x - sub[0].x );</span>
339       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<span class="line-added">340       bitmap-&gt;buffer -= pitch;</span>
341       if ( error )
342         goto Exit;
343 
<span class="line-modified">344       bitmap-&gt;buffer += 2 * pitch;</span>
<span class="line-modified">345       FT_Outline_Translate( outline,</span>
<span class="line-modified">346                             sub[1].y - sub[2].y,</span>
<span class="line-modified">347                             sub[2].x - sub[1].x );</span>
348       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<span class="line-added">349       bitmap-&gt;buffer -= 2 * pitch;</span>
350       if ( error )
351         goto Exit;
352 
<span class="line-added">353       x_shift -= sub[2].y;</span>
<span class="line-added">354       y_shift += sub[2].x;</span>
<span class="line-added">355 </span>
356       bitmap-&gt;pitch /= 3;
357       bitmap-&gt;rows  *= 3;
358     }
359     else  /* grayscale */
360       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
361 
362 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
363 
364   Exit:
365     if ( !error )
366     {
367       /* everything is fine; the glyph is now officially a bitmap */
368       slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;
369     }
370     else if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
371     {
372       FT_FREE( bitmap-&gt;buffer );
373       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
374     }
375 
</pre>
<hr />
<pre>
425       FT_MODULE_RENDERER,
426       sizeof ( FT_RendererRec ),
427 
428       &quot;smooth&quot;,
429       0x10000L,
430       0x20000L,
431 
432       NULL,    /* module specific interface */
433 
434       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
435       (FT_Module_Destructor) NULL,            /* module_done   */
436       (FT_Module_Requester)  NULL,            /* get_interface */
437 
438     FT_GLYPH_FORMAT_OUTLINE,
439 
440     (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
441     (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
442     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
443     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */
444 
<span class="line-modified">445     (FT_Raster_Funcs*)&amp;ft_grays_raster               /* raster_class    */</span>
446   )
447 
448 
449   FT_DEFINE_RENDERER(
450     ft_smooth_lcd_renderer_class,
451 
452       FT_MODULE_RENDERER,
453       sizeof ( FT_RendererRec ),
454 
455       &quot;smooth-lcd&quot;,
456       0x10000L,
457       0x20000L,
458 
459       NULL,    /* module specific interface */
460 
461       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
462       (FT_Module_Destructor) NULL,            /* module_done   */
463       (FT_Module_Requester)  NULL,            /* get_interface */
464 
465     FT_GLYPH_FORMAT_OUTLINE,
466 
467     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
468     (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
469     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
470     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */
471 
<span class="line-modified">472     (FT_Raster_Funcs*)&amp;ft_grays_raster                /* raster_class    */</span>
473   )
474 
475 
476   FT_DEFINE_RENDERER(
477     ft_smooth_lcdv_renderer_class,
478 
479       FT_MODULE_RENDERER,
480       sizeof ( FT_RendererRec ),
481 
482       &quot;smooth-lcdv&quot;,
483       0x10000L,
484       0x20000L,
485 
486       NULL,    /* module specific interface */
487 
488       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
489       (FT_Module_Destructor) NULL,            /* module_done   */
490       (FT_Module_Requester)  NULL,            /* get_interface */
491 
492     FT_GLYPH_FORMAT_OUTLINE,
493 
494     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
495     (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
496     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
497     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */
498 
<span class="line-modified">499     (FT_Raster_Funcs*)&amp;ft_grays_raster                  /* raster_class    */</span>
500   )
501 
502 
503 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="ftsmerrs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftsmooth.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
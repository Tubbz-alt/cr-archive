<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfreetype/src/type1/t1load.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="t1gload.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1load.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/type1/t1load.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,65 +1,65 @@</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  t1load.c                                                               */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*    Type 1 font loader (body).                                           */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  Copyright 1996-2018 by                                                 */</span>
<span class="udiff-line-modified-removed">- /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="udiff-line-modified-removed">- /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="udiff-line-modified-removed">- /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="udiff-line-modified-removed">- /*  this file you indicate that you have read the license and              */</span>
<span class="udiff-line-modified-removed">- /*  understand and accept it fully.                                        */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This is the new and improved Type 1 data loader for FreeType 2.  The  */</span>
<span class="udiff-line-modified-removed">-   /* old loader has several problems: it is slow, complex, difficult to    */</span>
<span class="udiff-line-modified-removed">-   /* maintain, and contains incredible hacks to make it accept some        */</span>
<span class="udiff-line-modified-removed">-   /* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */</span>
<span class="udiff-line-modified-removed">-   /* the Type 1 fonts on my machine still aren&#39;t loaded correctly by it.   */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This version is much simpler, much faster and also easier to read and */</span>
<span class="udiff-line-modified-removed">-   /* maintain by a great order of magnitude.  The idea behind it is to     */</span>
<span class="udiff-line-modified-removed">-   /* _not_ try to read the Type 1 token stream with a state machine (i.e.  */</span>
<span class="udiff-line-modified-removed">-   /* a Postscript-like interpreter) but rather to perform simple pattern   */</span>
<span class="udiff-line-modified-removed">-   /* matching.                                                             */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Indeed, nearly all data definitions follow a simple pattern like      */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*  ... /Field &lt;data&gt; ...                                                */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* where &lt;data&gt; can be a number, a boolean, a string, or an array of     */</span>
<span class="udiff-line-modified-removed">-   /* numbers.  There are a few exceptions, namely the encoding, font name, */</span>
<span class="udiff-line-modified-removed">-   /* charstrings, and subrs; they are handled with a special pattern       */</span>
<span class="udiff-line-modified-removed">-   /* matching routine.                                                     */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* All other common cases are handled very simply.  The matching rules   */</span>
<span class="udiff-line-modified-removed">-   /* are defined in the file `t1tokens.h&#39; through the use of several       */</span>
<span class="udiff-line-modified-removed">-   /* macros calls PARSE_XXX.  This file is included twice here; the first  */</span>
<span class="udiff-line-modified-removed">-   /* time to generate parsing callback functions, the second time to       */</span>
<span class="udiff-line-modified-removed">-   /* generate a table of keywords (with pointers to the associated         */</span>
<span class="udiff-line-modified-removed">-   /* callback functions).                                                  */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The function `parse_dict&#39; simply scans *linearly* a given dictionary  */</span>
<span class="udiff-line-modified-removed">-   /* (either the top-level or private one) and calls the appropriate       */</span>
<span class="udiff-line-modified-removed">-   /* callback when it encounters an immediate keyword.                     */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This is by far the fastest way one can find to parse and read all     */</span>
<span class="udiff-line-modified-removed">-   /* data.                                                                 */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This led to tremendous code size reduction.  Note that later, the     */</span>
<span class="udiff-line-modified-removed">-   /* glyph loader will also be _greatly_ simplified, and the automatic     */</span>
<span class="udiff-line-modified-removed">-   /* hinter will replace the clumsy `t1hinter&#39;.                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-added">+ /****************************************************************************</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * t1load.c</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  *   Type 1 font loader (body).</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 1996-2019 by</span>
<span class="udiff-line-modified-added">+  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * This file is part of the FreeType project, and may only be used,</span>
<span class="udiff-line-modified-added">+  * modified, and distributed under the terms of the FreeType project</span>
<span class="udiff-line-modified-added">+  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="udiff-line-modified-added">+  * this file you indicate that you have read the license and</span>
<span class="udiff-line-modified-added">+  * understand and accept it fully.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This is the new and improved Type 1 data loader for FreeType 2.  The</span>
<span class="udiff-line-modified-added">+    * old loader has several problems: it is slow, complex, difficult to</span>
<span class="udiff-line-modified-added">+    * maintain, and contains incredible hacks to make it accept some</span>
<span class="udiff-line-modified-added">+    * ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of</span>
<span class="udiff-line-modified-added">+    * the Type 1 fonts on my machine still aren&#39;t loaded correctly by it.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This version is much simpler, much faster and also easier to read and</span>
<span class="udiff-line-modified-added">+    * maintain by a great order of magnitude.  The idea behind it is to</span>
<span class="udiff-line-modified-added">+    * _not_ try to read the Type 1 token stream with a state machine (i.e.</span>
<span class="udiff-line-modified-added">+    * a Postscript-like interpreter) but rather to perform simple pattern</span>
<span class="udiff-line-modified-added">+    * matching.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Indeed, nearly all data definitions follow a simple pattern like</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * ... /Field &lt;data&gt; ...</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * where &lt;data&gt; can be a number, a boolean, a string, or an array of</span>
<span class="udiff-line-modified-added">+    * numbers.  There are a few exceptions, namely the encoding, font name,</span>
<span class="udiff-line-modified-added">+    * charstrings, and subrs; they are handled with a special pattern</span>
<span class="udiff-line-modified-added">+    * matching routine.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * All other common cases are handled very simply.  The matching rules</span>
<span class="udiff-line-modified-added">+    * are defined in the file `t1tokens.h&#39; through the use of several</span>
<span class="udiff-line-modified-added">+    * macros calls PARSE_XXX.  This file is included twice here; the first</span>
<span class="udiff-line-modified-added">+    * time to generate parsing callback functions, the second time to</span>
<span class="udiff-line-modified-added">+    * generate a table of keywords (with pointers to the associated</span>
<span class="udiff-line-modified-added">+    * callback functions).</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The function `parse_dict&#39; simply scans *linearly* a given dictionary</span>
<span class="udiff-line-modified-added">+    * (either the top-level or private one) and calls the appropriate</span>
<span class="udiff-line-modified-added">+    * callback when it encounters an immediate keyword.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This is by far the fastest way one can find to parse and read all</span>
<span class="udiff-line-modified-added">+    * data.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This led to tremendous code size reduction.  Note that later, the</span>
<span class="udiff-line-modified-added">+    * glyph loader will also be _greatly_ simplified, and the automatic</span>
<span class="udiff-line-modified-added">+    * hinter will replace the clumsy `t1hinter&#39;.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    */</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_INTERNAL_DEBUG_H
  #include FT_CONFIG_CONFIG_H
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -71,24 +71,24 @@</span>
  #include &quot;t1load.h&quot;
  #include &quot;t1errors.h&quot;
  
  
  #ifdef FT_CONFIG_OPTION_INCREMENTAL
<span class="udiff-line-modified-removed">- #define IS_INCREMENTAL  (FT_Bool)( face-&gt;root.internal-&gt;incremental_interface != 0 )</span>
<span class="udiff-line-modified-added">+ #define IS_INCREMENTAL  FT_BOOL( face-&gt;root.internal-&gt;incremental_interface )</span>
  #else
  #define IS_INCREMENTAL  0
  #endif
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="udiff-line-modified-removed">-   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="udiff-line-modified-removed">-   /* messages during execution.                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="udiff-line-modified-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="udiff-line-modified-added">+    * messages during execution.</span>
<span class="udiff-line-modified-added">+    */</span>
  #undef  FT_COMPONENT
<span class="udiff-line-modified-removed">- #define FT_COMPONENT  trace_t1load</span>
<span class="udiff-line-modified-added">+ #define FT_COMPONENT  t1load</span>
  
  
  #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,15 +220,15 @@</span>
  
      return error;
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Given a normalized (blend) coordinate, figure out the design          */</span>
<span class="udiff-line-modified-removed">-   /* coordinate appropriate for that value.                                */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Given a normalized (blend) coordinate, figure out the design</span>
<span class="udiff-line-modified-added">+    * coordinate appropriate for that value.</span>
<span class="udiff-line-modified-added">+    */</span>
    static FT_Fixed
    mm_axis_unmap( PS_DesignMap  axismap,
                   FT_Fixed      ncv )
    {
      int  j;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -249,15 +249,15 @@</span>
  
      return INT_TO_FIXED( axismap-&gt;design_points[axismap-&gt;num_points - 1] );
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Given a vector of weights, one for each design, figure out the        */</span>
<span class="udiff-line-modified-removed">-   /* normalized axis coordinates which gave rise to those weights.         */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Given a vector of weights, one for each design, figure out the</span>
<span class="udiff-line-modified-added">+    * normalized axis coordinates which gave rise to those weights.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    mm_weights_unmap( FT_Fixed*  weights,
                      FT_Fixed*  axiscoords,
                      FT_UInt    axis_count )
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -291,15 +291,15 @@</span>
                          weights[11] + weights[10] + weights[9] + weights[8];
      }
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Just a wrapper around T1_Get_Multi_Master to support the different    */</span>
<span class="udiff-line-modified-removed">-   /*  arguments needed by the GX var distortable fonts.                    */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Just a wrapper around T1_Get_Multi_Master to support the different</span>
<span class="udiff-line-modified-added">+    * arguments needed by the GX var distortable fonts.</span>
<span class="udiff-line-modified-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    T1_Get_MM_Var( T1_Face      face,
                   FT_MM_Var*  *master )
    {
      FT_Memory        memory = face-&gt;root.memory;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -346,20 +346,17 @@</span>
          mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39; );
        else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;OpticalSize&quot; ) == 0 )
          mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;o&#39;, &#39;p&#39;, &#39;s&#39;, &#39;z&#39; );
      }
  
<span class="udiff-line-modified-removed">-     if ( blend-&gt;num_designs == ( 1U &lt;&lt; blend-&gt;num_axis ) )</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       mm_weights_unmap( blend-&gt;default_weight_vector,</span>
<span class="udiff-line-removed">-                         axiscoords,</span>
<span class="udiff-line-removed">-                         blend-&gt;num_axis );</span>
<span class="udiff-line-modified-added">+     mm_weights_unmap( blend-&gt;default_weight_vector,</span>
<span class="udiff-line-modified-added">+                       axiscoords,</span>
<span class="udiff-line-modified-added">+                       blend-&gt;num_axis );</span>
  
<span class="udiff-line-modified-removed">-       for ( i = 0; i &lt; mmaster.num_axis; i++ )</span>
<span class="udiff-line-modified-removed">-         mmvar-&gt;axis[i].def = mm_axis_unmap( &amp;blend-&gt;design_map[i],</span>
<span class="udiff-line-modified-removed">-                                             axiscoords[i] );</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     for ( i = 0; i &lt; mmaster.num_axis; i++ )</span>
<span class="udiff-line-modified-added">+       mmvar-&gt;axis[i].def = mm_axis_unmap( &amp;blend-&gt;design_map[i],</span>
<span class="udiff-line-modified-added">+                                           axiscoords[i] );</span>
  
      *master = mmvar;
  
    Exit:
      return error;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -385,28 +382,35 @@</span>
  
      /* recompute the weight vector from the blend coordinates */
      for ( n = 0; n &lt; blend-&gt;num_designs; n++ )
      {
        FT_Fixed  result = 0x10000L;  /* 1.0 fixed */
<span class="udiff-line-added">+       FT_Fixed  factor;</span>
  
  
        for ( m = 0; m &lt; blend-&gt;num_axis; m++ )
        {
<span class="udiff-line-removed">-         FT_Fixed  factor;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         /* get current blend axis position;                  */</span>
          /* use a default value if we don&#39;t have a coordinate */
<span class="udiff-line-modified-removed">-         factor = m &lt; num_coords ? coords[m] : 0x8000;</span>
<span class="udiff-line-modified-removed">-         if ( factor &lt; 0 )</span>
<span class="udiff-line-modified-removed">-           factor = 0;</span>
<span class="udiff-line-modified-removed">-         if ( factor &gt; 0x10000L )</span>
<span class="udiff-line-modified-removed">-           factor = 0x10000L;</span>
<span class="udiff-line-modified-added">+         if ( m &gt;= num_coords )</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           result &gt;&gt;= 1;</span>
<span class="udiff-line-modified-added">+           continue;</span>
<span class="udiff-line-modified-added">+         }</span>
  
<span class="udiff-line-added">+         /* get current blend axis position */</span>
<span class="udiff-line-added">+         factor = coords[m];</span>
          if ( ( n &amp; ( 1 &lt;&lt; m ) ) == 0 )
            factor = 0x10000L - factor;
  
<span class="udiff-line-added">+         if ( factor &lt;= 0 )</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           result = 0;</span>
<span class="udiff-line-added">+           break;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+         else if ( factor &gt;= 0x10000L )</span>
<span class="udiff-line-added">+           continue;</span>
<span class="udiff-line-added">+ </span>
          result = FT_MulFix( result, factor );
        }
  
        if ( blend-&gt;weight_vector[n] != result )
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -474,10 +478,79 @@</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="udiff-line-added">+   FT_LOCAL_DEF( FT_Error )</span>
<span class="udiff-line-added">+   T1_Set_MM_WeightVector( T1_Face    face,</span>
<span class="udiff-line-added">+                           FT_UInt    len,</span>
<span class="udiff-line-added">+                           FT_Fixed*  weightvector )</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     PS_Blend  blend = face-&gt;blend;</span>
<span class="udiff-line-added">+     FT_UInt   i, n;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ( !blend )</span>
<span class="udiff-line-added">+      return FT_THROW( Invalid_Argument );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ( !len &amp;&amp; !weightvector )</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="udiff-line-added">+         blend-&gt;weight_vector[i] = blend-&gt;default_weight_vector[i];</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       if ( !weightvector )</span>
<span class="udiff-line-added">+         return FT_THROW( Invalid_Argument );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       n = len &lt; blend-&gt;num_designs ? len : blend-&gt;num_designs;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       for ( i = 0; i &lt; n; i++ )</span>
<span class="udiff-line-added">+         blend-&gt;weight_vector[i] = weightvector[i];</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       for ( ; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="udiff-line-added">+         blend-&gt;weight_vector[i] = (FT_Fixed)0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if ( len )</span>
<span class="udiff-line-added">+         face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;</span>
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+         face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return FT_Err_Ok;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   FT_LOCAL_DEF( FT_Error )</span>
<span class="udiff-line-added">+   T1_Get_MM_WeightVector( T1_Face    face,</span>
<span class="udiff-line-added">+                           FT_UInt*   len,</span>
<span class="udiff-line-added">+                           FT_Fixed*  weightvector )</span>
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     PS_Blend  blend = face-&gt;blend;</span>
<span class="udiff-line-added">+     FT_UInt   i;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ( !blend )</span>
<span class="udiff-line-added">+       return FT_THROW( Invalid_Argument );</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if ( *len &lt; blend-&gt;num_designs )</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       *len = blend-&gt;num_designs;</span>
<span class="udiff-line-added">+       return FT_THROW( Invalid_Argument );</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="udiff-line-added">+       weightvector[i] = blend-&gt;weight_vector[i];</span>
<span class="udiff-line-added">+     for ( ; i &lt; *len; i++ )</span>
<span class="udiff-line-added">+       weightvector[i] = (FT_Fixed)0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     *len = blend-&gt;num_designs;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return FT_Err_Ok;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
    FT_LOCAL_DEF( FT_Error )
    T1_Set_MM_Design( T1_Face   face,
                      FT_UInt   num_coords,
                      FT_Long*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -571,15 +644,15 @@</span>
  
      return T1_Set_MM_Blend( face, 0, NULL );
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Just a wrapper around T1_Set_MM_Design to support the different       */</span>
<span class="udiff-line-modified-removed">-   /* arguments needed by the GX var distortable fonts.                     */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Just a wrapper around T1_Set_MM_Design to support the different</span>
<span class="udiff-line-modified-added">+    * arguments needed by the GX var distortable fonts.</span>
<span class="udiff-line-modified-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    T1_Set_Var_Design( T1_Face    face,
                       FT_UInt    num_coords,
                       FT_Fixed*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -717,10 +790,12 @@</span>
      /* allocate blend if necessary */
      error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
      if ( error )
        goto Exit;
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+ </span>
      blend  = face-&gt;blend;
      memory = face-&gt;root.memory;
  
      /* each token is an immediate containing the name of the axis */
      for ( n = 0; n &lt; num_axis; n++ )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -739,15 +814,17 @@</span>
        {
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
        }
  
<span class="udiff-line-added">+       FT_TRACE4(( &quot; /%.*s&quot;, len, token-&gt;start ));</span>
<span class="udiff-line-added">+ </span>
        name = (FT_Byte*)blend-&gt;axis_names[n];
        if ( name )
        {
          FT_TRACE0(( &quot;parse_blend_axis_types:&quot;
<span class="udiff-line-modified-removed">-                     &quot; overwriting axis name `%s&#39; with `%*.s&#39;\n&quot;,</span>
<span class="udiff-line-modified-added">+                     &quot; overwriting axis name `%s&#39; with `%.*s&#39;\n&quot;,</span>
                      name, len, token-&gt;start ));
          FT_FREE( name );
        }
  
        if ( FT_ALLOC( blend-&gt;axis_names[n], len + 1 ) )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -756,10 +833,12 @@</span>
        name = (FT_Byte*)blend-&gt;axis_names[n];
        FT_MEM_COPY( name, token-&gt;start, len );
        name[len] = &#39;\0&#39;;
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+ </span>
    Exit:
      loader-&gt;parser.root.error = error;
    }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -800,10 +879,12 @@</span>
  
  
        blend    = face-&gt;blend;
        num_axis = 0;  /* make compiler happy */
  
<span class="udiff-line-added">+       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+ </span>
        for ( n = 0; n &lt; num_designs; n++ )
        {
          T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
          T1_Token     token;
          FT_Int       axis, n_axis;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -840,21 +921,26 @@</span>
            error = FT_THROW( Invalid_File_Format );
            goto Exit;
          }
  
          /* now read each axis token into the design position */
<span class="udiff-line-added">+         FT_TRACE4(( &quot; [&quot; )) ;</span>
          for ( axis = 0; axis &lt; n_axis; axis++ )
          {
            T1_Token  token2 = axis_tokens + axis;
  
  
            parser-&gt;root.cursor = token2-&gt;start;
            parser-&gt;root.limit  = token2-&gt;limit;
            blend-&gt;design_pos[n][axis] = T1_ToFixed( parser, 0 );
<span class="udiff-line-added">+           FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;design_pos[n][axis] / 65536 ));</span>
          }
<span class="udiff-line-added">+         FT_TRACE4(( &quot;]&quot; )) ;</span>
        }
  
<span class="udiff-line-added">+       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+ </span>
        loader-&gt;parser.root.cursor = old_cursor;
        loader-&gt;parser.root.limit  = old_limit;
      }
  
    Exit:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -897,10 +983,12 @@</span>
      error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
      if ( error )
        goto Exit;
      blend = face-&gt;blend;
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+ </span>
      /* now read each axis design map */
      for ( n = 0; n &lt; num_axis; n++ )
      {
        PS_DesignMap  map = blend-&gt;design_map + n;
        T1_Token      axis_token;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -913,10 +1001,12 @@</span>
        parser-&gt;root.cursor = axis_token-&gt;start;
        parser-&gt;root.limit  = axis_token-&gt;limit;
        T1_ToTokenArray( parser, point_tokens,
                         T1_MAX_MM_MAP_POINTS, &amp;num_points );
  
<span class="udiff-line-added">+       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+ </span>
        if ( num_points &lt;= 0 || num_points &gt; T1_MAX_MM_MAP_POINTS )
        {
          FT_ERROR(( &quot;parse_blend_design_map: incorrect table\n&quot; ));
          error = FT_THROW( Invalid_File_Format );
          goto Exit;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -946,13 +1036,21 @@</span>
          parser-&gt;root.cursor = point_token-&gt;start + 1;
          parser-&gt;root.limit  = point_token-&gt;limit - 1;
  
          map-&gt;design_points[p] = T1_ToInt( parser );
          map-&gt;blend_points [p] = T1_ToFixed( parser, 0 );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         FT_TRACE4(( &quot; [%d %f]&quot;,</span>
<span class="udiff-line-added">+                     map-&gt;design_points[p],</span>
<span class="udiff-line-added">+                     (double)map-&gt;blend_points[p] / 65536 ));</span>
        }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;]&quot; ));</span>
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+ </span>
      parser-&gt;root.cursor = old_cursor;
      parser-&gt;root.limit  = old_limit;
  
    Exit:
      parser-&gt;root.error = error;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1008,20 +1106,26 @@</span>
      }
  
      old_cursor = parser-&gt;root.cursor;
      old_limit  = parser-&gt;root.limit;
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;[&quot; ));</span>
<span class="udiff-line-added">+ </span>
      for ( n = 0; n &lt; num_designs; n++ )
      {
        token = design_tokens + n;
        parser-&gt;root.cursor = token-&gt;start;
        parser-&gt;root.limit  = token-&gt;limit;
  
        blend-&gt;default_weight_vector[n] =
        blend-&gt;weight_vector[n]         = T1_ToFixed( parser, 0 );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;weight_vector[n] / 65536 ));</span>
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+ </span>
      parser-&gt;root.cursor = old_cursor;
      parser-&gt;root.limit  = old_limit;
  
    Exit:
      parser-&gt;root.error = error;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1034,10 +1138,24 @@</span>
    parse_buildchar( T1_Face    face,
                     T1_Loader  loader )
    {
      face-&gt;len_buildchar = (FT_UInt)T1_ToFixedArray( &amp;loader-&gt;parser,
                                                      0, NULL, 0 );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       FT_UInt  i;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+       for ( i = 0; i &lt; face-&gt;len_buildchar; i++ )</span>
<span class="udiff-line-added">+         FT_TRACE4(( &quot; 0&quot; ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      return;
    }
  
  
  #endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1069,10 +1187,12 @@</span>
        blend = NULL;
  
      /* if the keyword has a dedicated callback, call it */
      if ( field-&gt;type == T1_FIELD_TYPE_CALLBACK )
      {
<span class="udiff-line-added">+       FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="udiff-line-added">+ </span>
        field-&gt;reader( (FT_Face)face, loader );
        error = loader-&gt;parser.root.error;
        goto Exit;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1146,10 +1266,12 @@</span>
        dummy_object = &amp;face-&gt;type1;
        objects      = &amp;dummy_object;
        max_objects  = 0;
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="udiff-line-added">+ </span>
      if ( *objects )
      {
        if ( field-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
             field-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
          error = T1_Load_Field_Table( &amp;loader-&gt;parser, field,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1165,10 +1287,12 @@</span>
                    &quot;                 (probably due to missing keywords)\n&quot;,
                   field-&gt;ident ));
        error = FT_Err_Ok;
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot;\n&quot; ));</span>
<span class="udiff-line-added">+ </span>
    Exit:
      return error;
    }
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1177,10 +1301,12 @@</span>
                   T1_Loader  loader )
    {
      FT_UNUSED( face );
  
      loader-&gt;keywords_encountered |= T1_PRIVATE;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     FT_TRACE4(( &quot;\n&quot; ));</span>
    }
  
  
    /* return 1 in case of success */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1256,10 +1382,18 @@</span>
      {
        parser-&gt;root.error = FT_THROW( Invalid_File_Format );
        return;
      }
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,</span>
<span class="udiff-line-added">+                 (double)temp[0] / 65536 / 1000,</span>
<span class="udiff-line-added">+                 (double)temp[1] / 65536 / 1000,</span>
<span class="udiff-line-added">+                 (double)temp[2] / 65536 / 1000,</span>
<span class="udiff-line-added">+                 (double)temp[3] / 65536 / 1000,</span>
<span class="udiff-line-added">+                 (double)temp[4] / 65536 / 1000,</span>
<span class="udiff-line-added">+                 (double)temp[5] / 65536 / 1000 ));</span>
<span class="udiff-line-added">+ </span>
      temp_scale = FT_ABS( temp[3] );
  
      if ( temp_scale == 0 )
      {
        FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1278,16 +1412,22 @@</span>
        temp[2] = FT_DivFix( temp[2], temp_scale );
        temp[4] = FT_DivFix( temp[4], temp_scale );
        temp[5] = FT_DivFix( temp[5], temp_scale );
        temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
      }
<span class="udiff-line-removed">- </span>
      matrix-&gt;xx = temp[0];
      matrix-&gt;yx = temp[1];
      matrix-&gt;xy = temp[2];
      matrix-&gt;yy = temp[3];
  
<span class="udiff-line-added">+     if ( !FT_Matrix_Check( matrix ) )</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));</span>
<span class="udiff-line-added">+       parser-&gt;root.error = FT_THROW( Invalid_File_Format );</span>
<span class="udiff-line-added">+       return;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      /* note that the offsets must be expressed in integer font units */
      offset-&gt;x = temp[4] &gt;&gt; 16;
      offset-&gt;y = temp[5] &gt;&gt; 16;
    }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1365,16 +1505,11 @@</span>
          return;
        }
  
        /* We need to `zero&#39; out encoding_table.elements */
        for ( n = 0; n &lt; array_size; n++ )
<span class="udiff-line-modified-removed">-       {</span>
<span class="udiff-line-removed">-         char*  notdef = (char *)&quot;.notdef&quot;;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         (void)T1_Add_Table( char_table, n, notdef, 8 );</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-modified-added">+         (void)T1_Add_Table( char_table, n, &quot;.notdef&quot;, 8 );</span>
  
        /* Now we need to read records of the form                */
        /*                                                        */
        /*   ... charcode /charname ...                           */
        /*                                                        */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1492,32 +1627,53 @@</span>
          }
  
          T1_Skip_Spaces( parser );
        }
  
<span class="udiff-line-added">+ #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       /* XXX show encoding vector */</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;...&quot; ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
        face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
        parser-&gt;root.cursor       = cur;
      }
  
      /* Otherwise, we should have either `StandardEncoding&#39;, */
      /* `ExpertEncoding&#39;, or `ISOLatin1Encoding&#39;             */
      else
      {
        if ( cur + 17 &lt; limit                                            &amp;&amp;
             ft_strncmp( (const char*)cur, &quot;StandardEncoding&quot;, 16 ) == 0 )
<span class="udiff-line-added">+       {</span>
          face-&gt;type1.encoding_type = T1_ENCODING_TYPE_STANDARD;
<span class="udiff-line-added">+         FT_TRACE4(( &quot; StandardEncoding\n&quot; ));</span>
<span class="udiff-line-added">+       }</span>
  
        else if ( cur + 15 &lt; limit                                          &amp;&amp;
                  ft_strncmp( (const char*)cur, &quot;ExpertEncoding&quot;, 14 ) == 0 )
<span class="udiff-line-added">+       {</span>
          face-&gt;type1.encoding_type = T1_ENCODING_TYPE_EXPERT;
<span class="udiff-line-added">+         FT_TRACE4(( &quot; ExpertEncoding\n&quot; ));</span>
<span class="udiff-line-added">+       }</span>
  
        else if ( cur + 18 &lt; limit                                             &amp;&amp;
                  ft_strncmp( (const char*)cur, &quot;ISOLatin1Encoding&quot;, 17 ) == 0 )
<span class="udiff-line-added">+       {</span>
          face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;
<span class="udiff-line-added">+         FT_TRACE4(( &quot; ISOLatin1Encoding\n&quot; ));</span>
<span class="udiff-line-added">+       }</span>
  
        else
<span class="udiff-line-added">+       {</span>
          parser-&gt;root.error = FT_ERR( Ignore );
<span class="udiff-line-added">+         FT_TRACE4(( &quot;&lt;unknown&gt;\n&quot; ));</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
  
    static void
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1694,10 +1850,19 @@</span>
      }
  
      if ( !loader-&gt;num_subrs )
        loader-&gt;num_subrs = num_subrs;
  
<span class="udiff-line-added">+ #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       /* XXX show subrs? */</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;%d elements&quot;, num_subrs ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      return;
  
    Fail:
      parser-&gt;root.error = error;
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1975,11 +2140,10 @@</span>
        /* We take index 0 and add it to the end of the table(s)    */
        /* and add our own /.notdef glyph to index 0.               */
  
        /* 0 333 hsbw endchar */
        FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };
<span class="udiff-line-removed">-       char*    notdef_name    = (char *)&quot;.notdef&quot;;</span>
  
  
        error = T1_Add_Table( swap_table, 0,
                              name_table-&gt;elements[0],
                              name_table-&gt;lengths [0] );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1990,11 +2154,11 @@</span>
                              code_table-&gt;elements[0],
                              code_table-&gt;lengths [0] );
        if ( error )
          goto Fail;
  
<span class="udiff-line-modified-removed">-       error = T1_Add_Table( name_table, 0, notdef_name, 8 );</span>
<span class="udiff-line-modified-added">+       error = T1_Add_Table( name_table, 0, &quot;.notdef&quot;, 8 );</span>
        if ( error )
          goto Fail;
  
        error = T1_Add_Table( code_table, 0, notdef_glyph, 5 );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2015,23 +2179,32 @@</span>
  
        /* we added a glyph. */
        loader-&gt;num_glyphs += 1;
      }
  
<span class="udiff-line-added">+ #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       /* XXX show charstrings? */</span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;%d elements&quot;, loader-&gt;num_glyphs ));</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="udiff-line-added">+ #endif</span>
<span class="udiff-line-added">+ </span>
      return;
  
    Fail:
      parser-&gt;root.error = error;
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Define the token field static variables.  This is a set of            */</span>
<span class="udiff-line-modified-removed">-   /* T1_FieldRec variables.                                                */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Define the token field static variables.  This is a set of</span>
<span class="udiff-line-modified-added">+    * T1_FieldRec variables.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    */</span>
  
  
    static
    const T1_FieldRec  t1_keywords[] =
    {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2214,10 +2387,11 @@</span>
                const FT_UInt dict =
                  ( loader-&gt;keywords_encountered &amp; T1_PRIVATE )
                      ? T1_FIELD_DICT_PRIVATE
                      : T1_FIELD_DICT_FONTDICT;
  
<span class="udiff-line-added">+ </span>
                if ( !( dict &amp; keyword-&gt;dict ) )
                {
                  FT_TRACE1(( &quot;parse_dict: found `%s&#39; but ignoring it&quot;
                              &quot; since it is in the wrong dictionary\n&quot;,
                              keyword-&gt;ident ));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2328,29 +2502,41 @@</span>
                              face-&gt;root.memory,
                              psaux );
      if ( error )
        goto Exit;
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot; top dictionary:\n&quot; ));</span>
      error = parse_dict( face, &amp;loader,
                          parser-&gt;base_dict, parser-&gt;base_len );
      if ( error )
        goto Exit;
  
      error = T1_Get_Private_Dict( parser, psaux );
      if ( error )
        goto Exit;
  
<span class="udiff-line-added">+     FT_TRACE4(( &quot; private dictionary:\n&quot; ));</span>
      error = parse_dict( face, &amp;loader,
                          parser-&gt;private_dict, parser-&gt;private_len );
      if ( error )
        goto Exit;
  
      /* ensure even-ness of `num_blue_values&#39; */
      priv-&gt;num_blue_values &amp;= ~1;
  
  #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
  
<span class="udiff-line-added">+     /* we don&#39;t support Multiple Master fonts with intermediate designs; */</span>
<span class="udiff-line-added">+     /* this implies that `num_designs&#39; must be equal to `2^^num_axis&#39;    */</span>
<span class="udiff-line-added">+     if ( face-&gt;blend                                                 &amp;&amp;</span>
<span class="udiff-line-added">+          face-&gt;blend-&gt;num_designs != ( 1U &lt;&lt; face-&gt;blend-&gt;num_axis ) )</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       FT_ERROR(( &quot;T1_Open_Face:&quot;</span>
<span class="udiff-line-added">+                  &quot; number-of-designs != 2 ^^ number-of-axes\n&quot; ));</span>
<span class="udiff-line-added">+       T1_Done_Blend( face );</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      if ( face-&gt;blend                                                     &amp;&amp;
           face-&gt;blend-&gt;num_default_design_vector != 0                     &amp;&amp;
           face-&gt;blend-&gt;num_default_design_vector != face-&gt;blend-&gt;num_axis )
      {
        /* we don&#39;t use it currently so just warn, reset, and ignore */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2439,12 +2625,11 @@</span>
      loader.glyph_names.elements = NULL;
  
      /* we must now build type1.encoding when we have a custom array */
      if ( type1-&gt;encoding_type == T1_ENCODING_TYPE_ARRAY )
      {
<span class="udiff-line-modified-removed">-       FT_Int    charcode, idx, min_char, max_char;</span>
<span class="udiff-line-removed">-       FT_Byte*  glyph_name;</span>
<span class="udiff-line-modified-added">+       FT_Int  charcode, idx, min_char, max_char;</span>
  
  
        /* OK, we do the following: for each element in the encoding  */
        /* table, look up the index of the glyph having the same name */
        /* the index is then stored in type1.encoding.char_index, and */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2454,31 +2639,31 @@</span>
        max_char = 0;
  
        charcode = 0;
        for ( ; charcode &lt; loader.encoding_table.max_elems; charcode++ )
        {
<span class="udiff-line-modified-removed">-         FT_Byte*  char_name;</span>
<span class="udiff-line-modified-added">+         const FT_String*  char_name =</span>
<span class="udiff-line-added">+               (const FT_String*)loader.encoding_table.elements[charcode];</span>
  
  
          type1-&gt;encoding.char_index[charcode] = 0;
<span class="udiff-line-modified-removed">-         type1-&gt;encoding.char_name [charcode] = (char *)&quot;.notdef&quot;;</span>
<span class="udiff-line-modified-added">+         type1-&gt;encoding.char_name [charcode] = &quot;.notdef&quot;;</span>
  
<span class="udiff-line-removed">-         char_name = loader.encoding_table.elements[charcode];</span>
          if ( char_name )
            for ( idx = 0; idx &lt; type1-&gt;num_glyphs; idx++ )
            {
<span class="udiff-line-modified-removed">-             glyph_name = (FT_Byte*)type1-&gt;glyph_names[idx];</span>
<span class="udiff-line-modified-removed">-             if ( ft_strcmp( (const char*)char_name,</span>
<span class="udiff-line-modified-removed">-                             (const char*)glyph_name ) == 0 )</span>
<span class="udiff-line-modified-added">+             const FT_String*  glyph_name = type1-&gt;glyph_names[idx];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+             if ( ft_strcmp( char_name, glyph_name ) == 0 )</span>
              {
                type1-&gt;encoding.char_index[charcode] = (FT_UShort)idx;
<span class="udiff-line-modified-removed">-               type1-&gt;encoding.char_name [charcode] = (char*)glyph_name;</span>
<span class="udiff-line-modified-added">+               type1-&gt;encoding.char_name [charcode] = glyph_name;</span>
  
                /* Change min/max encoded char only if glyph name is */
                /* not /.notdef                                      */
<span class="udiff-line-modified-removed">-               if ( ft_strcmp( (const char*)&quot;.notdef&quot;,</span>
<span class="udiff-line-removed">-                               (const char*)glyph_name ) != 0 )</span>
<span class="udiff-line-modified-added">+               if ( ft_strcmp( &quot;.notdef&quot;, glyph_name ) != 0 )</span>
                {
                  if ( charcode &lt; min_char )
                    min_char = charcode;
                  if ( charcode &gt;= max_char )
                    max_char = charcode + 1;
</pre>
<center><a href="t1gload.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1load.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/include/freetype/internal/ftcalc.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="cfftypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftdebug.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/include/freetype/internal/ftcalc.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,21 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ftcalc.h                                                               */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Arithmetic computations (specification).                             */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #ifndef FTCALC_H_
  #define FTCALC_H_
  
<span class="line-new-header">--- 1,21 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ftcalc.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Arithmetic computations (specification).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #ifndef FTCALC_H_
  #define FTCALC_H_
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,15 ***</span>
  
  
  FT_BEGIN_HEADER
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* FT_MulDiv() and FT_MulFix() are declared in freetype.h.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
  #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
    /* Provide assembler fragments for performance-critical functions. */
    /* These must be defined `static __inline__&#39; with GCC.             */
  
<span class="line-new-header">--- 25,15 ---</span>
  
  
  FT_BEGIN_HEADER
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * FT_MulDiv() and FT_MulFix() are declared in freetype.h.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
  #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
    /* Provide assembler fragments for performance-critical functions. */
    /* These must be defined `static __inline__&#39; with GCC.             */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,105 ***</span>
  #define FT_MulFix( a, b )  FT_MULFIX_ASSEMBLER( (FT_Int32)(a), (FT_Int32)(b) )
  #endif
  #endif
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    FT_MulDiv_No_Round                                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    A very simple function used to perform the computation `(a*b)/c&#39;   */</span>
<span class="line-modified">!   /*    (without rounding) with maximum accuracy (it uses a 64-bit         */</span>
<span class="line-modified">!   /*    intermediate integer whenever necessary).                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    This function isn&#39;t necessarily as fast as some processor specific */</span>
<span class="line-modified">!   /*    operations, but is at least completely portable.                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    a :: The first multiplier.                                         */</span>
<span class="line-modified">!   /*    b :: The second multiplier.                                        */</span>
<span class="line-modified">!   /*    c :: The divisor.                                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    The result of `(a*b)/c&#39;.  This function never traps when trying to */</span>
<span class="line-modified">!   /*    divide by zero; it simply returns `MaxInt&#39; or `MinInt&#39; depending   */</span>
<span class="line-modified">!   /*    on the signs of `a&#39; and `b&#39;.                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_BASE( FT_Long )
    FT_MulDiv_No_Round( FT_Long  a,
                        FT_Long  b,
                        FT_Long  c );
  
  
    /*
<span class="line-modified">!    *  A variant of FT_Matrix_Multiply which scales its result afterwards.</span>
<span class="line-modified">!    *  The idea is that both `a&#39; and `b&#39; are scaled by factors of 10 so that</span>
<span class="line-modified">!    *  the values are as precise as possible to get a correct result during</span>
<span class="line-modified">!    *  the 64bit multiplication.  Let `sa&#39; and `sb&#39; be the scaling factors of</span>
<span class="line-modified">!    *  `a&#39; and `b&#39;, respectively, then the scaling factor of the result is</span>
<span class="line-removed">-    *  `sa*sb&#39;.</span>
     */
    FT_BASE( void )
    FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                               FT_Matrix        *b,
                               FT_Long           scaling );
  
  
    /*
<span class="line-modified">!    *  A variant of FT_Vector_Transform.  See comments for</span>
<span class="line-modified">!    *  FT_Matrix_Multiply_Scaled.</span>
     */
    FT_BASE( void )
    FT_Vector_Transform_Scaled( FT_Vector*        vector,
                                const FT_Matrix*  matrix,
                                FT_Long           scaling );
  
  
    /*
<span class="line-modified">!    *  This function normalizes a vector and returns its original length.</span>
<span class="line-modified">!    *  The normalized vector is a 16.16 fixed-point unit vector with length</span>
<span class="line-modified">!    *  close to 0x10000.  The accuracy of the returned length is limited to</span>
<span class="line-modified">!    *  16 bits also.  The function utilizes quick inverse square root</span>
<span class="line-modified">!    *  approximation without divisions and square roots relying on Newton&#39;s</span>
<span class="line-modified">!    *  iterations instead.</span>
     */
    FT_BASE( FT_UInt32 )
    FT_Vector_NormLen( FT_Vector*  vector );
  
  
    /*
<span class="line-modified">!    *  Return -1, 0, or +1, depending on the orientation of a given corner.</span>
<span class="line-modified">!    *  We use the Cartesian coordinate system, with positive vertical values</span>
<span class="line-modified">!    *  going upwards.  The function returns +1 if the corner turns to the</span>
<span class="line-modified">!    *  left, -1 to the right, and 0 for undecidable cases.</span>
     */
    FT_BASE( FT_Int )
    ft_corner_orientation( FT_Pos  in_x,
                           FT_Pos  in_y,
                           FT_Pos  out_x,
                           FT_Pos  out_y );
  
  
    /*
<span class="line-modified">!    *  Return TRUE if a corner is flat or nearly flat.  This is equivalent to</span>
<span class="line-modified">!    *  saying that the corner point is close to its neighbors, or inside an</span>
<span class="line-modified">!    *  ellipse defined by the neighbor focal points to be more precise.</span>
     */
    FT_BASE( FT_Int )
    ft_corner_is_flat( FT_Pos  in_x,
                       FT_Pos  in_y,
                       FT_Pos  out_x,
                       FT_Pos  out_y );
  
  
    /*
<span class="line-modified">!    *  Return the most significant bit index.</span>
     */
  
  #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
  #if defined( __GNUC__ )                                          &amp;&amp; \
      ( __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4 ) )
  
  #if FT_SIZEOF_INT == 4
  
<span class="line-new-header">--- 244,123 ---</span>
  #define FT_MulFix( a, b )  FT_MULFIX_ASSEMBLER( (FT_Int32)(a), (FT_Int32)(b) )
  #endif
  #endif
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @function:</span>
<span class="line-modified">!    *   FT_MulDiv_No_Round</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @description:</span>
<span class="line-modified">!    *   A very simple function used to perform the computation &#39;(a*b)/c&#39;</span>
<span class="line-modified">!    *   (without rounding) with maximum accuracy (it uses a 64-bit</span>
<span class="line-modified">!    *   intermediate integer whenever necessary).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   This function isn&#39;t necessarily as fast as some processor-specific</span>
<span class="line-modified">!    *   operations, but is at least completely portable.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @input:</span>
<span class="line-modified">!    *   a ::</span>
<span class="line-modified">!    *     The first multiplier.</span>
<span class="line-modified">!    *   b ::</span>
<span class="line-modified">!    *     The second multiplier.</span>
<span class="line-modified">!    *   c ::</span>
<span class="line-modified">!    *     The divisor.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @return:</span>
<span class="line-modified">!    *   The result of &#39;(a*b)/c&#39;.  This function never traps when trying to</span>
<span class="line-added">+    *   divide by zero; it simply returns &#39;MaxInt&#39; or &#39;MinInt&#39; depending on</span>
<span class="line-added">+    *   the signs of &#39;a&#39; and &#39;b&#39;.</span>
<span class="line-added">+    */</span>
    FT_BASE( FT_Long )
    FT_MulDiv_No_Round( FT_Long  a,
                        FT_Long  b,
                        FT_Long  c );
  
  
    /*
<span class="line-modified">!    * A variant of FT_Matrix_Multiply which scales its result afterwards.  The</span>
<span class="line-modified">!    * idea is that both `a&#39; and `b&#39; are scaled by factors of 10 so that the</span>
<span class="line-modified">!    * values are as precise as possible to get a correct result during the</span>
<span class="line-modified">!    * 64bit multiplication.  Let `sa&#39; and `sb&#39; be the scaling factors of `a&#39;</span>
<span class="line-modified">!    * and `b&#39;, respectively, then the scaling factor of the result is `sa*sb&#39;.</span>
     */
    FT_BASE( void )
    FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
                               FT_Matrix        *b,
                               FT_Long           scaling );
  
  
    /*
<span class="line-modified">!    * Check a matrix.  If the transformation would lead to extreme shear or</span>
<span class="line-modified">!    * extreme scaling, for example, return 0.  If everything is OK, return 1.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * Based on geometric considerations we use the following inequality to</span>
<span class="line-added">+    * identify a degenerate matrix.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   50 * abs(xx*yy - xy*yx) &lt; xx^2 + xy^2 + yx^2 + yy^2</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * Value 50 is heuristic.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   FT_BASE( FT_Bool )</span>
<span class="line-added">+   FT_Matrix_Check( const FT_Matrix*  matrix );</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * A variant of FT_Vector_Transform.  See comments for</span>
<span class="line-added">+    * FT_Matrix_Multiply_Scaled.</span>
     */
    FT_BASE( void )
    FT_Vector_Transform_Scaled( FT_Vector*        vector,
                                const FT_Matrix*  matrix,
                                FT_Long           scaling );
  
  
    /*
<span class="line-modified">!    * This function normalizes a vector and returns its original length.  The</span>
<span class="line-modified">!    * normalized vector is a 16.16 fixed-point unit vector with length close</span>
<span class="line-modified">!    * to 0x10000.  The accuracy of the returned length is limited to 16 bits</span>
<span class="line-modified">!    * also.  The function utilizes quick inverse square root approximation</span>
<span class="line-modified">!    * without divisions and square roots relying on Newton&#39;s iterations</span>
<span class="line-modified">!    * instead.</span>
     */
    FT_BASE( FT_UInt32 )
    FT_Vector_NormLen( FT_Vector*  vector );
  
  
    /*
<span class="line-modified">!    * Return -1, 0, or +1, depending on the orientation of a given corner.  We</span>
<span class="line-modified">!    * use the Cartesian coordinate system, with positive vertical values going</span>
<span class="line-modified">!    * upwards.  The function returns +1 if the corner turns to the left, -1 to</span>
<span class="line-modified">!    * the right, and 0 for undecidable cases.</span>
     */
    FT_BASE( FT_Int )
    ft_corner_orientation( FT_Pos  in_x,
                           FT_Pos  in_y,
                           FT_Pos  out_x,
                           FT_Pos  out_y );
  
  
    /*
<span class="line-modified">!    * Return TRUE if a corner is flat or nearly flat.  This is equivalent to</span>
<span class="line-modified">!    * saying that the corner point is close to its neighbors, or inside an</span>
<span class="line-modified">!    * ellipse defined by the neighbor focal points to be more precise.</span>
     */
    FT_BASE( FT_Int )
    ft_corner_is_flat( FT_Pos  in_x,
                       FT_Pos  in_y,
                       FT_Pos  out_x,
                       FT_Pos  out_y );
  
  
    /*
<span class="line-modified">!    * Return the most significant bit index.</span>
     */
  
  #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
<span class="line-added">+ </span>
  #if defined( __GNUC__ )                                          &amp;&amp; \
      ( __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4 ) )
  
  #if FT_SIZEOF_INT == 4
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,13 ***</span>
  
  #elif FT_SIZEOF_LONG == 4
  
  #define FT_MSB( x )  ( 31 - __builtin_clzl( x ) )
  
  #endif
  
<span class="line-modified">! #endif /* __GNUC__ */</span>
  #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
  
  #ifndef FT_MSB
  
    FT_BASE( FT_Int )
<span class="line-new-header">--- 368,38 ---</span>
  
  #elif FT_SIZEOF_LONG == 4
  
  #define FT_MSB( x )  ( 31 - __builtin_clzl( x ) )
  
<span class="line-added">+ #endif /* __GNUC__ */</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+ #elif defined( _MSC_VER ) &amp;&amp; ( _MSC_VER &gt;= 1400 )</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if FT_SIZEOF_INT == 4</span>
<span class="line-added">+ </span>
<span class="line-added">+ #include &lt;intrin.h&gt;</span>
<span class="line-added">+ #pragma intrinsic( _BitScanReverse )</span>
<span class="line-added">+ </span>
<span class="line-added">+   static __inline FT_Int32</span>
<span class="line-added">+   FT_MSB_i386( FT_UInt32  x )</span>
<span class="line-added">+   {</span>
<span class="line-added">+     unsigned long  where;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+     _BitScanReverse( &amp;where, x );</span>
<span class="line-added">+ </span>
<span class="line-added">+     return (FT_Int32)where;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define FT_MSB( x )  ( FT_MSB_i386( x ) )</span>
<span class="line-added">+ </span>
  #endif
  
<span class="line-modified">! #endif /* _MSC_VER */</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
  
  #ifndef FT_MSB
  
    FT_BASE( FT_Int )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 364,37 ***</span>
  
  #endif
  
  
    /*
<span class="line-modified">!    *  Return sqrt(x*x+y*y), which is the same as `FT_Vector_Length&#39; but uses</span>
<span class="line-modified">!    *  two fixed-point arguments instead.</span>
     */
    FT_BASE( FT_Fixed )
    FT_Hypot( FT_Fixed  x,
              FT_Fixed  y );
  
  
  #if 0
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    FT_SqrtFixed                                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Computes the square root of a 16.16 fixed-point value.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    x :: The value to compute the root for.                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    The result of `sqrt(x)&#39;.                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">!   /*    This function is not very fast.                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_BASE( FT_Int32 )
    FT_SqrtFixed( FT_Int32  x );
  
  #endif /* 0 */
  
<span class="line-new-header">--- 407,38 ---</span>
  
  #endif
  
  
    /*
<span class="line-modified">!    * Return sqrt(x*x+y*y), which is the same as `FT_Vector_Length&#39; but uses</span>
<span class="line-modified">!    * two fixed-point arguments instead.</span>
     */
    FT_BASE( FT_Fixed )
    FT_Hypot( FT_Fixed  x,
              FT_Fixed  y );
  
  
  #if 0
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @function:</span>
<span class="line-modified">!    *   FT_SqrtFixed</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @description:</span>
<span class="line-modified">!    *   Computes the square root of a 16.16 fixed-point value.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @input:</span>
<span class="line-modified">!    *   x ::</span>
<span class="line-modified">!    *     The value to compute the root for.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @return:</span>
<span class="line-modified">!    *   The result of &#39;sqrt(x)&#39;.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @note:</span>
<span class="line-modified">!    *   This function is not very fast.</span>
<span class="line-added">+    */</span>
    FT_BASE( FT_Int32 )
    FT_SqrtFixed( FT_Int32  x );
  
  #endif /* 0 */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 407,18 ***</span>
  
  #define ROUND_F26DOT6( x )     ( x &gt;= 0 ? (    ( (x) + 32 ) &amp; -64 )     \
                                          : ( -( ( 32 - (x) ) &amp; -64 ) ) )
  
    /*
<span class="line-modified">!    *  The following macros have two purposes.</span>
     *
<span class="line-modified">!    *  . Tag places where overflow is expected and harmless.</span>
     *
<span class="line-modified">!    *  . Avoid run-time sanitizer errors.</span>
     *
<span class="line-modified">!    *  Use with care!</span>
     */
  #define ADD_LONG( a, b )                             \
            (FT_Long)( (FT_ULong)(a) + (FT_ULong)(b) )
  #define SUB_LONG( a, b )                             \
            (FT_Long)( (FT_ULong)(a) - (FT_ULong)(b) )
  #define MUL_LONG( a, b )                             \
<span class="line-new-header">--- 451,27 ---</span>
  
  #define ROUND_F26DOT6( x )     ( x &gt;= 0 ? (    ( (x) + 32 ) &amp; -64 )     \
                                          : ( -( ( 32 - (x) ) &amp; -64 ) ) )
  
    /*
<span class="line-modified">!    * The following macros have two purposes.</span>
     *
<span class="line-modified">!    * - Tag places where overflow is expected and harmless.</span>
     *
<span class="line-modified">!    * - Avoid run-time sanitizer errors.</span>
     *
<span class="line-modified">!    * Use with care!</span>
     */
<span class="line-added">+ #define ADD_INT( a, b )                           \</span>
<span class="line-added">+           (FT_Int)( (FT_UInt)(a) + (FT_UInt)(b) )</span>
<span class="line-added">+ #define SUB_INT( a, b )                           \</span>
<span class="line-added">+           (FT_Int)( (FT_UInt)(a) - (FT_UInt)(b) )</span>
<span class="line-added">+ #define MUL_INT( a, b )                           \</span>
<span class="line-added">+           (FT_Int)( (FT_UInt)(a) * (FT_UInt)(b) )</span>
<span class="line-added">+ #define NEG_INT( a )                              \</span>
<span class="line-added">+           (FT_Int)( (FT_UInt)0 - (FT_UInt)(a) )</span>
<span class="line-added">+ </span>
  #define ADD_LONG( a, b )                             \
            (FT_Long)( (FT_ULong)(a) + (FT_ULong)(b) )
  #define SUB_LONG( a, b )                             \
            (FT_Long)( (FT_ULong)(a) - (FT_ULong)(b) )
  #define MUL_LONG( a, b )                             \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 433,10 ***</span>
<span class="line-new-header">--- 486,23 ---</span>
  #define MUL_INT32( a, b )                               \
            (FT_Int32)( (FT_UInt32)(a) * (FT_UInt32)(b) )
  #define NEG_INT32( a )                                  \
            (FT_Int32)( (FT_UInt32)0 - (FT_UInt32)(a) )
  
<span class="line-added">+ #ifdef FT_LONG64</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define ADD_INT64( a, b )                               \</span>
<span class="line-added">+           (FT_Int64)( (FT_UInt64)(a) + (FT_UInt64)(b) )</span>
<span class="line-added">+ #define SUB_INT64( a, b )                               \</span>
<span class="line-added">+           (FT_Int64)( (FT_UInt64)(a) - (FT_UInt64)(b) )</span>
<span class="line-added">+ #define MUL_INT64( a, b )                               \</span>
<span class="line-added">+           (FT_Int64)( (FT_UInt64)(a) * (FT_UInt64)(b) )</span>
<span class="line-added">+ #define NEG_INT64( a )                                  \</span>
<span class="line-added">+           (FT_Int64)( (FT_UInt64)0 - (FT_UInt64)(a) )</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif /* FT_LONG64 */</span>
<span class="line-added">+ </span>
  
  FT_END_HEADER
  
  #endif /* FTCALC_H_ */
  
</pre>
<center><a href="cfftypes.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftdebug.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
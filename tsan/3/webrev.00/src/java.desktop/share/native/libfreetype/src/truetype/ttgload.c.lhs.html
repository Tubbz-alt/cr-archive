<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/truetype/ttgload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttgload.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    TrueType Glyph Loader (body).                                        */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_CONFIG_CONFIG_H
  22 #include FT_INTERNAL_CALC_H
  23 #include FT_INTERNAL_STREAM_H
  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_TRUETYPE_TAGS_H
  26 #include FT_OUTLINE_H
  27 #include FT_DRIVER_H
  28 #include FT_LIST_H
  29 
  30 #include &quot;ttgload.h&quot;
  31 #include &quot;ttpload.h&quot;
  32 
  33 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  34 #include &quot;ttgxvar.h&quot;
  35 #endif
  36 
  37 #include &quot;tterrors.h&quot;
  38 #include &quot;ttsubpix.h&quot;
  39 
  40 
<a name="2" id="anc2"></a><span class="line-modified">  41   /*************************************************************************/</span>
<span class="line-modified">  42   /*                                                                       */</span>
<span class="line-modified">  43   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  44   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  45   /* messages during execution.                                            */</span>
<span class="line-modified">  46   /*                                                                       */</span>
  47 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  48 #define FT_COMPONENT  trace_ttgload</span>
  49 
  50 
<a name="4" id="anc4"></a><span class="line-modified">  51   /*************************************************************************/</span>
<span class="line-modified">  52   /*                                                                       */</span>
<span class="line-modified">  53   /* Composite glyph flags.                                                */</span>
<span class="line-modified">  54   /*                                                                       */</span>















  55 #define ARGS_ARE_WORDS             0x0001
  56 #define ARGS_ARE_XY_VALUES         0x0002
  57 #define ROUND_XY_TO_GRID           0x0004
  58 #define WE_HAVE_A_SCALE            0x0008
  59 /* reserved                        0x0010 */
  60 #define MORE_COMPONENTS            0x0020
  61 #define WE_HAVE_AN_XY_SCALE        0x0040
  62 #define WE_HAVE_A_2X2              0x0080
  63 #define WE_HAVE_INSTR              0x0100
  64 #define USE_MY_METRICS             0x0200
<a name="5" id="anc5"></a><span class="line-modified">  65 #define OVERLAP_COMPOUND           0x0400</span>
  66 #define SCALED_COMPONENT_OFFSET    0x0800
  67 #define UNSCALED_COMPONENT_OFFSET  0x1000
  68 
  69 
<a name="6" id="anc6"></a><span class="line-modified">  70   /*************************************************************************/</span>
<span class="line-modified">  71   /*                                                                       */</span>
<span class="line-modified">  72   /* Return the horizontal metrics in font units for a given glyph.        */</span>
<span class="line-modified">  73   /*                                                                       */</span>









  74   FT_LOCAL_DEF( void )
  75   TT_Get_HMetrics( TT_Face     face,
  76                    FT_UInt     idx,
  77                    FT_Short*   lsb,
  78                    FT_UShort*  aw )
  79   {
  80     ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 0, idx, lsb, aw );
  81 
  82     FT_TRACE5(( &quot;  advance width (font units): %d\n&quot;, *aw ));
  83     FT_TRACE5(( &quot;  left side bearing (font units): %d\n&quot;, *lsb ));
  84   }
  85 
  86 
<a name="7" id="anc7"></a><span class="line-modified">  87   /*************************************************************************/</span>
<span class="line-modified">  88   /*                                                                       */</span>
<span class="line-modified">  89   /* Return the vertical metrics in font units for a given glyph.          */</span>
<span class="line-modified">  90   /* See function `tt_loader_set_pp&#39; below for explanations.               */</span>
<span class="line-modified">  91   /*                                                                       */</span>
  92   FT_LOCAL_DEF( void )
  93   TT_Get_VMetrics( TT_Face     face,
  94                    FT_UInt     idx,
  95                    FT_Pos      yMax,
  96                    FT_Short*   tsb,
  97                    FT_UShort*  ah )
  98   {
  99     if ( face-&gt;vertical_info )
 100       ( (SFNT_Service)face-&gt;sfnt )-&gt;get_metrics( face, 1, idx, tsb, ah );
 101 
 102     else if ( face-&gt;os2.version != 0xFFFFU )
 103     {
 104       *tsb = (FT_Short)( face-&gt;os2.sTypoAscender - yMax );
 105       *ah  = (FT_UShort)FT_ABS( face-&gt;os2.sTypoAscender -
 106                                 face-&gt;os2.sTypoDescender );
 107     }
 108 
 109     else
 110     {
 111       *tsb = (FT_Short)( face-&gt;horizontal.Ascender - yMax );
 112       *ah  = (FT_UShort)FT_ABS( face-&gt;horizontal.Ascender -
 113                                 face-&gt;horizontal.Descender );
 114     }
 115 
 116     FT_TRACE5(( &quot;  advance height (font units): %d\n&quot;, *ah ));
 117     FT_TRACE5(( &quot;  top side bearing (font units): %d\n&quot;, *tsb ));
 118   }
 119 
 120 
 121   static FT_Error
 122   tt_get_metrics( TT_Loader  loader,
 123                   FT_UInt    glyph_index )
 124   {
 125     TT_Face    face   = loader-&gt;face;
 126 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 127     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 128 #endif
 129 
 130     FT_Error   error;
 131     FT_Stream  stream = loader-&gt;stream;
 132 
 133     FT_Short   left_bearing = 0, top_bearing = 0;
 134     FT_UShort  advance_width = 0, advance_height = 0;
 135 
 136     /* we must preserve the stream position          */
 137     /* (which gets altered by the metrics functions) */
 138     FT_ULong  pos = FT_STREAM_POS();
 139 
 140 
 141     TT_Get_HMetrics( face, glyph_index,
 142                      &amp;left_bearing,
 143                      &amp;advance_width );
 144     TT_Get_VMetrics( face, glyph_index,
 145                      loader-&gt;bbox.yMax,
 146                      &amp;top_bearing,
 147                      &amp;advance_height );
 148 
 149     if ( FT_STREAM_SEEK( pos ) )
 150       return error;
 151 
 152     loader-&gt;left_bearing = left_bearing;
 153     loader-&gt;advance      = advance_width;
 154     loader-&gt;top_bearing  = top_bearing;
 155     loader-&gt;vadvance     = advance_height;
 156 
 157 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 158     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 &amp;&amp;
 159          loader-&gt;exec                                             )
 160     {
 161       loader-&gt;exec-&gt;sph_tweak_flags = 0;
 162 
 163       /* This may not be the right place for this, but it works...  */
 164       /* Note that we have to unconditionally load the tweaks since */
 165       /* it is possible that glyphs individually switch ClearType&#39;s */
 166       /* backward compatibility mode on and off.                    */
 167       sph_set_tweaks( loader, glyph_index );
 168     }
 169 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 170 
 171     if ( !loader-&gt;linear_def )
 172     {
 173       loader-&gt;linear_def = 1;
 174       loader-&gt;linear     = advance_width;
 175     }
 176 
 177     return FT_Err_Ok;
 178   }
 179 
 180 
 181 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 182 
 183   static void
 184   tt_get_metrics_incr_overrides( TT_Loader  loader,
 185                                  FT_UInt    glyph_index )
 186   {
 187     TT_Face  face = loader-&gt;face;
 188 
 189     FT_Short   left_bearing = 0, top_bearing = 0;
 190     FT_UShort  advance_width = 0, advance_height = 0;
 191 
 192 
 193     /* If this is an incrementally loaded font check whether there are */
 194     /* overriding metrics for this glyph.                              */
 195     if ( face-&gt;root.internal-&gt;incremental_interface                           &amp;&amp;
 196          face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_metrics )
 197     {
 198       FT_Incremental_MetricsRec  incr_metrics;
 199       FT_Error                   error;
 200 
 201 
 202       incr_metrics.bearing_x = loader-&gt;left_bearing;
 203       incr_metrics.bearing_y = 0;
 204       incr_metrics.advance   = loader-&gt;advance;
 205       incr_metrics.advance_v = 0;
 206 
 207       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_metrics(
 208                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
 209                 glyph_index, FALSE, &amp;incr_metrics );
 210       if ( error )
 211         goto Exit;
 212 
 213       left_bearing  = (FT_Short)incr_metrics.bearing_x;
 214       advance_width = (FT_UShort)incr_metrics.advance;
 215 
 216 #if 0
 217 
 218       /* GWW: Do I do the same for vertical metrics? */
 219       incr_metrics.bearing_x = 0;
 220       incr_metrics.bearing_y = loader-&gt;top_bearing;
 221       incr_metrics.advance   = loader-&gt;vadvance;
 222 
 223       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_metrics(
 224                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
 225                 glyph_index, TRUE, &amp;incr_metrics );
 226       if ( error )
 227         goto Exit;
 228 
 229       top_bearing    = (FT_Short)incr_metrics.bearing_y;
 230       advance_height = (FT_UShort)incr_metrics.advance;
 231 
 232 #endif /* 0 */
 233 
 234       loader-&gt;left_bearing = left_bearing;
 235       loader-&gt;advance      = advance_width;
 236       loader-&gt;top_bearing  = top_bearing;
 237       loader-&gt;vadvance     = advance_height;
 238 
 239       if ( !loader-&gt;linear_def )
 240       {
 241         loader-&gt;linear_def = 1;
 242         loader-&gt;linear     = advance_width;
 243       }
 244     }
 245 
 246   Exit:
 247     return;
 248   }
 249 
 250 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 251 
 252 
<a name="8" id="anc8"></a><span class="line-modified"> 253   /*************************************************************************/</span>
<span class="line-modified"> 254   /*                                                                       */</span>
<span class="line-modified"> 255   /* The following functions are used by default with TrueType fonts.      */</span>
<span class="line-modified"> 256   /* However, they can be replaced by alternatives if we need to support   */</span>
<span class="line-modified"> 257   /* TrueType-compressed formats (like MicroType) in the future.           */</span>
<span class="line-modified"> 258   /*                                                                       */</span>
<span class="line-modified"> 259   /*************************************************************************/</span>
 260 
 261   FT_CALLBACK_DEF( FT_Error )
 262   TT_Access_Glyph_Frame( TT_Loader  loader,
 263                          FT_UInt    glyph_index,
 264                          FT_ULong   offset,
 265                          FT_UInt    byte_count )
 266   {
 267     FT_Error   error;
 268     FT_Stream  stream = loader-&gt;stream;
 269 
<a name="9" id="anc9"></a><span class="line-removed"> 270     /* for non-debug mode */</span>
 271     FT_UNUSED( glyph_index );
 272 
 273 
<a name="10" id="anc10"></a><span class="line-removed"> 274     FT_TRACE4(( &quot;Glyph %ld\n&quot;, glyph_index ));</span>
<span class="line-removed"> 275 </span>
 276     /* the following line sets the `error&#39; variable through macros! */
 277     if ( FT_STREAM_SEEK( offset ) || FT_FRAME_ENTER( byte_count ) )
 278       return error;
 279 
 280     loader-&gt;cursor = stream-&gt;cursor;
 281     loader-&gt;limit  = stream-&gt;limit;
 282 
 283     return FT_Err_Ok;
 284   }
 285 
 286 
 287   FT_CALLBACK_DEF( void )
 288   TT_Forget_Glyph_Frame( TT_Loader  loader )
 289   {
 290     FT_Stream  stream = loader-&gt;stream;
 291 
 292 
 293     FT_FRAME_EXIT();
 294   }
 295 
 296 
 297   FT_CALLBACK_DEF( FT_Error )
 298   TT_Load_Glyph_Header( TT_Loader  loader )
 299   {
 300     FT_Byte*  p     = loader-&gt;cursor;
 301     FT_Byte*  limit = loader-&gt;limit;
 302 
 303 
 304     if ( p + 10 &gt; limit )
 305       return FT_THROW( Invalid_Outline );
 306 
 307     loader-&gt;n_contours = FT_NEXT_SHORT( p );
 308 
 309     loader-&gt;bbox.xMin = FT_NEXT_SHORT( p );
 310     loader-&gt;bbox.yMin = FT_NEXT_SHORT( p );
 311     loader-&gt;bbox.xMax = FT_NEXT_SHORT( p );
 312     loader-&gt;bbox.yMax = FT_NEXT_SHORT( p );
 313 
 314     FT_TRACE5(( &quot;  # of contours: %d\n&quot;, loader-&gt;n_contours ));
 315     FT_TRACE5(( &quot;  xMin: %4d  xMax: %4d\n&quot;, loader-&gt;bbox.xMin,
 316                                             loader-&gt;bbox.xMax ));
 317     FT_TRACE5(( &quot;  yMin: %4d  yMax: %4d\n&quot;, loader-&gt;bbox.yMin,
 318                                             loader-&gt;bbox.yMax ));
 319     loader-&gt;cursor = p;
 320 
 321     return FT_Err_Ok;
 322   }
 323 
 324 
 325   FT_CALLBACK_DEF( FT_Error )
 326   TT_Load_Simple_Glyph( TT_Loader  load )
 327   {
 328     FT_Error        error;
 329     FT_Byte*        p          = load-&gt;cursor;
 330     FT_Byte*        limit      = load-&gt;limit;
 331     FT_GlyphLoader  gloader    = load-&gt;gloader;
 332     FT_Int          n_contours = load-&gt;n_contours;
 333     FT_Outline*     outline;
 334     FT_UShort       n_ins;
 335     FT_Int          n_points;
 336 
 337     FT_Byte         *flag, *flag_limit;
 338     FT_Byte         c, count;
 339     FT_Vector       *vec, *vec_limit;
<a name="11" id="anc11"></a><span class="line-modified"> 340     FT_Pos          x;</span>
 341     FT_Short        *cont, *cont_limit, prev_cont;
 342     FT_Int          xy_size = 0;
 343 
 344 
 345     /* check that we can add the contours to the glyph */
 346     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, 0, n_contours );
 347     if ( error )
 348       goto Fail;
 349 
 350     /* reading the contours&#39; endpoints &amp; number of points */
 351     cont       = gloader-&gt;current.outline.contours;
 352     cont_limit = cont + n_contours;
 353 
 354     /* check space for contours array + instructions count */
 355     if ( n_contours &gt;= 0xFFF || p + ( n_contours + 1 ) * 2 &gt; limit )
 356       goto Invalid_Outline;
 357 
 358     prev_cont = FT_NEXT_SHORT( p );
 359 
 360     if ( n_contours &gt; 0 )
 361       cont[0] = prev_cont;
 362 
 363     if ( prev_cont &lt; 0 )
 364       goto Invalid_Outline;
 365 
 366     for ( cont++; cont &lt; cont_limit; cont++ )
 367     {
 368       cont[0] = FT_NEXT_SHORT( p );
 369       if ( cont[0] &lt;= prev_cont )
 370       {
 371         /* unordered contours: this is invalid */
 372         goto Invalid_Outline;
 373       }
 374       prev_cont = cont[0];
 375     }
 376 
 377     n_points = 0;
 378     if ( n_contours &gt; 0 )
 379     {
 380       n_points = cont[-1] + 1;
 381       if ( n_points &lt; 0 )
 382         goto Invalid_Outline;
 383     }
 384 
<a name="12" id="anc12"></a>

 385     /* note that we will add four phantom points later */
 386     error = FT_GLYPHLOADER_CHECK_POINTS( gloader, n_points + 4, 0 );
 387     if ( error )
 388       goto Fail;
 389 
 390     /* reading the bytecode instructions */
 391     load-&gt;glyph-&gt;control_len  = 0;
 392     load-&gt;glyph-&gt;control_data = NULL;
 393 
 394     if ( p + 2 &gt; limit )
 395       goto Invalid_Outline;
 396 
 397     n_ins = FT_NEXT_USHORT( p );
 398 
 399     FT_TRACE5(( &quot;  Instructions size: %u\n&quot;, n_ins ));
 400 
 401 #ifdef TT_USE_BYTECODE_INTERPRETER
 402 
 403     if ( IS_HINTED( load-&gt;load_flags ) )
 404     {
 405       FT_ULong  tmp;
 406 
 407 
 408       /* check instructions size */
 409       if ( ( limit - p ) &lt; n_ins )
 410       {
 411         FT_TRACE1(( &quot;TT_Load_Simple_Glyph: instruction count mismatch\n&quot; ));
 412         error = FT_THROW( Too_Many_Hints );
 413         goto Fail;
 414       }
 415 
 416       /* we don&#39;t trust `maxSizeOfInstructions&#39; in the `maxp&#39; table */
 417       /* and thus update the bytecode array size by ourselves       */
 418 
 419       tmp   = load-&gt;exec-&gt;glyphSize;
 420       error = Update_Max( load-&gt;exec-&gt;memory,
 421                           &amp;tmp,
 422                           sizeof ( FT_Byte ),
 423                           (void*)&amp;load-&gt;exec-&gt;glyphIns,
 424                           n_ins );
 425 
 426       load-&gt;exec-&gt;glyphSize = (FT_UShort)tmp;
 427       if ( error )
 428         return error;
 429 
 430       load-&gt;glyph-&gt;control_len  = n_ins;
 431       load-&gt;glyph-&gt;control_data = load-&gt;exec-&gt;glyphIns;
 432 
 433       if ( n_ins )
 434         FT_MEM_COPY( load-&gt;exec-&gt;glyphIns, p, (FT_Long)n_ins );
 435     }
 436 
 437 #endif /* TT_USE_BYTECODE_INTERPRETER */
 438 
 439     p += n_ins;
 440 
 441     outline = &amp;gloader-&gt;current.outline;
 442 
 443     /* reading the point tags */
 444     flag       = (FT_Byte*)outline-&gt;tags;
 445     flag_limit = flag + n_points;
 446 
 447     FT_ASSERT( flag );
 448 
 449     while ( flag &lt; flag_limit )
 450     {
 451       if ( p + 1 &gt; limit )
 452         goto Invalid_Outline;
 453 
 454       *flag++ = c = FT_NEXT_BYTE( p );
<a name="13" id="anc13"></a><span class="line-modified"> 455       if ( c &amp; 8 )</span>
 456       {
 457         if ( p + 1 &gt; limit )
 458           goto Invalid_Outline;
 459 
 460         count = FT_NEXT_BYTE( p );
 461         if ( flag + (FT_Int)count &gt; flag_limit )
 462           goto Invalid_Outline;
 463 
 464         for ( ; count &gt; 0; count-- )
 465           *flag++ = c;
 466       }
 467     }
 468 
 469     /* reading the X coordinates */
 470 
 471     vec       = outline-&gt;points;
 472     vec_limit = vec + n_points;
 473     flag      = (FT_Byte*)outline-&gt;tags;
 474     x         = 0;
 475 
 476     if ( p + xy_size &gt; limit )
 477       goto Invalid_Outline;
 478 
 479     for ( ; vec &lt; vec_limit; vec++, flag++ )
 480     {
<a name="14" id="anc14"></a><span class="line-modified"> 481       FT_Pos   y = 0;</span>
<span class="line-modified"> 482       FT_Byte  f = *flag;</span>
 483 
 484 
<a name="15" id="anc15"></a><span class="line-modified"> 485       if ( f &amp; 2 )</span>
 486       {
 487         if ( p + 1 &gt; limit )
 488           goto Invalid_Outline;
 489 
<a name="16" id="anc16"></a><span class="line-modified"> 490         y = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 491         if ( ( f &amp; 16 ) == 0 )</span>
<span class="line-modified"> 492           y = -y;</span>
 493       }
<a name="17" id="anc17"></a><span class="line-modified"> 494       else if ( ( f &amp; 16 ) == 0 )</span>
 495       {
 496         if ( p + 2 &gt; limit )
 497           goto Invalid_Outline;
 498 
<a name="18" id="anc18"></a><span class="line-modified"> 499         y = (FT_Pos)FT_NEXT_SHORT( p );</span>
 500       }
 501 
<a name="19" id="anc19"></a><span class="line-modified"> 502       x     += y;</span>
 503       vec-&gt;x = x;
<a name="20" id="anc20"></a><span class="line-removed"> 504       /* the cast is for stupid compilers */</span>
<span class="line-removed"> 505       *flag  = (FT_Byte)( f &amp; ~( 2 | 16 ) );</span>
 506     }
 507 
 508     /* reading the Y coordinates */
 509 
 510     vec       = gloader-&gt;current.outline.points;
 511     vec_limit = vec + n_points;
 512     flag      = (FT_Byte*)outline-&gt;tags;
<a name="21" id="anc21"></a><span class="line-modified"> 513     x         = 0;</span>
 514 
 515     for ( ; vec &lt; vec_limit; vec++, flag++ )
 516     {
<a name="22" id="anc22"></a><span class="line-modified"> 517       FT_Pos   y = 0;</span>
<span class="line-modified"> 518       FT_Byte  f = *flag;</span>
 519 
 520 
<a name="23" id="anc23"></a><span class="line-modified"> 521       if ( f &amp; 4 )</span>
 522       {
 523         if ( p + 1 &gt; limit )
 524           goto Invalid_Outline;
 525 
<a name="24" id="anc24"></a><span class="line-modified"> 526         y = (FT_Pos)FT_NEXT_BYTE( p );</span>
<span class="line-modified"> 527         if ( ( f &amp; 32 ) == 0 )</span>
<span class="line-modified"> 528           y = -y;</span>
 529       }
<a name="25" id="anc25"></a><span class="line-modified"> 530       else if ( ( f &amp; 32 ) == 0 )</span>
 531       {
 532         if ( p + 2 &gt; limit )
 533           goto Invalid_Outline;
 534 
<a name="26" id="anc26"></a><span class="line-modified"> 535         y = (FT_Pos)FT_NEXT_SHORT( p );</span>
 536       }
 537 
<a name="27" id="anc27"></a><span class="line-modified"> 538       x     += y;</span>
<span class="line-modified"> 539       vec-&gt;y = x;</span>

 540       /* the cast is for stupid compilers */
<a name="28" id="anc28"></a><span class="line-modified"> 541       *flag  = (FT_Byte)( f &amp; FT_CURVE_TAG_ON );</span>
 542     }
 543 
 544     outline-&gt;n_points   = (FT_Short)n_points;
 545     outline-&gt;n_contours = (FT_Short)n_contours;
 546 
 547     load-&gt;cursor = p;
 548 
 549   Fail:
 550     return error;
 551 
 552   Invalid_Outline:
 553     error = FT_THROW( Invalid_Outline );
 554     goto Fail;
 555   }
 556 
 557 
 558   FT_CALLBACK_DEF( FT_Error )
 559   TT_Load_Composite_Glyph( TT_Loader  loader )
 560   {
 561     FT_Error        error;
<a name="29" id="anc29"></a><span class="line-modified"> 562     FT_Byte*        p       = loader-&gt;cursor;</span>
<span class="line-modified"> 563     FT_Byte*        limit   = loader-&gt;limit;</span>
<span class="line-modified"> 564     FT_GlyphLoader  gloader = loader-&gt;gloader;</span>

 565     FT_SubGlyph     subglyph;
 566     FT_UInt         num_subglyphs;
 567 
 568 
 569     num_subglyphs = 0;
 570 
 571     do
 572     {
 573       FT_Fixed  xx, xy, yy, yx;
 574       FT_UInt   count;
 575 
 576 
 577       /* check that we can load a new subglyph */
 578       error = FT_GlyphLoader_CheckSubGlyphs( gloader, num_subglyphs + 1 );
 579       if ( error )
 580         goto Fail;
 581 
 582       /* check space */
 583       if ( p + 4 &gt; limit )
 584         goto Invalid_Composite;
 585 
 586       subglyph = gloader-&gt;current.subglyphs + num_subglyphs;
 587 
 588       subglyph-&gt;arg1 = subglyph-&gt;arg2 = 0;
 589 
 590       subglyph-&gt;flags = FT_NEXT_USHORT( p );
 591       subglyph-&gt;index = FT_NEXT_USHORT( p );
 592 
<a name="30" id="anc30"></a>




 593       /* check space */
 594       count = 2;
 595       if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 596         count += 2;
 597       if ( subglyph-&gt;flags &amp; WE_HAVE_A_SCALE )
 598         count += 2;
 599       else if ( subglyph-&gt;flags &amp; WE_HAVE_AN_XY_SCALE )
 600         count += 4;
 601       else if ( subglyph-&gt;flags &amp; WE_HAVE_A_2X2 )
 602         count += 8;
 603 
 604       if ( p + count &gt; limit )
 605         goto Invalid_Composite;
 606 
 607       /* read arguments */
 608       if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
 609       {
 610         if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 611         {
 612           subglyph-&gt;arg1 = FT_NEXT_SHORT( p );
 613           subglyph-&gt;arg2 = FT_NEXT_SHORT( p );
 614         }
 615         else
 616         {
 617           subglyph-&gt;arg1 = FT_NEXT_CHAR( p );
 618           subglyph-&gt;arg2 = FT_NEXT_CHAR( p );
 619         }
 620       }
 621       else
 622       {
 623         if ( subglyph-&gt;flags &amp; ARGS_ARE_WORDS )
 624         {
 625           subglyph-&gt;arg1 = (FT_Int)FT_NEXT_USHORT( p );
 626           subglyph-&gt;arg2 = (FT_Int)FT_NEXT_USHORT( p );
 627         }
 628         else
 629         {
 630           subglyph-&gt;arg1 = (FT_Int)FT_NEXT_BYTE( p );
 631           subglyph-&gt;arg2 = (FT_Int)FT_NEXT_BYTE( p );
 632         }
 633       }
 634 
 635       /* read transform */
 636       xx = yy = 0x10000L;
 637       xy = yx = 0;
 638 
 639       if ( subglyph-&gt;flags &amp; WE_HAVE_A_SCALE )
 640       {
 641         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 642         yy = xx;
 643       }
 644       else if ( subglyph-&gt;flags &amp; WE_HAVE_AN_XY_SCALE )
 645       {
 646         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 647         yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 648       }
 649       else if ( subglyph-&gt;flags &amp; WE_HAVE_A_2X2 )
 650       {
 651         xx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 652         yx = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 653         xy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 654         yy = (FT_Fixed)FT_NEXT_SHORT( p ) * 4;
 655       }
 656 
 657       subglyph-&gt;transform.xx = xx;
 658       subglyph-&gt;transform.xy = xy;
 659       subglyph-&gt;transform.yx = yx;
 660       subglyph-&gt;transform.yy = yy;
 661 
 662       num_subglyphs++;
 663 
 664     } while ( subglyph-&gt;flags &amp; MORE_COMPONENTS );
 665 
 666     gloader-&gt;current.num_subglyphs = num_subglyphs;
 667     FT_TRACE5(( &quot;  %d component%s\n&quot;,
 668                 num_subglyphs,
 669                 num_subglyphs &gt; 1 ? &quot;s&quot; : &quot;&quot; ));
 670 
 671 #ifdef FT_DEBUG_LEVEL_TRACE
 672     {
 673       FT_UInt  i;
 674 
 675 
 676       subglyph = gloader-&gt;current.subglyphs;
 677 
 678       for ( i = 0; i &lt; num_subglyphs; i++ )
 679       {
 680         if ( num_subglyphs &gt; 1 )
 681           FT_TRACE7(( &quot;    subglyph %d:\n&quot;, i ));
 682 
 683         FT_TRACE7(( &quot;      glyph index: %d\n&quot;, subglyph-&gt;index ));
 684 
 685         if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
 686           FT_TRACE7(( &quot;      offset: x=%d, y=%d\n&quot;,
 687                       subglyph-&gt;arg1,
 688                       subglyph-&gt;arg2 ));
 689         else
 690           FT_TRACE7(( &quot;      matching points: base=%d, component=%d\n&quot;,
 691                       subglyph-&gt;arg1,
 692                       subglyph-&gt;arg2 ));
 693 
 694         if ( subglyph-&gt;flags &amp; WE_HAVE_A_SCALE )
 695           FT_TRACE7(( &quot;      scaling: %f\n&quot;,
 696                       subglyph-&gt;transform.xx / 65536.0 ));
 697         else if ( subglyph-&gt;flags &amp; WE_HAVE_AN_XY_SCALE )
 698           FT_TRACE7(( &quot;      scaling: x=%f, y=%f\n&quot;,
 699                       subglyph-&gt;transform.xx / 65536.0,
 700                       subglyph-&gt;transform.yy / 65536.0 ));
 701         else if ( subglyph-&gt;flags &amp; WE_HAVE_A_2X2 )
 702           FT_TRACE7(( &quot;      scaling: xx=%f, yx=%f\n&quot;
 703                       &quot;               xy=%f, yy=%f\n&quot;,
 704                       subglyph-&gt;transform.xx / 65536.0,
 705                       subglyph-&gt;transform.yx / 65536.0,
 706                       subglyph-&gt;transform.xy / 65536.0,
 707                       subglyph-&gt;transform.yy / 65536.0 ));
 708 
 709         subglyph++;
 710       }
 711     }
 712 #endif /* FT_DEBUG_LEVEL_TRACE */
 713 
 714 #ifdef TT_USE_BYTECODE_INTERPRETER
 715 
 716     {
 717       FT_Stream  stream = loader-&gt;stream;
 718 
 719 
 720       /* we must undo the FT_FRAME_ENTER in order to point */
 721       /* to the composite instructions, if we find some.   */
 722       /* We will process them later.                       */
 723       /*                                                   */
 724       loader-&gt;ins_pos = (FT_ULong)( FT_STREAM_POS() +
 725                                     p - limit );
 726     }
 727 
 728 #endif
 729 
 730     loader-&gt;cursor = p;
 731 
 732   Fail:
 733     return error;
 734 
 735   Invalid_Composite:
 736     error = FT_THROW( Invalid_Composite );
 737     goto Fail;
 738   }
 739 
 740 
 741   FT_LOCAL_DEF( void )
 742   TT_Init_Glyph_Loading( TT_Face  face )
 743   {
 744     face-&gt;access_glyph_frame   = TT_Access_Glyph_Frame;
 745     face-&gt;read_glyph_header    = TT_Load_Glyph_Header;
 746     face-&gt;read_simple_glyph    = TT_Load_Simple_Glyph;
 747     face-&gt;read_composite_glyph = TT_Load_Composite_Glyph;
 748     face-&gt;forget_glyph_frame   = TT_Forget_Glyph_Frame;
 749   }
 750 
 751 
 752   static void
 753   tt_prepare_zone( TT_GlyphZone  zone,
 754                    FT_GlyphLoad  load,
 755                    FT_UInt       start_point,
 756                    FT_UInt       start_contour )
 757   {
 758     zone-&gt;n_points    = (FT_UShort)load-&gt;outline.n_points -
 759                           (FT_UShort)start_point;
 760     zone-&gt;n_contours  = load-&gt;outline.n_contours -
 761                           (FT_Short)start_contour;
 762     zone-&gt;org         = load-&gt;extra_points + start_point;
 763     zone-&gt;cur         = load-&gt;outline.points + start_point;
 764     zone-&gt;orus        = load-&gt;extra_points2 + start_point;
 765     zone-&gt;tags        = (FT_Byte*)load-&gt;outline.tags + start_point;
 766     zone-&gt;contours    = (FT_UShort*)load-&gt;outline.contours + start_contour;
 767     zone-&gt;first_point = (FT_UShort)start_point;
 768   }
 769 
 770 
<a name="31" id="anc31"></a><span class="line-modified"> 771   /*************************************************************************/</span>
<span class="line-modified"> 772   /*                                                                       */</span>
<span class="line-modified"> 773   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 774   /*    TT_Hint_Glyph                                                      */</span>
<span class="line-modified"> 775   /*                                                                       */</span>
<span class="line-modified"> 776   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 777   /*    Hint the glyph using the zone prepared by the caller.  Note that   */</span>
<span class="line-modified"> 778   /*    the zone is supposed to include four phantom points.               */</span>
<span class="line-modified"> 779   /*                                                                       */</span>
 780   static FT_Error
 781   TT_Hint_Glyph( TT_Loader  loader,
 782                  FT_Bool    is_composite )
 783   {
 784 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
 785     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 786     TT_Face    face   = loader-&gt;face;
 787     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 788 #endif
 789 
 790     TT_GlyphZone  zone = &amp;loader-&gt;zone;
 791 
 792 #ifdef TT_USE_BYTECODE_INTERPRETER
 793     FT_Long       n_ins;
 794 #else
 795     FT_UNUSED( is_composite );
 796 #endif
 797 
 798 
 799 #ifdef TT_USE_BYTECODE_INTERPRETER
<a name="32" id="anc32"></a><span class="line-removed"> 800     if ( loader-&gt;glyph-&gt;control_len &gt; 0xFFFFL )</span>
<span class="line-removed"> 801     {</span>
<span class="line-removed"> 802       FT_TRACE1(( &quot;TT_Hint_Glyph: too long instructions&quot; ));</span>
<span class="line-removed"> 803       FT_TRACE1(( &quot; (0x%lx byte) is truncated\n&quot;,</span>
<span class="line-removed"> 804                   loader-&gt;glyph-&gt;control_len ));</span>
<span class="line-removed"> 805     }</span>
 806     n_ins = loader-&gt;glyph-&gt;control_len;
 807 
<a name="33" id="anc33"></a><span class="line-modified"> 808     /* save original point position in org */</span>
 809     if ( n_ins &gt; 0 )
 810       FT_ARRAY_COPY( zone-&gt;org, zone-&gt;cur, zone-&gt;n_points );
 811 
 812     /* Reset graphics state. */
 813     loader-&gt;exec-&gt;GS = loader-&gt;size-&gt;GS;
 814 
 815     /* XXX: UNDOCUMENTED! Hinting instructions of a composite glyph */
 816     /*      completely refer to the (already) hinted subglyphs.     */
 817     if ( is_composite )
 818     {
 819       loader-&gt;exec-&gt;metrics.x_scale = 1 &lt;&lt; 16;
 820       loader-&gt;exec-&gt;metrics.y_scale = 1 &lt;&lt; 16;
 821 
 822       FT_ARRAY_COPY( zone-&gt;orus, zone-&gt;cur, zone-&gt;n_points );
 823     }
 824     else
 825     {
 826       loader-&gt;exec-&gt;metrics.x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
 827       loader-&gt;exec-&gt;metrics.y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
 828     }
 829 #endif
 830 
 831     /* round phantom points */
 832     zone-&gt;cur[zone-&gt;n_points - 4].x =
 833       FT_PIX_ROUND( zone-&gt;cur[zone-&gt;n_points - 4].x );
 834     zone-&gt;cur[zone-&gt;n_points - 3].x =
 835       FT_PIX_ROUND( zone-&gt;cur[zone-&gt;n_points - 3].x );
 836     zone-&gt;cur[zone-&gt;n_points - 2].y =
 837       FT_PIX_ROUND( zone-&gt;cur[zone-&gt;n_points - 2].y );
 838     zone-&gt;cur[zone-&gt;n_points - 1].y =
 839       FT_PIX_ROUND( zone-&gt;cur[zone-&gt;n_points - 1].y );
 840 
 841 #ifdef TT_USE_BYTECODE_INTERPRETER
 842 
 843     if ( n_ins &gt; 0 )
 844     {
 845       FT_Error  error;
 846 
 847       FT_GlyphLoader  gloader         = loader-&gt;gloader;
 848       FT_Outline      current_outline = gloader-&gt;current.outline;
 849 
 850 
 851       TT_Set_CodeRange( loader-&gt;exec, tt_coderange_glyph,
 852                         loader-&gt;exec-&gt;glyphIns, n_ins );
 853 
 854       loader-&gt;exec-&gt;is_composite = is_composite;
 855       loader-&gt;exec-&gt;pts          = *zone;
 856 
 857       error = TT_Run_Context( loader-&gt;exec );
 858       if ( error &amp;&amp; loader-&gt;exec-&gt;pedantic_hinting )
 859         return error;
 860 
 861       /* store drop-out mode in bits 5-7; set bit 2 also as a marker */
 862       current_outline.tags[0] |=
 863         ( loader-&gt;exec-&gt;GS.scan_type &lt;&lt; 5 ) | FT_CURVE_TAG_HAS_SCANMODE;
 864     }
 865 
 866 #endif
 867 
 868 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 869     /* Save possibly modified glyph phantom points unless in v40 backward  */
 870     /* compatibility mode, where no movement on the x axis means no reason */
 871     /* to change bearings or advance widths.                               */
 872     if ( !( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 &amp;&amp;
 873             loader-&gt;exec-&gt;backward_compatibility ) )
 874     {
 875 #endif
 876       loader-&gt;pp1 = zone-&gt;cur[zone-&gt;n_points - 4];
 877       loader-&gt;pp2 = zone-&gt;cur[zone-&gt;n_points - 3];
 878       loader-&gt;pp3 = zone-&gt;cur[zone-&gt;n_points - 2];
 879       loader-&gt;pp4 = zone-&gt;cur[zone-&gt;n_points - 1];
 880 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
 881     }
 882 #endif
 883 
 884 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 885     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
 886     {
 887       if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_DEEMBOLDEN )
 888         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, -24, 0 );
 889 
 890       else if ( loader-&gt;exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_EMBOLDEN )
 891         FT_Outline_EmboldenXY( &amp;loader-&gt;gloader-&gt;current.outline, 24, 0 );
 892     }
 893 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 894 
 895     return FT_Err_Ok;
 896   }
 897 
 898 
<a name="34" id="anc34"></a><span class="line-modified"> 899   /*************************************************************************/</span>
<span class="line-modified"> 900   /*                                                                       */</span>
<span class="line-modified"> 901   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 902   /*    TT_Process_Simple_Glyph                                            */</span>
<span class="line-modified"> 903   /*                                                                       */</span>
<span class="line-modified"> 904   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 905   /*    Once a simple glyph has been loaded, it needs to be processed.     */</span>
<span class="line-modified"> 906   /*    Usually, this means scaling and hinting through bytecode           */</span>
<span class="line-modified"> 907   /*    interpretation.                                                    */</span>
<span class="line-modified"> 908   /*                                                                       */</span>
 909   static FT_Error
 910   TT_Process_Simple_Glyph( TT_Loader  loader )
 911   {
 912     FT_GlyphLoader  gloader = loader-&gt;gloader;
 913     FT_Error        error   = FT_Err_Ok;
 914     FT_Outline*     outline;
 915     FT_Int          n_points;
 916 
<a name="35" id="anc35"></a>




 917 
 918     outline  = &amp;gloader-&gt;current.outline;
 919     n_points = outline-&gt;n_points;
 920 
 921     /* set phantom points */
 922 
 923     outline-&gt;points[n_points    ] = loader-&gt;pp1;
 924     outline-&gt;points[n_points + 1] = loader-&gt;pp2;
 925     outline-&gt;points[n_points + 2] = loader-&gt;pp3;
 926     outline-&gt;points[n_points + 3] = loader-&gt;pp4;
 927 
 928     outline-&gt;tags[n_points    ] = 0;
 929     outline-&gt;tags[n_points + 1] = 0;
 930     outline-&gt;tags[n_points + 2] = 0;
 931     outline-&gt;tags[n_points + 3] = 0;
 932 
 933     n_points += 4;
 934 
 935 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 936 
<a name="36" id="anc36"></a><span class="line-modified"> 937     if ( FT_IS_NAMED_INSTANCE( FT_FACE( loader-&gt;face ) ) ||</span>
<span class="line-removed"> 938          FT_IS_VARIATION( FT_FACE( loader-&gt;face ) )      )</span>
 939     {
<a name="37" id="anc37"></a>


 940       /* Deltas apply to the unscaled data. */
 941       error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
 942                                           loader-&gt;glyph_index,
 943                                           outline,
<a name="38" id="anc38"></a>
 944                                           (FT_UInt)n_points );
 945 
 946       /* recalculate linear horizontal and vertical advances */
 947       /* if we don&#39;t have HVAR and VVAR, respectively        */
<a name="39" id="anc39"></a>


 948       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<a name="40" id="anc40"></a><span class="line-modified"> 949         loader-&gt;linear = outline-&gt;points[n_points - 3].x -</span>
<span class="line-modified"> 950                          outline-&gt;points[n_points - 4].x;</span>
 951       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<a name="41" id="anc41"></a><span class="line-modified"> 952         loader-&gt;vadvance = outline-&gt;points[n_points - 1].x -</span>
<span class="line-modified"> 953                            outline-&gt;points[n_points - 2].x;</span>
 954 
 955       if ( error )
<a name="42" id="anc42"></a><span class="line-modified"> 956         return error;</span>
 957     }
 958 
 959 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 960 
 961     if ( IS_HINTED( loader-&gt;load_flags ) )
 962     {
 963       tt_prepare_zone( &amp;loader-&gt;zone, &amp;gloader-&gt;current, 0, 0 );
 964 
 965       FT_ARRAY_COPY( loader-&gt;zone.orus, loader-&gt;zone.cur,
 966                      loader-&gt;zone.n_points + 4 );
 967     }
 968 
 969     {
 970 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 971       TT_Face    face   = loader-&gt;face;
 972       TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
 973 
 974       FT_String*  family         = face-&gt;root.family_name;
 975       FT_UInt     ppem           = loader-&gt;size-&gt;metrics-&gt;x_ppem;
 976       FT_String*  style          = face-&gt;root.style_name;
 977       FT_UInt     x_scale_factor = 1000;
 978 #endif
 979 
 980       FT_Vector*  vec   = outline-&gt;points;
 981       FT_Vector*  limit = outline-&gt;points + n_points;
 982 
 983       FT_Fixed  x_scale = 0; /* pacify compiler */
 984       FT_Fixed  y_scale = 0;
 985 
 986       FT_Bool  do_scale = FALSE;
 987 
 988 
 989 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 990 
 991       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
 992       {
 993         /* scale, but only if enabled and only if TT hinting is being used */
 994         if ( IS_HINTED( loader-&gt;load_flags ) )
 995           x_scale_factor = sph_test_tweak_x_scaling( face,
 996                                                      family,
 997                                                      ppem,
 998                                                      style,
 999                                                      loader-&gt;glyph_index );
1000         /* scale the glyph */
1001         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 ||
1002              x_scale_factor != 1000                         )
1003         {
1004           x_scale = FT_MulDiv( loader-&gt;size-&gt;metrics-&gt;x_scale,
1005                                (FT_Long)x_scale_factor, 1000 );
1006           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1007 
1008           /* compensate for any scaling by de/emboldening; */
1009           /* the amount was determined via experimentation */
1010           if ( x_scale_factor != 1000 &amp;&amp; ppem &gt; 11 )
<a name="43" id="anc43"></a>







1011             FT_Outline_EmboldenXY( outline,
1012                                    FT_MulFix( 1280 * ppem,
1013                                               1000 - x_scale_factor ),
1014                                    0 );
<a name="44" id="anc44"></a>




1015           do_scale = TRUE;
1016         }
1017       }
1018       else
1019 
1020 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
1021 
1022       {
1023         /* scale the glyph */
1024         if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1025         {
1026           x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1027           y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1028 
1029           do_scale = TRUE;
1030         }
1031       }
1032 
1033       if ( do_scale )
1034       {
<a name="45" id="anc45"></a><span class="line-modified">1035         for ( ; vec &lt; limit; vec++ )</span>

1036         {
<a name="46" id="anc46"></a><span class="line-modified">1037           vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );</span>
<span class="line-modified">1038           vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );</span>















1039         }
1040       }
1041 
1042 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1043       /* if we have a HVAR table, `pp1&#39; and/or `pp2&#39; are already adjusted */
1044       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) ||
1045            !IS_HINTED( loader-&gt;load_flags )                                 )
1046 #endif
1047       {
1048         loader-&gt;pp1 = outline-&gt;points[n_points - 4];
1049         loader-&gt;pp2 = outline-&gt;points[n_points - 3];
1050       }
1051 
1052 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1053       /* if we have a VVAR table, `pp3&#39; and/or `pp4&#39; are already adjusted */
1054       if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) ||
1055            !IS_HINTED( loader-&gt;load_flags )                                 )
1056 #endif
1057       {
1058         loader-&gt;pp3 = outline-&gt;points[n_points - 2];
1059         loader-&gt;pp4 = outline-&gt;points[n_points - 1];
1060       }
1061     }
1062 
1063     if ( IS_HINTED( loader-&gt;load_flags ) )
1064     {
1065       loader-&gt;zone.n_points += 4;
1066 
1067       error = TT_Hint_Glyph( loader, 0 );
1068     }
1069 
<a name="47" id="anc47"></a>




1070     return error;
1071   }
1072 
1073 
<a name="48" id="anc48"></a><span class="line-modified">1074   /*************************************************************************/</span>
<span class="line-modified">1075   /*                                                                       */</span>
<span class="line-modified">1076   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1077   /*    TT_Process_Composite_Component                                     */</span>
<span class="line-modified">1078   /*                                                                       */</span>
<span class="line-modified">1079   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1080   /*    Once a composite component has been loaded, it needs to be         */</span>
<span class="line-modified">1081   /*    processed.  Usually, this means transforming and translating.      */</span>
<span class="line-modified">1082   /*                                                                       */</span>
1083   static FT_Error
1084   TT_Process_Composite_Component( TT_Loader    loader,
1085                                   FT_SubGlyph  subglyph,
1086                                   FT_UInt      start_point,
1087                                   FT_UInt      num_base_points )
1088   {
1089     FT_GlyphLoader  gloader = loader-&gt;gloader;
1090     FT_Outline      current;
1091     FT_Bool         have_scale;
1092     FT_Pos          x, y;
1093 
1094 
1095     current.points   = gloader-&gt;base.outline.points +
1096                          num_base_points;
1097     current.n_points = gloader-&gt;base.outline.n_points -
1098                          (short)num_base_points;
1099 
1100     have_scale = FT_BOOL( subglyph-&gt;flags &amp; ( WE_HAVE_A_SCALE     |
1101                                               WE_HAVE_AN_XY_SCALE |
1102                                               WE_HAVE_A_2X2       ) );
1103 
1104     /* perform the transform required for this subglyph */
1105     if ( have_scale )
1106       FT_Outline_Transform( &amp;current, &amp;subglyph-&gt;transform );
1107 
1108     /* get offset */
1109     if ( !( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES ) )
1110     {
1111       FT_UInt     num_points = (FT_UInt)gloader-&gt;base.outline.n_points;
1112       FT_UInt     k = (FT_UInt)subglyph-&gt;arg1;
1113       FT_UInt     l = (FT_UInt)subglyph-&gt;arg2;
1114       FT_Vector*  p1;
1115       FT_Vector*  p2;
1116 
1117 
1118       /* match l-th point of the newly loaded component to the k-th point */
1119       /* of the previously loaded components.                             */
1120 
1121       /* change to the point numbers used by our outline */
1122       k += start_point;
1123       l += num_base_points;
1124       if ( k &gt;= num_base_points ||
1125            l &gt;= num_points      )
1126         return FT_THROW( Invalid_Composite );
1127 
1128       p1 = gloader-&gt;base.outline.points + k;
1129       p2 = gloader-&gt;base.outline.points + l;
1130 
1131       x = p1-&gt;x - p2-&gt;x;
1132       y = p1-&gt;y - p2-&gt;y;
1133     }
1134     else
1135     {
1136       x = subglyph-&gt;arg1;
1137       y = subglyph-&gt;arg2;
1138 
1139       if ( !x &amp;&amp; !y )
1140         return FT_Err_Ok;
1141 
1142       /* Use a default value dependent on                                  */
1143       /* TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED.  This is useful for old */
1144       /* TT fonts which don&#39;t set the xxx_COMPONENT_OFFSET bit.            */
1145 
1146       if ( have_scale &amp;&amp;
1147 #ifdef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
1148            !( subglyph-&gt;flags &amp; UNSCALED_COMPONENT_OFFSET ) )
1149 #else
1150             ( subglyph-&gt;flags &amp; SCALED_COMPONENT_OFFSET ) )
1151 #endif
1152       {
1153 
1154 #if 0
1155 
<a name="49" id="anc49"></a><span class="line-modified">1156         /*******************************************************************/</span>
<span class="line-modified">1157         /*                                                                 */</span>
<span class="line-modified">1158         /* This algorithm is what Apple documents.  But it doesn&#39;t work.   */</span>
<span class="line-modified">1159         /*                                                                 */</span>
1160         int  a = subglyph-&gt;transform.xx &gt; 0 ?  subglyph-&gt;transform.xx
1161                                             : -subglyph-&gt;transform.xx;
1162         int  b = subglyph-&gt;transform.yx &gt; 0 ?  subglyph-&gt;transform.yx
1163                                             : -subglyph-&gt;transform.yx;
1164         int  c = subglyph-&gt;transform.xy &gt; 0 ?  subglyph-&gt;transform.xy
1165                                             : -subglyph-&gt;transform.xy;
1166         int  d = subglyph-&gt;transform.yy &gt; 0 ?  subglyph-&gt;transform.yy
1167                                             : -subglyph-&gt;transform.yy;
1168         int  m = a &gt; b ? a : b;
1169         int  n = c &gt; d ? c : d;
1170 
1171 
1172         if ( a - b &lt;= 33 &amp;&amp; a - b &gt;= -33 )
1173           m *= 2;
1174         if ( c - d &lt;= 33 &amp;&amp; c - d &gt;= -33 )
1175           n *= 2;
1176         x = FT_MulFix( x, m );
1177         y = FT_MulFix( y, n );
1178 
1179 #else /* 1 */
1180 
<a name="50" id="anc50"></a><span class="line-modified">1181         /*******************************************************************/</span>
<span class="line-modified">1182         /*                                                                 */</span>
<span class="line-modified">1183         /* This algorithm is a guess and works much better than the above. */</span>
<span class="line-modified">1184         /*                                                                 */</span>
1185         FT_Fixed  mac_xscale = FT_Hypot( subglyph-&gt;transform.xx,
1186                                          subglyph-&gt;transform.xy );
1187         FT_Fixed  mac_yscale = FT_Hypot( subglyph-&gt;transform.yy,
1188                                          subglyph-&gt;transform.yx );
1189 
1190 
1191         x = FT_MulFix( x, mac_xscale );
1192         y = FT_MulFix( y, mac_yscale );
1193 
1194 #endif /* 1 */
1195 
1196       }
1197 
1198       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
1199       {
1200         FT_Fixed  x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;
1201         FT_Fixed  y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;
1202 
1203 
1204         x = FT_MulFix( x, x_scale );
1205         y = FT_MulFix( y, y_scale );
1206 
1207         if ( subglyph-&gt;flags &amp; ROUND_XY_TO_GRID )
1208         {
1209           TT_Face    face   = loader-&gt;face;
1210           TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
1211 
1212 
1213           if ( IS_HINTED( loader-&gt;load_flags ) )
1214           {
1215             /*
1216              * We round the horizontal offset only if there is hinting along
1217              * the x axis; this corresponds to integer advance width values.
1218              *
1219              * Theoretically, a glyph&#39;s bytecode can toggle ClearType&#39;s
1220              * `backward compatibility&#39; mode, which would allow modification
1221              * of the advance width.  In reality, however, applications
1222              * neither allow nor expect modified advance widths if subpixel
1223              * rendering is active.
1224              *
1225              */
1226             if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_35 )
1227               x = FT_PIX_ROUND( x );
1228 
1229             y = FT_PIX_ROUND( y );
1230           }
1231         }
1232       }
1233     }
1234 
1235     if ( x || y )
1236       FT_Outline_Translate( &amp;current, x, y );
1237 
1238     return FT_Err_Ok;
1239   }
1240 
1241 
<a name="51" id="anc51"></a><span class="line-modified">1242   /*************************************************************************/</span>
<span class="line-modified">1243   /*                                                                       */</span>
<span class="line-modified">1244   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1245   /*    TT_Process_Composite_Glyph                                         */</span>
<span class="line-modified">1246   /*                                                                       */</span>
<span class="line-modified">1247   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1248   /*    This is slightly different from TT_Process_Simple_Glyph, in that   */</span>
<span class="line-modified">1249   /*    its sole purpose is to hint the glyph.  Thus this function is      */</span>
<span class="line-modified">1250   /*    only available when bytecode interpreter is enabled.               */</span>
<span class="line-modified">1251   /*                                                                       */</span>
1252   static FT_Error
1253   TT_Process_Composite_Glyph( TT_Loader  loader,
1254                               FT_UInt    start_point,
1255                               FT_UInt    start_contour )
1256   {
1257     FT_Error     error;
1258     FT_Outline*  outline;
1259     FT_UInt      i;
1260 
1261 
1262     outline = &amp;loader-&gt;gloader-&gt;base.outline;
1263 
1264     /* make room for phantom points */
1265     error = FT_GLYPHLOADER_CHECK_POINTS( loader-&gt;gloader,
1266                                          outline-&gt;n_points + 4,
1267                                          0 );
1268     if ( error )
1269       return error;
1270 
1271     outline-&gt;points[outline-&gt;n_points    ] = loader-&gt;pp1;
1272     outline-&gt;points[outline-&gt;n_points + 1] = loader-&gt;pp2;
1273     outline-&gt;points[outline-&gt;n_points + 2] = loader-&gt;pp3;
1274     outline-&gt;points[outline-&gt;n_points + 3] = loader-&gt;pp4;
1275 
1276     outline-&gt;tags[outline-&gt;n_points    ] = 0;
1277     outline-&gt;tags[outline-&gt;n_points + 1] = 0;
1278     outline-&gt;tags[outline-&gt;n_points + 2] = 0;
1279     outline-&gt;tags[outline-&gt;n_points + 3] = 0;
1280 
1281 #ifdef TT_USE_BYTECODE_INTERPRETER
1282 
1283     {
1284       FT_Stream  stream = loader-&gt;stream;
1285       FT_UShort  n_ins, max_ins;
1286       FT_ULong   tmp;
1287 
1288 
1289       /* TT_Load_Composite_Glyph only gives us the offset of instructions */
1290       /* so we read them here                                             */
1291       if ( FT_STREAM_SEEK( loader-&gt;ins_pos ) ||
1292            FT_READ_USHORT( n_ins )           )
1293         return error;
1294 
1295       FT_TRACE5(( &quot;  Instructions size = %d\n&quot;, n_ins ));
1296 
1297       /* check it */
1298       max_ins = loader-&gt;face-&gt;max_profile.maxSizeOfInstructions;
1299       if ( n_ins &gt; max_ins )
1300       {
1301         /* don&#39;t trust `maxSizeOfInstructions&#39;; */
1302         /* only do a rough safety check         */
1303         if ( (FT_Int)n_ins &gt; loader-&gt;byte_len )
1304         {
1305           FT_TRACE1(( &quot;TT_Process_Composite_Glyph:&quot;
1306                       &quot; too many instructions (%d) for glyph with length %d\n&quot;,
1307                       n_ins, loader-&gt;byte_len ));
1308           return FT_THROW( Too_Many_Hints );
1309         }
1310 
1311         tmp   = loader-&gt;exec-&gt;glyphSize;
1312         error = Update_Max( loader-&gt;exec-&gt;memory,
1313                             &amp;tmp,
1314                             sizeof ( FT_Byte ),
1315                             (void*)&amp;loader-&gt;exec-&gt;glyphIns,
1316                             n_ins );
1317 
1318         loader-&gt;exec-&gt;glyphSize = (FT_UShort)tmp;
1319         if ( error )
1320           return error;
1321       }
1322       else if ( n_ins == 0 )
1323         return FT_Err_Ok;
1324 
1325       if ( FT_STREAM_READ( loader-&gt;exec-&gt;glyphIns, n_ins ) )
1326         return error;
1327 
1328       loader-&gt;glyph-&gt;control_data = loader-&gt;exec-&gt;glyphIns;
1329       loader-&gt;glyph-&gt;control_len  = n_ins;
1330     }
1331 
1332 #endif
1333 
1334     tt_prepare_zone( &amp;loader-&gt;zone, &amp;loader-&gt;gloader-&gt;base,
1335                      start_point, start_contour );
1336 
1337     /* Some points are likely touched during execution of  */
1338     /* instructions on components.  So let&#39;s untouch them. */
1339     for ( i = 0; i &lt; loader-&gt;zone.n_points; i++ )
1340       loader-&gt;zone.tags[i] &amp;= ~FT_CURVE_TAG_TOUCH_BOTH;
1341 
1342     loader-&gt;zone.n_points += 4;
1343 
1344     return TT_Hint_Glyph( loader, 1 );
1345   }
1346 
1347 
1348   /*
1349    * Calculate the phantom points
1350    *
1351    * Defining the right side bearing (rsb) as
1352    *
1353    *   rsb = aw - (lsb + xmax - xmin)
1354    *
1355    * (with `aw&#39; the advance width, `lsb&#39; the left side bearing, and `xmin&#39;
1356    * and `xmax&#39; the glyph&#39;s minimum and maximum x value), the OpenType
1357    * specification defines the initial position of horizontal phantom points
1358    * as
1359    *
1360    *   pp1 = (round(xmin - lsb), 0)      ,
1361    *   pp2 = (round(pp1 + aw), 0)        .
1362    *
1363    * Note that the rounding to the grid (in the device space) is not
1364    * documented currently in the specification.
1365    *
1366    * However, the specification lacks the precise definition of vertical
1367    * phantom points.  Greg Hitchcock provided the following explanation.
1368    *
1369    * - a `vmtx&#39; table is present
1370    *
1371    *   For any glyph, the minimum and maximum y values (`ymin&#39; and `ymax&#39;)
1372    *   are given in the `glyf&#39; table, the top side bearing (tsb) and advance
1373    *   height (ah) are given in the `vmtx&#39; table.  The bottom side bearing
1374    *   (bsb) is then calculated as
1375    *
1376    *     bsb = ah - (tsb + ymax - ymin)       ,
1377    *
1378    *   and the initial position of vertical phantom points is
1379    *
1380    *     pp3 = (x, round(ymax + tsb))       ,
1381    *     pp4 = (x, round(pp3 - ah))         .
1382    *
1383    *   See below for value `x&#39;.
1384    *
1385    * - no `vmtx&#39; table in the font
1386    *
1387    *   If there is an `OS/2&#39; table, we set
1388    *
1389    *     DefaultAscender = sTypoAscender       ,
1390    *     DefaultDescender = sTypoDescender     ,
1391    *
1392    *   otherwise we use data from the `hhea&#39; table:
1393    *
1394    *     DefaultAscender = Ascender         ,
1395    *     DefaultDescender = Descender       .
1396    *
1397    *   With these two variables we can now set
1398    *
1399    *     ah = DefaultAscender - sDefaultDescender    ,
1400    *     tsb = DefaultAscender - yMax                ,
1401    *
1402    *   and proceed as if a `vmtx&#39; table was present.
1403    *
1404    * Usually we have
1405    *
1406    *   x = aw / 2      ,                                                (1)
1407    *
1408    * but there is one compatibility case where it can be set to
1409    *
1410    *   x = -DefaultDescender -
1411    *         ((DefaultAscender - DefaultDescender - aw) / 2)     .      (2)
1412    *
1413    * and another one with
1414    *
1415    *   x = 0     .                                                      (3)
1416    *
1417    * In Windows, the history of those values is quite complicated,
1418    * depending on the hinting engine (that is, the graphics framework).
1419    *
1420    *   framework        from                 to       formula
1421    *  ----------------------------------------------------------
1422    *    GDI       Windows 98               current      (1)
1423    *              (Windows 2000 for NT)
1424    *    GDI+      Windows XP               Windows 7    (2)
1425    *    GDI+      Windows 8                current      (3)
1426    *    DWrite    Windows 7                current      (3)
1427    *
1428    * For simplicity, FreeType uses (1) for grayscale subpixel hinting and
1429    * (3) for everything else.
1430    *
1431    */
1432   static void
1433   tt_loader_set_pp( TT_Loader  loader )
1434   {
1435     FT_Bool  subpixel_hinting = 0;
1436     FT_Bool  grayscale        = 0;
1437     FT_Bool  use_aw_2         = 0;
1438 
1439 #ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
1440     TT_Driver driver = (TT_Driver)FT_FACE_DRIVER( loader-&gt;face );
1441 #endif
1442 
1443 
1444 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1445     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
1446     {
1447       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting
1448                                       : 0;
1449       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale
1450                                       : 0;
1451     }
1452 #endif
1453 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1454     if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
1455     {
1456       subpixel_hinting = loader-&gt;exec ? loader-&gt;exec-&gt;subpixel_hinting_lean
1457                                       : 0;
1458       grayscale        = loader-&gt;exec ? loader-&gt;exec-&gt;grayscale_cleartype
1459                                       : 0;
1460     }
1461 #endif
1462 
<a name="52" id="anc52"></a><span class="line-modified">1463     use_aw_2 = (FT_Bool)( subpixel_hinting &amp;&amp; grayscale );</span>
1464 
1465     loader-&gt;pp1.x = loader-&gt;bbox.xMin - loader-&gt;left_bearing;
1466     loader-&gt;pp1.y = 0;
1467     loader-&gt;pp2.x = loader-&gt;pp1.x + loader-&gt;advance;
1468     loader-&gt;pp2.y = 0;
1469 
1470     loader-&gt;pp3.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1471     loader-&gt;pp3.y = loader-&gt;bbox.yMax + loader-&gt;top_bearing;
1472     loader-&gt;pp4.x = use_aw_2 ? loader-&gt;advance / 2 : 0;
1473     loader-&gt;pp4.y = loader-&gt;pp3.y - loader-&gt;vadvance;
1474   }
1475 
1476 
1477   /* a utility function to retrieve i-th node from given FT_List */
1478   static FT_ListNode
1479   ft_list_get_node_at( FT_List  list,
1480                        FT_UInt  idx )
1481   {
1482     FT_ListNode  cur;
1483 
1484 
1485     if ( !list )
1486       return NULL;
1487 
1488     for ( cur = list-&gt;head; cur; cur = cur-&gt;next )
1489     {
1490       if ( !idx )
1491         return cur;
1492 
1493       idx--;
1494     }
1495 
1496     return NULL;
1497   }
1498 
1499 
<a name="53" id="anc53"></a><span class="line-modified">1500   /*************************************************************************/</span>
<span class="line-modified">1501   /*                                                                       */</span>
<span class="line-modified">1502   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1503   /*    load_truetype_glyph                                                */</span>
<span class="line-modified">1504   /*                                                                       */</span>
<span class="line-modified">1505   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1506   /*    Loads a given truetype glyph.  Handles composites and uses a       */</span>
<span class="line-modified">1507   /*    TT_Loader object.                                                  */</span>
<span class="line-modified">1508   /*                                                                       */</span>
1509   static FT_Error
1510   load_truetype_glyph( TT_Loader  loader,
1511                        FT_UInt    glyph_index,
1512                        FT_UInt    recurse_count,
1513                        FT_Bool    header_only )
1514   {
<a name="54" id="anc54"></a><span class="line-modified">1515     FT_Error        error        = FT_Err_Ok;</span>
1516     FT_Fixed        x_scale, y_scale;
1517     FT_ULong        offset;
<a name="55" id="anc55"></a><span class="line-modified">1518     TT_Face         face         = loader-&gt;face;</span>
<span class="line-modified">1519     FT_GlyphLoader  gloader      = loader-&gt;gloader;</span>
<span class="line-modified">1520     FT_Bool         opened_frame = 0;</span>

1521 
1522 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1523     FT_StreamRec    inc_stream;
1524     FT_Data         glyph_data;
1525     FT_Bool         glyph_data_loaded = 0;
1526 #endif
1527 
1528 
1529 #ifdef FT_DEBUG_LEVEL_TRACE
1530     if ( recurse_count )
1531       FT_TRACE5(( &quot;  nesting level: %d\n&quot;, recurse_count ));
1532 #endif
1533 
1534     /* some fonts have an incorrect value of `maxComponentDepth&#39; */
1535     if ( recurse_count &gt; face-&gt;max_profile.maxComponentDepth )
1536     {
1537       FT_TRACE1(( &quot;load_truetype_glyph: maxComponentDepth set to %d\n&quot;,
1538                   recurse_count ));
1539       face-&gt;max_profile.maxComponentDepth = (FT_UShort)recurse_count;
1540     }
1541 
1542 #ifndef FT_CONFIG_OPTION_INCREMENTAL
1543     /* check glyph index */
1544     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs )
1545     {
1546       error = FT_THROW( Invalid_Glyph_Index );
1547       goto Exit;
1548     }
1549 #endif
1550 
1551     loader-&gt;glyph_index = glyph_index;
1552 
<a name="56" id="anc56"></a><span class="line-modified">1553     if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )</span>
1554     {
<a name="57" id="anc57"></a><span class="line-modified">1555       x_scale = loader-&gt;size-&gt;metrics-&gt;x_scale;</span>
<span class="line-modified">1556       y_scale = loader-&gt;size-&gt;metrics-&gt;y_scale;</span>
1557     }
1558     else
1559     {
<a name="58" id="anc58"></a><span class="line-modified">1560       x_scale = 0x10000L;</span>
<span class="line-modified">1561       y_scale = 0x10000L;</span>
1562     }
1563 
1564     /* Set `offset&#39; to the start of the glyph relative to the start of */
1565     /* the `glyf&#39; table, and `byte_len&#39; to the length of the glyph in  */
1566     /* bytes.                                                          */
1567 
1568 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1569 
1570     /* If we are loading glyph data via the incremental interface, set */
1571     /* the loader stream to a memory stream reading the data returned  */
1572     /* by the interface.                                               */
1573     if ( face-&gt;root.internal-&gt;incremental_interface )
1574     {
1575       error = face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;get_glyph_data(
1576                 face-&gt;root.internal-&gt;incremental_interface-&gt;object,
1577                 glyph_index, &amp;glyph_data );
1578       if ( error )
1579         goto Exit;
1580 
1581       glyph_data_loaded = 1;
1582       offset            = 0;
1583       loader-&gt;byte_len  = glyph_data.length;
1584 
1585       FT_ZERO( &amp;inc_stream );
1586       FT_Stream_OpenMemory( &amp;inc_stream,
1587                             glyph_data.pointer,
1588                             (FT_ULong)glyph_data.length );
1589 
1590       loader-&gt;stream = &amp;inc_stream;
1591     }
1592     else
1593 
1594 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
1595 
1596       offset = tt_face_get_location( face, glyph_index,
1597                                      (FT_UInt*)&amp;loader-&gt;byte_len );
1598 
1599     if ( loader-&gt;byte_len &gt; 0 )
1600     {
1601 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1602       /* for the incremental interface, `glyf_offset&#39; is always zero */
1603       if ( !face-&gt;glyf_offset                          &amp;&amp;
1604            !face-&gt;root.internal-&gt;incremental_interface )
1605 #else
1606       if ( !face-&gt;glyf_offset )
1607 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
1608       {
1609         FT_TRACE2(( &quot;no `glyf&#39; table but non-zero `loca&#39; entry\n&quot; ));
1610         error = FT_THROW( Invalid_Table );
1611         goto Exit;
1612       }
1613 
1614       error = face-&gt;access_glyph_frame( loader, glyph_index,
1615                                         face-&gt;glyf_offset + offset,
1616                                         (FT_UInt)loader-&gt;byte_len );
1617       if ( error )
1618         goto Exit;
1619 
<a name="59" id="anc59"></a><span class="line-removed">1620       opened_frame = 1;</span>
<span class="line-removed">1621 </span>
1622       /* read glyph header first */
1623       error = face-&gt;read_glyph_header( loader );
<a name="60" id="anc60"></a><span class="line-removed">1624       if ( error )</span>
<span class="line-removed">1625         goto Exit;</span>
1626 
<a name="61" id="anc61"></a><span class="line-modified">1627       /* the metrics must be computed after loading the glyph header */</span>
<span class="line-removed">1628       /* since we need the glyph&#39;s `yMax&#39; value in case the vertical */</span>
<span class="line-removed">1629       /* metrics must be emulated                                    */</span>
<span class="line-removed">1630       error = tt_get_metrics( loader, glyph_index );</span>
<span class="line-removed">1631       if ( error )</span>
<span class="line-removed">1632         goto Exit;</span>
1633 
<a name="62" id="anc62"></a><span class="line-modified">1634       if ( header_only )</span>
1635         goto Exit;
1636     }
1637 
<a name="63" id="anc63"></a>
1638     if ( loader-&gt;byte_len == 0 || loader-&gt;n_contours == 0 )
1639     {
1640       loader-&gt;bbox.xMin = 0;
1641       loader-&gt;bbox.xMax = 0;
1642       loader-&gt;bbox.yMin = 0;
1643       loader-&gt;bbox.yMax = 0;
<a name="64" id="anc64"></a>
1644 
<a name="65" id="anc65"></a><span class="line-modified">1645       error = tt_get_metrics( loader, glyph_index );</span>
<span class="line-modified">1646       if ( error )</span>
<span class="line-modified">1647         goto Exit;</span>



1648 
<a name="66" id="anc66"></a><span class="line-modified">1649       if ( header_only )</span>
<span class="line-modified">1650         goto Exit;</span>
1651 
<a name="67" id="anc67"></a>

1652       /* must initialize points before (possibly) overriding */
1653       /* glyph metrics from the incremental interface        */
1654       tt_loader_set_pp( loader );
1655 
1656 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1657       tt_get_metrics_incr_overrides( loader, glyph_index );
1658 #endif
1659 
1660 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1661 
1662       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1663            FT_IS_VARIATION( FT_FACE( face ) )      )
1664       {
1665         /* a small outline structure with four elements for */
1666         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39;  */
1667         FT_Vector   points[4];
1668         char        tags[4]     = { 1, 1, 1, 1 };
1669         short       contours[4] = { 0, 1, 2, 3 };
1670         FT_Outline  outline;
1671 
<a name="68" id="anc68"></a>


1672 
1673         points[0].x = loader-&gt;pp1.x;
1674         points[0].y = loader-&gt;pp1.y;
1675         points[1].x = loader-&gt;pp2.x;
1676         points[1].y = loader-&gt;pp2.y;
1677 
1678         points[2].x = loader-&gt;pp3.x;
1679         points[2].y = loader-&gt;pp3.y;
1680         points[3].x = loader-&gt;pp4.x;
1681         points[3].y = loader-&gt;pp4.y;
1682 
1683         outline.n_points   = 4;
1684         outline.n_contours = 4;
1685         outline.points     = points;
1686         outline.tags       = tags;
1687         outline.contours   = contours;
1688 
1689         /* this must be done before scaling */
1690         error = TT_Vary_Apply_Glyph_Deltas( loader-&gt;face,
1691                                             glyph_index,
1692                                             &amp;outline,
<a name="69" id="anc69"></a>
1693                                             (FT_UInt)outline.n_points );
1694         if ( error )
1695           goto Exit;
1696 
1697         loader-&gt;pp1.x = points[0].x;
1698         loader-&gt;pp1.y = points[0].y;
1699         loader-&gt;pp2.x = points[1].x;
1700         loader-&gt;pp2.y = points[1].y;
1701 
1702         loader-&gt;pp3.x = points[2].x;
1703         loader-&gt;pp3.y = points[2].y;
1704         loader-&gt;pp4.x = points[3].x;
1705         loader-&gt;pp4.y = points[3].y;
1706 
<a name="70" id="anc70"></a><span class="line-removed">1707 </span>
1708         /* recalculate linear horizontal and vertical advances */
1709         /* if we don&#39;t have HVAR and VVAR, respectively        */
1710         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<a name="71" id="anc71"></a><span class="line-modified">1711           loader-&gt;linear = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>

1712         if ( !( loader-&gt;face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<a name="72" id="anc72"></a><span class="line-modified">1713           loader-&gt;vadvance = loader-&gt;pp4.x - loader-&gt;pp3.x;</span>

1714       }
1715 
1716 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1717 
1718       /* scale phantom points, if necessary; */
1719       /* they get rounded in `TT_Hint_Glyph&#39; */
1720       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1721       {
1722         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
1723         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
1724         /* pp1.y and pp2.y are always zero */
1725 
1726         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
1727         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
1728         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
1729         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
1730       }
1731 
1732       error = FT_Err_Ok;
1733       goto Exit;
1734     }
1735 
1736     /* must initialize phantom points before (possibly) overriding */
1737     /* glyph metrics from the incremental interface                */
1738     tt_loader_set_pp( loader );
1739 
1740 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1741     tt_get_metrics_incr_overrides( loader, glyph_index );
1742 #endif
1743 
1744     /***********************************************************************/
1745     /***********************************************************************/
1746     /***********************************************************************/
1747 
<a name="73" id="anc73"></a>









1748     /* if it is a simple glyph, load it */
1749 
1750     if ( loader-&gt;n_contours &gt; 0 )
1751     {
1752       error = face-&gt;read_simple_glyph( loader );
1753       if ( error )
1754         goto Exit;
1755 
1756       /* all data have been read */
1757       face-&gt;forget_glyph_frame( loader );
1758       opened_frame = 0;
1759 
1760       error = TT_Process_Simple_Glyph( loader );
1761       if ( error )
1762         goto Exit;
1763 
1764       FT_GlyphLoader_Add( gloader );
1765     }
1766 
1767     /***********************************************************************/
1768     /***********************************************************************/
1769     /***********************************************************************/
1770 
1771     /* otherwise, load a composite! */
1772     else if ( loader-&gt;n_contours &lt; 0 )
1773     {
1774       FT_Memory  memory = face-&gt;root.memory;
1775 
1776       FT_UInt   start_point;
1777       FT_UInt   start_contour;
1778       FT_ULong  ins_pos;  /* position of composite instructions, if any */
1779 
1780       FT_ListNode  node, node2;
1781 
1782 
1783       /* normalize the `n_contours&#39; value */
1784       loader-&gt;n_contours = -1;
1785 
1786       /*
1787        * We store the glyph index directly in the `node-&gt;data&#39; pointer,
1788        * following the glib solution (cf. macro `GUINT_TO_POINTER&#39;) with a
1789        * double cast to make this portable.  Note, however, that this needs
1790        * pointers with a width of at least 32 bits.
1791        */
1792 
<a name="74" id="anc74"></a><span class="line-removed">1793 </span>
1794       /* clear the nodes filled by sibling chains */
1795       node = ft_list_get_node_at( &amp;loader-&gt;composites, recurse_count );
1796       for ( node2 = node; node2; node2 = node2-&gt;next )
1797         node2-&gt;data = (void*)FT_ULONG_MAX;
1798 
1799       /* check whether we already have a composite glyph with this index */
1800       if ( FT_List_Find( &amp;loader-&gt;composites,
1801                          FT_UINT_TO_POINTER( glyph_index ) ) )
1802       {
1803         FT_TRACE1(( &quot;TT_Load_Composite_Glyph:&quot;
1804                     &quot; infinite recursion detected\n&quot; ));
1805         error = FT_THROW( Invalid_Composite );
1806         goto Exit;
1807       }
1808 
1809       else if ( node )
1810         node-&gt;data = FT_UINT_TO_POINTER( glyph_index );
1811 
1812       else
1813       {
1814         if ( FT_NEW( node ) )
1815           goto Exit;
1816         node-&gt;data = FT_UINT_TO_POINTER( glyph_index );
1817         FT_List_Add( &amp;loader-&gt;composites, node );
1818       }
1819 
1820       start_point   = (FT_UInt)gloader-&gt;base.outline.n_points;
1821       start_contour = (FT_UInt)gloader-&gt;base.outline.n_contours;
1822 
1823       /* for each subglyph, read composite header */
1824       error = face-&gt;read_composite_glyph( loader );
1825       if ( error )
1826         goto Exit;
1827 
1828       /* store the offset of instructions */
1829       ins_pos = loader-&gt;ins_pos;
1830 
1831       /* all data we need are read */
1832       face-&gt;forget_glyph_frame( loader );
1833       opened_frame = 0;
1834 
1835 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1836 
1837       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1838            FT_IS_VARIATION( FT_FACE( face ) )      )
1839       {
1840         short        i, limit;
1841         FT_SubGlyph  subglyph;
1842 
1843         FT_Outline  outline;
<a name="75" id="anc75"></a><span class="line-modified">1844         FT_Vector*  points   = NULL;</span>
<span class="line-modified">1845         char*       tags     = NULL;</span>
<span class="line-modified">1846         short*      contours = NULL;</span>

1847 
1848 
1849         limit = (short)gloader-&gt;current.num_subglyphs;
1850 
1851         /* construct an outline structure for              */
1852         /* communication with `TT_Vary_Apply_Glyph_Deltas&#39; */
1853         outline.n_points   = (short)( gloader-&gt;current.num_subglyphs + 4 );
1854         outline.n_contours = outline.n_points;
1855 
1856         outline.points   = NULL;
1857         outline.tags     = NULL;
1858         outline.contours = NULL;
1859 
<a name="76" id="anc76"></a><span class="line-modified">1860         if ( FT_NEW_ARRAY( points, outline.n_points )   ||</span>
<span class="line-modified">1861              FT_NEW_ARRAY( tags, outline.n_points )     ||</span>
<span class="line-modified">1862              FT_NEW_ARRAY( contours, outline.n_points ) )</span>

1863           goto Exit1;
1864 
1865         subglyph = gloader-&gt;current.subglyphs;
1866 
1867         for ( i = 0; i &lt; limit; i++, subglyph++ )
1868         {
1869           /* applying deltas for anchor points doesn&#39;t make sense, */
1870           /* but we don&#39;t have to specially check this since       */
1871           /* unused delta values are zero anyways                  */
1872           points[i].x = subglyph-&gt;arg1;
1873           points[i].y = subglyph-&gt;arg2;
1874           tags[i]     = 1;
1875           contours[i] = i;
1876         }
1877 
1878         points[i].x = loader-&gt;pp1.x;
1879         points[i].y = loader-&gt;pp1.y;
1880         tags[i]     = 1;
1881         contours[i] = i;
1882 
1883         i++;
1884         points[i].x = loader-&gt;pp2.x;
1885         points[i].y = loader-&gt;pp2.y;
1886         tags[i]     = 1;
1887         contours[i] = i;
1888 
1889         i++;
1890         points[i].x = loader-&gt;pp3.x;
1891         points[i].y = loader-&gt;pp3.y;
1892         tags[i]     = 1;
1893         contours[i] = i;
1894 
1895         i++;
1896         points[i].x = loader-&gt;pp4.x;
1897         points[i].y = loader-&gt;pp4.y;
1898         tags[i]     = 1;
1899         contours[i] = i;
1900 
1901         outline.points   = points;
1902         outline.tags     = tags;
1903         outline.contours = contours;
1904 
1905         /* this call provides additional offsets */
1906         /* for each component&#39;s translation      */
1907         if ( FT_SET_ERROR( TT_Vary_Apply_Glyph_Deltas(
1908                              face,
1909                              glyph_index,
1910                              &amp;outline,
<a name="77" id="anc77"></a>
1911                              (FT_UInt)outline.n_points ) ) )
1912           goto Exit1;
1913 
1914         subglyph = gloader-&gt;current.subglyphs;
1915 
1916         for ( i = 0; i &lt; limit; i++, subglyph++ )
1917         {
1918           if ( subglyph-&gt;flags &amp; ARGS_ARE_XY_VALUES )
1919           {
1920             subglyph-&gt;arg1 = (FT_Int16)points[i].x;
1921             subglyph-&gt;arg2 = (FT_Int16)points[i].y;
1922           }
1923         }
1924 
1925         loader-&gt;pp1.x = points[i + 0].x;
1926         loader-&gt;pp1.y = points[i + 0].y;
1927         loader-&gt;pp2.x = points[i + 1].x;
1928         loader-&gt;pp2.y = points[i + 1].y;
1929 
1930         loader-&gt;pp3.x = points[i + 2].x;
1931         loader-&gt;pp3.y = points[i + 2].y;
1932         loader-&gt;pp4.x = points[i + 3].x;
1933         loader-&gt;pp4.y = points[i + 3].y;
1934 
1935         /* recalculate linear horizontal and vertical advances */
1936         /* if we don&#39;t have HVAR and VVAR, respectively        */
1937         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE ) )
<a name="78" id="anc78"></a><span class="line-modified">1938           loader-&gt;linear = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>


1939         if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE ) )
<a name="79" id="anc79"></a><span class="line-modified">1940           loader-&gt;vadvance = loader-&gt;pp4.x - loader-&gt;pp3.x;</span>


1941 
1942       Exit1:
1943         FT_FREE( outline.points );
1944         FT_FREE( outline.tags );
1945         FT_FREE( outline.contours );
<a name="80" id="anc80"></a>
1946 
1947         if ( error )
1948           goto Exit;
1949       }
1950 
1951 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1952 
1953       /* scale phantom points, if necessary; */
1954       /* they get rounded in `TT_Hint_Glyph&#39; */
1955       if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
1956       {
1957         loader-&gt;pp1.x = FT_MulFix( loader-&gt;pp1.x, x_scale );
1958         loader-&gt;pp2.x = FT_MulFix( loader-&gt;pp2.x, x_scale );
1959         /* pp1.y and pp2.y are always zero */
1960 
1961         loader-&gt;pp3.x = FT_MulFix( loader-&gt;pp3.x, x_scale );
1962         loader-&gt;pp3.y = FT_MulFix( loader-&gt;pp3.y, y_scale );
1963         loader-&gt;pp4.x = FT_MulFix( loader-&gt;pp4.x, x_scale );
1964         loader-&gt;pp4.y = FT_MulFix( loader-&gt;pp4.y, y_scale );
1965       }
1966 
1967       /* if the flag FT_LOAD_NO_RECURSE is set, we return the subglyph */
1968       /* `as is&#39; in the glyph slot (the client application will be     */
1969       /* responsible for interpreting these data)...                   */
1970       if ( loader-&gt;load_flags &amp; FT_LOAD_NO_RECURSE )
1971       {
1972         FT_GlyphLoader_Add( gloader );
1973         loader-&gt;glyph-&gt;format = FT_GLYPH_FORMAT_COMPOSITE;
1974 
1975         goto Exit;
1976       }
1977 
1978       /*********************************************************************/
1979       /*********************************************************************/
1980       /*********************************************************************/
1981 
1982       {
1983         FT_UInt      n, num_base_points;
1984         FT_SubGlyph  subglyph       = NULL;
1985 
1986         FT_UInt      num_points     = start_point;
1987         FT_UInt      num_subglyphs  = gloader-&gt;current.num_subglyphs;
1988         FT_UInt      num_base_subgs = gloader-&gt;base.num_subglyphs;
1989 
1990         FT_Stream    old_stream     = loader-&gt;stream;
1991         FT_Int       old_byte_len   = loader-&gt;byte_len;
1992 
1993 
1994         FT_GlyphLoader_Add( gloader );
1995 
1996         /* read each subglyph independently */
1997         for ( n = 0; n &lt; num_subglyphs; n++ )
1998         {
1999           FT_Vector  pp[4];
2000 
2001           FT_Int  linear_hadvance;
2002           FT_Int  linear_vadvance;
2003 
2004 
<a name="81" id="anc81"></a><span class="line-modified">2005           /* Each time we call load_truetype_glyph in this loop, the   */</span>
2006           /* value of `gloader.base.subglyphs&#39; can change due to table */
2007           /* reallocations.  We thus need to recompute the subglyph    */
2008           /* pointer on each iteration.                                */
2009           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2010 
2011           pp[0] = loader-&gt;pp1;
2012           pp[1] = loader-&gt;pp2;
2013           pp[2] = loader-&gt;pp3;
2014           pp[3] = loader-&gt;pp4;
2015 
2016           linear_hadvance = loader-&gt;linear;
2017           linear_vadvance = loader-&gt;vadvance;
2018 
2019           num_base_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2020 
2021           error = load_truetype_glyph( loader,
2022                                        (FT_UInt)subglyph-&gt;index,
2023                                        recurse_count + 1,
2024                                        FALSE );
2025           if ( error )
2026             goto Exit;
2027 
2028           /* restore subglyph pointer */
2029           subglyph = gloader-&gt;base.subglyphs + num_base_subgs + n;
2030 
2031           /* restore phantom points if necessary */
2032           if ( !( subglyph-&gt;flags &amp; USE_MY_METRICS ) )
2033           {
2034             loader-&gt;pp1 = pp[0];
2035             loader-&gt;pp2 = pp[1];
2036             loader-&gt;pp3 = pp[2];
2037             loader-&gt;pp4 = pp[3];
2038 
2039             loader-&gt;linear   = linear_hadvance;
2040             loader-&gt;vadvance = linear_vadvance;
2041           }
2042 
2043           num_points = (FT_UInt)gloader-&gt;base.outline.n_points;
2044 
2045           if ( num_points == num_base_points )
2046             continue;
2047 
<a name="82" id="anc82"></a><span class="line-modified">2048           /* gloader-&gt;base.outline consists of three parts:               */</span>
<span class="line-modified">2049           /* 0 -(1)-&gt; start_point -(2)-&gt; num_base_points -(3)-&gt; n_points. */</span>
<span class="line-modified">2050           /*                                                              */</span>
<span class="line-modified">2051           /* (1): exists from the beginning                               */</span>
<span class="line-modified">2052           /* (2): components that have been loaded so far                 */</span>
<span class="line-modified">2053           /* (3): the newly loaded component                              */</span>


2054           error = TT_Process_Composite_Component( loader,
2055                                                   subglyph,
2056                                                   start_point,
2057                                                   num_base_points );
2058           if ( error )
2059             goto Exit;
2060         }
2061 
2062         loader-&gt;stream   = old_stream;
2063         loader-&gt;byte_len = old_byte_len;
2064 
2065         /* process the glyph */
2066         loader-&gt;ins_pos = ins_pos;
2067         if ( IS_HINTED( loader-&gt;load_flags ) &amp;&amp;
2068 #ifdef TT_USE_BYTECODE_INTERPRETER
<a name="83" id="anc83"></a>
2069              subglyph-&gt;flags &amp; WE_HAVE_INSTR &amp;&amp;
2070 #endif
2071              num_points &gt; start_point )
2072         {
2073           error = TT_Process_Composite_Glyph( loader,
2074                                               start_point,
2075                                               start_contour );
2076           if ( error )
2077             goto Exit;
2078         }
2079       }
2080     }
2081 
2082     /***********************************************************************/
2083     /***********************************************************************/
2084     /***********************************************************************/
2085 
2086   Exit:
2087 
2088     if ( opened_frame )
2089       face-&gt;forget_glyph_frame( loader );
2090 
2091 #ifdef FT_CONFIG_OPTION_INCREMENTAL
2092 
2093     if ( glyph_data_loaded )
2094       face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;free_glyph_data(
2095         face-&gt;root.internal-&gt;incremental_interface-&gt;object,
2096         &amp;glyph_data );
2097 
2098 #endif
2099 
2100     return error;
2101   }
2102 
2103 
2104   static FT_Error
2105   compute_glyph_metrics( TT_Loader  loader,
2106                          FT_UInt    glyph_index )
2107   {
2108     TT_Face    face   = loader-&gt;face;
2109 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
2110     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2111     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( face );
2112 #endif
2113 
2114     FT_BBox       bbox;
2115     FT_Fixed      y_scale;
2116     TT_GlyphSlot  glyph = loader-&gt;glyph;
2117     TT_Size       size  = loader-&gt;size;
2118 
2119 
2120     y_scale = 0x10000L;
2121     if ( ( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) == 0 )
2122       y_scale = size-&gt;metrics-&gt;y_scale;
2123 
2124     if ( glyph-&gt;format != FT_GLYPH_FORMAT_COMPOSITE )
2125       FT_Outline_Get_CBox( &amp;glyph-&gt;outline, &amp;bbox );
2126     else
2127       bbox = loader-&gt;bbox;
2128 
2129     /* get the device-independent horizontal advance; it is scaled later */
2130     /* by the base layer.                                                */
2131     glyph-&gt;linearHoriAdvance = loader-&gt;linear;
2132 
2133     glyph-&gt;metrics.horiBearingX = bbox.xMin;
2134     glyph-&gt;metrics.horiBearingY = bbox.yMax;
<a name="84" id="anc84"></a><span class="line-modified">2135     glyph-&gt;metrics.horiAdvance  = loader-&gt;pp2.x - loader-&gt;pp1.x;</span>
2136 
2137     /* Adjust advance width to the value contained in the hdmx table   */
2138     /* unless FT_LOAD_COMPUTE_METRICS is set or backward compatibility */
2139     /* mode of the v40 interpreter is active.  See `ttinterp.h&#39; for    */
2140     /* details on backward compatibility mode.                         */
2141     if (
2142 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2143          !( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40  &amp;&amp;
2144             ( loader-&gt;exec &amp;&amp; loader-&gt;exec-&gt;backward_compatibility  ) ) &amp;&amp;
2145 #endif
2146          !face-&gt;postscript.isFixedPitch                                 &amp;&amp;
2147          IS_HINTED( loader-&gt;load_flags )                                &amp;&amp;
2148          !( loader-&gt;load_flags &amp; FT_LOAD_COMPUTE_METRICS )              )
2149     {
2150       FT_Byte*  widthp;
2151 
2152 
2153       widthp = tt_face_get_device_metrics( face,
2154                                            size-&gt;metrics-&gt;x_ppem,
2155                                            glyph_index );
2156 
2157 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2158 
2159       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
2160       {
2161         FT_Bool  ignore_x_mode;
2162 
2163 
2164         ignore_x_mode = FT_BOOL( FT_LOAD_TARGET_MODE( loader-&gt;load_flags ) !=
2165                                  FT_RENDER_MODE_MONO );
2166 
2167         if ( widthp                                                   &amp;&amp;
2168              ( ( ignore_x_mode &amp;&amp; loader-&gt;exec-&gt;compatible_widths ) ||
2169                 !ignore_x_mode                                      ||
2170                 SPH_OPTION_BITMAP_WIDTHS                            ) )
2171           glyph-&gt;metrics.horiAdvance = *widthp * 64;
2172       }
2173       else
2174 
2175 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
2176 
2177       {
2178         if ( widthp )
2179           glyph-&gt;metrics.horiAdvance = *widthp * 64;
2180       }
2181     }
2182 
2183     /* set glyph dimensions */
2184     glyph-&gt;metrics.width  = SUB_LONG( bbox.xMax, bbox.xMin );
2185     glyph-&gt;metrics.height = SUB_LONG( bbox.yMax, bbox.yMin );
2186 
2187     /* Now take care of vertical metrics.  In the case where there is */
2188     /* no vertical information within the font (relatively common),   */
2189     /* create some metrics manually                                   */
2190     {
2191       FT_Pos  top;      /* scaled vertical top side bearing  */
2192       FT_Pos  advance;  /* scaled vertical advance height    */
2193 
2194 
2195       /* Get the unscaled top bearing and advance height. */
2196       if ( face-&gt;vertical_info                   &amp;&amp;
2197            face-&gt;vertical.number_Of_VMetrics &gt; 0 )
2198       {
2199         top = (FT_Short)FT_DivFix( loader-&gt;pp3.y - bbox.yMax,
2200                                    y_scale );
2201 
2202         if ( loader-&gt;pp3.y &lt;= loader-&gt;pp4.y )
2203           advance = 0;
2204         else
2205           advance = (FT_UShort)FT_DivFix( loader-&gt;pp3.y - loader-&gt;pp4.y,
2206                                           y_scale );
2207       }
2208       else
2209       {
2210         FT_Pos  height;
2211 
2212 
2213         /* XXX Compute top side bearing and advance height in  */
2214         /*     Get_VMetrics instead of here.                   */
2215 
2216         /* NOTE: The OS/2 values are the only `portable&#39; ones, */
2217         /*       which is why we use them, if there is an OS/2 */
2218         /*       table in the font.  Otherwise, we use the     */
2219         /*       values defined in the horizontal header.      */
2220 
2221         height = (FT_Short)FT_DivFix( SUB_LONG( bbox.yMax,
2222                                                 bbox.yMin ),
2223                                       y_scale );
2224         if ( face-&gt;os2.version != 0xFFFFU )
2225           advance = (FT_Pos)( face-&gt;os2.sTypoAscender -
2226                               face-&gt;os2.sTypoDescender );
2227         else
2228           advance = (FT_Pos)( face-&gt;horizontal.Ascender -
2229                               face-&gt;horizontal.Descender );
2230 
2231         top = ( advance - height ) / 2;
2232       }
2233 
2234 #ifdef FT_CONFIG_OPTION_INCREMENTAL
2235       {
2236         FT_Incremental_InterfaceRec*  incr;
2237         FT_Incremental_MetricsRec     incr_metrics;
2238         FT_Error                      error;
2239 
2240 
2241         incr = face-&gt;root.internal-&gt;incremental_interface;
2242 
2243         /* If this is an incrementally loaded font see if there are */
2244         /* overriding metrics for this glyph.                       */
2245         if ( incr &amp;&amp; incr-&gt;funcs-&gt;get_glyph_metrics )
2246         {
2247           incr_metrics.bearing_x = 0;
2248           incr_metrics.bearing_y = top;
2249           incr_metrics.advance   = advance;
2250 
2251           error = incr-&gt;funcs-&gt;get_glyph_metrics( incr-&gt;object,
2252                                                   glyph_index,
2253                                                   TRUE,
2254                                                   &amp;incr_metrics );
2255           if ( error )
2256             return error;
2257 
2258           top     = incr_metrics.bearing_y;
2259           advance = incr_metrics.advance;
2260         }
2261       }
2262 
2263       /* GWW: Do vertical metrics get loaded incrementally too? */
2264 
2265 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
2266 
2267       glyph-&gt;linearVertAdvance = advance;
2268 
2269       /* scale the metrics */
2270       if ( !( loader-&gt;load_flags &amp; FT_LOAD_NO_SCALE ) )
2271       {
2272         top     = FT_MulFix( top,     y_scale );
2273         advance = FT_MulFix( advance, y_scale );
2274       }
2275 
2276       /* XXX: for now, we have no better algorithm for the lsb, but it */
2277       /*      should work fine.                                        */
2278       /*                                                               */
<a name="85" id="anc85"></a><span class="line-modified">2279       glyph-&gt;metrics.vertBearingX = glyph-&gt;metrics.horiBearingX -</span>
<span class="line-modified">2280                                       glyph-&gt;metrics.horiAdvance / 2;</span>
2281       glyph-&gt;metrics.vertBearingY = top;
2282       glyph-&gt;metrics.vertAdvance  = advance;
2283     }
2284 
<a name="86" id="anc86"></a><span class="line-modified">2285     return 0;</span>
2286   }
2287 
2288 
2289 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2290 
2291   static FT_Error
2292   load_sbit_image( TT_Size       size,
2293                    TT_GlyphSlot  glyph,
2294                    FT_UInt       glyph_index,
2295                    FT_Int32      load_flags )
2296   {
2297     TT_Face             face;
2298     SFNT_Service        sfnt;
2299     FT_Stream           stream;
2300     FT_Error            error;
2301     TT_SBit_MetricsRec  sbit_metrics;
2302 
2303 
2304     face   = (TT_Face)glyph-&gt;face;
2305     sfnt   = (SFNT_Service)face-&gt;sfnt;
2306     stream = face-&gt;root.stream;
2307 
2308     error = sfnt-&gt;load_sbit_image( face,
2309                                    size-&gt;strike_index,
2310                                    glyph_index,
2311                                    (FT_UInt)load_flags,
2312                                    stream,
2313                                    &amp;glyph-&gt;bitmap,
2314                                    &amp;sbit_metrics );
2315     if ( !error )
2316     {
2317       glyph-&gt;outline.n_points   = 0;
2318       glyph-&gt;outline.n_contours = 0;
2319 
2320       glyph-&gt;metrics.width  = (FT_Pos)sbit_metrics.width  * 64;
2321       glyph-&gt;metrics.height = (FT_Pos)sbit_metrics.height * 64;
2322 
2323       glyph-&gt;metrics.horiBearingX = (FT_Pos)sbit_metrics.horiBearingX * 64;
2324       glyph-&gt;metrics.horiBearingY = (FT_Pos)sbit_metrics.horiBearingY * 64;
2325       glyph-&gt;metrics.horiAdvance  = (FT_Pos)sbit_metrics.horiAdvance  * 64;
2326 
2327       glyph-&gt;metrics.vertBearingX = (FT_Pos)sbit_metrics.vertBearingX * 64;
2328       glyph-&gt;metrics.vertBearingY = (FT_Pos)sbit_metrics.vertBearingY * 64;
2329       glyph-&gt;metrics.vertAdvance  = (FT_Pos)sbit_metrics.vertAdvance  * 64;
2330 
2331       glyph-&gt;format = FT_GLYPH_FORMAT_BITMAP;
2332 
2333       if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
2334       {
2335         glyph-&gt;bitmap_left = sbit_metrics.vertBearingX;
2336         glyph-&gt;bitmap_top  = sbit_metrics.vertBearingY;
2337       }
2338       else
2339       {
2340         glyph-&gt;bitmap_left = sbit_metrics.horiBearingX;
2341         glyph-&gt;bitmap_top  = sbit_metrics.horiBearingY;
2342       }
2343     }
2344 
2345     return error;
2346   }
2347 
2348 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
2349 
2350 
2351   static FT_Error
2352   tt_loader_init( TT_Loader     loader,
2353                   TT_Size       size,
2354                   TT_GlyphSlot  glyph,
2355                   FT_Int32      load_flags,
2356                   FT_Bool       glyf_table_only )
2357   {
2358     TT_Face    face;
2359     FT_Stream  stream;
2360 
2361 #ifdef TT_USE_BYTECODE_INTERPRETER
2362     FT_Error   error;
2363     FT_Bool    pedantic = FT_BOOL( load_flags &amp; FT_LOAD_PEDANTIC );
2364 #if defined TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY || \
2365     defined TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2366     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( (TT_Face)glyph-&gt;face );
2367 #endif
2368 #endif
2369 
2370 
2371     face   = (TT_Face)glyph-&gt;face;
2372     stream = face-&gt;root.stream;
2373 
2374     FT_ZERO( loader );
2375 
2376 #ifdef TT_USE_BYTECODE_INTERPRETER
2377 
2378     /* load execution context */
2379     if ( IS_HINTED( load_flags ) &amp;&amp; !glyf_table_only )
2380     {
2381       TT_ExecContext  exec;
2382       FT_Bool         grayscale = TRUE;
2383 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2384       FT_Bool         subpixel_hinting_lean;
2385       FT_Bool         grayscale_cleartype;
2386 #endif
2387 
2388 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2389       FT_Bool  subpixel_hinting = FALSE;
2390 
2391 #if 0
2392       /* not used yet */
2393       FT_Bool  compatible_widths;
2394       FT_Bool  symmetrical_smoothing;
2395       FT_Bool  bgr;
2396       FT_Bool  vertical_lcd;
2397       FT_Bool  subpixel_positioned;
2398       FT_Bool  gray_cleartype;
2399 #endif
2400 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
2401 
2402       FT_Bool  reexecute = FALSE;
2403 
2404 
2405       if ( size-&gt;bytecode_ready &lt; 0 || size-&gt;cvt_ready &lt; 0 )
2406       {
2407         error = tt_size_ready_bytecode( size, pedantic );
2408         if ( error )
2409           return error;
2410       }
2411       else if ( size-&gt;bytecode_ready )
2412         return size-&gt;bytecode_ready;
2413       else if ( size-&gt;cvt_ready )
2414         return size-&gt;cvt_ready;
2415 
2416       /* query new execution context */
2417       exec = size-&gt;context;
2418       if ( !exec )
2419         return FT_THROW( Could_Not_Find_Context );
2420 
2421 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2422       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
2423       {
2424         subpixel_hinting_lean =
2425           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2426                    FT_RENDER_MODE_MONO               );
2427         grayscale_cleartype =
2428           FT_BOOL( subpixel_hinting_lean         &amp;&amp;
2429                    !( ( load_flags         &amp;
2430                         FT_LOAD_TARGET_LCD )   ||
2431                       ( load_flags           &amp;
2432                         FT_LOAD_TARGET_LCD_V ) ) );
2433         exec-&gt;vertical_lcd_lean =
2434           FT_BOOL( subpixel_hinting_lean    &amp;&amp;
2435                    ( load_flags           &amp;
2436                      FT_LOAD_TARGET_LCD_V ) );
2437       }
2438       else
2439       {
2440         subpixel_hinting_lean   = FALSE;
2441         grayscale_cleartype     = FALSE;
2442         exec-&gt;vertical_lcd_lean = FALSE;
2443       }
2444 #endif
2445 
2446 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2447 
2448       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
2449       {
2450         subpixel_hinting = FT_BOOL( ( FT_LOAD_TARGET_MODE( load_flags ) !=
2451                                       FT_RENDER_MODE_MONO               )  &amp;&amp;
2452                                     SPH_OPTION_SET_SUBPIXEL                );
2453 
2454         if ( subpixel_hinting )
2455           grayscale = FALSE;
2456         else if ( SPH_OPTION_SET_GRAYSCALE )
2457         {
2458           grayscale        = TRUE;
2459           subpixel_hinting = FALSE;
2460         }
2461         else
2462           grayscale = FALSE;
2463 
2464         if ( FT_IS_TRICKY( glyph-&gt;face ) )
2465           subpixel_hinting = FALSE;
2466 
2467         exec-&gt;ignore_x_mode      = subpixel_hinting || grayscale;
2468         exec-&gt;rasterizer_version = SPH_OPTION_SET_RASTERIZER_VERSION;
2469         if ( exec-&gt;sph_tweak_flags &amp; SPH_TWEAK_RASTERIZER_35 )
2470           exec-&gt;rasterizer_version = TT_INTERPRETER_VERSION_35;
2471 
2472 #if 1
2473         exec-&gt;compatible_widths     = SPH_OPTION_SET_COMPATIBLE_WIDTHS;
2474         exec-&gt;symmetrical_smoothing = TRUE;
2475         exec-&gt;bgr                   = FALSE;
2476         exec-&gt;vertical_lcd          = FALSE;
2477         exec-&gt;subpixel_positioned   = TRUE;
2478         exec-&gt;gray_cleartype        = FALSE;
2479 #else /* 0 */
2480         exec-&gt;compatible_widths =
2481           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2482                    TT_LOAD_COMPATIBLE_WIDTHS );
2483         exec-&gt;symmetrical_smoothing =
2484           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2485                    TT_LOAD_SYMMETRICAL_SMOOTHING );
2486         exec-&gt;bgr =
2487           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2488                    TT_LOAD_BGR );
2489         exec-&gt;vertical_lcd =
2490           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2491                    TT_LOAD_VERTICAL_LCD );
2492         exec-&gt;subpixel_positioned =
2493           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2494                    TT_LOAD_SUBPIXEL_POSITIONED );
2495         exec-&gt;gray_cleartype =
2496           FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2497                    TT_LOAD_GRAY_CLEARTYPE );
2498 #endif /* 0 */
2499 
2500       }
2501       else
2502 
2503 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
2504 
2505 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2506       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
2507         grayscale = FT_BOOL( !subpixel_hinting_lean               &amp;&amp;
2508                              FT_LOAD_TARGET_MODE( load_flags ) !=
2509                                FT_RENDER_MODE_MONO                );
2510       else
2511 #endif
2512         grayscale = FT_BOOL( FT_LOAD_TARGET_MODE( load_flags ) !=
2513                                FT_RENDER_MODE_MONO             );
2514 
2515       error = TT_Load_Context( exec, face, size );
2516       if ( error )
2517         return error;
2518 
2519 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2520 
2521       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 )
2522       {
2523         /* a change from mono to subpixel rendering (and vice versa) */
2524         /* requires a re-execution of the CVT program                */
2525         if ( subpixel_hinting != exec-&gt;subpixel_hinting )
2526         {
2527           FT_TRACE4(( &quot;tt_loader_init: subpixel hinting change,&quot;
2528                       &quot; re-executing `prep&#39; table\n&quot; ));
2529 
2530           exec-&gt;subpixel_hinting = subpixel_hinting;
2531           reexecute              = TRUE;
2532         }
2533 
2534         /* a change from mono to grayscale rendering (and vice versa) */
2535         /* requires a re-execution of the CVT program                 */
2536         if ( grayscale != exec-&gt;grayscale )
2537         {
2538           FT_TRACE4(( &quot;tt_loader_init: grayscale hinting change,&quot;
2539                       &quot; re-executing `prep&#39; table\n&quot; ));
2540 
2541           exec-&gt;grayscale = grayscale;
2542           reexecute       = TRUE;
2543         }
2544       }
2545       else
2546 
2547 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
2548 
2549       {
2550 
2551 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
2552         if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_40 )
2553         {
2554           /* a change from mono to subpixel rendering (and vice versa) */
2555           /* requires a re-execution of the CVT program                */
2556           if ( subpixel_hinting_lean != exec-&gt;subpixel_hinting_lean )
2557           {
2558             FT_TRACE4(( &quot;tt_loader_init: subpixel hinting change,&quot;
2559                         &quot; re-executing `prep&#39; table\n&quot; ));
2560 
2561             exec-&gt;subpixel_hinting_lean = subpixel_hinting_lean;
2562             reexecute                   = TRUE;
2563           }
2564 
2565           /* a change from colored to grayscale subpixel rendering (and */
2566           /* vice versa) requires a re-execution of the CVT program     */
2567           if ( grayscale_cleartype != exec-&gt;grayscale_cleartype )
2568           {
2569             FT_TRACE4(( &quot;tt_loader_init: grayscale subpixel hinting change,&quot;
2570                         &quot; re-executing `prep&#39; table\n&quot; ));
2571 
2572             exec-&gt;grayscale_cleartype = grayscale_cleartype;
2573             reexecute                 = TRUE;
2574           }
2575         }
2576 #endif
2577 
2578         /* a change from mono to grayscale rendering (and vice versa) */
2579         /* requires a re-execution of the CVT program                 */
2580         if ( grayscale != exec-&gt;grayscale )
2581         {
2582           FT_TRACE4(( &quot;tt_loader_init: grayscale hinting change,&quot;
2583                       &quot; re-executing `prep&#39; table\n&quot; ));
2584 
2585           exec-&gt;grayscale = grayscale;
2586           reexecute       = TRUE;
2587         }
2588       }
2589 
2590       if ( reexecute )
2591       {
<a name="87" id="anc87"></a><span class="line-removed">2592         FT_UInt  i;</span>
<span class="line-removed">2593 </span>
<span class="line-removed">2594 </span>
<span class="line-removed">2595         for ( i = 0; i &lt; size-&gt;cvt_size; i++ )</span>
<span class="line-removed">2596           size-&gt;cvt[i] = FT_MulFix( face-&gt;cvt[i], size-&gt;ttmetrics.scale );</span>
2597         error = tt_size_run_prep( size, pedantic );
2598         if ( error )
2599           return error;
2600       }
2601 
2602       /* check whether the cvt program has disabled hinting */
2603       if ( exec-&gt;GS.instruct_control &amp; 1 )
2604         load_flags |= FT_LOAD_NO_HINTING;
2605 
2606       /* load default graphics state -- if needed */
2607       if ( exec-&gt;GS.instruct_control &amp; 2 )
2608         exec-&gt;GS = tt_default_graphics_state;
2609 
2610 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2611       /* check whether we have a font hinted for ClearType --           */
2612       /* note that this flag can also be modified in a glyph&#39;s bytecode */
2613       if ( driver-&gt;interpreter_version == TT_INTERPRETER_VERSION_38 &amp;&amp;
2614            exec-&gt;GS.instruct_control &amp; 4                            )
2615         exec-&gt;ignore_x_mode = 0;
2616 #endif
2617 
2618       exec-&gt;pedantic_hinting = FT_BOOL( load_flags &amp; FT_LOAD_PEDANTIC );
2619       loader-&gt;exec = exec;
2620       loader-&gt;instructions = exec-&gt;glyphIns;
2621     }
2622 
2623 #endif /* TT_USE_BYTECODE_INTERPRETER */
2624 
2625     /* get face&#39;s glyph loader */
2626     if ( !glyf_table_only )
2627     {
2628       FT_GlyphLoader  gloader = glyph-&gt;internal-&gt;loader;
2629 
2630 
2631       FT_GlyphLoader_Rewind( gloader );
2632       loader-&gt;gloader = gloader;
2633     }
2634 
2635     loader-&gt;load_flags = (FT_ULong)load_flags;
2636 
2637     loader-&gt;face   = face;
2638     loader-&gt;size   = size;
2639     loader-&gt;glyph  = (FT_GlyphSlot)glyph;
2640     loader-&gt;stream = stream;
2641 
2642     loader-&gt;composites.head = NULL;
2643     loader-&gt;composites.tail = NULL;
2644 
2645     return FT_Err_Ok;
2646   }
2647 
2648 
2649   static void
2650   tt_loader_done( TT_Loader  loader )
2651   {
2652     FT_List_Finalize( &amp;loader-&gt;composites,
2653                       NULL,
2654                       loader-&gt;face-&gt;root.memory,
2655                       NULL );
2656   }
2657 
2658 
<a name="88" id="anc88"></a><span class="line-modified">2659   /*************************************************************************/</span>
<span class="line-modified">2660   /*                                                                       */</span>
<span class="line-modified">2661   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2662   /*    TT_Load_Glyph                                                      */</span>
<span class="line-modified">2663   /*                                                                       */</span>
<span class="line-modified">2664   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2665   /*    A function used to load a single glyph within a given glyph slot,  */</span>
<span class="line-modified">2666   /*    for a given size.                                                  */</span>
<span class="line-modified">2667   /*                                                                       */</span>
<span class="line-modified">2668   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2669   /*    glyph       :: A handle to a target slot object where the glyph    */</span>
<span class="line-modified">2670   /*                   will be loaded.                                     */</span>
<span class="line-modified">2671   /*                                                                       */</span>
<span class="line-modified">2672   /*    size        :: A handle to the source face size at which the glyph */</span>
<span class="line-modified">2673   /*                   must be scaled/loaded.                              */</span>
<span class="line-modified">2674   /*                                                                       */</span>
<span class="line-modified">2675   /*    glyph_index :: The index of the glyph in the font file.            */</span>
<span class="line-modified">2676   /*                                                                       */</span>
<span class="line-modified">2677   /*    load_flags  :: A flag indicating what to load for this glyph.  The */</span>
<span class="line-modified">2678   /*                   FT_LOAD_XXX constants can be used to control the    */</span>
<span class="line-modified">2679   /*                   glyph loading process (e.g., whether the outline    */</span>
<span class="line-modified">2680   /*                   should be scaled, whether to load bitmaps or not,   */</span>
<span class="line-modified">2681   /*                   whether to hint the outline, etc).                  */</span>
<span class="line-modified">2682   /*                                                                       */</span>
<span class="line-modified">2683   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2684   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2685   /*                                                                       */</span>




2686   FT_LOCAL_DEF( FT_Error )
2687   TT_Load_Glyph( TT_Size       size,
2688                  TT_GlyphSlot  glyph,
2689                  FT_UInt       glyph_index,
2690                  FT_Int32      load_flags )
2691   {
2692     FT_Error      error;
2693     TT_LoaderRec  loader;
2694 
<a name="89" id="anc89"></a><span class="line-removed">2695 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
<span class="line-removed">2696 #define IS_DEFAULT_INSTANCE  ( !( FT_IS_NAMED_INSTANCE( glyph-&gt;face ) ||  \</span>
<span class="line-removed">2697                                   FT_IS_VARIATION( glyph-&gt;face )      ) )</span>
<span class="line-removed">2698 #else</span>
<span class="line-removed">2699 #define IS_DEFAULT_INSTANCE  1</span>
<span class="line-removed">2700 #endif</span>
<span class="line-removed">2701 </span>
2702 
2703     FT_TRACE1(( &quot;TT_Load_Glyph: glyph index %d\n&quot;, glyph_index ));
2704 
2705 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
2706 
2707     /* try to load embedded bitmap (if any) */
2708     if ( size-&gt;strike_index != 0xFFFFFFFFUL      &amp;&amp;
2709          ( load_flags &amp; FT_LOAD_NO_BITMAP ) == 0 &amp;&amp;
<a name="90" id="anc90"></a><span class="line-modified">2710          IS_DEFAULT_INSTANCE                     )</span>
2711     {
2712       FT_Fixed  x_scale = size-&gt;root.metrics.x_scale;
2713       FT_Fixed  y_scale = size-&gt;root.metrics.y_scale;
2714 
2715 
2716       error = load_sbit_image( size, glyph, glyph_index, load_flags );
2717       if ( FT_ERR_EQ( error, Missing_Bitmap ) )
2718       {
2719         /* the bitmap strike is incomplete and misses the requested glyph; */
2720         /* if we have a bitmap-only font, return an empty glyph            */
2721         if ( !FT_IS_SCALABLE( glyph-&gt;face ) )
2722         {
2723           TT_Face  face = (TT_Face)glyph-&gt;face;
2724 
2725           FT_Short  left_bearing = 0;
2726           FT_Short  top_bearing  = 0;
2727 
2728           FT_UShort  advance_width  = 0;
2729           FT_UShort  advance_height = 0;
2730 
2731 
2732           /* to return an empty glyph, however, we need metrics data   */
2733           /* from the `hmtx&#39; (or `vmtx&#39;) table; the assumption is that */
2734           /* empty glyphs are missing intentionally, representing      */
2735           /* whitespace - not having at least horizontal metrics is    */
2736           /* thus considered an error                                  */
2737           if ( !face-&gt;horz_metrics_size )
2738             return error;
2739 
2740           /* we now construct an empty bitmap glyph */
2741           TT_Get_HMetrics( face, glyph_index,
2742                            &amp;left_bearing,
2743                            &amp;advance_width );
2744           TT_Get_VMetrics( face, glyph_index,
2745                            0,
2746                            &amp;top_bearing,
2747                            &amp;advance_height );
2748 
2749           glyph-&gt;outline.n_points   = 0;
2750           glyph-&gt;outline.n_contours = 0;
2751 
2752           glyph-&gt;metrics.width  = 0;
2753           glyph-&gt;metrics.height = 0;
2754 
2755           glyph-&gt;metrics.horiBearingX = FT_MulFix( left_bearing, x_scale );
2756           glyph-&gt;metrics.horiBearingY = 0;
2757           glyph-&gt;metrics.horiAdvance  = FT_MulFix( advance_width, x_scale );
2758 
2759           glyph-&gt;metrics.vertBearingX = 0;
2760           glyph-&gt;metrics.vertBearingY = FT_MulFix( top_bearing, y_scale );
2761           glyph-&gt;metrics.vertAdvance  = FT_MulFix( advance_height, y_scale );
2762 
2763           glyph-&gt;format            = FT_GLYPH_FORMAT_BITMAP;
2764           glyph-&gt;bitmap.pixel_mode = FT_PIXEL_MODE_MONO;
2765 
2766           glyph-&gt;bitmap_left = 0;
2767           glyph-&gt;bitmap_top  = 0;
2768 
2769           return FT_Err_Ok;
2770         }
2771       }
2772       else if ( error )
2773       {
2774         /* return error if font is not scalable */
2775         if ( !FT_IS_SCALABLE( glyph-&gt;face ) )
2776           return error;
2777       }
2778       else
2779       {
2780         if ( FT_IS_SCALABLE( glyph-&gt;face ) )
2781         {
2782           /* for the bbox we need the header only */
2783           (void)tt_loader_init( &amp;loader, size, glyph, load_flags, TRUE );
2784           (void)load_truetype_glyph( &amp;loader, glyph_index, 0, TRUE );
2785           tt_loader_done( &amp;loader );
2786           glyph-&gt;linearHoriAdvance = loader.linear;
2787           glyph-&gt;linearVertAdvance = loader.vadvance;
2788 
2789           /* sanity checks: if `xxxAdvance&#39; in the sbit metric */
2790           /* structure isn&#39;t set, use `linearXXXAdvance&#39;      */
2791           if ( !glyph-&gt;metrics.horiAdvance &amp;&amp; glyph-&gt;linearHoriAdvance )
2792             glyph-&gt;metrics.horiAdvance = FT_MulFix( glyph-&gt;linearHoriAdvance,
2793                                                     x_scale );
2794           if ( !glyph-&gt;metrics.vertAdvance &amp;&amp; glyph-&gt;linearVertAdvance )
2795             glyph-&gt;metrics.vertAdvance = FT_MulFix( glyph-&gt;linearVertAdvance,
2796                                                     y_scale );
2797         }
2798 
2799         return FT_Err_Ok;
2800       }
2801     }
2802 
2803 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
2804 
2805     /* if FT_LOAD_NO_SCALE is not set, `ttmetrics&#39; must be valid */
2806     if ( !( load_flags &amp; FT_LOAD_NO_SCALE ) &amp;&amp; !size-&gt;ttmetrics.valid )
2807     {
2808       error = FT_THROW( Invalid_Size_Handle );
2809       goto Exit;
2810     }
2811 
2812     if ( load_flags &amp; FT_LOAD_SBITS_ONLY )
2813     {
2814       error = FT_THROW( Invalid_Argument );
2815       goto Exit;
2816     }
2817 
2818     error = tt_loader_init( &amp;loader, size, glyph, load_flags, FALSE );
2819     if ( error )
2820       goto Exit;
2821 
2822     glyph-&gt;format        = FT_GLYPH_FORMAT_OUTLINE;
2823     glyph-&gt;num_subglyphs = 0;
2824     glyph-&gt;outline.flags = 0;
2825 
2826     /* main loading loop */
2827     error = load_truetype_glyph( &amp;loader, glyph_index, 0, FALSE );
2828     if ( !error )
2829     {
2830       if ( glyph-&gt;format == FT_GLYPH_FORMAT_COMPOSITE )
2831       {
2832         glyph-&gt;num_subglyphs = loader.gloader-&gt;base.num_subglyphs;
2833         glyph-&gt;subglyphs     = loader.gloader-&gt;base.subglyphs;
2834       }
2835       else
2836       {
2837         glyph-&gt;outline        = loader.gloader-&gt;base.outline;
2838         glyph-&gt;outline.flags &amp;= ~FT_OUTLINE_SINGLE_PASS;
2839 
2840         /* Translate array so that (0,0) is the glyph&#39;s origin.  Note  */
2841         /* that this behaviour is independent on the value of bit 1 of */
2842         /* the `flags&#39; field in the `head&#39; table -- at least major     */
2843         /* applications like Acroread indicate that.                   */
2844         if ( loader.pp1.x )
2845           FT_Outline_Translate( &amp;glyph-&gt;outline, -loader.pp1.x, 0 );
2846       }
2847 
2848 #ifdef TT_USE_BYTECODE_INTERPRETER
2849 
2850       if ( IS_HINTED( load_flags ) )
2851       {
2852         if ( loader.exec-&gt;GS.scan_control )
2853         {
2854           /* convert scan conversion mode to FT_OUTLINE_XXX flags */
2855           switch ( loader.exec-&gt;GS.scan_type )
2856           {
2857           case 0: /* simple drop-outs including stubs */
2858             glyph-&gt;outline.flags |= FT_OUTLINE_INCLUDE_STUBS;
2859             break;
2860           case 1: /* simple drop-outs excluding stubs */
2861             /* nothing; it&#39;s the default rendering mode */
2862             break;
2863           case 4: /* smart drop-outs including stubs */
2864             glyph-&gt;outline.flags |= FT_OUTLINE_SMART_DROPOUTS |
2865                                     FT_OUTLINE_INCLUDE_STUBS;
2866             break;
2867           case 5: /* smart drop-outs excluding stubs  */
2868             glyph-&gt;outline.flags |= FT_OUTLINE_SMART_DROPOUTS;
2869             break;
2870 
2871           default: /* no drop-out control */
2872             glyph-&gt;outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
2873             break;
2874           }
2875         }
2876         else
2877           glyph-&gt;outline.flags |= FT_OUTLINE_IGNORE_DROPOUTS;
2878       }
2879 
2880 #endif /* TT_USE_BYTECODE_INTERPRETER */
2881 
2882       error = compute_glyph_metrics( &amp;loader, glyph_index );
2883     }
2884 
2885     tt_loader_done( &amp;loader );
2886 
2887     /* Set the `high precision&#39; bit flag.                           */
2888     /* This is _critical_ to get correct output for monochrome      */
2889     /* TrueType glyphs at all sizes using the bytecode interpreter. */
2890     /*                                                              */
2891     if ( !( load_flags &amp; FT_LOAD_NO_SCALE ) &amp;&amp;
2892          size-&gt;metrics-&gt;y_ppem &lt; 24         )
2893       glyph-&gt;outline.flags |= FT_OUTLINE_HIGH_PRECISION;
2894 
2895   Exit:
2896 #ifdef FT_DEBUG_LEVEL_TRACE
2897     if ( error )
2898       FT_TRACE1(( &quot;  failed (error code 0x%x)\n&quot;,
2899                   error ));
2900 #endif
2901 
2902     return error;
2903   }
2904 
2905 
2906 /* END */
<a name="91" id="anc91"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="91" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="pshints.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="psintrp.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/psaux/psintrp.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  psintrp.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Adobe&#39;s CFF Interpreter (body).                                      */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2007-2014 Adobe Systems Incorporated.                        */</span>
<span class="line-modified">   8 /*                                                                         */</span>
<span class="line-modified">   9 /*  This software, and all works of authorship, whether in source or       */</span>
<span class="line-modified">  10 /*  object code form as indicated by the copyright notice(s) included      */</span>
<span class="line-modified">  11 /*  herein (collectively, the &quot;Work&quot;) is made available, and may only be   */</span>
<span class="line-modified">  12 /*  used, modified, and distributed under the FreeType Project License,    */</span>
<span class="line-modified">  13 /*  LICENSE.TXT.  Additionally, subject to the terms and conditions of the */</span>
<span class="line-modified">  14 /*  FreeType Project License, each contributor to the Work hereby grants   */</span>
<span class="line-modified">  15 /*  to any individual or legal entity exercising permissions granted by    */</span>
<span class="line-modified">  16 /*  the FreeType Project License and this section (hereafter, &quot;You&quot; or     */</span>
<span class="line-modified">  17 /*  &quot;Your&quot;) a perpetual, worldwide, non-exclusive, no-charge,              */</span>
<span class="line-modified">  18 /*  royalty-free, irrevocable (except as stated in this section) patent    */</span>
<span class="line-modified">  19 /*  license to make, have made, use, offer to sell, sell, import, and      */</span>
<span class="line-modified">  20 /*  otherwise transfer the Work, where such license applies only to those  */</span>
<span class="line-modified">  21 /*  patent claims licensable by such contributor that are necessarily      */</span>
<span class="line-modified">  22 /*  infringed by their contribution(s) alone or by combination of their    */</span>
<span class="line-modified">  23 /*  contribution(s) with the Work to which such contribution(s) was        */</span>
<span class="line-modified">  24 /*  submitted.  If You institute patent litigation against any entity      */</span>
<span class="line-modified">  25 /*  (including a cross-claim or counterclaim in a lawsuit) alleging that   */</span>
<span class="line-modified">  26 /*  the Work or a contribution incorporated within the Work constitutes    */</span>
<span class="line-modified">  27 /*  direct or contributory patent infringement, then any patent licenses   */</span>
<span class="line-modified">  28 /*  granted to You under this License for that Work shall terminate as of  */</span>
<span class="line-modified">  29 /*  the date such litigation is filed.                                     */</span>
<span class="line-modified">  30 /*                                                                         */</span>
<span class="line-modified">  31 /*  By using, modifying, or distributing the Work you indicate that you    */</span>
<span class="line-modified">  32 /*  have read and understood the terms and conditions of the               */</span>
<span class="line-modified">  33 /*  FreeType Project License as well as those provided in this section,    */</span>
<span class="line-modified">  34 /*  and you accept them fully.                                             */</span>
<span class="line-modified">  35 /*                                                                         */</span>
<span class="line-modified">  36 /***************************************************************************/</span>
  37 
  38 
  39 #include &quot;psft.h&quot;
  40 #include FT_INTERNAL_DEBUG_H
  41 #include FT_SERVICE_CFF_TABLE_LOAD_H
  42 
  43 #include &quot;psglue.h&quot;
  44 #include &quot;psfont.h&quot;
  45 #include &quot;psstack.h&quot;
  46 #include &quot;pshints.h&quot;
  47 #include &quot;psintrp.h&quot;
  48 
  49 #include &quot;pserror.h&quot;
  50 
  51 #include &quot;psobjs.h&quot;   /* for cff_random */
  52 #include &quot;t1decode.h&quot; /* for t1 seac    */
  53 
  54 
<span class="line-modified">  55   /*************************************************************************/</span>
<span class="line-modified">  56   /*                                                                       */</span>
<span class="line-modified">  57   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  58   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  59   /* messages during execution.                                            */</span>
<span class="line-modified">  60   /*                                                                       */</span>
  61 #undef  FT_COMPONENT
<span class="line-modified">  62 #define FT_COMPONENT  trace_cf2interp</span>
  63 
  64 
  65   FT_LOCAL_DEF( void )
  66   cf2_hintmask_init( CF2_HintMask  hintmask,
  67                      FT_Error*     error )
  68   {
  69     FT_ZERO( hintmask );
  70 
  71     hintmask-&gt;error = error;
  72   }
  73 
  74 
  75   FT_LOCAL_DEF( FT_Bool )
  76   cf2_hintmask_isValid( const CF2_HintMask  hintmask )
  77   {
  78     return hintmask-&gt;isValid;
  79   }
  80 
  81 
  82   FT_LOCAL_DEF( FT_Bool )
</pre>
<hr />
<pre>
 270     cf2_escSETCURRENTPT, /* 33     T1 only */
 271     cf2_escHFLEX,        /* 34 */
 272     cf2_escFLEX,         /* 35 */
 273     cf2_escHFLEX1,       /* 36 */
 274     cf2_escFLEX1,        /* 37 */
 275     cf2_escRESERVED_38   /* 38     &amp; all higher     */
 276   };
 277 
 278 
 279   /* `stemHintArray&#39; does not change once we start drawing the outline. */
 280   static void
 281   cf2_doStems( const CF2_Font  font,
 282                CF2_Stack       opStack,
 283                CF2_ArrStack    stemHintArray,
 284                CF2_Fixed*      width,
 285                FT_Bool*        haveWidth,
 286                CF2_Fixed       hintOffset )
 287   {
 288     CF2_UInt  i;
 289     CF2_UInt  count       = cf2_stack_count( opStack );
<span class="line-modified"> 290     FT_Bool   hasWidthArg = (FT_Bool)( count &amp; 1 );</span>
 291 
 292     /* variable accumulates delta values from operand stack */
 293     CF2_Fixed  position = hintOffset;
 294 
 295     if ( font-&gt;isT1 &amp;&amp; !font-&gt;decoder-&gt;flex_state &amp;&amp; !*haveWidth )
 296       FT_ERROR(( &quot;cf2_doStems (Type 1 mode):&quot;
 297                  &quot; No width. Use hsbw/sbw as first op\n&quot; ));
 298 
 299     if ( !font-&gt;isT1 &amp;&amp; hasWidthArg &amp;&amp; !*haveWidth )
 300       *width = ADD_INT32( cf2_stack_getReal( opStack, 0 ),
 301                           cf2_getNominalWidthX( font-&gt;decoder ) );
 302 
 303     if ( font-&gt;decoder-&gt;width_only )
 304       goto exit;
 305 
 306     for ( i = hasWidthArg ? 1 : 0; i &lt; count; i += 2 )
 307     {
 308       /* construct a CF2_StemHint and push it onto the list */
 309       CF2_StemHintRec  stemhint;
 310 
</pre>
<hr />
<pre>
 347 
 348     vals[0] = *curX;
 349     vals[1] = *curY;
 350     idx     = 0;
 351     isHFlex = FT_BOOL( readFromStack[9] == FALSE );
 352     top     = isHFlex ? 9 : 10;
 353 
 354     for ( i = 0; i &lt; top; i++ )
 355     {
 356       vals[i + 2] = vals[i];
 357       if ( readFromStack[i] )
 358         vals[i + 2] = ADD_INT32( vals[i + 2], cf2_stack_getReal( opStack,
 359                                                                  idx++ ) );
 360     }
 361 
 362     if ( isHFlex )
 363       vals[9 + 2] = *curY;
 364 
 365     if ( doConditionalLastRead )
 366     {
<span class="line-modified"> 367       FT_Bool    lastIsX = (FT_Bool)(</span>
 368                              cf2_fixedAbs( SUB_INT32( vals[10], *curX ) ) &gt;
 369                              cf2_fixedAbs( SUB_INT32( vals[11], *curY ) ) );
 370       CF2_Fixed  lastVal = cf2_stack_getReal( opStack, idx );
 371 
 372 
 373       if ( lastIsX )
 374       {
 375         vals[12] = ADD_INT32( vals[10], lastVal );
 376         vals[13] = *curY;
 377       }
 378       else
 379       {
 380         vals[12] = *curX;
 381         vals[13] = ADD_INT32( vals[11], lastVal );
 382       }
 383     }
 384     else
 385     {
 386       if ( readFromStack[10] )
 387         vals[12] = ADD_INT32( vals[10],
</pre>
<hr />
<pre>
 595      */
 596 
 597     /* allocate an operand stack */
 598     stackSize = font-&gt;isCFF2 ? cf2_getMaxstack( decoder )
 599                              : CF2_OPERAND_STACK_SIZE;
 600     opStack   = cf2_stack_init( memory, error, stackSize );
 601 
 602     if ( !opStack )
 603     {
 604       lastError = FT_THROW( Out_Of_Memory );
 605       goto exit;
 606     }
 607 
 608     /* initialize subroutine stack by placing top level charstring as */
 609     /* first element (max depth plus one for the charstring)          */
 610     /* Note: Caller owns and must finalize the first charstring.      */
 611     /*       Our copy of it does not change that requirement.         */
 612     cf2_arrstack_setCount( &amp;subrStack, CF2_MAX_SUBR + 1 );
 613 
 614     charstring  = (CF2_Buffer)cf2_arrstack_getBuffer( &amp;subrStack );
<span class="line-removed"> 615     *charstring = *buf;    /* structure copy */</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617     charstringIndex = 0;       /* entry is valid now */</span>
 618 
 619     /* catch errors so far */
 620     if ( *error )
 621       goto exit;
 622 



 623     /* main interpreter loop */
 624     while ( 1 )
 625     {
 626       if ( font-&gt;isT1 )
 627         FT_ASSERT( known_othersubr_result_cnt == 0 ||
 628                    result_cnt == 0                 );
 629 
 630       if ( cf2_buf_isEnd( charstring ) )
 631       {
 632         /* If we&#39;ve reached the end of the charstring, simulate a */
 633         /* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
 634         /* We do this for both CFF and CFF2.                      */
 635         if ( charstringIndex )
 636           op1 = cf2_cmdRETURN;  /* end of buffer for subroutine */
 637         else
 638           op1 = cf2_cmdENDCHAR; /* end of buffer for top level charstring */
 639       }
 640       else
 641       {
 642         op1 = (FT_Byte)cf2_buf_readByte( charstring );
</pre>
<hr />
<pre>
 646         if ( ( op1 == cf2_cmdRETURN || op1 == cf2_cmdENDCHAR ) &amp;&amp;
 647              font-&gt;isCFF2                                      )
 648           op1 = cf2_cmdRESERVED_0;
 649       }
 650 
 651       if ( font-&gt;isT1 )
 652       {
 653         if ( !initial_map_ready           &amp;&amp;
 654              !( op1 == cf2_cmdHSTEM     ||
 655                 op1 == cf2_cmdVSTEM     ||
 656                 op1 == cf2_cmdHSBW      ||
 657                 op1 == cf2_cmdCALLSUBR  ||
 658                 op1 == cf2_cmdRETURN    ||
 659                 op1 == cf2_cmdESC       ||
 660                 op1 == cf2_cmdENDCHAR   ||
 661                 op1 &gt;= 32 /* Numbers */ ) )
 662         {
 663           /* Skip outline commands first time round.       */
 664           /* `endchar&#39; will trigger initial hintmap build  */
 665           /* and rewind the charstring.                    */

 666           cf2_stack_clear( opStack );
 667           continue;
 668         }
 669 
 670         if ( result_cnt &gt; 0               &amp;&amp;
 671              !( op1 == cf2_cmdCALLSUBR  ||
 672                 op1 == cf2_cmdRETURN    ||
 673                 op1 == cf2_cmdESC       ||
 674                 op1 &gt;= 32 /* Numbers */ ) )
 675         {
 676           /* all operands have been transferred by previous pops */
 677           result_cnt = 0;
 678         }
 679 
 680         if ( large_int &amp;&amp; !( op1 &gt;= 32 || op1 == cf2_escDIV ) )
 681         {
 682           FT_ERROR(( &quot;cf2_interpT2CharString (Type 1 mode):&quot;
 683                      &quot; no `div&#39; after large integer\n&quot; ));
 684 
 685           large_int = FALSE;
</pre>
<hr />
<pre>
 758             if ( lastError )
 759               goto exit;
 760           }
 761 
 762           /* do the blend */
 763           numBlends = (FT_UInt)cf2_stack_popInt( opStack );
 764           if ( numBlends &gt; stackSize )
 765           {
 766             lastError = FT_THROW( Invalid_Glyph_Format );
 767             goto exit;
 768           }
 769 
 770           cf2_doBlend( &amp;font-&gt;blend, opStack, numBlends );
 771 
 772           font-&gt;blend.usedBV = TRUE;
 773         }
 774         continue;     /* do not clear the stack */
 775 
 776       case cf2_cmdHSTEMHM:
 777       case cf2_cmdHSTEM:
<span class="line-modified"> 778         FT_TRACE4(( op1 == cf2_cmdHSTEMHM ? &quot; hstemhm\n&quot; : &quot; hstem\n&quot; ));</span>

 779 
 780         if ( !font-&gt;isT1 )
 781         {
 782           /* never add hints after the mask is computed */
 783           /* except if in Type 1 mode (no hintmask op)  */
 784           if ( cf2_hintmask_isValid( &amp;hintMask ) )
 785           {
 786             FT_TRACE4(( &quot;cf2_interpT2CharString:&quot;
 787                         &quot; invalid horizontal hint mask\n&quot; ));
 788             break;
 789           }
 790         }
 791 
 792         /* add left-sidebearing correction in Type 1 mode */
 793         cf2_doStems( font,
 794                      opStack,
 795                      &amp;hStemHintArray,
 796                      width,
 797                      &amp;haveWidth,
 798                      font-&gt;isT1 ? decoder-&gt;builder.left_bearing-&gt;y
 799                                 : 0 );
 800 
 801         if ( decoder-&gt;width_only )
 802           goto exit;
 803 
 804         break;
 805 
 806       case cf2_cmdVSTEMHM:
 807       case cf2_cmdVSTEM:
<span class="line-modified"> 808         FT_TRACE4(( op1 == cf2_cmdVSTEMHM ? &quot; vstemhm\n&quot; : &quot; vstem\n&quot; ));</span>

 809 
 810         if ( !font-&gt;isT1 )
 811         {
 812           /* never add hints after the mask is computed */
 813           /* except if in Type 1 mode (no hintmask op)  */
 814           if ( cf2_hintmask_isValid( &amp;hintMask ) )
 815           {
 816             FT_TRACE4(( &quot;cf2_interpT2CharString:&quot;
 817                         &quot; invalid vertical hint mask\n&quot; ));
 818             break;
 819           }
 820         }
 821 
 822         /* add left-sidebearing correction in Type 1 mode */
 823         cf2_doStems( font,
 824                      opStack,
 825                      &amp;vStemHintArray,
 826                      width,
 827                      &amp;haveWidth,
 828                      font-&gt;isT1 ? decoder-&gt;builder.left_bearing-&gt;x
</pre>
<hr />
<pre>
 871                                                        idx + 0 ) );
 872             curY = ADD_INT32( curY, cf2_stack_getReal( opStack,
 873                                                        idx + 1 ) );
 874 
 875             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 876           }
 877 
 878           cf2_stack_clear( opStack );
 879         }
 880         continue; /* no need to clear stack again */
 881 
 882       case cf2_cmdHLINETO:
 883       case cf2_cmdVLINETO:
 884         {
 885           CF2_UInt  idx;
 886           CF2_UInt  count = cf2_stack_count( opStack );
 887 
 888           FT_Bool  isX = FT_BOOL( op1 == cf2_cmdHLINETO );
 889 
 890 
<span class="line-modified"> 891           FT_TRACE4(( isX ? &quot; hlineto\n&quot; : &quot; vlineto\n&quot; ));</span>
 892 
 893           for ( idx = 0; idx &lt; count; idx++ )
 894           {
 895             CF2_Fixed  v = cf2_stack_getReal( opStack, idx );
 896 
 897 
 898             if ( isX )
 899               curX = ADD_INT32( curX, v );
 900             else
 901               curY = ADD_INT32( curY, v );
 902 
 903             isX = !isX;
 904 
 905             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 906           }
 907 
 908           cf2_stack_clear( opStack );
 909         }
 910         continue;
 911 
 912       case cf2_cmdRCURVELINE:
 913       case cf2_cmdRRCURVETO:
 914         {
 915           CF2_UInt  count = cf2_stack_count( opStack );
 916           CF2_UInt  idx   = 0;
 917 
 918 
<span class="line-modified"> 919           FT_TRACE4(( op1 == cf2_cmdRCURVELINE ? &quot; rcurveline\n&quot;</span>
<span class="line-modified"> 920                                                : &quot; rrcurveto\n&quot; ));</span>
 921 
 922           while ( idx + 6 &lt;= count )
 923           {
 924             CF2_Fixed  x1, y1, x2, y2, x3, y3;
 925 
 926 
 927             x1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 0 ), curX );
 928             y1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 1 ), curY );
 929             x2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 2 ), x1 );
 930             y2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 3 ), y1 );
 931             x3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 4 ), x2 );
 932             y3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 5 ), y2 );
 933 
 934             cf2_glyphpath_curveTo( &amp;glyphPath, x1, y1, x2, y2, x3, y3 );
 935 
 936             curX  = x3;
 937             curY  = y3;
 938             idx  += 6;
 939           }
 940 
 941           if ( op1 == cf2_cmdRCURVELINE )
 942           {
 943             curX = ADD_INT32( curX, cf2_stack_getReal( opStack,
 944                                                        idx + 0 ) );
 945             curY = ADD_INT32( curY, cf2_stack_getReal( opStack,
 946                                                        idx + 1 ) );
 947 
 948             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 949           }
 950 
 951           cf2_stack_clear( opStack );
 952         }
 953         continue; /* no need to clear stack again */
 954 
 955       case cf2_cmdCLOSEPATH:
 956         if ( !font-&gt;isT1 )
 957           FT_TRACE4(( &quot; unknown op (%d)\n&quot;, op1 ));
 958         else
 959         {
<span class="line-modified"> 960           FT_TRACE4(( &quot; closepath&quot; ));</span>
 961 
 962           /* if there is no path, `closepath&#39; is a no-op */
<span class="line-modified"> 963           ps_builder_close_contour( &amp;decoder-&gt;builder );</span>
 964 
 965           haveWidth = TRUE;
 966         }
 967         break;
 968 
 969       case cf2_cmdCALLGSUBR:
 970       case cf2_cmdCALLSUBR:
 971         {
 972           CF2_Int  subrNum;
 973 
 974 
<span class="line-modified"> 975           FT_TRACE4(( op1 == cf2_cmdCALLGSUBR ? &quot; callgsubr&quot;</span>
<span class="line-modified"> 976                                               : &quot; callsubr&quot; ));</span>
 977 
 978           if ( ( !font-&gt;isT1 &amp;&amp; charstringIndex &gt; CF2_MAX_SUBR )       ||
 979                (  font-&gt;isT1 &amp;&amp; charstringIndex &gt; T1_MAX_SUBRS_CALLS ) )
 980           {
 981             /* max subr plus one for charstring */
 982             lastError = FT_THROW( Invalid_Glyph_Format );
 983             goto exit;                      /* overflow of stack */
 984           }
 985 
 986           /* push our current CFF charstring region on subrStack */
 987           charstring = (CF2_Buffer)
 988                          cf2_arrstack_getPointer(
 989                            &amp;subrStack,
 990                            (size_t)charstringIndex + 1 );
 991 
 992           /* set up the new CFF region and pointer */
 993           subrNum = cf2_stack_popInt( opStack );
 994 
 995           if ( font-&gt;isT1 &amp;&amp; decoder-&gt;locals_hash )
 996           {
</pre>
<hr />
<pre>
1195 
1196                 case cf2_escVSTEM3:
1197                 case cf2_escHSTEM3:
1198                   /*
1199                    * Type 1:                          Type 2:
1200                    *   x0 dx0 x1 dx1 x2 dx2 vstem3      x dx {dxa dxb}* vstem
1201                    *   y0 dy0 y1 dy1 y2 dy2 hstem3      y dy {dya dyb}* hstem
1202                    *   relative to lsb point            relative to zero
1203                    *
1204                    */
1205                   {
1206                     if ( !font-&gt;isT1 )
1207                       FT_TRACE4(( &quot; unknown op (12, %d)\n&quot;, op2 ));
1208                     else
1209                     {
1210                       CF2_F16Dot16  v0, v1, v2;
1211 
1212                       FT_Bool  isV = FT_BOOL( op2 == cf2_escVSTEM3 );
1213 
1214 
<span class="line-modified">1215                       FT_TRACE4(( isV ? &quot; vstem3\n&quot;</span>
<span class="line-modified">1216                                       : &quot; hstem3\n&quot; ));</span>
1217 
1218                       FT_ASSERT( cf2_stack_count( opStack ) == 6 );
1219 
1220                       v0 = cf2_stack_getReal( opStack, 0 );
1221                       v1 = cf2_stack_getReal( opStack, 2 );
1222                       v2 = cf2_stack_getReal( opStack, 4 );
1223 
1224                       cf2_stack_setReal(
1225                         opStack, 2,
1226                         SUB_INT32( SUB_INT32( v1, v0 ),
1227                                    cf2_stack_getReal( opStack, 1 ) ) );
1228                       cf2_stack_setReal(
1229                         opStack, 4,
1230                         SUB_INT32( SUB_INT32( v2, v1 ),
1231                                    cf2_stack_getReal( opStack, 3 ) ) );
1232 
1233                       /* add left-sidebearing correction */
1234                       cf2_doStems( font,
1235                                    opStack,
1236                                    isV ? &amp;vStemHintArray : &amp;hStemHintArray,
</pre>
<hr />
<pre>
1627                     cf2_stack_pushInt( opStack, arg1 == arg2 );
1628                   }
1629                   continue; /* do not clear the stack */
1630 
1631                 case cf2_escCALLOTHERSUBR:
1632                   if ( !font-&gt;isT1 )
1633                     FT_TRACE4(( &quot; unknown op (12, %d)\n&quot;, op2 ));
1634                   else
1635                   {
1636                     CF2_Int   subr_no;
1637                     CF2_Int   arg_cnt;
1638                     CF2_UInt  count;
1639                     CF2_UInt  opIdx = 0;
1640 
1641 
1642                     FT_TRACE4(( &quot; callothersubr\n&quot; ));
1643 
1644                     subr_no = cf2_stack_popInt( opStack );
1645                     arg_cnt = cf2_stack_popInt( opStack );
1646 
<span class="line-modified">1647                     /*******************************************************/</span>
<span class="line-modified">1648                     /*                                                     */</span>
<span class="line-modified">1649                     /* remove all operands to callothersubr from the stack */</span>
<span class="line-modified">1650                     /*                                                     */</span>
<span class="line-modified">1651                     /* for handled othersubrs, where we know the number of */</span>
<span class="line-modified">1652                     /* arguments, we increase the stack by the value of    */</span>
<span class="line-modified">1653                     /* known_othersubr_result_cnt                          */</span>
<span class="line-modified">1654                     /*                                                     */</span>
<span class="line-modified">1655                     /* for unhandled othersubrs the following pops adjust  */</span>
<span class="line-modified">1656                     /* the stack pointer as necessary                      */</span>

1657 
1658                     count = cf2_stack_count( opStack );
1659                     FT_ASSERT( (CF2_UInt)arg_cnt &lt;= count );
1660 
1661                     opIdx += count - (CF2_UInt)arg_cnt;
1662 
1663                     known_othersubr_result_cnt = 0;
1664                     result_cnt                 = 0;
1665 
1666                     /* XXX TODO: The checks to `arg_count == &lt;whatever&gt;&#39;   */
1667                     /* might not be correct; an othersubr expects a        */
1668                     /* certain number of operands on the PostScript stack  */
1669                     /* (as opposed to the T1 stack) but it doesn&#39;t have to */
1670                     /* put them there by itself; previous othersubrs might */
1671                     /* have left the operands there if they were not       */
1672                     /* followed by an appropriate number of pops           */
1673                     /*                                                     */
1674                     /* On the other hand, Adobe Reader 7.0.8 for Linux     */
1675                     /* doesn&#39;t accept a font that contains charstrings     */
1676                     /* like                                                */
</pre>
<hr />
<pre>
2399                   }
2400                   break;
2401 
2402                 } /* end of 2nd switch checking op2 */
2403               }
2404             }
2405           } /* end of 1st switch checking op2 */
2406         } /* case cf2_cmdESC */
2407 
2408         break;
2409 
2410       case cf2_cmdHSBW:
2411         if ( !font-&gt;isT1 )
2412           FT_TRACE4(( &quot; unknown op (%d)\n&quot;, op1 ));
2413         else
2414         {
2415           CF2_Fixed    lsb_x;
2416           PS_Builder*  builder;
2417 
2418 
<span class="line-modified">2419           FT_TRACE4(( &quot; hsbw&quot; ));</span>
2420 
2421           builder = &amp;decoder-&gt;builder;
2422 
2423           builder-&gt;advance-&gt;x = cf2_stack_popFixed( opStack );
2424           builder-&gt;advance-&gt;y = 0;
2425 
2426           lsb_x = cf2_stack_popFixed( opStack );
2427 
2428           builder-&gt;left_bearing-&gt;x = ADD_INT32( builder-&gt;left_bearing-&gt;x,
2429                                                 lsb_x );
2430 
2431           haveWidth = TRUE;
2432 
2433           /* the `metrics_only&#39; indicates that we only want to compute */
2434           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
2435           /* rest of it; so exit immediately                           */
2436           if ( builder-&gt;metrics_only )
2437             goto exit;
2438 
2439           if ( initial_map_ready )
</pre>
<hr />
<pre>
2545           {
2546             lastError = error2;      /* pass FreeType error through */
2547             goto exit;
2548           }
2549           cf2_interpT2CharString( font,
2550                                   &amp;component,
2551                                   callbacks,
2552                                   translation,
2553                                   TRUE,
2554                                   0,
2555                                   0,
2556                                   &amp;dummyWidth );
2557           cf2_freeSeacComponent( decoder, &amp;component );
2558         }
2559         goto exit;
2560 
2561       case cf2_cmdCNTRMASK:
2562       case cf2_cmdHINTMASK:
2563         /* the final \n in the tracing message gets added in      */
2564         /* `cf2_hintmask_read&#39; (which also traces the mask bytes) */
<span class="line-modified">2565         FT_TRACE4(( op1 == cf2_cmdCNTRMASK ? &quot; cntrmask&quot; : &quot; hintmask&quot; ));</span>
2566 
2567         /* never add hints after the mask is computed */
2568         if ( cf2_stack_count( opStack ) &gt; 1    &amp;&amp;
2569              cf2_hintmask_isValid( &amp;hintMask ) )
2570         {
2571           FT_TRACE4(( &quot;cf2_interpT2CharString: invalid hint mask\n&quot; ));
2572           break;
2573         }
2574 
2575         /* if there are arguments on the stack, there this is an */
2576         /* implied cf2_cmdVSTEMHM                                */
2577         cf2_doStems( font,
2578                      opStack,
2579                      &amp;vStemHintArray,
2580                      width,
2581                      &amp;haveWidth,
2582                      0 );
2583 
2584         if ( decoder-&gt;width_only )
2585           goto exit;
</pre>
<hr />
<pre>
2811           cf2_stack_clear( opStack );
2812         }
2813         continue; /* no need to clear stack again */
2814 
2815       case cf2_cmdVHCURVETO:
2816       case cf2_cmdHVCURVETO:
2817         {
2818           CF2_UInt  count, count1 = cf2_stack_count( opStack );
2819           CF2_UInt  idx = 0;
2820 
2821           FT_Bool  alternate = FT_BOOL( op1 == cf2_cmdHVCURVETO );
2822 
2823 
2824           /* if `cf2_stack_count&#39; isn&#39;t of the form 8n, 8n+1, */
2825           /* 8n+4, or 8n+5, we enforce it by clearing the     */
2826           /* second bit                                       */
2827           /* (and sorting the stack indexing to suit)         */
2828           count = count1 &amp; ~2U;
2829           idx  += count1 - count;
2830 
<span class="line-modified">2831           FT_TRACE4(( alternate ? &quot; hvcurveto\n&quot; : &quot; vhcurveto\n&quot; ));</span>
2832 
2833           while ( idx &lt; count )
2834           {
2835             CF2_Fixed x1, x2, x3, y1, y2, y3;
2836 
2837 
2838             if ( alternate )
2839             {
2840               x1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 0 ), curX );
2841               y1 = curY;
2842               x2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 1 ), x1 );
2843               y2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 2 ), y1 );
2844               y3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 3 ), y2 );
2845 
2846               if ( count - idx == 5 )
2847               {
2848                 x3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 4 ), x2 );
2849 
2850                 idx++;
2851               }
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * psintrp.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Adobe&#39;s CFF Interpreter (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright 2007-2014 Adobe Systems Incorporated.</span>
<span class="line-modified">   8  *</span>
<span class="line-modified">   9  * This software, and all works of authorship, whether in source or</span>
<span class="line-modified">  10  * object code form as indicated by the copyright notice(s) included</span>
<span class="line-modified">  11  * herein (collectively, the &quot;Work&quot;) is made available, and may only be</span>
<span class="line-modified">  12  * used, modified, and distributed under the FreeType Project License,</span>
<span class="line-modified">  13  * LICENSE.TXT.  Additionally, subject to the terms and conditions of the</span>
<span class="line-modified">  14  * FreeType Project License, each contributor to the Work hereby grants</span>
<span class="line-modified">  15  * to any individual or legal entity exercising permissions granted by</span>
<span class="line-modified">  16  * the FreeType Project License and this section (hereafter, &quot;You&quot; or</span>
<span class="line-modified">  17  * &quot;Your&quot;) a perpetual, worldwide, non-exclusive, no-charge,</span>
<span class="line-modified">  18  * royalty-free, irrevocable (except as stated in this section) patent</span>
<span class="line-modified">  19  * license to make, have made, use, offer to sell, sell, import, and</span>
<span class="line-modified">  20  * otherwise transfer the Work, where such license applies only to those</span>
<span class="line-modified">  21  * patent claims licensable by such contributor that are necessarily</span>
<span class="line-modified">  22  * infringed by their contribution(s) alone or by combination of their</span>
<span class="line-modified">  23  * contribution(s) with the Work to which such contribution(s) was</span>
<span class="line-modified">  24  * submitted.  If You institute patent litigation against any entity</span>
<span class="line-modified">  25  * (including a cross-claim or counterclaim in a lawsuit) alleging that</span>
<span class="line-modified">  26  * the Work or a contribution incorporated within the Work constitutes</span>
<span class="line-modified">  27  * direct or contributory patent infringement, then any patent licenses</span>
<span class="line-modified">  28  * granted to You under this License for that Work shall terminate as of</span>
<span class="line-modified">  29  * the date such litigation is filed.</span>
<span class="line-modified">  30  *</span>
<span class="line-modified">  31  * By using, modifying, or distributing the Work you indicate that you</span>
<span class="line-modified">  32  * have read and understood the terms and conditions of the</span>
<span class="line-modified">  33  * FreeType Project License as well as those provided in this section,</span>
<span class="line-modified">  34  * and you accept them fully.</span>
<span class="line-modified">  35  *</span>
<span class="line-modified">  36  */</span>
  37 
  38 
  39 #include &quot;psft.h&quot;
  40 #include FT_INTERNAL_DEBUG_H
  41 #include FT_SERVICE_CFF_TABLE_LOAD_H
  42 
  43 #include &quot;psglue.h&quot;
  44 #include &quot;psfont.h&quot;
  45 #include &quot;psstack.h&quot;
  46 #include &quot;pshints.h&quot;
  47 #include &quot;psintrp.h&quot;
  48 
  49 #include &quot;pserror.h&quot;
  50 
  51 #include &quot;psobjs.h&quot;   /* for cff_random */
  52 #include &quot;t1decode.h&quot; /* for t1 seac    */
  53 
  54 
<span class="line-modified">  55   /**************************************************************************</span>
<span class="line-modified">  56    *</span>
<span class="line-modified">  57    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  58    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  59    * messages during execution.</span>
<span class="line-modified">  60    */</span>
  61 #undef  FT_COMPONENT
<span class="line-modified">  62 #define FT_COMPONENT  cf2interp</span>
  63 
  64 
  65   FT_LOCAL_DEF( void )
  66   cf2_hintmask_init( CF2_HintMask  hintmask,
  67                      FT_Error*     error )
  68   {
  69     FT_ZERO( hintmask );
  70 
  71     hintmask-&gt;error = error;
  72   }
  73 
  74 
  75   FT_LOCAL_DEF( FT_Bool )
  76   cf2_hintmask_isValid( const CF2_HintMask  hintmask )
  77   {
  78     return hintmask-&gt;isValid;
  79   }
  80 
  81 
  82   FT_LOCAL_DEF( FT_Bool )
</pre>
<hr />
<pre>
 270     cf2_escSETCURRENTPT, /* 33     T1 only */
 271     cf2_escHFLEX,        /* 34 */
 272     cf2_escFLEX,         /* 35 */
 273     cf2_escHFLEX1,       /* 36 */
 274     cf2_escFLEX1,        /* 37 */
 275     cf2_escRESERVED_38   /* 38     &amp; all higher     */
 276   };
 277 
 278 
 279   /* `stemHintArray&#39; does not change once we start drawing the outline. */
 280   static void
 281   cf2_doStems( const CF2_Font  font,
 282                CF2_Stack       opStack,
 283                CF2_ArrStack    stemHintArray,
 284                CF2_Fixed*      width,
 285                FT_Bool*        haveWidth,
 286                CF2_Fixed       hintOffset )
 287   {
 288     CF2_UInt  i;
 289     CF2_UInt  count       = cf2_stack_count( opStack );
<span class="line-modified"> 290     FT_Bool   hasWidthArg = FT_BOOL( count &amp; 1 );</span>
 291 
 292     /* variable accumulates delta values from operand stack */
 293     CF2_Fixed  position = hintOffset;
 294 
 295     if ( font-&gt;isT1 &amp;&amp; !font-&gt;decoder-&gt;flex_state &amp;&amp; !*haveWidth )
 296       FT_ERROR(( &quot;cf2_doStems (Type 1 mode):&quot;
 297                  &quot; No width. Use hsbw/sbw as first op\n&quot; ));
 298 
 299     if ( !font-&gt;isT1 &amp;&amp; hasWidthArg &amp;&amp; !*haveWidth )
 300       *width = ADD_INT32( cf2_stack_getReal( opStack, 0 ),
 301                           cf2_getNominalWidthX( font-&gt;decoder ) );
 302 
 303     if ( font-&gt;decoder-&gt;width_only )
 304       goto exit;
 305 
 306     for ( i = hasWidthArg ? 1 : 0; i &lt; count; i += 2 )
 307     {
 308       /* construct a CF2_StemHint and push it onto the list */
 309       CF2_StemHintRec  stemhint;
 310 
</pre>
<hr />
<pre>
 347 
 348     vals[0] = *curX;
 349     vals[1] = *curY;
 350     idx     = 0;
 351     isHFlex = FT_BOOL( readFromStack[9] == FALSE );
 352     top     = isHFlex ? 9 : 10;
 353 
 354     for ( i = 0; i &lt; top; i++ )
 355     {
 356       vals[i + 2] = vals[i];
 357       if ( readFromStack[i] )
 358         vals[i + 2] = ADD_INT32( vals[i + 2], cf2_stack_getReal( opStack,
 359                                                                  idx++ ) );
 360     }
 361 
 362     if ( isHFlex )
 363       vals[9 + 2] = *curY;
 364 
 365     if ( doConditionalLastRead )
 366     {
<span class="line-modified"> 367       FT_Bool    lastIsX = FT_BOOL(</span>
 368                              cf2_fixedAbs( SUB_INT32( vals[10], *curX ) ) &gt;
 369                              cf2_fixedAbs( SUB_INT32( vals[11], *curY ) ) );
 370       CF2_Fixed  lastVal = cf2_stack_getReal( opStack, idx );
 371 
 372 
 373       if ( lastIsX )
 374       {
 375         vals[12] = ADD_INT32( vals[10], lastVal );
 376         vals[13] = *curY;
 377       }
 378       else
 379       {
 380         vals[12] = *curX;
 381         vals[13] = ADD_INT32( vals[11], lastVal );
 382       }
 383     }
 384     else
 385     {
 386       if ( readFromStack[10] )
 387         vals[12] = ADD_INT32( vals[10],
</pre>
<hr />
<pre>
 595      */
 596 
 597     /* allocate an operand stack */
 598     stackSize = font-&gt;isCFF2 ? cf2_getMaxstack( decoder )
 599                              : CF2_OPERAND_STACK_SIZE;
 600     opStack   = cf2_stack_init( memory, error, stackSize );
 601 
 602     if ( !opStack )
 603     {
 604       lastError = FT_THROW( Out_Of_Memory );
 605       goto exit;
 606     }
 607 
 608     /* initialize subroutine stack by placing top level charstring as */
 609     /* first element (max depth plus one for the charstring)          */
 610     /* Note: Caller owns and must finalize the first charstring.      */
 611     /*       Our copy of it does not change that requirement.         */
 612     cf2_arrstack_setCount( &amp;subrStack, CF2_MAX_SUBR + 1 );
 613 
 614     charstring  = (CF2_Buffer)cf2_arrstack_getBuffer( &amp;subrStack );



 615 
 616     /* catch errors so far */
 617     if ( *error )
 618       goto exit;
 619 
<span class="line-added"> 620     *charstring     = *buf;    /* structure copy     */</span>
<span class="line-added"> 621     charstringIndex = 0;       /* entry is valid now */</span>
<span class="line-added"> 622 </span>
 623     /* main interpreter loop */
 624     while ( 1 )
 625     {
 626       if ( font-&gt;isT1 )
 627         FT_ASSERT( known_othersubr_result_cnt == 0 ||
 628                    result_cnt == 0                 );
 629 
 630       if ( cf2_buf_isEnd( charstring ) )
 631       {
 632         /* If we&#39;ve reached the end of the charstring, simulate a */
 633         /* cf2_cmdRETURN or cf2_cmdENDCHAR.                       */
 634         /* We do this for both CFF and CFF2.                      */
 635         if ( charstringIndex )
 636           op1 = cf2_cmdRETURN;  /* end of buffer for subroutine */
 637         else
 638           op1 = cf2_cmdENDCHAR; /* end of buffer for top level charstring */
 639       }
 640       else
 641       {
 642         op1 = (FT_Byte)cf2_buf_readByte( charstring );
</pre>
<hr />
<pre>
 646         if ( ( op1 == cf2_cmdRETURN || op1 == cf2_cmdENDCHAR ) &amp;&amp;
 647              font-&gt;isCFF2                                      )
 648           op1 = cf2_cmdRESERVED_0;
 649       }
 650 
 651       if ( font-&gt;isT1 )
 652       {
 653         if ( !initial_map_ready           &amp;&amp;
 654              !( op1 == cf2_cmdHSTEM     ||
 655                 op1 == cf2_cmdVSTEM     ||
 656                 op1 == cf2_cmdHSBW      ||
 657                 op1 == cf2_cmdCALLSUBR  ||
 658                 op1 == cf2_cmdRETURN    ||
 659                 op1 == cf2_cmdESC       ||
 660                 op1 == cf2_cmdENDCHAR   ||
 661                 op1 &gt;= 32 /* Numbers */ ) )
 662         {
 663           /* Skip outline commands first time round.       */
 664           /* `endchar&#39; will trigger initial hintmap build  */
 665           /* and rewind the charstring.                    */
<span class="line-added"> 666           FT_TRACE4(( &quot; &lt;outline command skipped&gt;\n&quot; ));</span>
 667           cf2_stack_clear( opStack );
 668           continue;
 669         }
 670 
 671         if ( result_cnt &gt; 0               &amp;&amp;
 672              !( op1 == cf2_cmdCALLSUBR  ||
 673                 op1 == cf2_cmdRETURN    ||
 674                 op1 == cf2_cmdESC       ||
 675                 op1 &gt;= 32 /* Numbers */ ) )
 676         {
 677           /* all operands have been transferred by previous pops */
 678           result_cnt = 0;
 679         }
 680 
 681         if ( large_int &amp;&amp; !( op1 &gt;= 32 || op1 == cf2_escDIV ) )
 682         {
 683           FT_ERROR(( &quot;cf2_interpT2CharString (Type 1 mode):&quot;
 684                      &quot; no `div&#39; after large integer\n&quot; ));
 685 
 686           large_int = FALSE;
</pre>
<hr />
<pre>
 759             if ( lastError )
 760               goto exit;
 761           }
 762 
 763           /* do the blend */
 764           numBlends = (FT_UInt)cf2_stack_popInt( opStack );
 765           if ( numBlends &gt; stackSize )
 766           {
 767             lastError = FT_THROW( Invalid_Glyph_Format );
 768             goto exit;
 769           }
 770 
 771           cf2_doBlend( &amp;font-&gt;blend, opStack, numBlends );
 772 
 773           font-&gt;blend.usedBV = TRUE;
 774         }
 775         continue;     /* do not clear the stack */
 776 
 777       case cf2_cmdHSTEMHM:
 778       case cf2_cmdHSTEM:
<span class="line-modified"> 779         FT_TRACE4(( &quot;%s\n&quot;, op1 == cf2_cmdHSTEMHM ? &quot; hstemhm&quot;</span>
<span class="line-added"> 780                                                   : &quot; hstem&quot; ));</span>
 781 
 782         if ( !font-&gt;isT1 )
 783         {
 784           /* never add hints after the mask is computed */
 785           /* except if in Type 1 mode (no hintmask op)  */
 786           if ( cf2_hintmask_isValid( &amp;hintMask ) )
 787           {
 788             FT_TRACE4(( &quot;cf2_interpT2CharString:&quot;
 789                         &quot; invalid horizontal hint mask\n&quot; ));
 790             break;
 791           }
 792         }
 793 
 794         /* add left-sidebearing correction in Type 1 mode */
 795         cf2_doStems( font,
 796                      opStack,
 797                      &amp;hStemHintArray,
 798                      width,
 799                      &amp;haveWidth,
 800                      font-&gt;isT1 ? decoder-&gt;builder.left_bearing-&gt;y
 801                                 : 0 );
 802 
 803         if ( decoder-&gt;width_only )
 804           goto exit;
 805 
 806         break;
 807 
 808       case cf2_cmdVSTEMHM:
 809       case cf2_cmdVSTEM:
<span class="line-modified"> 810         FT_TRACE4(( &quot;%s\n&quot;, op1 == cf2_cmdVSTEMHM ? &quot; vstemhm&quot;</span>
<span class="line-added"> 811                                                   : &quot; vstem&quot; ));</span>
 812 
 813         if ( !font-&gt;isT1 )
 814         {
 815           /* never add hints after the mask is computed */
 816           /* except if in Type 1 mode (no hintmask op)  */
 817           if ( cf2_hintmask_isValid( &amp;hintMask ) )
 818           {
 819             FT_TRACE4(( &quot;cf2_interpT2CharString:&quot;
 820                         &quot; invalid vertical hint mask\n&quot; ));
 821             break;
 822           }
 823         }
 824 
 825         /* add left-sidebearing correction in Type 1 mode */
 826         cf2_doStems( font,
 827                      opStack,
 828                      &amp;vStemHintArray,
 829                      width,
 830                      &amp;haveWidth,
 831                      font-&gt;isT1 ? decoder-&gt;builder.left_bearing-&gt;x
</pre>
<hr />
<pre>
 874                                                        idx + 0 ) );
 875             curY = ADD_INT32( curY, cf2_stack_getReal( opStack,
 876                                                        idx + 1 ) );
 877 
 878             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 879           }
 880 
 881           cf2_stack_clear( opStack );
 882         }
 883         continue; /* no need to clear stack again */
 884 
 885       case cf2_cmdHLINETO:
 886       case cf2_cmdVLINETO:
 887         {
 888           CF2_UInt  idx;
 889           CF2_UInt  count = cf2_stack_count( opStack );
 890 
 891           FT_Bool  isX = FT_BOOL( op1 == cf2_cmdHLINETO );
 892 
 893 
<span class="line-modified"> 894           FT_TRACE4(( &quot;%s\n&quot;, isX ? &quot; hlineto&quot; : &quot; vlineto&quot; ));</span>
 895 
 896           for ( idx = 0; idx &lt; count; idx++ )
 897           {
 898             CF2_Fixed  v = cf2_stack_getReal( opStack, idx );
 899 
 900 
 901             if ( isX )
 902               curX = ADD_INT32( curX, v );
 903             else
 904               curY = ADD_INT32( curY, v );
 905 
 906             isX = !isX;
 907 
 908             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 909           }
 910 
 911           cf2_stack_clear( opStack );
 912         }
 913         continue;
 914 
 915       case cf2_cmdRCURVELINE:
 916       case cf2_cmdRRCURVETO:
 917         {
 918           CF2_UInt  count = cf2_stack_count( opStack );
 919           CF2_UInt  idx   = 0;
 920 
 921 
<span class="line-modified"> 922           FT_TRACE4(( &quot;%s\n&quot;, op1 == cf2_cmdRCURVELINE ? &quot; rcurveline&quot;</span>
<span class="line-modified"> 923                                                        : &quot; rrcurveto&quot; ));</span>
 924 
 925           while ( idx + 6 &lt;= count )
 926           {
 927             CF2_Fixed  x1, y1, x2, y2, x3, y3;
 928 
 929 
 930             x1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 0 ), curX );
 931             y1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 1 ), curY );
 932             x2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 2 ), x1 );
 933             y2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 3 ), y1 );
 934             x3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 4 ), x2 );
 935             y3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 5 ), y2 );
 936 
 937             cf2_glyphpath_curveTo( &amp;glyphPath, x1, y1, x2, y2, x3, y3 );
 938 
 939             curX  = x3;
 940             curY  = y3;
 941             idx  += 6;
 942           }
 943 
 944           if ( op1 == cf2_cmdRCURVELINE )
 945           {
 946             curX = ADD_INT32( curX, cf2_stack_getReal( opStack,
 947                                                        idx + 0 ) );
 948             curY = ADD_INT32( curY, cf2_stack_getReal( opStack,
 949                                                        idx + 1 ) );
 950 
 951             cf2_glyphpath_lineTo( &amp;glyphPath, curX, curY );
 952           }
 953 
 954           cf2_stack_clear( opStack );
 955         }
 956         continue; /* no need to clear stack again */
 957 
 958       case cf2_cmdCLOSEPATH:
 959         if ( !font-&gt;isT1 )
 960           FT_TRACE4(( &quot; unknown op (%d)\n&quot;, op1 ));
 961         else
 962         {
<span class="line-modified"> 963           FT_TRACE4(( &quot; closepath\n&quot; ));</span>
 964 
 965           /* if there is no path, `closepath&#39; is a no-op */
<span class="line-modified"> 966           cf2_glyphpath_closeOpenPath( &amp;glyphPath );</span>
 967 
 968           haveWidth = TRUE;
 969         }
 970         break;
 971 
 972       case cf2_cmdCALLGSUBR:
 973       case cf2_cmdCALLSUBR:
 974         {
 975           CF2_Int  subrNum;
 976 
 977 
<span class="line-modified"> 978           FT_TRACE4(( &quot;%s&quot;, op1 == cf2_cmdCALLGSUBR ? &quot; callgsubr&quot;</span>
<span class="line-modified"> 979                                                     : &quot; callsubr&quot; ));</span>
 980 
 981           if ( ( !font-&gt;isT1 &amp;&amp; charstringIndex &gt; CF2_MAX_SUBR )       ||
 982                (  font-&gt;isT1 &amp;&amp; charstringIndex &gt; T1_MAX_SUBRS_CALLS ) )
 983           {
 984             /* max subr plus one for charstring */
 985             lastError = FT_THROW( Invalid_Glyph_Format );
 986             goto exit;                      /* overflow of stack */
 987           }
 988 
 989           /* push our current CFF charstring region on subrStack */
 990           charstring = (CF2_Buffer)
 991                          cf2_arrstack_getPointer(
 992                            &amp;subrStack,
 993                            (size_t)charstringIndex + 1 );
 994 
 995           /* set up the new CFF region and pointer */
 996           subrNum = cf2_stack_popInt( opStack );
 997 
 998           if ( font-&gt;isT1 &amp;&amp; decoder-&gt;locals_hash )
 999           {
</pre>
<hr />
<pre>
1198 
1199                 case cf2_escVSTEM3:
1200                 case cf2_escHSTEM3:
1201                   /*
1202                    * Type 1:                          Type 2:
1203                    *   x0 dx0 x1 dx1 x2 dx2 vstem3      x dx {dxa dxb}* vstem
1204                    *   y0 dy0 y1 dy1 y2 dy2 hstem3      y dy {dya dyb}* hstem
1205                    *   relative to lsb point            relative to zero
1206                    *
1207                    */
1208                   {
1209                     if ( !font-&gt;isT1 )
1210                       FT_TRACE4(( &quot; unknown op (12, %d)\n&quot;, op2 ));
1211                     else
1212                     {
1213                       CF2_F16Dot16  v0, v1, v2;
1214 
1215                       FT_Bool  isV = FT_BOOL( op2 == cf2_escVSTEM3 );
1216 
1217 
<span class="line-modified">1218                       FT_TRACE4(( &quot;%s\n&quot;, isV ? &quot; vstem3&quot;</span>
<span class="line-modified">1219                                               : &quot; hstem3&quot; ));</span>
1220 
1221                       FT_ASSERT( cf2_stack_count( opStack ) == 6 );
1222 
1223                       v0 = cf2_stack_getReal( opStack, 0 );
1224                       v1 = cf2_stack_getReal( opStack, 2 );
1225                       v2 = cf2_stack_getReal( opStack, 4 );
1226 
1227                       cf2_stack_setReal(
1228                         opStack, 2,
1229                         SUB_INT32( SUB_INT32( v1, v0 ),
1230                                    cf2_stack_getReal( opStack, 1 ) ) );
1231                       cf2_stack_setReal(
1232                         opStack, 4,
1233                         SUB_INT32( SUB_INT32( v2, v1 ),
1234                                    cf2_stack_getReal( opStack, 3 ) ) );
1235 
1236                       /* add left-sidebearing correction */
1237                       cf2_doStems( font,
1238                                    opStack,
1239                                    isV ? &amp;vStemHintArray : &amp;hStemHintArray,
</pre>
<hr />
<pre>
1630                     cf2_stack_pushInt( opStack, arg1 == arg2 );
1631                   }
1632                   continue; /* do not clear the stack */
1633 
1634                 case cf2_escCALLOTHERSUBR:
1635                   if ( !font-&gt;isT1 )
1636                     FT_TRACE4(( &quot; unknown op (12, %d)\n&quot;, op2 ));
1637                   else
1638                   {
1639                     CF2_Int   subr_no;
1640                     CF2_Int   arg_cnt;
1641                     CF2_UInt  count;
1642                     CF2_UInt  opIdx = 0;
1643 
1644 
1645                     FT_TRACE4(( &quot; callothersubr\n&quot; ));
1646 
1647                     subr_no = cf2_stack_popInt( opStack );
1648                     arg_cnt = cf2_stack_popInt( opStack );
1649 
<span class="line-modified">1650                     /********************************************************</span>
<span class="line-modified">1651                      *</span>
<span class="line-modified">1652                      * remove all operands to callothersubr from the stack</span>
<span class="line-modified">1653                      *</span>
<span class="line-modified">1654                      * for handled othersubrs, where we know the number of</span>
<span class="line-modified">1655                      * arguments, we increase the stack by the value of</span>
<span class="line-modified">1656                      * known_othersubr_result_cnt</span>
<span class="line-modified">1657                      *</span>
<span class="line-modified">1658                      * for unhandled othersubrs the following pops adjust</span>
<span class="line-modified">1659                      * the stack pointer as necessary</span>
<span class="line-added">1660                      */</span>
1661 
1662                     count = cf2_stack_count( opStack );
1663                     FT_ASSERT( (CF2_UInt)arg_cnt &lt;= count );
1664 
1665                     opIdx += count - (CF2_UInt)arg_cnt;
1666 
1667                     known_othersubr_result_cnt = 0;
1668                     result_cnt                 = 0;
1669 
1670                     /* XXX TODO: The checks to `arg_count == &lt;whatever&gt;&#39;   */
1671                     /* might not be correct; an othersubr expects a        */
1672                     /* certain number of operands on the PostScript stack  */
1673                     /* (as opposed to the T1 stack) but it doesn&#39;t have to */
1674                     /* put them there by itself; previous othersubrs might */
1675                     /* have left the operands there if they were not       */
1676                     /* followed by an appropriate number of pops           */
1677                     /*                                                     */
1678                     /* On the other hand, Adobe Reader 7.0.8 for Linux     */
1679                     /* doesn&#39;t accept a font that contains charstrings     */
1680                     /* like                                                */
</pre>
<hr />
<pre>
2403                   }
2404                   break;
2405 
2406                 } /* end of 2nd switch checking op2 */
2407               }
2408             }
2409           } /* end of 1st switch checking op2 */
2410         } /* case cf2_cmdESC */
2411 
2412         break;
2413 
2414       case cf2_cmdHSBW:
2415         if ( !font-&gt;isT1 )
2416           FT_TRACE4(( &quot; unknown op (%d)\n&quot;, op1 ));
2417         else
2418         {
2419           CF2_Fixed    lsb_x;
2420           PS_Builder*  builder;
2421 
2422 
<span class="line-modified">2423           FT_TRACE4(( &quot; hsbw\n&quot; ));</span>
2424 
2425           builder = &amp;decoder-&gt;builder;
2426 
2427           builder-&gt;advance-&gt;x = cf2_stack_popFixed( opStack );
2428           builder-&gt;advance-&gt;y = 0;
2429 
2430           lsb_x = cf2_stack_popFixed( opStack );
2431 
2432           builder-&gt;left_bearing-&gt;x = ADD_INT32( builder-&gt;left_bearing-&gt;x,
2433                                                 lsb_x );
2434 
2435           haveWidth = TRUE;
2436 
2437           /* the `metrics_only&#39; indicates that we only want to compute */
2438           /* the glyph&#39;s metrics (lsb + advance width), not load the   */
2439           /* rest of it; so exit immediately                           */
2440           if ( builder-&gt;metrics_only )
2441             goto exit;
2442 
2443           if ( initial_map_ready )
</pre>
<hr />
<pre>
2549           {
2550             lastError = error2;      /* pass FreeType error through */
2551             goto exit;
2552           }
2553           cf2_interpT2CharString( font,
2554                                   &amp;component,
2555                                   callbacks,
2556                                   translation,
2557                                   TRUE,
2558                                   0,
2559                                   0,
2560                                   &amp;dummyWidth );
2561           cf2_freeSeacComponent( decoder, &amp;component );
2562         }
2563         goto exit;
2564 
2565       case cf2_cmdCNTRMASK:
2566       case cf2_cmdHINTMASK:
2567         /* the final \n in the tracing message gets added in      */
2568         /* `cf2_hintmask_read&#39; (which also traces the mask bytes) */
<span class="line-modified">2569         FT_TRACE4(( &quot;%s&quot;, op1 == cf2_cmdCNTRMASK ? &quot; cntrmask&quot; : &quot; hintmask&quot; ));</span>
2570 
2571         /* never add hints after the mask is computed */
2572         if ( cf2_stack_count( opStack ) &gt; 1    &amp;&amp;
2573              cf2_hintmask_isValid( &amp;hintMask ) )
2574         {
2575           FT_TRACE4(( &quot;cf2_interpT2CharString: invalid hint mask\n&quot; ));
2576           break;
2577         }
2578 
2579         /* if there are arguments on the stack, there this is an */
2580         /* implied cf2_cmdVSTEMHM                                */
2581         cf2_doStems( font,
2582                      opStack,
2583                      &amp;vStemHintArray,
2584                      width,
2585                      &amp;haveWidth,
2586                      0 );
2587 
2588         if ( decoder-&gt;width_only )
2589           goto exit;
</pre>
<hr />
<pre>
2815           cf2_stack_clear( opStack );
2816         }
2817         continue; /* no need to clear stack again */
2818 
2819       case cf2_cmdVHCURVETO:
2820       case cf2_cmdHVCURVETO:
2821         {
2822           CF2_UInt  count, count1 = cf2_stack_count( opStack );
2823           CF2_UInt  idx = 0;
2824 
2825           FT_Bool  alternate = FT_BOOL( op1 == cf2_cmdHVCURVETO );
2826 
2827 
2828           /* if `cf2_stack_count&#39; isn&#39;t of the form 8n, 8n+1, */
2829           /* 8n+4, or 8n+5, we enforce it by clearing the     */
2830           /* second bit                                       */
2831           /* (and sorting the stack indexing to suit)         */
2832           count = count1 &amp; ~2U;
2833           idx  += count1 - count;
2834 
<span class="line-modified">2835           FT_TRACE4(( &quot;%s\n&quot;, alternate ? &quot; hvcurveto&quot; : &quot; vhcurveto&quot; ));</span>
2836 
2837           while ( idx &lt; count )
2838           {
2839             CF2_Fixed x1, x2, x3, y1, y2, y3;
2840 
2841 
2842             if ( alternate )
2843             {
2844               x1 = ADD_INT32( cf2_stack_getReal( opStack, idx + 0 ), curX );
2845               y1 = curY;
2846               x2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 1 ), x1 );
2847               y2 = ADD_INT32( cf2_stack_getReal( opStack, idx + 2 ), y1 );
2848               y3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 3 ), y2 );
2849 
2850               if ( count - idx == 5 )
2851               {
2852                 x3 = ADD_INT32( cf2_stack_getReal( opStack, idx + 4 ), x2 );
2853 
2854                 idx++;
2855               }
</pre>
</td>
</tr>
</table>
<center><a href="pshints.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="psintrp.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
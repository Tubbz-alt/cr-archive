<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftstream.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftsnames.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftstroke.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftstream.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftstream.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    I/O stream support (body).                                           */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2000-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_STREAM_H
 21 #include FT_INTERNAL_DEBUG_H
 22 
 23 
<span class="line-modified"> 24   /*************************************************************************/</span>
<span class="line-modified"> 25   /*                                                                       */</span>
<span class="line-modified"> 26   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 27   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 28   /* messages during execution.                                            */</span>
<span class="line-modified"> 29   /*                                                                       */</span>
 30 #undef  FT_COMPONENT
<span class="line-modified"> 31 #define FT_COMPONENT  trace_stream</span>
 32 
 33 
 34   FT_BASE_DEF( void )
 35   FT_Stream_OpenMemory( FT_Stream       stream,
 36                         const FT_Byte*  base,
 37                         FT_ULong        size )
 38   {
 39     stream-&gt;base   = (FT_Byte*) base;
 40     stream-&gt;size   = size;
 41     stream-&gt;pos    = 0;
 42     stream-&gt;cursor = NULL;
 43     stream-&gt;read   = NULL;
 44     stream-&gt;close  = NULL;
 45   }
 46 
 47 
 48   FT_BASE_DEF( void )
 49   FT_Stream_Close( FT_Stream  stream )
 50   {
 51     if ( stream &amp;&amp; stream-&gt;close )
</pre>
<hr />
<pre>
202     {
203       *pbytes = (FT_Byte*)stream-&gt;cursor;
204 
205       /* equivalent to FT_Stream_ExitFrame(), with no memory block release */
206       stream-&gt;cursor = NULL;
207       stream-&gt;limit  = NULL;
208     }
209 
210     return error;
211   }
212 
213 
214   FT_BASE_DEF( void )
215   FT_Stream_ReleaseFrame( FT_Stream  stream,
216                           FT_Byte**  pbytes )
217   {
218     if ( stream &amp;&amp; stream-&gt;read )
219     {
220       FT_Memory  memory = stream-&gt;memory;
221 

222 #ifdef FT_DEBUG_MEMORY
223       ft_mem_free( memory, *pbytes );
<span class="line-removed">224       *pbytes = NULL;</span>
225 #else
226       FT_FREE( *pbytes );
227 #endif
228     }

229     *pbytes = NULL;
230   }
231 
232 
233   FT_BASE_DEF( FT_Error )
234   FT_Stream_EnterFrame( FT_Stream  stream,
235                         FT_ULong   count )
236   {
237     FT_Error  error = FT_Err_Ok;
238     FT_ULong  read_bytes;
239 
240 


241     /* check for nested frame access */
242     FT_ASSERT( stream &amp;&amp; stream-&gt;cursor == 0 );
243 
244     if ( stream-&gt;read )
245     {
246       /* allocate the frame in memory */
247       FT_Memory  memory = stream-&gt;memory;
248 
249 
250       /* simple sanity check */
251       if ( count &gt; stream-&gt;size )
252       {
253         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
254                    &quot; frame size (%lu) larger than stream size (%lu)\n&quot;,
255                    count, stream-&gt;size ));
256 
257         error = FT_THROW( Invalid_Stream_Operation );
258         goto Exit;
259       }
260 
</pre>
<hr />
<pre>
264                                                     (FT_Long)count,
265                                                     &amp;error );
266       if ( error )
267         goto Exit;
268 #else
269       if ( FT_QALLOC( stream-&gt;base, count ) )
270         goto Exit;
271 #endif
272       /* read it */
273       read_bytes = stream-&gt;read( stream, stream-&gt;pos,
274                                  stream-&gt;base, count );
275       if ( read_bytes &lt; count )
276       {
277         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
278                    &quot; invalid read; expected %lu bytes, got %lu\n&quot;,
279                    count, read_bytes ));
280 
281         FT_FREE( stream-&gt;base );
282         error = FT_THROW( Invalid_Stream_Operation );
283       }

284       stream-&gt;cursor = stream-&gt;base;
285       stream-&gt;limit  = stream-&gt;cursor + count;
286       stream-&gt;pos   += read_bytes;
287     }
288     else
289     {
290       /* check current and new position */
291       if ( stream-&gt;pos &gt;= stream-&gt;size        ||
292            stream-&gt;size - stream-&gt;pos &lt; count )
293       {
294         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
295                    &quot; invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\n&quot;,
296                    stream-&gt;pos, count, stream-&gt;size ));
297 
298         error = FT_THROW( Invalid_Stream_Operation );
299         goto Exit;
300       }
301 
302       /* set cursor */
303       stream-&gt;cursor = stream-&gt;base + stream-&gt;pos;
304       stream-&gt;limit  = stream-&gt;cursor + count;
305       stream-&gt;pos   += count;
306     }
307 
308   Exit:
309     return error;
310   }
311 
312 
313   FT_BASE_DEF( void )
314   FT_Stream_ExitFrame( FT_Stream  stream )
315   {
316     /* IMPORTANT: The assertion stream-&gt;cursor != 0 was removed, given    */
317     /*            that it is possible to access a frame of length 0 in    */
318     /*            some weird fonts (usually, when accessing an array of   */
319     /*            0 records, like in some strange kern tables).           */
320     /*                                                                    */
321     /*  In this case, the loader code handles the 0-length table          */
322     /*  gracefully; however, stream.cursor is really set to 0 by the      */
323     /*  FT_Stream_EnterFrame() call, and this is not an error.            */
<span class="line-modified">324     /*                                                                    */</span>


325     FT_ASSERT( stream );
326 
327     if ( stream-&gt;read )
328     {
329       FT_Memory  memory = stream-&gt;memory;
330 

331 #ifdef FT_DEBUG_MEMORY
332       ft_mem_free( memory, stream-&gt;base );
333       stream-&gt;base = NULL;
334 #else
335       FT_FREE( stream-&gt;base );
336 #endif
337     }

338     stream-&gt;cursor = NULL;
339     stream-&gt;limit  = NULL;
340   }
341 
342 
343   FT_BASE_DEF( FT_Char )
344   FT_Stream_GetChar( FT_Stream  stream )
345   {
346     FT_Char  result;
347 
348 
349     FT_ASSERT( stream &amp;&amp; stream-&gt;cursor );
350 
351     result = 0;
352     if ( stream-&gt;cursor &lt; stream-&gt;limit )
353       result = (FT_Char)*stream-&gt;cursor++;
354 
355     return result;
356   }
357 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftstream.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   I/O stream support (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2000-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_STREAM_H
 21 #include FT_INTERNAL_DEBUG_H
 22 
 23 
<span class="line-modified"> 24   /**************************************************************************</span>
<span class="line-modified"> 25    *</span>
<span class="line-modified"> 26    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 27    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 28    * messages during execution.</span>
<span class="line-modified"> 29    */</span>
 30 #undef  FT_COMPONENT
<span class="line-modified"> 31 #define FT_COMPONENT  stream</span>
 32 
 33 
 34   FT_BASE_DEF( void )
 35   FT_Stream_OpenMemory( FT_Stream       stream,
 36                         const FT_Byte*  base,
 37                         FT_ULong        size )
 38   {
 39     stream-&gt;base   = (FT_Byte*) base;
 40     stream-&gt;size   = size;
 41     stream-&gt;pos    = 0;
 42     stream-&gt;cursor = NULL;
 43     stream-&gt;read   = NULL;
 44     stream-&gt;close  = NULL;
 45   }
 46 
 47 
 48   FT_BASE_DEF( void )
 49   FT_Stream_Close( FT_Stream  stream )
 50   {
 51     if ( stream &amp;&amp; stream-&gt;close )
</pre>
<hr />
<pre>
202     {
203       *pbytes = (FT_Byte*)stream-&gt;cursor;
204 
205       /* equivalent to FT_Stream_ExitFrame(), with no memory block release */
206       stream-&gt;cursor = NULL;
207       stream-&gt;limit  = NULL;
208     }
209 
210     return error;
211   }
212 
213 
214   FT_BASE_DEF( void )
215   FT_Stream_ReleaseFrame( FT_Stream  stream,
216                           FT_Byte**  pbytes )
217   {
218     if ( stream &amp;&amp; stream-&gt;read )
219     {
220       FT_Memory  memory = stream-&gt;memory;
221 
<span class="line-added">222 </span>
223 #ifdef FT_DEBUG_MEMORY
224       ft_mem_free( memory, *pbytes );

225 #else
226       FT_FREE( *pbytes );
227 #endif
228     }
<span class="line-added">229 </span>
230     *pbytes = NULL;
231   }
232 
233 
234   FT_BASE_DEF( FT_Error )
235   FT_Stream_EnterFrame( FT_Stream  stream,
236                         FT_ULong   count )
237   {
238     FT_Error  error = FT_Err_Ok;
239     FT_ULong  read_bytes;
240 
241 
<span class="line-added">242     FT_TRACE7(( &quot;FT_Stream_EnterFrame: %ld bytes\n&quot;, count ));</span>
<span class="line-added">243 </span>
244     /* check for nested frame access */
245     FT_ASSERT( stream &amp;&amp; stream-&gt;cursor == 0 );
246 
247     if ( stream-&gt;read )
248     {
249       /* allocate the frame in memory */
250       FT_Memory  memory = stream-&gt;memory;
251 
252 
253       /* simple sanity check */
254       if ( count &gt; stream-&gt;size )
255       {
256         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
257                    &quot; frame size (%lu) larger than stream size (%lu)\n&quot;,
258                    count, stream-&gt;size ));
259 
260         error = FT_THROW( Invalid_Stream_Operation );
261         goto Exit;
262       }
263 
</pre>
<hr />
<pre>
267                                                     (FT_Long)count,
268                                                     &amp;error );
269       if ( error )
270         goto Exit;
271 #else
272       if ( FT_QALLOC( stream-&gt;base, count ) )
273         goto Exit;
274 #endif
275       /* read it */
276       read_bytes = stream-&gt;read( stream, stream-&gt;pos,
277                                  stream-&gt;base, count );
278       if ( read_bytes &lt; count )
279       {
280         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
281                    &quot; invalid read; expected %lu bytes, got %lu\n&quot;,
282                    count, read_bytes ));
283 
284         FT_FREE( stream-&gt;base );
285         error = FT_THROW( Invalid_Stream_Operation );
286       }
<span class="line-added">287 </span>
288       stream-&gt;cursor = stream-&gt;base;
289       stream-&gt;limit  = stream-&gt;cursor + count;
290       stream-&gt;pos   += read_bytes;
291     }
292     else
293     {
294       /* check current and new position */
295       if ( stream-&gt;pos &gt;= stream-&gt;size        ||
296            stream-&gt;size - stream-&gt;pos &lt; count )
297       {
298         FT_ERROR(( &quot;FT_Stream_EnterFrame:&quot;
299                    &quot; invalid i/o; pos = 0x%lx, count = %lu, size = 0x%lx\n&quot;,
300                    stream-&gt;pos, count, stream-&gt;size ));
301 
302         error = FT_THROW( Invalid_Stream_Operation );
303         goto Exit;
304       }
305 
306       /* set cursor */
307       stream-&gt;cursor = stream-&gt;base + stream-&gt;pos;
308       stream-&gt;limit  = stream-&gt;cursor + count;
309       stream-&gt;pos   += count;
310     }
311 
312   Exit:
313     return error;
314   }
315 
316 
317   FT_BASE_DEF( void )
318   FT_Stream_ExitFrame( FT_Stream  stream )
319   {
320     /* IMPORTANT: The assertion stream-&gt;cursor != 0 was removed, given    */
321     /*            that it is possible to access a frame of length 0 in    */
322     /*            some weird fonts (usually, when accessing an array of   */
323     /*            0 records, like in some strange kern tables).           */
324     /*                                                                    */
325     /*  In this case, the loader code handles the 0-length table          */
326     /*  gracefully; however, stream.cursor is really set to 0 by the      */
327     /*  FT_Stream_EnterFrame() call, and this is not an error.            */
<span class="line-modified">328 </span>
<span class="line-added">329     FT_TRACE7(( &quot;FT_Stream_ExitFrame\n&quot; ));</span>
<span class="line-added">330 </span>
331     FT_ASSERT( stream );
332 
333     if ( stream-&gt;read )
334     {
335       FT_Memory  memory = stream-&gt;memory;
336 
<span class="line-added">337 </span>
338 #ifdef FT_DEBUG_MEMORY
339       ft_mem_free( memory, stream-&gt;base );
340       stream-&gt;base = NULL;
341 #else
342       FT_FREE( stream-&gt;base );
343 #endif
344     }
<span class="line-added">345 </span>
346     stream-&gt;cursor = NULL;
347     stream-&gt;limit  = NULL;
348   }
349 
350 
351   FT_BASE_DEF( FT_Char )
352   FT_Stream_GetChar( FT_Stream  stream )
353   {
354     FT_Char  result;
355 
356 
357     FT_ASSERT( stream &amp;&amp; stream-&gt;cursor );
358 
359     result = 0;
360     if ( stream-&gt;cursor &lt; stream-&gt;limit )
361       result = (FT_Char)*stream-&gt;cursor++;
362 
363     return result;
364   }
365 
</pre>
</td>
</tr>
</table>
<center><a href="ftsnames.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftstroke.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
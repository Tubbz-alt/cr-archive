<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/include/freetype/internal/ftstream.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftserv.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="fttrace.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/include/freetype/internal/ftstream.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,21 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ftstream.h                                                             */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Stream handling (specification).                                     */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #ifndef FTSTREAM_H_
  #define FTSTREAM_H_
  
<span class="line-new-header">--- 1,21 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ftstream.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Stream handling (specification).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #ifndef FTSTREAM_H_
  #define FTSTREAM_H_
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 94,17 ***</span>
  
    /* Construct an FT_Frame_Field out of a structure type and a field name. */
    /* The structure type must be set in the FT_STRUCTURE macro before       */
    /* calling the FT_FRAME_START() macro.                                   */
    /*                                                                       */
<span class="line-modified">! #define FT_FIELD_SIZE( f ) \</span>
            (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f )
  
<span class="line-modified">! #define FT_FIELD_SIZE_DELTA( f ) \</span>
            (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f[0] )
  
<span class="line-modified">! #define FT_FIELD_OFFSET( f ) \</span>
            (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
  
  #define FT_FRAME_FIELD( frame_op, field ) \
            {                               \
              frame_op,                     \
<span class="line-new-header">--- 94,17 ---</span>
  
    /* Construct an FT_Frame_Field out of a structure type and a field name. */
    /* The structure type must be set in the FT_STRUCTURE macro before       */
    /* calling the FT_FRAME_START() macro.                                   */
    /*                                                                       */
<span class="line-modified">! #define FT_FIELD_SIZE( f )                          \</span>
            (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f )
  
<span class="line-modified">! #define FT_FIELD_SIZE_DELTA( f )                       \</span>
            (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f[0] )
  
<span class="line-modified">! #define FT_FIELD_OFFSET( f )                         \</span>
            (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
  
  #define FT_FRAME_FIELD( frame_op, field ) \
            {                               \
              frame_op,                     \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 145,15 ***</span>
            }
  
  #define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Integer extraction macros -- the `buffer&#39; parameter must ALWAYS be of */</span>
<span class="line-modified">!   /* type `char*&#39; or equivalent (1-byte elements).                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
  
  #define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
  
  #define FT_INT16( x )   ( (FT_Int16)(x)  )
  #define FT_UINT16( x )  ( (FT_UInt16)(x) )
<span class="line-new-header">--- 145,15 ---</span>
            }
  
  #define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Integer extraction macros -- the &#39;buffer&#39; parameter must ALWAYS be of</span>
<span class="line-modified">!    * type &#39;char*&#39; or equivalent (1-byte elements).</span>
<span class="line-modified">!    */</span>
  
  #define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
  
  #define FT_INT16( x )   ( (FT_Int16)(x)  )
  #define FT_UINT16( x )  ( (FT_UInt16)(x) )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,10 ***</span>
<span class="line-new-header">--- 163,25 ---</span>
  
  #define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
  #define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
  
  
<span class="line-added">+   /*</span>
<span class="line-added">+    *    function      acts on      increases  does range   for    emits</span>
<span class="line-added">+    *                                pointer    checking   frames  error</span>
<span class="line-added">+    *  -------------------------------------------------------------------</span>
<span class="line-added">+    *   FT_PEEK_XXX  buffer pointer      no         no        no     no</span>
<span class="line-added">+    *   FT_NEXT_XXX  buffer pointer     yes         no        no     no</span>
<span class="line-added">+    *   FT_GET_XXX   stream-&gt;cursor     yes        yes       yes     no</span>
<span class="line-added">+    *   FT_READ_XXX  stream-&gt;pos        yes        yes        no    yes</span>
<span class="line-added">+    */</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   /*</span>
<span class="line-added">+    * `FT_PEEK_XXX&#39; are generic macros to get data from a buffer position.  No</span>
<span class="line-added">+    * safety checks are performed.</span>
<span class="line-added">+    */</span>
  #define FT_PEEK_SHORT( p )  FT_INT16( FT_BYTE_U16( p, 0, 8 ) | \
                                        FT_BYTE_U16( p, 1, 0 ) )
  
  #define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
                                          FT_BYTE_U16( p, 1, 0 ) )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,11 ***</span>
  
  #define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
                                            FT_BYTE_U32( p, 1,  8 ) | \
                                            FT_BYTE_U32( p, 0,  0 ) )
  
<span class="line-modified">! </span>
  #define FT_NEXT_CHAR( buffer )       \
            ( (signed char)*buffer++ )
  
  #define FT_NEXT_BYTE( buffer )         \
            ( (unsigned char)*buffer++ )
<span class="line-new-header">--- 226,14 ---</span>
  
  #define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
                                            FT_BYTE_U32( p, 1,  8 ) | \
                                            FT_BYTE_U32( p, 0,  0 ) )
  
<span class="line-modified">!   /*</span>
<span class="line-added">+    * `FT_NEXT_XXX&#39; are generic macros to get data from a buffer position</span>
<span class="line-added">+    * which is then increased appropriately.  No safety checks are performed.</span>
<span class="line-added">+    */</span>
  #define FT_NEXT_CHAR( buffer )       \
            ( (signed char)*buffer++ )
  
  #define FT_NEXT_BYTE( buffer )         \
            ( (unsigned char)*buffer++ )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,14 ***</span>
  
  #define FT_NEXT_ULONG_LE( buffer )                                           \
            ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Each GET_xxxx() macro uses an implicit `stream&#39; variable.             */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #if 0
  #define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream-&gt;cursor )
  
  #define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
  #define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
<span class="line-new-header">--- 274,18 ---</span>
  
  #define FT_NEXT_ULONG_LE( buffer )                                           \
            ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The `FT_GET_XXX` macros use an implicit &#39;stream&#39; variable.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * Note that a call to `FT_STREAM_SEEK` or `FT_STREAM_POS` has **no**</span>
<span class="line-added">+    * effect on `FT_GET_XXX`!  They operate on `stream-&gt;pos`, while</span>
<span class="line-added">+    * `FT_GET_XXX` use `stream-&gt;cursor`.</span>
<span class="line-added">+    */</span>
  #if 0
  #define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream-&gt;cursor )
  
  #define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
  #define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 297,14 ***</span>
<span class="line-new-header">--- 319,22 ---</span>
  #define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )
  #define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )
  #define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )
  #endif
  
<span class="line-added">+ </span>
  #define FT_READ_MACRO( func, type, var )        \
            ( var = (type)func( stream, &amp;error ), \
              error != FT_Err_Ok )
  
<span class="line-added">+   /*</span>
<span class="line-added">+    * The `FT_READ_XXX&#39; macros use implicit `stream&#39; and `error&#39; variables.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * `FT_READ_XXX&#39; can be controlled with `FT_STREAM_SEEK&#39; and</span>
<span class="line-added">+    * `FT_STREAM_POS&#39;.  They use the full machinery to check whether a read is</span>
<span class="line-added">+    * valid.</span>
<span class="line-added">+    */</span>
  #define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
  #define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
  #define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )
  #define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )
  #define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 385,43 ***</span>
                       FT_Byte*   buffer,
                       FT_ULong   count );
  
    /* Enter a frame of `count&#39; consecutive bytes in a stream.  Returns an */
    /* error if the frame could not be read/accessed.  The caller can use  */
<span class="line-modified">!   /* the FT_Stream_Get_XXX functions to retrieve frame data without      */</span>
    /* error checks.                                                       */
    /*                                                                     */
<span class="line-modified">!   /* You must _always_ call FT_Stream_ExitFrame() once you have entered  */</span>
    /* a stream frame!                                                     */
    /*                                                                     */
    FT_BASE( FT_Error )
    FT_Stream_EnterFrame( FT_Stream  stream,
                          FT_ULong   count );
  
    /* exit a stream frame */
    FT_BASE( void )
    FT_Stream_ExitFrame( FT_Stream  stream );
  
    /* Extract a stream frame.  If the stream is disk-based, a heap block */
    /* is allocated and the frame bytes are read into it.  If the stream  */
<span class="line-modified">!   /* is memory-based, this function simply set a pointer to the data.   */</span>
    /*                                                                    */
    /* Useful to optimize access to memory-based streams transparently.   */
    /*                                                                    */
<span class="line-modified">!   /* All extracted frames must be `freed&#39; with a call to the function   */</span>
<span class="line-modified">!   /* FT_Stream_ReleaseFrame().                                          */</span>
    /*                                                                    */
    FT_BASE( FT_Error )
    FT_Stream_ExtractFrame( FT_Stream  stream,
                            FT_ULong   count,
                            FT_Byte**  pbytes );
  
<span class="line-modified">!   /* release an extract frame (see FT_Stream_ExtractFrame) */</span>
    FT_BASE( void )
    FT_Stream_ReleaseFrame( FT_Stream  stream,
                            FT_Byte**  pbytes );
  
    /* read a byte from an entered frame */
    FT_BASE( FT_Char )
    FT_Stream_GetChar( FT_Stream  stream );
  
    /* read a 16-bit big-endian unsigned integer from an entered frame */
<span class="line-new-header">--- 415,49 ---</span>
                       FT_Byte*   buffer,
                       FT_ULong   count );
  
    /* Enter a frame of `count&#39; consecutive bytes in a stream.  Returns an */
    /* error if the frame could not be read/accessed.  The caller can use  */
<span class="line-modified">!   /* the `FT_Stream_GetXXX&#39; functions to retrieve frame data without     */</span>
    /* error checks.                                                       */
    /*                                                                     */
<span class="line-modified">!   /* You must _always_ call `FT_Stream_ExitFrame&#39; once you have entered  */</span>
    /* a stream frame!                                                     */
    /*                                                                     */
<span class="line-added">+   /* Nested frames are not permitted.                                    */</span>
<span class="line-added">+   /*                                                                     */</span>
    FT_BASE( FT_Error )
    FT_Stream_EnterFrame( FT_Stream  stream,
                          FT_ULong   count );
  
    /* exit a stream frame */
    FT_BASE( void )
    FT_Stream_ExitFrame( FT_Stream  stream );
  
<span class="line-added">+ </span>
    /* Extract a stream frame.  If the stream is disk-based, a heap block */
    /* is allocated and the frame bytes are read into it.  If the stream  */
<span class="line-modified">!   /* is memory-based, this function simply sets a pointer to the data.  */</span>
    /*                                                                    */
    /* Useful to optimize access to memory-based streams transparently.   */
    /*                                                                    */
<span class="line-modified">!   /* `FT_Stream_GetXXX&#39; functions can&#39;t be used.                        */</span>
<span class="line-modified">!   /*                                                                    */</span>
<span class="line-added">+   /* An extracted frame must be `freed&#39; with a call to the function     */</span>
<span class="line-added">+   /* `FT_Stream_ReleaseFrame&#39;.                                          */</span>
    /*                                                                    */
    FT_BASE( FT_Error )
    FT_Stream_ExtractFrame( FT_Stream  stream,
                            FT_ULong   count,
                            FT_Byte**  pbytes );
  
<span class="line-modified">!   /* release an extract frame (see `FT_Stream_ExtractFrame&#39;) */</span>
    FT_BASE( void )
    FT_Stream_ReleaseFrame( FT_Stream  stream,
                            FT_Byte**  pbytes );
  
<span class="line-added">+ </span>
    /* read a byte from an entered frame */
    FT_BASE( FT_Char )
    FT_Stream_GetChar( FT_Stream  stream );
  
    /* read a 16-bit big-endian unsigned integer from an entered frame */
</pre>
<center><a href="ftserv.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="fttrace.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
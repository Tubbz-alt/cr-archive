<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/smooth/ftsmooth.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftsmooth.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Anti-aliasing renderer interface (body).                             */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2000-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_OBJECTS_H
 22 #include FT_OUTLINE_H
 23 #include &quot;ftsmooth.h&quot;
 24 #include &quot;ftgrays.h&quot;
<a name="2" id="anc2"></a><span class="line-removed"> 25 #include &quot;ftspic.h&quot;</span>
 26 
 27 #include &quot;ftsmerrs.h&quot;
 28 
 29 
 30   /* initialize renderer -- init its raster */
 31   static FT_Error
 32   ft_smooth_init( FT_Renderer  render )
 33   {
<a name="3" id="anc3"></a>



















 34     render-&gt;clazz-&gt;raster_class-&gt;raster_reset( render-&gt;raster, NULL, 0 );
 35 
 36     return 0;
 37   }
 38 
 39 
 40   /* sets render-specific mode */
 41   static FT_Error
 42   ft_smooth_set_mode( FT_Renderer  render,
 43                       FT_ULong     mode_tag,
 44                       FT_Pointer   data )
 45   {
 46     /* we simply pass it to the raster */
 47     return render-&gt;clazz-&gt;raster_class-&gt;raster_set_mode( render-&gt;raster,
 48                                                          mode_tag,
 49                                                          data );
 50   }
 51 
 52   /* transform a given glyph image */
 53   static FT_Error
 54   ft_smooth_transform( FT_Renderer       render,
 55                        FT_GlyphSlot      slot,
 56                        const FT_Matrix*  matrix,
 57                        const FT_Vector*  delta )
 58   {
 59     FT_Error  error = FT_Err_Ok;
 60 
 61 
 62     if ( slot-&gt;format != render-&gt;glyph_format )
 63     {
 64       error = FT_THROW( Invalid_Argument );
 65       goto Exit;
 66     }
 67 
 68     if ( matrix )
 69       FT_Outline_Transform( &amp;slot-&gt;outline, matrix );
 70 
 71     if ( delta )
 72       FT_Outline_Translate( &amp;slot-&gt;outline, delta-&gt;x, delta-&gt;y );
 73 
 74   Exit:
 75     return error;
 76   }
 77 
 78 
 79   /* return the glyph&#39;s control box */
 80   static void
 81   ft_smooth_get_cbox( FT_Renderer   render,
 82                       FT_GlyphSlot  slot,
 83                       FT_BBox*      cbox )
 84   {
 85     FT_ZERO( cbox );
 86 
 87     if ( slot-&gt;format == render-&gt;glyph_format )
 88       FT_Outline_Get_CBox( &amp;slot-&gt;outline, cbox );
 89   }
 90 
 91 
 92   /* convert a slot&#39;s glyph image into a bitmap */
 93   static FT_Error
 94   ft_smooth_render_generic( FT_Renderer       render,
 95                             FT_GlyphSlot      slot,
 96                             FT_Render_Mode    mode,
 97                             const FT_Vector*  origin,
 98                             FT_Render_Mode    required_mode )
 99   {
100     FT_Error     error   = FT_Err_Ok;
101     FT_Outline*  outline = &amp;slot-&gt;outline;
102     FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
103     FT_Memory    memory  = render-&gt;root.memory;
104     FT_Pos       x_shift = 0;
105     FT_Pos       y_shift = 0;
106     FT_Int       hmul    = ( mode == FT_RENDER_MODE_LCD );
107     FT_Int       vmul    = ( mode == FT_RENDER_MODE_LCD_V );
108 
109     FT_Raster_Params  params;
110 
111 
112     /* check glyph image format */
113     if ( slot-&gt;format != render-&gt;glyph_format )
114     {
115       error = FT_THROW( Invalid_Argument );
116       goto Exit;
117     }
118 
119     /* check mode */
120     if ( mode != required_mode )
121     {
122       error = FT_THROW( Cannot_Render_Glyph );
123       goto Exit;
124     }
125 
126     /* release old bitmap buffer */
127     if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
128     {
129       FT_FREE( bitmap-&gt;buffer );
130       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
131     }
132 
<a name="4" id="anc4"></a><span class="line-modified">133     ft_glyphslot_preset_bitmap( slot, mode, origin );</span>




134 
135     /* allocate new one */
136     if ( FT_ALLOC_MULT( bitmap-&gt;buffer, bitmap-&gt;rows, bitmap-&gt;pitch ) )
137       goto Exit;
138 
139     slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;
140 
141     x_shift = 64 * -slot-&gt;bitmap_left;
142     y_shift = 64 * -slot-&gt;bitmap_top;
143     if ( bitmap-&gt;pixel_mode == FT_PIXEL_MODE_LCD_V )
144       y_shift += 64 * (FT_Int)bitmap-&gt;rows / 3;
145     else
146       y_shift += 64 * (FT_Int)bitmap-&gt;rows;
147 
148     if ( origin )
149     {
150       x_shift += origin-&gt;x;
151       y_shift += origin-&gt;y;
152     }
153 
154     /* translate outline to render it into the bitmap */
155     if ( x_shift || y_shift )
156       FT_Outline_Translate( outline, x_shift, y_shift );
157 
158     /* set up parameters */
159     params.target = bitmap;
160     params.source = outline;
161     params.flags  = FT_RASTER_FLAG_AA;
162 
163 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
164 
165     /* implode outline if needed */
166     {
167       FT_Vector*  points     = outline-&gt;points;
168       FT_Vector*  points_end = points + outline-&gt;n_points;
169       FT_Vector*  vec;
170 
171 
172       if ( hmul )
173         for ( vec = points; vec &lt; points_end; vec++ )
174           vec-&gt;x *= 3;
175 
176       if ( vmul )
177         for ( vec = points; vec &lt; points_end; vec++ )
178           vec-&gt;y *= 3;
179     }
180 
181     /* render outline into the bitmap */
182     error = render-&gt;raster_render( render-&gt;raster, &amp;params );
183 
184     /* deflate outline if needed */
185     {
186       FT_Vector*  points     = outline-&gt;points;
187       FT_Vector*  points_end = points + outline-&gt;n_points;
188       FT_Vector*  vec;
189 
190 
191       if ( hmul )
192         for ( vec = points; vec &lt; points_end; vec++ )
193           vec-&gt;x /= 3;
194 
195       if ( vmul )
196         for ( vec = points; vec &lt; points_end; vec++ )
197           vec-&gt;y /= 3;
198     }
199 
200     if ( error )
201       goto Exit;
202 
203     /* finally apply filtering */
204     if ( hmul || vmul )
205     {
206       FT_Byte*                 lcd_weights;
207       FT_Bitmap_LcdFilterFunc  lcd_filter_func;
208 
209 
210       /* Per-face LCD filtering takes priority if set up. */
211       if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
212       {
213         lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
214         lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
215       }
216       else
217       {
218         lcd_weights     = slot-&gt;library-&gt;lcd_weights;
219         lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
220       }
221 
222       if ( lcd_filter_func )
<a name="5" id="anc5"></a><span class="line-modified">223         lcd_filter_func( bitmap, mode, lcd_weights );</span>
224     }
225 
226 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
227 
228     if ( hmul )  /* lcd */
229     {
230       FT_Byte*  line;
231       FT_Byte*  temp = NULL;
232       FT_UInt   i, j;
233 
234       unsigned int  height = bitmap-&gt;rows;
235       unsigned int  width  = bitmap-&gt;width;
236       int           pitch  = bitmap-&gt;pitch;
237 
<a name="6" id="anc6"></a>
238 
<a name="7" id="anc7"></a><span class="line-removed">239       /* Render 3 separate monochrome bitmaps, shifting the outline  */</span>
<span class="line-removed">240       /* by 1/3 pixel.                                               */</span>
<span class="line-removed">241       width /= 3;</span>
242 
<a name="8" id="anc8"></a><span class="line-modified">243       bitmap-&gt;buffer += width;</span>

244 
<a name="9" id="anc9"></a>


245       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
246       if ( error )
247         goto Exit;
248 
<a name="10" id="anc10"></a><span class="line-removed">249       FT_Outline_Translate( outline, -21, 0 );</span>
<span class="line-removed">250       x_shift        -= 21;</span>
251       bitmap-&gt;buffer += width;
<a name="11" id="anc11"></a><span class="line-modified">252 </span>


253       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="12" id="anc12"></a>
254       if ( error )
255         goto Exit;
256 
<a name="13" id="anc13"></a><span class="line-modified">257       FT_Outline_Translate( outline,  42, 0 );</span>
<span class="line-modified">258       x_shift        += 42;</span>
<span class="line-modified">259       bitmap-&gt;buffer -= 2 * width;</span>
<span class="line-modified">260 </span>
261       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="14" id="anc14"></a>
262       if ( error )
263         goto Exit;
264 
<a name="15" id="anc15"></a>


265       /* XXX: Rearrange the bytes according to FT_PIXEL_MODE_LCD.    */
266       /* XXX: It is more efficient to render every third byte above. */
267 
268       if ( FT_ALLOC( temp, (FT_ULong)pitch ) )
269         goto Exit;
270 
271       for ( i = 0; i &lt; height; i++ )
272       {
273         line = bitmap-&gt;buffer + i * (FT_ULong)pitch;
274         for ( j = 0; j &lt; width; j++ )
275         {
276           temp[3 * j    ] = line[j];
277           temp[3 * j + 1] = line[j + width];
278           temp[3 * j + 2] = line[j + width + width];
279         }
280         FT_MEM_COPY( line, temp, pitch );
281       }
282 
283       FT_FREE( temp );
284     }
285     else if ( vmul )  /* lcd_v */
286     {
287       int  pitch  = bitmap-&gt;pitch;
288 
<a name="16" id="anc16"></a>

289 
<a name="17" id="anc17"></a><span class="line-modified">290       /* Render 3 separate monochrome bitmaps, shifting the outline  */</span>
<span class="line-modified">291       /* by 1/3 pixel. Triple the pitch to render on each third row. */</span>

292       bitmap-&gt;pitch *= 3;
293       bitmap-&gt;rows  /= 3;
294 
<a name="18" id="anc18"></a><span class="line-modified">295       bitmap-&gt;buffer += pitch;</span>
<span class="line-modified">296 </span>

297       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
298       if ( error )
299         goto Exit;
300 
<a name="19" id="anc19"></a><span class="line-removed">301       FT_Outline_Translate( outline, 0,  21 );</span>
<span class="line-removed">302       y_shift        += 21;</span>
303       bitmap-&gt;buffer += pitch;
<a name="20" id="anc20"></a><span class="line-modified">304 </span>


305       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="21" id="anc21"></a>
306       if ( error )
307         goto Exit;
308 
<a name="22" id="anc22"></a><span class="line-modified">309       FT_Outline_Translate( outline, 0, -42 );</span>
<span class="line-modified">310       y_shift        -= 42;</span>
<span class="line-modified">311       bitmap-&gt;buffer -= 2 * pitch;</span>
<span class="line-modified">312 </span>
313       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="23" id="anc23"></a>
314       if ( error )
315         goto Exit;
316 
<a name="24" id="anc24"></a>


317       bitmap-&gt;pitch /= 3;
318       bitmap-&gt;rows  *= 3;
319     }
320     else  /* grayscale */
321       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
322 
323 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
324 
325   Exit:
326     if ( !error )
327     {
328       /* everything is fine; the glyph is now officially a bitmap */
329       slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;
330     }
331     else if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
332     {
333       FT_FREE( bitmap-&gt;buffer );
334       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
335     }
336 
337     if ( x_shift || y_shift )
338       FT_Outline_Translate( outline, -x_shift, -y_shift );
339 
340     return error;
341   }
342 
343 
344   /* convert a slot&#39;s glyph image into a bitmap */
345   static FT_Error
346   ft_smooth_render( FT_Renderer       render,
347                     FT_GlyphSlot      slot,
348                     FT_Render_Mode    mode,
349                     const FT_Vector*  origin )
350   {
351     if ( mode == FT_RENDER_MODE_LIGHT )
352       mode = FT_RENDER_MODE_NORMAL;
353 
354     return ft_smooth_render_generic( render, slot, mode, origin,
355                                      FT_RENDER_MODE_NORMAL );
356   }
357 
358 
359   /* convert a slot&#39;s glyph image into a horizontal LCD bitmap */
360   static FT_Error
361   ft_smooth_render_lcd( FT_Renderer       render,
362                         FT_GlyphSlot      slot,
363                         FT_Render_Mode    mode,
364                         const FT_Vector*  origin )
365   {
366     return ft_smooth_render_generic( render, slot, mode, origin,
367                                      FT_RENDER_MODE_LCD );
368   }
369 
370 
371   /* convert a slot&#39;s glyph image into a vertical LCD bitmap */
372   static FT_Error
373   ft_smooth_render_lcd_v( FT_Renderer       render,
374                           FT_GlyphSlot      slot,
375                           FT_Render_Mode    mode,
376                           const FT_Vector*  origin )
377   {
378     return ft_smooth_render_generic( render, slot, mode, origin,
379                                      FT_RENDER_MODE_LCD_V );
380   }
381 
382 
383   FT_DEFINE_RENDERER(
384     ft_smooth_renderer_class,
385 
386       FT_MODULE_RENDERER,
387       sizeof ( FT_RendererRec ),
388 
389       &quot;smooth&quot;,
390       0x10000L,
391       0x20000L,
392 
393       NULL,    /* module specific interface */
394 
395       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
396       (FT_Module_Destructor) NULL,            /* module_done   */
397       (FT_Module_Requester)  NULL,            /* get_interface */
398 
399     FT_GLYPH_FORMAT_OUTLINE,
400 
401     (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
402     (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
403     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
404     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */
405 
<a name="25" id="anc25"></a><span class="line-modified">406     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET           /* raster_class    */</span>
407   )
408 
409 
410   FT_DEFINE_RENDERER(
411     ft_smooth_lcd_renderer_class,
412 
413       FT_MODULE_RENDERER,
414       sizeof ( FT_RendererRec ),
415 
416       &quot;smooth-lcd&quot;,
417       0x10000L,
418       0x20000L,
419 
420       NULL,    /* module specific interface */
421 
422       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
423       (FT_Module_Destructor) NULL,            /* module_done   */
424       (FT_Module_Requester)  NULL,            /* get_interface */
425 
426     FT_GLYPH_FORMAT_OUTLINE,
427 
428     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
429     (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
430     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
431     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */
432 
<a name="26" id="anc26"></a><span class="line-modified">433     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET            /* raster_class    */</span>
434   )
435 
436 
437   FT_DEFINE_RENDERER(
438     ft_smooth_lcdv_renderer_class,
439 
440       FT_MODULE_RENDERER,
441       sizeof ( FT_RendererRec ),
442 
443       &quot;smooth-lcdv&quot;,
444       0x10000L,
445       0x20000L,
446 
447       NULL,    /* module specific interface */
448 
449       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
450       (FT_Module_Destructor) NULL,            /* module_done   */
451       (FT_Module_Requester)  NULL,            /* get_interface */
452 
453     FT_GLYPH_FORMAT_OUTLINE,
454 
455     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
456     (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
457     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
458     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */
459 
<a name="27" id="anc27"></a><span class="line-modified">460     (FT_Raster_Funcs*)&amp;FT_GRAYS_RASTER_GET              /* raster_class    */</span>
461   )
462 
463 
464 /* END */
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfreetype/src/smooth/ftgrays.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../sfnt/ttsbit.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftgrays.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/smooth/ftgrays.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,96 +1,104 @@</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  ftgrays.c                                                              */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*    A new `perfect&#39; anti-aliasing renderer (body).                       */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  Copyright 2000-2018 by                                                 */</span>
<span class="udiff-line-modified-removed">- /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="udiff-line-modified-removed">- /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="udiff-line-modified-removed">- /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="udiff-line-modified-removed">- /*  this file you indicate that you have read the license and              */</span>
<span class="udiff-line-modified-removed">- /*  understand and accept it fully.                                        */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This file can be compiled without the rest of the FreeType engine, by */</span>
<span class="udiff-line-modified-removed">-   /* defining the STANDALONE_ macro when compiling it.  You also need to   */</span>
<span class="udiff-line-modified-removed">-   /* put the files `ftgrays.h&#39; and `ftimage.h&#39; into the current            */</span>
<span class="udiff-line-modified-removed">-   /* compilation directory.  Typically, you could do something like        */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - copy `src/smooth/ftgrays.c&#39; (this file) to your current directory   */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - copy `include/freetype/ftimage.h&#39; and `src/smooth/ftgrays.h&#39; to the */</span>
<span class="udiff-line-modified-removed">-   /*   same directory                                                      */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - compile `ftgrays&#39; with the STANDALONE_ macro defined, as in         */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*     cc -c -DSTANDALONE_ ftgrays.c                                     */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The renderer can be initialized with a call to                        */</span>
<span class="udiff-line-modified-removed">-   /* `ft_gray_raster.raster_new&#39;; an anti-aliased bitmap can be generated  */</span>
<span class="udiff-line-modified-removed">-   /* with a call to `ft_gray_raster.raster_render&#39;.                        */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* See the comments and documentation in the file `ftimage.h&#39; for more   */</span>
<span class="udiff-line-modified-removed">-   /* details on how the raster works.                                      */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This is a new anti-aliasing scan-converter for FreeType 2.  The       */</span>
<span class="udiff-line-modified-removed">-   /* algorithm used here is _very_ different from the one in the standard  */</span>
<span class="udiff-line-modified-removed">-   /* `ftraster&#39; module.  Actually, `ftgrays&#39; computes the _exact_          */</span>
<span class="udiff-line-modified-removed">-   /* coverage of the outline on each pixel cell.                           */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* It is based on ideas that I initially found in Raph Levien&#39;s          */</span>
<span class="udiff-line-modified-removed">-   /* excellent LibArt graphics library (see http://www.levien.com/libart   */</span>
<span class="udiff-line-modified-removed">-   /* for more information, though the web pages do not tell anything       */</span>
<span class="udiff-line-modified-removed">-   /* about the renderer; you&#39;ll have to dive into the source code to       */</span>
<span class="udiff-line-modified-removed">-   /* understand how it works).                                             */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Note, however, that this is a _very_ different implementation         */</span>
<span class="udiff-line-modified-removed">-   /* compared to Raph&#39;s.  Coverage information is stored in a very         */</span>
<span class="udiff-line-modified-removed">-   /* different way, and I don&#39;t use sorted vector paths.  Also, it doesn&#39;t */</span>
<span class="udiff-line-modified-removed">-   /* use floating point values.                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* This renderer has the following advantages:                           */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - It doesn&#39;t need an intermediate bitmap.  Instead, one can supply a  */</span>
<span class="udiff-line-modified-removed">-   /*   callback function that will be called by the renderer to draw gray  */</span>
<span class="udiff-line-modified-removed">-   /*   spans on any target surface.  You can thus do direct composition on */</span>
<span class="udiff-line-modified-removed">-   /*   any kind of bitmap, provided that you give the renderer the right   */</span>
<span class="udiff-line-modified-removed">-   /*   callback.                                                           */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */</span>
<span class="udiff-line-modified-removed">-   /*   each pixel cell.                                                    */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - It performs a single pass on the outline (the `standard&#39; FT2        */</span>
<span class="udiff-line-modified-removed">-   /*   renderer makes two passes).                                         */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - It can easily be modified to render to _any_ number of gray levels  */</span>
<span class="udiff-line-modified-removed">-   /*   cheaply.                                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* - For small (&lt; 20) pixel sizes, it is faster than the standard        */</span>
<span class="udiff-line-modified-removed">-   /*   renderer.                                                           */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="udiff-line-modified-removed">-   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="udiff-line-modified-removed">-   /* messages during execution.                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+ /****************************************************************************</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * ftgrays.c</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  *   A new `perfect&#39; anti-aliasing renderer (body).</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2000-2019 by</span>
<span class="udiff-line-modified-added">+  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * This file is part of the FreeType project, and may only be used,</span>
<span class="udiff-line-modified-added">+  * modified, and distributed under the terms of the FreeType project</span>
<span class="udiff-line-modified-added">+  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="udiff-line-modified-added">+  * this file you indicate that you have read the license and</span>
<span class="udiff-line-modified-added">+  * understand and accept it fully.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This file can be compiled without the rest of the FreeType engine, by</span>
<span class="udiff-line-modified-added">+    * defining the STANDALONE_ macro when compiling it.  You also need to</span>
<span class="udiff-line-modified-added">+    * put the files `ftgrays.h&#39; and `ftimage.h&#39; into the current</span>
<span class="udiff-line-modified-added">+    * compilation directory.  Typically, you could do something like</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - copy `src/smooth/ftgrays.c&#39; (this file) to your current directory</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - copy `include/freetype/ftimage.h&#39; and `src/smooth/ftgrays.h&#39; to the</span>
<span class="udiff-line-modified-added">+    *   same directory</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - compile `ftgrays&#39; with the STANDALONE_ macro defined, as in</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    *     cc -c -DSTANDALONE_ ftgrays.c</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The renderer can be initialized with a call to</span>
<span class="udiff-line-modified-added">+    * `ft_gray_raster.raster_new&#39;; an anti-aliased bitmap can be generated</span>
<span class="udiff-line-modified-added">+    * with a call to `ft_gray_raster.raster_render&#39;.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * See the comments and documentation in the file `ftimage.h&#39; for more</span>
<span class="udiff-line-modified-added">+    * details on how the raster works.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This is a new anti-aliasing scan-converter for FreeType 2.  The</span>
<span class="udiff-line-modified-added">+    * algorithm used here is _very_ different from the one in the standard</span>
<span class="udiff-line-modified-added">+    * `ftraster&#39; module.  Actually, `ftgrays&#39; computes the _exact_</span>
<span class="udiff-line-modified-added">+    * coverage of the outline on each pixel cell by straight segments.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * It is based on ideas that I initially found in Raph Levien&#39;s</span>
<span class="udiff-line-modified-added">+    * excellent LibArt graphics library (see https://www.levien.com/libart</span>
<span class="udiff-line-modified-added">+    * for more information, though the web pages do not tell anything</span>
<span class="udiff-line-modified-added">+    * about the renderer; you&#39;ll have to dive into the source code to</span>
<span class="udiff-line-modified-added">+    * understand how it works).</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Note, however, that this is a _very_ different implementation</span>
<span class="udiff-line-modified-added">+    * compared to Raph&#39;s.  Coverage information is stored in a very</span>
<span class="udiff-line-modified-added">+    * different way, and I don&#39;t use sorted vector paths.  Also, it doesn&#39;t</span>
<span class="udiff-line-modified-added">+    * use floating point values.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Bézier segments are flattened by splitting them until their deviation</span>
<span class="udiff-line-modified-added">+    * from straight line becomes much smaller than a pixel.  Therefore, the</span>
<span class="udiff-line-modified-added">+    * pixel coverage by a Bézier curve is calculated approximately.  To</span>
<span class="udiff-line-modified-added">+    * estimate the deviation, we use the distance from the control point</span>
<span class="udiff-line-modified-added">+    * to the conic chord centre or the cubic chord trisection.  These</span>
<span class="udiff-line-modified-added">+    * distances vanish fast after each split.  In the conic case, they vanish</span>
<span class="udiff-line-modified-added">+    * predictably and the number of necessary splits can be calculated.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * This renderer has the following advantages:</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - It doesn&#39;t need an intermediate bitmap.  Instead, one can supply a</span>
<span class="udiff-line-modified-added">+    *   callback function that will be called by the renderer to draw gray</span>
<span class="udiff-line-modified-added">+    *   spans on any target surface.  You can thus do direct composition on</span>
<span class="udiff-line-modified-added">+    *   any kind of bitmap, provided that you give the renderer the right</span>
<span class="udiff-line-modified-added">+    *   callback.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on</span>
<span class="udiff-line-modified-added">+    *   each pixel cell by straight segments.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - It performs a single pass on the outline (the `standard&#39; FT2</span>
<span class="udiff-line-modified-added">+    *   renderer makes two passes).</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - It can easily be modified to render to _any_ number of gray levels</span>
<span class="udiff-line-modified-added">+    *   cheaply.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * - For small (&lt; 80) pixel sizes, it is faster than the standard</span>
<span class="udiff-line-modified-added">+    *   renderer.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    */</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /**************************************************************************</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="udiff-line-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="udiff-line-added">+    * messages during execution.</span>
<span class="udiff-line-added">+    */</span>
  #undef  FT_COMPONENT
<span class="udiff-line-modified-removed">- #define FT_COMPONENT  trace_smooth</span>
<span class="udiff-line-modified-added">+ #define FT_COMPONENT  smooth</span>
  
  
  #ifdef STANDALONE_
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -110,13 +118,13 @@</span>
  #define FT_MAX( a, b )  ( (a) &gt; (b) ? (a) : (b) )
  #define FT_ABS( a )     ( (a) &lt; 0 ? -(a) : (a) )
  
  
    /*
<span class="udiff-line-modified-removed">-    *  Approximate sqrt(x*x+y*y) using the `alpha max plus beta min&#39;</span>
<span class="udiff-line-modified-removed">-    *  algorithm.  We use alpha = 1, beta = 3/8, giving us results with a</span>
<span class="udiff-line-modified-removed">-    *  largest error less than 7% compared to the exact value.</span>
<span class="udiff-line-modified-added">+    * Approximate sqrt(x*x+y*y) using the `alpha max plus beta min&#39;</span>
<span class="udiff-line-modified-added">+    * algorithm.  We use alpha = 1, beta = 3/8, giving us results with a</span>
<span class="udiff-line-modified-added">+    * largest error less than 7% compared to the exact value.</span>
     */
  #define FT_HYPOT( x, y )                 \
            ( x = FT_ABS( x ),             \
              y = FT_ABS( y ),             \
              x &gt; y ? x + ( 3 * y &gt;&gt; 3 )   \
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -220,14 +228,14 @@</span>
  #ifndef FT_ERROR
  #define FT_ERROR( varformat )   FT_Message varformat
  #endif
  
  #define FT_THROW( e )                               \
<span class="udiff-line-modified-removed">-           ( FT_Throw( FT_ERR_CAT( ErrRaster, e ),   \</span>
<span class="udiff-line-modified-added">+           ( FT_Throw( FT_ERR_CAT( ErrRaster_, e ),  \</span>
                        __LINE__,                     \
                        __FILE__ )                  | \
<span class="udiff-line-modified-removed">-             FT_ERR_CAT( ErrRaster, e )            )</span>
<span class="udiff-line-modified-added">+             FT_ERR_CAT( ErrRaster_, e )           )</span>
  
  #else /* !FT_DEBUG_LEVEL_TRACE */
  
  #define FT_TRACE5( x )  do { } while ( 0 )     /* nothing */
  #define FT_TRACE7( x )  do { } while ( 0 )     /* nothing */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -277,12 +285,10 @@</span>
  #include FT_INTERNAL_CALC_H
  #include FT_OUTLINE_H
  
  #include &quot;ftsmerrs.h&quot;
  
<span class="udiff-line-removed">- #include &quot;ftspic.h&quot;</span>
<span class="udiff-line-removed">- </span>
  #define Smooth_Err_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph
  #define Smooth_Err_Memory_Overflow  Smooth_Err_Out_Of_Memory
  #define ErrRaster_Memory_Overflow   Smooth_Err_Out_Of_Memory
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -327,21 +333,13 @@</span>
  
  
    /* must be at least 6 bits! */
  #define PIXEL_BITS  8
  
<span class="udiff-line-removed">- #undef FLOOR</span>
<span class="udiff-line-removed">- #undef CEILING</span>
<span class="udiff-line-removed">- #undef TRUNC</span>
<span class="udiff-line-removed">- #undef SCALED</span>
<span class="udiff-line-removed">- </span>
  #define ONE_PIXEL       ( 1 &lt;&lt; PIXEL_BITS )
<span class="udiff-line-modified-removed">- #define TRUNC( x )      ( (TCoord)( (x) &gt;&gt; PIXEL_BITS ) )</span>
<span class="udiff-line-modified-removed">- #define SUBPIXELS( x )  ( (TPos)(x) * ONE_PIXEL )</span>
<span class="udiff-line-removed">- #define FLOOR( x )      ( (x) &amp; -ONE_PIXEL )</span>
<span class="udiff-line-removed">- #define CEILING( x )    ( ( (x) + ONE_PIXEL - 1 ) &amp; -ONE_PIXEL )</span>
<span class="udiff-line-removed">- #define ROUND( x )      ( ( (x) + ONE_PIXEL / 2 ) &amp; -ONE_PIXEL )</span>
<span class="udiff-line-modified-added">+ #define TRUNC( x )      (TCoord)( (x) &gt;&gt; PIXEL_BITS )</span>
<span class="udiff-line-modified-added">+ #define FRACT( x )      (TCoord)( (x) &amp; ( ONE_PIXEL - 1 ) )</span>
  
  #if PIXEL_BITS &gt;= 6
  #define UPSCALE( x )    ( (x) * ( ONE_PIXEL &gt;&gt; 6 ) )
  #define DOWNSCALE( x )  ( (x) &gt;&gt; ( PIXEL_BITS - 6 ) )
  #else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,19 +386,19 @@</span>
    /* These macros speed up repetitive divisions by replacing them */
    /* with multiplications and right shifts.                       */
  #define FT_UDIVPREP( c, b )                                        \
    long  b ## _r = c ? (long)( FT_ULONG_MAX &gt;&gt; PIXEL_BITS ) / ( b ) \
                      : 0
<span class="udiff-line-modified-removed">- #define FT_UDIV( a, b )                                        \</span>
<span class="udiff-line-modified-removed">-   ( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) &gt;&gt;   \</span>
<span class="udiff-line-modified-removed">-     ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )</span>
<span class="udiff-line-modified-added">+ #define FT_UDIV( a, b )                                                \</span>
<span class="udiff-line-modified-added">+   (TCoord)( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) &gt;&gt;   \</span>
<span class="udiff-line-modified-added">+             ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )</span>
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*   TYPE DEFINITIONS                                                    */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * TYPE DEFINITIONS</span>
<span class="udiff-line-modified-added">+    */</span>
  
    /* don&#39;t change the following types to FT_Int or FT_Pos, since we might */
    /* need to define them to &quot;float&quot; or &quot;double&quot; when experimenting with   */
    /* new algorithms                                                       */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -432,10 +430,13 @@</span>
  #define FT_MAX_GRAY_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( TCell ) )
  #else
  #define FT_MAX_GRAY_POOL  ( 2048 / sizeof ( TCell ) )
  #endif
  
<span class="udiff-line-added">+   /* FT_Span buffer size for direct rendering only */</span>
<span class="udiff-line-added">+ #define FT_MAX_GRAY_SPANS  10</span>
<span class="udiff-line-added">+ </span>
  
  #if defined( _MSC_VER )      /* Visual C++ (and Intel C++) */
    /* We disable the warning `structure was padded due to   */
    /* __declspec(align())&#39; in order to compile cleanly with */
    /* the maximum level of warnings.                        */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -465,10 +466,12 @@</span>
      FT_Outline  outline;
      TPixmap     target;
  
      FT_Raster_Span_Func  render_span;
      void*                render_span_data;
<span class="udiff-line-added">+     FT_Span              spans[FT_MAX_GRAY_SPANS];</span>
<span class="udiff-line-added">+     int                  num_spans;</span>
  
    } gray_TWorker, *gray_PWorker;
  
  #if defined( _MSC_VER )
  #pragma warning( pop )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -514,26 +517,25 @@</span>
    }
  
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Record the current cell in the table.                                 */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Record the current cell in the linked list.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    gray_record_cell( RAS_ARG )
    {
      PCell  *pcell, cell;
      TCoord  x = ras.ex;
  
  
      pcell = &amp;ras.ycells[ras.ey - ras.min_ey];
<span class="udiff-line-modified-removed">-     for (;;)</span>
<span class="udiff-line-modified-added">+     while ( ( cell = *pcell ) )</span>
      {
<span class="udiff-line-modified-removed">-       cell = *pcell;</span>
<span class="udiff-line-removed">-       if ( !cell || cell-&gt;x &gt; x )</span>
<span class="udiff-line-modified-added">+       if ( cell-&gt;x &gt; x )</span>
          break;
  
        if ( cell-&gt;x == x )
          goto Found;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -559,14 +561,14 @@</span>
      cell-&gt;area  += ras.area;
      cell-&gt;cover += ras.cover;
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Set the current cell to a new position.                               */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Set the current cell to a new position.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    gray_set_cell( RAS_ARG_ TCoord  ex,
                            TCoord  ey )
    {
      /* Move the cell pointer to a new position.  We set the `invalid&#39;      */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -577,33 +579,30 @@</span>
      /* . the new horizontal position must be strictly less than max_ex     */
      /*                                                                     */
      /* Note that if a cell is to the left of the clipping region, it is    */
      /* actually set to the (min_ex-1) horizontal position.                 */
  
<span class="udiff-line-removed">-     if ( ex &lt; ras.min_ex )</span>
<span class="udiff-line-removed">-       ex = ras.min_ex - 1;</span>
<span class="udiff-line-removed">- </span>
      /* record the current one if it is valid and substantial */
      if ( !ras.invalid &amp;&amp; ( ras.area || ras.cover ) )
        gray_record_cell( RAS_VAR );
  
      ras.area  = 0;
      ras.cover = 0;
<span class="udiff-line-modified-removed">-     ras.ex    = ex;</span>
<span class="udiff-line-modified-added">+     ras.ex    = FT_MAX( ex, ras.min_ex - 1 );</span>
      ras.ey    = ey;
  
      ras.invalid = ( ey &gt;= ras.max_ey || ey &lt; ras.min_ey ||
                      ex &gt;= ras.max_ex );
    }
  
  
  #ifndef FT_LONG64
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Render a scanline as one or more cells.                               */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Render a scanline as one or more cells.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    gray_render_scanline( RAS_ARG_ TCoord  ey,
                                   TPos    x1,
                                   TCoord  y1,
                                   TPos    x2,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -622,12 +621,12 @@</span>
      {
        gray_set_cell( RAS_VAR_ ex2, ey );
        return;
      }
  
<span class="udiff-line-modified-removed">-     fx1   = (TCoord)( x1 - SUBPIXELS( ex1 ) );</span>
<span class="udiff-line-modified-removed">-     fx2   = (TCoord)( x2 - SUBPIXELS( ex2 ) );</span>
<span class="udiff-line-modified-added">+     fx1   = FRACT( x1 );</span>
<span class="udiff-line-modified-added">+     fx2   = FRACT( x2 );</span>
  
      /* everything is located in a single cell.  That is easy! */
      /*                                                        */
      if ( ex1 == ex2 )
        goto End;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,10 +649,13 @@</span>
        first = 0;
        incr  = -1;
        dx    = -dx;
      }
  
<span class="udiff-line-added">+     /* the fractional part of y-delta is mod/dx. It is essential to */</span>
<span class="udiff-line-added">+     /* keep track of its accumulation for accurate rendering.       */</span>
<span class="udiff-line-added">+     /* XXX: y-delta and x-delta below should be related.            */</span>
      FT_DIV_MOD( TCoord, p, dx, delta, mod );
  
      ras.area  += (TArea)( ( fx1 + first ) * delta );
      ras.cover += delta;
      y1        += delta;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -694,14 +696,14 @@</span>
      ras.area  += (TArea)( ( fx1 + fx2 ) * dy );
      ras.cover += dy;
    }
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Render a given line as a series of scanlines.                         */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Render a given line as a series of scanlines.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
      TCoord  ey1, ey2, fy1, fy2, first, delta, mod;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -715,12 +717,12 @@</span>
      /* perform vertical clipping */
      if ( ( ey1 &gt;= ras.max_ey &amp;&amp; ey2 &gt;= ras.max_ey ) ||
           ( ey1 &lt;  ras.min_ey &amp;&amp; ey2 &lt;  ras.min_ey ) )
        goto End;
  
<span class="udiff-line-modified-removed">-     fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );</span>
<span class="udiff-line-modified-removed">-     fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );</span>
<span class="udiff-line-modified-added">+     fy1 = FRACT( ras.y );</span>
<span class="udiff-line-modified-added">+     fy2 = FRACT( to_y );</span>
  
      /* everything is on a single scanline */
      if ( ey1 == ey2 )
      {
        gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, to_x, fy2 );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,11 +734,11 @@</span>
  
      /* vertical line - avoid calling gray_render_scanline */
      if ( dx == 0 )
      {
        TCoord  ex     = TRUNC( ras.x );
<span class="udiff-line-modified-removed">-       TCoord  two_fx = (TCoord)( ( ras.x - SUBPIXELS( ex ) ) &lt;&lt; 1 );</span>
<span class="udiff-line-modified-added">+       TCoord  two_fx = FRACT( ras.x ) &lt;&lt; 1;</span>
        TArea   area;
  
  
        if ( dy &gt; 0)
        {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -787,10 +789,12 @@</span>
        first = 0;
        incr  = -1;
        dy    = -dy;
      }
  
<span class="udiff-line-added">+     /* the fractional part of x-delta is mod/dy. It is essential to */</span>
<span class="udiff-line-added">+     /* keep track of its accumulation for accurate rendering.       */</span>
      FT_DIV_MOD( TCoord, p, dy, delta, mod );
  
      x = ras.x + delta;
      gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, x, first );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -835,20 +839,21 @@</span>
      ras.y       = to_y;
    }
  
  #else
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* Render a straight line across multiple cells in any direction.        */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * Render a straight line across multiple cells in any direction.</span>
<span class="udiff-line-modified-added">+    */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
<span class="udiff-line-modified-removed">-     TPos    dx, dy, fx1, fy1, fx2, fy2;</span>
<span class="udiff-line-modified-removed">-     TCoord  ex1, ex2, ey1, ey2;</span>
<span class="udiff-line-modified-added">+     TPos    dx, dy;</span>
<span class="udiff-line-modified-added">+     TCoord  fx1, fy1, fx2, fy2;</span>
<span class="udiff-line-added">+     TCoord  ex1, ey1, ex2, ey2;</span>
  
  
      ey1 = TRUNC( ras.y );
      ey2 = TRUNC( to_y );
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -858,22 +863,22 @@</span>
        goto End;
  
      ex1 = TRUNC( ras.x );
      ex2 = TRUNC( to_x );
  
<span class="udiff-line-modified-removed">-     fx1 = ras.x - SUBPIXELS( ex1 );</span>
<span class="udiff-line-modified-removed">-     fy1 = ras.y - SUBPIXELS( ey1 );</span>
<span class="udiff-line-modified-added">+     fx1 = FRACT( ras.x );</span>
<span class="udiff-line-modified-added">+     fy1 = FRACT( ras.y );</span>
  
      dx = to_x - ras.x;
      dy = to_y - ras.y;
  
      if ( ex1 == ex2 &amp;&amp; ey1 == ey2 )       /* inside one cell */
        ;
      else if ( dy == 0 ) /* ex1 != ex2 */  /* any horizontal line */
      {
<span class="udiff-line-modified-removed">-       ex1 = ex2;</span>
<span class="udiff-line-modified-removed">-       gray_set_cell( RAS_VAR_ ex1, ey1 );</span>
<span class="udiff-line-modified-added">+       gray_set_cell( RAS_VAR_ ex2, ey2 );</span>
<span class="udiff-line-modified-added">+       goto End;</span>
      }
      else if ( dx == 0 )
      {
        if ( dy &gt; 0 )                       /* vertical line up */
          do
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -896,11 +901,11 @@</span>
            gray_set_cell( RAS_VAR_ ex1, ey1 );
          } while ( ey1 != ey2 );
      }
      else                                  /* any other line */
      {
<span class="udiff-line-modified-removed">-       TPos  prod = dx * fy1 - dy * fx1;</span>
<span class="udiff-line-modified-added">+       TPos  prod = dx * (TPos)fy1 - dy * (TPos)fx1;</span>
        FT_UDIVPREP( ex1 != ex2, dx );
        FT_UDIVPREP( ey1 != ey2, dy );
  
  
        /* The fundamental value `prod&#39; determines which side and the  */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -910,11 +915,11 @@</span>
        {
          if      ( prod                                   &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL                  &gt;  0 ) /* left */
          {
            fx2 = 0;
<span class="udiff-line-modified-removed">-           fy2 = (TPos)FT_UDIV( -prod, -dx );</span>
<span class="udiff-line-modified-added">+           fy2 = FT_UDIV( -prod, -dx );</span>
            prod -= dy * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = ONE_PIXEL;
            fy1 = fy2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -922,11 +927,11 @@</span>
          }
          else if ( prod - dx * ONE_PIXEL                  &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL + dy * ONE_PIXEL &gt;  0 ) /* up */
          {
            prod -= dx * ONE_PIXEL;
<span class="udiff-line-modified-removed">-           fx2 = (TPos)FT_UDIV( -prod, dy );</span>
<span class="udiff-line-modified-added">+           fx2 = FT_UDIV( -prod, dy );</span>
            fy2 = ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
            fy1 = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -935,21 +940,21 @@</span>
          else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL &lt;= 0 &amp;&amp;
                    prod                  + dy * ONE_PIXEL &gt;= 0 ) /* right */
          {
            prod += dy * ONE_PIXEL;
            fx2 = ONE_PIXEL;
<span class="udiff-line-modified-removed">-           fy2 = (TPos)FT_UDIV( prod, dx );</span>
<span class="udiff-line-modified-added">+           fy2 = FT_UDIV( prod, dx );</span>
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = 0;
            fy1 = fy2;
            ex1++;
          }
          else /* ( prod                  + dy * ONE_PIXEL &lt;  0 &amp;&amp;
                    prod                                   &gt;  0 )    down */
          {
<span class="udiff-line-modified-removed">-           fx2 = (TPos)FT_UDIV( prod, -dy );</span>
<span class="udiff-line-modified-added">+           fx2 = FT_UDIV( prod, -dy );</span>
            fy2 = 0;
            prod += dx * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -959,12 +964,12 @@</span>
  
          gray_set_cell( RAS_VAR_ ex1, ey1 );
        } while ( ex1 != ex2 || ey1 != ey2 );
      }
  
<span class="udiff-line-modified-removed">-     fx2 = to_x - SUBPIXELS( ex2 );</span>
<span class="udiff-line-modified-removed">-     fy2 = to_y - SUBPIXELS( ey2 );</span>
<span class="udiff-line-modified-added">+     fx2 = FRACT( to_x );</span>
<span class="udiff-line-modified-added">+     fy2 = FRACT( to_y );</span>
  
      ras.cover += ( fy2 - fy1 );
      ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
  
    End:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -979,20 +984,22 @@</span>
    {
      TPos  a, b;
  
  
      base[4].x = base[2].x;
<span class="udiff-line-modified-removed">-     b = base[1].x;</span>
<span class="udiff-line-modified-removed">-     a = base[3].x = ( base[2].x + b ) / 2;</span>
<span class="udiff-line-modified-removed">-     b = base[1].x = ( base[0].x + b ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[2].x = ( a + b ) / 2;</span>
<span class="udiff-line-modified-added">+     a = base[0].x + base[1].x;</span>
<span class="udiff-line-modified-added">+     b = base[1].x + base[2].x;</span>
<span class="udiff-line-modified-added">+     base[3].x = b &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     base[2].x = ( a + b ) &gt;&gt; 2;</span>
<span class="udiff-line-added">+     base[1].x = a &gt;&gt; 1;</span>
  
      base[4].y = base[2].y;
<span class="udiff-line-modified-removed">-     b = base[1].y;</span>
<span class="udiff-line-modified-removed">-     a = base[3].y = ( base[2].y + b ) / 2;</span>
<span class="udiff-line-modified-removed">-     b = base[1].y = ( base[0].y + b ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[2].y = ( a + b ) / 2;</span>
<span class="udiff-line-modified-added">+     a = base[0].y + base[1].y;</span>
<span class="udiff-line-modified-added">+     b = base[1].y + base[2].y;</span>
<span class="udiff-line-modified-added">+     base[3].y = b &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     base[2].y = ( a + b ) &gt;&gt; 2;</span>
<span class="udiff-line-added">+     base[1].y = a &gt;&gt; 1;</span>
    }
  
  
    static void
    gray_render_conic( RAS_ARG_ const FT_Vector*  control,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1042,16 +1049,15 @@</span>
      /* We use decrement counter to count the total number of segments */
      /* to draw starting from 2^level. Before each draw we split as    */
      /* many times as there are trailing zeros in the counter.         */
      do
      {
<span class="udiff-line-modified-removed">-       split = 1;</span>
<span class="udiff-line-modified-removed">-       while ( ( draw &amp; split ) == 0 )</span>
<span class="udiff-line-modified-added">+       split = draw &amp; ( -draw );  /* isolate the rightmost 1-bit */</span>
<span class="udiff-line-modified-added">+       while ( ( split &gt;&gt;= 1 ) )</span>
        {
          gray_split_conic( arc );
          arc += 2;
<span class="udiff-line-removed">-         split &lt;&lt;= 1;</span>
        }
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
        arc -= 2;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1060,45 +1066,46 @@</span>
  
  
    static void
    gray_split_cubic( FT_Vector*  base )
    {
<span class="udiff-line-modified-removed">-     TPos  a, b, c, d;</span>
<span class="udiff-line-modified-added">+     TPos  a, b, c;</span>
  
  
      base[6].x = base[3].x;
<span class="udiff-line-modified-removed">-     c = base[1].x;</span>
<span class="udiff-line-modified-removed">-     d = base[2].x;</span>
<span class="udiff-line-modified-removed">-     base[1].x = a = ( base[0].x + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[5].x = b = ( base[3].x + d ) / 2;</span>
<span class="udiff-line-modified-removed">-     c = ( c + d ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[2].x = a = ( a + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[4].x = b = ( b + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[3].x = ( a + b ) / 2;</span>
<span class="udiff-line-modified-added">+     a = base[0].x + base[1].x;</span>
<span class="udiff-line-modified-added">+     b = base[1].x + base[2].x;</span>
<span class="udiff-line-modified-added">+     c = base[2].x + base[3].x;</span>
<span class="udiff-line-modified-added">+     base[5].x = c &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     c += b;</span>
<span class="udiff-line-modified-added">+     base[4].x = c &gt;&gt; 2;</span>
<span class="udiff-line-modified-added">+     base[1].x = a &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     a += b;</span>
<span class="udiff-line-added">+     base[2].x = a &gt;&gt; 2;</span>
<span class="udiff-line-added">+     base[3].x = ( a + c ) &gt;&gt; 3;</span>
  
      base[6].y = base[3].y;
<span class="udiff-line-modified-removed">-     c = base[1].y;</span>
<span class="udiff-line-modified-removed">-     d = base[2].y;</span>
<span class="udiff-line-modified-removed">-     base[1].y = a = ( base[0].y + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[5].y = b = ( base[3].y + d ) / 2;</span>
<span class="udiff-line-modified-removed">-     c = ( c + d ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[2].y = a = ( a + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[4].y = b = ( b + c ) / 2;</span>
<span class="udiff-line-modified-removed">-     base[3].y = ( a + b ) / 2;</span>
<span class="udiff-line-modified-added">+     a = base[0].y + base[1].y;</span>
<span class="udiff-line-modified-added">+     b = base[1].y + base[2].y;</span>
<span class="udiff-line-modified-added">+     c = base[2].y + base[3].y;</span>
<span class="udiff-line-modified-added">+     base[5].y = c &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     c += b;</span>
<span class="udiff-line-modified-added">+     base[4].y = c &gt;&gt; 2;</span>
<span class="udiff-line-modified-added">+     base[1].y = a &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     a += b;</span>
<span class="udiff-line-added">+     base[2].y = a &gt;&gt; 2;</span>
<span class="udiff-line-added">+     base[3].y = ( a + c ) &gt;&gt; 3;</span>
    }
  
  
    static void
    gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,
                                const FT_Vector*  control2,
                                const FT_Vector*  to )
    {
      FT_Vector   bez_stack[16 * 3 + 1];  /* enough to accommodate bisections */
      FT_Vector*  arc = bez_stack;
<span class="udiff-line-removed">-     TPos        dx, dy, dx_, dy_;</span>
<span class="udiff-line-removed">-     TPos        dx1, dy1, dx2, dy2;</span>
<span class="udiff-line-removed">-     TPos        L, s, s_limit;</span>
  
  
      arc[0].x = UPSCALE( to-&gt;x );
      arc[0].y = UPSCALE( to-&gt;y );
      arc[1].x = UPSCALE( control2-&gt;x );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1123,49 +1130,17 @@</span>
        return;
      }
  
      for (;;)
      {
<span class="udiff-line-modified-removed">-       /* Decide whether to split or draw. See `Rapid Termination          */</span>
<span class="udiff-line-modified-removed">-       /* Evaluation for Recursive Subdivision of Bezier Curves&#39; by Thomas */</span>
<span class="udiff-line-modified-removed">-       /* F. Hain, at                                                      */</span>
<span class="udiff-line-modified-removed">-       /* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       /* dx and dy are x and y components of the P0-P3 chord vector. */</span>
<span class="udiff-line-modified-removed">-       dx = dx_ = arc[3].x - arc[0].x;</span>
<span class="udiff-line-removed">-       dy = dy_ = arc[3].y - arc[0].y;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       L = FT_HYPOT( dx_, dy_ );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* Avoid possible arithmetic overflow below by splitting. */</span>
<span class="udiff-line-removed">-       if ( L &gt; 32767 )</span>
<span class="udiff-line-removed">-         goto Split;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* Max deviation may be as much as (s/L) * 3/4 (if Hain&#39;s v = 1). */</span>
<span class="udiff-line-removed">-       s_limit = L * (TPos)( ONE_PIXEL / 6 );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* s is L * the perpendicular distance from P1 to the line P0-P3. */</span>
<span class="udiff-line-removed">-       dx1 = arc[1].x - arc[0].x;</span>
<span class="udiff-line-removed">-       dy1 = arc[1].y - arc[0].y;</span>
<span class="udiff-line-removed">-       s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx1 ), MUL_LONG( dx, dy1 ) ) );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if ( s &gt; s_limit )</span>
<span class="udiff-line-removed">-         goto Split;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* s is L * the perpendicular distance from P2 to the line P0-P3. */</span>
<span class="udiff-line-removed">-       dx2 = arc[2].x - arc[0].x;</span>
<span class="udiff-line-removed">-       dy2 = arc[2].y - arc[0].y;</span>
<span class="udiff-line-removed">-       s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx2 ), MUL_LONG( dx, dy2 ) ) );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       if ( s &gt; s_limit )</span>
<span class="udiff-line-removed">-         goto Split;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       /* Split super curvy segments where the off points are so far</span>
<span class="udiff-line-removed">-          from the chord that the angles P0-P1-P3 or P0-P2-P3 become</span>
<span class="udiff-line-removed">-          acute as detected by appropriate dot products. */</span>
<span class="udiff-line-removed">-       if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) &gt; 0 ||</span>
<span class="udiff-line-removed">-            dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) &gt; 0 )</span>
<span class="udiff-line-modified-added">+       /* with each split, control points quickly converge towards  */</span>
<span class="udiff-line-modified-added">+       /* chord trisection points and the vanishing distances below */</span>
<span class="udiff-line-modified-added">+       /* indicate when the segment is flat enough to draw          */</span>
<span class="udiff-line-modified-added">+       if ( FT_ABS( 2 * arc[0].x - 3 * arc[1].x + arc[3].x ) &gt; ONE_PIXEL / 2 ||</span>
<span class="udiff-line-modified-added">+            FT_ABS( 2 * arc[0].y - 3 * arc[1].y + arc[3].y ) &gt; ONE_PIXEL / 2 ||</span>
<span class="udiff-line-modified-added">+            FT_ABS( arc[0].x - 3 * arc[2].x + 2 * arc[3].x ) &gt; ONE_PIXEL / 2 ||</span>
<span class="udiff-line-modified-added">+            FT_ABS( arc[0].y - 3 * arc[2].y + 2 * arc[3].y ) &gt; ONE_PIXEL / 2 )</span>
          goto Split;
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
  
        if ( arc == bez_stack )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1236,38 +1211,43 @@</span>
                         TArea   coverage,
                         TCoord  acount )
    {
      /* scale the coverage from 0..(ONE_PIXEL*ONE_PIXEL*2) to 0..256  */
      coverage &gt;&gt;= PIXEL_BITS * 2 + 1 - 8;
<span class="udiff-line-removed">-     if ( coverage &lt; 0 )</span>
<span class="udiff-line-removed">-       coverage = -coverage - 1;</span>
  
      /* compute the line&#39;s coverage depending on the outline fill rule */
      if ( ras.outline.flags &amp; FT_OUTLINE_EVEN_ODD_FILL )
      {
        coverage &amp;= 511;
  
        if ( coverage &gt;= 256 )
          coverage = 511 - coverage;
      }
<span class="udiff-line-modified-removed">-     else</span>
<span class="udiff-line-modified-added">+     else  /* default non-zero winding rule */</span>
      {
<span class="udiff-line-modified-removed">-       /* normal non-zero winding rule */</span>
<span class="udiff-line-modified-added">+       if ( coverage &lt; 0 )</span>
<span class="udiff-line-added">+         coverage = ~coverage;  /* the same as -coverage - 1 */</span>
<span class="udiff-line-added">+ </span>
        if ( coverage &gt;= 256 )
          coverage = 255;
      }
  
<span class="udiff-line-modified-removed">-     if ( ras.render_span )  /* for FT_RASTER_FLAG_DIRECT only */</span>
<span class="udiff-line-modified-added">+     if ( ras.num_spans &gt;= 0 )  /* for FT_RASTER_FLAG_DIRECT only */</span>
      {
<span class="udiff-line-modified-removed">-       FT_Span  span;</span>
<span class="udiff-line-modified-added">+       FT_Span*  span = ras.spans + ras.num_spans++;</span>
  
  
<span class="udiff-line-modified-removed">-       span.x        = (short)x;</span>
<span class="udiff-line-modified-removed">-       span.len      = (unsigned short)acount;</span>
<span class="udiff-line-modified-removed">-       span.coverage = (unsigned char)coverage;</span>
<span class="udiff-line-modified-added">+       span-&gt;x        = (short)x;</span>
<span class="udiff-line-modified-added">+       span-&gt;len      = (unsigned short)acount;</span>
<span class="udiff-line-modified-added">+       span-&gt;coverage = (unsigned char)coverage;</span>
  
<span class="udiff-line-modified-removed">-       ras.render_span( y, 1, &amp;span, ras.render_span_data );</span>
<span class="udiff-line-modified-added">+       if ( ras.num_spans == FT_MAX_GRAY_SPANS )</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         /* flush the span buffer and reset the count */</span>
<span class="udiff-line-added">+         ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );</span>
<span class="udiff-line-added">+         ras.num_spans = 0;</span>
<span class="udiff-line-added">+       }</span>
      }
      else
      {
        unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;
        unsigned char   c = (unsigned char)coverage;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1277,18 +1257,33 @@</span>
         * calling `memset&#39;.  This is mainly due to the cost of the
         * function call.
         */
        switch ( acount )
        {
<span class="udiff-line-modified-removed">-       case 7: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 6: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 5: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 4: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 3: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 2: *q++ = c;</span>
<span class="udiff-line-modified-removed">-       case 1: *q   = c;</span>
<span class="udiff-line-modified-removed">-       case 0: break;</span>
<span class="udiff-line-modified-added">+       case 7:</span>
<span class="udiff-line-modified-added">+         *q++ = c;</span>
<span class="udiff-line-modified-added">+         /* fall through */</span>
<span class="udiff-line-modified-added">+       case 6:</span>
<span class="udiff-line-modified-added">+         *q++ = c;</span>
<span class="udiff-line-modified-added">+         /* fall through */</span>
<span class="udiff-line-modified-added">+       case 5:</span>
<span class="udiff-line-modified-added">+         *q++ = c;</span>
<span class="udiff-line-added">+         /* fall through */</span>
<span class="udiff-line-added">+       case 4:</span>
<span class="udiff-line-added">+         *q++ = c;</span>
<span class="udiff-line-added">+         /* fall through */</span>
<span class="udiff-line-added">+       case 3:</span>
<span class="udiff-line-added">+         *q++ = c;</span>
<span class="udiff-line-added">+         /* fall through */</span>
<span class="udiff-line-added">+       case 2:</span>
<span class="udiff-line-added">+         *q++ = c;</span>
<span class="udiff-line-added">+         /* fall through */</span>
<span class="udiff-line-added">+       case 1:</span>
<span class="udiff-line-added">+         *q = c;</span>
<span class="udiff-line-added">+         /* fall through */</span>
<span class="udiff-line-added">+       case 0:</span>
<span class="udiff-line-added">+         break;</span>
        default:
          FT_MEM_SET( q, c, acount );
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1322,57 +1317,67 @@</span>
          x = cell-&gt;x + 1;
        }
  
        if ( cover != 0 )
          gray_hline( RAS_VAR_ x, y, cover, ras.max_ex - x );
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       if ( ras.num_spans &gt; 0 )  /* for FT_RASTER_FLAG_DIRECT only */</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         /* flush the span buffer and reset the count */</span>
<span class="udiff-line-added">+         ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );</span>
<span class="udiff-line-added">+         ras.num_spans = 0;</span>
<span class="udiff-line-added">+       }</span>
      }
    }
  
  
  #ifdef STANDALONE_
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*  The following functions should only compile in stand-alone mode,     */</span>
<span class="udiff-line-modified-removed">-   /*  i.e., when building this component without the rest of FreeType.     */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* &lt;Function&gt;                                                            */</span>
<span class="udiff-line-modified-removed">-   /*    FT_Outline_Decompose                                               */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* &lt;Description&gt;                                                         */</span>
<span class="udiff-line-modified-removed">-   /*    Walk over an outline&#39;s structure to decompose it into individual   */</span>
<span class="udiff-line-modified-removed">-   /*    segments and Bézier arcs.  This function is also able to emit      */</span>
<span class="udiff-line-modified-removed">-   /*    `move to&#39; and `close to&#39; operations to indicate the start and end  */</span>
<span class="udiff-line-modified-removed">-   /*    of new contours in the outline.                                    */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* &lt;Input&gt;                                                               */</span>
<span class="udiff-line-modified-removed">-   /*    outline        :: A pointer to the source target.                  */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /*    func_interface :: A table of `emitters&#39;, i.e., function pointers   */</span>
<span class="udiff-line-modified-removed">-   /*                      called during decomposition to indicate path     */</span>
<span class="udiff-line-modified-removed">-   /*                      operations.                                      */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* &lt;InOut&gt;                                                               */</span>
<span class="udiff-line-modified-removed">-   /*    user           :: A typeless pointer which is passed to each       */</span>
<span class="udiff-line-modified-removed">-   /*                      emitter during the decomposition.  It can be     */</span>
<span class="udiff-line-modified-removed">-   /*                      used to store the state during the               */</span>
<span class="udiff-line-modified-removed">-   /*                      decomposition.                                   */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* &lt;Return&gt;                                                              */</span>
<span class="udiff-line-modified-removed">-   /*    Error code.  0 means success.                                      */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The following functions should only compile in stand-alone mode,</span>
<span class="udiff-line-modified-added">+    * i.e., when building this component without the rest of FreeType.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    */</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * @Function:</span>
<span class="udiff-line-modified-added">+    *   FT_Outline_Decompose</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * @Description:</span>
<span class="udiff-line-modified-added">+    *   Walk over an outline&#39;s structure to decompose it into individual</span>
<span class="udiff-line-modified-added">+    *   segments and Bézier arcs.  This function is also able to emit</span>
<span class="udiff-line-modified-added">+    *   `move to&#39; and `close to&#39; operations to indicate the start and end</span>
<span class="udiff-line-modified-added">+    *   of new contours in the outline.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * @Input:</span>
<span class="udiff-line-modified-added">+    *   outline ::</span>
<span class="udiff-line-modified-added">+    *     A pointer to the source target.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    *   func_interface ::</span>
<span class="udiff-line-modified-added">+    *     A table of `emitters&#39;, i.e., function pointers</span>
<span class="udiff-line-modified-added">+    *     called during decomposition to indicate path</span>
<span class="udiff-line-modified-added">+    *     operations.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * @InOut:</span>
<span class="udiff-line-modified-added">+    *   user ::</span>
<span class="udiff-line-modified-added">+    *     A typeless pointer which is passed to each</span>
<span class="udiff-line-modified-added">+    *     emitter during the decomposition.  It can be</span>
<span class="udiff-line-modified-added">+    *     used to store the state during the</span>
<span class="udiff-line-modified-added">+    *     decomposition.</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-added">+    * @Return:</span>
<span class="udiff-line-added">+    *   Error code.  0 means success.</span>
<span class="udiff-line-added">+    */</span>
    static int
    FT_Outline_Decompose( const FT_Outline*        outline,
                          const FT_Outline_Funcs*  func_interface,
                          void*                    user )
    {
  #undef SCALED
<span class="udiff-line-modified-removed">- #define SCALED( x )  ( ( (x) &lt;&lt; shift ) - delta )</span>
<span class="udiff-line-modified-added">+ #define SCALED( x )  ( (x) * ( 1L &lt;&lt; shift ) - delta )</span>
  
      FT_Vector   v_last;
      FT_Vector   v_control;
      FT_Vector   v_start;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1608,85 +1613,10 @@</span>
  
    Invalid_Outline:
      return FT_THROW( Invalid_Outline );
    }
  
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   /*************************************************************************/</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /* &lt;Function&gt;                                                            */</span>
<span class="udiff-line-removed">-   /*    FT_Outline_Get_CBox                                                */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /* &lt;Description&gt;                                                         */</span>
<span class="udiff-line-removed">-   /*    Return an outline&#39;s `control box&#39;.  The control box encloses all   */</span>
<span class="udiff-line-removed">-   /*    the outline&#39;s points, including Bézier control points.  Though it  */</span>
<span class="udiff-line-removed">-   /*    coincides with the exact bounding box for most glyphs, it can be   */</span>
<span class="udiff-line-removed">-   /*    slightly larger in some situations (like when rotating an outline  */</span>
<span class="udiff-line-removed">-   /*    that contains Bézier outside arcs).                                */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /*    Computing the control box is very fast, while getting the bounding */</span>
<span class="udiff-line-removed">-   /*    box can take much more time as it needs to walk over all segments  */</span>
<span class="udiff-line-removed">-   /*    and arcs in the outline.  To get the latter, you can use the       */</span>
<span class="udiff-line-removed">-   /*    `ftbbox&#39; component, which is dedicated to this single task.        */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /* &lt;Input&gt;                                                               */</span>
<span class="udiff-line-removed">-   /*    outline :: A pointer to the source outline descriptor.             */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /* &lt;Output&gt;                                                              */</span>
<span class="udiff-line-removed">-   /*    acbox   :: The outline&#39;s control box.                              */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">-   /* &lt;Note&gt;                                                                */</span>
<span class="udiff-line-removed">-   /*    See @FT_Glyph_Get_CBox for a discussion of tricky fonts.           */</span>
<span class="udiff-line-removed">-   /*                                                                       */</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   static void</span>
<span class="udiff-line-removed">-   FT_Outline_Get_CBox( const FT_Outline*  outline,</span>
<span class="udiff-line-removed">-                        FT_BBox           *acbox )</span>
<span class="udiff-line-removed">-   {</span>
<span class="udiff-line-removed">-     TPos  xMin, yMin, xMax, yMax;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if ( outline &amp;&amp; acbox )</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       if ( outline-&gt;n_points == 0 )</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-removed">-         xMin = 0;</span>
<span class="udiff-line-removed">-         yMin = 0;</span>
<span class="udiff-line-removed">-         xMax = 0;</span>
<span class="udiff-line-removed">-         yMax = 0;</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">-       {</span>
<span class="udiff-line-removed">-         FT_Vector*  vec   = outline-&gt;points;</span>
<span class="udiff-line-removed">-         FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         xMin = xMax = vec-&gt;x;</span>
<span class="udiff-line-removed">-         yMin = yMax = vec-&gt;y;</span>
<span class="udiff-line-removed">-         vec++;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         for ( ; vec &lt; limit; vec++ )</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           TPos  x, y;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           x = vec-&gt;x;</span>
<span class="udiff-line-removed">-           if ( x &lt; xMin ) xMin = x;</span>
<span class="udiff-line-removed">-           if ( x &gt; xMax ) xMax = x;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-           y = vec-&gt;y;</span>
<span class="udiff-line-removed">-           if ( y &lt; yMin ) yMin = y;</span>
<span class="udiff-line-removed">-           if ( y &gt; yMax ) yMax = y;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-       }</span>
<span class="udiff-line-removed">-       acbox-&gt;xMin = xMin;</span>
<span class="udiff-line-removed">-       acbox-&gt;xMax = xMax;</span>
<span class="udiff-line-removed">-       acbox-&gt;yMin = yMin;</span>
<span class="udiff-line-removed">-       acbox-&gt;yMax = yMax;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-   }</span>
<span class="udiff-line-removed">- </span>
  #endif /* STANDALONE_ */
  
  
    FT_DEFINE_OUTLINE_FUNCS(
      func_interface,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1700,23 +1630,24 @@</span>
      0                                        /* delta    */
    )
  
  
    static int
<span class="udiff-line-modified-removed">-   gray_convert_glyph_inner( RAS_ARG )</span>
<span class="udiff-line-modified-added">+   gray_convert_glyph_inner( RAS_ARG,</span>
<span class="udiff-line-added">+                             int  continued )</span>
    {
<span class="udiff-line-added">+     int  error;</span>
  
<span class="udiff-line-removed">-     volatile int  error = 0;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="udiff-line-removed">-       FT_Outline_Funcs func_interface;</span>
<span class="udiff-line-removed">-       Init_Class_func_interface(&amp;func_interface);</span>
<span class="udiff-line-removed">- #endif</span>
  
      if ( ft_setjmp( ras.jump_buffer ) == 0 )
      {
<span class="udiff-line-added">+       if ( continued )</span>
<span class="udiff-line-added">+         FT_Trace_Disable();</span>
        error = FT_Outline_Decompose( &amp;ras.outline, &amp;func_interface, &amp;ras );
<span class="udiff-line-added">+       if ( continued )</span>
<span class="udiff-line-added">+         FT_Trace_Enable();</span>
<span class="udiff-line-added">+ </span>
        if ( !ras.invalid )
          gray_record_cell( RAS_VAR );
  
        FT_TRACE7(( &quot;band [%d..%d]: %d cell%s\n&quot;,
                    ras.min_ey,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1739,20 +1670,20 @@</span>
    static int
    gray_convert_glyph( RAS_ARG )
    {
      const TCoord  yMin = ras.min_ey;
      const TCoord  yMax = ras.max_ey;
<span class="udiff-line-removed">-     const TCoord  xMin = ras.min_ex;</span>
<span class="udiff-line-removed">-     const TCoord  xMax = ras.max_ex;</span>
  
      TCell    buffer[FT_MAX_GRAY_POOL];
      size_t   height = (size_t)( yMax - yMin );
      size_t   n = FT_MAX_GRAY_POOL / 8;
      TCoord   y;
      TCoord   bands[32];  /* enough to accommodate bisections */
      TCoord*  band;
  
<span class="udiff-line-added">+     int  continued = 0;</span>
<span class="udiff-line-added">+ </span>
  
      /* set up vertical bands */
      if ( height &gt; n )
      {
        /* two divisions rounded up */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1772,12 +1703,12 @@</span>
        ras.min_ey = y;
        y         += height;
        ras.max_ey = FT_MIN( y, yMax );
  
        band    = bands;
<span class="udiff-line-modified-removed">-       band[1] = xMin;</span>
<span class="udiff-line-modified-removed">-       band[0] = xMax;</span>
<span class="udiff-line-modified-added">+       band[1] = ras.min_ey;</span>
<span class="udiff-line-modified-added">+       band[0] = ras.max_ey;</span>
  
        do
        {
          TCoord  width = band[0] - band[1];
          int     error;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1785,14 +1716,15 @@</span>
  
          FT_MEM_ZERO( ras.ycells, height * sizeof ( PCell ) );
  
          ras.num_cells = 0;
          ras.invalid   = 1;
<span class="udiff-line-modified-removed">-         ras.min_ex    = band[1];</span>
<span class="udiff-line-modified-removed">-         ras.max_ex    = band[0];</span>
<span class="udiff-line-modified-added">+         ras.min_ey    = band[1];</span>
<span class="udiff-line-modified-added">+         ras.max_ey    = band[0];</span>
  
<span class="udiff-line-modified-removed">-         error = gray_convert_glyph_inner( RAS_VAR );</span>
<span class="udiff-line-modified-added">+         error     = gray_convert_glyph_inner( RAS_VAR, continued );</span>
<span class="udiff-line-added">+         continued = 1;</span>
  
          if ( !error )
          {
            gray_sweep( RAS_VAR );
            band--;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1825,11 +1757,10 @@</span>
    gray_raster_render( FT_Raster                raster,
                        const FT_Raster_Params*  params )
    {
      const FT_Outline*  outline    = (const FT_Outline*)params-&gt;source;
      const FT_Bitmap*   target_map = params-&gt;target;
<span class="udiff-line-removed">-     FT_BBox            cbox, clip;</span>
  
  #ifndef FT_STATIC_RASTER
      gray_TWorker  worker[1];
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1862,10 +1793,16 @@</span>
        if ( !params-&gt;gray_spans )
          return 0;
  
        ras.render_span      = (FT_Raster_Span_Func)params-&gt;gray_spans;
        ras.render_span_data = params-&gt;user;
<span class="udiff-line-added">+       ras.num_spans        = 0;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+       ras.min_ex = params-&gt;clip_box.xMin;</span>
<span class="udiff-line-added">+       ras.min_ey = params-&gt;clip_box.yMin;</span>
<span class="udiff-line-added">+       ras.max_ex = params-&gt;clip_box.xMax;</span>
<span class="udiff-line-added">+       ras.max_ey = params-&gt;clip_box.yMax;</span>
      }
      else
      {
        /* if direct mode is not set, we must have a target bitmap */
        if ( !target_map )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1886,50 +1823,19 @@</span>
  
        ras.target.pitch = target_map-&gt;pitch;
  
        ras.render_span      = (FT_Raster_Span_Func)NULL;
        ras.render_span_data = NULL;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     FT_Outline_Get_CBox( outline, &amp;cbox );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* reject too large outline coordinates */</span>
<span class="udiff-line-removed">-     if ( cbox.xMin &lt; -0x1000000L || cbox.xMax &gt; 0x1000000L ||</span>
<span class="udiff-line-removed">-          cbox.yMin &lt; -0x1000000L || cbox.yMax &gt; 0x1000000L )</span>
<span class="udiff-line-removed">-       return FT_THROW( Invalid_Outline );</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* truncate the bounding box to integer pixels */</span>
<span class="udiff-line-removed">-     cbox.xMin = cbox.xMin &gt;&gt; 6;</span>
<span class="udiff-line-removed">-     cbox.yMin = cbox.yMin &gt;&gt; 6;</span>
<span class="udiff-line-removed">-     cbox.xMax = ( cbox.xMax + 63 ) &gt;&gt; 6;</span>
<span class="udiff-line-removed">-     cbox.yMax = ( cbox.yMax + 63 ) &gt;&gt; 6;</span>
<span class="udiff-line-modified-added">+       ras.num_spans        = -1;  /* invalid */</span>
  
<span class="udiff-line-modified-removed">-     /* compute clipping box */</span>
<span class="udiff-line-modified-removed">-     if ( !( params-&gt;flags &amp; FT_RASTER_FLAG_DIRECT ) )</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* compute clip box from target pixmap */</span>
<span class="udiff-line-removed">-       clip.xMin = 0;</span>
<span class="udiff-line-removed">-       clip.yMin = 0;</span>
<span class="udiff-line-removed">-       clip.xMax = (FT_Pos)target_map-&gt;width;</span>
<span class="udiff-line-removed">-       clip.yMax = (FT_Pos)target_map-&gt;rows;</span>
<span class="udiff-line-modified-added">+       ras.min_ex = 0;</span>
<span class="udiff-line-modified-added">+       ras.min_ey = 0;</span>
<span class="udiff-line-modified-added">+       ras.max_ex = (FT_Pos)target_map-&gt;width;</span>
<span class="udiff-line-modified-added">+       ras.max_ey = (FT_Pos)target_map-&gt;rows;</span>
      }
<span class="udiff-line-removed">-     else if ( params-&gt;flags &amp; FT_RASTER_FLAG_CLIP )</span>
<span class="udiff-line-removed">-       clip = params-&gt;clip_box;</span>
<span class="udiff-line-removed">-     else</span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-       clip.xMin = -32768L;</span>
<span class="udiff-line-removed">-       clip.yMin = -32768L;</span>
<span class="udiff-line-removed">-       clip.xMax =  32767L;</span>
<span class="udiff-line-removed">-       clip.yMax =  32767L;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     /* clip to target bitmap, exit if nothing to do */</span>
<span class="udiff-line-removed">-     ras.min_ex = FT_MAX( cbox.xMin, clip.xMin );</span>
<span class="udiff-line-removed">-     ras.min_ey = FT_MAX( cbox.yMin, clip.yMin );</span>
<span class="udiff-line-removed">-     ras.max_ex = FT_MIN( cbox.xMax, clip.xMax );</span>
<span class="udiff-line-removed">-     ras.max_ey = FT_MIN( cbox.yMax, clip.yMax );</span>
  
<span class="udiff-line-added">+     /* exit if nothing to do */</span>
      if ( ras.max_ex &lt;= ras.min_ex || ras.max_ey &lt;= ras.min_ey )
        return 0;
  
      return gray_convert_glyph( RAS_VAR );
    }
</pre>
<center><a href="../sfnt/ttsbit.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftgrays.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/truetype/ttobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttobjs.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Objects manager (body).                                              */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_INTERNAL_STREAM_H
  22 #include FT_TRUETYPE_TAGS_H
  23 #include FT_INTERNAL_SFNT_H
  24 #include FT_DRIVER_H
  25 
  26 #include &quot;ttgload.h&quot;
  27 #include &quot;ttpload.h&quot;
  28 
  29 #include &quot;tterrors.h&quot;
  30 
  31 #ifdef TT_USE_BYTECODE_INTERPRETER
  32 #include &quot;ttinterp.h&quot;
  33 #endif
  34 
  35 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  36 #include &quot;ttgxvar.h&quot;
  37 #endif
  38 
<a name="2" id="anc2"></a><span class="line-modified">  39   /*************************************************************************/</span>
<span class="line-modified">  40   /*                                                                       */</span>
<span class="line-modified">  41   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  42   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  43   /* messages during execution.                                            */</span>
<span class="line-modified">  44   /*                                                                       */</span>
  45 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  46 #define FT_COMPONENT  trace_ttobjs</span>
  47 
  48 
  49 #ifdef TT_USE_BYTECODE_INTERPRETER
  50 
<a name="4" id="anc4"></a><span class="line-modified">  51   /*************************************************************************/</span>
<span class="line-modified">  52   /*                                                                       */</span>
<span class="line-modified">  53   /*                       GLYPH ZONE FUNCTIONS                            */</span>
<span class="line-modified">  54   /*                                                                       */</span>
<span class="line-modified">  55   /*************************************************************************/</span>
<span class="line-modified">  56 </span>
<span class="line-modified">  57 </span>
<span class="line-modified">  58   /*************************************************************************/</span>
<span class="line-modified">  59   /*                                                                       */</span>
<span class="line-modified">  60   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">  61   /*    tt_glyphzone_done                                                  */</span>
<span class="line-modified">  62   /*                                                                       */</span>
<span class="line-modified">  63   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">  64   /*    Deallocate a glyph zone.                                           */</span>
<span class="line-modified">  65   /*                                                                       */</span>
<span class="line-modified">  66   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">  67   /*    zone :: A pointer to the target glyph zone.                        */</span>
<span class="line-modified">  68   /*                                                                       */</span>

  69   FT_LOCAL_DEF( void )
  70   tt_glyphzone_done( TT_GlyphZone  zone )
  71   {
  72     FT_Memory  memory = zone-&gt;memory;
  73 
  74 
  75     if ( memory )
  76     {
  77       FT_FREE( zone-&gt;contours );
  78       FT_FREE( zone-&gt;tags );
  79       FT_FREE( zone-&gt;cur );
  80       FT_FREE( zone-&gt;org );
  81       FT_FREE( zone-&gt;orus );
  82 
  83       zone-&gt;max_points   = zone-&gt;n_points   = 0;
  84       zone-&gt;max_contours = zone-&gt;n_contours = 0;
  85       zone-&gt;memory       = NULL;
  86     }
  87   }
  88 
  89 
<a name="5" id="anc5"></a><span class="line-modified">  90   /*************************************************************************/</span>
<span class="line-modified">  91   /*                                                                       */</span>
<span class="line-modified">  92   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">  93   /*    tt_glyphzone_new                                                   */</span>
<span class="line-modified">  94   /*                                                                       */</span>
<span class="line-modified">  95   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">  96   /*    Allocate a new glyph zone.                                         */</span>
<span class="line-modified">  97   /*                                                                       */</span>
<span class="line-modified">  98   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">  99   /*    memory      :: A handle to the current memory object.              */</span>
<span class="line-modified"> 100   /*                                                                       */</span>
<span class="line-modified"> 101   /*    maxPoints   :: The capacity of glyph zone in points.               */</span>
<span class="line-modified"> 102   /*                                                                       */</span>
<span class="line-modified"> 103   /*    maxContours :: The capacity of glyph zone in contours.             */</span>
<span class="line-modified"> 104   /*                                                                       */</span>
<span class="line-modified"> 105   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified"> 106   /*    zone        :: A pointer to the target glyph zone record.          */</span>
<span class="line-modified"> 107   /*                                                                       */</span>
<span class="line-modified"> 108   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 109   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 110   /*                                                                       */</span>




 111   FT_LOCAL_DEF( FT_Error )
 112   tt_glyphzone_new( FT_Memory     memory,
 113                     FT_UShort     maxPoints,
 114                     FT_Short      maxContours,
 115                     TT_GlyphZone  zone )
 116   {
 117     FT_Error  error;
 118 
 119 
 120     FT_ZERO( zone );
 121     zone-&gt;memory = memory;
 122 
 123     if ( FT_NEW_ARRAY( zone-&gt;org,      maxPoints   ) ||
 124          FT_NEW_ARRAY( zone-&gt;cur,      maxPoints   ) ||
 125          FT_NEW_ARRAY( zone-&gt;orus,     maxPoints   ) ||
 126          FT_NEW_ARRAY( zone-&gt;tags,     maxPoints   ) ||
 127          FT_NEW_ARRAY( zone-&gt;contours, maxContours ) )
 128     {
 129       tt_glyphzone_done( zone );
 130     }
 131     else
 132     {
 133       zone-&gt;max_points   = maxPoints;
 134       zone-&gt;max_contours = maxContours;
 135     }
 136 
 137     return error;
 138   }
 139 #endif /* TT_USE_BYTECODE_INTERPRETER */
 140 
 141 
 142   /* Compare the face with a list of well-known `tricky&#39; fonts. */
 143   /* This list shall be expanded as we find more of them.       */
 144 
 145   static FT_Bool
<a name="6" id="anc6"></a><span class="line-modified"> 146   tt_check_trickyness_family( FT_String*  name )</span>
 147   {
 148 
 149 #define TRICK_NAMES_MAX_CHARACTERS  19
 150 #define TRICK_NAMES_COUNT           26
 151 
 152     static const char trick_names[TRICK_NAMES_COUNT]
 153                                  [TRICK_NAMES_MAX_CHARACTERS + 1] =
 154     {
 155       /*
 156          PostScript names are given in brackets if they differ from the
 157          family name.  The version numbers, together with the copyright or
 158          release year data, are taken from fonts available to the
 159          developers.
 160 
 161          Note that later versions of the fonts might be no longer tricky;
 162          for example, `MingLiU&#39; version 7.00 (file `mingliu.ttc&#39; from
 163          Windows 7) is an ordinary TTC with non-tricky subfonts.
 164        */
 165 
 166       &quot;cpop&quot;,               /* dftt-p7.ttf; version 1.00, 1992 [DLJGyShoMedium] */
 167       &quot;DFGirl-W6-WIN-BF&quot;,   /* dftt-h6.ttf; version 1.00, 1993 */
 168       &quot;DFGothic-EB&quot;,        /* DynaLab Inc. 1992-1995 */
 169       &quot;DFGyoSho-Lt&quot;,        /* DynaLab Inc. 1992-1995 */
 170       &quot;DFHei-Md-HK-BF&quot;,     /* maybe DynaLab Inc. */
 171       &quot;DFHSGothic-W5&quot;,      /* DynaLab Inc. 1992-1995 */
 172       &quot;DFHSMincho-W3&quot;,      /* DynaLab Inc. 1992-1995 */
 173       &quot;DFHSMincho-W7&quot;,      /* DynaLab Inc. 1992-1995 */
 174       &quot;DFKaiSho-SB&quot;,        /* dfkaisb.ttf */
 175       &quot;DFKaiShu&quot;,
 176       &quot;DFKaiShu-Md-HK-BF&quot;,  /* maybe DynaLab Inc. */
 177       &quot;DFKai-SB&quot;,           /* kaiu.ttf; version 3.00, 1998 [DFKaiShu-SB-Estd-BF] */
 178       &quot;DFMing-Bd-HK-BF&quot;,    /* maybe DynaLab Inc. */
 179       &quot;DLC&quot;,                /* dftt-m7.ttf; version 1.00, 1993 [DLCMingBold] */
 180                             /* dftt-f5.ttf; version 1.00, 1993 [DLCFongSung] */
 181       &quot;DLCHayMedium&quot;,       /* dftt-b5.ttf; version 1.00, 1993 */
 182       &quot;DLCHayBold&quot;,         /* dftt-b7.ttf; version 1.00, 1993 */
 183       &quot;DLCKaiMedium&quot;,       /* dftt-k5.ttf; version 1.00, 1992 */
 184       &quot;DLCLiShu&quot;,           /* dftt-l5.ttf; version 1.00, 1992 */
 185       &quot;DLCRoundBold&quot;,       /* dftt-r7.ttf; version 1.00, 1993 */
 186       &quot;HuaTianKaiTi?&quot;,      /* htkt2.ttf */
 187       &quot;HuaTianSongTi?&quot;,     /* htst3.ttf */
 188       &quot;Ming(for ISO10646)&quot;, /* hkscsiic.ttf; version 0.12, 2007 [Ming] */
 189                             /* iicore.ttf; version 0.07, 2007 [Ming] */
 190       &quot;MingLiU&quot;,            /* mingliu.ttf */
 191                             /* mingliu.ttc; version 3.21, 2001 */
 192       &quot;MingMedium&quot;,         /* dftt-m5.ttf; version 1.00, 1993 [DLCMingMedium] */
 193       &quot;PMingLiU&quot;,           /* mingliu.ttc; version 3.21, 2001 */
 194       &quot;MingLi43&quot;,           /* mingli.ttf; version 1.00, 1992 */
 195     };
 196 
 197     int  nn;
 198 
 199 
 200     for ( nn = 0; nn &lt; TRICK_NAMES_COUNT; nn++ )
 201       if ( ft_strstr( name, trick_names[nn] ) )
 202         return TRUE;
 203 
 204     return FALSE;
 205   }
 206 
 207 
 208   /* XXX: This function should be in the `sfnt&#39; module. */
 209 
 210   /* Some PDF generators clear the checksums in the TrueType header table. */
 211   /* For example, Quartz ContextPDF clears all entries, or Bullzip PDF     */
 212   /* Printer clears the entries for subsetted subtables.  We thus have to  */
 213   /* recalculate the checksums  where necessary.                           */
 214 
 215   static FT_UInt32
 216   tt_synth_sfnt_checksum( FT_Stream  stream,
 217                           FT_ULong   length )
 218   {
 219     FT_Error   error;
 220     FT_UInt32  checksum = 0;
 221     FT_UInt    i;
 222 
 223 
 224     if ( FT_FRAME_ENTER( length ) )
 225       return 0;
 226 
 227     for ( ; length &gt; 3; length -= 4 )
 228       checksum += (FT_UInt32)FT_GET_ULONG();
 229 
 230     for ( i = 3; length &gt; 0; length--, i-- )
 231       checksum += (FT_UInt32)FT_GET_BYTE() &lt;&lt; ( i * 8 );
 232 
 233     FT_FRAME_EXIT();
 234 
 235     return checksum;
 236   }
 237 
 238 
 239   /* XXX: This function should be in the `sfnt&#39; module. */
 240 
 241   static FT_ULong
 242   tt_get_sfnt_checksum( TT_Face    face,
 243                         FT_UShort  i )
 244   {
 245 #if 0 /* if we believe the written value, use following part. */
 246     if ( face-&gt;dir_tables[i].CheckSum )
 247       return face-&gt;dir_tables[i].CheckSum;
 248 #endif
 249 
 250     if ( !face-&gt;goto_table )
 251       return 0;
 252 
 253     if ( face-&gt;goto_table( face,
 254                            face-&gt;dir_tables[i].Tag,
 255                            face-&gt;root.stream,
 256                            NULL ) )
 257       return 0;
 258 
 259     return (FT_ULong)tt_synth_sfnt_checksum( face-&gt;root.stream,
 260                                              face-&gt;dir_tables[i].Length );
 261   }
 262 
 263 
 264   typedef struct tt_sfnt_id_rec_
 265   {
 266     FT_ULong  CheckSum;
 267     FT_ULong  Length;
 268 
 269   } tt_sfnt_id_rec;
 270 
 271 
 272   static FT_Bool
 273   tt_check_trickyness_sfnt_ids( TT_Face  face )
 274   {
 275 #define TRICK_SFNT_IDS_PER_FACE   3
 276 #define TRICK_SFNT_IDS_NUM_FACES  29
 277 
 278     static const tt_sfnt_id_rec sfnt_id[TRICK_SFNT_IDS_NUM_FACES]
 279                                        [TRICK_SFNT_IDS_PER_FACE] = {
 280 
 281 #define TRICK_SFNT_ID_cvt   0
 282 #define TRICK_SFNT_ID_fpgm  1
 283 #define TRICK_SFNT_ID_prep  2
 284 
 285       { /* MingLiU 1995 */
 286         { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
 287         { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
 288         { 0xA344A1EAUL, 0x000001E1UL }  /* prep */
 289       },
 290       { /* MingLiU 1996- */
 291         { 0x05BCF058UL, 0x000002E4UL }, /* cvt  */
 292         { 0x28233BF1UL, 0x000087C4UL }, /* fpgm */
 293         { 0xA344A1EBUL, 0x000001E1UL }  /* prep */
 294       },
 295       { /* DFGothic-EB */
 296         { 0x12C3EBB2UL, 0x00000350UL }, /* cvt  */
 297         { 0xB680EE64UL, 0x000087A7UL }, /* fpgm */
 298         { 0xCE939563UL, 0x00000758UL }  /* prep */
 299       },
 300       { /* DFGyoSho-Lt */
 301         { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
 302         { 0xCE5956E9UL, 0x0000BC85UL }, /* fpgm */
 303         { 0x8272F416UL, 0x00000045UL }  /* prep */
 304       },
 305       { /* DFHei-Md-HK-BF */
 306         { 0x1257EB46UL, 0x00000350UL }, /* cvt  */
 307         { 0xF699D160UL, 0x0000715FUL }, /* fpgm */
 308         { 0xD222F568UL, 0x000003BCUL }  /* prep */
 309       },
 310       { /* DFHSGothic-W5 */
 311         { 0x1262EB4EUL, 0x00000350UL }, /* cvt  */
 312         { 0xE86A5D64UL, 0x00007940UL }, /* fpgm */
 313         { 0x7850F729UL, 0x000005FFUL }  /* prep */
 314       },
 315       { /* DFHSMincho-W3 */
 316         { 0x122DEB0AUL, 0x00000350UL }, /* cvt  */
 317         { 0x3D16328AUL, 0x0000859BUL }, /* fpgm */
 318         { 0xA93FC33BUL, 0x000002CBUL }  /* prep */
 319       },
 320       { /* DFHSMincho-W7 */
 321         { 0x125FEB26UL, 0x00000350UL }, /* cvt  */
 322         { 0xA5ACC982UL, 0x00007EE1UL }, /* fpgm */
 323         { 0x90999196UL, 0x0000041FUL }  /* prep */
 324       },
 325       { /* DFKaiShu */
 326         { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
 327         { 0x5A30CA3BUL, 0x00009063UL }, /* fpgm */
 328         { 0x13A42602UL, 0x0000007EUL }  /* prep */
 329       },
 330       { /* DFKaiShu, variant */
 331         { 0x11E5EAD4UL, 0x00000350UL }, /* cvt  */
 332         { 0xA6E78C01UL, 0x00008998UL }, /* fpgm */
 333         { 0x13A42602UL, 0x0000007EUL }  /* prep */
 334       },
 335       { /* DFKaiShu-Md-HK-BF */
 336         { 0x11E5EAD4UL, 0x00000360UL }, /* cvt  */
 337         { 0x9DB282B2UL, 0x0000C06EUL }, /* fpgm */
 338         { 0x53E6D7CAUL, 0x00000082UL }  /* prep */
 339       },
 340       { /* DFMing-Bd-HK-BF */
 341         { 0x1243EB18UL, 0x00000350UL }, /* cvt  */
 342         { 0xBA0A8C30UL, 0x000074ADUL }, /* fpgm */
 343         { 0xF3D83409UL, 0x0000037BUL }  /* prep */
 344       },
 345       { /* DLCLiShu */
 346         { 0x07DCF546UL, 0x00000308UL }, /* cvt  */
 347         { 0x40FE7C90UL, 0x00008E2AUL }, /* fpgm */
 348         { 0x608174B5UL, 0x0000007AUL }  /* prep */
 349       },
 350       { /* DLCHayBold */
 351         { 0xEB891238UL, 0x00000308UL }, /* cvt  */
 352         { 0xD2E4DCD4UL, 0x0000676FUL }, /* fpgm */
 353         { 0x8EA5F293UL, 0x000003B8UL }  /* prep */
 354       },
 355       { /* HuaTianKaiTi */
 356         { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
 357         { 0x9C9E48B8UL, 0x0000BEA2UL }, /* fpgm */
 358         { 0x70020112UL, 0x00000008UL }  /* prep */
 359       },
 360       { /* HuaTianSongTi */
 361         { 0xFFFBFFFCUL, 0x00000008UL }, /* cvt  */
 362         { 0x0A5A0483UL, 0x00017C39UL }, /* fpgm */
 363         { 0x70020112UL, 0x00000008UL }  /* prep */
 364       },
 365       { /* NEC fadpop7.ttf */
 366         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 367         { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
 368         { 0xA39B58E3UL, 0x0000117CUL }  /* prep */
 369       },
 370       { /* NEC fadrei5.ttf */
 371         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 372         { 0x33C41652UL, 0x000000E5UL }, /* fpgm */
 373         { 0x26D6C52AUL, 0x00000F6AUL }  /* prep */
 374       },
 375       { /* NEC fangot7.ttf */
 376         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 377         { 0x6DB1651DUL, 0x0000019DUL }, /* fpgm */
 378         { 0x6C6E4B03UL, 0x00002492UL }  /* prep */
 379       },
 380       { /* NEC fangyo5.ttf */
 381         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 382         { 0x40C92555UL, 0x000000E5UL }, /* fpgm */
 383         { 0xDE51FAD0UL, 0x0000117CUL }  /* prep */
 384       },
 385       { /* NEC fankyo5.ttf */
 386         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 387         { 0x85E47664UL, 0x000000E5UL }, /* fpgm */
 388         { 0xA6C62831UL, 0x00001CAAUL }  /* prep */
 389       },
 390       { /* NEC fanrgo5.ttf */
 391         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 392         { 0x2D891CFDUL, 0x0000019DUL }, /* fpgm */
 393         { 0xA0604633UL, 0x00001DE8UL }  /* prep */
 394       },
 395       { /* NEC fangot5.ttc */
 396         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 397         { 0x40AA774CUL, 0x000001CBUL }, /* fpgm */
 398         { 0x9B5CAA96UL, 0x00001F9AUL }  /* prep */
 399       },
 400       { /* NEC fanmin3.ttc */
 401         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 402         { 0x0D3DE9CBUL, 0x00000141UL }, /* fpgm */
 403         { 0xD4127766UL, 0x00002280UL }  /* prep */
 404       },
 405       { /* NEC FA-Gothic, 1996 */
 406         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 407         { 0x4A692698UL, 0x000001F0UL }, /* fpgm */
 408         { 0x340D4346UL, 0x00001FCAUL }  /* prep */
 409       },
 410       { /* NEC FA-Minchou, 1996 */
 411         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 412         { 0xCD34C604UL, 0x00000166UL }, /* fpgm */
 413         { 0x6CF31046UL, 0x000022B0UL }  /* prep */
 414       },
 415       { /* NEC FA-RoundGothicB, 1996 */
 416         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 417         { 0x5DA75315UL, 0x0000019DUL }, /* fpgm */
 418         { 0x40745A5FUL, 0x000022E0UL }  /* prep */
 419       },
 420       { /* NEC FA-RoundGothicM, 1996 */
 421         { 0x00000000UL, 0x00000000UL }, /* cvt  */
 422         { 0xF055FC48UL, 0x000001C2UL }, /* fpgm */
 423         { 0x3900DED3UL, 0x00001E18UL }  /* prep */
 424       },
 425         { /* MINGLI.TTF, 1992 */
 426         { 0x00170003UL, 0x00000060UL }, /* cvt  */
 427         { 0xDBB4306EUL, 0x000058AAUL }, /* fpgm */
 428         { 0xD643482AUL, 0x00000035UL }  /* prep */
 429       }
 430     };
 431 
 432     FT_ULong   checksum;
 433     int        num_matched_ids[TRICK_SFNT_IDS_NUM_FACES];
 434     FT_Bool    has_cvt, has_fpgm, has_prep;
 435     FT_UShort  i;
 436     int        j, k;
 437 
 438 
 439     FT_MEM_SET( num_matched_ids, 0,
 440                 sizeof ( int ) * TRICK_SFNT_IDS_NUM_FACES );
 441     has_cvt  = FALSE;
 442     has_fpgm = FALSE;
 443     has_prep = FALSE;
 444 
 445     for ( i = 0; i &lt; face-&gt;num_tables; i++ )
 446     {
 447       checksum = 0;
 448 
 449       switch( face-&gt;dir_tables[i].Tag )
 450       {
 451       case TTAG_cvt:
 452         k = TRICK_SFNT_ID_cvt;
 453         has_cvt  = TRUE;
 454         break;
 455 
 456       case TTAG_fpgm:
 457         k = TRICK_SFNT_ID_fpgm;
 458         has_fpgm = TRUE;
 459         break;
 460 
 461       case TTAG_prep:
 462         k = TRICK_SFNT_ID_prep;
 463         has_prep = TRUE;
 464         break;
 465 
 466       default:
 467         continue;
 468       }
 469 
 470       for ( j = 0; j &lt; TRICK_SFNT_IDS_NUM_FACES; j++ )
 471         if ( face-&gt;dir_tables[i].Length == sfnt_id[j][k].Length )
 472         {
 473           if ( !checksum )
 474             checksum = tt_get_sfnt_checksum( face, i );
 475 
 476           if ( sfnt_id[j][k].CheckSum == checksum )
 477             num_matched_ids[j]++;
 478 
 479           if ( num_matched_ids[j] == TRICK_SFNT_IDS_PER_FACE )
 480             return TRUE;
 481         }
 482     }
 483 
 484     for ( j = 0; j &lt; TRICK_SFNT_IDS_NUM_FACES; j++ )
 485     {
 486       if ( !has_cvt  &amp;&amp; !sfnt_id[j][TRICK_SFNT_ID_cvt].Length )
 487         num_matched_ids[j]++;
 488       if ( !has_fpgm &amp;&amp; !sfnt_id[j][TRICK_SFNT_ID_fpgm].Length )
 489         num_matched_ids[j]++;
 490       if ( !has_prep &amp;&amp; !sfnt_id[j][TRICK_SFNT_ID_prep].Length )
 491         num_matched_ids[j]++;
 492       if ( num_matched_ids[j] == TRICK_SFNT_IDS_PER_FACE )
 493         return TRUE;
 494     }
 495 
 496     return FALSE;
 497   }
 498 
 499 
 500   static FT_Bool
 501   tt_check_trickyness( FT_Face  face )
 502   {
 503     if ( !face )
 504       return FALSE;
 505 
 506     /* For first, check the face name for quick check. */
 507     if ( face-&gt;family_name                               &amp;&amp;
 508          tt_check_trickyness_family( face-&gt;family_name ) )
 509       return TRUE;
 510 
 511     /* Type42 fonts may lack `name&#39; tables, we thus try to identify */
 512     /* tricky fonts by checking the checksums of Type42-persistent  */
 513     /* sfnt tables (`cvt&#39;, `fpgm&#39;, and `prep&#39;).                     */
 514     if ( tt_check_trickyness_sfnt_ids( (TT_Face)face ) )
 515       return TRUE;
 516 
 517     return FALSE;
 518   }
 519 
 520 
 521   /* Check whether `.notdef&#39; is the only glyph in the `loca&#39; table. */
 522   static FT_Bool
 523   tt_check_single_notdef( FT_Face  ttface )
 524   {
 525     FT_Bool   result = FALSE;
 526 
 527     TT_Face   face = (TT_Face)ttface;
 528     FT_UInt   asize;
 529     FT_ULong  i;
 530     FT_ULong  glyph_index = 0;
 531     FT_UInt   count       = 0;
 532 
 533 
 534     for( i = 0; i &lt; face-&gt;num_locations; i++ )
 535     {
 536       tt_face_get_location( face, i, &amp;asize );
 537       if ( asize &gt; 0 )
 538       {
 539         count += 1;
 540         if ( count &gt; 1 )
 541           break;
 542         glyph_index = i;
 543       }
 544     }
 545 
 546     /* Only have a single outline. */
 547     if ( count == 1 )
 548     {
 549       if ( glyph_index == 0 )
 550         result = TRUE;
 551       else
 552       {
 553         /* FIXME: Need to test glyphname == .notdef ? */
 554         FT_Error error;
 555         char buf[8];
 556 
 557 
 558         error = FT_Get_Glyph_Name( ttface, glyph_index, buf, 8 );
 559         if ( !error                                            &amp;&amp;
 560              buf[0] == &#39;.&#39; &amp;&amp; !ft_strncmp( buf, &quot;.notdef&quot;, 8 ) )
 561           result = TRUE;
 562       }
 563     }
 564 
 565     return result;
 566   }
 567 
 568 
<a name="7" id="anc7"></a><span class="line-modified"> 569   /*************************************************************************/</span>
<span class="line-modified"> 570   /*                                                                       */</span>
<span class="line-modified"> 571   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 572   /*    tt_face_init                                                       */</span>
<span class="line-modified"> 573   /*                                                                       */</span>
<span class="line-modified"> 574   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 575   /*    Initialize a given TrueType face object.                           */</span>
<span class="line-modified"> 576   /*                                                                       */</span>
<span class="line-modified"> 577   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 578   /*    stream     :: The source font stream.                              */</span>
<span class="line-modified"> 579   /*                                                                       */</span>
<span class="line-modified"> 580   /*    face_index :: The index of the TrueType font, if we are opening a  */</span>
<span class="line-modified"> 581   /*                  collection, in bits 0-15.  The numbered instance     */</span>
<span class="line-modified"> 582   /*                  index~+~1 of a GX (sub)font, if applicable, in bits  */</span>
<span class="line-modified"> 583   /*                  16-30.                                               */</span>
<span class="line-modified"> 584   /*                                                                       */</span>
<span class="line-modified"> 585   /*    num_params :: Number of additional generic parameters.  Ignored.   */</span>
<span class="line-modified"> 586   /*                                                                       */</span>
<span class="line-modified"> 587   /*    params     :: Additional generic parameters.  Ignored.             */</span>
<span class="line-modified"> 588   /*                                                                       */</span>
<span class="line-modified"> 589   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 590   /*    face       :: The newly built face object.                         */</span>
<span class="line-modified"> 591   /*                                                                       */</span>
<span class="line-modified"> 592   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 593   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 594   /*                                                                       */</span>





 595   FT_LOCAL_DEF( FT_Error )
 596   tt_face_init( FT_Stream      stream,
 597                 FT_Face        ttface,      /* TT_Face */
 598                 FT_Int         face_index,
 599                 FT_Int         num_params,
 600                 FT_Parameter*  params )
 601   {
 602     FT_Error      error;
 603     FT_Library    library;
 604     SFNT_Service  sfnt;
 605     TT_Face       face = (TT_Face)ttface;
 606 
 607 
 608     FT_TRACE2(( &quot;TTF driver\n&quot; ));
 609 
 610     library = ttface-&gt;driver-&gt;root.library;
 611 
 612     sfnt = (SFNT_Service)FT_Get_Module_Interface( library, &quot;sfnt&quot; );
 613     if ( !sfnt )
 614     {
 615       FT_ERROR(( &quot;tt_face_init: cannot access `sfnt&#39; module\n&quot; ));
 616       error = FT_THROW( Missing_Module );
 617       goto Exit;
 618     }
 619 
 620     /* create input stream from resource */
 621     if ( FT_STREAM_SEEK( 0 ) )
 622       goto Exit;
 623 
 624     /* check that we have a valid TrueType file */
 625     FT_TRACE2(( &quot;  &quot; ));
 626     error = sfnt-&gt;init_face( stream, face, face_index, num_params, params );
 627 
 628     /* Stream may have changed. */
 629     stream = face-&gt;root.stream;
 630 
 631     if ( error )
 632       goto Exit;
 633 
 634     /* We must also be able to accept Mac/GX fonts, as well as OT ones. */
 635     /* The 0x00020000 tag is completely undocumented; some fonts from   */
 636     /* Arphic made for Chinese Windows 3.1 have this.                   */
 637     if ( face-&gt;format_tag != 0x00010000L  &amp;&amp; /* MS fonts                             */
 638          face-&gt;format_tag != 0x00020000L  &amp;&amp; /* CJK fonts for Win 3.1                */
 639          face-&gt;format_tag != TTAG_true    &amp;&amp; /* Mac fonts                            */
 640          face-&gt;format_tag != TTAG_0xA5kbd &amp;&amp; /* `Keyboard.dfont&#39; (legacy Mac OS X)   */
 641          face-&gt;format_tag != TTAG_0xA5lst )  /* `LastResort.dfont&#39; (legacy Mac OS X) */
 642     {
 643       FT_TRACE2(( &quot;  not a TTF font\n&quot; ));
 644       goto Bad_Format;
 645     }
 646 
 647 #ifdef TT_USE_BYTECODE_INTERPRETER
 648     ttface-&gt;face_flags |= FT_FACE_FLAG_HINTER;
 649 #endif
 650 
 651     /* If we are performing a simple font format check, exit immediately. */
 652     if ( face_index &lt; 0 )
 653       return FT_Err_Ok;
 654 
 655     /* Load font directory */
 656     error = sfnt-&gt;load_face( stream, face, face_index, num_params, params );
 657     if ( error )
 658       goto Exit;
 659 
 660     if ( tt_check_trickyness( ttface ) )
 661       ttface-&gt;face_flags |= FT_FACE_FLAG_TRICKY;
 662 
 663     error = tt_face_load_hdmx( face, stream );
 664     if ( error )
 665       goto Exit;
 666 
 667     if ( FT_IS_SCALABLE( ttface ) )
 668     {
 669 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 670       if ( !ttface-&gt;internal-&gt;incremental_interface )
 671 #endif
 672       {
 673         error = tt_face_load_loca( face, stream );
 674 
 675         /* having a (non-zero) `glyf&#39; table without */
 676         /* a `loca&#39; table is not valid              */
 677         if ( face-&gt;glyf_len &amp;&amp; FT_ERR_EQ( error, Table_Missing ) )
 678           goto Exit;
 679         if ( error )
 680           goto Exit;
 681       }
 682 
 683       /* `fpgm&#39;, `cvt&#39;, and `prep&#39; are optional */
 684       error = tt_face_load_cvt( face, stream );
 685       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
 686         goto Exit;
 687 
 688       error = tt_face_load_fpgm( face, stream );
 689       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
 690         goto Exit;
 691 
 692       error = tt_face_load_prep( face, stream );
 693       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
 694         goto Exit;
 695 
 696       /* Check the scalable flag based on `loca&#39;. */
 697 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 698       if ( !ttface-&gt;internal-&gt;incremental_interface )
 699 #endif
 700       {
 701         if ( ttface-&gt;num_fixed_sizes          &amp;&amp;
 702              face-&gt;glyph_locations            &amp;&amp;
 703              tt_check_single_notdef( ttface ) )
 704         {
 705           FT_TRACE5(( &quot;tt_face_init:&quot;
 706                       &quot; Only the `.notdef&#39; glyph has an outline.\n&quot;
 707                       &quot;             &quot;
 708                       &quot; Resetting scalable flag to FALSE.\n&quot; ));
 709 
 710           ttface-&gt;face_flags &amp;= ~FT_FACE_FLAG_SCALABLE;
 711         }
 712       }
 713     }
 714 
 715 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 716 
 717     {
 718       FT_UInt  instance_index = (FT_UInt)face_index &gt;&gt; 16;
 719 
 720 
 721       if ( FT_HAS_MULTIPLE_MASTERS( ttface ) &amp;&amp;
 722            instance_index &gt; 0                )
 723       {
 724         error = TT_Set_Named_Instance( face, instance_index );
 725         if ( error )
 726           goto Exit;
 727 
 728         tt_apply_mvar( face );
 729       }
 730     }
 731 
 732 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 733 
 734     /* initialize standard glyph loading routines */
 735     TT_Init_Glyph_Loading( face );
 736 
 737   Exit:
 738     return error;
 739 
 740   Bad_Format:
 741     error = FT_THROW( Unknown_File_Format );
 742     goto Exit;
 743   }
 744 
 745 
<a name="8" id="anc8"></a><span class="line-modified"> 746   /*************************************************************************/</span>
<span class="line-modified"> 747   /*                                                                       */</span>
<span class="line-modified"> 748   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 749   /*    tt_face_done                                                       */</span>
<span class="line-modified"> 750   /*                                                                       */</span>
<span class="line-modified"> 751   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 752   /*    Finalize a given face object.                                      */</span>
<span class="line-modified"> 753   /*                                                                       */</span>
<span class="line-modified"> 754   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 755   /*    face :: A pointer to the face object to destroy.                   */</span>
<span class="line-modified"> 756   /*                                                                       */</span>

 757   FT_LOCAL_DEF( void )
 758   tt_face_done( FT_Face  ttface )           /* TT_Face */
 759   {
 760     TT_Face       face = (TT_Face)ttface;
 761     FT_Memory     memory;
 762     FT_Stream     stream;
 763     SFNT_Service  sfnt;
 764 
 765 
 766     if ( !face )
 767       return;
 768 
 769     memory = ttface-&gt;memory;
 770     stream = ttface-&gt;stream;
 771     sfnt   = (SFNT_Service)face-&gt;sfnt;
 772 
 773     /* for `extended TrueType formats&#39; (i.e. compressed versions) */
 774     if ( face-&gt;extra.finalizer )
 775       face-&gt;extra.finalizer( face-&gt;extra.data );
 776 
 777     if ( sfnt )
 778       sfnt-&gt;done_face( face );
 779 
 780     /* freeing the locations table */
 781     tt_face_done_loca( face );
 782 
 783     tt_face_free_hdmx( face );
 784 
 785     /* freeing the CVT */
 786     FT_FREE( face-&gt;cvt );
 787     face-&gt;cvt_size = 0;
 788 
 789     /* freeing the programs */
 790     FT_FRAME_RELEASE( face-&gt;font_program );
 791     FT_FRAME_RELEASE( face-&gt;cvt_program );
 792     face-&gt;font_program_size = 0;
 793     face-&gt;cvt_program_size  = 0;
 794 
 795 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 796     tt_done_blend( face );
 797     face-&gt;blend = NULL;
 798 #endif
 799   }
 800 
 801 
<a name="9" id="anc9"></a><span class="line-modified"> 802   /*************************************************************************/</span>
<span class="line-modified"> 803   /*                                                                       */</span>
<span class="line-modified"> 804   /*                           SIZE  FUNCTIONS                             */</span>
<span class="line-modified"> 805   /*                                                                       */</span>
<span class="line-modified"> 806   /*************************************************************************/</span>
 807 
 808 #ifdef TT_USE_BYTECODE_INTERPRETER
 809 
<a name="10" id="anc10"></a><span class="line-modified"> 810   /*************************************************************************/</span>
<span class="line-modified"> 811   /*                                                                       */</span>
<span class="line-modified"> 812   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 813   /*    tt_size_run_fpgm                                                   */</span>
<span class="line-modified"> 814   /*                                                                       */</span>
<span class="line-modified"> 815   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 816   /*    Run the font program.                                              */</span>
<span class="line-modified"> 817   /*                                                                       */</span>
<span class="line-modified"> 818   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 819   /*    size     :: A handle to the size object.                           */</span>
<span class="line-modified"> 820   /*                                                                       */</span>
<span class="line-modified"> 821   /*    pedantic :: Set if bytecode execution should be pedantic.          */</span>
<span class="line-modified"> 822   /*                                                                       */</span>
<span class="line-modified"> 823   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 824   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 825   /*                                                                       */</span>


 826   FT_LOCAL_DEF( FT_Error )
 827   tt_size_run_fpgm( TT_Size  size,
 828                     FT_Bool  pedantic )
 829   {
 830     TT_Face         face = (TT_Face)size-&gt;root.face;
 831     TT_ExecContext  exec;
 832     FT_Error        error;
 833 
 834 
 835     exec = size-&gt;context;
 836 
 837     error = TT_Load_Context( exec, face, size );
 838     if ( error )
 839       return error;
 840 
 841     exec-&gt;callTop = 0;
 842     exec-&gt;top     = 0;
 843 
 844     exec-&gt;period    = 64;
 845     exec-&gt;phase     = 0;
 846     exec-&gt;threshold = 0;
 847 
 848     exec-&gt;instruction_trap = FALSE;
 849     exec-&gt;F_dot_P          = 0x4000L;
 850 
 851     exec-&gt;pedantic_hinting = pedantic;
 852 
 853     {
 854       FT_Size_Metrics*  size_metrics = &amp;exec-&gt;metrics;
 855       TT_Size_Metrics*  tt_metrics   = &amp;exec-&gt;tt_metrics;
 856 
 857 
 858       size_metrics-&gt;x_ppem   = 0;
 859       size_metrics-&gt;y_ppem   = 0;
 860       size_metrics-&gt;x_scale  = 0;
 861       size_metrics-&gt;y_scale  = 0;
 862 
 863       tt_metrics-&gt;ppem  = 0;
 864       tt_metrics-&gt;scale = 0;
 865       tt_metrics-&gt;ratio = 0x10000L;
 866     }
 867 
 868     /* allow font program execution */
 869     TT_Set_CodeRange( exec,
 870                       tt_coderange_font,
 871                       face-&gt;font_program,
 872                       (FT_Long)face-&gt;font_program_size );
 873 
 874     /* disable CVT and glyph programs coderange */
 875     TT_Clear_CodeRange( exec, tt_coderange_cvt );
 876     TT_Clear_CodeRange( exec, tt_coderange_glyph );
 877 
 878     if ( face-&gt;font_program_size &gt; 0 )
 879     {
 880       TT_Goto_CodeRange( exec, tt_coderange_font, 0 );
 881 
 882       FT_TRACE4(( &quot;Executing `fpgm&#39; table.\n&quot; ));
 883       error = face-&gt;interpreter( exec );
 884 #ifdef FT_DEBUG_LEVEL_TRACE
 885       if ( error )
 886         FT_TRACE4(( &quot;  interpretation failed with error code 0x%x\n&quot;,
 887                     error ));
 888 #endif
 889     }
 890     else
 891       error = FT_Err_Ok;
 892 
 893     size-&gt;bytecode_ready = error;
 894 
 895     if ( !error )
 896       TT_Save_Context( exec, size );
 897 
 898     return error;
 899   }
 900 
 901 
<a name="11" id="anc11"></a><span class="line-modified"> 902   /*************************************************************************/</span>
<span class="line-modified"> 903   /*                                                                       */</span>
<span class="line-modified"> 904   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 905   /*    tt_size_run_prep                                                   */</span>
<span class="line-modified"> 906   /*                                                                       */</span>
<span class="line-modified"> 907   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 908   /*    Run the control value program.                                     */</span>
<span class="line-modified"> 909   /*                                                                       */</span>
<span class="line-modified"> 910   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 911   /*    size     :: A handle to the size object.                           */</span>
<span class="line-modified"> 912   /*                                                                       */</span>
<span class="line-modified"> 913   /*    pedantic :: Set if bytecode execution should be pedantic.          */</span>
<span class="line-modified"> 914   /*                                                                       */</span>
<span class="line-modified"> 915   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 916   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 917   /*                                                                       */</span>


 918   FT_LOCAL_DEF( FT_Error )
 919   tt_size_run_prep( TT_Size  size,
 920                     FT_Bool  pedantic )
 921   {
 922     TT_Face         face = (TT_Face)size-&gt;root.face;
 923     TT_ExecContext  exec;
 924     FT_Error        error;
<a name="12" id="anc12"></a>
 925 
<a name="13" id="anc13"></a>













 926 
 927     exec = size-&gt;context;
 928 
 929     error = TT_Load_Context( exec, face, size );
 930     if ( error )
 931       return error;
 932 
 933     exec-&gt;callTop = 0;
 934     exec-&gt;top     = 0;
 935 
 936     exec-&gt;instruction_trap = FALSE;
 937 
 938     exec-&gt;pedantic_hinting = pedantic;
 939 
 940     TT_Set_CodeRange( exec,
 941                       tt_coderange_cvt,
 942                       face-&gt;cvt_program,
 943                       (FT_Long)face-&gt;cvt_program_size );
 944 
 945     TT_Clear_CodeRange( exec, tt_coderange_glyph );
 946 
 947     if ( face-&gt;cvt_program_size &gt; 0 )
 948     {
 949       TT_Goto_CodeRange( exec, tt_coderange_cvt, 0 );
 950 
 951       FT_TRACE4(( &quot;Executing `prep&#39; table.\n&quot; ));
 952       error = face-&gt;interpreter( exec );
 953 #ifdef FT_DEBUG_LEVEL_TRACE
 954       if ( error )
 955         FT_TRACE4(( &quot;  interpretation failed with error code 0x%x\n&quot;,
 956                     error ));
 957 #endif
 958     }
 959     else
 960       error = FT_Err_Ok;
 961 
 962     size-&gt;cvt_ready = error;
 963 
 964     /* UNDOCUMENTED!  The MS rasterizer doesn&#39;t allow the following */
 965     /* graphics state variables to be modified by the CVT program.  */
 966 
 967     exec-&gt;GS.dualVector.x = 0x4000;
 968     exec-&gt;GS.dualVector.y = 0;
 969     exec-&gt;GS.projVector.x = 0x4000;
 970     exec-&gt;GS.projVector.y = 0x0;
 971     exec-&gt;GS.freeVector.x = 0x4000;
 972     exec-&gt;GS.freeVector.y = 0x0;
 973 
 974     exec-&gt;GS.rp0 = 0;
 975     exec-&gt;GS.rp1 = 0;
 976     exec-&gt;GS.rp2 = 0;
 977 
 978     exec-&gt;GS.gep0 = 1;
 979     exec-&gt;GS.gep1 = 1;
 980     exec-&gt;GS.gep2 = 1;
 981 
 982     exec-&gt;GS.loop = 1;
 983 
 984     /* save as default graphics state */
 985     size-&gt;GS = exec-&gt;GS;
 986 
 987     TT_Save_Context( exec, size );
 988 
 989     return error;
 990   }
 991 
 992 
 993   static void
 994   tt_size_done_bytecode( FT_Size  ftsize )
 995   {
 996     TT_Size    size   = (TT_Size)ftsize;
 997     TT_Face    face   = (TT_Face)ftsize-&gt;face;
 998     FT_Memory  memory = face-&gt;root.memory;
 999 
1000     if ( size-&gt;context )
1001     {
1002       TT_Done_Context( size-&gt;context );
1003       size-&gt;context = NULL;
1004     }
1005 
1006     FT_FREE( size-&gt;cvt );
1007     size-&gt;cvt_size = 0;
1008 
1009     /* free storage area */
1010     FT_FREE( size-&gt;storage );
1011     size-&gt;storage_size = 0;
1012 
1013     /* twilight zone */
1014     tt_glyphzone_done( &amp;size-&gt;twilight );
1015 
1016     FT_FREE( size-&gt;function_defs );
1017     FT_FREE( size-&gt;instruction_defs );
1018 
1019     size-&gt;num_function_defs    = 0;
1020     size-&gt;max_function_defs    = 0;
1021     size-&gt;num_instruction_defs = 0;
1022     size-&gt;max_instruction_defs = 0;
1023 
1024     size-&gt;max_func = 0;
1025     size-&gt;max_ins  = 0;
1026 
1027     size-&gt;bytecode_ready = -1;
1028     size-&gt;cvt_ready      = -1;
1029   }
1030 
1031 
1032   /* Initialize bytecode-related fields in the size object.       */
1033   /* We do this only if bytecode interpretation is really needed. */
1034   static FT_Error
1035   tt_size_init_bytecode( FT_Size  ftsize,
1036                          FT_Bool  pedantic )
1037   {
1038     FT_Error   error;
1039     TT_Size    size = (TT_Size)ftsize;
1040     TT_Face    face = (TT_Face)ftsize-&gt;face;
1041     FT_Memory  memory = face-&gt;root.memory;
1042 
1043     FT_UShort       n_twilight;
1044     TT_MaxProfile*  maxp = &amp;face-&gt;max_profile;
1045 
1046 
1047     /* clean up bytecode related data */
1048     FT_FREE( size-&gt;function_defs );
1049     FT_FREE( size-&gt;instruction_defs );
1050     FT_FREE( size-&gt;cvt );
1051     FT_FREE( size-&gt;storage );
1052 
1053     if ( size-&gt;context )
1054       TT_Done_Context( size-&gt;context );
1055     tt_glyphzone_done( &amp;size-&gt;twilight );
1056 
1057     size-&gt;bytecode_ready = -1;
1058     size-&gt;cvt_ready      = -1;
1059 
1060     size-&gt;context = TT_New_Context( (TT_Driver)face-&gt;root.driver );
1061 
1062     size-&gt;max_function_defs    = maxp-&gt;maxFunctionDefs;
1063     size-&gt;max_instruction_defs = maxp-&gt;maxInstructionDefs;
1064 
1065     size-&gt;num_function_defs    = 0;
1066     size-&gt;num_instruction_defs = 0;
1067 
1068     size-&gt;max_func = 0;
1069     size-&gt;max_ins  = 0;
1070 
1071     size-&gt;cvt_size     = face-&gt;cvt_size;
1072     size-&gt;storage_size = maxp-&gt;maxStorage;
1073 
1074     /* Set default metrics */
1075     {
1076       TT_Size_Metrics*  tt_metrics = &amp;size-&gt;ttmetrics;
1077 
1078 
1079       tt_metrics-&gt;rotated   = FALSE;
1080       tt_metrics-&gt;stretched = FALSE;
1081 
<a name="14" id="anc14"></a><span class="line-modified">1082       /* set default engine compensation */</span>
<span class="line-modified">1083       tt_metrics-&gt;compensations[0] = 0;   /* gray     */</span>
<span class="line-modified">1084       tt_metrics-&gt;compensations[1] = 0;   /* black    */</span>
<span class="line-modified">1085       tt_metrics-&gt;compensations[2] = 0;   /* white    */</span>
<span class="line-modified">1086       tt_metrics-&gt;compensations[3] = 0;   /* reserved */</span>






1087     }
1088 
1089     /* allocate function defs, instruction defs, cvt, and storage area */
1090     if ( FT_NEW_ARRAY( size-&gt;function_defs,    size-&gt;max_function_defs    ) ||
1091          FT_NEW_ARRAY( size-&gt;instruction_defs, size-&gt;max_instruction_defs ) ||
1092          FT_NEW_ARRAY( size-&gt;cvt,              size-&gt;cvt_size             ) ||
1093          FT_NEW_ARRAY( size-&gt;storage,          size-&gt;storage_size         ) )
1094       goto Exit;
1095 
1096     /* reserve twilight zone */
1097     n_twilight = maxp-&gt;maxTwilightPoints;
1098 
1099     /* there are 4 phantom points (do we need this?) */
1100     n_twilight += 4;
1101 
1102     error = tt_glyphzone_new( memory, n_twilight, 0, &amp;size-&gt;twilight );
1103     if ( error )
1104       goto Exit;
1105 
1106     size-&gt;twilight.n_points = n_twilight;
1107 
1108     size-&gt;GS = tt_default_graphics_state;
1109 
1110     /* set `face-&gt;interpreter&#39; according to the debug hook present */
1111     {
1112       FT_Library  library = face-&gt;root.driver-&gt;root.library;
1113 
1114 
1115       face-&gt;interpreter = (TT_Interpreter)
1116                             library-&gt;debug_hooks[FT_DEBUG_HOOK_TRUETYPE];
1117       if ( !face-&gt;interpreter )
1118         face-&gt;interpreter = (TT_Interpreter)TT_RunIns;
1119     }
1120 
1121     /* Fine, now run the font program! */
1122 
1123     /* In case of an error while executing `fpgm&#39;, we intentionally don&#39;t */
1124     /* clean up immediately – bugs in the `fpgm&#39; are so fundamental that  */
1125     /* all following hinting calls should fail.  Additionally, `fpgm&#39; is  */
1126     /* to be executed just once; calling it again is completely useless   */
1127     /* and might even lead to extremely slow behaviour if it is malformed */
1128     /* (containing an infinite loop, for example).                        */
1129     error = tt_size_run_fpgm( size, pedantic );
1130     return error;
1131 
1132   Exit:
1133     if ( error )
1134       tt_size_done_bytecode( ftsize );
1135 
1136     return error;
1137   }
1138 
1139 
1140   FT_LOCAL_DEF( FT_Error )
1141   tt_size_ready_bytecode( TT_Size  size,
1142                           FT_Bool  pedantic )
1143   {
1144     FT_Error  error = FT_Err_Ok;
1145 
1146 
1147     if ( size-&gt;bytecode_ready &lt; 0 )
1148       error = tt_size_init_bytecode( (FT_Size)size, pedantic );
1149     else
1150       error = size-&gt;bytecode_ready;
1151 
1152     if ( error )
1153       goto Exit;
1154 
1155     /* rescale CVT when needed */
1156     if ( size-&gt;cvt_ready &lt; 0 )
1157     {
1158       FT_UInt  i;
<a name="15" id="anc15"></a><span class="line-removed">1159       TT_Face  face = (TT_Face)size-&gt;root.face;</span>
<span class="line-removed">1160 </span>
1161 
<a name="16" id="anc16"></a><span class="line-removed">1162       /* Scale the cvt values to the new ppem.          */</span>
<span class="line-removed">1163       /* We use by default the y ppem to scale the CVT. */</span>
<span class="line-removed">1164       for ( i = 0; i &lt; size-&gt;cvt_size; i++ )</span>
<span class="line-removed">1165         size-&gt;cvt[i] = FT_MulFix( face-&gt;cvt[i], size-&gt;ttmetrics.scale );</span>
1166 
1167       /* all twilight points are originally zero */
1168       for ( i = 0; i &lt; (FT_UInt)size-&gt;twilight.n_points; i++ )
1169       {
1170         size-&gt;twilight.org[i].x = 0;
1171         size-&gt;twilight.org[i].y = 0;
1172         size-&gt;twilight.cur[i].x = 0;
1173         size-&gt;twilight.cur[i].y = 0;
1174       }
1175 
1176       /* clear storage area */
1177       for ( i = 0; i &lt; (FT_UInt)size-&gt;storage_size; i++ )
1178         size-&gt;storage[i] = 0;
1179 
1180       size-&gt;GS = tt_default_graphics_state;
1181 
1182       error = tt_size_run_prep( size, pedantic );
1183     }
1184     else
1185       error = size-&gt;cvt_ready;
1186 
1187   Exit:
1188     return error;
1189   }
1190 
1191 #endif /* TT_USE_BYTECODE_INTERPRETER */
1192 
1193 
<a name="17" id="anc17"></a><span class="line-modified">1194   /*************************************************************************/</span>
<span class="line-modified">1195   /*                                                                       */</span>
<span class="line-modified">1196   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1197   /*    tt_size_init                                                       */</span>
<span class="line-modified">1198   /*                                                                       */</span>
<span class="line-modified">1199   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1200   /*    Initialize a new TrueType size object.                             */</span>
<span class="line-modified">1201   /*                                                                       */</span>
<span class="line-modified">1202   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1203   /*    size :: A handle to the size object.                               */</span>
<span class="line-modified">1204   /*                                                                       */</span>
<span class="line-modified">1205   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1206   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1207   /*                                                                       */</span>

1208   FT_LOCAL_DEF( FT_Error )
1209   tt_size_init( FT_Size  ttsize )           /* TT_Size */
1210   {
1211     TT_Size   size  = (TT_Size)ttsize;
1212     FT_Error  error = FT_Err_Ok;
1213 
1214 
1215 #ifdef TT_USE_BYTECODE_INTERPRETER
1216     size-&gt;bytecode_ready = -1;
1217     size-&gt;cvt_ready      = -1;
1218 #endif
1219 
1220     size-&gt;ttmetrics.valid = FALSE;
1221     size-&gt;strike_index    = 0xFFFFFFFFUL;
1222 
1223     return error;
1224   }
1225 
1226 
<a name="18" id="anc18"></a><span class="line-modified">1227   /*************************************************************************/</span>
<span class="line-modified">1228   /*                                                                       */</span>
<span class="line-modified">1229   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1230   /*    tt_size_done                                                       */</span>
<span class="line-modified">1231   /*                                                                       */</span>
<span class="line-modified">1232   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1233   /*    The TrueType size object finalizer.                                */</span>
<span class="line-modified">1234   /*                                                                       */</span>
<span class="line-modified">1235   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1236   /*    size :: A handle to the target size object.                        */</span>
<span class="line-modified">1237   /*                                                                       */</span>

1238   FT_LOCAL_DEF( void )
1239   tt_size_done( FT_Size  ttsize )           /* TT_Size */
1240   {
1241     TT_Size  size = (TT_Size)ttsize;
1242 
1243 
1244 #ifdef TT_USE_BYTECODE_INTERPRETER
1245     tt_size_done_bytecode( ttsize );
1246 #endif
1247 
1248     size-&gt;ttmetrics.valid = FALSE;
1249   }
1250 
1251 
<a name="19" id="anc19"></a><span class="line-modified">1252   /*************************************************************************/</span>
<span class="line-modified">1253   /*                                                                       */</span>
<span class="line-modified">1254   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1255   /*    tt_size_reset                                                      */</span>
<span class="line-modified">1256   /*                                                                       */</span>
<span class="line-modified">1257   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1258   /*    Reset a TrueType size when resolutions and character dimensions    */</span>
<span class="line-modified">1259   /*    have been changed.                                                 */</span>
<span class="line-modified">1260   /*                                                                       */</span>
<span class="line-modified">1261   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1262   /*    size        :: A handle to the target size object.                 */</span>
<span class="line-modified">1263   /*                                                                       */</span>
<span class="line-modified">1264   /*    only_height :: Only recompute ascender, descender, and height;     */</span>
<span class="line-modified">1265   /*                   this flag is used for variation fonts where         */</span>
<span class="line-modified">1266   /*                   `tt_size_reset&#39; is used as an iterator function.    */</span>
<span class="line-modified">1267   /*                                                                       */</span>


1268   FT_LOCAL_DEF( FT_Error )
1269   tt_size_reset( TT_Size  size,
1270                  FT_Bool  only_height )
1271   {
1272     TT_Face           face;
1273     FT_Size_Metrics*  size_metrics;
1274 
1275 
1276     face = (TT_Face)size-&gt;root.face;
1277 
1278     /* nothing to do for CFF2 */
1279     if ( face-&gt;is_cff2 )
1280       return FT_Err_Ok;
1281 
1282     size-&gt;ttmetrics.valid = FALSE;
1283 
1284     size_metrics = &amp;size-&gt;hinted_metrics;
1285 
1286     /* copy the result from base layer */
1287     *size_metrics = size-&gt;root.metrics;
1288 
1289     if ( size_metrics-&gt;x_ppem &lt; 1 || size_metrics-&gt;y_ppem &lt; 1 )
1290       return FT_THROW( Invalid_PPem );
1291 
1292     /* This bit flag, if set, indicates that the ppems must be       */
1293     /* rounded to integers.  Nearly all TrueType fonts have this bit */
1294     /* set, as hinting won&#39;t work really well otherwise.             */
1295     /*                                                               */
1296     if ( face-&gt;header.Flags &amp; 8 )
1297     {
1298       /* the TT spec always asks for ROUND, not FLOOR or CEIL */
1299       size_metrics-&gt;ascender = FT_PIX_ROUND(
1300                                  FT_MulFix( face-&gt;root.ascender,
1301                                             size_metrics-&gt;y_scale ) );
1302       size_metrics-&gt;descender = FT_PIX_ROUND(
1303                                  FT_MulFix( face-&gt;root.descender,
1304                                             size_metrics-&gt;y_scale ) );
1305       size_metrics-&gt;height = FT_PIX_ROUND(
1306                                FT_MulFix( face-&gt;root.height,
1307                                           size_metrics-&gt;y_scale ) );
1308     }
1309 
1310     size-&gt;ttmetrics.valid = TRUE;
1311 
1312     if ( only_height )
1313     {
1314       /* we must not recompute the scaling values here since       */
1315       /* `tt_size_reset&#39; was already called (with only_height = 0) */
1316       return FT_Err_Ok;
1317     }
1318 
1319     if ( face-&gt;header.Flags &amp; 8 )
1320     {
1321       /* base scaling values on integer ppem values, */
1322       /* as mandated by the TrueType specification   */
1323       size_metrics-&gt;x_scale = FT_DivFix( size_metrics-&gt;x_ppem &lt;&lt; 6,
1324                                          face-&gt;root.units_per_EM );
1325       size_metrics-&gt;y_scale = FT_DivFix( size_metrics-&gt;y_ppem &lt;&lt; 6,
1326                                          face-&gt;root.units_per_EM );
1327 
1328       size_metrics-&gt;max_advance = FT_PIX_ROUND(
1329                                     FT_MulFix( face-&gt;root.max_advance_width,
1330                                                size_metrics-&gt;x_scale ) );
1331     }
1332 
1333     /* compute new transformation */
1334     if ( size_metrics-&gt;x_ppem &gt;= size_metrics-&gt;y_ppem )
1335     {
1336       size-&gt;ttmetrics.scale   = size_metrics-&gt;x_scale;
1337       size-&gt;ttmetrics.ppem    = size_metrics-&gt;x_ppem;
1338       size-&gt;ttmetrics.x_ratio = 0x10000L;
1339       size-&gt;ttmetrics.y_ratio = FT_DivFix( size_metrics-&gt;y_ppem,
1340                                            size_metrics-&gt;x_ppem );
1341     }
1342     else
1343     {
1344       size-&gt;ttmetrics.scale   = size_metrics-&gt;y_scale;
1345       size-&gt;ttmetrics.ppem    = size_metrics-&gt;y_ppem;
1346       size-&gt;ttmetrics.x_ratio = FT_DivFix( size_metrics-&gt;x_ppem,
1347                                            size_metrics-&gt;y_ppem );
1348       size-&gt;ttmetrics.y_ratio = 0x10000L;
1349     }
1350 
1351     size-&gt;metrics = size_metrics;
1352 
1353 #ifdef TT_USE_BYTECODE_INTERPRETER
1354     size-&gt;cvt_ready = -1;
1355 #endif /* TT_USE_BYTECODE_INTERPRETER */
1356 
1357     return FT_Err_Ok;
1358   }
1359 
1360 
<a name="20" id="anc20"></a><span class="line-modified">1361   /*************************************************************************/</span>
<span class="line-modified">1362   /*                                                                       */</span>
<span class="line-modified">1363   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1364   /*    tt_driver_init                                                     */</span>
<span class="line-modified">1365   /*                                                                       */</span>
<span class="line-modified">1366   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1367   /*    Initialize a given TrueType driver object.                         */</span>
<span class="line-modified">1368   /*                                                                       */</span>
<span class="line-modified">1369   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1370   /*    driver :: A handle to the target driver object.                    */</span>
<span class="line-modified">1371   /*                                                                       */</span>
<span class="line-modified">1372   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1373   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1374   /*                                                                       */</span>

1375   FT_LOCAL_DEF( FT_Error )
1376   tt_driver_init( FT_Module  ttdriver )     /* TT_Driver */
1377   {
1378 
1379 #ifdef TT_USE_BYTECODE_INTERPRETER
1380 
1381     TT_Driver  driver = (TT_Driver)ttdriver;
1382 
1383     driver-&gt;interpreter_version = TT_INTERPRETER_VERSION_35;
1384 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1385     driver-&gt;interpreter_version = TT_INTERPRETER_VERSION_38;
1386 #endif
1387 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1388     driver-&gt;interpreter_version = TT_INTERPRETER_VERSION_40;
1389 #endif
1390 
1391 #else /* !TT_USE_BYTECODE_INTERPRETER */
1392 
1393     FT_UNUSED( ttdriver );
1394 
1395 #endif /* !TT_USE_BYTECODE_INTERPRETER */
1396 
1397     return FT_Err_Ok;
1398   }
1399 
1400 
<a name="21" id="anc21"></a><span class="line-modified">1401   /*************************************************************************/</span>
<span class="line-modified">1402   /*                                                                       */</span>
<span class="line-modified">1403   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1404   /*    tt_driver_done                                                     */</span>
<span class="line-modified">1405   /*                                                                       */</span>
<span class="line-modified">1406   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1407   /*    Finalize a given TrueType driver.                                  */</span>
<span class="line-modified">1408   /*                                                                       */</span>
<span class="line-modified">1409   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1410   /*    driver :: A handle to the target TrueType driver.                  */</span>
<span class="line-modified">1411   /*                                                                       */</span>

1412   FT_LOCAL_DEF( void )
1413   tt_driver_done( FT_Module  ttdriver )     /* TT_Driver */
1414   {
1415     FT_UNUSED( ttdriver );
1416   }
1417 
1418 
<a name="22" id="anc22"></a><span class="line-modified">1419   /*************************************************************************/</span>
<span class="line-modified">1420   /*                                                                       */</span>
<span class="line-modified">1421   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1422   /*    tt_slot_init                                                       */</span>
<span class="line-modified">1423   /*                                                                       */</span>
<span class="line-modified">1424   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1425   /*    Initialize a new slot object.                                      */</span>
<span class="line-modified">1426   /*                                                                       */</span>
<span class="line-modified">1427   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1428   /*    slot :: A handle to the slot object.                               */</span>
<span class="line-modified">1429   /*                                                                       */</span>
<span class="line-modified">1430   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1431   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1432   /*                                                                       */</span>

1433   FT_LOCAL_DEF( FT_Error )
1434   tt_slot_init( FT_GlyphSlot  slot )
1435   {
1436     return FT_GlyphLoader_CreateExtra( slot-&gt;internal-&gt;loader );
1437   }
1438 
1439 
1440 /* END */
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
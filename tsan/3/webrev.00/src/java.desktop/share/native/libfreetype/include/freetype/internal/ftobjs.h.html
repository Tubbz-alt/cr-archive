<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/include/freetype/internal/ftobjs.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /****************************************************************************
   2  *
   3  * ftobjs.h
   4  *
   5  *   The FreeType private base classes (specification).
   6  *
   7  * Copyright (C) 1996-2019 by
   8  * David Turner, Robert Wilhelm, and Werner Lemberg.
   9  *
  10  * This file is part of the FreeType project, and may only be used,
  11  * modified, and distributed under the terms of the FreeType project
  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
  13  * this file you indicate that you have read the license and
  14  * understand and accept it fully.
  15  *
  16  */
  17 
  18 
  19   /**************************************************************************
  20    *
  21    * This file contains the definition of all internal FreeType classes.
  22    *
  23    */
  24 
  25 
  26 #ifndef FTOBJS_H_
  27 #define FTOBJS_H_
  28 
  29 #include &lt;ft2build.h&gt;
  30 #include FT_RENDER_H
  31 #include FT_SIZES_H
  32 #include FT_LCD_FILTER_H
  33 #include FT_INTERNAL_MEMORY_H
  34 #include FT_INTERNAL_GLYPH_LOADER_H
  35 #include FT_INTERNAL_DRIVER_H
  36 #include FT_INTERNAL_AUTOHINT_H
  37 #include FT_INTERNAL_SERVICE_H
  38 #include FT_INTERNAL_CALC_H
  39 
  40 #ifdef FT_CONFIG_OPTION_INCREMENTAL
  41 #include FT_INCREMENTAL_H
  42 #endif
  43 
  44 
  45 FT_BEGIN_HEADER
  46 
  47 
  48   /**************************************************************************
  49    *
  50    * Some generic definitions.
  51    */
  52 #ifndef TRUE
  53 #define TRUE  1
  54 #endif
  55 
  56 #ifndef FALSE
  57 #define FALSE  0
  58 #endif
  59 
  60 #ifndef NULL
  61 #define NULL  (void*)0
  62 #endif
  63 
  64 
  65   /**************************************************************************
  66    *
  67    * The min and max functions missing in C.  As usual, be careful not to
  68    * write things like FT_MIN( a++, b++ ) to avoid side effects.
  69    */
  70 #define FT_MIN( a, b )  ( (a) &lt; (b) ? (a) : (b) )
  71 #define FT_MAX( a, b )  ( (a) &gt; (b) ? (a) : (b) )
  72 
  73 #define FT_ABS( a )     ( (a) &lt; 0 ? -(a) : (a) )
  74 
  75   /*
  76    * Approximate sqrt(x*x+y*y) using the `alpha max plus beta min&#39; algorithm.
  77    * We use alpha = 1, beta = 3/8, giving us results with a largest error
  78    * less than 7% compared to the exact value.
  79    */
  80 #define FT_HYPOT( x, y )                 \
  81           ( x = FT_ABS( x ),             \
  82             y = FT_ABS( y ),             \
  83             x &gt; y ? x + ( 3 * y &gt;&gt; 3 )   \
  84                   : y + ( 3 * x &gt;&gt; 3 ) )
  85 
  86   /* we use FT_TYPEOF to suppress signedness compilation warnings */
  87 #define FT_PAD_FLOOR( x, n )  ( (x) &amp; ~FT_TYPEOF( x )( (n) - 1 ) )
  88 #define FT_PAD_ROUND( x, n )  FT_PAD_FLOOR( (x) + (n) / 2, n )
  89 #define FT_PAD_CEIL( x, n )   FT_PAD_FLOOR( (x) + (n) - 1, n )
  90 
  91 #define FT_PIX_FLOOR( x )     ( (x) &amp; ~FT_TYPEOF( x )63 )
  92 #define FT_PIX_ROUND( x )     FT_PIX_FLOOR( (x) + 32 )
  93 #define FT_PIX_CEIL( x )      FT_PIX_FLOOR( (x) + 63 )
  94 
  95   /* specialized versions (for signed values)                   */
  96   /* that don&#39;t produce run-time errors due to integer overflow */
  97 #define FT_PAD_ROUND_LONG( x, n )  FT_PAD_FLOOR( ADD_LONG( (x), (n) / 2 ), \
  98                                                  n )
  99 #define FT_PAD_CEIL_LONG( x, n )   FT_PAD_FLOOR( ADD_LONG( (x), (n) - 1 ), \
 100                                                  n )
 101 #define FT_PIX_ROUND_LONG( x )     FT_PIX_FLOOR( ADD_LONG( (x), 32 ) )
 102 #define FT_PIX_CEIL_LONG( x )      FT_PIX_FLOOR( ADD_LONG( (x), 63 ) )
 103 
 104 #define FT_PAD_ROUND_INT32( x, n )  FT_PAD_FLOOR( ADD_INT32( (x), (n) / 2 ), \
 105                                                   n )
 106 #define FT_PAD_CEIL_INT32( x, n )   FT_PAD_FLOOR( ADD_INT32( (x), (n) - 1 ), \
 107                                                   n )
 108 #define FT_PIX_ROUND_INT32( x )     FT_PIX_FLOOR( ADD_INT32( (x), 32 ) )
 109 #define FT_PIX_CEIL_INT32( x )      FT_PIX_FLOOR( ADD_INT32( (x), 63 ) )
 110 
 111 
 112   /*
 113    * character classification functions -- since these are used to parse font
 114    * files, we must not use those in &lt;ctypes.h&gt; which are locale-dependent
 115    */
 116 #define  ft_isdigit( x )   ( ( (unsigned)(x) - &#39;0&#39; ) &lt; 10U )
 117 
 118 #define  ft_isxdigit( x )  ( ( (unsigned)(x) - &#39;0&#39; ) &lt; 10U || \
 119                              ( (unsigned)(x) - &#39;a&#39; ) &lt; 6U  || \
 120                              ( (unsigned)(x) - &#39;A&#39; ) &lt; 6U  )
 121 
 122   /* the next two macros assume ASCII representation */
 123 #define  ft_isupper( x )  ( ( (unsigned)(x) - &#39;A&#39; ) &lt; 26U )
 124 #define  ft_islower( x )  ( ( (unsigned)(x) - &#39;a&#39; ) &lt; 26U )
 125 
 126 #define  ft_isalpha( x )  ( ft_isupper( x ) || ft_islower( x ) )
 127 #define  ft_isalnum( x )  ( ft_isdigit( x ) || ft_isalpha( x ) )
 128 
 129 
 130   /*************************************************************************/
 131   /*************************************************************************/
 132   /*************************************************************************/
 133   /****                                                                 ****/
 134   /****                                                                 ****/
 135   /****                       C H A R M A P S                           ****/
 136   /****                                                                 ****/
 137   /****                                                                 ****/
 138   /*************************************************************************/
 139   /*************************************************************************/
 140   /*************************************************************************/
 141 
 142   /* handle to internal charmap object */
 143   typedef struct FT_CMapRec_*              FT_CMap;
 144 
 145   /* handle to charmap class structure */
 146   typedef const struct FT_CMap_ClassRec_*  FT_CMap_Class;
 147 
 148   /* internal charmap object structure */
 149   typedef struct  FT_CMapRec_
 150   {
 151     FT_CharMapRec  charmap;
 152     FT_CMap_Class  clazz;
 153 
 154   } FT_CMapRec;
 155 
 156   /* typecast any pointer to a charmap handle */
 157 #define FT_CMAP( x )  ( (FT_CMap)( x ) )
 158 
 159   /* obvious macros */
 160 #define FT_CMAP_PLATFORM_ID( x )  FT_CMAP( x )-&gt;charmap.platform_id
 161 #define FT_CMAP_ENCODING_ID( x )  FT_CMAP( x )-&gt;charmap.encoding_id
 162 #define FT_CMAP_ENCODING( x )     FT_CMAP( x )-&gt;charmap.encoding
 163 #define FT_CMAP_FACE( x )         FT_CMAP( x )-&gt;charmap.face
 164 
 165 
 166   /* class method definitions */
 167   typedef FT_Error
 168   (*FT_CMap_InitFunc)( FT_CMap     cmap,
 169                        FT_Pointer  init_data );
 170 
 171   typedef void
 172   (*FT_CMap_DoneFunc)( FT_CMap  cmap );
 173 
 174   typedef FT_UInt
 175   (*FT_CMap_CharIndexFunc)( FT_CMap    cmap,
 176                             FT_UInt32  char_code );
 177 
 178   typedef FT_UInt
 179   (*FT_CMap_CharNextFunc)( FT_CMap     cmap,
 180                            FT_UInt32  *achar_code );
 181 
 182   typedef FT_UInt
 183   (*FT_CMap_CharVarIndexFunc)( FT_CMap    cmap,
 184                                FT_CMap    unicode_cmap,
 185                                FT_UInt32  char_code,
 186                                FT_UInt32  variant_selector );
 187 
 188   typedef FT_Int
 189   (*FT_CMap_CharVarIsDefaultFunc)( FT_CMap    cmap,
 190                                    FT_UInt32  char_code,
 191                                    FT_UInt32  variant_selector );
 192 
 193   typedef FT_UInt32 *
 194   (*FT_CMap_VariantListFunc)( FT_CMap    cmap,
 195                               FT_Memory  mem );
 196 
 197   typedef FT_UInt32 *
 198   (*FT_CMap_CharVariantListFunc)( FT_CMap    cmap,
 199                                   FT_Memory  mem,
 200                                   FT_UInt32  char_code );
 201 
 202   typedef FT_UInt32 *
 203   (*FT_CMap_VariantCharListFunc)( FT_CMap    cmap,
 204                                   FT_Memory  mem,
 205                                   FT_UInt32  variant_selector );
 206 
 207 
 208   typedef struct  FT_CMap_ClassRec_
 209   {
 210     FT_ULong               size;
 211 
 212     FT_CMap_InitFunc       init;
 213     FT_CMap_DoneFunc       done;
 214     FT_CMap_CharIndexFunc  char_index;
 215     FT_CMap_CharNextFunc   char_next;
 216 
 217     /* Subsequent entries are special ones for format 14 -- the variant */
 218     /* selector subtable which behaves like no other                    */
 219 
 220     FT_CMap_CharVarIndexFunc      char_var_index;
 221     FT_CMap_CharVarIsDefaultFunc  char_var_default;
 222     FT_CMap_VariantListFunc       variant_list;
 223     FT_CMap_CharVariantListFunc   charvariant_list;
 224     FT_CMap_VariantCharListFunc   variantchar_list;
 225 
 226   } FT_CMap_ClassRec;
 227 
 228 
 229 #define FT_DECLARE_CMAP_CLASS( class_ )              \
 230   FT_CALLBACK_TABLE const  FT_CMap_ClassRec class_;
 231 
 232 #define FT_DEFINE_CMAP_CLASS(       \
 233           class_,                   \
 234           size_,                    \
 235           init_,                    \
 236           done_,                    \
 237           char_index_,              \
 238           char_next_,               \
 239           char_var_index_,          \
 240           char_var_default_,        \
 241           variant_list_,            \
 242           charvariant_list_,        \
 243           variantchar_list_ )       \
 244   FT_CALLBACK_TABLE_DEF             \
 245   const FT_CMap_ClassRec  class_ =  \
 246   {                                 \
 247     size_,                          \
 248     init_,                          \
 249     done_,                          \
 250     char_index_,                    \
 251     char_next_,                     \
 252     char_var_index_,                \
 253     char_var_default_,              \
 254     variant_list_,                  \
 255     charvariant_list_,              \
 256     variantchar_list_               \
 257   };
 258 
 259 
 260   /* create a new charmap and add it to charmap-&gt;face */
 261   FT_BASE( FT_Error )
 262   FT_CMap_New( FT_CMap_Class  clazz,
 263                FT_Pointer     init_data,
 264                FT_CharMap     charmap,
 265                FT_CMap       *acmap );
 266 
 267   /* destroy a charmap and remove it from face&#39;s list */
 268   FT_BASE( void )
 269   FT_CMap_Done( FT_CMap  cmap );
 270 
 271 
 272   /* add LCD padding to CBox */
 273   FT_BASE( void )
 274   ft_lcd_padding( FT_BBox*        cbox,
 275                   FT_GlyphSlot    slot,
 276                   FT_Render_Mode  mode );
 277 
 278 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 279 
 280   typedef void  (*FT_Bitmap_LcdFilterFunc)( FT_Bitmap*      bitmap,
 281                                             FT_Byte*        weights );
 282 
 283 
 284   /* This is the default LCD filter, an in-place, 5-tap FIR filter. */
 285   FT_BASE( void )
 286   ft_lcd_filter_fir( FT_Bitmap*           bitmap,
 287                      FT_LcdFiveTapFilter  weights );
 288 
 289 #endif /* FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
 290 
 291   /**************************************************************************
 292    *
 293    * @struct:
 294    *   FT_Face_InternalRec
 295    *
 296    * @description:
 297    *   This structure contains the internal fields of each FT_Face object.
 298    *   These fields may change between different releases of FreeType.
 299    *
 300    * @fields:
 301    *   max_points ::
 302    *     The maximum number of points used to store the vectorial outline of
 303    *     any glyph in this face.  If this value cannot be known in advance,
 304    *     or if the face isn&#39;t scalable, this should be set to 0.  Only
 305    *     relevant for scalable formats.
 306    *
 307    *   max_contours ::
 308    *     The maximum number of contours used to store the vectorial outline
 309    *     of any glyph in this face.  If this value cannot be known in
 310    *     advance, or if the face isn&#39;t scalable, this should be set to 0.
 311    *     Only relevant for scalable formats.
 312    *
 313    *   transform_matrix ::
 314    *     A 2x2 matrix of 16.16 coefficients used to transform glyph outlines
 315    *     after they are loaded from the font.  Only used by the convenience
 316    *     functions.
 317    *
 318    *   transform_delta ::
 319    *     A translation vector used to transform glyph outlines after they are
 320    *     loaded from the font.  Only used by the convenience functions.
 321    *
 322    *   transform_flags ::
 323    *     Some flags used to classify the transform.  Only used by the
 324    *     convenience functions.
 325    *
 326    *   services ::
 327    *     A cache for frequently used services.  It should be only accessed
 328    *     with the macro `FT_FACE_LOOKUP_SERVICE`.
 329    *
 330    *   incremental_interface ::
 331    *     If non-null, the interface through which glyph data and metrics are
 332    *     loaded incrementally for faces that do not provide all of this data
 333    *     when first opened.  This field exists only if
 334    *     @FT_CONFIG_OPTION_INCREMENTAL is defined.
 335    *
 336    *   no_stem_darkening ::
 337    *     Overrides the module-level default, see @stem-darkening[cff], for
 338    *     example.  FALSE and TRUE toggle stem darkening on and off,
 339    *     respectively, value~-1 means to use the module/driver default.
 340    *
 341    *   random_seed ::
 342    *     If positive, override the seed value for the CFF &#39;random&#39; operator.
 343    *     Value~0 means to use the font&#39;s value.  Value~-1 means to use the
 344    *     CFF driver&#39;s default.
 345    *
 346    *   lcd_weights ::
 347    *   lcd_filter_func ::
 348    *     These fields specify the LCD filtering weights and callback function
 349    *     for ClearType-style subpixel rendering.
 350    *
 351    *   refcount ::
 352    *     A counter initialized to~1 at the time an @FT_Face structure is
 353    *     created.  @FT_Reference_Face increments this counter, and
 354    *     @FT_Done_Face only destroys a face if the counter is~1, otherwise it
 355    *     simply decrements it.
 356    */
 357   typedef struct  FT_Face_InternalRec_
 358   {
 359     FT_Matrix  transform_matrix;
 360     FT_Vector  transform_delta;
 361     FT_Int     transform_flags;
 362 
 363     FT_ServiceCacheRec  services;
 364 
 365 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 366     FT_Incremental_InterfaceRec*  incremental_interface;
 367 #endif
 368 
 369     FT_Char              no_stem_darkening;
 370     FT_Int32             random_seed;
 371 
 372 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 373     FT_LcdFiveTapFilter      lcd_weights;      /* filter weights, if any */
 374     FT_Bitmap_LcdFilterFunc  lcd_filter_func;  /* filtering callback     */
 375 #endif
 376 
 377     FT_Int  refcount;
 378 
 379   } FT_Face_InternalRec;
 380 
 381 
 382   /**************************************************************************
 383    *
 384    * @struct:
 385    *   FT_Slot_InternalRec
 386    *
 387    * @description:
 388    *   This structure contains the internal fields of each FT_GlyphSlot
 389    *   object.  These fields may change between different releases of
 390    *   FreeType.
 391    *
 392    * @fields:
 393    *   loader ::
 394    *     The glyph loader object used to load outlines into the glyph slot.
 395    *
 396    *   flags ::
 397    *     Possible values are zero or FT_GLYPH_OWN_BITMAP.  The latter
 398    *     indicates that the FT_GlyphSlot structure owns the bitmap buffer.
 399    *
 400    *   glyph_transformed ::
 401    *     Boolean.  Set to TRUE when the loaded glyph must be transformed
 402    *     through a specific font transformation.  This is _not_ the same as
 403    *     the face transform set through FT_Set_Transform().
 404    *
 405    *   glyph_matrix ::
 406    *     The 2x2 matrix corresponding to the glyph transformation, if
 407    *     necessary.
 408    *
 409    *   glyph_delta ::
 410    *     The 2d translation vector corresponding to the glyph transformation,
 411    *     if necessary.
 412    *
 413    *   glyph_hints ::
 414    *     Format-specific glyph hints management.
 415    *
 416    *   load_flags ::
 417    *     The load flags passed as an argument to @FT_Load_Glyph while
 418    *     initializing the glyph slot.
 419    */
 420 
 421 #define FT_GLYPH_OWN_BITMAP  0x1U
 422 
 423   typedef struct  FT_Slot_InternalRec_
 424   {
 425     FT_GlyphLoader  loader;
 426     FT_UInt         flags;
 427     FT_Bool         glyph_transformed;
 428     FT_Matrix       glyph_matrix;
 429     FT_Vector       glyph_delta;
 430     void*           glyph_hints;
 431 
 432     FT_Int32        load_flags;
 433 
 434   } FT_GlyphSlot_InternalRec;
 435 
 436 
 437   /**************************************************************************
 438    *
 439    * @struct:
 440    *   FT_Size_InternalRec
 441    *
 442    * @description:
 443    *   This structure contains the internal fields of each FT_Size object.
 444    *
 445    * @fields:
 446    *   module_data ::
 447    *     Data specific to a driver module.
 448    *
 449    *   autohint_mode ::
 450    *     The used auto-hinting mode.
 451    *
 452    *   autohint_metrics ::
 453    *     Metrics used by the auto-hinter.
 454    *
 455    */
 456 
 457   typedef struct  FT_Size_InternalRec_
 458   {
 459     void*  module_data;
 460 
 461     FT_Render_Mode   autohint_mode;
 462     FT_Size_Metrics  autohint_metrics;
 463 
 464   } FT_Size_InternalRec;
 465 
 466 
 467   /*************************************************************************/
 468   /*************************************************************************/
 469   /*************************************************************************/
 470   /****                                                                 ****/
 471   /****                                                                 ****/
 472   /****                         M O D U L E S                           ****/
 473   /****                                                                 ****/
 474   /****                                                                 ****/
 475   /*************************************************************************/
 476   /*************************************************************************/
 477   /*************************************************************************/
 478 
 479 
 480   /**************************************************************************
 481    *
 482    * @struct:
 483    *   FT_ModuleRec
 484    *
 485    * @description:
 486    *   A module object instance.
 487    *
 488    * @fields:
 489    *   clazz ::
 490    *     A pointer to the module&#39;s class.
 491    *
 492    *   library ::
 493    *     A handle to the parent library object.
 494    *
 495    *   memory ::
 496    *     A handle to the memory manager.
 497    */
 498   typedef struct  FT_ModuleRec_
 499   {
 500     FT_Module_Class*  clazz;
 501     FT_Library        library;
 502     FT_Memory         memory;
 503 
 504   } FT_ModuleRec;
 505 
 506 
 507   /* typecast an object to an FT_Module */
 508 #define FT_MODULE( x )  ( (FT_Module)(x) )
 509 
 510 #define FT_MODULE_CLASS( x )    FT_MODULE( x )-&gt;clazz
 511 #define FT_MODULE_LIBRARY( x )  FT_MODULE( x )-&gt;library
 512 #define FT_MODULE_MEMORY( x )   FT_MODULE( x )-&gt;memory
 513 
 514 
 515 #define FT_MODULE_IS_DRIVER( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 516                                     FT_MODULE_FONT_DRIVER )
 517 
 518 #define FT_MODULE_IS_RENDERER( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 519                                       FT_MODULE_RENDERER )
 520 
 521 #define FT_MODULE_IS_HINTER( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 522                                     FT_MODULE_HINTER )
 523 
 524 #define FT_MODULE_IS_STYLER( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 525                                     FT_MODULE_STYLER )
 526 
 527 #define FT_DRIVER_IS_SCALABLE( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 528                                       FT_MODULE_DRIVER_SCALABLE )
 529 
 530 #define FT_DRIVER_USES_OUTLINES( x )  !( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 531                                          FT_MODULE_DRIVER_NO_OUTLINES )
 532 
 533 #define FT_DRIVER_HAS_HINTER( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 534                                      FT_MODULE_DRIVER_HAS_HINTER )
 535 
 536 #define FT_DRIVER_HINTS_LIGHTLY( x )  ( FT_MODULE_CLASS( x )-&gt;module_flags &amp; \
 537                                         FT_MODULE_DRIVER_HINTS_LIGHTLY )
 538 
 539 
 540   /**************************************************************************
 541    *
 542    * @function:
 543    *   FT_Get_Module_Interface
 544    *
 545    * @description:
 546    *   Finds a module and returns its specific interface as a typeless
 547    *   pointer.
 548    *
 549    * @input:
 550    *   library ::
 551    *     A handle to the library object.
 552    *
 553    *   module_name ::
 554    *     The module&#39;s name (as an ASCII string).
 555    *
 556    * @return:
 557    *   A module-specific interface if available, 0 otherwise.
 558    *
 559    * @note:
 560    *   You should better be familiar with FreeType internals to know which
 561    *   module to look for, and what its interface is :-)
 562    */
 563   FT_BASE( const void* )
 564   FT_Get_Module_Interface( FT_Library   library,
 565                            const char*  mod_name );
 566 
 567   FT_BASE( FT_Pointer )
 568   ft_module_get_service( FT_Module    module,
 569                          const char*  service_id,
 570                          FT_Bool      global );
 571 
 572 #ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
 573   FT_BASE( FT_Error )
 574   ft_property_string_set( FT_Library        library,
 575                           const FT_String*  module_name,
 576                           const FT_String*  property_name,
 577                           FT_String*        value );
 578 #endif
 579 
 580   /* */
 581 
 582 
 583   /*************************************************************************/
 584   /*************************************************************************/
 585   /*************************************************************************/
 586   /****                                                                 ****/
 587   /****                                                                 ****/
 588   /****   F A C E,   S I Z E   &amp;   G L Y P H   S L O T   O B J E C T S  ****/
 589   /****                                                                 ****/
 590   /****                                                                 ****/
 591   /*************************************************************************/
 592   /*************************************************************************/
 593   /*************************************************************************/
 594 
 595   /* a few macros used to perform easy typecasts with minimal brain damage */
 596 
 597 #define FT_FACE( x )          ( (FT_Face)(x) )
 598 #define FT_SIZE( x )          ( (FT_Size)(x) )
 599 #define FT_SLOT( x )          ( (FT_GlyphSlot)(x) )
 600 
 601 #define FT_FACE_DRIVER( x )   FT_FACE( x )-&gt;driver
 602 #define FT_FACE_LIBRARY( x )  FT_FACE_DRIVER( x )-&gt;root.library
 603 #define FT_FACE_MEMORY( x )   FT_FACE( x )-&gt;memory
 604 #define FT_FACE_STREAM( x )   FT_FACE( x )-&gt;stream
 605 
 606 #define FT_SIZE_FACE( x )     FT_SIZE( x )-&gt;face
 607 #define FT_SLOT_FACE( x )     FT_SLOT( x )-&gt;face
 608 
 609 #define FT_FACE_SLOT( x )     FT_FACE( x )-&gt;glyph
 610 #define FT_FACE_SIZE( x )     FT_FACE( x )-&gt;size
 611 
 612 
 613   /**************************************************************************
 614    *
 615    * @function:
 616    *   FT_New_GlyphSlot
 617    *
 618    * @description:
 619    *   It is sometimes useful to have more than one glyph slot for a given
 620    *   face object.  This function is used to create additional slots.  All
 621    *   of them are automatically discarded when the face is destroyed.
 622    *
 623    * @input:
 624    *   face ::
 625    *     A handle to a parent face object.
 626    *
 627    * @output:
 628    *   aslot ::
 629    *     A handle to a new glyph slot object.
 630    *
 631    * @return:
 632    *   FreeType error code.  0 means success.
 633    */
 634   FT_BASE( FT_Error )
 635   FT_New_GlyphSlot( FT_Face        face,
 636                     FT_GlyphSlot  *aslot );
 637 
 638 
 639   /**************************************************************************
 640    *
 641    * @function:
 642    *   FT_Done_GlyphSlot
 643    *
 644    * @description:
 645    *   Destroys a given glyph slot.  Remember however that all slots are
 646    *   automatically destroyed with its parent.  Using this function is not
 647    *   always mandatory.
 648    *
 649    * @input:
 650    *   slot ::
 651    *     A handle to a target glyph slot.
 652    */
 653   FT_BASE( void )
 654   FT_Done_GlyphSlot( FT_GlyphSlot  slot );
 655 
 656  /* */
 657 
 658 #define FT_REQUEST_WIDTH( req )                                            \
 659           ( (req)-&gt;horiResolution                                          \
 660               ? ( (req)-&gt;width * (FT_Pos)(req)-&gt;horiResolution + 36 ) / 72 \
 661               : (req)-&gt;width )
 662 
 663 #define FT_REQUEST_HEIGHT( req )                                            \
 664           ( (req)-&gt;vertResolution                                           \
 665               ? ( (req)-&gt;height * (FT_Pos)(req)-&gt;vertResolution + 36 ) / 72 \
 666               : (req)-&gt;height )
 667 
 668 
 669   /* Set the metrics according to a bitmap strike. */
 670   FT_BASE( void )
 671   FT_Select_Metrics( FT_Face   face,
 672                      FT_ULong  strike_index );
 673 
 674 
 675   /* Set the metrics according to a size request. */
 676   FT_BASE( void )
 677   FT_Request_Metrics( FT_Face          face,
 678                       FT_Size_Request  req );
 679 
 680 
 681   /* Match a size request against `available_sizes&#39;. */
 682   FT_BASE( FT_Error )
 683   FT_Match_Size( FT_Face          face,
 684                  FT_Size_Request  req,
 685                  FT_Bool          ignore_width,
 686                  FT_ULong*        size_index );
 687 
 688 
 689   /* Use the horizontal metrics to synthesize the vertical metrics. */
 690   /* If `advance&#39; is zero, it is also synthesized.                  */
 691   FT_BASE( void )
 692   ft_synthesize_vertical_metrics( FT_Glyph_Metrics*  metrics,
 693                                   FT_Pos             advance );
 694 
 695 
 696   /* Free the bitmap of a given glyphslot when needed (i.e., only when it */
 697   /* was allocated with ft_glyphslot_alloc_bitmap).                       */
 698   FT_BASE( void )
 699   ft_glyphslot_free_bitmap( FT_GlyphSlot  slot );
 700 
 701 
 702   /* Preset bitmap metrics of an outline glyphslot prior to rendering */
 703   /* and check whether the truncated bbox is too large for rendering. */
 704   FT_BASE( FT_Bool )
 705   ft_glyphslot_preset_bitmap( FT_GlyphSlot      slot,
 706                               FT_Render_Mode    mode,
 707                               const FT_Vector*  origin );
 708 
 709   /* Allocate a new bitmap buffer in a glyph slot. */
 710   FT_BASE( FT_Error )
 711   ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
 712                              FT_ULong      size );
 713 
 714 
 715   /* Set the bitmap buffer in a glyph slot to a given pointer.  The buffer */
 716   /* will not be freed by a later call to ft_glyphslot_free_bitmap.        */
 717   FT_BASE( void )
 718   ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
 719                            FT_Byte*      buffer );
 720 
 721 
 722   /*************************************************************************/
 723   /*************************************************************************/
 724   /*************************************************************************/
 725   /****                                                                 ****/
 726   /****                                                                 ****/
 727   /****                        R E N D E R E R S                        ****/
 728   /****                                                                 ****/
 729   /****                                                                 ****/
 730   /*************************************************************************/
 731   /*************************************************************************/
 732   /*************************************************************************/
 733 
 734 
 735 #define FT_RENDERER( x )       ( (FT_Renderer)(x) )
 736 #define FT_GLYPH( x )          ( (FT_Glyph)(x) )
 737 #define FT_BITMAP_GLYPH( x )   ( (FT_BitmapGlyph)(x) )
 738 #define FT_OUTLINE_GLYPH( x )  ( (FT_OutlineGlyph)(x) )
 739 
 740 
 741   typedef struct  FT_RendererRec_
 742   {
 743     FT_ModuleRec            root;
 744     FT_Renderer_Class*      clazz;
 745     FT_Glyph_Format         glyph_format;
 746     FT_Glyph_Class          glyph_class;
 747 
 748     FT_Raster               raster;
 749     FT_Raster_Render_Func   raster_render;
 750     FT_Renderer_RenderFunc  render;
 751 
 752   } FT_RendererRec;
 753 
 754 
 755   /*************************************************************************/
 756   /*************************************************************************/
 757   /*************************************************************************/
 758   /****                                                                 ****/
 759   /****                                                                 ****/
 760   /****                    F O N T   D R I V E R S                      ****/
 761   /****                                                                 ****/
 762   /****                                                                 ****/
 763   /*************************************************************************/
 764   /*************************************************************************/
 765   /*************************************************************************/
 766 
 767 
 768   /* typecast a module into a driver easily */
 769 #define FT_DRIVER( x )  ( (FT_Driver)(x) )
 770 
 771   /* typecast a module as a driver, and get its driver class */
 772 #define FT_DRIVER_CLASS( x )  FT_DRIVER( x )-&gt;clazz
 773 
 774 
 775   /**************************************************************************
 776    *
 777    * @struct:
 778    *   FT_DriverRec
 779    *
 780    * @description:
 781    *   The root font driver class.  A font driver is responsible for managing
 782    *   and loading font files of a given format.
 783    *
 784    * @fields:
 785    *   root ::
 786    *     Contains the fields of the root module class.
 787    *
 788    *   clazz ::
 789    *     A pointer to the font driver&#39;s class.  Note that this is NOT
 790    *     root.clazz.  &#39;class&#39; wasn&#39;t used as it is a reserved word in C++.
 791    *
 792    *   faces_list ::
 793    *     The list of faces currently opened by this driver.
 794    *
 795    *   glyph_loader ::
 796    *     Unused.  Used to be glyph loader for all faces managed by this
 797    *     driver.
 798    */
 799   typedef struct  FT_DriverRec_
 800   {
 801     FT_ModuleRec     root;
 802     FT_Driver_Class  clazz;
 803     FT_ListRec       faces_list;
 804     FT_GlyphLoader   glyph_loader;
 805 
 806   } FT_DriverRec;
 807 
 808 
 809   /*************************************************************************/
 810   /*************************************************************************/
 811   /*************************************************************************/
 812   /****                                                                 ****/
 813   /****                                                                 ****/
 814   /****                       L I B R A R I E S                         ****/
 815   /****                                                                 ****/
 816   /****                                                                 ****/
 817   /*************************************************************************/
 818   /*************************************************************************/
 819   /*************************************************************************/
 820 
 821 
 822   /**************************************************************************
 823    *
 824    * @struct:
 825    *   FT_LibraryRec
 826    *
 827    * @description:
 828    *   The FreeType library class.  This is the root of all FreeType data.
 829    *   Use FT_New_Library() to create a library object, and FT_Done_Library()
 830    *   to discard it and all child objects.
 831    *
 832    * @fields:
 833    *   memory ::
 834    *     The library&#39;s memory object.  Manages memory allocation.
 835    *
 836    *   version_major ::
 837    *     The major version number of the library.
 838    *
 839    *   version_minor ::
 840    *     The minor version number of the library.
 841    *
 842    *   version_patch ::
 843    *     The current patch level of the library.
 844    *
 845    *   num_modules ::
 846    *     The number of modules currently registered within this library.
 847    *     This is set to 0 for new libraries.  New modules are added through
 848    *     the FT_Add_Module() API function.
 849    *
 850    *   modules ::
 851    *     A table used to store handles to the currently registered
 852    *     modules. Note that each font driver contains a list of its opened
 853    *     faces.
 854    *
 855    *   renderers ::
 856    *     The list of renderers currently registered within the library.
 857    *
 858    *   cur_renderer ::
 859    *     The current outline renderer.  This is a shortcut used to avoid
 860    *     parsing the list on each call to FT_Outline_Render().  It is a
 861    *     handle to the current renderer for the FT_GLYPH_FORMAT_OUTLINE
 862    *     format.
 863    *
 864    *   auto_hinter ::
 865    *     The auto-hinter module interface.
 866    *
 867    *   debug_hooks ::
 868    *     An array of four function pointers that allow debuggers to hook into
 869    *     a font format&#39;s interpreter.  Currently, only the TrueType bytecode
 870    *     debugger uses this.
 871    *
 872    *   lcd_weights ::
 873    *     The LCD filter weights for ClearType-style subpixel rendering.
 874    *
 875    *   lcd_filter_func ::
 876    *     The LCD filtering callback function for for ClearType-style subpixel
 877    *     rendering.
 878    *
 879    *   lcd_geometry ::
 880    *     This array specifies LCD subpixel geometry and controls Harmony LCD
 881    *     rendering technique, alternative to ClearType.
 882    *
 883    *   pic_container ::
 884    *     Contains global structs and tables, instead of defining them
 885    *     globally.
 886    *
 887    *   refcount ::
 888    *     A counter initialized to~1 at the time an @FT_Library structure is
 889    *     created.  @FT_Reference_Library increments this counter, and
 890    *     @FT_Done_Library only destroys a library if the counter is~1,
 891    *     otherwise it simply decrements it.
 892    */
 893   typedef struct  FT_LibraryRec_
 894   {
 895     FT_Memory          memory;           /* library&#39;s memory manager */
 896 
 897     FT_Int             version_major;
 898     FT_Int             version_minor;
 899     FT_Int             version_patch;
 900 
 901     FT_UInt            num_modules;
 902     FT_Module          modules[FT_MAX_MODULES];  /* module objects  */
 903 
 904     FT_ListRec         renderers;        /* list of renderers        */
 905     FT_Renderer        cur_renderer;     /* current outline renderer */
 906     FT_Module          auto_hinter;
 907 
 908     FT_DebugHook_Func  debug_hooks[4];
 909 
 910 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 911     FT_LcdFiveTapFilter      lcd_weights;      /* filter weights, if any */
 912     FT_Bitmap_LcdFilterFunc  lcd_filter_func;  /* filtering callback     */
 913 #else
 914     FT_Vector                lcd_geometry[3];  /* RGB subpixel positions */
 915 #endif
 916 
 917     FT_Int             refcount;
 918 
 919   } FT_LibraryRec;
 920 
 921 
 922   FT_BASE( FT_Renderer )
 923   FT_Lookup_Renderer( FT_Library       library,
 924                       FT_Glyph_Format  format,
 925                       FT_ListNode*     node );
 926 
 927   FT_BASE( FT_Error )
 928   FT_Render_Glyph_Internal( FT_Library      library,
 929                             FT_GlyphSlot    slot,
 930                             FT_Render_Mode  render_mode );
 931 
 932   typedef const char*
 933   (*FT_Face_GetPostscriptNameFunc)( FT_Face  face );
 934 
 935   typedef FT_Error
 936   (*FT_Face_GetGlyphNameFunc)( FT_Face     face,
 937                                FT_UInt     glyph_index,
 938                                FT_Pointer  buffer,
 939                                FT_UInt     buffer_max );
 940 
 941   typedef FT_UInt
 942   (*FT_Face_GetGlyphNameIndexFunc)( FT_Face           face,
 943                                     const FT_String*  glyph_name );
 944 
 945 
 946 #ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
 947 
 948   /**************************************************************************
 949    *
 950    * @function:
 951    *   FT_New_Memory
 952    *
 953    * @description:
 954    *   Creates a new memory object.
 955    *
 956    * @return:
 957    *   A pointer to the new memory object.  0 in case of error.
 958    */
 959   FT_BASE( FT_Memory )
 960   FT_New_Memory( void );
 961 
 962 
 963   /**************************************************************************
 964    *
 965    * @function:
 966    *   FT_Done_Memory
 967    *
 968    * @description:
 969    *   Discards memory manager.
 970    *
 971    * @input:
 972    *   memory ::
 973    *     A handle to the memory manager.
 974    */
 975   FT_BASE( void )
 976   FT_Done_Memory( FT_Memory  memory );
 977 
 978 #endif /* !FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */
 979 
 980 
 981   /* Define default raster&#39;s interface.  The default raster is located in  */
 982   /* `src/base/ftraster.c&#39;.                                                */
 983   /*                                                                       */
 984   /* Client applications can register new rasters through the              */
 985   /* FT_Set_Raster() API.                                                  */
 986 
 987 #ifndef FT_NO_DEFAULT_RASTER
 988   FT_EXPORT_VAR( FT_Raster_Funcs )  ft_default_raster;
 989 #endif
 990 
 991 
 992   /**************************************************************************
 993    *
 994    * @macro:
 995    *   FT_DEFINE_OUTLINE_FUNCS
 996    *
 997    * @description:
 998    *   Used to initialize an instance of FT_Outline_Funcs struct.  The struct
 999    *   will be allocated in the global scope (or the scope where the macro is
1000    *   used).
1001    */
1002 #define FT_DEFINE_OUTLINE_FUNCS(           \
1003           class_,                          \
1004           move_to_,                        \
1005           line_to_,                        \
1006           conic_to_,                       \
1007           cubic_to_,                       \
1008           shift_,                          \
1009           delta_ )                         \
1010   static const  FT_Outline_Funcs class_ =  \
1011   {                                        \
1012     move_to_,                              \
1013     line_to_,                              \
1014     conic_to_,                             \
1015     cubic_to_,                             \
1016     shift_,                                \
1017     delta_                                 \
1018   };
1019 
1020 
1021   /**************************************************************************
1022    *
1023    * @macro:
1024    *   FT_DEFINE_RASTER_FUNCS
1025    *
1026    * @description:
1027    *   Used to initialize an instance of FT_Raster_Funcs struct.  The struct
1028    *   will be allocated in the global scope (or the scope where the macro is
1029    *   used).
1030    */
1031 #define FT_DEFINE_RASTER_FUNCS(    \
1032           class_,                  \
1033           glyph_format_,           \
1034           raster_new_,             \
1035           raster_reset_,           \
1036           raster_set_mode_,        \
1037           raster_render_,          \
1038           raster_done_ )           \
1039   const FT_Raster_Funcs  class_ =  \
1040   {                                \
1041     glyph_format_,                 \
1042     raster_new_,                   \
1043     raster_reset_,                 \
1044     raster_set_mode_,              \
1045     raster_render_,                \
1046     raster_done_                   \
1047   };
1048 
1049 
1050 
1051   /**************************************************************************
1052    *
1053    * @macro:
1054    *   FT_DEFINE_GLYPH
1055    *
1056    * @description:
1057    *   The struct will be allocated in the global scope (or the scope where
1058    *   the macro is used).
1059    */
1060 #define FT_DEFINE_GLYPH(          \
1061           class_,                 \
1062           size_,                  \
1063           format_,                \
1064           init_,                  \
1065           done_,                  \
1066           copy_,                  \
1067           transform_,             \
1068           bbox_,                  \
1069           prepare_ )              \
1070   FT_CALLBACK_TABLE_DEF           \
1071   const FT_Glyph_Class  class_ =  \
1072   {                               \
1073     size_,                        \
1074     format_,                      \
1075     init_,                        \
1076     done_,                        \
1077     copy_,                        \
1078     transform_,                   \
1079     bbox_,                        \
1080     prepare_                      \
1081   };
1082 
1083 
1084   /**************************************************************************
1085    *
1086    * @macro:
1087    *   FT_DECLARE_RENDERER
1088    *
1089    * @description:
1090    *   Used to create a forward declaration of a FT_Renderer_Class struct
1091    *   instance.
1092    *
1093    * @macro:
1094    *   FT_DEFINE_RENDERER
1095    *
1096    * @description:
1097    *   Used to initialize an instance of FT_Renderer_Class struct.
1098    *
1099    *   The struct will be allocated in the global scope (or the scope where
1100    *   the macro is used).
1101    */
1102 #define FT_DECLARE_RENDERER( class_ )               \
1103   FT_EXPORT_VAR( const FT_Renderer_Class ) class_;
1104 
1105 #define FT_DEFINE_RENDERER(                  \
1106           class_,                            \
1107           flags_,                            \
1108           size_,                             \
1109           name_,                             \
1110           version_,                          \
1111           requires_,                         \
1112           interface_,                        \
1113           init_,                             \
1114           done_,                             \
1115           get_interface_,                    \
1116           glyph_format_,                     \
1117           render_glyph_,                     \
1118           transform_glyph_,                  \
1119           get_glyph_cbox_,                   \
1120           set_mode_,                         \
1121           raster_class_ )                    \
1122   FT_CALLBACK_TABLE_DEF                      \
1123   const FT_Renderer_Class  class_ =          \
1124   {                                          \
1125     FT_DEFINE_ROOT_MODULE( flags_,           \
1126                            size_,            \
1127                            name_,            \
1128                            version_,         \
1129                            requires_,        \
1130                            interface_,       \
1131                            init_,            \
1132                            done_,            \
1133                            get_interface_ )  \
1134     glyph_format_,                           \
1135                                              \
1136     render_glyph_,                           \
1137     transform_glyph_,                        \
1138     get_glyph_cbox_,                         \
1139     set_mode_,                               \
1140                                              \
1141     raster_class_                            \
1142   };
1143 
1144 
1145   /**************************************************************************
1146    *
1147    * @macro:
1148    *   FT_DECLARE_MODULE
1149    *
1150    * @description:
1151    *   Used to create a forward declaration of a FT_Module_Class struct
1152    *   instance.
1153    *
1154    * @macro:
1155    *   FT_DEFINE_MODULE
1156    *
1157    * @description:
1158    *   Used to initialize an instance of an FT_Module_Class struct.
1159    *
1160    *   The struct will be allocated in the global scope (or the scope where
1161    *   the macro is used).
1162    *
1163    * @macro:
1164    *   FT_DEFINE_ROOT_MODULE
1165    *
1166    * @description:
1167    *   Used to initialize an instance of an FT_Module_Class struct inside
1168    *   another struct that contains it or in a function that initializes that
1169    *   containing struct.
1170    */
1171 #define FT_DECLARE_MODULE( class_ )  \
1172   FT_CALLBACK_TABLE                  \
1173   const FT_Module_Class  class_;
1174 
1175 #define FT_DEFINE_ROOT_MODULE(  \
1176           flags_,               \
1177           size_,                \
1178           name_,                \
1179           version_,             \
1180           requires_,            \
1181           interface_,           \
1182           init_,                \
1183           done_,                \
1184           get_interface_ )      \
1185   {                             \
1186     flags_,                     \
1187     size_,                      \
1188                                 \
1189     name_,                      \
1190     version_,                   \
1191     requires_,                  \
1192                                 \
1193     interface_,                 \
1194                                 \
1195     init_,                      \
1196     done_,                      \
1197     get_interface_,             \
1198   },
1199 
1200 #define FT_DEFINE_MODULE(         \
1201           class_,                 \
1202           flags_,                 \
1203           size_,                  \
1204           name_,                  \
1205           version_,               \
1206           requires_,              \
1207           interface_,             \
1208           init_,                  \
1209           done_,                  \
1210           get_interface_ )        \
1211   FT_CALLBACK_TABLE_DEF           \
1212   const FT_Module_Class class_ =  \
1213   {                               \
1214     flags_,                       \
1215     size_,                        \
1216                                   \
1217     name_,                        \
1218     version_,                     \
1219     requires_,                    \
1220                                   \
1221     interface_,                   \
1222                                   \
1223     init_,                        \
1224     done_,                        \
1225     get_interface_,               \
1226   };
1227 
1228 
1229 FT_END_HEADER
1230 
1231 #endif /* FTOBJS_H_ */
1232 
1233 
1234 /* END */
    </pre>
  </body>
</html>
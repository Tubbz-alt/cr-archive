diff a/src/java.desktop/share/native/libfreetype/src/base/ftstroke.c b/src/java.desktop/share/native/libfreetype/src/base/ftstroke.c
--- a/src/java.desktop/share/native/libfreetype/src/base/ftstroke.c
+++ b/src/java.desktop/share/native/libfreetype/src/base/ftstroke.c
@@ -1,40 +1,35 @@
-/***************************************************************************/
-/*                                                                         */
-/*  ftstroke.c                                                             */
-/*                                                                         */
-/*    FreeType path stroker (body).                                        */
-/*                                                                         */
-/*  Copyright 2002-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * ftstroke.c
+ *
+ *   FreeType path stroker (body).
+ *
+ * Copyright (C) 2002-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include FT_STROKER_H
 #include FT_TRIGONOMETRY_H
 #include FT_OUTLINE_H
 #include FT_INTERNAL_MEMORY_H
 #include FT_INTERNAL_DEBUG_H
 #include FT_INTERNAL_OBJECTS_H
 
-#include "basepic.h"
 
-
-  /* declare an extern to access `ft_outline_glyph_class' globally     */
-  /* allocated  in `ftglyph.c', and use the FT_OUTLINE_GLYPH_CLASS_GET */
-  /* macro to access it when FT_CONFIG_OPTION_PIC is defined           */
-#ifndef FT_CONFIG_OPTION_PIC
+  /* declare an extern to access `ft_outline_glyph_class' globally */
+  /* allocated  in `ftglyph.c'                                     */
   FT_CALLBACK_TABLE const FT_Glyph_Class  ft_outline_glyph_class;
-#endif
 
 
   /* documentation is in ftstroke.h */
 
   FT_EXPORT_DEF( FT_StrokerBorder )
@@ -89,20 +84,22 @@
   {
     FT_Pos  a, b;
 
 
     base[4].x = base[2].x;
-    b = base[1].x;
-    a = base[3].x = ( base[2].x + b ) / 2;
-    b = base[1].x = ( base[0].x + b ) / 2;
-    base[2].x = ( a + b ) / 2;
+    a = base[0].x + base[1].x;
+    b = base[1].x + base[2].x;
+    base[3].x = b >> 1;
+    base[2].x = ( a + b ) >> 2;
+    base[1].x = a >> 1;
 
     base[4].y = base[2].y;
-    b = base[1].y;
-    a = base[3].y = ( base[2].y + b ) / 2;
-    b = base[1].y = ( base[0].y + b ) / 2;
-    base[2].y = ( a + b ) / 2;
+    a = base[0].y + base[1].y;
+    b = base[1].y + base[2].y;
+    base[3].y = b >> 1;
+    base[2].y = ( a + b ) >> 2;
+    base[1].y = a >> 1;
   }
 
 
   static FT_Bool
   ft_conic_is_small_enough( FT_Vector*  base,
@@ -156,32 +153,36 @@
 
 
   static void
   ft_cubic_split( FT_Vector*  base )
   {
-    FT_Pos  a, b, c, d;
+    FT_Pos  a, b, c;
 
 
     base[6].x = base[3].x;
-    c = base[1].x;
-    d = base[2].x;
-    base[1].x = a = ( base[0].x + c ) / 2;
-    base[5].x = b = ( base[3].x + d ) / 2;
-    c = ( c + d ) / 2;
-    base[2].x = a = ( a + c ) / 2;
-    base[4].x = b = ( b + c ) / 2;
-    base[3].x = ( a + b ) / 2;
+    a = base[0].x + base[1].x;
+    b = base[1].x + base[2].x;
+    c = base[2].x + base[3].x;
+    base[5].x = c >> 1;
+    c += b;
+    base[4].x = c >> 2;
+    base[1].x = a >> 1;
+    a += b;
+    base[2].x = a >> 2;
+    base[3].x = ( a + c ) >> 3;
 
     base[6].y = base[3].y;
-    c = base[1].y;
-    d = base[2].y;
-    base[1].y = a = ( base[0].y + c ) / 2;
-    base[5].y = b = ( base[3].y + d ) / 2;
-    c = ( c + d ) / 2;
-    base[2].y = a = ( a + c ) / 2;
-    base[4].y = b = ( b + c ) / 2;
-    base[3].y = ( a + b ) / 2;
+    a = base[0].y + base[1].y;
+    b = base[1].y + base[2].y;
+    c = base[2].y + base[3].y;
+    base[5].y = c >> 1;
+    c += b;
+    base[4].y = c >> 2;
+    base[1].y = a >> 1;
+    a += b;
+    base[2].y = a >> 2;
+    base[3].y = ( a + c ) >> 3;
   }
 
 
   /* Return the average of `angle1' and `angle2'.            */
   /* This gives correct result even if `angle1' and `angle2' */
@@ -370,10 +371,11 @@
     {
       /* copy the last point to the start of this sub-path, since */
       /* it contains the `adjusted' starting coordinates          */
       border->num_points    = --count;
       border->points[start] = border->points[count];
+      border->tags[start]   = border->tags[count];
 
       if ( reverse )
       {
         /* reverse the points */
         {
@@ -434,12 +436,12 @@
       /* move last point */
       border->points[border->num_points - 1] = *to;
     }
     else
     {
-      /* don't add zero-length lineto */
-      if ( border->num_points > 0                                          &&
+      /* don't add zero-length lineto, but always add moveto */
+      if ( border->num_points > (FT_UInt)border->start                     &&
            FT_IS_SMALL( border->points[border->num_points - 1].x - to->x ) &&
            FT_IS_SMALL( border->points[border->num_points - 1].y - to->y ) )
         return error;
 
       /* add one point */
@@ -2085,12 +2087,12 @@
 
 
   /* documentation is in ftstroke.h */
 
   /*
-   *  The following is very similar to FT_Outline_Decompose, except
-   *  that we do support opened paths, and do not scale the outline.
+   * The following is very similar to FT_Outline_Decompose, except
+   * that we do support opened paths, and do not scale the outline.
    */
   FT_EXPORT_DEF( FT_Error )
   FT_Stroker_ParseOutline( FT_Stroker   stroker,
                            FT_Outline*  outline,
                            FT_Bool      opened )
@@ -2304,21 +2306,16 @@
                    FT_Bool      destroy )
   {
     FT_Error  error = FT_ERR( Invalid_Argument );
     FT_Glyph  glyph = NULL;
 
-    /* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */
-    FT_Library  library = stroker->library;
-
-    FT_UNUSED( library );
-
 
     if ( !pglyph )
       goto Exit;
 
     glyph = *pglyph;
-    if ( !glyph || glyph->clazz != FT_OUTLINE_GLYPH_CLASS_GET )
+    if ( !glyph || glyph->clazz != &ft_outline_glyph_class )
       goto Exit;
 
     {
       FT_Glyph  copy;
 
@@ -2384,21 +2381,16 @@
                          FT_Bool      destroy )
   {
     FT_Error  error = FT_ERR( Invalid_Argument );
     FT_Glyph  glyph = NULL;
 
-    /* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */
-    FT_Library  library = stroker->library;
-
-    FT_UNUSED( library );
-
 
     if ( !pglyph )
       goto Exit;
 
     glyph = *pglyph;
-    if ( !glyph || glyph->clazz != FT_OUTLINE_GLYPH_CLASS_GET )
+    if ( !glyph || glyph->clazz != &ft_outline_glyph_class )
       goto Exit;
 
     {
       FT_Glyph  copy;
 

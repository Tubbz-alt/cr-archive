<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/include/freetype/config/ftconfig.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /****************************************************************************
  2  *
  3  * ftconfig.h
  4  *
  5  *   ANSI-specific configuration file (specification only).
  6  *
  7  * Copyright (C) 1996-2019 by
  8  * David Turner, Robert Wilhelm, and Werner Lemberg.
  9  *
 10  * This file is part of the FreeType project, and may only be used,
 11  * modified, and distributed under the terms of the FreeType project
 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 13  * this file you indicate that you have read the license and
 14  * understand and accept it fully.
 15  *
 16  */
 17 
 18 
 19   /**************************************************************************
 20    *
 21    * This header file contains a number of macro definitions that are used by
 22    * the rest of the engine.  Most of the macros here are automatically
 23    * determined at compile time, and you should not need to change it to port
 24    * FreeType, except to compile the library with a non-ANSI compiler.
 25    *
 26    * Note however that if some specific modifications are needed, we advise
 27    * you to place a modified copy in your build directory.
 28    *
 29    * The build directory is usually `builds/&lt;system&gt;`, and contains
 30    * system-specific files that are always included first when building the
 31    * library.
 32    *
 33    * This ANSI version should stay in `include/config/`.
 34    *
 35    */
 36 
 37 #ifndef FTCONFIG_H_
 38 #define FTCONFIG_H_
 39 
 40 #include &lt;ft2build.h&gt;
 41 #include FT_CONFIG_OPTIONS_H
 42 #include FT_CONFIG_STANDARD_LIBRARY_H
 43 
 44 
 45 FT_BEGIN_HEADER
 46 
 47 
 48   /**************************************************************************
 49    *
 50    *              PLATFORM-SPECIFIC CONFIGURATION MACROS
 51    *
 52    * These macros can be toggled to suit a specific system.  The current ones
 53    * are defaults used to compile FreeType in an ANSI C environment (16bit
 54    * compilers are also supported).  Copy this file to your own
 55    * `builds/&lt;system&gt;` directory, and edit it to port the engine.
 56    *
 57    */
 58 
 59 
 60   /* There are systems (like the Texas Instruments &#39;C54x) where a `char`  */
 61   /* has 16~bits.  ANSI~C says that `sizeof(char)` is always~1.  Since an */
 62   /* `int` has 16~bits also for this system, `sizeof(int)` gives~1 which  */
 63   /* is probably unexpected.                                              */
 64   /*                                                                      */
 65   /* `CHAR_BIT` (defined in `limits.h`) gives the number of bits in a     */
 66   /* `char` type.                                                         */
 67 
 68 #ifndef FT_CHAR_BIT
 69 #define FT_CHAR_BIT  CHAR_BIT
 70 #endif
 71 
 72 
 73   /* The size of an `int` type. */
 74 #if                                 FT_UINT_MAX == 0xFFFFUL
 75 #define FT_SIZEOF_INT  ( 16 / FT_CHAR_BIT )
 76 #elif                               FT_UINT_MAX == 0xFFFFFFFFUL
 77 #define FT_SIZEOF_INT  ( 32 / FT_CHAR_BIT )
 78 #elif FT_UINT_MAX &gt; 0xFFFFFFFFUL &amp;&amp; FT_UINT_MAX == 0xFFFFFFFFFFFFFFFFUL
 79 #define FT_SIZEOF_INT  ( 64 / FT_CHAR_BIT )
 80 #else
 81 #error &quot;Unsupported size of `int&#39; type!&quot;
 82 #endif
 83 
 84   /* The size of a `long` type.  A five-byte `long` (as used e.g. on the */
 85   /* DM642) is recognized but avoided.                                   */
 86 #if                                  FT_ULONG_MAX == 0xFFFFFFFFUL
 87 #define FT_SIZEOF_LONG  ( 32 / FT_CHAR_BIT )
 88 #elif FT_ULONG_MAX &gt; 0xFFFFFFFFUL &amp;&amp; FT_ULONG_MAX == 0xFFFFFFFFFFUL
 89 #define FT_SIZEOF_LONG  ( 32 / FT_CHAR_BIT )
 90 #elif FT_ULONG_MAX &gt; 0xFFFFFFFFUL &amp;&amp; FT_ULONG_MAX == 0xFFFFFFFFFFFFFFFFUL
 91 #define FT_SIZEOF_LONG  ( 64 / FT_CHAR_BIT )
 92 #else
 93 #error &quot;Unsupported size of `long&#39; type!&quot;
 94 #endif
 95 
 96 
 97   /* `FT_UNUSED` indicates that a given parameter is not used --   */
 98   /* this is only used to get rid of unpleasant compiler warnings. */
 99 #ifndef FT_UNUSED
100 #define FT_UNUSED( arg )  ( (arg) = (arg) )
101 #endif
102 
103 
104   /**************************************************************************
105    *
106    *                    AUTOMATIC CONFIGURATION MACROS
107    *
108    * These macros are computed from the ones defined above.  Don&#39;t touch
109    * their definition, unless you know precisely what you are doing.  No
110    * porter should need to mess with them.
111    *
112    */
113 
114 
115   /**************************************************************************
116    *
117    * Mac support
118    *
119    *   This is the only necessary change, so it is defined here instead
120    *   providing a new configuration file.
121    */
122 #if defined( __APPLE__ ) || ( defined( __MWERKS__ ) &amp;&amp; defined( macintosh ) )
123   /* No Carbon frameworks for 64bit 10.4.x.                         */
124   /* `AvailabilityMacros.h` is available since Mac OS X 10.2,       */
125   /* so guess the system version by maximum errno before inclusion. */
126 #include &lt;errno.h&gt;
127 #ifdef ECANCELED /* defined since 10.2 */
128 #include &quot;AvailabilityMacros.h&quot;
129 #endif
130 #if defined( __LP64__ ) &amp;&amp; \
131     ( MAC_OS_X_VERSION_MIN_REQUIRED &lt;= MAC_OS_X_VERSION_10_4 )
132 #undef FT_MACINTOSH
133 #endif
134 
135 #elif defined( __SC__ ) || defined( __MRC__ )
136   /* Classic MacOS compilers */
137 #include &quot;ConditionalMacros.h&quot;
138 #if TARGET_OS_MAC
139 #define FT_MACINTOSH 1
140 #endif
141 
142 #endif
143 
144 
145   /* Fix compiler warning with sgi compiler. */
146 #if defined( __sgi ) &amp;&amp; !defined( __GNUC__ )
147 #if defined( _COMPILER_VERSION ) &amp;&amp; ( _COMPILER_VERSION &gt;= 730 )
148 #pragma set woff 3505
149 #endif
150 #endif
151 
152 
153   /**************************************************************************
154    *
155    * @section:
156    *   basic_types
157    *
158    */
159 
160 
161   /**************************************************************************
162    *
163    * @type:
164    *   FT_Int16
165    *
166    * @description:
167    *   A typedef for a 16bit signed integer type.
168    */
169   typedef signed short  FT_Int16;
170 
171 
172   /**************************************************************************
173    *
174    * @type:
175    *   FT_UInt16
176    *
177    * @description:
178    *   A typedef for a 16bit unsigned integer type.
179    */
180   typedef unsigned short  FT_UInt16;
181 
182   /* */
183 
184 
185   /* this #if 0 ... #endif clause is for documentation purposes */
186 #if 0
187 
188   /**************************************************************************
189    *
190    * @type:
191    *   FT_Int32
192    *
193    * @description:
194    *   A typedef for a 32bit signed integer type.  The size depends on the
195    *   configuration.
196    */
197   typedef signed XXX  FT_Int32;
198 
199 
200   /**************************************************************************
201    *
202    * @type:
203    *   FT_UInt32
204    *
205    *   A typedef for a 32bit unsigned integer type.  The size depends on the
206    *   configuration.
207    */
208   typedef unsigned XXX  FT_UInt32;
209 
210 
211   /**************************************************************************
212    *
213    * @type:
214    *   FT_Int64
215    *
216    *   A typedef for a 64bit signed integer type.  The size depends on the
217    *   configuration.  Only defined if there is real 64bit support;
218    *   otherwise, it gets emulated with a structure (if necessary).
219    */
220   typedef signed XXX  FT_Int64;
221 
222 
223   /**************************************************************************
224    *
225    * @type:
226    *   FT_UInt64
227    *
228    *   A typedef for a 64bit unsigned integer type.  The size depends on the
229    *   configuration.  Only defined if there is real 64bit support;
230    *   otherwise, it gets emulated with a structure (if necessary).
231    */
232   typedef unsigned XXX  FT_UInt64;
233 
234   /* */
235 
236 #endif
237 
238 #if FT_SIZEOF_INT == ( 32 / FT_CHAR_BIT )
239 
240   typedef signed int      FT_Int32;
241   typedef unsigned int    FT_UInt32;
242 
243 #elif FT_SIZEOF_LONG == ( 32 / FT_CHAR_BIT )
244 
245   typedef signed long     FT_Int32;
246   typedef unsigned long   FT_UInt32;
247 
248 #else
249 #error &quot;no 32bit type found -- please check your configuration files&quot;
250 #endif
251 
252 
253   /* look up an integer type that is at least 32~bits */
254 #if FT_SIZEOF_INT &gt;= ( 32 / FT_CHAR_BIT )
255 
256   typedef int            FT_Fast;
257   typedef unsigned int   FT_UFast;
258 
259 #elif FT_SIZEOF_LONG &gt;= ( 32 / FT_CHAR_BIT )
260 
261   typedef long           FT_Fast;
262   typedef unsigned long  FT_UFast;
263 
264 #endif
265 
266 
267   /* determine whether we have a 64-bit `int` type for platforms without */
268   /* Autoconf                                                            */
269 #if FT_SIZEOF_LONG == ( 64 / FT_CHAR_BIT )
270 
271   /* `FT_LONG64` must be defined if a 64-bit type is available */
272 #define FT_LONG64
273 #define FT_INT64   long
274 #define FT_UINT64  unsigned long
275 
276   /**************************************************************************
277    *
278    * A 64-bit data type may create compilation problems if you compile in
279    * strict ANSI mode.  To avoid them, we disable other 64-bit data types if
280    * `__STDC__` is defined.  You can however ignore this rule by defining the
281    * `FT_CONFIG_OPTION_FORCE_INT64` configuration macro.
282    */
283 #elif !defined( __STDC__ ) || defined( FT_CONFIG_OPTION_FORCE_INT64 )
284 
285 #if defined( __STDC_VERSION__ ) &amp;&amp; __STDC_VERSION__ &gt;= 199901L
286 
287 #define FT_LONG64
288 #define FT_INT64   long long int
289 #define FT_UINT64  unsigned long long int
290 
291 #elif defined( _MSC_VER ) &amp;&amp; _MSC_VER &gt;= 900 /* Visual C++ (and Intel C++) */
292 
293   /* this compiler provides the `__int64` type */
294 #define FT_LONG64
295 #define FT_INT64   __int64
296 #define FT_UINT64  unsigned __int64
297 
298 #elif defined( __BORLANDC__ )  /* Borland C++ */
299 
300   /* XXXX: We should probably check the value of `__BORLANDC__` in order */
301   /*       to test the compiler version.                                 */
302 
303   /* this compiler provides the `__int64` type */
304 #define FT_LONG64
305 #define FT_INT64   __int64
306 #define FT_UINT64  unsigned __int64
307 
308 #elif defined( __WATCOMC__ )   /* Watcom C++ */
309 
310   /* Watcom doesn&#39;t provide 64-bit data types */
311 
312 #elif defined( __MWERKS__ )    /* Metrowerks CodeWarrior */
313 
314 #define FT_LONG64
315 #define FT_INT64   long long int
316 #define FT_UINT64  unsigned long long int
317 
318 #elif defined( __GNUC__ )
319 
320   /* GCC provides the `long long` type */
321 #define FT_LONG64
322 #define FT_INT64   long long int
323 #define FT_UINT64  unsigned long long int
324 
325 #endif /* __STDC_VERSION__ &gt;= 199901L */
326 
327 #endif /* FT_SIZEOF_LONG == (64 / FT_CHAR_BIT) */
328 
329 #ifdef FT_LONG64
330   typedef FT_INT64   FT_Int64;
331   typedef FT_UINT64  FT_UInt64;
332 #endif
333 
334 
335 #ifdef _WIN64
336   /* only 64bit Windows uses the LLP64 data model, i.e., */
337   /* 32bit integers, 64bit pointers                      */
338 #define FT_UINT_TO_POINTER( x ) (void*)(unsigned __int64)(x)
339 #else
340 #define FT_UINT_TO_POINTER( x ) (void*)(unsigned long)(x)
341 #endif
342 
343 
344   /**************************************************************************
345    *
346    * miscellaneous
347    *
348    */
349 
350 
351 #define FT_BEGIN_STMNT  do {
352 #define FT_END_STMNT    } while ( 0 )
353 #define FT_DUMMY_STMNT  FT_BEGIN_STMNT FT_END_STMNT
354 
355 
356   /* `typeof` condition taken from gnulib&#39;s `intprops.h` header file */
357 #if ( ( defined( __GNUC__ ) &amp;&amp; __GNUC__ &gt;= 2 )                       || \
358       ( defined( __IBMC__ ) &amp;&amp; __IBMC__ &gt;= 1210 &amp;&amp;                      \
359         defined( __IBM__TYPEOF__ ) )                                 || \
360       ( defined( __SUNPRO_C ) &amp;&amp; __SUNPRO_C &gt;= 0x5110 &amp;&amp; !__STDC__ ) )
361 #define FT_TYPEOF( type )  ( __typeof__ ( type ) )
362 #else
363 #define FT_TYPEOF( type )  /* empty */
364 #endif
365 
366 
367   /* Use `FT_LOCAL` and `FT_LOCAL_DEF` to declare and define,            */
368   /* respectively, a function that gets used only within the scope of a  */
369   /* module.  Normally, both the header and source code files for such a */
370   /* function are within a single module directory.                      */
371   /*                                                                     */
372   /* Intra-module arrays should be tagged with `FT_LOCAL_ARRAY` and      */
373   /* `FT_LOCAL_ARRAY_DEF`.                                               */
374   /*                                                                     */
375 #ifdef FT_MAKE_OPTION_SINGLE_OBJECT
376 
377 #define FT_LOCAL( x )      static  x
378 #define FT_LOCAL_DEF( x )  static  x
379 
380 #else
381 
382 #ifdef __cplusplus
383 #define FT_LOCAL( x )      extern &quot;C&quot;  x
384 #define FT_LOCAL_DEF( x )  extern &quot;C&quot;  x
385 #else
386 #define FT_LOCAL( x )      extern  x
387 #define FT_LOCAL_DEF( x )  x
388 #endif
389 
390 #endif /* FT_MAKE_OPTION_SINGLE_OBJECT */
391 
392 #define FT_LOCAL_ARRAY( x )      extern const  x
393 #define FT_LOCAL_ARRAY_DEF( x )  const  x
394 
395 
396   /* Use `FT_BASE` and `FT_BASE_DEF` to declare and define, respectively, */
397   /* functions that are used in more than a single module.  In the        */
398   /* current setup this implies that the declaration is in a header file  */
399   /* in the `include/freetype/internal` directory, and the function body  */
400   /* is in a file in `src/base`.                                          */
401   /*                                                                      */
402 #ifndef FT_BASE
403 
404 #ifdef __cplusplus
405 #define FT_BASE( x )  extern &quot;C&quot;  x
406 #else
407 #define FT_BASE( x )  extern  x
408 #endif
409 
410 #endif /* !FT_BASE */
411 
412 
413 #ifndef FT_BASE_DEF
414 
415 #ifdef __cplusplus
416 #define FT_BASE_DEF( x )  x
417 #else
418 #define FT_BASE_DEF( x )  x
419 #endif
420 
421 #endif /* !FT_BASE_DEF */
422 
423 
424   /* When compiling FreeType as a DLL or DSO with hidden visibility    */
425   /* some systems/compilers need a special attribute in front OR after */
426   /* the return type of function declarations.                         */
427   /*                                                                   */
428   /* Two macros are used within the FreeType source code to define     */
429   /* exported library functions: `FT_EXPORT` and `FT_EXPORT_DEF`.      */
430   /*                                                                   */
431   /* - `FT_EXPORT( return_type )`                                      */
432   /*                                                                   */
433   /*   is used in a function declaration, as in                        */
434   /*                                                                   */
435   /*   ```                                                             */
436   /*     FT_EXPORT( FT_Error )                                         */
437   /*     FT_Init_FreeType( FT_Library*  alibrary );                    */
438   /*   ```                                                             */
439   /*                                                                   */
440   /* - `FT_EXPORT_DEF( return_type )`                                  */
441   /*                                                                   */
442   /*   is used in a function definition, as in                         */
443   /*                                                                   */
444   /*   ```                                                             */
445   /*     FT_EXPORT_DEF( FT_Error )                                     */
446   /*     FT_Init_FreeType( FT_Library*  alibrary )                     */
447   /*     {                                                             */
448   /*       ... some code ...                                           */
449   /*       return FT_Err_Ok;                                           */
450   /*     }                                                             */
451   /*   ```                                                             */
452   /*                                                                   */
453   /* You can provide your own implementation of `FT_EXPORT` and        */
454   /* `FT_EXPORT_DEF` here if you want.                                 */
455   /*                                                                   */
456   /* To export a variable, use `FT_EXPORT_VAR`.                        */
457   /*                                                                   */
458 #ifndef FT_EXPORT
459 
460 #ifdef FT2_BUILD_LIBRARY
461 
462 #if defined( _WIN32 ) &amp;&amp; defined( DLL_EXPORT )
463 #define FT_EXPORT( x )  __declspec( dllexport )  x
464 #elif defined( __GNUC__ ) &amp;&amp; __GNUC__ &gt;= 4
465 #define FT_EXPORT( x )  __attribute__(( visibility( &quot;default&quot; ) ))  x
466 #elif defined( __SUNPRO_C ) &amp;&amp; __SUNPRO_C &gt;= 0x550
467 #define FT_EXPORT( x )  __global  x
468 #elif defined( __cplusplus )
469 #define FT_EXPORT( x )  extern &quot;C&quot;  x
470 #else
471 #define FT_EXPORT( x )  extern  x
472 #endif
473 
474 #else
475 
476 #if defined( _WIN32 ) &amp;&amp; defined( DLL_IMPORT )
477 #define FT_EXPORT( x )  __declspec( dllimport )  x
478 #elif defined( __cplusplus )
479 #define FT_EXPORT( x )  extern &quot;C&quot;  x
480 #else
481 #define FT_EXPORT( x )  extern  x
482 #endif
483 
484 #endif
485 
486 #endif /* !FT_EXPORT */
487 
488 
489 #ifndef FT_EXPORT_DEF
490 
491 #ifdef __cplusplus
492 #define FT_EXPORT_DEF( x )  extern &quot;C&quot;  x
493 #else
494 #define FT_EXPORT_DEF( x )  extern  x
495 #endif
496 
497 #endif /* !FT_EXPORT_DEF */
498 
499 
500 #ifndef FT_EXPORT_VAR
501 
502 #ifdef __cplusplus
503 #define FT_EXPORT_VAR( x )  extern &quot;C&quot;  x
504 #else
505 #define FT_EXPORT_VAR( x )  extern  x
506 #endif
507 
508 #endif /* !FT_EXPORT_VAR */
509 
510 
511   /* The following macros are needed to compile the library with a   */
512   /* C++ compiler and with 16bit compilers.                          */
513   /*                                                                 */
514 
515   /* This is special.  Within C++, you must specify `extern &quot;C&quot;` for */
516   /* functions which are used via function pointers, and you also    */
517   /* must do that for structures which contain function pointers to  */
518   /* assure C linkage -- it&#39;s not possible to have (local) anonymous */
519   /* functions which are accessed by (global) function pointers.     */
520   /*                                                                 */
521   /*                                                                 */
522   /* FT_CALLBACK_DEF is used to _define_ a callback function,        */
523   /* located in the same source code file as the structure that uses */
524   /* it.                                                             */
525   /*                                                                 */
526   /* FT_BASE_CALLBACK and FT_BASE_CALLBACK_DEF are used to declare   */
527   /* and define a callback function, respectively, in a similar way  */
528   /* as FT_BASE and FT_BASE_DEF work.                                */
529   /*                                                                 */
530   /* FT_CALLBACK_TABLE is used to _declare_ a constant variable that */
531   /* contains pointers to callback functions.                        */
532   /*                                                                 */
533   /* FT_CALLBACK_TABLE_DEF is used to _define_ a constant variable   */
534   /* that contains pointers to callback functions.                   */
535   /*                                                                 */
536   /*                                                                 */
537   /* Some 16bit compilers have to redefine these macros to insert    */
538   /* the infamous `_cdecl` or `__fastcall` declarations.             */
539   /*                                                                 */
540 #ifndef FT_CALLBACK_DEF
541 #ifdef __cplusplus
542 #define FT_CALLBACK_DEF( x )  extern &quot;C&quot;  x
543 #else
544 #define FT_CALLBACK_DEF( x )  static  x
545 #endif
546 #endif /* FT_CALLBACK_DEF */
547 
548 #ifndef FT_BASE_CALLBACK
549 #ifdef __cplusplus
550 #define FT_BASE_CALLBACK( x )      extern &quot;C&quot;  x
551 #define FT_BASE_CALLBACK_DEF( x )  extern &quot;C&quot;  x
552 #else
553 #define FT_BASE_CALLBACK( x )      extern  x
554 #define FT_BASE_CALLBACK_DEF( x )  x
555 #endif
556 #endif /* FT_BASE_CALLBACK */
557 
558 #ifndef FT_CALLBACK_TABLE
559 #ifdef __cplusplus
560 #define FT_CALLBACK_TABLE      extern &quot;C&quot;
561 #define FT_CALLBACK_TABLE_DEF  extern &quot;C&quot;
562 #else
563 #define FT_CALLBACK_TABLE      extern
564 #define FT_CALLBACK_TABLE_DEF  /* nothing */
565 #endif
566 #endif /* FT_CALLBACK_TABLE */
567 
568 
569 FT_END_HEADER
570 
571 
572 #endif /* FTCONFIG_H_ */
573 
574 
575 /* END */
    </pre>
  </body>
</html>
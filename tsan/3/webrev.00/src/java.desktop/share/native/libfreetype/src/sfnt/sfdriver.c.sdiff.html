<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/sfnt/sfdriver.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="pngshim.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="sfdriver.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/sfnt/sfdriver.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  sfdriver.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    High-level SFNT driver interface (body).                             */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_INTERNAL_SFNT_H
  22 #include FT_INTERNAL_OBJECTS_H
  23 #include FT_TRUETYPE_IDS_H
  24 
  25 #include &quot;sfdriver.h&quot;
  26 #include &quot;ttload.h&quot;
  27 #include &quot;sfobjs.h&quot;
<span class="line-removed">  28 #include &quot;sfntpic.h&quot;</span>
  29 
  30 #include &quot;sferrors.h&quot;
  31 
  32 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
  33 #include &quot;ttsbit.h&quot;
  34 #endif
  35 





  36 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
  37 #include &quot;ttpost.h&quot;
  38 #endif
  39 
  40 #ifdef TT_CONFIG_OPTION_BDF
  41 #include &quot;ttbdf.h&quot;
  42 #include FT_SERVICE_BDF_H
  43 #endif
  44 
  45 #include &quot;ttcmap.h&quot;
  46 #include &quot;ttkern.h&quot;
  47 #include &quot;ttmtx.h&quot;
  48 
  49 #include FT_SERVICE_GLYPH_DICT_H
  50 #include FT_SERVICE_POSTSCRIPT_NAME_H
  51 #include FT_SERVICE_SFNT_H
  52 #include FT_SERVICE_TT_CMAP_H
  53 
  54 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  55 #include FT_MULTIPLE_MASTERS_H
  56 #include FT_SERVICE_MULTIPLE_MASTERS_H
  57 #endif
  58 
  59 
<span class="line-modified">  60   /*************************************************************************/</span>
<span class="line-modified">  61   /*                                                                       */</span>
<span class="line-modified">  62   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  63   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  64   /* messages during execution.                                            */</span>
<span class="line-modified">  65   /*                                                                       */</span>
  66 #undef  FT_COMPONENT
<span class="line-modified">  67 #define FT_COMPONENT  trace_sfdriver</span>
  68 
  69 
  70   /*
<span class="line-modified">  71    *  SFNT TABLE SERVICE</span>
  72    *
  73    */
  74 
  75   static void*
  76   get_sfnt_table( TT_Face      face,
  77                   FT_Sfnt_Tag  tag )
  78   {
  79     void*  table;
  80 
  81 
  82     switch ( tag )
  83     {
  84     case FT_SFNT_HEAD:
  85       table = &amp;face-&gt;header;
  86       break;
  87 
  88     case FT_SFNT_HHEA:
  89       table = &amp;face-&gt;horizontal;
  90       break;
  91 
</pre>
<hr />
<pre>
 138       *offset = face-&gt;dir_tables[idx].Offset;
 139       *length = face-&gt;dir_tables[idx].Length;
 140     }
 141 
 142     return FT_Err_Ok;
 143   }
 144 
 145 
 146   FT_DEFINE_SERVICE_SFNT_TABLEREC(
 147     sfnt_service_sfnt_table,
 148 
 149     (FT_SFNT_TableLoadFunc)tt_face_load_any,     /* load_table */
 150     (FT_SFNT_TableGetFunc) get_sfnt_table,       /* get_table  */
 151     (FT_SFNT_TableInfoFunc)sfnt_table_info       /* table_info */
 152   )
 153 
 154 
 155 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 156 
 157   /*
<span class="line-modified"> 158    *  GLYPH DICT SERVICE</span>
 159    *
 160    */
 161 
 162   static FT_Error
 163   sfnt_get_glyph_name( FT_Face     face,
 164                        FT_UInt     glyph_index,
 165                        FT_Pointer  buffer,
 166                        FT_UInt     buffer_max )
 167   {
 168     FT_String*  gname;
 169     FT_Error    error;
 170 
 171 
 172     error = tt_face_get_ps_name( (TT_Face)face, glyph_index, &amp;gname );
 173     if ( !error )
 174       FT_STRCPYN( buffer, gname, buffer_max );
 175 
 176     return error;
 177   }
 178 
 179 
 180   static FT_UInt
<span class="line-modified"> 181   sfnt_get_name_index( FT_Face     face,</span>
<span class="line-modified"> 182                        FT_String*  glyph_name )</span>
 183   {
 184     TT_Face  ttface = (TT_Face)face;
 185 
 186     FT_UInt  i, max_gid = FT_UINT_MAX;
 187 
 188 
 189     if ( face-&gt;num_glyphs &lt; 0 )
 190       return 0;
 191     else if ( (FT_ULong)face-&gt;num_glyphs &lt; FT_UINT_MAX )
 192       max_gid = (FT_UInt)face-&gt;num_glyphs;
 193     else
 194       FT_TRACE0(( &quot;Ignore glyph names for invalid GID 0x%08x - 0x%08x\n&quot;,
 195                   FT_UINT_MAX, face-&gt;num_glyphs ));
 196 
 197     for ( i = 0; i &lt; max_gid; i++ )
 198     {
 199       FT_String*  gname;
 200       FT_Error    error = tt_face_get_ps_name( ttface, i, &amp;gname );
 201 
 202 
</pre>
<hr />
<pre>
 205 
 206       if ( !ft_strcmp( glyph_name, gname ) )
 207         return i;
 208     }
 209 
 210     return 0;
 211   }
 212 
 213 
 214   FT_DEFINE_SERVICE_GLYPHDICTREC(
 215     sfnt_service_glyph_dict,
 216 
 217     (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,    /* get_name   */
 218     (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index     /* name_index */
 219   )
 220 
 221 #endif /* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
 222 
 223 
 224   /*
<span class="line-modified"> 225    *  POSTSCRIPT NAME SERVICE</span>
 226    *
 227    */
 228 
 229   /* an array representing allowed ASCII characters in a PS string */
 230   static const unsigned char sfnt_ps_map[16] =
 231   {
 232                 /*             4        0        C        8 */
 233     0x00, 0x00, /* 0x00: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 234     0x00, 0x00, /* 0x10: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 235     0xDE, 0x7C, /* 0x20: 1 1 0 1  1 1 1 0  0 1 1 1  1 1 0 0 */
 236     0xFF, 0xAF, /* 0x30: 1 1 1 1  1 1 1 1  1 0 1 0  1 1 1 1 */
 237     0xFF, 0xFF, /* 0x40: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 238     0xFF, 0xD7, /* 0x50: 1 1 1 1  1 1 1 1  1 1 0 1  0 1 1 1 */
 239     0xFF, 0xFF, /* 0x60: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 240     0xFF, 0x57  /* 0x70: 1 1 1 1  1 1 1 1  0 1 0 1  0 1 1 1 */
 241   };
 242 
 243 
 244   static int
 245   sfnt_is_postscript( int  c )
</pre>
<hr />
<pre>
 354       h4 ^= k4;
 355 
 356       h4  = ROTL32( h4, 13 );
 357       h4 += h1;
 358       h4  = h4 * 5 + 0x32ac3b17;
 359     }
 360 
 361     {
 362       const FT_Byte*  tail = (const FT_Byte*)( data + nblocks * 16 );
 363 
 364       FT_UInt32  k1 = 0;
 365       FT_UInt32  k2 = 0;
 366       FT_UInt32  k3 = 0;
 367       FT_UInt32  k4 = 0;
 368 
 369 
 370       switch ( len &amp; 15 )
 371       {
 372       case 15:
 373         k4 ^= (FT_UInt32)tail[14] &lt;&lt; 16;

 374       case 14:
 375         k4 ^= (FT_UInt32)tail[13] &lt;&lt; 8;

 376       case 13:
 377         k4 ^= (FT_UInt32)tail[12];
 378         k4 *= c4;
 379         k4  = ROTL32( k4, 18 );
 380         k4 *= c1;
 381         h4 ^= k4;

 382 
 383       case 12:
 384         k3 ^= (FT_UInt32)tail[11] &lt;&lt; 24;

 385       case 11:
 386         k3 ^= (FT_UInt32)tail[10] &lt;&lt; 16;

 387       case 10:
 388         k3 ^= (FT_UInt32)tail[9] &lt;&lt; 8;

 389       case 9:
 390         k3 ^= (FT_UInt32)tail[8];
 391         k3 *= c3;
 392         k3  = ROTL32( k3, 17 );
 393         k3 *= c4;
 394         h3 ^= k3;

 395 
 396       case 8:
 397         k2 ^= (FT_UInt32)tail[7] &lt;&lt; 24;

 398       case 7:
 399         k2 ^= (FT_UInt32)tail[6] &lt;&lt; 16;

 400       case 6:
 401         k2 ^= (FT_UInt32)tail[5] &lt;&lt; 8;

 402       case 5:
 403         k2 ^= (FT_UInt32)tail[4];
 404         k2 *= c2;
 405         k2  = ROTL32( k2, 16 );
 406         k2 *= c3;
 407         h2 ^= k2;

 408 
 409       case 4:
 410         k1 ^= (FT_UInt32)tail[3] &lt;&lt; 24;

 411       case 3:
 412         k1 ^= (FT_UInt32)tail[2] &lt;&lt; 16;

 413       case 2:
 414         k1 ^= (FT_UInt32)tail[1] &lt;&lt; 8;

 415       case 1:
 416         k1 ^= (FT_UInt32)tail[0];
 417         k1 *= c1;
 418         k1  = ROTL32( k1, 15 );
 419         k1 *= c2;
 420         h1 ^= k1;
 421       }
 422     }
 423 
 424     h1 ^= len;
 425     h2 ^= len;
 426     h3 ^= len;
 427     h4 ^= len;
 428 
 429     h1 += h2;
 430     h1 += h3;
 431     h1 += h4;
 432 
 433     h2 += h1;
 434     h3 += h1;
</pre>
<hr />
<pre>
 443     h1 += h3;
 444     h1 += h4;
 445 
 446     h2 += h1;
 447     h3 += h1;
 448     h4 += h1;
 449 
 450     ((FT_UInt32*)out)[0] = h1;
 451     ((FT_UInt32*)out)[1] = h2;
 452     ((FT_UInt32*)out)[2] = h3;
 453     ((FT_UInt32*)out)[3] = h4;
 454   }
 455 
 456 
 457 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 458 
 459 
 460   typedef int (*char_type_func)( int  c );
 461 
 462 
<span class="line-modified"> 463   /* handling of PID/EID 3/0 and 3/1 is the same */</span>
 464 #define IS_WIN( n )  ( (n)-&gt;platformID == 3                             &amp;&amp; \
<span class="line-modified"> 465                        ( (n)-&gt;encodingID == 1 || (n)-&gt;encodingID == 0 ) &amp;&amp; \</span>
<span class="line-removed"> 466                        (n)-&gt;languageID == 0x409                         )</span>
 467 
 468 #define IS_APPLE( n )  ( (n)-&gt;platformID == 1 &amp;&amp; \
<span class="line-modified"> 469                          (n)-&gt;encodingID == 0 &amp;&amp; \</span>
<span class="line-removed"> 470                          (n)-&gt;languageID == 0 )</span>
 471 
 472   static char*
 473   get_win_string( FT_Memory       memory,
 474                   FT_Stream       stream,
 475                   TT_Name         entry,
 476                   char_type_func  char_type,
 477                   FT_Bool         report_invalid_characters )
 478   {
 479     FT_Error  error = FT_Err_Ok;
 480 
 481     char*       result = NULL;
 482     FT_String*  r;
 483     FT_Char*    p;
 484     FT_UInt     len;
 485 
 486     FT_UNUSED( error );
 487 
 488 
 489     if ( FT_ALLOC( result, entry-&gt;stringLength / 2 + 1 ) )
 490       return NULL;
 491 
 492     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 493          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<span class="line-modified"> 494     {</span>
<span class="line-removed"> 495       FT_FREE( result );</span>
<span class="line-removed"> 496       entry-&gt;stringLength = 0;</span>
<span class="line-removed"> 497       entry-&gt;stringOffset = 0;</span>
<span class="line-removed"> 498       FT_FREE( entry-&gt;string );</span>
<span class="line-removed"> 499 </span>
<span class="line-removed"> 500       return NULL;</span>
<span class="line-removed"> 501     }</span>
 502 
 503     r = (FT_String*)result;
 504     p = (FT_Char*)stream-&gt;cursor;
 505 
 506     for ( len = entry-&gt;stringLength / 2; len &gt; 0; len--, p += 2 )
 507     {
<span class="line-modified"> 508       if ( p[0] == 0 )</span>


 509       {
<span class="line-modified"> 510         if ( char_type( p[1] ) )</span>
<span class="line-modified"> 511           *r++ = p[1];</span>
<span class="line-modified"> 512         else</span>
<span class="line-modified"> 513         {</span>
<span class="line-modified"> 514           if ( report_invalid_characters )</span>
<span class="line-removed"> 515           {</span>
<span class="line-removed"> 516             FT_TRACE0(( &quot;get_win_string:&quot;</span>
<span class="line-removed"> 517                         &quot; Character `%c&#39; (0x%X) invalid in PS name string\n&quot;,</span>
<span class="line-removed"> 518                         p[1], p[1] ));</span>
<span class="line-removed"> 519             /* it&#39;s not the job of FreeType to correct PS names... */</span>
<span class="line-removed"> 520             *r++ = p[1];</span>
<span class="line-removed"> 521           }</span>
<span class="line-removed"> 522         }</span>
 523       }
 524     }
<span class="line-modified"> 525     *r = &#39;\0&#39;;</span>

 526 
 527     FT_FRAME_EXIT();
 528 
<span class="line-modified"> 529     return result;</span>










 530   }
 531 
 532 
 533   static char*
 534   get_apple_string( FT_Memory       memory,
 535                     FT_Stream       stream,
 536                     TT_Name         entry,
 537                     char_type_func  char_type,
 538                     FT_Bool         report_invalid_characters )
 539   {
 540     FT_Error  error = FT_Err_Ok;
 541 
 542     char*       result = NULL;
 543     FT_String*  r;
 544     FT_Char*    p;
 545     FT_UInt     len;
 546 
 547     FT_UNUSED( error );
 548 
 549 
 550     if ( FT_ALLOC( result, entry-&gt;stringLength + 1 ) )
 551       return NULL;
 552 
 553     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 554          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<span class="line-modified"> 555     {</span>
<span class="line-removed"> 556       FT_FREE( result );</span>
<span class="line-removed"> 557       entry-&gt;stringOffset = 0;</span>
<span class="line-removed"> 558       entry-&gt;stringLength = 0;</span>
<span class="line-removed"> 559       FT_FREE( entry-&gt;string );</span>
<span class="line-removed"> 560 </span>
<span class="line-removed"> 561       return NULL;</span>
<span class="line-removed"> 562     }</span>
 563 
 564     r = (FT_String*)result;
 565     p = (FT_Char*)stream-&gt;cursor;
 566 
 567     for ( len = entry-&gt;stringLength; len &gt; 0; len--, p++ )
 568     {
 569       if ( char_type( *p ) )
 570         *r++ = *p;
 571       else
 572       {
 573         if ( report_invalid_characters )
<span class="line-removed"> 574         {</span>
 575           FT_TRACE0(( &quot;get_apple_string:&quot;
 576                       &quot; Character `%c&#39; (0x%X) invalid in PS name string\n&quot;,
 577                       *p, *p ));
<span class="line-modified"> 578           /* it&#39;s not the job of FreeType to correct PS names... */</span>
<span class="line-removed"> 579           *r++ = *p;</span>
<span class="line-removed"> 580         }</span>
 581       }
 582     }
<span class="line-modified"> 583     *r = &#39;\0&#39;;</span>

 584 
 585     FT_FRAME_EXIT();
 586 
<span class="line-modified"> 587     return result;</span>










 588   }
 589 
 590 
 591   static FT_Bool
 592   sfnt_get_name_id( TT_Face    face,
 593                     FT_UShort  id,
 594                     FT_Int    *win,
 595                     FT_Int    *apple )
 596   {
 597     FT_Int  n;
 598 
 599 
 600     *win   = -1;
 601     *apple = -1;
 602 
 603     for ( n = 0; n &lt; face-&gt;num_names; n++ )
 604     {
 605       TT_Name  name = face-&gt;name_table.names + n;
 606 
 607 
 608       if ( name-&gt;nameID == id &amp;&amp; name-&gt;stringLength &gt; 0 )
 609       {
<span class="line-modified"> 610         if ( IS_WIN( name ) )</span>
 611           *win = n;
 612 
<span class="line-modified"> 613         if ( IS_APPLE( name ) )</span>
 614           *apple = n;
 615       }
 616     }
 617 
 618     return ( *win &gt;= 0 ) || ( *apple &gt;= 0 );
 619   }
 620 
 621 
 622 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 623 
 624   /*
 625       The maximum length of an axis value descriptor.
 626 
 627       We need 65536 different values for the decimal fraction; this fits
 628       nicely into five decimal places.  Consequently, it consists of
 629 
 630         . the minus sign if the number is negative,
 631         . up to five characters for the digits before the decimal point,
 632         . the decimal point if there is a fractional part, and
 633         . up to five characters for the digits after the decimal point.
 634 
 635       We also need one byte for the leading `_&#39; character and up to four
 636       bytes for the axis tag.
 637    */
 638 #define MAX_VALUE_DESCRIPTOR_LEN  ( 1 + 5 + 1 + 5 + 1 + 4 )
 639 
 640 
 641   /* the maximum length of PostScript font names */
 642 #define MAX_PS_NAME_LEN  127
 643 
 644 
 645   /*
<span class="line-modified"> 646    *  Find the shortest decimal representation of a 16.16 fixed point</span>
<span class="line-modified"> 647    *  number.  The function fills `buf&#39; with the result, returning a pointer</span>
<span class="line-modified"> 648    *  to the position after the representation&#39;s last byte.</span>
 649    */
 650 
 651   static char*
 652   fixed2float( FT_Int  fixed,
 653                char*   buf )
 654   {
 655     char*  p;
 656     char*  q;
 657     char   tmp[5];
 658 
 659     FT_Int  int_part;
 660     FT_Int  frac_part;
 661 
 662     FT_Int  i;
 663 
 664 
 665     p = buf;
 666 
 667     if ( fixed == 0 )
 668     {
 669       *p++ = &#39;0&#39;;
 670       return p;
 671     }
 672 
 673     if ( fixed &lt; 0 )
 674     {
 675       *p++ = &#39;-&#39;;
<span class="line-modified"> 676       fixed = -fixed;</span>
 677     }
 678 
 679     int_part  = ( fixed &gt;&gt; 16 ) &amp; 0xFFFF;
 680     frac_part = fixed &amp; 0xFFFF;
 681 
 682     /* get digits of integer part (in reverse order) */
 683     q = tmp;
 684     while ( int_part &gt; 0 )
 685     {
 686       *q++      = &#39;0&#39; + int_part % 10;
 687       int_part /= 10;
 688     }
 689 
 690     /* copy digits in correct order to buffer */
 691     while ( q &gt; tmp )
 692       *p++ = *--q;
 693 
 694     if ( !frac_part )
 695       return p;
 696 
</pre>
<hr />
<pre>
 811         found = sfnt_get_name_id( face,
 812                                   TT_NAME_ID_FONT_FAMILY,
 813                                   &amp;win,
 814                                   &amp;apple );
 815       }
 816 
 817       if ( !found )
 818       {
 819         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 820                     &quot; Can&#39;t construct PS name prefix for font instances\n&quot; ));
 821         return NULL;
 822       }
 823 
 824       /* prefer Windows entries over Apple */
 825       if ( win != -1 )
 826         result = get_win_string( face-&gt;root.memory,
 827                                  face-&gt;name_table.stream,
 828                                  face-&gt;name_table.names + win,
 829                                  sfnt_is_alphanumeric,
 830                                  0 );
<span class="line-modified"> 831       else</span>
 832         result = get_apple_string( face-&gt;root.memory,
 833                                    face-&gt;name_table.stream,
 834                                    face-&gt;name_table.names + apple,
 835                                    sfnt_is_alphanumeric,
 836                                    0 );
 837 







 838       len = ft_strlen( result );
 839 
 840       /* sanitize if necessary; we reserve space for 36 bytes (a 128bit  */
 841       /* checksum as a hex number, preceded by `-&#39; and followed by three */
 842       /* ASCII dots, to be used if the constructed PS name would be too  */
 843       /* long); this is also sufficient for a single instance            */
 844       if ( len &gt; MAX_PS_NAME_LEN - ( 1 + 32 + 3 ) )
 845       {
 846         len         = MAX_PS_NAME_LEN - ( 1 + 32 + 3 );
 847         result[len] = &#39;\0&#39;;
 848 
 849         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 850                     &quot; Shortening variation PS name prefix\n&quot;
 851                     &quot;                     &quot;
 852                     &quot; to %d characters\n&quot;, len ));
 853       }
 854 
 855       face-&gt;var_postscript_prefix     = result;
 856       face-&gt;var_postscript_prefix_len = len;
 857     }
</pre>
<hr />
<pre>
1035            FT_IS_VARIATION( FT_FACE( face ) )      ) )
1036     {
1037       face-&gt;postscript_name = sfnt_get_var_ps_name( face );
1038       return face-&gt;postscript_name;
1039     }
1040 #endif
1041 
1042     /* scan the name table to see whether we have a Postscript name here, */
1043     /* either in Macintosh or Windows platform encodings                  */
1044     found = sfnt_get_name_id( face, TT_NAME_ID_PS_NAME, &amp;win, &amp;apple );
1045     if ( !found )
1046       return NULL;
1047 
1048     /* prefer Windows entries over Apple */
1049     if ( win != -1 )
1050       result = get_win_string( face-&gt;root.memory,
1051                                face-&gt;name_table.stream,
1052                                face-&gt;name_table.names + win,
1053                                sfnt_is_postscript,
1054                                1 );
<span class="line-modified">1055     else</span>
1056       result = get_apple_string( face-&gt;root.memory,
1057                                  face-&gt;name_table.stream,
1058                                  face-&gt;name_table.names + apple,
1059                                  sfnt_is_postscript,
1060                                  1 );
1061 
1062     face-&gt;postscript_name = result;
1063 
1064     return result;
1065   }
1066 
1067 
1068   FT_DEFINE_SERVICE_PSFONTNAMEREC(
1069     sfnt_service_ps_name,
1070 
1071     (FT_PsName_GetFunc)sfnt_get_ps_name       /* get_ps_font_name */
1072   )
1073 
1074 
1075   /*
<span class="line-modified">1076    *  TT CMAP INFO</span>
1077    */
1078   FT_DEFINE_SERVICE_TTCMAPSREC(
1079     tt_service_get_cmap_info,
1080 
1081     (TT_CMap_Info_GetFunc)tt_get_cmap_info    /* get_cmap_info */
1082   )
1083 
1084 
1085 #ifdef TT_CONFIG_OPTION_BDF
1086 
1087   static FT_Error
1088   sfnt_get_charset_id( TT_Face       face,
1089                        const char*  *acharset_encoding,
1090                        const char*  *acharset_registry )
1091   {
1092     BDF_PropertyRec  encoding, registry;
1093     FT_Error         error;
1094 
1095 
1096     /* XXX: I don&#39;t know whether this is correct, since
</pre>
<hr />
<pre>
1115           error = FT_THROW( Invalid_Argument );
1116       }
1117     }
1118 
1119     return error;
1120   }
1121 
1122 
1123   FT_DEFINE_SERVICE_BDFRec(
1124     sfnt_service_bdf,
1125 
1126     (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,     /* get_charset_id */
1127     (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop    /* get_property   */
1128   )
1129 
1130 
1131 #endif /* TT_CONFIG_OPTION_BDF */
1132 
1133 
1134   /*
<span class="line-modified">1135    *  SERVICE LIST</span>
1136    */
1137 
1138 #if defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES &amp;&amp; defined TT_CONFIG_OPTION_BDF
1139   FT_DEFINE_SERVICEDESCREC5(
1140     sfnt_services,
1141 
<span class="line-modified">1142     FT_SERVICE_ID_SFNT_TABLE,           &amp;SFNT_SERVICE_SFNT_TABLE_GET,</span>
<span class="line-modified">1143     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;SFNT_SERVICE_PS_NAME_GET,</span>
<span class="line-modified">1144     FT_SERVICE_ID_GLYPH_DICT,           &amp;SFNT_SERVICE_GLYPH_DICT_GET,</span>
<span class="line-modified">1145     FT_SERVICE_ID_BDF,                  &amp;SFNT_SERVICE_BDF_GET,</span>
<span class="line-modified">1146     FT_SERVICE_ID_TT_CMAP,              &amp;TT_SERVICE_CMAP_INFO_GET )</span>
1147 #elif defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1148   FT_DEFINE_SERVICEDESCREC4(
1149     sfnt_services,
1150 
<span class="line-modified">1151     FT_SERVICE_ID_SFNT_TABLE,           &amp;SFNT_SERVICE_SFNT_TABLE_GET,</span>
<span class="line-modified">1152     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;SFNT_SERVICE_PS_NAME_GET,</span>
<span class="line-modified">1153     FT_SERVICE_ID_GLYPH_DICT,           &amp;SFNT_SERVICE_GLYPH_DICT_GET,</span>
<span class="line-modified">1154     FT_SERVICE_ID_TT_CMAP,              &amp;TT_SERVICE_CMAP_INFO_GET )</span>
1155 #elif defined TT_CONFIG_OPTION_BDF
1156   FT_DEFINE_SERVICEDESCREC4(
1157     sfnt_services,
1158 
<span class="line-modified">1159     FT_SERVICE_ID_SFNT_TABLE,           &amp;SFNT_SERVICE_SFNT_TABLE_GET,</span>
<span class="line-modified">1160     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;SFNT_SERVICE_PS_NAME_GET,</span>
<span class="line-modified">1161     FT_SERVICE_ID_BDF,                  &amp;SFNT_SERVICE_BDF_GET,</span>
<span class="line-modified">1162     FT_SERVICE_ID_TT_CMAP,              &amp;TT_SERVICE_CMAP_INFO_GET )</span>
1163 #else
1164   FT_DEFINE_SERVICEDESCREC3(
1165     sfnt_services,
1166 
<span class="line-modified">1167     FT_SERVICE_ID_SFNT_TABLE,           &amp;SFNT_SERVICE_SFNT_TABLE_GET,</span>
<span class="line-modified">1168     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;SFNT_SERVICE_PS_NAME_GET,</span>
<span class="line-modified">1169     FT_SERVICE_ID_TT_CMAP,              &amp;TT_SERVICE_CMAP_INFO_GET )</span>
1170 #endif
1171 
1172 
1173   FT_CALLBACK_DEF( FT_Module_Interface )
1174   sfnt_get_interface( FT_Module    module,
1175                       const char*  module_interface )
1176   {
<span class="line-removed">1177     /* SFNT_SERVICES_GET dereferences `library&#39; in PIC mode */</span>
<span class="line-removed">1178 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">1179     FT_Library  library;</span>
<span class="line-removed">1180 </span>
<span class="line-removed">1181 </span>
<span class="line-removed">1182     if ( !module )</span>
<span class="line-removed">1183       return NULL;</span>
<span class="line-removed">1184     library = module-&gt;library;</span>
<span class="line-removed">1185     if ( !library )</span>
<span class="line-removed">1186       return NULL;</span>
<span class="line-removed">1187 #else</span>
1188     FT_UNUSED( module );
<span class="line-removed">1189 #endif</span>
1190 
<span class="line-modified">1191     return ft_service_list_lookup( SFNT_SERVICES_GET, module_interface );</span>
1192   }
1193 
1194 
1195 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1196 #define PUT_EMBEDDED_BITMAPS( a )  a
1197 #else
1198 #define PUT_EMBEDDED_BITMAPS( a )  NULL
1199 #endif
1200 






1201 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1202 #define PUT_PS_NAMES( a )  a
1203 #else
1204 #define PUT_PS_NAMES( a )  NULL
1205 #endif
1206 
1207   FT_DEFINE_SFNT_INTERFACE(
1208     sfnt_interface,
1209 
1210     tt_face_goto_table,     /* TT_Loader_GotoTableFunc goto_table      */
1211 
1212     sfnt_init_face,         /* TT_Init_Face_Func       init_face       */
1213     sfnt_load_face,         /* TT_Load_Face_Func       load_face       */
1214     sfnt_done_face,         /* TT_Done_Face_Func       done_face       */
1215     sfnt_get_interface,     /* FT_Module_Requester     get_interface   */
1216 
1217     tt_face_load_any,       /* TT_Load_Any_Func        load_any        */
1218 
1219     tt_face_load_head,      /* TT_Load_Table_Func      load_head       */
1220     tt_face_load_hhea,      /* TT_Load_Metrics_Func    load_hhea       */
</pre>
<hr />
<pre>
1239     /* see `ttpost.h&#39; */
1240     PUT_PS_NAMES( tt_face_get_ps_name   ),
1241                             /* TT_Get_PS_Name_Func     get_psname      */
1242     PUT_PS_NAMES( tt_face_free_ps_names ),
1243                             /* TT_Free_Table_Func      free_psnames    */
1244 
1245     /* since version 2.1.8 */
1246     tt_face_get_kerning,    /* TT_Face_GetKerningFunc  get_kerning     */
1247 
1248     /* since version 2.2 */
1249     tt_face_load_font_dir,  /* TT_Load_Table_Func      load_font_dir   */
1250     tt_face_load_hmtx,      /* TT_Load_Metrics_Func    load_hmtx       */
1251 
1252     /* see `ttsbit.h&#39; and `sfnt.h&#39; */
1253     PUT_EMBEDDED_BITMAPS( tt_face_load_sbit ),
1254                             /* TT_Load_Table_Func      load_eblc       */
1255     PUT_EMBEDDED_BITMAPS( tt_face_free_sbit ),
1256                             /* TT_Free_Table_Func      free_eblc       */
1257 
1258     PUT_EMBEDDED_BITMAPS( tt_face_set_sbit_strike     ),
<span class="line-modified">1259                             /* TT_Set_SBit_Strike_Func set_sbit_strike */</span>
1260     PUT_EMBEDDED_BITMAPS( tt_face_load_strike_metrics ),
<span class="line-modified">1261                     /* TT_Load_Strike_Metrics_Func load_strike_metrics */</span>















1262 
1263     tt_face_get_metrics,    /* TT_Get_Metrics_Func     get_metrics     */
1264 
1265     tt_face_get_name,       /* TT_Get_Name_Func        get_name        */
1266     sfnt_get_name_id        /* TT_Get_Name_ID_Func     get_name_id     */
1267   )
1268 
1269 
1270   FT_DEFINE_MODULE(
1271     sfnt_module_class,
1272 
1273     0,  /* not a font driver or renderer */
1274     sizeof ( FT_ModuleRec ),
1275 
1276     &quot;sfnt&quot;,     /* driver name                            */
1277     0x10000L,   /* driver version 1.0                     */
1278     0x20000L,   /* driver requires FreeType 2.0 or higher */
1279 
<span class="line-modified">1280     (const void*)&amp;SFNT_INTERFACE_GET,  /* module specific interface */</span>
1281 
1282     (FT_Module_Constructor)NULL,               /* module_init   */
1283     (FT_Module_Destructor) NULL,               /* module_done   */
1284     (FT_Module_Requester)  sfnt_get_interface  /* get_interface */
1285   )
1286 
1287 
1288 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * sfdriver.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   High-level SFNT driver interface (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_INTERNAL_SFNT_H
  22 #include FT_INTERNAL_OBJECTS_H
  23 #include FT_TRUETYPE_IDS_H
  24 
  25 #include &quot;sfdriver.h&quot;
  26 #include &quot;ttload.h&quot;
  27 #include &quot;sfobjs.h&quot;

  28 
  29 #include &quot;sferrors.h&quot;
  30 
  31 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
  32 #include &quot;ttsbit.h&quot;
  33 #endif
  34 
<span class="line-added">  35 #ifdef TT_CONFIG_OPTION_COLOR_LAYERS</span>
<span class="line-added">  36 #include &quot;ttcolr.h&quot;</span>
<span class="line-added">  37 #include &quot;ttcpal.h&quot;</span>
<span class="line-added">  38 #endif</span>
<span class="line-added">  39 </span>
  40 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
  41 #include &quot;ttpost.h&quot;
  42 #endif
  43 
  44 #ifdef TT_CONFIG_OPTION_BDF
  45 #include &quot;ttbdf.h&quot;
  46 #include FT_SERVICE_BDF_H
  47 #endif
  48 
  49 #include &quot;ttcmap.h&quot;
  50 #include &quot;ttkern.h&quot;
  51 #include &quot;ttmtx.h&quot;
  52 
  53 #include FT_SERVICE_GLYPH_DICT_H
  54 #include FT_SERVICE_POSTSCRIPT_NAME_H
  55 #include FT_SERVICE_SFNT_H
  56 #include FT_SERVICE_TT_CMAP_H
  57 
  58 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  59 #include FT_MULTIPLE_MASTERS_H
  60 #include FT_SERVICE_MULTIPLE_MASTERS_H
  61 #endif
  62 
  63 
<span class="line-modified">  64   /**************************************************************************</span>
<span class="line-modified">  65    *</span>
<span class="line-modified">  66    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  67    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  68    * messages during execution.</span>
<span class="line-modified">  69    */</span>
  70 #undef  FT_COMPONENT
<span class="line-modified">  71 #define FT_COMPONENT  sfdriver</span>
  72 
  73 
  74   /*
<span class="line-modified">  75    * SFNT TABLE SERVICE</span>
  76    *
  77    */
  78 
  79   static void*
  80   get_sfnt_table( TT_Face      face,
  81                   FT_Sfnt_Tag  tag )
  82   {
  83     void*  table;
  84 
  85 
  86     switch ( tag )
  87     {
  88     case FT_SFNT_HEAD:
  89       table = &amp;face-&gt;header;
  90       break;
  91 
  92     case FT_SFNT_HHEA:
  93       table = &amp;face-&gt;horizontal;
  94       break;
  95 
</pre>
<hr />
<pre>
 142       *offset = face-&gt;dir_tables[idx].Offset;
 143       *length = face-&gt;dir_tables[idx].Length;
 144     }
 145 
 146     return FT_Err_Ok;
 147   }
 148 
 149 
 150   FT_DEFINE_SERVICE_SFNT_TABLEREC(
 151     sfnt_service_sfnt_table,
 152 
 153     (FT_SFNT_TableLoadFunc)tt_face_load_any,     /* load_table */
 154     (FT_SFNT_TableGetFunc) get_sfnt_table,       /* get_table  */
 155     (FT_SFNT_TableInfoFunc)sfnt_table_info       /* table_info */
 156   )
 157 
 158 
 159 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 160 
 161   /*
<span class="line-modified"> 162    * GLYPH DICT SERVICE</span>
 163    *
 164    */
 165 
 166   static FT_Error
 167   sfnt_get_glyph_name( FT_Face     face,
 168                        FT_UInt     glyph_index,
 169                        FT_Pointer  buffer,
 170                        FT_UInt     buffer_max )
 171   {
 172     FT_String*  gname;
 173     FT_Error    error;
 174 
 175 
 176     error = tt_face_get_ps_name( (TT_Face)face, glyph_index, &amp;gname );
 177     if ( !error )
 178       FT_STRCPYN( buffer, gname, buffer_max );
 179 
 180     return error;
 181   }
 182 
 183 
 184   static FT_UInt
<span class="line-modified"> 185   sfnt_get_name_index( FT_Face           face,</span>
<span class="line-modified"> 186                        const FT_String*  glyph_name )</span>
 187   {
 188     TT_Face  ttface = (TT_Face)face;
 189 
 190     FT_UInt  i, max_gid = FT_UINT_MAX;
 191 
 192 
 193     if ( face-&gt;num_glyphs &lt; 0 )
 194       return 0;
 195     else if ( (FT_ULong)face-&gt;num_glyphs &lt; FT_UINT_MAX )
 196       max_gid = (FT_UInt)face-&gt;num_glyphs;
 197     else
 198       FT_TRACE0(( &quot;Ignore glyph names for invalid GID 0x%08x - 0x%08x\n&quot;,
 199                   FT_UINT_MAX, face-&gt;num_glyphs ));
 200 
 201     for ( i = 0; i &lt; max_gid; i++ )
 202     {
 203       FT_String*  gname;
 204       FT_Error    error = tt_face_get_ps_name( ttface, i, &amp;gname );
 205 
 206 
</pre>
<hr />
<pre>
 209 
 210       if ( !ft_strcmp( glyph_name, gname ) )
 211         return i;
 212     }
 213 
 214     return 0;
 215   }
 216 
 217 
 218   FT_DEFINE_SERVICE_GLYPHDICTREC(
 219     sfnt_service_glyph_dict,
 220 
 221     (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,    /* get_name   */
 222     (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index     /* name_index */
 223   )
 224 
 225 #endif /* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
 226 
 227 
 228   /*
<span class="line-modified"> 229    * POSTSCRIPT NAME SERVICE</span>
 230    *
 231    */
 232 
 233   /* an array representing allowed ASCII characters in a PS string */
 234   static const unsigned char sfnt_ps_map[16] =
 235   {
 236                 /*             4        0        C        8 */
 237     0x00, 0x00, /* 0x00: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 238     0x00, 0x00, /* 0x10: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 239     0xDE, 0x7C, /* 0x20: 1 1 0 1  1 1 1 0  0 1 1 1  1 1 0 0 */
 240     0xFF, 0xAF, /* 0x30: 1 1 1 1  1 1 1 1  1 0 1 0  1 1 1 1 */
 241     0xFF, 0xFF, /* 0x40: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 242     0xFF, 0xD7, /* 0x50: 1 1 1 1  1 1 1 1  1 1 0 1  0 1 1 1 */
 243     0xFF, 0xFF, /* 0x60: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 244     0xFF, 0x57  /* 0x70: 1 1 1 1  1 1 1 1  0 1 0 1  0 1 1 1 */
 245   };
 246 
 247 
 248   static int
 249   sfnt_is_postscript( int  c )
</pre>
<hr />
<pre>
 358       h4 ^= k4;
 359 
 360       h4  = ROTL32( h4, 13 );
 361       h4 += h1;
 362       h4  = h4 * 5 + 0x32ac3b17;
 363     }
 364 
 365     {
 366       const FT_Byte*  tail = (const FT_Byte*)( data + nblocks * 16 );
 367 
 368       FT_UInt32  k1 = 0;
 369       FT_UInt32  k2 = 0;
 370       FT_UInt32  k3 = 0;
 371       FT_UInt32  k4 = 0;
 372 
 373 
 374       switch ( len &amp; 15 )
 375       {
 376       case 15:
 377         k4 ^= (FT_UInt32)tail[14] &lt;&lt; 16;
<span class="line-added"> 378         /* fall through */</span>
 379       case 14:
 380         k4 ^= (FT_UInt32)tail[13] &lt;&lt; 8;
<span class="line-added"> 381         /* fall through */</span>
 382       case 13:
 383         k4 ^= (FT_UInt32)tail[12];
 384         k4 *= c4;
 385         k4  = ROTL32( k4, 18 );
 386         k4 *= c1;
 387         h4 ^= k4;
<span class="line-added"> 388         /* fall through */</span>
 389 
 390       case 12:
 391         k3 ^= (FT_UInt32)tail[11] &lt;&lt; 24;
<span class="line-added"> 392         /* fall through */</span>
 393       case 11:
 394         k3 ^= (FT_UInt32)tail[10] &lt;&lt; 16;
<span class="line-added"> 395         /* fall through */</span>
 396       case 10:
 397         k3 ^= (FT_UInt32)tail[9] &lt;&lt; 8;
<span class="line-added"> 398         /* fall through */</span>
 399       case 9:
 400         k3 ^= (FT_UInt32)tail[8];
 401         k3 *= c3;
 402         k3  = ROTL32( k3, 17 );
 403         k3 *= c4;
 404         h3 ^= k3;
<span class="line-added"> 405         /* fall through */</span>
 406 
 407       case 8:
 408         k2 ^= (FT_UInt32)tail[7] &lt;&lt; 24;
<span class="line-added"> 409         /* fall through */</span>
 410       case 7:
 411         k2 ^= (FT_UInt32)tail[6] &lt;&lt; 16;
<span class="line-added"> 412         /* fall through */</span>
 413       case 6:
 414         k2 ^= (FT_UInt32)tail[5] &lt;&lt; 8;
<span class="line-added"> 415         /* fall through */</span>
 416       case 5:
 417         k2 ^= (FT_UInt32)tail[4];
 418         k2 *= c2;
 419         k2  = ROTL32( k2, 16 );
 420         k2 *= c3;
 421         h2 ^= k2;
<span class="line-added"> 422         /* fall through */</span>
 423 
 424       case 4:
 425         k1 ^= (FT_UInt32)tail[3] &lt;&lt; 24;
<span class="line-added"> 426         /* fall through */</span>
 427       case 3:
 428         k1 ^= (FT_UInt32)tail[2] &lt;&lt; 16;
<span class="line-added"> 429         /* fall through */</span>
 430       case 2:
 431         k1 ^= (FT_UInt32)tail[1] &lt;&lt; 8;
<span class="line-added"> 432         /* fall through */</span>
 433       case 1:
 434         k1 ^= (FT_UInt32)tail[0];
 435         k1 *= c1;
 436         k1  = ROTL32( k1, 15 );
 437         k1 *= c2;
 438         h1 ^= k1;
 439       }
 440     }
 441 
 442     h1 ^= len;
 443     h2 ^= len;
 444     h3 ^= len;
 445     h4 ^= len;
 446 
 447     h1 += h2;
 448     h1 += h3;
 449     h1 += h4;
 450 
 451     h2 += h1;
 452     h3 += h1;
</pre>
<hr />
<pre>
 461     h1 += h3;
 462     h1 += h4;
 463 
 464     h2 += h1;
 465     h3 += h1;
 466     h4 += h1;
 467 
 468     ((FT_UInt32*)out)[0] = h1;
 469     ((FT_UInt32*)out)[1] = h2;
 470     ((FT_UInt32*)out)[2] = h3;
 471     ((FT_UInt32*)out)[3] = h4;
 472   }
 473 
 474 
 475 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 476 
 477 
 478   typedef int (*char_type_func)( int  c );
 479 
 480 
<span class="line-modified"> 481   /* Handling of PID/EID 3/0 and 3/1 is the same. */</span>
 482 #define IS_WIN( n )  ( (n)-&gt;platformID == 3                             &amp;&amp; \
<span class="line-modified"> 483                        ( (n)-&gt;encodingID == 1 || (n)-&gt;encodingID == 0 ) )</span>

 484 
 485 #define IS_APPLE( n )  ( (n)-&gt;platformID == 1 &amp;&amp; \
<span class="line-modified"> 486                          (n)-&gt;encodingID == 0 )</span>

 487 
 488   static char*
 489   get_win_string( FT_Memory       memory,
 490                   FT_Stream       stream,
 491                   TT_Name         entry,
 492                   char_type_func  char_type,
 493                   FT_Bool         report_invalid_characters )
 494   {
 495     FT_Error  error = FT_Err_Ok;
 496 
 497     char*       result = NULL;
 498     FT_String*  r;
 499     FT_Char*    p;
 500     FT_UInt     len;
 501 
 502     FT_UNUSED( error );
 503 
 504 
 505     if ( FT_ALLOC( result, entry-&gt;stringLength / 2 + 1 ) )
 506       return NULL;
 507 
 508     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 509          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<span class="line-modified"> 510       goto get_win_string_error;</span>







 511 
 512     r = (FT_String*)result;
 513     p = (FT_Char*)stream-&gt;cursor;
 514 
 515     for ( len = entry-&gt;stringLength / 2; len &gt; 0; len--, p += 2 )
 516     {
<span class="line-modified"> 517       if ( p[0] == 0 &amp;&amp; char_type( p[1] ) )</span>
<span class="line-added"> 518         *r++ = p[1];</span>
<span class="line-added"> 519       else</span>
 520       {
<span class="line-modified"> 521         if ( report_invalid_characters )</span>
<span class="line-modified"> 522           FT_TRACE0(( &quot;get_win_string:&quot;</span>
<span class="line-modified"> 523                       &quot; Character 0x%X invalid in PS name string\n&quot;,</span>
<span class="line-modified"> 524                       ((unsigned)p[0])*256 + (unsigned)p[1] ));</span>
<span class="line-modified"> 525         break;</span>








 526       }
 527     }
<span class="line-modified"> 528     if ( !len )</span>
<span class="line-added"> 529       *r = &#39;\0&#39;;</span>
 530 
 531     FT_FRAME_EXIT();
 532 
<span class="line-modified"> 533     if ( !len )</span>
<span class="line-added"> 534       return result;</span>
<span class="line-added"> 535 </span>
<span class="line-added"> 536   get_win_string_error:</span>
<span class="line-added"> 537     FT_FREE( result );</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539     entry-&gt;stringLength = 0;</span>
<span class="line-added"> 540     entry-&gt;stringOffset = 0;</span>
<span class="line-added"> 541     FT_FREE( entry-&gt;string );</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543     return NULL;</span>
 544   }
 545 
 546 
 547   static char*
 548   get_apple_string( FT_Memory       memory,
 549                     FT_Stream       stream,
 550                     TT_Name         entry,
 551                     char_type_func  char_type,
 552                     FT_Bool         report_invalid_characters )
 553   {
 554     FT_Error  error = FT_Err_Ok;
 555 
 556     char*       result = NULL;
 557     FT_String*  r;
 558     FT_Char*    p;
 559     FT_UInt     len;
 560 
 561     FT_UNUSED( error );
 562 
 563 
 564     if ( FT_ALLOC( result, entry-&gt;stringLength + 1 ) )
 565       return NULL;
 566 
 567     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 568          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<span class="line-modified"> 569       goto get_apple_string_error;</span>







 570 
 571     r = (FT_String*)result;
 572     p = (FT_Char*)stream-&gt;cursor;
 573 
 574     for ( len = entry-&gt;stringLength; len &gt; 0; len--, p++ )
 575     {
 576       if ( char_type( *p ) )
 577         *r++ = *p;
 578       else
 579       {
 580         if ( report_invalid_characters )

 581           FT_TRACE0(( &quot;get_apple_string:&quot;
 582                       &quot; Character `%c&#39; (0x%X) invalid in PS name string\n&quot;,
 583                       *p, *p ));
<span class="line-modified"> 584         break;</span>


 585       }
 586     }
<span class="line-modified"> 587     if ( !len )</span>
<span class="line-added"> 588       *r = &#39;\0&#39;;</span>
 589 
 590     FT_FRAME_EXIT();
 591 
<span class="line-modified"> 592     if ( !len )</span>
<span class="line-added"> 593       return result;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595   get_apple_string_error:</span>
<span class="line-added"> 596     FT_FREE( result );</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     entry-&gt;stringOffset = 0;</span>
<span class="line-added"> 599     entry-&gt;stringLength = 0;</span>
<span class="line-added"> 600     FT_FREE( entry-&gt;string );</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602     return NULL;</span>
 603   }
 604 
 605 
 606   static FT_Bool
 607   sfnt_get_name_id( TT_Face    face,
 608                     FT_UShort  id,
 609                     FT_Int    *win,
 610                     FT_Int    *apple )
 611   {
 612     FT_Int  n;
 613 
 614 
 615     *win   = -1;
 616     *apple = -1;
 617 
 618     for ( n = 0; n &lt; face-&gt;num_names; n++ )
 619     {
 620       TT_Name  name = face-&gt;name_table.names + n;
 621 
 622 
 623       if ( name-&gt;nameID == id &amp;&amp; name-&gt;stringLength &gt; 0 )
 624       {
<span class="line-modified"> 625         if ( IS_WIN( name ) &amp;&amp; ( name-&gt;languageID == 0x409 || *win == -1 ) )</span>
 626           *win = n;
 627 
<span class="line-modified"> 628         if ( IS_APPLE( name ) &amp;&amp; ( name-&gt;languageID == 0 || *apple == -1 ) )</span>
 629           *apple = n;
 630       }
 631     }
 632 
 633     return ( *win &gt;= 0 ) || ( *apple &gt;= 0 );
 634   }
 635 
 636 
 637 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 638 
 639   /*
 640       The maximum length of an axis value descriptor.
 641 
 642       We need 65536 different values for the decimal fraction; this fits
 643       nicely into five decimal places.  Consequently, it consists of
 644 
 645         . the minus sign if the number is negative,
 646         . up to five characters for the digits before the decimal point,
 647         . the decimal point if there is a fractional part, and
 648         . up to five characters for the digits after the decimal point.
 649 
 650       We also need one byte for the leading `_&#39; character and up to four
 651       bytes for the axis tag.
 652    */
 653 #define MAX_VALUE_DESCRIPTOR_LEN  ( 1 + 5 + 1 + 5 + 1 + 4 )
 654 
 655 
 656   /* the maximum length of PostScript font names */
 657 #define MAX_PS_NAME_LEN  127
 658 
 659 
 660   /*
<span class="line-modified"> 661    * Find the shortest decimal representation of a 16.16 fixed point</span>
<span class="line-modified"> 662    * number.  The function fills `buf&#39; with the result, returning a pointer</span>
<span class="line-modified"> 663    * to the position after the representation&#39;s last byte.</span>
 664    */
 665 
 666   static char*
 667   fixed2float( FT_Int  fixed,
 668                char*   buf )
 669   {
 670     char*  p;
 671     char*  q;
 672     char   tmp[5];
 673 
 674     FT_Int  int_part;
 675     FT_Int  frac_part;
 676 
 677     FT_Int  i;
 678 
 679 
 680     p = buf;
 681 
 682     if ( fixed == 0 )
 683     {
 684       *p++ = &#39;0&#39;;
 685       return p;
 686     }
 687 
 688     if ( fixed &lt; 0 )
 689     {
 690       *p++ = &#39;-&#39;;
<span class="line-modified"> 691       fixed = NEG_INT( fixed );</span>
 692     }
 693 
 694     int_part  = ( fixed &gt;&gt; 16 ) &amp; 0xFFFF;
 695     frac_part = fixed &amp; 0xFFFF;
 696 
 697     /* get digits of integer part (in reverse order) */
 698     q = tmp;
 699     while ( int_part &gt; 0 )
 700     {
 701       *q++      = &#39;0&#39; + int_part % 10;
 702       int_part /= 10;
 703     }
 704 
 705     /* copy digits in correct order to buffer */
 706     while ( q &gt; tmp )
 707       *p++ = *--q;
 708 
 709     if ( !frac_part )
 710       return p;
 711 
</pre>
<hr />
<pre>
 826         found = sfnt_get_name_id( face,
 827                                   TT_NAME_ID_FONT_FAMILY,
 828                                   &amp;win,
 829                                   &amp;apple );
 830       }
 831 
 832       if ( !found )
 833       {
 834         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 835                     &quot; Can&#39;t construct PS name prefix for font instances\n&quot; ));
 836         return NULL;
 837       }
 838 
 839       /* prefer Windows entries over Apple */
 840       if ( win != -1 )
 841         result = get_win_string( face-&gt;root.memory,
 842                                  face-&gt;name_table.stream,
 843                                  face-&gt;name_table.names + win,
 844                                  sfnt_is_alphanumeric,
 845                                  0 );
<span class="line-modified"> 846       if ( !result &amp;&amp; apple != -1 )</span>
 847         result = get_apple_string( face-&gt;root.memory,
 848                                    face-&gt;name_table.stream,
 849                                    face-&gt;name_table.names + apple,
 850                                    sfnt_is_alphanumeric,
 851                                    0 );
 852 
<span class="line-added"> 853       if ( !result )</span>
<span class="line-added"> 854       {</span>
<span class="line-added"> 855         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;</span>
<span class="line-added"> 856                     &quot; No valid PS name prefix for font instances found\n&quot; ));</span>
<span class="line-added"> 857         return NULL;</span>
<span class="line-added"> 858       }</span>
<span class="line-added"> 859 </span>
 860       len = ft_strlen( result );
 861 
 862       /* sanitize if necessary; we reserve space for 36 bytes (a 128bit  */
 863       /* checksum as a hex number, preceded by `-&#39; and followed by three */
 864       /* ASCII dots, to be used if the constructed PS name would be too  */
 865       /* long); this is also sufficient for a single instance            */
 866       if ( len &gt; MAX_PS_NAME_LEN - ( 1 + 32 + 3 ) )
 867       {
 868         len         = MAX_PS_NAME_LEN - ( 1 + 32 + 3 );
 869         result[len] = &#39;\0&#39;;
 870 
 871         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 872                     &quot; Shortening variation PS name prefix\n&quot;
 873                     &quot;                     &quot;
 874                     &quot; to %d characters\n&quot;, len ));
 875       }
 876 
 877       face-&gt;var_postscript_prefix     = result;
 878       face-&gt;var_postscript_prefix_len = len;
 879     }
</pre>
<hr />
<pre>
1057            FT_IS_VARIATION( FT_FACE( face ) )      ) )
1058     {
1059       face-&gt;postscript_name = sfnt_get_var_ps_name( face );
1060       return face-&gt;postscript_name;
1061     }
1062 #endif
1063 
1064     /* scan the name table to see whether we have a Postscript name here, */
1065     /* either in Macintosh or Windows platform encodings                  */
1066     found = sfnt_get_name_id( face, TT_NAME_ID_PS_NAME, &amp;win, &amp;apple );
1067     if ( !found )
1068       return NULL;
1069 
1070     /* prefer Windows entries over Apple */
1071     if ( win != -1 )
1072       result = get_win_string( face-&gt;root.memory,
1073                                face-&gt;name_table.stream,
1074                                face-&gt;name_table.names + win,
1075                                sfnt_is_postscript,
1076                                1 );
<span class="line-modified">1077     if ( !result &amp;&amp; apple != -1 )</span>
1078       result = get_apple_string( face-&gt;root.memory,
1079                                  face-&gt;name_table.stream,
1080                                  face-&gt;name_table.names + apple,
1081                                  sfnt_is_postscript,
1082                                  1 );
1083 
1084     face-&gt;postscript_name = result;
1085 
1086     return result;
1087   }
1088 
1089 
1090   FT_DEFINE_SERVICE_PSFONTNAMEREC(
1091     sfnt_service_ps_name,
1092 
1093     (FT_PsName_GetFunc)sfnt_get_ps_name       /* get_ps_font_name */
1094   )
1095 
1096 
1097   /*
<span class="line-modified">1098    * TT CMAP INFO</span>
1099    */
1100   FT_DEFINE_SERVICE_TTCMAPSREC(
1101     tt_service_get_cmap_info,
1102 
1103     (TT_CMap_Info_GetFunc)tt_get_cmap_info    /* get_cmap_info */
1104   )
1105 
1106 
1107 #ifdef TT_CONFIG_OPTION_BDF
1108 
1109   static FT_Error
1110   sfnt_get_charset_id( TT_Face       face,
1111                        const char*  *acharset_encoding,
1112                        const char*  *acharset_registry )
1113   {
1114     BDF_PropertyRec  encoding, registry;
1115     FT_Error         error;
1116 
1117 
1118     /* XXX: I don&#39;t know whether this is correct, since
</pre>
<hr />
<pre>
1137           error = FT_THROW( Invalid_Argument );
1138       }
1139     }
1140 
1141     return error;
1142   }
1143 
1144 
1145   FT_DEFINE_SERVICE_BDFRec(
1146     sfnt_service_bdf,
1147 
1148     (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,     /* get_charset_id */
1149     (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop    /* get_property   */
1150   )
1151 
1152 
1153 #endif /* TT_CONFIG_OPTION_BDF */
1154 
1155 
1156   /*
<span class="line-modified">1157    * SERVICE LIST</span>
1158    */
1159 
1160 #if defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES &amp;&amp; defined TT_CONFIG_OPTION_BDF
1161   FT_DEFINE_SERVICEDESCREC5(
1162     sfnt_services,
1163 
<span class="line-modified">1164     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1165     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1166     FT_SERVICE_ID_GLYPH_DICT,           &amp;sfnt_service_glyph_dict,</span>
<span class="line-modified">1167     FT_SERVICE_ID_BDF,                  &amp;sfnt_service_bdf,</span>
<span class="line-modified">1168     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1169 #elif defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1170   FT_DEFINE_SERVICEDESCREC4(
1171     sfnt_services,
1172 
<span class="line-modified">1173     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1174     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1175     FT_SERVICE_ID_GLYPH_DICT,           &amp;sfnt_service_glyph_dict,</span>
<span class="line-modified">1176     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1177 #elif defined TT_CONFIG_OPTION_BDF
1178   FT_DEFINE_SERVICEDESCREC4(
1179     sfnt_services,
1180 
<span class="line-modified">1181     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1182     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1183     FT_SERVICE_ID_BDF,                  &amp;sfnt_service_bdf,</span>
<span class="line-modified">1184     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1185 #else
1186   FT_DEFINE_SERVICEDESCREC3(
1187     sfnt_services,
1188 
<span class="line-modified">1189     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1190     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1191     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1192 #endif
1193 
1194 
1195   FT_CALLBACK_DEF( FT_Module_Interface )
1196   sfnt_get_interface( FT_Module    module,
1197                       const char*  module_interface )
1198   {











1199     FT_UNUSED( module );

1200 
<span class="line-modified">1201     return ft_service_list_lookup( sfnt_services, module_interface );</span>
1202   }
1203 
1204 
1205 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1206 #define PUT_EMBEDDED_BITMAPS( a )  a
1207 #else
1208 #define PUT_EMBEDDED_BITMAPS( a )  NULL
1209 #endif
1210 
<span class="line-added">1211 #ifdef TT_CONFIG_OPTION_COLOR_LAYERS</span>
<span class="line-added">1212 #define PUT_COLOR_LAYERS( a )  a</span>
<span class="line-added">1213 #else</span>
<span class="line-added">1214 #define PUT_COLOR_LAYERS( a )  NULL</span>
<span class="line-added">1215 #endif</span>
<span class="line-added">1216 </span>
1217 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1218 #define PUT_PS_NAMES( a )  a
1219 #else
1220 #define PUT_PS_NAMES( a )  NULL
1221 #endif
1222 
1223   FT_DEFINE_SFNT_INTERFACE(
1224     sfnt_interface,
1225 
1226     tt_face_goto_table,     /* TT_Loader_GotoTableFunc goto_table      */
1227 
1228     sfnt_init_face,         /* TT_Init_Face_Func       init_face       */
1229     sfnt_load_face,         /* TT_Load_Face_Func       load_face       */
1230     sfnt_done_face,         /* TT_Done_Face_Func       done_face       */
1231     sfnt_get_interface,     /* FT_Module_Requester     get_interface   */
1232 
1233     tt_face_load_any,       /* TT_Load_Any_Func        load_any        */
1234 
1235     tt_face_load_head,      /* TT_Load_Table_Func      load_head       */
1236     tt_face_load_hhea,      /* TT_Load_Metrics_Func    load_hhea       */
</pre>
<hr />
<pre>
1255     /* see `ttpost.h&#39; */
1256     PUT_PS_NAMES( tt_face_get_ps_name   ),
1257                             /* TT_Get_PS_Name_Func     get_psname      */
1258     PUT_PS_NAMES( tt_face_free_ps_names ),
1259                             /* TT_Free_Table_Func      free_psnames    */
1260 
1261     /* since version 2.1.8 */
1262     tt_face_get_kerning,    /* TT_Face_GetKerningFunc  get_kerning     */
1263 
1264     /* since version 2.2 */
1265     tt_face_load_font_dir,  /* TT_Load_Table_Func      load_font_dir   */
1266     tt_face_load_hmtx,      /* TT_Load_Metrics_Func    load_hmtx       */
1267 
1268     /* see `ttsbit.h&#39; and `sfnt.h&#39; */
1269     PUT_EMBEDDED_BITMAPS( tt_face_load_sbit ),
1270                             /* TT_Load_Table_Func      load_eblc       */
1271     PUT_EMBEDDED_BITMAPS( tt_face_free_sbit ),
1272                             /* TT_Free_Table_Func      free_eblc       */
1273 
1274     PUT_EMBEDDED_BITMAPS( tt_face_set_sbit_strike     ),
<span class="line-modified">1275                    /* TT_Set_SBit_Strike_Func      set_sbit_strike     */</span>
1276     PUT_EMBEDDED_BITMAPS( tt_face_load_strike_metrics ),
<span class="line-modified">1277                    /* TT_Load_Strike_Metrics_Func  load_strike_metrics */</span>
<span class="line-added">1278 </span>
<span class="line-added">1279     PUT_COLOR_LAYERS( tt_face_load_cpal ),</span>
<span class="line-added">1280                             /* TT_Load_Table_Func      load_cpal       */</span>
<span class="line-added">1281     PUT_COLOR_LAYERS( tt_face_load_colr ),</span>
<span class="line-added">1282                             /* TT_Load_Table_Func      load_colr       */</span>
<span class="line-added">1283     PUT_COLOR_LAYERS( tt_face_free_cpal ),</span>
<span class="line-added">1284                             /* TT_Free_Table_Func      free_cpal       */</span>
<span class="line-added">1285     PUT_COLOR_LAYERS( tt_face_free_colr ),</span>
<span class="line-added">1286                             /* TT_Free_Table_Func      free_colr       */</span>
<span class="line-added">1287     PUT_COLOR_LAYERS( tt_face_palette_set ),</span>
<span class="line-added">1288                             /* TT_Set_Palette_Func     set_palette     */</span>
<span class="line-added">1289     PUT_COLOR_LAYERS( tt_face_get_colr_layer ),</span>
<span class="line-added">1290                             /* TT_Get_Colr_Layer_Func  get_colr_layer  */</span>
<span class="line-added">1291     PUT_COLOR_LAYERS( tt_face_colr_blend_layer ),</span>
<span class="line-added">1292                             /* TT_Blend_Colr_Func      colr_blend      */</span>
1293 
1294     tt_face_get_metrics,    /* TT_Get_Metrics_Func     get_metrics     */
1295 
1296     tt_face_get_name,       /* TT_Get_Name_Func        get_name        */
1297     sfnt_get_name_id        /* TT_Get_Name_ID_Func     get_name_id     */
1298   )
1299 
1300 
1301   FT_DEFINE_MODULE(
1302     sfnt_module_class,
1303 
1304     0,  /* not a font driver or renderer */
1305     sizeof ( FT_ModuleRec ),
1306 
1307     &quot;sfnt&quot;,     /* driver name                            */
1308     0x10000L,   /* driver version 1.0                     */
1309     0x20000L,   /* driver requires FreeType 2.0 or higher */
1310 
<span class="line-modified">1311     (const void*)&amp;sfnt_interface,  /* module specific interface */</span>
1312 
1313     (FT_Module_Constructor)NULL,               /* module_init   */
1314     (FT_Module_Destructor) NULL,               /* module_done   */
1315     (FT_Module_Requester)  sfnt_get_interface  /* get_interface */
1316   )
1317 
1318 
1319 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="pngshim.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="sfdriver.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/truetype/ttgxvar.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ttgload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgxvar.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/truetype/ttgxvar.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttgxvar.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    TrueType GX Font Variation loader                                    */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2004-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18 </span>
<span class="line-modified">  19   /*************************************************************************/</span>
<span class="line-modified">  20   /*                                                                       */</span>
<span class="line-modified">  21   /* Apple documents the `fvar&#39;, `gvar&#39;, `cvar&#39;, and `avar&#39; tables at      */</span>
<span class="line-modified">  22   /*                                                                       */</span>
<span class="line-modified">  23   /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html */</span>
<span class="line-modified">  24   /*                                                                       */</span>
<span class="line-modified">  25   /* The documentation for `gvar&#39; is not intelligible; `cvar&#39; refers you   */</span>
<span class="line-modified">  26   /* to `gvar&#39; and is thus also incomprehensible.                          */</span>
<span class="line-modified">  27   /*                                                                       */</span>
<span class="line-modified">  28   /* The documentation for `avar&#39; appears correct, but Apple has no fonts  */</span>
<span class="line-modified">  29   /* with an `avar&#39; table, so it is hard to test.                          */</span>
<span class="line-modified">  30   /*                                                                       */</span>
<span class="line-modified">  31   /* Many thanks to John Jenkins (at Apple) in figuring this out.          */</span>
<span class="line-modified">  32   /*                                                                       */</span>
<span class="line-modified">  33   /*                                                                       */</span>
<span class="line-modified">  34   /* Apple&#39;s `kern&#39; table has some references to tuple indices, but as     */</span>
<span class="line-modified">  35   /* there is no indication where these indices are defined, nor how to    */</span>
<span class="line-modified">  36   /* interpolate the kerning values (different tuples have different       */</span>
<span class="line-modified">  37   /* classes) this issue is ignored.                                       */</span>
<span class="line-modified">  38   /*                                                                       */</span>
<span class="line-modified">  39   /*************************************************************************/</span>
  40 
  41 
  42 #include &lt;ft2build.h&gt;
  43 #include FT_INTERNAL_DEBUG_H
  44 #include FT_CONFIG_CONFIG_H
  45 #include FT_INTERNAL_STREAM_H
  46 #include FT_INTERNAL_SFNT_H
  47 #include FT_TRUETYPE_TAGS_H
  48 #include FT_TRUETYPE_IDS_H
  49 #include FT_MULTIPLE_MASTERS_H
  50 #include FT_LIST_H
  51 
  52 #include &quot;ttpload.h&quot;
  53 #include &quot;ttgxvar.h&quot;
  54 
  55 #include &quot;tterrors.h&quot;
  56 
  57 
  58 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  59 
  60 
  61 #define FT_Stream_FTell( stream )                         \
  62           (FT_ULong)( (stream)-&gt;cursor - (stream)-&gt;base )
  63 #define FT_Stream_SeekSet( stream, off )                               \
  64           (stream)-&gt;cursor =                                           \
  65             ( (off) &lt; (FT_ULong)( (stream)-&gt;limit - (stream)-&gt;base ) ) \
  66                         ? (stream)-&gt;base + (off)                       \
  67                         : (stream)-&gt;limit
  68 
  69 
<span class="line-modified">  70   /*************************************************************************/</span>
<span class="line-modified">  71   /*                                                                       */</span>
<span class="line-modified">  72   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  73   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  74   /* messages during execution.                                            */</span>
<span class="line-modified">  75   /*                                                                       */</span>













  76 #undef  FT_COMPONENT
<span class="line-modified">  77 #define FT_COMPONENT  trace_ttgxvar</span>
  78 
  79 
  80   /*************************************************************************/
  81   /*************************************************************************/
  82   /*****                                                               *****/
  83   /*****                       Internal Routines                       *****/
  84   /*****                                                               *****/
  85   /*************************************************************************/
  86   /*************************************************************************/
  87 
  88 
<span class="line-modified">  89   /*************************************************************************/</span>
<span class="line-modified">  90   /*                                                                       */</span>
<span class="line-modified">  91   /* The macro ALL_POINTS is used in `ft_var_readpackedpoints&#39;.  It        */</span>
<span class="line-modified">  92   /* indicates that there is a delta for every point without needing to    */</span>
<span class="line-modified">  93   /* enumerate all of them.                                                */</span>
<span class="line-modified">  94   /*                                                                       */</span>
  95 
  96   /* ensure that value `0&#39; has the same width as a pointer */
  97 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
  98 
  99 
 100 #define GX_PT_POINTS_ARE_WORDS      0x80U
 101 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 102 
 103 
<span class="line-modified"> 104   /*************************************************************************/</span>
<span class="line-modified"> 105   /*                                                                       */</span>
<span class="line-modified"> 106   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 107   /*    ft_var_readpackedpoints                                            */</span>
<span class="line-modified"> 108   /*                                                                       */</span>
<span class="line-modified"> 109   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 110   /*    Read a set of points to which the following deltas will apply.     */</span>
<span class="line-modified"> 111   /*    Points are packed with a run length encoding.                      */</span>
<span class="line-modified"> 112   /*                                                                       */</span>
<span class="line-modified"> 113   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 114   /*    stream    :: The data stream.                                      */</span>
<span class="line-modified"> 115   /*                                                                       */</span>
<span class="line-modified"> 116   /*    size      :: The size of the table holding the data.               */</span>
<span class="line-modified"> 117   /*                                                                       */</span>
<span class="line-modified"> 118   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified"> 119   /*    point_cnt :: The number of points read.  A zero value means that   */</span>
<span class="line-modified"> 120   /*                 all points in the glyph will be affected, without     */</span>
<span class="line-modified"> 121   /*                 enumerating them individually.                        */</span>
<span class="line-modified"> 122   /*                                                                       */</span>
<span class="line-modified"> 123   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 124   /*    An array of FT_UShort containing the affected points or the        */</span>
<span class="line-modified"> 125   /*    special value ALL_POINTS.                                          */</span>
<span class="line-modified"> 126   /*                                                                       */</span>



 127   static FT_UShort*
 128   ft_var_readpackedpoints( FT_Stream  stream,
 129                            FT_ULong   size,
 130                            FT_UInt   *point_cnt )
 131   {
 132     FT_UShort *points = NULL;
 133     FT_UInt    n;
 134     FT_UInt    runcnt;
 135     FT_UInt    i, j;
 136     FT_UShort  first;
 137     FT_Memory  memory = stream-&gt;memory;
 138     FT_Error   error  = FT_Err_Ok;
 139 
 140     FT_UNUSED( error );
 141 
 142 
 143     *point_cnt = 0;
 144 
 145     n = FT_GET_BYTE();
 146     if ( n == 0 )
</pre>
<hr />
<pre>
 194 
 195         for ( j = 0; j &lt; runcnt; j++ )
 196         {
 197           first      += FT_GET_BYTE();
 198           points[i++] = first;
 199           if ( i &gt;= n )
 200             break;
 201         }
 202       }
 203     }
 204 
 205     return points;
 206   }
 207 
 208 
 209 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 210 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 211 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 212 
 213 
<span class="line-modified"> 214   /*************************************************************************/</span>
<span class="line-modified"> 215   /*                                                                       */</span>
<span class="line-modified"> 216   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 217   /*    ft_var_readpackeddeltas                                            */</span>
<span class="line-modified"> 218   /*                                                                       */</span>
<span class="line-modified"> 219   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 220   /*    Read a set of deltas.  These are packed slightly differently than  */</span>
<span class="line-modified"> 221   /*    points.  In particular there is no overall count.                  */</span>
<span class="line-modified"> 222   /*                                                                       */</span>
<span class="line-modified"> 223   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 224   /*    stream    :: The data stream.                                      */</span>
<span class="line-modified"> 225   /*                                                                       */</span>
<span class="line-modified"> 226   /*    size      :: The size of the table holding the data.               */</span>
<span class="line-modified"> 227   /*                                                                       */</span>
<span class="line-modified"> 228   /*    delta_cnt :: The number of deltas to be read.                      */</span>
<span class="line-modified"> 229   /*                                                                       */</span>
<span class="line-modified"> 230   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 231   /*    An array of FT_Short containing the deltas for the affected        */</span>
<span class="line-modified"> 232   /*    points.  (This only gets the deltas for one dimension.  It will    */</span>
<span class="line-modified"> 233   /*    generally be called twice, once for x, once for y.  When used in   */</span>
<span class="line-modified"> 234   /*    cvt table, it will only be called once.)                           */</span>
<span class="line-modified"> 235   /*                                                                       */</span>
<span class="line-modified"> 236   static FT_Short*</span>







 237   ft_var_readpackeddeltas( FT_Stream  stream,
 238                            FT_ULong   size,
 239                            FT_UInt    delta_cnt )
 240   {
<span class="line-modified"> 241     FT_Short  *deltas = NULL;</span>
 242     FT_UInt    runcnt, cnt;
 243     FT_UInt    i, j;
 244     FT_Memory  memory = stream-&gt;memory;
 245     FT_Error   error  = FT_Err_Ok;
 246 
 247     FT_UNUSED( error );
 248 
 249 
 250     if ( delta_cnt &gt; size )
 251     {
 252       FT_TRACE1(( &quot;ft_var_readpackeddeltas: number of points too large\n&quot; ));
 253       return NULL;
 254     }
 255 
 256     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
 257       return NULL;
 258 
 259     i = 0;
 260     while ( i &lt; delta_cnt )
 261     {
 262       runcnt = FT_GET_BYTE();
 263       cnt    = runcnt &amp; GX_DT_DELTA_RUN_COUNT_MASK;
 264 
 265       if ( runcnt &amp; GX_DT_DELTAS_ARE_ZERO )
 266       {
 267         /* `runcnt&#39; zeroes get added */
 268         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
 269           deltas[i++] = 0;
 270       }
 271       else if ( runcnt &amp; GX_DT_DELTAS_ARE_WORDS )
 272       {
 273         /* `runcnt&#39; shorts from the stack */
 274         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified"> 275           deltas[i++] = FT_GET_SHORT();</span>
 276       }
 277       else
 278       {
 279         /* `runcnt&#39; signed bytes from the stack */
 280         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified"> 281           deltas[i++] = FT_GET_CHAR();</span>
 282       }
 283 
 284       if ( j &lt;= cnt )
 285       {
 286         /* bad format */
 287         FT_FREE( deltas );
 288         return NULL;
 289       }
 290     }
 291 
 292     return deltas;
 293   }
 294 
 295 
<span class="line-modified"> 296   /*************************************************************************/</span>
<span class="line-modified"> 297   /*                                                                       */</span>
<span class="line-modified"> 298   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 299   /*    ft_var_load_avar                                                   */</span>
<span class="line-modified"> 300   /*                                                                       */</span>
<span class="line-modified"> 301   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 302   /*    Parse the `avar&#39; table if present.  It need not be, so we return   */</span>
<span class="line-modified"> 303   /*    nothing.                                                           */</span>
<span class="line-modified"> 304   /*                                                                       */</span>
<span class="line-modified"> 305   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 306   /*    face :: The font face.                                             */</span>
<span class="line-modified"> 307   /*                                                                       */</span>

 308   static void
 309   ft_var_load_avar( TT_Face  face )
 310   {
 311     FT_Stream       stream = FT_FACE_STREAM( face );
 312     FT_Memory       memory = stream-&gt;memory;
 313     GX_Blend        blend  = face-&gt;blend;
 314     GX_AVarSegment  segment;
 315     FT_Error        error = FT_Err_Ok;
 316     FT_Long         version;
 317     FT_Long         axisCount;
 318     FT_Int          i, j;
 319     FT_ULong        table_len;
 320 
 321     FT_UNUSED( error );
 322 
 323 
 324     FT_TRACE2(( &quot;AVAR &quot; ));
 325 
 326     blend-&gt;avar_loaded = TRUE;
 327     error = face-&gt;goto_table( face, TTAG_avar, stream, &amp;table_len );
</pre>
<hr />
<pre>
 360     {
 361       FT_TRACE5(( &quot;  axis %d:\n&quot;, i ));
 362 
 363       segment-&gt;pairCount = FT_GET_USHORT();
 364       if ( (FT_ULong)segment-&gt;pairCount * 4 &gt; table_len                ||
 365            FT_NEW_ARRAY( segment-&gt;correspondence, segment-&gt;pairCount ) )
 366       {
 367         /* Failure.  Free everything we have done so far.  We must do */
 368         /* it right now since loading the `avar&#39; table is optional.   */
 369 
 370         for ( j = i - 1; j &gt;= 0; j-- )
 371           FT_FREE( blend-&gt;avar_segment[j].correspondence );
 372 
 373         FT_FREE( blend-&gt;avar_segment );
 374         blend-&gt;avar_segment = NULL;
 375         goto Exit;
 376       }
 377 
 378       for ( j = 0; j &lt; segment-&gt;pairCount; j++ )
 379       {
<span class="line-modified"> 380         /* convert to Fixed */</span>
<span class="line-modified"> 381         segment-&gt;correspondence[j].fromCoord = FT_GET_SHORT() * 4;</span>
<span class="line-modified"> 382         segment-&gt;correspondence[j].toCoord   = FT_GET_SHORT() * 4;</span>

 383 
 384         FT_TRACE5(( &quot;    mapping %.5f to %.5f\n&quot;,
 385                     segment-&gt;correspondence[j].fromCoord / 65536.0,
 386                     segment-&gt;correspondence[j].toCoord / 65536.0 ));
 387       }
 388 
 389       FT_TRACE5(( &quot;\n&quot; ));
 390     }
 391 
 392   Exit:
 393     FT_FRAME_EXIT();
 394   }
 395 
 396 
<span class="line-removed"> 397   /* some macros we need */</span>
<span class="line-removed"> 398 #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )</span>
<span class="line-removed"> 399 </span>
<span class="line-removed"> 400 #define FT_fdot14ToFixed( x )                \</span>
<span class="line-removed"> 401         ( (FT_Fixed)( (FT_ULong)(x) &lt;&lt; 2 ) )</span>
<span class="line-removed"> 402 #define FT_intToFixed( i )                    \</span>
<span class="line-removed"> 403         ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 16 ) )</span>
<span class="line-removed"> 404 #define FT_fixedToInt( x )                                   \</span>
<span class="line-removed"> 405         ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) &gt;&gt; 16 ) )</span>
<span class="line-removed"> 406 </span>
<span class="line-removed"> 407 </span>
 408   static FT_Error
 409   ft_var_load_item_variation_store( TT_Face          face,
 410                                     FT_ULong         offset,
 411                                     GX_ItemVarStore  itemStore )
 412   {
 413     FT_Stream  stream = FT_FACE_STREAM( face );
 414     FT_Memory  memory = stream-&gt;memory;
 415 
 416     FT_Error   error;
 417     FT_UShort  format;
 418     FT_ULong   region_offset;
 419     FT_UInt    i, j, k;
 420     FT_UInt    shortDeltaCount;
 421 
 422     GX_Blend        blend = face-&gt;blend;
 423     GX_ItemVarData  varData;
 424 
 425     FT_ULong*  dataOffsetArray = NULL;
 426 
 427 
</pre>
<hr />
<pre>
 685 
 686       innerIndex = mapData &amp; innerIndexMask;
 687 
 688       if ( innerIndex &gt;= itemStore-&gt;varData[outerIndex].itemCount )
 689       {
 690         FT_TRACE2(( &quot;innerIndex[%d] == %d out of range\n&quot;,
 691                     i,
 692                     innerIndex ));
 693         error = FT_THROW( Invalid_Table );
 694           goto Exit;
 695       }
 696 
 697       map-&gt;innerIndex[i] = innerIndex;
 698     }
 699 
 700   Exit:
 701     return error;
 702   }
 703 
 704 
<span class="line-modified"> 705   /*************************************************************************/</span>
<span class="line-modified"> 706   /*                                                                       */</span>
<span class="line-modified"> 707   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 708   /*    ft_var_load_hvvar                                                  */</span>
<span class="line-modified"> 709   /*                                                                       */</span>
<span class="line-modified"> 710   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 711   /*    If `vertical&#39; is zero, parse the `HVAR&#39; table and set              */</span>
<span class="line-modified"> 712   /*    `blend-&gt;hvar_loaded&#39; to TRUE.  On success, `blend-&gt;hvar_checked&#39;   */</span>
<span class="line-modified"> 713   /*    is set to TRUE.                                                    */</span>
<span class="line-modified"> 714   /*                                                                       */</span>
<span class="line-modified"> 715   /*    If `vertical&#39; is not zero, parse the `VVAR&#39; table and set          */</span>
<span class="line-modified"> 716   /*    `blend-&gt;vvar_loaded&#39; to TRUE.  On success, `blend-&gt;vvar_checked&#39;   */</span>
<span class="line-modified"> 717   /*    is set to TRUE.                                                    */</span>
<span class="line-modified"> 718   /*                                                                       */</span>
<span class="line-modified"> 719   /*    Some memory may remain allocated on error; it is always freed in   */</span>
<span class="line-modified"> 720   /*    `tt_done_blend&#39;, however.                                          */</span>
<span class="line-modified"> 721   /*                                                                       */</span>
<span class="line-modified"> 722   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 723   /*    face :: The font face.                                             */</span>
<span class="line-modified"> 724   /*                                                                       */</span>
<span class="line-modified"> 725   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 726   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 727   /*                                                                       */</span>

 728   static FT_Error
 729   ft_var_load_hvvar( TT_Face  face,
 730                      FT_Bool  vertical )
 731   {
 732     FT_Stream  stream = FT_FACE_STREAM( face );
 733     FT_Memory  memory = stream-&gt;memory;
 734 
 735     GX_Blend  blend = face-&gt;blend;
 736 
 737     GX_HVVarTable  table;
 738 
 739     FT_Error   error;
 740     FT_UShort  majorVersion;
 741     FT_ULong   table_len;
 742     FT_ULong   table_offset;
 743     FT_ULong   store_offset;
 744     FT_ULong   widthMap_offset;
 745 
 746 
 747     if ( vertical )
</pre>
<hr />
<pre>
 855                          FT_UInt          innerIndex )
 856   {
 857     GX_ItemVarData  varData;
 858     FT_Short*       deltaSet;
 859 
 860     FT_UInt   master, j;
 861     FT_Fixed  netAdjustment = 0;     /* accumulated adjustment */
 862     FT_Fixed  scaledDelta;
 863     FT_Fixed  delta;
 864 
 865 
 866     /* See pseudo code from `Font Variations Overview&#39; */
 867     /* in the OpenType specification.                  */
 868 
 869     varData  = &amp;itemStore-&gt;varData[outerIndex];
 870     deltaSet = &amp;varData-&gt;deltaSet[varData-&gt;regionIdxCount * innerIndex];
 871 
 872     /* outer loop steps through master designs to be blended */
 873     for ( master = 0; master &lt; varData-&gt;regionIdxCount; master++ )
 874     {
<span class="line-modified"> 875       FT_Fixed  scalar      = FT_FIXED_ONE;</span>
 876       FT_UInt   regionIndex = varData-&gt;regionIndices[master];
 877 
 878       GX_AxisCoords  axis = itemStore-&gt;varRegionList[regionIndex].axisList;
 879 
 880 
 881       /* inner loop steps through axes in this region */
 882       for ( j = 0; j &lt; itemStore-&gt;axisCount; j++, axis++ )
 883       {
<span class="line-removed"> 884         FT_Fixed  axisScalar;</span>
<span class="line-removed"> 885 </span>
<span class="line-removed"> 886 </span>
 887         /* compute the scalar contribution of this axis; */
 888         /* ignore invalid ranges                         */
 889         if ( axis-&gt;startCoord &gt; axis-&gt;peakCoord ||
 890              axis-&gt;peakCoord &gt; axis-&gt;endCoord   )
<span class="line-modified"> 891           axisScalar = FT_FIXED_ONE;</span>
 892 
 893         else if ( axis-&gt;startCoord &lt; 0 &amp;&amp;
 894                   axis-&gt;endCoord &gt; 0   &amp;&amp;
 895                   axis-&gt;peakCoord != 0 )
<span class="line-modified"> 896           axisScalar = FT_FIXED_ONE;</span>
 897 
 898         /* peak of 0 means ignore this axis */
 899         else if ( axis-&gt;peakCoord == 0 )
<span class="line-modified"> 900           axisScalar = FT_FIXED_ONE;</span>
 901 
<span class="line-modified"> 902         /* ignore this region if coords are out of range */</span>
<span class="line-modified"> 903         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;startCoord ||</span>
<span class="line-removed"> 904                   face-&gt;blend-&gt;normalizedcoords[j] &gt; axis-&gt;endCoord   )</span>
<span class="line-removed"> 905           axisScalar = 0;</span>
 906 
<span class="line-modified"> 907         /* calculate a proportional factor */</span>
<span class="line-modified"> 908         else</span>

 909         {
<span class="line-modified"> 910           if ( face-&gt;blend-&gt;normalizedcoords[j] == axis-&gt;peakCoord )</span>
<span class="line-modified"> 911             axisScalar = FT_FIXED_ONE;</span>
<span class="line-removed"> 912           else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;peakCoord )</span>
<span class="line-removed"> 913             axisScalar =</span>
<span class="line-removed"> 914               FT_DivFix( face-&gt;blend-&gt;normalizedcoords[j] - axis-&gt;startCoord,</span>
<span class="line-removed"> 915                          axis-&gt;peakCoord - axis-&gt;startCoord );</span>
<span class="line-removed"> 916           else</span>
<span class="line-removed"> 917             axisScalar =</span>
<span class="line-removed"> 918               FT_DivFix( axis-&gt;endCoord - face-&gt;blend-&gt;normalizedcoords[j],</span>
<span class="line-removed"> 919                          axis-&gt;endCoord - axis-&gt;peakCoord );</span>
 920         }
 921 
<span class="line-modified"> 922         /* take product of all the axis scalars */</span>
<span class="line-modified"> 923         scalar = FT_MulFix( scalar, axisScalar );</span>
<span class="line-modified"> 924 </span>








 925       } /* per-axis loop */
 926 
 927       /* get the scaled delta for this region */
 928       delta       = FT_intToFixed( deltaSet[master] );
 929       scaledDelta = FT_MulFix( scalar, delta );
 930 
 931       /* accumulate the adjustments from each region */
 932       netAdjustment = netAdjustment + scaledDelta;
 933 
 934     } /* per-region loop */
 935 
 936     return FT_fixedToInt( netAdjustment );
 937   }
 938 
 939 
<span class="line-modified"> 940   /*************************************************************************/</span>
<span class="line-modified"> 941   /*                                                                       */</span>
<span class="line-modified"> 942   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 943   /*    tt_hvadvance_adjust                                                */</span>
<span class="line-modified"> 944   /*                                                                       */</span>
<span class="line-modified"> 945   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 946   /*    Apply `HVAR&#39; advance width or `VVAR&#39; advance height adjustment of  */</span>
<span class="line-modified"> 947   /*    a given glyph.                                                     */</span>
<span class="line-modified"> 948   /*                                                                       */</span>
<span class="line-modified"> 949   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 950   /*    gindex   :: The glyph index.                                       */</span>
<span class="line-modified"> 951   /*                                                                       */</span>
<span class="line-modified"> 952   /*    vertical :: If set, handle `VVAR&#39; table.                           */</span>
<span class="line-modified"> 953   /*                                                                       */</span>
<span class="line-modified"> 954   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 955   /*    face     :: The font face.                                         */</span>
<span class="line-modified"> 956   /*                                                                       */</span>
<span class="line-modified"> 957   /*    adelta   :: Points to width or height value that gets modified.    */</span>
<span class="line-modified"> 958   /*                                                                       */</span>




 959   static FT_Error
 960   tt_hvadvance_adjust( TT_Face  face,
 961                        FT_UInt  gindex,
 962                        FT_Int  *avalue,
 963                        FT_Bool  vertical )
 964   {
 965     FT_Error  error = FT_Err_Ok;
 966     FT_UInt   innerIndex, outerIndex;
 967     FT_Int    delta;
 968 
 969     GX_HVVarTable  table;
 970 
 971 
 972     if ( !face-&gt;doblend || !face-&gt;blend )
 973       goto Exit;
 974 
 975     if ( vertical )
 976     {
 977       if ( !face-&gt;blend-&gt;vvar_loaded )
 978       {
</pre>
<hr />
<pre>
1134       GX_VALUE_CASE( STRS, os2.yStrikeoutSize );
1135       GX_VALUE_CASE( UNDO, postscript.underlinePosition );
1136       GX_VALUE_CASE( UNDS, postscript.underlineThickness );
1137       GX_VALUE_CASE( VASC, vertical.Ascender );
1138       GX_VALUE_CASE( VCOF, vertical.caret_Offset );
1139       GX_VALUE_CASE( VCRN, vertical.caret_Slope_Run );
1140       GX_VALUE_CASE( VCRS, vertical.caret_Slope_Rise );
1141       GX_VALUE_CASE( VDSC, vertical.Descender );
1142       GX_VALUE_CASE( VLGP, vertical.Line_Gap );
1143       GX_VALUE_CASE( XHGT, os2.sxHeight );
1144 
1145     default:
1146       /* ignore unknown tag */
1147       p = NULL;
1148     }
1149 
1150     return p;
1151   }
1152 
1153 
<span class="line-modified">1154   /*************************************************************************/</span>
<span class="line-modified">1155   /*                                                                       */</span>
<span class="line-modified">1156   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1157   /*    ft_var_load_mvar                                                   */</span>
<span class="line-modified">1158   /*                                                                       */</span>
<span class="line-modified">1159   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1160   /*    Parse the `MVAR&#39; table.                                            */</span>
<span class="line-modified">1161   /*                                                                       */</span>
<span class="line-modified">1162   /*    Some memory may remain allocated on error; it is always freed in   */</span>
<span class="line-modified">1163   /*    `tt_done_blend&#39;, however.                                          */</span>
<span class="line-modified">1164   /*                                                                       */</span>
<span class="line-modified">1165   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1166   /*    face :: The font face.                                             */</span>
<span class="line-modified">1167   /*                                                                       */</span>

1168   static void
1169   ft_var_load_mvar( TT_Face  face )
1170   {
1171     FT_Stream  stream = FT_FACE_STREAM( face );
1172     FT_Memory  memory = stream-&gt;memory;
1173 
1174     GX_Blend         blend = face-&gt;blend;
1175     GX_ItemVarStore  itemStore;
1176     GX_Value         value, limit;
1177 
1178     FT_Error   error;
1179     FT_UShort  majorVersion;
1180     FT_ULong   table_len;
1181     FT_ULong   table_offset;
1182     FT_UShort  store_offset;
1183     FT_ULong   records_offset;
1184 
1185 
1186     FT_TRACE2(( &quot;MVAR &quot; ));
1187 
</pre>
<hr />
<pre>
1280 
1281     face-&gt;variation_support |= TT_FACE_FLAG_VAR_MVAR;
1282   }
1283 
1284 
1285   static FT_Error
1286   tt_size_reset_iterator( FT_ListNode  node,
1287                           void*        user )
1288   {
1289     TT_Size  size = (TT_Size)node-&gt;data;
1290 
1291     FT_UNUSED( user );
1292 
1293 
1294     tt_size_reset( size, 1 );
1295 
1296     return FT_Err_Ok;
1297   }
1298 
1299 
<span class="line-modified">1300   /*************************************************************************/</span>
<span class="line-modified">1301   /*                                                                       */</span>
<span class="line-modified">1302   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1303   /*    tt_apply_mvar                                                      */</span>
<span class="line-modified">1304   /*                                                                       */</span>
<span class="line-modified">1305   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1306   /*    Apply `MVAR&#39; table adjustments.                                    */</span>
<span class="line-modified">1307   /*                                                                       */</span>
<span class="line-modified">1308   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1309   /*    face :: The font face.                                             */</span>
<span class="line-modified">1310   /*                                                                       */</span>

1311   FT_LOCAL_DEF( void )
1312   tt_apply_mvar( TT_Face  face )
1313   {
1314     GX_Blend  blend = face-&gt;blend;
1315     GX_Value  value, limit;



1316 
1317 
1318     if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_MVAR ) )
1319       return;
1320 
1321     value = blend-&gt;mvar_table-&gt;values;
1322     limit = value + blend-&gt;mvar_table-&gt;valueCount;
1323 
1324     for ( ; value &lt; limit; value++ )
1325     {
1326       FT_Short*  p = ft_var_get_value_pointer( face, value-&gt;tag );
1327       FT_Int     delta;
1328 
1329 
1330       delta = ft_var_get_item_delta( face,
1331                                      &amp;blend-&gt;mvar_table-&gt;itemStore,
1332                                      value-&gt;outerIndex,
1333                                      value-&gt;innerIndex );
1334 
1335       if ( p )
1336       {
1337         FT_TRACE5(( &quot;value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\n&quot;,
1338                     (FT_Char)( value-&gt;tag &gt;&gt; 24 ),
1339                     (FT_Char)( value-&gt;tag &gt;&gt; 16 ),
1340                     (FT_Char)( value-&gt;tag &gt;&gt; 8 ),
1341                     (FT_Char)( value-&gt;tag ),
1342                     value-&gt;unmodified,
1343                     value-&gt;unmodified == 1 ? &quot;&quot; : &quot;s&quot;,
1344                     delta,
1345                     delta == 1 ? &quot;&quot; : &quot;s&quot; ));
1346 
1347         /* since we handle both signed and unsigned values as FT_Short, */
1348         /* ensure proper overflow arithmetic                            */
1349         *p = (FT_Short)( value-&gt;unmodified + (FT_Short)delta );








1350       }
1351     }
1352 
1353     /* adjust all derived values */
1354     {
1355       FT_Face  root = &amp;face-&gt;root;
1356 
<span class="line-modified">1357 </span>
<span class="line-modified">1358       if ( face-&gt;os2.version != 0xFFFFU )</span>
<span class="line-modified">1359       {</span>
<span class="line-modified">1360         if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">1361         {</span>
<span class="line-modified">1362           root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1363           root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-modified">1364 </span>
<span class="line-modified">1365           root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1366                          face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">1367         }</span>
<span class="line-modified">1368         else</span>
<span class="line-modified">1369         {</span>
<span class="line-modified">1370           root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-modified">1371           root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-modified">1372 </span>
<span class="line-modified">1373           root-&gt;height = root-&gt;ascender - root-&gt;descender;</span>
<span class="line-modified">1374         }</span>
<span class="line-modified">1375       }</span>















1376 
1377       root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1378                                   face-&gt;postscript.underlineThickness / 2;
1379       root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1380 
1381       /* iterate over all FT_Size objects and call `tt_size_reset&#39; */
1382       /* to propagate the metrics changes                          */
1383       FT_List_Iterate( &amp;root-&gt;sizes_list,
1384                        tt_size_reset_iterator,
1385                        NULL );
1386     }
1387   }
1388 
1389 
1390   typedef struct  GX_GVar_Head_
1391   {
1392     FT_Long    version;
1393     FT_UShort  axisCount;
1394     FT_UShort  globalCoordCount;
1395     FT_ULong   offsetToCoord;
1396     FT_UShort  glyphCount;
1397     FT_UShort  flags;
1398     FT_ULong   offsetToData;
1399 
1400   } GX_GVar_Head;
1401 
1402 
<span class="line-modified">1403   /*************************************************************************/</span>
<span class="line-modified">1404   /*                                                                       */</span>
<span class="line-modified">1405   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1406   /*    ft_var_load_gvar                                                   */</span>
<span class="line-modified">1407   /*                                                                       */</span>
<span class="line-modified">1408   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1409   /*    Parse the `gvar&#39; table if present.  If `fvar&#39; is there, `gvar&#39; had */</span>
<span class="line-modified">1410   /*    better be there too.                                               */</span>
<span class="line-modified">1411   /*                                                                       */</span>
<span class="line-modified">1412   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1413   /*    face :: The font face.                                             */</span>
<span class="line-modified">1414   /*                                                                       */</span>
<span class="line-modified">1415   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1416   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1417   /*                                                                       */</span>

1418   static FT_Error
1419   ft_var_load_gvar( TT_Face  face )
1420   {
1421     FT_Stream     stream = FT_FACE_STREAM( face );
1422     FT_Memory     memory = stream-&gt;memory;
1423     GX_Blend      blend  = face-&gt;blend;
1424     FT_Error      error;
1425     FT_UInt       i, j;
1426     FT_ULong      table_len;
1427     FT_ULong      gvar_start;
1428     FT_ULong      offsetToData;
1429     GX_GVar_Head  gvar_head;
1430 
1431     static const FT_Frame_Field  gvar_fields[] =
1432     {
1433 
1434 #undef  FT_STRUCTURE
1435 #define FT_STRUCTURE  GX_GVar_Head
1436 
1437       FT_FRAME_START( 20 ),
</pre>
<hr />
<pre>
1495       goto Exit;
1496     }
1497 
1498     FT_TRACE2(( &quot;loaded\n&quot; ));
1499 
1500     blend-&gt;gvar_size   = table_len;
1501     blend-&gt;tuplecount  = gvar_head.globalCoordCount;
1502     blend-&gt;gv_glyphcnt = gvar_head.glyphCount;
1503     offsetToData       = gvar_start + gvar_head.offsetToData;
1504 
1505     FT_TRACE5(( &quot;gvar: there %s %d shared coordinate%s:\n&quot;,
1506                 blend-&gt;tuplecount == 1 ? &quot;is&quot; : &quot;are&quot;,
1507                 blend-&gt;tuplecount,
1508                 blend-&gt;tuplecount == 1 ? &quot;&quot; : &quot;s&quot; ));
1509 
1510     if ( FT_NEW_ARRAY( blend-&gt;glyphoffsets, blend-&gt;gv_glyphcnt + 1 ) )
1511       goto Exit;
1512 
1513     if ( gvar_head.flags &amp; 1 )
1514     {



1515       /* long offsets (one more offset than glyphs, to mark size of last) */
1516       if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 4L ) )
1517         goto Exit;
1518 
1519       for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )

1520         blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_ULONG();
<span class="line-modified">1521 </span>
<span class="line-modified">1522       FT_FRAME_EXIT();</span>








1523     }
1524     else
1525     {



1526       /* short offsets (one more offset than glyphs, to mark size of last) */
1527       if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 2L ) )
1528         goto Exit;
1529 
1530       for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )

1531         blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
<span class="line-modified">1532                                                /* XXX: Undocumented: `*2&#39;! */</span>
<span class="line-modified">1533 </span>
<span class="line-modified">1534       FT_FRAME_EXIT();</span>







1535     }
1536 




1537     if ( blend-&gt;tuplecount != 0 )
1538     {
1539       if ( FT_NEW_ARRAY( blend-&gt;tuplecoords,
1540                          gvar_head.axisCount * blend-&gt;tuplecount ) )
1541         goto Exit;
1542 
1543       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
1544            FT_FRAME_ENTER( blend-&gt;tuplecount * gvar_head.axisCount * 2L ) )
1545         goto Exit;
1546 
1547       for ( i = 0; i &lt; blend-&gt;tuplecount; i++ )
1548       {
1549         FT_TRACE5(( &quot;  [ &quot; ));
1550         for ( j = 0; j &lt; (FT_UInt)gvar_head.axisCount; j++ )
1551         {
1552           blend-&gt;tuplecoords[i * gvar_head.axisCount + j] =
<span class="line-modified">1553             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */</span>
1554           FT_TRACE5(( &quot;%.5f &quot;,
1555             blend-&gt;tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
1556         }
1557         FT_TRACE5(( &quot;]\n&quot; ));
1558       }
1559 
1560       FT_TRACE5(( &quot;\n&quot; ));
1561 
1562       FT_FRAME_EXIT();
1563     }
1564 
1565   Exit:
1566     return error;
1567   }
1568 
1569 
<span class="line-modified">1570   /*************************************************************************/</span>
<span class="line-modified">1571   /*                                                                       */</span>
<span class="line-modified">1572   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1573   /*    ft_var_apply_tuple                                                 */</span>
<span class="line-modified">1574   /*                                                                       */</span>
<span class="line-modified">1575   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1576   /*    Figure out whether a given tuple (design) applies to the current   */</span>
<span class="line-modified">1577   /*    blend, and if so, what is the scaling factor.                      */</span>
<span class="line-modified">1578   /*                                                                       */</span>
<span class="line-modified">1579   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1580   /*    blend           :: The current blend of the font.                  */</span>
<span class="line-modified">1581   /*                                                                       */</span>
<span class="line-modified">1582   /*    tupleIndex      :: A flag saying whether this is an intermediate   */</span>
<span class="line-modified">1583   /*                       tuple or not.                                   */</span>
<span class="line-modified">1584   /*                                                                       */</span>
<span class="line-modified">1585   /*    tuple_coords    :: The coordinates of the tuple in normalized axis */</span>
<span class="line-modified">1586   /*                       units.                                          */</span>
<span class="line-modified">1587   /*                                                                       */</span>
<span class="line-modified">1588   /*    im_start_coords :: The initial coordinates where this tuple starts */</span>
<span class="line-modified">1589   /*                       to apply (for intermediate coordinates).        */</span>
<span class="line-modified">1590   /*                                                                       */</span>
<span class="line-modified">1591   /*    im_end_coords   :: The final coordinates after which this tuple no */</span>
<span class="line-modified">1592   /*                       longer applies (for intermediate coordinates).  */</span>
<span class="line-modified">1593   /*                                                                       */</span>
<span class="line-modified">1594   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1595   /*    An FT_Fixed value containing the scaling factor.                   */</span>
<span class="line-modified">1596   /*                                                                       */</span>





1597   static FT_Fixed
1598   ft_var_apply_tuple( GX_Blend   blend,
1599                       FT_UShort  tupleIndex,
1600                       FT_Fixed*  tuple_coords,
1601                       FT_Fixed*  im_start_coords,
1602                       FT_Fixed*  im_end_coords )
1603   {
1604     FT_UInt   i;
1605     FT_Fixed  apply = 0x10000L;
1606 
1607 
1608     for ( i = 0; i &lt; blend-&gt;num_axis; i++ )
1609     {
<span class="line-modified">1610       FT_TRACE6(( &quot;    axis coordinate %d (%.5f):\n&quot;,</span>
1611                   i, blend-&gt;normalizedcoords[i] / 65536.0 ));
<span class="line-removed">1612       if ( !( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE ) )</span>
<span class="line-removed">1613         FT_TRACE6(( &quot;      intermediate coordinates %d (%.5f, %.5f):\n&quot;,</span>
<span class="line-removed">1614                     i,</span>
<span class="line-removed">1615                     im_start_coords[i] / 65536.0,</span>
<span class="line-removed">1616                     im_end_coords[i] / 65536.0 ));</span>
1617 
1618       /* It&#39;s not clear why (for intermediate tuples) we don&#39;t need     */
1619       /* to check against start/end -- the documentation says we don&#39;t. */
1620       /* Similarly, it&#39;s unclear why we don&#39;t need to scale along the   */
1621       /* axis.                                                          */
1622 
1623       if ( tuple_coords[i] == 0 )
1624       {
<span class="line-modified">1625         FT_TRACE6(( &quot;      tuple coordinate is zero, ignored\n&quot;, i ));</span>
1626         continue;
1627       }
1628 
1629       if ( blend-&gt;normalizedcoords[i] == 0 )
1630       {
1631         FT_TRACE6(( &quot;      axis coordinate is zero, stop\n&quot; ));
1632         apply = 0;
1633         break;
1634       }
1635 
1636       if ( blend-&gt;normalizedcoords[i] == tuple_coords[i] )
1637       {
<span class="line-modified">1638         FT_TRACE6(( &quot;      tuple coordinate value %.5f fits perfectly\n&quot;,</span>
1639                     tuple_coords[i] / 65536.0 ));
1640         /* `apply&#39; does not change */
1641         continue;
1642       }
1643 
1644       if ( !( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE ) )
1645       {
1646         /* not an intermediate tuple */
1647 
1648         if ( blend-&gt;normalizedcoords[i] &lt; FT_MIN( 0, tuple_coords[i] ) ||
1649              blend-&gt;normalizedcoords[i] &gt; FT_MAX( 0, tuple_coords[i] ) )
1650         {
<span class="line-modified">1651           FT_TRACE6(( &quot;      tuple coordinate value %.5f is exceeded, stop\n&quot;,</span>
1652                       tuple_coords[i] / 65536.0 ));
1653           apply = 0;
1654           break;
1655         }
1656 
<span class="line-modified">1657         FT_TRACE6(( &quot;      tuple coordinate value %.5f fits\n&quot;,</span>
1658                     tuple_coords[i] / 65536.0 ));
1659         apply = FT_MulDiv( apply,
1660                            blend-&gt;normalizedcoords[i],
1661                            tuple_coords[i] );
1662       }
1663       else
1664       {
1665         /* intermediate tuple */
1666 
<span class="line-modified">1667         if ( blend-&gt;normalizedcoords[i] &lt; im_start_coords[i] ||</span>
<span class="line-modified">1668              blend-&gt;normalizedcoords[i] &gt; im_end_coords[i]   )</span>
1669         {
<span class="line-modified">1670           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] is exceeded,&quot;</span>
1671                       &quot; stop\n&quot;,
1672                       im_start_coords[i] / 65536.0,
1673                       im_end_coords[i] / 65536.0 ));
1674           apply = 0;
1675           break;
1676         }
1677 
<span class="line-modified">1678         else if ( blend-&gt;normalizedcoords[i] &lt; tuple_coords[i] )</span>
<span class="line-modified">1679         {</span>
<span class="line-modified">1680           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] fits\n&quot;,</span>
<span class="line-modified">1681                       im_start_coords[i] / 65536.0,</span>
<span class="line-removed">1682                       im_end_coords[i] / 65536.0 ));</span>
1683           apply = FT_MulDiv( apply,
1684                              blend-&gt;normalizedcoords[i] - im_start_coords[i],
1685                              tuple_coords[i] - im_start_coords[i] );
<span class="line-removed">1686         }</span>
<span class="line-removed">1687 </span>
1688         else
<span class="line-removed">1689         {</span>
<span class="line-removed">1690           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] fits\n&quot;,</span>
<span class="line-removed">1691                       im_start_coords[i] / 65536.0,</span>
<span class="line-removed">1692                       im_end_coords[i] / 65536.0 ));</span>
1693           apply = FT_MulDiv( apply,
1694                              im_end_coords[i] - blend-&gt;normalizedcoords[i],
1695                              im_end_coords[i] - tuple_coords[i] );
<span class="line-removed">1696         }</span>
1697       }
1698     }
1699 
1700     FT_TRACE6(( &quot;    apply factor is %.5f\n&quot;, apply / 65536.0 ));
1701 
1702     return apply;
1703   }
1704 
1705 
1706   /* convert from design coordinates to normalized coordinates */
1707 
1708   static void
1709   ft_var_to_normalized( TT_Face    face,
1710                         FT_UInt    num_coords,
1711                         FT_Fixed*  coords,
1712                         FT_Fixed*  normalized )
1713   {
1714     GX_Blend        blend;
1715     FT_MM_Var*      mmvar;
1716     FT_UInt         i, j;
</pre>
<hr />
<pre>
1739       FT_Fixed  coord = coords[i];
1740 
1741 
1742       FT_TRACE5(( &quot;    %d: %.5f\n&quot;, i, coord / 65536.0 ));
1743       if ( coord &gt; a-&gt;maximum || coord &lt; a-&gt;minimum )
1744       {
1745         FT_TRACE1((
1746           &quot;ft_var_to_normalized: design coordinate %.5f\n&quot;
1747           &quot;                      is out of range [%.5f;%.5f]; clamping\n&quot;,
1748           coord / 65536.0,
1749           a-&gt;minimum / 65536.0,
1750           a-&gt;maximum / 65536.0 ));
1751 
1752         if ( coord &gt; a-&gt;maximum )
1753           coord = a-&gt;maximum;
1754         else
1755           coord = a-&gt;minimum;
1756       }
1757 
1758       if ( coord &lt; a-&gt;def )
<span class="line-modified">1759         normalized[i] = -FT_DivFix( coord - a-&gt;def,</span>
<span class="line-modified">1760                                     a-&gt;minimum - a-&gt;def );</span>
1761       else if ( coord &gt; a-&gt;def )
<span class="line-modified">1762         normalized[i] = FT_DivFix( coord - a-&gt;def,</span>
<span class="line-modified">1763                                    a-&gt;maximum - a-&gt;def );</span>
1764       else
1765         normalized[i] = 0;
1766     }
1767 
1768     FT_TRACE5(( &quot;\n&quot; ));
1769 
1770     for ( ; i &lt; mmvar-&gt;num_axis; i++ )
1771       normalized[i] = 0;
1772 
1773     if ( blend-&gt;avar_segment )
1774     {
1775       FT_TRACE5(( &quot;normalized design coordinates&quot;
1776                   &quot; before applying `avar&#39; data:\n&quot; ));
1777 
1778       av = blend-&gt;avar_segment;
1779       for ( i = 0; i &lt; mmvar-&gt;num_axis; i++, av++ )
1780       {
1781         for ( j = 1; j &lt; (FT_UInt)av-&gt;pairCount; j++ )
1782         {
1783           if ( normalized[i] &lt; av-&gt;correspondence[j].fromCoord )
</pre>
<hr />
<pre>
1893     FT_UShort  axisCount;
1894     FT_UShort  axisSize;
1895     FT_UShort  instanceCount;
1896     FT_UShort  instanceSize;
1897 
1898   } GX_FVar_Head;
1899 
1900 
1901   typedef struct  fvar_axis_
1902   {
1903     FT_ULong   axisTag;
1904     FT_Fixed   minValue;
1905     FT_Fixed   defaultValue;
1906     FT_Fixed   maxValue;
1907     FT_UShort  flags;
1908     FT_UShort  nameID;
1909 
1910   } GX_FVar_Axis;
1911 
1912 
<span class="line-modified">1913   /*************************************************************************/</span>
<span class="line-modified">1914   /*                                                                       */</span>
<span class="line-modified">1915   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1916   /*    TT_Get_MM_Var                                                      */</span>
<span class="line-modified">1917   /*                                                                       */</span>
<span class="line-modified">1918   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1919   /*    Check that the font&#39;s `fvar&#39; table is valid, parse it, and return  */</span>
<span class="line-modified">1920   /*    those data.  It also loads (and parses) the `MVAR&#39; table, if       */</span>
<span class="line-modified">1921   /*    possible.                                                          */</span>
<span class="line-modified">1922   /*                                                                       */</span>
<span class="line-modified">1923   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1924   /*    face   :: The font face.                                           */</span>
<span class="line-modified">1925   /*              TT_Get_MM_Var initializes the blend structure.           */</span>
<span class="line-modified">1926   /*                                                                       */</span>
<span class="line-modified">1927   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">1928   /*    master :: The `fvar&#39; data (must be freed by caller).  Can be NULL, */</span>
<span class="line-modified">1929   /*              which makes this function simply load MM support.        */</span>
<span class="line-modified">1930   /*                                                                       */</span>
<span class="line-modified">1931   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1932   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">1933   /*                                                                       */</span>


1934   FT_LOCAL_DEF( FT_Error )
1935   TT_Get_MM_Var( TT_Face      face,
1936                  FT_MM_Var*  *master )
1937   {
1938     FT_Stream            stream     = face-&gt;root.stream;
1939     FT_Memory            memory     = face-&gt;root.memory;
1940     FT_ULong             table_len;
1941     FT_Error             error      = FT_Err_Ok;
1942     FT_ULong             fvar_start = 0;
1943     FT_UInt              i, j;
1944     FT_MM_Var*           mmvar = NULL;
1945     FT_Fixed*            next_coords;
1946     FT_Fixed*            nsc;
1947     FT_String*           next_name;
1948     FT_Var_Axis*         a;
1949     FT_Fixed*            c;
1950     FT_Var_Named_Style*  ns;
1951     GX_FVar_Head         fvar_head;
1952     FT_Bool              usePsName  = 0;
1953     FT_UInt              num_instances;
</pre>
<hr />
<pre>
2490       FT_Bool    have_diff = 0;
2491       FT_UInt    j;
2492       FT_Fixed*  c;
2493       FT_Fixed*  n;
2494 
2495 
2496       manageCvt = mcvt_retain;
2497 
2498       for ( i = 0; i &lt; num_coords; i++ )
2499       {
2500         if ( blend-&gt;normalizedcoords[i] != coords[i] )
2501         {
2502           manageCvt = mcvt_load;
2503           have_diff = 1;
2504           break;
2505         }
2506       }
2507 
2508       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
2509       {
<span class="line-modified">2510         FT_UInt  idx = (FT_UInt)face-&gt;root.face_index &gt;&gt; 16;</span>
2511 
2512 
2513         c = blend-&gt;normalizedcoords + i;
<span class="line-modified">2514         n = blend-&gt;normalized_stylecoords + idx * mmvar-&gt;num_axis + i;</span>



2515         for ( j = i; j &lt; mmvar-&gt;num_axis; j++, n++, c++ )
2516           if ( *c != *n )
2517             have_diff = 1;
2518       }
2519       else
2520       {
2521         c = blend-&gt;normalizedcoords + i;
2522         for ( j = i; j &lt; mmvar-&gt;num_axis; j++, c++ )
2523           if ( *c != 0 )
2524             have_diff = 1;
2525       }
2526 
2527       /* return value -1 indicates `no change&#39; */
2528       if ( !have_diff )



2529         return -1;

2530 
2531       for ( ; i &lt; mmvar-&gt;num_axis; i++ )
2532       {
2533         if ( blend-&gt;normalizedcoords[i] != 0 )
2534         {
2535           manageCvt = mcvt_load;
2536           break;
2537         }
2538       }
2539 
2540       /* If we don&#39;t change the blend coords then we don&#39;t need to do  */
2541       /* anything to the cvt table.  It will be correct.  Otherwise we */
2542       /* no longer have the original cvt (it was modified when we set  */
2543       /* the blend last time), so we must reload and then modify it.   */
2544     }
2545 
2546     blend-&gt;num_axis = mmvar-&gt;num_axis;
2547     FT_MEM_COPY( blend-&gt;normalizedcoords,
2548                  coords,
2549                  num_coords * sizeof ( FT_Fixed ) );
</pre>
<hr />
<pre>
2573         /* The original cvt table is in memory.  All we need to do is */
2574         /* apply the `cvar&#39; table (if any).                           */
2575         error = tt_face_vary_cvt( face, face-&gt;root.stream );
2576         break;
2577 
2578       case mcvt_retain:
2579         /* The cvt table is correct for this set of coordinates. */
2580         break;
2581       }
2582     }
2583 
2584     /* enforce recomputation of the PostScript name; */
2585     FT_FREE( face-&gt;postscript_name );
2586     face-&gt;postscript_name = NULL;
2587 
2588   Exit:
2589     return error;
2590   }
2591 
2592 
<span class="line-modified">2593   /*************************************************************************/</span>
<span class="line-modified">2594   /*                                                                       */</span>
<span class="line-modified">2595   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2596   /*    TT_Set_MM_Blend                                                    */</span>
<span class="line-modified">2597   /*                                                                       */</span>
<span class="line-modified">2598   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2599   /*    Set the blend (normalized) coordinates for this instance of the    */</span>
<span class="line-modified">2600   /*    font.  Check that the `gvar&#39; table is reasonable and does some     */</span>
<span class="line-modified">2601   /*    initial preparation.                                               */</span>
<span class="line-modified">2602   /*                                                                       */</span>
<span class="line-modified">2603   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">2604   /*    face       :: The font.                                            */</span>
<span class="line-modified">2605   /*                  Initialize the blend structure with `gvar&#39; data.     */</span>
<span class="line-modified">2606   /*                                                                       */</span>
<span class="line-modified">2607   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2608   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">2609   /*                  larger than the number of axes, ignore the excess    */</span>
<span class="line-modified">2610   /*                  values.  If it is smaller than the number of axes,   */</span>
<span class="line-modified">2611   /*                  use the default value (0) for the remaining axes.    */</span>
<span class="line-modified">2612   /*                                                                       */</span>
<span class="line-modified">2613   /*    coords     :: An array of `num_coords&#39;, each between [-1,1].       */</span>
<span class="line-modified">2614   /*                                                                       */</span>
<span class="line-modified">2615   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2616   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2617   /*                                                                       */</span>



2618   FT_LOCAL_DEF( FT_Error )
2619   TT_Set_MM_Blend( TT_Face    face,
2620                    FT_UInt    num_coords,
2621                    FT_Fixed*  coords )
2622   {
2623     FT_Error  error;
2624 
2625 
2626     error = tt_set_mm_blend( face, num_coords, coords, 1 );
2627     if ( error )
2628       return error;
2629 
2630     if ( num_coords )
2631       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
2632     else
2633       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
2634 
2635     return FT_Err_Ok;
2636   }
2637 
2638 
<span class="line-modified">2639   /*************************************************************************/</span>
<span class="line-modified">2640   /*                                                                       */</span>
<span class="line-modified">2641   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2642   /*    TT_Get_MM_Blend                                                    */</span>
<span class="line-modified">2643   /*                                                                       */</span>
<span class="line-modified">2644   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2645   /*    Get the blend (normalized) coordinates for this instance of the    */</span>
<span class="line-modified">2646   /*    font.                                                              */</span>
<span class="line-modified">2647   /*                                                                       */</span>
<span class="line-modified">2648   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">2649   /*    face       :: The font.                                            */</span>
<span class="line-modified">2650   /*                  Initialize the blend structure with `gvar&#39; data.     */</span>
<span class="line-modified">2651   /*                                                                       */</span>
<span class="line-modified">2652   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2653   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">2654   /*                  larger than the number of axes, set the excess       */</span>
<span class="line-modified">2655   /*                  values to 0.                                         */</span>
<span class="line-modified">2656   /*                                                                       */</span>
<span class="line-modified">2657   /*    coords     :: An array of `num_coords&#39;, each between [-1,1].       */</span>
<span class="line-modified">2658   /*                                                                       */</span>
<span class="line-modified">2659   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2660   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2661   /*                                                                       */</span>



2662   FT_LOCAL_DEF( FT_Error )
2663   TT_Get_MM_Blend( TT_Face    face,
2664                    FT_UInt    num_coords,
2665                    FT_Fixed*  coords )
2666   {
2667     FT_Error  error = FT_Err_Ok;
2668     GX_Blend  blend;
2669     FT_UInt   i, nc;
2670 
2671 
2672     if ( !face-&gt;blend )
2673     {
2674       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
2675         return error;
2676     }
2677 
2678     blend = face-&gt;blend;
2679 
2680     if ( !blend-&gt;coords )
2681     {
</pre>
<hr />
<pre>
2695     }
2696 
2697     if ( face-&gt;doblend )
2698     {
2699       for ( i = 0; i &lt; nc; i++ )
2700         coords[i] = blend-&gt;normalizedcoords[i];
2701     }
2702     else
2703     {
2704       for ( i = 0; i &lt; nc; i++ )
2705         coords[i] = 0;
2706     }
2707 
2708     for ( ; i &lt; num_coords; i++ )
2709       coords[i] = 0;
2710 
2711     return FT_Err_Ok;
2712   }
2713 
2714 
<span class="line-modified">2715   /*************************************************************************/</span>
<span class="line-modified">2716   /*                                                                       */</span>
<span class="line-modified">2717   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2718   /*    TT_Set_Var_Design                                                  */</span>
<span class="line-modified">2719   /*                                                                       */</span>
<span class="line-modified">2720   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2721   /*    Set the coordinates for the instance, measured in the user         */</span>
<span class="line-modified">2722   /*    coordinate system.  Parse the `avar&#39; table (if present) to convert */</span>
<span class="line-modified">2723   /*    from user to normalized coordinates.                               */</span>
<span class="line-modified">2724   /*                                                                       */</span>
<span class="line-modified">2725   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">2726   /*    face       :: The font face.                                       */</span>
<span class="line-modified">2727   /*                  Initialize the blend struct with `gvar&#39; data.        */</span>
<span class="line-modified">2728   /*                                                                       */</span>
<span class="line-modified">2729   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2730   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">2731   /*                  larger than the number of axes, ignore the excess    */</span>
<span class="line-modified">2732   /*                  values.  If it is smaller than the number of axes,   */</span>
<span class="line-modified">2733   /*                  use the default values for the remaining axes.       */</span>
<span class="line-modified">2734   /*                                                                       */</span>
<span class="line-modified">2735   /*    coords     :: A coordinate array with `num_coords&#39; elements.       */</span>
<span class="line-modified">2736   /*                                                                       */</span>
<span class="line-modified">2737   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2738   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">2739   /*                                                                       */</span>



2740   FT_LOCAL_DEF( FT_Error )
2741   TT_Set_Var_Design( TT_Face    face,
2742                      FT_UInt    num_coords,
2743                      FT_Fixed*  coords )
2744   {
2745     FT_Error    error  = FT_Err_Ok;
2746     GX_Blend    blend;
2747     FT_MM_Var*  mmvar;
2748     FT_UInt     i;
2749     FT_Memory   memory = face-&gt;root.memory;
2750 
2751     FT_Fixed*  c;
2752     FT_Fixed*  n;
2753     FT_Fixed*  normalized = NULL;
2754 
2755     FT_Bool  have_diff = 0;
2756 
2757 
2758     if ( !face-&gt;blend )
2759     {
</pre>
<hr />
<pre>
2837 
2838     FT_TRACE5(( &quot;TT_Set_Var_Design:\n&quot;
2839                 &quot;  normalized design coordinates:\n&quot; ));
2840     ft_var_to_normalized( face, num_coords, blend-&gt;coords, normalized );
2841 
2842     error = tt_set_mm_blend( face, mmvar-&gt;num_axis, normalized, 0 );
2843     if ( error )
2844       goto Exit;
2845 
2846     if ( num_coords )
2847       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
2848     else
2849       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
2850 
2851   Exit:
2852     FT_FREE( normalized );
2853     return error;
2854   }
2855 
2856 
<span class="line-modified">2857   /*************************************************************************/</span>
<span class="line-modified">2858   /*                                                                       */</span>
<span class="line-modified">2859   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2860   /*    TT_Get_Var_Design                                                  */</span>
<span class="line-modified">2861   /*                                                                       */</span>
<span class="line-modified">2862   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2863   /*    Get the design coordinates of the currently selected interpolated  */</span>
<span class="line-modified">2864   /*    font.                                                              */</span>
<span class="line-modified">2865   /*                                                                       */</span>
<span class="line-modified">2866   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2867   /*    face       :: A handle to the source face.                         */</span>
<span class="line-modified">2868   /*                                                                       */</span>
<span class="line-modified">2869   /*    num_coords :: The number of design coordinates to retrieve.  If it */</span>
<span class="line-modified">2870   /*                  is larger than the number of axes, set the excess    */</span>
<span class="line-modified">2871   /*                  values to~0.                                         */</span>
<span class="line-modified">2872   /*                                                                       */</span>
<span class="line-modified">2873   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">2874   /*    coords     :: The design coordinates array.                        */</span>
<span class="line-modified">2875   /*                                                                       */</span>
<span class="line-modified">2876   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2877   /*    FreeType error code.  0~means success.                             */</span>
<span class="line-modified">2878   /*                                                                       */</span>



2879   FT_LOCAL_DEF( FT_Error )
2880   TT_Get_Var_Design( TT_Face    face,
2881                      FT_UInt    num_coords,
2882                      FT_Fixed*  coords )
2883   {
2884     FT_Error  error = FT_Err_Ok;
2885     GX_Blend  blend;
2886     FT_UInt   i, nc;
2887 
2888 
2889     if ( !face-&gt;blend )
2890     {
2891       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
2892         return error;
2893     }
2894 
2895     blend = face-&gt;blend;
2896 
2897     if ( !blend-&gt;coords )
2898     {
</pre>
<hr />
<pre>
2912     }
2913 
2914     if ( face-&gt;doblend )
2915     {
2916       for ( i = 0; i &lt; nc; i++ )
2917         coords[i] = blend-&gt;coords[i];
2918     }
2919     else
2920     {
2921       for ( i = 0; i &lt; nc; i++ )
2922         coords[i] = 0;
2923     }
2924 
2925     for ( ; i &lt; num_coords; i++ )
2926       coords[i] = 0;
2927 
2928     return FT_Err_Ok;
2929   }
2930 
2931 
<span class="line-modified">2932   /*************************************************************************/</span>
<span class="line-modified">2933   /*                                                                       */</span>
<span class="line-modified">2934   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2935   /*    TT_Set_Named_Instance                                              */</span>
<span class="line-modified">2936   /*                                                                       */</span>
<span class="line-modified">2937   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2938   /*    Set the given named instance, also resetting any further           */</span>
<span class="line-modified">2939   /*    variation.                                                         */</span>
<span class="line-modified">2940   /*                                                                       */</span>
<span class="line-modified">2941   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2942   /*    face           :: A handle to the source face.                     */</span>
<span class="line-modified">2943   /*                                                                       */</span>
<span class="line-modified">2944   /*    instance_index :: The instance index, starting with value 1.       */</span>
<span class="line-modified">2945   /*                      Value 0 indicates to not use an instance.        */</span>
<span class="line-modified">2946   /*                                                                       */</span>
<span class="line-modified">2947   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2948   /*    FreeType error code.  0~means success.                             */</span>
<span class="line-modified">2949   /*                                                                       */</span>


2950   FT_LOCAL_DEF( FT_Error )
2951   TT_Set_Named_Instance( TT_Face  face,
2952                          FT_UInt  instance_index )
2953   {
2954     FT_Error    error = FT_ERR( Invalid_Argument );
2955     GX_Blend    blend;
2956     FT_MM_Var*  mmvar;
2957 
2958     FT_UInt  num_instances;
2959 
2960 
2961     if ( !face-&gt;blend )
2962     {
2963       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
2964         goto Exit;
2965     }
2966 
2967     blend = face-&gt;blend;
2968     mmvar = blend-&gt;mmvar;
2969 
2970     num_instances = (FT_UInt)face-&gt;root.style_flags &gt;&gt; 16;
2971 
2972     /* `instance_index&#39; starts with value 1, thus `&gt;&#39; */
2973     if ( instance_index &gt; num_instances )
2974       goto Exit;
2975 
<span class="line-modified">2976     if ( instance_index &gt; 0 &amp;&amp; mmvar-&gt;namedstyle )</span>
2977     {
2978       FT_Memory     memory = face-&gt;root.memory;
2979       SFNT_Service  sfnt   = (SFNT_Service)face-&gt;sfnt;
2980 
2981       FT_Var_Named_Style*  named_style;
2982       FT_String*           style_name;
2983 
2984 
2985       named_style = mmvar-&gt;namedstyle + instance_index - 1;
2986 
2987       error = sfnt-&gt;get_name( face,
2988                               (FT_UShort)named_style-&gt;strid,
2989                               &amp;style_name );
2990       if ( error )
2991         goto Exit;
2992 
2993       /* set (or replace) style name */
2994       FT_FREE( face-&gt;root.style_name );
2995       face-&gt;root.style_name = style_name;
2996 
2997       /* finally, select the named instance */
2998       error = TT_Set_Var_Design( face,
2999                                  mmvar-&gt;num_axis,
3000                                  named_style-&gt;coords );
3001       if ( error )




3002         goto Exit;

3003     }
3004     else
3005       error = TT_Set_Var_Design( face, 0, NULL );
3006 
3007     face-&gt;root.face_index  = ( instance_index &lt;&lt; 16 )             |
3008                              ( face-&gt;root.face_index &amp; 0xFFFFL );
3009     face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
3010 
3011   Exit:
3012     return error;
3013   }
3014 
3015 
3016   /*************************************************************************/
3017   /*************************************************************************/
3018   /*****                                                               *****/
3019   /*****                     GX VAR PARSING ROUTINES                   *****/
3020   /*****                                                               *****/
3021   /*************************************************************************/
3022   /*************************************************************************/
3023 
3024 
<span class="line-modified">3025   /*************************************************************************/</span>
<span class="line-modified">3026   /*                                                                       */</span>
<span class="line-modified">3027   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">3028   /*    tt_face_vary_cvt                                                   */</span>
<span class="line-modified">3029   /*                                                                       */</span>
<span class="line-modified">3030   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">3031   /*    Modify the loaded cvt table according to the `cvar&#39; table and the  */</span>
<span class="line-modified">3032   /*    font&#39;s blend.                                                      */</span>
<span class="line-modified">3033   /*                                                                       */</span>
<span class="line-modified">3034   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">3035   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">3036   /*                                                                       */</span>
<span class="line-modified">3037   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">3038   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">3039   /*                                                                       */</span>
<span class="line-modified">3040   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">3041   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">3042   /*                                                                       */</span>
<span class="line-modified">3043   /*    Most errors are ignored.  It is perfectly valid not to have a      */</span>
<span class="line-modified">3044   /*    `cvar&#39; table even if there is a `gvar&#39; and `fvar&#39; table.           */</span>
<span class="line-modified">3045   /*                                                                       */</span>

















3046   FT_LOCAL_DEF( FT_Error )
3047   tt_face_vary_cvt( TT_Face    face,
3048                     FT_Stream  stream )
3049   {
<span class="line-modified">3050     FT_Error    error;</span>
<span class="line-modified">3051     FT_Memory   memory = stream-&gt;memory;</span>
<span class="line-modified">3052     FT_ULong    table_start;</span>
<span class="line-modified">3053     FT_ULong    table_len;</span>
<span class="line-modified">3054     FT_UInt     tupleCount;</span>
<span class="line-modified">3055     FT_ULong    offsetToData;</span>
<span class="line-modified">3056     FT_ULong    here;</span>
<span class="line-modified">3057     FT_UInt     i, j;</span>
<span class="line-modified">3058     FT_Fixed*   tuple_coords    = NULL;</span>
<span class="line-modified">3059     FT_Fixed*   im_start_coords = NULL;</span>
<span class="line-modified">3060     FT_Fixed*   im_end_coords   = NULL;</span>
<span class="line-modified">3061     GX_Blend    blend           = face-&gt;blend;</span>
<span class="line-modified">3062     FT_UInt     point_count, spoint_count = 0;</span>










3063     FT_UShort*  sharedpoints = NULL;
3064     FT_UShort*  localpoints  = NULL;
3065     FT_UShort*  points;
<span class="line-modified">3066     FT_Short*   deltas;</span>


3067 
3068 
3069     FT_TRACE2(( &quot;CVAR &quot; ));
3070 
3071     if ( !blend )
3072     {
3073       FT_TRACE2(( &quot;\n&quot;
3074                   &quot;tt_face_vary_cvt: no blend specified\n&quot; ));
3075       error = FT_Err_Ok;
3076       goto Exit;
3077     }
3078 
3079     if ( !face-&gt;cvt )
3080     {
3081       FT_TRACE2(( &quot;\n&quot;
3082                   &quot;tt_face_vary_cvt: no `cvt &#39; table\n&quot; ));
3083       error = FT_Err_Ok;
3084       goto Exit;
3085     }
3086 
</pre>
<hr />
<pre>
3129       goto FExit;
3130     }
3131 
3132     offsetToData += table_start;
3133 
3134     if ( tupleCount &amp; GX_TC_TUPLES_SHARE_POINT_NUMBERS )
3135     {
3136       here = FT_Stream_FTell( stream );
3137 
3138       FT_Stream_SeekSet( stream, offsetToData );
3139 
3140       sharedpoints = ft_var_readpackedpoints( stream,
3141                                               table_len,
3142                                               &amp;spoint_count );
3143       offsetToData = FT_Stream_FTell( stream );
3144 
3145       FT_Stream_SeekSet( stream, here );
3146     }
3147 
3148     FT_TRACE5(( &quot;cvar: there %s %d tuple%s:\n&quot;,
<span class="line-modified">3149                 ( tupleCount &amp; 0xFFF ) == 1 ? &quot;is&quot; : &quot;are&quot;,</span>
<span class="line-modified">3150                 tupleCount &amp; 0xFFF,</span>
<span class="line-modified">3151                 ( tupleCount &amp; 0xFFF ) == 1 ? &quot;&quot; : &quot;s&quot; ));</span>
3152 
<span class="line-modified">3153     for ( i = 0; i &lt; ( tupleCount &amp; 0xFFF ); i++ )</span>



3154     {
3155       FT_UInt   tupleDataSize;
3156       FT_UInt   tupleIndex;
3157       FT_Fixed  apply;
3158 
3159 
3160       FT_TRACE6(( &quot;  tuple %d:\n&quot;, i ));
3161 
3162       tupleDataSize = FT_GET_USHORT();
3163       tupleIndex    = FT_GET_USHORT();
3164 
3165       if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
3166       {
3167         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3168           tuple_coords[j] = FT_GET_SHORT() * 4;  /* convert from        */</span>
<span class="line-removed">3169                                                  /* short frac to fixed */</span>
3170       }
3171       else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
3172       {
3173         FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;
3174                     &quot; invalid tuple index\n&quot; ));
3175 
3176         error = FT_THROW( Invalid_Table );
<span class="line-modified">3177         goto Exit;</span>
3178       }
3179       else










3180         FT_MEM_COPY(
3181           tuple_coords,
<span class="line-modified">3182           &amp;blend-&gt;tuplecoords[( tupleIndex &amp; 0xFFF ) * blend-&gt;num_axis],</span>

3183           blend-&gt;num_axis * sizeof ( FT_Fixed ) );

3184 
3185       if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
3186       {
3187         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3188           im_start_coords[j] = FT_GET_SHORT() * 4;</span>
3189         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3190           im_end_coords[j] = FT_GET_SHORT() * 4;</span>
3191       }
3192 
3193       apply = ft_var_apply_tuple( blend,
3194                                   (FT_UShort)tupleIndex,
3195                                   tuple_coords,
3196                                   im_start_coords,
3197                                   im_end_coords );
3198 
3199       if ( apply == 0 )              /* tuple isn&#39;t active for our blend */
3200       {
3201         offsetToData += tupleDataSize;
3202         continue;
3203       }
3204 
3205       here = FT_Stream_FTell( stream );
3206 
3207       FT_Stream_SeekSet( stream, offsetToData );
3208 
3209       if ( tupleIndex &amp; GX_TI_PRIVATE_POINT_NUMBERS )
3210       {
</pre>
<hr />
<pre>
3224                                         point_count == 0 ? face-&gt;cvt_size
3225                                                          : point_count );
3226 
3227       if ( !points                                                        ||
3228            !deltas                                                        ||
3229            ( localpoints == ALL_POINTS &amp;&amp; point_count != face-&gt;cvt_size ) )
3230         ; /* failure, ignore it */
3231 
3232       else if ( localpoints == ALL_POINTS )
3233       {
3234 #ifdef FT_DEBUG_LEVEL_TRACE
3235         int  count = 0;
3236 #endif
3237 
3238 
3239         FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
3240 
3241         /* this means that there are deltas for every entry in cvt */
3242         for ( j = 0; j &lt; face-&gt;cvt_size; j++ )
3243         {
<span class="line-modified">3244           FT_Long  orig_cvt = face-&gt;cvt[j];</span>
3245 
3246 
<span class="line-modified">3247           face-&gt;cvt[j] = (FT_Short)( orig_cvt +</span>
<span class="line-modified">3248                                      FT_MulFix( deltas[j], apply ) );</span>
3249 
3250 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3251           if ( orig_cvt != face-&gt;cvt[j] )</span>
3252           {
<span class="line-modified">3253             FT_TRACE7(( &quot;      %d: %d -&gt; %d\n&quot;,</span>
<span class="line-modified">3254                         j, orig_cvt, face-&gt;cvt[j] ));</span>




3255             count++;
3256           }
3257 #endif
3258         }
3259 
3260 #ifdef FT_DEBUG_LEVEL_TRACE
3261         if ( !count )
3262           FT_TRACE7(( &quot;      none\n&quot; ));
3263 #endif
3264       }
3265 
3266       else
3267       {
3268 #ifdef FT_DEBUG_LEVEL_TRACE
3269         int  count = 0;
3270 #endif
3271 
3272 
3273         FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
3274 
3275         for ( j = 0; j &lt; point_count; j++ )
3276         {
<span class="line-modified">3277           int      pindex;</span>
<span class="line-modified">3278           FT_Long  orig_cvt;</span>
3279 
3280 
3281           pindex = points[j];
3282           if ( (FT_ULong)pindex &gt;= face-&gt;cvt_size )
3283             continue;
3284 
<span class="line-modified">3285           orig_cvt          = face-&gt;cvt[pindex];</span>
<span class="line-modified">3286           face-&gt;cvt[pindex] = (FT_Short)( orig_cvt +</span>
<span class="line-removed">3287                                           FT_MulFix( deltas[j], apply ) );</span>
3288 
3289 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3290           if ( orig_cvt != face-&gt;cvt[pindex] )</span>
3291           {
<span class="line-modified">3292             FT_TRACE7(( &quot;      %d: %d -&gt; %d\n&quot;,</span>
<span class="line-modified">3293                         pindex, orig_cvt, face-&gt;cvt[pindex] ));</span>




3294             count++;
3295           }
3296 #endif
3297         }
3298 
3299 #ifdef FT_DEBUG_LEVEL_TRACE
3300         if ( !count )
3301           FT_TRACE7(( &quot;      none\n&quot; ));
3302 #endif
3303       }
3304 
3305       if ( localpoints != ALL_POINTS )
3306         FT_FREE( localpoints );
3307       FT_FREE( deltas );
3308 
3309       offsetToData += tupleDataSize;
3310 
3311       FT_Stream_SeekSet( stream, here );
3312     }
3313 
3314     FT_TRACE5(( &quot;\n&quot; ));
3315 



3316   FExit:
3317     FT_FRAME_EXIT();
3318 
3319   Exit:
3320     if ( sharedpoints != ALL_POINTS )
3321       FT_FREE( sharedpoints );
3322     FT_FREE( tuple_coords );
3323     FT_FREE( im_start_coords );
3324     FT_FREE( im_end_coords );







3325 
3326     return error;
3327   }
3328 
3329 
3330   /* Shift the original coordinates of all points between indices `p1&#39; */
3331   /* and `p2&#39;, using the same difference as given by index `ref&#39;.      */
3332 
3333   /* modeled after `af_iup_shift&#39; */
3334 
3335   static void
3336   tt_delta_shift( int         p1,
3337                   int         p2,
3338                   int         ref,
3339                   FT_Vector*  in_points,
3340                   FT_Vector*  out_points )
3341   {
3342     int        p;
3343     FT_Vector  delta;
3344 
</pre>
<hr />
<pre>
3350       return;
3351 
3352     for ( p = p1; p &lt; ref; p++ )
3353     {
3354       out_points[p].x += delta.x;
3355       out_points[p].y += delta.y;
3356     }
3357 
3358     for ( p = ref + 1; p &lt;= p2; p++ )
3359     {
3360       out_points[p].x += delta.x;
3361       out_points[p].y += delta.y;
3362     }
3363   }
3364 
3365 
3366   /* Interpolate the original coordinates of all points with indices */
3367   /* between `p1&#39; and `p2&#39;, using `ref1&#39; and `ref2&#39; as the reference */
3368   /* point indices.                                                  */
3369 
<span class="line-modified">3370   /* modeled after `af_iup_interp&#39;, `_iup_worker_interpolate&#39;, and */</span>
<span class="line-modified">3371   /* `Ins_IUP&#39;                                                     */</span>
<span class="line-removed">3372 </span>
3373   static void
3374   tt_delta_interpolate( int         p1,
3375                         int         p2,
3376                         int         ref1,
3377                         int         ref2,
3378                         FT_Vector*  in_points,
3379                         FT_Vector*  out_points )
3380   {
3381     int  p, i;
3382 
3383     FT_Pos  out, in1, in2, out1, out2, d1, d2;
3384 
3385 
3386     if ( p1 &gt; p2 )
3387       return;
3388 
3389     /* handle both horizontal and vertical coordinates */
3390     for ( i = 0; i &lt;= 1; i++ )
3391     {
3392       /* shift array pointers so that we can access `foo.y&#39; as `foo.x&#39; */
</pre>
<hr />
<pre>
3511                                 cur_delta,
3512                                 first_delta,
3513                                 in_points,
3514                                 out_points );
3515 
3516           if ( first_delta &gt; 0 )
3517             tt_delta_interpolate( first_point,
3518                                   first_delta - 1,
3519                                   cur_delta,
3520                                   first_delta,
3521                                   in_points,
3522                                   out_points );
3523         }
3524       }
3525       contour++;
3526 
3527     } while ( contour &lt; outline-&gt;n_contours );
3528   }
3529 
3530 
<span class="line-modified">3531   /*************************************************************************/</span>
<span class="line-modified">3532   /*                                                                       */</span>
<span class="line-modified">3533   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">3534   /*    TT_Vary_Apply_Glyph_Deltas                                         */</span>
<span class="line-modified">3535   /*                                                                       */</span>
<span class="line-modified">3536   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">3537   /*    Apply the appropriate deltas to the current glyph.                 */</span>
<span class="line-modified">3538   /*                                                                       */</span>
<span class="line-modified">3539   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">3540   /*    face        :: A handle to the target face object.                 */</span>
<span class="line-modified">3541   /*                                                                       */</span>
<span class="line-modified">3542   /*    glyph_index :: The index of the glyph being modified.              */</span>
<span class="line-modified">3543   /*                                                                       */</span>
<span class="line-modified">3544   /*    n_points    :: The number of the points in the glyph, including    */</span>
<span class="line-modified">3545   /*                   phantom points.                                     */</span>
<span class="line-modified">3546   /*                                                                       */</span>
<span class="line-modified">3547   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">3548   /*    outline     :: The outline to change.                              */</span>
<span class="line-modified">3549   /*                                                                       */</span>
<span class="line-modified">3550   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">3551   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">3552   /*                                                                       */</span>









3553   FT_LOCAL_DEF( FT_Error )
3554   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
3555                               FT_UInt      glyph_index,
3556                               FT_Outline*  outline,

3557                               FT_UInt      n_points )
3558   {
<span class="line-modified">3559     FT_Stream   stream = face-&gt;root.stream;</span>
<span class="line-modified">3560     FT_Memory   memory = stream-&gt;memory;</span>
<span class="line-modified">3561     GX_Blend    blend  = face-&gt;blend;</span>
3562 
<span class="line-modified">3563     FT_Vector*  points_org = NULL;</span>
<span class="line-modified">3564     FT_Vector*  points_out = NULL;</span>
3565     FT_Bool*    has_delta  = NULL;
3566 
<span class="line-modified">3567     FT_Error    error;</span>
<span class="line-modified">3568     FT_ULong    glyph_start;</span>
<span class="line-modified">3569     FT_UInt     tupleCount;</span>
<span class="line-modified">3570     FT_ULong    offsetToData;</span>
<span class="line-modified">3571     FT_ULong    here;</span>
<span class="line-modified">3572     FT_UInt     i, j;</span>
<span class="line-modified">3573     FT_Fixed*   tuple_coords    = NULL;</span>
<span class="line-modified">3574     FT_Fixed*   im_start_coords = NULL;</span>
<span class="line-modified">3575     FT_Fixed*   im_end_coords   = NULL;</span>
<span class="line-modified">3576     FT_UInt     point_count, spoint_count = 0;</span>








3577     FT_UShort*  sharedpoints = NULL;
3578     FT_UShort*  localpoints  = NULL;
3579     FT_UShort*  points;
<span class="line-modified">3580     FT_Short    *deltas_x, *deltas_y;</span>




3581 
3582 
3583     if ( !face-&gt;doblend || !blend )
3584       return FT_THROW( Invalid_Argument );
3585 






3586     if ( glyph_index &gt;= blend-&gt;gv_glyphcnt      ||
3587          blend-&gt;glyphoffsets[glyph_index] ==
3588            blend-&gt;glyphoffsets[glyph_index + 1] )
3589     {
3590       FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3591                   &quot; no variation data for this glyph\n&quot; ));
3592       return FT_Err_Ok;
3593     }
3594 
3595     if ( FT_NEW_ARRAY( points_org, n_points ) ||
3596          FT_NEW_ARRAY( points_out, n_points ) ||
3597          FT_NEW_ARRAY( has_delta, n_points )  )
3598       goto Fail1;
3599 
<span class="line-modified">3600     if ( FT_STREAM_SEEK( blend-&gt;glyphoffsets[glyph_index] )   ||</span>
<span class="line-modified">3601          FT_FRAME_ENTER( blend-&gt;glyphoffsets[glyph_index + 1] -</span>
<span class="line-modified">3602                            blend-&gt;glyphoffsets[glyph_index] ) )</span>


3603       goto Fail1;
3604 
3605     glyph_start = FT_Stream_FTell( stream );
3606 
3607     /* each set of glyph variation data is formatted similarly to `cvar&#39; */
3608 
3609     if ( FT_NEW_ARRAY( tuple_coords, blend-&gt;num_axis )    ||
3610          FT_NEW_ARRAY( im_start_coords, blend-&gt;num_axis ) ||
3611          FT_NEW_ARRAY( im_end_coords, blend-&gt;num_axis )   )
3612       goto Fail2;
3613 
3614     tupleCount   = FT_GET_USHORT();
3615     offsetToData = FT_GET_USHORT();
3616 
3617     /* rough sanity test */
<span class="line-modified">3618     if ( offsetToData + ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) * 4 &gt;</span>
<span class="line-modified">3619            blend-&gt;gvar_size )</span>
3620     {
3621       FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3622                   &quot; invalid glyph variation array header\n&quot; ));
3623 
3624       error = FT_THROW( Invalid_Table );
3625       goto Fail2;
3626     }
3627 
3628     offsetToData += glyph_start;
3629 
3630     if ( tupleCount &amp; GX_TC_TUPLES_SHARE_POINT_NUMBERS )
3631     {
3632       here = FT_Stream_FTell( stream );
3633 
3634       FT_Stream_SeekSet( stream, offsetToData );
3635 
3636       sharedpoints = ft_var_readpackedpoints( stream,
3637                                               blend-&gt;gvar_size,
3638                                               &amp;spoint_count );
3639       offsetToData = FT_Stream_FTell( stream );
3640 
3641       FT_Stream_SeekSet( stream, here );
3642     }
3643 
3644     FT_TRACE5(( &quot;gvar: there %s %d tuple%s:\n&quot;,
3645                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,
3646                 tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,
3647                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));
3648 




3649     for ( j = 0; j &lt; n_points; j++ )
<span class="line-modified">3650       points_org[j] = outline-&gt;points[j];</span>



3651 
3652     for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )
3653     {
3654       FT_UInt   tupleDataSize;
3655       FT_UInt   tupleIndex;
3656       FT_Fixed  apply;
3657 
3658 
3659       FT_TRACE6(( &quot;  tuple %d:\n&quot;, i ));
3660 
3661       tupleDataSize = FT_GET_USHORT();
3662       tupleIndex    = FT_GET_USHORT();
3663 
3664       if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
3665       {
3666         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3667           tuple_coords[j] = FT_GET_SHORT() * 4;   /* convert from        */</span>
<span class="line-removed">3668                                                   /* short frac to fixed */</span>
3669       }
3670       else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
3671       {
3672         FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3673                     &quot; invalid tuple index\n&quot; ));
3674 
3675         error = FT_THROW( Invalid_Table );
<span class="line-modified">3676         goto Fail2;</span>
3677       }
3678       else
3679         FT_MEM_COPY(
3680           tuple_coords,
<span class="line-modified">3681           &amp;blend-&gt;tuplecoords[( tupleIndex &amp; 0xFFF ) * blend-&gt;num_axis],</span>

3682           blend-&gt;num_axis * sizeof ( FT_Fixed ) );
3683 
3684       if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
3685       {
3686         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3687           im_start_coords[j] = FT_GET_SHORT() * 4;</span>
3688         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3689           im_end_coords[j] = FT_GET_SHORT() * 4;</span>
3690       }
3691 
3692       apply = ft_var_apply_tuple( blend,
3693                                   (FT_UShort)tupleIndex,
3694                                   tuple_coords,
3695                                   im_start_coords,
3696                                   im_end_coords );
3697 
3698       if ( apply == 0 )              /* tuple isn&#39;t active for our blend */
3699       {
3700         offsetToData += tupleDataSize;
3701         continue;
3702       }
3703 
3704       here = FT_Stream_FTell( stream );
3705 
3706       FT_Stream_SeekSet( stream, offsetToData );
3707 
3708       if ( tupleIndex &amp; GX_TI_PRIVATE_POINT_NUMBERS )
3709       {
</pre>
<hr />
<pre>
3725       deltas_y = ft_var_readpackeddeltas( stream,
3726                                           blend-&gt;gvar_size,
3727                                           point_count == 0 ? n_points
3728                                                            : point_count );
3729 
3730       if ( !points || !deltas_y || !deltas_x )
3731         ; /* failure, ignore it */
3732 
3733       else if ( points == ALL_POINTS )
3734       {
3735 #ifdef FT_DEBUG_LEVEL_TRACE
3736         int  count = 0;
3737 #endif
3738 
3739 
3740         FT_TRACE7(( &quot;    point deltas:\n&quot; ));
3741 
3742         /* this means that there are deltas for every point in the glyph */
3743         for ( j = 0; j &lt; n_points; j++ )
3744         {
<span class="line-modified">3745           FT_Pos  delta_x = FT_MulFix( deltas_x[j], apply );</span>
<span class="line-modified">3746           FT_Pos  delta_y = FT_MulFix( deltas_y[j], apply );</span>



3747 
3748 
3749           if ( j &lt; n_points - 4 )
3750           {
<span class="line-modified">3751             outline-&gt;points[j].x += delta_x;</span>
<span class="line-modified">3752             outline-&gt;points[j].y += delta_y;</span>
3753           }
3754           else
3755           {
3756             /* To avoid double adjustment of advance width or height, */
3757             /* adjust phantom points only if there is no HVAR or VVAR */
3758             /* support, respectively.                                 */
3759             if ( j == ( n_points - 4 )        &amp;&amp;
3760                  !( face-&gt;variation_support &amp;
3761                     TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">3762               outline-&gt;points[j].x += delta_x;</span>
3763 
3764             else if ( j == ( n_points - 3 )          &amp;&amp;
3765                       !( face-&gt;variation_support   &amp;
3766                          TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">3767               outline-&gt;points[j].x += delta_x;</span>
3768 
3769             else if ( j == ( n_points - 2 )        &amp;&amp;
3770                       !( face-&gt;variation_support &amp;
3771                          TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">3772               outline-&gt;points[j].y += delta_y;</span>
3773 
3774             else if ( j == ( n_points - 1 )          &amp;&amp;
3775                       !( face-&gt;variation_support   &amp;
3776                          TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">3777               outline-&gt;points[j].y += delta_y;</span>
3778           }
3779 
3780 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3781           if ( delta_x || delta_y )</span>
3782           {
<span class="line-modified">3783             FT_TRACE7(( &quot;      %d: (%d, %d) -&gt; (%d, %d)\n&quot;,</span>
3784                         j,
<span class="line-modified">3785                         outline-&gt;points[j].x - delta_x,</span>
<span class="line-modified">3786                         outline-&gt;points[j].y - delta_y,</span>
<span class="line-modified">3787                         outline-&gt;points[j].x,</span>
<span class="line-modified">3788                         outline-&gt;points[j].y ));</span>




3789             count++;
3790           }
3791 #endif
3792         }
3793 
3794 #ifdef FT_DEBUG_LEVEL_TRACE
3795         if ( !count )
3796           FT_TRACE7(( &quot;      none\n&quot; ));
3797 #endif
3798       }
3799 
3800       else
3801       {
3802 #ifdef FT_DEBUG_LEVEL_TRACE
3803         int  count = 0;
3804 #endif
3805 
3806 
3807         /* we have to interpolate the missing deltas similar to the */
3808         /* IUP bytecode instruction                                 */
</pre>
<hr />
<pre>
3820           if ( idx &gt;= n_points )
3821             continue;
3822 
3823           has_delta[idx] = TRUE;
3824 
3825           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
3826           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
3827         }
3828 
3829         /* no need to handle phantom points here,      */
3830         /* since solitary points can&#39;t be interpolated */
3831         tt_interpolate_deltas( outline,
3832                                points_out,
3833                                points_org,
3834                                has_delta );
3835 
3836         FT_TRACE7(( &quot;    point deltas:\n&quot; ));
3837 
3838         for ( j = 0; j &lt; n_points; j++ )
3839         {
<span class="line-modified">3840           FT_Pos  delta_x = points_out[j].x - points_org[j].x;</span>
<span class="line-modified">3841           FT_Pos  delta_y = points_out[j].y - points_org[j].y;</span>



3842 
3843 
3844           if ( j &lt; n_points - 4 )
3845           {
<span class="line-modified">3846             outline-&gt;points[j].x += delta_x;</span>
<span class="line-modified">3847             outline-&gt;points[j].y += delta_y;</span>
3848           }
3849           else
3850           {
3851             /* To avoid double adjustment of advance width or height, */
3852             /* adjust phantom points only if there is no HVAR or VVAR */
3853             /* support, respectively.                                 */
3854             if ( j == ( n_points - 4 )        &amp;&amp;
3855                  !( face-&gt;variation_support &amp;
3856                     TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">3857               outline-&gt;points[j].x += delta_x;</span>
3858 
3859             else if ( j == ( n_points - 3 )          &amp;&amp;
3860                       !( face-&gt;variation_support   &amp;
3861                          TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">3862               outline-&gt;points[j].x += delta_x;</span>
3863 
3864             else if ( j == ( n_points - 2 )        &amp;&amp;
3865                       !( face-&gt;variation_support &amp;
3866                          TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">3867               outline-&gt;points[j].y += delta_y;</span>
3868 
3869             else if ( j == ( n_points - 1 )          &amp;&amp;
3870                       !( face-&gt;variation_support   &amp;
3871                          TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">3872               outline-&gt;points[j].y += delta_y;</span>
3873           }
3874 
3875 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3876           if ( delta_x || delta_y )</span>
3877           {
<span class="line-modified">3878             FT_TRACE7(( &quot;      %d: (%d, %d) -&gt; (%d, %d)\n&quot;,</span>
3879                         j,
<span class="line-modified">3880                         outline-&gt;points[j].x - delta_x,</span>
<span class="line-modified">3881                         outline-&gt;points[j].y - delta_y,</span>
<span class="line-modified">3882                         outline-&gt;points[j].x,</span>
<span class="line-modified">3883                         outline-&gt;points[j].y ));</span>




3884             count++;
3885           }
3886 #endif
3887         }
3888 
3889 #ifdef FT_DEBUG_LEVEL_TRACE
3890         if ( !count )
3891           FT_TRACE7(( &quot;      none\n&quot; ));
3892 #endif
3893       }
3894 
3895       if ( localpoints != ALL_POINTS )
3896         FT_FREE( localpoints );
3897       FT_FREE( deltas_x );
3898       FT_FREE( deltas_y );
3899 
3900       offsetToData += tupleDataSize;
3901 
3902       FT_Stream_SeekSet( stream, here );
3903     }
3904 
3905     FT_TRACE5(( &quot;\n&quot; ));
3906 













3907   Fail2:
3908     if ( sharedpoints != ALL_POINTS )
3909       FT_FREE( sharedpoints );
3910     FT_FREE( tuple_coords );
3911     FT_FREE( im_start_coords );
3912     FT_FREE( im_end_coords );
3913 
3914     FT_FRAME_EXIT();
3915 
3916   Fail1:
3917     FT_FREE( points_org );
3918     FT_FREE( points_out );
3919     FT_FREE( has_delta );
3920 
3921     return error;
3922   }
3923 
3924 
<span class="line-modified">3925   /*************************************************************************/</span>
<span class="line-modified">3926   /*                                                                       */</span>
<span class="line-modified">3927   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">3928   /*    tt_get_var_blend                                                   */</span>
<span class="line-modified">3929   /*                                                                       */</span>
<span class="line-modified">3930   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">3931   /*    An extended internal version of `TT_Get_MM_Blend&#39; that returns     */</span>
<span class="line-modified">3932   /*    pointers instead of copying data, without any initialization of    */</span>
<span class="line-modified">3933   /*    the MM machinery in case it isn&#39;t loaded yet.                      */</span>
<span class="line-modified">3934   /*                                                                       */</span>
3935   FT_LOCAL_DEF( FT_Error )
3936   tt_get_var_blend( TT_Face      face,
3937                     FT_UInt     *num_coords,
3938                     FT_Fixed*   *coords,
3939                     FT_Fixed*   *normalizedcoords,
3940                     FT_MM_Var*  *mm_var )
3941   {
3942     if ( face-&gt;blend )
3943     {
3944       if ( num_coords )
3945         *num_coords       = face-&gt;blend-&gt;num_axis;
3946       if ( coords )
3947         *coords           = face-&gt;blend-&gt;coords;
3948       if ( normalizedcoords )
3949         *normalizedcoords = face-&gt;blend-&gt;normalizedcoords;
3950       if ( mm_var )
3951         *mm_var           = face-&gt;blend-&gt;mmvar;
3952     }
3953     else
3954     {
</pre>
<hr />
<pre>
3976     {
3977       for ( i = 0; i &lt; itemStore-&gt;dataCount; i++ )
3978       {
3979         FT_FREE( itemStore-&gt;varData[i].regionIndices );
3980         FT_FREE( itemStore-&gt;varData[i].deltaSet );
3981       }
3982 
3983       FT_FREE( itemStore-&gt;varData );
3984     }
3985 
3986     if ( itemStore-&gt;varRegionList )
3987     {
3988       for ( i = 0; i &lt; itemStore-&gt;regionCount; i++ )
3989         FT_FREE( itemStore-&gt;varRegionList[i].axisList );
3990 
3991       FT_FREE( itemStore-&gt;varRegionList );
3992     }
3993   }
3994 
3995 
<span class="line-modified">3996   /*************************************************************************/</span>
<span class="line-modified">3997   /*                                                                       */</span>
<span class="line-modified">3998   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">3999   /*    tt_done_blend                                                      */</span>
<span class="line-modified">4000   /*                                                                       */</span>
<span class="line-modified">4001   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">4002   /*    Free the blend internal data structure.                            */</span>
<span class="line-modified">4003   /*                                                                       */</span>
4004   FT_LOCAL_DEF( void )
4005   tt_done_blend( TT_Face  face )
4006   {
4007     FT_Memory  memory = FT_FACE_MEMORY( face );
4008     GX_Blend   blend  = face-&gt;blend;
4009 
4010 
4011     if ( blend )
4012     {
4013       FT_UInt  i, num_axes;
4014 
4015 
4016       /* blend-&gt;num_axis might not be set up yet */
4017       num_axes = blend-&gt;mmvar-&gt;num_axis;
4018 
4019       FT_FREE( blend-&gt;coords );
4020       FT_FREE( blend-&gt;normalizedcoords );
4021       FT_FREE( blend-&gt;normalized_stylecoords );
4022       FT_FREE( blend-&gt;mmvar );
4023 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ttgxvar.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   TrueType GX Font Variation loader</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2004-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18 </span>
<span class="line-modified">  19   /**************************************************************************</span>
<span class="line-modified">  20    *</span>
<span class="line-modified">  21    * Apple documents the `fvar&#39;, `gvar&#39;, `cvar&#39;, and `avar&#39; tables at</span>
<span class="line-modified">  22    *</span>
<span class="line-modified">  23    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html</span>
<span class="line-modified">  24    *</span>
<span class="line-modified">  25    * The documentation for `gvar&#39; is not intelligible; `cvar&#39; refers you</span>
<span class="line-modified">  26    * to `gvar&#39; and is thus also incomprehensible.</span>
<span class="line-modified">  27    *</span>
<span class="line-modified">  28    * The documentation for `avar&#39; appears correct, but Apple has no fonts</span>
<span class="line-modified">  29    * with an `avar&#39; table, so it is hard to test.</span>
<span class="line-modified">  30    *</span>
<span class="line-modified">  31    * Many thanks to John Jenkins (at Apple) in figuring this out.</span>
<span class="line-modified">  32    *</span>
<span class="line-modified">  33    *</span>
<span class="line-modified">  34    * Apple&#39;s `kern&#39; table has some references to tuple indices, but as</span>
<span class="line-modified">  35    * there is no indication where these indices are defined, nor how to</span>
<span class="line-modified">  36    * interpolate the kerning values (different tuples have different</span>
<span class="line-modified">  37    * classes) this issue is ignored.</span>
<span class="line-modified">  38    *</span>
<span class="line-modified">  39    */</span>
  40 
  41 
  42 #include &lt;ft2build.h&gt;
  43 #include FT_INTERNAL_DEBUG_H
  44 #include FT_CONFIG_CONFIG_H
  45 #include FT_INTERNAL_STREAM_H
  46 #include FT_INTERNAL_SFNT_H
  47 #include FT_TRUETYPE_TAGS_H
  48 #include FT_TRUETYPE_IDS_H
  49 #include FT_MULTIPLE_MASTERS_H
  50 #include FT_LIST_H
  51 
  52 #include &quot;ttpload.h&quot;
  53 #include &quot;ttgxvar.h&quot;
  54 
  55 #include &quot;tterrors.h&quot;
  56 
  57 
  58 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  59 
  60 
  61 #define FT_Stream_FTell( stream )                         \
  62           (FT_ULong)( (stream)-&gt;cursor - (stream)-&gt;base )
  63 #define FT_Stream_SeekSet( stream, off )                               \
  64           (stream)-&gt;cursor =                                           \
  65             ( (off) &lt; (FT_ULong)( (stream)-&gt;limit - (stream)-&gt;base ) ) \
  66                         ? (stream)-&gt;base + (off)                       \
  67                         : (stream)-&gt;limit
  68 
  69 
<span class="line-modified">  70   /* some macros we need */</span>
<span class="line-modified">  71 #define FT_fdot14ToFixed( x )                  \</span>
<span class="line-modified">  72           ( (FT_Fixed)( (FT_ULong)(x) &lt;&lt; 2 ) )</span>
<span class="line-modified">  73 #define FT_intToFixed( i )                      \</span>
<span class="line-modified">  74           ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 16 ) )</span>
<span class="line-modified">  75 #define FT_fdot6ToFixed( i )                    \</span>
<span class="line-added">  76           ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 10 ) )</span>
<span class="line-added">  77 #define FT_fixedToInt( x )                          \</span>
<span class="line-added">  78           ( (FT_Short)( ( (x) + 0x8000U ) &gt;&gt; 16 ) )</span>
<span class="line-added">  79 #define FT_fixedToFdot6( x )                    \</span>
<span class="line-added">  80           ( (FT_Pos)( ( (x) + 0x200 ) &gt;&gt; 10 ) )</span>
<span class="line-added">  81 </span>
<span class="line-added">  82 </span>
<span class="line-added">  83   /**************************************************************************</span>
<span class="line-added">  84    *</span>
<span class="line-added">  85    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-added">  86    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-added">  87    * messages during execution.</span>
<span class="line-added">  88    */</span>
  89 #undef  FT_COMPONENT
<span class="line-modified">  90 #define FT_COMPONENT  ttgxvar</span>
  91 
  92 
  93   /*************************************************************************/
  94   /*************************************************************************/
  95   /*****                                                               *****/
  96   /*****                       Internal Routines                       *****/
  97   /*****                                                               *****/
  98   /*************************************************************************/
  99   /*************************************************************************/
 100 
 101 
<span class="line-modified"> 102   /**************************************************************************</span>
<span class="line-modified"> 103    *</span>
<span class="line-modified"> 104    * The macro ALL_POINTS is used in `ft_var_readpackedpoints&#39;.  It</span>
<span class="line-modified"> 105    * indicates that there is a delta for every point without needing to</span>
<span class="line-modified"> 106    * enumerate all of them.</span>
<span class="line-modified"> 107    */</span>
 108 
 109   /* ensure that value `0&#39; has the same width as a pointer */
 110 #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
 111 
 112 
 113 #define GX_PT_POINTS_ARE_WORDS      0x80U
 114 #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
 115 
 116 
<span class="line-modified"> 117   /**************************************************************************</span>
<span class="line-modified"> 118    *</span>
<span class="line-modified"> 119    * @Function:</span>
<span class="line-modified"> 120    *   ft_var_readpackedpoints</span>
<span class="line-modified"> 121    *</span>
<span class="line-modified"> 122    * @Description:</span>
<span class="line-modified"> 123    *   Read a set of points to which the following deltas will apply.</span>
<span class="line-modified"> 124    *   Points are packed with a run length encoding.</span>
<span class="line-modified"> 125    *</span>
<span class="line-modified"> 126    * @Input:</span>
<span class="line-modified"> 127    *   stream ::</span>
<span class="line-modified"> 128    *     The data stream.</span>
<span class="line-modified"> 129    *</span>
<span class="line-modified"> 130    *   size ::</span>
<span class="line-modified"> 131    *     The size of the table holding the data.</span>
<span class="line-modified"> 132    *</span>
<span class="line-modified"> 133    * @Output:</span>
<span class="line-modified"> 134    *   point_cnt ::</span>
<span class="line-modified"> 135    *     The number of points read.  A zero value means that</span>
<span class="line-modified"> 136    *     all points in the glyph will be affected, without</span>
<span class="line-modified"> 137    *     enumerating them individually.</span>
<span class="line-modified"> 138    *</span>
<span class="line-modified"> 139    * @Return:</span>
<span class="line-added"> 140    *   An array of FT_UShort containing the affected points or the</span>
<span class="line-added"> 141    *   special value ALL_POINTS.</span>
<span class="line-added"> 142    */</span>
 143   static FT_UShort*
 144   ft_var_readpackedpoints( FT_Stream  stream,
 145                            FT_ULong   size,
 146                            FT_UInt   *point_cnt )
 147   {
 148     FT_UShort *points = NULL;
 149     FT_UInt    n;
 150     FT_UInt    runcnt;
 151     FT_UInt    i, j;
 152     FT_UShort  first;
 153     FT_Memory  memory = stream-&gt;memory;
 154     FT_Error   error  = FT_Err_Ok;
 155 
 156     FT_UNUSED( error );
 157 
 158 
 159     *point_cnt = 0;
 160 
 161     n = FT_GET_BYTE();
 162     if ( n == 0 )
</pre>
<hr />
<pre>
 210 
 211         for ( j = 0; j &lt; runcnt; j++ )
 212         {
 213           first      += FT_GET_BYTE();
 214           points[i++] = first;
 215           if ( i &gt;= n )
 216             break;
 217         }
 218       }
 219     }
 220 
 221     return points;
 222   }
 223 
 224 
 225 #define GX_DT_DELTAS_ARE_ZERO       0x80U
 226 #define GX_DT_DELTAS_ARE_WORDS      0x40U
 227 #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
 228 
 229 
<span class="line-modified"> 230   /**************************************************************************</span>
<span class="line-modified"> 231    *</span>
<span class="line-modified"> 232    * @Function:</span>
<span class="line-modified"> 233    *   ft_var_readpackeddeltas</span>
<span class="line-modified"> 234    *</span>
<span class="line-modified"> 235    * @Description:</span>
<span class="line-modified"> 236    *   Read a set of deltas.  These are packed slightly differently than</span>
<span class="line-modified"> 237    *   points.  In particular there is no overall count.</span>
<span class="line-modified"> 238    *</span>
<span class="line-modified"> 239    * @Input:</span>
<span class="line-modified"> 240    *   stream ::</span>
<span class="line-modified"> 241    *     The data stream.</span>
<span class="line-modified"> 242    *</span>
<span class="line-modified"> 243    *   size ::</span>
<span class="line-modified"> 244    *     The size of the table holding the data.</span>
<span class="line-modified"> 245    *</span>
<span class="line-modified"> 246    *   delta_cnt ::</span>
<span class="line-modified"> 247    *     The number of deltas to be read.</span>
<span class="line-modified"> 248    *</span>
<span class="line-modified"> 249    * @Return:</span>
<span class="line-modified"> 250    *   An array of FT_Fixed containing the deltas for the affected</span>
<span class="line-modified"> 251    *   points.  (This only gets the deltas for one dimension.  It will</span>
<span class="line-modified"> 252    *   generally be called twice, once for x, once for y.  When used in</span>
<span class="line-added"> 253    *   cvt table, it will only be called once.)</span>
<span class="line-added"> 254    *</span>
<span class="line-added"> 255    *   We use FT_Fixed to avoid accumulation errors while summing up all</span>
<span class="line-added"> 256    *   deltas (the rounding to integer values happens as the very last</span>
<span class="line-added"> 257    *   step).</span>
<span class="line-added"> 258    */</span>
<span class="line-added"> 259   static FT_Fixed*</span>
 260   ft_var_readpackeddeltas( FT_Stream  stream,
 261                            FT_ULong   size,
 262                            FT_UInt    delta_cnt )
 263   {
<span class="line-modified"> 264     FT_Fixed  *deltas = NULL;</span>
 265     FT_UInt    runcnt, cnt;
 266     FT_UInt    i, j;
 267     FT_Memory  memory = stream-&gt;memory;
 268     FT_Error   error  = FT_Err_Ok;
 269 
 270     FT_UNUSED( error );
 271 
 272 
 273     if ( delta_cnt &gt; size )
 274     {
 275       FT_TRACE1(( &quot;ft_var_readpackeddeltas: number of points too large\n&quot; ));
 276       return NULL;
 277     }
 278 
 279     if ( FT_NEW_ARRAY( deltas, delta_cnt ) )
 280       return NULL;
 281 
 282     i = 0;
 283     while ( i &lt; delta_cnt )
 284     {
 285       runcnt = FT_GET_BYTE();
 286       cnt    = runcnt &amp; GX_DT_DELTA_RUN_COUNT_MASK;
 287 
 288       if ( runcnt &amp; GX_DT_DELTAS_ARE_ZERO )
 289       {
 290         /* `runcnt&#39; zeroes get added */
 291         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
 292           deltas[i++] = 0;
 293       }
 294       else if ( runcnt &amp; GX_DT_DELTAS_ARE_WORDS )
 295       {
 296         /* `runcnt&#39; shorts from the stack */
 297         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified"> 298           deltas[i++] = FT_intToFixed( FT_GET_SHORT() );</span>
 299       }
 300       else
 301       {
 302         /* `runcnt&#39; signed bytes from the stack */
 303         for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified"> 304           deltas[i++] = FT_intToFixed( FT_GET_CHAR() );</span>
 305       }
 306 
 307       if ( j &lt;= cnt )
 308       {
 309         /* bad format */
 310         FT_FREE( deltas );
 311         return NULL;
 312       }
 313     }
 314 
 315     return deltas;
 316   }
 317 
 318 
<span class="line-modified"> 319   /**************************************************************************</span>
<span class="line-modified"> 320    *</span>
<span class="line-modified"> 321    * @Function:</span>
<span class="line-modified"> 322    *   ft_var_load_avar</span>
<span class="line-modified"> 323    *</span>
<span class="line-modified"> 324    * @Description:</span>
<span class="line-modified"> 325    *   Parse the `avar&#39; table if present.  It need not be, so we return</span>
<span class="line-modified"> 326    *   nothing.</span>
<span class="line-modified"> 327    *</span>
<span class="line-modified"> 328    * @InOut:</span>
<span class="line-modified"> 329    *   face ::</span>
<span class="line-modified"> 330    *     The font face.</span>
<span class="line-added"> 331    */</span>
 332   static void
 333   ft_var_load_avar( TT_Face  face )
 334   {
 335     FT_Stream       stream = FT_FACE_STREAM( face );
 336     FT_Memory       memory = stream-&gt;memory;
 337     GX_Blend        blend  = face-&gt;blend;
 338     GX_AVarSegment  segment;
 339     FT_Error        error = FT_Err_Ok;
 340     FT_Long         version;
 341     FT_Long         axisCount;
 342     FT_Int          i, j;
 343     FT_ULong        table_len;
 344 
 345     FT_UNUSED( error );
 346 
 347 
 348     FT_TRACE2(( &quot;AVAR &quot; ));
 349 
 350     blend-&gt;avar_loaded = TRUE;
 351     error = face-&gt;goto_table( face, TTAG_avar, stream, &amp;table_len );
</pre>
<hr />
<pre>
 384     {
 385       FT_TRACE5(( &quot;  axis %d:\n&quot;, i ));
 386 
 387       segment-&gt;pairCount = FT_GET_USHORT();
 388       if ( (FT_ULong)segment-&gt;pairCount * 4 &gt; table_len                ||
 389            FT_NEW_ARRAY( segment-&gt;correspondence, segment-&gt;pairCount ) )
 390       {
 391         /* Failure.  Free everything we have done so far.  We must do */
 392         /* it right now since loading the `avar&#39; table is optional.   */
 393 
 394         for ( j = i - 1; j &gt;= 0; j-- )
 395           FT_FREE( blend-&gt;avar_segment[j].correspondence );
 396 
 397         FT_FREE( blend-&gt;avar_segment );
 398         blend-&gt;avar_segment = NULL;
 399         goto Exit;
 400       }
 401 
 402       for ( j = 0; j &lt; segment-&gt;pairCount; j++ )
 403       {
<span class="line-modified"> 404         segment-&gt;correspondence[j].fromCoord =</span>
<span class="line-modified"> 405           FT_fdot14ToFixed( FT_GET_SHORT() );</span>
<span class="line-modified"> 406         segment-&gt;correspondence[j].toCoord =</span>
<span class="line-added"> 407           FT_fdot14ToFixed( FT_GET_SHORT() );</span>
 408 
 409         FT_TRACE5(( &quot;    mapping %.5f to %.5f\n&quot;,
 410                     segment-&gt;correspondence[j].fromCoord / 65536.0,
 411                     segment-&gt;correspondence[j].toCoord / 65536.0 ));
 412       }
 413 
 414       FT_TRACE5(( &quot;\n&quot; ));
 415     }
 416 
 417   Exit:
 418     FT_FRAME_EXIT();
 419   }
 420 
 421 











 422   static FT_Error
 423   ft_var_load_item_variation_store( TT_Face          face,
 424                                     FT_ULong         offset,
 425                                     GX_ItemVarStore  itemStore )
 426   {
 427     FT_Stream  stream = FT_FACE_STREAM( face );
 428     FT_Memory  memory = stream-&gt;memory;
 429 
 430     FT_Error   error;
 431     FT_UShort  format;
 432     FT_ULong   region_offset;
 433     FT_UInt    i, j, k;
 434     FT_UInt    shortDeltaCount;
 435 
 436     GX_Blend        blend = face-&gt;blend;
 437     GX_ItemVarData  varData;
 438 
 439     FT_ULong*  dataOffsetArray = NULL;
 440 
 441 
</pre>
<hr />
<pre>
 699 
 700       innerIndex = mapData &amp; innerIndexMask;
 701 
 702       if ( innerIndex &gt;= itemStore-&gt;varData[outerIndex].itemCount )
 703       {
 704         FT_TRACE2(( &quot;innerIndex[%d] == %d out of range\n&quot;,
 705                     i,
 706                     innerIndex ));
 707         error = FT_THROW( Invalid_Table );
 708           goto Exit;
 709       }
 710 
 711       map-&gt;innerIndex[i] = innerIndex;
 712     }
 713 
 714   Exit:
 715     return error;
 716   }
 717 
 718 
<span class="line-modified"> 719   /**************************************************************************</span>
<span class="line-modified"> 720    *</span>
<span class="line-modified"> 721    * @Function:</span>
<span class="line-modified"> 722    *   ft_var_load_hvvar</span>
<span class="line-modified"> 723    *</span>
<span class="line-modified"> 724    * @Description:</span>
<span class="line-modified"> 725    *   If `vertical&#39; is zero, parse the `HVAR&#39; table and set</span>
<span class="line-modified"> 726    *   `blend-&gt;hvar_loaded&#39; to TRUE.  On success, `blend-&gt;hvar_checked&#39;</span>
<span class="line-modified"> 727    *   is set to TRUE.</span>
<span class="line-modified"> 728    *</span>
<span class="line-modified"> 729    *   If `vertical&#39; is not zero, parse the `VVAR&#39; table and set</span>
<span class="line-modified"> 730    *   `blend-&gt;vvar_loaded&#39; to TRUE.  On success, `blend-&gt;vvar_checked&#39;</span>
<span class="line-modified"> 731    *   is set to TRUE.</span>
<span class="line-modified"> 732    *</span>
<span class="line-modified"> 733    *   Some memory may remain allocated on error; it is always freed in</span>
<span class="line-modified"> 734    *   `tt_done_blend&#39;, however.</span>
<span class="line-modified"> 735    *</span>
<span class="line-modified"> 736    * @InOut:</span>
<span class="line-modified"> 737    *   face ::</span>
<span class="line-modified"> 738    *     The font face.</span>
<span class="line-modified"> 739    *</span>
<span class="line-modified"> 740    * @Return:</span>
<span class="line-modified"> 741    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 742    */</span>
 743   static FT_Error
 744   ft_var_load_hvvar( TT_Face  face,
 745                      FT_Bool  vertical )
 746   {
 747     FT_Stream  stream = FT_FACE_STREAM( face );
 748     FT_Memory  memory = stream-&gt;memory;
 749 
 750     GX_Blend  blend = face-&gt;blend;
 751 
 752     GX_HVVarTable  table;
 753 
 754     FT_Error   error;
 755     FT_UShort  majorVersion;
 756     FT_ULong   table_len;
 757     FT_ULong   table_offset;
 758     FT_ULong   store_offset;
 759     FT_ULong   widthMap_offset;
 760 
 761 
 762     if ( vertical )
</pre>
<hr />
<pre>
 870                          FT_UInt          innerIndex )
 871   {
 872     GX_ItemVarData  varData;
 873     FT_Short*       deltaSet;
 874 
 875     FT_UInt   master, j;
 876     FT_Fixed  netAdjustment = 0;     /* accumulated adjustment */
 877     FT_Fixed  scaledDelta;
 878     FT_Fixed  delta;
 879 
 880 
 881     /* See pseudo code from `Font Variations Overview&#39; */
 882     /* in the OpenType specification.                  */
 883 
 884     varData  = &amp;itemStore-&gt;varData[outerIndex];
 885     deltaSet = &amp;varData-&gt;deltaSet[varData-&gt;regionIdxCount * innerIndex];
 886 
 887     /* outer loop steps through master designs to be blended */
 888     for ( master = 0; master &lt; varData-&gt;regionIdxCount; master++ )
 889     {
<span class="line-modified"> 890       FT_Fixed  scalar      = 0x10000L;</span>
 891       FT_UInt   regionIndex = varData-&gt;regionIndices[master];
 892 
 893       GX_AxisCoords  axis = itemStore-&gt;varRegionList[regionIndex].axisList;
 894 
 895 
 896       /* inner loop steps through axes in this region */
 897       for ( j = 0; j &lt; itemStore-&gt;axisCount; j++, axis++ )
 898       {



 899         /* compute the scalar contribution of this axis; */
 900         /* ignore invalid ranges                         */
 901         if ( axis-&gt;startCoord &gt; axis-&gt;peakCoord ||
 902              axis-&gt;peakCoord &gt; axis-&gt;endCoord   )
<span class="line-modified"> 903           continue;</span>
 904 
 905         else if ( axis-&gt;startCoord &lt; 0 &amp;&amp;
 906                   axis-&gt;endCoord &gt; 0   &amp;&amp;
 907                   axis-&gt;peakCoord != 0 )
<span class="line-modified"> 908           continue;</span>
 909 
 910         /* peak of 0 means ignore this axis */
 911         else if ( axis-&gt;peakCoord == 0 )
<span class="line-modified"> 912           continue;</span>
 913 
<span class="line-modified"> 914         else if ( face-&gt;blend-&gt;normalizedcoords[j] == axis-&gt;peakCoord )</span>
<span class="line-modified"> 915           continue;</span>


 916 
<span class="line-modified"> 917         /* ignore this region if coords are out of range */</span>
<span class="line-modified"> 918         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt;= axis-&gt;startCoord ||</span>
<span class="line-added"> 919                   face-&gt;blend-&gt;normalizedcoords[j] &gt;= axis-&gt;endCoord   )</span>
 920         {
<span class="line-modified"> 921           scalar = 0;</span>
<span class="line-modified"> 922           break;</span>








 923         }
 924 
<span class="line-modified"> 925         /* cumulative product of all the axis scalars */</span>
<span class="line-modified"> 926         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;peakCoord )</span>
<span class="line-modified"> 927           scalar =</span>
<span class="line-added"> 928             FT_MulDiv( scalar,</span>
<span class="line-added"> 929                        face-&gt;blend-&gt;normalizedcoords[j] - axis-&gt;startCoord,</span>
<span class="line-added"> 930                        axis-&gt;peakCoord - axis-&gt;startCoord );</span>
<span class="line-added"> 931         else</span>
<span class="line-added"> 932           scalar =</span>
<span class="line-added"> 933             FT_MulDiv( scalar,</span>
<span class="line-added"> 934                        axis-&gt;endCoord - face-&gt;blend-&gt;normalizedcoords[j],</span>
<span class="line-added"> 935                        axis-&gt;endCoord - axis-&gt;peakCoord );</span>
 936       } /* per-axis loop */
 937 
 938       /* get the scaled delta for this region */
 939       delta       = FT_intToFixed( deltaSet[master] );
 940       scaledDelta = FT_MulFix( scalar, delta );
 941 
 942       /* accumulate the adjustments from each region */
 943       netAdjustment = netAdjustment + scaledDelta;
 944 
 945     } /* per-region loop */
 946 
 947     return FT_fixedToInt( netAdjustment );
 948   }
 949 
 950 
<span class="line-modified"> 951   /**************************************************************************</span>
<span class="line-modified"> 952    *</span>
<span class="line-modified"> 953    * @Function:</span>
<span class="line-modified"> 954    *   tt_hvadvance_adjust</span>
<span class="line-modified"> 955    *</span>
<span class="line-modified"> 956    * @Description:</span>
<span class="line-modified"> 957    *   Apply `HVAR&#39; advance width or `VVAR&#39; advance height adjustment of</span>
<span class="line-modified"> 958    *   a given glyph.</span>
<span class="line-modified"> 959    *</span>
<span class="line-modified"> 960    * @Input:</span>
<span class="line-modified"> 961    *   gindex ::</span>
<span class="line-modified"> 962    *     The glyph index.</span>
<span class="line-modified"> 963    *</span>
<span class="line-modified"> 964    *   vertical ::</span>
<span class="line-modified"> 965    *     If set, handle `VVAR&#39; table.</span>
<span class="line-modified"> 966    *</span>
<span class="line-modified"> 967    * @InOut:</span>
<span class="line-modified"> 968    *   face ::</span>
<span class="line-modified"> 969    *     The font face.</span>
<span class="line-added"> 970    *</span>
<span class="line-added"> 971    *   adelta ::</span>
<span class="line-added"> 972    *     Points to width or height value that gets modified.</span>
<span class="line-added"> 973    */</span>
 974   static FT_Error
 975   tt_hvadvance_adjust( TT_Face  face,
 976                        FT_UInt  gindex,
 977                        FT_Int  *avalue,
 978                        FT_Bool  vertical )
 979   {
 980     FT_Error  error = FT_Err_Ok;
 981     FT_UInt   innerIndex, outerIndex;
 982     FT_Int    delta;
 983 
 984     GX_HVVarTable  table;
 985 
 986 
 987     if ( !face-&gt;doblend || !face-&gt;blend )
 988       goto Exit;
 989 
 990     if ( vertical )
 991     {
 992       if ( !face-&gt;blend-&gt;vvar_loaded )
 993       {
</pre>
<hr />
<pre>
1149       GX_VALUE_CASE( STRS, os2.yStrikeoutSize );
1150       GX_VALUE_CASE( UNDO, postscript.underlinePosition );
1151       GX_VALUE_CASE( UNDS, postscript.underlineThickness );
1152       GX_VALUE_CASE( VASC, vertical.Ascender );
1153       GX_VALUE_CASE( VCOF, vertical.caret_Offset );
1154       GX_VALUE_CASE( VCRN, vertical.caret_Slope_Run );
1155       GX_VALUE_CASE( VCRS, vertical.caret_Slope_Rise );
1156       GX_VALUE_CASE( VDSC, vertical.Descender );
1157       GX_VALUE_CASE( VLGP, vertical.Line_Gap );
1158       GX_VALUE_CASE( XHGT, os2.sxHeight );
1159 
1160     default:
1161       /* ignore unknown tag */
1162       p = NULL;
1163     }
1164 
1165     return p;
1166   }
1167 
1168 
<span class="line-modified">1169   /**************************************************************************</span>
<span class="line-modified">1170    *</span>
<span class="line-modified">1171    * @Function:</span>
<span class="line-modified">1172    *   ft_var_load_mvar</span>
<span class="line-modified">1173    *</span>
<span class="line-modified">1174    * @Description:</span>
<span class="line-modified">1175    *   Parse the `MVAR&#39; table.</span>
<span class="line-modified">1176    *</span>
<span class="line-modified">1177    *   Some memory may remain allocated on error; it is always freed in</span>
<span class="line-modified">1178    *   `tt_done_blend&#39;, however.</span>
<span class="line-modified">1179    *</span>
<span class="line-modified">1180    * @InOut:</span>
<span class="line-modified">1181    *   face ::</span>
<span class="line-modified">1182    *     The font face.</span>
<span class="line-added">1183    */</span>
1184   static void
1185   ft_var_load_mvar( TT_Face  face )
1186   {
1187     FT_Stream  stream = FT_FACE_STREAM( face );
1188     FT_Memory  memory = stream-&gt;memory;
1189 
1190     GX_Blend         blend = face-&gt;blend;
1191     GX_ItemVarStore  itemStore;
1192     GX_Value         value, limit;
1193 
1194     FT_Error   error;
1195     FT_UShort  majorVersion;
1196     FT_ULong   table_len;
1197     FT_ULong   table_offset;
1198     FT_UShort  store_offset;
1199     FT_ULong   records_offset;
1200 
1201 
1202     FT_TRACE2(( &quot;MVAR &quot; ));
1203 
</pre>
<hr />
<pre>
1296 
1297     face-&gt;variation_support |= TT_FACE_FLAG_VAR_MVAR;
1298   }
1299 
1300 
1301   static FT_Error
1302   tt_size_reset_iterator( FT_ListNode  node,
1303                           void*        user )
1304   {
1305     TT_Size  size = (TT_Size)node-&gt;data;
1306 
1307     FT_UNUSED( user );
1308 
1309 
1310     tt_size_reset( size, 1 );
1311 
1312     return FT_Err_Ok;
1313   }
1314 
1315 
<span class="line-modified">1316   /**************************************************************************</span>
<span class="line-modified">1317    *</span>
<span class="line-modified">1318    * @Function:</span>
<span class="line-modified">1319    *   tt_apply_mvar</span>
<span class="line-modified">1320    *</span>
<span class="line-modified">1321    * @Description:</span>
<span class="line-modified">1322    *   Apply `MVAR&#39; table adjustments.</span>
<span class="line-modified">1323    *</span>
<span class="line-modified">1324    * @InOut:</span>
<span class="line-modified">1325    *   face ::</span>
<span class="line-modified">1326    *     The font face.</span>
<span class="line-added">1327    */</span>
1328   FT_LOCAL_DEF( void )
1329   tt_apply_mvar( TT_Face  face )
1330   {
1331     GX_Blend  blend = face-&gt;blend;
1332     GX_Value  value, limit;
<span class="line-added">1333     FT_Short  mvar_hasc_delta = 0;</span>
<span class="line-added">1334     FT_Short  mvar_hdsc_delta = 0;</span>
<span class="line-added">1335     FT_Short  mvar_hlgp_delta = 0;</span>
1336 
1337 
1338     if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_MVAR ) )
1339       return;
1340 
1341     value = blend-&gt;mvar_table-&gt;values;
1342     limit = value + blend-&gt;mvar_table-&gt;valueCount;
1343 
1344     for ( ; value &lt; limit; value++ )
1345     {
1346       FT_Short*  p = ft_var_get_value_pointer( face, value-&gt;tag );
1347       FT_Int     delta;
1348 
1349 
1350       delta = ft_var_get_item_delta( face,
1351                                      &amp;blend-&gt;mvar_table-&gt;itemStore,
1352                                      value-&gt;outerIndex,
1353                                      value-&gt;innerIndex );
1354 
1355       if ( p )
1356       {
1357         FT_TRACE5(( &quot;value %c%c%c%c (%d unit%s) adjusted by %d unit%s (MVAR)\n&quot;,
1358                     (FT_Char)( value-&gt;tag &gt;&gt; 24 ),
1359                     (FT_Char)( value-&gt;tag &gt;&gt; 16 ),
1360                     (FT_Char)( value-&gt;tag &gt;&gt; 8 ),
1361                     (FT_Char)( value-&gt;tag ),
1362                     value-&gt;unmodified,
1363                     value-&gt;unmodified == 1 ? &quot;&quot; : &quot;s&quot;,
1364                     delta,
1365                     delta == 1 ? &quot;&quot; : &quot;s&quot; ));
1366 
1367         /* since we handle both signed and unsigned values as FT_Short, */
1368         /* ensure proper overflow arithmetic                            */
1369         *p = (FT_Short)( value-&gt;unmodified + (FT_Short)delta );
<span class="line-added">1370 </span>
<span class="line-added">1371         /* Treat hasc, hdsc and hlgp specially, see below. */</span>
<span class="line-added">1372         if ( value-&gt;tag == MVAR_TAG_HASC )</span>
<span class="line-added">1373           mvar_hasc_delta = (FT_Short)delta;</span>
<span class="line-added">1374         else if ( value-&gt;tag == MVAR_TAG_HDSC )</span>
<span class="line-added">1375           mvar_hdsc_delta = (FT_Short)delta;</span>
<span class="line-added">1376         else if ( value-&gt;tag == MVAR_TAG_HLGP )</span>
<span class="line-added">1377           mvar_hlgp_delta = (FT_Short)delta;</span>
1378       }
1379     }
1380 
1381     /* adjust all derived values */
1382     {
1383       FT_Face  root = &amp;face-&gt;root;
1384 
<span class="line-modified">1385       /*</span>
<span class="line-modified">1386        * Apply the deltas of hasc, hdsc and hlgp to the FT_Face&#39;s ascender,</span>
<span class="line-modified">1387        * descender and height attributes, no matter how they were originally</span>
<span class="line-modified">1388        * computed.</span>
<span class="line-modified">1389        *</span>
<span class="line-modified">1390        * (Code that ignores those and accesses the font&#39;s metrics values</span>
<span class="line-modified">1391        * directly is already served by the delta application code above.)</span>
<span class="line-modified">1392        *</span>
<span class="line-modified">1393        * The MVAR table supports variations for both typo and win metrics.</span>
<span class="line-modified">1394        * According to Behdad Esfahbod, the thinking of the working group was</span>
<span class="line-modified">1395        * that no one uses win metrics anymore for setting line metrics (the</span>
<span class="line-modified">1396        * specification even calls these metrics &quot;horizontal clipping</span>
<span class="line-modified">1397        * ascent/descent&quot;, probably for their role on the Windows platform in</span>
<span class="line-modified">1398        * computing clipping boxes), and new fonts should use typo metrics, so</span>
<span class="line-modified">1399        * typo deltas should be applied to whatever sfnt_load_face decided the</span>
<span class="line-modified">1400        * line metrics should be.</span>
<span class="line-modified">1401        *</span>
<span class="line-modified">1402        * Before, the following led to different line metrics between default</span>
<span class="line-modified">1403        * outline and instances, visible when e.g. the default outlines were</span>
<span class="line-added">1404        * used as the regular face and instances for everything else:</span>
<span class="line-added">1405        *</span>
<span class="line-added">1406        * 1. sfnt_load_face applied the hhea metrics by default.</span>
<span class="line-added">1407        * 2. This code later applied the typo metrics by default, regardless of</span>
<span class="line-added">1408        *    whether they were actually changed or the font had the OS/2 table&#39;s</span>
<span class="line-added">1409        *    fsSelection&#39;s bit 7 (USE_TYPO_METRICS) set.</span>
<span class="line-added">1410        */</span>
<span class="line-added">1411       FT_Short  current_line_gap = root-&gt;height - root-&gt;ascender +</span>
<span class="line-added">1412                                    root-&gt;descender;</span>
<span class="line-added">1413 </span>
<span class="line-added">1414 </span>
<span class="line-added">1415       root-&gt;ascender  = root-&gt;ascender + mvar_hasc_delta;</span>
<span class="line-added">1416       root-&gt;descender = root-&gt;descender + mvar_hdsc_delta;</span>
<span class="line-added">1417       root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">1418                         current_line_gap + mvar_hlgp_delta;</span>
1419 
1420       root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1421                                   face-&gt;postscript.underlineThickness / 2;
1422       root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1423 
1424       /* iterate over all FT_Size objects and call `tt_size_reset&#39; */
1425       /* to propagate the metrics changes                          */
1426       FT_List_Iterate( &amp;root-&gt;sizes_list,
1427                        tt_size_reset_iterator,
1428                        NULL );
1429     }
1430   }
1431 
1432 
1433   typedef struct  GX_GVar_Head_
1434   {
1435     FT_Long    version;
1436     FT_UShort  axisCount;
1437     FT_UShort  globalCoordCount;
1438     FT_ULong   offsetToCoord;
1439     FT_UShort  glyphCount;
1440     FT_UShort  flags;
1441     FT_ULong   offsetToData;
1442 
1443   } GX_GVar_Head;
1444 
1445 
<span class="line-modified">1446   /**************************************************************************</span>
<span class="line-modified">1447    *</span>
<span class="line-modified">1448    * @Function:</span>
<span class="line-modified">1449    *   ft_var_load_gvar</span>
<span class="line-modified">1450    *</span>
<span class="line-modified">1451    * @Description:</span>
<span class="line-modified">1452    *   Parse the `gvar&#39; table if present.  If `fvar&#39; is there, `gvar&#39; had</span>
<span class="line-modified">1453    *   better be there too.</span>
<span class="line-modified">1454    *</span>
<span class="line-modified">1455    * @InOut:</span>
<span class="line-modified">1456    *   face ::</span>
<span class="line-modified">1457    *     The font face.</span>
<span class="line-modified">1458    *</span>
<span class="line-modified">1459    * @Return:</span>
<span class="line-modified">1460    *   FreeType error code.  0 means success.</span>
<span class="line-added">1461    */</span>
1462   static FT_Error
1463   ft_var_load_gvar( TT_Face  face )
1464   {
1465     FT_Stream     stream = FT_FACE_STREAM( face );
1466     FT_Memory     memory = stream-&gt;memory;
1467     GX_Blend      blend  = face-&gt;blend;
1468     FT_Error      error;
1469     FT_UInt       i, j;
1470     FT_ULong      table_len;
1471     FT_ULong      gvar_start;
1472     FT_ULong      offsetToData;
1473     GX_GVar_Head  gvar_head;
1474 
1475     static const FT_Frame_Field  gvar_fields[] =
1476     {
1477 
1478 #undef  FT_STRUCTURE
1479 #define FT_STRUCTURE  GX_GVar_Head
1480 
1481       FT_FRAME_START( 20 ),
</pre>
<hr />
<pre>
1539       goto Exit;
1540     }
1541 
1542     FT_TRACE2(( &quot;loaded\n&quot; ));
1543 
1544     blend-&gt;gvar_size   = table_len;
1545     blend-&gt;tuplecount  = gvar_head.globalCoordCount;
1546     blend-&gt;gv_glyphcnt = gvar_head.glyphCount;
1547     offsetToData       = gvar_start + gvar_head.offsetToData;
1548 
1549     FT_TRACE5(( &quot;gvar: there %s %d shared coordinate%s:\n&quot;,
1550                 blend-&gt;tuplecount == 1 ? &quot;is&quot; : &quot;are&quot;,
1551                 blend-&gt;tuplecount,
1552                 blend-&gt;tuplecount == 1 ? &quot;&quot; : &quot;s&quot; ));
1553 
1554     if ( FT_NEW_ARRAY( blend-&gt;glyphoffsets, blend-&gt;gv_glyphcnt + 1 ) )
1555       goto Exit;
1556 
1557     if ( gvar_head.flags &amp; 1 )
1558     {
<span class="line-added">1559       FT_ULong  limit = gvar_start + table_len;</span>
<span class="line-added">1560 </span>
<span class="line-added">1561 </span>
1562       /* long offsets (one more offset than glyphs, to mark size of last) */
1563       if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 4L ) )
1564         goto Exit;
1565 
1566       for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
<span class="line-added">1567       {</span>
1568         blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_ULONG();
<span class="line-modified">1569         /* use `&gt;&#39;, not `&gt;=&#39; */</span>
<span class="line-modified">1570         if ( blend-&gt;glyphoffsets[i] &gt; limit )</span>
<span class="line-added">1571         {</span>
<span class="line-added">1572           FT_TRACE2(( &quot;ft_var_load_gvar:&quot;</span>
<span class="line-added">1573                       &quot; invalid glyph variation data offset for index %d\n&quot;,</span>
<span class="line-added">1574                       i ));</span>
<span class="line-added">1575           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">1576           break;</span>
<span class="line-added">1577         }</span>
<span class="line-added">1578       }</span>
1579     }
1580     else
1581     {
<span class="line-added">1582       FT_ULong  limit = gvar_start + table_len;</span>
<span class="line-added">1583 </span>
<span class="line-added">1584 </span>
1585       /* short offsets (one more offset than glyphs, to mark size of last) */
1586       if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 2L ) )
1587         goto Exit;
1588 
1589       for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
<span class="line-added">1590       {</span>
1591         blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
<span class="line-modified">1592         /* use `&gt;&#39;, not `&gt;=&#39; */</span>
<span class="line-modified">1593         if ( blend-&gt;glyphoffsets[i] &gt; limit )</span>
<span class="line-modified">1594         {</span>
<span class="line-added">1595           FT_TRACE2(( &quot;ft_var_load_gvar:&quot;</span>
<span class="line-added">1596                       &quot; invalid glyph variation data offset for index %d\n&quot;,</span>
<span class="line-added">1597                       i ));</span>
<span class="line-added">1598           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">1599           break;</span>
<span class="line-added">1600         }</span>
<span class="line-added">1601       }</span>
1602     }
1603 
<span class="line-added">1604     FT_FRAME_EXIT();</span>
<span class="line-added">1605     if ( error )</span>
<span class="line-added">1606       goto Exit;</span>
<span class="line-added">1607 </span>
1608     if ( blend-&gt;tuplecount != 0 )
1609     {
1610       if ( FT_NEW_ARRAY( blend-&gt;tuplecoords,
1611                          gvar_head.axisCount * blend-&gt;tuplecount ) )
1612         goto Exit;
1613 
1614       if ( FT_STREAM_SEEK( gvar_start + gvar_head.offsetToCoord )         ||
1615            FT_FRAME_ENTER( blend-&gt;tuplecount * gvar_head.axisCount * 2L ) )
1616         goto Exit;
1617 
1618       for ( i = 0; i &lt; blend-&gt;tuplecount; i++ )
1619       {
1620         FT_TRACE5(( &quot;  [ &quot; ));
1621         for ( j = 0; j &lt; (FT_UInt)gvar_head.axisCount; j++ )
1622         {
1623           blend-&gt;tuplecoords[i * gvar_head.axisCount + j] =
<span class="line-modified">1624             FT_fdot14ToFixed( FT_GET_SHORT() );</span>
1625           FT_TRACE5(( &quot;%.5f &quot;,
1626             blend-&gt;tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
1627         }
1628         FT_TRACE5(( &quot;]\n&quot; ));
1629       }
1630 
1631       FT_TRACE5(( &quot;\n&quot; ));
1632 
1633       FT_FRAME_EXIT();
1634     }
1635 
1636   Exit:
1637     return error;
1638   }
1639 
1640 
<span class="line-modified">1641   /**************************************************************************</span>
<span class="line-modified">1642    *</span>
<span class="line-modified">1643    * @Function:</span>
<span class="line-modified">1644    *   ft_var_apply_tuple</span>
<span class="line-modified">1645    *</span>
<span class="line-modified">1646    * @Description:</span>
<span class="line-modified">1647    *   Figure out whether a given tuple (design) applies to the current</span>
<span class="line-modified">1648    *   blend, and if so, what is the scaling factor.</span>
<span class="line-modified">1649    *</span>
<span class="line-modified">1650    * @Input:</span>
<span class="line-modified">1651    *   blend ::</span>
<span class="line-modified">1652    *     The current blend of the font.</span>
<span class="line-modified">1653    *</span>
<span class="line-modified">1654    *   tupleIndex ::</span>
<span class="line-modified">1655    *     A flag saying whether this is an intermediate</span>
<span class="line-modified">1656    *     tuple or not.</span>
<span class="line-modified">1657    *</span>
<span class="line-modified">1658    *   tuple_coords ::</span>
<span class="line-modified">1659    *     The coordinates of the tuple in normalized axis</span>
<span class="line-modified">1660    *     units.</span>
<span class="line-modified">1661    *</span>
<span class="line-modified">1662    *   im_start_coords ::</span>
<span class="line-modified">1663    *     The initial coordinates where this tuple starts</span>
<span class="line-modified">1664    *     to apply (for intermediate coordinates).</span>
<span class="line-modified">1665    *</span>
<span class="line-modified">1666    *   im_end_coords ::</span>
<span class="line-modified">1667    *     The final coordinates after which this tuple no</span>
<span class="line-added">1668    *     longer applies (for intermediate coordinates).</span>
<span class="line-added">1669    *</span>
<span class="line-added">1670    * @Return:</span>
<span class="line-added">1671    *   An FT_Fixed value containing the scaling factor.</span>
<span class="line-added">1672    */</span>
1673   static FT_Fixed
1674   ft_var_apply_tuple( GX_Blend   blend,
1675                       FT_UShort  tupleIndex,
1676                       FT_Fixed*  tuple_coords,
1677                       FT_Fixed*  im_start_coords,
1678                       FT_Fixed*  im_end_coords )
1679   {
1680     FT_UInt   i;
1681     FT_Fixed  apply = 0x10000L;
1682 
1683 
1684     for ( i = 0; i &lt; blend-&gt;num_axis; i++ )
1685     {
<span class="line-modified">1686       FT_TRACE6(( &quot;    axis %d coordinate %.5f:\n&quot;,</span>
1687                   i, blend-&gt;normalizedcoords[i] / 65536.0 ));





1688 
1689       /* It&#39;s not clear why (for intermediate tuples) we don&#39;t need     */
1690       /* to check against start/end -- the documentation says we don&#39;t. */
1691       /* Similarly, it&#39;s unclear why we don&#39;t need to scale along the   */
1692       /* axis.                                                          */
1693 
1694       if ( tuple_coords[i] == 0 )
1695       {
<span class="line-modified">1696         FT_TRACE6(( &quot;      tuple coordinate is zero, ignore\n&quot;, i ));</span>
1697         continue;
1698       }
1699 
1700       if ( blend-&gt;normalizedcoords[i] == 0 )
1701       {
1702         FT_TRACE6(( &quot;      axis coordinate is zero, stop\n&quot; ));
1703         apply = 0;
1704         break;
1705       }
1706 
1707       if ( blend-&gt;normalizedcoords[i] == tuple_coords[i] )
1708       {
<span class="line-modified">1709         FT_TRACE6(( &quot;      tuple coordinate %.5f fits perfectly\n&quot;,</span>
1710                     tuple_coords[i] / 65536.0 ));
1711         /* `apply&#39; does not change */
1712         continue;
1713       }
1714 
1715       if ( !( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE ) )
1716       {
1717         /* not an intermediate tuple */
1718 
1719         if ( blend-&gt;normalizedcoords[i] &lt; FT_MIN( 0, tuple_coords[i] ) ||
1720              blend-&gt;normalizedcoords[i] &gt; FT_MAX( 0, tuple_coords[i] ) )
1721         {
<span class="line-modified">1722           FT_TRACE6(( &quot;      tuple coordinate %.5f is exceeded, stop\n&quot;,</span>
1723                       tuple_coords[i] / 65536.0 ));
1724           apply = 0;
1725           break;
1726         }
1727 
<span class="line-modified">1728         FT_TRACE6(( &quot;      tuple coordinate %.5f fits\n&quot;,</span>
1729                     tuple_coords[i] / 65536.0 ));
1730         apply = FT_MulDiv( apply,
1731                            blend-&gt;normalizedcoords[i],
1732                            tuple_coords[i] );
1733       }
1734       else
1735       {
1736         /* intermediate tuple */
1737 
<span class="line-modified">1738         if ( blend-&gt;normalizedcoords[i] &lt;= im_start_coords[i] ||</span>
<span class="line-modified">1739              blend-&gt;normalizedcoords[i] &gt;= im_end_coords[i]   )</span>
1740         {
<span class="line-modified">1741           FT_TRACE6(( &quot;      intermediate tuple range ]%.5f;%.5f[ is exceeded,&quot;</span>
1742                       &quot; stop\n&quot;,
1743                       im_start_coords[i] / 65536.0,
1744                       im_end_coords[i] / 65536.0 ));
1745           apply = 0;
1746           break;
1747         }
1748 
<span class="line-modified">1749         FT_TRACE6(( &quot;      intermediate tuple range ]%.5f;%.5f[ fits\n&quot;,</span>
<span class="line-modified">1750                     im_start_coords[i] / 65536.0,</span>
<span class="line-modified">1751                     im_end_coords[i] / 65536.0 ));</span>
<span class="line-modified">1752         if ( blend-&gt;normalizedcoords[i] &lt; tuple_coords[i] )</span>

1753           apply = FT_MulDiv( apply,
1754                              blend-&gt;normalizedcoords[i] - im_start_coords[i],
1755                              tuple_coords[i] - im_start_coords[i] );


1756         else




1757           apply = FT_MulDiv( apply,
1758                              im_end_coords[i] - blend-&gt;normalizedcoords[i],
1759                              im_end_coords[i] - tuple_coords[i] );

1760       }
1761     }
1762 
1763     FT_TRACE6(( &quot;    apply factor is %.5f\n&quot;, apply / 65536.0 ));
1764 
1765     return apply;
1766   }
1767 
1768 
1769   /* convert from design coordinates to normalized coordinates */
1770 
1771   static void
1772   ft_var_to_normalized( TT_Face    face,
1773                         FT_UInt    num_coords,
1774                         FT_Fixed*  coords,
1775                         FT_Fixed*  normalized )
1776   {
1777     GX_Blend        blend;
1778     FT_MM_Var*      mmvar;
1779     FT_UInt         i, j;
</pre>
<hr />
<pre>
1802       FT_Fixed  coord = coords[i];
1803 
1804 
1805       FT_TRACE5(( &quot;    %d: %.5f\n&quot;, i, coord / 65536.0 ));
1806       if ( coord &gt; a-&gt;maximum || coord &lt; a-&gt;minimum )
1807       {
1808         FT_TRACE1((
1809           &quot;ft_var_to_normalized: design coordinate %.5f\n&quot;
1810           &quot;                      is out of range [%.5f;%.5f]; clamping\n&quot;,
1811           coord / 65536.0,
1812           a-&gt;minimum / 65536.0,
1813           a-&gt;maximum / 65536.0 ));
1814 
1815         if ( coord &gt; a-&gt;maximum )
1816           coord = a-&gt;maximum;
1817         else
1818           coord = a-&gt;minimum;
1819       }
1820 
1821       if ( coord &lt; a-&gt;def )
<span class="line-modified">1822         normalized[i] = -FT_DivFix( SUB_LONG( coord, a-&gt;def ),</span>
<span class="line-modified">1823                                     SUB_LONG( a-&gt;minimum, a-&gt;def ) );</span>
1824       else if ( coord &gt; a-&gt;def )
<span class="line-modified">1825         normalized[i] = FT_DivFix( SUB_LONG( coord, a-&gt;def ),</span>
<span class="line-modified">1826                                    SUB_LONG( a-&gt;maximum, a-&gt;def ) );</span>
1827       else
1828         normalized[i] = 0;
1829     }
1830 
1831     FT_TRACE5(( &quot;\n&quot; ));
1832 
1833     for ( ; i &lt; mmvar-&gt;num_axis; i++ )
1834       normalized[i] = 0;
1835 
1836     if ( blend-&gt;avar_segment )
1837     {
1838       FT_TRACE5(( &quot;normalized design coordinates&quot;
1839                   &quot; before applying `avar&#39; data:\n&quot; ));
1840 
1841       av = blend-&gt;avar_segment;
1842       for ( i = 0; i &lt; mmvar-&gt;num_axis; i++, av++ )
1843       {
1844         for ( j = 1; j &lt; (FT_UInt)av-&gt;pairCount; j++ )
1845         {
1846           if ( normalized[i] &lt; av-&gt;correspondence[j].fromCoord )
</pre>
<hr />
<pre>
1956     FT_UShort  axisCount;
1957     FT_UShort  axisSize;
1958     FT_UShort  instanceCount;
1959     FT_UShort  instanceSize;
1960 
1961   } GX_FVar_Head;
1962 
1963 
1964   typedef struct  fvar_axis_
1965   {
1966     FT_ULong   axisTag;
1967     FT_Fixed   minValue;
1968     FT_Fixed   defaultValue;
1969     FT_Fixed   maxValue;
1970     FT_UShort  flags;
1971     FT_UShort  nameID;
1972 
1973   } GX_FVar_Axis;
1974 
1975 
<span class="line-modified">1976   /**************************************************************************</span>
<span class="line-modified">1977    *</span>
<span class="line-modified">1978    * @Function:</span>
<span class="line-modified">1979    *   TT_Get_MM_Var</span>
<span class="line-modified">1980    *</span>
<span class="line-modified">1981    * @Description:</span>
<span class="line-modified">1982    *   Check that the font&#39;s `fvar&#39; table is valid, parse it, and return</span>
<span class="line-modified">1983    *   those data.  It also loads (and parses) the `MVAR&#39; table, if</span>
<span class="line-modified">1984    *   possible.</span>
<span class="line-modified">1985    *</span>
<span class="line-modified">1986    * @InOut:</span>
<span class="line-modified">1987    *   face ::</span>
<span class="line-modified">1988    *     The font face.</span>
<span class="line-modified">1989    *     TT_Get_MM_Var initializes the blend structure.</span>
<span class="line-modified">1990    *</span>
<span class="line-modified">1991    * @Output:</span>
<span class="line-modified">1992    *   master ::</span>
<span class="line-modified">1993    *     The `fvar&#39; data (must be freed by caller).  Can be NULL,</span>
<span class="line-modified">1994    *     which makes this function simply load MM support.</span>
<span class="line-modified">1995    *</span>
<span class="line-modified">1996    * @Return:</span>
<span class="line-added">1997    *   FreeType error code.  0 means success.</span>
<span class="line-added">1998    */</span>
1999   FT_LOCAL_DEF( FT_Error )
2000   TT_Get_MM_Var( TT_Face      face,
2001                  FT_MM_Var*  *master )
2002   {
2003     FT_Stream            stream     = face-&gt;root.stream;
2004     FT_Memory            memory     = face-&gt;root.memory;
2005     FT_ULong             table_len;
2006     FT_Error             error      = FT_Err_Ok;
2007     FT_ULong             fvar_start = 0;
2008     FT_UInt              i, j;
2009     FT_MM_Var*           mmvar = NULL;
2010     FT_Fixed*            next_coords;
2011     FT_Fixed*            nsc;
2012     FT_String*           next_name;
2013     FT_Var_Axis*         a;
2014     FT_Fixed*            c;
2015     FT_Var_Named_Style*  ns;
2016     GX_FVar_Head         fvar_head;
2017     FT_Bool              usePsName  = 0;
2018     FT_UInt              num_instances;
</pre>
<hr />
<pre>
2555       FT_Bool    have_diff = 0;
2556       FT_UInt    j;
2557       FT_Fixed*  c;
2558       FT_Fixed*  n;
2559 
2560 
2561       manageCvt = mcvt_retain;
2562 
2563       for ( i = 0; i &lt; num_coords; i++ )
2564       {
2565         if ( blend-&gt;normalizedcoords[i] != coords[i] )
2566         {
2567           manageCvt = mcvt_load;
2568           have_diff = 1;
2569           break;
2570         }
2571       }
2572 
2573       if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
2574       {
<span class="line-modified">2575         FT_UInt  instance_index = (FT_UInt)face-&gt;root.face_index &gt;&gt; 16;</span>
2576 
2577 
2578         c = blend-&gt;normalizedcoords + i;
<span class="line-modified">2579         n = blend-&gt;normalized_stylecoords            +</span>
<span class="line-added">2580             ( instance_index - 1 ) * mmvar-&gt;num_axis +</span>
<span class="line-added">2581             i;</span>
<span class="line-added">2582 </span>
2583         for ( j = i; j &lt; mmvar-&gt;num_axis; j++, n++, c++ )
2584           if ( *c != *n )
2585             have_diff = 1;
2586       }
2587       else
2588       {
2589         c = blend-&gt;normalizedcoords + i;
2590         for ( j = i; j &lt; mmvar-&gt;num_axis; j++, c++ )
2591           if ( *c != 0 )
2592             have_diff = 1;
2593       }
2594 
2595       /* return value -1 indicates `no change&#39; */
2596       if ( !have_diff )
<span class="line-added">2597       {</span>
<span class="line-added">2598         face-&gt;doblend = TRUE;</span>
<span class="line-added">2599 </span>
2600         return -1;
<span class="line-added">2601       }</span>
2602 
2603       for ( ; i &lt; mmvar-&gt;num_axis; i++ )
2604       {
2605         if ( blend-&gt;normalizedcoords[i] != 0 )
2606         {
2607           manageCvt = mcvt_load;
2608           break;
2609         }
2610       }
2611 
2612       /* If we don&#39;t change the blend coords then we don&#39;t need to do  */
2613       /* anything to the cvt table.  It will be correct.  Otherwise we */
2614       /* no longer have the original cvt (it was modified when we set  */
2615       /* the blend last time), so we must reload and then modify it.   */
2616     }
2617 
2618     blend-&gt;num_axis = mmvar-&gt;num_axis;
2619     FT_MEM_COPY( blend-&gt;normalizedcoords,
2620                  coords,
2621                  num_coords * sizeof ( FT_Fixed ) );
</pre>
<hr />
<pre>
2645         /* The original cvt table is in memory.  All we need to do is */
2646         /* apply the `cvar&#39; table (if any).                           */
2647         error = tt_face_vary_cvt( face, face-&gt;root.stream );
2648         break;
2649 
2650       case mcvt_retain:
2651         /* The cvt table is correct for this set of coordinates. */
2652         break;
2653       }
2654     }
2655 
2656     /* enforce recomputation of the PostScript name; */
2657     FT_FREE( face-&gt;postscript_name );
2658     face-&gt;postscript_name = NULL;
2659 
2660   Exit:
2661     return error;
2662   }
2663 
2664 
<span class="line-modified">2665   /**************************************************************************</span>
<span class="line-modified">2666    *</span>
<span class="line-modified">2667    * @Function:</span>
<span class="line-modified">2668    *   TT_Set_MM_Blend</span>
<span class="line-modified">2669    *</span>
<span class="line-modified">2670    * @Description:</span>
<span class="line-modified">2671    *   Set the blend (normalized) coordinates for this instance of the</span>
<span class="line-modified">2672    *   font.  Check that the `gvar&#39; table is reasonable and does some</span>
<span class="line-modified">2673    *   initial preparation.</span>
<span class="line-modified">2674    *</span>
<span class="line-modified">2675    * @InOut:</span>
<span class="line-modified">2676    *   face ::</span>
<span class="line-modified">2677    *     The font.</span>
<span class="line-modified">2678    *     Initialize the blend structure with `gvar&#39; data.</span>
<span class="line-modified">2679    *</span>
<span class="line-modified">2680    * @Input:</span>
<span class="line-modified">2681    *   num_coords ::</span>
<span class="line-modified">2682    *     The number of available coordinates.  If it is</span>
<span class="line-modified">2683    *     larger than the number of axes, ignore the excess</span>
<span class="line-modified">2684    *     values.  If it is smaller than the number of axes,</span>
<span class="line-modified">2685    *     use the default value (0) for the remaining axes.</span>
<span class="line-modified">2686    *</span>
<span class="line-modified">2687    *   coords ::</span>
<span class="line-modified">2688    *     An array of `num_coords&#39;, each between [-1,1].</span>
<span class="line-modified">2689    *</span>
<span class="line-added">2690    * @Return:</span>
<span class="line-added">2691    *   FreeType error code.  0 means success.</span>
<span class="line-added">2692    */</span>
2693   FT_LOCAL_DEF( FT_Error )
2694   TT_Set_MM_Blend( TT_Face    face,
2695                    FT_UInt    num_coords,
2696                    FT_Fixed*  coords )
2697   {
2698     FT_Error  error;
2699 
2700 
2701     error = tt_set_mm_blend( face, num_coords, coords, 1 );
2702     if ( error )
2703       return error;
2704 
2705     if ( num_coords )
2706       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
2707     else
2708       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
2709 
2710     return FT_Err_Ok;
2711   }
2712 
2713 
<span class="line-modified">2714   /**************************************************************************</span>
<span class="line-modified">2715    *</span>
<span class="line-modified">2716    * @Function:</span>
<span class="line-modified">2717    *   TT_Get_MM_Blend</span>
<span class="line-modified">2718    *</span>
<span class="line-modified">2719    * @Description:</span>
<span class="line-modified">2720    *   Get the blend (normalized) coordinates for this instance of the</span>
<span class="line-modified">2721    *   font.</span>
<span class="line-modified">2722    *</span>
<span class="line-modified">2723    * @InOut:</span>
<span class="line-modified">2724    *   face ::</span>
<span class="line-modified">2725    *     The font.</span>
<span class="line-modified">2726    *     Initialize the blend structure with `gvar&#39; data.</span>
<span class="line-modified">2727    *</span>
<span class="line-modified">2728    * @Input:</span>
<span class="line-modified">2729    *   num_coords ::</span>
<span class="line-modified">2730    *     The number of available coordinates.  If it is</span>
<span class="line-modified">2731    *     larger than the number of axes, set the excess</span>
<span class="line-modified">2732    *     values to 0.</span>
<span class="line-modified">2733    *</span>
<span class="line-modified">2734    *   coords ::</span>
<span class="line-modified">2735    *     An array of `num_coords&#39;, each between [-1,1].</span>
<span class="line-modified">2736    *</span>
<span class="line-added">2737    * @Return:</span>
<span class="line-added">2738    *   FreeType error code.  0 means success.</span>
<span class="line-added">2739    */</span>
2740   FT_LOCAL_DEF( FT_Error )
2741   TT_Get_MM_Blend( TT_Face    face,
2742                    FT_UInt    num_coords,
2743                    FT_Fixed*  coords )
2744   {
2745     FT_Error  error = FT_Err_Ok;
2746     GX_Blend  blend;
2747     FT_UInt   i, nc;
2748 
2749 
2750     if ( !face-&gt;blend )
2751     {
2752       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
2753         return error;
2754     }
2755 
2756     blend = face-&gt;blend;
2757 
2758     if ( !blend-&gt;coords )
2759     {
</pre>
<hr />
<pre>
2773     }
2774 
2775     if ( face-&gt;doblend )
2776     {
2777       for ( i = 0; i &lt; nc; i++ )
2778         coords[i] = blend-&gt;normalizedcoords[i];
2779     }
2780     else
2781     {
2782       for ( i = 0; i &lt; nc; i++ )
2783         coords[i] = 0;
2784     }
2785 
2786     for ( ; i &lt; num_coords; i++ )
2787       coords[i] = 0;
2788 
2789     return FT_Err_Ok;
2790   }
2791 
2792 
<span class="line-modified">2793   /**************************************************************************</span>
<span class="line-modified">2794    *</span>
<span class="line-modified">2795    * @Function:</span>
<span class="line-modified">2796    *   TT_Set_Var_Design</span>
<span class="line-modified">2797    *</span>
<span class="line-modified">2798    * @Description:</span>
<span class="line-modified">2799    *   Set the coordinates for the instance, measured in the user</span>
<span class="line-modified">2800    *   coordinate system.  Parse the `avar&#39; table (if present) to convert</span>
<span class="line-modified">2801    *   from user to normalized coordinates.</span>
<span class="line-modified">2802    *</span>
<span class="line-modified">2803    * @InOut:</span>
<span class="line-modified">2804    *   face ::</span>
<span class="line-modified">2805    *     The font face.</span>
<span class="line-modified">2806    *     Initialize the blend struct with `gvar&#39; data.</span>
<span class="line-modified">2807    *</span>
<span class="line-modified">2808    * @Input:</span>
<span class="line-modified">2809    *   num_coords ::</span>
<span class="line-modified">2810    *     The number of available coordinates.  If it is</span>
<span class="line-modified">2811    *     larger than the number of axes, ignore the excess</span>
<span class="line-modified">2812    *     values.  If it is smaller than the number of axes,</span>
<span class="line-modified">2813    *     use the default values for the remaining axes.</span>
<span class="line-modified">2814    *</span>
<span class="line-modified">2815    *   coords ::</span>
<span class="line-modified">2816    *     A coordinate array with `num_coords&#39; elements.</span>
<span class="line-modified">2817    *</span>
<span class="line-added">2818    * @Return:</span>
<span class="line-added">2819    *   FreeType error code.  0 means success.</span>
<span class="line-added">2820    */</span>
2821   FT_LOCAL_DEF( FT_Error )
2822   TT_Set_Var_Design( TT_Face    face,
2823                      FT_UInt    num_coords,
2824                      FT_Fixed*  coords )
2825   {
2826     FT_Error    error  = FT_Err_Ok;
2827     GX_Blend    blend;
2828     FT_MM_Var*  mmvar;
2829     FT_UInt     i;
2830     FT_Memory   memory = face-&gt;root.memory;
2831 
2832     FT_Fixed*  c;
2833     FT_Fixed*  n;
2834     FT_Fixed*  normalized = NULL;
2835 
2836     FT_Bool  have_diff = 0;
2837 
2838 
2839     if ( !face-&gt;blend )
2840     {
</pre>
<hr />
<pre>
2918 
2919     FT_TRACE5(( &quot;TT_Set_Var_Design:\n&quot;
2920                 &quot;  normalized design coordinates:\n&quot; ));
2921     ft_var_to_normalized( face, num_coords, blend-&gt;coords, normalized );
2922 
2923     error = tt_set_mm_blend( face, mmvar-&gt;num_axis, normalized, 0 );
2924     if ( error )
2925       goto Exit;
2926 
2927     if ( num_coords )
2928       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
2929     else
2930       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
2931 
2932   Exit:
2933     FT_FREE( normalized );
2934     return error;
2935   }
2936 
2937 
<span class="line-modified">2938   /**************************************************************************</span>
<span class="line-modified">2939    *</span>
<span class="line-modified">2940    * @Function:</span>
<span class="line-modified">2941    *   TT_Get_Var_Design</span>
<span class="line-modified">2942    *</span>
<span class="line-modified">2943    * @Description:</span>
<span class="line-modified">2944    *   Get the design coordinates of the currently selected interpolated</span>
<span class="line-modified">2945    *   font.</span>
<span class="line-modified">2946    *</span>
<span class="line-modified">2947    * @Input:</span>
<span class="line-modified">2948    *   face ::</span>
<span class="line-modified">2949    *     A handle to the source face.</span>
<span class="line-modified">2950    *</span>
<span class="line-modified">2951    *   num_coords ::</span>
<span class="line-modified">2952    *     The number of design coordinates to retrieve.  If it</span>
<span class="line-modified">2953    *     is larger than the number of axes, set the excess</span>
<span class="line-modified">2954    *     values to~0.</span>
<span class="line-modified">2955    *</span>
<span class="line-modified">2956    * @Output:</span>
<span class="line-modified">2957    *   coords ::</span>
<span class="line-modified">2958    *     The design coordinates array.</span>
<span class="line-modified">2959    *</span>
<span class="line-added">2960    * @Return:</span>
<span class="line-added">2961    *   FreeType error code.  0~means success.</span>
<span class="line-added">2962    */</span>
2963   FT_LOCAL_DEF( FT_Error )
2964   TT_Get_Var_Design( TT_Face    face,
2965                      FT_UInt    num_coords,
2966                      FT_Fixed*  coords )
2967   {
2968     FT_Error  error = FT_Err_Ok;
2969     GX_Blend  blend;
2970     FT_UInt   i, nc;
2971 
2972 
2973     if ( !face-&gt;blend )
2974     {
2975       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
2976         return error;
2977     }
2978 
2979     blend = face-&gt;blend;
2980 
2981     if ( !blend-&gt;coords )
2982     {
</pre>
<hr />
<pre>
2996     }
2997 
2998     if ( face-&gt;doblend )
2999     {
3000       for ( i = 0; i &lt; nc; i++ )
3001         coords[i] = blend-&gt;coords[i];
3002     }
3003     else
3004     {
3005       for ( i = 0; i &lt; nc; i++ )
3006         coords[i] = 0;
3007     }
3008 
3009     for ( ; i &lt; num_coords; i++ )
3010       coords[i] = 0;
3011 
3012     return FT_Err_Ok;
3013   }
3014 
3015 
<span class="line-modified">3016   /**************************************************************************</span>
<span class="line-modified">3017    *</span>
<span class="line-modified">3018    * @Function:</span>
<span class="line-modified">3019    *   TT_Set_Named_Instance</span>
<span class="line-modified">3020    *</span>
<span class="line-modified">3021    * @Description:</span>
<span class="line-modified">3022    *   Set the given named instance, also resetting any further</span>
<span class="line-modified">3023    *   variation.</span>
<span class="line-modified">3024    *</span>
<span class="line-modified">3025    * @Input:</span>
<span class="line-modified">3026    *   face ::</span>
<span class="line-modified">3027    *     A handle to the source face.</span>
<span class="line-modified">3028    *</span>
<span class="line-modified">3029    *   instance_index ::</span>
<span class="line-modified">3030    *     The instance index, starting with value 1.</span>
<span class="line-modified">3031    *     Value 0 indicates to not use an instance.</span>
<span class="line-modified">3032    *</span>
<span class="line-modified">3033    * @Return:</span>
<span class="line-added">3034    *   FreeType error code.  0~means success.</span>
<span class="line-added">3035    */</span>
3036   FT_LOCAL_DEF( FT_Error )
3037   TT_Set_Named_Instance( TT_Face  face,
3038                          FT_UInt  instance_index )
3039   {
3040     FT_Error    error = FT_ERR( Invalid_Argument );
3041     GX_Blend    blend;
3042     FT_MM_Var*  mmvar;
3043 
3044     FT_UInt  num_instances;
3045 
3046 
3047     if ( !face-&gt;blend )
3048     {
3049       if ( FT_SET_ERROR( TT_Get_MM_Var( face, NULL ) ) )
3050         goto Exit;
3051     }
3052 
3053     blend = face-&gt;blend;
3054     mmvar = blend-&gt;mmvar;
3055 
3056     num_instances = (FT_UInt)face-&gt;root.style_flags &gt;&gt; 16;
3057 
3058     /* `instance_index&#39; starts with value 1, thus `&gt;&#39; */
3059     if ( instance_index &gt; num_instances )
3060       goto Exit;
3061 
<span class="line-modified">3062     if ( instance_index &gt; 0 )</span>
3063     {
3064       FT_Memory     memory = face-&gt;root.memory;
3065       SFNT_Service  sfnt   = (SFNT_Service)face-&gt;sfnt;
3066 
3067       FT_Var_Named_Style*  named_style;
3068       FT_String*           style_name;
3069 
3070 
3071       named_style = mmvar-&gt;namedstyle + instance_index - 1;
3072 
3073       error = sfnt-&gt;get_name( face,
3074                               (FT_UShort)named_style-&gt;strid,
3075                               &amp;style_name );
3076       if ( error )
3077         goto Exit;
3078 
3079       /* set (or replace) style name */
3080       FT_FREE( face-&gt;root.style_name );
3081       face-&gt;root.style_name = style_name;
3082 
3083       /* finally, select the named instance */
3084       error = TT_Set_Var_Design( face,
3085                                  mmvar-&gt;num_axis,
3086                                  named_style-&gt;coords );
3087       if ( error )
<span class="line-added">3088       {</span>
<span class="line-added">3089         /* internal error code -1 means `no change&#39; */</span>
<span class="line-added">3090         if ( error == -1 )</span>
<span class="line-added">3091           error = FT_Err_Ok;</span>
3092         goto Exit;
<span class="line-added">3093       }</span>
3094     }
3095     else
3096       error = TT_Set_Var_Design( face, 0, NULL );
3097 
3098     face-&gt;root.face_index  = ( instance_index &lt;&lt; 16 )             |
3099                              ( face-&gt;root.face_index &amp; 0xFFFFL );
3100     face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
3101 
3102   Exit:
3103     return error;
3104   }
3105 
3106 
3107   /*************************************************************************/
3108   /*************************************************************************/
3109   /*****                                                               *****/
3110   /*****                     GX VAR PARSING ROUTINES                   *****/
3111   /*****                                                               *****/
3112   /*************************************************************************/
3113   /*************************************************************************/
3114 
3115 
<span class="line-modified">3116   static FT_Error</span>
<span class="line-modified">3117   tt_cvt_ready_iterator( FT_ListNode  node,</span>
<span class="line-modified">3118                          void*        user )</span>
<span class="line-modified">3119   {</span>
<span class="line-modified">3120     TT_Size  size = (TT_Size)node-&gt;data;</span>
<span class="line-modified">3121 </span>
<span class="line-modified">3122     FT_UNUSED( user );</span>
<span class="line-modified">3123 </span>
<span class="line-modified">3124 </span>
<span class="line-modified">3125     size-&gt;cvt_ready = -1;</span>
<span class="line-modified">3126 </span>
<span class="line-modified">3127     return FT_Err_Ok;</span>
<span class="line-modified">3128   }</span>
<span class="line-modified">3129 </span>
<span class="line-modified">3130 </span>
<span class="line-modified">3131   /**************************************************************************</span>
<span class="line-modified">3132    *</span>
<span class="line-modified">3133    * @Function:</span>
<span class="line-modified">3134    *   tt_face_vary_cvt</span>
<span class="line-modified">3135    *</span>
<span class="line-modified">3136    * @Description:</span>
<span class="line-added">3137    *   Modify the loaded cvt table according to the `cvar&#39; table and the</span>
<span class="line-added">3138    *   font&#39;s blend.</span>
<span class="line-added">3139    *</span>
<span class="line-added">3140    * @InOut:</span>
<span class="line-added">3141    *   face ::</span>
<span class="line-added">3142    *     A handle to the target face object.</span>
<span class="line-added">3143    *</span>
<span class="line-added">3144    * @Input:</span>
<span class="line-added">3145    *   stream ::</span>
<span class="line-added">3146    *     A handle to the input stream.</span>
<span class="line-added">3147    *</span>
<span class="line-added">3148    * @Return:</span>
<span class="line-added">3149    *   FreeType error code.  0 means success.</span>
<span class="line-added">3150    *</span>
<span class="line-added">3151    *   Most errors are ignored.  It is perfectly valid not to have a</span>
<span class="line-added">3152    *   `cvar&#39; table even if there is a `gvar&#39; and `fvar&#39; table.</span>
<span class="line-added">3153    */</span>
3154   FT_LOCAL_DEF( FT_Error )
3155   tt_face_vary_cvt( TT_Face    face,
3156                     FT_Stream  stream )
3157   {
<span class="line-modified">3158     FT_Error   error;</span>
<span class="line-modified">3159     FT_Memory  memory = stream-&gt;memory;</span>
<span class="line-modified">3160 </span>
<span class="line-modified">3161     FT_Face  root = &amp;face-&gt;root;</span>
<span class="line-modified">3162 </span>
<span class="line-modified">3163     FT_ULong  table_start;</span>
<span class="line-modified">3164     FT_ULong  table_len;</span>
<span class="line-modified">3165 </span>
<span class="line-modified">3166     FT_UInt   tupleCount;</span>
<span class="line-modified">3167     FT_ULong  offsetToData;</span>
<span class="line-modified">3168 </span>
<span class="line-modified">3169     FT_ULong  here;</span>
<span class="line-modified">3170     FT_UInt   i, j;</span>
<span class="line-added">3171 </span>
<span class="line-added">3172     FT_Fixed*  tuple_coords    = NULL;</span>
<span class="line-added">3173     FT_Fixed*  im_start_coords = NULL;</span>
<span class="line-added">3174     FT_Fixed*  im_end_coords   = NULL;</span>
<span class="line-added">3175 </span>
<span class="line-added">3176     GX_Blend  blend = face-&gt;blend;</span>
<span class="line-added">3177 </span>
<span class="line-added">3178     FT_UInt  point_count;</span>
<span class="line-added">3179     FT_UInt  spoint_count = 0;</span>
<span class="line-added">3180 </span>
3181     FT_UShort*  sharedpoints = NULL;
3182     FT_UShort*  localpoints  = NULL;
3183     FT_UShort*  points;
<span class="line-modified">3184 </span>
<span class="line-added">3185     FT_Fixed*  deltas     = NULL;</span>
<span class="line-added">3186     FT_Fixed*  cvt_deltas = NULL;</span>
3187 
3188 
3189     FT_TRACE2(( &quot;CVAR &quot; ));
3190 
3191     if ( !blend )
3192     {
3193       FT_TRACE2(( &quot;\n&quot;
3194                   &quot;tt_face_vary_cvt: no blend specified\n&quot; ));
3195       error = FT_Err_Ok;
3196       goto Exit;
3197     }
3198 
3199     if ( !face-&gt;cvt )
3200     {
3201       FT_TRACE2(( &quot;\n&quot;
3202                   &quot;tt_face_vary_cvt: no `cvt &#39; table\n&quot; ));
3203       error = FT_Err_Ok;
3204       goto Exit;
3205     }
3206 
</pre>
<hr />
<pre>
3249       goto FExit;
3250     }
3251 
3252     offsetToData += table_start;
3253 
3254     if ( tupleCount &amp; GX_TC_TUPLES_SHARE_POINT_NUMBERS )
3255     {
3256       here = FT_Stream_FTell( stream );
3257 
3258       FT_Stream_SeekSet( stream, offsetToData );
3259 
3260       sharedpoints = ft_var_readpackedpoints( stream,
3261                                               table_len,
3262                                               &amp;spoint_count );
3263       offsetToData = FT_Stream_FTell( stream );
3264 
3265       FT_Stream_SeekSet( stream, here );
3266     }
3267 
3268     FT_TRACE5(( &quot;cvar: there %s %d tuple%s:\n&quot;,
<span class="line-modified">3269                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,</span>
<span class="line-modified">3270                 tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,</span>
<span class="line-modified">3271                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));</span>
3272 
<span class="line-modified">3273     if ( FT_NEW_ARRAY( cvt_deltas, face-&gt;cvt_size ) )</span>
<span class="line-added">3274       goto FExit;</span>
<span class="line-added">3275 </span>
<span class="line-added">3276     for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )</span>
3277     {
3278       FT_UInt   tupleDataSize;
3279       FT_UInt   tupleIndex;
3280       FT_Fixed  apply;
3281 
3282 
3283       FT_TRACE6(( &quot;  tuple %d:\n&quot;, i ));
3284 
3285       tupleDataSize = FT_GET_USHORT();
3286       tupleIndex    = FT_GET_USHORT();
3287 
3288       if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
3289       {
3290         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3291           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>

3292       }
3293       else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
3294       {
3295         FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;
3296                     &quot; invalid tuple index\n&quot; ));
3297 
3298         error = FT_THROW( Invalid_Table );
<span class="line-modified">3299         goto FExit;</span>
3300       }
3301       else
<span class="line-added">3302       {</span>
<span class="line-added">3303         if ( !blend-&gt;tuplecoords )</span>
<span class="line-added">3304         {</span>
<span class="line-added">3305           FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;</span>
<span class="line-added">3306                       &quot; no valid tuple coordinates available\n&quot; ));</span>
<span class="line-added">3307 </span>
<span class="line-added">3308           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">3309           goto FExit;</span>
<span class="line-added">3310         }</span>
<span class="line-added">3311 </span>
3312         FT_MEM_COPY(
3313           tuple_coords,
<span class="line-modified">3314           blend-&gt;tuplecoords +</span>
<span class="line-added">3315             ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) * blend-&gt;num_axis,</span>
3316           blend-&gt;num_axis * sizeof ( FT_Fixed ) );
<span class="line-added">3317       }</span>
3318 
3319       if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
3320       {
3321         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3322           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
3323         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3324           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
3325       }
3326 
3327       apply = ft_var_apply_tuple( blend,
3328                                   (FT_UShort)tupleIndex,
3329                                   tuple_coords,
3330                                   im_start_coords,
3331                                   im_end_coords );
3332 
3333       if ( apply == 0 )              /* tuple isn&#39;t active for our blend */
3334       {
3335         offsetToData += tupleDataSize;
3336         continue;
3337       }
3338 
3339       here = FT_Stream_FTell( stream );
3340 
3341       FT_Stream_SeekSet( stream, offsetToData );
3342 
3343       if ( tupleIndex &amp; GX_TI_PRIVATE_POINT_NUMBERS )
3344       {
</pre>
<hr />
<pre>
3358                                         point_count == 0 ? face-&gt;cvt_size
3359                                                          : point_count );
3360 
3361       if ( !points                                                        ||
3362            !deltas                                                        ||
3363            ( localpoints == ALL_POINTS &amp;&amp; point_count != face-&gt;cvt_size ) )
3364         ; /* failure, ignore it */
3365 
3366       else if ( localpoints == ALL_POINTS )
3367       {
3368 #ifdef FT_DEBUG_LEVEL_TRACE
3369         int  count = 0;
3370 #endif
3371 
3372 
3373         FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
3374 
3375         /* this means that there are deltas for every entry in cvt */
3376         for ( j = 0; j &lt; face-&gt;cvt_size; j++ )
3377         {
<span class="line-modified">3378           FT_Fixed  old_cvt_delta;</span>
3379 
3380 
<span class="line-modified">3381           old_cvt_delta = cvt_deltas[j];</span>
<span class="line-modified">3382           cvt_deltas[j] = old_cvt_delta + FT_MulFix( deltas[j], apply );</span>
3383 
3384 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3385           if ( old_cvt_delta != cvt_deltas[j] )</span>
3386           {
<span class="line-modified">3387             FT_TRACE7(( &quot;      %d: %f -&gt; %f\n&quot;,</span>
<span class="line-modified">3388                         j,</span>
<span class="line-added">3389                         ( FT_fdot6ToFixed( face-&gt;cvt[j] ) +</span>
<span class="line-added">3390                           old_cvt_delta ) / 65536.0,</span>
<span class="line-added">3391                         ( FT_fdot6ToFixed( face-&gt;cvt[j] ) +</span>
<span class="line-added">3392                           cvt_deltas[j] ) / 65536.0 ));</span>
3393             count++;
3394           }
3395 #endif
3396         }
3397 
3398 #ifdef FT_DEBUG_LEVEL_TRACE
3399         if ( !count )
3400           FT_TRACE7(( &quot;      none\n&quot; ));
3401 #endif
3402       }
3403 
3404       else
3405       {
3406 #ifdef FT_DEBUG_LEVEL_TRACE
3407         int  count = 0;
3408 #endif
3409 
3410 
3411         FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
3412 
3413         for ( j = 0; j &lt; point_count; j++ )
3414         {
<span class="line-modified">3415           int       pindex;</span>
<span class="line-modified">3416           FT_Fixed  old_cvt_delta;</span>
3417 
3418 
3419           pindex = points[j];
3420           if ( (FT_ULong)pindex &gt;= face-&gt;cvt_size )
3421             continue;
3422 
<span class="line-modified">3423           old_cvt_delta      = cvt_deltas[pindex];</span>
<span class="line-modified">3424           cvt_deltas[pindex] = old_cvt_delta + FT_MulFix( deltas[j], apply );</span>

3425 
3426 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3427           if ( old_cvt_delta != cvt_deltas[pindex] )</span>
3428           {
<span class="line-modified">3429             FT_TRACE7(( &quot;      %d: %f -&gt; %f\n&quot;,</span>
<span class="line-modified">3430                         pindex,</span>
<span class="line-added">3431                         ( FT_fdot6ToFixed( face-&gt;cvt[pindex] ) +</span>
<span class="line-added">3432                           old_cvt_delta ) / 65536.0,</span>
<span class="line-added">3433                         ( FT_fdot6ToFixed( face-&gt;cvt[pindex] ) +</span>
<span class="line-added">3434                           cvt_deltas[pindex] ) / 65536.0 ));</span>
3435             count++;
3436           }
3437 #endif
3438         }
3439 
3440 #ifdef FT_DEBUG_LEVEL_TRACE
3441         if ( !count )
3442           FT_TRACE7(( &quot;      none\n&quot; ));
3443 #endif
3444       }
3445 
3446       if ( localpoints != ALL_POINTS )
3447         FT_FREE( localpoints );
3448       FT_FREE( deltas );
3449 
3450       offsetToData += tupleDataSize;
3451 
3452       FT_Stream_SeekSet( stream, here );
3453     }
3454 
3455     FT_TRACE5(( &quot;\n&quot; ));
3456 
<span class="line-added">3457     for ( i = 0; i &lt; face-&gt;cvt_size; i++ )</span>
<span class="line-added">3458       face-&gt;cvt[i] += FT_fixedToFdot6( cvt_deltas[i] );</span>
<span class="line-added">3459 </span>
3460   FExit:
3461     FT_FRAME_EXIT();
3462 
3463   Exit:
3464     if ( sharedpoints != ALL_POINTS )
3465       FT_FREE( sharedpoints );
3466     FT_FREE( tuple_coords );
3467     FT_FREE( im_start_coords );
3468     FT_FREE( im_end_coords );
<span class="line-added">3469     FT_FREE( cvt_deltas );</span>
<span class="line-added">3470 </span>
<span class="line-added">3471     /* iterate over all FT_Size objects and set `cvt_ready&#39; to -1 */</span>
<span class="line-added">3472     /* to trigger rescaling of all CVT values                     */</span>
<span class="line-added">3473     FT_List_Iterate( &amp;root-&gt;sizes_list,</span>
<span class="line-added">3474                      tt_cvt_ready_iterator,</span>
<span class="line-added">3475                      NULL );</span>
3476 
3477     return error;
3478   }
3479 
3480 
3481   /* Shift the original coordinates of all points between indices `p1&#39; */
3482   /* and `p2&#39;, using the same difference as given by index `ref&#39;.      */
3483 
3484   /* modeled after `af_iup_shift&#39; */
3485 
3486   static void
3487   tt_delta_shift( int         p1,
3488                   int         p2,
3489                   int         ref,
3490                   FT_Vector*  in_points,
3491                   FT_Vector*  out_points )
3492   {
3493     int        p;
3494     FT_Vector  delta;
3495 
</pre>
<hr />
<pre>
3501       return;
3502 
3503     for ( p = p1; p &lt; ref; p++ )
3504     {
3505       out_points[p].x += delta.x;
3506       out_points[p].y += delta.y;
3507     }
3508 
3509     for ( p = ref + 1; p &lt;= p2; p++ )
3510     {
3511       out_points[p].x += delta.x;
3512       out_points[p].y += delta.y;
3513     }
3514   }
3515 
3516 
3517   /* Interpolate the original coordinates of all points with indices */
3518   /* between `p1&#39; and `p2&#39;, using `ref1&#39; and `ref2&#39; as the reference */
3519   /* point indices.                                                  */
3520 
<span class="line-modified">3521   /* modeled after `af_iup_interp&#39;, `_iup_worker_interpolate&#39;, and   */</span>
<span class="line-modified">3522   /* `Ins_IUP&#39; with spec differences in handling ill-defined cases.  */</span>

3523   static void
3524   tt_delta_interpolate( int         p1,
3525                         int         p2,
3526                         int         ref1,
3527                         int         ref2,
3528                         FT_Vector*  in_points,
3529                         FT_Vector*  out_points )
3530   {
3531     int  p, i;
3532 
3533     FT_Pos  out, in1, in2, out1, out2, d1, d2;
3534 
3535 
3536     if ( p1 &gt; p2 )
3537       return;
3538 
3539     /* handle both horizontal and vertical coordinates */
3540     for ( i = 0; i &lt;= 1; i++ )
3541     {
3542       /* shift array pointers so that we can access `foo.y&#39; as `foo.x&#39; */
</pre>
<hr />
<pre>
3661                                 cur_delta,
3662                                 first_delta,
3663                                 in_points,
3664                                 out_points );
3665 
3666           if ( first_delta &gt; 0 )
3667             tt_delta_interpolate( first_point,
3668                                   first_delta - 1,
3669                                   cur_delta,
3670                                   first_delta,
3671                                   in_points,
3672                                   out_points );
3673         }
3674       }
3675       contour++;
3676 
3677     } while ( contour &lt; outline-&gt;n_contours );
3678   }
3679 
3680 
<span class="line-modified">3681   /**************************************************************************</span>
<span class="line-modified">3682    *</span>
<span class="line-modified">3683    * @Function:</span>
<span class="line-modified">3684    *   TT_Vary_Apply_Glyph_Deltas</span>
<span class="line-modified">3685    *</span>
<span class="line-modified">3686    * @Description:</span>
<span class="line-modified">3687    *   Apply the appropriate deltas to the current glyph.</span>
<span class="line-modified">3688    *</span>
<span class="line-modified">3689    * @Input:</span>
<span class="line-modified">3690    *   face ::</span>
<span class="line-modified">3691    *     A handle to the target face object.</span>
<span class="line-modified">3692    *</span>
<span class="line-modified">3693    *   glyph_index ::</span>
<span class="line-modified">3694    *     The index of the glyph being modified.</span>
<span class="line-modified">3695    *</span>
<span class="line-modified">3696    *   n_points ::</span>
<span class="line-modified">3697    *     The number of the points in the glyph, including</span>
<span class="line-modified">3698    *     phantom points.</span>
<span class="line-modified">3699    *</span>
<span class="line-modified">3700    * @InOut:</span>
<span class="line-modified">3701    *   outline ::</span>
<span class="line-modified">3702    *     The outline to change.</span>
<span class="line-added">3703    *</span>
<span class="line-added">3704    * @Output:</span>
<span class="line-added">3705    *   unrounded ::</span>
<span class="line-added">3706    *     An array with `n_points&#39; elements that is filled with unrounded</span>
<span class="line-added">3707    *     point coordinates (in 26.6 format).</span>
<span class="line-added">3708    *</span>
<span class="line-added">3709    * @Return:</span>
<span class="line-added">3710    *   FreeType error code.  0 means success.</span>
<span class="line-added">3711    */</span>
3712   FT_LOCAL_DEF( FT_Error )
3713   TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
3714                               FT_UInt      glyph_index,
3715                               FT_Outline*  outline,
<span class="line-added">3716                               FT_Vector*   unrounded,</span>
3717                               FT_UInt      n_points )
3718   {
<span class="line-modified">3719     FT_Error   error;</span>
<span class="line-modified">3720     FT_Stream  stream = face-&gt;root.stream;</span>
<span class="line-modified">3721     FT_Memory  memory = stream-&gt;memory;</span>
3722 
<span class="line-modified">3723     FT_Vector*  points_org = NULL;  /* coordinates in 16.16 format */</span>
<span class="line-modified">3724     FT_Vector*  points_out = NULL;  /* coordinates in 16.16 format */</span>
3725     FT_Bool*    has_delta  = NULL;
3726 
<span class="line-modified">3727     FT_ULong  glyph_start;</span>
<span class="line-modified">3728 </span>
<span class="line-modified">3729     FT_UInt   tupleCount;</span>
<span class="line-modified">3730     FT_ULong  offsetToData;</span>
<span class="line-modified">3731     FT_ULong  dataSize;</span>
<span class="line-modified">3732 </span>
<span class="line-modified">3733     FT_ULong  here;</span>
<span class="line-modified">3734     FT_UInt   i, j;</span>
<span class="line-modified">3735 </span>
<span class="line-modified">3736     FT_Fixed*  tuple_coords    = NULL;</span>
<span class="line-added">3737     FT_Fixed*  im_start_coords = NULL;</span>
<span class="line-added">3738     FT_Fixed*  im_end_coords   = NULL;</span>
<span class="line-added">3739 </span>
<span class="line-added">3740     GX_Blend  blend = face-&gt;blend;</span>
<span class="line-added">3741 </span>
<span class="line-added">3742     FT_UInt  point_count;</span>
<span class="line-added">3743     FT_UInt  spoint_count = 0;</span>
<span class="line-added">3744 </span>
3745     FT_UShort*  sharedpoints = NULL;
3746     FT_UShort*  localpoints  = NULL;
3747     FT_UShort*  points;
<span class="line-modified">3748 </span>
<span class="line-added">3749     FT_Fixed*  deltas_x       = NULL;</span>
<span class="line-added">3750     FT_Fixed*  deltas_y       = NULL;</span>
<span class="line-added">3751     FT_Fixed*  point_deltas_x = NULL;</span>
<span class="line-added">3752     FT_Fixed*  point_deltas_y = NULL;</span>
3753 
3754 
3755     if ( !face-&gt;doblend || !blend )
3756       return FT_THROW( Invalid_Argument );
3757 
<span class="line-added">3758     for ( i = 0; i &lt; n_points; i++ )</span>
<span class="line-added">3759     {</span>
<span class="line-added">3760       unrounded[i].x = INT_TO_F26DOT6( outline-&gt;points[i].x );</span>
<span class="line-added">3761       unrounded[i].y = INT_TO_F26DOT6( outline-&gt;points[i].y );</span>
<span class="line-added">3762     }</span>
<span class="line-added">3763 </span>
3764     if ( glyph_index &gt;= blend-&gt;gv_glyphcnt      ||
3765          blend-&gt;glyphoffsets[glyph_index] ==
3766            blend-&gt;glyphoffsets[glyph_index + 1] )
3767     {
3768       FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3769                   &quot; no variation data for this glyph\n&quot; ));
3770       return FT_Err_Ok;
3771     }
3772 
3773     if ( FT_NEW_ARRAY( points_org, n_points ) ||
3774          FT_NEW_ARRAY( points_out, n_points ) ||
3775          FT_NEW_ARRAY( has_delta, n_points )  )
3776       goto Fail1;
3777 
<span class="line-modified">3778     dataSize = blend-&gt;glyphoffsets[glyph_index + 1] -</span>
<span class="line-modified">3779                  blend-&gt;glyphoffsets[glyph_index];</span>
<span class="line-modified">3780 </span>
<span class="line-added">3781     if ( FT_STREAM_SEEK( blend-&gt;glyphoffsets[glyph_index] ) ||</span>
<span class="line-added">3782          FT_FRAME_ENTER( dataSize )                         )</span>
3783       goto Fail1;
3784 
3785     glyph_start = FT_Stream_FTell( stream );
3786 
3787     /* each set of glyph variation data is formatted similarly to `cvar&#39; */
3788 
3789     if ( FT_NEW_ARRAY( tuple_coords, blend-&gt;num_axis )    ||
3790          FT_NEW_ARRAY( im_start_coords, blend-&gt;num_axis ) ||
3791          FT_NEW_ARRAY( im_end_coords, blend-&gt;num_axis )   )
3792       goto Fail2;
3793 
3794     tupleCount   = FT_GET_USHORT();
3795     offsetToData = FT_GET_USHORT();
3796 
3797     /* rough sanity test */
<span class="line-modified">3798     if ( offsetToData &gt; dataSize                                ||</span>
<span class="line-modified">3799          ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) * 4 &gt; dataSize )</span>
3800     {
3801       FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3802                   &quot; invalid glyph variation array header\n&quot; ));
3803 
3804       error = FT_THROW( Invalid_Table );
3805       goto Fail2;
3806     }
3807 
3808     offsetToData += glyph_start;
3809 
3810     if ( tupleCount &amp; GX_TC_TUPLES_SHARE_POINT_NUMBERS )
3811     {
3812       here = FT_Stream_FTell( stream );
3813 
3814       FT_Stream_SeekSet( stream, offsetToData );
3815 
3816       sharedpoints = ft_var_readpackedpoints( stream,
3817                                               blend-&gt;gvar_size,
3818                                               &amp;spoint_count );
3819       offsetToData = FT_Stream_FTell( stream );
3820 
3821       FT_Stream_SeekSet( stream, here );
3822     }
3823 
3824     FT_TRACE5(( &quot;gvar: there %s %d tuple%s:\n&quot;,
3825                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,
3826                 tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,
3827                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));
3828 
<span class="line-added">3829     if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||</span>
<span class="line-added">3830          FT_NEW_ARRAY( point_deltas_y, n_points ) )</span>
<span class="line-added">3831       goto Fail3;</span>
<span class="line-added">3832 </span>
3833     for ( j = 0; j &lt; n_points; j++ )
<span class="line-modified">3834     {</span>
<span class="line-added">3835       points_org[j].x = FT_intToFixed( outline-&gt;points[j].x );</span>
<span class="line-added">3836       points_org[j].y = FT_intToFixed( outline-&gt;points[j].y );</span>
<span class="line-added">3837     }</span>
3838 
3839     for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )
3840     {
3841       FT_UInt   tupleDataSize;
3842       FT_UInt   tupleIndex;
3843       FT_Fixed  apply;
3844 
3845 
3846       FT_TRACE6(( &quot;  tuple %d:\n&quot;, i ));
3847 
3848       tupleDataSize = FT_GET_USHORT();
3849       tupleIndex    = FT_GET_USHORT();
3850 
3851       if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
3852       {
3853         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3854           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>

3855       }
3856       else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
3857       {
3858         FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
3859                     &quot; invalid tuple index\n&quot; ));
3860 
3861         error = FT_THROW( Invalid_Table );
<span class="line-modified">3862         goto Fail3;</span>
3863       }
3864       else
3865         FT_MEM_COPY(
3866           tuple_coords,
<span class="line-modified">3867           blend-&gt;tuplecoords +</span>
<span class="line-added">3868             ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) * blend-&gt;num_axis,</span>
3869           blend-&gt;num_axis * sizeof ( FT_Fixed ) );
3870 
3871       if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
3872       {
3873         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3874           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
3875         for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">3876           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
3877       }
3878 
3879       apply = ft_var_apply_tuple( blend,
3880                                   (FT_UShort)tupleIndex,
3881                                   tuple_coords,
3882                                   im_start_coords,
3883                                   im_end_coords );
3884 
3885       if ( apply == 0 )              /* tuple isn&#39;t active for our blend */
3886       {
3887         offsetToData += tupleDataSize;
3888         continue;
3889       }
3890 
3891       here = FT_Stream_FTell( stream );
3892 
3893       FT_Stream_SeekSet( stream, offsetToData );
3894 
3895       if ( tupleIndex &amp; GX_TI_PRIVATE_POINT_NUMBERS )
3896       {
</pre>
<hr />
<pre>
3912       deltas_y = ft_var_readpackeddeltas( stream,
3913                                           blend-&gt;gvar_size,
3914                                           point_count == 0 ? n_points
3915                                                            : point_count );
3916 
3917       if ( !points || !deltas_y || !deltas_x )
3918         ; /* failure, ignore it */
3919 
3920       else if ( points == ALL_POINTS )
3921       {
3922 #ifdef FT_DEBUG_LEVEL_TRACE
3923         int  count = 0;
3924 #endif
3925 
3926 
3927         FT_TRACE7(( &quot;    point deltas:\n&quot; ));
3928 
3929         /* this means that there are deltas for every point in the glyph */
3930         for ( j = 0; j &lt; n_points; j++ )
3931         {
<span class="line-modified">3932           FT_Fixed  old_point_delta_x = point_deltas_x[j];</span>
<span class="line-modified">3933           FT_Fixed  old_point_delta_y = point_deltas_y[j];</span>
<span class="line-added">3934 </span>
<span class="line-added">3935           FT_Fixed  point_delta_x = FT_MulFix( deltas_x[j], apply );</span>
<span class="line-added">3936           FT_Fixed  point_delta_y = FT_MulFix( deltas_y[j], apply );</span>
3937 
3938 
3939           if ( j &lt; n_points - 4 )
3940           {
<span class="line-modified">3941             point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
<span class="line-modified">3942             point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
3943           }
3944           else
3945           {
3946             /* To avoid double adjustment of advance width or height, */
3947             /* adjust phantom points only if there is no HVAR or VVAR */
3948             /* support, respectively.                                 */
3949             if ( j == ( n_points - 4 )        &amp;&amp;
3950                  !( face-&gt;variation_support &amp;
3951                     TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">3952               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
3953 
3954             else if ( j == ( n_points - 3 )          &amp;&amp;
3955                       !( face-&gt;variation_support   &amp;
3956                          TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">3957               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
3958 
3959             else if ( j == ( n_points - 2 )        &amp;&amp;
3960                       !( face-&gt;variation_support &amp;
3961                          TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">3962               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
3963 
3964             else if ( j == ( n_points - 1 )          &amp;&amp;
3965                       !( face-&gt;variation_support   &amp;
3966                          TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">3967               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
3968           }
3969 
3970 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">3971           if ( point_delta_x || point_delta_y )</span>
3972           {
<span class="line-modified">3973             FT_TRACE7(( &quot;      %d: (%f, %f) -&gt; (%f, %f)\n&quot;,</span>
3974                         j,
<span class="line-modified">3975                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-modified">3976                           old_point_delta_x ) / 65536.0,</span>
<span class="line-modified">3977                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-modified">3978                           old_point_delta_y ) / 65536.0,</span>
<span class="line-added">3979                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-added">3980                           point_deltas_x[j] ) / 65536.0,</span>
<span class="line-added">3981                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-added">3982                           point_deltas_y[j] ) / 65536.0 ));</span>
3983             count++;
3984           }
3985 #endif
3986         }
3987 
3988 #ifdef FT_DEBUG_LEVEL_TRACE
3989         if ( !count )
3990           FT_TRACE7(( &quot;      none\n&quot; ));
3991 #endif
3992       }
3993 
3994       else
3995       {
3996 #ifdef FT_DEBUG_LEVEL_TRACE
3997         int  count = 0;
3998 #endif
3999 
4000 
4001         /* we have to interpolate the missing deltas similar to the */
4002         /* IUP bytecode instruction                                 */
</pre>
<hr />
<pre>
4014           if ( idx &gt;= n_points )
4015             continue;
4016 
4017           has_delta[idx] = TRUE;
4018 
4019           points_out[idx].x += FT_MulFix( deltas_x[j], apply );
4020           points_out[idx].y += FT_MulFix( deltas_y[j], apply );
4021         }
4022 
4023         /* no need to handle phantom points here,      */
4024         /* since solitary points can&#39;t be interpolated */
4025         tt_interpolate_deltas( outline,
4026                                points_out,
4027                                points_org,
4028                                has_delta );
4029 
4030         FT_TRACE7(( &quot;    point deltas:\n&quot; ));
4031 
4032         for ( j = 0; j &lt; n_points; j++ )
4033         {
<span class="line-modified">4034           FT_Fixed  old_point_delta_x = point_deltas_x[j];</span>
<span class="line-modified">4035           FT_Fixed  old_point_delta_y = point_deltas_y[j];</span>
<span class="line-added">4036 </span>
<span class="line-added">4037           FT_Pos  point_delta_x = points_out[j].x - points_org[j].x;</span>
<span class="line-added">4038           FT_Pos  point_delta_y = points_out[j].y - points_org[j].y;</span>
4039 
4040 
4041           if ( j &lt; n_points - 4 )
4042           {
<span class="line-modified">4043             point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
<span class="line-modified">4044             point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
4045           }
4046           else
4047           {
4048             /* To avoid double adjustment of advance width or height, */
4049             /* adjust phantom points only if there is no HVAR or VVAR */
4050             /* support, respectively.                                 */
4051             if ( j == ( n_points - 4 )        &amp;&amp;
4052                  !( face-&gt;variation_support &amp;
4053                     TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">4054               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
4055 
4056             else if ( j == ( n_points - 3 )          &amp;&amp;
4057                       !( face-&gt;variation_support   &amp;
4058                          TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">4059               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
4060 
4061             else if ( j == ( n_points - 2 )        &amp;&amp;
4062                       !( face-&gt;variation_support &amp;
4063                          TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">4064               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
4065 
4066             else if ( j == ( n_points - 1 )          &amp;&amp;
4067                       !( face-&gt;variation_support   &amp;
4068                          TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">4069               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
4070           }
4071 
4072 #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">4073           if ( point_delta_x || point_delta_y )</span>
4074           {
<span class="line-modified">4075             FT_TRACE7(( &quot;      %d: (%f, %f) -&gt; (%f, %f)\n&quot;,</span>
4076                         j,
<span class="line-modified">4077                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-modified">4078                           old_point_delta_x ) / 65536.0,</span>
<span class="line-modified">4079                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-modified">4080                           old_point_delta_y ) / 65536.0,</span>
<span class="line-added">4081                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-added">4082                           point_deltas_x[j] ) / 65536.0,</span>
<span class="line-added">4083                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-added">4084                           point_deltas_y[j] ) / 65536.0 ));</span>
4085             count++;
4086           }
4087 #endif
4088         }
4089 
4090 #ifdef FT_DEBUG_LEVEL_TRACE
4091         if ( !count )
4092           FT_TRACE7(( &quot;      none\n&quot; ));
4093 #endif
4094       }
4095 
4096       if ( localpoints != ALL_POINTS )
4097         FT_FREE( localpoints );
4098       FT_FREE( deltas_x );
4099       FT_FREE( deltas_y );
4100 
4101       offsetToData += tupleDataSize;
4102 
4103       FT_Stream_SeekSet( stream, here );
4104     }
4105 
4106     FT_TRACE5(( &quot;\n&quot; ));
4107 
<span class="line-added">4108     for ( i = 0; i &lt; n_points; i++ )</span>
<span class="line-added">4109     {</span>
<span class="line-added">4110       unrounded[i].x += FT_fixedToFdot6( point_deltas_x[i] );</span>
<span class="line-added">4111       unrounded[i].y += FT_fixedToFdot6( point_deltas_y[i] );</span>
<span class="line-added">4112 </span>
<span class="line-added">4113       outline-&gt;points[i].x += FT_fixedToInt( point_deltas_x[i] );</span>
<span class="line-added">4114       outline-&gt;points[i].y += FT_fixedToInt( point_deltas_y[i] );</span>
<span class="line-added">4115     }</span>
<span class="line-added">4116 </span>
<span class="line-added">4117   Fail3:</span>
<span class="line-added">4118     FT_FREE( point_deltas_x );</span>
<span class="line-added">4119     FT_FREE( point_deltas_y );</span>
<span class="line-added">4120 </span>
4121   Fail2:
4122     if ( sharedpoints != ALL_POINTS )
4123       FT_FREE( sharedpoints );
4124     FT_FREE( tuple_coords );
4125     FT_FREE( im_start_coords );
4126     FT_FREE( im_end_coords );
4127 
4128     FT_FRAME_EXIT();
4129 
4130   Fail1:
4131     FT_FREE( points_org );
4132     FT_FREE( points_out );
4133     FT_FREE( has_delta );
4134 
4135     return error;
4136   }
4137 
4138 
<span class="line-modified">4139   /**************************************************************************</span>
<span class="line-modified">4140    *</span>
<span class="line-modified">4141    * @Function:</span>
<span class="line-modified">4142    *   tt_get_var_blend</span>
<span class="line-modified">4143    *</span>
<span class="line-modified">4144    * @Description:</span>
<span class="line-modified">4145    *   An extended internal version of `TT_Get_MM_Blend&#39; that returns</span>
<span class="line-modified">4146    *   pointers instead of copying data, without any initialization of</span>
<span class="line-modified">4147    *   the MM machinery in case it isn&#39;t loaded yet.</span>
<span class="line-modified">4148    */</span>
4149   FT_LOCAL_DEF( FT_Error )
4150   tt_get_var_blend( TT_Face      face,
4151                     FT_UInt     *num_coords,
4152                     FT_Fixed*   *coords,
4153                     FT_Fixed*   *normalizedcoords,
4154                     FT_MM_Var*  *mm_var )
4155   {
4156     if ( face-&gt;blend )
4157     {
4158       if ( num_coords )
4159         *num_coords       = face-&gt;blend-&gt;num_axis;
4160       if ( coords )
4161         *coords           = face-&gt;blend-&gt;coords;
4162       if ( normalizedcoords )
4163         *normalizedcoords = face-&gt;blend-&gt;normalizedcoords;
4164       if ( mm_var )
4165         *mm_var           = face-&gt;blend-&gt;mmvar;
4166     }
4167     else
4168     {
</pre>
<hr />
<pre>
4190     {
4191       for ( i = 0; i &lt; itemStore-&gt;dataCount; i++ )
4192       {
4193         FT_FREE( itemStore-&gt;varData[i].regionIndices );
4194         FT_FREE( itemStore-&gt;varData[i].deltaSet );
4195       }
4196 
4197       FT_FREE( itemStore-&gt;varData );
4198     }
4199 
4200     if ( itemStore-&gt;varRegionList )
4201     {
4202       for ( i = 0; i &lt; itemStore-&gt;regionCount; i++ )
4203         FT_FREE( itemStore-&gt;varRegionList[i].axisList );
4204 
4205       FT_FREE( itemStore-&gt;varRegionList );
4206     }
4207   }
4208 
4209 
<span class="line-modified">4210   /**************************************************************************</span>
<span class="line-modified">4211    *</span>
<span class="line-modified">4212    * @Function:</span>
<span class="line-modified">4213    *   tt_done_blend</span>
<span class="line-modified">4214    *</span>
<span class="line-modified">4215    * @Description:</span>
<span class="line-modified">4216    *   Free the blend internal data structure.</span>
<span class="line-modified">4217    */</span>
4218   FT_LOCAL_DEF( void )
4219   tt_done_blend( TT_Face  face )
4220   {
4221     FT_Memory  memory = FT_FACE_MEMORY( face );
4222     GX_Blend   blend  = face-&gt;blend;
4223 
4224 
4225     if ( blend )
4226     {
4227       FT_UInt  i, num_axes;
4228 
4229 
4230       /* blend-&gt;num_axis might not be set up yet */
4231       num_axes = blend-&gt;mmvar-&gt;num_axis;
4232 
4233       FT_FREE( blend-&gt;coords );
4234       FT_FREE( blend-&gt;normalizedcoords );
4235       FT_FREE( blend-&gt;normalized_stylecoords );
4236       FT_FREE( blend-&gt;mmvar );
4237 
</pre>
</td>
</tr>
</table>
<center><a href="ttgload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgxvar.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
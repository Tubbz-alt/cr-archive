<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/autofit/afhints.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afhints.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afindic.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afhints.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,21 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  afhints.h                                                              */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Auto-fitter hinting routines (specification).                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
  
  #ifndef AFHINTS_H_
  #define AFHINTS_H_
  
<span class="line-new-header">--- 1,21 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * afhints.h</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Auto-fitter hinting routines (specification).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
  
  #ifndef AFHINTS_H_
  #define AFHINTS_H_
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 24,12 ***</span>
  #define xxAF_SORT_SEGMENTS
  
  FT_BEGIN_HEADER
  
    /*
<span class="line-modified">!    *  The definition of outline glyph hints.  These are shared by all</span>
<span class="line-modified">!    *  writing system analysis routines (until now).</span>
     */
  
    typedef enum  AF_Dimension_
    {
      AF_DIMENSION_HORZ = 0,  /* x coordinates,                    */
<span class="line-new-header">--- 24,12 ---</span>
  #define xxAF_SORT_SEGMENTS
  
  FT_BEGIN_HEADER
  
    /*
<span class="line-modified">!    * The definition of outline glyph hints.  These are shared by all</span>
<span class="line-modified">!    * writing system analysis routines (until now).</span>
     */
  
    typedef enum  AF_Dimension_
    {
      AF_DIMENSION_HORZ = 0,  /* x coordinates,                    */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,157 ***</span>
  
    } AF_Direction;
  
  
    /*
<span class="line-modified">!    *  The following explanations are mostly taken from the article</span>
     *
<span class="line-modified">!    *    Real-Time Grid Fitting of Typographic Outlines</span>
     *
<span class="line-modified">!    *  by David Turner and Werner Lemberg</span>
     *
<span class="line-modified">!    *    https://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf</span>
     *
<span class="line-modified">!    *  with appropriate updates.</span>
     *
     *
<span class="line-modified">!    *  Segments</span>
     *
<span class="line-modified">!    *    `af_{cjk,latin,...}_hints_compute_segments&#39; are the functions to</span>
<span class="line-modified">!    *    find segments in an outline.</span>
     *
<span class="line-modified">!    *    A segment is a series of at least two consecutive points that are</span>
<span class="line-modified">!    *    approximately aligned along a coordinate axis.  The analysis to do</span>
<span class="line-modified">!    *    so is specific to a writing system.</span>
     *
     *
<span class="line-modified">!    *  Edges</span>
     *
<span class="line-modified">!    *    `af_{cjk,latin,...}_hints_compute_edges&#39; are the functions to find</span>
<span class="line-modified">!    *    edges.</span>
     *
<span class="line-modified">!    *    As soon as segments are defined, the auto-hinter groups them into</span>
<span class="line-modified">!    *    edges.  An edge corresponds to a single position on the main</span>
<span class="line-modified">!    *    dimension that collects one or more segments (allowing for a small</span>
<span class="line-modified">!    *    threshold).</span>
     *
<span class="line-modified">!    *    As an example, the `latin&#39; writing system first tries to grid-fit</span>
<span class="line-modified">!    *    edges, then to align segments on the edges unless it detects that</span>
<span class="line-modified">!    *    they form a serif.</span>
     *
     *
<span class="line-modified">!    *                      A          H</span>
<span class="line-modified">!    *                       |        |</span>
<span class="line-modified">!    *                       |        |</span>
<span class="line-modified">!    *                       |        |</span>
<span class="line-modified">!    *                       |        |</span>
<span class="line-modified">!    *         C             |        |             F</span>
<span class="line-modified">!    *          +------&lt;-----+        +-----&lt;------+</span>
<span class="line-modified">!    *          |             B      G             |</span>
<span class="line-modified">!    *          |                                  |</span>
<span class="line-modified">!    *          |                                  |</span>
<span class="line-modified">!    *          +---------------&gt;------------------+</span>
<span class="line-modified">!    *         D                                    E</span>
     *
     *
<span class="line-modified">!    *  Stems</span>
     *
<span class="line-modified">!    *    Stems are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
     *
<span class="line-modified">!    *    Segments need to be `linked&#39; to other ones in order to detect stems.</span>
<span class="line-modified">!    *    A stem is made of two segments that face each other in opposite</span>
<span class="line-modified">!    *    directions and that are sufficiently close to each other.  Using</span>
<span class="line-modified">!    *    vocabulary from the TrueType specification, stem segments form a</span>
<span class="line-modified">!    *    `black distance&#39;.</span>
     *
<span class="line-modified">!    *    In the above ASCII drawing, the horizontal segments are BC, DE, and</span>
<span class="line-modified">!    *    FG; the vertical segments are AB, CD, EF, and GH.</span>
     *
<span class="line-modified">!    *    Each segment has at most one `best&#39; candidate to form a black</span>
<span class="line-modified">!    *    distance, or no candidate at all.  Notice that two distinct segments</span>
<span class="line-modified">!    *    can have the same candidate, which frequently means a serif.</span>
     *
<span class="line-modified">!    *    A stem is recognized by the following condition:</span>
     *
<span class="line-modified">!    *      best segment_1 = segment_2 &amp;&amp; best segment_2 = segment_1</span>
     *
<span class="line-modified">!    *    The best candidate is stored in field `link&#39; in structure</span>
<span class="line-modified">!    *    `AF_Segment&#39;.</span>
     *
<span class="line-modified">!    *    In the above ASCII drawing, the best candidate for both AB and CD is</span>
<span class="line-modified">!    *    GH, while the best candidate for GH is AB.  Similarly, the best</span>
<span class="line-modified">!    *    candidate for EF and GH is AB, while the best candidate for AB is</span>
<span class="line-modified">!    *    GH.</span>
     *
<span class="line-modified">!    *    The detection and handling of stems is dependent on the writing</span>
<span class="line-modified">!    *    system.</span>
     *
     *
<span class="line-modified">!    *  Serifs</span>
     *
<span class="line-modified">!    *    Serifs are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
     *
<span class="line-modified">!    *    In comparison to a stem, a serif (as handled by the auto-hinter</span>
<span class="line-modified">!    *    module that takes care of the `latin&#39; writing system) has</span>
     *
<span class="line-modified">!    *      best segment_1 = segment_2 &amp;&amp; best segment_2 != segment_1</span>
     *
<span class="line-modified">!    *    where segment_1 corresponds to the serif segment (CD and EF in the</span>
<span class="line-modified">!    *    above ASCII drawing).</span>
     *
<span class="line-modified">!    *    The best candidate is stored in field `serif&#39; in structure</span>
<span class="line-modified">!    *    `AF_Segment&#39; (and `link&#39; is set to NULL).</span>
     *
     *
<span class="line-modified">!    *  Touched points</span>
     *
<span class="line-modified">!    *    A point is called `touched&#39; if it has been processed somehow by the</span>
<span class="line-modified">!    *    auto-hinter.  It basically means that it shouldn&#39;t be moved again</span>
<span class="line-modified">!    *    (or moved only under certain constraints to preserve the already</span>
<span class="line-modified">!    *    applied processing).</span>
     *
     *
<span class="line-modified">!    *  Flat and round segments</span>
     *
<span class="line-modified">!    *    Segments are `round&#39; or `flat&#39;, depending on the series of points</span>
<span class="line-modified">!    *    that define them.  A segment is round if the next and previous point</span>
<span class="line-modified">!    *    of an extremum (which can be either a single point or sequence of</span>
<span class="line-modified">!    *    points) are both conic or cubic control points.  Otherwise, a</span>
<span class="line-modified">!    *    segment with an extremum is flat.</span>
     *
     *
<span class="line-modified">!    *  Strong Points</span>
     *
<span class="line-modified">!    *    Experience has shown that points not part of an edge need to be</span>
<span class="line-modified">!    *    interpolated linearly between their two closest edges, even if these</span>
<span class="line-modified">!    *    are not part of the contour of those particular points.  Typical</span>
<span class="line-modified">!    *    candidates for this are</span>
     *
<span class="line-modified">!    *    - angle points (i.e., points where the `in&#39; and `out&#39; direction</span>
<span class="line-modified">!    *      differ greatly)</span>
     *
<span class="line-modified">!    *    - inflection points (i.e., where the `in&#39; and `out&#39; angles are the</span>
<span class="line-modified">!    *      same, but the curvature changes sign) [currently, such points</span>
<span class="line-modified">!    *      aren&#39;t handled specially in the auto-hinter]</span>
     *
<span class="line-modified">!    *    `af_glyph_hints_align_strong_points&#39; is the function that takes</span>
<span class="line-modified">!    *    care of such situations; it is equivalent to the TrueType `IP&#39;</span>
<span class="line-modified">!    *    hinting instruction.</span>
     *
     *
<span class="line-modified">!    *  Weak Points</span>
     *
<span class="line-modified">!    *    Other points in the outline must be interpolated using the</span>
<span class="line-modified">!    *    coordinates of their previous and next unfitted contour neighbours.</span>
<span class="line-modified">!    *    These are called `weak points&#39; and are touched by the function</span>
<span class="line-modified">!    *    `af_glyph_hints_align_weak_points&#39;, equivalent to the TrueType `IUP&#39;</span>
<span class="line-modified">!    *    hinting instruction.  Typical candidates are control points and</span>
<span class="line-modified">!    *    points on the contour without a major direction.</span>
     *
<span class="line-modified">!    *    The major effect is to reduce possible distortion caused by</span>
<span class="line-modified">!    *    alignment of edges and strong points, thus weak points are processed</span>
<span class="line-modified">!    *    after strong points.</span>
     */
  
  
    /* point hint flags */
  #define AF_FLAG_NONE  0
<span class="line-new-header">--- 54,157 ---</span>
  
    } AF_Direction;
  
  
    /*
<span class="line-modified">!    * The following explanations are mostly taken from the article</span>
     *
<span class="line-modified">!    *   Real-Time Grid Fitting of Typographic Outlines</span>
     *
<span class="line-modified">!    * by David Turner and Werner Lemberg</span>
     *
<span class="line-modified">!    *   https://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf</span>
     *
<span class="line-modified">!    * with appropriate updates.</span>
     *
     *
<span class="line-modified">!    * Segments</span>
     *
<span class="line-modified">!    *   `af_{cjk,latin,...}_hints_compute_segments&#39; are the functions to</span>
<span class="line-modified">!    *   find segments in an outline.</span>
     *
<span class="line-modified">!    *   A segment is a series of at least two consecutive points that are</span>
<span class="line-modified">!    *   approximately aligned along a coordinate axis.  The analysis to do</span>
<span class="line-modified">!    *   so is specific to a writing system.</span>
     *
     *
<span class="line-modified">!    * Edges</span>
     *
<span class="line-modified">!    *   `af_{cjk,latin,...}_hints_compute_edges&#39; are the functions to find</span>
<span class="line-modified">!    *   edges.</span>
     *
<span class="line-modified">!    *   As soon as segments are defined, the auto-hinter groups them into</span>
<span class="line-modified">!    *   edges.  An edge corresponds to a single position on the main</span>
<span class="line-modified">!    *   dimension that collects one or more segments (allowing for a small</span>
<span class="line-modified">!    *   threshold).</span>
     *
<span class="line-modified">!    *   As an example, the `latin&#39; writing system first tries to grid-fit</span>
<span class="line-modified">!    *   edges, then to align segments on the edges unless it detects that</span>
<span class="line-modified">!    *   they form a serif.</span>
     *
     *
<span class="line-modified">!    *                     A          H</span>
<span class="line-modified">!    *                      |        |</span>
<span class="line-modified">!    *                      |        |</span>
<span class="line-modified">!    *                      |        |</span>
<span class="line-modified">!    *                      |        |</span>
<span class="line-modified">!    *        C             |        |             F</span>
<span class="line-modified">!    *         +------&lt;-----+        +-----&lt;------+</span>
<span class="line-modified">!    *         |             B      G             |</span>
<span class="line-modified">!    *         |                                  |</span>
<span class="line-modified">!    *         |                                  |</span>
<span class="line-modified">!    *         +---------------&gt;------------------+</span>
<span class="line-modified">!    *        D                                    E</span>
     *
     *
<span class="line-modified">!    * Stems</span>
     *
<span class="line-modified">!    *   Stems are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
     *
<span class="line-modified">!    *   Segments need to be `linked&#39; to other ones in order to detect stems.</span>
<span class="line-modified">!    *   A stem is made of two segments that face each other in opposite</span>
<span class="line-modified">!    *   directions and that are sufficiently close to each other.  Using</span>
<span class="line-modified">!    *   vocabulary from the TrueType specification, stem segments form a</span>
<span class="line-modified">!    *   `black distance&#39;.</span>
     *
<span class="line-modified">!    *   In the above ASCII drawing, the horizontal segments are BC, DE, and</span>
<span class="line-modified">!    *   FG; the vertical segments are AB, CD, EF, and GH.</span>
     *
<span class="line-modified">!    *   Each segment has at most one `best&#39; candidate to form a black</span>
<span class="line-modified">!    *   distance, or no candidate at all.  Notice that two distinct segments</span>
<span class="line-modified">!    *   can have the same candidate, which frequently means a serif.</span>
     *
<span class="line-modified">!    *   A stem is recognized by the following condition:</span>
     *
<span class="line-modified">!    *     best segment_1 = segment_2 &amp;&amp; best segment_2 = segment_1</span>
     *
<span class="line-modified">!    *   The best candidate is stored in field `link&#39; in structure</span>
<span class="line-modified">!    *   `AF_Segment&#39;.</span>
     *
<span class="line-modified">!    *   In the above ASCII drawing, the best candidate for both AB and CD is</span>
<span class="line-modified">!    *   GH, while the best candidate for GH is AB.  Similarly, the best</span>
<span class="line-modified">!    *   candidate for EF and GH is AB, while the best candidate for AB is</span>
<span class="line-modified">!    *   GH.</span>
     *
<span class="line-modified">!    *   The detection and handling of stems is dependent on the writing</span>
<span class="line-modified">!    *   system.</span>
     *
     *
<span class="line-modified">!    * Serifs</span>
     *
<span class="line-modified">!    *   Serifs are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
     *
<span class="line-modified">!    *   In comparison to a stem, a serif (as handled by the auto-hinter</span>
<span class="line-modified">!    *   module that takes care of the `latin&#39; writing system) has</span>
     *
<span class="line-modified">!    *     best segment_1 = segment_2 &amp;&amp; best segment_2 != segment_1</span>
     *
<span class="line-modified">!    *   where segment_1 corresponds to the serif segment (CD and EF in the</span>
<span class="line-modified">!    *   above ASCII drawing).</span>
     *
<span class="line-modified">!    *   The best candidate is stored in field `serif&#39; in structure</span>
<span class="line-modified">!    *   `AF_Segment&#39; (and `link&#39; is set to NULL).</span>
     *
     *
<span class="line-modified">!    * Touched points</span>
     *
<span class="line-modified">!    *   A point is called `touched&#39; if it has been processed somehow by the</span>
<span class="line-modified">!    *   auto-hinter.  It basically means that it shouldn&#39;t be moved again</span>
<span class="line-modified">!    *   (or moved only under certain constraints to preserve the already</span>
<span class="line-modified">!    *   applied processing).</span>
     *
     *
<span class="line-modified">!    * Flat and round segments</span>
     *
<span class="line-modified">!    *   Segments are `round&#39; or `flat&#39;, depending on the series of points</span>
<span class="line-modified">!    *   that define them.  A segment is round if the next and previous point</span>
<span class="line-modified">!    *   of an extremum (which can be either a single point or sequence of</span>
<span class="line-modified">!    *   points) are both conic or cubic control points.  Otherwise, a</span>
<span class="line-modified">!    *   segment with an extremum is flat.</span>
     *
     *
<span class="line-modified">!    * Strong Points</span>
     *
<span class="line-modified">!    *   Experience has shown that points not part of an edge need to be</span>
<span class="line-modified">!    *   interpolated linearly between their two closest edges, even if these</span>
<span class="line-modified">!    *   are not part of the contour of those particular points.  Typical</span>
<span class="line-modified">!    *   candidates for this are</span>
     *
<span class="line-modified">!    *   - angle points (i.e., points where the `in&#39; and `out&#39; direction</span>
<span class="line-modified">!    *     differ greatly)</span>
     *
<span class="line-modified">!    *   - inflection points (i.e., where the `in&#39; and `out&#39; angles are the</span>
<span class="line-modified">!    *     same, but the curvature changes sign) [currently, such points</span>
<span class="line-modified">!    *     aren&#39;t handled specially in the auto-hinter]</span>
     *
<span class="line-modified">!    *   `af_glyph_hints_align_strong_points&#39; is the function that takes</span>
<span class="line-modified">!    *   care of such situations; it is equivalent to the TrueType `IP&#39;</span>
<span class="line-modified">!    *   hinting instruction.</span>
     *
     *
<span class="line-modified">!    * Weak Points</span>
     *
<span class="line-modified">!    *   Other points in the outline must be interpolated using the</span>
<span class="line-modified">!    *   coordinates of their previous and next unfitted contour neighbours.</span>
<span class="line-modified">!    *   These are called `weak points&#39; and are touched by the function</span>
<span class="line-modified">!    *   `af_glyph_hints_align_weak_points&#39;, equivalent to the TrueType `IUP&#39;</span>
<span class="line-modified">!    *   hinting instruction.  Typical candidates are control points and</span>
<span class="line-modified">!    *   points on the contour without a major direction.</span>
     *
<span class="line-modified">!    *   The major effect is to reduce possible distortion caused by</span>
<span class="line-modified">!    *   alignment of edges and strong points, thus weak points are processed</span>
<span class="line-modified">!    *   after strong points.</span>
     */
  
  
    /* point hint flags */
  #define AF_FLAG_NONE  0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,10 ***</span>
<span class="line-new-header">--- 250,16 ---</span>
      FT_Pos     u, v;     /* current (x,y) or (y,x) depending on context */
  
      AF_Point   next;     /* next point in contour     */
      AF_Point   prev;     /* previous point in contour */
  
<span class="line-added">+ #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">+     /* track `before&#39; and `after&#39; edges for strong points */</span>
<span class="line-added">+     AF_Edge    before[2];</span>
<span class="line-added">+     AF_Edge    after[2];</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
    } AF_PointRec;
  
  
    typedef struct  AF_SegmentRec_
    {
</pre>
<center><a href="afhints.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afindic.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
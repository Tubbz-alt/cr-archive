<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/include/freetype/internal/ftstream.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftstream.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Stream handling (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef FTSTREAM_H_
 20 #define FTSTREAM_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_SYSTEM_H
 25 #include FT_INTERNAL_OBJECTS_H
 26 
 27 
 28 FT_BEGIN_HEADER
 29 
 30 
 31   /* format of an 8-bit frame_op value:           */
 32   /*                                              */
 33   /* bit  76543210                                */
 34   /*      xxxxxxes                                */
 35   /*                                              */
 36   /* s is set to 1 if the value is signed.        */
 37   /* e is set to 1 if the value is little-endian. */
 38   /* xxx is a command.                            */
 39 
 40 #define FT_FRAME_OP_SHIFT         2
 41 #define FT_FRAME_OP_SIGNED        1
 42 #define FT_FRAME_OP_LITTLE        2
 43 #define FT_FRAME_OP_COMMAND( x )  ( x &gt;&gt; FT_FRAME_OP_SHIFT )
 44 
 45 #define FT_MAKE_FRAME_OP( command, little, sign ) \
 46           ( ( command &lt;&lt; FT_FRAME_OP_SHIFT ) | ( little &lt;&lt; 1 ) | sign )
 47 
 48 #define FT_FRAME_OP_END    0
 49 #define FT_FRAME_OP_START  1  /* start a new frame     */
 50 #define FT_FRAME_OP_BYTE   2  /* read 1-byte value     */
 51 #define FT_FRAME_OP_SHORT  3  /* read 2-byte value     */
 52 #define FT_FRAME_OP_LONG   4  /* read 4-byte value     */
 53 #define FT_FRAME_OP_OFF3   5  /* read 3-byte value     */
 54 #define FT_FRAME_OP_BYTES  6  /* read a bytes sequence */
 55 
 56 
 57   typedef enum  FT_Frame_Op_
 58   {
 59     ft_frame_end       = 0,
 60     ft_frame_start     = FT_MAKE_FRAME_OP( FT_FRAME_OP_START, 0, 0 ),
 61 
 62     ft_frame_byte      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 0 ),
 63     ft_frame_schar     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTE,  0, 1 ),
 64 
 65     ft_frame_ushort_be = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 0 ),
 66     ft_frame_short_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 0, 1 ),
 67     ft_frame_ushort_le = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 0 ),
 68     ft_frame_short_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_SHORT, 1, 1 ),
 69 
 70     ft_frame_ulong_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 0 ),
 71     ft_frame_long_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 0, 1 ),
 72     ft_frame_ulong_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 0 ),
 73     ft_frame_long_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_LONG, 1, 1 ),
 74 
 75     ft_frame_uoff3_be  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 0 ),
 76     ft_frame_off3_be   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 0, 1 ),
 77     ft_frame_uoff3_le  = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 0 ),
 78     ft_frame_off3_le   = FT_MAKE_FRAME_OP( FT_FRAME_OP_OFF3, 1, 1 ),
 79 
 80     ft_frame_bytes     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 0 ),
 81     ft_frame_skip      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 1 )
 82 
 83   } FT_Frame_Op;
 84 
 85 
 86   typedef struct  FT_Frame_Field_
 87   {
 88     FT_Byte    value;
 89     FT_Byte    size;
 90     FT_UShort  offset;
 91 
 92   } FT_Frame_Field;
 93 
 94 
 95   /* Construct an FT_Frame_Field out of a structure type and a field name. */
 96   /* The structure type must be set in the FT_STRUCTURE macro before       */
 97   /* calling the FT_FRAME_START() macro.                                   */
 98   /*                                                                       */
<a name="2" id="anc2"></a><span class="line-modified"> 99 #define FT_FIELD_SIZE( f )                          \</span>
100           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f )
101 
<a name="3" id="anc3"></a><span class="line-modified">102 #define FT_FIELD_SIZE_DELTA( f )                       \</span>
103           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f[0] )
104 
<a name="4" id="anc4"></a><span class="line-modified">105 #define FT_FIELD_OFFSET( f )                         \</span>
106           (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
107 
108 #define FT_FRAME_FIELD( frame_op, field ) \
109           {                               \
110             frame_op,                     \
111             FT_FIELD_SIZE( field ),       \
112             FT_FIELD_OFFSET( field )      \
113           }
114 
115 #define FT_MAKE_EMPTY_FIELD( frame_op )  { frame_op, 0, 0 }
116 
117 #define FT_FRAME_START( size )   { ft_frame_start, 0, size }
118 #define FT_FRAME_END             { ft_frame_end, 0, 0 }
119 
120 #define FT_FRAME_LONG( f )       FT_FRAME_FIELD( ft_frame_long_be, f )
121 #define FT_FRAME_ULONG( f )      FT_FRAME_FIELD( ft_frame_ulong_be, f )
122 #define FT_FRAME_SHORT( f )      FT_FRAME_FIELD( ft_frame_short_be, f )
123 #define FT_FRAME_USHORT( f )     FT_FRAME_FIELD( ft_frame_ushort_be, f )
124 #define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
125 #define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
126 #define FT_FRAME_BYTE( f )       FT_FRAME_FIELD( ft_frame_byte, f )
127 #define FT_FRAME_CHAR( f )       FT_FRAME_FIELD( ft_frame_schar, f )
128 
129 #define FT_FRAME_LONG_LE( f )    FT_FRAME_FIELD( ft_frame_long_le, f )
130 #define FT_FRAME_ULONG_LE( f )   FT_FRAME_FIELD( ft_frame_ulong_le, f )
131 #define FT_FRAME_SHORT_LE( f )   FT_FRAME_FIELD( ft_frame_short_le, f )
132 #define FT_FRAME_USHORT_LE( f )  FT_FRAME_FIELD( ft_frame_ushort_le, f )
133 #define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
134 #define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
135 
136 #define FT_FRAME_SKIP_LONG       { ft_frame_long_be, 0, 0 }
137 #define FT_FRAME_SKIP_SHORT      { ft_frame_short_be, 0, 0 }
138 #define FT_FRAME_SKIP_BYTE       { ft_frame_byte, 0, 0 }
139 
140 #define FT_FRAME_BYTES( field, count ) \
141           {                            \
142             ft_frame_bytes,            \
143             count,                     \
144             FT_FIELD_OFFSET( field )   \
145           }
146 
147 #define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
148 
149 
<a name="5" id="anc5"></a><span class="line-modified">150   /**************************************************************************</span>
<span class="line-modified">151    *</span>
<span class="line-modified">152    * Integer extraction macros -- the &#39;buffer&#39; parameter must ALWAYS be of</span>
<span class="line-modified">153    * type &#39;char*&#39; or equivalent (1-byte elements).</span>
<span class="line-modified">154    */</span>
155 
156 #define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
157 
158 #define FT_INT16( x )   ( (FT_Int16)(x)  )
159 #define FT_UINT16( x )  ( (FT_UInt16)(x) )
160 #define FT_INT32( x )   ( (FT_Int32)(x)  )
161 #define FT_UINT32( x )  ( (FT_UInt32)(x) )
162 
163 
164 #define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
165 #define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
166 
167 
<a name="6" id="anc6"></a><span class="line-added">168   /*</span>
<span class="line-added">169    *    function      acts on      increases  does range   for    emits</span>
<span class="line-added">170    *                                pointer    checking   frames  error</span>
<span class="line-added">171    *  -------------------------------------------------------------------</span>
<span class="line-added">172    *   FT_PEEK_XXX  buffer pointer      no         no        no     no</span>
<span class="line-added">173    *   FT_NEXT_XXX  buffer pointer     yes         no        no     no</span>
<span class="line-added">174    *   FT_GET_XXX   stream-&gt;cursor     yes        yes       yes     no</span>
<span class="line-added">175    *   FT_READ_XXX  stream-&gt;pos        yes        yes        no    yes</span>
<span class="line-added">176    */</span>
<span class="line-added">177 </span>
<span class="line-added">178 </span>
<span class="line-added">179   /*</span>
<span class="line-added">180    * `FT_PEEK_XXX&#39; are generic macros to get data from a buffer position.  No</span>
<span class="line-added">181    * safety checks are performed.</span>
<span class="line-added">182    */</span>
183 #define FT_PEEK_SHORT( p )  FT_INT16( FT_BYTE_U16( p, 0, 8 ) | \
184                                       FT_BYTE_U16( p, 1, 0 ) )
185 
186 #define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
187                                         FT_BYTE_U16( p, 1, 0 ) )
188 
189 #define FT_PEEK_LONG( p )  FT_INT32( FT_BYTE_U32( p, 0, 24 ) | \
190                                      FT_BYTE_U32( p, 1, 16 ) | \
191                                      FT_BYTE_U32( p, 2,  8 ) | \
192                                      FT_BYTE_U32( p, 3,  0 ) )
193 
194 #define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
195                                        FT_BYTE_U32( p, 1, 16 ) | \
196                                        FT_BYTE_U32( p, 2,  8 ) | \
197                                        FT_BYTE_U32( p, 3,  0 ) )
198 
199 #define FT_PEEK_OFF3( p )  FT_INT32( FT_BYTE_U32( p, 0, 16 ) | \
200                                      FT_BYTE_U32( p, 1,  8 ) | \
201                                      FT_BYTE_U32( p, 2,  0 ) )
202 
203 #define FT_PEEK_UOFF3( p )  FT_UINT32( FT_BYTE_U32( p, 0, 16 ) | \
204                                        FT_BYTE_U32( p, 1,  8 ) | \
205                                        FT_BYTE_U32( p, 2,  0 ) )
206 
207 #define FT_PEEK_SHORT_LE( p )  FT_INT16( FT_BYTE_U16( p, 1, 8 ) | \
208                                          FT_BYTE_U16( p, 0, 0 ) )
209 
210 #define FT_PEEK_USHORT_LE( p )  FT_UINT16( FT_BYTE_U16( p, 1, 8 ) |  \
211                                            FT_BYTE_U16( p, 0, 0 ) )
212 
213 #define FT_PEEK_LONG_LE( p )  FT_INT32( FT_BYTE_U32( p, 3, 24 ) | \
214                                         FT_BYTE_U32( p, 2, 16 ) | \
215                                         FT_BYTE_U32( p, 1,  8 ) | \
216                                         FT_BYTE_U32( p, 0,  0 ) )
217 
218 #define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
219                                           FT_BYTE_U32( p, 2, 16 ) | \
220                                           FT_BYTE_U32( p, 1,  8 ) | \
221                                           FT_BYTE_U32( p, 0,  0 ) )
222 
223 #define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_BYTE_U32( p, 2, 16 ) | \
224                                         FT_BYTE_U32( p, 1,  8 ) | \
225                                         FT_BYTE_U32( p, 0,  0 ) )
226 
227 #define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
228                                           FT_BYTE_U32( p, 1,  8 ) | \
229                                           FT_BYTE_U32( p, 0,  0 ) )
230 
<a name="7" id="anc7"></a><span class="line-modified">231   /*</span>
<span class="line-added">232    * `FT_NEXT_XXX&#39; are generic macros to get data from a buffer position</span>
<span class="line-added">233    * which is then increased appropriately.  No safety checks are performed.</span>
<span class="line-added">234    */</span>
235 #define FT_NEXT_CHAR( buffer )       \
236           ( (signed char)*buffer++ )
237 
238 #define FT_NEXT_BYTE( buffer )         \
239           ( (unsigned char)*buffer++ )
240 
241 #define FT_NEXT_SHORT( buffer )                                   \
242           ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
243 
244 #define FT_NEXT_USHORT( buffer )                                            \
245           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
246 
247 #define FT_NEXT_OFF3( buffer )                                  \
248           ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
249 
250 #define FT_NEXT_UOFF3( buffer )                                           \
251           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
252 
253 #define FT_NEXT_LONG( buffer )                                  \
254           ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
255 
256 #define FT_NEXT_ULONG( buffer )                                           \
257           ( (unsigned long)( buffer += 4, FT_PEEK_ULONG( buffer - 4 ) ) )
258 
259 
260 #define FT_NEXT_SHORT_LE( buffer )                                   \
261           ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
262 
263 #define FT_NEXT_USHORT_LE( buffer )                                            \
264           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
265 
266 #define FT_NEXT_OFF3_LE( buffer )                                  \
267           ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
268 
269 #define FT_NEXT_UOFF3_LE( buffer )                                           \
270           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
271 
272 #define FT_NEXT_LONG_LE( buffer )                                  \
273           ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
274 
275 #define FT_NEXT_ULONG_LE( buffer )                                           \
276           ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
277 
278 
<a name="8" id="anc8"></a><span class="line-modified">279   /**************************************************************************</span>
<span class="line-modified">280    *</span>
<span class="line-modified">281    * The `FT_GET_XXX` macros use an implicit &#39;stream&#39; variable.</span>
<span class="line-modified">282    *</span>
<span class="line-added">283    * Note that a call to `FT_STREAM_SEEK` or `FT_STREAM_POS` has **no**</span>
<span class="line-added">284    * effect on `FT_GET_XXX`!  They operate on `stream-&gt;pos`, while</span>
<span class="line-added">285    * `FT_GET_XXX` use `stream-&gt;cursor`.</span>
<span class="line-added">286    */</span>
287 #if 0
288 #define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream-&gt;cursor )
289 
290 #define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
291 #define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
292 #define FT_GET_SHORT()      FT_GET_MACRO( SHORT )
293 #define FT_GET_USHORT()     FT_GET_MACRO( USHORT )
294 #define FT_GET_OFF3()       FT_GET_MACRO( OFF3 )
295 #define FT_GET_UOFF3()      FT_GET_MACRO( UOFF3 )
296 #define FT_GET_LONG()       FT_GET_MACRO( LONG )
297 #define FT_GET_ULONG()      FT_GET_MACRO( ULONG )
298 #define FT_GET_TAG4()       FT_GET_MACRO( ULONG )
299 
300 #define FT_GET_SHORT_LE()   FT_GET_MACRO( SHORT_LE )
301 #define FT_GET_USHORT_LE()  FT_GET_MACRO( USHORT_LE )
302 #define FT_GET_LONG_LE()    FT_GET_MACRO( LONG_LE )
303 #define FT_GET_ULONG_LE()   FT_GET_MACRO( ULONG_LE )
304 
305 #else
306 #define FT_GET_MACRO( func, type )        ( (type)func( stream ) )
307 
308 #define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
309 #define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
310 #define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )
311 #define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )
312 #define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )
313 #define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )
314 #define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )
315 #define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
316 #define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
317 
318 #define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )
319 #define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )
320 #define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )
321 #define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )
322 #endif
323 
<a name="9" id="anc9"></a><span class="line-added">324 </span>
325 #define FT_READ_MACRO( func, type, var )        \
326           ( var = (type)func( stream, &amp;error ), \
327             error != FT_Err_Ok )
328 
<a name="10" id="anc10"></a><span class="line-added">329   /*</span>
<span class="line-added">330    * The `FT_READ_XXX&#39; macros use implicit `stream&#39; and `error&#39; variables.</span>
<span class="line-added">331    *</span>
<span class="line-added">332    * `FT_READ_XXX&#39; can be controlled with `FT_STREAM_SEEK&#39; and</span>
<span class="line-added">333    * `FT_STREAM_POS&#39;.  They use the full machinery to check whether a read is</span>
<span class="line-added">334    * valid.</span>
<span class="line-added">335    */</span>
336 #define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
337 #define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
338 #define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )
339 #define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )
340 #define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )
341 #define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )
342 #define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )
343 #define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )
344 
345 #define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )
346 #define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )
347 #define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )
348 #define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )
349 
350 
351 #ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
352 
353   /* initialize a stream for reading a regular system stream */
354   FT_BASE( FT_Error )
355   FT_Stream_Open( FT_Stream    stream,
356                   const char*  filepathname );
357 
358 #endif /* FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM */
359 
360 
361   /* create a new (input) stream from an FT_Open_Args structure */
362   FT_BASE( FT_Error )
363   FT_Stream_New( FT_Library           library,
364                  const FT_Open_Args*  args,
365                  FT_Stream           *astream );
366 
367   /* free a stream */
368   FT_BASE( void )
369   FT_Stream_Free( FT_Stream  stream,
370                   FT_Int     external );
371 
372   /* initialize a stream for reading in-memory data */
373   FT_BASE( void )
374   FT_Stream_OpenMemory( FT_Stream       stream,
375                         const FT_Byte*  base,
376                         FT_ULong        size );
377 
378   /* close a stream (does not destroy the stream structure) */
379   FT_BASE( void )
380   FT_Stream_Close( FT_Stream  stream );
381 
382 
383   /* seek within a stream. position is relative to start of stream */
384   FT_BASE( FT_Error )
385   FT_Stream_Seek( FT_Stream  stream,
386                   FT_ULong   pos );
387 
388   /* skip bytes in a stream */
389   FT_BASE( FT_Error )
390   FT_Stream_Skip( FT_Stream  stream,
391                   FT_Long    distance );
392 
393   /* return current stream position */
394   FT_BASE( FT_ULong )
395   FT_Stream_Pos( FT_Stream  stream );
396 
397   /* read bytes from a stream into a user-allocated buffer, returns an */
398   /* error if not all bytes could be read.                             */
399   FT_BASE( FT_Error )
400   FT_Stream_Read( FT_Stream  stream,
401                   FT_Byte*   buffer,
402                   FT_ULong   count );
403 
404   /* read bytes from a stream at a given position */
405   FT_BASE( FT_Error )
406   FT_Stream_ReadAt( FT_Stream  stream,
407                     FT_ULong   pos,
408                     FT_Byte*   buffer,
409                     FT_ULong   count );
410 
411   /* try to read bytes at the end of a stream; return number of bytes */
412   /* really available                                                 */
413   FT_BASE( FT_ULong )
414   FT_Stream_TryRead( FT_Stream  stream,
415                      FT_Byte*   buffer,
416                      FT_ULong   count );
417 
418   /* Enter a frame of `count&#39; consecutive bytes in a stream.  Returns an */
419   /* error if the frame could not be read/accessed.  The caller can use  */
<a name="11" id="anc11"></a><span class="line-modified">420   /* the `FT_Stream_GetXXX&#39; functions to retrieve frame data without     */</span>
421   /* error checks.                                                       */
422   /*                                                                     */
<a name="12" id="anc12"></a><span class="line-modified">423   /* You must _always_ call `FT_Stream_ExitFrame&#39; once you have entered  */</span>
424   /* a stream frame!                                                     */
425   /*                                                                     */
<a name="13" id="anc13"></a><span class="line-added">426   /* Nested frames are not permitted.                                    */</span>
<span class="line-added">427   /*                                                                     */</span>
428   FT_BASE( FT_Error )
429   FT_Stream_EnterFrame( FT_Stream  stream,
430                         FT_ULong   count );
431 
432   /* exit a stream frame */
433   FT_BASE( void )
434   FT_Stream_ExitFrame( FT_Stream  stream );
435 
<a name="14" id="anc14"></a><span class="line-added">436 </span>
437   /* Extract a stream frame.  If the stream is disk-based, a heap block */
438   /* is allocated and the frame bytes are read into it.  If the stream  */
<a name="15" id="anc15"></a><span class="line-modified">439   /* is memory-based, this function simply sets a pointer to the data.  */</span>
440   /*                                                                    */
441   /* Useful to optimize access to memory-based streams transparently.   */
442   /*                                                                    */
<a name="16" id="anc16"></a><span class="line-modified">443   /* `FT_Stream_GetXXX&#39; functions can&#39;t be used.                        */</span>
<span class="line-modified">444   /*                                                                    */</span>
<span class="line-added">445   /* An extracted frame must be `freed&#39; with a call to the function     */</span>
<span class="line-added">446   /* `FT_Stream_ReleaseFrame&#39;.                                          */</span>
447   /*                                                                    */
448   FT_BASE( FT_Error )
449   FT_Stream_ExtractFrame( FT_Stream  stream,
450                           FT_ULong   count,
451                           FT_Byte**  pbytes );
452 
<a name="17" id="anc17"></a><span class="line-modified">453   /* release an extract frame (see `FT_Stream_ExtractFrame&#39;) */</span>
454   FT_BASE( void )
455   FT_Stream_ReleaseFrame( FT_Stream  stream,
456                           FT_Byte**  pbytes );
457 
<a name="18" id="anc18"></a><span class="line-added">458 </span>
459   /* read a byte from an entered frame */
460   FT_BASE( FT_Char )
461   FT_Stream_GetChar( FT_Stream  stream );
462 
463   /* read a 16-bit big-endian unsigned integer from an entered frame */
464   FT_BASE( FT_UShort )
465   FT_Stream_GetUShort( FT_Stream  stream );
466 
467   /* read a 24-bit big-endian unsigned integer from an entered frame */
468   FT_BASE( FT_ULong )
469   FT_Stream_GetUOffset( FT_Stream  stream );
470 
471   /* read a 32-bit big-endian unsigned integer from an entered frame */
472   FT_BASE( FT_ULong )
473   FT_Stream_GetULong( FT_Stream  stream );
474 
475   /* read a 16-bit little-endian unsigned integer from an entered frame */
476   FT_BASE( FT_UShort )
477   FT_Stream_GetUShortLE( FT_Stream  stream );
478 
479   /* read a 32-bit little-endian unsigned integer from an entered frame */
480   FT_BASE( FT_ULong )
481   FT_Stream_GetULongLE( FT_Stream  stream );
482 
483 
484   /* read a byte from a stream */
485   FT_BASE( FT_Char )
486   FT_Stream_ReadChar( FT_Stream  stream,
487                       FT_Error*  error );
488 
489   /* read a 16-bit big-endian unsigned integer from a stream */
490   FT_BASE( FT_UShort )
491   FT_Stream_ReadUShort( FT_Stream  stream,
492                         FT_Error*  error );
493 
494   /* read a 24-bit big-endian unsigned integer from a stream */
495   FT_BASE( FT_ULong )
496   FT_Stream_ReadUOffset( FT_Stream  stream,
497                          FT_Error*  error );
498 
499   /* read a 32-bit big-endian integer from a stream */
500   FT_BASE( FT_ULong )
501   FT_Stream_ReadULong( FT_Stream  stream,
502                        FT_Error*  error );
503 
504   /* read a 16-bit little-endian unsigned integer from a stream */
505   FT_BASE( FT_UShort )
506   FT_Stream_ReadUShortLE( FT_Stream  stream,
507                           FT_Error*  error );
508 
509   /* read a 32-bit little-endian unsigned integer from a stream */
510   FT_BASE( FT_ULong )
511   FT_Stream_ReadULongLE( FT_Stream  stream,
512                          FT_Error*  error );
513 
514   /* Read a structure from a stream.  The structure must be described */
515   /* by an array of FT_Frame_Field records.                           */
516   FT_BASE( FT_Error )
517   FT_Stream_ReadFields( FT_Stream              stream,
518                         const FT_Frame_Field*  fields,
519                         void*                  structure );
520 
521 
522 #define FT_STREAM_POS()           \
523           FT_Stream_Pos( stream )
524 
525 #define FT_STREAM_SEEK( position )                               \
526           FT_SET_ERROR( FT_Stream_Seek( stream,                  \
527                                         (FT_ULong)(position) ) )
528 
529 #define FT_STREAM_SKIP( distance )                              \
530           FT_SET_ERROR( FT_Stream_Skip( stream,                 \
531                                         (FT_Long)(distance) ) )
532 
533 #define FT_STREAM_READ( buffer, count )                       \
534           FT_SET_ERROR( FT_Stream_Read( stream,               \
535                                         (FT_Byte*)(buffer),   \
536                                         (FT_ULong)(count) ) )
537 
538 #define FT_STREAM_READ_AT( position, buffer, count )            \
539           FT_SET_ERROR( FT_Stream_ReadAt( stream,               \
540                                           (FT_ULong)(position), \
541                                           (FT_Byte*)(buffer),   \
542                                           (FT_ULong)(count) ) )
543 
544 #define FT_STREAM_READ_FIELDS( fields, object )                          \
545           FT_SET_ERROR( FT_Stream_ReadFields( stream, fields, object ) )
546 
547 
548 #define FT_FRAME_ENTER( size )                                           \
549           FT_SET_ERROR(                                                  \
550             FT_DEBUG_INNER( FT_Stream_EnterFrame( stream,                \
551                                                   (FT_ULong)(size) ) ) )
552 
553 #define FT_FRAME_EXIT()                                   \
554           FT_DEBUG_INNER( FT_Stream_ExitFrame( stream ) )
555 
556 #define FT_FRAME_EXTRACT( size, bytes )                                       \
557           FT_SET_ERROR(                                                       \
558             FT_DEBUG_INNER( FT_Stream_ExtractFrame( stream,                   \
559                                                     (FT_ULong)(size),         \
560                                                     (FT_Byte**)&amp;(bytes) ) ) )
561 
562 #define FT_FRAME_RELEASE( bytes )                                         \
563           FT_DEBUG_INNER( FT_Stream_ReleaseFrame( stream,                 \
564                                                   (FT_Byte**)&amp;(bytes) ) )
565 
566 
567 FT_END_HEADER
568 
569 #endif /* FTSTREAM_H_ */
570 
571 
572 /* END */
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afblue.hin.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  afcjk.c                                                                */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Auto-fitter hinting routines for CJK writing system (body).          */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2006-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18   /*
<span class="line-modified">  19    *  The algorithm is based on akito&#39;s autohint patch, archived at</span>
  20    *
<span class="line-modified">  21    *  https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
  22    *
  23    */
  24 
  25 #include &lt;ft2build.h&gt;
  26 #include FT_ADVANCES_H
  27 #include FT_INTERNAL_DEBUG_H
  28 
  29 #include &quot;afglobal.h&quot;
<span class="line-removed">  30 #include &quot;afpic.h&quot;</span>
  31 #include &quot;aflatin.h&quot;
  32 #include &quot;afcjk.h&quot;
  33 
  34 
  35 #ifdef AF_CONFIG_OPTION_CJK
  36 
  37 #undef AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT
  38 
  39 #include &quot;aferrors.h&quot;
  40 
  41 
  42 #ifdef AF_CONFIG_OPTION_USE_WARPER
  43 #include &quot;afwarp.h&quot;
  44 #endif
  45 
  46 
<span class="line-modified">  47   /*************************************************************************/</span>
<span class="line-modified">  48   /*                                                                       */</span>
<span class="line-modified">  49   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  50   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  51   /* messages during execution.                                            */</span>
<span class="line-modified">  52   /*                                                                       */</span>
  53 #undef  FT_COMPONENT
<span class="line-modified">  54 #define FT_COMPONENT  trace_afcjk</span>
  55 
  56 
  57   /*************************************************************************/
  58   /*************************************************************************/
  59   /*****                                                               *****/
  60   /*****              C J K   G L O B A L   M E T R I C S              *****/
  61   /*****                                                               *****/
  62   /*************************************************************************/
  63   /*************************************************************************/
  64 
  65 
  66   /* Basically the Latin version with AF_CJKMetrics */
  67   /* to replace AF_LatinMetrics.                    */
  68 
  69   FT_LOCAL_DEF( void )
  70   af_cjk_metrics_init_widths( AF_CJKMetrics  metrics,
  71                               FT_Face        face )
  72   {
  73     /* scan the array of segments in each direction */
  74     AF_GlyphHintsRec  hints[1];
  75 
  76 
  77     FT_TRACE5(( &quot;\n&quot;
  78                 &quot;cjk standard widths computation (style `%s&#39;)\n&quot;
  79                 &quot;===================================================\n&quot;
  80                 &quot;\n&quot;,
  81                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
  82 
  83     af_glyph_hints_init( hints, face-&gt;memory );
  84 
  85     metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;
  86     metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;
  87 
  88     {
  89       FT_Error          error;
  90       FT_ULong          glyph_index;
  91       int               dim;
  92       AF_CJKMetricsRec  dummy[1];
  93       AF_Scaler         scaler = &amp;dummy-&gt;root.scaler;
  94 
<span class="line-removed">  95 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">  96       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-removed">  97 #endif</span>
<span class="line-removed">  98 </span>
  99       AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified"> 100       AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-modified"> 101                                        [style_class-&gt;script];</span>








 102 
<span class="line-removed"> 103       void*        shaper_buf;</span>
 104       const char*  p;
 105 
 106 #ifdef FT_DEBUG_LEVEL_TRACE
 107       FT_ULong  ch = 0;
 108 #endif
 109 
<span class="line-modified"> 110       p          = script_class-&gt;standard_charstring;</span>


 111       shaper_buf = af_shaper_buf_create( face );

 112 
 113       /* We check a list of standard characters.  The first match wins. */
 114 
 115       glyph_index = 0;
 116       while ( *p )
 117       {
 118         unsigned int  num_idx;
 119 
 120 #ifdef FT_DEBUG_LEVEL_TRACE
 121         const char*  p_old;
 122 #endif
 123 
 124 
 125         while ( *p == &#39; &#39; )
 126           p++;
 127 
 128 #ifdef FT_DEBUG_LEVEL_TRACE
 129         p_old = p;
 130         GET_UTF8_CHAR( ch, p_old );
 131 #endif
</pre>
<hr />
<pre>
 176       af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
 177 
 178       error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );
 179       if ( error )
 180         goto Exit;
 181 
 182       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 183       {
 184         AF_CJKAxis    axis    = &amp;metrics-&gt;axis[dim];
 185         AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];
 186         AF_Segment    seg, limit, link;
 187         FT_UInt       num_widths = 0;
 188 
 189 
 190         error = af_latin_hints_compute_segments( hints,
 191                                                  (AF_Dimension)dim );
 192         if ( error )
 193           goto Exit;
 194 
 195         /*
<span class="line-modified"> 196          *  We assume that the glyphs selected for the stem width</span>
<span class="line-modified"> 197          *  computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified"> 198          *  algorithm works fine without adjustments of its scoring</span>
<span class="line-modified"> 199          *  function.</span>
 200          */
 201         af_latin_hints_link_segments( hints,
 202                                       0,
 203                                       NULL,
 204                                       (AF_Dimension)dim );
 205 
 206         seg   = axhints-&gt;segments;
 207         limit = seg + axhints-&gt;num_segments;
 208 
 209         for ( ; seg &lt; limit; seg++ )
 210         {
 211           link = seg-&gt;link;
 212 
 213           /* we only consider stem segments there! */
 214           if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )
 215           {
 216             FT_Pos  dist;
 217 
 218 
 219             dist = seg-&gt;pos - link-&gt;pos;
</pre>
<hr />
<pre>
 279                              FT_Face        face )
 280   {
 281     FT_Pos      fills[AF_BLUE_STRING_MAX_LEN];
 282     FT_Pos      flats[AF_BLUE_STRING_MAX_LEN];
 283 
 284     FT_UInt     num_fills;
 285     FT_UInt     num_flats;
 286 
 287     FT_Bool     fill;
 288 
 289     AF_CJKBlue  blue;
 290     FT_Error    error;
 291     AF_CJKAxis  axis;
 292     FT_Outline  outline;
 293 
 294     AF_StyleClass  sc = metrics-&gt;root.style_class;
 295 
 296     AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
 297     const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
 298 
<span class="line-modified"> 299     void*  shaper_buf;</span>







 300 
 301 
 302     /* we walk over the blue character strings as specified in the   */
 303     /* style&#39;s entry in the `af_blue_stringset&#39; array, computing its */
 304     /* extremum points (depending on the string properties)          */
 305 
 306     FT_TRACE5(( &quot;cjk blue zones computation\n&quot;
 307                 &quot;==========================\n&quot;
 308                 &quot;\n&quot; ));
 309 

 310     shaper_buf = af_shaper_buf_create( face );

 311 
 312     for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
 313     {
 314       const char*  p = &amp;af_blue_strings[bs-&gt;string];
 315       FT_Pos*      blue_ref;
 316       FT_Pos*      blue_shoot;
 317 
 318 
 319       if ( AF_CJK_IS_HORIZ_BLUE( bs ) )
 320         axis = &amp;metrics-&gt;axis[AF_DIMENSION_HORZ];
 321       else
 322         axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
 323 
 324 #ifdef FT_DEBUG_LEVEL_TRACE
 325       {
 326         FT_String*  cjk_blue_name[4] =
 327         {
 328           (FT_String*)&quot;bottom&quot;,    /* --   , --  */
 329           (FT_String*)&quot;top&quot;,       /* --   , TOP */
 330           (FT_String*)&quot;left&quot;,      /* HORIZ, --  */
</pre>
<hr />
<pre>
 466                     best_point = pp;
 467                     best_pos   = points[pp].y;
 468                   }
 469               }
 470             }
 471           }
 472 
 473           FT_TRACE5(( &quot;  U+%04lX: best_pos = %5ld\n&quot;, ch, best_pos ));
 474         }
 475 
 476         if ( fill )
 477           fills[num_fills++] = best_pos;
 478         else
 479           flats[num_flats++] = best_pos;
 480 
 481       } /* end while loop */
 482 
 483       if ( num_flats == 0 &amp;&amp; num_fills == 0 )
 484       {
 485         /*
<span class="line-modified"> 486          *  we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified"> 487          *  we will simply ignore it then</span>
 488          */
 489         FT_TRACE5(( &quot;  empty\n&quot; ));
 490         continue;
 491       }
 492 
 493       /* we have computed the contents of the `fill&#39; and `flats&#39; tables,   */
 494       /* now determine the reference and overshoot position of the blue -- */
 495       /* we simply take the median value after a simple sort               */
 496       af_sort_pos( num_fills, fills );
 497       af_sort_pos( num_flats, flats );
 498 
 499       blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];
 500       blue_ref   = &amp;blue-&gt;ref.org;
 501       blue_shoot = &amp;blue-&gt;shoot.org;
 502 
 503       axis-&gt;blue_count++;
 504 
 505       if ( num_flats == 0 )
 506       {
 507         *blue_ref   =
</pre>
<hr />
<pre>
 548 
 549     } /* end for loop */
 550 
 551     af_shaper_buf_destroy( face, shaper_buf );
 552 
 553     FT_TRACE5(( &quot;\n&quot; ));
 554 
 555     return;
 556   }
 557 
 558 
 559   /* Basically the Latin version with type AF_CJKMetrics for metrics. */
 560 
 561   FT_LOCAL_DEF( void )
 562   af_cjk_metrics_check_digits( AF_CJKMetrics  metrics,
 563                                FT_Face        face )
 564   {
 565     FT_Bool   started = 0, same_width = 1;
 566     FT_Fixed  advance = 0, old_advance = 0;
 567 
<span class="line-modified"> 568     void*  shaper_buf;</span>







 569 
 570     /* in all supported charmaps, digits have character codes 0x30-0x39 */
 571     const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
 572     const char*  p;
 573 
 574 
<span class="line-modified"> 575     p          = digits;</span>


 576     shaper_buf = af_shaper_buf_create( face );

 577 
 578     while ( *p )
 579     {
 580       FT_ULong      glyph_index;
 581       unsigned int  num_idx;
 582 
 583 
 584       /* reject input that maps to more than a single glyph */
 585       p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 586       if ( num_idx &gt; 1 )
 587         continue;
 588 
 589       glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 590                                         shaper_buf,
 591                                         0,
 592                                         &amp;advance,
 593                                         NULL );
 594       if ( !glyph_index )
 595         continue;
 596 
</pre>
<hr />
<pre>
 873                    ( dist * 8 &lt; seg1-&gt;score * 7 || seg1-&gt;len &lt; len ) )
 874               {
 875                 seg1-&gt;score = dist;
 876                 seg1-&gt;len   = len;
 877                 seg1-&gt;link  = seg2;
 878               }
 879 
 880               if ( dist * 8 &lt; seg2-&gt;score * 9                        &amp;&amp;
 881                    ( dist * 8 &lt; seg2-&gt;score * 7 || seg2-&gt;len &lt; len ) )
 882               {
 883                 seg2-&gt;score = dist;
 884                 seg2-&gt;len   = len;
 885                 seg2-&gt;link  = seg1;
 886               }
 887             }
 888           }
 889         }
 890     }
 891 
 892     /*
<span class="line-modified"> 893      *  now compute the `serif&#39; segments</span>
 894      *
<span class="line-modified"> 895      *  In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="line-modified"> 896      *  We either identify the stems on the ends as serifs or remove</span>
<span class="line-modified"> 897      *  the linkage, depending on the length of the stems.</span>
 898      *
 899      */
 900 
 901     {
 902       AF_Segment  link1, link2;
 903 
 904 
 905       for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )
 906       {
 907         link1 = seg1-&gt;link;
 908         if ( !link1 || link1-&gt;link != seg1 || link1-&gt;pos &lt;= seg1-&gt;pos )
 909           continue;
 910 
 911         if ( seg1-&gt;score &gt;= dist_threshold )
 912           continue;
 913 
 914         for ( seg2 = segments; seg2 &lt; segment_limit; seg2++ )
 915         {
 916           if ( seg2-&gt;pos &gt; seg1-&gt;pos || seg1 == seg2 )
 917             continue;
</pre>
<hr />
<pre>
 983                               AF_Dimension   dim )
 984   {
 985     AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
 986     FT_Error      error  = FT_Err_Ok;
 987     FT_Memory     memory = hints-&gt;memory;
 988     AF_CJKAxis    laxis  = &amp;((AF_CJKMetrics)hints-&gt;metrics)-&gt;axis[dim];
 989 
 990     AF_Segment    segments      = axis-&gt;segments;
 991     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
 992     AF_Segment    seg;
 993 
 994     FT_Fixed      scale;
 995     FT_Pos        edge_distance_threshold;
 996 
 997 
 998     axis-&gt;num_edges = 0;
 999 
1000     scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
1001                                          : hints-&gt;y_scale;
1002 
<span class="line-modified">1003     /*********************************************************************/</span>
<span class="line-modified">1004     /*                                                                   */</span>
<span class="line-modified">1005     /* We begin by generating a sorted table of edges for the current    */</span>
<span class="line-modified">1006     /* direction.  To do so, we simply scan each segment and try to find */</span>
<span class="line-modified">1007     /* an edge in our table that corresponds to its position.            */</span>
<span class="line-modified">1008     /*                                                                   */</span>
<span class="line-modified">1009     /* If no edge is found, we create and insert a new edge in the       */</span>
<span class="line-modified">1010     /* sorted table.  Otherwise, we simply add the segment to the edge&#39;s */</span>
<span class="line-modified">1011     /* list which is then processed in the second step to compute the    */</span>
<span class="line-modified">1012     /* edge&#39;s properties.                                                */</span>
<span class="line-modified">1013     /*                                                                   */</span>
<span class="line-modified">1014     /* Note that the edges table is sorted along the segment/edge        */</span>
<span class="line-modified">1015     /* position.                                                         */</span>
<span class="line-modified">1016     /*                                                                   */</span>
<span class="line-modified">1017     /*********************************************************************/</span>
1018 
1019     edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
1020                                          scale );
1021     if ( edge_distance_threshold &gt; 64 / 4 )
1022       edge_distance_threshold = FT_DivFix( 64 / 4, scale );
1023     else
1024       edge_distance_threshold = laxis-&gt;edge_distance_threshold;
1025 
1026     for ( seg = segments; seg &lt; segment_limit; seg++ )
1027     {
1028       AF_Edge  found = NULL;
1029       FT_Pos   best  = 0xFFFFU;
1030       FT_Int   ee;
1031 
1032 
1033       /* look for an edge corresponding to the segment */
1034       for ( ee = 0; ee &lt; axis-&gt;num_edges; ee++ )
1035       {
1036         AF_Edge  edge = axis-&gt;edges + ee;
1037         FT_Pos   dist;
</pre>
<hr />
<pre>
1097         FT_ZERO( edge );
1098 
1099         edge-&gt;first    = seg;
1100         edge-&gt;last     = seg;
1101         edge-&gt;dir      = seg-&gt;dir;
1102         edge-&gt;fpos     = seg-&gt;pos;
1103         edge-&gt;opos     = FT_MulFix( seg-&gt;pos, scale );
1104         edge-&gt;pos      = edge-&gt;opos;
1105         seg-&gt;edge_next = seg;
1106       }
1107       else
1108       {
1109         /* if an edge was found, simply add the segment to the edge&#39;s */
1110         /* list                                                       */
1111         seg-&gt;edge_next         = found-&gt;first;
1112         found-&gt;last-&gt;edge_next = seg;
1113         found-&gt;last            = seg;
1114       }
1115     }
1116 
<span class="line-modified">1117     /******************************************************************/</span>
<span class="line-modified">1118     /*                                                                */</span>
<span class="line-modified">1119     /* Good, we now compute each edge&#39;s properties according to the   */</span>
<span class="line-modified">1120     /* segments found on its position.  Basically, these are          */</span>
<span class="line-modified">1121     /*                                                                */</span>
<span class="line-modified">1122     /*  - the edge&#39;s main direction                                   */</span>
<span class="line-modified">1123     /*  - stem edge, serif edge or both (which defaults to stem then) */</span>
<span class="line-modified">1124     /*  - rounded edge, straight or both (which defaults to straight) */</span>
<span class="line-modified">1125     /*  - link for edge                                               */</span>
<span class="line-modified">1126     /*                                                                */</span>
<span class="line-modified">1127     /******************************************************************/</span>
1128 
1129     /* first of all, set the `edge&#39; field in each segment -- this is */
1130     /* required in order to compute edge links                       */
1131 
1132     /*
1133      * Note that removing this loop and setting the `edge&#39; field of each
1134      * segment directly in the code above slows down execution speed for
1135      * some reasons on platforms like the Sun.
1136      */
1137     {
1138       AF_Edge  edges      = axis-&gt;edges;
1139       AF_Edge  edge_limit = edges + axis-&gt;num_edges;
1140       AF_Edge  edge;
1141 
1142 
1143       for ( edge = edges; edge &lt; edge_limit; edge++ )
1144       {
1145         seg = edge-&gt;first;
1146         if ( seg )
1147           do
1148           {
1149             seg-&gt;edge = edge;
1150             seg       = seg-&gt;edge_next;
1151 
1152           } while ( seg != edge-&gt;first );
1153       }
1154 
1155       /* now compute each edge properties */
1156       for ( edge = edges; edge &lt; edge_limit; edge++ )
1157       {
1158         FT_Int  is_round    = 0;  /* does it contain round segments?    */
1159         FT_Int  is_straight = 0;  /* does it contain straight segments? */
1160 
1161 
1162         seg = edge-&gt;first;


1163 
1164         do
1165         {
1166           FT_Bool  is_serif;
1167 
1168 
1169           /* check for roundness of segment */
1170           if ( seg-&gt;flags &amp; AF_EDGE_ROUND )
1171             is_round++;
1172           else
1173             is_straight++;
1174 
1175           /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
1176           /* be ignored                                                   */
<span class="line-modified">1177           is_serif = (FT_Bool)( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
1178 
1179           if ( seg-&gt;link || is_serif )
1180           {
1181             AF_Edge     edge2;
1182             AF_Segment  seg2;
1183 
1184 
1185             edge2 = edge-&gt;link;
1186             seg2  = seg-&gt;link;
1187 
1188             if ( is_serif )
1189             {
1190               seg2  = seg-&gt;serif;
1191               edge2 = edge-&gt;serif;
1192             }
1193 
1194             if ( edge2 )
1195             {
1196               FT_Pos  edge_delta;
1197               FT_Pos  seg_delta;
1198 
1199 
1200               edge_delta = edge-&gt;fpos - edge2-&gt;fpos;
1201               if ( edge_delta &lt; 0 )
1202                 edge_delta = -edge_delta;
1203 
1204               seg_delta = AF_SEGMENT_DIST( seg, seg2 );
1205 
1206               if ( seg_delta &lt; edge_delta )
1207                 edge2 = seg2-&gt;edge;
1208             }
1209             else
1210               edge2 = seg2-&gt;edge;
1211 
1212             if ( is_serif )
1213             {
1214               edge-&gt;serif   = edge2;
1215               edge2-&gt;flags |= AF_EDGE_SERIF;
1216             }
1217             else
<span class="line-modified">1218               edge-&gt;link  = edge2;</span>
1219           }
1220 
1221           seg = seg-&gt;edge_next;
1222 
1223         } while ( seg != edge-&gt;first );
1224 

1225         /* set the round/straight flags */
1226         edge-&gt;flags = AF_EDGE_NORMAL;
1227 
1228         if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
1229           edge-&gt;flags |= AF_EDGE_ROUND;
1230 
1231         /* get rid of serifs if link is set                 */
1232         /* XXX: This gets rid of many unpleasant artefacts! */
1233         /*      Example: the `c&#39; in cour.pfa at size 13     */
1234 
1235         if ( edge-&gt;serif &amp;&amp; edge-&gt;link )
1236           edge-&gt;serif = NULL;
1237       }
1238     }
1239 
1240   Exit:
1241     return error;
1242   }
1243 
1244 
</pre>
<hr />
<pre>
1347 
1348       if ( best_blue )
1349         edge-&gt;blue_edge = best_blue;
1350     }
1351   }
1352 
1353 
1354   /* Initalize hinting engine. */
1355 
1356   FT_LOCAL_DEF( FT_Error )
1357   af_cjk_hints_init( AF_GlyphHints  hints,
1358                      AF_CJKMetrics  metrics )
1359   {
1360     FT_Render_Mode  mode;
1361     FT_UInt32       scaler_flags, other_flags;
1362 
1363 
1364     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
1365 
1366     /*
<span class="line-modified">1367      *  correct x_scale and y_scale when needed, since they may have</span>
<span class="line-modified">1368      *  been modified af_cjk_scale_dim above</span>
1369      */
1370     hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
1371     hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
1372     hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
1373     hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
1374 
1375     /* compute flags depending on render mode, etc. */
1376     mode = metrics-&gt;root.scaler.render_mode;
1377 
1378 #if 0 /* AF_CONFIG_OPTION_USE_WARPER */
1379     if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
1380       metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
1381 #endif
1382 
1383     scaler_flags = hints-&gt;scaler_flags;
1384     other_flags  = 0;
1385 
1386     /*
<span class="line-modified">1387      *  We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">1388      *  horizontal LCD rendering targets only.</span>
1389      */
1390     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
1391       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
1392 
1393     /*
<span class="line-modified">1394      *  We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">1395      *  vertical LCD rendering targets only.</span>
1396      */
1397     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
1398       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
1399 
1400     /*
<span class="line-modified">1401      *  We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
1402      */
1403     if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
1404       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
1405 
1406     if ( mode == FT_RENDER_MODE_MONO )
1407       other_flags |= AF_LATIN_HINTS_MONO;
1408 
1409     scaler_flags |= AF_SCALER_FLAG_NO_ADVANCE;
1410 
1411 #ifdef AF_CONFIG_OPTION_USE_WARPER
1412     /* get (global) warper flag */
1413     if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )
1414       scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
1415 #endif
1416 
1417     hints-&gt;scaler_flags = scaler_flags;
1418     hints-&gt;other_flags  = other_flags;
1419 
1420     return FT_Err_Ok;
1421   }
</pre>
<hr />
<pre>
2077         if ( edge3-&gt;link )
2078           edge3-&gt;link-&gt;pos -= delta;
2079 
2080         /* move the serifs along with the stem */
2081         if ( n_edges == 12 )
2082         {
2083           ( edges + 8 )-&gt;pos -= delta;
2084           ( edges + 11 )-&gt;pos -= delta;
2085         }
2086 
2087         edge3-&gt;flags |= AF_EDGE_DONE;
2088         if ( edge3-&gt;link )
2089           edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;
2090       }
2091     }
2092 
2093     if ( !skipped )
2094       goto Exit;
2095 
2096     /*
<span class="line-modified">2097      *  now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">2098      *  to complete our processing</span>
2099      */
2100     for ( edge = edges; edge &lt; edge_limit; edge++ )
2101     {
2102       if ( edge-&gt;flags &amp; AF_EDGE_DONE )
2103         continue;
2104 
2105       if ( edge-&gt;serif )
2106       {
2107         af_cjk_align_serif_edge( hints, edge-&gt;serif, edge );
2108         edge-&gt;flags |= AF_EDGE_DONE;
2109         skipped--;
2110       }
2111     }
2112 
2113     if ( !skipped )
2114       goto Exit;
2115 
2116     for ( edge = edges; edge &lt; edge_limit; edge++ )
2117     {
2118       AF_Edge  before, after;
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * afcjk.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auto-fitter hinting routines for CJK writing system (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2006-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18   /*
<span class="line-modified">  19    * The algorithm is based on akito&#39;s autohint patch, archived at</span>
  20    *
<span class="line-modified">  21    * https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
  22    *
  23    */
  24 
  25 #include &lt;ft2build.h&gt;
  26 #include FT_ADVANCES_H
  27 #include FT_INTERNAL_DEBUG_H
  28 
  29 #include &quot;afglobal.h&quot;

  30 #include &quot;aflatin.h&quot;
  31 #include &quot;afcjk.h&quot;
  32 
  33 
  34 #ifdef AF_CONFIG_OPTION_CJK
  35 
  36 #undef AF_CONFIG_OPTION_CJK_BLUE_HANI_VERT
  37 
  38 #include &quot;aferrors.h&quot;
  39 
  40 
  41 #ifdef AF_CONFIG_OPTION_USE_WARPER
  42 #include &quot;afwarp.h&quot;
  43 #endif
  44 
  45 
<span class="line-modified">  46   /**************************************************************************</span>
<span class="line-modified">  47    *</span>
<span class="line-modified">  48    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  49    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  50    * messages during execution.</span>
<span class="line-modified">  51    */</span>
  52 #undef  FT_COMPONENT
<span class="line-modified">  53 #define FT_COMPONENT  afcjk</span>
  54 
  55 
  56   /*************************************************************************/
  57   /*************************************************************************/
  58   /*****                                                               *****/
  59   /*****              C J K   G L O B A L   M E T R I C S              *****/
  60   /*****                                                               *****/
  61   /*************************************************************************/
  62   /*************************************************************************/
  63 
  64 
  65   /* Basically the Latin version with AF_CJKMetrics */
  66   /* to replace AF_LatinMetrics.                    */
  67 
  68   FT_LOCAL_DEF( void )
  69   af_cjk_metrics_init_widths( AF_CJKMetrics  metrics,
  70                               FT_Face        face )
  71   {
  72     /* scan the array of segments in each direction */
  73     AF_GlyphHintsRec  hints[1];
  74 
  75 
  76     FT_TRACE5(( &quot;\n&quot;
  77                 &quot;cjk standard widths computation (style `%s&#39;)\n&quot;
  78                 &quot;===================================================\n&quot;
  79                 &quot;\n&quot;,
  80                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
  81 
  82     af_glyph_hints_init( hints, face-&gt;memory );
  83 
  84     metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;
  85     metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;
  86 
  87     {
  88       FT_Error          error;
  89       FT_ULong          glyph_index;
  90       int               dim;
  91       AF_CJKMetricsRec  dummy[1];
  92       AF_Scaler         scaler = &amp;dummy-&gt;root.scaler;
  93 




  94       AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">  95       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="line-modified">  96 </span>
<span class="line-added">  97       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">  98       /* unsigned long value.                                        */</span>
<span class="line-added">  99 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 100       void*     shaper_buf;</span>
<span class="line-added"> 101 #else</span>
<span class="line-added"> 102       FT_ULong  shaper_buf_;</span>
<span class="line-added"> 103       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added"> 104 #endif</span>
 105 

 106       const char*  p;
 107 
 108 #ifdef FT_DEBUG_LEVEL_TRACE
 109       FT_ULong  ch = 0;
 110 #endif
 111 
<span class="line-modified"> 112       p = script_class-&gt;standard_charstring;</span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
 115       shaper_buf = af_shaper_buf_create( face );
<span class="line-added"> 116 #endif</span>
 117 
 118       /* We check a list of standard characters.  The first match wins. */
 119 
 120       glyph_index = 0;
 121       while ( *p )
 122       {
 123         unsigned int  num_idx;
 124 
 125 #ifdef FT_DEBUG_LEVEL_TRACE
 126         const char*  p_old;
 127 #endif
 128 
 129 
 130         while ( *p == &#39; &#39; )
 131           p++;
 132 
 133 #ifdef FT_DEBUG_LEVEL_TRACE
 134         p_old = p;
 135         GET_UTF8_CHAR( ch, p_old );
 136 #endif
</pre>
<hr />
<pre>
 181       af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
 182 
 183       error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );
 184       if ( error )
 185         goto Exit;
 186 
 187       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 188       {
 189         AF_CJKAxis    axis    = &amp;metrics-&gt;axis[dim];
 190         AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];
 191         AF_Segment    seg, limit, link;
 192         FT_UInt       num_widths = 0;
 193 
 194 
 195         error = af_latin_hints_compute_segments( hints,
 196                                                  (AF_Dimension)dim );
 197         if ( error )
 198           goto Exit;
 199 
 200         /*
<span class="line-modified"> 201          * We assume that the glyphs selected for the stem width</span>
<span class="line-modified"> 202          * computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified"> 203          * algorithm works fine without adjustments of its scoring</span>
<span class="line-modified"> 204          * function.</span>
 205          */
 206         af_latin_hints_link_segments( hints,
 207                                       0,
 208                                       NULL,
 209                                       (AF_Dimension)dim );
 210 
 211         seg   = axhints-&gt;segments;
 212         limit = seg + axhints-&gt;num_segments;
 213 
 214         for ( ; seg &lt; limit; seg++ )
 215         {
 216           link = seg-&gt;link;
 217 
 218           /* we only consider stem segments there! */
 219           if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )
 220           {
 221             FT_Pos  dist;
 222 
 223 
 224             dist = seg-&gt;pos - link-&gt;pos;
</pre>
<hr />
<pre>
 284                              FT_Face        face )
 285   {
 286     FT_Pos      fills[AF_BLUE_STRING_MAX_LEN];
 287     FT_Pos      flats[AF_BLUE_STRING_MAX_LEN];
 288 
 289     FT_UInt     num_fills;
 290     FT_UInt     num_flats;
 291 
 292     FT_Bool     fill;
 293 
 294     AF_CJKBlue  blue;
 295     FT_Error    error;
 296     AF_CJKAxis  axis;
 297     FT_Outline  outline;
 298 
 299     AF_StyleClass  sc = metrics-&gt;root.style_class;
 300 
 301     AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
 302     const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
 303 
<span class="line-modified"> 304     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added"> 305     /* unsigned long value.                                        */</span>
<span class="line-added"> 306 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 307     void*     shaper_buf;</span>
<span class="line-added"> 308 #else</span>
<span class="line-added"> 309     FT_ULong  shaper_buf_;</span>
<span class="line-added"> 310     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added"> 311 #endif</span>
 312 
 313 
 314     /* we walk over the blue character strings as specified in the   */
 315     /* style&#39;s entry in the `af_blue_stringset&#39; array, computing its */
 316     /* extremum points (depending on the string properties)          */
 317 
 318     FT_TRACE5(( &quot;cjk blue zones computation\n&quot;
 319                 &quot;==========================\n&quot;
 320                 &quot;\n&quot; ));
 321 
<span class="line-added"> 322 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
 323     shaper_buf = af_shaper_buf_create( face );
<span class="line-added"> 324 #endif</span>
 325 
 326     for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
 327     {
 328       const char*  p = &amp;af_blue_strings[bs-&gt;string];
 329       FT_Pos*      blue_ref;
 330       FT_Pos*      blue_shoot;
 331 
 332 
 333       if ( AF_CJK_IS_HORIZ_BLUE( bs ) )
 334         axis = &amp;metrics-&gt;axis[AF_DIMENSION_HORZ];
 335       else
 336         axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
 337 
 338 #ifdef FT_DEBUG_LEVEL_TRACE
 339       {
 340         FT_String*  cjk_blue_name[4] =
 341         {
 342           (FT_String*)&quot;bottom&quot;,    /* --   , --  */
 343           (FT_String*)&quot;top&quot;,       /* --   , TOP */
 344           (FT_String*)&quot;left&quot;,      /* HORIZ, --  */
</pre>
<hr />
<pre>
 480                     best_point = pp;
 481                     best_pos   = points[pp].y;
 482                   }
 483               }
 484             }
 485           }
 486 
 487           FT_TRACE5(( &quot;  U+%04lX: best_pos = %5ld\n&quot;, ch, best_pos ));
 488         }
 489 
 490         if ( fill )
 491           fills[num_fills++] = best_pos;
 492         else
 493           flats[num_flats++] = best_pos;
 494 
 495       } /* end while loop */
 496 
 497       if ( num_flats == 0 &amp;&amp; num_fills == 0 )
 498       {
 499         /*
<span class="line-modified"> 500          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified"> 501          * we will simply ignore it then</span>
 502          */
 503         FT_TRACE5(( &quot;  empty\n&quot; ));
 504         continue;
 505       }
 506 
 507       /* we have computed the contents of the `fill&#39; and `flats&#39; tables,   */
 508       /* now determine the reference and overshoot position of the blue -- */
 509       /* we simply take the median value after a simple sort               */
 510       af_sort_pos( num_fills, fills );
 511       af_sort_pos( num_flats, flats );
 512 
 513       blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];
 514       blue_ref   = &amp;blue-&gt;ref.org;
 515       blue_shoot = &amp;blue-&gt;shoot.org;
 516 
 517       axis-&gt;blue_count++;
 518 
 519       if ( num_flats == 0 )
 520       {
 521         *blue_ref   =
</pre>
<hr />
<pre>
 562 
 563     } /* end for loop */
 564 
 565     af_shaper_buf_destroy( face, shaper_buf );
 566 
 567     FT_TRACE5(( &quot;\n&quot; ));
 568 
 569     return;
 570   }
 571 
 572 
 573   /* Basically the Latin version with type AF_CJKMetrics for metrics. */
 574 
 575   FT_LOCAL_DEF( void )
 576   af_cjk_metrics_check_digits( AF_CJKMetrics  metrics,
 577                                FT_Face        face )
 578   {
 579     FT_Bool   started = 0, same_width = 1;
 580     FT_Fixed  advance = 0, old_advance = 0;
 581 
<span class="line-modified"> 582     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added"> 583     /* unsigned long value.                                        */</span>
<span class="line-added"> 584 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 585     void*     shaper_buf;</span>
<span class="line-added"> 586 #else</span>
<span class="line-added"> 587     FT_ULong  shaper_buf_;</span>
<span class="line-added"> 588     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added"> 589 #endif</span>
 590 
 591     /* in all supported charmaps, digits have character codes 0x30-0x39 */
 592     const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
 593     const char*  p;
 594 
 595 
<span class="line-modified"> 596     p = digits;</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
 599     shaper_buf = af_shaper_buf_create( face );
<span class="line-added"> 600 #endif</span>
 601 
 602     while ( *p )
 603     {
 604       FT_ULong      glyph_index;
 605       unsigned int  num_idx;
 606 
 607 
 608       /* reject input that maps to more than a single glyph */
 609       p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 610       if ( num_idx &gt; 1 )
 611         continue;
 612 
 613       glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 614                                         shaper_buf,
 615                                         0,
 616                                         &amp;advance,
 617                                         NULL );
 618       if ( !glyph_index )
 619         continue;
 620 
</pre>
<hr />
<pre>
 897                    ( dist * 8 &lt; seg1-&gt;score * 7 || seg1-&gt;len &lt; len ) )
 898               {
 899                 seg1-&gt;score = dist;
 900                 seg1-&gt;len   = len;
 901                 seg1-&gt;link  = seg2;
 902               }
 903 
 904               if ( dist * 8 &lt; seg2-&gt;score * 9                        &amp;&amp;
 905                    ( dist * 8 &lt; seg2-&gt;score * 7 || seg2-&gt;len &lt; len ) )
 906               {
 907                 seg2-&gt;score = dist;
 908                 seg2-&gt;len   = len;
 909                 seg2-&gt;link  = seg1;
 910               }
 911             }
 912           }
 913         }
 914     }
 915 
 916     /*
<span class="line-modified"> 917      * now compute the `serif&#39; segments</span>
 918      *
<span class="line-modified"> 919      * In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="line-modified"> 920      * We either identify the stems on the ends as serifs or remove</span>
<span class="line-modified"> 921      * the linkage, depending on the length of the stems.</span>
 922      *
 923      */
 924 
 925     {
 926       AF_Segment  link1, link2;
 927 
 928 
 929       for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )
 930       {
 931         link1 = seg1-&gt;link;
 932         if ( !link1 || link1-&gt;link != seg1 || link1-&gt;pos &lt;= seg1-&gt;pos )
 933           continue;
 934 
 935         if ( seg1-&gt;score &gt;= dist_threshold )
 936           continue;
 937 
 938         for ( seg2 = segments; seg2 &lt; segment_limit; seg2++ )
 939         {
 940           if ( seg2-&gt;pos &gt; seg1-&gt;pos || seg1 == seg2 )
 941             continue;
</pre>
<hr />
<pre>
1007                               AF_Dimension   dim )
1008   {
1009     AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
1010     FT_Error      error  = FT_Err_Ok;
1011     FT_Memory     memory = hints-&gt;memory;
1012     AF_CJKAxis    laxis  = &amp;((AF_CJKMetrics)hints-&gt;metrics)-&gt;axis[dim];
1013 
1014     AF_Segment    segments      = axis-&gt;segments;
1015     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
1016     AF_Segment    seg;
1017 
1018     FT_Fixed      scale;
1019     FT_Pos        edge_distance_threshold;
1020 
1021 
1022     axis-&gt;num_edges = 0;
1023 
1024     scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
1025                                          : hints-&gt;y_scale;
1026 
<span class="line-modified">1027     /**********************************************************************</span>
<span class="line-modified">1028      *</span>
<span class="line-modified">1029      * We begin by generating a sorted table of edges for the current</span>
<span class="line-modified">1030      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="line-modified">1031      * an edge in our table that corresponds to its position.</span>
<span class="line-modified">1032      *</span>
<span class="line-modified">1033      * If no edge is found, we create and insert a new edge in the</span>
<span class="line-modified">1034      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="line-modified">1035      * list which is then processed in the second step to compute the</span>
<span class="line-modified">1036      * edge&#39;s properties.</span>
<span class="line-modified">1037      *</span>
<span class="line-modified">1038      * Note that the edges table is sorted along the segment/edge</span>
<span class="line-modified">1039      * position.</span>
<span class="line-modified">1040      *</span>
<span class="line-modified">1041      */</span>
1042 
1043     edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
1044                                          scale );
1045     if ( edge_distance_threshold &gt; 64 / 4 )
1046       edge_distance_threshold = FT_DivFix( 64 / 4, scale );
1047     else
1048       edge_distance_threshold = laxis-&gt;edge_distance_threshold;
1049 
1050     for ( seg = segments; seg &lt; segment_limit; seg++ )
1051     {
1052       AF_Edge  found = NULL;
1053       FT_Pos   best  = 0xFFFFU;
1054       FT_Int   ee;
1055 
1056 
1057       /* look for an edge corresponding to the segment */
1058       for ( ee = 0; ee &lt; axis-&gt;num_edges; ee++ )
1059       {
1060         AF_Edge  edge = axis-&gt;edges + ee;
1061         FT_Pos   dist;
</pre>
<hr />
<pre>
1121         FT_ZERO( edge );
1122 
1123         edge-&gt;first    = seg;
1124         edge-&gt;last     = seg;
1125         edge-&gt;dir      = seg-&gt;dir;
1126         edge-&gt;fpos     = seg-&gt;pos;
1127         edge-&gt;opos     = FT_MulFix( seg-&gt;pos, scale );
1128         edge-&gt;pos      = edge-&gt;opos;
1129         seg-&gt;edge_next = seg;
1130       }
1131       else
1132       {
1133         /* if an edge was found, simply add the segment to the edge&#39;s */
1134         /* list                                                       */
1135         seg-&gt;edge_next         = found-&gt;first;
1136         found-&gt;last-&gt;edge_next = seg;
1137         found-&gt;last            = seg;
1138       }
1139     }
1140 
<span class="line-modified">1141     /*******************************************************************</span>
<span class="line-modified">1142      *</span>
<span class="line-modified">1143      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="line-modified">1144      * segments found on its position.  Basically, these are</span>
<span class="line-modified">1145      *</span>
<span class="line-modified">1146      * - the edge&#39;s main direction</span>
<span class="line-modified">1147      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="line-modified">1148      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="line-modified">1149      * - link for edge</span>
<span class="line-modified">1150      *</span>
<span class="line-modified">1151      */</span>
1152 
1153     /* first of all, set the `edge&#39; field in each segment -- this is */
1154     /* required in order to compute edge links                       */
1155 
1156     /*
1157      * Note that removing this loop and setting the `edge&#39; field of each
1158      * segment directly in the code above slows down execution speed for
1159      * some reasons on platforms like the Sun.
1160      */
1161     {
1162       AF_Edge  edges      = axis-&gt;edges;
1163       AF_Edge  edge_limit = edges + axis-&gt;num_edges;
1164       AF_Edge  edge;
1165 
1166 
1167       for ( edge = edges; edge &lt; edge_limit; edge++ )
1168       {
1169         seg = edge-&gt;first;
1170         if ( seg )
1171           do
1172           {
1173             seg-&gt;edge = edge;
1174             seg       = seg-&gt;edge_next;
1175 
1176           } while ( seg != edge-&gt;first );
1177       }
1178 
1179       /* now compute each edge properties */
1180       for ( edge = edges; edge &lt; edge_limit; edge++ )
1181       {
1182         FT_Int  is_round    = 0;  /* does it contain round segments?    */
1183         FT_Int  is_straight = 0;  /* does it contain straight segments? */
1184 
1185 
1186         seg = edge-&gt;first;
<span class="line-added">1187         if ( !seg )</span>
<span class="line-added">1188           goto Skip_Loop;</span>
1189 
1190         do
1191         {
1192           FT_Bool  is_serif;
1193 
1194 
1195           /* check for roundness of segment */
1196           if ( seg-&gt;flags &amp; AF_EDGE_ROUND )
1197             is_round++;
1198           else
1199             is_straight++;
1200 
1201           /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
1202           /* be ignored                                                   */
<span class="line-modified">1203           is_serif = FT_BOOL( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
1204 
1205           if ( seg-&gt;link || is_serif )
1206           {
1207             AF_Edge     edge2;
1208             AF_Segment  seg2;
1209 
1210 
1211             edge2 = edge-&gt;link;
1212             seg2  = seg-&gt;link;
1213 
1214             if ( is_serif )
1215             {
1216               seg2  = seg-&gt;serif;
1217               edge2 = edge-&gt;serif;
1218             }
1219 
1220             if ( edge2 )
1221             {
1222               FT_Pos  edge_delta;
1223               FT_Pos  seg_delta;
1224 
1225 
1226               edge_delta = edge-&gt;fpos - edge2-&gt;fpos;
1227               if ( edge_delta &lt; 0 )
1228                 edge_delta = -edge_delta;
1229 
1230               seg_delta = AF_SEGMENT_DIST( seg, seg2 );
1231 
1232               if ( seg_delta &lt; edge_delta )
1233                 edge2 = seg2-&gt;edge;
1234             }
1235             else
1236               edge2 = seg2-&gt;edge;
1237 
1238             if ( is_serif )
1239             {
1240               edge-&gt;serif   = edge2;
1241               edge2-&gt;flags |= AF_EDGE_SERIF;
1242             }
1243             else
<span class="line-modified">1244               edge-&gt;link = edge2;</span>
1245           }
1246 
1247           seg = seg-&gt;edge_next;
1248 
1249         } while ( seg != edge-&gt;first );
1250 
<span class="line-added">1251       Skip_Loop:</span>
1252         /* set the round/straight flags */
1253         edge-&gt;flags = AF_EDGE_NORMAL;
1254 
1255         if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
1256           edge-&gt;flags |= AF_EDGE_ROUND;
1257 
1258         /* get rid of serifs if link is set                 */
1259         /* XXX: This gets rid of many unpleasant artefacts! */
1260         /*      Example: the `c&#39; in cour.pfa at size 13     */
1261 
1262         if ( edge-&gt;serif &amp;&amp; edge-&gt;link )
1263           edge-&gt;serif = NULL;
1264       }
1265     }
1266 
1267   Exit:
1268     return error;
1269   }
1270 
1271 
</pre>
<hr />
<pre>
1374 
1375       if ( best_blue )
1376         edge-&gt;blue_edge = best_blue;
1377     }
1378   }
1379 
1380 
1381   /* Initalize hinting engine. */
1382 
1383   FT_LOCAL_DEF( FT_Error )
1384   af_cjk_hints_init( AF_GlyphHints  hints,
1385                      AF_CJKMetrics  metrics )
1386   {
1387     FT_Render_Mode  mode;
1388     FT_UInt32       scaler_flags, other_flags;
1389 
1390 
1391     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
1392 
1393     /*
<span class="line-modified">1394      * correct x_scale and y_scale when needed, since they may have</span>
<span class="line-modified">1395      * been modified af_cjk_scale_dim above</span>
1396      */
1397     hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
1398     hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
1399     hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
1400     hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
1401 
1402     /* compute flags depending on render mode, etc. */
1403     mode = metrics-&gt;root.scaler.render_mode;
1404 
1405 #if 0 /* AF_CONFIG_OPTION_USE_WARPER */
1406     if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
1407       metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
1408 #endif
1409 
1410     scaler_flags = hints-&gt;scaler_flags;
1411     other_flags  = 0;
1412 
1413     /*
<span class="line-modified">1414      * We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">1415      * horizontal LCD rendering targets only.</span>
1416      */
1417     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
1418       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
1419 
1420     /*
<span class="line-modified">1421      * We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">1422      * vertical LCD rendering targets only.</span>
1423      */
1424     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
1425       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
1426 
1427     /*
<span class="line-modified">1428      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
1429      */
1430     if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
1431       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
1432 
1433     if ( mode == FT_RENDER_MODE_MONO )
1434       other_flags |= AF_LATIN_HINTS_MONO;
1435 
1436     scaler_flags |= AF_SCALER_FLAG_NO_ADVANCE;
1437 
1438 #ifdef AF_CONFIG_OPTION_USE_WARPER
1439     /* get (global) warper flag */
1440     if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )
1441       scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
1442 #endif
1443 
1444     hints-&gt;scaler_flags = scaler_flags;
1445     hints-&gt;other_flags  = other_flags;
1446 
1447     return FT_Err_Ok;
1448   }
</pre>
<hr />
<pre>
2104         if ( edge3-&gt;link )
2105           edge3-&gt;link-&gt;pos -= delta;
2106 
2107         /* move the serifs along with the stem */
2108         if ( n_edges == 12 )
2109         {
2110           ( edges + 8 )-&gt;pos -= delta;
2111           ( edges + 11 )-&gt;pos -= delta;
2112         }
2113 
2114         edge3-&gt;flags |= AF_EDGE_DONE;
2115         if ( edge3-&gt;link )
2116           edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;
2117       }
2118     }
2119 
2120     if ( !skipped )
2121       goto Exit;
2122 
2123     /*
<span class="line-modified">2124      * now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">2125      * to complete our processing</span>
2126      */
2127     for ( edge = edges; edge &lt; edge_limit; edge++ )
2128     {
2129       if ( edge-&gt;flags &amp; AF_EDGE_DONE )
2130         continue;
2131 
2132       if ( edge-&gt;serif )
2133       {
2134         af_cjk_align_serif_edge( hints, edge-&gt;serif, edge );
2135         edge-&gt;flags |= AF_EDGE_DONE;
2136         skipped--;
2137       }
2138     }
2139 
2140     if ( !skipped )
2141       goto Exit;
2142 
2143     for ( edge = edges; edge &lt; edge_limit; edge++ )
2144     {
2145       AF_Edge  before, after;
</pre>
</td>
</tr>
</table>
<center><a href="afblue.hin.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
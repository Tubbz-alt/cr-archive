diff a/src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c b/src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c
--- a/src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c
+++ b/src/java.desktop/share/native/libfreetype/src/psaux/t1decode.c
@@ -1,21 +1,21 @@
-/***************************************************************************/
-/*                                                                         */
-/*  t1decode.c                                                             */
-/*                                                                         */
-/*    PostScript Type 1 decoding routines (body).                          */
-/*                                                                         */
-/*  Copyright 2000-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * t1decode.c
+ *
+ *   PostScript Type 1 decoding routines (body).
+ *
+ * Copyright (C) 2000-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_DEBUG_H
@@ -29,18 +29,18 @@
 #include "psauxerr.h"
 
 /* ensure proper sign extension */
 #define Fix2Int( f )  ( (FT_Int)(FT_Short)( (f) >> 16 ) )
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_t1decode
+#define FT_COMPONENT  t1decode
 
 
   typedef enum  T1_Operator_
   {
     op_none = 0,
@@ -107,28 +107,30 @@
     2, /* setcurrentpoint */
     2  /* opcode 15 (undocumented and obsolete) */
   };
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    t1_lookup_glyph_by_stdcharcode_ps                                  */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */
-  /*    implement the SEAC Type 1 operator in the Adobe engine             */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    face     :: The current face object.                               */
-  /*                                                                       */
-  /*    charcode :: The character code to look for.                        */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    A glyph index in the font face.  Returns -1 if the corresponding   */
-  /*    glyph wasn't found.                                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   t1_lookup_glyph_by_stdcharcode_ps
+   *
+   * @Description:
+   *   Looks up a given glyph by its StandardEncoding charcode.  Used to
+   *   implement the SEAC Type 1 operator in the Adobe engine
+   *
+   * @Input:
+   *   face ::
+   *     The current face object.
+   *
+   *   charcode ::
+   *     The character code to look for.
+   *
+   * @Return:
+   *   A glyph index in the font face.  Returns -1 if the corresponding
+   *   glyph wasn't found.
+   */
   FT_LOCAL_DEF( FT_Int )
   t1_lookup_glyph_by_stdcharcode_ps( PS_Decoder*  decoder,
                                      FT_Int       charcode )
   {
     FT_UInt             n;
@@ -157,28 +159,31 @@
     return -1;
   }
 
 
 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    t1_lookup_glyph_by_stdcharcode                                     */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Looks up a given glyph by its StandardEncoding charcode.  Used to  */
-  /*    implement the SEAC Type 1 operator.                                */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    face     :: The current face object.                               */
-  /*                                                                       */
-  /*    charcode :: The character code to look for.                        */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    A glyph index in the font face.  Returns -1 if the corresponding   */
-  /*    glyph wasn't found.                                                */
-  /*                                                                       */
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   t1_lookup_glyph_by_stdcharcode
+   *
+   * @Description:
+   *   Looks up a given glyph by its StandardEncoding charcode.  Used to
+   *   implement the SEAC Type 1 operator.
+   *
+   * @Input:
+   *   face ::
+   *     The current face object.
+   *
+   *   charcode ::
+   *     The character code to look for.
+   *
+   * @Return:
+   *   A glyph index in the font face.  Returns -1 if the corresponding
+   *   glyph wasn't found.
+   */
   static FT_Int
   t1_lookup_glyph_by_stdcharcode( T1_Decoder  decoder,
                                   FT_Int      charcode )
   {
     FT_UInt             n;
@@ -215,34 +220,40 @@
   {
     return decoder->parse_callback( decoder, glyph );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    t1operator_seac                                                    */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Implements the `seac' Type 1 operator for a Type 1 decoder.        */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    decoder :: The current CID decoder.                                */
-  /*                                                                       */
-  /*    asb     :: The accent's side bearing.                              */
-  /*                                                                       */
-  /*    adx     :: The horizontal offset of the accent.                    */
-  /*                                                                       */
-  /*    ady     :: The vertical offset of the accent.                      */
-  /*                                                                       */
-  /*    bchar   :: The base character's StandardEncoding charcode.         */
-  /*                                                                       */
-  /*    achar   :: The accent character's StandardEncoding charcode.       */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   t1operator_seac
+   *
+   * @Description:
+   *   Implements the `seac' Type 1 operator for a Type 1 decoder.
+   *
+   * @Input:
+   *   decoder ::
+   *     The current CID decoder.
+   *
+   *   asb ::
+   *     The accent's side bearing.
+   *
+   *   adx ::
+   *     The horizontal offset of the accent.
+   *
+   *   ady ::
+   *     The vertical offset of the accent.
+   *
+   *   bchar ::
+   *     The base character's StandardEncoding charcode.
+   *
+   *   achar ::
+   *     The accent character's StandardEncoding charcode.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   */
   static FT_Error
   t1operator_seac( T1_Decoder  decoder,
                    FT_Pos      asb,
                    FT_Pos      adx,
                    FT_Pos      ady,
@@ -397,28 +408,31 @@
   Exit:
     return error;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    t1_decoder_parse_charstrings                                       */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Parses a given Type 1 charstrings program.                         */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    decoder         :: The current Type 1 decoder.                     */
-  /*                                                                       */
-  /*    charstring_base :: The base address of the charstring stream.      */
-  /*                                                                       */
-  /*    charstring_len  :: The length in bytes of the charstring stream.   */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   t1_decoder_parse_charstrings
+   *
+   * @Description:
+   *   Parses a given Type 1 charstrings program.
+   *
+   * @Input:
+   *   decoder ::
+   *     The current Type 1 decoder.
+   *
+   *   charstring_base ::
+   *     The base address of the charstring stream.
+   *
+   *   charstring_len ::
+   *     The length in bytes of the charstring stream.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   */
   FT_LOCAL_DEF( FT_Error )
   t1_decoder_parse_charstrings( T1_Decoder  decoder,
                                 FT_Byte*    charstring_base,
                                 FT_UInt     charstring_len )
   {
@@ -464,13 +478,10 @@
                ( decoder->buildchar == NULL )  );
 
     if ( decoder->buildchar && decoder->len_buildchar > 0 )
       FT_ARRAY_ZERO( decoder->buildchar, decoder->len_buildchar );
 
-    FT_TRACE4(( "\n"
-                "Start charstring\n" ));
-
     zone->base           = charstring_base;
     limit = zone->limit  = charstring_base + charstring_len;
     ip    = zone->cursor = zone->base;
 
     error = FT_Err_Ok;
@@ -501,15 +512,15 @@
         FT_TRACE5(( " (%d)", decoder->top - decoder->stack ));
         bol = FALSE;
       }
 #endif
 
-      /*********************************************************************/
-      /*                                                                   */
-      /* Decode operator or operand                                        */
-      /*                                                                   */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Decode operator or operand
+       *
+       */
 
       /* first of all, decompress operator or value */
       switch ( *ip++ )
       {
       case 1:
@@ -708,15 +719,15 @@
                    " no `div' after large integer\n" ));
 
         large_int = FALSE;
       }
 
-      /*********************************************************************/
-      /*                                                                   */
-      /*  Push value on stack, or process operator                         */
-      /*                                                                   */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Push value on stack, or process operator
+       *
+       */
       if ( op == op_none )
       {
         if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
         {
           FT_ERROR(( "t1_decoder_parse_charstrings: stack overflow\n" ));
@@ -750,20 +761,21 @@
         top -= 2;
 
         subr_no = Fix2Int( top[1] );
         arg_cnt = Fix2Int( top[0] );
 
-        /***********************************************************/
-        /*                                                         */
-        /* remove all operands to callothersubr from the stack     */
-        /*                                                         */
-        /* for handled othersubrs, where we know the number of     */
-        /* arguments, we increase the stack by the value of        */
-        /* known_othersubr_result_cnt                              */
-        /*                                                         */
-        /* for unhandled othersubrs the following pops adjust the  */
-        /* stack pointer as necessary                              */
+        /************************************************************
+         *
+         * remove all operands to callothersubr from the stack
+         *
+         * for handled othersubrs, where we know the number of
+         * arguments, we increase the stack by the value of
+         * known_othersubr_result_cnt
+         *
+         * for unhandled othersubrs the following pops adjust the
+         * stack pointer as necessary
+         */
 
         if ( arg_cnt > top - decoder->stack )
           goto Stack_Underflow;
 
         top -= arg_cnt;
@@ -1221,11 +1233,14 @@
 
           /* the `metrics_only' indicates that we only want to compute */
           /* the glyph's metrics (lsb + advance width), not load the   */
           /* rest of it; so exit immediately                           */
           if ( builder->metrics_only )
+          {
+            FT_TRACE4(( "\n" ));
             return FT_Err_Ok;
+          }
 
           break;
 
         case op_seac:
           return t1operator_seac( decoder,
@@ -1253,11 +1268,14 @@
 
           /* the `metrics_only' indicates that we only want to compute */
           /* the glyph's metrics (lsb + advance width), not load the   */
           /* rest of it; so exit immediately                           */
           if ( builder->metrics_only )
+          {
+            FT_TRACE4(( "\n" ));
             return FT_Err_Ok;
+          }
 
           break;
 
         case op_closepath:
           FT_TRACE4(( " closepath" ));
@@ -1636,30 +1654,35 @@
 
   Stack_Underflow:
     return FT_THROW( Stack_Underflow );
   }
 
-#else /* T1_CONFIG_OPTION_OLD_ENGINE */
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    t1_decoder_parse_metrics                                           */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Parses a given Type 1 charstrings program to extract width         */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    decoder         :: The current Type 1 decoder.                     */
-  /*                                                                       */
-  /*    charstring_base :: The base address of the charstring stream.      */
-  /*                                                                       */
-  /*    charstring_len  :: The length in bytes of the charstring stream.   */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
+
+#else /* !T1_CONFIG_OPTION_OLD_ENGINE */
+
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   t1_decoder_parse_metrics
+   *
+   * @Description:
+   *   Parses a given Type 1 charstrings program to extract width
+   *
+   * @Input:
+   *   decoder ::
+   *     The current Type 1 decoder.
+   *
+   *   charstring_base ::
+   *     The base address of the charstring stream.
+   *
+   *   charstring_len ::
+   *     The length in bytes of the charstring stream.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   */
   FT_LOCAL_DEF( FT_Error )
   t1_decoder_parse_metrics( T1_Decoder  decoder,
                             FT_Byte*    charstring_base,
                             FT_UInt     charstring_len )
   {
@@ -1678,13 +1701,10 @@
     decoder->zone = decoder->zones;
     zone          = decoder->zones;
 
     builder->parse_state = T1_Parse_Start;
 
-    FT_TRACE4(( "\n"
-                "Start charstring: get width\n" ));
-
     zone->base           = charstring_base;
     limit = zone->limit  = charstring_base + charstring_len;
     ip    = zone->cursor = zone->base;
 
     /* now, execute loop */
@@ -1701,15 +1721,15 @@
         FT_TRACE5(( " (%d)", decoder->top - decoder->stack ));
         bol = FALSE;
       }
 #endif
 
-      /*********************************************************************/
-      /*                                                                   */
-      /* Decode operator or operand                                        */
-      /*                                                                   */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Decode operator or operand
+       *
+       */
 
       /* first of all, decompress operator or value */
       switch ( *ip++ )
       {
       case 1:
@@ -1815,15 +1835,15 @@
                      " invalid byte (%d)\n", ip[-1] ));
           goto Syntax_Error;
         }
       }
 
-      /*********************************************************************/
-      /*                                                                   */
-      /*  Push value on stack, or process operator                         */
-      /*                                                                   */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Push value on stack, or process operator
+       *
+       */
       if ( op == op_none )
       {
         if ( top - decoder->stack >= T1_MAX_CHARSTRINGS_OPERANDS )
         {
           FT_ERROR(( "t1_decoder_parse_metrics: stack overflow\n" ));
@@ -1873,10 +1893,11 @@
           builder->advance.y = 0;
 
           /* we only want to compute the glyph's metrics */
           /* (lsb + advance width), not load the rest of */
           /* it; so exit immediately                     */
+          FT_TRACE4(( "\n" ));
           return FT_Err_Ok;
 
         case op_sbw:
           FT_TRACE4(( " sbw" ));
 
@@ -1891,10 +1912,11 @@
           builder->advance.y = top[3];
 
           /* we only want to compute the glyph's metrics */
           /* (lsb + advance width), not load the rest of */
           /* it; so exit immediately                     */
+          FT_TRACE4(( "\n" ));
           return FT_Err_Ok;
 
         default:
           FT_ERROR(( "t1_decoder_parse_metrics:"
                      " unhandled opcode %d\n", op ));
@@ -1915,11 +1937,12 @@
     return FT_THROW( Syntax_Error );
 
   Stack_Underflow:
     return FT_THROW( Stack_Underflow );
   }
-#endif /* T1_CONFIG_OPTION_OLD_ENGINE */
+
+#endif /* !T1_CONFIG_OPTION_OLD_ENGINE */
 
 
   /* initialize T1 decoder */
   FT_LOCAL_DEF( FT_Error )
   t1_decoder_init( T1_Decoder           decoder,
@@ -1932,11 +1955,11 @@
                    FT_Render_Mode       hint_mode,
                    T1_Decoder_Callback  parse_callback )
   {
     FT_ZERO( decoder );
 
-    /* retrieve PSNames interface from list of current modules */
+    /* retrieve `psnames' interface from list of current modules */
     {
       FT_Service_PsCMaps  psnames;
 
 
       FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );

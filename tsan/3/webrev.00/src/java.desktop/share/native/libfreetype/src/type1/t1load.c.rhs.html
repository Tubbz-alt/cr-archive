<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/type1/t1load.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * t1load.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Type 1 font loader (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18 </span>
<span class="line-modified">  19   /**************************************************************************</span>
<span class="line-modified">  20    *</span>
<span class="line-modified">  21    * This is the new and improved Type 1 data loader for FreeType 2.  The</span>
<span class="line-modified">  22    * old loader has several problems: it is slow, complex, difficult to</span>
<span class="line-modified">  23    * maintain, and contains incredible hacks to make it accept some</span>
<span class="line-modified">  24    * ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of</span>
<span class="line-modified">  25    * the Type 1 fonts on my machine still aren&#39;t loaded correctly by it.</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * This version is much simpler, much faster and also easier to read and</span>
<span class="line-modified">  28    * maintain by a great order of magnitude.  The idea behind it is to</span>
<span class="line-modified">  29    * _not_ try to read the Type 1 token stream with a state machine (i.e.</span>
<span class="line-modified">  30    * a Postscript-like interpreter) but rather to perform simple pattern</span>
<span class="line-modified">  31    * matching.</span>
<span class="line-modified">  32    *</span>
<span class="line-modified">  33    * Indeed, nearly all data definitions follow a simple pattern like</span>
<span class="line-modified">  34    *</span>
<span class="line-modified">  35    * ... /Field &lt;data&gt; ...</span>
<span class="line-modified">  36    *</span>
<span class="line-modified">  37    * where &lt;data&gt; can be a number, a boolean, a string, or an array of</span>
<span class="line-modified">  38    * numbers.  There are a few exceptions, namely the encoding, font name,</span>
<span class="line-modified">  39    * charstrings, and subrs; they are handled with a special pattern</span>
<span class="line-modified">  40    * matching routine.</span>
<span class="line-modified">  41    *</span>
<span class="line-modified">  42    * All other common cases are handled very simply.  The matching rules</span>
<span class="line-modified">  43    * are defined in the file `t1tokens.h&#39; through the use of several</span>
<span class="line-modified">  44    * macros calls PARSE_XXX.  This file is included twice here; the first</span>
<span class="line-modified">  45    * time to generate parsing callback functions, the second time to</span>
<span class="line-modified">  46    * generate a table of keywords (with pointers to the associated</span>
<span class="line-modified">  47    * callback functions).</span>
<span class="line-modified">  48    *</span>
<span class="line-modified">  49    * The function `parse_dict&#39; simply scans *linearly* a given dictionary</span>
<span class="line-modified">  50    * (either the top-level or private one) and calls the appropriate</span>
<span class="line-modified">  51    * callback when it encounters an immediate keyword.</span>
<span class="line-modified">  52    *</span>
<span class="line-modified">  53    * This is by far the fastest way one can find to parse and read all</span>
<span class="line-modified">  54    * data.</span>
<span class="line-modified">  55    *</span>
<span class="line-modified">  56    * This led to tremendous code size reduction.  Note that later, the</span>
<span class="line-modified">  57    * glyph loader will also be _greatly_ simplified, and the automatic</span>
<span class="line-modified">  58    * hinter will replace the clumsy `t1hinter&#39;.</span>
<span class="line-modified">  59    *</span>
<span class="line-modified">  60    */</span>
  61 
  62 
  63 #include &lt;ft2build.h&gt;
  64 #include FT_INTERNAL_DEBUG_H
  65 #include FT_CONFIG_CONFIG_H
  66 #include FT_MULTIPLE_MASTERS_H
  67 #include FT_INTERNAL_TYPE1_TYPES_H
  68 #include FT_INTERNAL_CALC_H
  69 #include FT_INTERNAL_HASH_H
  70 
  71 #include &quot;t1load.h&quot;
  72 #include &quot;t1errors.h&quot;
  73 
  74 
  75 #ifdef FT_CONFIG_OPTION_INCREMENTAL
<a name="2" id="anc2"></a><span class="line-modified">  76 #define IS_INCREMENTAL  FT_BOOL( face-&gt;root.internal-&gt;incremental_interface )</span>
  77 #else
  78 #define IS_INCREMENTAL  0
  79 #endif
  80 
  81 
<a name="3" id="anc3"></a><span class="line-modified">  82   /**************************************************************************</span>
<span class="line-modified">  83    *</span>
<span class="line-modified">  84    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  85    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  86    * messages during execution.</span>
<span class="line-modified">  87    */</span>
  88 #undef  FT_COMPONENT
<a name="4" id="anc4"></a><span class="line-modified">  89 #define FT_COMPONENT  t1load</span>
  90 
  91 
  92 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
  93 
  94 
  95   /*************************************************************************/
  96   /*************************************************************************/
  97   /*****                                                               *****/
  98   /*****                    MULTIPLE MASTERS SUPPORT                   *****/
  99   /*****                                                               *****/
 100   /*************************************************************************/
 101   /*************************************************************************/
 102 
 103   static FT_Error
 104   t1_allocate_blend( T1_Face  face,
 105                      FT_UInt  num_designs,
 106                      FT_UInt  num_axis )
 107   {
 108     PS_Blend   blend;
 109     FT_Memory  memory = face-&gt;root.memory;
 110     FT_Error   error  = FT_Err_Ok;
 111 
 112 
 113     blend = face-&gt;blend;
 114     if ( !blend )
 115     {
 116       if ( FT_NEW( blend ) )
 117         goto Exit;
 118 
 119       blend-&gt;num_default_design_vector = 0;
 120 
 121       face-&gt;blend = blend;
 122     }
 123 
 124     /* allocate design data if needed */
 125     if ( num_designs &gt; 0 )
 126     {
 127       if ( blend-&gt;num_designs == 0 )
 128       {
 129         FT_UInt  nn;
 130 
 131 
 132         /* allocate the blend `private&#39; and `font_info&#39; dictionaries */
 133         if ( FT_NEW_ARRAY( blend-&gt;font_infos[1], num_designs     ) ||
 134              FT_NEW_ARRAY( blend-&gt;privates  [1], num_designs     ) ||
 135              FT_NEW_ARRAY( blend-&gt;bboxes    [1], num_designs     ) ||
 136              FT_NEW_ARRAY( blend-&gt;weight_vector, num_designs * 2 ) )
 137           goto Exit;
 138 
 139         blend-&gt;default_weight_vector = blend-&gt;weight_vector + num_designs;
 140 
 141         blend-&gt;font_infos[0] = &amp;face-&gt;type1.font_info;
 142         blend-&gt;privates  [0] = &amp;face-&gt;type1.private_dict;
 143         blend-&gt;bboxes    [0] = &amp;face-&gt;type1.font_bbox;
 144 
 145         for ( nn = 2; nn &lt;= num_designs; nn++ )
 146         {
 147           blend-&gt;font_infos[nn] = blend-&gt;font_infos[nn - 1] + 1;
 148           blend-&gt;privates  [nn] = blend-&gt;privates  [nn - 1] + 1;
 149           blend-&gt;bboxes    [nn] = blend-&gt;bboxes    [nn - 1] + 1;
 150         }
 151 
 152         blend-&gt;num_designs = num_designs;
 153       }
 154       else if ( blend-&gt;num_designs != num_designs )
 155         goto Fail;
 156     }
 157 
 158     /* allocate axis data if needed */
 159     if ( num_axis &gt; 0 )
 160     {
 161       if ( blend-&gt;num_axis != 0 &amp;&amp; blend-&gt;num_axis != num_axis )
 162         goto Fail;
 163 
 164       blend-&gt;num_axis = num_axis;
 165     }
 166 
 167     /* allocate the blend design pos table if needed */
 168     num_designs = blend-&gt;num_designs;
 169     num_axis    = blend-&gt;num_axis;
 170     if ( num_designs &amp;&amp; num_axis &amp;&amp; blend-&gt;design_pos[0] == 0 )
 171     {
 172       FT_UInt  n;
 173 
 174 
 175       if ( FT_NEW_ARRAY( blend-&gt;design_pos[0], num_designs * num_axis ) )
 176         goto Exit;
 177 
 178       for ( n = 1; n &lt; num_designs; n++ )
 179         blend-&gt;design_pos[n] = blend-&gt;design_pos[0] + num_axis * n;
 180     }
 181 
 182   Exit:
 183     return error;
 184 
 185   Fail:
 186     error = FT_THROW( Invalid_File_Format );
 187     goto Exit;
 188   }
 189 
 190 
 191   FT_LOCAL_DEF( FT_Error )
 192   T1_Get_Multi_Master( T1_Face           face,
 193                        FT_Multi_Master*  master )
 194   {
 195     PS_Blend  blend = face-&gt;blend;
 196     FT_UInt   n;
 197     FT_Error  error;
 198 
 199 
 200     error = FT_THROW( Invalid_Argument );
 201 
 202     if ( blend )
 203     {
 204       master-&gt;num_axis    = blend-&gt;num_axis;
 205       master-&gt;num_designs = blend-&gt;num_designs;
 206 
 207       for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
 208       {
 209         FT_MM_Axis*   axis = master-&gt;axis + n;
 210         PS_DesignMap  map = blend-&gt;design_map + n;
 211 
 212 
 213         axis-&gt;name    = blend-&gt;axis_names[n];
 214         axis-&gt;minimum = map-&gt;design_points[0];
 215         axis-&gt;maximum = map-&gt;design_points[map-&gt;num_points - 1];
 216       }
 217 
 218       error = FT_Err_Ok;
 219     }
 220 
 221     return error;
 222   }
 223 
 224 
<a name="5" id="anc5"></a><span class="line-modified"> 225   /**************************************************************************</span>
<span class="line-modified"> 226    *</span>
<span class="line-modified"> 227    * Given a normalized (blend) coordinate, figure out the design</span>
<span class="line-modified"> 228    * coordinate appropriate for that value.</span>
<span class="line-modified"> 229    */</span>
 230   static FT_Fixed
 231   mm_axis_unmap( PS_DesignMap  axismap,
 232                  FT_Fixed      ncv )
 233   {
 234     int  j;
 235 
 236 
 237     if ( ncv &lt;= axismap-&gt;blend_points[0] )
 238       return INT_TO_FIXED( axismap-&gt;design_points[0] );
 239 
 240     for ( j = 1; j &lt; axismap-&gt;num_points; j++ )
 241     {
 242       if ( ncv &lt;= axismap-&gt;blend_points[j] )
 243         return INT_TO_FIXED( axismap-&gt;design_points[j - 1] ) +
 244                ( axismap-&gt;design_points[j] - axismap-&gt;design_points[j - 1] ) *
 245                FT_DivFix( ncv - axismap-&gt;blend_points[j - 1],
 246                           axismap-&gt;blend_points[j] -
 247                             axismap-&gt;blend_points[j - 1] );
 248     }
 249 
 250     return INT_TO_FIXED( axismap-&gt;design_points[axismap-&gt;num_points - 1] );
 251   }
 252 
 253 
<a name="6" id="anc6"></a><span class="line-modified"> 254   /**************************************************************************</span>
<span class="line-modified"> 255    *</span>
<span class="line-modified"> 256    * Given a vector of weights, one for each design, figure out the</span>
<span class="line-modified"> 257    * normalized axis coordinates which gave rise to those weights.</span>
<span class="line-modified"> 258    */</span>
 259   static void
 260   mm_weights_unmap( FT_Fixed*  weights,
 261                     FT_Fixed*  axiscoords,
 262                     FT_UInt    axis_count )
 263   {
 264     FT_ASSERT( axis_count &lt;= T1_MAX_MM_AXIS );
 265 
 266     if ( axis_count == 1 )
 267       axiscoords[0] = weights[1];
 268 
 269     else if ( axis_count == 2 )
 270     {
 271       axiscoords[0] = weights[3] + weights[1];
 272       axiscoords[1] = weights[3] + weights[2];
 273     }
 274 
 275     else if ( axis_count == 3 )
 276     {
 277       axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
 278       axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
 279       axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
 280     }
 281 
 282     else
 283     {
 284       axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
 285                         weights[7] + weights[5] + weights[3] + weights[1];
 286       axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
 287                         weights[7] + weights[6] + weights[3] + weights[2];
 288       axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
 289                         weights[7] + weights[6] + weights[5] + weights[4];
 290       axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
 291                         weights[11] + weights[10] + weights[9] + weights[8];
 292     }
 293   }
 294 
 295 
<a name="7" id="anc7"></a><span class="line-modified"> 296   /**************************************************************************</span>
<span class="line-modified"> 297    *</span>
<span class="line-modified"> 298    * Just a wrapper around T1_Get_Multi_Master to support the different</span>
<span class="line-modified"> 299    * arguments needed by the GX var distortable fonts.</span>
<span class="line-modified"> 300    */</span>
 301   FT_LOCAL_DEF( FT_Error )
 302   T1_Get_MM_Var( T1_Face      face,
 303                  FT_MM_Var*  *master )
 304   {
 305     FT_Memory        memory = face-&gt;root.memory;
 306     FT_MM_Var       *mmvar = NULL;
 307     FT_Multi_Master  mmaster;
 308     FT_Error         error;
 309     FT_UInt          i;
 310     FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
 311     PS_Blend         blend = face-&gt;blend;
 312 
 313 
 314     error = T1_Get_Multi_Master( face, &amp;mmaster );
 315     if ( error )
 316       goto Exit;
 317     if ( FT_ALLOC( mmvar,
 318                    sizeof ( FT_MM_Var ) +
 319                      mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
 320       goto Exit;
 321 
 322     mmvar-&gt;num_axis        = mmaster.num_axis;
 323     mmvar-&gt;num_designs     = mmaster.num_designs;
 324     mmvar-&gt;num_namedstyles = 0;                           /* Not supported */
 325     mmvar-&gt;axis            = (FT_Var_Axis*)&amp;mmvar[1];
 326                                       /* Point to axes after MM_Var struct */
 327     mmvar-&gt;namedstyle      = NULL;
 328 
 329     for ( i = 0; i &lt; mmaster.num_axis; i++ )
 330     {
 331       mmvar-&gt;axis[i].name    = mmaster.axis[i].name;
 332       mmvar-&gt;axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum );
 333       mmvar-&gt;axis[i].maximum = INT_TO_FIXED( mmaster.axis[i].maximum );
 334       mmvar-&gt;axis[i].def     = ( mmvar-&gt;axis[i].minimum +
 335                                    mmvar-&gt;axis[i].maximum ) / 2;
 336                             /* Does not apply.  But this value is in range */
 337       mmvar-&gt;axis[i].strid   = ~0U;                      /* Does not apply */
 338       mmvar-&gt;axis[i].tag     = ~0U;                      /* Does not apply */
 339 
 340       if ( !mmvar-&gt;axis[i].name )
 341         continue;
 342 
 343       if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Weight&quot; ) == 0 )
 344         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;g&#39;, &#39;h&#39;, &#39;t&#39; );
 345       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Width&quot; ) == 0 )
 346         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39; );
 347       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;OpticalSize&quot; ) == 0 )
 348         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;o&#39;, &#39;p&#39;, &#39;s&#39;, &#39;z&#39; );
 349     }
 350 
<a name="8" id="anc8"></a><span class="line-modified"> 351     mm_weights_unmap( blend-&gt;default_weight_vector,</span>
<span class="line-modified"> 352                       axiscoords,</span>
<span class="line-modified"> 353                       blend-&gt;num_axis );</span>


 354 
<a name="9" id="anc9"></a><span class="line-modified"> 355     for ( i = 0; i &lt; mmaster.num_axis; i++ )</span>
<span class="line-modified"> 356       mmvar-&gt;axis[i].def = mm_axis_unmap( &amp;blend-&gt;design_map[i],</span>
<span class="line-modified"> 357                                           axiscoords[i] );</span>

 358 
 359     *master = mmvar;
 360 
 361   Exit:
 362     return error;
 363   }
 364 
 365 
 366   static FT_Error
 367   t1_set_mm_blend( T1_Face    face,
 368                    FT_UInt    num_coords,
 369                    FT_Fixed*  coords )
 370   {
 371     PS_Blend  blend = face-&gt;blend;
 372     FT_UInt   n, m;
 373 
 374     FT_Bool  have_diff = 0;
 375 
 376 
 377     if ( !blend )
 378       return FT_THROW( Invalid_Argument );
 379 
 380     if ( num_coords &gt; blend-&gt;num_axis )
 381       num_coords = blend-&gt;num_axis;
 382 
 383     /* recompute the weight vector from the blend coordinates */
 384     for ( n = 0; n &lt; blend-&gt;num_designs; n++ )
 385     {
 386       FT_Fixed  result = 0x10000L;  /* 1.0 fixed */
<a name="10" id="anc10"></a><span class="line-added"> 387       FT_Fixed  factor;</span>
 388 
 389 
 390       for ( m = 0; m &lt; blend-&gt;num_axis; m++ )
 391       {
<a name="11" id="anc11"></a>



 392         /* use a default value if we don&#39;t have a coordinate */
<a name="12" id="anc12"></a><span class="line-modified"> 393         if ( m &gt;= num_coords )</span>
<span class="line-modified"> 394         {</span>
<span class="line-modified"> 395           result &gt;&gt;= 1;</span>
<span class="line-modified"> 396           continue;</span>
<span class="line-modified"> 397         }</span>
 398 
<a name="13" id="anc13"></a><span class="line-added"> 399         /* get current blend axis position */</span>
<span class="line-added"> 400         factor = coords[m];</span>
 401         if ( ( n &amp; ( 1 &lt;&lt; m ) ) == 0 )
 402           factor = 0x10000L - factor;
 403 
<a name="14" id="anc14"></a><span class="line-added"> 404         if ( factor &lt;= 0 )</span>
<span class="line-added"> 405         {</span>
<span class="line-added"> 406           result = 0;</span>
<span class="line-added"> 407           break;</span>
<span class="line-added"> 408         }</span>
<span class="line-added"> 409         else if ( factor &gt;= 0x10000L )</span>
<span class="line-added"> 410           continue;</span>
<span class="line-added"> 411 </span>
 412         result = FT_MulFix( result, factor );
 413       }
 414 
 415       if ( blend-&gt;weight_vector[n] != result )
 416       {
 417         blend-&gt;weight_vector[n] = result;
 418         have_diff               = 1;
 419       }
 420     }
 421 
 422     /* return value -1 indicates `no change&#39; */
 423     return have_diff ? FT_Err_Ok : -1;
 424   }
 425 
 426 
 427   FT_LOCAL_DEF( FT_Error )
 428   T1_Set_MM_Blend( T1_Face    face,
 429                    FT_UInt    num_coords,
 430                    FT_Fixed*  coords )
 431   {
 432     FT_Error  error;
 433 
 434 
 435     error = t1_set_mm_blend( face, num_coords, coords );
 436     if ( error )
 437       return error;
 438 
 439     if ( num_coords )
 440       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
 441     else
 442       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
 443 
 444     return FT_Err_Ok;
 445   }
 446 
 447 
 448   FT_LOCAL_DEF( FT_Error )
 449   T1_Get_MM_Blend( T1_Face    face,
 450                    FT_UInt    num_coords,
 451                    FT_Fixed*  coords )
 452   {
 453     PS_Blend  blend = face-&gt;blend;
 454 
 455     FT_Fixed  axiscoords[4];
 456     FT_UInt   i, nc;
 457 
 458 
 459     if ( !blend )
 460       return FT_THROW( Invalid_Argument );
 461 
 462     mm_weights_unmap( blend-&gt;weight_vector,
 463                       axiscoords,
 464                       blend-&gt;num_axis );
 465 
 466     nc = num_coords;
 467     if ( num_coords &gt; blend-&gt;num_axis )
 468     {
 469       FT_TRACE2(( &quot;T1_Get_MM_Blend: only using first %d of %d coordinates\n&quot;,
 470                   blend-&gt;num_axis, num_coords ));
 471       nc = blend-&gt;num_axis;
 472     }
 473 
 474     for ( i = 0; i &lt; nc; i++ )
 475       coords[i] = axiscoords[i];
 476     for ( ; i &lt; num_coords; i++ )
 477       coords[i] = 0x8000;
 478 
 479     return FT_Err_Ok;
 480   }
 481 
 482 
<a name="15" id="anc15"></a><span class="line-added"> 483   FT_LOCAL_DEF( FT_Error )</span>
<span class="line-added"> 484   T1_Set_MM_WeightVector( T1_Face    face,</span>
<span class="line-added"> 485                           FT_UInt    len,</span>
<span class="line-added"> 486                           FT_Fixed*  weightvector )</span>
<span class="line-added"> 487   {</span>
<span class="line-added"> 488     PS_Blend  blend = face-&gt;blend;</span>
<span class="line-added"> 489     FT_UInt   i, n;</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 </span>
<span class="line-added"> 492     if ( !blend )</span>
<span class="line-added"> 493      return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 494 </span>
<span class="line-added"> 495     if ( !len &amp;&amp; !weightvector )</span>
<span class="line-added"> 496     {</span>
<span class="line-added"> 497       for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 498         blend-&gt;weight_vector[i] = blend-&gt;default_weight_vector[i];</span>
<span class="line-added"> 499     }</span>
<span class="line-added"> 500     else</span>
<span class="line-added"> 501     {</span>
<span class="line-added"> 502       if ( !weightvector )</span>
<span class="line-added"> 503         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505       n = len &lt; blend-&gt;num_designs ? len : blend-&gt;num_designs;</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507       for ( i = 0; i &lt; n; i++ )</span>
<span class="line-added"> 508         blend-&gt;weight_vector[i] = weightvector[i];</span>
<span class="line-added"> 509 </span>
<span class="line-added"> 510       for ( ; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 511         blend-&gt;weight_vector[i] = (FT_Fixed)0;</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513       if ( len )</span>
<span class="line-added"> 514         face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;</span>
<span class="line-added"> 515       else</span>
<span class="line-added"> 516         face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;</span>
<span class="line-added"> 517     }</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519     return FT_Err_Ok;</span>
<span class="line-added"> 520   }</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523   FT_LOCAL_DEF( FT_Error )</span>
<span class="line-added"> 524   T1_Get_MM_WeightVector( T1_Face    face,</span>
<span class="line-added"> 525                           FT_UInt*   len,</span>
<span class="line-added"> 526                           FT_Fixed*  weightvector )</span>
<span class="line-added"> 527   {</span>
<span class="line-added"> 528     PS_Blend  blend = face-&gt;blend;</span>
<span class="line-added"> 529     FT_UInt   i;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532     if ( !blend )</span>
<span class="line-added"> 533       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535     if ( *len &lt; blend-&gt;num_designs )</span>
<span class="line-added"> 536     {</span>
<span class="line-added"> 537       *len = blend-&gt;num_designs;</span>
<span class="line-added"> 538       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 539     }</span>
<span class="line-added"> 540 </span>
<span class="line-added"> 541     for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 542       weightvector[i] = blend-&gt;weight_vector[i];</span>
<span class="line-added"> 543     for ( ; i &lt; *len; i++ )</span>
<span class="line-added"> 544       weightvector[i] = (FT_Fixed)0;</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     *len = blend-&gt;num_designs;</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548     return FT_Err_Ok;</span>
<span class="line-added"> 549   }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551 </span>
 552   FT_LOCAL_DEF( FT_Error )
 553   T1_Set_MM_Design( T1_Face   face,
 554                     FT_UInt   num_coords,
 555                     FT_Long*  coords )
 556   {
 557     FT_Error  error;
 558     PS_Blend  blend = face-&gt;blend;
 559     FT_UInt   n, p;
 560     FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];
 561 
 562 
 563     if ( !blend )
 564       return FT_THROW( Invalid_Argument );
 565 
 566     if ( num_coords &gt; blend-&gt;num_axis )
 567       num_coords = blend-&gt;num_axis;
 568 
 569     /* compute the blend coordinates through the blend design map */
 570 
 571     for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
 572     {
 573       FT_Long       design;
 574       FT_Fixed      the_blend;
 575       PS_DesignMap  map     = blend-&gt;design_map + n;
 576       FT_Long*      designs = map-&gt;design_points;
 577       FT_Fixed*     blends  = map-&gt;blend_points;
 578       FT_Int        before  = -1, after = -1;
 579 
 580 
 581       /* use a default value if we don&#39;t have a coordinate */
 582       if ( n &lt; num_coords )
 583         design = coords[n];
 584       else
 585         design = ( designs[map-&gt;num_points - 1] - designs[0] ) / 2;
 586 
 587       for ( p = 0; p &lt; (FT_UInt)map-&gt;num_points; p++ )
 588       {
 589         FT_Long  p_design = designs[p];
 590 
 591 
 592         /* exact match? */
 593         if ( design == p_design )
 594         {
 595           the_blend = blends[p];
 596           goto Found;
 597         }
 598 
 599         if ( design &lt; p_design )
 600         {
 601           after = (FT_Int)p;
 602           break;
 603         }
 604 
 605         before = (FT_Int)p;
 606       }
 607 
 608       /* now interpolate if necessary */
 609       if ( before &lt; 0 )
 610         the_blend = blends[0];
 611 
 612       else if ( after &lt; 0 )
 613         the_blend = blends[map-&gt;num_points - 1];
 614 
 615       else
 616         the_blend = FT_MulDiv( design         - designs[before],
 617                                blends [after] - blends [before],
 618                                designs[after] - designs[before] );
 619 
 620     Found:
 621       final_blends[n] = the_blend;
 622     }
 623 
 624     error = t1_set_mm_blend( face, blend-&gt;num_axis, final_blends );
 625     if ( error )
 626       return error;
 627 
 628     if ( num_coords )
 629       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
 630     else
 631       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
 632 
 633     return FT_Err_Ok;
 634   }
 635 
 636 
 637   /* MM fonts don&#39;t have named instances, so only the design is reset */
 638 
 639   FT_LOCAL_DEF( FT_Error )
 640   T1_Reset_MM_Blend( T1_Face  face,
 641                      FT_UInt  instance_index )
 642   {
 643     FT_UNUSED( instance_index );
 644 
 645     return T1_Set_MM_Blend( face, 0, NULL );
 646   }
 647 
 648 
<a name="16" id="anc16"></a><span class="line-modified"> 649   /**************************************************************************</span>
<span class="line-modified"> 650    *</span>
<span class="line-modified"> 651    * Just a wrapper around T1_Set_MM_Design to support the different</span>
<span class="line-modified"> 652    * arguments needed by the GX var distortable fonts.</span>
<span class="line-modified"> 653    */</span>
 654   FT_LOCAL_DEF( FT_Error )
 655   T1_Set_Var_Design( T1_Face    face,
 656                      FT_UInt    num_coords,
 657                      FT_Fixed*  coords )
 658   {
 659      FT_Long  lcoords[T1_MAX_MM_AXIS];
 660      FT_UInt  i;
 661 
 662 
 663      if ( num_coords &gt; T1_MAX_MM_AXIS )
 664        num_coords = T1_MAX_MM_AXIS;
 665 
 666      for ( i = 0; i &lt; num_coords; i++ )
 667        lcoords[i] = FIXED_TO_INT( coords[i] );
 668 
 669      return T1_Set_MM_Design( face, num_coords, lcoords );
 670   }
 671 
 672 
 673   FT_LOCAL_DEF( FT_Error )
 674   T1_Get_Var_Design( T1_Face    face,
 675                      FT_UInt    num_coords,
 676                      FT_Fixed*  coords )
 677   {
 678     PS_Blend  blend = face-&gt;blend;
 679 
 680     FT_Fixed  axiscoords[4];
 681     FT_UInt   i, nc;
 682 
 683 
 684     if ( !blend )
 685       return FT_THROW( Invalid_Argument );
 686 
 687     mm_weights_unmap( blend-&gt;weight_vector,
 688                       axiscoords,
 689                       blend-&gt;num_axis );
 690 
 691     nc = num_coords;
 692     if ( num_coords &gt; blend-&gt;num_axis )
 693     {
 694       FT_TRACE2(( &quot;T1_Get_Var_Design:&quot;
 695                   &quot; only using first %d of %d coordinates\n&quot;,
 696                   blend-&gt;num_axis, num_coords ));
 697       nc = blend-&gt;num_axis;
 698     }
 699 
 700     for ( i = 0; i &lt; nc; i++ )
 701       coords[i] = mm_axis_unmap( &amp;blend-&gt;design_map[i], axiscoords[i] );
 702     for ( ; i &lt; num_coords; i++ )
 703       coords[i] = 0;
 704 
 705     return FT_Err_Ok;
 706   }
 707 
 708 
 709   FT_LOCAL_DEF( void )
 710   T1_Done_Blend( T1_Face  face )
 711   {
 712     FT_Memory  memory = face-&gt;root.memory;
 713     PS_Blend   blend  = face-&gt;blend;
 714 
 715 
 716     if ( blend )
 717     {
 718       FT_UInt  num_designs = blend-&gt;num_designs;
 719       FT_UInt  num_axis    = blend-&gt;num_axis;
 720       FT_UInt  n;
 721 
 722 
 723       /* release design pos table */
 724       FT_FREE( blend-&gt;design_pos[0] );
 725       for ( n = 1; n &lt; num_designs; n++ )
 726         blend-&gt;design_pos[n] = NULL;
 727 
 728       /* release blend `private&#39; and `font info&#39; dictionaries */
 729       FT_FREE( blend-&gt;privates[1] );
 730       FT_FREE( blend-&gt;font_infos[1] );
 731       FT_FREE( blend-&gt;bboxes[1] );
 732 
 733       for ( n = 0; n &lt; num_designs; n++ )
 734       {
 735         blend-&gt;privates  [n] = NULL;
 736         blend-&gt;font_infos[n] = NULL;
 737         blend-&gt;bboxes    [n] = NULL;
 738       }
 739 
 740       /* release weight vectors */
 741       FT_FREE( blend-&gt;weight_vector );
 742       blend-&gt;default_weight_vector = NULL;
 743 
 744       /* release axis names */
 745       for ( n = 0; n &lt; num_axis; n++ )
 746         FT_FREE( blend-&gt;axis_names[n] );
 747 
 748       /* release design map */
 749       for ( n = 0; n &lt; num_axis; n++ )
 750       {
 751         PS_DesignMap  dmap = blend-&gt;design_map + n;
 752 
 753 
 754         FT_FREE( dmap-&gt;design_points );
 755         dmap-&gt;num_points = 0;
 756       }
 757 
 758       FT_FREE( face-&gt;blend );
 759     }
 760   }
 761 
 762 
 763   static void
 764   parse_blend_axis_types( T1_Face    face,
 765                           T1_Loader  loader )
 766   {
 767     T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 768     FT_Int       n, num_axis;
 769     FT_Error     error = FT_Err_Ok;
 770     PS_Blend     blend;
 771     FT_Memory    memory;
 772 
 773 
 774     /* take an array of objects */
 775     T1_ToTokenArray( &amp;loader-&gt;parser, axis_tokens,
 776                      T1_MAX_MM_AXIS, &amp;num_axis );
 777     if ( num_axis &lt; 0 )
 778     {
 779       error = FT_ERR( Ignore );
 780       goto Exit;
 781     }
 782     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 783     {
 784       FT_ERROR(( &quot;parse_blend_axis_types: incorrect number of axes: %d\n&quot;,
 785                  num_axis ));
 786       error = FT_THROW( Invalid_File_Format );
 787       goto Exit;
 788     }
 789 
 790     /* allocate blend if necessary */
 791     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 792     if ( error )
 793       goto Exit;
 794 
<a name="17" id="anc17"></a><span class="line-added"> 795     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 796 </span>
 797     blend  = face-&gt;blend;
 798     memory = face-&gt;root.memory;
 799 
 800     /* each token is an immediate containing the name of the axis */
 801     for ( n = 0; n &lt; num_axis; n++ )
 802     {
 803       T1_Token  token = axis_tokens + n;
 804       FT_Byte*  name;
 805       FT_UInt   len;
 806 
 807 
 808       /* skip first slash, if any */
 809       if ( token-&gt;start[0] == &#39;/&#39; )
 810         token-&gt;start++;
 811 
 812       len = (FT_UInt)( token-&gt;limit - token-&gt;start );
 813       if ( len == 0 )
 814       {
 815         error = FT_THROW( Invalid_File_Format );
 816         goto Exit;
 817       }
 818 
<a name="18" id="anc18"></a><span class="line-added"> 819       FT_TRACE4(( &quot; /%.*s&quot;, len, token-&gt;start ));</span>
<span class="line-added"> 820 </span>
 821       name = (FT_Byte*)blend-&gt;axis_names[n];
 822       if ( name )
 823       {
 824         FT_TRACE0(( &quot;parse_blend_axis_types:&quot;
<a name="19" id="anc19"></a><span class="line-modified"> 825                     &quot; overwriting axis name `%s&#39; with `%.*s&#39;\n&quot;,</span>
 826                     name, len, token-&gt;start ));
 827         FT_FREE( name );
 828       }
 829 
 830       if ( FT_ALLOC( blend-&gt;axis_names[n], len + 1 ) )
 831         goto Exit;
 832 
 833       name = (FT_Byte*)blend-&gt;axis_names[n];
 834       FT_MEM_COPY( name, token-&gt;start, len );
 835       name[len] = &#39;\0&#39;;
 836     }
 837 
<a name="20" id="anc20"></a><span class="line-added"> 838     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added"> 839 </span>
 840   Exit:
 841     loader-&gt;parser.root.error = error;
 842   }
 843 
 844 
 845   static void
 846   parse_blend_design_positions( T1_Face    face,
 847                                 T1_Loader  loader )
 848   {
 849     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
 850     FT_Int       num_designs;
 851     FT_Int       num_axis;
 852     T1_Parser    parser = &amp;loader-&gt;parser;
 853 
 854     FT_Error     error = FT_Err_Ok;
 855     PS_Blend     blend;
 856 
 857 
 858     /* get the array of design tokens -- compute number of designs */
 859     T1_ToTokenArray( parser, design_tokens,
 860                      T1_MAX_MM_DESIGNS, &amp;num_designs );
 861     if ( num_designs &lt; 0 )
 862     {
 863       error = FT_ERR( Ignore );
 864       goto Exit;
 865     }
 866     if ( num_designs == 0 || num_designs &gt; T1_MAX_MM_DESIGNS )
 867     {
 868       FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 869                  &quot; incorrect number of designs: %d\n&quot;,
 870                  num_designs ));
 871       error = FT_THROW( Invalid_File_Format );
 872       goto Exit;
 873     }
 874 
 875     {
 876       FT_Byte*  old_cursor = parser-&gt;root.cursor;
 877       FT_Byte*  old_limit  = parser-&gt;root.limit;
 878       FT_Int    n;
 879 
 880 
 881       blend    = face-&gt;blend;
 882       num_axis = 0;  /* make compiler happy */
 883 
<a name="21" id="anc21"></a><span class="line-added"> 884       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 885 </span>
 886       for ( n = 0; n &lt; num_designs; n++ )
 887       {
 888         T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 889         T1_Token     token;
 890         FT_Int       axis, n_axis;
 891 
 892 
 893         /* read axis/coordinates tokens */
 894         token = design_tokens + n;
 895         parser-&gt;root.cursor = token-&gt;start;
 896         parser-&gt;root.limit  = token-&gt;limit;
 897         T1_ToTokenArray( parser, axis_tokens, T1_MAX_MM_AXIS, &amp;n_axis );
 898 
 899         if ( n == 0 )
 900         {
 901           if ( n_axis &lt;= 0 || n_axis &gt; T1_MAX_MM_AXIS )
 902           {
 903             FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 904                        &quot; invalid number of axes: %d\n&quot;,
 905                        n_axis ));
 906             error = FT_THROW( Invalid_File_Format );
 907             goto Exit;
 908           }
 909 
 910           num_axis = n_axis;
 911           error = t1_allocate_blend( face,
 912                                      (FT_UInt)num_designs,
 913                                      (FT_UInt)num_axis );
 914           if ( error )
 915             goto Exit;
 916           blend = face-&gt;blend;
 917         }
 918         else if ( n_axis != num_axis )
 919         {
 920           FT_ERROR(( &quot;parse_blend_design_positions: incorrect table\n&quot; ));
 921           error = FT_THROW( Invalid_File_Format );
 922           goto Exit;
 923         }
 924 
 925         /* now read each axis token into the design position */
<a name="22" id="anc22"></a><span class="line-added"> 926         FT_TRACE4(( &quot; [&quot; )) ;</span>
 927         for ( axis = 0; axis &lt; n_axis; axis++ )
 928         {
 929           T1_Token  token2 = axis_tokens + axis;
 930 
 931 
 932           parser-&gt;root.cursor = token2-&gt;start;
 933           parser-&gt;root.limit  = token2-&gt;limit;
 934           blend-&gt;design_pos[n][axis] = T1_ToFixed( parser, 0 );
<a name="23" id="anc23"></a><span class="line-added"> 935           FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;design_pos[n][axis] / 65536 ));</span>
 936         }
<a name="24" id="anc24"></a><span class="line-added"> 937         FT_TRACE4(( &quot;]&quot; )) ;</span>
 938       }
 939 
<a name="25" id="anc25"></a><span class="line-added"> 940       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added"> 941 </span>
 942       loader-&gt;parser.root.cursor = old_cursor;
 943       loader-&gt;parser.root.limit  = old_limit;
 944     }
 945 
 946   Exit:
 947     loader-&gt;parser.root.error = error;
 948   }
 949 
 950 
 951   static void
 952   parse_blend_design_map( T1_Face    face,
 953                           T1_Loader  loader )
 954   {
 955     FT_Error     error  = FT_Err_Ok;
 956     T1_Parser    parser = &amp;loader-&gt;parser;
 957     PS_Blend     blend;
 958     T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 959     FT_Int       n, num_axis;
 960     FT_Byte*     old_cursor;
 961     FT_Byte*     old_limit;
 962     FT_Memory    memory = face-&gt;root.memory;
 963 
 964 
 965     T1_ToTokenArray( parser, axis_tokens,
 966                      T1_MAX_MM_AXIS, &amp;num_axis );
 967     if ( num_axis &lt; 0 )
 968     {
 969       error = FT_ERR( Ignore );
 970       goto Exit;
 971     }
 972     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 973     {
 974       FT_ERROR(( &quot;parse_blend_design_map: incorrect number of axes: %d\n&quot;,
 975                  num_axis ));
 976       error = FT_THROW( Invalid_File_Format );
 977       goto Exit;
 978     }
 979 
 980     old_cursor = parser-&gt;root.cursor;
 981     old_limit  = parser-&gt;root.limit;
 982 
 983     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 984     if ( error )
 985       goto Exit;
 986     blend = face-&gt;blend;
 987 
<a name="26" id="anc26"></a><span class="line-added"> 988     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 989 </span>
 990     /* now read each axis design map */
 991     for ( n = 0; n &lt; num_axis; n++ )
 992     {
 993       PS_DesignMap  map = blend-&gt;design_map + n;
 994       T1_Token      axis_token;
 995       T1_TokenRec   point_tokens[T1_MAX_MM_MAP_POINTS];
 996       FT_Int        p, num_points;
 997 
 998 
 999       axis_token = axis_tokens + n;
1000 
1001       parser-&gt;root.cursor = axis_token-&gt;start;
1002       parser-&gt;root.limit  = axis_token-&gt;limit;
1003       T1_ToTokenArray( parser, point_tokens,
1004                        T1_MAX_MM_MAP_POINTS, &amp;num_points );
1005 
<a name="27" id="anc27"></a><span class="line-added">1006       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1007 </span>
1008       if ( num_points &lt;= 0 || num_points &gt; T1_MAX_MM_MAP_POINTS )
1009       {
1010         FT_ERROR(( &quot;parse_blend_design_map: incorrect table\n&quot; ));
1011         error = FT_THROW( Invalid_File_Format );
1012         goto Exit;
1013       }
1014 
1015       if ( map-&gt;design_points )
1016       {
1017         FT_ERROR(( &quot;parse_blend_design_map: duplicate table\n&quot; ));
1018         error = FT_THROW( Invalid_File_Format );
1019         goto Exit;
1020       }
1021 
1022       /* allocate design map data */
1023       if ( FT_NEW_ARRAY( map-&gt;design_points, num_points * 2 ) )
1024         goto Exit;
1025       map-&gt;blend_points = map-&gt;design_points + num_points;
1026       map-&gt;num_points   = (FT_Byte)num_points;
1027 
1028       for ( p = 0; p &lt; num_points; p++ )
1029       {
1030         T1_Token  point_token;
1031 
1032 
1033         point_token = point_tokens + p;
1034 
1035         /* don&#39;t include delimiting brackets */
1036         parser-&gt;root.cursor = point_token-&gt;start + 1;
1037         parser-&gt;root.limit  = point_token-&gt;limit - 1;
1038 
1039         map-&gt;design_points[p] = T1_ToInt( parser );
1040         map-&gt;blend_points [p] = T1_ToFixed( parser, 0 );
<a name="28" id="anc28"></a><span class="line-added">1041 </span>
<span class="line-added">1042         FT_TRACE4(( &quot; [%d %f]&quot;,</span>
<span class="line-added">1043                     map-&gt;design_points[p],</span>
<span class="line-added">1044                     (double)map-&gt;blend_points[p] / 65536 ));</span>
1045       }
<a name="29" id="anc29"></a><span class="line-added">1046 </span>
<span class="line-added">1047       FT_TRACE4(( &quot;]&quot; ));</span>
1048     }
1049 
<a name="30" id="anc30"></a><span class="line-added">1050     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1051 </span>
1052     parser-&gt;root.cursor = old_cursor;
1053     parser-&gt;root.limit  = old_limit;
1054 
1055   Exit:
1056     parser-&gt;root.error = error;
1057   }
1058 
1059 
1060   static void
1061   parse_weight_vector( T1_Face    face,
1062                        T1_Loader  loader )
1063   {
1064     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
1065     FT_Int       num_designs;
1066     FT_Error     error  = FT_Err_Ok;
1067     T1_Parser    parser = &amp;loader-&gt;parser;
1068     PS_Blend     blend  = face-&gt;blend;
1069     T1_Token     token;
1070     FT_Int       n;
1071     FT_Byte*     old_cursor;
1072     FT_Byte*     old_limit;
1073 
1074 
1075     T1_ToTokenArray( parser, design_tokens,
1076                      T1_MAX_MM_DESIGNS, &amp;num_designs );
1077     if ( num_designs &lt; 0 )
1078     {
1079       error = FT_ERR( Ignore );
1080       goto Exit;
1081     }
1082     if ( num_designs == 0 || num_designs &gt; T1_MAX_MM_DESIGNS )
1083     {
1084       FT_ERROR(( &quot;parse_weight_vector:&quot;
1085                  &quot; incorrect number of designs: %d\n&quot;,
1086                  num_designs ));
1087       error = FT_THROW( Invalid_File_Format );
1088       goto Exit;
1089     }
1090 
1091     if ( !blend || !blend-&gt;num_designs )
1092     {
1093       error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );
1094       if ( error )
1095         goto Exit;
1096       blend = face-&gt;blend;
1097     }
1098     else if ( blend-&gt;num_designs != (FT_UInt)num_designs )
1099     {
1100       FT_ERROR(( &quot;parse_weight_vector:&quot;
1101                  &quot; /BlendDesignPosition and /WeightVector have\n&quot;
1102                  &quot;                    &quot;
1103                  &quot; different number of elements\n&quot; ));
1104       error = FT_THROW( Invalid_File_Format );
1105       goto Exit;
1106     }
1107 
1108     old_cursor = parser-&gt;root.cursor;
1109     old_limit  = parser-&gt;root.limit;
1110 
<a name="31" id="anc31"></a><span class="line-added">1111     FT_TRACE4(( &quot;[&quot; ));</span>
<span class="line-added">1112 </span>
1113     for ( n = 0; n &lt; num_designs; n++ )
1114     {
1115       token = design_tokens + n;
1116       parser-&gt;root.cursor = token-&gt;start;
1117       parser-&gt;root.limit  = token-&gt;limit;
1118 
1119       blend-&gt;default_weight_vector[n] =
1120       blend-&gt;weight_vector[n]         = T1_ToFixed( parser, 0 );
<a name="32" id="anc32"></a><span class="line-added">1121 </span>
<span class="line-added">1122       FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;weight_vector[n] / 65536 ));</span>
1123     }
1124 
<a name="33" id="anc33"></a><span class="line-added">1125     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1126 </span>
1127     parser-&gt;root.cursor = old_cursor;
1128     parser-&gt;root.limit  = old_limit;
1129 
1130   Exit:
1131     parser-&gt;root.error = error;
1132   }
1133 
1134 
1135   /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
1136   /* we&#39;re only interested in the number of array elements */
1137   static void
1138   parse_buildchar( T1_Face    face,
1139                    T1_Loader  loader )
1140   {
1141     face-&gt;len_buildchar = (FT_UInt)T1_ToFixedArray( &amp;loader-&gt;parser,
1142                                                     0, NULL, 0 );
<a name="34" id="anc34"></a><span class="line-added">1143 </span>
<span class="line-added">1144 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1145     {</span>
<span class="line-added">1146       FT_UInt  i;</span>
<span class="line-added">1147 </span>
<span class="line-added">1148 </span>
<span class="line-added">1149       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1150       for ( i = 0; i &lt; face-&gt;len_buildchar; i++ )</span>
<span class="line-added">1151         FT_TRACE4(( &quot; 0&quot; ));</span>
<span class="line-added">1152 </span>
<span class="line-added">1153       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1154     }</span>
<span class="line-added">1155 #endif</span>
<span class="line-added">1156 </span>
1157     return;
1158   }
1159 
1160 
1161 #endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
1162 
1163 
1164 
1165 
1166   /*************************************************************************/
1167   /*************************************************************************/
1168   /*****                                                               *****/
1169   /*****                      TYPE 1 SYMBOL PARSING                    *****/
1170   /*****                                                               *****/
1171   /*************************************************************************/
1172   /*************************************************************************/
1173 
1174   static FT_Error
1175   t1_load_keyword( T1_Face         face,
1176                    T1_Loader       loader,
1177                    const T1_Field  field )
1178   {
1179     FT_Error  error;
1180     void*     dummy_object;
1181     void**    objects;
1182     FT_UInt   max_objects;
1183     PS_Blend  blend = face-&gt;blend;
1184 
1185 
1186     if ( blend &amp;&amp; blend-&gt;num_designs == 0 )
1187       blend = NULL;
1188 
1189     /* if the keyword has a dedicated callback, call it */
1190     if ( field-&gt;type == T1_FIELD_TYPE_CALLBACK )
1191     {
<a name="35" id="anc35"></a><span class="line-added">1192       FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="line-added">1193 </span>
1194       field-&gt;reader( (FT_Face)face, loader );
1195       error = loader-&gt;parser.root.error;
1196       goto Exit;
1197     }
1198 
1199     /* now, the keyword is either a simple field, or a table of fields; */
1200     /* we are now going to take care of it                              */
1201     switch ( field-&gt;location )
1202     {
1203     case T1_FIELD_LOCATION_FONT_INFO:
1204       dummy_object = &amp;face-&gt;type1.font_info;
1205       objects      = &amp;dummy_object;
1206       max_objects  = 0;
1207 
1208       if ( blend )
1209       {
1210         objects     = (void**)blend-&gt;font_infos;
1211         max_objects = blend-&gt;num_designs;
1212       }
1213       break;
1214 
1215     case T1_FIELD_LOCATION_FONT_EXTRA:
1216       dummy_object = &amp;face-&gt;type1.font_extra;
1217       objects      = &amp;dummy_object;
1218       max_objects  = 0;
1219       break;
1220 
1221     case T1_FIELD_LOCATION_PRIVATE:
1222       dummy_object = &amp;face-&gt;type1.private_dict;
1223       objects      = &amp;dummy_object;
1224       max_objects  = 0;
1225 
1226       if ( blend )
1227       {
1228         objects     = (void**)blend-&gt;privates;
1229         max_objects = blend-&gt;num_designs;
1230       }
1231       break;
1232 
1233     case T1_FIELD_LOCATION_BBOX:
1234       dummy_object = &amp;face-&gt;type1.font_bbox;
1235       objects      = &amp;dummy_object;
1236       max_objects  = 0;
1237 
1238       if ( blend )
1239       {
1240         objects     = (void**)blend-&gt;bboxes;
1241         max_objects = blend-&gt;num_designs;
1242       }
1243       break;
1244 
1245     case T1_FIELD_LOCATION_LOADER:
1246       dummy_object = loader;
1247       objects      = &amp;dummy_object;
1248       max_objects  = 0;
1249       break;
1250 
1251     case T1_FIELD_LOCATION_FACE:
1252       dummy_object = face;
1253       objects      = &amp;dummy_object;
1254       max_objects  = 0;
1255       break;
1256 
1257 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
1258     case T1_FIELD_LOCATION_BLEND:
1259       dummy_object = face-&gt;blend;
1260       objects      = &amp;dummy_object;
1261       max_objects  = 0;
1262       break;
1263 #endif
1264 
1265     default:
1266       dummy_object = &amp;face-&gt;type1;
1267       objects      = &amp;dummy_object;
1268       max_objects  = 0;
1269     }
1270 
<a name="36" id="anc36"></a><span class="line-added">1271     FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="line-added">1272 </span>
1273     if ( *objects )
1274     {
1275       if ( field-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
1276            field-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
1277         error = T1_Load_Field_Table( &amp;loader-&gt;parser, field,
1278                                      objects, max_objects, 0 );
1279       else
1280         error = T1_Load_Field( &amp;loader-&gt;parser, field,
1281                                objects, max_objects, 0 );
1282     }
1283     else
1284     {
1285       FT_TRACE1(( &quot;t1_load_keyword: ignoring keyword `%s&#39;&quot;
1286                   &quot; which is not valid at this point\n&quot;
1287                   &quot;                 (probably due to missing keywords)\n&quot;,
1288                  field-&gt;ident ));
1289       error = FT_Err_Ok;
1290     }
1291 
<a name="37" id="anc37"></a><span class="line-added">1292     FT_TRACE4(( &quot;\n&quot; ));</span>
<span class="line-added">1293 </span>
1294   Exit:
1295     return error;
1296   }
1297 
1298 
1299   static void
1300   parse_private( T1_Face    face,
1301                  T1_Loader  loader )
1302   {
1303     FT_UNUSED( face );
1304 
1305     loader-&gt;keywords_encountered |= T1_PRIVATE;
<a name="38" id="anc38"></a><span class="line-added">1306 </span>
<span class="line-added">1307     FT_TRACE4(( &quot;\n&quot; ));</span>
1308   }
1309 
1310 
1311   /* return 1 in case of success */
1312 
1313   static int
1314   read_binary_data( T1_Parser  parser,
1315                     FT_ULong*  size,
1316                     FT_Byte**  base,
1317                     FT_Bool    incremental )
1318   {
1319     FT_Byte*  cur;
1320     FT_Byte*  limit = parser-&gt;root.limit;
1321 
1322 
1323     /* the binary data has one of the following formats */
1324     /*                                                  */
1325     /*   `size&#39; [white*] RD white ....... ND            */
1326     /*   `size&#39; [white*] -| white ....... |-            */
1327     /*                                                  */
1328 
1329     T1_Skip_Spaces( parser );
1330 
1331     cur = parser-&gt;root.cursor;
1332 
1333     if ( cur &lt; limit &amp;&amp; ft_isdigit( *cur ) )
1334     {
1335       FT_Long  s = T1_ToInt( parser );
1336 
1337 
1338       T1_Skip_PS_Token( parser );   /* `RD&#39; or `-|&#39; or something else */
1339 
1340       /* there is only one whitespace char after the */
1341       /* `RD&#39; or `-|&#39; token                          */
1342       *base = parser-&gt;root.cursor + 1;
1343 
1344       if ( s &gt;= 0 &amp;&amp; s &lt; limit - *base )
1345       {
1346         parser-&gt;root.cursor += s + 1;
1347         *size = (FT_ULong)s;
1348         return !parser-&gt;root.error;
1349       }
1350     }
1351 
1352     if( !incremental )
1353     {
1354       FT_ERROR(( &quot;read_binary_data: invalid size field\n&quot; ));
1355       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1356     }
1357 
1358     return 0;
1359   }
1360 
1361 
1362   /* We now define the routines to handle the `/Encoding&#39;, `/Subrs&#39;, */
1363   /* and `/CharStrings&#39; dictionaries.                                */
1364 
1365   static void
1366   t1_parse_font_matrix( T1_Face    face,
1367                         T1_Loader  loader )
1368   {
1369     T1_Parser   parser = &amp;loader-&gt;parser;
1370     FT_Matrix*  matrix = &amp;face-&gt;type1.font_matrix;
1371     FT_Vector*  offset = &amp;face-&gt;type1.font_offset;
1372     FT_Face     root   = (FT_Face)&amp;face-&gt;root;
1373     FT_Fixed    temp[6];
1374     FT_Fixed    temp_scale;
1375     FT_Int      result;
1376 
1377 
1378     /* input is scaled by 1000 to accommodate default FontMatrix */
1379     result = T1_ToFixedArray( parser, 6, temp, 3 );
1380 
1381     if ( result &lt; 6 )
1382     {
1383       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1384       return;
1385     }
1386 
<a name="39" id="anc39"></a><span class="line-added">1387     FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,</span>
<span class="line-added">1388                 (double)temp[0] / 65536 / 1000,</span>
<span class="line-added">1389                 (double)temp[1] / 65536 / 1000,</span>
<span class="line-added">1390                 (double)temp[2] / 65536 / 1000,</span>
<span class="line-added">1391                 (double)temp[3] / 65536 / 1000,</span>
<span class="line-added">1392                 (double)temp[4] / 65536 / 1000,</span>
<span class="line-added">1393                 (double)temp[5] / 65536 / 1000 ));</span>
<span class="line-added">1394 </span>
1395     temp_scale = FT_ABS( temp[3] );
1396 
1397     if ( temp_scale == 0 )
1398     {
1399       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));
1400       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1401       return;
1402     }
1403 
1404     /* atypical case */
1405     if ( temp_scale != 0x10000L )
1406     {
1407       /* set units per EM based on FontMatrix values */
1408       root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
1409 
1410       temp[0] = FT_DivFix( temp[0], temp_scale );
1411       temp[1] = FT_DivFix( temp[1], temp_scale );
1412       temp[2] = FT_DivFix( temp[2], temp_scale );
1413       temp[4] = FT_DivFix( temp[4], temp_scale );
1414       temp[5] = FT_DivFix( temp[5], temp_scale );
1415       temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
1416     }
<a name="40" id="anc40"></a>
1417     matrix-&gt;xx = temp[0];
1418     matrix-&gt;yx = temp[1];
1419     matrix-&gt;xy = temp[2];
1420     matrix-&gt;yy = temp[3];
1421 
<a name="41" id="anc41"></a><span class="line-added">1422     if ( !FT_Matrix_Check( matrix ) )</span>
<span class="line-added">1423     {</span>
<span class="line-added">1424       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));</span>
<span class="line-added">1425       parser-&gt;root.error = FT_THROW( Invalid_File_Format );</span>
<span class="line-added">1426       return;</span>
<span class="line-added">1427     }</span>
<span class="line-added">1428 </span>
1429     /* note that the offsets must be expressed in integer font units */
1430     offset-&gt;x = temp[4] &gt;&gt; 16;
1431     offset-&gt;y = temp[5] &gt;&gt; 16;
1432   }
1433 
1434 
1435   static void
1436   parse_encoding( T1_Face    face,
1437                   T1_Loader  loader )
1438   {
1439     T1_Parser  parser = &amp;loader-&gt;parser;
1440     FT_Byte*   cur;
1441     FT_Byte*   limit  = parser-&gt;root.limit;
1442 
1443     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1444 
1445 
1446     T1_Skip_Spaces( parser );
1447     cur = parser-&gt;root.cursor;
1448     if ( cur &gt;= limit )
1449     {
1450       FT_ERROR(( &quot;parse_encoding: out of bounds\n&quot; ));
1451       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1452       return;
1453     }
1454 
1455     /* if we have a number or `[&#39;, the encoding is an array, */
1456     /* and we must load it now                               */
1457     if ( ft_isdigit( *cur ) || *cur == &#39;[&#39; )
1458     {
1459       T1_Encoding  encode          = &amp;face-&gt;type1.encoding;
1460       FT_Int       count, array_size, n;
1461       PS_Table     char_table      = &amp;loader-&gt;encoding_table;
1462       FT_Memory    memory          = parser-&gt;root.memory;
1463       FT_Error     error;
1464       FT_Bool      only_immediates = 0;
1465 
1466 
1467       /* read the number of entries in the encoding; should be 256 */
1468       if ( *cur == &#39;[&#39; )
1469       {
1470         count           = 256;
1471         only_immediates = 1;
1472         parser-&gt;root.cursor++;
1473       }
1474       else
1475         count = (FT_Int)T1_ToInt( parser );
1476 
1477       array_size = count;
1478       if ( count &gt; 256 )
1479       {
1480         FT_TRACE2(( &quot;parse_encoding:&quot;
1481                     &quot; only using first 256 encoding array entries\n&quot; ));
1482         array_size = 256;
1483       }
1484 
1485       T1_Skip_Spaces( parser );
1486       if ( parser-&gt;root.cursor &gt;= limit )
1487         return;
1488 
1489       /* PostScript happily allows overwriting of encoding arrays */
1490       if ( encode-&gt;char_index )
1491       {
1492         FT_FREE( encode-&gt;char_index );
1493         FT_FREE( encode-&gt;char_name );
1494         T1_Release_Table( char_table );
1495       }
1496 
1497       /* we use a T1_Table to store our charnames */
1498       loader-&gt;num_chars = encode-&gt;num_chars = array_size;
1499       if ( FT_NEW_ARRAY( encode-&gt;char_index, array_size )     ||
1500            FT_NEW_ARRAY( encode-&gt;char_name,  array_size )     ||
1501            FT_SET_ERROR( psaux-&gt;ps_table_funcs-&gt;init(
1502                            char_table, array_size, memory ) ) )
1503       {
1504         parser-&gt;root.error = error;
1505         return;
1506       }
1507 
1508       /* We need to `zero&#39; out encoding_table.elements */
1509       for ( n = 0; n &lt; array_size; n++ )
<a name="42" id="anc42"></a><span class="line-modified">1510         (void)T1_Add_Table( char_table, n, &quot;.notdef&quot;, 8 );</span>





1511 
1512       /* Now we need to read records of the form                */
1513       /*                                                        */
1514       /*   ... charcode /charname ...                           */
1515       /*                                                        */
1516       /* for each entry in our table.                           */
1517       /*                                                        */
1518       /* We simply look for a number followed by an immediate   */
1519       /* name.  Note that this ignores correctly the sequence   */
1520       /* that is often seen in type1 fonts:                     */
1521       /*                                                        */
1522       /*   0 1 255 { 1 index exch /.notdef put } for dup        */
1523       /*                                                        */
1524       /* used to clean the encoding array before anything else. */
1525       /*                                                        */
1526       /* Alternatively, if the array is directly given as       */
1527       /*                                                        */
1528       /*   /Encoding [ ... ]                                    */
1529       /*                                                        */
1530       /* we only read immediates.                               */
1531 
1532       n = 0;
1533       T1_Skip_Spaces( parser );
1534 
1535       while ( parser-&gt;root.cursor &lt; limit )
1536       {
1537         cur = parser-&gt;root.cursor;
1538 
1539         /* we stop when we encounter a `def&#39; or `]&#39; */
1540         if ( *cur == &#39;d&#39; &amp;&amp; cur + 3 &lt; limit )
1541         {
1542           if ( cur[1] == &#39;e&#39;         &amp;&amp;
1543                cur[2] == &#39;f&#39;         &amp;&amp;
1544                IS_PS_DELIM( cur[3] ) )
1545           {
1546             FT_TRACE6(( &quot;encoding end\n&quot; ));
1547             cur += 3;
1548             break;
1549           }
1550         }
1551         if ( *cur == &#39;]&#39; )
1552         {
1553           FT_TRACE6(( &quot;encoding end\n&quot; ));
1554           cur++;
1555           break;
1556         }
1557 
1558         /* check whether we&#39;ve found an entry */
1559         if ( ft_isdigit( *cur ) || only_immediates )
1560         {
1561           FT_Int  charcode;
1562 
1563 
1564           if ( only_immediates )
1565             charcode = n;
1566           else
1567           {
1568             charcode = (FT_Int)T1_ToInt( parser );
1569             T1_Skip_Spaces( parser );
1570 
1571             /* protect against invalid charcode */
1572             if ( cur == parser-&gt;root.cursor )
1573             {
1574               parser-&gt;root.error = FT_THROW( Unknown_File_Format );
1575               return;
1576             }
1577           }
1578 
1579           cur = parser-&gt;root.cursor;
1580 
1581           if ( cur + 2 &lt; limit &amp;&amp; *cur == &#39;/&#39; &amp;&amp; n &lt; count )
1582           {
1583             FT_UInt  len;
1584 
1585 
1586             cur++;
1587 
1588             parser-&gt;root.cursor = cur;
1589             T1_Skip_PS_Token( parser );
1590             if ( parser-&gt;root.cursor &gt;= limit )
1591               return;
1592             if ( parser-&gt;root.error )
1593               return;
1594 
1595             len = (FT_UInt)( parser-&gt;root.cursor - cur );
1596 
1597             if ( n &lt; array_size )
1598             {
1599               parser-&gt;root.error = T1_Add_Table( char_table, charcode,
1600                                                  cur, len + 1 );
1601               if ( parser-&gt;root.error )
1602                 return;
1603               char_table-&gt;elements[charcode][len] = &#39;\0&#39;;
1604             }
1605 
1606             n++;
1607           }
1608           else if ( only_immediates )
1609           {
1610             /* Since the current position is not updated for           */
1611             /* immediates-only mode we would get an infinite loop if   */
1612             /* we don&#39;t do anything here.                              */
1613             /*                                                         */
1614             /* This encoding array is not valid according to the type1 */
1615             /* specification (it might be an encoding for a CID type1  */
1616             /* font, however), so we conclude that this font is NOT a  */
1617             /* type1 font.                                             */
1618             parser-&gt;root.error = FT_THROW( Unknown_File_Format );
1619             return;
1620           }
1621         }
1622         else
1623         {
1624           T1_Skip_PS_Token( parser );
1625           if ( parser-&gt;root.error )
1626             return;
1627         }
1628 
1629         T1_Skip_Spaces( parser );
1630       }
1631 
<a name="43" id="anc43"></a><span class="line-added">1632 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1633       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1634 </span>
<span class="line-added">1635       /* XXX show encoding vector */</span>
<span class="line-added">1636       FT_TRACE4(( &quot;...&quot; ));</span>
<span class="line-added">1637 </span>
<span class="line-added">1638       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1639 #endif</span>
<span class="line-added">1640 </span>
1641       face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
1642       parser-&gt;root.cursor       = cur;
1643     }
1644 
1645     /* Otherwise, we should have either `StandardEncoding&#39;, */
1646     /* `ExpertEncoding&#39;, or `ISOLatin1Encoding&#39;             */
1647     else
1648     {
1649       if ( cur + 17 &lt; limit                                            &amp;&amp;
1650            ft_strncmp( (const char*)cur, &quot;StandardEncoding&quot;, 16 ) == 0 )
<a name="44" id="anc44"></a><span class="line-added">1651       {</span>
1652         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_STANDARD;
<a name="45" id="anc45"></a><span class="line-added">1653         FT_TRACE4(( &quot; StandardEncoding\n&quot; ));</span>
<span class="line-added">1654       }</span>
1655 
1656       else if ( cur + 15 &lt; limit                                          &amp;&amp;
1657                 ft_strncmp( (const char*)cur, &quot;ExpertEncoding&quot;, 14 ) == 0 )
<a name="46" id="anc46"></a><span class="line-added">1658       {</span>
1659         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_EXPERT;
<a name="47" id="anc47"></a><span class="line-added">1660         FT_TRACE4(( &quot; ExpertEncoding\n&quot; ));</span>
<span class="line-added">1661       }</span>
1662 
1663       else if ( cur + 18 &lt; limit                                             &amp;&amp;
1664                 ft_strncmp( (const char*)cur, &quot;ISOLatin1Encoding&quot;, 17 ) == 0 )
<a name="48" id="anc48"></a><span class="line-added">1665       {</span>
1666         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;
<a name="49" id="anc49"></a><span class="line-added">1667         FT_TRACE4(( &quot; ISOLatin1Encoding\n&quot; ));</span>
<span class="line-added">1668       }</span>
1669 
1670       else
<a name="50" id="anc50"></a><span class="line-added">1671       {</span>
1672         parser-&gt;root.error = FT_ERR( Ignore );
<a name="51" id="anc51"></a><span class="line-added">1673         FT_TRACE4(( &quot;&lt;unknown&gt;\n&quot; ));</span>
<span class="line-added">1674       }</span>
1675     }
1676   }
1677 
1678 
1679   static void
1680   parse_subrs( T1_Face    face,
1681                T1_Loader  loader )
1682   {
1683     T1_Parser  parser = &amp;loader-&gt;parser;
1684     PS_Table   table  = &amp;loader-&gt;subrs;
1685     FT_Memory  memory = parser-&gt;root.memory;
1686     FT_Error   error;
1687     FT_Int     num_subrs;
1688     FT_UInt    count;
1689 
1690     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1691 
1692 
1693     T1_Skip_Spaces( parser );
1694 
1695     /* test for empty array */
1696     if ( parser-&gt;root.cursor &lt; parser-&gt;root.limit &amp;&amp;
1697          *parser-&gt;root.cursor == &#39;[&#39;              )
1698     {
1699       T1_Skip_PS_Token( parser );
1700       T1_Skip_Spaces  ( parser );
1701       if ( parser-&gt;root.cursor &gt;= parser-&gt;root.limit ||
1702            *parser-&gt;root.cursor != &#39;]&#39;               )
1703         parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1704       return;
1705     }
1706 
1707     num_subrs = (FT_Int)T1_ToInt( parser );
1708     if ( num_subrs &lt; 0 )
1709     {
1710       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1711       return;
1712     }
1713 
1714     /* we certainly need more than 8 bytes per subroutine */
1715     if ( parser-&gt;root.limit &gt;= parser-&gt;root.cursor                     &amp;&amp;
1716          num_subrs &gt; ( parser-&gt;root.limit - parser-&gt;root.cursor ) &gt;&gt; 3 )
1717     {
1718       /*
1719        * There are two possibilities.  Either the font contains an invalid
1720        * value for `num_subrs&#39;, or we have a subsetted font where the
1721        * subroutine indices are not adjusted, e.g.
1722        *
1723        *   /Subrs 812 array
1724        *     dup 0 { ... } NP
1725        *     dup 51 { ... } NP
1726        *     dup 681 { ... } NP
1727        *   ND
1728        *
1729        * In both cases, we use a number hash that maps from subr indices to
1730        * actual array elements.
1731        */
1732 
1733       FT_TRACE0(( &quot;parse_subrs: adjusting number of subroutines&quot;
1734                   &quot; (from %d to %d)\n&quot;,
1735                   num_subrs,
1736                   ( parser-&gt;root.limit - parser-&gt;root.cursor ) &gt;&gt; 3 ));
1737       num_subrs = ( parser-&gt;root.limit - parser-&gt;root.cursor ) &gt;&gt; 3;
1738 
1739       if ( !loader-&gt;subrs_hash )
1740       {
1741         if ( FT_NEW( loader-&gt;subrs_hash ) )
1742           goto Fail;
1743 
1744         error = ft_hash_num_init( loader-&gt;subrs_hash, memory );
1745         if ( error )
1746           goto Fail;
1747       }
1748     }
1749 
1750     /* position the parser right before the `dup&#39; of the first subr */
1751     T1_Skip_PS_Token( parser );         /* `array&#39; */
1752     if ( parser-&gt;root.error )
1753       return;
1754     T1_Skip_Spaces( parser );
1755 
1756     /* initialize subrs array -- with synthetic fonts it is possible */
1757     /* we get here twice                                             */
1758     if ( !loader-&gt;num_subrs )
1759     {
1760       error = psaux-&gt;ps_table_funcs-&gt;init( table, num_subrs, memory );
1761       if ( error )
1762         goto Fail;
1763     }
1764 
1765     /* the format is simple:   */
1766     /*                         */
1767     /*   `index&#39; + binary data */
1768     /*                         */
1769     for ( count = 0; ; count++ )
1770     {
1771       FT_Long   idx;
1772       FT_ULong  size;
1773       FT_Byte*  base;
1774 
1775 
1776       /* If we are out of data, or if the next token isn&#39;t `dup&#39;, */
1777       /* we are done.                                             */
1778       if ( parser-&gt;root.cursor + 4 &gt;= parser-&gt;root.limit          ||
1779           ft_strncmp( (char*)parser-&gt;root.cursor, &quot;dup&quot;, 3 ) != 0 )
1780         break;
1781 
1782       T1_Skip_PS_Token( parser );       /* `dup&#39; */
1783 
1784       idx = T1_ToInt( parser );
1785 
1786       if ( !read_binary_data( parser, &amp;size, &amp;base, IS_INCREMENTAL ) )
1787         return;
1788 
1789       /* The binary string is followed by one token, e.g. `NP&#39; */
1790       /* (bound to `noaccess put&#39;) or by two separate tokens:  */
1791       /* `noaccess&#39; &amp; `put&#39;.  We position the parser right     */
1792       /* before the next `dup&#39;, if any.                        */
1793       T1_Skip_PS_Token( parser );   /* `NP&#39; or `|&#39; or `noaccess&#39; */
1794       if ( parser-&gt;root.error )
1795         return;
1796       T1_Skip_Spaces  ( parser );
1797 
1798       if ( parser-&gt;root.cursor + 4 &lt; parser-&gt;root.limit            &amp;&amp;
1799            ft_strncmp( (char*)parser-&gt;root.cursor, &quot;put&quot;, 3 ) == 0 )
1800       {
1801         T1_Skip_PS_Token( parser ); /* skip `put&#39; */
1802         T1_Skip_Spaces  ( parser );
1803       }
1804 
1805       /* if we use a hash, the subrs index is the key, and a running */
1806       /* counter specified for `T1_Add_Table&#39; acts as the value      */
1807       if ( loader-&gt;subrs_hash )
1808       {
1809         ft_hash_num_insert( idx, count, loader-&gt;subrs_hash, memory );
1810         idx = count;
1811       }
1812 
1813       /* with synthetic fonts it is possible we get here twice */
1814       if ( loader-&gt;num_subrs )
1815         continue;
1816 
1817       /* some fonts use a value of -1 for lenIV to indicate that */
1818       /* the charstrings are unencoded                           */
1819       /*                                                         */
1820       /* thanks to Tom Kacvinsky for pointing this out           */
1821       /*                                                         */
1822       if ( face-&gt;type1.private_dict.lenIV &gt;= 0 )
1823       {
1824         FT_Byte*  temp = NULL;
1825 
1826 
1827         /* some fonts define empty subr records -- this is not totally */
1828         /* compliant to the specification (which says they should at   */
1829         /* least contain a `return&#39;), but we support them anyway       */
1830         if ( size &lt; (FT_ULong)face-&gt;type1.private_dict.lenIV )
1831         {
1832           error = FT_THROW( Invalid_File_Format );
1833           goto Fail;
1834         }
1835 
1836         /* t1_decrypt() shouldn&#39;t write to base -- make temporary copy */
1837         if ( FT_ALLOC( temp, size ) )
1838           goto Fail;
1839         FT_MEM_COPY( temp, base, size );
1840         psaux-&gt;t1_decrypt( temp, size, 4330 );
1841         size -= (FT_ULong)face-&gt;type1.private_dict.lenIV;
1842         error = T1_Add_Table( table, (FT_Int)idx,
1843                               temp + face-&gt;type1.private_dict.lenIV, size );
1844         FT_FREE( temp );
1845       }
1846       else
1847         error = T1_Add_Table( table, (FT_Int)idx, base, size );
1848       if ( error )
1849         goto Fail;
1850     }
1851 
1852     if ( !loader-&gt;num_subrs )
1853       loader-&gt;num_subrs = num_subrs;
1854 
<a name="52" id="anc52"></a><span class="line-added">1855 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1856       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="line-added">1857 </span>
<span class="line-added">1858       /* XXX show subrs? */</span>
<span class="line-added">1859       FT_TRACE4(( &quot;%d elements&quot;, num_subrs ));</span>
<span class="line-added">1860 </span>
<span class="line-added">1861       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="line-added">1862 #endif</span>
<span class="line-added">1863 </span>
1864     return;
1865 
1866   Fail:
1867     parser-&gt;root.error = error;
1868   }
1869 
1870 
1871 #define TABLE_EXTEND  5
1872 
1873 
1874   static void
1875   parse_charstrings( T1_Face    face,
1876                      T1_Loader  loader )
1877   {
1878     T1_Parser      parser       = &amp;loader-&gt;parser;
1879     PS_Table       code_table   = &amp;loader-&gt;charstrings;
1880     PS_Table       name_table   = &amp;loader-&gt;glyph_names;
1881     PS_Table       swap_table   = &amp;loader-&gt;swap_table;
1882     FT_Memory      memory       = parser-&gt;root.memory;
1883     FT_Error       error;
1884 
1885     PSAux_Service  psaux        = (PSAux_Service)face-&gt;psaux;
1886 
1887     FT_Byte*       cur          = parser-&gt;root.cursor;
1888     FT_Byte*       limit        = parser-&gt;root.limit;
1889     FT_Int         n, num_glyphs;
1890     FT_Int         notdef_index = 0;
1891     FT_Byte        notdef_found = 0;
1892 
1893 
1894     num_glyphs = (FT_Int)T1_ToInt( parser );
1895     if ( num_glyphs &lt; 0 )
1896     {
1897       error = FT_THROW( Invalid_File_Format );
1898       goto Fail;
1899     }
1900 
1901     /* we certainly need more than 8 bytes per glyph */
1902     if ( num_glyphs &gt; ( limit - cur ) &gt;&gt; 3 )
1903     {
1904       FT_TRACE0(( &quot;parse_charstrings: adjusting number of glyphs&quot;
1905                   &quot; (from %d to %d)\n&quot;,
1906                   num_glyphs, ( limit - cur ) &gt;&gt; 3 ));
1907       num_glyphs = ( limit - cur ) &gt;&gt; 3;
1908     }
1909 
1910     /* some fonts like Optima-Oblique not only define the /CharStrings */
1911     /* array but access it also                                        */
1912     if ( num_glyphs == 0 || parser-&gt;root.error )
1913       return;
1914 
1915     /* initialize tables, leaving space for addition of .notdef, */
1916     /* if necessary, and a few other glyphs to handle buggy      */
1917     /* fonts which have more glyphs than specified.              */
1918 
1919     /* for some non-standard fonts like `Optima&#39; which provides  */
1920     /* different outlines depending on the resolution it is      */
1921     /* possible to get here twice                                */
1922     if ( !loader-&gt;num_glyphs )
1923     {
1924       error = psaux-&gt;ps_table_funcs-&gt;init(
1925                 code_table, num_glyphs + 1 + TABLE_EXTEND, memory );
1926       if ( error )
1927         goto Fail;
1928 
1929       error = psaux-&gt;ps_table_funcs-&gt;init(
1930                 name_table, num_glyphs + 1 + TABLE_EXTEND, memory );
1931       if ( error )
1932         goto Fail;
1933 
1934       /* Initialize table for swapping index notdef_index and */
1935       /* index 0 names and codes (if necessary).              */
1936 
1937       error = psaux-&gt;ps_table_funcs-&gt;init( swap_table, 4, memory );
1938       if ( error )
1939         goto Fail;
1940     }
1941 
1942     n = 0;
1943 
1944     for (;;)
1945     {
1946       FT_ULong  size;
1947       FT_Byte*  base;
1948 
1949 
1950       /* the format is simple:        */
1951       /*   `/glyphname&#39; + binary data */
1952 
1953       T1_Skip_Spaces( parser );
1954 
1955       cur = parser-&gt;root.cursor;
1956       if ( cur &gt;= limit )
1957         break;
1958 
1959       /* we stop when we find a `def&#39; or `end&#39; keyword */
1960       if ( cur + 3 &lt; limit &amp;&amp; IS_PS_DELIM( cur[3] ) )
1961       {
1962         if ( cur[0] == &#39;d&#39; &amp;&amp;
1963              cur[1] == &#39;e&#39; &amp;&amp;
1964              cur[2] == &#39;f&#39; )
1965         {
1966           /* There are fonts which have this: */
1967           /*                                  */
1968           /*   /CharStrings 118 dict def      */
1969           /*   Private begin                  */
1970           /*   CharStrings begin              */
1971           /*   ...                            */
1972           /*                                  */
1973           /* To catch this we ignore `def&#39; if */
1974           /* no charstring has actually been  */
1975           /* seen.                            */
1976           if ( n )
1977             break;
1978         }
1979 
1980         if ( cur[0] == &#39;e&#39; &amp;&amp;
1981              cur[1] == &#39;n&#39; &amp;&amp;
1982              cur[2] == &#39;d&#39; )
1983           break;
1984       }
1985 
1986       T1_Skip_PS_Token( parser );
1987       if ( parser-&gt;root.cursor &gt;= limit )
1988       {
1989         error = FT_THROW( Invalid_File_Format );
1990         goto Fail;
1991       }
1992       if ( parser-&gt;root.error )
1993         return;
1994 
1995       if ( *cur == &#39;/&#39; )
1996       {
1997         FT_UInt  len;
1998 
1999 
2000         if ( cur + 2 &gt;= limit )
2001         {
2002           error = FT_THROW( Invalid_File_Format );
2003           goto Fail;
2004         }
2005 
2006         cur++;                              /* skip `/&#39; */
2007         len = (FT_UInt)( parser-&gt;root.cursor - cur );
2008 
2009         if ( !read_binary_data( parser, &amp;size, &amp;base, IS_INCREMENTAL ) )
2010           return;
2011 
2012         /* for some non-standard fonts like `Optima&#39; which provides */
2013         /* different outlines depending on the resolution it is     */
2014         /* possible to get here twice                               */
2015         if ( loader-&gt;num_glyphs )
2016           continue;
2017 
2018         error = T1_Add_Table( name_table, n, cur, len + 1 );
2019         if ( error )
2020           goto Fail;
2021 
2022         /* add a trailing zero to the name table */
2023         name_table-&gt;elements[n][len] = &#39;\0&#39;;
2024 
2025         /* record index of /.notdef */
2026         if ( *cur == &#39;.&#39;                                              &amp;&amp;
2027              ft_strcmp( &quot;.notdef&quot;,
2028                         (const char*)(name_table-&gt;elements[n]) ) == 0 )
2029         {
2030           notdef_index = n;
2031           notdef_found = 1;
2032         }
2033 
2034         if ( face-&gt;type1.private_dict.lenIV &gt;= 0 &amp;&amp;
2035              n &lt; num_glyphs + TABLE_EXTEND       )
2036         {
2037           FT_Byte*  temp = NULL;
2038 
2039 
2040           if ( size &lt;= (FT_ULong)face-&gt;type1.private_dict.lenIV )
2041           {
2042             error = FT_THROW( Invalid_File_Format );
2043             goto Fail;
2044           }
2045 
2046           /* t1_decrypt() shouldn&#39;t write to base -- make temporary copy */
2047           if ( FT_ALLOC( temp, size ) )
2048             goto Fail;
2049           FT_MEM_COPY( temp, base, size );
2050           psaux-&gt;t1_decrypt( temp, size, 4330 );
2051           size -= (FT_ULong)face-&gt;type1.private_dict.lenIV;
2052           error = T1_Add_Table( code_table, n,
2053                                 temp + face-&gt;type1.private_dict.lenIV, size );
2054           FT_FREE( temp );
2055         }
2056         else
2057           error = T1_Add_Table( code_table, n, base, size );
2058         if ( error )
2059           goto Fail;
2060 
2061         n++;
2062       }
2063     }
2064 
2065     if ( !n )
2066     {
2067       error = FT_THROW( Invalid_File_Format );
2068       goto Fail;
2069     }
2070 
2071     loader-&gt;num_glyphs = n;
2072 
2073     /* if /.notdef is found but does not occupy index 0, do our magic. */
2074     if ( notdef_found                                                 &amp;&amp;
2075          ft_strcmp( &quot;.notdef&quot;, (const char*)name_table-&gt;elements[0] ) )
2076     {
2077       /* Swap glyph in index 0 with /.notdef glyph.  First, add index 0  */
2078       /* name and code entries to swap_table.  Then place notdef_index   */
2079       /* name and code entries into swap_table.  Then swap name and code */
2080       /* entries at indices notdef_index and 0 using values stored in    */
2081       /* swap_table.                                                     */
2082 
2083       /* Index 0 name */
2084       error = T1_Add_Table( swap_table, 0,
2085                             name_table-&gt;elements[0],
2086                             name_table-&gt;lengths [0] );
2087       if ( error )
2088         goto Fail;
2089 
2090       /* Index 0 code */
2091       error = T1_Add_Table( swap_table, 1,
2092                             code_table-&gt;elements[0],
2093                             code_table-&gt;lengths [0] );
2094       if ( error )
2095         goto Fail;
2096 
2097       /* Index notdef_index name */
2098       error = T1_Add_Table( swap_table, 2,
2099                             name_table-&gt;elements[notdef_index],
2100                             name_table-&gt;lengths [notdef_index] );
2101       if ( error )
2102         goto Fail;
2103 
2104       /* Index notdef_index code */
2105       error = T1_Add_Table( swap_table, 3,
2106                             code_table-&gt;elements[notdef_index],
2107                             code_table-&gt;lengths [notdef_index] );
2108       if ( error )
2109         goto Fail;
2110 
2111       error = T1_Add_Table( name_table, notdef_index,
2112                             swap_table-&gt;elements[0],
2113                             swap_table-&gt;lengths [0] );
2114       if ( error )
2115         goto Fail;
2116 
2117       error = T1_Add_Table( code_table, notdef_index,
2118                             swap_table-&gt;elements[1],
2119                             swap_table-&gt;lengths [1] );
2120       if ( error )
2121         goto Fail;
2122 
2123       error = T1_Add_Table( name_table, 0,
2124                             swap_table-&gt;elements[2],
2125                             swap_table-&gt;lengths [2] );
2126       if ( error )
2127         goto Fail;
2128 
2129       error = T1_Add_Table( code_table, 0,
2130                             swap_table-&gt;elements[3],
2131                             swap_table-&gt;lengths [3] );
2132       if ( error )
2133         goto Fail;
2134 
2135     }
2136     else if ( !notdef_found )
2137     {
2138       /* notdef_index is already 0, or /.notdef is undefined in   */
2139       /* charstrings dictionary.  Worry about /.notdef undefined. */
2140       /* We take index 0 and add it to the end of the table(s)    */
2141       /* and add our own /.notdef glyph to index 0.               */
2142 
2143       /* 0 333 hsbw endchar */
2144       FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };
<a name="53" id="anc53"></a>
2145 
2146 
2147       error = T1_Add_Table( swap_table, 0,
2148                             name_table-&gt;elements[0],
2149                             name_table-&gt;lengths [0] );
2150       if ( error )
2151         goto Fail;
2152 
2153       error = T1_Add_Table( swap_table, 1,
2154                             code_table-&gt;elements[0],
2155                             code_table-&gt;lengths [0] );
2156       if ( error )
2157         goto Fail;
2158 
<a name="54" id="anc54"></a><span class="line-modified">2159       error = T1_Add_Table( name_table, 0, &quot;.notdef&quot;, 8 );</span>
2160       if ( error )
2161         goto Fail;
2162 
2163       error = T1_Add_Table( code_table, 0, notdef_glyph, 5 );
2164 
2165       if ( error )
2166         goto Fail;
2167 
2168       error = T1_Add_Table( name_table, n,
2169                             swap_table-&gt;elements[0],
2170                             swap_table-&gt;lengths [0] );
2171       if ( error )
2172         goto Fail;
2173 
2174       error = T1_Add_Table( code_table, n,
2175                             swap_table-&gt;elements[1],
2176                             swap_table-&gt;lengths [1] );
2177       if ( error )
2178         goto Fail;
2179 
2180       /* we added a glyph. */
2181       loader-&gt;num_glyphs += 1;
2182     }
2183 
<a name="55" id="anc55"></a><span class="line-added">2184 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">2185       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="line-added">2186 </span>
<span class="line-added">2187       /* XXX show charstrings? */</span>
<span class="line-added">2188       FT_TRACE4(( &quot;%d elements&quot;, loader-&gt;num_glyphs ));</span>
<span class="line-added">2189 </span>
<span class="line-added">2190       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="line-added">2191 #endif</span>
<span class="line-added">2192 </span>
2193     return;
2194 
2195   Fail:
2196     parser-&gt;root.error = error;
2197   }
2198 
2199 
<a name="56" id="anc56"></a><span class="line-modified">2200   /**************************************************************************</span>
<span class="line-modified">2201    *</span>
<span class="line-modified">2202    * Define the token field static variables.  This is a set of</span>
<span class="line-modified">2203    * T1_FieldRec variables.</span>
<span class="line-modified">2204    *</span>
<span class="line-modified">2205    */</span>
2206 
2207 
2208   static
2209   const T1_FieldRec  t1_keywords[] =
2210   {
2211 
2212 #include &quot;t1tokens.h&quot;
2213 
2214     /* now add the special functions... */
2215     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,           t1_parse_font_matrix,
2216                        T1_FIELD_DICT_FONTDICT )
2217     T1_FIELD_CALLBACK( &quot;Encoding&quot;,             parse_encoding,
2218                        T1_FIELD_DICT_FONTDICT )
2219     T1_FIELD_CALLBACK( &quot;Subrs&quot;,                parse_subrs,
2220                        T1_FIELD_DICT_PRIVATE )
2221     T1_FIELD_CALLBACK( &quot;CharStrings&quot;,          parse_charstrings,
2222                        T1_FIELD_DICT_PRIVATE )
2223     T1_FIELD_CALLBACK( &quot;Private&quot;,              parse_private,
2224                        T1_FIELD_DICT_FONTDICT )
2225 
2226 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
2227     T1_FIELD_CALLBACK( &quot;BlendDesignPositions&quot;, parse_blend_design_positions,
2228                        T1_FIELD_DICT_FONTDICT )
2229     T1_FIELD_CALLBACK( &quot;BlendDesignMap&quot;,       parse_blend_design_map,
2230                        T1_FIELD_DICT_FONTDICT )
2231     T1_FIELD_CALLBACK( &quot;BlendAxisTypes&quot;,       parse_blend_axis_types,
2232                        T1_FIELD_DICT_FONTDICT )
2233     T1_FIELD_CALLBACK( &quot;WeightVector&quot;,         parse_weight_vector,
2234                        T1_FIELD_DICT_FONTDICT )
2235     T1_FIELD_CALLBACK( &quot;BuildCharArray&quot;,       parse_buildchar,
2236                        T1_FIELD_DICT_PRIVATE )
2237 #endif
2238 
2239     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
2240   };
2241 
2242 
2243   static FT_Error
2244   parse_dict( T1_Face    face,
2245               T1_Loader  loader,
2246               FT_Byte*   base,
2247               FT_ULong   size )
2248   {
2249     T1_Parser  parser = &amp;loader-&gt;parser;
2250     FT_Byte   *limit, *start_binary = NULL;
2251     FT_Bool    have_integer = 0;
2252 
2253 
2254     parser-&gt;root.cursor = base;
2255     parser-&gt;root.limit  = base + size;
2256     parser-&gt;root.error  = FT_Err_Ok;
2257 
2258     limit = parser-&gt;root.limit;
2259 
2260     T1_Skip_Spaces( parser );
2261 
2262     while ( parser-&gt;root.cursor &lt; limit )
2263     {
2264       FT_Byte*  cur;
2265 
2266 
2267       cur = parser-&gt;root.cursor;
2268 
2269       /* look for `eexec&#39; */
2270       if ( IS_PS_TOKEN( cur, limit, &quot;eexec&quot; ) )
2271         break;
2272 
2273       /* look for `closefile&#39; which ends the eexec section */
2274       else if ( IS_PS_TOKEN( cur, limit, &quot;closefile&quot; ) )
2275         break;
2276 
2277       /* in a synthetic font the base font starts after a           */
2278       /* `FontDictionary&#39; token that is placed after a Private dict */
2279       else if ( IS_PS_TOKEN( cur, limit, &quot;FontDirectory&quot; ) )
2280       {
2281         if ( loader-&gt;keywords_encountered &amp; T1_PRIVATE )
2282           loader-&gt;keywords_encountered |=
2283             T1_FONTDIR_AFTER_PRIVATE;
2284         parser-&gt;root.cursor += 13;
2285       }
2286 
2287       /* check whether we have an integer */
2288       else if ( ft_isdigit( *cur ) )
2289       {
2290         start_binary = cur;
2291         T1_Skip_PS_Token( parser );
2292         if ( parser-&gt;root.error )
2293           goto Exit;
2294         have_integer = 1;
2295       }
2296 
2297       /* in valid Type 1 fonts we don&#39;t see `RD&#39; or `-|&#39; directly */
2298       /* since those tokens are handled by parse_subrs and        */
2299       /* parse_charstrings                                        */
2300       else if ( *cur == &#39;R&#39; &amp;&amp; cur + 6 &lt; limit &amp;&amp; *(cur + 1) == &#39;D&#39; &amp;&amp;
2301                 have_integer )
2302       {
2303         FT_ULong  s;
2304         FT_Byte*  b;
2305 
2306 
2307         parser-&gt;root.cursor = start_binary;
2308         if ( !read_binary_data( parser, &amp;s, &amp;b, IS_INCREMENTAL ) )
2309           return FT_THROW( Invalid_File_Format );
2310         have_integer = 0;
2311       }
2312 
2313       else if ( *cur == &#39;-&#39; &amp;&amp; cur + 6 &lt; limit &amp;&amp; *(cur + 1) == &#39;|&#39; &amp;&amp;
2314                 have_integer )
2315       {
2316         FT_ULong  s;
2317         FT_Byte*  b;
2318 
2319 
2320         parser-&gt;root.cursor = start_binary;
2321         if ( !read_binary_data( parser, &amp;s, &amp;b, IS_INCREMENTAL ) )
2322           return FT_THROW( Invalid_File_Format );
2323         have_integer = 0;
2324       }
2325 
2326       /* look for immediates */
2327       else if ( *cur == &#39;/&#39; &amp;&amp; cur + 2 &lt; limit )
2328       {
2329         FT_UInt  len;
2330 
2331 
2332         cur++;
2333 
2334         parser-&gt;root.cursor = cur;
2335         T1_Skip_PS_Token( parser );
2336         if ( parser-&gt;root.error )
2337           goto Exit;
2338 
2339         len = (FT_UInt)( parser-&gt;root.cursor - cur );
2340 
2341         if ( len &gt; 0 &amp;&amp; len &lt; 22 &amp;&amp; parser-&gt;root.cursor &lt; limit )
2342         {
2343           /* now compare the immediate name to the keyword table */
2344           T1_Field  keyword = (T1_Field)t1_keywords;
2345 
2346 
2347           for (;;)
2348           {
2349             FT_Byte*  name;
2350 
2351 
2352             name = (FT_Byte*)keyword-&gt;ident;
2353             if ( !name )
2354               break;
2355 
2356             if ( cur[0] == name[0]                      &amp;&amp;
2357                  len == ft_strlen( (const char *)name ) &amp;&amp;
2358                  ft_memcmp( cur, name, len ) == 0       )
2359             {
2360               /* We found it -- run the parsing callback!     */
2361               /* We record every instance of every field      */
2362               /* (until we reach the base font of a           */
2363               /* synthetic font) to deal adequately with      */
2364               /* multiple master fonts; this is also          */
2365               /* necessary because later PostScript           */
2366               /* definitions override earlier ones.           */
2367 
2368               /* Once we encounter `FontDirectory&#39; after      */
2369               /* `/Private&#39;, we know that this is a synthetic */
2370               /* font; except for `/CharStrings&#39; we are not   */
2371               /* interested in anything that follows this     */
2372               /* `FontDirectory&#39;.                             */
2373 
2374               /* MM fonts have more than one /Private token at */
2375               /* the top level; let&#39;s hope that all the junk   */
2376               /* that follows the first /Private token is not  */
2377               /* interesting to us.                            */
2378 
2379               /* According to Adobe Tech Note #5175 (CID-Keyed */
2380               /* Font Installation for ATM Software) a `begin&#39; */
2381               /* must be followed by exactly one `end&#39;, and    */
2382               /* `begin&#39; -- `end&#39; pairs must be accurately     */
2383               /* paired.  We could use this to distinguish     */
2384               /* between the global Private and the Private    */
2385               /* dict that is a member of the Blend dict.      */
2386 
2387               const FT_UInt dict =
2388                 ( loader-&gt;keywords_encountered &amp; T1_PRIVATE )
2389                     ? T1_FIELD_DICT_PRIVATE
2390                     : T1_FIELD_DICT_FONTDICT;
2391 
<a name="57" id="anc57"></a><span class="line-added">2392 </span>
2393               if ( !( dict &amp; keyword-&gt;dict ) )
2394               {
2395                 FT_TRACE1(( &quot;parse_dict: found `%s&#39; but ignoring it&quot;
2396                             &quot; since it is in the wrong dictionary\n&quot;,
2397                             keyword-&gt;ident ));
2398                 break;
2399               }
2400 
2401               if ( !( loader-&gt;keywords_encountered &amp;
2402                       T1_FONTDIR_AFTER_PRIVATE     )                  ||
2403                    ft_strcmp( (const char*)name, &quot;CharStrings&quot; ) == 0 )
2404               {
2405                 parser-&gt;root.error = t1_load_keyword( face,
2406                                                       loader,
2407                                                       keyword );
2408                 if ( parser-&gt;root.error )
2409                 {
2410                   if ( FT_ERR_EQ( parser-&gt;root.error, Ignore ) )
2411                     parser-&gt;root.error = FT_Err_Ok;
2412                   else
2413                     return parser-&gt;root.error;
2414                 }
2415               }
2416               break;
2417             }
2418 
2419             keyword++;
2420           }
2421         }
2422 
2423         have_integer = 0;
2424       }
2425       else
2426       {
2427         T1_Skip_PS_Token( parser );
2428         if ( parser-&gt;root.error )
2429           goto Exit;
2430         have_integer = 0;
2431       }
2432 
2433       T1_Skip_Spaces( parser );
2434     }
2435 
2436   Exit:
2437     return parser-&gt;root.error;
2438   }
2439 
2440 
2441   static void
2442   t1_init_loader( T1_Loader  loader,
2443                   T1_Face    face )
2444   {
2445     FT_UNUSED( face );
2446 
2447     FT_ZERO( loader );
2448   }
2449 
2450 
2451   static void
2452   t1_done_loader( T1_Loader  loader )
2453   {
2454     T1_Parser  parser = &amp;loader-&gt;parser;
2455     FT_Memory  memory = parser-&gt;root.memory;
2456 
2457 
2458     /* finalize tables */
2459     T1_Release_Table( &amp;loader-&gt;encoding_table );
2460     T1_Release_Table( &amp;loader-&gt;charstrings );
2461     T1_Release_Table( &amp;loader-&gt;glyph_names );
2462     T1_Release_Table( &amp;loader-&gt;swap_table );
2463     T1_Release_Table( &amp;loader-&gt;subrs );
2464 
2465     /* finalize hash */
2466     ft_hash_num_free( loader-&gt;subrs_hash, memory );
2467     FT_FREE( loader-&gt;subrs_hash );
2468 
2469     /* finalize parser */
2470     T1_Finalize_Parser( parser );
2471   }
2472 
2473 
2474   FT_LOCAL_DEF( FT_Error )
2475   T1_Open_Face( T1_Face  face )
2476   {
2477     T1_LoaderRec   loader;
2478     T1_Parser      parser;
2479     T1_Font        type1 = &amp;face-&gt;type1;
2480     PS_Private     priv  = &amp;type1-&gt;private_dict;
2481     FT_Error       error;
2482 
2483     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
2484 
2485 
2486     t1_init_loader( &amp;loader, face );
2487 
2488     /* default values */
2489     face-&gt;ndv_idx          = -1;
2490     face-&gt;cdv_idx          = -1;
2491     face-&gt;len_buildchar    = 0;
2492 
2493     priv-&gt;blue_shift       = 7;
2494     priv-&gt;blue_fuzz        = 1;
2495     priv-&gt;lenIV            = 4;
2496     priv-&gt;expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
2497     priv-&gt;blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );
2498 
2499     parser = &amp;loader.parser;
2500     error  = T1_New_Parser( parser,
2501                             face-&gt;root.stream,
2502                             face-&gt;root.memory,
2503                             psaux );
2504     if ( error )
2505       goto Exit;
2506 
<a name="58" id="anc58"></a><span class="line-added">2507     FT_TRACE4(( &quot; top dictionary:\n&quot; ));</span>
2508     error = parse_dict( face, &amp;loader,
2509                         parser-&gt;base_dict, parser-&gt;base_len );
2510     if ( error )
2511       goto Exit;
2512 
2513     error = T1_Get_Private_Dict( parser, psaux );
2514     if ( error )
2515       goto Exit;
2516 
<a name="59" id="anc59"></a><span class="line-added">2517     FT_TRACE4(( &quot; private dictionary:\n&quot; ));</span>
2518     error = parse_dict( face, &amp;loader,
2519                         parser-&gt;private_dict, parser-&gt;private_len );
2520     if ( error )
2521       goto Exit;
2522 
2523     /* ensure even-ness of `num_blue_values&#39; */
2524     priv-&gt;num_blue_values &amp;= ~1;
2525 
2526 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
2527 
<a name="60" id="anc60"></a><span class="line-added">2528     /* we don&#39;t support Multiple Master fonts with intermediate designs; */</span>
<span class="line-added">2529     /* this implies that `num_designs&#39; must be equal to `2^^num_axis&#39;    */</span>
<span class="line-added">2530     if ( face-&gt;blend                                                 &amp;&amp;</span>
<span class="line-added">2531          face-&gt;blend-&gt;num_designs != ( 1U &lt;&lt; face-&gt;blend-&gt;num_axis ) )</span>
<span class="line-added">2532     {</span>
<span class="line-added">2533       FT_ERROR(( &quot;T1_Open_Face:&quot;</span>
<span class="line-added">2534                  &quot; number-of-designs != 2 ^^ number-of-axes\n&quot; ));</span>
<span class="line-added">2535       T1_Done_Blend( face );</span>
<span class="line-added">2536     }</span>
<span class="line-added">2537 </span>
2538     if ( face-&gt;blend                                                     &amp;&amp;
2539          face-&gt;blend-&gt;num_default_design_vector != 0                     &amp;&amp;
2540          face-&gt;blend-&gt;num_default_design_vector != face-&gt;blend-&gt;num_axis )
2541     {
2542       /* we don&#39;t use it currently so just warn, reset, and ignore */
2543       FT_ERROR(( &quot;T1_Open_Face(): /DesignVector contains %u entries &quot;
2544                  &quot;while there are %u axes.\n&quot;,
2545                  face-&gt;blend-&gt;num_default_design_vector,
2546                  face-&gt;blend-&gt;num_axis ));
2547 
2548       face-&gt;blend-&gt;num_default_design_vector = 0;
2549     }
2550 
2551     /* the following can happen for MM instances; we then treat the */
2552     /* font as a normal PS font                                     */
2553     if ( face-&gt;blend                                             &amp;&amp;
2554          ( !face-&gt;blend-&gt;num_designs || !face-&gt;blend-&gt;num_axis ) )
2555       T1_Done_Blend( face );
2556 
2557     /* another safety check */
2558     if ( face-&gt;blend )
2559     {
2560       FT_UInt  i;
2561 
2562 
2563       for ( i = 0; i &lt; face-&gt;blend-&gt;num_axis; i++ )
2564         if ( !face-&gt;blend-&gt;design_map[i].num_points )
2565         {
2566           T1_Done_Blend( face );
2567           break;
2568         }
2569     }
2570 
2571     if ( face-&gt;blend )
2572     {
2573       if ( face-&gt;len_buildchar &gt; 0 )
2574       {
2575         FT_Memory  memory = face-&gt;root.memory;
2576 
2577 
2578         if ( FT_NEW_ARRAY( face-&gt;buildchar, face-&gt;len_buildchar ) )
2579         {
2580           FT_ERROR(( &quot;T1_Open_Face: cannot allocate BuildCharArray\n&quot; ));
2581           face-&gt;len_buildchar = 0;
2582           goto Exit;
2583         }
2584       }
2585     }
2586     else
2587       face-&gt;len_buildchar = 0;
2588 
2589 #endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
2590 
2591     /* now, propagate the subrs, charstrings, and glyphnames tables */
2592     /* to the Type1 data                                            */
2593     type1-&gt;num_glyphs = loader.num_glyphs;
2594 
2595     if ( loader.subrs.init )
2596     {
2597       type1-&gt;num_subrs   = loader.num_subrs;
2598       type1-&gt;subrs_block = loader.subrs.block;
2599       type1-&gt;subrs       = loader.subrs.elements;
2600       type1-&gt;subrs_len   = loader.subrs.lengths;
2601       type1-&gt;subrs_hash  = loader.subrs_hash;
2602 
2603       /* prevent `t1_done_loader&#39; from freeing the propagated data */
2604       loader.subrs.init = 0;
2605       loader.subrs_hash = NULL;
2606     }
2607 
2608     if ( !IS_INCREMENTAL )
2609       if ( !loader.charstrings.init )
2610       {
2611         FT_ERROR(( &quot;T1_Open_Face: no `/CharStrings&#39; array in face\n&quot; ));
2612         error = FT_THROW( Invalid_File_Format );
2613       }
2614 
2615     loader.charstrings.init  = 0;
2616     type1-&gt;charstrings_block = loader.charstrings.block;
2617     type1-&gt;charstrings       = loader.charstrings.elements;
2618     type1-&gt;charstrings_len   = loader.charstrings.lengths;
2619 
2620     /* we copy the glyph names `block&#39; and `elements&#39; fields; */
2621     /* the `lengths&#39; field must be released later             */
2622     type1-&gt;glyph_names_block    = loader.glyph_names.block;
2623     type1-&gt;glyph_names          = (FT_String**)loader.glyph_names.elements;
2624     loader.glyph_names.block    = NULL;
2625     loader.glyph_names.elements = NULL;
2626 
2627     /* we must now build type1.encoding when we have a custom array */
2628     if ( type1-&gt;encoding_type == T1_ENCODING_TYPE_ARRAY )
2629     {
<a name="61" id="anc61"></a><span class="line-modified">2630       FT_Int  charcode, idx, min_char, max_char;</span>

2631 
2632 
2633       /* OK, we do the following: for each element in the encoding  */
2634       /* table, look up the index of the glyph having the same name */
2635       /* the index is then stored in type1.encoding.char_index, and */
2636       /* the name to type1.encoding.char_name                       */
2637 
2638       min_char = 0;
2639       max_char = 0;
2640 
2641       charcode = 0;
2642       for ( ; charcode &lt; loader.encoding_table.max_elems; charcode++ )
2643       {
<a name="62" id="anc62"></a><span class="line-modified">2644         const FT_String*  char_name =</span>
<span class="line-added">2645               (const FT_String*)loader.encoding_table.elements[charcode];</span>
2646 
2647 
2648         type1-&gt;encoding.char_index[charcode] = 0;
<a name="63" id="anc63"></a><span class="line-modified">2649         type1-&gt;encoding.char_name [charcode] = &quot;.notdef&quot;;</span>
2650 
<a name="64" id="anc64"></a>
2651         if ( char_name )
2652           for ( idx = 0; idx &lt; type1-&gt;num_glyphs; idx++ )
2653           {
<a name="65" id="anc65"></a><span class="line-modified">2654             const FT_String*  glyph_name = type1-&gt;glyph_names[idx];</span>
<span class="line-modified">2655 </span>
<span class="line-modified">2656 </span>
<span class="line-added">2657             if ( ft_strcmp( char_name, glyph_name ) == 0 )</span>
2658             {
2659               type1-&gt;encoding.char_index[charcode] = (FT_UShort)idx;
<a name="66" id="anc66"></a><span class="line-modified">2660               type1-&gt;encoding.char_name [charcode] = glyph_name;</span>
2661 
2662               /* Change min/max encoded char only if glyph name is */
2663               /* not /.notdef                                      */
<a name="67" id="anc67"></a><span class="line-modified">2664               if ( ft_strcmp( &quot;.notdef&quot;, glyph_name ) != 0 )</span>

2665               {
2666                 if ( charcode &lt; min_char )
2667                   min_char = charcode;
2668                 if ( charcode &gt;= max_char )
2669                   max_char = charcode + 1;
2670               }
2671               break;
2672             }
2673           }
2674       }
2675 
2676       type1-&gt;encoding.code_first = min_char;
2677       type1-&gt;encoding.code_last  = max_char;
2678       type1-&gt;encoding.num_chars  = loader.num_chars;
2679     }
2680 
2681     /* some sanitizing to avoid overflows later on; */
2682     /* the upper limits are ad-hoc values           */
2683     if ( priv-&gt;blue_shift &gt; 1000 || priv-&gt;blue_shift &lt; 0 )
2684     {
2685       FT_TRACE2(( &quot;T1_Open_Face:&quot;
2686                   &quot; setting unlikely BlueShift value %d to default (7)\n&quot;,
2687                   priv-&gt;blue_shift ));
2688       priv-&gt;blue_shift = 7;
2689     }
2690 
2691     if ( priv-&gt;blue_fuzz &gt; 1000 || priv-&gt;blue_fuzz &lt; 0 )
2692     {
2693       FT_TRACE2(( &quot;T1_Open_Face:&quot;
2694                   &quot; setting unlikely BlueFuzz value %d to default (1)\n&quot;,
2695                   priv-&gt;blue_fuzz ));
2696       priv-&gt;blue_fuzz = 1;
2697     }
2698 
2699   Exit:
2700     t1_done_loader( &amp;loader );
2701     return error;
2702   }
2703 
2704 
2705 /* END */
<a name="68" id="anc68"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="68" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/src/autofit/afglobal.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /****************************************************************************
  2  *
  3  * afglobal.c
  4  *
  5  *   Auto-fitter routines to compute global hinting values (body).
  6  *
  7  * Copyright (C) 2003-2019 by
  8  * David Turner, Robert Wilhelm, and Werner Lemberg.
  9  *
 10  * This file is part of the FreeType project, and may only be used,
 11  * modified, and distributed under the terms of the FreeType project
 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 13  * this file you indicate that you have read the license and
 14  * understand and accept it fully.
 15  *
 16  */
 17 
 18 
 19 #include &quot;afglobal.h&quot;
 20 #include &quot;afranges.h&quot;
 21 #include &quot;afshaper.h&quot;
 22 #include FT_INTERNAL_DEBUG_H
 23 
 24 
 25   /**************************************************************************
 26    *
 27    * The macro FT_COMPONENT is used in trace mode.  It is an implicit
 28    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
 29    * messages during execution.
 30    */
 31 #undef  FT_COMPONENT
 32 #define FT_COMPONENT  afglobal
 33 
 34 
 35   /* get writing system specific header files */
 36 #undef  WRITING_SYSTEM
 37 #define WRITING_SYSTEM( ws, WS )  /* empty */
 38 #include &quot;afwrtsys.h&quot;
 39 
 40 #include &quot;aferrors.h&quot;
 41 
 42 
 43 #undef  SCRIPT
 44 #define SCRIPT( s, S, d, h, H, ss )         \
 45           AF_DEFINE_SCRIPT_CLASS(           \
 46             af_ ## s ## _script_class,      \
 47             AF_SCRIPT_ ## S,                \
 48             af_ ## s ## _uniranges,         \
 49             af_ ## s ## _nonbase_uniranges, \
 50             AF_ ## H,                       \
 51             ss )
 52 
 53 #include &quot;afscript.h&quot;
 54 
 55 
 56 #undef  STYLE
 57 #define STYLE( s, S, d, ws, sc, ss, c )  \
 58           AF_DEFINE_STYLE_CLASS(         \
 59             af_ ## s ## _style_class,    \
 60             AF_STYLE_ ## S,              \
 61             ws,                          \
 62             sc,                          \
 63             ss,                          \
 64             c )
 65 
 66 #include &quot;afstyles.h&quot;
 67 
 68 
 69 #undef  WRITING_SYSTEM
 70 #define WRITING_SYSTEM( ws, WS )               \
 71           &amp;af_ ## ws ## _writing_system_class,
 72 
 73   FT_LOCAL_ARRAY_DEF( AF_WritingSystemClass )
 74   af_writing_system_classes[] =
 75   {
 76 
 77 #include &quot;afwrtsys.h&quot;
 78 
 79     NULL  /* do not remove */
 80   };
 81 
 82 
 83 #undef  SCRIPT
 84 #define SCRIPT( s, S, d, h, H, ss )   \
 85           &amp;af_ ## s ## _script_class,
 86 
 87   FT_LOCAL_ARRAY_DEF( AF_ScriptClass )
 88   af_script_classes[] =
 89   {
 90 
 91 #include &quot;afscript.h&quot;
 92 
 93     NULL  /* do not remove */
 94   };
 95 
 96 
 97 #undef  STYLE
 98 #define STYLE( s, S, d, ws, sc, ss, c ) \
 99           &amp;af_ ## s ## _style_class,
100 
101   FT_LOCAL_ARRAY_DEF( AF_StyleClass )
102   af_style_classes[] =
103   {
104 
105 #include &quot;afstyles.h&quot;
106 
107     NULL  /* do not remove */
108   };
109 
110 
111 #ifdef FT_DEBUG_LEVEL_TRACE
112 
113 #undef  STYLE
114 #define STYLE( s, S, d, ws, sc, ss, c )  #s,
115 
116   FT_LOCAL_ARRAY_DEF( char* )
117   af_style_names[] =
118   {
119 
120 #include &quot;afstyles.h&quot;
121 
122   };
123 
124 #endif /* FT_DEBUG_LEVEL_TRACE */
125 
126 
127   /* Compute the style index of each glyph within a given face. */
128 
129   static FT_Error
130   af_face_globals_compute_style_coverage( AF_FaceGlobals  globals )
131   {
132     FT_Error    error;
133     FT_Face     face        = globals-&gt;face;
134     FT_CharMap  old_charmap = face-&gt;charmap;
135     FT_UShort*  gstyles     = globals-&gt;glyph_styles;
136     FT_UInt     ss;
137     FT_UInt     i;
138     FT_UInt     dflt        = ~0U; /* a non-valid value */
139 
140 
141     /* the value AF_STYLE_UNASSIGNED means `uncovered glyph&#39; */
142     for ( i = 0; i &lt; (FT_UInt)globals-&gt;glyph_count; i++ )
143       gstyles[i] = AF_STYLE_UNASSIGNED;
144 
145     error = FT_Select_Charmap( face, FT_ENCODING_UNICODE );
146     if ( error )
147     {
148       /*
149        * Ignore this error; we simply use the fallback style.
150        * XXX: Shouldn&#39;t we rather disable hinting?
151        */
152       error = FT_Err_Ok;
153       goto Exit;
154     }
155 
156     /* scan each style in a Unicode charmap */
157     for ( ss = 0; af_style_classes[ss]; ss++ )
158     {
159       AF_StyleClass       style_class =
160                             af_style_classes[ss];
161       AF_ScriptClass      script_class =
162                             af_script_classes[style_class-&gt;script];
163       AF_Script_UniRange  range;
164 
165 
166       if ( !script_class-&gt;script_uni_ranges )
167         continue;
168 
169       /*
170        * Scan all Unicode points in the range and set the corresponding
171        * glyph style index.
172        */
173       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
174       {
175         if ( (FT_UInt)style_class-&gt;script ==
176              globals-&gt;module-&gt;default_script )
177           dflt = ss;
178 
179         for ( range = script_class-&gt;script_uni_ranges;
180               range-&gt;first != 0;
181               range++ )
182         {
183           FT_ULong  charcode = range-&gt;first;
184           FT_UInt   gindex;
185 
186 
187           gindex = FT_Get_Char_Index( face, charcode );
188 
189           if ( gindex != 0                                                &amp;&amp;
190                gindex &lt; (FT_ULong)globals-&gt;glyph_count                    &amp;&amp;
191                ( gstyles[gindex] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
192             gstyles[gindex] = (FT_UShort)ss;
193 
194           for (;;)
195           {
196             charcode = FT_Get_Next_Char( face, charcode, &amp;gindex );
197 
198             if ( gindex == 0 || charcode &gt; range-&gt;last )
199               break;
200 
201             if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count                    &amp;&amp;
202                  ( gstyles[gindex] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
203               gstyles[gindex] = (FT_UShort)ss;
204           }
205         }
206 
207         /* do the same for the script&#39;s non-base characters */
208         for ( range = script_class-&gt;script_uni_nonbase_ranges;
209               range-&gt;first != 0;
210               range++ )
211         {
212           FT_ULong  charcode = range-&gt;first;
213           FT_UInt   gindex;
214 
215 
216           gindex = FT_Get_Char_Index( face, charcode );
217 
218           if ( gindex != 0                                          &amp;&amp;
219                gindex &lt; (FT_ULong)globals-&gt;glyph_count              &amp;&amp;
220                ( gstyles[gindex] &amp; AF_STYLE_MASK ) == (FT_UShort)ss )
221             gstyles[gindex] |= AF_NONBASE;
222 
223           for (;;)
224           {
225             charcode = FT_Get_Next_Char( face, charcode, &amp;gindex );
226 
227             if ( gindex == 0 || charcode &gt; range-&gt;last )
228               break;
229 
230             if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count              &amp;&amp;
231                  ( gstyles[gindex] &amp; AF_STYLE_MASK ) == (FT_UShort)ss )
232               gstyles[gindex] |= AF_NONBASE;
233           }
234         }
235       }
236       else
237       {
238         /* get glyphs not directly addressable by cmap */
239         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
240       }
241     }
242 
243     /* handle the remaining default OpenType features ... */
244     for ( ss = 0; af_style_classes[ss]; ss++ )
245     {
246       AF_StyleClass  style_class = af_style_classes[ss];
247 
248 
249       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
250         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
251     }
252 
253     /* ... and finally the default OpenType features of the default script */
254     af_shaper_get_coverage( globals, af_style_classes[dflt], gstyles, 1 );
255 
256     /* mark ASCII digits */
257     for ( i = 0x30; i &lt;= 0x39; i++ )
258     {
259       FT_UInt  gindex = FT_Get_Char_Index( face, i );
260 
261 
262       if ( gindex != 0 &amp;&amp; gindex &lt; (FT_ULong)globals-&gt;glyph_count )
263         gstyles[gindex] |= AF_DIGIT;
264     }
265 
266   Exit:
267     /*
268      * By default, all uncovered glyphs are set to the fallback style.
269      * XXX: Shouldn&#39;t we disable hinting or do something similar?
270      */
271     if ( globals-&gt;module-&gt;fallback_style != AF_STYLE_UNASSIGNED )
272     {
273       FT_Long  nn;
274 
275 
276       for ( nn = 0; nn &lt; globals-&gt;glyph_count; nn++ )
277       {
278         if ( ( gstyles[nn] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
279         {
280           gstyles[nn] &amp;= ~AF_STYLE_MASK;
281           gstyles[nn] |= globals-&gt;module-&gt;fallback_style;
282         }
283       }
284     }
285 
286 #ifdef FT_DEBUG_LEVEL_TRACE
287 
288     FT_TRACE4(( &quot;\n&quot;
289                 &quot;style coverage\n&quot;
290                 &quot;==============\n&quot;
291                 &quot;\n&quot; ));
292 
293     for ( ss = 0; af_style_classes[ss]; ss++ )
294     {
295       AF_StyleClass  style_class = af_style_classes[ss];
296       FT_UInt        count       = 0;
297       FT_Long        idx;
298 
299 
300       FT_TRACE4(( &quot;%s:\n&quot;, af_style_names[style_class-&gt;style] ));
301 
302       for ( idx = 0; idx &lt; globals-&gt;glyph_count; idx++ )
303       {
304         if ( ( gstyles[idx] &amp; AF_STYLE_MASK ) == style_class-&gt;style )
305         {
306           if ( !( count % 10 ) )
307             FT_TRACE4(( &quot; &quot; ));
308 
309           FT_TRACE4(( &quot; %d&quot;, idx ));
310           count++;
311 
312           if ( !( count % 10 ) )
313             FT_TRACE4(( &quot;\n&quot; ));
314         }
315       }
316 
317       if ( !count )
318         FT_TRACE4(( &quot;  (none)\n&quot; ));
319       if ( count % 10 )
320         FT_TRACE4(( &quot;\n&quot; ));
321     }
322 
323 #endif /* FT_DEBUG_LEVEL_TRACE */
324 
325     FT_Set_Charmap( face, old_charmap );
326     return error;
327   }
328 
329 
330   FT_LOCAL_DEF( FT_Error )
331   af_face_globals_new( FT_Face          face,
332                        AF_FaceGlobals  *aglobals,
333                        AF_Module        module )
334   {
335     FT_Error        error;
336     FT_Memory       memory;
337     AF_FaceGlobals  globals = NULL;
338 
339 
340     memory = face-&gt;memory;
341 
342     /* we allocate an AF_FaceGlobals structure together */
343     /* with the glyph_styles array                      */
344     if ( FT_ALLOC( globals,
345                    sizeof ( *globals ) +
346                      (FT_ULong)face-&gt;num_glyphs * sizeof ( FT_UShort ) ) )
347       goto Exit;
348 
349     globals-&gt;face                      = face;
350     globals-&gt;glyph_count               = face-&gt;num_glyphs;
351     /* right after the globals structure come the glyph styles */
352     globals-&gt;glyph_styles              = (FT_UShort*)( globals + 1 );
353     globals-&gt;module                    = module;
354     globals-&gt;stem_darkening_for_ppem   = 0;
355     globals-&gt;darken_x                  = 0;
356     globals-&gt;darken_y                  = 0;
357     globals-&gt;standard_vertical_width   = 0;
358     globals-&gt;standard_horizontal_width = 0;
359     globals-&gt;scale_down_factor         = 0;
360 
361 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
362     globals-&gt;hb_font = hb_ft_font_create( face, NULL );
363     globals-&gt;hb_buf  = hb_buffer_create();
364 #endif
365 
366     error = af_face_globals_compute_style_coverage( globals );
367     if ( error )
368     {
369       af_face_globals_free( globals );
370       globals = NULL;
371     }
372     else
373       globals-&gt;increase_x_height = AF_PROP_INCREASE_X_HEIGHT_MAX;
374 
375   Exit:
376     *aglobals = globals;
377     return error;
378   }
379 
380 
381   FT_LOCAL_DEF( void )
382   af_face_globals_free( AF_FaceGlobals  globals )
383   {
384     if ( globals )
385     {
386       FT_Memory  memory = globals-&gt;face-&gt;memory;
387       FT_UInt    nn;
388 
389 
390       for ( nn = 0; nn &lt; AF_STYLE_MAX; nn++ )
391       {
392         if ( globals-&gt;metrics[nn] )
393         {
394           AF_StyleClass          style_class =
395             af_style_classes[nn];
396           AF_WritingSystemClass  writing_system_class =
397             af_writing_system_classes[style_class-&gt;writing_system];
398 
399 
400           if ( writing_system_class-&gt;style_metrics_done )
401             writing_system_class-&gt;style_metrics_done( globals-&gt;metrics[nn] );
402 
403           FT_FREE( globals-&gt;metrics[nn] );
404         }
405       }
406 
407 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
408       hb_font_destroy( globals-&gt;hb_font );
409       hb_buffer_destroy( globals-&gt;hb_buf );
410 #endif
411 
412       /* no need to free `globals-&gt;glyph_styles&#39;; */
413       /* it is part of the `globals&#39; array        */
414       FT_FREE( globals );
415     }
416   }
417 
418 
419   FT_LOCAL_DEF( FT_Error )
420   af_face_globals_get_metrics( AF_FaceGlobals    globals,
421                                FT_UInt           gindex,
422                                FT_UInt           options,
423                                AF_StyleMetrics  *ametrics )
424   {
425     AF_StyleMetrics  metrics = NULL;
426 
427     AF_Style               style = (AF_Style)options;
428     AF_WritingSystemClass  writing_system_class;
429     AF_StyleClass          style_class;
430 
431     FT_Error  error = FT_Err_Ok;
432 
433 
434     if ( gindex &gt;= (FT_ULong)globals-&gt;glyph_count )
435     {
436       error = FT_THROW( Invalid_Argument );
437       goto Exit;
438     }
439 
440     /* if we have a forced style (via `options&#39;), use it, */
441     /* otherwise look into `glyph_styles&#39; array           */
442     if ( style == AF_STYLE_NONE_DFLT || style + 1 &gt;= AF_STYLE_MAX )
443       style = (AF_Style)( globals-&gt;glyph_styles[gindex] &amp;
444                           AF_STYLE_UNASSIGNED           );
445 
446   Again:
447     style_class          = af_style_classes[style];
448     writing_system_class = af_writing_system_classes
449                              [style_class-&gt;writing_system];
450 
451     metrics = globals-&gt;metrics[style];
452     if ( !metrics )
453     {
454       /* create the global metrics object if necessary */
455       FT_Memory  memory = globals-&gt;face-&gt;memory;
456 
457 
458       if ( FT_ALLOC( metrics, writing_system_class-&gt;style_metrics_size ) )
459         goto Exit;
460 
461       metrics-&gt;style_class = style_class;
462       metrics-&gt;globals     = globals;
463 
464       if ( writing_system_class-&gt;style_metrics_init )
465       {
466         error = writing_system_class-&gt;style_metrics_init( metrics,
467                                                           globals-&gt;face );
468         if ( error )
469         {
470           if ( writing_system_class-&gt;style_metrics_done )
471             writing_system_class-&gt;style_metrics_done( metrics );
472 
473           FT_FREE( metrics );
474 
475           /* internal error code -1 indicates   */
476           /* that no blue zones have been found */
477           if ( error == -1 )
478           {
479             style = (AF_Style)( globals-&gt;glyph_styles[gindex] &amp;
480                                 AF_STYLE_UNASSIGNED           );
481             goto Again;
482           }
483 
484           goto Exit;
485         }
486       }
487 
488       globals-&gt;metrics[style] = metrics;
489     }
490 
491   Exit:
492     *ametrics = metrics;
493 
494     return error;
495   }
496 
497 
498   FT_LOCAL_DEF( FT_Bool )
499   af_face_globals_is_digit( AF_FaceGlobals  globals,
500                             FT_UInt         gindex )
501   {
502     if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count )
503       return FT_BOOL( globals-&gt;glyph_styles[gindex] &amp; AF_DIGIT );
504 
505     return FT_BOOL( 0 );
506   }
507 
508 
509 /* END */
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/truetype/ttgxvar.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ttgload.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgxvar.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/truetype/ttgxvar.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,44 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ttgxvar.c                                                              */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    TrueType GX Font Variation loader                                    */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2004-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.     */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Apple documents the `fvar&#39;, `gvar&#39;, `cvar&#39;, and `avar&#39; tables at      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The documentation for `gvar&#39; is not intelligible; `cvar&#39; refers you   */</span>
<span class="line-modified">!   /* to `gvar&#39; and is thus also incomprehensible.                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The documentation for `avar&#39; appears correct, but Apple has no fonts  */</span>
<span class="line-modified">!   /* with an `avar&#39; table, so it is hard to test.                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Many thanks to John Jenkins (at Apple) in figuring this out.          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Apple&#39;s `kern&#39; table has some references to tuple indices, but as     */</span>
<span class="line-modified">!   /* there is no indication where these indices are defined, nor how to    */</span>
<span class="line-modified">!   /* interpolate the kerning values (different tuples have different       */</span>
<span class="line-modified">!   /* classes) this issue is ignored.                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_INTERNAL_DEBUG_H
  #include FT_CONFIG_CONFIG_H
<span class="line-new-header">--- 1,44 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ttgxvar.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   TrueType GX Font Variation loader</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2004-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, Werner Lemberg, and George Williams.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Apple documents the `fvar&#39;, `gvar&#39;, `cvar&#39;, and `avar&#39; tables at</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6[fgca]var.html</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The documentation for `gvar&#39; is not intelligible; `cvar&#39; refers you</span>
<span class="line-modified">!    * to `gvar&#39; and is thus also incomprehensible.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The documentation for `avar&#39; appears correct, but Apple has no fonts</span>
<span class="line-modified">!    * with an `avar&#39; table, so it is hard to test.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Many thanks to John Jenkins (at Apple) in figuring this out.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Apple&#39;s `kern&#39; table has some references to tuple indices, but as</span>
<span class="line-modified">!    * there is no indication where these indices are defined, nor how to</span>
<span class="line-modified">!    * interpolate the kerning values (different tuples have different</span>
<span class="line-modified">!    * classes) this issue is ignored.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
  
  
  #include &lt;ft2build.h&gt;
  #include FT_INTERNAL_DEBUG_H
  #include FT_CONFIG_CONFIG_H
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,18 ***</span>
              ( (off) &lt; (FT_ULong)( (stream)-&gt;limit - (stream)-&gt;base ) ) \
                          ? (stream)-&gt;base + (off)                       \
                          : (stream)-&gt;limit
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_ttgxvar</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*****                                                               *****/
<span class="line-new-header">--- 65,31 ---</span>
              ( (off) &lt; (FT_ULong)( (stream)-&gt;limit - (stream)-&gt;base ) ) \
                          ? (stream)-&gt;base + (off)                       \
                          : (stream)-&gt;limit
  
  
<span class="line-modified">!   /* some macros we need */</span>
<span class="line-modified">! #define FT_fdot14ToFixed( x )                  \</span>
<span class="line-modified">!           ( (FT_Fixed)( (FT_ULong)(x) &lt;&lt; 2 ) )</span>
<span class="line-modified">! #define FT_intToFixed( i )                      \</span>
<span class="line-modified">!           ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 16 ) )</span>
<span class="line-modified">! #define FT_fdot6ToFixed( i )                    \</span>
<span class="line-added">+           ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 10 ) )</span>
<span class="line-added">+ #define FT_fixedToInt( x )                          \</span>
<span class="line-added">+           ( (FT_Short)( ( (x) + 0x8000U ) &gt;&gt; 16 ) )</span>
<span class="line-added">+ #define FT_fixedToFdot6( x )                    \</span>
<span class="line-added">+           ( (FT_Pos)( ( (x) + 0x200 ) &gt;&gt; 10 ) )</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   /**************************************************************************</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-added">+    * messages during execution.</span>
<span class="line-added">+    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  ttgxvar</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*****                                                               *****/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,48 ***</span>
    /*****                                                               *****/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro ALL_POINTS is used in `ft_var_readpackedpoints&#39;.  It        */</span>
<span class="line-modified">!   /* indicates that there is a delta for every point without needing to    */</span>
<span class="line-modified">!   /* enumerate all of them.                                                */</span>
<span class="line-modified">!   /*                                                                       */</span>
  
    /* ensure that value `0&#39; has the same width as a pointer */
  #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
  
  
  #define GX_PT_POINTS_ARE_WORDS      0x80U
  #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_readpackedpoints                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Read a set of points to which the following deltas will apply.     */</span>
<span class="line-modified">!   /*    Points are packed with a run length encoding.                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    stream    :: The data stream.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    size      :: The size of the table holding the data.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">!   /*    point_cnt :: The number of points read.  A zero value means that   */</span>
<span class="line-modified">!   /*                 all points in the glyph will be affected, without     */</span>
<span class="line-modified">!   /*                 enumerating them individually.                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    An array of FT_UShort containing the affected points or the        */</span>
<span class="line-modified">!   /*    special value ALL_POINTS.                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_UShort*
    ft_var_readpackedpoints( FT_Stream  stream,
                             FT_ULong   size,
                             FT_UInt   *point_cnt )
    {
<span class="line-new-header">--- 97,51 ---</span>
    /*****                                                               *****/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro ALL_POINTS is used in `ft_var_readpackedpoints&#39;.  It</span>
<span class="line-modified">!    * indicates that there is a delta for every point without needing to</span>
<span class="line-modified">!    * enumerate all of them.</span>
<span class="line-modified">!    */</span>
  
    /* ensure that value `0&#39; has the same width as a pointer */
  #define ALL_POINTS  (FT_UShort*)~(FT_PtrDist)0
  
  
  #define GX_PT_POINTS_ARE_WORDS      0x80U
  #define GX_PT_POINT_RUN_COUNT_MASK  0x7FU
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_readpackedpoints</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Read a set of points to which the following deltas will apply.</span>
<span class="line-modified">!    *   Points are packed with a run length encoding.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   stream ::</span>
<span class="line-modified">!    *     The data stream.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   size ::</span>
<span class="line-modified">!    *     The size of the table holding the data.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Output:</span>
<span class="line-modified">!    *   point_cnt ::</span>
<span class="line-modified">!    *     The number of points read.  A zero value means that</span>
<span class="line-modified">!    *     all points in the glyph will be affected, without</span>
<span class="line-modified">!    *     enumerating them individually.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-added">+    *   An array of FT_UShort containing the affected points or the</span>
<span class="line-added">+    *   special value ALL_POINTS.</span>
<span class="line-added">+    */</span>
    static FT_UShort*
    ft_var_readpackedpoints( FT_Stream  stream,
                             FT_ULong   size,
                             FT_UInt   *point_cnt )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,38 ***</span>
  #define GX_DT_DELTAS_ARE_ZERO       0x80U
  #define GX_DT_DELTAS_ARE_WORDS      0x40U
  #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_readpackeddeltas                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Read a set of deltas.  These are packed slightly differently than  */</span>
<span class="line-modified">!   /*    points.  In particular there is no overall count.                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    stream    :: The data stream.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    size      :: The size of the table holding the data.               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    delta_cnt :: The number of deltas to be read.                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    An array of FT_Short containing the deltas for the affected        */</span>
<span class="line-modified">!   /*    points.  (This only gets the deltas for one dimension.  It will    */</span>
<span class="line-modified">!   /*    generally be called twice, once for x, once for y.  When used in   */</span>
<span class="line-modified">!   /*    cvt table, it will only be called once.)                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   static FT_Short*</span>
    ft_var_readpackeddeltas( FT_Stream  stream,
                             FT_ULong   size,
                             FT_UInt    delta_cnt )
    {
<span class="line-modified">!     FT_Short  *deltas = NULL;</span>
      FT_UInt    runcnt, cnt;
      FT_UInt    i, j;
      FT_Memory  memory = stream-&gt;memory;
      FT_Error   error  = FT_Err_Ok;
  
<span class="line-new-header">--- 225,45 ---</span>
  #define GX_DT_DELTAS_ARE_ZERO       0x80U
  #define GX_DT_DELTAS_ARE_WORDS      0x40U
  #define GX_DT_DELTA_RUN_COUNT_MASK  0x3FU
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_readpackeddeltas</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Read a set of deltas.  These are packed slightly differently than</span>
<span class="line-modified">!    *   points.  In particular there is no overall count.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   stream ::</span>
<span class="line-modified">!    *     The data stream.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   size ::</span>
<span class="line-modified">!    *     The size of the table holding the data.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   delta_cnt ::</span>
<span class="line-modified">!    *     The number of deltas to be read.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   An array of FT_Fixed containing the deltas for the affected</span>
<span class="line-modified">!    *   points.  (This only gets the deltas for one dimension.  It will</span>
<span class="line-modified">!    *   generally be called twice, once for x, once for y.  When used in</span>
<span class="line-added">+    *   cvt table, it will only be called once.)</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   We use FT_Fixed to avoid accumulation errors while summing up all</span>
<span class="line-added">+    *   deltas (the rounding to integer values happens as the very last</span>
<span class="line-added">+    *   step).</span>
<span class="line-added">+    */</span>
<span class="line-added">+   static FT_Fixed*</span>
    ft_var_readpackeddeltas( FT_Stream  stream,
                             FT_ULong   size,
                             FT_UInt    delta_cnt )
    {
<span class="line-modified">!     FT_Fixed  *deltas = NULL;</span>
      FT_UInt    runcnt, cnt;
      FT_UInt    i, j;
      FT_Memory  memory = stream-&gt;memory;
      FT_Error   error  = FT_Err_Ok;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 270,17 ***</span>
        }
        else if ( runcnt &amp; GX_DT_DELTAS_ARE_WORDS )
        {
          /* `runcnt&#39; shorts from the stack */
          for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified">!           deltas[i++] = FT_GET_SHORT();</span>
        }
        else
        {
          /* `runcnt&#39; signed bytes from the stack */
          for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified">!           deltas[i++] = FT_GET_CHAR();</span>
        }
  
        if ( j &lt;= cnt )
        {
          /* bad format */
<span class="line-new-header">--- 293,17 ---</span>
        }
        else if ( runcnt &amp; GX_DT_DELTAS_ARE_WORDS )
        {
          /* `runcnt&#39; shorts from the stack */
          for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified">!           deltas[i++] = FT_intToFixed( FT_GET_SHORT() );</span>
        }
        else
        {
          /* `runcnt&#39; signed bytes from the stack */
          for ( j = 0; j &lt;= cnt &amp;&amp; i &lt; delta_cnt; j++ )
<span class="line-modified">!           deltas[i++] = FT_intToFixed( FT_GET_CHAR() );</span>
        }
  
        if ( j &lt;= cnt )
        {
          /* bad format */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 291,22 ***</span>
  
      return deltas;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_load_avar                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Parse the `avar&#39; table if present.  It need not be, so we return   */</span>
<span class="line-modified">!   /*    nothing.                                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face :: The font face.                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    ft_var_load_avar( TT_Face  face )
    {
      FT_Stream       stream = FT_FACE_STREAM( face );
      FT_Memory       memory = stream-&gt;memory;
<span class="line-new-header">--- 314,23 ---</span>
  
      return deltas;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_load_avar</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Parse the `avar&#39; table if present.  It need not be, so we return</span>
<span class="line-modified">!    *   nothing.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-added">+    */</span>
    static void
    ft_var_load_avar( TT_Face  face )
    {
      FT_Stream       stream = FT_FACE_STREAM( face );
      FT_Memory       memory = stream-&gt;memory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 375,13 ***</span>
          goto Exit;
        }
  
        for ( j = 0; j &lt; segment-&gt;pairCount; j++ )
        {
<span class="line-modified">!         /* convert to Fixed */</span>
<span class="line-modified">!         segment-&gt;correspondence[j].fromCoord = FT_GET_SHORT() * 4;</span>
<span class="line-modified">!         segment-&gt;correspondence[j].toCoord   = FT_GET_SHORT() * 4;</span>
  
          FT_TRACE5(( &quot;    mapping %.5f to %.5f\n&quot;,
                      segment-&gt;correspondence[j].fromCoord / 65536.0,
                      segment-&gt;correspondence[j].toCoord / 65536.0 ));
        }
<span class="line-new-header">--- 399,14 ---</span>
          goto Exit;
        }
  
        for ( j = 0; j &lt; segment-&gt;pairCount; j++ )
        {
<span class="line-modified">!         segment-&gt;correspondence[j].fromCoord =</span>
<span class="line-modified">!           FT_fdot14ToFixed( FT_GET_SHORT() );</span>
<span class="line-modified">!         segment-&gt;correspondence[j].toCoord =</span>
<span class="line-added">+           FT_fdot14ToFixed( FT_GET_SHORT() );</span>
  
          FT_TRACE5(( &quot;    mapping %.5f to %.5f\n&quot;,
                      segment-&gt;correspondence[j].fromCoord / 65536.0,
                      segment-&gt;correspondence[j].toCoord / 65536.0 ));
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 392,21 ***</span>
    Exit:
      FT_FRAME_EXIT();
    }
  
  
<span class="line-removed">-   /* some macros we need */</span>
<span class="line-removed">- #define FT_FIXED_ONE  ( (FT_Fixed)0x10000 )</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define FT_fdot14ToFixed( x )                \</span>
<span class="line-removed">-         ( (FT_Fixed)( (FT_ULong)(x) &lt;&lt; 2 ) )</span>
<span class="line-removed">- #define FT_intToFixed( i )                    \</span>
<span class="line-removed">-         ( (FT_Fixed)( (FT_ULong)(i) &lt;&lt; 16 ) )</span>
<span class="line-removed">- #define FT_fixedToInt( x )                                   \</span>
<span class="line-removed">-         ( (FT_Short)( ( (FT_UInt32)(x) + 0x8000U ) &gt;&gt; 16 ) )</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
    static FT_Error
    ft_var_load_item_variation_store( TT_Face          face,
                                      FT_ULong         offset,
                                      GX_ItemVarStore  itemStore )
    {
<span class="line-new-header">--- 417,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 700,33 ***</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_load_hvvar                                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    If `vertical&#39; is zero, parse the `HVAR&#39; table and set              */</span>
<span class="line-modified">!   /*    `blend-&gt;hvar_loaded&#39; to TRUE.  On success, `blend-&gt;hvar_checked&#39;   */</span>
<span class="line-modified">!   /*    is set to TRUE.                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    If `vertical&#39; is not zero, parse the `VVAR&#39; table and set          */</span>
<span class="line-modified">!   /*    `blend-&gt;vvar_loaded&#39; to TRUE.  On success, `blend-&gt;vvar_checked&#39;   */</span>
<span class="line-modified">!   /*    is set to TRUE.                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Some memory may remain allocated on error; it is always freed in   */</span>
<span class="line-modified">!   /*    `tt_done_blend&#39;, however.                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face :: The font face.                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    ft_var_load_hvvar( TT_Face  face,
                       FT_Bool  vertical )
    {
      FT_Stream  stream = FT_FACE_STREAM( face );
<span class="line-new-header">--- 714,34 ---</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_load_hvvar</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   If `vertical&#39; is zero, parse the `HVAR&#39; table and set</span>
<span class="line-modified">!    *   `blend-&gt;hvar_loaded&#39; to TRUE.  On success, `blend-&gt;hvar_checked&#39;</span>
<span class="line-modified">!    *   is set to TRUE.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   If `vertical&#39; is not zero, parse the `VVAR&#39; table and set</span>
<span class="line-modified">!    *   `blend-&gt;vvar_loaded&#39; to TRUE.  On success, `blend-&gt;vvar_checked&#39;</span>
<span class="line-modified">!    *   is set to TRUE.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Some memory may remain allocated on error; it is always freed in</span>
<span class="line-modified">!    *   `tt_done_blend&#39;, however.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    static FT_Error
    ft_var_load_hvvar( TT_Face  face,
                       FT_Bool  vertical )
    {
      FT_Stream  stream = FT_FACE_STREAM( face );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 870,60 ***</span>
      deltaSet = &amp;varData-&gt;deltaSet[varData-&gt;regionIdxCount * innerIndex];
  
      /* outer loop steps through master designs to be blended */
      for ( master = 0; master &lt; varData-&gt;regionIdxCount; master++ )
      {
<span class="line-modified">!       FT_Fixed  scalar      = FT_FIXED_ONE;</span>
        FT_UInt   regionIndex = varData-&gt;regionIndices[master];
  
        GX_AxisCoords  axis = itemStore-&gt;varRegionList[regionIndex].axisList;
  
  
        /* inner loop steps through axes in this region */
        for ( j = 0; j &lt; itemStore-&gt;axisCount; j++, axis++ )
        {
<span class="line-removed">-         FT_Fixed  axisScalar;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
          /* compute the scalar contribution of this axis; */
          /* ignore invalid ranges                         */
          if ( axis-&gt;startCoord &gt; axis-&gt;peakCoord ||
               axis-&gt;peakCoord &gt; axis-&gt;endCoord   )
<span class="line-modified">!           axisScalar = FT_FIXED_ONE;</span>
  
          else if ( axis-&gt;startCoord &lt; 0 &amp;&amp;
                    axis-&gt;endCoord &gt; 0   &amp;&amp;
                    axis-&gt;peakCoord != 0 )
<span class="line-modified">!           axisScalar = FT_FIXED_ONE;</span>
  
          /* peak of 0 means ignore this axis */
          else if ( axis-&gt;peakCoord == 0 )
<span class="line-modified">!           axisScalar = FT_FIXED_ONE;</span>
  
<span class="line-modified">!         /* ignore this region if coords are out of range */</span>
<span class="line-modified">!         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;startCoord ||</span>
<span class="line-removed">-                   face-&gt;blend-&gt;normalizedcoords[j] &gt; axis-&gt;endCoord   )</span>
<span class="line-removed">-           axisScalar = 0;</span>
  
<span class="line-modified">!         /* calculate a proportional factor */</span>
<span class="line-modified">!         else</span>
          {
<span class="line-modified">!           if ( face-&gt;blend-&gt;normalizedcoords[j] == axis-&gt;peakCoord )</span>
<span class="line-modified">!             axisScalar = FT_FIXED_ONE;</span>
<span class="line-removed">-           else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;peakCoord )</span>
<span class="line-removed">-             axisScalar =</span>
<span class="line-removed">-               FT_DivFix( face-&gt;blend-&gt;normalizedcoords[j] - axis-&gt;startCoord,</span>
<span class="line-removed">-                          axis-&gt;peakCoord - axis-&gt;startCoord );</span>
<span class="line-removed">-           else</span>
<span class="line-removed">-             axisScalar =</span>
<span class="line-removed">-               FT_DivFix( axis-&gt;endCoord - face-&gt;blend-&gt;normalizedcoords[j],</span>
<span class="line-removed">-                          axis-&gt;endCoord - axis-&gt;peakCoord );</span>
          }
  
<span class="line-modified">!         /* take product of all the axis scalars */</span>
<span class="line-modified">!         scalar = FT_MulFix( scalar, axisScalar );</span>
<span class="line-modified">! </span>
        } /* per-axis loop */
  
        /* get the scaled delta for this region */
        delta       = FT_intToFixed( deltaSet[master] );
        scaledDelta = FT_MulFix( scalar, delta );
<span class="line-new-header">--- 885,56 ---</span>
      deltaSet = &amp;varData-&gt;deltaSet[varData-&gt;regionIdxCount * innerIndex];
  
      /* outer loop steps through master designs to be blended */
      for ( master = 0; master &lt; varData-&gt;regionIdxCount; master++ )
      {
<span class="line-modified">!       FT_Fixed  scalar      = 0x10000L;</span>
        FT_UInt   regionIndex = varData-&gt;regionIndices[master];
  
        GX_AxisCoords  axis = itemStore-&gt;varRegionList[regionIndex].axisList;
  
  
        /* inner loop steps through axes in this region */
        for ( j = 0; j &lt; itemStore-&gt;axisCount; j++, axis++ )
        {
          /* compute the scalar contribution of this axis; */
          /* ignore invalid ranges                         */
          if ( axis-&gt;startCoord &gt; axis-&gt;peakCoord ||
               axis-&gt;peakCoord &gt; axis-&gt;endCoord   )
<span class="line-modified">!           continue;</span>
  
          else if ( axis-&gt;startCoord &lt; 0 &amp;&amp;
                    axis-&gt;endCoord &gt; 0   &amp;&amp;
                    axis-&gt;peakCoord != 0 )
<span class="line-modified">!           continue;</span>
  
          /* peak of 0 means ignore this axis */
          else if ( axis-&gt;peakCoord == 0 )
<span class="line-modified">!           continue;</span>
  
<span class="line-modified">!         else if ( face-&gt;blend-&gt;normalizedcoords[j] == axis-&gt;peakCoord )</span>
<span class="line-modified">!           continue;</span>
  
<span class="line-modified">!         /* ignore this region if coords are out of range */</span>
<span class="line-modified">!         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt;= axis-&gt;startCoord ||</span>
<span class="line-added">+                   face-&gt;blend-&gt;normalizedcoords[j] &gt;= axis-&gt;endCoord   )</span>
          {
<span class="line-modified">!           scalar = 0;</span>
<span class="line-modified">!           break;</span>
          }
  
<span class="line-modified">!         /* cumulative product of all the axis scalars */</span>
<span class="line-modified">!         else if ( face-&gt;blend-&gt;normalizedcoords[j] &lt; axis-&gt;peakCoord )</span>
<span class="line-modified">!           scalar =</span>
<span class="line-added">+             FT_MulDiv( scalar,</span>
<span class="line-added">+                        face-&gt;blend-&gt;normalizedcoords[j] - axis-&gt;startCoord,</span>
<span class="line-added">+                        axis-&gt;peakCoord - axis-&gt;startCoord );</span>
<span class="line-added">+         else</span>
<span class="line-added">+           scalar =</span>
<span class="line-added">+             FT_MulDiv( scalar,</span>
<span class="line-added">+                        axis-&gt;endCoord - face-&gt;blend-&gt;normalizedcoords[j],</span>
<span class="line-added">+                        axis-&gt;endCoord - axis-&gt;peakCoord );</span>
        } /* per-axis loop */
  
        /* get the scaled delta for this region */
        delta       = FT_intToFixed( deltaSet[master] );
        scaledDelta = FT_MulFix( scalar, delta );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,29 ***</span>
  
      return FT_fixedToInt( netAdjustment );
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    tt_hvadvance_adjust                                                */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Apply `HVAR&#39; advance width or `VVAR&#39; advance height adjustment of  */</span>
<span class="line-modified">!   /*    a given glyph.                                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    gindex   :: The glyph index.                                       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    vertical :: If set, handle `VVAR&#39; table.                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face     :: The font face.                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    adelta   :: Points to width or height value that gets modified.    */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    tt_hvadvance_adjust( TT_Face  face,
                         FT_UInt  gindex,
                         FT_Int  *avalue,
                         FT_Bool  vertical )
<span class="line-new-header">--- 946,33 ---</span>
  
      return FT_fixedToInt( netAdjustment );
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   tt_hvadvance_adjust</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Apply `HVAR&#39; advance width or `VVAR&#39; advance height adjustment of</span>
<span class="line-modified">!    *   a given glyph.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   gindex ::</span>
<span class="line-modified">!    *     The glyph index.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   vertical ::</span>
<span class="line-modified">!    *     If set, handle `VVAR&#39; table.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   adelta ::</span>
<span class="line-added">+    *     Points to width or height value that gets modified.</span>
<span class="line-added">+    */</span>
    static FT_Error
    tt_hvadvance_adjust( TT_Face  face,
                         FT_UInt  gindex,
                         FT_Int  *avalue,
                         FT_Bool  vertical )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1149,24 ***</span>
  
      return p;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_load_mvar                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Parse the `MVAR&#39; table.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Some memory may remain allocated on error; it is always freed in   */</span>
<span class="line-modified">!   /*    `tt_done_blend&#39;, however.                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face :: The font face.                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    ft_var_load_mvar( TT_Face  face )
    {
      FT_Stream  stream = FT_FACE_STREAM( face );
      FT_Memory  memory = stream-&gt;memory;
<span class="line-new-header">--- 1164,25 ---</span>
  
      return p;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_load_mvar</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Parse the `MVAR&#39; table.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   Some memory may remain allocated on error; it is always freed in</span>
<span class="line-modified">!    *   `tt_done_blend&#39;, however.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-added">+    */</span>
    static void
    ft_var_load_mvar( TT_Face  face )
    {
      FT_Stream  stream = FT_FACE_STREAM( face );
      FT_Memory  memory = stream-&gt;memory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1295,26 ***</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    tt_apply_mvar                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Apply `MVAR&#39; table adjustments.                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face :: The font face.                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( void )
    tt_apply_mvar( TT_Face  face )
    {
      GX_Blend  blend = face-&gt;blend;
      GX_Value  value, limit;
  
  
      if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_MVAR ) )
        return;
  
<span class="line-new-header">--- 1311,30 ---</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   tt_apply_mvar</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Apply `MVAR&#39; table adjustments.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( void )
    tt_apply_mvar( TT_Face  face )
    {
      GX_Blend  blend = face-&gt;blend;
      GX_Value  value, limit;
<span class="line-added">+     FT_Short  mvar_hasc_delta = 0;</span>
<span class="line-added">+     FT_Short  mvar_hdsc_delta = 0;</span>
<span class="line-added">+     FT_Short  mvar_hlgp_delta = 0;</span>
  
  
      if ( !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_MVAR ) )
        return;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1345,36 ***</span>
                      delta == 1 ? &quot;&quot; : &quot;s&quot; ));
  
          /* since we handle both signed and unsigned values as FT_Short, */
          /* ensure proper overflow arithmetic                            */
          *p = (FT_Short)( value-&gt;unmodified + (FT_Short)delta );
        }
      }
  
      /* adjust all derived values */
      {
        FT_Face  root = &amp;face-&gt;root;
  
<span class="line-modified">! </span>
<span class="line-modified">!       if ( face-&gt;os2.version != 0xFFFFU )</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">!           root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">!                          face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-modified">!           root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           root-&gt;height = root-&gt;ascender - root-&gt;descender;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       }</span>
  
        root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
                                    face-&gt;postscript.underlineThickness / 2;
        root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
  
<span class="line-new-header">--- 1365,59 ---</span>
                      delta == 1 ? &quot;&quot; : &quot;s&quot; ));
  
          /* since we handle both signed and unsigned values as FT_Short, */
          /* ensure proper overflow arithmetic                            */
          *p = (FT_Short)( value-&gt;unmodified + (FT_Short)delta );
<span class="line-added">+ </span>
<span class="line-added">+         /* Treat hasc, hdsc and hlgp specially, see below. */</span>
<span class="line-added">+         if ( value-&gt;tag == MVAR_TAG_HASC )</span>
<span class="line-added">+           mvar_hasc_delta = (FT_Short)delta;</span>
<span class="line-added">+         else if ( value-&gt;tag == MVAR_TAG_HDSC )</span>
<span class="line-added">+           mvar_hdsc_delta = (FT_Short)delta;</span>
<span class="line-added">+         else if ( value-&gt;tag == MVAR_TAG_HLGP )</span>
<span class="line-added">+           mvar_hlgp_delta = (FT_Short)delta;</span>
        }
      }
  
      /* adjust all derived values */
      {
        FT_Face  root = &amp;face-&gt;root;
  
<span class="line-modified">!       /*</span>
<span class="line-modified">!        * Apply the deltas of hasc, hdsc and hlgp to the FT_Face&#39;s ascender,</span>
<span class="line-modified">!        * descender and height attributes, no matter how they were originally</span>
<span class="line-modified">!        * computed.</span>
<span class="line-modified">!        *</span>
<span class="line-modified">!        * (Code that ignores those and accesses the font&#39;s metrics values</span>
<span class="line-modified">!        * directly is already served by the delta application code above.)</span>
<span class="line-modified">!        *</span>
<span class="line-modified">!        * The MVAR table supports variations for both typo and win metrics.</span>
<span class="line-modified">!        * According to Behdad Esfahbod, the thinking of the working group was</span>
<span class="line-modified">!        * that no one uses win metrics anymore for setting line metrics (the</span>
<span class="line-modified">!        * specification even calls these metrics &quot;horizontal clipping</span>
<span class="line-modified">!        * ascent/descent&quot;, probably for their role on the Windows platform in</span>
<span class="line-modified">!        * computing clipping boxes), and new fonts should use typo metrics, so</span>
<span class="line-modified">!        * typo deltas should be applied to whatever sfnt_load_face decided the</span>
<span class="line-modified">!        * line metrics should be.</span>
<span class="line-modified">!        *</span>
<span class="line-modified">!        * Before, the following led to different line metrics between default</span>
<span class="line-modified">!        * outline and instances, visible when e.g. the default outlines were</span>
<span class="line-added">+        * used as the regular face and instances for everything else:</span>
<span class="line-added">+        *</span>
<span class="line-added">+        * 1. sfnt_load_face applied the hhea metrics by default.</span>
<span class="line-added">+        * 2. This code later applied the typo metrics by default, regardless of</span>
<span class="line-added">+        *    whether they were actually changed or the font had the OS/2 table&#39;s</span>
<span class="line-added">+        *    fsSelection&#39;s bit 7 (USE_TYPO_METRICS) set.</span>
<span class="line-added">+        */</span>
<span class="line-added">+       FT_Short  current_line_gap = root-&gt;height - root-&gt;ascender +</span>
<span class="line-added">+                                    root-&gt;descender;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+       root-&gt;ascender  = root-&gt;ascender + mvar_hasc_delta;</span>
<span class="line-added">+       root-&gt;descender = root-&gt;descender + mvar_hdsc_delta;</span>
<span class="line-added">+       root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">+                         current_line_gap + mvar_hlgp_delta;</span>
  
        root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
                                    face-&gt;postscript.underlineThickness / 2;
        root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1398,25 ***</span>
      FT_ULong   offsetToData;
  
    } GX_GVar_Head;
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_load_gvar                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Parse the `gvar&#39; table if present.  If `fvar&#39; is there, `gvar&#39; had */</span>
<span class="line-modified">!   /*    better be there too.                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face :: The font face.                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Error
    ft_var_load_gvar( TT_Face  face )
    {
      FT_Stream     stream = FT_FACE_STREAM( face );
      FT_Memory     memory = stream-&gt;memory;
<span class="line-new-header">--- 1441,26 ---</span>
      FT_ULong   offsetToData;
  
    } GX_GVar_Head;
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_load_gvar</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Parse the `gvar&#39; table if present.  If `fvar&#39; is there, `gvar&#39; had</span>
<span class="line-modified">!    *   better be there too.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-modified">!    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    static FT_Error
    ft_var_load_gvar( TT_Face  face )
    {
      FT_Stream     stream = FT_FACE_STREAM( face );
      FT_Memory     memory = stream-&gt;memory;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1510,32 ***</span>
      if ( FT_NEW_ARRAY( blend-&gt;glyphoffsets, blend-&gt;gv_glyphcnt + 1 ) )
        goto Exit;
  
      if ( gvar_head.flags &amp; 1 )
      {
        /* long offsets (one more offset than glyphs, to mark size of last) */
        if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 4L ) )
          goto Exit;
  
        for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
          blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_ULONG();
<span class="line-modified">! </span>
<span class="line-modified">!       FT_FRAME_EXIT();</span>
      }
      else
      {
        /* short offsets (one more offset than glyphs, to mark size of last) */
        if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 2L ) )
          goto Exit;
  
        for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
          blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
<span class="line-modified">!                                                /* XXX: Undocumented: `*2&#39;! */</span>
<span class="line-modified">! </span>
<span class="line-modified">!       FT_FRAME_EXIT();</span>
      }
  
      if ( blend-&gt;tuplecount != 0 )
      {
        if ( FT_NEW_ARRAY( blend-&gt;tuplecoords,
                           gvar_head.axisCount * blend-&gt;tuplecount ) )
          goto Exit;
<span class="line-new-header">--- 1554,59 ---</span>
      if ( FT_NEW_ARRAY( blend-&gt;glyphoffsets, blend-&gt;gv_glyphcnt + 1 ) )
        goto Exit;
  
      if ( gvar_head.flags &amp; 1 )
      {
<span class="line-added">+       FT_ULong  limit = gvar_start + table_len;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
        /* long offsets (one more offset than glyphs, to mark size of last) */
        if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 4L ) )
          goto Exit;
  
        for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
<span class="line-added">+       {</span>
          blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_ULONG();
<span class="line-modified">!         /* use `&gt;&#39;, not `&gt;=&#39; */</span>
<span class="line-modified">!         if ( blend-&gt;glyphoffsets[i] &gt; limit )</span>
<span class="line-added">+         {</span>
<span class="line-added">+           FT_TRACE2(( &quot;ft_var_load_gvar:&quot;</span>
<span class="line-added">+                       &quot; invalid glyph variation data offset for index %d\n&quot;,</span>
<span class="line-added">+                       i ));</span>
<span class="line-added">+           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
      else
      {
<span class="line-added">+       FT_ULong  limit = gvar_start + table_len;</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
        /* short offsets (one more offset than glyphs, to mark size of last) */
        if ( FT_FRAME_ENTER( ( blend-&gt;gv_glyphcnt + 1 ) * 2L ) )
          goto Exit;
  
        for ( i = 0; i &lt;= blend-&gt;gv_glyphcnt; i++ )
<span class="line-added">+       {</span>
          blend-&gt;glyphoffsets[i] = offsetToData + FT_GET_USHORT() * 2;
<span class="line-modified">!         /* use `&gt;&#39;, not `&gt;=&#39; */</span>
<span class="line-modified">!         if ( blend-&gt;glyphoffsets[i] &gt; limit )</span>
<span class="line-modified">!         {</span>
<span class="line-added">+           FT_TRACE2(( &quot;ft_var_load_gvar:&quot;</span>
<span class="line-added">+                       &quot; invalid glyph variation data offset for index %d\n&quot;,</span>
<span class="line-added">+                       i ));</span>
<span class="line-added">+           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
      }
  
<span class="line-added">+     FT_FRAME_EXIT();</span>
<span class="line-added">+     if ( error )</span>
<span class="line-added">+       goto Exit;</span>
<span class="line-added">+ </span>
      if ( blend-&gt;tuplecount != 0 )
      {
        if ( FT_NEW_ARRAY( blend-&gt;tuplecoords,
                           gvar_head.axisCount * blend-&gt;tuplecount ) )
          goto Exit;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1548,11 ***</span>
        {
          FT_TRACE5(( &quot;  [ &quot; ));
          for ( j = 0; j &lt; (FT_UInt)gvar_head.axisCount; j++ )
          {
            blend-&gt;tuplecoords[i * gvar_head.axisCount + j] =
<span class="line-modified">!             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */</span>
            FT_TRACE5(( &quot;%.5f &quot;,
              blend-&gt;tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
          }
          FT_TRACE5(( &quot;]\n&quot; ));
        }
<span class="line-new-header">--- 1619,11 ---</span>
        {
          FT_TRACE5(( &quot;  [ &quot; ));
          for ( j = 0; j &lt; (FT_UInt)gvar_head.axisCount; j++ )
          {
            blend-&gt;tuplecoords[i * gvar_head.axisCount + j] =
<span class="line-modified">!             FT_fdot14ToFixed( FT_GET_SHORT() );</span>
            FT_TRACE5(( &quot;%.5f &quot;,
              blend-&gt;tuplecoords[i * gvar_head.axisCount + j] / 65536.0 ));
          }
          FT_TRACE5(( &quot;]\n&quot; ));
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1565,37 ***</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    ft_var_apply_tuple                                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Figure out whether a given tuple (design) applies to the current   */</span>
<span class="line-modified">!   /*    blend, and if so, what is the scaling factor.                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    blend           :: The current blend of the font.                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    tupleIndex      :: A flag saying whether this is an intermediate   */</span>
<span class="line-modified">!   /*                       tuple or not.                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    tuple_coords    :: The coordinates of the tuple in normalized axis */</span>
<span class="line-modified">!   /*                       units.                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    im_start_coords :: The initial coordinates where this tuple starts */</span>
<span class="line-modified">!   /*                       to apply (for intermediate coordinates).        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    im_end_coords   :: The final coordinates after which this tuple no */</span>
<span class="line-modified">!   /*                       longer applies (for intermediate coordinates).  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    An FT_Fixed value containing the scaling factor.                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static FT_Fixed
    ft_var_apply_tuple( GX_Blend   blend,
                        FT_UShort  tupleIndex,
                        FT_Fixed*  tuple_coords,
                        FT_Fixed*  im_start_coords,
<span class="line-new-header">--- 1636,42 ---</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   ft_var_apply_tuple</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Figure out whether a given tuple (design) applies to the current</span>
<span class="line-modified">!    *   blend, and if so, what is the scaling factor.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   blend ::</span>
<span class="line-modified">!    *     The current blend of the font.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   tupleIndex ::</span>
<span class="line-modified">!    *     A flag saying whether this is an intermediate</span>
<span class="line-modified">!    *     tuple or not.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   tuple_coords ::</span>
<span class="line-modified">!    *     The coordinates of the tuple in normalized axis</span>
<span class="line-modified">!    *     units.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   im_start_coords ::</span>
<span class="line-modified">!    *     The initial coordinates where this tuple starts</span>
<span class="line-modified">!    *     to apply (for intermediate coordinates).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   im_end_coords ::</span>
<span class="line-modified">!    *     The final coordinates after which this tuple no</span>
<span class="line-added">+    *     longer applies (for intermediate coordinates).</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   An FT_Fixed value containing the scaling factor.</span>
<span class="line-added">+    */</span>
    static FT_Fixed
    ft_var_apply_tuple( GX_Blend   blend,
                        FT_UShort  tupleIndex,
                        FT_Fixed*  tuple_coords,
                        FT_Fixed*  im_start_coords,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1605,26 ***</span>
      FT_Fixed  apply = 0x10000L;
  
  
      for ( i = 0; i &lt; blend-&gt;num_axis; i++ )
      {
<span class="line-modified">!       FT_TRACE6(( &quot;    axis coordinate %d (%.5f):\n&quot;,</span>
                    i, blend-&gt;normalizedcoords[i] / 65536.0 ));
<span class="line-removed">-       if ( !( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE ) )</span>
<span class="line-removed">-         FT_TRACE6(( &quot;      intermediate coordinates %d (%.5f, %.5f):\n&quot;,</span>
<span class="line-removed">-                     i,</span>
<span class="line-removed">-                     im_start_coords[i] / 65536.0,</span>
<span class="line-removed">-                     im_end_coords[i] / 65536.0 ));</span>
  
        /* It&#39;s not clear why (for intermediate tuples) we don&#39;t need     */
        /* to check against start/end -- the documentation says we don&#39;t. */
        /* Similarly, it&#39;s unclear why we don&#39;t need to scale along the   */
        /* axis.                                                          */
  
        if ( tuple_coords[i] == 0 )
        {
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate is zero, ignored\n&quot;, i ));</span>
          continue;
        }
  
        if ( blend-&gt;normalizedcoords[i] == 0 )
        {
<span class="line-new-header">--- 1681,21 ---</span>
      FT_Fixed  apply = 0x10000L;
  
  
      for ( i = 0; i &lt; blend-&gt;num_axis; i++ )
      {
<span class="line-modified">!       FT_TRACE6(( &quot;    axis %d coordinate %.5f:\n&quot;,</span>
                    i, blend-&gt;normalizedcoords[i] / 65536.0 ));
  
        /* It&#39;s not clear why (for intermediate tuples) we don&#39;t need     */
        /* to check against start/end -- the documentation says we don&#39;t. */
        /* Similarly, it&#39;s unclear why we don&#39;t need to scale along the   */
        /* axis.                                                          */
  
        if ( tuple_coords[i] == 0 )
        {
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate is zero, ignore\n&quot;, i ));</span>
          continue;
        }
  
        if ( blend-&gt;normalizedcoords[i] == 0 )
        {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1633,11 ***</span>
          break;
        }
  
        if ( blend-&gt;normalizedcoords[i] == tuple_coords[i] )
        {
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate value %.5f fits perfectly\n&quot;,</span>
                      tuple_coords[i] / 65536.0 ));
          /* `apply&#39; does not change */
          continue;
        }
  
<span class="line-new-header">--- 1704,11 ---</span>
          break;
        }
  
        if ( blend-&gt;normalizedcoords[i] == tuple_coords[i] )
        {
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate %.5f fits perfectly\n&quot;,</span>
                      tuple_coords[i] / 65536.0 ));
          /* `apply&#39; does not change */
          continue;
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1646,56 ***</span>
          /* not an intermediate tuple */
  
          if ( blend-&gt;normalizedcoords[i] &lt; FT_MIN( 0, tuple_coords[i] ) ||
               blend-&gt;normalizedcoords[i] &gt; FT_MAX( 0, tuple_coords[i] ) )
          {
<span class="line-modified">!           FT_TRACE6(( &quot;      tuple coordinate value %.5f is exceeded, stop\n&quot;,</span>
                        tuple_coords[i] / 65536.0 ));
            apply = 0;
            break;
          }
  
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate value %.5f fits\n&quot;,</span>
                      tuple_coords[i] / 65536.0 ));
          apply = FT_MulDiv( apply,
                             blend-&gt;normalizedcoords[i],
                             tuple_coords[i] );
        }
        else
        {
          /* intermediate tuple */
  
<span class="line-modified">!         if ( blend-&gt;normalizedcoords[i] &lt; im_start_coords[i] ||</span>
<span class="line-modified">!              blend-&gt;normalizedcoords[i] &gt; im_end_coords[i]   )</span>
          {
<span class="line-modified">!           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] is exceeded,&quot;</span>
                        &quot; stop\n&quot;,
                        im_start_coords[i] / 65536.0,
                        im_end_coords[i] / 65536.0 ));
            apply = 0;
            break;
          }
  
<span class="line-modified">!         else if ( blend-&gt;normalizedcoords[i] &lt; tuple_coords[i] )</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] fits\n&quot;,</span>
<span class="line-modified">!                       im_start_coords[i] / 65536.0,</span>
<span class="line-removed">-                       im_end_coords[i] / 65536.0 ));</span>
            apply = FT_MulDiv( apply,
                               blend-&gt;normalizedcoords[i] - im_start_coords[i],
                               tuple_coords[i] - im_start_coords[i] );
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
          else
<span class="line-removed">-         {</span>
<span class="line-removed">-           FT_TRACE6(( &quot;      intermediate tuple range [%.5f;%.5f] fits\n&quot;,</span>
<span class="line-removed">-                       im_start_coords[i] / 65536.0,</span>
<span class="line-removed">-                       im_end_coords[i] / 65536.0 ));</span>
            apply = FT_MulDiv( apply,
                               im_end_coords[i] - blend-&gt;normalizedcoords[i],
                               im_end_coords[i] - tuple_coords[i] );
<span class="line-removed">-         }</span>
        }
      }
  
      FT_TRACE6(( &quot;    apply factor is %.5f\n&quot;, apply / 65536.0 ));
  
<span class="line-new-header">--- 1717,48 ---</span>
          /* not an intermediate tuple */
  
          if ( blend-&gt;normalizedcoords[i] &lt; FT_MIN( 0, tuple_coords[i] ) ||
               blend-&gt;normalizedcoords[i] &gt; FT_MAX( 0, tuple_coords[i] ) )
          {
<span class="line-modified">!           FT_TRACE6(( &quot;      tuple coordinate %.5f is exceeded, stop\n&quot;,</span>
                        tuple_coords[i] / 65536.0 ));
            apply = 0;
            break;
          }
  
<span class="line-modified">!         FT_TRACE6(( &quot;      tuple coordinate %.5f fits\n&quot;,</span>
                      tuple_coords[i] / 65536.0 ));
          apply = FT_MulDiv( apply,
                             blend-&gt;normalizedcoords[i],
                             tuple_coords[i] );
        }
        else
        {
          /* intermediate tuple */
  
<span class="line-modified">!         if ( blend-&gt;normalizedcoords[i] &lt;= im_start_coords[i] ||</span>
<span class="line-modified">!              blend-&gt;normalizedcoords[i] &gt;= im_end_coords[i]   )</span>
          {
<span class="line-modified">!           FT_TRACE6(( &quot;      intermediate tuple range ]%.5f;%.5f[ is exceeded,&quot;</span>
                        &quot; stop\n&quot;,
                        im_start_coords[i] / 65536.0,
                        im_end_coords[i] / 65536.0 ));
            apply = 0;
            break;
          }
  
<span class="line-modified">!         FT_TRACE6(( &quot;      intermediate tuple range ]%.5f;%.5f[ fits\n&quot;,</span>
<span class="line-modified">!                     im_start_coords[i] / 65536.0,</span>
<span class="line-modified">!                     im_end_coords[i] / 65536.0 ));</span>
<span class="line-modified">!         if ( blend-&gt;normalizedcoords[i] &lt; tuple_coords[i] )</span>
            apply = FT_MulDiv( apply,
                               blend-&gt;normalizedcoords[i] - im_start_coords[i],
                               tuple_coords[i] - im_start_coords[i] );
          else
            apply = FT_MulDiv( apply,
                               im_end_coords[i] - blend-&gt;normalizedcoords[i],
                               im_end_coords[i] - tuple_coords[i] );
        }
      }
  
      FT_TRACE6(( &quot;    apply factor is %.5f\n&quot;, apply / 65536.0 ));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1754,15 ***</span>
          else
            coord = a-&gt;minimum;
        }
  
        if ( coord &lt; a-&gt;def )
<span class="line-modified">!         normalized[i] = -FT_DivFix( coord - a-&gt;def,</span>
<span class="line-modified">!                                     a-&gt;minimum - a-&gt;def );</span>
        else if ( coord &gt; a-&gt;def )
<span class="line-modified">!         normalized[i] = FT_DivFix( coord - a-&gt;def,</span>
<span class="line-modified">!                                    a-&gt;maximum - a-&gt;def );</span>
        else
          normalized[i] = 0;
      }
  
      FT_TRACE5(( &quot;\n&quot; ));
<span class="line-new-header">--- 1817,15 ---</span>
          else
            coord = a-&gt;minimum;
        }
  
        if ( coord &lt; a-&gt;def )
<span class="line-modified">!         normalized[i] = -FT_DivFix( SUB_LONG( coord, a-&gt;def ),</span>
<span class="line-modified">!                                     SUB_LONG( a-&gt;minimum, a-&gt;def ) );</span>
        else if ( coord &gt; a-&gt;def )
<span class="line-modified">!         normalized[i] = FT_DivFix( SUB_LONG( coord, a-&gt;def ),</span>
<span class="line-modified">!                                    SUB_LONG( a-&gt;maximum, a-&gt;def ) );</span>
        else
          normalized[i] = 0;
      }
  
      FT_TRACE5(( &quot;\n&quot; ));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1908,31 ***</span>
      FT_UShort  nameID;
  
    } GX_FVar_Axis;
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Get_MM_Var                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Check that the font&#39;s `fvar&#39; table is valid, parse it, and return  */</span>
<span class="line-modified">!   /*    those data.  It also loads (and parses) the `MVAR&#39; table, if       */</span>
<span class="line-modified">!   /*    possible.                                                          */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face   :: The font face.                                           */</span>
<span class="line-modified">!   /*              TT_Get_MM_Var initializes the blend structure.           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">!   /*    master :: The `fvar&#39; data (must be freed by caller).  Can be NULL, */</span>
<span class="line-modified">!   /*              which makes this function simply load MM support.        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_MM_Var( TT_Face      face,
                   FT_MM_Var*  *master )
    {
      FT_Stream            stream     = face-&gt;root.stream;
<span class="line-new-header">--- 1971,33 ---</span>
      FT_UShort  nameID;
  
    } GX_FVar_Axis;
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Get_MM_Var</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Check that the font&#39;s `fvar&#39; table is valid, parse it, and return</span>
<span class="line-modified">!    *   those data.  It also loads (and parses) the `MVAR&#39; table, if</span>
<span class="line-modified">!    *   possible.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-modified">!    *     TT_Get_MM_Var initializes the blend structure.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Output:</span>
<span class="line-modified">!    *   master ::</span>
<span class="line-modified">!    *     The `fvar&#39; data (must be freed by caller).  Can be NULL,</span>
<span class="line-modified">!    *     which makes this function simply load MM support.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_MM_Var( TT_Face      face,
                   FT_MM_Var*  *master )
    {
      FT_Stream            stream     = face-&gt;root.stream;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2505,15 ***</span>
          }
        }
  
        if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
        {
<span class="line-modified">!         FT_UInt  idx = (FT_UInt)face-&gt;root.face_index &gt;&gt; 16;</span>
  
  
          c = blend-&gt;normalizedcoords + i;
<span class="line-modified">!         n = blend-&gt;normalized_stylecoords + idx * mmvar-&gt;num_axis + i;</span>
          for ( j = i; j &lt; mmvar-&gt;num_axis; j++, n++, c++ )
            if ( *c != *n )
              have_diff = 1;
        }
        else
<span class="line-new-header">--- 2570,18 ---</span>
          }
        }
  
        if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) )
        {
<span class="line-modified">!         FT_UInt  instance_index = (FT_UInt)face-&gt;root.face_index &gt;&gt; 16;</span>
  
  
          c = blend-&gt;normalizedcoords + i;
<span class="line-modified">!         n = blend-&gt;normalized_stylecoords            +</span>
<span class="line-added">+             ( instance_index - 1 ) * mmvar-&gt;num_axis +</span>
<span class="line-added">+             i;</span>
<span class="line-added">+ </span>
          for ( j = i; j &lt; mmvar-&gt;num_axis; j++, n++, c++ )
            if ( *c != *n )
              have_diff = 1;
        }
        else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2524,11 ***</span>
<span class="line-new-header">--- 2592,15 ---</span>
              have_diff = 1;
        }
  
        /* return value -1 indicates `no change&#39; */
        if ( !have_diff )
<span class="line-added">+       {</span>
<span class="line-added">+         face-&gt;doblend = TRUE;</span>
<span class="line-added">+ </span>
          return -1;
<span class="line-added">+       }</span>
  
        for ( ; i &lt; mmvar-&gt;num_axis; i++ )
        {
          if ( blend-&gt;normalizedcoords[i] != 0 )
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2588,35 ***</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Set_MM_Blend                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Set the blend (normalized) coordinates for this instance of the    */</span>
<span class="line-modified">!   /*    font.  Check that the `gvar&#39; table is reasonable and does some     */</span>
<span class="line-modified">!   /*    initial preparation.                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face       :: The font.                                            */</span>
<span class="line-modified">!   /*                  Initialize the blend structure with `gvar&#39; data.     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">!   /*                  larger than the number of axes, ignore the excess    */</span>
<span class="line-modified">!   /*                  values.  If it is smaller than the number of axes,   */</span>
<span class="line-modified">!   /*                  use the default value (0) for the remaining axes.    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    coords     :: An array of `num_coords&#39;, each between [-1,1].       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_MM_Blend( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
    {
<span class="line-new-header">--- 2660,38 ---</span>
    Exit:
      return error;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Set_MM_Blend</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Set the blend (normalized) coordinates for this instance of the</span>
<span class="line-modified">!    *   font.  Check that the `gvar&#39; table is reasonable and does some</span>
<span class="line-modified">!    *   initial preparation.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font.</span>
<span class="line-modified">!    *     Initialize the blend structure with `gvar&#39; data.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   num_coords ::</span>
<span class="line-modified">!    *     The number of available coordinates.  If it is</span>
<span class="line-modified">!    *     larger than the number of axes, ignore the excess</span>
<span class="line-modified">!    *     values.  If it is smaller than the number of axes,</span>
<span class="line-modified">!    *     use the default value (0) for the remaining axes.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   coords ::</span>
<span class="line-modified">!    *     An array of `num_coords&#39;, each between [-1,1].</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_MM_Blend( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2634,33 ***</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Get_MM_Blend                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Get the blend (normalized) coordinates for this instance of the    */</span>
<span class="line-modified">!   /*    font.                                                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face       :: The font.                                            */</span>
<span class="line-modified">!   /*                  Initialize the blend structure with `gvar&#39; data.     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">!   /*                  larger than the number of axes, set the excess       */</span>
<span class="line-modified">!   /*                  values to 0.                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    coords     :: An array of `num_coords&#39;, each between [-1,1].       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_MM_Blend( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
    {
<span class="line-new-header">--- 2709,36 ---</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Get_MM_Blend</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Get the blend (normalized) coordinates for this instance of the</span>
<span class="line-modified">!    *   font.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font.</span>
<span class="line-modified">!    *     Initialize the blend structure with `gvar&#39; data.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   num_coords ::</span>
<span class="line-modified">!    *     The number of available coordinates.  If it is</span>
<span class="line-modified">!    *     larger than the number of axes, set the excess</span>
<span class="line-modified">!    *     values to 0.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   coords ::</span>
<span class="line-modified">!    *     An array of `num_coords&#39;, each between [-1,1].</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_MM_Blend( TT_Face    face,
                     FT_UInt    num_coords,
                     FT_Fixed*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2710,35 ***</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Set_Var_Design                                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Set the coordinates for the instance, measured in the user         */</span>
<span class="line-modified">!   /*    coordinate system.  Parse the `avar&#39; table (if present) to convert */</span>
<span class="line-modified">!   /*    from user to normalized coordinates.                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face       :: The font face.                                       */</span>
<span class="line-modified">!   /*                  Initialize the blend struct with `gvar&#39; data.        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    num_coords :: The number of available coordinates.  If it is       */</span>
<span class="line-modified">!   /*                  larger than the number of axes, ignore the excess    */</span>
<span class="line-modified">!   /*                  values.  If it is smaller than the number of axes,   */</span>
<span class="line-modified">!   /*                  use the default values for the remaining axes.       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    coords     :: A coordinate array with `num_coords&#39; elements.       */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_Var_Design( TT_Face    face,
                       FT_UInt    num_coords,
                       FT_Fixed*  coords )
    {
<span class="line-new-header">--- 2788,38 ---</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Set_Var_Design</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Set the coordinates for the instance, measured in the user</span>
<span class="line-modified">!    *   coordinate system.  Parse the `avar&#39; table (if present) to convert</span>
<span class="line-modified">!    *   from user to normalized coordinates.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     The font face.</span>
<span class="line-modified">!    *     Initialize the blend struct with `gvar&#39; data.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   num_coords ::</span>
<span class="line-modified">!    *     The number of available coordinates.  If it is</span>
<span class="line-modified">!    *     larger than the number of axes, ignore the excess</span>
<span class="line-modified">!    *     values.  If it is smaller than the number of axes,</span>
<span class="line-modified">!    *     use the default values for the remaining axes.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   coords ::</span>
<span class="line-modified">!    *     A coordinate array with `num_coords&#39; elements.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_Var_Design( TT_Face    face,
                       FT_UInt    num_coords,
                       FT_Fixed*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2852,32 ***</span>
      FT_FREE( normalized );
      return error;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Get_Var_Design                                                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Get the design coordinates of the currently selected interpolated  */</span>
<span class="line-modified">!   /*    font.                                                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    face       :: A handle to the source face.                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    num_coords :: The number of design coordinates to retrieve.  If it */</span>
<span class="line-modified">!   /*                  is larger than the number of axes, set the excess    */</span>
<span class="line-modified">!   /*                  values to~0.                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">!   /*    coords     :: The design coordinates array.                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0~means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_Var_Design( TT_Face    face,
                       FT_UInt    num_coords,
                       FT_Fixed*  coords )
    {
<span class="line-new-header">--- 2933,35 ---</span>
      FT_FREE( normalized );
      return error;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Get_Var_Design</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Get the design coordinates of the currently selected interpolated</span>
<span class="line-modified">!    *   font.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     A handle to the source face.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   num_coords ::</span>
<span class="line-modified">!    *     The number of design coordinates to retrieve.  If it</span>
<span class="line-modified">!    *     is larger than the number of axes, set the excess</span>
<span class="line-modified">!    *     values to~0.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Output:</span>
<span class="line-modified">!    *   coords ::</span>
<span class="line-modified">!    *     The design coordinates array.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0~means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Get_Var_Design( TT_Face    face,
                       FT_UInt    num_coords,
                       FT_Fixed*  coords )
    {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2927,28 ***</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Set_Named_Instance                                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Set the given named instance, also resetting any further           */</span>
<span class="line-modified">!   /*    variation.                                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    face           :: A handle to the source face.                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    instance_index :: The instance index, starting with value 1.       */</span>
<span class="line-modified">!   /*                      Value 0 indicates to not use an instance.        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0~means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_Named_Instance( TT_Face  face,
                           FT_UInt  instance_index )
    {
      FT_Error    error = FT_ERR( Invalid_Argument );
<span class="line-new-header">--- 3011,30 ---</span>
  
      return FT_Err_Ok;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Set_Named_Instance</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Set the given named instance, also resetting any further</span>
<span class="line-modified">!    *   variation.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     A handle to the source face.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   instance_index ::</span>
<span class="line-modified">!    *     The instance index, starting with value 1.</span>
<span class="line-modified">!    *     Value 0 indicates to not use an instance.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0~means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Set_Named_Instance( TT_Face  face,
                           FT_UInt  instance_index )
    {
      FT_Error    error = FT_ERR( Invalid_Argument );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2971,11 ***</span>
  
      /* `instance_index&#39; starts with value 1, thus `&gt;&#39; */
      if ( instance_index &gt; num_instances )
        goto Exit;
  
<span class="line-modified">!     if ( instance_index &gt; 0 &amp;&amp; mmvar-&gt;namedstyle )</span>
      {
        FT_Memory     memory = face-&gt;root.memory;
        SFNT_Service  sfnt   = (SFNT_Service)face-&gt;sfnt;
  
        FT_Var_Named_Style*  named_style;
<span class="line-new-header">--- 3057,11 ---</span>
  
      /* `instance_index&#39; starts with value 1, thus `&gt;&#39; */
      if ( instance_index &gt; num_instances )
        goto Exit;
  
<span class="line-modified">!     if ( instance_index &gt; 0 )</span>
      {
        FT_Memory     memory = face-&gt;root.memory;
        SFNT_Service  sfnt   = (SFNT_Service)face-&gt;sfnt;
  
        FT_Var_Named_Style*  named_style;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2997,11 ***</span>
<span class="line-new-header">--- 3083,16 ---</span>
        /* finally, select the named instance */
        error = TT_Set_Var_Design( face,
                                   mmvar-&gt;num_axis,
                                   named_style-&gt;coords );
        if ( error )
<span class="line-added">+       {</span>
<span class="line-added">+         /* internal error code -1 means `no change&#39; */</span>
<span class="line-added">+         if ( error == -1 )</span>
<span class="line-added">+           error = FT_Err_Ok;</span>
          goto Exit;
<span class="line-added">+       }</span>
      }
      else
        error = TT_Set_Var_Design( face, 0, NULL );
  
      face-&gt;root.face_index  = ( instance_index &lt;&lt; 16 )             |
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3020,52 ***</span>
    /*****                                                               *****/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    tt_face_vary_cvt                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Modify the loaded cvt table according to the `cvar&#39; table and the  */</span>
<span class="line-modified">!   /*    font&#39;s blend.                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    face   :: A handle to the target face object.                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    stream :: A handle to the input stream.                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    Most errors are ignored.  It is perfectly valid not to have a      */</span>
<span class="line-modified">!   /*    `cvar&#39; table even if there is a `gvar&#39; and `fvar&#39; table.           */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    tt_face_vary_cvt( TT_Face    face,
                      FT_Stream  stream )
    {
<span class="line-modified">!     FT_Error    error;</span>
<span class="line-modified">!     FT_Memory   memory = stream-&gt;memory;</span>
<span class="line-modified">!     FT_ULong    table_start;</span>
<span class="line-modified">!     FT_ULong    table_len;</span>
<span class="line-modified">!     FT_UInt     tupleCount;</span>
<span class="line-modified">!     FT_ULong    offsetToData;</span>
<span class="line-modified">!     FT_ULong    here;</span>
<span class="line-modified">!     FT_UInt     i, j;</span>
<span class="line-modified">!     FT_Fixed*   tuple_coords    = NULL;</span>
<span class="line-modified">!     FT_Fixed*   im_start_coords = NULL;</span>
<span class="line-modified">!     FT_Fixed*   im_end_coords   = NULL;</span>
<span class="line-modified">!     GX_Blend    blend           = face-&gt;blend;</span>
<span class="line-modified">!     FT_UInt     point_count, spoint_count = 0;</span>
      FT_UShort*  sharedpoints = NULL;
      FT_UShort*  localpoints  = NULL;
      FT_UShort*  points;
<span class="line-modified">!     FT_Short*   deltas;</span>
  
  
      FT_TRACE2(( &quot;CVAR &quot; ));
  
      if ( !blend )
<span class="line-new-header">--- 3111,81 ---</span>
    /*****                                                               *****/
    /*************************************************************************/
    /*************************************************************************/
  
  
<span class="line-modified">!   static FT_Error</span>
<span class="line-modified">!   tt_cvt_ready_iterator( FT_ListNode  node,</span>
<span class="line-modified">!                          void*        user )</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     TT_Size  size = (TT_Size)node-&gt;data;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_UNUSED( user );</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!     size-&gt;cvt_ready = -1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return FT_Err_Ok;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   tt_face_vary_cvt</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-added">+    *   Modify the loaded cvt table according to the `cvar&#39; table and the</span>
<span class="line-added">+    *   font&#39;s blend.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @InOut:</span>
<span class="line-added">+    *   face ::</span>
<span class="line-added">+    *     A handle to the target face object.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Input:</span>
<span class="line-added">+    *   stream ::</span>
<span class="line-added">+    *     A handle to the input stream.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    *   Most errors are ignored.  It is perfectly valid not to have a</span>
<span class="line-added">+    *   `cvar&#39; table even if there is a `gvar&#39; and `fvar&#39; table.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    tt_face_vary_cvt( TT_Face    face,
                      FT_Stream  stream )
    {
<span class="line-modified">!     FT_Error   error;</span>
<span class="line-modified">!     FT_Memory  memory = stream-&gt;memory;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_Face  root = &amp;face-&gt;root;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_ULong  table_start;</span>
<span class="line-modified">!     FT_ULong  table_len;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_UInt   tupleCount;</span>
<span class="line-modified">!     FT_ULong  offsetToData;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_ULong  here;</span>
<span class="line-modified">!     FT_UInt   i, j;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FT_Fixed*  tuple_coords    = NULL;</span>
<span class="line-added">+     FT_Fixed*  im_start_coords = NULL;</span>
<span class="line-added">+     FT_Fixed*  im_end_coords   = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GX_Blend  blend = face-&gt;blend;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FT_UInt  point_count;</span>
<span class="line-added">+     FT_UInt  spoint_count = 0;</span>
<span class="line-added">+ </span>
      FT_UShort*  sharedpoints = NULL;
      FT_UShort*  localpoints  = NULL;
      FT_UShort*  points;
<span class="line-modified">! </span>
<span class="line-added">+     FT_Fixed*  deltas     = NULL;</span>
<span class="line-added">+     FT_Fixed*  cvt_deltas = NULL;</span>
  
  
      FT_TRACE2(( &quot;CVAR &quot; ));
  
      if ( !blend )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3144,15 ***</span>
  
        FT_Stream_SeekSet( stream, here );
      }
  
      FT_TRACE5(( &quot;cvar: there %s %d tuple%s:\n&quot;,
<span class="line-modified">!                 ( tupleCount &amp; 0xFFF ) == 1 ? &quot;is&quot; : &quot;are&quot;,</span>
<span class="line-modified">!                 tupleCount &amp; 0xFFF,</span>
<span class="line-modified">!                 ( tupleCount &amp; 0xFFF ) == 1 ? &quot;&quot; : &quot;s&quot; ));</span>
  
<span class="line-modified">!     for ( i = 0; i &lt; ( tupleCount &amp; 0xFFF ); i++ )</span>
      {
        FT_UInt   tupleDataSize;
        FT_UInt   tupleIndex;
        FT_Fixed  apply;
  
<span class="line-new-header">--- 3264,18 ---</span>
  
        FT_Stream_SeekSet( stream, here );
      }
  
      FT_TRACE5(( &quot;cvar: there %s %d tuple%s:\n&quot;,
<span class="line-modified">!                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,</span>
<span class="line-modified">!                 tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,</span>
<span class="line-modified">!                 ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));</span>
  
<span class="line-modified">!     if ( FT_NEW_ARRAY( cvt_deltas, face-&gt;cvt_size ) )</span>
<span class="line-added">+       goto FExit;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )</span>
      {
        FT_UInt   tupleDataSize;
        FT_UInt   tupleIndex;
        FT_Fixed  apply;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3163,33 ***</span>
        tupleIndex    = FT_GET_USHORT();
  
        if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           tuple_coords[j] = FT_GET_SHORT() * 4;  /* convert from        */</span>
<span class="line-removed">-                                                  /* short frac to fixed */</span>
        }
        else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
        {
          FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;
                      &quot; invalid tuple index\n&quot; ));
  
          error = FT_THROW( Invalid_Table );
<span class="line-modified">!         goto Exit;</span>
        }
        else
          FT_MEM_COPY(
            tuple_coords,
<span class="line-modified">!           &amp;blend-&gt;tuplecoords[( tupleIndex &amp; 0xFFF ) * blend-&gt;num_axis],</span>
            blend-&gt;num_axis * sizeof ( FT_Fixed ) );
  
        if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_start_coords[j] = FT_GET_SHORT() * 4;</span>
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_end_coords[j] = FT_GET_SHORT() * 4;</span>
        }
  
        apply = ft_var_apply_tuple( blend,
                                    (FT_UShort)tupleIndex,
                                    tuple_coords,
<span class="line-new-header">--- 3286,44 ---</span>
        tupleIndex    = FT_GET_USHORT();
  
        if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
        }
        else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
        {
          FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;
                      &quot; invalid tuple index\n&quot; ));
  
          error = FT_THROW( Invalid_Table );
<span class="line-modified">!         goto FExit;</span>
        }
        else
<span class="line-added">+       {</span>
<span class="line-added">+         if ( !blend-&gt;tuplecoords )</span>
<span class="line-added">+         {</span>
<span class="line-added">+           FT_TRACE2(( &quot;tt_face_vary_cvt:&quot;</span>
<span class="line-added">+                       &quot; no valid tuple coordinates available\n&quot; ));</span>
<span class="line-added">+ </span>
<span class="line-added">+           error = FT_THROW( Invalid_Table );</span>
<span class="line-added">+           goto FExit;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          FT_MEM_COPY(
            tuple_coords,
<span class="line-modified">!           blend-&gt;tuplecoords +</span>
<span class="line-added">+             ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) * blend-&gt;num_axis,</span>
            blend-&gt;num_axis * sizeof ( FT_Fixed ) );
<span class="line-added">+       }</span>
  
        if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
        }
  
        apply = ft_var_apply_tuple( blend,
                                    (FT_UShort)tupleIndex,
                                    tuple_coords,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3239,21 ***</span>
          FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
  
          /* this means that there are deltas for every entry in cvt */
          for ( j = 0; j &lt; face-&gt;cvt_size; j++ )
          {
<span class="line-modified">!           FT_Long  orig_cvt = face-&gt;cvt[j];</span>
  
  
<span class="line-modified">!           face-&gt;cvt[j] = (FT_Short)( orig_cvt +</span>
<span class="line-modified">!                                      FT_MulFix( deltas[j], apply ) );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( orig_cvt != face-&gt;cvt[j] )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: %d -&gt; %d\n&quot;,</span>
<span class="line-modified">!                         j, orig_cvt, face-&gt;cvt[j] ));</span>
              count++;
            }
  #endif
          }
  
<span class="line-new-header">--- 3373,25 ---</span>
          FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
  
          /* this means that there are deltas for every entry in cvt */
          for ( j = 0; j &lt; face-&gt;cvt_size; j++ )
          {
<span class="line-modified">!           FT_Fixed  old_cvt_delta;</span>
  
  
<span class="line-modified">!           old_cvt_delta = cvt_deltas[j];</span>
<span class="line-modified">!           cvt_deltas[j] = old_cvt_delta + FT_MulFix( deltas[j], apply );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( old_cvt_delta != cvt_deltas[j] )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: %f -&gt; %f\n&quot;,</span>
<span class="line-modified">!                         j,</span>
<span class="line-added">+                         ( FT_fdot6ToFixed( face-&gt;cvt[j] ) +</span>
<span class="line-added">+                           old_cvt_delta ) / 65536.0,</span>
<span class="line-added">+                         ( FT_fdot6ToFixed( face-&gt;cvt[j] ) +</span>
<span class="line-added">+                           cvt_deltas[j] ) / 65536.0 ));</span>
              count++;
            }
  #endif
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3272,27 ***</span>
  
          FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
  
          for ( j = 0; j &lt; point_count; j++ )
          {
<span class="line-modified">!           int      pindex;</span>
<span class="line-modified">!           FT_Long  orig_cvt;</span>
  
  
            pindex = points[j];
            if ( (FT_ULong)pindex &gt;= face-&gt;cvt_size )
              continue;
  
<span class="line-modified">!           orig_cvt          = face-&gt;cvt[pindex];</span>
<span class="line-modified">!           face-&gt;cvt[pindex] = (FT_Short)( orig_cvt +</span>
<span class="line-removed">-                                           FT_MulFix( deltas[j], apply ) );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( orig_cvt != face-&gt;cvt[pindex] )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: %d -&gt; %d\n&quot;,</span>
<span class="line-modified">!                         pindex, orig_cvt, face-&gt;cvt[pindex] ));</span>
              count++;
            }
  #endif
          }
  
<span class="line-new-header">--- 3410,30 ---</span>
  
          FT_TRACE7(( &quot;    CVT deltas:\n&quot; ));
  
          for ( j = 0; j &lt; point_count; j++ )
          {
<span class="line-modified">!           int       pindex;</span>
<span class="line-modified">!           FT_Fixed  old_cvt_delta;</span>
  
  
            pindex = points[j];
            if ( (FT_ULong)pindex &gt;= face-&gt;cvt_size )
              continue;
  
<span class="line-modified">!           old_cvt_delta      = cvt_deltas[pindex];</span>
<span class="line-modified">!           cvt_deltas[pindex] = old_cvt_delta + FT_MulFix( deltas[j], apply );</span>
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( old_cvt_delta != cvt_deltas[pindex] )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: %f -&gt; %f\n&quot;,</span>
<span class="line-modified">!                         pindex,</span>
<span class="line-added">+                         ( FT_fdot6ToFixed( face-&gt;cvt[pindex] ) +</span>
<span class="line-added">+                           old_cvt_delta ) / 65536.0,</span>
<span class="line-added">+                         ( FT_fdot6ToFixed( face-&gt;cvt[pindex] ) +</span>
<span class="line-added">+                           cvt_deltas[pindex] ) / 65536.0 ));</span>
              count++;
            }
  #endif
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3311,19 ***</span>
<span class="line-new-header">--- 3452,29 ---</span>
        FT_Stream_SeekSet( stream, here );
      }
  
      FT_TRACE5(( &quot;\n&quot; ));
  
<span class="line-added">+     for ( i = 0; i &lt; face-&gt;cvt_size; i++ )</span>
<span class="line-added">+       face-&gt;cvt[i] += FT_fixedToFdot6( cvt_deltas[i] );</span>
<span class="line-added">+ </span>
    FExit:
      FT_FRAME_EXIT();
  
    Exit:
      if ( sharedpoints != ALL_POINTS )
        FT_FREE( sharedpoints );
      FT_FREE( tuple_coords );
      FT_FREE( im_start_coords );
      FT_FREE( im_end_coords );
<span class="line-added">+     FT_FREE( cvt_deltas );</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* iterate over all FT_Size objects and set `cvt_ready&#39; to -1 */</span>
<span class="line-added">+     /* to trigger rescaling of all CVT values                     */</span>
<span class="line-added">+     FT_List_Iterate( &amp;root-&gt;sizes_list,</span>
<span class="line-added">+                      tt_cvt_ready_iterator,</span>
<span class="line-added">+                      NULL );</span>
  
      return error;
    }
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3365,13 ***</span>
  
    /* Interpolate the original coordinates of all points with indices */
    /* between `p1&#39; and `p2&#39;, using `ref1&#39; and `ref2&#39; as the reference */
    /* point indices.                                                  */
  
<span class="line-modified">!   /* modeled after `af_iup_interp&#39;, `_iup_worker_interpolate&#39;, and */</span>
<span class="line-modified">!   /* `Ins_IUP&#39;                                                     */</span>
<span class="line-removed">- </span>
    static void
    tt_delta_interpolate( int         p1,
                          int         p2,
                          int         ref1,
                          int         ref2,
<span class="line-new-header">--- 3516,12 ---</span>
  
    /* Interpolate the original coordinates of all points with indices */
    /* between `p1&#39; and `p2&#39;, using `ref1&#39; and `ref2&#39; as the reference */
    /* point indices.                                                  */
  
<span class="line-modified">!   /* modeled after `af_iup_interp&#39;, `_iup_worker_interpolate&#39;, and   */</span>
<span class="line-modified">!   /* `Ins_IUP&#39; with spec differences in handling ill-defined cases.  */</span>
    static void
    tt_delta_interpolate( int         p1,
                          int         p2,
                          int         ref1,
                          int         ref2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3526,65 ***</span>
  
      } while ( contour &lt; outline-&gt;n_contours );
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    TT_Vary_Apply_Glyph_Deltas                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Apply the appropriate deltas to the current glyph.                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    face        :: A handle to the target face object.                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    glyph_index :: The index of the glyph being modified.              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    n_points    :: The number of the points in the glyph, including    */</span>
<span class="line-modified">!   /*                   phantom points.                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    outline     :: The outline to change.                              */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                                FT_UInt      glyph_index,
                                FT_Outline*  outline,
                                FT_UInt      n_points )
    {
<span class="line-modified">!     FT_Stream   stream = face-&gt;root.stream;</span>
<span class="line-modified">!     FT_Memory   memory = stream-&gt;memory;</span>
<span class="line-modified">!     GX_Blend    blend  = face-&gt;blend;</span>
  
<span class="line-modified">!     FT_Vector*  points_org = NULL;</span>
<span class="line-modified">!     FT_Vector*  points_out = NULL;</span>
      FT_Bool*    has_delta  = NULL;
  
<span class="line-modified">!     FT_Error    error;</span>
<span class="line-modified">!     FT_ULong    glyph_start;</span>
<span class="line-modified">!     FT_UInt     tupleCount;</span>
<span class="line-modified">!     FT_ULong    offsetToData;</span>
<span class="line-modified">!     FT_ULong    here;</span>
<span class="line-modified">!     FT_UInt     i, j;</span>
<span class="line-modified">!     FT_Fixed*   tuple_coords    = NULL;</span>
<span class="line-modified">!     FT_Fixed*   im_start_coords = NULL;</span>
<span class="line-modified">!     FT_Fixed*   im_end_coords   = NULL;</span>
<span class="line-modified">!     FT_UInt     point_count, spoint_count = 0;</span>
      FT_UShort*  sharedpoints = NULL;
      FT_UShort*  localpoints  = NULL;
      FT_UShort*  points;
<span class="line-modified">!     FT_Short    *deltas_x, *deltas_y;</span>
  
  
      if ( !face-&gt;doblend || !blend )
        return FT_THROW( Invalid_Argument );
  
      if ( glyph_index &gt;= blend-&gt;gv_glyphcnt      ||
           blend-&gt;glyphoffsets[glyph_index] ==
             blend-&gt;glyphoffsets[glyph_index + 1] )
      {
        FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
<span class="line-new-header">--- 3676,93 ---</span>
  
      } while ( contour &lt; outline-&gt;n_contours );
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   TT_Vary_Apply_Glyph_Deltas</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Apply the appropriate deltas to the current glyph.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   face ::</span>
<span class="line-modified">!    *     A handle to the target face object.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   glyph_index ::</span>
<span class="line-modified">!    *     The index of the glyph being modified.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   n_points ::</span>
<span class="line-modified">!    *     The number of the points in the glyph, including</span>
<span class="line-modified">!    *     phantom points.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   outline ::</span>
<span class="line-modified">!    *     The outline to change.</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Output:</span>
<span class="line-added">+    *   unrounded ::</span>
<span class="line-added">+    *     An array with `n_points&#39; elements that is filled with unrounded</span>
<span class="line-added">+    *     point coordinates (in 26.6 format).</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   FreeType error code.  0 means success.</span>
<span class="line-added">+    */</span>
    FT_LOCAL_DEF( FT_Error )
    TT_Vary_Apply_Glyph_Deltas( TT_Face      face,
                                FT_UInt      glyph_index,
                                FT_Outline*  outline,
<span class="line-added">+                               FT_Vector*   unrounded,</span>
                                FT_UInt      n_points )
    {
<span class="line-modified">!     FT_Error   error;</span>
<span class="line-modified">!     FT_Stream  stream = face-&gt;root.stream;</span>
<span class="line-modified">!     FT_Memory  memory = stream-&gt;memory;</span>
  
<span class="line-modified">!     FT_Vector*  points_org = NULL;  /* coordinates in 16.16 format */</span>
<span class="line-modified">!     FT_Vector*  points_out = NULL;  /* coordinates in 16.16 format */</span>
      FT_Bool*    has_delta  = NULL;
  
<span class="line-modified">!     FT_ULong  glyph_start;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_UInt   tupleCount;</span>
<span class="line-modified">!     FT_ULong  offsetToData;</span>
<span class="line-modified">!     FT_ULong  dataSize;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_ULong  here;</span>
<span class="line-modified">!     FT_UInt   i, j;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     FT_Fixed*  tuple_coords    = NULL;</span>
<span class="line-added">+     FT_Fixed*  im_start_coords = NULL;</span>
<span class="line-added">+     FT_Fixed*  im_end_coords   = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+     GX_Blend  blend = face-&gt;blend;</span>
<span class="line-added">+ </span>
<span class="line-added">+     FT_UInt  point_count;</span>
<span class="line-added">+     FT_UInt  spoint_count = 0;</span>
<span class="line-added">+ </span>
      FT_UShort*  sharedpoints = NULL;
      FT_UShort*  localpoints  = NULL;
      FT_UShort*  points;
<span class="line-modified">! </span>
<span class="line-added">+     FT_Fixed*  deltas_x       = NULL;</span>
<span class="line-added">+     FT_Fixed*  deltas_y       = NULL;</span>
<span class="line-added">+     FT_Fixed*  point_deltas_x = NULL;</span>
<span class="line-added">+     FT_Fixed*  point_deltas_y = NULL;</span>
  
  
      if ( !face-&gt;doblend || !blend )
        return FT_THROW( Invalid_Argument );
  
<span class="line-added">+     for ( i = 0; i &lt; n_points; i++ )</span>
<span class="line-added">+     {</span>
<span class="line-added">+       unrounded[i].x = INT_TO_F26DOT6( outline-&gt;points[i].x );</span>
<span class="line-added">+       unrounded[i].y = INT_TO_F26DOT6( outline-&gt;points[i].y );</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if ( glyph_index &gt;= blend-&gt;gv_glyphcnt      ||
           blend-&gt;glyphoffsets[glyph_index] ==
             blend-&gt;glyphoffsets[glyph_index + 1] )
      {
        FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3595,13 ***</span>
      if ( FT_NEW_ARRAY( points_org, n_points ) ||
           FT_NEW_ARRAY( points_out, n_points ) ||
           FT_NEW_ARRAY( has_delta, n_points )  )
        goto Fail1;
  
<span class="line-modified">!     if ( FT_STREAM_SEEK( blend-&gt;glyphoffsets[glyph_index] )   ||</span>
<span class="line-modified">!          FT_FRAME_ENTER( blend-&gt;glyphoffsets[glyph_index + 1] -</span>
<span class="line-modified">!                            blend-&gt;glyphoffsets[glyph_index] ) )</span>
        goto Fail1;
  
      glyph_start = FT_Stream_FTell( stream );
  
      /* each set of glyph variation data is formatted similarly to `cvar&#39; */
<span class="line-new-header">--- 3773,15 ---</span>
      if ( FT_NEW_ARRAY( points_org, n_points ) ||
           FT_NEW_ARRAY( points_out, n_points ) ||
           FT_NEW_ARRAY( has_delta, n_points )  )
        goto Fail1;
  
<span class="line-modified">!     dataSize = blend-&gt;glyphoffsets[glyph_index + 1] -</span>
<span class="line-modified">!                  blend-&gt;glyphoffsets[glyph_index];</span>
<span class="line-modified">! </span>
<span class="line-added">+     if ( FT_STREAM_SEEK( blend-&gt;glyphoffsets[glyph_index] ) ||</span>
<span class="line-added">+          FT_FRAME_ENTER( dataSize )                         )</span>
        goto Fail1;
  
      glyph_start = FT_Stream_FTell( stream );
  
      /* each set of glyph variation data is formatted similarly to `cvar&#39; */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3613,12 ***</span>
  
      tupleCount   = FT_GET_USHORT();
      offsetToData = FT_GET_USHORT();
  
      /* rough sanity test */
<span class="line-modified">!     if ( offsetToData + ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) * 4 &gt;</span>
<span class="line-modified">!            blend-&gt;gvar_size )</span>
      {
        FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
                    &quot; invalid glyph variation array header\n&quot; ));
  
        error = FT_THROW( Invalid_Table );
<span class="line-new-header">--- 3793,12 ---</span>
  
      tupleCount   = FT_GET_USHORT();
      offsetToData = FT_GET_USHORT();
  
      /* rough sanity test */
<span class="line-modified">!     if ( offsetToData &gt; dataSize                                ||</span>
<span class="line-modified">!          ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) * 4 &gt; dataSize )</span>
      {
        FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
                    &quot; invalid glyph variation array header\n&quot; ));
  
        error = FT_THROW( Invalid_Table );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3644,12 ***</span>
      FT_TRACE5(( &quot;gvar: there %s %d tuple%s:\n&quot;,
                  ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,
                  tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,
                  ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));
  
      for ( j = 0; j &lt; n_points; j++ )
<span class="line-modified">!       points_org[j] = outline-&gt;points[j];</span>
  
      for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )
      {
        FT_UInt   tupleDataSize;
        FT_UInt   tupleIndex;
<span class="line-new-header">--- 3824,19 ---</span>
      FT_TRACE5(( &quot;gvar: there %s %d tuple%s:\n&quot;,
                  ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;is&quot; : &quot;are&quot;,
                  tupleCount &amp; GX_TC_TUPLE_COUNT_MASK,
                  ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ) == 1 ? &quot;&quot; : &quot;s&quot; ));
  
<span class="line-added">+     if ( FT_NEW_ARRAY( point_deltas_x, n_points ) ||</span>
<span class="line-added">+          FT_NEW_ARRAY( point_deltas_y, n_points ) )</span>
<span class="line-added">+       goto Fail3;</span>
<span class="line-added">+ </span>
      for ( j = 0; j &lt; n_points; j++ )
<span class="line-modified">!     {</span>
<span class="line-added">+       points_org[j].x = FT_intToFixed( outline-&gt;points[j].x );</span>
<span class="line-added">+       points_org[j].y = FT_intToFixed( outline-&gt;points[j].y );</span>
<span class="line-added">+     }</span>
  
      for ( i = 0; i &lt; ( tupleCount &amp; GX_TC_TUPLE_COUNT_MASK ); i++ )
      {
        FT_UInt   tupleDataSize;
        FT_UInt   tupleIndex;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3662,33 ***</span>
        tupleIndex    = FT_GET_USHORT();
  
        if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           tuple_coords[j] = FT_GET_SHORT() * 4;   /* convert from        */</span>
<span class="line-removed">-                                                   /* short frac to fixed */</span>
        }
        else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
        {
          FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
                      &quot; invalid tuple index\n&quot; ));
  
          error = FT_THROW( Invalid_Table );
<span class="line-modified">!         goto Fail2;</span>
        }
        else
          FT_MEM_COPY(
            tuple_coords,
<span class="line-modified">!           &amp;blend-&gt;tuplecoords[( tupleIndex &amp; 0xFFF ) * blend-&gt;num_axis],</span>
            blend-&gt;num_axis * sizeof ( FT_Fixed ) );
  
        if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_start_coords[j] = FT_GET_SHORT() * 4;</span>
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_end_coords[j] = FT_GET_SHORT() * 4;</span>
        }
  
        apply = ft_var_apply_tuple( blend,
                                    (FT_UShort)tupleIndex,
                                    tuple_coords,
<span class="line-new-header">--- 3849,33 ---</span>
        tupleIndex    = FT_GET_USHORT();
  
        if ( tupleIndex &amp; GX_TI_EMBEDDED_TUPLE_COORD )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           tuple_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
        }
        else if ( ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) &gt;= blend-&gt;tuplecount )
        {
          FT_TRACE2(( &quot;TT_Vary_Apply_Glyph_Deltas:&quot;
                      &quot; invalid tuple index\n&quot; ));
  
          error = FT_THROW( Invalid_Table );
<span class="line-modified">!         goto Fail3;</span>
        }
        else
          FT_MEM_COPY(
            tuple_coords,
<span class="line-modified">!           blend-&gt;tuplecoords +</span>
<span class="line-added">+             ( tupleIndex &amp; GX_TI_TUPLE_INDEX_MASK ) * blend-&gt;num_axis,</span>
            blend-&gt;num_axis * sizeof ( FT_Fixed ) );
  
        if ( tupleIndex &amp; GX_TI_INTERMEDIATE_TUPLE )
        {
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_start_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
          for ( j = 0; j &lt; blend-&gt;num_axis; j++ )
<span class="line-modified">!           im_end_coords[j] = FT_fdot14ToFixed( FT_GET_SHORT() );</span>
        }
  
        apply = ft_var_apply_tuple( blend,
                                    (FT_UShort)tupleIndex,
                                    tuple_coords,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3740,54 ***</span>
          FT_TRACE7(( &quot;    point deltas:\n&quot; ));
  
          /* this means that there are deltas for every point in the glyph */
          for ( j = 0; j &lt; n_points; j++ )
          {
<span class="line-modified">!           FT_Pos  delta_x = FT_MulFix( deltas_x[j], apply );</span>
<span class="line-modified">!           FT_Pos  delta_y = FT_MulFix( deltas_y[j], apply );</span>
  
  
            if ( j &lt; n_points - 4 )
            {
<span class="line-modified">!             outline-&gt;points[j].x += delta_x;</span>
<span class="line-modified">!             outline-&gt;points[j].y += delta_y;</span>
            }
            else
            {
              /* To avoid double adjustment of advance width or height, */
              /* adjust phantom points only if there is no HVAR or VVAR */
              /* support, respectively.                                 */
              if ( j == ( n_points - 4 )        &amp;&amp;
                   !( face-&gt;variation_support &amp;
                      TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">!               outline-&gt;points[j].x += delta_x;</span>
  
              else if ( j == ( n_points - 3 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">!               outline-&gt;points[j].x += delta_x;</span>
  
              else if ( j == ( n_points - 2 )        &amp;&amp;
                        !( face-&gt;variation_support &amp;
                           TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">!               outline-&gt;points[j].y += delta_y;</span>
  
              else if ( j == ( n_points - 1 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">!               outline-&gt;points[j].y += delta_y;</span>
            }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( delta_x || delta_y )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: (%d, %d) -&gt; (%d, %d)\n&quot;,</span>
                          j,
<span class="line-modified">!                         outline-&gt;points[j].x - delta_x,</span>
<span class="line-modified">!                         outline-&gt;points[j].y - delta_y,</span>
<span class="line-modified">!                         outline-&gt;points[j].x,</span>
<span class="line-modified">!                         outline-&gt;points[j].y ));</span>
              count++;
            }
  #endif
          }
  
<span class="line-new-header">--- 3927,61 ---</span>
          FT_TRACE7(( &quot;    point deltas:\n&quot; ));
  
          /* this means that there are deltas for every point in the glyph */
          for ( j = 0; j &lt; n_points; j++ )
          {
<span class="line-modified">!           FT_Fixed  old_point_delta_x = point_deltas_x[j];</span>
<span class="line-modified">!           FT_Fixed  old_point_delta_y = point_deltas_y[j];</span>
<span class="line-added">+ </span>
<span class="line-added">+           FT_Fixed  point_delta_x = FT_MulFix( deltas_x[j], apply );</span>
<span class="line-added">+           FT_Fixed  point_delta_y = FT_MulFix( deltas_y[j], apply );</span>
  
  
            if ( j &lt; n_points - 4 )
            {
<span class="line-modified">!             point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
<span class="line-modified">!             point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
            }
            else
            {
              /* To avoid double adjustment of advance width or height, */
              /* adjust phantom points only if there is no HVAR or VVAR */
              /* support, respectively.                                 */
              if ( j == ( n_points - 4 )        &amp;&amp;
                   !( face-&gt;variation_support &amp;
                      TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">!               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
  
              else if ( j == ( n_points - 3 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">!               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
  
              else if ( j == ( n_points - 2 )        &amp;&amp;
                        !( face-&gt;variation_support &amp;
                           TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">!               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
  
              else if ( j == ( n_points - 1 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">!               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
            }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( point_delta_x || point_delta_y )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: (%f, %f) -&gt; (%f, %f)\n&quot;,</span>
                          j,
<span class="line-modified">!                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-modified">!                           old_point_delta_x ) / 65536.0,</span>
<span class="line-modified">!                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-modified">!                           old_point_delta_y ) / 65536.0,</span>
<span class="line-added">+                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-added">+                           point_deltas_x[j] ) / 65536.0,</span>
<span class="line-added">+                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-added">+                           point_deltas_y[j] ) / 65536.0 ));</span>
              count++;
            }
  #endif
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3835,54 ***</span>
  
          FT_TRACE7(( &quot;    point deltas:\n&quot; ));
  
          for ( j = 0; j &lt; n_points; j++ )
          {
<span class="line-modified">!           FT_Pos  delta_x = points_out[j].x - points_org[j].x;</span>
<span class="line-modified">!           FT_Pos  delta_y = points_out[j].y - points_org[j].y;</span>
  
  
            if ( j &lt; n_points - 4 )
            {
<span class="line-modified">!             outline-&gt;points[j].x += delta_x;</span>
<span class="line-modified">!             outline-&gt;points[j].y += delta_y;</span>
            }
            else
            {
              /* To avoid double adjustment of advance width or height, */
              /* adjust phantom points only if there is no HVAR or VVAR */
              /* support, respectively.                                 */
              if ( j == ( n_points - 4 )        &amp;&amp;
                   !( face-&gt;variation_support &amp;
                      TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">!               outline-&gt;points[j].x += delta_x;</span>
  
              else if ( j == ( n_points - 3 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">!               outline-&gt;points[j].x += delta_x;</span>
  
              else if ( j == ( n_points - 2 )        &amp;&amp;
                        !( face-&gt;variation_support &amp;
                           TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">!               outline-&gt;points[j].y += delta_y;</span>
  
              else if ( j == ( n_points - 1 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">!               outline-&gt;points[j].y += delta_y;</span>
            }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( delta_x || delta_y )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: (%d, %d) -&gt; (%d, %d)\n&quot;,</span>
                          j,
<span class="line-modified">!                         outline-&gt;points[j].x - delta_x,</span>
<span class="line-modified">!                         outline-&gt;points[j].y - delta_y,</span>
<span class="line-modified">!                         outline-&gt;points[j].x,</span>
<span class="line-modified">!                         outline-&gt;points[j].y ));</span>
              count++;
            }
  #endif
          }
  
<span class="line-new-header">--- 4029,61 ---</span>
  
          FT_TRACE7(( &quot;    point deltas:\n&quot; ));
  
          for ( j = 0; j &lt; n_points; j++ )
          {
<span class="line-modified">!           FT_Fixed  old_point_delta_x = point_deltas_x[j];</span>
<span class="line-modified">!           FT_Fixed  old_point_delta_y = point_deltas_y[j];</span>
<span class="line-added">+ </span>
<span class="line-added">+           FT_Pos  point_delta_x = points_out[j].x - points_org[j].x;</span>
<span class="line-added">+           FT_Pos  point_delta_y = points_out[j].y - points_org[j].y;</span>
  
  
            if ( j &lt; n_points - 4 )
            {
<span class="line-modified">!             point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
<span class="line-modified">!             point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
            }
            else
            {
              /* To avoid double adjustment of advance width or height, */
              /* adjust phantom points only if there is no HVAR or VVAR */
              /* support, respectively.                                 */
              if ( j == ( n_points - 4 )        &amp;&amp;
                   !( face-&gt;variation_support &amp;
                      TT_FACE_FLAG_VAR_LSB    ) )
<span class="line-modified">!               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
  
              else if ( j == ( n_points - 3 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_HADVANCE ) )
<span class="line-modified">!               point_deltas_x[j] = old_point_delta_x + point_delta_x;</span>
  
              else if ( j == ( n_points - 2 )        &amp;&amp;
                        !( face-&gt;variation_support &amp;
                           TT_FACE_FLAG_VAR_TSB    ) )
<span class="line-modified">!               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
  
              else if ( j == ( n_points - 1 )          &amp;&amp;
                        !( face-&gt;variation_support   &amp;
                           TT_FACE_FLAG_VAR_VADVANCE ) )
<span class="line-modified">!               point_deltas_y[j] = old_point_delta_y + point_delta_y;</span>
            }
  
  #ifdef FT_DEBUG_LEVEL_TRACE
<span class="line-modified">!           if ( point_delta_x || point_delta_y )</span>
            {
<span class="line-modified">!             FT_TRACE7(( &quot;      %d: (%f, %f) -&gt; (%f, %f)\n&quot;,</span>
                          j,
<span class="line-modified">!                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-modified">!                           old_point_delta_x ) / 65536.0,</span>
<span class="line-modified">!                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-modified">!                           old_point_delta_y ) / 65536.0,</span>
<span class="line-added">+                         ( FT_intToFixed( outline-&gt;points[j].x ) +</span>
<span class="line-added">+                           point_deltas_x[j] ) / 65536.0,</span>
<span class="line-added">+                         ( FT_intToFixed( outline-&gt;points[j].y ) +</span>
<span class="line-added">+                           point_deltas_y[j] ) / 65536.0 ));</span>
              count++;
            }
  #endif
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3902,10 ***</span>
<span class="line-new-header">--- 4103,23 ---</span>
        FT_Stream_SeekSet( stream, here );
      }
  
      FT_TRACE5(( &quot;\n&quot; ));
  
<span class="line-added">+     for ( i = 0; i &lt; n_points; i++ )</span>
<span class="line-added">+     {</span>
<span class="line-added">+       unrounded[i].x += FT_fixedToFdot6( point_deltas_x[i] );</span>
<span class="line-added">+       unrounded[i].y += FT_fixedToFdot6( point_deltas_y[i] );</span>
<span class="line-added">+ </span>
<span class="line-added">+       outline-&gt;points[i].x += FT_fixedToInt( point_deltas_x[i] );</span>
<span class="line-added">+       outline-&gt;points[i].y += FT_fixedToInt( point_deltas_y[i] );</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   Fail3:</span>
<span class="line-added">+     FT_FREE( point_deltas_x );</span>
<span class="line-added">+     FT_FREE( point_deltas_y );</span>
<span class="line-added">+ </span>
    Fail2:
      if ( sharedpoints != ALL_POINTS )
        FT_FREE( sharedpoints );
      FT_FREE( tuple_coords );
      FT_FREE( im_start_coords );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3920,20 ***</span>
  
      return error;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    tt_get_var_blend                                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    An extended internal version of `TT_Get_MM_Blend&#39; that returns     */</span>
<span class="line-modified">!   /*    pointers instead of copying data, without any initialization of    */</span>
<span class="line-modified">!   /*    the MM machinery in case it isn&#39;t loaded yet.                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( FT_Error )
    tt_get_var_blend( TT_Face      face,
                      FT_UInt     *num_coords,
                      FT_Fixed*   *coords,
                      FT_Fixed*   *normalizedcoords,
<span class="line-new-header">--- 4134,20 ---</span>
  
      return error;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   tt_get_var_blend</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   An extended internal version of `TT_Get_MM_Blend&#39; that returns</span>
<span class="line-modified">!    *   pointers instead of copying data, without any initialization of</span>
<span class="line-modified">!    *   the MM machinery in case it isn&#39;t loaded yet.</span>
<span class="line-modified">!    */</span>
    FT_LOCAL_DEF( FT_Error )
    tt_get_var_blend( TT_Face      face,
                      FT_UInt     *num_coords,
                      FT_Fixed*   *coords,
                      FT_Fixed*   *normalizedcoords,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3991,18 ***</span>
        FT_FREE( itemStore-&gt;varRegionList );
      }
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    tt_done_blend                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Free the blend internal data structure.                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
    FT_LOCAL_DEF( void )
    tt_done_blend( TT_Face  face )
    {
      FT_Memory  memory = FT_FACE_MEMORY( face );
      GX_Blend   blend  = face-&gt;blend;
<span class="line-new-header">--- 4205,18 ---</span>
        FT_FREE( itemStore-&gt;varRegionList );
      }
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   tt_done_blend</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Free the blend internal data structure.</span>
<span class="line-modified">!    */</span>
    FT_LOCAL_DEF( void )
    tt_done_blend( TT_Face  face )
    {
      FT_Memory  memory = FT_FACE_MEMORY( face );
      GX_Blend   blend  = face-&gt;blend;
</pre>
<center><a href="ttgload.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttgxvar.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/psaux/psobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="psintrp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="psobjs.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/psaux/psobjs.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  psobjs.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Auxiliary functions for PostScript fonts (body).                     */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_POSTSCRIPT_AUX_H
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_CALC_H
  23 #include FT_DRIVER_H
  24 
  25 #include &quot;psobjs.h&quot;
  26 #include &quot;psconv.h&quot;
  27 
  28 #include &quot;psauxerr.h&quot;
  29 #include &quot;psauxmod.h&quot;
  30 
  31 
<span class="line-modified">  32   /*************************************************************************/</span>
<span class="line-modified">  33   /*                                                                       */</span>
<span class="line-modified">  34   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  35   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  36   /* messages during execution.                                            */</span>
<span class="line-modified">  37   /*                                                                       */</span>
  38 #undef  FT_COMPONENT
<span class="line-modified">  39 #define FT_COMPONENT  trace_psobjs</span>
  40 
  41 
  42   /*************************************************************************/
  43   /*************************************************************************/
  44   /*****                                                               *****/
  45   /*****                             PS_TABLE                          *****/
  46   /*****                                                               *****/
  47   /*************************************************************************/
  48   /*************************************************************************/
  49 
<span class="line-modified">  50   /*************************************************************************/</span>
<span class="line-modified">  51   /*                                                                       */</span>
<span class="line-modified">  52   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">  53   /*    ps_table_new                                                       */</span>
<span class="line-modified">  54   /*                                                                       */</span>
<span class="line-modified">  55   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">  56   /*    Initializes a PS_Table.                                            */</span>
<span class="line-modified">  57   /*                                                                       */</span>
<span class="line-modified">  58   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">  59   /*    table  :: The address of the target table.                         */</span>
<span class="line-modified">  60   /*                                                                       */</span>
<span class="line-modified">  61   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">  62   /*    count  :: The table size = the maximum number of elements.         */</span>
<span class="line-modified">  63   /*                                                                       */</span>
<span class="line-modified">  64   /*    memory :: The memory object to use for all subsequent              */</span>
<span class="line-modified">  65   /*              reallocations.                                           */</span>
<span class="line-modified">  66   /*                                                                       */</span>
<span class="line-modified">  67   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">  68   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified">  69   /*                                                                       */</span>



  70   FT_LOCAL_DEF( FT_Error )
  71   ps_table_new( PS_Table   table,
  72                 FT_Int     count,
  73                 FT_Memory  memory )
  74   {
  75     FT_Error  error;
  76 
  77 
  78     table-&gt;memory = memory;
  79     if ( FT_NEW_ARRAY( table-&gt;elements, count ) ||
  80          FT_NEW_ARRAY( table-&gt;lengths,  count ) )
  81       goto Exit;
  82 
  83     table-&gt;max_elems = count;
  84     table-&gt;init      = 0xDEADBEEFUL;
  85     table-&gt;num_elems = 0;
  86     table-&gt;block     = NULL;
  87     table-&gt;capacity  = 0;
  88     table-&gt;cursor    = 0;
  89 
</pre>
<hr />
<pre>
 127     if ( FT_ALLOC( table-&gt;block, new_size ) )
 128     {
 129       table-&gt;block = old_base;
 130       return error;
 131     }
 132 
 133     /* copy elements and shift offsets */
 134     if ( old_base )
 135     {
 136       FT_MEM_COPY( table-&gt;block, old_base, table-&gt;capacity );
 137       shift_elements( table, old_base );
 138       FT_FREE( old_base );
 139     }
 140 
 141     table-&gt;capacity = new_size;
 142 
 143     return FT_Err_Ok;
 144   }
 145 
 146 
<span class="line-modified"> 147   /*************************************************************************/</span>
<span class="line-modified"> 148   /*                                                                       */</span>
<span class="line-modified"> 149   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 150   /*    ps_table_add                                                       */</span>
<span class="line-modified"> 151   /*                                                                       */</span>
<span class="line-modified"> 152   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 153   /*    Adds an object to a PS_Table, possibly growing its memory block.   */</span>
<span class="line-modified"> 154   /*                                                                       */</span>
<span class="line-modified"> 155   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 156   /*    table  :: The target table.                                        */</span>
<span class="line-modified"> 157   /*                                                                       */</span>
<span class="line-modified"> 158   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 159   /*    idx    :: The index of the object in the table.                    */</span>
<span class="line-modified"> 160   /*                                                                       */</span>
<span class="line-modified"> 161   /*    object :: The address of the object to copy in memory.             */</span>
<span class="line-modified"> 162   /*                                                                       */</span>
<span class="line-modified"> 163   /*    length :: The length in bytes of the source object.                */</span>
<span class="line-modified"> 164   /*                                                                       */</span>
<span class="line-modified"> 165   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 166   /*    FreeType error code.  0 means success.  An error is returned if a  */</span>
<span class="line-modified"> 167   /*    reallocation fails.                                                */</span>
<span class="line-modified"> 168   /*                                                                       */</span>




 169   FT_LOCAL_DEF( FT_Error )
<span class="line-modified"> 170   ps_table_add( PS_Table  table,</span>
<span class="line-modified"> 171                 FT_Int    idx,</span>
<span class="line-modified"> 172                 void*     object,</span>
<span class="line-modified"> 173                 FT_UInt   length )</span>
 174   {
 175     if ( idx &lt; 0 || idx &gt;= table-&gt;max_elems )
 176     {
 177       FT_ERROR(( &quot;ps_table_add: invalid index\n&quot; ));
 178       return FT_THROW( Invalid_Argument );
 179     }
 180 
 181     /* grow the base block if needed */
 182     if ( table-&gt;cursor + length &gt; table-&gt;capacity )
 183     {
 184       FT_Error    error;
 185       FT_Offset   new_size = table-&gt;capacity;
 186       FT_PtrDist  in_offset;
 187 
 188 
 189       in_offset = (FT_Byte*)object - table-&gt;block;
 190       if ( in_offset &lt; 0 || (FT_Offset)in_offset &gt;= table-&gt;capacity )
 191         in_offset = -1;
 192 
 193       while ( new_size &lt; table-&gt;cursor + length )
</pre>
<hr />
<pre>
 199       }
 200 
 201       error = reallocate_t1_table( table, new_size );
 202       if ( error )
 203         return error;
 204 
 205       if ( in_offset &gt;= 0 )
 206         object = table-&gt;block + in_offset;
 207     }
 208 
 209     /* add the object to the base block and adjust offset */
 210     table-&gt;elements[idx] = table-&gt;block + table-&gt;cursor;
 211     table-&gt;lengths [idx] = length;
 212     FT_MEM_COPY( table-&gt;block + table-&gt;cursor, object, length );
 213 
 214     table-&gt;cursor += length;
 215     return FT_Err_Ok;
 216   }
 217 
 218 
<span class="line-modified"> 219   /*************************************************************************/</span>
<span class="line-modified"> 220   /*                                                                       */</span>
<span class="line-modified"> 221   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 222   /*    ps_table_done                                                      */</span>
<span class="line-modified"> 223   /*                                                                       */</span>
<span class="line-modified"> 224   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 225   /*    Finalizes a PS_TableRec (i.e., reallocate it to its current        */</span>
<span class="line-modified"> 226   /*    cursor).                                                           */</span>
<span class="line-modified"> 227   /*                                                                       */</span>
<span class="line-modified"> 228   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 229   /*    table :: The target table.                                         */</span>
<span class="line-modified"> 230   /*                                                                       */</span>
<span class="line-modified"> 231   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 232   /*    This function does NOT release the heap&#39;s memory block.  It is up  */</span>
<span class="line-modified"> 233   /*    to the caller to clean it, or reference it in its own structures.  */</span>
<span class="line-modified"> 234   /*                                                                       */</span>

 235   FT_LOCAL_DEF( void )
 236   ps_table_done( PS_Table  table )
 237   {
 238     FT_Memory  memory = table-&gt;memory;
 239     FT_Error   error;
 240     FT_Byte*   old_base = table-&gt;block;
 241 
 242 
 243     /* should never fail, because rec.cursor &lt;= rec.size */
 244     if ( !old_base )
 245       return;
 246 
 247     if ( FT_ALLOC( table-&gt;block, table-&gt;cursor ) )
 248       return;
 249     FT_MEM_COPY( table-&gt;block, old_base, table-&gt;cursor );
 250     shift_elements( table, old_base );
 251 
 252     table-&gt;capacity = table-&gt;cursor;
 253     FT_FREE( old_base );
 254 
</pre>
<hr />
<pre>
 481       case &#39;&lt;&#39;:
 482         error = skip_string( &amp;cur, limit );
 483         break;
 484 
 485       case &#39;%&#39;:
 486         skip_comment( &amp;cur, limit );
 487         break;
 488       }
 489     }
 490 
 491   end:
 492     if ( embed != 0 )
 493       error = FT_THROW( Invalid_File_Format );
 494 
 495     *acur = cur;
 496 
 497     return error;
 498   }
 499 
 500 
<span class="line-modified"> 501   /***********************************************************************/</span>
<span class="line-modified"> 502   /*                                                                     */</span>
<span class="line-modified"> 503   /* All exported parsing routines handle leading whitespace and stop at */</span>
<span class="line-modified"> 504   /* the first character which isn&#39;t part of the just handled token.     */</span>
<span class="line-modified"> 505   /*                                                                     */</span>
<span class="line-modified"> 506   /***********************************************************************/</span>
 507 
 508 
 509   FT_LOCAL_DEF( void )
 510   ps_parser_skip_PS_token( PS_Parser  parser )
 511   {
 512     /* Note: PostScript allows any non-delimiting, non-whitespace        */
 513     /*       character in a name (PS Ref Manual, 3rd ed, p31).           */
 514     /*       PostScript delimiters are (, ), &lt;, &gt;, [, ], {, }, /, and %. */
 515 
 516     FT_Byte*  cur   = parser-&gt;cursor;
 517     FT_Byte*  limit = parser-&gt;limit;
 518     FT_Error  error = FT_Err_Ok;
 519 
 520 
 521     skip_spaces( &amp;cur, limit );             /* this also skips comments */
 522     if ( cur &gt;= limit )
 523       goto Exit;
 524 
 525     /* self-delimiting, single-character tokens */
 526     if ( *cur == &#39;[&#39; || *cur == &#39;]&#39; )
</pre>
<hr />
<pre>
1083       idx = 1;
1084 
1085       /* don&#39;t include delimiters */
1086       cur++;
1087       limit--;
1088     }
1089 
1090     for ( ; count &gt; 0; count--, idx++ )
1091     {
1092       FT_Byte*    q      = (FT_Byte*)objects[idx] + field-&gt;offset;
1093       FT_Long     val;
1094       FT_String*  string = NULL;
1095 
1096 
1097       skip_spaces( &amp;cur, limit );
1098 
1099       switch ( type )
1100       {
1101       case T1_FIELD_TYPE_BOOL:
1102         val = ps_tobool( &amp;cur, limit );

1103         goto Store_Integer;
1104 
1105       case T1_FIELD_TYPE_FIXED:
1106         val = PS_Conv_ToFixed( &amp;cur, limit, 0 );

1107         goto Store_Integer;
1108 
1109       case T1_FIELD_TYPE_FIXED_1000:
1110         val = PS_Conv_ToFixed( &amp;cur, limit, 3 );

1111         goto Store_Integer;
1112 
1113       case T1_FIELD_TYPE_INTEGER:
1114         val = PS_Conv_ToInt( &amp;cur, limit );

1115         /* fall through */
1116 
1117       Store_Integer:
1118         switch ( field-&gt;size )
1119         {
1120         case (8 / FT_CHAR_BIT):
1121           *(FT_Byte*)q = (FT_Byte)val;
1122           break;
1123 
1124         case (16 / FT_CHAR_BIT):
1125           *(FT_UShort*)q = (FT_UShort)val;
1126           break;
1127 
1128         case (32 / FT_CHAR_BIT):
1129           *(FT_UInt32*)q = (FT_UInt32)val;
1130           break;
1131 
1132         default:                /* for 64-bit systems */
1133           *(FT_Long*)q = val;
1134         }
</pre>
<hr />
<pre>
1171             error = FT_THROW( Invalid_File_Format );
1172             goto Exit;
1173           }
1174 
1175           /* for this to work (FT_String**)q must have been */
1176           /* initialized to NULL                            */
1177           if ( *(FT_String**)q )
1178           {
1179             FT_TRACE0(( &quot;ps_parser_load_field: overwriting field %s\n&quot;,
1180                         field-&gt;ident ));
1181             FT_FREE( *(FT_String**)q );
1182             *(FT_String**)q = NULL;
1183           }
1184 
1185           if ( FT_ALLOC( string, len + 1 ) )
1186             goto Exit;
1187 
1188           FT_MEM_COPY( string, cur, len );
1189           string[len] = 0;
1190 







1191           *(FT_String**)q = string;
1192         }
1193         break;
1194 
1195       case T1_FIELD_TYPE_BBOX:
1196         {
1197           FT_Fixed  temp[4];
1198           FT_BBox*  bbox = (FT_BBox*)q;
1199           FT_Int    result;
1200 
1201 
1202           result = ps_tofixedarray( &amp;cur, limit, 4, temp, 0 );
1203 
1204           if ( result &lt; 4 )
1205           {
1206             FT_ERROR(( &quot;ps_parser_load_field:&quot;
1207                        &quot; expected four integers in bounding box\n&quot; ));
1208             error = FT_THROW( Invalid_File_Format );
1209             goto Exit;
1210           }
1211 
1212           bbox-&gt;xMin = FT_RoundFix( temp[0] );
1213           bbox-&gt;yMin = FT_RoundFix( temp[1] );
1214           bbox-&gt;xMax = FT_RoundFix( temp[2] );
1215           bbox-&gt;yMax = FT_RoundFix( temp[3] );






1216         }
1217         break;
1218 
1219       case T1_FIELD_TYPE_MM_BBOX:
1220         {
1221           FT_Memory  memory = parser-&gt;memory;
1222           FT_Fixed*  temp   = NULL;
1223           FT_Int     result;
1224           FT_UInt    i;
1225 
1226 
1227           if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )
1228             goto Exit;
1229 
1230           for ( i = 0; i &lt; 4; i++ )
1231           {
1232             result = ps_tofixedarray( &amp;cur, limit, (FT_Int)max_objects,
1233                                       temp + i * max_objects, 0 );
1234             if ( result &lt; 0 || (FT_UInt)result &lt; max_objects )
1235             {
1236               FT_ERROR(( &quot;ps_parser_load_field:&quot;
1237                          &quot; expected %d integer%s in the %s subarray\n&quot;
1238                          &quot;                     &quot;
1239                          &quot; of /FontBBox in the /Blend dictionary\n&quot;,
1240                          max_objects, max_objects &gt; 1 ? &quot;s&quot; : &quot;&quot;,
1241                          i == 0 ? &quot;first&quot;
1242                                 : ( i == 1 ? &quot;second&quot;
1243                                            : ( i == 2 ? &quot;third&quot;
1244                                                       : &quot;fourth&quot; ) ) ));
1245               error = FT_THROW( Invalid_File_Format );
1246 
1247               FT_FREE( temp );
1248               goto Exit;
1249             }
1250 
1251             skip_spaces( &amp;cur, limit );
1252           }
1253 

1254           for ( i = 0; i &lt; max_objects; i++ )
1255           {
1256             FT_BBox*  bbox = (FT_BBox*)objects[i];
1257 
1258 
1259             bbox-&gt;xMin = FT_RoundFix( temp[i                  ] );
1260             bbox-&gt;yMin = FT_RoundFix( temp[i +     max_objects] );
1261             bbox-&gt;xMax = FT_RoundFix( temp[i + 2 * max_objects] );
1262             bbox-&gt;yMax = FT_RoundFix( temp[i + 3 * max_objects] );






1263           }

1264 
1265           FT_FREE( temp );
1266         }
1267         break;
1268 
1269       default:
1270         /* an error occurred */
1271         goto Fail;
1272       }
1273     }
1274 
1275 #if 0  /* obsolete -- keep for reference */
1276     if ( pflags )
1277       *pflags |= 1L &lt;&lt; field-&gt;flag_bit;
1278 #else
1279     FT_UNUSED( pflags );
1280 #endif
1281 
1282     error = FT_Err_Ok;
1283 
</pre>
<hr />
<pre>
1316 
1317     ps_parser_to_token_array( parser, elements,
1318                               T1_MAX_TABLE_ELEMENTS, &amp;num_elements );
1319     if ( num_elements &lt; 0 )
1320     {
1321       error = FT_ERR( Ignore );
1322       goto Exit;
1323     }
1324     if ( (FT_UInt)num_elements &gt; field-&gt;array_max )
1325       num_elements = (FT_Int)field-&gt;array_max;
1326 
1327     old_cursor = parser-&gt;cursor;
1328     old_limit  = parser-&gt;limit;
1329 
1330     /* we store the elements count if necessary;           */
1331     /* we further assume that `count_offset&#39; can&#39;t be zero */
1332     if ( field-&gt;type != T1_FIELD_TYPE_BBOX &amp;&amp; field-&gt;count_offset != 0 )
1333       *(FT_Byte*)( (FT_Byte*)objects[0] + field-&gt;count_offset ) =
1334         (FT_Byte)num_elements;
1335 


1336     /* we now load each element, adjusting the field.offset on each one */
1337     token = elements;
1338     for ( ; num_elements &gt; 0; num_elements--, token++ )
1339     {
1340       parser-&gt;cursor = token-&gt;start;
1341       parser-&gt;limit  = token-&gt;limit;
1342 
1343       error = ps_parser_load_field( parser,
1344                                     &amp;fieldrec,
1345                                     objects,
1346                                     max_objects,
1347                                     0 );
1348       if ( error )
1349         break;
1350 
1351       fieldrec.offset += fieldrec.size;
1352     }
1353 


1354 #if 0  /* obsolete -- keep for reference */
1355     if ( pflags )
1356       *pflags |= 1L &lt;&lt; field-&gt;flag_bit;
1357 #else
1358     FT_UNUSED( pflags );
1359 #endif
1360 
1361     parser-&gt;cursor = old_cursor;
1362     parser-&gt;limit  = old_limit;
1363 
1364   Exit:
1365     return error;
1366   }
1367 
1368 
1369   FT_LOCAL_DEF( FT_Long )
1370   ps_parser_to_int( PS_Parser  parser )
1371   {
1372     ps_parser_skip_spaces( parser );
1373     return PS_Conv_ToInt( &amp;parser-&gt;cursor, parser-&gt;limit );
</pre>
<hr />
<pre>
1393     if ( cur &gt;= parser-&gt;limit )
1394       goto Exit;
1395 
1396     if ( delimiters )
1397     {
1398       if ( *cur != &#39;&lt;&#39; )
1399       {
1400         FT_ERROR(( &quot;ps_parser_to_bytes: Missing starting delimiter `&lt;&#39;\n&quot; ));
1401         error = FT_THROW( Invalid_File_Format );
1402         goto Exit;
1403       }
1404 
1405       cur++;
1406     }
1407 
1408     *pnum_bytes = PS_Conv_ASCIIHexDecode( &amp;cur,
1409                                           parser-&gt;limit,
1410                                           bytes,
1411                                           max_bytes );
1412 


1413     if ( delimiters )
1414     {
1415       if ( cur &lt; parser-&gt;limit &amp;&amp; *cur != &#39;&gt;&#39; )
1416       {
1417         FT_ERROR(( &quot;ps_parser_to_bytes: Missing closing delimiter `&gt;&#39;\n&quot; ));
1418         error = FT_THROW( Invalid_File_Format );
1419         goto Exit;
1420       }
1421 
<span class="line-modified">1422       cur++;</span>
1423     }
1424 
<span class="line-removed">1425     parser-&gt;cursor = cur;</span>
<span class="line-removed">1426 </span>
1427   Exit:
1428     return error;
1429   }
1430 
1431 
1432   FT_LOCAL_DEF( FT_Fixed )
1433   ps_parser_to_fixed( PS_Parser  parser,
1434                       FT_Int     power_ten )
1435   {
1436     ps_parser_skip_spaces( parser );
1437     return PS_Conv_ToFixed( &amp;parser-&gt;cursor, parser-&gt;limit, power_ten );
1438   }
1439 
1440 
1441   FT_LOCAL_DEF( FT_Int )
1442   ps_parser_to_coord_array( PS_Parser  parser,
1443                             FT_Int     max_coords,
1444                             FT_Short*  coords )
1445   {
1446     ps_parser_skip_spaces( parser );
</pre>
<hr />
<pre>
1492     parser-&gt;memory = memory;
1493     parser-&gt;funcs  = ps_parser_funcs;
1494   }
1495 
1496 
1497   FT_LOCAL_DEF( void )
1498   ps_parser_done( PS_Parser  parser )
1499   {
1500     FT_UNUSED( parser );
1501   }
1502 
1503 
1504   /*************************************************************************/
1505   /*************************************************************************/
1506   /*****                                                               *****/
1507   /*****                            T1 BUILDER                         *****/
1508   /*****                                                               *****/
1509   /*************************************************************************/
1510   /*************************************************************************/
1511 
<span class="line-modified">1512   /*************************************************************************/</span>
<span class="line-modified">1513   /*                                                                       */</span>
<span class="line-modified">1514   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1515   /*    t1_builder_init                                                    */</span>
<span class="line-modified">1516   /*                                                                       */</span>
<span class="line-modified">1517   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1518   /*    Initializes a given glyph builder.                                 */</span>
<span class="line-modified">1519   /*                                                                       */</span>
<span class="line-modified">1520   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1521   /*    builder :: A pointer to the glyph builder to initialize.           */</span>
<span class="line-modified">1522   /*                                                                       */</span>
<span class="line-modified">1523   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1524   /*    face    :: The current face object.                                */</span>
<span class="line-modified">1525   /*                                                                       */</span>
<span class="line-modified">1526   /*    size    :: The current size object.                                */</span>
<span class="line-modified">1527   /*                                                                       */</span>
<span class="line-modified">1528   /*    glyph   :: The current glyph object.                               */</span>
<span class="line-modified">1529   /*                                                                       */</span>
<span class="line-modified">1530   /*    hinting :: Whether hinting should be applied.                      */</span>
<span class="line-modified">1531   /*                                                                       */</span>





1532   FT_LOCAL_DEF( void )
1533   t1_builder_init( T1_Builder    builder,
1534                    FT_Face       face,
1535                    FT_Size       size,
1536                    FT_GlyphSlot  glyph,
1537                    FT_Bool       hinting )
1538   {
1539     builder-&gt;parse_state = T1_Parse_Start;
1540     builder-&gt;load_points = 1;
1541 
1542     builder-&gt;face   = face;
1543     builder-&gt;glyph  = glyph;
1544     builder-&gt;memory = face-&gt;memory;
1545 
1546     if ( glyph )
1547     {
1548       FT_GlyphLoader  loader = glyph-&gt;internal-&gt;loader;
1549 
1550 
1551       builder-&gt;loader  = loader;
</pre>
<hr />
<pre>
1555 
1556       builder-&gt;hints_globals = size-&gt;internal-&gt;module_data;
1557       builder-&gt;hints_funcs   = NULL;
1558 
1559       if ( hinting )
1560         builder-&gt;hints_funcs = glyph-&gt;internal-&gt;glyph_hints;
1561     }
1562 
1563     builder-&gt;pos_x = 0;
1564     builder-&gt;pos_y = 0;
1565 
1566     builder-&gt;left_bearing.x = 0;
1567     builder-&gt;left_bearing.y = 0;
1568     builder-&gt;advance.x      = 0;
1569     builder-&gt;advance.y      = 0;
1570 
1571     builder-&gt;funcs = t1_builder_funcs;
1572   }
1573 
1574 
<span class="line-modified">1575   /*************************************************************************/</span>
<span class="line-modified">1576   /*                                                                       */</span>
<span class="line-modified">1577   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1578   /*    t1_builder_done                                                    */</span>
<span class="line-modified">1579   /*                                                                       */</span>
<span class="line-modified">1580   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1581   /*    Finalizes a given glyph builder.  Its contents can still be used   */</span>
<span class="line-modified">1582   /*    after the call, but the function saves important information       */</span>
<span class="line-modified">1583   /*    within the corresponding glyph slot.                               */</span>
<span class="line-modified">1584   /*                                                                       */</span>
<span class="line-modified">1585   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1586   /*    builder :: A pointer to the glyph builder to finalize.             */</span>
<span class="line-modified">1587   /*                                                                       */</span>

1588   FT_LOCAL_DEF( void )
1589   t1_builder_done( T1_Builder  builder )
1590   {
1591     FT_GlyphSlot  glyph = builder-&gt;glyph;
1592 
1593 
1594     if ( glyph )
1595       glyph-&gt;outline = *builder-&gt;base;
1596   }
1597 
1598 
1599   /* check that there is enough space for `count&#39; more points */
1600   FT_LOCAL_DEF( FT_Error )
1601   t1_builder_check_points( T1_Builder  builder,
1602                            FT_Int      count )
1603   {
1604     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
1605   }
1606 
1607 
</pre>
<hr />
<pre>
1752       {
1753         outline-&gt;n_contours--;
1754         outline-&gt;n_points--;
1755       }
1756       else
1757         outline-&gt;contours[outline-&gt;n_contours - 1] =
1758           (short)( outline-&gt;n_points - 1 );
1759     }
1760   }
1761 
1762 
1763   /*************************************************************************/
1764   /*************************************************************************/
1765   /*****                                                               *****/
1766   /*****                           CFF BUILDER                         *****/
1767   /*****                                                               *****/
1768   /*************************************************************************/
1769   /*************************************************************************/
1770 
1771 
<span class="line-modified">1772   /*************************************************************************/</span>
<span class="line-modified">1773   /*                                                                       */</span>
<span class="line-modified">1774   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1775   /*    cff_builder_init                                                   */</span>
<span class="line-modified">1776   /*                                                                       */</span>
<span class="line-modified">1777   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1778   /*    Initializes a given glyph builder.                                 */</span>
<span class="line-modified">1779   /*                                                                       */</span>
<span class="line-modified">1780   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1781   /*    builder :: A pointer to the glyph builder to initialize.           */</span>
<span class="line-modified">1782   /*                                                                       */</span>
<span class="line-modified">1783   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1784   /*    face    :: The current face object.                                */</span>
<span class="line-modified">1785   /*                                                                       */</span>
<span class="line-modified">1786   /*    size    :: The current size object.                                */</span>
<span class="line-modified">1787   /*                                                                       */</span>
<span class="line-modified">1788   /*    glyph   :: The current glyph object.                               */</span>
<span class="line-modified">1789   /*                                                                       */</span>
<span class="line-modified">1790   /*    hinting :: Whether hinting is active.                              */</span>
<span class="line-modified">1791   /*                                                                       */</span>





1792   FT_LOCAL_DEF( void )
1793   cff_builder_init( CFF_Builder*   builder,
1794                     TT_Face        face,
1795                     CFF_Size       size,
1796                     CFF_GlyphSlot  glyph,
1797                     FT_Bool        hinting )
1798   {
1799     builder-&gt;path_begun  = 0;
1800     builder-&gt;load_points = 1;
1801 
1802     builder-&gt;face   = face;
1803     builder-&gt;glyph  = glyph;
1804     builder-&gt;memory = face-&gt;root.memory;
1805 
1806     if ( glyph )
1807     {
1808       FT_GlyphLoader  loader = glyph-&gt;root.internal-&gt;loader;
1809 
1810 
1811       builder-&gt;loader  = loader;
</pre>
<hr />
<pre>
1824         if ( internal )
1825         {
1826           builder-&gt;hints_globals = (void *)internal-&gt;topfont;
1827           builder-&gt;hints_funcs   = glyph-&gt;root.internal-&gt;glyph_hints;
1828         }
1829       }
1830     }
1831 
1832     builder-&gt;pos_x = 0;
1833     builder-&gt;pos_y = 0;
1834 
1835     builder-&gt;left_bearing.x = 0;
1836     builder-&gt;left_bearing.y = 0;
1837     builder-&gt;advance.x      = 0;
1838     builder-&gt;advance.y      = 0;
1839 
1840     builder-&gt;funcs = cff_builder_funcs;
1841   }
1842 
1843 
<span class="line-modified">1844   /*************************************************************************/</span>
<span class="line-modified">1845   /*                                                                       */</span>
<span class="line-modified">1846   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1847   /*    cff_builder_done                                                   */</span>
<span class="line-modified">1848   /*                                                                       */</span>
<span class="line-modified">1849   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1850   /*    Finalizes a given glyph builder.  Its contents can still be used   */</span>
<span class="line-modified">1851   /*    after the call, but the function saves important information       */</span>
<span class="line-modified">1852   /*    within the corresponding glyph slot.                               */</span>
<span class="line-modified">1853   /*                                                                       */</span>
<span class="line-modified">1854   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1855   /*    builder :: A pointer to the glyph builder to finalize.             */</span>
<span class="line-modified">1856   /*                                                                       */</span>

1857   FT_LOCAL_DEF( void )
1858   cff_builder_done( CFF_Builder*  builder )
1859   {
1860     CFF_GlyphSlot  glyph = builder-&gt;glyph;
1861 
1862 
1863     if ( glyph )
1864       glyph-&gt;root.outline = *builder-&gt;base;
1865   }
1866 
1867 
1868   /* check that there is enough space for `count&#39; more points */
1869   FT_LOCAL_DEF( FT_Error )
1870   cff_check_points( CFF_Builder*  builder,
1871                     FT_Int        count )
1872   {
1873     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
1874   }
1875 
1876 
</pre>
<hr />
<pre>
1976     }
1977 
1978     return error;
1979   }
1980 
1981 
1982   /* close the current contour */
1983   FT_LOCAL_DEF( void )
1984   cff_builder_close_contour( CFF_Builder*  builder )
1985   {
1986     FT_Outline*  outline = builder-&gt;current;
1987     FT_Int       first;
1988 
1989 
1990     if ( !outline )
1991       return;
1992 
1993     first = outline-&gt;n_contours &lt;= 1
1994             ? 0 : outline-&gt;contours[outline-&gt;n_contours - 2] + 1;
1995 








1996     /* We must not include the last point in the path if it */
1997     /* is located on the first point.                       */
1998     if ( outline-&gt;n_points &gt; 1 )
1999     {
2000       FT_Vector*  p1      = outline-&gt;points + first;
2001       FT_Vector*  p2      = outline-&gt;points + outline-&gt;n_points - 1;
2002       FT_Byte*    control = (FT_Byte*)outline-&gt;tags + outline-&gt;n_points - 1;
2003 
2004 
2005       /* `delete&#39; last point only if it coincides with the first    */
2006       /* point and if it is not a control point (which can happen). */
2007       if ( p1-&gt;x == p2-&gt;x &amp;&amp; p1-&gt;y == p2-&gt;y )
2008         if ( *control == FT_CURVE_TAG_ON )
2009           outline-&gt;n_points--;
2010     }
2011 
2012     if ( outline-&gt;n_contours &gt; 0 )
2013     {
2014       /* Don&#39;t add contours only consisting of one point, i.e., */
2015       /* check whether begin point and last point are the same. */
2016       if ( first == outline-&gt;n_points - 1 )
2017       {
2018         outline-&gt;n_contours--;
2019         outline-&gt;n_points--;
2020       }
2021       else
2022         outline-&gt;contours[outline-&gt;n_contours - 1] =
2023           (short)( outline-&gt;n_points - 1 );
2024     }
2025   }
2026 
2027 
2028   /*************************************************************************/
2029   /*************************************************************************/
2030   /*****                                                               *****/
2031   /*****                            PS BUILDER                         *****/
2032   /*****                                                               *****/
2033   /*************************************************************************/
2034   /*************************************************************************/
2035 
<span class="line-modified">2036   /*************************************************************************/</span>
<span class="line-modified">2037   /*                                                                       */</span>
<span class="line-modified">2038   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2039   /*    ps_builder_init                                                    */</span>
<span class="line-modified">2040   /*                                                                       */</span>
<span class="line-modified">2041   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2042   /*    Initializes a given glyph builder.                                 */</span>
<span class="line-modified">2043   /*                                                                       */</span>
<span class="line-modified">2044   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">2045   /*    builder :: A pointer to the glyph builder to initialize.           */</span>
<span class="line-modified">2046   /*                                                                       */</span>
<span class="line-modified">2047   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2048   /*    face    :: The current face object.                                */</span>
<span class="line-modified">2049   /*                                                                       */</span>
<span class="line-modified">2050   /*    size    :: The current size object.                                */</span>
<span class="line-modified">2051   /*                                                                       */</span>
<span class="line-modified">2052   /*    glyph   :: The current glyph object.                               */</span>
<span class="line-modified">2053   /*                                                                       */</span>
<span class="line-modified">2054   /*    hinting :: Whether hinting should be applied.                      */</span>
<span class="line-modified">2055   /*                                                                       */</span>





2056   FT_LOCAL_DEF( void )
2057   ps_builder_init( PS_Builder*  ps_builder,
2058                    void*        builder,
2059                    FT_Bool      is_t1 )
2060   {
2061     FT_ZERO( ps_builder );
2062 
2063     if ( is_t1 )
2064     {
2065       T1_Builder  t1builder = (T1_Builder)builder;
2066 
2067 
2068       ps_builder-&gt;memory  = t1builder-&gt;memory;
2069       ps_builder-&gt;face    = (FT_Face)t1builder-&gt;face;
2070       ps_builder-&gt;glyph   = (CFF_GlyphSlot)t1builder-&gt;glyph;
2071       ps_builder-&gt;loader  = t1builder-&gt;loader;
2072       ps_builder-&gt;base    = t1builder-&gt;base;
2073       ps_builder-&gt;current = t1builder-&gt;current;
2074 
2075       ps_builder-&gt;pos_x = &amp;t1builder-&gt;pos_x;
</pre>
<hr />
<pre>
2099 
2100       ps_builder-&gt;pos_x = &amp;cffbuilder-&gt;pos_x;
2101       ps_builder-&gt;pos_y = &amp;cffbuilder-&gt;pos_y;
2102 
2103       ps_builder-&gt;left_bearing = &amp;cffbuilder-&gt;left_bearing;
2104       ps_builder-&gt;advance      = &amp;cffbuilder-&gt;advance;
2105 
2106       ps_builder-&gt;bbox        = &amp;cffbuilder-&gt;bbox;
2107       ps_builder-&gt;path_begun  = cffbuilder-&gt;path_begun;
2108       ps_builder-&gt;load_points = cffbuilder-&gt;load_points;
2109       ps_builder-&gt;no_recurse  = cffbuilder-&gt;no_recurse;
2110 
2111       ps_builder-&gt;metrics_only = cffbuilder-&gt;metrics_only;
2112     }
2113 
2114     ps_builder-&gt;is_t1 = is_t1;
2115     ps_builder-&gt;funcs = ps_builder_funcs;
2116   }
2117 
2118 
<span class="line-modified">2119   /*************************************************************************/</span>
<span class="line-modified">2120   /*                                                                       */</span>
<span class="line-modified">2121   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2122   /*    ps_builder_done                                                    */</span>
<span class="line-modified">2123   /*                                                                       */</span>
<span class="line-modified">2124   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2125   /*    Finalizes a given glyph builder.  Its contents can still be used   */</span>
<span class="line-modified">2126   /*    after the call, but the function saves important information       */</span>
<span class="line-modified">2127   /*    within the corresponding glyph slot.                               */</span>
<span class="line-modified">2128   /*                                                                       */</span>
<span class="line-modified">2129   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2130   /*    builder :: A pointer to the glyph builder to finalize.             */</span>
<span class="line-modified">2131   /*                                                                       */</span>

2132   FT_LOCAL_DEF( void )
2133   ps_builder_done( PS_Builder*  builder )
2134   {
2135     CFF_GlyphSlot  glyph = builder-&gt;glyph;
2136 
2137 
2138     if ( glyph )
2139       glyph-&gt;root.outline = *builder-&gt;base;
2140   }
2141 
2142 
2143   /* check that there is enough space for `count&#39; more points */
2144   FT_LOCAL_DEF( FT_Error )
2145   ps_builder_check_points( PS_Builder*  builder,
2146                            FT_Int       count )
2147   {
2148     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
2149   }
2150 
2151 
</pre>
<hr />
<pre>
2319       {
2320         outline-&gt;n_contours--;
2321         outline-&gt;n_points--;
2322       }
2323       else
2324         outline-&gt;contours[outline-&gt;n_contours - 1] =
2325           (short)( outline-&gt;n_points - 1 );
2326     }
2327   }
2328 
2329 
2330   /*************************************************************************/
2331   /*************************************************************************/
2332   /*****                                                               *****/
2333   /*****                            OTHER                              *****/
2334   /*****                                                               *****/
2335   /*************************************************************************/
2336   /*************************************************************************/
2337 
2338 
<span class="line-modified">2339   /*************************************************************************/</span>
<span class="line-modified">2340   /*                                                                       */</span>
<span class="line-modified">2341   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2342   /*    ps_decoder_init                                                    */</span>
<span class="line-modified">2343   /*                                                                       */</span>
<span class="line-modified">2344   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2345   /*    Creates a wrapper decoder for use in the combined                  */</span>
<span class="line-modified">2346   /*    Type 1 / CFF interpreter.                                          */</span>
<span class="line-modified">2347   /*                                                                       */</span>
<span class="line-modified">2348   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">2349   /*    ps_decoder :: A pointer to the decoder to initialize.              */</span>
<span class="line-modified">2350   /*                                                                       */</span>
<span class="line-modified">2351   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2352   /*    decoder    :: A pointer to the original decoder.                   */</span>
<span class="line-modified">2353   /*                                                                       */</span>
<span class="line-modified">2354   /*    is_t1      :: Flag indicating Type 1 or CFF                        */</span>
<span class="line-modified">2355   /*                                                                       */</span>



2356   FT_LOCAL_DEF( void )
2357   ps_decoder_init( PS_Decoder*  ps_decoder,
2358                    void*        decoder,
2359                    FT_Bool      is_t1 )
2360   {
2361     FT_ZERO( ps_decoder );
2362 
2363     if ( is_t1 )
2364     {
2365       T1_Decoder  t1_decoder = (T1_Decoder)decoder;
2366 
2367 
2368       ps_builder_init( &amp;ps_decoder-&gt;builder,
2369                        &amp;t1_decoder-&gt;builder,
2370                        is_t1 );
2371 
2372       ps_decoder-&gt;cf2_instance = &amp;t1_decoder-&gt;cf2_instance;
2373       ps_decoder-&gt;psnames      = t1_decoder-&gt;psnames;
2374 
2375       ps_decoder-&gt;num_glyphs  = t1_decoder-&gt;num_glyphs;
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * psobjs.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auxiliary functions for PostScript fonts (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_POSTSCRIPT_AUX_H
  21 #include FT_INTERNAL_DEBUG_H
  22 #include FT_INTERNAL_CALC_H
  23 #include FT_DRIVER_H
  24 
  25 #include &quot;psobjs.h&quot;
  26 #include &quot;psconv.h&quot;
  27 
  28 #include &quot;psauxerr.h&quot;
  29 #include &quot;psauxmod.h&quot;
  30 
  31 
<span class="line-modified">  32   /**************************************************************************</span>
<span class="line-modified">  33    *</span>
<span class="line-modified">  34    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  35    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  36    * messages during execution.</span>
<span class="line-modified">  37    */</span>
  38 #undef  FT_COMPONENT
<span class="line-modified">  39 #define FT_COMPONENT  psobjs</span>
  40 
  41 
  42   /*************************************************************************/
  43   /*************************************************************************/
  44   /*****                                                               *****/
  45   /*****                             PS_TABLE                          *****/
  46   /*****                                                               *****/
  47   /*************************************************************************/
  48   /*************************************************************************/
  49 
<span class="line-modified">  50   /**************************************************************************</span>
<span class="line-modified">  51    *</span>
<span class="line-modified">  52    * @Function:</span>
<span class="line-modified">  53    *   ps_table_new</span>
<span class="line-modified">  54    *</span>
<span class="line-modified">  55    * @Description:</span>
<span class="line-modified">  56    *   Initializes a PS_Table.</span>
<span class="line-modified">  57    *</span>
<span class="line-modified">  58    * @InOut:</span>
<span class="line-modified">  59    *   table ::</span>
<span class="line-modified">  60    *     The address of the target table.</span>
<span class="line-modified">  61    *</span>
<span class="line-modified">  62    * @Input:</span>
<span class="line-modified">  63    *   count ::</span>
<span class="line-modified">  64    *     The table size = the maximum number of elements.</span>
<span class="line-modified">  65    *</span>
<span class="line-modified">  66    *   memory ::</span>
<span class="line-modified">  67    *     The memory object to use for all subsequent</span>
<span class="line-modified">  68    *     reallocations.</span>
<span class="line-modified">  69    *</span>
<span class="line-added">  70    * @Return:</span>
<span class="line-added">  71    *   FreeType error code.  0 means success.</span>
<span class="line-added">  72    */</span>
  73   FT_LOCAL_DEF( FT_Error )
  74   ps_table_new( PS_Table   table,
  75                 FT_Int     count,
  76                 FT_Memory  memory )
  77   {
  78     FT_Error  error;
  79 
  80 
  81     table-&gt;memory = memory;
  82     if ( FT_NEW_ARRAY( table-&gt;elements, count ) ||
  83          FT_NEW_ARRAY( table-&gt;lengths,  count ) )
  84       goto Exit;
  85 
  86     table-&gt;max_elems = count;
  87     table-&gt;init      = 0xDEADBEEFUL;
  88     table-&gt;num_elems = 0;
  89     table-&gt;block     = NULL;
  90     table-&gt;capacity  = 0;
  91     table-&gt;cursor    = 0;
  92 
</pre>
<hr />
<pre>
 130     if ( FT_ALLOC( table-&gt;block, new_size ) )
 131     {
 132       table-&gt;block = old_base;
 133       return error;
 134     }
 135 
 136     /* copy elements and shift offsets */
 137     if ( old_base )
 138     {
 139       FT_MEM_COPY( table-&gt;block, old_base, table-&gt;capacity );
 140       shift_elements( table, old_base );
 141       FT_FREE( old_base );
 142     }
 143 
 144     table-&gt;capacity = new_size;
 145 
 146     return FT_Err_Ok;
 147   }
 148 
 149 
<span class="line-modified"> 150   /**************************************************************************</span>
<span class="line-modified"> 151    *</span>
<span class="line-modified"> 152    * @Function:</span>
<span class="line-modified"> 153    *   ps_table_add</span>
<span class="line-modified"> 154    *</span>
<span class="line-modified"> 155    * @Description:</span>
<span class="line-modified"> 156    *   Adds an object to a PS_Table, possibly growing its memory block.</span>
<span class="line-modified"> 157    *</span>
<span class="line-modified"> 158    * @InOut:</span>
<span class="line-modified"> 159    *   table ::</span>
<span class="line-modified"> 160    *     The target table.</span>
<span class="line-modified"> 161    *</span>
<span class="line-modified"> 162    * @Input:</span>
<span class="line-modified"> 163    *   idx ::</span>
<span class="line-modified"> 164    *     The index of the object in the table.</span>
<span class="line-modified"> 165    *</span>
<span class="line-modified"> 166    *   object ::</span>
<span class="line-modified"> 167    *     The address of the object to copy in memory.</span>
<span class="line-modified"> 168    *</span>
<span class="line-modified"> 169    *   length ::</span>
<span class="line-modified"> 170    *     The length in bytes of the source object.</span>
<span class="line-modified"> 171    *</span>
<span class="line-added"> 172    * @Return:</span>
<span class="line-added"> 173    *   FreeType error code.  0 means success.  An error is returned if a</span>
<span class="line-added"> 174    *   reallocation fails.</span>
<span class="line-added"> 175    */</span>
 176   FT_LOCAL_DEF( FT_Error )
<span class="line-modified"> 177   ps_table_add( PS_Table     table,</span>
<span class="line-modified"> 178                 FT_Int       idx,</span>
<span class="line-modified"> 179                 const void*  object,</span>
<span class="line-modified"> 180                 FT_UInt      length )</span>
 181   {
 182     if ( idx &lt; 0 || idx &gt;= table-&gt;max_elems )
 183     {
 184       FT_ERROR(( &quot;ps_table_add: invalid index\n&quot; ));
 185       return FT_THROW( Invalid_Argument );
 186     }
 187 
 188     /* grow the base block if needed */
 189     if ( table-&gt;cursor + length &gt; table-&gt;capacity )
 190     {
 191       FT_Error    error;
 192       FT_Offset   new_size = table-&gt;capacity;
 193       FT_PtrDist  in_offset;
 194 
 195 
 196       in_offset = (FT_Byte*)object - table-&gt;block;
 197       if ( in_offset &lt; 0 || (FT_Offset)in_offset &gt;= table-&gt;capacity )
 198         in_offset = -1;
 199 
 200       while ( new_size &lt; table-&gt;cursor + length )
</pre>
<hr />
<pre>
 206       }
 207 
 208       error = reallocate_t1_table( table, new_size );
 209       if ( error )
 210         return error;
 211 
 212       if ( in_offset &gt;= 0 )
 213         object = table-&gt;block + in_offset;
 214     }
 215 
 216     /* add the object to the base block and adjust offset */
 217     table-&gt;elements[idx] = table-&gt;block + table-&gt;cursor;
 218     table-&gt;lengths [idx] = length;
 219     FT_MEM_COPY( table-&gt;block + table-&gt;cursor, object, length );
 220 
 221     table-&gt;cursor += length;
 222     return FT_Err_Ok;
 223   }
 224 
 225 
<span class="line-modified"> 226   /**************************************************************************</span>
<span class="line-modified"> 227    *</span>
<span class="line-modified"> 228    * @Function:</span>
<span class="line-modified"> 229    *   ps_table_done</span>
<span class="line-modified"> 230    *</span>
<span class="line-modified"> 231    * @Description:</span>
<span class="line-modified"> 232    *   Finalizes a PS_TableRec (i.e., reallocate it to its current</span>
<span class="line-modified"> 233    *   cursor).</span>
<span class="line-modified"> 234    *</span>
<span class="line-modified"> 235    * @InOut:</span>
<span class="line-modified"> 236    *   table ::</span>
<span class="line-modified"> 237    *     The target table.</span>
<span class="line-modified"> 238    *</span>
<span class="line-modified"> 239    * @Note:</span>
<span class="line-modified"> 240    *   This function does NOT release the heap&#39;s memory block.  It is up</span>
<span class="line-modified"> 241    *   to the caller to clean it, or reference it in its own structures.</span>
<span class="line-added"> 242    */</span>
 243   FT_LOCAL_DEF( void )
 244   ps_table_done( PS_Table  table )
 245   {
 246     FT_Memory  memory = table-&gt;memory;
 247     FT_Error   error;
 248     FT_Byte*   old_base = table-&gt;block;
 249 
 250 
 251     /* should never fail, because rec.cursor &lt;= rec.size */
 252     if ( !old_base )
 253       return;
 254 
 255     if ( FT_ALLOC( table-&gt;block, table-&gt;cursor ) )
 256       return;
 257     FT_MEM_COPY( table-&gt;block, old_base, table-&gt;cursor );
 258     shift_elements( table, old_base );
 259 
 260     table-&gt;capacity = table-&gt;cursor;
 261     FT_FREE( old_base );
 262 
</pre>
<hr />
<pre>
 489       case &#39;&lt;&#39;:
 490         error = skip_string( &amp;cur, limit );
 491         break;
 492 
 493       case &#39;%&#39;:
 494         skip_comment( &amp;cur, limit );
 495         break;
 496       }
 497     }
 498 
 499   end:
 500     if ( embed != 0 )
 501       error = FT_THROW( Invalid_File_Format );
 502 
 503     *acur = cur;
 504 
 505     return error;
 506   }
 507 
 508 
<span class="line-modified"> 509   /************************************************************************</span>
<span class="line-modified"> 510    *</span>
<span class="line-modified"> 511    * All exported parsing routines handle leading whitespace and stop at</span>
<span class="line-modified"> 512    * the first character which isn&#39;t part of the just handled token.</span>
<span class="line-modified"> 513    *</span>
<span class="line-modified"> 514    */</span>
 515 
 516 
 517   FT_LOCAL_DEF( void )
 518   ps_parser_skip_PS_token( PS_Parser  parser )
 519   {
 520     /* Note: PostScript allows any non-delimiting, non-whitespace        */
 521     /*       character in a name (PS Ref Manual, 3rd ed, p31).           */
 522     /*       PostScript delimiters are (, ), &lt;, &gt;, [, ], {, }, /, and %. */
 523 
 524     FT_Byte*  cur   = parser-&gt;cursor;
 525     FT_Byte*  limit = parser-&gt;limit;
 526     FT_Error  error = FT_Err_Ok;
 527 
 528 
 529     skip_spaces( &amp;cur, limit );             /* this also skips comments */
 530     if ( cur &gt;= limit )
 531       goto Exit;
 532 
 533     /* self-delimiting, single-character tokens */
 534     if ( *cur == &#39;[&#39; || *cur == &#39;]&#39; )
</pre>
<hr />
<pre>
1091       idx = 1;
1092 
1093       /* don&#39;t include delimiters */
1094       cur++;
1095       limit--;
1096     }
1097 
1098     for ( ; count &gt; 0; count--, idx++ )
1099     {
1100       FT_Byte*    q      = (FT_Byte*)objects[idx] + field-&gt;offset;
1101       FT_Long     val;
1102       FT_String*  string = NULL;
1103 
1104 
1105       skip_spaces( &amp;cur, limit );
1106 
1107       switch ( type )
1108       {
1109       case T1_FIELD_TYPE_BOOL:
1110         val = ps_tobool( &amp;cur, limit );
<span class="line-added">1111         FT_TRACE4(( &quot; %s&quot;, val ? &quot;true&quot; : &quot;false&quot; ));</span>
1112         goto Store_Integer;
1113 
1114       case T1_FIELD_TYPE_FIXED:
1115         val = PS_Conv_ToFixed( &amp;cur, limit, 0 );
<span class="line-added">1116         FT_TRACE4(( &quot; %f&quot;, (double)val / 65536 ));</span>
1117         goto Store_Integer;
1118 
1119       case T1_FIELD_TYPE_FIXED_1000:
1120         val = PS_Conv_ToFixed( &amp;cur, limit, 3 );
<span class="line-added">1121         FT_TRACE4(( &quot; %f&quot;, (double)val / 65536 / 1000 ));</span>
1122         goto Store_Integer;
1123 
1124       case T1_FIELD_TYPE_INTEGER:
1125         val = PS_Conv_ToInt( &amp;cur, limit );
<span class="line-added">1126         FT_TRACE4(( &quot; %ld&quot;, val ));</span>
1127         /* fall through */
1128 
1129       Store_Integer:
1130         switch ( field-&gt;size )
1131         {
1132         case (8 / FT_CHAR_BIT):
1133           *(FT_Byte*)q = (FT_Byte)val;
1134           break;
1135 
1136         case (16 / FT_CHAR_BIT):
1137           *(FT_UShort*)q = (FT_UShort)val;
1138           break;
1139 
1140         case (32 / FT_CHAR_BIT):
1141           *(FT_UInt32*)q = (FT_UInt32)val;
1142           break;
1143 
1144         default:                /* for 64-bit systems */
1145           *(FT_Long*)q = val;
1146         }
</pre>
<hr />
<pre>
1183             error = FT_THROW( Invalid_File_Format );
1184             goto Exit;
1185           }
1186 
1187           /* for this to work (FT_String**)q must have been */
1188           /* initialized to NULL                            */
1189           if ( *(FT_String**)q )
1190           {
1191             FT_TRACE0(( &quot;ps_parser_load_field: overwriting field %s\n&quot;,
1192                         field-&gt;ident ));
1193             FT_FREE( *(FT_String**)q );
1194             *(FT_String**)q = NULL;
1195           }
1196 
1197           if ( FT_ALLOC( string, len + 1 ) )
1198             goto Exit;
1199 
1200           FT_MEM_COPY( string, cur, len );
1201           string[len] = 0;
1202 
<span class="line-added">1203 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1204           if ( token.type == T1_TOKEN_TYPE_STRING )</span>
<span class="line-added">1205             FT_TRACE4(( &quot; (%s)&quot;, string ));</span>
<span class="line-added">1206           else</span>
<span class="line-added">1207             FT_TRACE4(( &quot; /%s&quot;, string ));</span>
<span class="line-added">1208 #endif</span>
<span class="line-added">1209 </span>
1210           *(FT_String**)q = string;
1211         }
1212         break;
1213 
1214       case T1_FIELD_TYPE_BBOX:
1215         {
1216           FT_Fixed  temp[4];
1217           FT_BBox*  bbox = (FT_BBox*)q;
1218           FT_Int    result;
1219 
1220 
1221           result = ps_tofixedarray( &amp;cur, limit, 4, temp, 0 );
1222 
1223           if ( result &lt; 4 )
1224           {
1225             FT_ERROR(( &quot;ps_parser_load_field:&quot;
1226                        &quot; expected four integers in bounding box\n&quot; ));
1227             error = FT_THROW( Invalid_File_Format );
1228             goto Exit;
1229           }
1230 
1231           bbox-&gt;xMin = FT_RoundFix( temp[0] );
1232           bbox-&gt;yMin = FT_RoundFix( temp[1] );
1233           bbox-&gt;xMax = FT_RoundFix( temp[2] );
1234           bbox-&gt;yMax = FT_RoundFix( temp[3] );
<span class="line-added">1235 </span>
<span class="line-added">1236           FT_TRACE4(( &quot; [%d %d %d %d]&quot;,</span>
<span class="line-added">1237                       bbox-&gt;xMin / 65536,</span>
<span class="line-added">1238                       bbox-&gt;yMin / 65536,</span>
<span class="line-added">1239                       bbox-&gt;xMax / 65536,</span>
<span class="line-added">1240                       bbox-&gt;yMax / 65536 ));</span>
1241         }
1242         break;
1243 
1244       case T1_FIELD_TYPE_MM_BBOX:
1245         {
1246           FT_Memory  memory = parser-&gt;memory;
1247           FT_Fixed*  temp   = NULL;
1248           FT_Int     result;
1249           FT_UInt    i;
1250 
1251 
1252           if ( FT_NEW_ARRAY( temp, max_objects * 4 ) )
1253             goto Exit;
1254 
1255           for ( i = 0; i &lt; 4; i++ )
1256           {
1257             result = ps_tofixedarray( &amp;cur, limit, (FT_Int)max_objects,
1258                                       temp + i * max_objects, 0 );
1259             if ( result &lt; 0 || (FT_UInt)result &lt; max_objects )
1260             {
1261               FT_ERROR(( &quot;ps_parser_load_field:&quot;
1262                          &quot; expected %d integer%s in the %s subarray\n&quot;
1263                          &quot;                     &quot;
1264                          &quot; of /FontBBox in the /Blend dictionary\n&quot;,
1265                          max_objects, max_objects &gt; 1 ? &quot;s&quot; : &quot;&quot;,
1266                          i == 0 ? &quot;first&quot;
1267                                 : ( i == 1 ? &quot;second&quot;
1268                                            : ( i == 2 ? &quot;third&quot;
1269                                                       : &quot;fourth&quot; ) ) ));
1270               error = FT_THROW( Invalid_File_Format );
1271 
1272               FT_FREE( temp );
1273               goto Exit;
1274             }
1275 
1276             skip_spaces( &amp;cur, limit );
1277           }
1278 
<span class="line-added">1279           FT_TRACE4(( &quot; [&quot; ));</span>
1280           for ( i = 0; i &lt; max_objects; i++ )
1281           {
1282             FT_BBox*  bbox = (FT_BBox*)objects[i];
1283 
1284 
1285             bbox-&gt;xMin = FT_RoundFix( temp[i                  ] );
1286             bbox-&gt;yMin = FT_RoundFix( temp[i +     max_objects] );
1287             bbox-&gt;xMax = FT_RoundFix( temp[i + 2 * max_objects] );
1288             bbox-&gt;yMax = FT_RoundFix( temp[i + 3 * max_objects] );
<span class="line-added">1289 </span>
<span class="line-added">1290             FT_TRACE4(( &quot; [%d %d %d %d]&quot;,</span>
<span class="line-added">1291                         bbox-&gt;xMin / 65536,</span>
<span class="line-added">1292                         bbox-&gt;yMin / 65536,</span>
<span class="line-added">1293                         bbox-&gt;xMax / 65536,</span>
<span class="line-added">1294                         bbox-&gt;yMax / 65536 ));</span>
1295           }
<span class="line-added">1296           FT_TRACE4(( &quot;]&quot; ));</span>
1297 
1298           FT_FREE( temp );
1299         }
1300         break;
1301 
1302       default:
1303         /* an error occurred */
1304         goto Fail;
1305       }
1306     }
1307 
1308 #if 0  /* obsolete -- keep for reference */
1309     if ( pflags )
1310       *pflags |= 1L &lt;&lt; field-&gt;flag_bit;
1311 #else
1312     FT_UNUSED( pflags );
1313 #endif
1314 
1315     error = FT_Err_Ok;
1316 
</pre>
<hr />
<pre>
1349 
1350     ps_parser_to_token_array( parser, elements,
1351                               T1_MAX_TABLE_ELEMENTS, &amp;num_elements );
1352     if ( num_elements &lt; 0 )
1353     {
1354       error = FT_ERR( Ignore );
1355       goto Exit;
1356     }
1357     if ( (FT_UInt)num_elements &gt; field-&gt;array_max )
1358       num_elements = (FT_Int)field-&gt;array_max;
1359 
1360     old_cursor = parser-&gt;cursor;
1361     old_limit  = parser-&gt;limit;
1362 
1363     /* we store the elements count if necessary;           */
1364     /* we further assume that `count_offset&#39; can&#39;t be zero */
1365     if ( field-&gt;type != T1_FIELD_TYPE_BBOX &amp;&amp; field-&gt;count_offset != 0 )
1366       *(FT_Byte*)( (FT_Byte*)objects[0] + field-&gt;count_offset ) =
1367         (FT_Byte)num_elements;
1368 
<span class="line-added">1369     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1370 </span>
1371     /* we now load each element, adjusting the field.offset on each one */
1372     token = elements;
1373     for ( ; num_elements &gt; 0; num_elements--, token++ )
1374     {
1375       parser-&gt;cursor = token-&gt;start;
1376       parser-&gt;limit  = token-&gt;limit;
1377 
1378       error = ps_parser_load_field( parser,
1379                                     &amp;fieldrec,
1380                                     objects,
1381                                     max_objects,
1382                                     0 );
1383       if ( error )
1384         break;
1385 
1386       fieldrec.offset += fieldrec.size;
1387     }
1388 
<span class="line-added">1389     FT_TRACE4(( &quot;]&quot; ));</span>
<span class="line-added">1390 </span>
1391 #if 0  /* obsolete -- keep for reference */
1392     if ( pflags )
1393       *pflags |= 1L &lt;&lt; field-&gt;flag_bit;
1394 #else
1395     FT_UNUSED( pflags );
1396 #endif
1397 
1398     parser-&gt;cursor = old_cursor;
1399     parser-&gt;limit  = old_limit;
1400 
1401   Exit:
1402     return error;
1403   }
1404 
1405 
1406   FT_LOCAL_DEF( FT_Long )
1407   ps_parser_to_int( PS_Parser  parser )
1408   {
1409     ps_parser_skip_spaces( parser );
1410     return PS_Conv_ToInt( &amp;parser-&gt;cursor, parser-&gt;limit );
</pre>
<hr />
<pre>
1430     if ( cur &gt;= parser-&gt;limit )
1431       goto Exit;
1432 
1433     if ( delimiters )
1434     {
1435       if ( *cur != &#39;&lt;&#39; )
1436       {
1437         FT_ERROR(( &quot;ps_parser_to_bytes: Missing starting delimiter `&lt;&#39;\n&quot; ));
1438         error = FT_THROW( Invalid_File_Format );
1439         goto Exit;
1440       }
1441 
1442       cur++;
1443     }
1444 
1445     *pnum_bytes = PS_Conv_ASCIIHexDecode( &amp;cur,
1446                                           parser-&gt;limit,
1447                                           bytes,
1448                                           max_bytes );
1449 
<span class="line-added">1450     parser-&gt;cursor = cur;</span>
<span class="line-added">1451 </span>
1452     if ( delimiters )
1453     {
1454       if ( cur &lt; parser-&gt;limit &amp;&amp; *cur != &#39;&gt;&#39; )
1455       {
1456         FT_ERROR(( &quot;ps_parser_to_bytes: Missing closing delimiter `&gt;&#39;\n&quot; ));
1457         error = FT_THROW( Invalid_File_Format );
1458         goto Exit;
1459       }
1460 
<span class="line-modified">1461       parser-&gt;cursor++;</span>
1462     }
1463 


1464   Exit:
1465     return error;
1466   }
1467 
1468 
1469   FT_LOCAL_DEF( FT_Fixed )
1470   ps_parser_to_fixed( PS_Parser  parser,
1471                       FT_Int     power_ten )
1472   {
1473     ps_parser_skip_spaces( parser );
1474     return PS_Conv_ToFixed( &amp;parser-&gt;cursor, parser-&gt;limit, power_ten );
1475   }
1476 
1477 
1478   FT_LOCAL_DEF( FT_Int )
1479   ps_parser_to_coord_array( PS_Parser  parser,
1480                             FT_Int     max_coords,
1481                             FT_Short*  coords )
1482   {
1483     ps_parser_skip_spaces( parser );
</pre>
<hr />
<pre>
1529     parser-&gt;memory = memory;
1530     parser-&gt;funcs  = ps_parser_funcs;
1531   }
1532 
1533 
1534   FT_LOCAL_DEF( void )
1535   ps_parser_done( PS_Parser  parser )
1536   {
1537     FT_UNUSED( parser );
1538   }
1539 
1540 
1541   /*************************************************************************/
1542   /*************************************************************************/
1543   /*****                                                               *****/
1544   /*****                            T1 BUILDER                         *****/
1545   /*****                                                               *****/
1546   /*************************************************************************/
1547   /*************************************************************************/
1548 
<span class="line-modified">1549   /**************************************************************************</span>
<span class="line-modified">1550    *</span>
<span class="line-modified">1551    * @Function:</span>
<span class="line-modified">1552    *   t1_builder_init</span>
<span class="line-modified">1553    *</span>
<span class="line-modified">1554    * @Description:</span>
<span class="line-modified">1555    *   Initializes a given glyph builder.</span>
<span class="line-modified">1556    *</span>
<span class="line-modified">1557    * @InOut:</span>
<span class="line-modified">1558    *   builder ::</span>
<span class="line-modified">1559    *     A pointer to the glyph builder to initialize.</span>
<span class="line-modified">1560    *</span>
<span class="line-modified">1561    * @Input:</span>
<span class="line-modified">1562    *   face ::</span>
<span class="line-modified">1563    *     The current face object.</span>
<span class="line-modified">1564    *</span>
<span class="line-modified">1565    *   size ::</span>
<span class="line-modified">1566    *     The current size object.</span>
<span class="line-modified">1567    *</span>
<span class="line-modified">1568    *   glyph ::</span>
<span class="line-added">1569    *     The current glyph object.</span>
<span class="line-added">1570    *</span>
<span class="line-added">1571    *   hinting ::</span>
<span class="line-added">1572    *     Whether hinting should be applied.</span>
<span class="line-added">1573    */</span>
1574   FT_LOCAL_DEF( void )
1575   t1_builder_init( T1_Builder    builder,
1576                    FT_Face       face,
1577                    FT_Size       size,
1578                    FT_GlyphSlot  glyph,
1579                    FT_Bool       hinting )
1580   {
1581     builder-&gt;parse_state = T1_Parse_Start;
1582     builder-&gt;load_points = 1;
1583 
1584     builder-&gt;face   = face;
1585     builder-&gt;glyph  = glyph;
1586     builder-&gt;memory = face-&gt;memory;
1587 
1588     if ( glyph )
1589     {
1590       FT_GlyphLoader  loader = glyph-&gt;internal-&gt;loader;
1591 
1592 
1593       builder-&gt;loader  = loader;
</pre>
<hr />
<pre>
1597 
1598       builder-&gt;hints_globals = size-&gt;internal-&gt;module_data;
1599       builder-&gt;hints_funcs   = NULL;
1600 
1601       if ( hinting )
1602         builder-&gt;hints_funcs = glyph-&gt;internal-&gt;glyph_hints;
1603     }
1604 
1605     builder-&gt;pos_x = 0;
1606     builder-&gt;pos_y = 0;
1607 
1608     builder-&gt;left_bearing.x = 0;
1609     builder-&gt;left_bearing.y = 0;
1610     builder-&gt;advance.x      = 0;
1611     builder-&gt;advance.y      = 0;
1612 
1613     builder-&gt;funcs = t1_builder_funcs;
1614   }
1615 
1616 
<span class="line-modified">1617   /**************************************************************************</span>
<span class="line-modified">1618    *</span>
<span class="line-modified">1619    * @Function:</span>
<span class="line-modified">1620    *   t1_builder_done</span>
<span class="line-modified">1621    *</span>
<span class="line-modified">1622    * @Description:</span>
<span class="line-modified">1623    *   Finalizes a given glyph builder.  Its contents can still be used</span>
<span class="line-modified">1624    *   after the call, but the function saves important information</span>
<span class="line-modified">1625    *   within the corresponding glyph slot.</span>
<span class="line-modified">1626    *</span>
<span class="line-modified">1627    * @Input:</span>
<span class="line-modified">1628    *   builder ::</span>
<span class="line-modified">1629    *     A pointer to the glyph builder to finalize.</span>
<span class="line-added">1630    */</span>
1631   FT_LOCAL_DEF( void )
1632   t1_builder_done( T1_Builder  builder )
1633   {
1634     FT_GlyphSlot  glyph = builder-&gt;glyph;
1635 
1636 
1637     if ( glyph )
1638       glyph-&gt;outline = *builder-&gt;base;
1639   }
1640 
1641 
1642   /* check that there is enough space for `count&#39; more points */
1643   FT_LOCAL_DEF( FT_Error )
1644   t1_builder_check_points( T1_Builder  builder,
1645                            FT_Int      count )
1646   {
1647     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
1648   }
1649 
1650 
</pre>
<hr />
<pre>
1795       {
1796         outline-&gt;n_contours--;
1797         outline-&gt;n_points--;
1798       }
1799       else
1800         outline-&gt;contours[outline-&gt;n_contours - 1] =
1801           (short)( outline-&gt;n_points - 1 );
1802     }
1803   }
1804 
1805 
1806   /*************************************************************************/
1807   /*************************************************************************/
1808   /*****                                                               *****/
1809   /*****                           CFF BUILDER                         *****/
1810   /*****                                                               *****/
1811   /*************************************************************************/
1812   /*************************************************************************/
1813 
1814 
<span class="line-modified">1815   /**************************************************************************</span>
<span class="line-modified">1816    *</span>
<span class="line-modified">1817    * @Function:</span>
<span class="line-modified">1818    *   cff_builder_init</span>
<span class="line-modified">1819    *</span>
<span class="line-modified">1820    * @Description:</span>
<span class="line-modified">1821    *   Initializes a given glyph builder.</span>
<span class="line-modified">1822    *</span>
<span class="line-modified">1823    * @InOut:</span>
<span class="line-modified">1824    *   builder ::</span>
<span class="line-modified">1825    *     A pointer to the glyph builder to initialize.</span>
<span class="line-modified">1826    *</span>
<span class="line-modified">1827    * @Input:</span>
<span class="line-modified">1828    *   face ::</span>
<span class="line-modified">1829    *     The current face object.</span>
<span class="line-modified">1830    *</span>
<span class="line-modified">1831    *   size ::</span>
<span class="line-modified">1832    *     The current size object.</span>
<span class="line-modified">1833    *</span>
<span class="line-modified">1834    *   glyph ::</span>
<span class="line-added">1835    *     The current glyph object.</span>
<span class="line-added">1836    *</span>
<span class="line-added">1837    *   hinting ::</span>
<span class="line-added">1838    *     Whether hinting is active.</span>
<span class="line-added">1839    */</span>
1840   FT_LOCAL_DEF( void )
1841   cff_builder_init( CFF_Builder*   builder,
1842                     TT_Face        face,
1843                     CFF_Size       size,
1844                     CFF_GlyphSlot  glyph,
1845                     FT_Bool        hinting )
1846   {
1847     builder-&gt;path_begun  = 0;
1848     builder-&gt;load_points = 1;
1849 
1850     builder-&gt;face   = face;
1851     builder-&gt;glyph  = glyph;
1852     builder-&gt;memory = face-&gt;root.memory;
1853 
1854     if ( glyph )
1855     {
1856       FT_GlyphLoader  loader = glyph-&gt;root.internal-&gt;loader;
1857 
1858 
1859       builder-&gt;loader  = loader;
</pre>
<hr />
<pre>
1872         if ( internal )
1873         {
1874           builder-&gt;hints_globals = (void *)internal-&gt;topfont;
1875           builder-&gt;hints_funcs   = glyph-&gt;root.internal-&gt;glyph_hints;
1876         }
1877       }
1878     }
1879 
1880     builder-&gt;pos_x = 0;
1881     builder-&gt;pos_y = 0;
1882 
1883     builder-&gt;left_bearing.x = 0;
1884     builder-&gt;left_bearing.y = 0;
1885     builder-&gt;advance.x      = 0;
1886     builder-&gt;advance.y      = 0;
1887 
1888     builder-&gt;funcs = cff_builder_funcs;
1889   }
1890 
1891 
<span class="line-modified">1892   /**************************************************************************</span>
<span class="line-modified">1893    *</span>
<span class="line-modified">1894    * @Function:</span>
<span class="line-modified">1895    *   cff_builder_done</span>
<span class="line-modified">1896    *</span>
<span class="line-modified">1897    * @Description:</span>
<span class="line-modified">1898    *   Finalizes a given glyph builder.  Its contents can still be used</span>
<span class="line-modified">1899    *   after the call, but the function saves important information</span>
<span class="line-modified">1900    *   within the corresponding glyph slot.</span>
<span class="line-modified">1901    *</span>
<span class="line-modified">1902    * @Input:</span>
<span class="line-modified">1903    *   builder ::</span>
<span class="line-modified">1904    *     A pointer to the glyph builder to finalize.</span>
<span class="line-added">1905    */</span>
1906   FT_LOCAL_DEF( void )
1907   cff_builder_done( CFF_Builder*  builder )
1908   {
1909     CFF_GlyphSlot  glyph = builder-&gt;glyph;
1910 
1911 
1912     if ( glyph )
1913       glyph-&gt;root.outline = *builder-&gt;base;
1914   }
1915 
1916 
1917   /* check that there is enough space for `count&#39; more points */
1918   FT_LOCAL_DEF( FT_Error )
1919   cff_check_points( CFF_Builder*  builder,
1920                     FT_Int        count )
1921   {
1922     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
1923   }
1924 
1925 
</pre>
<hr />
<pre>
2025     }
2026 
2027     return error;
2028   }
2029 
2030 
2031   /* close the current contour */
2032   FT_LOCAL_DEF( void )
2033   cff_builder_close_contour( CFF_Builder*  builder )
2034   {
2035     FT_Outline*  outline = builder-&gt;current;
2036     FT_Int       first;
2037 
2038 
2039     if ( !outline )
2040       return;
2041 
2042     first = outline-&gt;n_contours &lt;= 1
2043             ? 0 : outline-&gt;contours[outline-&gt;n_contours - 2] + 1;
2044 
<span class="line-added">2045     /* in malformed fonts it can happen that a contour was started */</span>
<span class="line-added">2046     /* but no points were added                                    */</span>
<span class="line-added">2047     if ( outline-&gt;n_contours &amp;&amp; first == outline-&gt;n_points )</span>
<span class="line-added">2048     {</span>
<span class="line-added">2049       outline-&gt;n_contours--;</span>
<span class="line-added">2050       return;</span>
<span class="line-added">2051     }</span>
<span class="line-added">2052 </span>
2053     /* We must not include the last point in the path if it */
2054     /* is located on the first point.                       */
2055     if ( outline-&gt;n_points &gt; 1 )
2056     {
2057       FT_Vector*  p1      = outline-&gt;points + first;
2058       FT_Vector*  p2      = outline-&gt;points + outline-&gt;n_points - 1;
2059       FT_Byte*    control = (FT_Byte*)outline-&gt;tags + outline-&gt;n_points - 1;
2060 
2061 
2062       /* `delete&#39; last point only if it coincides with the first    */
2063       /* point and if it is not a control point (which can happen). */
2064       if ( p1-&gt;x == p2-&gt;x &amp;&amp; p1-&gt;y == p2-&gt;y )
2065         if ( *control == FT_CURVE_TAG_ON )
2066           outline-&gt;n_points--;
2067     }
2068 
2069     if ( outline-&gt;n_contours &gt; 0 )
2070     {
2071       /* Don&#39;t add contours only consisting of one point, i.e., */
2072       /* check whether begin point and last point are the same. */
2073       if ( first == outline-&gt;n_points - 1 )
2074       {
2075         outline-&gt;n_contours--;
2076         outline-&gt;n_points--;
2077       }
2078       else
2079         outline-&gt;contours[outline-&gt;n_contours - 1] =
2080           (short)( outline-&gt;n_points - 1 );
2081     }
2082   }
2083 
2084 
2085   /*************************************************************************/
2086   /*************************************************************************/
2087   /*****                                                               *****/
2088   /*****                            PS BUILDER                         *****/
2089   /*****                                                               *****/
2090   /*************************************************************************/
2091   /*************************************************************************/
2092 
<span class="line-modified">2093   /**************************************************************************</span>
<span class="line-modified">2094    *</span>
<span class="line-modified">2095    * @Function:</span>
<span class="line-modified">2096    *   ps_builder_init</span>
<span class="line-modified">2097    *</span>
<span class="line-modified">2098    * @Description:</span>
<span class="line-modified">2099    *   Initializes a given glyph builder.</span>
<span class="line-modified">2100    *</span>
<span class="line-modified">2101    * @InOut:</span>
<span class="line-modified">2102    *   builder ::</span>
<span class="line-modified">2103    *     A pointer to the glyph builder to initialize.</span>
<span class="line-modified">2104    *</span>
<span class="line-modified">2105    * @Input:</span>
<span class="line-modified">2106    *   face ::</span>
<span class="line-modified">2107    *     The current face object.</span>
<span class="line-modified">2108    *</span>
<span class="line-modified">2109    *   size ::</span>
<span class="line-modified">2110    *     The current size object.</span>
<span class="line-modified">2111    *</span>
<span class="line-modified">2112    *   glyph ::</span>
<span class="line-added">2113    *     The current glyph object.</span>
<span class="line-added">2114    *</span>
<span class="line-added">2115    *   hinting ::</span>
<span class="line-added">2116    *     Whether hinting should be applied.</span>
<span class="line-added">2117    */</span>
2118   FT_LOCAL_DEF( void )
2119   ps_builder_init( PS_Builder*  ps_builder,
2120                    void*        builder,
2121                    FT_Bool      is_t1 )
2122   {
2123     FT_ZERO( ps_builder );
2124 
2125     if ( is_t1 )
2126     {
2127       T1_Builder  t1builder = (T1_Builder)builder;
2128 
2129 
2130       ps_builder-&gt;memory  = t1builder-&gt;memory;
2131       ps_builder-&gt;face    = (FT_Face)t1builder-&gt;face;
2132       ps_builder-&gt;glyph   = (CFF_GlyphSlot)t1builder-&gt;glyph;
2133       ps_builder-&gt;loader  = t1builder-&gt;loader;
2134       ps_builder-&gt;base    = t1builder-&gt;base;
2135       ps_builder-&gt;current = t1builder-&gt;current;
2136 
2137       ps_builder-&gt;pos_x = &amp;t1builder-&gt;pos_x;
</pre>
<hr />
<pre>
2161 
2162       ps_builder-&gt;pos_x = &amp;cffbuilder-&gt;pos_x;
2163       ps_builder-&gt;pos_y = &amp;cffbuilder-&gt;pos_y;
2164 
2165       ps_builder-&gt;left_bearing = &amp;cffbuilder-&gt;left_bearing;
2166       ps_builder-&gt;advance      = &amp;cffbuilder-&gt;advance;
2167 
2168       ps_builder-&gt;bbox        = &amp;cffbuilder-&gt;bbox;
2169       ps_builder-&gt;path_begun  = cffbuilder-&gt;path_begun;
2170       ps_builder-&gt;load_points = cffbuilder-&gt;load_points;
2171       ps_builder-&gt;no_recurse  = cffbuilder-&gt;no_recurse;
2172 
2173       ps_builder-&gt;metrics_only = cffbuilder-&gt;metrics_only;
2174     }
2175 
2176     ps_builder-&gt;is_t1 = is_t1;
2177     ps_builder-&gt;funcs = ps_builder_funcs;
2178   }
2179 
2180 
<span class="line-modified">2181   /**************************************************************************</span>
<span class="line-modified">2182    *</span>
<span class="line-modified">2183    * @Function:</span>
<span class="line-modified">2184    *   ps_builder_done</span>
<span class="line-modified">2185    *</span>
<span class="line-modified">2186    * @Description:</span>
<span class="line-modified">2187    *   Finalizes a given glyph builder.  Its contents can still be used</span>
<span class="line-modified">2188    *   after the call, but the function saves important information</span>
<span class="line-modified">2189    *   within the corresponding glyph slot.</span>
<span class="line-modified">2190    *</span>
<span class="line-modified">2191    * @Input:</span>
<span class="line-modified">2192    *   builder ::</span>
<span class="line-modified">2193    *     A pointer to the glyph builder to finalize.</span>
<span class="line-added">2194    */</span>
2195   FT_LOCAL_DEF( void )
2196   ps_builder_done( PS_Builder*  builder )
2197   {
2198     CFF_GlyphSlot  glyph = builder-&gt;glyph;
2199 
2200 
2201     if ( glyph )
2202       glyph-&gt;root.outline = *builder-&gt;base;
2203   }
2204 
2205 
2206   /* check that there is enough space for `count&#39; more points */
2207   FT_LOCAL_DEF( FT_Error )
2208   ps_builder_check_points( PS_Builder*  builder,
2209                            FT_Int       count )
2210   {
2211     return FT_GLYPHLOADER_CHECK_POINTS( builder-&gt;loader, count, 0 );
2212   }
2213 
2214 
</pre>
<hr />
<pre>
2382       {
2383         outline-&gt;n_contours--;
2384         outline-&gt;n_points--;
2385       }
2386       else
2387         outline-&gt;contours[outline-&gt;n_contours - 1] =
2388           (short)( outline-&gt;n_points - 1 );
2389     }
2390   }
2391 
2392 
2393   /*************************************************************************/
2394   /*************************************************************************/
2395   /*****                                                               *****/
2396   /*****                            OTHER                              *****/
2397   /*****                                                               *****/
2398   /*************************************************************************/
2399   /*************************************************************************/
2400 
2401 
<span class="line-modified">2402   /**************************************************************************</span>
<span class="line-modified">2403    *</span>
<span class="line-modified">2404    * @Function:</span>
<span class="line-modified">2405    *   ps_decoder_init</span>
<span class="line-modified">2406    *</span>
<span class="line-modified">2407    * @Description:</span>
<span class="line-modified">2408    *   Creates a wrapper decoder for use in the combined</span>
<span class="line-modified">2409    *   Type 1 / CFF interpreter.</span>
<span class="line-modified">2410    *</span>
<span class="line-modified">2411    * @InOut:</span>
<span class="line-modified">2412    *   ps_decoder ::</span>
<span class="line-modified">2413    *     A pointer to the decoder to initialize.</span>
<span class="line-modified">2414    *</span>
<span class="line-modified">2415    * @Input:</span>
<span class="line-modified">2416    *   decoder ::</span>
<span class="line-modified">2417    *     A pointer to the original decoder.</span>
<span class="line-modified">2418    *</span>
<span class="line-added">2419    *   is_t1 ::</span>
<span class="line-added">2420    *     Flag indicating Type 1 or CFF</span>
<span class="line-added">2421    */</span>
2422   FT_LOCAL_DEF( void )
2423   ps_decoder_init( PS_Decoder*  ps_decoder,
2424                    void*        decoder,
2425                    FT_Bool      is_t1 )
2426   {
2427     FT_ZERO( ps_decoder );
2428 
2429     if ( is_t1 )
2430     {
2431       T1_Decoder  t1_decoder = (T1_Decoder)decoder;
2432 
2433 
2434       ps_builder_init( &amp;ps_decoder-&gt;builder,
2435                        &amp;t1_decoder-&gt;builder,
2436                        is_t1 );
2437 
2438       ps_decoder-&gt;cf2_instance = &amp;t1_decoder-&gt;cf2_instance;
2439       ps_decoder-&gt;psnames      = t1_decoder-&gt;psnames;
2440 
2441       ps_decoder-&gt;num_glyphs  = t1_decoder-&gt;num_glyphs;
</pre>
</td>
</tr>
</table>
<center><a href="psintrp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="psobjs.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/truetype/ttdriver.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ttdriver.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   TrueType font driver implementation (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_STREAM_H
 22 #include FT_INTERNAL_SFNT_H
 23 #include FT_SERVICE_FONT_FORMAT_H
 24 
 25 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 26 #include FT_MULTIPLE_MASTERS_H
 27 #include FT_SERVICE_MULTIPLE_MASTERS_H
 28 #include FT_SERVICE_METRICS_VARIATIONS_H
 29 #endif
 30 
 31 #include FT_SERVICE_TRUETYPE_ENGINE_H
 32 #include FT_SERVICE_TRUETYPE_GLYF_H
 33 #include FT_SERVICE_PROPERTIES_H
 34 #include FT_DRIVER_H
 35 
 36 #include &quot;ttdriver.h&quot;
 37 #include &quot;ttgload.h&quot;
 38 #include &quot;ttpload.h&quot;
 39 
 40 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 41 #include &quot;ttgxvar.h&quot;
 42 #endif
 43 
 44 #include &quot;tterrors.h&quot;
 45 
<a name="2" id="anc2"></a>
 46 
<a name="3" id="anc3"></a><span class="line-modified"> 47   /**************************************************************************</span>
<span class="line-modified"> 48    *</span>
<span class="line-modified"> 49    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 50    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 51    * messages during execution.</span>
<span class="line-modified"> 52    */</span>
 53 #undef  FT_COMPONENT
<a name="4" id="anc4"></a><span class="line-modified"> 54 #define FT_COMPONENT  ttdriver</span>
 55 
 56 
 57   /*
<a name="5" id="anc5"></a><span class="line-modified"> 58    * PROPERTY SERVICE</span>
 59    *
 60    */
 61   static FT_Error
 62   tt_property_set( FT_Module    module,         /* TT_Driver */
 63                    const char*  property_name,
 64                    const void*  value,
 65                    FT_Bool      value_is_string )
 66   {
 67     FT_Error   error  = FT_Err_Ok;
 68     TT_Driver  driver = (TT_Driver)module;
 69 
 70 #ifndef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
 71     FT_UNUSED( value_is_string );
 72 #endif
 73 
 74 
 75     if ( !ft_strcmp( property_name, &quot;interpreter-version&quot; ) )
 76     {
 77       FT_UInt  interpreter_version;
 78 
 79 
 80 #ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
 81       if ( value_is_string )
 82       {
 83         const char*  s = (const char*)value;
 84 
 85 
 86         interpreter_version = (FT_UInt)ft_strtol( s, NULL, 10 );
 87       }
 88       else
 89 #endif
 90       {
 91         FT_UInt*  iv = (FT_UInt*)value;
 92 
 93 
 94         interpreter_version = *iv;
 95       }
 96 
 97       if ( interpreter_version == TT_INTERPRETER_VERSION_35
 98 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 99            || interpreter_version == TT_INTERPRETER_VERSION_38
100 #endif
101 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
102            || interpreter_version == TT_INTERPRETER_VERSION_40
103 #endif
104          )
105         driver-&gt;interpreter_version = interpreter_version;
106       else
107         error = FT_ERR( Unimplemented_Feature );
108 
109       return error;
110     }
111 
112     FT_TRACE0(( &quot;tt_property_set: missing property `%s&#39;\n&quot;,
113                 property_name ));
114     return FT_THROW( Missing_Property );
115   }
116 
117 
118   static FT_Error
119   tt_property_get( FT_Module    module,         /* TT_Driver */
120                    const char*  property_name,
121                    const void*  value )
122   {
123     FT_Error   error  = FT_Err_Ok;
124     TT_Driver  driver = (TT_Driver)module;
125 
126     FT_UInt  interpreter_version = driver-&gt;interpreter_version;
127 
128 
129     if ( !ft_strcmp( property_name, &quot;interpreter-version&quot; ) )
130     {
131       FT_UInt*  val = (FT_UInt*)value;
132 
133 
134       *val = interpreter_version;
135 
136       return error;
137     }
138 
139     FT_TRACE0(( &quot;tt_property_get: missing property `%s&#39;\n&quot;,
140                 property_name ));
141     return FT_THROW( Missing_Property );
142   }
143 
144 
145   FT_DEFINE_SERVICE_PROPERTIESREC(
146     tt_service_properties,
147 
148     (FT_Properties_SetFunc)tt_property_set,     /* set_property */
149     (FT_Properties_GetFunc)tt_property_get      /* get_property */
150   )
151 
152 
153   /*************************************************************************/
154   /*************************************************************************/
155   /*************************************************************************/
156   /****                                                                 ****/
157   /****                                                                 ****/
158   /****                          F A C E S                              ****/
159   /****                                                                 ****/
160   /****                                                                 ****/
161   /*************************************************************************/
162   /*************************************************************************/
163   /*************************************************************************/
164 
165 
<a name="6" id="anc6"></a><span class="line-modified">166   /**************************************************************************</span>
<span class="line-modified">167    *</span>
<span class="line-modified">168    * @Function:</span>
<span class="line-modified">169    *   tt_get_kerning</span>
<span class="line-modified">170    *</span>
<span class="line-modified">171    * @Description:</span>
<span class="line-modified">172    *   A driver method used to return the kerning vector between two</span>
<span class="line-modified">173    *   glyphs of the same face.</span>
<span class="line-modified">174    *</span>
<span class="line-modified">175    * @Input:</span>
<span class="line-modified">176    *   face ::</span>
<span class="line-modified">177    *     A handle to the source face object.</span>
<span class="line-modified">178    *</span>
<span class="line-modified">179    *   left_glyph ::</span>
<span class="line-modified">180    *     The index of the left glyph in the kern pair.</span>
<span class="line-modified">181    *</span>
<span class="line-modified">182    *   right_glyph ::</span>
<span class="line-modified">183    *     The index of the right glyph in the kern pair.</span>
<span class="line-modified">184    *</span>
<span class="line-modified">185    * @Output:</span>
<span class="line-modified">186    *   kerning ::</span>
<span class="line-modified">187    *     The kerning vector.  This is in font units for</span>
<span class="line-modified">188    *     scalable formats, and in pixels for fixed-sizes</span>
<span class="line-modified">189    *     formats.</span>
<span class="line-modified">190    *</span>
<span class="line-modified">191    * @Return:</span>
<span class="line-modified">192    *   FreeType error code.  0 means success.</span>
<span class="line-modified">193    *</span>
<span class="line-modified">194    * @Note:</span>
<span class="line-modified">195    *   Only horizontal layouts (left-to-right &amp; right-to-left) are</span>
<span class="line-modified">196    *   supported by this function.  Other layouts, or more sophisticated</span>
<span class="line-modified">197    *   kernings, are out of scope of this method (the basic driver</span>
<span class="line-added">198    *   interface is meant to be simple).</span>
<span class="line-added">199    *</span>
<span class="line-added">200    *   They can be implemented by format-specific interfaces.</span>
<span class="line-added">201    */</span>
202   static FT_Error
203   tt_get_kerning( FT_Face     ttface,          /* TT_Face */
204                   FT_UInt     left_glyph,
205                   FT_UInt     right_glyph,
206                   FT_Vector*  kerning )
207   {
208     TT_Face       face = (TT_Face)ttface;
209     SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;
210 
211 
212     kerning-&gt;x = 0;
213     kerning-&gt;y = 0;
214 
215     if ( sfnt )
216       kerning-&gt;x = sfnt-&gt;get_kerning( face, left_glyph, right_glyph );
217 
218     return 0;
219   }
220 
221 
222   static FT_Error
223   tt_get_advances( FT_Face    ttface,
224                    FT_UInt    start,
225                    FT_UInt    count,
226                    FT_Int32   flags,
227                    FT_Fixed  *advances )
228   {
229     FT_UInt  nn;
230     TT_Face  face = (TT_Face)ttface;
231 
232 
233     /* XXX: TODO: check for sbits */
234 
235     if ( flags &amp; FT_LOAD_VERTICAL_LAYOUT )
236     {
237 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
238       /* no fast retrieval for blended MM fonts without VVAR table */
239       if ( ( FT_IS_NAMED_INSTANCE( ttface ) || FT_IS_VARIATION( ttface ) ) &amp;&amp;
240            !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_VADVANCE )        )
241         return FT_THROW( Unimplemented_Feature );
242 #endif
243 
244       for ( nn = 0; nn &lt; count; nn++ )
245       {
246         FT_Short   tsb;
247         FT_UShort  ah;
248 
249 
250         /* since we don&#39;t need `tsb&#39;, we use zero for `yMax&#39; parameter */
251         TT_Get_VMetrics( face, start + nn, 0, &amp;tsb, &amp;ah );
252         advances[nn] = ah;
253       }
254     }
255     else
256     {
257 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
258       /* no fast retrieval for blended MM fonts without HVAR table */
259       if ( ( FT_IS_NAMED_INSTANCE( ttface ) || FT_IS_VARIATION( ttface ) ) &amp;&amp;
260            !( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_HADVANCE )        )
261         return FT_THROW( Unimplemented_Feature );
262 #endif
263 
264       for ( nn = 0; nn &lt; count; nn++ )
265       {
266         FT_Short   lsb;
267         FT_UShort  aw;
268 
269 
270         TT_Get_HMetrics( face, start + nn, &amp;lsb, &amp;aw );
271         advances[nn] = aw;
272       }
273     }
274 
275     return FT_Err_Ok;
276   }
277 
278 
279   /*************************************************************************/
280   /*************************************************************************/
281   /*************************************************************************/
282   /****                                                                 ****/
283   /****                                                                 ****/
284   /****                           S I Z E S                             ****/
285   /****                                                                 ****/
286   /****                                                                 ****/
287   /*************************************************************************/
288   /*************************************************************************/
289   /*************************************************************************/
290 
291 
292 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
293 
294   static FT_Error
295   tt_size_select( FT_Size   size,
296                   FT_ULong  strike_index )
297   {
298     TT_Face   ttface = (TT_Face)size-&gt;face;
299     TT_Size   ttsize = (TT_Size)size;
300     FT_Error  error  = FT_Err_Ok;
301 
302 
303     ttsize-&gt;strike_index = strike_index;
304 
305     if ( FT_IS_SCALABLE( size-&gt;face ) )
306     {
307       /* use the scaled metrics, even when tt_size_reset fails */
308       FT_Select_Metrics( size-&gt;face, strike_index );
309 
310       tt_size_reset( ttsize, 0 ); /* ignore return value */
311     }
312     else
313     {
314       SFNT_Service      sfnt         = (SFNT_Service)ttface-&gt;sfnt;
315       FT_Size_Metrics*  size_metrics = &amp;size-&gt;metrics;
316 
317 
318       error = sfnt-&gt;load_strike_metrics( ttface,
319                                          strike_index,
320                                          size_metrics );
321       if ( error )
322         ttsize-&gt;strike_index = 0xFFFFFFFFUL;
323     }
324 
325     return error;
326   }
327 
328 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
329 
330 
331   static FT_Error
332   tt_size_request( FT_Size          size,
333                    FT_Size_Request  req )
334   {
335     TT_Size   ttsize = (TT_Size)size;
336     FT_Error  error  = FT_Err_Ok;
337 
338 
339 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
340 
341     if ( FT_HAS_FIXED_SIZES( size-&gt;face ) )
342     {
343       TT_Face       ttface = (TT_Face)size-&gt;face;
344       SFNT_Service  sfnt   = (SFNT_Service)ttface-&gt;sfnt;
345       FT_ULong      strike_index;
346 
347 
348       error = sfnt-&gt;set_sbit_strike( ttface, req, &amp;strike_index );
349 
350       if ( error )
351         ttsize-&gt;strike_index = 0xFFFFFFFFUL;
352       else
353         return tt_size_select( size, strike_index );
354     }
355 
356 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
357 
358     FT_Request_Metrics( size-&gt;face, req );
359 
360     if ( FT_IS_SCALABLE( size-&gt;face ) )
361     {
362       error = tt_size_reset( ttsize, 0 );
363 
364 #ifdef TT_USE_BYTECODE_INTERPRETER
365       /* for the `MPS&#39; bytecode instruction we need the point size */
366       if ( !error )
367       {
368         FT_UInt  resolution =
369                    ttsize-&gt;metrics-&gt;x_ppem &gt; ttsize-&gt;metrics-&gt;y_ppem
370                      ? req-&gt;horiResolution
371                      : req-&gt;vertResolution;
372 
373 
374         /* if we don&#39;t have a resolution value, assume 72dpi */
375         if ( req-&gt;type == FT_SIZE_REQUEST_TYPE_SCALES ||
376              !resolution                              )
377           resolution = 72;
378 
379         ttsize-&gt;point_size = FT_MulDiv( ttsize-&gt;ttmetrics.ppem,
380                                         64 * 72,
381                                         resolution );
382       }
383 #endif
384     }
385 
386     return error;
387   }
388 
389 
<a name="7" id="anc7"></a><span class="line-modified">390   /**************************************************************************</span>
<span class="line-modified">391    *</span>
<span class="line-modified">392    * @Function:</span>
<span class="line-modified">393    *   tt_glyph_load</span>
<span class="line-modified">394    *</span>
<span class="line-modified">395    * @Description:</span>
<span class="line-modified">396    *   A driver method used to load a glyph within a given glyph slot.</span>
<span class="line-modified">397    *</span>
<span class="line-modified">398    * @Input:</span>
<span class="line-modified">399    *   slot ::</span>
<span class="line-modified">400    *     A handle to the target slot object where the glyph</span>
<span class="line-modified">401    *     will be loaded.</span>
<span class="line-modified">402    *</span>
<span class="line-modified">403    *   size ::</span>
<span class="line-modified">404    *     A handle to the source face size at which the glyph</span>
<span class="line-modified">405    *     must be scaled, loaded, etc.</span>
<span class="line-modified">406    *</span>
<span class="line-modified">407    *   glyph_index ::</span>
<span class="line-modified">408    *     The index of the glyph in the font file.</span>
<span class="line-modified">409    *</span>
<span class="line-modified">410    *   load_flags ::</span>
<span class="line-modified">411    *     A flag indicating what to load for this glyph.  The</span>
<span class="line-modified">412    *     FT_LOAD_XXX constants can be used to control the</span>
<span class="line-modified">413    *     glyph loading process (e.g., whether the outline</span>
<span class="line-modified">414    *     should be scaled, whether to load bitmaps or not,</span>
<span class="line-modified">415    *     whether to hint the outline, etc).</span>
<span class="line-added">416    *</span>
<span class="line-added">417    * @Return:</span>
<span class="line-added">418    *   FreeType error code.  0 means success.</span>
<span class="line-added">419    */</span>
420   static FT_Error
421   tt_glyph_load( FT_GlyphSlot  ttslot,      /* TT_GlyphSlot */
422                  FT_Size       ttsize,      /* TT_Size      */
423                  FT_UInt       glyph_index,
424                  FT_Int32      load_flags )
425   {
426     TT_GlyphSlot  slot = (TT_GlyphSlot)ttslot;
427     TT_Size       size = (TT_Size)ttsize;
428     FT_Face       face = ttslot-&gt;face;
429     FT_Error      error;
430 
431 
432     if ( !slot )
433       return FT_THROW( Invalid_Slot_Handle );
434 
435     if ( !size )
436       return FT_THROW( Invalid_Size_Handle );
437 
438     if ( !face )
439       return FT_THROW( Invalid_Face_Handle );
440 
441 #ifdef FT_CONFIG_OPTION_INCREMENTAL
442     if ( glyph_index &gt;= (FT_UInt)face-&gt;num_glyphs &amp;&amp;
443          !face-&gt;internal-&gt;incremental_interface   )
444 #else
445     if ( glyph_index &gt;= (FT_UInt)face-&gt;num_glyphs )
446 #endif
447       return FT_THROW( Invalid_Argument );
448 
449     if ( load_flags &amp; FT_LOAD_NO_HINTING )
450     {
451       /* both FT_LOAD_NO_HINTING and FT_LOAD_NO_AUTOHINT   */
452       /* are necessary to disable hinting for tricky fonts */
453 
454       if ( FT_IS_TRICKY( face ) )
455         load_flags &amp;= ~FT_LOAD_NO_HINTING;
456 
457       if ( load_flags &amp; FT_LOAD_NO_AUTOHINT )
458         load_flags |= FT_LOAD_NO_HINTING;
459     }
460 
461     if ( load_flags &amp; ( FT_LOAD_NO_RECURSE | FT_LOAD_NO_SCALE ) )
462     {
463       load_flags |= FT_LOAD_NO_BITMAP | FT_LOAD_NO_SCALE;
464 
465       if ( !FT_IS_TRICKY( face ) )
466         load_flags |= FT_LOAD_NO_HINTING;
467     }
468 
469     /* use hinted metrics only if we load a glyph with hinting */
470     size-&gt;metrics = ( load_flags &amp; FT_LOAD_NO_HINTING )
471                       ? &amp;ttsize-&gt;metrics
472                       : &amp;size-&gt;hinted_metrics;
473 
<a name="8" id="anc8"></a><span class="line-modified">474     /* now fill in the glyph slot with outline/bitmap/layered */</span>
475     error = TT_Load_Glyph( size, slot, glyph_index, load_flags );
476 
477     /* force drop-out mode to 2 - irrelevant now */
478     /* slot-&gt;outline.dropout_mode = 2; */
479 
480     return error;
481   }
482 
483 
484   /*************************************************************************/
485   /*************************************************************************/
486   /*************************************************************************/
487   /****                                                                 ****/
488   /****                                                                 ****/
489   /****                D R I V E R  I N T E R F A C E                   ****/
490   /****                                                                 ****/
491   /****                                                                 ****/
492   /*************************************************************************/
493   /*************************************************************************/
494   /*************************************************************************/
495 
496 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
497 
498   FT_DEFINE_SERVICE_MULTIMASTERSREC(
499     tt_service_gx_multi_masters,
500 
<a name="9" id="anc9"></a><span class="line-modified">501     (FT_Get_MM_Func)             NULL,                  /* get_mm              */</span>
<span class="line-modified">502     (FT_Set_MM_Design_Func)      NULL,                  /* set_mm_design       */</span>
<span class="line-modified">503     (FT_Set_MM_Blend_Func)       TT_Set_MM_Blend,       /* set_mm_blend        */</span>
<span class="line-modified">504     (FT_Get_MM_Blend_Func)       TT_Get_MM_Blend,       /* get_mm_blend        */</span>
<span class="line-modified">505     (FT_Get_MM_Var_Func)         TT_Get_MM_Var,         /* get_mm_var          */</span>
<span class="line-modified">506     (FT_Set_Var_Design_Func)     TT_Set_Var_Design,     /* set_var_design      */</span>
<span class="line-modified">507     (FT_Get_Var_Design_Func)     TT_Get_Var_Design,     /* get_var_design      */</span>
<span class="line-modified">508     (FT_Set_Instance_Func)       TT_Set_Named_Instance, /* set_instance        */</span>
<span class="line-modified">509     (FT_Set_MM_WeightVector_Func)NULL,                  /* set_mm_weightvector */</span>
<span class="line-modified">510     (FT_Get_MM_WeightVector_Func)NULL,                  /* get_mm_weightvector */</span>
<span class="line-modified">511 </span>
<span class="line-added">512     (FT_Get_Var_Blend_Func)      tt_get_var_blend,      /* get_var_blend       */</span>
<span class="line-added">513     (FT_Done_Blend_Func)         tt_done_blend          /* done_blend          */</span>
514   )
515 
516   FT_DEFINE_SERVICE_METRICSVARIATIONSREC(
517     tt_service_metrics_variations,
518 
519     (FT_HAdvance_Adjust_Func)tt_hadvance_adjust,     /* hadvance_adjust */
520     (FT_LSB_Adjust_Func)     NULL,                   /* lsb_adjust      */
521     (FT_RSB_Adjust_Func)     NULL,                   /* rsb_adjust      */
522 
523     (FT_VAdvance_Adjust_Func)tt_vadvance_adjust,     /* vadvance_adjust */
524     (FT_TSB_Adjust_Func)     NULL,                   /* tsb_adjust      */
525     (FT_BSB_Adjust_Func)     NULL,                   /* bsb_adjust      */
526     (FT_VOrg_Adjust_Func)    NULL,                   /* vorg_adjust     */
527 
528     (FT_Metrics_Adjust_Func) tt_apply_mvar           /* metrics_adjust  */
529   )
530 
531 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
532 
533 
534   static const FT_Service_TrueTypeEngineRec  tt_service_truetype_engine =
535   {
536 #ifdef TT_USE_BYTECODE_INTERPRETER
537 
538     FT_TRUETYPE_ENGINE_TYPE_PATENTED
539 
540 #else /* !TT_USE_BYTECODE_INTERPRETER */
541 
542     FT_TRUETYPE_ENGINE_TYPE_NONE
543 
544 #endif /* TT_USE_BYTECODE_INTERPRETER */
545   };
546 
547 
548   FT_DEFINE_SERVICE_TTGLYFREC(
549     tt_service_truetype_glyf,
550 
551     (TT_Glyf_GetLocationFunc)tt_face_get_location      /* get_location */
552   )
553 
554 
555 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
556   FT_DEFINE_SERVICEDESCREC6(
557     tt_services,
558 
559     FT_SERVICE_ID_FONT_FORMAT,        FT_FONT_FORMAT_TRUETYPE,
<a name="10" id="anc10"></a><span class="line-modified">560     FT_SERVICE_ID_MULTI_MASTERS,      &amp;tt_service_gx_multi_masters,</span>
<span class="line-modified">561     FT_SERVICE_ID_METRICS_VARIATIONS, &amp;tt_service_metrics_variations,</span>
562     FT_SERVICE_ID_TRUETYPE_ENGINE,    &amp;tt_service_truetype_engine,
<a name="11" id="anc11"></a><span class="line-modified">563     FT_SERVICE_ID_TT_GLYF,            &amp;tt_service_truetype_glyf,</span>
<span class="line-modified">564     FT_SERVICE_ID_PROPERTIES,         &amp;tt_service_properties )</span>
565 #else
566   FT_DEFINE_SERVICEDESCREC4(
567     tt_services,
568 
569     FT_SERVICE_ID_FONT_FORMAT,     FT_FONT_FORMAT_TRUETYPE,
570     FT_SERVICE_ID_TRUETYPE_ENGINE, &amp;tt_service_truetype_engine,
<a name="12" id="anc12"></a><span class="line-modified">571     FT_SERVICE_ID_TT_GLYF,         &amp;tt_service_truetype_glyf,</span>
<span class="line-modified">572     FT_SERVICE_ID_PROPERTIES,      &amp;tt_service_properties )</span>
573 #endif
574 
575 
576   FT_CALLBACK_DEF( FT_Module_Interface )
577   tt_get_interface( FT_Module    driver,    /* TT_Driver */
578                     const char*  tt_interface )
579   {
580     FT_Library           library;
581     FT_Module_Interface  result;
582     FT_Module            sfntd;
583     SFNT_Service         sfnt;
584 
585 
<a name="13" id="anc13"></a><span class="line-modified">586     result = ft_service_list_lookup( tt_services, tt_interface );</span>









587     if ( result )
588       return result;
589 
<a name="14" id="anc14"></a>
590     if ( !driver )
591       return NULL;
592     library = driver-&gt;library;
593     if ( !library )
594       return NULL;
<a name="15" id="anc15"></a>
595 
596     /* only return the default interface from the SFNT module */
597     sfntd = FT_Get_Module( library, &quot;sfnt&quot; );
598     if ( sfntd )
599     {
600       sfnt = (SFNT_Service)( sfntd-&gt;clazz-&gt;module_interface );
601       if ( sfnt )
602         return sfnt-&gt;get_interface( driver, tt_interface );
603     }
604 
605     return 0;
606   }
607 
608 
609   /* The FT_DriverInterface structure is defined in ftdriver.h. */
610 
611 #ifdef TT_USE_BYTECODE_INTERPRETER
612 #define TT_HINTER_FLAG  FT_MODULE_DRIVER_HAS_HINTER
613 #else
614 #define TT_HINTER_FLAG  0
615 #endif
616 
617 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
618 #define TT_SIZE_SELECT  tt_size_select
619 #else
620 #define TT_SIZE_SELECT  0
621 #endif
622 
623   FT_DEFINE_DRIVER(
624     tt_driver_class,
625 
626       FT_MODULE_FONT_DRIVER     |
627       FT_MODULE_DRIVER_SCALABLE |
628       TT_HINTER_FLAG,
629 
630       sizeof ( TT_DriverRec ),
631 
632       &quot;truetype&quot;,      /* driver name                           */
633       0x10000L,        /* driver version == 1.0                 */
634       0x20000L,        /* driver requires FreeType 2.0 or above */
635 
636       NULL,    /* module-specific interface */
637 
638       tt_driver_init,           /* FT_Module_Constructor  module_init   */
639       tt_driver_done,           /* FT_Module_Destructor   module_done   */
640       tt_get_interface,         /* FT_Module_Requester    get_interface */
641 
642     sizeof ( TT_FaceRec ),
643     sizeof ( TT_SizeRec ),
644     sizeof ( FT_GlyphSlotRec ),
645 
646     tt_face_init,               /* FT_Face_InitFunc  init_face */
647     tt_face_done,               /* FT_Face_DoneFunc  done_face */
648     tt_size_init,               /* FT_Size_InitFunc  init_size */
649     tt_size_done,               /* FT_Size_DoneFunc  done_size */
650     tt_slot_init,               /* FT_Slot_InitFunc  init_slot */
651     NULL,                       /* FT_Slot_DoneFunc  done_slot */
652 
653     tt_glyph_load,              /* FT_Slot_LoadFunc  load_glyph */
654 
655     tt_get_kerning,             /* FT_Face_GetKerningFunc   get_kerning  */
656     NULL,                       /* FT_Face_AttachFunc       attach_file  */
657     tt_get_advances,            /* FT_Face_GetAdvancesFunc  get_advances */
658 
659     tt_size_request,            /* FT_Size_RequestFunc  request_size */
660     TT_SIZE_SELECT              /* FT_Size_SelectFunc   select_size  */
661   )
662 
663 
664 /* END */
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftcalc.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftbitmap.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftcid.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftcalc.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ftcalc.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Arithmetic computations (body).                                      */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18   /*************************************************************************/</span>
<span class="line-modified">  19   /*                                                                       */</span>
<span class="line-modified">  20   /* Support for 1-complement arithmetic has been totally dropped in this  */</span>
<span class="line-modified">  21   /* release.  You can still write your own code if you need it.           */</span>
<span class="line-modified">  22   /*                                                                       */</span>
<span class="line-modified">  23   /*************************************************************************/</span>
<span class="line-modified">  24 </span>
<span class="line-modified">  25   /*************************************************************************/</span>
<span class="line-modified">  26   /*                                                                       */</span>
<span class="line-modified">  27   /* Implementing basic computation routines.                              */</span>
<span class="line-modified">  28   /*                                                                       */</span>
<span class="line-modified">  29   /* FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),   */</span>
<span class="line-modified">  30   /* and FT_FloorFix() are declared in freetype.h.                         */</span>
<span class="line-modified">  31   /*                                                                       */</span>
<span class="line-modified">  32   /*************************************************************************/</span>
  33 
  34 
  35 #include &lt;ft2build.h&gt;
  36 #include FT_GLYPH_H
  37 #include FT_TRIGONOMETRY_H
  38 #include FT_INTERNAL_CALC_H
  39 #include FT_INTERNAL_DEBUG_H
  40 #include FT_INTERNAL_OBJECTS_H
  41 
  42 
  43 #ifdef FT_MULFIX_ASSEMBLER
  44 #undef FT_MulFix
  45 #endif
  46 
  47 /* we need to emulate a 64-bit data type if a real one isn&#39;t available */
  48 
  49 #ifndef FT_LONG64
  50 
  51   typedef struct  FT_Int64_
  52   {
  53     FT_UInt32  lo;
  54     FT_UInt32  hi;
  55 
  56   } FT_Int64;
  57 
  58 #endif /* !FT_LONG64 */
  59 
  60 
<span class="line-modified">  61   /*************************************************************************/</span>
<span class="line-modified">  62   /*                                                                       */</span>
<span class="line-modified">  63   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  64   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  65   /* messages during execution.                                            */</span>
<span class="line-modified">  66   /*                                                                       */</span>
  67 #undef  FT_COMPONENT
<span class="line-modified">  68 #define FT_COMPONENT  trace_calc</span>
  69 
  70 
  71   /* transfer sign, leaving a positive number;                        */
  72   /* we need an unsigned value to safely negate INT_MIN (or LONG_MIN) */
  73 #define FT_MOVE_SIGN( x, x_unsigned, s ) \
  74   FT_BEGIN_STMNT                         \
  75     if ( x &lt; 0 )                         \
  76     {                                    \
  77       x_unsigned = 0U - (x_unsigned);    \
  78       s          = -s;                   \
  79     }                                    \
  80   FT_END_STMNT
  81 
  82   /* The following three functions are available regardless of whether */
  83   /* FT_LONG64 is defined.                                             */
  84 
  85   /* documentation is in freetype.h */
  86 
  87   FT_EXPORT_DEF( FT_Fixed )
  88   FT_RoundFix( FT_Fixed  a )
</pre>
<hr />
<pre>
 499 
 500     a_ = (FT_Long)a;
 501 
 502     return s &lt; 0 ? NEG_LONG( a_ ) : a_;
 503   }
 504 
 505 
 506   /* documentation is in freetype.h */
 507 
 508   FT_EXPORT_DEF( FT_Long )
 509   FT_MulFix( FT_Long  a_,
 510              FT_Long  b_ )
 511   {
 512 #ifdef FT_MULFIX_ASSEMBLER
 513 
 514     return FT_MULFIX_ASSEMBLER( a_, b_ );
 515 
 516 #elif 0
 517 
 518     /*
<span class="line-modified"> 519      *  This code is nonportable.  See comment below.</span>
 520      *
<span class="line-modified"> 521      *  However, on a platform where right-shift of a signed quantity fills</span>
<span class="line-modified"> 522      *  the leftmost bits by copying the sign bit, it might be faster.</span>
 523      */
 524 
 525     FT_Long    sa, sb;
 526     FT_UInt32  a, b;
 527 
 528 
 529     /*
<span class="line-modified"> 530      *  This is a clever way of converting a signed number `a&#39; into its</span>
<span class="line-modified"> 531      *  absolute value (stored back into `a&#39;) and its sign.  The sign is</span>
<span class="line-modified"> 532      *  stored in `sa&#39;; 0 means `a&#39; was positive or zero, and -1 means `a&#39;</span>
<span class="line-modified"> 533      *  was negative.  (Similarly for `b&#39; and `sb&#39;).</span>
 534      *
<span class="line-modified"> 535      *  Unfortunately, it doesn&#39;t work (at least not portably).</span>
 536      *
<span class="line-modified"> 537      *  It makes the assumption that right-shift on a negative signed value</span>
<span class="line-modified"> 538      *  fills the leftmost bits by copying the sign bit.  This is wrong.</span>
<span class="line-modified"> 539      *  According to K&amp;R 2nd ed, section `A7.8 Shift Operators&#39; on page 206,</span>
<span class="line-modified"> 540      *  the result of right-shift of a negative signed value is</span>
<span class="line-modified"> 541      *  implementation-defined.  At least one implementation fills the</span>
<span class="line-modified"> 542      *  leftmost bits with 0s (i.e., it is exactly the same as an unsigned</span>
<span class="line-modified"> 543      *  right shift).  This means that when `a&#39; is negative, `sa&#39; ends up</span>
<span class="line-modified"> 544      *  with the value 1 rather than -1.  After that, everything else goes</span>
<span class="line-modified"> 545      *  wrong.</span>
 546      */
 547     sa = ( a_ &gt;&gt; ( sizeof ( a_ ) * 8 - 1 ) );
 548     a  = ( a_ ^ sa ) - sa;
 549     sb = ( b_ &gt;&gt; ( sizeof ( b_ ) * 8 - 1 ) );
 550     b  = ( b_ ^ sb ) - sb;
 551 
 552     a = (FT_UInt32)a_;
 553     b = (FT_UInt32)b_;
 554 
 555     if ( a + ( b &gt;&gt; 8 ) &lt;= 8190UL )
 556       a = ( a * b + 0x8000U ) &gt;&gt; 16;
 557     else
 558     {
 559       FT_UInt32  al = a &amp; 0xFFFFUL;
 560 
 561 
 562       a = ( a &gt;&gt; 16 ) * b + al * ( b &gt;&gt; 16 ) +
 563           ( ( al * ( b &amp; 0xFFFFUL ) + 0x8000UL ) &gt;&gt; 16 );
 564     }
 565 
</pre>
<hr />
<pre>
 684 
 685 
 686   /* documentation is in ftglyph.h */
 687 
 688   FT_EXPORT_DEF( FT_Error )
 689   FT_Matrix_Invert( FT_Matrix*  matrix )
 690   {
 691     FT_Pos  delta, xx, yy;
 692 
 693 
 694     if ( !matrix )
 695       return FT_THROW( Invalid_Argument );
 696 
 697     /* compute discriminant */
 698     delta = FT_MulFix( matrix-&gt;xx, matrix-&gt;yy ) -
 699             FT_MulFix( matrix-&gt;xy, matrix-&gt;yx );
 700 
 701     if ( !delta )
 702       return FT_THROW( Invalid_Argument );  /* matrix can&#39;t be inverted */
 703 
<span class="line-modified"> 704     matrix-&gt;xy = - FT_DivFix( matrix-&gt;xy, delta );</span>
<span class="line-modified"> 705     matrix-&gt;yx = - FT_DivFix( matrix-&gt;yx, delta );</span>
 706 
 707     xx = matrix-&gt;xx;
 708     yy = matrix-&gt;yy;
 709 
 710     matrix-&gt;xx = FT_DivFix( yy, delta );
 711     matrix-&gt;yy = FT_DivFix( xx, delta );
 712 
 713     return FT_Err_Ok;
 714   }
 715 
 716 
 717   /* documentation is in ftcalc.h */
 718 
 719   FT_BASE_DEF( void )
 720   FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
 721                              FT_Matrix        *b,
 722                              FT_Long           scaling )
 723   {
 724     FT_Fixed  xx, xy, yx, yy;
 725 
</pre>
<hr />
<pre>
 728 
 729     if ( !a || !b )
 730       return;
 731 
 732     xx = ADD_LONG( FT_MulDiv( a-&gt;xx, b-&gt;xx, val ),
 733                    FT_MulDiv( a-&gt;xy, b-&gt;yx, val ) );
 734     xy = ADD_LONG( FT_MulDiv( a-&gt;xx, b-&gt;xy, val ),
 735                    FT_MulDiv( a-&gt;xy, b-&gt;yy, val ) );
 736     yx = ADD_LONG( FT_MulDiv( a-&gt;yx, b-&gt;xx, val ),
 737                    FT_MulDiv( a-&gt;yy, b-&gt;yx, val ) );
 738     yy = ADD_LONG( FT_MulDiv( a-&gt;yx, b-&gt;xy, val ),
 739                    FT_MulDiv( a-&gt;yy, b-&gt;yy, val ) );
 740 
 741     b-&gt;xx = xx;
 742     b-&gt;xy = xy;
 743     b-&gt;yx = yx;
 744     b-&gt;yy = yy;
 745   }
 746 
 747 






































































 748   /* documentation is in ftcalc.h */
 749 
 750   FT_BASE_DEF( void )
 751   FT_Vector_Transform_Scaled( FT_Vector*        vector,
 752                               const FT_Matrix*  matrix,
 753                               FT_Long           scaling )
 754   {
 755     FT_Pos   xz, yz;
 756 
 757     FT_Long  val = 0x10000L * scaling;
 758 
 759 
 760     if ( !vector || !matrix )
 761       return;
 762 
 763     xz = ADD_LONG( FT_MulDiv( vector-&gt;x, matrix-&gt;xx, val ),
 764                    FT_MulDiv( vector-&gt;y, matrix-&gt;xy, val ) );
 765     yz = ADD_LONG( FT_MulDiv( vector-&gt;x, matrix-&gt;yx, val ),
 766                    FT_MulDiv( vector-&gt;y, matrix-&gt;yy, val ) );
 767 
</pre>
<hr />
<pre>
 896           rem_hi -= test_div;
 897           root   += 1;
 898         }
 899       } while ( --count );
 900     }
 901 
 902     return (FT_Int32)root;
 903   }
 904 
 905 #endif /* 0 */
 906 
 907 
 908   /* documentation is in ftcalc.h */
 909 
 910   FT_BASE_DEF( FT_Int )
 911   ft_corner_orientation( FT_Pos  in_x,
 912                          FT_Pos  in_y,
 913                          FT_Pos  out_x,
 914                          FT_Pos  out_y )
 915   {



 916 #ifdef FT_LONG64
 917 
<span class="line-modified"> 918     FT_Int64  delta = (FT_Int64)in_x * out_y - (FT_Int64)in_y * out_x;</span>

 919 
 920 
 921     return ( delta &gt; 0 ) - ( delta &lt; 0 );
 922 
 923 #else
 924 
 925     FT_Int  result;
 926 
 927 
<span class="line-removed"> 928     /* we silently ignore overflow errors, since such large values */</span>
<span class="line-removed"> 929     /* lead to even more (harmless) rendering errors later on      */</span>
 930     if ( ADD_LONG( FT_ABS( in_x ), FT_ABS( out_y ) ) &lt;= 131071L &amp;&amp;
 931          ADD_LONG( FT_ABS( in_y ), FT_ABS( out_x ) ) &lt;= 131071L )
 932     {
 933       FT_Long  z1 = MUL_LONG( in_x, out_y );
 934       FT_Long  z2 = MUL_LONG( in_y, out_x );
 935 
 936 
 937       if ( z1 &gt; z2 )
 938         result = +1;
 939       else if ( z1 &lt; z2 )
 940         result = -1;
 941       else
 942         result = 0;
 943     }
 944     else /* products might overflow 32 bits */
 945     {
 946       FT_Int64  z1, z2;
 947 
 948 
 949       /* XXX: this function does not allow 64-bit arguments */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ftcalc.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Arithmetic computations (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18   /**************************************************************************</span>
<span class="line-modified">  19    *</span>
<span class="line-modified">  20    * Support for 1-complement arithmetic has been totally dropped in this</span>
<span class="line-modified">  21    * release.  You can still write your own code if you need it.</span>
<span class="line-modified">  22    *</span>
<span class="line-modified">  23    */</span>
<span class="line-modified">  24 </span>
<span class="line-modified">  25   /**************************************************************************</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * Implementing basic computation routines.</span>
<span class="line-modified">  28    *</span>
<span class="line-modified">  29    * FT_MulDiv(), FT_MulFix(), FT_DivFix(), FT_RoundFix(), FT_CeilFix(),</span>
<span class="line-modified">  30    * and FT_FloorFix() are declared in freetype.h.</span>
<span class="line-modified">  31    *</span>
<span class="line-modified">  32    */</span>
  33 
  34 
  35 #include &lt;ft2build.h&gt;
  36 #include FT_GLYPH_H
  37 #include FT_TRIGONOMETRY_H
  38 #include FT_INTERNAL_CALC_H
  39 #include FT_INTERNAL_DEBUG_H
  40 #include FT_INTERNAL_OBJECTS_H
  41 
  42 
  43 #ifdef FT_MULFIX_ASSEMBLER
  44 #undef FT_MulFix
  45 #endif
  46 
  47 /* we need to emulate a 64-bit data type if a real one isn&#39;t available */
  48 
  49 #ifndef FT_LONG64
  50 
  51   typedef struct  FT_Int64_
  52   {
  53     FT_UInt32  lo;
  54     FT_UInt32  hi;
  55 
  56   } FT_Int64;
  57 
  58 #endif /* !FT_LONG64 */
  59 
  60 
<span class="line-modified">  61   /**************************************************************************</span>
<span class="line-modified">  62    *</span>
<span class="line-modified">  63    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  64    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  65    * messages during execution.</span>
<span class="line-modified">  66    */</span>
  67 #undef  FT_COMPONENT
<span class="line-modified">  68 #define FT_COMPONENT  calc</span>
  69 
  70 
  71   /* transfer sign, leaving a positive number;                        */
  72   /* we need an unsigned value to safely negate INT_MIN (or LONG_MIN) */
  73 #define FT_MOVE_SIGN( x, x_unsigned, s ) \
  74   FT_BEGIN_STMNT                         \
  75     if ( x &lt; 0 )                         \
  76     {                                    \
  77       x_unsigned = 0U - (x_unsigned);    \
  78       s          = -s;                   \
  79     }                                    \
  80   FT_END_STMNT
  81 
  82   /* The following three functions are available regardless of whether */
  83   /* FT_LONG64 is defined.                                             */
  84 
  85   /* documentation is in freetype.h */
  86 
  87   FT_EXPORT_DEF( FT_Fixed )
  88   FT_RoundFix( FT_Fixed  a )
</pre>
<hr />
<pre>
 499 
 500     a_ = (FT_Long)a;
 501 
 502     return s &lt; 0 ? NEG_LONG( a_ ) : a_;
 503   }
 504 
 505 
 506   /* documentation is in freetype.h */
 507 
 508   FT_EXPORT_DEF( FT_Long )
 509   FT_MulFix( FT_Long  a_,
 510              FT_Long  b_ )
 511   {
 512 #ifdef FT_MULFIX_ASSEMBLER
 513 
 514     return FT_MULFIX_ASSEMBLER( a_, b_ );
 515 
 516 #elif 0
 517 
 518     /*
<span class="line-modified"> 519      * This code is nonportable.  See comment below.</span>
 520      *
<span class="line-modified"> 521      * However, on a platform where right-shift of a signed quantity fills</span>
<span class="line-modified"> 522      * the leftmost bits by copying the sign bit, it might be faster.</span>
 523      */
 524 
 525     FT_Long    sa, sb;
 526     FT_UInt32  a, b;
 527 
 528 
 529     /*
<span class="line-modified"> 530      * This is a clever way of converting a signed number `a&#39; into its</span>
<span class="line-modified"> 531      * absolute value (stored back into `a&#39;) and its sign.  The sign is</span>
<span class="line-modified"> 532      * stored in `sa&#39;; 0 means `a&#39; was positive or zero, and -1 means `a&#39;</span>
<span class="line-modified"> 533      * was negative.  (Similarly for `b&#39; and `sb&#39;).</span>
 534      *
<span class="line-modified"> 535      * Unfortunately, it doesn&#39;t work (at least not portably).</span>
 536      *
<span class="line-modified"> 537      * It makes the assumption that right-shift on a negative signed value</span>
<span class="line-modified"> 538      * fills the leftmost bits by copying the sign bit.  This is wrong.</span>
<span class="line-modified"> 539      * According to K&amp;R 2nd ed, section `A7.8 Shift Operators&#39; on page 206,</span>
<span class="line-modified"> 540      * the result of right-shift of a negative signed value is</span>
<span class="line-modified"> 541      * implementation-defined.  At least one implementation fills the</span>
<span class="line-modified"> 542      * leftmost bits with 0s (i.e., it is exactly the same as an unsigned</span>
<span class="line-modified"> 543      * right shift).  This means that when `a&#39; is negative, `sa&#39; ends up</span>
<span class="line-modified"> 544      * with the value 1 rather than -1.  After that, everything else goes</span>
<span class="line-modified"> 545      * wrong.</span>
 546      */
 547     sa = ( a_ &gt;&gt; ( sizeof ( a_ ) * 8 - 1 ) );
 548     a  = ( a_ ^ sa ) - sa;
 549     sb = ( b_ &gt;&gt; ( sizeof ( b_ ) * 8 - 1 ) );
 550     b  = ( b_ ^ sb ) - sb;
 551 
 552     a = (FT_UInt32)a_;
 553     b = (FT_UInt32)b_;
 554 
 555     if ( a + ( b &gt;&gt; 8 ) &lt;= 8190UL )
 556       a = ( a * b + 0x8000U ) &gt;&gt; 16;
 557     else
 558     {
 559       FT_UInt32  al = a &amp; 0xFFFFUL;
 560 
 561 
 562       a = ( a &gt;&gt; 16 ) * b + al * ( b &gt;&gt; 16 ) +
 563           ( ( al * ( b &amp; 0xFFFFUL ) + 0x8000UL ) &gt;&gt; 16 );
 564     }
 565 
</pre>
<hr />
<pre>
 684 
 685 
 686   /* documentation is in ftglyph.h */
 687 
 688   FT_EXPORT_DEF( FT_Error )
 689   FT_Matrix_Invert( FT_Matrix*  matrix )
 690   {
 691     FT_Pos  delta, xx, yy;
 692 
 693 
 694     if ( !matrix )
 695       return FT_THROW( Invalid_Argument );
 696 
 697     /* compute discriminant */
 698     delta = FT_MulFix( matrix-&gt;xx, matrix-&gt;yy ) -
 699             FT_MulFix( matrix-&gt;xy, matrix-&gt;yx );
 700 
 701     if ( !delta )
 702       return FT_THROW( Invalid_Argument );  /* matrix can&#39;t be inverted */
 703 
<span class="line-modified"> 704     matrix-&gt;xy = -FT_DivFix( matrix-&gt;xy, delta );</span>
<span class="line-modified"> 705     matrix-&gt;yx = -FT_DivFix( matrix-&gt;yx, delta );</span>
 706 
 707     xx = matrix-&gt;xx;
 708     yy = matrix-&gt;yy;
 709 
 710     matrix-&gt;xx = FT_DivFix( yy, delta );
 711     matrix-&gt;yy = FT_DivFix( xx, delta );
 712 
 713     return FT_Err_Ok;
 714   }
 715 
 716 
 717   /* documentation is in ftcalc.h */
 718 
 719   FT_BASE_DEF( void )
 720   FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
 721                              FT_Matrix        *b,
 722                              FT_Long           scaling )
 723   {
 724     FT_Fixed  xx, xy, yx, yy;
 725 
</pre>
<hr />
<pre>
 728 
 729     if ( !a || !b )
 730       return;
 731 
 732     xx = ADD_LONG( FT_MulDiv( a-&gt;xx, b-&gt;xx, val ),
 733                    FT_MulDiv( a-&gt;xy, b-&gt;yx, val ) );
 734     xy = ADD_LONG( FT_MulDiv( a-&gt;xx, b-&gt;xy, val ),
 735                    FT_MulDiv( a-&gt;xy, b-&gt;yy, val ) );
 736     yx = ADD_LONG( FT_MulDiv( a-&gt;yx, b-&gt;xx, val ),
 737                    FT_MulDiv( a-&gt;yy, b-&gt;yx, val ) );
 738     yy = ADD_LONG( FT_MulDiv( a-&gt;yx, b-&gt;xy, val ),
 739                    FT_MulDiv( a-&gt;yy, b-&gt;yy, val ) );
 740 
 741     b-&gt;xx = xx;
 742     b-&gt;xy = xy;
 743     b-&gt;yx = yx;
 744     b-&gt;yy = yy;
 745   }
 746 
 747 
<span class="line-added"> 748   /* documentation is in ftcalc.h */</span>
<span class="line-added"> 749 </span>
<span class="line-added"> 750   FT_BASE_DEF( FT_Bool )</span>
<span class="line-added"> 751   FT_Matrix_Check( const FT_Matrix*  matrix )</span>
<span class="line-added"> 752   {</span>
<span class="line-added"> 753     FT_Matrix  m;</span>
<span class="line-added"> 754     FT_Fixed   val[4];</span>
<span class="line-added"> 755     FT_Fixed   nonzero_minval, maxval;</span>
<span class="line-added"> 756     FT_Fixed   temp1, temp2;</span>
<span class="line-added"> 757     FT_UInt    i;</span>
<span class="line-added"> 758 </span>
<span class="line-added"> 759 </span>
<span class="line-added"> 760     if ( !matrix )</span>
<span class="line-added"> 761       return 0;</span>
<span class="line-added"> 762 </span>
<span class="line-added"> 763     val[0] = FT_ABS( matrix-&gt;xx );</span>
<span class="line-added"> 764     val[1] = FT_ABS( matrix-&gt;xy );</span>
<span class="line-added"> 765     val[2] = FT_ABS( matrix-&gt;yx );</span>
<span class="line-added"> 766     val[3] = FT_ABS( matrix-&gt;yy );</span>
<span class="line-added"> 767 </span>
<span class="line-added"> 768     /*</span>
<span class="line-added"> 769      * To avoid overflow, we ensure that each value is not larger than</span>
<span class="line-added"> 770      *</span>
<span class="line-added"> 771      *   int(sqrt(2^31 / 4)) = 23170  ;</span>
<span class="line-added"> 772      *</span>
<span class="line-added"> 773      * we also check that no value becomes zero if we have to scale.</span>
<span class="line-added"> 774      */</span>
<span class="line-added"> 775 </span>
<span class="line-added"> 776     maxval         = 0;</span>
<span class="line-added"> 777     nonzero_minval = FT_LONG_MAX;</span>
<span class="line-added"> 778 </span>
<span class="line-added"> 779     for ( i = 0; i &lt; 4; i++ )</span>
<span class="line-added"> 780     {</span>
<span class="line-added"> 781       if ( val[i] &gt; maxval )</span>
<span class="line-added"> 782         maxval = val[i];</span>
<span class="line-added"> 783       if ( val[i] &amp;&amp; val[i] &lt; nonzero_minval )</span>
<span class="line-added"> 784         nonzero_minval = val[i];</span>
<span class="line-added"> 785     }</span>
<span class="line-added"> 786 </span>
<span class="line-added"> 787     /* we only handle 32bit values */</span>
<span class="line-added"> 788     if ( maxval &gt; 0x7FFFFFFFL )</span>
<span class="line-added"> 789       return 0;</span>
<span class="line-added"> 790 </span>
<span class="line-added"> 791     if ( maxval &gt; 23170 )</span>
<span class="line-added"> 792     {</span>
<span class="line-added"> 793       FT_Fixed  scale = FT_DivFix( maxval, 23170 );</span>
<span class="line-added"> 794 </span>
<span class="line-added"> 795 </span>
<span class="line-added"> 796       if ( !FT_DivFix( nonzero_minval, scale ) )</span>
<span class="line-added"> 797         return 0;    /* value range too large */</span>
<span class="line-added"> 798 </span>
<span class="line-added"> 799       m.xx = FT_DivFix( matrix-&gt;xx, scale );</span>
<span class="line-added"> 800       m.xy = FT_DivFix( matrix-&gt;xy, scale );</span>
<span class="line-added"> 801       m.yx = FT_DivFix( matrix-&gt;yx, scale );</span>
<span class="line-added"> 802       m.yy = FT_DivFix( matrix-&gt;yy, scale );</span>
<span class="line-added"> 803     }</span>
<span class="line-added"> 804     else</span>
<span class="line-added"> 805       m = *matrix;</span>
<span class="line-added"> 806 </span>
<span class="line-added"> 807     temp1 = FT_ABS( m.xx * m.yy - m.xy * m.yx );</span>
<span class="line-added"> 808     temp2 = m.xx * m.xx + m.xy * m.xy + m.yx * m.yx + m.yy * m.yy;</span>
<span class="line-added"> 809 </span>
<span class="line-added"> 810     if ( temp1 == 0         ||</span>
<span class="line-added"> 811          temp2 / temp1 &gt; 50 )</span>
<span class="line-added"> 812       return 0;</span>
<span class="line-added"> 813 </span>
<span class="line-added"> 814     return 1;</span>
<span class="line-added"> 815   }</span>
<span class="line-added"> 816 </span>
<span class="line-added"> 817 </span>
 818   /* documentation is in ftcalc.h */
 819 
 820   FT_BASE_DEF( void )
 821   FT_Vector_Transform_Scaled( FT_Vector*        vector,
 822                               const FT_Matrix*  matrix,
 823                               FT_Long           scaling )
 824   {
 825     FT_Pos   xz, yz;
 826 
 827     FT_Long  val = 0x10000L * scaling;
 828 
 829 
 830     if ( !vector || !matrix )
 831       return;
 832 
 833     xz = ADD_LONG( FT_MulDiv( vector-&gt;x, matrix-&gt;xx, val ),
 834                    FT_MulDiv( vector-&gt;y, matrix-&gt;xy, val ) );
 835     yz = ADD_LONG( FT_MulDiv( vector-&gt;x, matrix-&gt;yx, val ),
 836                    FT_MulDiv( vector-&gt;y, matrix-&gt;yy, val ) );
 837 
</pre>
<hr />
<pre>
 966           rem_hi -= test_div;
 967           root   += 1;
 968         }
 969       } while ( --count );
 970     }
 971 
 972     return (FT_Int32)root;
 973   }
 974 
 975 #endif /* 0 */
 976 
 977 
 978   /* documentation is in ftcalc.h */
 979 
 980   FT_BASE_DEF( FT_Int )
 981   ft_corner_orientation( FT_Pos  in_x,
 982                          FT_Pos  in_y,
 983                          FT_Pos  out_x,
 984                          FT_Pos  out_y )
 985   {
<span class="line-added"> 986     /* we silently ignore overflow errors since such large values */</span>
<span class="line-added"> 987     /* lead to even more (harmless) rendering errors later on     */</span>
<span class="line-added"> 988 </span>
 989 #ifdef FT_LONG64
 990 
<span class="line-modified"> 991     FT_Int64  delta = SUB_INT64( MUL_INT64( in_x, out_y ),</span>
<span class="line-added"> 992                                  MUL_INT64( in_y, out_x ) );</span>
 993 
 994 
 995     return ( delta &gt; 0 ) - ( delta &lt; 0 );
 996 
 997 #else
 998 
 999     FT_Int  result;
1000 
1001 


1002     if ( ADD_LONG( FT_ABS( in_x ), FT_ABS( out_y ) ) &lt;= 131071L &amp;&amp;
1003          ADD_LONG( FT_ABS( in_y ), FT_ABS( out_x ) ) &lt;= 131071L )
1004     {
1005       FT_Long  z1 = MUL_LONG( in_x, out_y );
1006       FT_Long  z2 = MUL_LONG( in_y, out_x );
1007 
1008 
1009       if ( z1 &gt; z2 )
1010         result = +1;
1011       else if ( z1 &lt; z2 )
1012         result = -1;
1013       else
1014         result = 0;
1015     }
1016     else /* products might overflow 32 bits */
1017     {
1018       FT_Int64  z1, z2;
1019 
1020 
1021       /* XXX: this function does not allow 64-bit arguments */
</pre>
</td>
</tr>
</table>
<center><a href="ftbitmap.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftcid.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
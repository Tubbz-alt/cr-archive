<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/include/freetype/internal/psaux.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /****************************************************************************
   2  *
   3  * psaux.h
   4  *
   5  *   Auxiliary functions and data structures related to PostScript fonts
   6  *   (specification).
   7  *
   8  * Copyright (C) 1996-2019 by
   9  * David Turner, Robert Wilhelm, and Werner Lemberg.
  10  *
  11  * This file is part of the FreeType project, and may only be used,
  12  * modified, and distributed under the terms of the FreeType project
  13  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
  14  * this file you indicate that you have read the license and
  15  * understand and accept it fully.
  16  *
  17  */
  18 
  19 
  20 #ifndef PSAUX_H_
  21 #define PSAUX_H_
  22 
  23 
  24 #include &lt;ft2build.h&gt;
  25 #include FT_INTERNAL_OBJECTS_H
  26 #include FT_INTERNAL_TYPE1_TYPES_H
  27 #include FT_INTERNAL_HASH_H
  28 #include FT_INTERNAL_TRUETYPE_TYPES_H
  29 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  30 #include FT_INTERNAL_CFF_TYPES_H
  31 #include FT_INTERNAL_CFF_OBJECTS_TYPES_H
  32 
  33 
  34 
  35 FT_BEGIN_HEADER
  36 
  37 
  38   /**************************************************************************
  39    *
  40    * PostScript modules driver class.
  41    */
  42   typedef struct  PS_DriverRec_
  43   {
  44     FT_DriverRec  root;
  45 
  46     FT_UInt   hinting_engine;
  47     FT_Bool   no_stem_darkening;
  48     FT_Int    darken_params[8];
  49     FT_Int32  random_seed;
  50 
  51   } PS_DriverRec, *PS_Driver;
  52 
  53 
  54   /*************************************************************************/
  55   /*************************************************************************/
  56   /*****                                                               *****/
  57   /*****                             T1_TABLE                          *****/
  58   /*****                                                               *****/
  59   /*************************************************************************/
  60   /*************************************************************************/
  61 
  62 
  63   typedef struct PS_TableRec_*              PS_Table;
  64   typedef const struct PS_Table_FuncsRec_*  PS_Table_Funcs;
  65 
  66 
  67   /**************************************************************************
  68    *
  69    * @struct:
  70    *   PS_Table_FuncsRec
  71    *
  72    * @description:
  73    *   A set of function pointers to manage PS_Table objects.
  74    *
  75    * @fields:
  76    *   table_init ::
  77    *     Used to initialize a table.
  78    *
  79    *   table_done ::
  80    *     Finalizes resp. destroy a given table.
  81    *
  82    *   table_add ::
  83    *     Adds a new object to a table.
  84    *
  85    *   table_release ::
  86    *     Releases table data, then finalizes it.
  87    */
  88   typedef struct  PS_Table_FuncsRec_
  89   {
  90     FT_Error
  91     (*init)( PS_Table   table,
  92              FT_Int     count,
  93              FT_Memory  memory );
  94 
  95     void
  96     (*done)( PS_Table  table );
  97 
  98     FT_Error
  99     (*add)( PS_Table     table,
 100             FT_Int       idx,
 101             const void*  object,
 102             FT_UInt      length );
 103 
 104     void
 105     (*release)( PS_Table  table );
 106 
 107   } PS_Table_FuncsRec;
 108 
 109 
 110   /**************************************************************************
 111    *
 112    * @struct:
 113    *   PS_TableRec
 114    *
 115    * @description:
 116    *   A PS_Table is a simple object used to store an array of objects in a
 117    *   single memory block.
 118    *
 119    * @fields:
 120    *   block ::
 121    *     The address in memory of the growheap&#39;s block.  This can change
 122    *     between two object adds, due to reallocation.
 123    *
 124    *   cursor ::
 125    *     The current top of the grow heap within its block.
 126    *
 127    *   capacity ::
 128    *     The current size of the heap block.  Increments by 1kByte chunks.
 129    *
 130    *   init ::
 131    *     Set to 0xDEADBEEF if &#39;elements&#39; and &#39;lengths&#39; have been allocated.
 132    *
 133    *   max_elems ::
 134    *     The maximum number of elements in table.
 135    *
 136    *   num_elems ::
 137    *     The current number of elements in table.
 138    *
 139    *   elements ::
 140    *     A table of element addresses within the block.
 141    *
 142    *   lengths ::
 143    *     A table of element sizes within the block.
 144    *
 145    *   memory ::
 146    *     The object used for memory operations (alloc/realloc).
 147    *
 148    *   funcs ::
 149    *     A table of method pointers for this object.
 150    */
 151   typedef struct  PS_TableRec_
 152   {
 153     FT_Byte*           block;          /* current memory block           */
 154     FT_Offset          cursor;         /* current cursor in memory block */
 155     FT_Offset          capacity;       /* current size of memory block   */
 156     FT_ULong           init;
 157 
 158     FT_Int             max_elems;
 159     FT_Int             num_elems;
 160     FT_Byte**          elements;       /* addresses of table elements */
 161     FT_UInt*           lengths;        /* lengths of table elements   */
 162 
 163     FT_Memory          memory;
 164     PS_Table_FuncsRec  funcs;
 165 
 166   } PS_TableRec;
 167 
 168 
 169   /*************************************************************************/
 170   /*************************************************************************/
 171   /*****                                                               *****/
 172   /*****                       T1 FIELDS &amp; TOKENS                      *****/
 173   /*****                                                               *****/
 174   /*************************************************************************/
 175   /*************************************************************************/
 176 
 177   typedef struct PS_ParserRec_*  PS_Parser;
 178 
 179   typedef struct T1_TokenRec_*   T1_Token;
 180 
 181   typedef struct T1_FieldRec_*   T1_Field;
 182 
 183 
 184   /* simple enumeration type used to identify token types */
 185   typedef enum  T1_TokenType_
 186   {
 187     T1_TOKEN_TYPE_NONE = 0,
 188     T1_TOKEN_TYPE_ANY,
 189     T1_TOKEN_TYPE_STRING,
 190     T1_TOKEN_TYPE_ARRAY,
 191     T1_TOKEN_TYPE_KEY, /* aka `name&#39; */
 192 
 193     /* do not remove */
 194     T1_TOKEN_TYPE_MAX
 195 
 196   } T1_TokenType;
 197 
 198 
 199   /* a simple structure used to identify tokens */
 200   typedef struct  T1_TokenRec_
 201   {
 202     FT_Byte*      start;   /* first character of token in input stream */
 203     FT_Byte*      limit;   /* first character after the token          */
 204     T1_TokenType  type;    /* type of token                            */
 205 
 206   } T1_TokenRec;
 207 
 208 
 209   /* enumeration type used to identify object fields */
 210   typedef enum  T1_FieldType_
 211   {
 212     T1_FIELD_TYPE_NONE = 0,
 213     T1_FIELD_TYPE_BOOL,
 214     T1_FIELD_TYPE_INTEGER,
 215     T1_FIELD_TYPE_FIXED,
 216     T1_FIELD_TYPE_FIXED_1000,
 217     T1_FIELD_TYPE_STRING,
 218     T1_FIELD_TYPE_KEY,
 219     T1_FIELD_TYPE_BBOX,
 220     T1_FIELD_TYPE_MM_BBOX,
 221     T1_FIELD_TYPE_INTEGER_ARRAY,
 222     T1_FIELD_TYPE_FIXED_ARRAY,
 223     T1_FIELD_TYPE_CALLBACK,
 224 
 225     /* do not remove */
 226     T1_FIELD_TYPE_MAX
 227 
 228   } T1_FieldType;
 229 
 230 
 231   typedef enum  T1_FieldLocation_
 232   {
 233     T1_FIELD_LOCATION_CID_INFO,
 234     T1_FIELD_LOCATION_FONT_DICT,
 235     T1_FIELD_LOCATION_FONT_EXTRA,
 236     T1_FIELD_LOCATION_FONT_INFO,
 237     T1_FIELD_LOCATION_PRIVATE,
 238     T1_FIELD_LOCATION_BBOX,
 239     T1_FIELD_LOCATION_LOADER,
 240     T1_FIELD_LOCATION_FACE,
 241     T1_FIELD_LOCATION_BLEND,
 242 
 243     /* do not remove */
 244     T1_FIELD_LOCATION_MAX
 245 
 246   } T1_FieldLocation;
 247 
 248 
 249   typedef void
 250   (*T1_Field_ParseFunc)( FT_Face     face,
 251                          FT_Pointer  parser );
 252 
 253 
 254   /* structure type used to model object fields */
 255   typedef struct  T1_FieldRec_
 256   {
 257     const char*         ident;        /* field identifier               */
 258     T1_FieldLocation    location;
 259     T1_FieldType        type;         /* type of field                  */
 260     T1_Field_ParseFunc  reader;
 261     FT_UInt             offset;       /* offset of field in object      */
 262     FT_Byte             size;         /* size of field in bytes         */
 263     FT_UInt             array_max;    /* maximum number of elements for */
 264                                       /* array                          */
 265     FT_UInt             count_offset; /* offset of element count for    */
 266                                       /* arrays; must not be zero if in */
 267                                       /* use -- in other words, a       */
 268                                       /* `num_FOO&#39; element must not     */
 269                                       /* start the used structure if we */
 270                                       /* parse a `FOO&#39; array            */
 271     FT_UInt             dict;         /* where we expect it             */
 272   } T1_FieldRec;
 273 
 274 #define T1_FIELD_DICT_FONTDICT ( 1 &lt;&lt; 0 ) /* also FontInfo and FDArray */
 275 #define T1_FIELD_DICT_PRIVATE  ( 1 &lt;&lt; 1 )
 276 
 277 
 278 
 279 #define T1_NEW_SIMPLE_FIELD( _ident, _type, _fname, _dict ) \
 280           {                                                 \
 281             _ident, T1CODE, _type,                          \
 282             0,                                              \
 283             FT_FIELD_OFFSET( _fname ),                      \
 284             FT_FIELD_SIZE( _fname ),                        \
 285             0, 0,                                           \
 286             _dict                                           \
 287           },
 288 
 289 #define T1_NEW_CALLBACK_FIELD( _ident, _reader, _dict ) \
 290           {                                             \
 291             _ident, T1CODE, T1_FIELD_TYPE_CALLBACK,     \
 292             (T1_Field_ParseFunc)_reader,                \
 293             0, 0,                                       \
 294             0, 0,                                       \
 295             _dict                                       \
 296           },
 297 
 298 #define T1_NEW_TABLE_FIELD( _ident, _type, _fname, _max, _dict ) \
 299           {                                                      \
 300             _ident, T1CODE, _type,                               \
 301             0,                                                   \
 302             FT_FIELD_OFFSET( _fname ),                           \
 303             FT_FIELD_SIZE_DELTA( _fname ),                       \
 304             _max,                                                \
 305             FT_FIELD_OFFSET( num_ ## _fname ),                   \
 306             _dict                                                \
 307           },
 308 
 309 #define T1_NEW_TABLE_FIELD2( _ident, _type, _fname, _max, _dict ) \
 310           {                                                       \
 311             _ident, T1CODE, _type,                                \
 312             0,                                                    \
 313             FT_FIELD_OFFSET( _fname ),                            \
 314             FT_FIELD_SIZE_DELTA( _fname ),                        \
 315             _max, 0,                                              \
 316             _dict                                                 \
 317           },
 318 
 319 
 320 #define T1_FIELD_BOOL( _ident, _fname, _dict )                             \
 321           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BOOL, _fname, _dict )
 322 
 323 #define T1_FIELD_NUM( _ident, _fname, _dict )                                 \
 324           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER, _fname, _dict )
 325 
 326 #define T1_FIELD_FIXED( _ident, _fname, _dict )                             \
 327           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED, _fname, _dict )
 328 
 329 #define T1_FIELD_FIXED_1000( _ident, _fname, _dict )                     \
 330           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_1000, _fname, \
 331                                _dict )
 332 
 333 #define T1_FIELD_STRING( _ident, _fname, _dict )                             \
 334           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_STRING, _fname, _dict )
 335 
 336 #define T1_FIELD_KEY( _ident, _fname, _dict )                             \
 337           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_KEY, _fname, _dict )
 338 
 339 #define T1_FIELD_BBOX( _ident, _fname, _dict )                             \
 340           T1_NEW_SIMPLE_FIELD( _ident, T1_FIELD_TYPE_BBOX, _fname, _dict )
 341 
 342 
 343 #define T1_FIELD_NUM_TABLE( _ident, _fname, _fmax, _dict )         \
 344           T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
 345                               _fname, _fmax, _dict )
 346 
 347 #define T1_FIELD_FIXED_TABLE( _ident, _fname, _fmax, _dict )     \
 348           T1_NEW_TABLE_FIELD( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
 349                               _fname, _fmax, _dict )
 350 
 351 #define T1_FIELD_NUM_TABLE2( _ident, _fname, _fmax, _dict )         \
 352           T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_INTEGER_ARRAY, \
 353                                _fname, _fmax, _dict )
 354 
 355 #define T1_FIELD_FIXED_TABLE2( _ident, _fname, _fmax, _dict )     \
 356           T1_NEW_TABLE_FIELD2( _ident, T1_FIELD_TYPE_FIXED_ARRAY, \
 357                                _fname, _fmax, _dict )
 358 
 359 #define T1_FIELD_CALLBACK( _ident, _name, _dict )       \
 360           T1_NEW_CALLBACK_FIELD( _ident, _name, _dict )
 361 
 362 
 363   /*************************************************************************/
 364   /*************************************************************************/
 365   /*****                                                               *****/
 366   /*****                            T1 PARSER                          *****/
 367   /*****                                                               *****/
 368   /*************************************************************************/
 369   /*************************************************************************/
 370 
 371   typedef const struct PS_Parser_FuncsRec_*  PS_Parser_Funcs;
 372 
 373   typedef struct  PS_Parser_FuncsRec_
 374   {
 375     void
 376     (*init)( PS_Parser  parser,
 377              FT_Byte*   base,
 378              FT_Byte*   limit,
 379              FT_Memory  memory );
 380 
 381     void
 382     (*done)( PS_Parser  parser );
 383 
 384     void
 385     (*skip_spaces)( PS_Parser  parser );
 386     void
 387     (*skip_PS_token)( PS_Parser  parser );
 388 
 389     FT_Long
 390     (*to_int)( PS_Parser  parser );
 391     FT_Fixed
 392     (*to_fixed)( PS_Parser  parser,
 393                  FT_Int     power_ten );
 394 
 395     FT_Error
 396     (*to_bytes)( PS_Parser  parser,
 397                  FT_Byte*   bytes,
 398                  FT_Offset  max_bytes,
 399                  FT_ULong*  pnum_bytes,
 400                  FT_Bool    delimiters );
 401 
 402     FT_Int
 403     (*to_coord_array)( PS_Parser  parser,
 404                        FT_Int     max_coords,
 405                        FT_Short*  coords );
 406     FT_Int
 407     (*to_fixed_array)( PS_Parser  parser,
 408                        FT_Int     max_values,
 409                        FT_Fixed*  values,
 410                        FT_Int     power_ten );
 411 
 412     void
 413     (*to_token)( PS_Parser  parser,
 414                  T1_Token   token );
 415     void
 416     (*to_token_array)( PS_Parser  parser,
 417                        T1_Token   tokens,
 418                        FT_UInt    max_tokens,
 419                        FT_Int*    pnum_tokens );
 420 
 421     FT_Error
 422     (*load_field)( PS_Parser       parser,
 423                    const T1_Field  field,
 424                    void**          objects,
 425                    FT_UInt         max_objects,
 426                    FT_ULong*       pflags );
 427 
 428     FT_Error
 429     (*load_field_table)( PS_Parser       parser,
 430                          const T1_Field  field,
 431                          void**          objects,
 432                          FT_UInt         max_objects,
 433                          FT_ULong*       pflags );
 434 
 435   } PS_Parser_FuncsRec;
 436 
 437 
 438   /**************************************************************************
 439    *
 440    * @struct:
 441    *   PS_ParserRec
 442    *
 443    * @description:
 444    *   A PS_Parser is an object used to parse a Type 1 font very quickly.
 445    *
 446    * @fields:
 447    *   cursor ::
 448    *     The current position in the text.
 449    *
 450    *   base ::
 451    *     Start of the processed text.
 452    *
 453    *   limit ::
 454    *     End of the processed text.
 455    *
 456    *   error ::
 457    *     The last error returned.
 458    *
 459    *   memory ::
 460    *     The object used for memory operations (alloc/realloc).
 461    *
 462    *   funcs ::
 463    *     A table of functions for the parser.
 464    */
 465   typedef struct  PS_ParserRec_
 466   {
 467     FT_Byte*   cursor;
 468     FT_Byte*   base;
 469     FT_Byte*   limit;
 470     FT_Error   error;
 471     FT_Memory  memory;
 472 
 473     PS_Parser_FuncsRec  funcs;
 474 
 475   } PS_ParserRec;
 476 
 477 
 478   /*************************************************************************/
 479   /*************************************************************************/
 480   /*****                                                               *****/
 481   /*****                         PS BUILDER                            *****/
 482   /*****                                                               *****/
 483   /*************************************************************************/
 484   /*************************************************************************/
 485 
 486 
 487   typedef struct PS_Builder_  PS_Builder;
 488   typedef const struct PS_Builder_FuncsRec_*  PS_Builder_Funcs;
 489 
 490   typedef struct  PS_Builder_FuncsRec_
 491   {
 492     void
 493     (*init)( PS_Builder*  ps_builder,
 494              void*        builder,
 495              FT_Bool      is_t1 );
 496 
 497     void
 498     (*done)( PS_Builder*  builder );
 499 
 500   } PS_Builder_FuncsRec;
 501 
 502 
 503   /**************************************************************************
 504    *
 505    * @struct:
 506    *   PS_Builder
 507    *
 508    * @description:
 509    *    A structure used during glyph loading to store its outline.
 510    *
 511    * @fields:
 512    *   memory ::
 513    *     The current memory object.
 514    *
 515    *   face ::
 516    *     The current face object.
 517    *
 518    *   glyph ::
 519    *     The current glyph slot.
 520    *
 521    *   loader ::
 522    *     XXX
 523    *
 524    *   base ::
 525    *     The base glyph outline.
 526    *
 527    *   current ::
 528    *     The current glyph outline.
 529    *
 530    *   pos_x ::
 531    *     The horizontal translation (if composite glyph).
 532    *
 533    *   pos_y ::
 534    *     The vertical translation (if composite glyph).
 535    *
 536    *   left_bearing ::
 537    *     The left side bearing point.
 538    *
 539    *   advance ::
 540    *     The horizontal advance vector.
 541    *
 542    *   bbox ::
 543    *     Unused.
 544    *
 545    *   path_begun ::
 546    *     A flag which indicates that a new path has begun.
 547    *
 548    *   load_points ::
 549    *     If this flag is not set, no points are loaded.
 550    *
 551    *   no_recurse ::
 552    *     Set but not used.
 553    *
 554    *   metrics_only ::
 555    *     A boolean indicating that we only want to compute the metrics of a
 556    *     given glyph, not load all of its points.
 557    *
 558    *   is_t1 ::
 559    *     Set if current font type is Type 1.
 560    *
 561    *   funcs ::
 562    *     An array of function pointers for the builder.
 563    */
 564   struct  PS_Builder_
 565   {
 566     FT_Memory       memory;
 567     FT_Face         face;
 568     CFF_GlyphSlot   glyph;
 569     FT_GlyphLoader  loader;
 570     FT_Outline*     base;
 571     FT_Outline*     current;
 572 
 573     FT_Pos*  pos_x;
 574     FT_Pos*  pos_y;
 575 
 576     FT_Vector*  left_bearing;
 577     FT_Vector*  advance;
 578 
 579     FT_BBox*  bbox;          /* bounding box */
 580     FT_Bool   path_begun;
 581     FT_Bool   load_points;
 582     FT_Bool   no_recurse;
 583 
 584     FT_Bool  metrics_only;
 585     FT_Bool  is_t1;
 586 
 587     PS_Builder_FuncsRec  funcs;
 588 
 589   };
 590 
 591 
 592   /*************************************************************************/
 593   /*************************************************************************/
 594   /*****                                                               *****/
 595   /*****                            PS DECODER                         *****/
 596   /*****                                                               *****/
 597   /*************************************************************************/
 598   /*************************************************************************/
 599 
 600 #define PS_MAX_OPERANDS        48
 601 #define PS_MAX_SUBRS_CALLS     16   /* maximum subroutine nesting;         */
 602                                     /* only 10 are allowed but there exist */
 603                                     /* fonts like `HiraKakuProN-W3.ttf&#39;    */
 604                                     /* (Hiragino Kaku Gothic ProN W3;      */
 605                                     /* 8.2d6e1; 2014-12-19) that exceed    */
 606                                     /* this limit                          */
 607 
 608   /* execution context charstring zone */
 609 
 610   typedef struct  PS_Decoder_Zone_
 611   {
 612     FT_Byte*  base;
 613     FT_Byte*  limit;
 614     FT_Byte*  cursor;
 615 
 616   } PS_Decoder_Zone;
 617 
 618 
 619   typedef FT_Error
 620   (*CFF_Decoder_Get_Glyph_Callback)( TT_Face    face,
 621                                      FT_UInt    glyph_index,
 622                                      FT_Byte**  pointer,
 623                                      FT_ULong*  length );
 624 
 625   typedef void
 626   (*CFF_Decoder_Free_Glyph_Callback)( TT_Face    face,
 627                                       FT_Byte**  pointer,
 628                                       FT_ULong   length );
 629 
 630 
 631   typedef struct  PS_Decoder_
 632   {
 633     PS_Builder  builder;
 634 
 635     FT_Fixed   stack[PS_MAX_OPERANDS + 1];
 636     FT_Fixed*  top;
 637 
 638     PS_Decoder_Zone   zones[PS_MAX_SUBRS_CALLS + 1];
 639     PS_Decoder_Zone*  zone;
 640 
 641     FT_Int     flex_state;
 642     FT_Int     num_flex_vectors;
 643     FT_Vector  flex_vectors[7];
 644 
 645     CFF_Font     cff;
 646     CFF_SubFont  current_subfont; /* for current glyph_index */
 647     FT_Generic*  cf2_instance;
 648 
 649     FT_Pos*  glyph_width;
 650     FT_Bool  width_only;
 651     FT_Int   num_hints;
 652 
 653     FT_UInt  num_locals;
 654     FT_UInt  num_globals;
 655 
 656     FT_Int  locals_bias;
 657     FT_Int  globals_bias;
 658 
 659     FT_Byte**  locals;
 660     FT_Byte**  globals;
 661 
 662     FT_Byte**  glyph_names;   /* for pure CFF fonts only  */
 663     FT_UInt    num_glyphs;    /* number of glyphs in font */
 664 
 665     FT_Render_Mode  hint_mode;
 666 
 667     FT_Bool  seac;
 668 
 669     CFF_Decoder_Get_Glyph_Callback   get_glyph_callback;
 670     CFF_Decoder_Free_Glyph_Callback  free_glyph_callback;
 671 
 672     /* Type 1 stuff */
 673     FT_Service_PsCMaps  psnames;      /* for seac */
 674 
 675     FT_Int    lenIV;         /* internal for sub routine calls   */
 676     FT_UInt*  locals_len;    /* array of subrs length (optional) */
 677     FT_Hash   locals_hash;   /* used if `num_subrs&#39; was massaged */
 678 
 679     FT_Matrix  font_matrix;
 680     FT_Vector  font_offset;
 681 
 682     PS_Blend  blend;         /* for multiple master support */
 683 
 684     FT_Long*  buildchar;
 685     FT_UInt   len_buildchar;
 686 
 687   } PS_Decoder;
 688 
 689 
 690   /*************************************************************************/
 691   /*************************************************************************/
 692   /*****                                                               *****/
 693   /*****                         T1 BUILDER                            *****/
 694   /*****                                                               *****/
 695   /*************************************************************************/
 696   /*************************************************************************/
 697 
 698 
 699   typedef struct T1_BuilderRec_*  T1_Builder;
 700 
 701 
 702   typedef FT_Error
 703   (*T1_Builder_Check_Points_Func)( T1_Builder  builder,
 704                                    FT_Int      count );
 705 
 706   typedef void
 707   (*T1_Builder_Add_Point_Func)( T1_Builder  builder,
 708                                 FT_Pos      x,
 709                                 FT_Pos      y,
 710                                 FT_Byte     flag );
 711 
 712   typedef FT_Error
 713   (*T1_Builder_Add_Point1_Func)( T1_Builder  builder,
 714                                  FT_Pos      x,
 715                                  FT_Pos      y );
 716 
 717   typedef FT_Error
 718   (*T1_Builder_Add_Contour_Func)( T1_Builder  builder );
 719 
 720   typedef FT_Error
 721   (*T1_Builder_Start_Point_Func)( T1_Builder  builder,
 722                                   FT_Pos      x,
 723                                   FT_Pos      y );
 724 
 725   typedef void
 726   (*T1_Builder_Close_Contour_Func)( T1_Builder  builder );
 727 
 728 
 729   typedef const struct T1_Builder_FuncsRec_*  T1_Builder_Funcs;
 730 
 731   typedef struct  T1_Builder_FuncsRec_
 732   {
 733     void
 734     (*init)( T1_Builder    builder,
 735              FT_Face       face,
 736              FT_Size       size,
 737              FT_GlyphSlot  slot,
 738              FT_Bool       hinting );
 739 
 740     void
 741     (*done)( T1_Builder   builder );
 742 
 743     T1_Builder_Check_Points_Func   check_points;
 744     T1_Builder_Add_Point_Func      add_point;
 745     T1_Builder_Add_Point1_Func     add_point1;
 746     T1_Builder_Add_Contour_Func    add_contour;
 747     T1_Builder_Start_Point_Func    start_point;
 748     T1_Builder_Close_Contour_Func  close_contour;
 749 
 750   } T1_Builder_FuncsRec;
 751 
 752 
 753   /* an enumeration type to handle charstring parsing states */
 754   typedef enum  T1_ParseState_
 755   {
 756     T1_Parse_Start,
 757     T1_Parse_Have_Width,
 758     T1_Parse_Have_Moveto,
 759     T1_Parse_Have_Path
 760 
 761   } T1_ParseState;
 762 
 763 
 764   /**************************************************************************
 765    *
 766    * @struct:
 767    *   T1_BuilderRec
 768    *
 769    * @description:
 770    *    A structure used during glyph loading to store its outline.
 771    *
 772    * @fields:
 773    *   memory ::
 774    *     The current memory object.
 775    *
 776    *   face ::
 777    *     The current face object.
 778    *
 779    *   glyph ::
 780    *     The current glyph slot.
 781    *
 782    *   loader ::
 783    *     XXX
 784    *
 785    *   base ::
 786    *     The base glyph outline.
 787    *
 788    *   current ::
 789    *     The current glyph outline.
 790    *
 791    *   max_points ::
 792    *     maximum points in builder outline
 793    *
 794    *   max_contours ::
 795    *     Maximum number of contours in builder outline.
 796    *
 797    *   pos_x ::
 798    *     The horizontal translation (if composite glyph).
 799    *
 800    *   pos_y ::
 801    *     The vertical translation (if composite glyph).
 802    *
 803    *   left_bearing ::
 804    *     The left side bearing point.
 805    *
 806    *   advance ::
 807    *     The horizontal advance vector.
 808    *
 809    *   bbox ::
 810    *     Unused.
 811    *
 812    *   parse_state ::
 813    *     An enumeration which controls the charstring parsing state.
 814    *
 815    *   load_points ::
 816    *     If this flag is not set, no points are loaded.
 817    *
 818    *   no_recurse ::
 819    *     Set but not used.
 820    *
 821    *   metrics_only ::
 822    *     A boolean indicating that we only want to compute the metrics of a
 823    *     given glyph, not load all of its points.
 824    *
 825    *   funcs ::
 826    *     An array of function pointers for the builder.
 827    */
 828   typedef struct  T1_BuilderRec_
 829   {
 830     FT_Memory       memory;
 831     FT_Face         face;
 832     FT_GlyphSlot    glyph;
 833     FT_GlyphLoader  loader;
 834     FT_Outline*     base;
 835     FT_Outline*     current;
 836 
 837     FT_Pos          pos_x;
 838     FT_Pos          pos_y;
 839 
 840     FT_Vector       left_bearing;
 841     FT_Vector       advance;
 842 
 843     FT_BBox         bbox;          /* bounding box */
 844     T1_ParseState   parse_state;
 845     FT_Bool         load_points;
 846     FT_Bool         no_recurse;
 847 
 848     FT_Bool         metrics_only;
 849 
 850     void*           hints_funcs;    /* hinter-specific */
 851     void*           hints_globals;  /* hinter-specific */
 852 
 853     T1_Builder_FuncsRec  funcs;
 854 
 855   } T1_BuilderRec;
 856 
 857 
 858   /*************************************************************************/
 859   /*************************************************************************/
 860   /*****                                                               *****/
 861   /*****                         T1 DECODER                            *****/
 862   /*****                                                               *****/
 863   /*************************************************************************/
 864   /*************************************************************************/
 865 
 866 #if 0
 867 
 868   /**************************************************************************
 869    *
 870    * T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine
 871    * calls during glyph loading.
 872    */
 873 #define T1_MAX_SUBRS_CALLS  8
 874 
 875 
 876   /**************************************************************************
 877    *
 878    * T1_MAX_CHARSTRING_OPERANDS is the charstring stack&#39;s capacity.  A
 879    * minimum of 16 is required.
 880    */
 881 #define T1_MAX_CHARSTRINGS_OPERANDS  32
 882 
 883 #endif /* 0 */
 884 
 885 
 886   typedef struct  T1_Decoder_ZoneRec_
 887   {
 888     FT_Byte*  cursor;
 889     FT_Byte*  base;
 890     FT_Byte*  limit;
 891 
 892   } T1_Decoder_ZoneRec, *T1_Decoder_Zone;
 893 
 894 
 895   typedef struct T1_DecoderRec_*              T1_Decoder;
 896   typedef const struct T1_Decoder_FuncsRec_*  T1_Decoder_Funcs;
 897 
 898 
 899   typedef FT_Error
 900   (*T1_Decoder_Callback)( T1_Decoder  decoder,
 901                           FT_UInt     glyph_index );
 902 
 903 
 904   typedef struct  T1_Decoder_FuncsRec_
 905   {
 906     FT_Error
 907     (*init)( T1_Decoder           decoder,
 908              FT_Face              face,
 909              FT_Size              size,
 910              FT_GlyphSlot         slot,
 911              FT_Byte**            glyph_names,
 912              PS_Blend             blend,
 913              FT_Bool              hinting,
 914              FT_Render_Mode       hint_mode,
 915              T1_Decoder_Callback  callback );
 916 
 917     void
 918     (*done)( T1_Decoder  decoder );
 919 
 920 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 921     FT_Error
 922     (*parse_charstrings_old)( T1_Decoder  decoder,
 923                               FT_Byte*    base,
 924                               FT_UInt     len );
 925 #else
 926     FT_Error
 927     (*parse_metrics)( T1_Decoder  decoder,
 928                       FT_Byte*    base,
 929                       FT_UInt     len );
 930 #endif
 931 
 932     FT_Error
 933     (*parse_charstrings)( PS_Decoder*  decoder,
 934                           FT_Byte*     charstring_base,
 935                           FT_ULong     charstring_len );
 936 
 937 
 938   } T1_Decoder_FuncsRec;
 939 
 940 
 941   typedef struct  T1_DecoderRec_
 942   {
 943     T1_BuilderRec        builder;
 944 
 945     FT_Long              stack[T1_MAX_CHARSTRINGS_OPERANDS];
 946     FT_Long*             top;
 947 
 948     T1_Decoder_ZoneRec   zones[T1_MAX_SUBRS_CALLS + 1];
 949     T1_Decoder_Zone      zone;
 950 
 951     FT_Service_PsCMaps   psnames;      /* for seac */
 952     FT_UInt              num_glyphs;
 953     FT_Byte**            glyph_names;
 954 
 955     FT_Int               lenIV;        /* internal for sub routine calls */
 956     FT_Int               num_subrs;
 957     FT_Byte**            subrs;
 958     FT_UInt*             subrs_len;    /* array of subrs length (optional) */
 959     FT_Hash              subrs_hash;   /* used if `num_subrs&#39; was massaged */
 960 
 961     FT_Matrix            font_matrix;
 962     FT_Vector            font_offset;
 963 
 964     FT_Int               flex_state;
 965     FT_Int               num_flex_vectors;
 966     FT_Vector            flex_vectors[7];
 967 
 968     PS_Blend             blend;       /* for multiple master support */
 969 
 970     FT_Render_Mode       hint_mode;
 971 
 972     T1_Decoder_Callback  parse_callback;
 973     T1_Decoder_FuncsRec  funcs;
 974 
 975     FT_Long*             buildchar;
 976     FT_UInt              len_buildchar;
 977 
 978     FT_Bool              seac;
 979 
 980     FT_Generic           cf2_instance;
 981 
 982   } T1_DecoderRec;
 983 
 984 
 985   /*************************************************************************/
 986   /*************************************************************************/
 987   /*****                                                               *****/
 988   /*****                        CFF BUILDER                            *****/
 989   /*****                                                               *****/
 990   /*************************************************************************/
 991   /*************************************************************************/
 992 
 993 
 994   typedef struct CFF_Builder_  CFF_Builder;
 995 
 996 
 997   typedef FT_Error
 998   (*CFF_Builder_Check_Points_Func)( CFF_Builder*  builder,
 999                                     FT_Int        count );
1000 
1001   typedef void
1002   (*CFF_Builder_Add_Point_Func)( CFF_Builder*  builder,
1003                                  FT_Pos        x,
1004                                  FT_Pos        y,
1005                                  FT_Byte       flag );
1006   typedef FT_Error
1007   (*CFF_Builder_Add_Point1_Func)( CFF_Builder*  builder,
1008                                   FT_Pos        x,
1009                                   FT_Pos        y );
1010   typedef FT_Error
1011   (*CFF_Builder_Start_Point_Func)( CFF_Builder*  builder,
1012                                    FT_Pos        x,
1013                                    FT_Pos        y );
1014   typedef void
1015   (*CFF_Builder_Close_Contour_Func)( CFF_Builder*  builder );
1016 
1017   typedef FT_Error
1018   (*CFF_Builder_Add_Contour_Func)( CFF_Builder*  builder );
1019 
1020   typedef const struct CFF_Builder_FuncsRec_*  CFF_Builder_Funcs;
1021 
1022   typedef struct  CFF_Builder_FuncsRec_
1023   {
1024     void
1025     (*init)( CFF_Builder*   builder,
1026              TT_Face        face,
1027              CFF_Size       size,
1028              CFF_GlyphSlot  glyph,
1029              FT_Bool        hinting );
1030 
1031     void
1032     (*done)( CFF_Builder*  builder );
1033 
1034     CFF_Builder_Check_Points_Func   check_points;
1035     CFF_Builder_Add_Point_Func      add_point;
1036     CFF_Builder_Add_Point1_Func     add_point1;
1037     CFF_Builder_Add_Contour_Func    add_contour;
1038     CFF_Builder_Start_Point_Func    start_point;
1039     CFF_Builder_Close_Contour_Func  close_contour;
1040 
1041   } CFF_Builder_FuncsRec;
1042 
1043 
1044   /**************************************************************************
1045    *
1046    * @struct:
1047    *   CFF_Builder
1048    *
1049    * @description:
1050    *    A structure used during glyph loading to store its outline.
1051    *
1052    * @fields:
1053    *   memory ::
1054    *     The current memory object.
1055    *
1056    *   face ::
1057    *     The current face object.
1058    *
1059    *   glyph ::
1060    *     The current glyph slot.
1061    *
1062    *   loader ::
1063    *     The current glyph loader.
1064    *
1065    *   base ::
1066    *     The base glyph outline.
1067    *
1068    *   current ::
1069    *     The current glyph outline.
1070    *
1071    *   pos_x ::
1072    *     The horizontal translation (if composite glyph).
1073    *
1074    *   pos_y ::
1075    *     The vertical translation (if composite glyph).
1076    *
1077    *   left_bearing ::
1078    *     The left side bearing point.
1079    *
1080    *   advance ::
1081    *     The horizontal advance vector.
1082    *
1083    *   bbox ::
1084    *     Unused.
1085    *
1086    *   path_begun ::
1087    *     A flag which indicates that a new path has begun.
1088    *
1089    *   load_points ::
1090    *     If this flag is not set, no points are loaded.
1091    *
1092    *   no_recurse ::
1093    *     Set but not used.
1094    *
1095    *   metrics_only ::
1096    *     A boolean indicating that we only want to compute the metrics of a
1097    *     given glyph, not load all of its points.
1098    *
1099    *   hints_funcs ::
1100    *     Auxiliary pointer for hinting.
1101    *
1102    *   hints_globals ::
1103    *     Auxiliary pointer for hinting.
1104    *
1105    *   funcs ::
1106    *     A table of method pointers for this object.
1107    */
1108   struct  CFF_Builder_
1109   {
1110     FT_Memory       memory;
1111     TT_Face         face;
1112     CFF_GlyphSlot   glyph;
1113     FT_GlyphLoader  loader;
1114     FT_Outline*     base;
1115     FT_Outline*     current;
1116 
1117     FT_Pos  pos_x;
1118     FT_Pos  pos_y;
1119 
1120     FT_Vector  left_bearing;
1121     FT_Vector  advance;
1122 
1123     FT_BBox  bbox;          /* bounding box */
1124 
1125     FT_Bool  path_begun;
1126     FT_Bool  load_points;
1127     FT_Bool  no_recurse;
1128 
1129     FT_Bool  metrics_only;
1130 
1131     void*  hints_funcs;     /* hinter-specific */
1132     void*  hints_globals;   /* hinter-specific */
1133 
1134     CFF_Builder_FuncsRec  funcs;
1135   };
1136 
1137 
1138   /*************************************************************************/
1139   /*************************************************************************/
1140   /*****                                                               *****/
1141   /*****                        CFF DECODER                            *****/
1142   /*****                                                               *****/
1143   /*************************************************************************/
1144   /*************************************************************************/
1145 
1146 
1147 #define CFF_MAX_OPERANDS        48
1148 #define CFF_MAX_SUBRS_CALLS     16  /* maximum subroutine nesting;         */
1149                                     /* only 10 are allowed but there exist */
1150                                     /* fonts like `HiraKakuProN-W3.ttf&#39;    */
1151                                     /* (Hiragino Kaku Gothic ProN W3;      */
1152                                     /* 8.2d6e1; 2014-12-19) that exceed    */
1153                                     /* this limit                          */
1154 #define CFF_MAX_TRANS_ELEMENTS  32
1155 
1156   /* execution context charstring zone */
1157 
1158   typedef struct  CFF_Decoder_Zone_
1159   {
1160     FT_Byte*  base;
1161     FT_Byte*  limit;
1162     FT_Byte*  cursor;
1163 
1164   } CFF_Decoder_Zone;
1165 
1166 
1167   typedef struct  CFF_Decoder_
1168   {
1169     CFF_Builder  builder;
1170     CFF_Font     cff;
1171 
1172     FT_Fixed   stack[CFF_MAX_OPERANDS + 1];
1173     FT_Fixed*  top;
1174 
1175     CFF_Decoder_Zone   zones[CFF_MAX_SUBRS_CALLS + 1];
1176     CFF_Decoder_Zone*  zone;
1177 
1178     FT_Int     flex_state;
1179     FT_Int     num_flex_vectors;
1180     FT_Vector  flex_vectors[7];
1181 
1182     FT_Pos  glyph_width;
1183     FT_Pos  nominal_width;
1184 
1185     FT_Bool   read_width;
1186     FT_Bool   width_only;
1187     FT_Int    num_hints;
1188     FT_Fixed  buildchar[CFF_MAX_TRANS_ELEMENTS];
1189 
1190     FT_UInt  num_locals;
1191     FT_UInt  num_globals;
1192 
1193     FT_Int  locals_bias;
1194     FT_Int  globals_bias;
1195 
1196     FT_Byte**  locals;
1197     FT_Byte**  globals;
1198 
1199     FT_Byte**  glyph_names;   /* for pure CFF fonts only  */
1200     FT_UInt    num_glyphs;    /* number of glyphs in font */
1201 
1202     FT_Render_Mode  hint_mode;
1203 
1204     FT_Bool  seac;
1205 
1206     CFF_SubFont  current_subfont; /* for current glyph_index */
1207 
1208     CFF_Decoder_Get_Glyph_Callback   get_glyph_callback;
1209     CFF_Decoder_Free_Glyph_Callback  free_glyph_callback;
1210 
1211   } CFF_Decoder;
1212 
1213 
1214   typedef const struct CFF_Decoder_FuncsRec_*  CFF_Decoder_Funcs;
1215 
1216   typedef struct  CFF_Decoder_FuncsRec_
1217   {
1218     void
1219     (*init)( CFF_Decoder*                     decoder,
1220              TT_Face                          face,
1221              CFF_Size                         size,
1222              CFF_GlyphSlot                    slot,
1223              FT_Bool                          hinting,
1224              FT_Render_Mode                   hint_mode,
1225              CFF_Decoder_Get_Glyph_Callback   get_callback,
1226              CFF_Decoder_Free_Glyph_Callback  free_callback );
1227 
1228     FT_Error
1229     (*prepare)( CFF_Decoder*  decoder,
1230                 CFF_Size      size,
1231                 FT_UInt       glyph_index );
1232 
1233 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1234     FT_Error
1235     (*parse_charstrings_old)( CFF_Decoder*  decoder,
1236                               FT_Byte*      charstring_base,
1237                               FT_ULong      charstring_len,
1238                               FT_Bool       in_dict );
1239 #endif
1240 
1241     FT_Error
1242     (*parse_charstrings)( PS_Decoder*  decoder,
1243                           FT_Byte*     charstring_base,
1244                           FT_ULong     charstring_len );
1245 
1246   } CFF_Decoder_FuncsRec;
1247 
1248 
1249   /*************************************************************************/
1250   /*************************************************************************/
1251   /*****                                                               *****/
1252   /*****                            AFM PARSER                         *****/
1253   /*****                                                               *****/
1254   /*************************************************************************/
1255   /*************************************************************************/
1256 
1257   typedef struct AFM_ParserRec_*  AFM_Parser;
1258 
1259   typedef struct  AFM_Parser_FuncsRec_
1260   {
1261     FT_Error
1262     (*init)( AFM_Parser  parser,
1263              FT_Memory   memory,
1264              FT_Byte*    base,
1265              FT_Byte*    limit );
1266 
1267     void
1268     (*done)( AFM_Parser  parser );
1269 
1270     FT_Error
1271     (*parse)( AFM_Parser  parser );
1272 
1273   } AFM_Parser_FuncsRec;
1274 
1275 
1276   typedef struct AFM_StreamRec_*  AFM_Stream;
1277 
1278 
1279   /**************************************************************************
1280    *
1281    * @struct:
1282    *   AFM_ParserRec
1283    *
1284    * @description:
1285    *   An AFM_Parser is a parser for the AFM files.
1286    *
1287    * @fields:
1288    *   memory ::
1289    *     The object used for memory operations (alloc and realloc).
1290    *
1291    *   stream ::
1292    *     This is an opaque object.
1293    *
1294    *   FontInfo ::
1295    *     The result will be stored here.
1296    *
1297    *   get_index ::
1298    *     A user provided function to get a glyph index by its name.
1299    */
1300   typedef struct  AFM_ParserRec_
1301   {
1302     FT_Memory     memory;
1303     AFM_Stream    stream;
1304 
1305     AFM_FontInfo  FontInfo;
1306 
1307     FT_Int
1308     (*get_index)( const char*  name,
1309                   FT_Offset    len,
1310                   void*        user_data );
1311 
1312     void*         user_data;
1313 
1314   } AFM_ParserRec;
1315 
1316 
1317   /*************************************************************************/
1318   /*************************************************************************/
1319   /*****                                                               *****/
1320   /*****                     TYPE1 CHARMAPS                            *****/
1321   /*****                                                               *****/
1322   /*************************************************************************/
1323   /*************************************************************************/
1324 
1325   typedef const struct T1_CMap_ClassesRec_*  T1_CMap_Classes;
1326 
1327   typedef struct T1_CMap_ClassesRec_
1328   {
1329     FT_CMap_Class  standard;
1330     FT_CMap_Class  expert;
1331     FT_CMap_Class  custom;
1332     FT_CMap_Class  unicode;
1333 
1334   } T1_CMap_ClassesRec;
1335 
1336 
1337   /*************************************************************************/
1338   /*************************************************************************/
1339   /*****                                                               *****/
1340   /*****                        PSAux Module Interface                 *****/
1341   /*****                                                               *****/
1342   /*************************************************************************/
1343   /*************************************************************************/
1344 
1345   typedef struct  PSAux_ServiceRec_
1346   {
1347     /* don&#39;t use `PS_Table_Funcs&#39; and friends to avoid compiler warnings */
1348     const PS_Table_FuncsRec*    ps_table_funcs;
1349     const PS_Parser_FuncsRec*   ps_parser_funcs;
1350     const T1_Builder_FuncsRec*  t1_builder_funcs;
1351     const T1_Decoder_FuncsRec*  t1_decoder_funcs;
1352 
1353     void
1354     (*t1_decrypt)( FT_Byte*   buffer,
1355                    FT_Offset  length,
1356                    FT_UShort  seed );
1357 
1358     FT_UInt32
1359     (*cff_random)( FT_UInt32  r );
1360 
1361     void
1362     (*ps_decoder_init)( PS_Decoder*  ps_decoder,
1363                         void*        decoder,
1364                         FT_Bool      is_t1 );
1365 
1366     void
1367     (*t1_make_subfont)( FT_Face      face,
1368                         PS_Private   priv,
1369                         CFF_SubFont  subfont );
1370 
1371     T1_CMap_Classes  t1_cmap_classes;
1372 
1373     /* fields after this comment line were added after version 2.1.10 */
1374     const AFM_Parser_FuncsRec*  afm_parser_funcs;
1375 
1376     const CFF_Decoder_FuncsRec*  cff_decoder_funcs;
1377 
1378   } PSAux_ServiceRec, *PSAux_Service;
1379 
1380   /* backward compatible type definition */
1381   typedef PSAux_ServiceRec   PSAux_Interface;
1382 
1383 
1384   /*************************************************************************/
1385   /*************************************************************************/
1386   /*****                                                               *****/
1387   /*****                 Some convenience functions                    *****/
1388   /*****                                                               *****/
1389   /*************************************************************************/
1390   /*************************************************************************/
1391 
1392 #define IS_PS_NEWLINE( ch ) \
1393   ( (ch) == &#39;\r&#39; ||         \
1394     (ch) == &#39;\n&#39; )
1395 
1396 #define IS_PS_SPACE( ch )  \
1397   ( (ch) == &#39; &#39;         || \
1398     IS_PS_NEWLINE( ch ) || \
1399     (ch) == &#39;\t&#39;        || \
1400     (ch) == &#39;\f&#39;        || \
1401     (ch) == &#39;\0&#39; )
1402 
1403 #define IS_PS_SPECIAL( ch )       \
1404   ( (ch) == &#39;/&#39;                || \
1405     (ch) == &#39;(&#39; || (ch) == &#39;)&#39; || \
1406     (ch) == &#39;&lt;&#39; || (ch) == &#39;&gt;&#39; || \
1407     (ch) == &#39;[&#39; || (ch) == &#39;]&#39; || \
1408     (ch) == &#39;{&#39; || (ch) == &#39;}&#39; || \
1409     (ch) == &#39;%&#39;                )
1410 
1411 #define IS_PS_DELIM( ch )  \
1412   ( IS_PS_SPACE( ch )   || \
1413     IS_PS_SPECIAL( ch ) )
1414 
1415 #define IS_PS_DIGIT( ch )        \
1416   ( (ch) &gt;= &#39;0&#39; &amp;&amp; (ch) &lt;= &#39;9&#39; )
1417 
1418 #define IS_PS_XDIGIT( ch )            \
1419   ( IS_PS_DIGIT( ch )              || \
1420     ( (ch) &gt;= &#39;A&#39; &amp;&amp; (ch) &lt;= &#39;F&#39; ) || \
1421     ( (ch) &gt;= &#39;a&#39; &amp;&amp; (ch) &lt;= &#39;f&#39; ) )
1422 
1423 #define IS_PS_BASE85( ch )       \
1424   ( (ch) &gt;= &#39;!&#39; &amp;&amp; (ch) &lt;= &#39;u&#39; )
1425 
1426 #define IS_PS_TOKEN( cur, limit, token )                                \
1427   ( (char)(cur)[0] == (token)[0]                                     &amp;&amp; \
1428     ( (cur) + sizeof ( (token) ) == (limit) ||                          \
1429       ( (cur) + sizeof( (token) ) &lt; (limit)          &amp;&amp;                 \
1430         IS_PS_DELIM( (cur)[sizeof ( (token) ) - 1] ) ) )             &amp;&amp; \
1431     ft_strncmp( (char*)(cur), (token), sizeof ( (token) ) - 1 ) == 0 )
1432 
1433 
1434 FT_END_HEADER
1435 
1436 #endif /* PSAUX_H_ */
1437 
1438 
1439 /* END */
    </pre>
  </body>
</html>
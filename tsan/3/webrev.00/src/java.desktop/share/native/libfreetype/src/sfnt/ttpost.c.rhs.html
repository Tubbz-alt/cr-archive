<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/ttpost.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ttpost.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   PostScript name table processing for TrueType and OpenType fonts</span>
<span class="line-modified">  6  *   (body).</span>
<span class="line-modified">  7  *</span>
<span class="line-modified">  8  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  9  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified"> 10  *</span>
<span class="line-modified"> 11  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 12  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 13  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 14  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 15  * understand and accept it fully.</span>
<span class="line-modified"> 16  *</span>
<span class="line-modified"> 17  */</span>
<span class="line-modified"> 18 </span>
<span class="line-modified"> 19   /**************************************************************************</span>
<span class="line-modified"> 20    *</span>
<span class="line-modified"> 21    * The post table is not completely loaded by the core engine.  This</span>
<span class="line-modified"> 22    * file loads the missing PS glyph names and implements an API to access</span>
<span class="line-modified"> 23    * them.</span>
<span class="line-modified"> 24    *</span>
<span class="line-modified"> 25    */</span>
 26 
 27 
 28 #include &lt;ft2build.h&gt;
 29 #include FT_INTERNAL_DEBUG_H
 30 #include FT_INTERNAL_STREAM_H
 31 #include FT_TRUETYPE_TAGS_H
 32 
 33 
 34 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 35 
 36 #include &quot;ttpost.h&quot;
 37 
 38 #include &quot;sferrors.h&quot;
 39 
 40 
<a name="2" id="anc2"></a><span class="line-modified"> 41   /**************************************************************************</span>
<span class="line-modified"> 42    *</span>
<span class="line-modified"> 43    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 44    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 45    * messages during execution.</span>
<span class="line-modified"> 46    */</span>
 47 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 48 #define FT_COMPONENT  ttpost</span>
 49 
 50 
<a name="4" id="anc4"></a><span class="line-modified"> 51   /* If this configuration macro is defined, we rely on the `psnames&#39; */</span>
 52   /* module to grab the glyph names.                                  */
 53 
 54 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
 55 
 56 
 57 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 58 
 59 #define MAC_NAME( x )  (FT_String*)psnames-&gt;macintosh_name( (FT_UInt)(x) )
 60 
 61 
 62 #else /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
 63 
 64 
<a name="5" id="anc5"></a><span class="line-modified"> 65    /* Otherwise, we ignore the `psnames&#39; module, and provide our own  */</span>
 66    /* table of Mac names.  Thus, it is possible to build a version of */
<a name="6" id="anc6"></a><span class="line-modified"> 67    /* FreeType without the Type 1 driver &amp; psnames module.            */</span>
 68 
 69 #define MAC_NAME( x )  (FT_String*)tt_post_default_names[x]
 70 
 71   /* the 258 default Mac PS glyph names; see file `tools/glnames.py&#39; */
 72 
 73   static const FT_String* const  tt_post_default_names[258] =
 74   {
 75     /*   0 */
 76     &quot;.notdef&quot;, &quot;.null&quot;, &quot;nonmarkingreturn&quot;, &quot;space&quot;, &quot;exclam&quot;,
 77     &quot;quotedbl&quot;, &quot;numbersign&quot;, &quot;dollar&quot;, &quot;percent&quot;, &quot;ampersand&quot;,
 78     /*  10 */
 79     &quot;quotesingle&quot;, &quot;parenleft&quot;, &quot;parenright&quot;, &quot;asterisk&quot;, &quot;plus&quot;,
 80     &quot;comma&quot;, &quot;hyphen&quot;, &quot;period&quot;, &quot;slash&quot;, &quot;zero&quot;,
 81     /*  20 */
 82     &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;,
 83     &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;colon&quot;,
 84     /*  30 */
 85     &quot;semicolon&quot;, &quot;less&quot;, &quot;equal&quot;, &quot;greater&quot;, &quot;question&quot;,
 86     &quot;at&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;,
 87     /*  40 */
 88     &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;,
 89     &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;,
 90     /*  50 */
 91     &quot;O&quot;, &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;,
 92     &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;,
 93     /*  60 */
 94     &quot;Y&quot;, &quot;Z&quot;, &quot;bracketleft&quot;, &quot;backslash&quot;, &quot;bracketright&quot;,
 95     &quot;asciicircum&quot;, &quot;underscore&quot;, &quot;grave&quot;, &quot;a&quot;, &quot;b&quot;,
 96     /*  70 */
 97     &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;,
 98     &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;,
 99     /*  80 */
100     &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;,
101     &quot;r&quot;, &quot;s&quot;, &quot;t&quot;, &quot;u&quot;, &quot;v&quot;,
102     /*  90 */
103     &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;braceleft&quot;,
104     &quot;bar&quot;, &quot;braceright&quot;, &quot;asciitilde&quot;, &quot;Adieresis&quot;, &quot;Aring&quot;,
105     /* 100 */
106     &quot;Ccedilla&quot;, &quot;Eacute&quot;, &quot;Ntilde&quot;, &quot;Odieresis&quot;, &quot;Udieresis&quot;,
107     &quot;aacute&quot;, &quot;agrave&quot;, &quot;acircumflex&quot;, &quot;adieresis&quot;, &quot;atilde&quot;,
108     /* 110 */
109     &quot;aring&quot;, &quot;ccedilla&quot;, &quot;eacute&quot;, &quot;egrave&quot;, &quot;ecircumflex&quot;,
110     &quot;edieresis&quot;, &quot;iacute&quot;, &quot;igrave&quot;, &quot;icircumflex&quot;, &quot;idieresis&quot;,
111     /* 120 */
112     &quot;ntilde&quot;, &quot;oacute&quot;, &quot;ograve&quot;, &quot;ocircumflex&quot;, &quot;odieresis&quot;,
113     &quot;otilde&quot;, &quot;uacute&quot;, &quot;ugrave&quot;, &quot;ucircumflex&quot;, &quot;udieresis&quot;,
114     /* 130 */
115     &quot;dagger&quot;, &quot;degree&quot;, &quot;cent&quot;, &quot;sterling&quot;, &quot;section&quot;,
116     &quot;bullet&quot;, &quot;paragraph&quot;, &quot;germandbls&quot;, &quot;registered&quot;, &quot;copyright&quot;,
117     /* 140 */
118     &quot;trademark&quot;, &quot;acute&quot;, &quot;dieresis&quot;, &quot;notequal&quot;, &quot;AE&quot;,
119     &quot;Oslash&quot;, &quot;infinity&quot;, &quot;plusminus&quot;, &quot;lessequal&quot;, &quot;greaterequal&quot;,
120     /* 150 */
121     &quot;yen&quot;, &quot;mu&quot;, &quot;partialdiff&quot;, &quot;summation&quot;, &quot;product&quot;,
122     &quot;pi&quot;, &quot;integral&quot;, &quot;ordfeminine&quot;, &quot;ordmasculine&quot;, &quot;Omega&quot;,
123     /* 160 */
124     &quot;ae&quot;, &quot;oslash&quot;, &quot;questiondown&quot;, &quot;exclamdown&quot;, &quot;logicalnot&quot;,
125     &quot;radical&quot;, &quot;florin&quot;, &quot;approxequal&quot;, &quot;Delta&quot;, &quot;guillemotleft&quot;,
126     /* 170 */
127     &quot;guillemotright&quot;, &quot;ellipsis&quot;, &quot;nonbreakingspace&quot;, &quot;Agrave&quot;, &quot;Atilde&quot;,
128     &quot;Otilde&quot;, &quot;OE&quot;, &quot;oe&quot;, &quot;endash&quot;, &quot;emdash&quot;,
129     /* 180 */
130     &quot;quotedblleft&quot;, &quot;quotedblright&quot;, &quot;quoteleft&quot;, &quot;quoteright&quot;, &quot;divide&quot;,
131     &quot;lozenge&quot;, &quot;ydieresis&quot;, &quot;Ydieresis&quot;, &quot;fraction&quot;, &quot;currency&quot;,
132     /* 190 */
133     &quot;guilsinglleft&quot;, &quot;guilsinglright&quot;, &quot;fi&quot;, &quot;fl&quot;, &quot;daggerdbl&quot;,
134     &quot;periodcentered&quot;, &quot;quotesinglbase&quot;, &quot;quotedblbase&quot;, &quot;perthousand&quot;, &quot;Acircumflex&quot;,
135     /* 200 */
136     &quot;Ecircumflex&quot;, &quot;Aacute&quot;, &quot;Edieresis&quot;, &quot;Egrave&quot;, &quot;Iacute&quot;,
137     &quot;Icircumflex&quot;, &quot;Idieresis&quot;, &quot;Igrave&quot;, &quot;Oacute&quot;, &quot;Ocircumflex&quot;,
138     /* 210 */
139     &quot;apple&quot;, &quot;Ograve&quot;, &quot;Uacute&quot;, &quot;Ucircumflex&quot;, &quot;Ugrave&quot;,
140     &quot;dotlessi&quot;, &quot;circumflex&quot;, &quot;tilde&quot;, &quot;macron&quot;, &quot;breve&quot;,
141     /* 220 */
142     &quot;dotaccent&quot;, &quot;ring&quot;, &quot;cedilla&quot;, &quot;hungarumlaut&quot;, &quot;ogonek&quot;,
143     &quot;caron&quot;, &quot;Lslash&quot;, &quot;lslash&quot;, &quot;Scaron&quot;, &quot;scaron&quot;,
144     /* 230 */
145     &quot;Zcaron&quot;, &quot;zcaron&quot;, &quot;brokenbar&quot;, &quot;Eth&quot;, &quot;eth&quot;,
146     &quot;Yacute&quot;, &quot;yacute&quot;, &quot;Thorn&quot;, &quot;thorn&quot;, &quot;minus&quot;,
147     /* 240 */
148     &quot;multiply&quot;, &quot;onesuperior&quot;, &quot;twosuperior&quot;, &quot;threesuperior&quot;, &quot;onehalf&quot;,
149     &quot;onequarter&quot;, &quot;threequarters&quot;, &quot;franc&quot;, &quot;Gbreve&quot;, &quot;gbreve&quot;,
150     /* 250 */
151     &quot;Idotaccent&quot;, &quot;Scedilla&quot;, &quot;scedilla&quot;, &quot;Cacute&quot;, &quot;cacute&quot;,
152     &quot;Ccaron&quot;, &quot;ccaron&quot;, &quot;dcroat&quot;,
153   };
154 
155 
156 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
157 
158 
159   static FT_Error
160   load_format_20( TT_Face    face,
161                   FT_Stream  stream,
162                   FT_ULong   post_limit )
163   {
164     FT_Memory   memory = stream-&gt;memory;
165     FT_Error    error;
166 
167     FT_Int      num_glyphs;
168     FT_UShort   num_names;
169 
170     FT_UShort*  glyph_indices = NULL;
171     FT_Char**   name_strings  = NULL;
172 
173 
174     if ( FT_READ_USHORT( num_glyphs ) )
175       goto Exit;
176 
177     /* UNDOCUMENTED!  The number of glyphs in this table can be smaller */
178     /* than the value in the maxp table (cf. cyberbit.ttf).             */
179 
180     /* There already exist fonts which have more than 32768 glyph names */
181     /* in this table, so the test for this threshold has been dropped.  */
182 
183     if ( num_glyphs &gt; face-&gt;max_profile.numGlyphs )
184     {
185       error = FT_THROW( Invalid_File_Format );
186       goto Exit;
187     }
188 
189     /* load the indices */
190     {
191       FT_Int  n;
192 
193 
194       if ( FT_NEW_ARRAY ( glyph_indices, num_glyphs ) ||
195            FT_FRAME_ENTER( num_glyphs * 2L )          )
196         goto Fail;
197 
198       for ( n = 0; n &lt; num_glyphs; n++ )
199         glyph_indices[n] = FT_GET_USHORT();
200 
201       FT_FRAME_EXIT();
202     }
203 
204     /* compute number of names stored in table */
205     {
206       FT_Int  n;
207 
208 
209       num_names = 0;
210 
211       for ( n = 0; n &lt; num_glyphs; n++ )
212       {
213         FT_Int  idx;
214 
215 
216         idx = glyph_indices[n];
217         if ( idx &gt;= 258 )
218         {
219           idx -= 257;
220           if ( idx &gt; num_names )
221             num_names = (FT_UShort)idx;
222         }
223       }
224     }
225 
226     /* now load the name strings */
227     {
228       FT_UShort  n;
229 
230 
231       if ( FT_NEW_ARRAY( name_strings, num_names ) )
232         goto Fail;
233 
234       for ( n = 0; n &lt; num_names; n++ )
235       {
236         FT_UInt  len;
237 
238 
239         if ( FT_STREAM_POS() &gt;= post_limit )
240           break;
241         else
242         {
243           FT_TRACE6(( &quot;load_format_20: %d byte left in post table\n&quot;,
244                       post_limit - FT_STREAM_POS() ));
245 
246           if ( FT_READ_BYTE( len ) )
247             goto Fail1;
248         }
249 
250         if ( len &gt; post_limit                   ||
251              FT_STREAM_POS() &gt; post_limit - len )
252         {
253           FT_Int  d = (FT_Int)post_limit - (FT_Int)FT_STREAM_POS();
254 
255 
256           FT_ERROR(( &quot;load_format_20:&quot;
257                      &quot; exceeding string length (%d),&quot;
258                      &quot; truncating at end of post table (%d byte left)\n&quot;,
259                      len, d ));
260           len = (FT_UInt)FT_MAX( 0, d );
261         }
262 
263         if ( FT_NEW_ARRAY( name_strings[n], len + 1 ) ||
264              FT_STREAM_READ( name_strings[n], len   ) )
265           goto Fail1;
266 
267         name_strings[n][len] = &#39;\0&#39;;
268       }
269 
270       if ( n &lt; num_names )
271       {
272         FT_ERROR(( &quot;load_format_20:&quot;
273                    &quot; all entries in post table are already parsed,&quot;
274                    &quot; using NULL names for gid %d - %d\n&quot;,
275                     n, num_names - 1 ));
276         for ( ; n &lt; num_names; n++ )
277           if ( FT_NEW_ARRAY( name_strings[n], 1 ) )
278             goto Fail1;
279           else
280             name_strings[n][0] = &#39;\0&#39;;
281       }
282     }
283 
284     /* all right, set table fields and exit successfully */
285     {
286       TT_Post_20  table = &amp;face-&gt;postscript_names.names.format_20;
287 
288 
289       table-&gt;num_glyphs    = (FT_UShort)num_glyphs;
290       table-&gt;num_names     = (FT_UShort)num_names;
291       table-&gt;glyph_indices = glyph_indices;
292       table-&gt;glyph_names   = name_strings;
293     }
294     return FT_Err_Ok;
295 
296   Fail1:
297     {
298       FT_UShort  n;
299 
300 
301       for ( n = 0; n &lt; num_names; n++ )
302         FT_FREE( name_strings[n] );
303     }
304 
305   Fail:
306     FT_FREE( name_strings );
307     FT_FREE( glyph_indices );
308 
309   Exit:
310     return error;
311   }
312 
313 
314   static FT_Error
315   load_format_25( TT_Face    face,
316                   FT_Stream  stream,
317                   FT_ULong   post_limit )
318   {
319     FT_Memory  memory = stream-&gt;memory;
320     FT_Error   error;
321 
322     FT_Int     num_glyphs;
323     FT_Char*   offset_table = NULL;
324 
325     FT_UNUSED( post_limit );
326 
327 
328     if ( FT_READ_USHORT( num_glyphs ) )
329       goto Exit;
330 
331     /* check the number of glyphs */
332     if ( num_glyphs &gt; face-&gt;max_profile.numGlyphs ||
333          num_glyphs &gt; 258                         ||
334          num_glyphs &lt; 1                           )
335     {
336       error = FT_THROW( Invalid_File_Format );
337       goto Exit;
338     }
339 
340     if ( FT_NEW_ARRAY( offset_table, num_glyphs )   ||
341          FT_STREAM_READ( offset_table, num_glyphs ) )
342       goto Fail;
343 
344     /* now check the offset table */
345     {
346       FT_Int  n;
347 
348 
349       for ( n = 0; n &lt; num_glyphs; n++ )
350       {
351         FT_Long  idx = (FT_Long)n + offset_table[n];
352 
353 
354         if ( idx &lt; 0 || idx &gt; num_glyphs )
355         {
356           error = FT_THROW( Invalid_File_Format );
357           goto Fail;
358         }
359       }
360     }
361 
362     /* OK, set table fields and exit successfully */
363     {
364       TT_Post_25  table = &amp;face-&gt;postscript_names.names.format_25;
365 
366 
367       table-&gt;num_glyphs = (FT_UShort)num_glyphs;
368       table-&gt;offsets    = offset_table;
369     }
370 
371     return FT_Err_Ok;
372 
373   Fail:
374     FT_FREE( offset_table );
375 
376   Exit:
377     return error;
378   }
379 
380 
381   static FT_Error
382   load_post_names( TT_Face  face )
383   {
384     FT_Stream  stream;
385     FT_Error   error;
386     FT_Fixed   format;
387     FT_ULong   post_len;
388     FT_ULong   post_limit;
389 
390 
391     /* get a stream for the face&#39;s resource */
392     stream = face-&gt;root.stream;
393 
394     /* seek to the beginning of the PS names table */
395     error = face-&gt;goto_table( face, TTAG_post, stream, &amp;post_len );
396     if ( error )
397       goto Exit;
398 
399     post_limit = FT_STREAM_POS() + post_len;
400 
401     format = face-&gt;postscript.FormatType;
402 
403     /* go to beginning of subtable */
404     if ( FT_STREAM_SKIP( 32 ) )
405       goto Exit;
406 
407     /* now read postscript table */
408     if ( format == 0x00020000L )
409       error = load_format_20( face, stream, post_limit );
410     else if ( format == 0x00025000L )
411       error = load_format_25( face, stream, post_limit );
412     else
413       error = FT_THROW( Invalid_File_Format );
414 
415     face-&gt;postscript_names.loaded = 1;
416 
417   Exit:
418     return error;
419   }
420 
421 
422   FT_LOCAL_DEF( void )
423   tt_face_free_ps_names( TT_Face  face )
424   {
425     FT_Memory      memory = face-&gt;root.memory;
426     TT_Post_Names  names  = &amp;face-&gt;postscript_names;
427     FT_Fixed       format;
428 
429 
430     if ( names-&gt;loaded )
431     {
432       format = face-&gt;postscript.FormatType;
433 
434       if ( format == 0x00020000L )
435       {
436         TT_Post_20  table = &amp;names-&gt;names.format_20;
437         FT_UShort   n;
438 
439 
440         FT_FREE( table-&gt;glyph_indices );
441         table-&gt;num_glyphs = 0;
442 
443         for ( n = 0; n &lt; table-&gt;num_names; n++ )
444           FT_FREE( table-&gt;glyph_names[n] );
445 
446         FT_FREE( table-&gt;glyph_names );
447         table-&gt;num_names = 0;
448       }
449       else if ( format == 0x00025000L )
450       {
451         TT_Post_25  table = &amp;names-&gt;names.format_25;
452 
453 
454         FT_FREE( table-&gt;offsets );
455         table-&gt;num_glyphs = 0;
456       }
457     }
458     names-&gt;loaded = 0;
459   }
460 
461 
<a name="7" id="anc7"></a><span class="line-modified">462   /**************************************************************************</span>
<span class="line-modified">463    *</span>
<span class="line-modified">464    * @Function:</span>
<span class="line-modified">465    *   tt_face_get_ps_name</span>
<span class="line-modified">466    *</span>
<span class="line-modified">467    * @Description:</span>
<span class="line-modified">468    *   Get the PostScript glyph name of a glyph.</span>
<span class="line-modified">469    *</span>
<span class="line-modified">470    * @Input:</span>
<span class="line-modified">471    *   face ::</span>
<span class="line-modified">472    *     A handle to the parent face.</span>
<span class="line-modified">473    *</span>
<span class="line-modified">474    *   idx ::</span>
<span class="line-modified">475    *     The glyph index.</span>
<span class="line-modified">476    *</span>
<span class="line-modified">477    * @InOut:</span>
<span class="line-modified">478    *   PSname ::</span>
<span class="line-modified">479    *     The address of a string pointer.  Undefined in case of</span>
<span class="line-modified">480    *     error, otherwise it is a pointer to the glyph name.</span>
<span class="line-modified">481    *</span>
<span class="line-modified">482    *     You must not modify the returned string!</span>
<span class="line-modified">483    *</span>
<span class="line-added">484    * @Output:</span>
<span class="line-added">485    *   FreeType error code.  0 means success.</span>
<span class="line-added">486    */</span>
487   FT_LOCAL_DEF( FT_Error )
488   tt_face_get_ps_name( TT_Face      face,
489                        FT_UInt      idx,
490                        FT_String**  PSname )
491   {
492     FT_Error       error;
493     TT_Post_Names  names;
494     FT_Fixed       format;
495 
496 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
497     FT_Service_PsCMaps  psnames;
498 #endif
499 
500 
501     if ( !face )
502       return FT_THROW( Invalid_Face_Handle );
503 
504     if ( idx &gt;= (FT_UInt)face-&gt;max_profile.numGlyphs )
505       return FT_THROW( Invalid_Glyph_Index );
506 
507 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
508     psnames = (FT_Service_PsCMaps)face-&gt;psnames;
509     if ( !psnames )
510       return FT_THROW( Unimplemented_Feature );
511 #endif
512 
513     names = &amp;face-&gt;postscript_names;
514 
515     /* `.notdef&#39; by default */
516     *PSname = MAC_NAME( 0 );
517 
518     format = face-&gt;postscript.FormatType;
519 
520     if ( format == 0x00010000L )
521     {
522       if ( idx &lt; 258 )                    /* paranoid checking */
523         *PSname = MAC_NAME( idx );
524     }
525     else if ( format == 0x00020000L )
526     {
527       TT_Post_20  table = &amp;names-&gt;names.format_20;
528 
529 
530       if ( !names-&gt;loaded )
531       {
532         error = load_post_names( face );
533         if ( error )
534           goto End;
535       }
536 
537       if ( idx &lt; (FT_UInt)table-&gt;num_glyphs )
538       {
539         FT_UShort  name_index = table-&gt;glyph_indices[idx];
540 
541 
542         if ( name_index &lt; 258 )
543           *PSname = MAC_NAME( name_index );
544         else
545           *PSname = (FT_String*)table-&gt;glyph_names[name_index - 258];
546       }
547     }
548     else if ( format == 0x00025000L )
549     {
550       TT_Post_25  table = &amp;names-&gt;names.format_25;
551 
552 
553       if ( !names-&gt;loaded )
554       {
555         error = load_post_names( face );
556         if ( error )
557           goto End;
558       }
559 
560       if ( idx &lt; (FT_UInt)table-&gt;num_glyphs )    /* paranoid checking */
561         *PSname = MAC_NAME( (FT_Int)idx + table-&gt;offsets[idx] );
562     }
563 
564     /* nothing to do for format == 0x00030000L */
565 
566   End:
567     return FT_Err_Ok;
568   }
569 
570 #else /* !TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
571 
572   /* ANSI C doesn&#39;t like empty source files */
573   typedef int  _tt_post_dummy;
574 
575 #endif /* !TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
576 
577 
578 /* END */
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/sfdriver.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * sfdriver.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   High-level SFNT driver interface (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 #include FT_INTERNAL_SFNT_H
  22 #include FT_INTERNAL_OBJECTS_H
  23 #include FT_TRUETYPE_IDS_H
  24 
  25 #include &quot;sfdriver.h&quot;
  26 #include &quot;ttload.h&quot;
  27 #include &quot;sfobjs.h&quot;
<a name="2" id="anc2"></a>
  28 
  29 #include &quot;sferrors.h&quot;
  30 
  31 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
  32 #include &quot;ttsbit.h&quot;
  33 #endif
  34 
<a name="3" id="anc3"></a><span class="line-added">  35 #ifdef TT_CONFIG_OPTION_COLOR_LAYERS</span>
<span class="line-added">  36 #include &quot;ttcolr.h&quot;</span>
<span class="line-added">  37 #include &quot;ttcpal.h&quot;</span>
<span class="line-added">  38 #endif</span>
<span class="line-added">  39 </span>
  40 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
  41 #include &quot;ttpost.h&quot;
  42 #endif
  43 
  44 #ifdef TT_CONFIG_OPTION_BDF
  45 #include &quot;ttbdf.h&quot;
  46 #include FT_SERVICE_BDF_H
  47 #endif
  48 
  49 #include &quot;ttcmap.h&quot;
  50 #include &quot;ttkern.h&quot;
  51 #include &quot;ttmtx.h&quot;
  52 
  53 #include FT_SERVICE_GLYPH_DICT_H
  54 #include FT_SERVICE_POSTSCRIPT_NAME_H
  55 #include FT_SERVICE_SFNT_H
  56 #include FT_SERVICE_TT_CMAP_H
  57 
  58 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  59 #include FT_MULTIPLE_MASTERS_H
  60 #include FT_SERVICE_MULTIPLE_MASTERS_H
  61 #endif
  62 
  63 
<a name="4" id="anc4"></a><span class="line-modified">  64   /**************************************************************************</span>
<span class="line-modified">  65    *</span>
<span class="line-modified">  66    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  67    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  68    * messages during execution.</span>
<span class="line-modified">  69    */</span>
  70 #undef  FT_COMPONENT
<a name="5" id="anc5"></a><span class="line-modified">  71 #define FT_COMPONENT  sfdriver</span>
  72 
  73 
  74   /*
<a name="6" id="anc6"></a><span class="line-modified">  75    * SFNT TABLE SERVICE</span>
  76    *
  77    */
  78 
  79   static void*
  80   get_sfnt_table( TT_Face      face,
  81                   FT_Sfnt_Tag  tag )
  82   {
  83     void*  table;
  84 
  85 
  86     switch ( tag )
  87     {
  88     case FT_SFNT_HEAD:
  89       table = &amp;face-&gt;header;
  90       break;
  91 
  92     case FT_SFNT_HHEA:
  93       table = &amp;face-&gt;horizontal;
  94       break;
  95 
  96     case FT_SFNT_VHEA:
  97       table = face-&gt;vertical_info ? &amp;face-&gt;vertical : NULL;
  98       break;
  99 
 100     case FT_SFNT_OS2:
 101       table = ( face-&gt;os2.version == 0xFFFFU ) ? NULL : &amp;face-&gt;os2;
 102       break;
 103 
 104     case FT_SFNT_POST:
 105       table = &amp;face-&gt;postscript;
 106       break;
 107 
 108     case FT_SFNT_MAXP:
 109       table = &amp;face-&gt;max_profile;
 110       break;
 111 
 112     case FT_SFNT_PCLT:
 113       table = face-&gt;pclt.Version ? &amp;face-&gt;pclt : NULL;
 114       break;
 115 
 116     default:
 117       table = NULL;
 118     }
 119 
 120     return table;
 121   }
 122 
 123 
 124   static FT_Error
 125   sfnt_table_info( TT_Face    face,
 126                    FT_UInt    idx,
 127                    FT_ULong  *tag,
 128                    FT_ULong  *offset,
 129                    FT_ULong  *length )
 130   {
 131     if ( !offset || !length )
 132       return FT_THROW( Invalid_Argument );
 133 
 134     if ( !tag )
 135       *length = face-&gt;num_tables;
 136     else
 137     {
 138       if ( idx &gt;= face-&gt;num_tables )
 139         return FT_THROW( Table_Missing );
 140 
 141       *tag    = face-&gt;dir_tables[idx].Tag;
 142       *offset = face-&gt;dir_tables[idx].Offset;
 143       *length = face-&gt;dir_tables[idx].Length;
 144     }
 145 
 146     return FT_Err_Ok;
 147   }
 148 
 149 
 150   FT_DEFINE_SERVICE_SFNT_TABLEREC(
 151     sfnt_service_sfnt_table,
 152 
 153     (FT_SFNT_TableLoadFunc)tt_face_load_any,     /* load_table */
 154     (FT_SFNT_TableGetFunc) get_sfnt_table,       /* get_table  */
 155     (FT_SFNT_TableInfoFunc)sfnt_table_info       /* table_info */
 156   )
 157 
 158 
 159 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 160 
 161   /*
<a name="7" id="anc7"></a><span class="line-modified"> 162    * GLYPH DICT SERVICE</span>
 163    *
 164    */
 165 
 166   static FT_Error
 167   sfnt_get_glyph_name( FT_Face     face,
 168                        FT_UInt     glyph_index,
 169                        FT_Pointer  buffer,
 170                        FT_UInt     buffer_max )
 171   {
 172     FT_String*  gname;
 173     FT_Error    error;
 174 
 175 
 176     error = tt_face_get_ps_name( (TT_Face)face, glyph_index, &amp;gname );
 177     if ( !error )
 178       FT_STRCPYN( buffer, gname, buffer_max );
 179 
 180     return error;
 181   }
 182 
 183 
 184   static FT_UInt
<a name="8" id="anc8"></a><span class="line-modified"> 185   sfnt_get_name_index( FT_Face           face,</span>
<span class="line-modified"> 186                        const FT_String*  glyph_name )</span>
 187   {
 188     TT_Face  ttface = (TT_Face)face;
 189 
 190     FT_UInt  i, max_gid = FT_UINT_MAX;
 191 
 192 
 193     if ( face-&gt;num_glyphs &lt; 0 )
 194       return 0;
 195     else if ( (FT_ULong)face-&gt;num_glyphs &lt; FT_UINT_MAX )
 196       max_gid = (FT_UInt)face-&gt;num_glyphs;
 197     else
 198       FT_TRACE0(( &quot;Ignore glyph names for invalid GID 0x%08x - 0x%08x\n&quot;,
 199                   FT_UINT_MAX, face-&gt;num_glyphs ));
 200 
 201     for ( i = 0; i &lt; max_gid; i++ )
 202     {
 203       FT_String*  gname;
 204       FT_Error    error = tt_face_get_ps_name( ttface, i, &amp;gname );
 205 
 206 
 207       if ( error )
 208         continue;
 209 
 210       if ( !ft_strcmp( glyph_name, gname ) )
 211         return i;
 212     }
 213 
 214     return 0;
 215   }
 216 
 217 
 218   FT_DEFINE_SERVICE_GLYPHDICTREC(
 219     sfnt_service_glyph_dict,
 220 
 221     (FT_GlyphDict_GetNameFunc)  sfnt_get_glyph_name,    /* get_name   */
 222     (FT_GlyphDict_NameIndexFunc)sfnt_get_name_index     /* name_index */
 223   )
 224 
 225 #endif /* TT_CONFIG_OPTION_POSTSCRIPT_NAMES */
 226 
 227 
 228   /*
<a name="9" id="anc9"></a><span class="line-modified"> 229    * POSTSCRIPT NAME SERVICE</span>
 230    *
 231    */
 232 
 233   /* an array representing allowed ASCII characters in a PS string */
 234   static const unsigned char sfnt_ps_map[16] =
 235   {
 236                 /*             4        0        C        8 */
 237     0x00, 0x00, /* 0x00: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 238     0x00, 0x00, /* 0x10: 0 0 0 0  0 0 0 0  0 0 0 0  0 0 0 0 */
 239     0xDE, 0x7C, /* 0x20: 1 1 0 1  1 1 1 0  0 1 1 1  1 1 0 0 */
 240     0xFF, 0xAF, /* 0x30: 1 1 1 1  1 1 1 1  1 0 1 0  1 1 1 1 */
 241     0xFF, 0xFF, /* 0x40: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 242     0xFF, 0xD7, /* 0x50: 1 1 1 1  1 1 1 1  1 1 0 1  0 1 1 1 */
 243     0xFF, 0xFF, /* 0x60: 1 1 1 1  1 1 1 1  1 1 1 1  1 1 1 1 */
 244     0xFF, 0x57  /* 0x70: 1 1 1 1  1 1 1 1  0 1 0 1  0 1 1 1 */
 245   };
 246 
 247 
 248   static int
 249   sfnt_is_postscript( int  c )
 250   {
 251     unsigned int  cc;
 252 
 253 
 254     if ( c &lt; 0 || c &gt;= 0x80 )
 255       return 0;
 256 
 257     cc = (unsigned int)c;
 258 
 259     return sfnt_ps_map[cc &gt;&gt; 3] &amp; ( 1 &lt;&lt; ( cc &amp; 0x07 ) );
 260   }
 261 
 262 
 263 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 264 
 265   /* Only ASCII letters and digits are taken for a variation font */
 266   /* instance&#39;s PostScript name.                                  */
 267   /*                                                              */
 268   /* `ft_isalnum&#39; is a macro, but we need a function here, thus   */
 269   /* this definition.                                             */
 270   static int
 271   sfnt_is_alphanumeric( int  c )
 272   {
 273     return ft_isalnum( c );
 274   }
 275 
 276 
 277   /* the implementation of MurmurHash3 is taken and adapted from          */
 278   /* https://github.com/aappleby/smhasher/blob/master/src/MurmurHash3.cpp */
 279 
 280 #define ROTL32( x, r )  ( x &lt;&lt; r ) | ( x &gt;&gt; ( 32 - r ) )
 281 
 282 
 283   static FT_UInt32
 284   fmix32( FT_UInt32  h )
 285   {
 286     h ^= h &gt;&gt; 16;
 287     h *= 0x85ebca6b;
 288     h ^= h &gt;&gt; 13;
 289     h *= 0xc2b2ae35;
 290     h ^= h &gt;&gt; 16;
 291 
 292     return h;
 293   }
 294 
 295 
 296   static void
 297   murmur_hash_3_128( const void*         key,
 298                      const unsigned int  len,
 299                      FT_UInt32           seed,
 300                      void*               out )
 301   {
 302     const FT_Byte*  data    = (const FT_Byte*)key;
 303     const int       nblocks = (int)len / 16;
 304 
 305     FT_UInt32  h1 = seed;
 306     FT_UInt32  h2 = seed;
 307     FT_UInt32  h3 = seed;
 308     FT_UInt32  h4 = seed;
 309 
 310     const FT_UInt32  c1 = 0x239b961b;
 311     const FT_UInt32  c2 = 0xab0e9789;
 312     const FT_UInt32  c3 = 0x38b34ae5;
 313     const FT_UInt32  c4 = 0xa1e38b93;
 314 
 315     const FT_UInt32*  blocks = (const FT_UInt32*)( data + nblocks * 16 );
 316 
 317     int  i;
 318 
 319 
 320     for( i = -nblocks; i; i++ )
 321     {
 322       FT_UInt32  k1 = blocks[i * 4 + 0];
 323       FT_UInt32  k2 = blocks[i * 4 + 1];
 324       FT_UInt32  k3 = blocks[i * 4 + 2];
 325       FT_UInt32  k4 = blocks[i * 4 + 3];
 326 
 327 
 328       k1 *= c1;
 329       k1  = ROTL32( k1, 15 );
 330       k1 *= c2;
 331       h1 ^= k1;
 332 
 333       h1  = ROTL32( h1, 19 );
 334       h1 += h2;
 335       h1  = h1 * 5 + 0x561ccd1b;
 336 
 337       k2 *= c2;
 338       k2  = ROTL32( k2, 16 );
 339       k2 *= c3;
 340       h2 ^= k2;
 341 
 342       h2  = ROTL32( h2, 17 );
 343       h2 += h3;
 344       h2  = h2 * 5 + 0x0bcaa747;
 345 
 346       k3 *= c3;
 347       k3  = ROTL32( k3, 17 );
 348       k3 *= c4;
 349       h3 ^= k3;
 350 
 351       h3  = ROTL32( h3, 15 );
 352       h3 += h4;
 353       h3  = h3 * 5 + 0x96cd1c35;
 354 
 355       k4 *= c4;
 356       k4  = ROTL32( k4, 18 );
 357       k4 *= c1;
 358       h4 ^= k4;
 359 
 360       h4  = ROTL32( h4, 13 );
 361       h4 += h1;
 362       h4  = h4 * 5 + 0x32ac3b17;
 363     }
 364 
 365     {
 366       const FT_Byte*  tail = (const FT_Byte*)( data + nblocks * 16 );
 367 
 368       FT_UInt32  k1 = 0;
 369       FT_UInt32  k2 = 0;
 370       FT_UInt32  k3 = 0;
 371       FT_UInt32  k4 = 0;
 372 
 373 
 374       switch ( len &amp; 15 )
 375       {
 376       case 15:
 377         k4 ^= (FT_UInt32)tail[14] &lt;&lt; 16;
<a name="10" id="anc10"></a><span class="line-added"> 378         /* fall through */</span>
 379       case 14:
 380         k4 ^= (FT_UInt32)tail[13] &lt;&lt; 8;
<a name="11" id="anc11"></a><span class="line-added"> 381         /* fall through */</span>
 382       case 13:
 383         k4 ^= (FT_UInt32)tail[12];
 384         k4 *= c4;
 385         k4  = ROTL32( k4, 18 );
 386         k4 *= c1;
 387         h4 ^= k4;
<a name="12" id="anc12"></a><span class="line-added"> 388         /* fall through */</span>
 389 
 390       case 12:
 391         k3 ^= (FT_UInt32)tail[11] &lt;&lt; 24;
<a name="13" id="anc13"></a><span class="line-added"> 392         /* fall through */</span>
 393       case 11:
 394         k3 ^= (FT_UInt32)tail[10] &lt;&lt; 16;
<a name="14" id="anc14"></a><span class="line-added"> 395         /* fall through */</span>
 396       case 10:
 397         k3 ^= (FT_UInt32)tail[9] &lt;&lt; 8;
<a name="15" id="anc15"></a><span class="line-added"> 398         /* fall through */</span>
 399       case 9:
 400         k3 ^= (FT_UInt32)tail[8];
 401         k3 *= c3;
 402         k3  = ROTL32( k3, 17 );
 403         k3 *= c4;
 404         h3 ^= k3;
<a name="16" id="anc16"></a><span class="line-added"> 405         /* fall through */</span>
 406 
 407       case 8:
 408         k2 ^= (FT_UInt32)tail[7] &lt;&lt; 24;
<a name="17" id="anc17"></a><span class="line-added"> 409         /* fall through */</span>
 410       case 7:
 411         k2 ^= (FT_UInt32)tail[6] &lt;&lt; 16;
<a name="18" id="anc18"></a><span class="line-added"> 412         /* fall through */</span>
 413       case 6:
 414         k2 ^= (FT_UInt32)tail[5] &lt;&lt; 8;
<a name="19" id="anc19"></a><span class="line-added"> 415         /* fall through */</span>
 416       case 5:
 417         k2 ^= (FT_UInt32)tail[4];
 418         k2 *= c2;
 419         k2  = ROTL32( k2, 16 );
 420         k2 *= c3;
 421         h2 ^= k2;
<a name="20" id="anc20"></a><span class="line-added"> 422         /* fall through */</span>
 423 
 424       case 4:
 425         k1 ^= (FT_UInt32)tail[3] &lt;&lt; 24;
<a name="21" id="anc21"></a><span class="line-added"> 426         /* fall through */</span>
 427       case 3:
 428         k1 ^= (FT_UInt32)tail[2] &lt;&lt; 16;
<a name="22" id="anc22"></a><span class="line-added"> 429         /* fall through */</span>
 430       case 2:
 431         k1 ^= (FT_UInt32)tail[1] &lt;&lt; 8;
<a name="23" id="anc23"></a><span class="line-added"> 432         /* fall through */</span>
 433       case 1:
 434         k1 ^= (FT_UInt32)tail[0];
 435         k1 *= c1;
 436         k1  = ROTL32( k1, 15 );
 437         k1 *= c2;
 438         h1 ^= k1;
 439       }
 440     }
 441 
 442     h1 ^= len;
 443     h2 ^= len;
 444     h3 ^= len;
 445     h4 ^= len;
 446 
 447     h1 += h2;
 448     h1 += h3;
 449     h1 += h4;
 450 
 451     h2 += h1;
 452     h3 += h1;
 453     h4 += h1;
 454 
 455     h1 = fmix32( h1 );
 456     h2 = fmix32( h2 );
 457     h3 = fmix32( h3 );
 458     h4 = fmix32( h4 );
 459 
 460     h1 += h2;
 461     h1 += h3;
 462     h1 += h4;
 463 
 464     h2 += h1;
 465     h3 += h1;
 466     h4 += h1;
 467 
 468     ((FT_UInt32*)out)[0] = h1;
 469     ((FT_UInt32*)out)[1] = h2;
 470     ((FT_UInt32*)out)[2] = h3;
 471     ((FT_UInt32*)out)[3] = h4;
 472   }
 473 
 474 
 475 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
 476 
 477 
 478   typedef int (*char_type_func)( int  c );
 479 
 480 
<a name="24" id="anc24"></a><span class="line-modified"> 481   /* Handling of PID/EID 3/0 and 3/1 is the same. */</span>
 482 #define IS_WIN( n )  ( (n)-&gt;platformID == 3                             &amp;&amp; \
<a name="25" id="anc25"></a><span class="line-modified"> 483                        ( (n)-&gt;encodingID == 1 || (n)-&gt;encodingID == 0 ) )</span>

 484 
 485 #define IS_APPLE( n )  ( (n)-&gt;platformID == 1 &amp;&amp; \
<a name="26" id="anc26"></a><span class="line-modified"> 486                          (n)-&gt;encodingID == 0 )</span>

 487 
 488   static char*
 489   get_win_string( FT_Memory       memory,
 490                   FT_Stream       stream,
 491                   TT_Name         entry,
 492                   char_type_func  char_type,
 493                   FT_Bool         report_invalid_characters )
 494   {
 495     FT_Error  error = FT_Err_Ok;
 496 
 497     char*       result = NULL;
 498     FT_String*  r;
 499     FT_Char*    p;
 500     FT_UInt     len;
 501 
 502     FT_UNUSED( error );
 503 
 504 
 505     if ( FT_ALLOC( result, entry-&gt;stringLength / 2 + 1 ) )
 506       return NULL;
 507 
 508     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 509          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<a name="27" id="anc27"></a><span class="line-modified"> 510       goto get_win_string_error;</span>







 511 
 512     r = (FT_String*)result;
 513     p = (FT_Char*)stream-&gt;cursor;
 514 
 515     for ( len = entry-&gt;stringLength / 2; len &gt; 0; len--, p += 2 )
 516     {
<a name="28" id="anc28"></a><span class="line-modified"> 517       if ( p[0] == 0 &amp;&amp; char_type( p[1] ) )</span>
<span class="line-added"> 518         *r++ = p[1];</span>
<span class="line-added"> 519       else</span>
 520       {
<a name="29" id="anc29"></a><span class="line-modified"> 521         if ( report_invalid_characters )</span>
<span class="line-modified"> 522           FT_TRACE0(( &quot;get_win_string:&quot;</span>
<span class="line-modified"> 523                       &quot; Character 0x%X invalid in PS name string\n&quot;,</span>
<span class="line-modified"> 524                       ((unsigned)p[0])*256 + (unsigned)p[1] ));</span>
<span class="line-modified"> 525         break;</span>








 526       }
 527     }
<a name="30" id="anc30"></a><span class="line-modified"> 528     if ( !len )</span>
<span class="line-added"> 529       *r = &#39;\0&#39;;</span>
 530 
 531     FT_FRAME_EXIT();
 532 
<a name="31" id="anc31"></a><span class="line-modified"> 533     if ( !len )</span>
<span class="line-added"> 534       return result;</span>
<span class="line-added"> 535 </span>
<span class="line-added"> 536   get_win_string_error:</span>
<span class="line-added"> 537     FT_FREE( result );</span>
<span class="line-added"> 538 </span>
<span class="line-added"> 539     entry-&gt;stringLength = 0;</span>
<span class="line-added"> 540     entry-&gt;stringOffset = 0;</span>
<span class="line-added"> 541     FT_FREE( entry-&gt;string );</span>
<span class="line-added"> 542 </span>
<span class="line-added"> 543     return NULL;</span>
 544   }
 545 
 546 
 547   static char*
 548   get_apple_string( FT_Memory       memory,
 549                     FT_Stream       stream,
 550                     TT_Name         entry,
 551                     char_type_func  char_type,
 552                     FT_Bool         report_invalid_characters )
 553   {
 554     FT_Error  error = FT_Err_Ok;
 555 
 556     char*       result = NULL;
 557     FT_String*  r;
 558     FT_Char*    p;
 559     FT_UInt     len;
 560 
 561     FT_UNUSED( error );
 562 
 563 
 564     if ( FT_ALLOC( result, entry-&gt;stringLength + 1 ) )
 565       return NULL;
 566 
 567     if ( FT_STREAM_SEEK( entry-&gt;stringOffset ) ||
 568          FT_FRAME_ENTER( entry-&gt;stringLength ) )
<a name="32" id="anc32"></a><span class="line-modified"> 569       goto get_apple_string_error;</span>







 570 
 571     r = (FT_String*)result;
 572     p = (FT_Char*)stream-&gt;cursor;
 573 
 574     for ( len = entry-&gt;stringLength; len &gt; 0; len--, p++ )
 575     {
 576       if ( char_type( *p ) )
 577         *r++ = *p;
 578       else
 579       {
 580         if ( report_invalid_characters )
<a name="33" id="anc33"></a>
 581           FT_TRACE0(( &quot;get_apple_string:&quot;
 582                       &quot; Character `%c&#39; (0x%X) invalid in PS name string\n&quot;,
 583                       *p, *p ));
<a name="34" id="anc34"></a><span class="line-modified"> 584         break;</span>


 585       }
 586     }
<a name="35" id="anc35"></a><span class="line-modified"> 587     if ( !len )</span>
<span class="line-added"> 588       *r = &#39;\0&#39;;</span>
 589 
 590     FT_FRAME_EXIT();
 591 
<a name="36" id="anc36"></a><span class="line-modified"> 592     if ( !len )</span>
<span class="line-added"> 593       return result;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595   get_apple_string_error:</span>
<span class="line-added"> 596     FT_FREE( result );</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     entry-&gt;stringOffset = 0;</span>
<span class="line-added"> 599     entry-&gt;stringLength = 0;</span>
<span class="line-added"> 600     FT_FREE( entry-&gt;string );</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602     return NULL;</span>
 603   }
 604 
 605 
 606   static FT_Bool
 607   sfnt_get_name_id( TT_Face    face,
 608                     FT_UShort  id,
 609                     FT_Int    *win,
 610                     FT_Int    *apple )
 611   {
 612     FT_Int  n;
 613 
 614 
 615     *win   = -1;
 616     *apple = -1;
 617 
 618     for ( n = 0; n &lt; face-&gt;num_names; n++ )
 619     {
 620       TT_Name  name = face-&gt;name_table.names + n;
 621 
 622 
 623       if ( name-&gt;nameID == id &amp;&amp; name-&gt;stringLength &gt; 0 )
 624       {
<a name="37" id="anc37"></a><span class="line-modified"> 625         if ( IS_WIN( name ) &amp;&amp; ( name-&gt;languageID == 0x409 || *win == -1 ) )</span>
 626           *win = n;
 627 
<a name="38" id="anc38"></a><span class="line-modified"> 628         if ( IS_APPLE( name ) &amp;&amp; ( name-&gt;languageID == 0 || *apple == -1 ) )</span>
 629           *apple = n;
 630       }
 631     }
 632 
 633     return ( *win &gt;= 0 ) || ( *apple &gt;= 0 );
 634   }
 635 
 636 
 637 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 638 
 639   /*
 640       The maximum length of an axis value descriptor.
 641 
 642       We need 65536 different values for the decimal fraction; this fits
 643       nicely into five decimal places.  Consequently, it consists of
 644 
 645         . the minus sign if the number is negative,
 646         . up to five characters for the digits before the decimal point,
 647         . the decimal point if there is a fractional part, and
 648         . up to five characters for the digits after the decimal point.
 649 
 650       We also need one byte for the leading `_&#39; character and up to four
 651       bytes for the axis tag.
 652    */
 653 #define MAX_VALUE_DESCRIPTOR_LEN  ( 1 + 5 + 1 + 5 + 1 + 4 )
 654 
 655 
 656   /* the maximum length of PostScript font names */
 657 #define MAX_PS_NAME_LEN  127
 658 
 659 
 660   /*
<a name="39" id="anc39"></a><span class="line-modified"> 661    * Find the shortest decimal representation of a 16.16 fixed point</span>
<span class="line-modified"> 662    * number.  The function fills `buf&#39; with the result, returning a pointer</span>
<span class="line-modified"> 663    * to the position after the representation&#39;s last byte.</span>
 664    */
 665 
 666   static char*
 667   fixed2float( FT_Int  fixed,
 668                char*   buf )
 669   {
 670     char*  p;
 671     char*  q;
 672     char   tmp[5];
 673 
 674     FT_Int  int_part;
 675     FT_Int  frac_part;
 676 
 677     FT_Int  i;
 678 
 679 
 680     p = buf;
 681 
 682     if ( fixed == 0 )
 683     {
 684       *p++ = &#39;0&#39;;
 685       return p;
 686     }
 687 
 688     if ( fixed &lt; 0 )
 689     {
 690       *p++ = &#39;-&#39;;
<a name="40" id="anc40"></a><span class="line-modified"> 691       fixed = NEG_INT( fixed );</span>
 692     }
 693 
 694     int_part  = ( fixed &gt;&gt; 16 ) &amp; 0xFFFF;
 695     frac_part = fixed &amp; 0xFFFF;
 696 
 697     /* get digits of integer part (in reverse order) */
 698     q = tmp;
 699     while ( int_part &gt; 0 )
 700     {
 701       *q++      = &#39;0&#39; + int_part % 10;
 702       int_part /= 10;
 703     }
 704 
 705     /* copy digits in correct order to buffer */
 706     while ( q &gt; tmp )
 707       *p++ = *--q;
 708 
 709     if ( !frac_part )
 710       return p;
 711 
 712     /* save position of point */
 713     q    = p;
 714     *p++ = &#39;.&#39;;
 715 
 716     /* apply rounding */
 717     frac_part = frac_part * 10 + 5;
 718 
 719     /* get digits of fractional part */
 720     for ( i = 0; i &lt; 5; i++ )
 721     {
 722       *p++ = &#39;0&#39; + (char)( frac_part / 0x10000L );
 723 
 724       frac_part %= 0x10000L;
 725       if ( !frac_part )
 726         break;
 727 
 728       frac_part *= 10;
 729     }
 730 
 731     /*
 732         If the remainder stored in `frac_part&#39; (after the last FOR loop) is
 733         smaller than 34480*10, the resulting decimal value minus 0.00001 is
 734         an equivalent representation of `fixed&#39;.
 735 
 736         The above FOR loop always finds the larger of the two values; I
 737         verified this by iterating over all possible fixed point numbers.
 738 
 739         If the remainder is 17232*10, both values are equally good, and we
 740         take the next even number (following IEEE 754&#39;s `round to nearest,
 741         ties to even&#39; rounding rule).
 742 
 743         If the remainder is smaller than 17232*10, the lower of the two
 744         numbers is nearer to the exact result (values 17232 and 34480 were
 745         also found by testing all possible fixed point values).
 746 
 747         We use this to find a shorter decimal representation.  If not ending
 748         with digit zero, we take the representation with less error.
 749      */
 750     p--;
 751     if ( p - q == 5 )  /* five digits? */
 752     {
 753       /* take the representation that has zero as the last digit */
 754       if ( frac_part &lt; 34480 * 10 &amp;&amp;
 755            *p == &#39;1&#39;              )
 756         *p = &#39;0&#39;;
 757 
 758       /* otherwise use the one with less error */
 759       else if ( frac_part == 17232 * 10 &amp;&amp;
 760                 *p &amp; 1                  )
 761         *p -= 1;
 762 
 763       else if ( frac_part &lt; 17232 * 10 &amp;&amp;
 764                 *p != &#39;0&#39;              )
 765         *p -= 1;
 766     }
 767 
 768     /* remove trailing zeros */
 769     while ( *p == &#39;0&#39; )
 770       *p-- = &#39;\0&#39;;
 771 
 772     return p + 1;
 773   }
 774 
 775 
 776   static const char  hexdigits[16] =
 777   {
 778     &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;,
 779     &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;
 780   };
 781 
 782 
 783   static const char*
 784   sfnt_get_var_ps_name( TT_Face  face )
 785   {
 786     FT_Error   error;
 787     FT_Memory  memory = face-&gt;root.memory;
 788 
 789     FT_Service_MultiMasters  mm = (FT_Service_MultiMasters)face-&gt;mm;
 790 
 791     FT_UInt     num_coords;
 792     FT_Fixed*   coords;
 793     FT_MM_Var*  mm_var;
 794 
 795     FT_Int   found, win, apple;
 796     FT_UInt  i, j;
 797 
 798     char*  result = NULL;
 799     char*  p;
 800 
 801 
 802     if ( !face-&gt;var_postscript_prefix )
 803     {
 804       FT_UInt  len;
 805 
 806 
 807       /* check whether we have a Variations PostScript Name Prefix */
 808       found = sfnt_get_name_id( face,
 809                                 TT_NAME_ID_VARIATIONS_PREFIX,
 810                                 &amp;win,
 811                                 &amp;apple );
 812       if ( !found )
 813       {
 814         /* otherwise use the typographic family name */
 815         found = sfnt_get_name_id( face,
 816                                   TT_NAME_ID_TYPOGRAPHIC_FAMILY,
 817                                   &amp;win,
 818                                   &amp;apple );
 819       }
 820 
 821       if ( !found )
 822       {
 823         /* as a last resort we try the family name; note that this is */
 824         /* not in the Adobe TechNote, but GX fonts (which predate the */
 825         /* TechNote) benefit from this behaviour                      */
 826         found = sfnt_get_name_id( face,
 827                                   TT_NAME_ID_FONT_FAMILY,
 828                                   &amp;win,
 829                                   &amp;apple );
 830       }
 831 
 832       if ( !found )
 833       {
 834         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 835                     &quot; Can&#39;t construct PS name prefix for font instances\n&quot; ));
 836         return NULL;
 837       }
 838 
 839       /* prefer Windows entries over Apple */
 840       if ( win != -1 )
 841         result = get_win_string( face-&gt;root.memory,
 842                                  face-&gt;name_table.stream,
 843                                  face-&gt;name_table.names + win,
 844                                  sfnt_is_alphanumeric,
 845                                  0 );
<a name="41" id="anc41"></a><span class="line-modified"> 846       if ( !result &amp;&amp; apple != -1 )</span>
 847         result = get_apple_string( face-&gt;root.memory,
 848                                    face-&gt;name_table.stream,
 849                                    face-&gt;name_table.names + apple,
 850                                    sfnt_is_alphanumeric,
 851                                    0 );
 852 
<a name="42" id="anc42"></a><span class="line-added"> 853       if ( !result )</span>
<span class="line-added"> 854       {</span>
<span class="line-added"> 855         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;</span>
<span class="line-added"> 856                     &quot; No valid PS name prefix for font instances found\n&quot; ));</span>
<span class="line-added"> 857         return NULL;</span>
<span class="line-added"> 858       }</span>
<span class="line-added"> 859 </span>
 860       len = ft_strlen( result );
 861 
 862       /* sanitize if necessary; we reserve space for 36 bytes (a 128bit  */
 863       /* checksum as a hex number, preceded by `-&#39; and followed by three */
 864       /* ASCII dots, to be used if the constructed PS name would be too  */
 865       /* long); this is also sufficient for a single instance            */
 866       if ( len &gt; MAX_PS_NAME_LEN - ( 1 + 32 + 3 ) )
 867       {
 868         len         = MAX_PS_NAME_LEN - ( 1 + 32 + 3 );
 869         result[len] = &#39;\0&#39;;
 870 
 871         FT_TRACE0(( &quot;sfnt_get_var_ps_name:&quot;
 872                     &quot; Shortening variation PS name prefix\n&quot;
 873                     &quot;                     &quot;
 874                     &quot; to %d characters\n&quot;, len ));
 875       }
 876 
 877       face-&gt;var_postscript_prefix     = result;
 878       face-&gt;var_postscript_prefix_len = len;
 879     }
 880 
 881     mm-&gt;get_var_blend( FT_FACE( face ),
 882                        &amp;num_coords,
 883                        &amp;coords,
 884                        NULL,
 885                        &amp;mm_var );
 886 
 887     if ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) &amp;&amp;
 888          !FT_IS_VARIATION( FT_FACE( face ) )     )
 889     {
 890       SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;
 891 
 892       FT_Long  instance = ( ( face-&gt;root.face_index &amp; 0x7FFF0000L ) &gt;&gt; 16 ) - 1;
 893       FT_UInt  psid     = mm_var-&gt;namedstyle[instance].psid;
 894 
 895       char*  ps_name = NULL;
 896 
 897 
 898       /* try first to load the name string with index `postScriptNameID&#39; */
 899       if ( psid == 6                      ||
 900            ( psid &gt; 255 &amp;&amp; psid &lt; 32768 ) )
 901         (void)sfnt-&gt;get_name( face, (FT_UShort)psid, &amp;ps_name );
 902 
 903       if ( ps_name )
 904       {
 905         result = ps_name;
 906         p      = result + ft_strlen( result ) + 1;
 907 
 908         goto check_length;
 909       }
 910       else
 911       {
 912         /* otherwise construct a name using `subfamilyNameID&#39; */
 913         FT_UInt  strid = mm_var-&gt;namedstyle[instance].strid;
 914 
 915         char*  subfamily_name;
 916         char*  s;
 917 
 918 
 919         (void)sfnt-&gt;get_name( face, (FT_UShort)strid, &amp;subfamily_name );
 920 
 921         if ( !subfamily_name )
 922         {
 923           FT_TRACE1(( &quot;sfnt_get_var_ps_name:&quot;
 924                       &quot; can&#39;t construct named instance PS name;\n&quot;
 925                       &quot;                     &quot;
 926                       &quot; trying to construct normal instance PS name\n&quot; ));
 927           goto construct_instance_name;
 928         }
 929 
 930         /* after the prefix we have character `-&#39; followed by the   */
 931         /* subfamily name (using only characters a-z, A-Z, and 0-9) */
 932         if ( FT_ALLOC( result, face-&gt;var_postscript_prefix_len +
 933                                1 + ft_strlen( subfamily_name ) + 1 ) )
 934           return NULL;
 935 
 936         ft_strcpy( result, face-&gt;var_postscript_prefix );
 937 
 938         p = result + face-&gt;var_postscript_prefix_len;
 939         *p++ = &#39;-&#39;;
 940 
 941         s = subfamily_name;
 942         while ( *s )
 943         {
 944           if ( ft_isalnum( *s ) )
 945             *p++ = *s;
 946           s++;
 947         }
 948         *p++ = &#39;\0&#39;;
 949 
 950         FT_FREE( subfamily_name );
 951       }
 952     }
 953     else
 954     {
 955       FT_Var_Axis*  axis;
 956 
 957 
 958     construct_instance_name:
 959       axis = mm_var-&gt;axis;
 960 
 961       if ( FT_ALLOC( result,
 962                      face-&gt;var_postscript_prefix_len +
 963                        num_coords * MAX_VALUE_DESCRIPTOR_LEN + 1 ) )
 964         return NULL;
 965 
 966       p = result;
 967 
 968       ft_strcpy( p, face-&gt;var_postscript_prefix );
 969       p += face-&gt;var_postscript_prefix_len;
 970 
 971       for ( i = 0; i &lt; num_coords; i++, coords++, axis++ )
 972       {
 973         char  t;
 974 
 975 
 976         /* omit axis value descriptor if it is identical */
 977         /* to the default axis value                     */
 978         if ( *coords == axis-&gt;def )
 979           continue;
 980 
 981         *p++ = &#39;_&#39;;
 982         p    = fixed2float( *coords, p );
 983 
 984         t = (char)( axis-&gt;tag &gt;&gt; 24 );
 985         if ( t != &#39; &#39; &amp;&amp; ft_isalnum( t ) )
 986           *p++ = t;
 987         t = (char)( axis-&gt;tag &gt;&gt; 16 );
 988         if ( t != &#39; &#39; &amp;&amp; ft_isalnum( t ) )
 989           *p++ = t;
 990         t = (char)( axis-&gt;tag &gt;&gt; 8 );
 991         if ( t != &#39; &#39; &amp;&amp; ft_isalnum( t ) )
 992           *p++ = t;
 993         t = (char)axis-&gt;tag;
 994         if ( t != &#39; &#39; &amp;&amp; ft_isalnum( t ) )
 995           *p++ = t;
 996       }
 997     }
 998 
 999   check_length:
1000     if ( p - result &gt; MAX_PS_NAME_LEN )
1001     {
1002       /* the PS name is too long; replace the part after the prefix with */
1003       /* a checksum; we use MurmurHash 3 with a hash length of 128 bit   */
1004 
1005       FT_UInt32  seed = 123456789;
1006 
1007       FT_UInt32   hash[4];
1008       FT_UInt32*  h;
1009 
1010 
1011       murmur_hash_3_128( result, p - result, seed, hash );
1012 
1013       p = result + face-&gt;var_postscript_prefix_len;
1014       *p++ = &#39;-&#39;;
1015 
1016       /* we convert the hash value to hex digits from back to front */
1017       p += 32 + 3;
1018       h  = hash + 3;
1019 
1020       *p-- = &#39;\0&#39;;
1021       *p-- = &#39;.&#39;;
1022       *p-- = &#39;.&#39;;
1023       *p-- = &#39;.&#39;;
1024 
1025       for ( i = 0; i &lt; 4; i++, h-- )
1026       {
1027         FT_UInt32  v = *h;
1028 
1029 
1030         for ( j = 0; j &lt; 8; j++ )
1031         {
1032           *p--   = hexdigits[v &amp; 0xF];
1033           v    &gt;&gt;= 4;
1034         }
1035       }
1036     }
1037 
1038     return result;
1039   }
1040 
1041 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
1042 
1043 
1044   static const char*
1045   sfnt_get_ps_name( TT_Face  face )
1046   {
1047     FT_Int       found, win, apple;
1048     const char*  result = NULL;
1049 
1050 
1051     if ( face-&gt;postscript_name )
1052       return face-&gt;postscript_name;
1053 
1054 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1055     if ( face-&gt;blend                                 &amp;&amp;
1056          ( FT_IS_NAMED_INSTANCE( FT_FACE( face ) ) ||
1057            FT_IS_VARIATION( FT_FACE( face ) )      ) )
1058     {
1059       face-&gt;postscript_name = sfnt_get_var_ps_name( face );
1060       return face-&gt;postscript_name;
1061     }
1062 #endif
1063 
1064     /* scan the name table to see whether we have a Postscript name here, */
1065     /* either in Macintosh or Windows platform encodings                  */
1066     found = sfnt_get_name_id( face, TT_NAME_ID_PS_NAME, &amp;win, &amp;apple );
1067     if ( !found )
1068       return NULL;
1069 
1070     /* prefer Windows entries over Apple */
1071     if ( win != -1 )
1072       result = get_win_string( face-&gt;root.memory,
1073                                face-&gt;name_table.stream,
1074                                face-&gt;name_table.names + win,
1075                                sfnt_is_postscript,
1076                                1 );
<a name="43" id="anc43"></a><span class="line-modified">1077     if ( !result &amp;&amp; apple != -1 )</span>
1078       result = get_apple_string( face-&gt;root.memory,
1079                                  face-&gt;name_table.stream,
1080                                  face-&gt;name_table.names + apple,
1081                                  sfnt_is_postscript,
1082                                  1 );
1083 
1084     face-&gt;postscript_name = result;
1085 
1086     return result;
1087   }
1088 
1089 
1090   FT_DEFINE_SERVICE_PSFONTNAMEREC(
1091     sfnt_service_ps_name,
1092 
1093     (FT_PsName_GetFunc)sfnt_get_ps_name       /* get_ps_font_name */
1094   )
1095 
1096 
1097   /*
<a name="44" id="anc44"></a><span class="line-modified">1098    * TT CMAP INFO</span>
1099    */
1100   FT_DEFINE_SERVICE_TTCMAPSREC(
1101     tt_service_get_cmap_info,
1102 
1103     (TT_CMap_Info_GetFunc)tt_get_cmap_info    /* get_cmap_info */
1104   )
1105 
1106 
1107 #ifdef TT_CONFIG_OPTION_BDF
1108 
1109   static FT_Error
1110   sfnt_get_charset_id( TT_Face       face,
1111                        const char*  *acharset_encoding,
1112                        const char*  *acharset_registry )
1113   {
1114     BDF_PropertyRec  encoding, registry;
1115     FT_Error         error;
1116 
1117 
1118     /* XXX: I don&#39;t know whether this is correct, since
1119      *      tt_face_find_bdf_prop only returns something correct if we have
1120      *      previously selected a size that is listed in the BDF table.
1121      *      Should we change the BDF table format to include single offsets
1122      *      for `CHARSET_REGISTRY&#39; and `CHARSET_ENCODING&#39;?
1123      */
1124     error = tt_face_find_bdf_prop( face, &quot;CHARSET_REGISTRY&quot;, &amp;registry );
1125     if ( !error )
1126     {
1127       error = tt_face_find_bdf_prop( face, &quot;CHARSET_ENCODING&quot;, &amp;encoding );
1128       if ( !error )
1129       {
1130         if ( registry.type == BDF_PROPERTY_TYPE_ATOM &amp;&amp;
1131              encoding.type == BDF_PROPERTY_TYPE_ATOM )
1132         {
1133           *acharset_encoding = encoding.u.atom;
1134           *acharset_registry = registry.u.atom;
1135         }
1136         else
1137           error = FT_THROW( Invalid_Argument );
1138       }
1139     }
1140 
1141     return error;
1142   }
1143 
1144 
1145   FT_DEFINE_SERVICE_BDFRec(
1146     sfnt_service_bdf,
1147 
1148     (FT_BDF_GetCharsetIdFunc)sfnt_get_charset_id,     /* get_charset_id */
1149     (FT_BDF_GetPropertyFunc) tt_face_find_bdf_prop    /* get_property   */
1150   )
1151 
1152 
1153 #endif /* TT_CONFIG_OPTION_BDF */
1154 
1155 
1156   /*
<a name="45" id="anc45"></a><span class="line-modified">1157    * SERVICE LIST</span>
1158    */
1159 
1160 #if defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES &amp;&amp; defined TT_CONFIG_OPTION_BDF
1161   FT_DEFINE_SERVICEDESCREC5(
1162     sfnt_services,
1163 
<a name="46" id="anc46"></a><span class="line-modified">1164     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1165     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1166     FT_SERVICE_ID_GLYPH_DICT,           &amp;sfnt_service_glyph_dict,</span>
<span class="line-modified">1167     FT_SERVICE_ID_BDF,                  &amp;sfnt_service_bdf,</span>
<span class="line-modified">1168     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1169 #elif defined TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1170   FT_DEFINE_SERVICEDESCREC4(
1171     sfnt_services,
1172 
<a name="47" id="anc47"></a><span class="line-modified">1173     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1174     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1175     FT_SERVICE_ID_GLYPH_DICT,           &amp;sfnt_service_glyph_dict,</span>
<span class="line-modified">1176     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1177 #elif defined TT_CONFIG_OPTION_BDF
1178   FT_DEFINE_SERVICEDESCREC4(
1179     sfnt_services,
1180 
<a name="48" id="anc48"></a><span class="line-modified">1181     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1182     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1183     FT_SERVICE_ID_BDF,                  &amp;sfnt_service_bdf,</span>
<span class="line-modified">1184     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1185 #else
1186   FT_DEFINE_SERVICEDESCREC3(
1187     sfnt_services,
1188 
<a name="49" id="anc49"></a><span class="line-modified">1189     FT_SERVICE_ID_SFNT_TABLE,           &amp;sfnt_service_sfnt_table,</span>
<span class="line-modified">1190     FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;sfnt_service_ps_name,</span>
<span class="line-modified">1191     FT_SERVICE_ID_TT_CMAP,              &amp;tt_service_get_cmap_info )</span>
1192 #endif
1193 
1194 
1195   FT_CALLBACK_DEF( FT_Module_Interface )
1196   sfnt_get_interface( FT_Module    module,
1197                       const char*  module_interface )
1198   {
<a name="50" id="anc50"></a>










1199     FT_UNUSED( module );
<a name="51" id="anc51"></a>
1200 
<a name="52" id="anc52"></a><span class="line-modified">1201     return ft_service_list_lookup( sfnt_services, module_interface );</span>
1202   }
1203 
1204 
1205 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1206 #define PUT_EMBEDDED_BITMAPS( a )  a
1207 #else
1208 #define PUT_EMBEDDED_BITMAPS( a )  NULL
1209 #endif
1210 
<a name="53" id="anc53"></a><span class="line-added">1211 #ifdef TT_CONFIG_OPTION_COLOR_LAYERS</span>
<span class="line-added">1212 #define PUT_COLOR_LAYERS( a )  a</span>
<span class="line-added">1213 #else</span>
<span class="line-added">1214 #define PUT_COLOR_LAYERS( a )  NULL</span>
<span class="line-added">1215 #endif</span>
<span class="line-added">1216 </span>
1217 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1218 #define PUT_PS_NAMES( a )  a
1219 #else
1220 #define PUT_PS_NAMES( a )  NULL
1221 #endif
1222 
1223   FT_DEFINE_SFNT_INTERFACE(
1224     sfnt_interface,
1225 
1226     tt_face_goto_table,     /* TT_Loader_GotoTableFunc goto_table      */
1227 
1228     sfnt_init_face,         /* TT_Init_Face_Func       init_face       */
1229     sfnt_load_face,         /* TT_Load_Face_Func       load_face       */
1230     sfnt_done_face,         /* TT_Done_Face_Func       done_face       */
1231     sfnt_get_interface,     /* FT_Module_Requester     get_interface   */
1232 
1233     tt_face_load_any,       /* TT_Load_Any_Func        load_any        */
1234 
1235     tt_face_load_head,      /* TT_Load_Table_Func      load_head       */
1236     tt_face_load_hhea,      /* TT_Load_Metrics_Func    load_hhea       */
1237     tt_face_load_cmap,      /* TT_Load_Table_Func      load_cmap       */
1238     tt_face_load_maxp,      /* TT_Load_Table_Func      load_maxp       */
1239     tt_face_load_os2,       /* TT_Load_Table_Func      load_os2        */
1240     tt_face_load_post,      /* TT_Load_Table_Func      load_post       */
1241 
1242     tt_face_load_name,      /* TT_Load_Table_Func      load_name       */
1243     tt_face_free_name,      /* TT_Free_Table_Func      free_name       */
1244 
1245     tt_face_load_kern,      /* TT_Load_Table_Func      load_kern       */
1246     tt_face_load_gasp,      /* TT_Load_Table_Func      load_gasp       */
1247     tt_face_load_pclt,      /* TT_Load_Table_Func      load_init       */
1248 
1249     /* see `ttload.h&#39; */
1250     PUT_EMBEDDED_BITMAPS( tt_face_load_bhed ),
1251                             /* TT_Load_Table_Func      load_bhed       */
1252     PUT_EMBEDDED_BITMAPS( tt_face_load_sbit_image ),
1253                             /* TT_Load_SBit_Image_Func load_sbit_image */
1254 
1255     /* see `ttpost.h&#39; */
1256     PUT_PS_NAMES( tt_face_get_ps_name   ),
1257                             /* TT_Get_PS_Name_Func     get_psname      */
1258     PUT_PS_NAMES( tt_face_free_ps_names ),
1259                             /* TT_Free_Table_Func      free_psnames    */
1260 
1261     /* since version 2.1.8 */
1262     tt_face_get_kerning,    /* TT_Face_GetKerningFunc  get_kerning     */
1263 
1264     /* since version 2.2 */
1265     tt_face_load_font_dir,  /* TT_Load_Table_Func      load_font_dir   */
1266     tt_face_load_hmtx,      /* TT_Load_Metrics_Func    load_hmtx       */
1267 
1268     /* see `ttsbit.h&#39; and `sfnt.h&#39; */
1269     PUT_EMBEDDED_BITMAPS( tt_face_load_sbit ),
1270                             /* TT_Load_Table_Func      load_eblc       */
1271     PUT_EMBEDDED_BITMAPS( tt_face_free_sbit ),
1272                             /* TT_Free_Table_Func      free_eblc       */
1273 
1274     PUT_EMBEDDED_BITMAPS( tt_face_set_sbit_strike     ),
<a name="54" id="anc54"></a><span class="line-modified">1275                    /* TT_Set_SBit_Strike_Func      set_sbit_strike     */</span>
1276     PUT_EMBEDDED_BITMAPS( tt_face_load_strike_metrics ),
<a name="55" id="anc55"></a><span class="line-modified">1277                    /* TT_Load_Strike_Metrics_Func  load_strike_metrics */</span>
<span class="line-added">1278 </span>
<span class="line-added">1279     PUT_COLOR_LAYERS( tt_face_load_cpal ),</span>
<span class="line-added">1280                             /* TT_Load_Table_Func      load_cpal       */</span>
<span class="line-added">1281     PUT_COLOR_LAYERS( tt_face_load_colr ),</span>
<span class="line-added">1282                             /* TT_Load_Table_Func      load_colr       */</span>
<span class="line-added">1283     PUT_COLOR_LAYERS( tt_face_free_cpal ),</span>
<span class="line-added">1284                             /* TT_Free_Table_Func      free_cpal       */</span>
<span class="line-added">1285     PUT_COLOR_LAYERS( tt_face_free_colr ),</span>
<span class="line-added">1286                             /* TT_Free_Table_Func      free_colr       */</span>
<span class="line-added">1287     PUT_COLOR_LAYERS( tt_face_palette_set ),</span>
<span class="line-added">1288                             /* TT_Set_Palette_Func     set_palette     */</span>
<span class="line-added">1289     PUT_COLOR_LAYERS( tt_face_get_colr_layer ),</span>
<span class="line-added">1290                             /* TT_Get_Colr_Layer_Func  get_colr_layer  */</span>
<span class="line-added">1291     PUT_COLOR_LAYERS( tt_face_colr_blend_layer ),</span>
<span class="line-added">1292                             /* TT_Blend_Colr_Func      colr_blend      */</span>
1293 
1294     tt_face_get_metrics,    /* TT_Get_Metrics_Func     get_metrics     */
1295 
1296     tt_face_get_name,       /* TT_Get_Name_Func        get_name        */
1297     sfnt_get_name_id        /* TT_Get_Name_ID_Func     get_name_id     */
1298   )
1299 
1300 
1301   FT_DEFINE_MODULE(
1302     sfnt_module_class,
1303 
1304     0,  /* not a font driver or renderer */
1305     sizeof ( FT_ModuleRec ),
1306 
1307     &quot;sfnt&quot;,     /* driver name                            */
1308     0x10000L,   /* driver version 1.0                     */
1309     0x20000L,   /* driver requires FreeType 2.0 or higher */
1310 
<a name="56" id="anc56"></a><span class="line-modified">1311     (const void*)&amp;sfnt_interface,  /* module specific interface */</span>
1312 
1313     (FT_Module_Constructor)NULL,               /* module_init   */
1314     (FT_Module_Destructor) NULL,               /* module_done   */
1315     (FT_Module_Requester)  sfnt_get_interface  /* get_interface */
1316   )
1317 
1318 
1319 /* END */
<a name="57" id="anc57"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="57" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * sfobjs.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   SFNT object management (base).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;sfobjs.h&quot;
  21 #include &quot;ttload.h&quot;
  22 #include &quot;ttcmap.h&quot;
  23 #include &quot;ttkern.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  24 #include &quot;sfwoff.h&quot;</span>
  25 #include FT_INTERNAL_SFNT_H
  26 #include FT_INTERNAL_DEBUG_H
  27 #include FT_TRUETYPE_IDS_H
  28 #include FT_TRUETYPE_TAGS_H
  29 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  30 #include FT_SFNT_NAMES_H
<a name="3" id="anc3"></a>
  31 
  32 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  33 #include FT_SERVICE_MULTIPLE_MASTERS_H
  34 #include FT_SERVICE_METRICS_VARIATIONS_H
  35 #endif
  36 
  37 #include &quot;sferrors.h&quot;
  38 
  39 #ifdef TT_CONFIG_OPTION_BDF
  40 #include &quot;ttbdf.h&quot;
  41 #endif
  42 
  43 
<a name="4" id="anc4"></a><span class="line-modified">  44   /**************************************************************************</span>
<span class="line-modified">  45    *</span>
<span class="line-modified">  46    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  47    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  48    * messages during execution.</span>
<span class="line-modified">  49    */</span>
  50 #undef  FT_COMPONENT
<a name="5" id="anc5"></a><span class="line-modified">  51 #define FT_COMPONENT  sfobjs</span>
  52 
  53 
  54 
  55   /* convert a UTF-16 name entry to ASCII */
  56   static FT_String*
  57   tt_name_ascii_from_utf16( TT_Name    entry,
  58                             FT_Memory  memory )
  59   {
  60     FT_String*  string = NULL;
  61     FT_UInt     len, code, n;
  62     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  63     FT_Error    error;
  64 
  65 
  66     len = (FT_UInt)entry-&gt;stringLength / 2;
  67 
  68     if ( FT_NEW_ARRAY( string, len + 1 ) )
  69       return NULL;
  70 
  71     for ( n = 0; n &lt; len; n++ )
  72     {
  73       code = FT_NEXT_USHORT( read );
  74 
  75       if ( code == 0 )
  76         break;
  77 
  78       if ( code &lt; 32 || code &gt; 127 )
  79         code = &#39;?&#39;;
  80 
  81       string[n] = (char)code;
  82     }
  83 
  84     string[n] = 0;
  85 
  86     return string;
  87   }
  88 
  89 
  90   /* convert an Apple Roman or symbol name entry to ASCII */
  91   static FT_String*
  92   tt_name_ascii_from_other( TT_Name    entry,
  93                             FT_Memory  memory )
  94   {
  95     FT_String*  string = NULL;
  96     FT_UInt     len, code, n;
  97     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  98     FT_Error    error;
  99 
 100 
 101     len = (FT_UInt)entry-&gt;stringLength;
 102 
 103     if ( FT_NEW_ARRAY( string, len + 1 ) )
 104       return NULL;
 105 
 106     for ( n = 0; n &lt; len; n++ )
 107     {
 108       code = *read++;
 109 
 110       if ( code == 0 )
 111         break;
 112 
 113       if ( code &lt; 32 || code &gt; 127 )
 114         code = &#39;?&#39;;
 115 
 116       string[n] = (char)code;
 117     }
 118 
 119     string[n] = 0;
 120 
 121     return string;
 122   }
 123 
 124 
 125   typedef FT_String*  (*TT_Name_ConvertFunc)( TT_Name    entry,
 126                                               FT_Memory  memory );
 127 
 128 
 129   /* documentation is in sfnt.h */
 130 
 131   FT_LOCAL_DEF( FT_Error )
 132   tt_face_get_name( TT_Face      face,
 133                     FT_UShort    nameid,
 134                     FT_String**  name )
 135   {
 136     FT_Memory   memory = face-&gt;root.memory;
 137     FT_Error    error  = FT_Err_Ok;
 138     FT_String*  result = NULL;
 139     FT_UShort   n;
 140     TT_Name     rec;
 141 
 142     FT_Int  found_apple         = -1;
 143     FT_Int  found_apple_roman   = -1;
 144     FT_Int  found_apple_english = -1;
 145     FT_Int  found_win           = -1;
 146     FT_Int  found_unicode       = -1;
 147 
 148     FT_Bool  is_english = 0;
 149 
 150     TT_Name_ConvertFunc  convert;
 151 
 152 
 153     FT_ASSERT( name );
 154 
 155     rec = face-&gt;name_table.names;
 156     for ( n = 0; n &lt; face-&gt;num_names; n++, rec++ )
 157     {
 158       /* According to the OpenType 1.3 specification, only Microsoft or  */
 159       /* Apple platform IDs might be used in the `name&#39; table.  The      */
 160       /* `Unicode&#39; platform is reserved for the `cmap&#39; table, and the    */
 161       /* `ISO&#39; one is deprecated.                                        */
 162       /*                                                                 */
 163       /* However, the Apple TrueType specification doesn&#39;t say the same  */
 164       /* thing and goes to suggest that all Unicode `name&#39; table entries */
 165       /* should be coded in UTF-16 (in big-endian format I suppose).     */
 166       /*                                                                 */
 167       if ( rec-&gt;nameID == nameid &amp;&amp; rec-&gt;stringLength &gt; 0 )
 168       {
 169         switch ( rec-&gt;platformID )
 170         {
 171         case TT_PLATFORM_APPLE_UNICODE:
 172         case TT_PLATFORM_ISO:
 173           /* there is `languageID&#39; to check there.  We should use this */
 174           /* field only as a last solution when nothing else is        */
 175           /* available.                                                */
 176           /*                                                           */
 177           found_unicode = n;
 178           break;
 179 
 180         case TT_PLATFORM_MACINTOSH:
 181           /* This is a bit special because some fonts will use either    */
 182           /* an English language id, or a Roman encoding id, to indicate */
 183           /* the English version of its font name.                       */
 184           /*                                                             */
 185           if ( rec-&gt;languageID == TT_MAC_LANGID_ENGLISH )
 186             found_apple_english = n;
 187           else if ( rec-&gt;encodingID == TT_MAC_ID_ROMAN )
 188             found_apple_roman = n;
 189           break;
 190 
 191         case TT_PLATFORM_MICROSOFT:
 192           /* we only take a non-English name when there is nothing */
 193           /* else available in the font                            */
 194           /*                                                       */
 195           if ( found_win == -1 || ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 )
 196           {
 197             switch ( rec-&gt;encodingID )
 198             {
 199             case TT_MS_ID_SYMBOL_CS:
 200             case TT_MS_ID_UNICODE_CS:
 201             case TT_MS_ID_UCS_4:
 202               is_english = FT_BOOL( ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 );
 203               found_win  = n;
 204               break;
 205 
 206             default:
 207               ;
 208             }
 209           }
 210           break;
 211 
 212         default:
 213           ;
 214         }
 215       }
 216     }
 217 
 218     found_apple = found_apple_roman;
 219     if ( found_apple_english &gt;= 0 )
 220       found_apple = found_apple_english;
 221 
 222     /* some fonts contain invalid Unicode or Macintosh formatted entries; */
 223     /* we will thus favor names encoded in Windows formats if available   */
 224     /* (provided it is an English name)                                   */
 225     /*                                                                    */
 226     convert = NULL;
 227     if ( found_win &gt;= 0 &amp;&amp; !( found_apple &gt;= 0 &amp;&amp; !is_english ) )
 228     {
 229       rec = face-&gt;name_table.names + found_win;
 230       switch ( rec-&gt;encodingID )
 231       {
 232         /* all Unicode strings are encoded using UTF-16BE */
 233       case TT_MS_ID_UNICODE_CS:
 234       case TT_MS_ID_SYMBOL_CS:
 235         convert = tt_name_ascii_from_utf16;
 236         break;
 237 
 238       case TT_MS_ID_UCS_4:
 239         /* Apparently, if this value is found in a name table entry, it is */
 240         /* documented as `full Unicode repertoire&#39;.  Experience with the   */
 241         /* MsGothic font shipped with Windows Vista shows that this really */
 242         /* means UTF-16 encoded names (UCS-4 values are only used within   */
 243         /* charmaps).                                                      */
 244         convert = tt_name_ascii_from_utf16;
 245         break;
 246 
 247       default:
 248         ;
 249       }
 250     }
 251     else if ( found_apple &gt;= 0 )
 252     {
 253       rec     = face-&gt;name_table.names + found_apple;
 254       convert = tt_name_ascii_from_other;
 255     }
 256     else if ( found_unicode &gt;= 0 )
 257     {
 258       rec     = face-&gt;name_table.names + found_unicode;
 259       convert = tt_name_ascii_from_utf16;
 260     }
 261 
 262     if ( rec &amp;&amp; convert )
 263     {
 264       if ( !rec-&gt;string )
 265       {
 266         FT_Stream  stream = face-&gt;name_table.stream;
 267 
 268 
 269         if ( FT_QNEW_ARRAY ( rec-&gt;string, rec-&gt;stringLength ) ||
 270              FT_STREAM_SEEK( rec-&gt;stringOffset )              ||
 271              FT_STREAM_READ( rec-&gt;string, rec-&gt;stringLength ) )
 272         {
 273           FT_FREE( rec-&gt;string );
 274           rec-&gt;stringLength = 0;
 275           result            = NULL;
 276           goto Exit;
 277         }
 278       }
 279 
 280       result = convert( rec, memory );
 281     }
 282 
 283   Exit:
 284     *name = result;
 285     return error;
 286   }
 287 
 288 
 289   static FT_Encoding
 290   sfnt_find_encoding( int  platform_id,
 291                       int  encoding_id )
 292   {
 293     typedef struct  TEncoding_
 294     {
 295       int          platform_id;
 296       int          encoding_id;
 297       FT_Encoding  encoding;
 298 
 299     } TEncoding;
 300 
 301     static
 302     const TEncoding  tt_encodings[] =
 303     {
 304       { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },
 305 
 306       { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },
 307 
 308       { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },
 309 
 310       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },
 311       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },
 312       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },
 313       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },
 314       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_PRC,        FT_ENCODING_PRC },
 315       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },
 316       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },
 317       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }
 318     };
 319 
 320     const TEncoding  *cur, *limit;
 321 
 322 
 323     cur   = tt_encodings;
 324     limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );
 325 
 326     for ( ; cur &lt; limit; cur++ )
 327     {
 328       if ( cur-&gt;platform_id == platform_id )
 329       {
 330         if ( cur-&gt;encoding_id == encoding_id ||
 331              cur-&gt;encoding_id == -1          )
 332           return cur-&gt;encoding;
 333       }
 334     }
 335 
 336     return FT_ENCODING_NONE;
 337   }
 338 
 339 
<a name="6" id="anc6"></a>












































































































































































































































































































































































































 340   /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */
 341   /* synthesized into a TTC with one offset table.              */
 342   static FT_Error
 343   sfnt_open_font( FT_Stream  stream,
 344                   TT_Face    face )
 345   {
 346     FT_Memory  memory = stream-&gt;memory;
 347     FT_Error   error;
 348     FT_ULong   tag, offset;
 349 
 350     static const FT_Frame_Field  ttc_header_fields[] =
 351     {
 352 #undef  FT_STRUCTURE
 353 #define FT_STRUCTURE  TTC_HeaderRec
 354 
 355       FT_FRAME_START( 8 ),
 356         FT_FRAME_LONG( version ),
 357         FT_FRAME_LONG( count   ),  /* this is ULong in the specs */
 358       FT_FRAME_END
 359     };
 360 
 361 
 362     face-&gt;ttc_header.tag     = 0;
 363     face-&gt;ttc_header.version = 0;
 364     face-&gt;ttc_header.count   = 0;
 365 
 366   retry:
 367     offset = FT_STREAM_POS();
 368 
 369     if ( FT_READ_ULONG( tag ) )
 370       return error;
 371 
 372     if ( tag == TTAG_wOFF )
 373     {
 374       FT_TRACE2(( &quot;sfnt_open_font: file is a WOFF; synthesizing SFNT\n&quot; ));
 375 
 376       if ( FT_STREAM_SEEK( offset ) )
 377         return error;
 378 
 379       error = woff_open_font( stream, face );
 380       if ( error )
 381         return error;
 382 
 383       /* Swap out stream and retry! */
 384       stream = face-&gt;root.stream;
 385       goto retry;
 386     }
 387 
 388     if ( tag != 0x00010000UL &amp;&amp;
 389          tag != TTAG_ttcf    &amp;&amp;
 390          tag != TTAG_OTTO    &amp;&amp;
 391          tag != TTAG_true    &amp;&amp;
 392          tag != TTAG_typ1    &amp;&amp;
 393          tag != TTAG_0xA5kbd &amp;&amp;
 394          tag != TTAG_0xA5lst &amp;&amp;
 395          tag != 0x00020000UL )
 396     {
 397       FT_TRACE2(( &quot;  not a font using the SFNT container format\n&quot; ));
 398       return FT_THROW( Unknown_File_Format );
 399     }
 400 
 401     face-&gt;ttc_header.tag = TTAG_ttcf;
 402 
 403     if ( tag == TTAG_ttcf )
 404     {
 405       FT_Int  n;
 406 
 407 
 408       FT_TRACE3(( &quot;sfnt_open_font: file is a collection\n&quot; ));
 409 
 410       if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &amp;face-&gt;ttc_header ) )
 411         return error;
 412 
 413       FT_TRACE3(( &quot;                with %ld subfonts\n&quot;,
 414                   face-&gt;ttc_header.count ));
 415 
 416       if ( face-&gt;ttc_header.count == 0 )
 417         return FT_THROW( Invalid_Table );
 418 
 419       /* a rough size estimate: let&#39;s conservatively assume that there   */
 420       /* is just a single table info in each subfont header (12 + 16*1 = */
 421       /* 28 bytes), thus we have (at least) `12 + 4*count&#39; bytes for the */
 422       /* size of the TTC header plus `28*count&#39; bytes for all subfont    */
 423       /* headers                                                         */
 424       if ( (FT_ULong)face-&gt;ttc_header.count &gt; stream-&gt;size / ( 28 + 4 ) )
 425         return FT_THROW( Array_Too_Large );
 426 
 427       /* now read the offsets of each font in the file */
 428       if ( FT_NEW_ARRAY( face-&gt;ttc_header.offsets, face-&gt;ttc_header.count ) )
 429         return error;
 430 
 431       if ( FT_FRAME_ENTER( face-&gt;ttc_header.count * 4L ) )
 432         return error;
 433 
 434       for ( n = 0; n &lt; face-&gt;ttc_header.count; n++ )
 435         face-&gt;ttc_header.offsets[n] = FT_GET_ULONG();
 436 
 437       FT_FRAME_EXIT();
 438     }
 439     else
 440     {
 441       FT_TRACE3(( &quot;sfnt_open_font: synthesize TTC\n&quot; ));
 442 
 443       face-&gt;ttc_header.version = 1 &lt;&lt; 16;
 444       face-&gt;ttc_header.count   = 1;
 445 
 446       if ( FT_NEW( face-&gt;ttc_header.offsets ) )
 447         return error;
 448 
 449       face-&gt;ttc_header.offsets[0] = offset;
 450     }
 451 
 452     return error;
 453   }
 454 
 455 
 456   FT_LOCAL_DEF( FT_Error )
 457   sfnt_init_face( FT_Stream      stream,
 458                   TT_Face        face,
 459                   FT_Int         face_instance_index,
 460                   FT_Int         num_params,
 461                   FT_Parameter*  params )
 462   {
 463     FT_Error      error;
 464     FT_Library    library = face-&gt;root.driver-&gt;root.library;
 465     SFNT_Service  sfnt;
 466     FT_Int        face_index;
 467 
 468 
 469     /* for now, parameters are unused */
 470     FT_UNUSED( num_params );
 471     FT_UNUSED( params );
 472 
 473 
 474     sfnt = (SFNT_Service)face-&gt;sfnt;
 475     if ( !sfnt )
 476     {
 477       sfnt = (SFNT_Service)FT_Get_Module_Interface( library, &quot;sfnt&quot; );
 478       if ( !sfnt )
 479       {
 480         FT_ERROR(( &quot;sfnt_init_face: cannot access `sfnt&#39; module\n&quot; ));
 481         return FT_THROW( Missing_Module );
 482       }
 483 
 484       face-&gt;sfnt       = sfnt;
 485       face-&gt;goto_table = sfnt-&gt;goto_table;
 486     }
 487 
 488     FT_FACE_FIND_GLOBAL_SERVICE( face, face-&gt;psnames, POSTSCRIPT_CMAPS );
 489 
 490 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 491     if ( !face-&gt;mm )
 492     {
 493       /* we want the MM interface from the `truetype&#39; module only */
 494       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 495 
 496 
 497       face-&gt;mm = ft_module_get_service( tt_module,
 498                                         FT_SERVICE_ID_MULTI_MASTERS,
 499                                         0 );
 500     }
 501 
 502     if ( !face-&gt;var )
 503     {
 504       /* we want the metrics variations interface */
 505       /* from the `truetype&#39; module only          */
 506       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 507 
 508 
 509       face-&gt;var = ft_module_get_service( tt_module,
 510                                          FT_SERVICE_ID_METRICS_VARIATIONS,
 511                                          0 );
 512     }
 513 #endif
 514 
 515     FT_TRACE2(( &quot;SFNT driver\n&quot; ));
 516 
 517     error = sfnt_open_font( stream, face );
 518     if ( error )
 519       return error;
 520 
 521     /* Stream may have changed in sfnt_open_font. */
 522     stream = face-&gt;root.stream;
 523 
<a name="7" id="anc7"></a><span class="line-modified"> 524     FT_TRACE2(( &quot;sfnt_init_face: %08p (index %d)\n&quot;,</span>
<span class="line-added"> 525                 face,</span>
<span class="line-added"> 526                 face_instance_index ));</span>
 527 
 528     face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;
 529 
 530     /* value -(N+1) requests information on index N */
 531     if ( face_instance_index &lt; 0 )
 532       face_index--;
 533 
 534     if ( face_index &gt;= face-&gt;ttc_header.count )
 535     {
 536       if ( face_instance_index &gt;= 0 )
 537         return FT_THROW( Invalid_Argument );
 538       else
 539         face_index = 0;
 540     }
 541 
 542     if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )
 543       return error;
 544 
 545     /* check whether we have a valid TrueType file */
 546     error = sfnt-&gt;load_font_dir( face, stream );
 547     if ( error )
 548       return error;
 549 
 550 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 551     {
 552       FT_Memory  memory = face-&gt;root.memory;
 553 
 554       FT_ULong  fvar_len;
 555 
 556       FT_ULong  version;
 557       FT_ULong  offset;
 558 
 559       FT_UShort  num_axes;
 560       FT_UShort  axis_size;
 561       FT_UShort  num_instances;
 562       FT_UShort  instance_size;
 563 
 564       FT_Int  instance_index;
 565 
 566       FT_Byte*  default_values  = NULL;
 567       FT_Byte*  instance_values = NULL;
 568 
 569 
 570       instance_index = FT_ABS( face_instance_index ) &gt;&gt; 16;
 571 
 572       /* test whether current face is a GX font with named instances */
 573       if ( face-&gt;goto_table( face, TTAG_fvar, stream, &amp;fvar_len ) ||
 574            fvar_len &lt; 20                                          ||
 575            FT_READ_ULONG( version )                               ||
 576            FT_READ_USHORT( offset )                               ||
 577            FT_STREAM_SKIP( 2 ) /* reserved */                     ||
 578            FT_READ_USHORT( num_axes )                             ||
 579            FT_READ_USHORT( axis_size )                            ||
 580            FT_READ_USHORT( num_instances )                        ||
 581            FT_READ_USHORT( instance_size )                        )
 582       {
 583         version       = 0;
 584         offset        = 0;
 585         num_axes      = 0;
 586         axis_size     = 0;
 587         num_instances = 0;
 588         instance_size = 0;
 589       }
 590 
 591       /* check that the data is bound by the table length */
 592       if ( version != 0x00010000UL                    ||
 593            axis_size != 20                            ||
 594            num_axes == 0                              ||
 595            /* `num_axes&#39; limit implied by 16-bit `instance_size&#39; */
 596            num_axes &gt; 0x3FFE                          ||
 597            !( instance_size == 4 + 4 * num_axes ||
 598               instance_size == 6 + 4 * num_axes )     ||
 599            /* `num_instances&#39; limit implied by limited range of name IDs */
 600            num_instances &gt; 0x7EFF                     ||
 601            offset                          +
 602              axis_size * num_axes          +
 603              instance_size * num_instances &gt; fvar_len )
 604         num_instances = 0;
 605       else
 606         face-&gt;variation_support |= TT_FACE_FLAG_VAR_FVAR;
 607 
 608       /*
<a name="8" id="anc8"></a><span class="line-modified"> 609        * As documented in the OpenType specification, an entry for the</span>
<span class="line-modified"> 610        * default instance may be omitted in the named instance table.  In</span>
<span class="line-modified"> 611        * particular this means that even if there is no named instance</span>
<span class="line-modified"> 612        * table in the font we actually do have a named instance, namely the</span>
<span class="line-modified"> 613        * default instance.</span>
 614        *
<a name="9" id="anc9"></a><span class="line-modified"> 615        * For consistency, we always want the default instance in our list</span>
<span class="line-modified"> 616        * of named instances.  If it is missing, we try to synthesize it</span>
<span class="line-modified"> 617        * later on.  Here, we have to adjust `num_instances&#39; accordingly.</span>
 618        */
 619 
 620       if ( ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR ) &amp;&amp;
 621            !( FT_ALLOC( default_values, num_axes * 4 )  ||
 622               FT_ALLOC( instance_values, num_axes * 4 ) )      )
 623       {
 624         /* the current stream position is 16 bytes after the table start */
 625         FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
 626         FT_ULong  default_value_offset, instance_offset;
 627 
 628         FT_Byte*  p;
 629         FT_UInt   i;
 630 
 631 
 632         default_value_offset = array_start + 8;
 633         p                    = default_values;
 634 
 635         for ( i = 0; i &lt; num_axes; i++ )
 636         {
 637           (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );
 638 
 639           default_value_offset += axis_size;
 640           p                    += 4;
 641         }
 642 
 643         instance_offset = array_start + axis_size * num_axes + 4;
 644 
 645         for ( i = 0; i &lt; num_instances; i++ )
 646         {
 647           (void)FT_STREAM_READ_AT( instance_offset,
 648                                    instance_values,
 649                                    num_axes * 4 );
 650 
 651           if ( !ft_memcmp( default_values, instance_values, num_axes * 4 ) )
 652             break;
 653 
 654           instance_offset += instance_size;
 655         }
 656 
 657         if ( i == num_instances )
 658         {
 659           /* no default instance in named instance table; */
 660           /* we thus have to synthesize it                */
 661           num_instances++;
 662         }
 663       }
 664 
 665       FT_FREE( default_values );
 666       FT_FREE( instance_values );
 667 
 668       /* we don&#39;t support Multiple Master CFFs yet; */
 669       /* note that `glyf&#39; or `CFF2&#39; have precedence */
 670       if ( face-&gt;goto_table( face, TTAG_glyf, stream, 0 ) &amp;&amp;
 671            face-&gt;goto_table( face, TTAG_CFF2, stream, 0 ) &amp;&amp;
 672            !face-&gt;goto_table( face, TTAG_CFF, stream, 0 ) )
 673         num_instances = 0;
 674 
 675       /* instance indices in `face_instance_index&#39; start with index 1, */
 676       /* thus `&gt;&#39; and not `&gt;=&#39;                                         */
 677       if ( instance_index &gt; num_instances )
 678       {
 679         if ( face_instance_index &gt;= 0 )
 680           return FT_THROW( Invalid_Argument );
 681         else
 682           num_instances = 0;
 683       }
 684 
 685       face-&gt;root.style_flags = (FT_Long)num_instances &lt;&lt; 16;
 686     }
 687 #endif
 688 
 689     face-&gt;root.num_faces  = face-&gt;ttc_header.count;
 690     face-&gt;root.face_index = face_instance_index;
 691 
 692     return error;
 693   }
 694 
 695 
 696 #define LOAD_( x )                                          \
 697   do                                                        \
 698   {                                                         \
 699     FT_TRACE2(( &quot;`&quot; #x &quot;&#39; &quot; ));                             \
 700     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
 701                                                             \
 702     error = sfnt-&gt;load_ ## x( face, stream );               \
 703                                                             \
 704     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
 705                         ? &quot;loaded&quot;                          \
 706                         : FT_ERR_EQ( error, Table_Missing ) \
 707                           ? &quot;missing&quot;                       \
 708                           : &quot;failed to load&quot; ));            \
 709     FT_TRACE3(( &quot;\n&quot; ));                                    \
 710   } while ( 0 )
 711 
 712 #define LOADM_( x, vertical )                               \
 713   do                                                        \
 714   {                                                         \
 715     FT_TRACE2(( &quot;`%s&quot; #x &quot;&#39; &quot;,                              \
 716                 vertical ? &quot;vertical &quot; : &quot;&quot; ));             \
 717     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
 718                                                             \
 719     error = sfnt-&gt;load_ ## x( face, stream, vertical );     \
 720                                                             \
 721     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
 722                         ? &quot;loaded&quot;                          \
 723                         : FT_ERR_EQ( error, Table_Missing ) \
 724                           ? &quot;missing&quot;                       \
 725                           : &quot;failed to load&quot; ));            \
 726     FT_TRACE3(( &quot;\n&quot; ));                                    \
 727   } while ( 0 )
 728 
 729 #define GET_NAME( id, field )                                   \
 730   do                                                            \
 731   {                                                             \
 732     error = tt_face_get_name( face, TT_NAME_ID_ ## id, field ); \
 733     if ( error )                                                \
 734       goto Exit;                                                \
 735   } while ( 0 )
 736 
 737 
 738   FT_LOCAL_DEF( FT_Error )
 739   sfnt_load_face( FT_Stream      stream,
 740                   TT_Face        face,
 741                   FT_Int         face_instance_index,
 742                   FT_Int         num_params,
 743                   FT_Parameter*  params )
 744   {
 745     FT_Error      error;
 746 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 747     FT_Error      psnames_error;
 748 #endif
 749     FT_Bool       has_outline;
 750     FT_Bool       is_apple_sbit;
 751     FT_Bool       is_apple_sbix;
 752     FT_Bool       has_CBLC;
 753     FT_Bool       has_CBDT;
 754     FT_Bool       ignore_typographic_family    = FALSE;
 755     FT_Bool       ignore_typographic_subfamily = FALSE;
 756 
 757     SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;
 758 
 759     FT_UNUSED( face_instance_index );
 760 
 761 
 762     /* Check parameters */
 763 
 764     {
 765       FT_Int  i;
 766 
 767 
 768       for ( i = 0; i &lt; num_params; i++ )
 769       {
 770         if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY )
 771           ignore_typographic_family = TRUE;
 772         else if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY )
 773           ignore_typographic_subfamily = TRUE;
 774       }
 775     }
 776 
 777     /* Load tables */
 778 
 779     /* We now support two SFNT-based bitmapped font formats.  They */
 780     /* are recognized easily as they do not include a `glyf&#39;       */
 781     /* table.                                                      */
 782     /*                                                             */
 783     /* The first format comes from Apple, and uses a table named   */
 784     /* `bhed&#39; instead of `head&#39; to store the font header (using    */
 785     /* the same format).  It also doesn&#39;t include horizontal and   */
 786     /* vertical metrics tables (i.e. `hhea&#39; and `vhea&#39; tables are  */
 787     /* missing).                                                   */
 788     /*                                                             */
 789     /* The other format comes from Microsoft, and is used with     */
 790     /* WinCE/PocketPC.  It looks like a standard TTF, except that  */
 791     /* it doesn&#39;t contain outlines.                                */
 792     /*                                                             */
 793 
 794     FT_TRACE2(( &quot;sfnt_load_face: %08p\n\n&quot;, face ));
 795 
 796     /* do we have outlines in there? */
 797 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 798     has_outline = FT_BOOL( face-&gt;root.internal-&gt;incremental_interface ||
 799                            tt_face_lookup_table( face, TTAG_glyf )    ||
 800                            tt_face_lookup_table( face, TTAG_CFF )     ||
 801                            tt_face_lookup_table( face, TTAG_CFF2 )    );
 802 #else
 803     has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) ||
 804                            tt_face_lookup_table( face, TTAG_CFF )  ||
 805                            tt_face_lookup_table( face, TTAG_CFF2 ) );
 806 #endif
 807 
 808     is_apple_sbit = 0;
 809     is_apple_sbix = !face-&gt;goto_table( face, TTAG_sbix, stream, 0 );
 810 
 811     /* Apple &#39;sbix&#39; color bitmaps are rendered scaled and then the &#39;glyf&#39;
 812      * outline rendered on top.  We don&#39;t support that yet, so just ignore
 813      * the &#39;glyf&#39; outline and advertise it as a bitmap-only font. */
 814     if ( is_apple_sbix )
 815       has_outline = FALSE;
 816 
 817     /* if this font doesn&#39;t contain outlines, we try to load */
 818     /* a `bhed&#39; table                                        */
 819     if ( !has_outline &amp;&amp; sfnt-&gt;load_bhed )
 820     {
 821       LOAD_( bhed );
 822       is_apple_sbit = FT_BOOL( !error );
 823     }
 824 
 825     /* load the font header (`head&#39; table) if this isn&#39;t an Apple */
 826     /* sbit font file                                             */
 827     if ( !is_apple_sbit || is_apple_sbix )
 828     {
 829       LOAD_( head );
 830       if ( error )
 831         goto Exit;
 832     }
 833 
 834     has_CBLC = !face-&gt;goto_table( face, TTAG_CBLC, stream, 0 );
 835     has_CBDT = !face-&gt;goto_table( face, TTAG_CBDT, stream, 0 );
 836 
 837     /* Ignore outlines for CBLC/CBDT fonts. */
 838     if ( has_CBLC || has_CBDT )
 839       has_outline = FALSE;
 840 
 841     /* OpenType 1.8.2 introduced limits to this value;    */
 842     /* however, they make sense for older SFNT fonts also */
 843     if ( face-&gt;header.Units_Per_EM &lt;    16 ||
 844          face-&gt;header.Units_Per_EM &gt; 16384 )
 845     {
 846       error = FT_THROW( Invalid_Table );
 847 
 848       goto Exit;
 849     }
 850 
 851     /* the following tables are often not present in embedded TrueType */
 852     /* fonts within PDF documents, so don&#39;t check for them.            */
 853     LOAD_( maxp );
 854     LOAD_( cmap );
 855 
 856     /* the following tables are optional in PCL fonts -- */
 857     /* don&#39;t check for errors                            */
 858     LOAD_( name );
 859     LOAD_( post );
 860 
 861 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
 862     psnames_error = error;
 863 #endif
 864 
 865     /* do not load the metrics headers and tables if this is an Apple */
 866     /* sbit font file                                                 */
 867     if ( !is_apple_sbit )
 868     {
 869       /* load the `hhea&#39; and `hmtx&#39; tables */
 870       LOADM_( hhea, 0 );
 871       if ( !error )
 872       {
 873         LOADM_( hmtx, 0 );
 874         if ( FT_ERR_EQ( error, Table_Missing ) )
 875         {
 876           error = FT_THROW( Hmtx_Table_Missing );
 877 
 878 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 879           /* If this is an incrementally loaded font and there are */
 880           /* overriding metrics, tolerate a missing `hmtx&#39; table.  */
 881           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
 882                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
 883                  get_glyph_metrics                                 )
 884           {
 885             face-&gt;horizontal.number_Of_HMetrics = 0;
 886             error                               = FT_Err_Ok;
 887           }
 888 #endif
 889         }
 890       }
 891       else if ( FT_ERR_EQ( error, Table_Missing ) )
 892       {
 893         /* No `hhea&#39; table necessary for SFNT Mac fonts. */
 894         if ( face-&gt;format_tag == TTAG_true )
 895         {
 896           FT_TRACE2(( &quot;This is an SFNT Mac font.\n&quot; ));
 897 
 898           has_outline = 0;
 899           error       = FT_Err_Ok;
 900         }
 901         else
 902         {
 903           error = FT_THROW( Horiz_Header_Missing );
 904 
 905 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 906           /* If this is an incrementally loaded font and there are */
 907           /* overriding metrics, tolerate a missing `hhea&#39; table.  */
 908           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
 909                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
 910                  get_glyph_metrics                                 )
 911           {
 912             face-&gt;horizontal.number_Of_HMetrics = 0;
 913             error                               = FT_Err_Ok;
 914           }
 915 #endif
 916 
 917         }
 918       }
 919 
 920       if ( error )
 921         goto Exit;
 922 
 923       /* try to load the `vhea&#39; and `vmtx&#39; tables */
 924       LOADM_( hhea, 1 );
 925       if ( !error )
 926       {
 927         LOADM_( hmtx, 1 );
 928         if ( !error )
 929           face-&gt;vertical_info = 1;
 930       }
 931 
 932       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
 933         goto Exit;
 934 
 935       LOAD_( os2 );
 936       if ( error )
 937       {
 938         /* we treat the table as missing if there are any errors */
 939         face-&gt;os2.version = 0xFFFFU;
 940       }
 941     }
 942 
 943     /* the optional tables */
 944 
 945     /* embedded bitmap support */
 946     if ( sfnt-&gt;load_eblc )
 947       LOAD_( eblc );
 948 
<a name="10" id="anc10"></a><span class="line-added"> 949     /* colored glyph support */</span>
<span class="line-added"> 950     if ( sfnt-&gt;load_cpal )</span>
<span class="line-added"> 951     {</span>
<span class="line-added"> 952       LOAD_( cpal );</span>
<span class="line-added"> 953       LOAD_( colr );</span>
<span class="line-added"> 954     }</span>
<span class="line-added"> 955 </span>
 956     /* consider the pclt, kerning, and gasp tables as optional */
 957     LOAD_( pclt );
 958     LOAD_( gasp );
 959     LOAD_( kern );
 960 
 961     face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;
 962 
 963     /* Bit 8 of the `fsSelection&#39; field in the `OS/2&#39; table denotes  */
 964     /* a WWS-only font face.  `WWS&#39; stands for `weight&#39;, width&#39;, and */
 965     /* `slope&#39;, a term used by Microsoft&#39;s Windows Presentation      */
 966     /* Foundation (WPF).  This flag has been introduced in version   */
 967     /* 1.5 of the OpenType specification (May 2008).                 */
 968 
 969     face-&gt;root.family_name = NULL;
 970     face-&gt;root.style_name  = NULL;
 971     if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )
 972     {
 973       if ( !ignore_typographic_family )
 974         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
 975       if ( !face-&gt;root.family_name )
 976         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
 977 
 978       if ( !ignore_typographic_subfamily )
 979         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
 980       if ( !face-&gt;root.style_name )
 981         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
 982     }
 983     else
 984     {
 985       GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );
 986       if ( !face-&gt;root.family_name &amp;&amp; !ignore_typographic_family )
 987         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
 988       if ( !face-&gt;root.family_name )
 989         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
 990 
 991       GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );
 992       if ( !face-&gt;root.style_name &amp;&amp; !ignore_typographic_subfamily )
 993         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
 994       if ( !face-&gt;root.style_name )
 995         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
 996     }
 997 
 998     /* now set up root fields */
 999     {
1000       FT_Face  root  = &amp;face-&gt;root;
1001       FT_Long  flags = root-&gt;face_flags;
1002 
1003 
<a name="11" id="anc11"></a><span class="line-modified">1004       /**********************************************************************</span>
<span class="line-modified">1005        *</span>
<span class="line-modified">1006        * Compute face flags.</span>
<span class="line-modified">1007        */</span>
1008       if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
<a name="12" id="anc12"></a><span class="line-modified">1009            face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX ||</span>
<span class="line-added">1010            face-&gt;colr                                       )</span>
1011         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
1012 
1013       if ( has_outline == TRUE )
1014         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
1015 
1016       /* The sfnt driver only supports bitmap fonts natively, thus we */
1017       /* don&#39;t set FT_FACE_FLAG_HINTER.                               */
1018       flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */
1019                FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */
1020 
1021 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1022       if ( !psnames_error                             &amp;&amp;
1023            face-&gt;postscript.FormatType != 0x00030000L )
1024         flags |= FT_FACE_FLAG_GLYPH_NAMES;
1025 #endif
1026 
1027       /* fixed width font? */
1028       if ( face-&gt;postscript.isFixedPitch )
1029         flags |= FT_FACE_FLAG_FIXED_WIDTH;
1030 
1031       /* vertical information? */
1032       if ( face-&gt;vertical_info )
1033         flags |= FT_FACE_FLAG_VERTICAL;
1034 
1035       /* kerning available ? */
1036       if ( TT_FACE_HAS_KERNING( face ) )
1037         flags |= FT_FACE_FLAG_KERNING;
1038 
1039 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1040       /* Don&#39;t bother to load the tables unless somebody asks for them. */
1041       /* No need to do work which will (probably) not be used.          */
1042       if ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR )
1043       {
1044         if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;
1045              tt_face_lookup_table( face, TTAG_gvar ) != 0 )
1046           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1047         if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )
1048           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1049       }
1050 #endif
1051 
1052       root-&gt;face_flags = flags;
1053 
<a name="13" id="anc13"></a><span class="line-modified">1054       /**********************************************************************</span>
<span class="line-modified">1055        *</span>
<span class="line-modified">1056        * Compute style flags.</span>
<span class="line-modified">1057        */</span>
1058 
1059       flags = 0;
1060       if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )
1061       {
1062         /* We have an OS/2 table; use the `fsSelection&#39; field.  Bit 9 */
1063         /* indicates an oblique font face.  This flag has been        */
1064         /* introduced in version 1.5 of the OpenType specification.   */
1065 
1066         if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */
1067           flags |= FT_STYLE_FLAG_ITALIC;
1068         else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */
1069           flags |= FT_STYLE_FLAG_ITALIC;
1070 
1071         if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */
1072           flags |= FT_STYLE_FLAG_BOLD;
1073       }
1074       else
1075       {
1076         /* this is an old Mac font, use the header field */
1077 
1078         if ( face-&gt;header.Mac_Style &amp; 1 )
1079           flags |= FT_STYLE_FLAG_BOLD;
1080 
1081         if ( face-&gt;header.Mac_Style &amp; 2 )
1082           flags |= FT_STYLE_FLAG_ITALIC;
1083       }
1084 
1085       root-&gt;style_flags |= flags;
1086 
<a name="14" id="anc14"></a><span class="line-modified">1087       /**********************************************************************</span>
<span class="line-modified">1088        *</span>
<span class="line-modified">1089        * Polish the charmaps.</span>
<span class="line-modified">1090        *</span>
<span class="line-modified">1091        *   Try to set the charmap encoding according to the platform &amp;</span>
<span class="line-modified">1092        *   encoding ID of each charmap.  Emulate Unicode charmap if one</span>
<span class="line-modified">1093        *   is missing.</span>
<span class="line-modified">1094        */</span>
1095 
1096       tt_face_build_cmaps( face );  /* ignore errors */
1097 
1098 
1099       /* set the encoding fields */
1100       {
1101         FT_Int   m;
1102 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1103         FT_Bool  has_unicode = FALSE;
1104 #endif
1105 
1106 
1107         for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )
1108         {
1109           FT_CharMap  charmap = root-&gt;charmaps[m];
1110 
1111 
1112           charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,
1113                                                   charmap-&gt;encoding_id );
1114 
1115 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1116 
1117           if ( charmap-&gt;encoding == FT_ENCODING_UNICODE   ||
1118                charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL )  /* PUA */
1119             has_unicode = TRUE;
1120         }
1121 
1122         /* synthesize Unicode charmap if one is missing */
1123         if ( !has_unicode )
1124         {
1125           FT_CharMapRec cmaprec;
1126 
1127 
1128           cmaprec.face        = root;
1129           cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
1130           cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
1131           cmaprec.encoding    = FT_ENCODING_UNICODE;
1132 
1133 
1134           error = FT_CMap_New( (FT_CMap_Class)&amp;tt_cmap_unicode_class_rec,
1135                                NULL, &amp;cmaprec, NULL );
1136           if ( error                                      &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified">1137                FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &amp;&amp;</span>
<span class="line-added">1138                FT_ERR_NEQ( error, Unimplemented_Feature ) )</span>
1139             goto Exit;
1140           error = FT_Err_Ok;
1141 
1142 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
1143 
1144         }
1145       }
1146 
1147 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1148 
1149       /*
<a name="16" id="anc16"></a><span class="line-modified">1150        * Now allocate the root array of FT_Bitmap_Size records and</span>
<span class="line-modified">1151        * populate them.  Unfortunately, it isn&#39;t possible to indicate bit</span>
<span class="line-modified">1152        * depths in the FT_Bitmap_Size record.  This is a design error.</span>
1153        */
1154       {
1155         FT_UInt  count;
1156 
1157 
1158         count = face-&gt;sbit_num_strikes;
1159 
1160         if ( count &gt; 0 )
1161         {
1162           FT_Memory        memory   = face-&gt;root.stream-&gt;memory;
1163           FT_UShort        em_size  = face-&gt;header.Units_Per_EM;
1164           FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;
1165           FT_Size_Metrics  metrics;
1166 
1167           FT_UInt*  sbit_strike_map = NULL;
1168           FT_UInt   strike_idx, bsize_idx;
1169 
1170 
1171           if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )
1172           {
1173             avgwidth = 1;
1174             em_size = 1;
1175           }
1176 
1177           /* to avoid invalid strike data in the `available_sizes&#39; field */
1178           /* of `FT_Face&#39;, we map `available_sizes&#39; indices to strike    */
1179           /* indices                                                     */
1180           if ( FT_NEW_ARRAY( root-&gt;available_sizes, count ) ||
1181                FT_NEW_ARRAY( sbit_strike_map, count ) )
1182             goto Exit;
1183 
1184           bsize_idx = 0;
1185           for ( strike_idx = 0; strike_idx &lt; count; strike_idx++ )
1186           {
1187             FT_Bitmap_Size*  bsize = root-&gt;available_sizes + bsize_idx;
1188 
1189 
1190             error = sfnt-&gt;load_strike_metrics( face, strike_idx, &amp;metrics );
1191             if ( error )
1192               continue;
1193 
1194             bsize-&gt;height = (FT_Short)( metrics.height &gt;&gt; 6 );
1195             bsize-&gt;width  = (FT_Short)(
1196               ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );
1197 
1198             bsize-&gt;x_ppem = metrics.x_ppem &lt;&lt; 6;
1199             bsize-&gt;y_ppem = metrics.y_ppem &lt;&lt; 6;
1200 
1201             /* assume 72dpi */
1202             bsize-&gt;size   = metrics.y_ppem &lt;&lt; 6;
1203 
1204             /* only use strikes with valid PPEM values */
1205             if ( bsize-&gt;x_ppem &amp;&amp; bsize-&gt;y_ppem )
1206               sbit_strike_map[bsize_idx++] = strike_idx;
1207           }
1208 
1209           /* reduce array size to the actually used elements */
1210           (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );
1211 
1212           /* from now on, all strike indices are mapped */
1213           /* using `sbit_strike_map&#39;                    */
1214           if ( bsize_idx )
1215           {
1216             face-&gt;sbit_strike_map = sbit_strike_map;
1217 
1218             root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;
1219             root-&gt;num_fixed_sizes = (FT_Int)bsize_idx;
1220           }
1221         }
1222       }
1223 
1224 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
1225 
1226       /* a font with no bitmaps and no outlines is scalable; */
1227       /* it has only empty glyphs then                       */
1228       if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )
1229         root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;
1230 
1231 
<a name="17" id="anc17"></a><span class="line-modified">1232       /**********************************************************************</span>
<span class="line-modified">1233        *</span>
<span class="line-modified">1234        * Set up metrics.</span>
<span class="line-modified">1235        */</span>
1236       if ( FT_IS_SCALABLE( root ) )
1237       {
1238         /* XXX What about if outline header is missing */
1239         /*     (e.g. sfnt wrapped bitmap)?             */
1240         root-&gt;bbox.xMin    = face-&gt;header.xMin;
1241         root-&gt;bbox.yMin    = face-&gt;header.yMin;
1242         root-&gt;bbox.xMax    = face-&gt;header.xMax;
1243         root-&gt;bbox.yMax    = face-&gt;header.yMax;
1244         root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;
1245 
1246 
<a name="18" id="anc18"></a><span class="line-modified">1247         /*</span>
<span class="line-modified">1248          * Computing the ascender/descender/height is tricky.</span>
<span class="line-modified">1249          *</span>
<span class="line-modified">1250          * The OpenType specification v1.8.3 says:</span>
<span class="line-modified">1251          *</span>
<span class="line-modified">1252          *   [OS/2&#39;s] sTypoAscender, sTypoDescender and sTypoLineGap fields</span>
<span class="line-modified">1253          *   are intended to allow applications to lay out documents in a</span>
<span class="line-modified">1254          *   typographically-correct and portable fashion.</span>
<span class="line-modified">1255          *</span>
<span class="line-modified">1256          * This is somewhat at odds with the decades of backwards</span>
<span class="line-modified">1257          * compatibility, operating systems and applications doing whatever</span>
<span class="line-modified">1258          * they want, not to mention broken fonts.</span>
<span class="line-modified">1259          *</span>
<span class="line-modified">1260          * Not all fonts have an OS/2 table; in this case, we take the values</span>
<span class="line-modified">1261          * in the horizontal header, although there is nothing stopping the</span>
<span class="line-modified">1262          * values from being unreliable. Even with a OS/2 table, certain fonts</span>
<span class="line-modified">1263          * set the sTypoAscender, sTypoDescender and sTypoLineGap fields to 0</span>
<span class="line-modified">1264          * and instead correctly set usWinAscent and usWinDescent.</span>
<span class="line-modified">1265          *</span>
<span class="line-modified">1266          * As an example, Arial Narrow is shipped as four files ARIALN.TTF,</span>
<span class="line-modified">1267          * ARIALNI.TTF, ARIALNB.TTF and ARIALNBI.TTF. Strangely, all fonts have</span>
<span class="line-modified">1268          * the same values in their sTypo* fields, except ARIALNB.ttf which</span>
<span class="line-modified">1269          * sets them to 0. All of them have different usWinAscent/Descent</span>
<span class="line-modified">1270          * values. The OS/2 table therefore cannot be trusted for computing the</span>
<span class="line-modified">1271          * text height reliably.</span>
<span class="line-modified">1272          *</span>
<span class="line-modified">1273          * As a compromise, do the following:</span>
<span class="line-modified">1274          *</span>
<span class="line-modified">1275          * 1. If the OS/2 table exists and the fsSelection bit 7 is set</span>
<span class="line-modified">1276          *    (USE_TYPO_METRICS), trust the font and use the sTypo* metrics.</span>
<span class="line-modified">1277          * 2. Otherwise, use the `hhea&#39; table&#39;s metrics.</span>
<span class="line-modified">1278          * 3. If they are zero and the OS/2 table exists,</span>
<span class="line-modified">1279          *    1. use the OS/2 table&#39;s sTypo* metrics if they are non-zero.</span>
<span class="line-modified">1280          *    2. Otherwise, use the OS/2 table&#39;s usWin* metrics.</span>
<span class="line-modified">1281          */</span>
<span class="line-modified">1282 </span>
<span class="line-added">1283         if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 128 )</span>
1284         {
<a name="19" id="anc19"></a><span class="line-modified">1285           root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1286           root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-modified">1287           root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1288                             face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">1289         }</span>
<span class="line-modified">1290         else</span>
<span class="line-added">1291         {</span>
<span class="line-added">1292           root-&gt;ascender  = face-&gt;horizontal.Ascender;</span>
<span class="line-added">1293           root-&gt;descender = face-&gt;horizontal.Descender;</span>
<span class="line-added">1294           root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">1295                             face-&gt;horizontal.Line_Gap;</span>
1296 
<a name="20" id="anc20"></a><span class="line-modified">1297           if ( !( root-&gt;ascender || root-&gt;descender ) )</span>
<span class="line-modified">1298           {</span>
<span class="line-modified">1299             if ( face-&gt;os2.version != 0xFFFFU )</span>

1300             {
<a name="21" id="anc21"></a><span class="line-modified">1301               if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">1302               {</span>
<span class="line-modified">1303                 root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1304                 root-&gt;descender = face-&gt;os2.sTypoDescender;</span>
<span class="line-added">1305                 root-&gt;height    = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-added">1306                                   face-&gt;os2.sTypoLineGap;</span>
<span class="line-added">1307               }</span>
<span class="line-added">1308               else</span>
<span class="line-added">1309               {</span>
<span class="line-added">1310                 root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-added">1311                 root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-added">1312                 root-&gt;height    =  root-&gt;ascender - root-&gt;descender;</span>
<span class="line-added">1313               }</span>
1314             }
1315           }
1316         }
1317 
1318         root-&gt;max_advance_width  =
1319           (FT_Short)face-&gt;horizontal.advance_Width_Max;
1320         root-&gt;max_advance_height =
1321           (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max
1322                                           : root-&gt;height );
1323 
1324         /* See https://www.microsoft.com/typography/otspec/post.htm -- */
1325         /* Adjust underline position from top edge to centre of        */
1326         /* stroke to convert TrueType meaning to FreeType meaning.     */
1327         root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1328                                     face-&gt;postscript.underlineThickness / 2;
1329         root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1330       }
1331 
1332     }
1333 
1334   Exit:
1335     FT_TRACE2(( &quot;sfnt_load_face: done\n&quot; ));
1336 
1337     return error;
1338   }
1339 
1340 
1341 #undef LOAD_
1342 #undef LOADM_
1343 #undef GET_NAME
1344 
1345 
1346   FT_LOCAL_DEF( void )
1347   sfnt_done_face( TT_Face  face )
1348   {
1349     FT_Memory     memory;
1350     SFNT_Service  sfnt;
1351 
1352 
1353     if ( !face )
1354       return;
1355 
1356     memory = face-&gt;root.memory;
1357     sfnt   = (SFNT_Service)face-&gt;sfnt;
1358 
1359     if ( sfnt )
1360     {
1361       /* destroy the postscript names table if it is loaded */
1362       if ( sfnt-&gt;free_psnames )
1363         sfnt-&gt;free_psnames( face );
1364 
1365       /* destroy the embedded bitmaps table if it is loaded */
1366       if ( sfnt-&gt;free_eblc )
1367         sfnt-&gt;free_eblc( face );
<a name="22" id="anc22"></a><span class="line-added">1368 </span>
<span class="line-added">1369       /* destroy color table data if it is loaded */</span>
<span class="line-added">1370       if ( sfnt-&gt;free_cpal )</span>
<span class="line-added">1371       {</span>
<span class="line-added">1372         sfnt-&gt;free_cpal( face );</span>
<span class="line-added">1373         sfnt-&gt;free_colr( face );</span>
<span class="line-added">1374       }</span>
1375     }
1376 
1377 #ifdef TT_CONFIG_OPTION_BDF
1378     /* freeing the embedded BDF properties */
1379     tt_face_free_bdf_props( face );
1380 #endif
1381 
1382     /* freeing the kerning table */
1383     tt_face_done_kern( face );
1384 
1385     /* freeing the collection table */
1386     FT_FREE( face-&gt;ttc_header.offsets );
1387     face-&gt;ttc_header.count = 0;
1388 
1389     /* freeing table directory */
1390     FT_FREE( face-&gt;dir_tables );
1391     face-&gt;num_tables = 0;
1392 
1393     {
1394       FT_Stream  stream = FT_FACE_STREAM( face );
1395 
1396 
1397       /* simply release the &#39;cmap&#39; table frame */
1398       FT_FRAME_RELEASE( face-&gt;cmap_table );
1399       face-&gt;cmap_size = 0;
1400     }
1401 
1402     face-&gt;horz_metrics_size = 0;
1403     face-&gt;vert_metrics_size = 0;
1404 
1405     /* freeing vertical metrics, if any */
1406     if ( face-&gt;vertical_info )
1407     {
1408       FT_FREE( face-&gt;vertical.long_metrics  );
1409       FT_FREE( face-&gt;vertical.short_metrics );
1410       face-&gt;vertical_info = 0;
1411     }
1412 
1413     /* freeing the gasp table */
1414     FT_FREE( face-&gt;gasp.gaspRanges );
1415     face-&gt;gasp.numRanges = 0;
1416 
1417     /* freeing the name table */
1418     if ( sfnt )
1419       sfnt-&gt;free_name( face );
1420 
1421     /* freeing family and style name */
1422     FT_FREE( face-&gt;root.family_name );
1423     FT_FREE( face-&gt;root.style_name );
1424 
1425     /* freeing sbit size table */
1426     FT_FREE( face-&gt;root.available_sizes );
1427     FT_FREE( face-&gt;sbit_strike_map );
1428     face-&gt;root.num_fixed_sizes = 0;
1429 
<a name="23" id="anc23"></a>
1430     FT_FREE( face-&gt;postscript_name );
<a name="24" id="anc24"></a><span class="line-added">1431 </span>
<span class="line-added">1432 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
1433     FT_FREE( face-&gt;var_postscript_prefix );
1434 #endif
1435 
<a name="25" id="anc25"></a><span class="line-added">1436     /* freeing glyph color palette data */</span>
<span class="line-added">1437     FT_FREE( face-&gt;palette_data.palette_name_ids );</span>
<span class="line-added">1438     FT_FREE( face-&gt;palette_data.palette_flags );</span>
<span class="line-added">1439     FT_FREE( face-&gt;palette_data.palette_entry_name_ids );</span>
<span class="line-added">1440     FT_FREE( face-&gt;palette );</span>
<span class="line-added">1441 </span>
1442     face-&gt;sfnt = NULL;
1443   }
1444 
1445 
1446 /* END */
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
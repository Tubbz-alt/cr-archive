<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/include/freetype/internal/ftstream.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftserv.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="fttrace.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/include/freetype/internal/ftstream.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftstream.h                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Stream handling (specification).                                     */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #ifndef FTSTREAM_H_
 20 #define FTSTREAM_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_SYSTEM_H
 25 #include FT_INTERNAL_OBJECTS_H
 26 
 27 
 28 FT_BEGIN_HEADER
 29 
 30 
 31   /* format of an 8-bit frame_op value:           */
 32   /*                                              */
 33   /* bit  76543210                                */
 34   /*      xxxxxxes                                */
 35   /*                                              */
 36   /* s is set to 1 if the value is signed.        */
</pre>
<hr />
<pre>
 79 
 80     ft_frame_bytes     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 0 ),
 81     ft_frame_skip      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 1 )
 82 
 83   } FT_Frame_Op;
 84 
 85 
 86   typedef struct  FT_Frame_Field_
 87   {
 88     FT_Byte    value;
 89     FT_Byte    size;
 90     FT_UShort  offset;
 91 
 92   } FT_Frame_Field;
 93 
 94 
 95   /* Construct an FT_Frame_Field out of a structure type and a field name. */
 96   /* The structure type must be set in the FT_STRUCTURE macro before       */
 97   /* calling the FT_FRAME_START() macro.                                   */
 98   /*                                                                       */
<span class="line-modified"> 99 #define FT_FIELD_SIZE( f ) \</span>
100           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f )
101 
<span class="line-modified">102 #define FT_FIELD_SIZE_DELTA( f ) \</span>
103           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f[0] )
104 
<span class="line-modified">105 #define FT_FIELD_OFFSET( f ) \</span>
106           (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
107 
108 #define FT_FRAME_FIELD( frame_op, field ) \
109           {                               \
110             frame_op,                     \
111             FT_FIELD_SIZE( field ),       \
112             FT_FIELD_OFFSET( field )      \
113           }
114 
115 #define FT_MAKE_EMPTY_FIELD( frame_op )  { frame_op, 0, 0 }
116 
117 #define FT_FRAME_START( size )   { ft_frame_start, 0, size }
118 #define FT_FRAME_END             { ft_frame_end, 0, 0 }
119 
120 #define FT_FRAME_LONG( f )       FT_FRAME_FIELD( ft_frame_long_be, f )
121 #define FT_FRAME_ULONG( f )      FT_FRAME_FIELD( ft_frame_ulong_be, f )
122 #define FT_FRAME_SHORT( f )      FT_FRAME_FIELD( ft_frame_short_be, f )
123 #define FT_FRAME_USHORT( f )     FT_FRAME_FIELD( ft_frame_ushort_be, f )
124 #define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
125 #define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
</pre>
<hr />
<pre>
130 #define FT_FRAME_ULONG_LE( f )   FT_FRAME_FIELD( ft_frame_ulong_le, f )
131 #define FT_FRAME_SHORT_LE( f )   FT_FRAME_FIELD( ft_frame_short_le, f )
132 #define FT_FRAME_USHORT_LE( f )  FT_FRAME_FIELD( ft_frame_ushort_le, f )
133 #define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
134 #define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
135 
136 #define FT_FRAME_SKIP_LONG       { ft_frame_long_be, 0, 0 }
137 #define FT_FRAME_SKIP_SHORT      { ft_frame_short_be, 0, 0 }
138 #define FT_FRAME_SKIP_BYTE       { ft_frame_byte, 0, 0 }
139 
140 #define FT_FRAME_BYTES( field, count ) \
141           {                            \
142             ft_frame_bytes,            \
143             count,                     \
144             FT_FIELD_OFFSET( field )   \
145           }
146 
147 #define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
148 
149 
<span class="line-modified">150   /*************************************************************************/</span>
<span class="line-modified">151   /*                                                                       */</span>
<span class="line-modified">152   /* Integer extraction macros -- the `buffer&#39; parameter must ALWAYS be of */</span>
<span class="line-modified">153   /* type `char*&#39; or equivalent (1-byte elements).                         */</span>
<span class="line-modified">154   /*                                                                       */</span>
155 
156 #define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
157 
158 #define FT_INT16( x )   ( (FT_Int16)(x)  )
159 #define FT_UINT16( x )  ( (FT_UInt16)(x) )
160 #define FT_INT32( x )   ( (FT_Int32)(x)  )
161 #define FT_UINT32( x )  ( (FT_UInt32)(x) )
162 
163 
164 #define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
165 #define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
166 
167 















168 #define FT_PEEK_SHORT( p )  FT_INT16( FT_BYTE_U16( p, 0, 8 ) | \
169                                       FT_BYTE_U16( p, 1, 0 ) )
170 
171 #define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
172                                         FT_BYTE_U16( p, 1, 0 ) )
173 
174 #define FT_PEEK_LONG( p )  FT_INT32( FT_BYTE_U32( p, 0, 24 ) | \
175                                      FT_BYTE_U32( p, 1, 16 ) | \
176                                      FT_BYTE_U32( p, 2,  8 ) | \
177                                      FT_BYTE_U32( p, 3,  0 ) )
178 
179 #define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
180                                        FT_BYTE_U32( p, 1, 16 ) | \
181                                        FT_BYTE_U32( p, 2,  8 ) | \
182                                        FT_BYTE_U32( p, 3,  0 ) )
183 
184 #define FT_PEEK_OFF3( p )  FT_INT32( FT_BYTE_U32( p, 0, 16 ) | \
185                                      FT_BYTE_U32( p, 1,  8 ) | \
186                                      FT_BYTE_U32( p, 2,  0 ) )
187 
</pre>
<hr />
<pre>
196                                            FT_BYTE_U16( p, 0, 0 ) )
197 
198 #define FT_PEEK_LONG_LE( p )  FT_INT32( FT_BYTE_U32( p, 3, 24 ) | \
199                                         FT_BYTE_U32( p, 2, 16 ) | \
200                                         FT_BYTE_U32( p, 1,  8 ) | \
201                                         FT_BYTE_U32( p, 0,  0 ) )
202 
203 #define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
204                                           FT_BYTE_U32( p, 2, 16 ) | \
205                                           FT_BYTE_U32( p, 1,  8 ) | \
206                                           FT_BYTE_U32( p, 0,  0 ) )
207 
208 #define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_BYTE_U32( p, 2, 16 ) | \
209                                         FT_BYTE_U32( p, 1,  8 ) | \
210                                         FT_BYTE_U32( p, 0,  0 ) )
211 
212 #define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
213                                           FT_BYTE_U32( p, 1,  8 ) | \
214                                           FT_BYTE_U32( p, 0,  0 ) )
215 
<span class="line-modified">216 </span>



217 #define FT_NEXT_CHAR( buffer )       \
218           ( (signed char)*buffer++ )
219 
220 #define FT_NEXT_BYTE( buffer )         \
221           ( (unsigned char)*buffer++ )
222 
223 #define FT_NEXT_SHORT( buffer )                                   \
224           ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
225 
226 #define FT_NEXT_USHORT( buffer )                                            \
227           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
228 
229 #define FT_NEXT_OFF3( buffer )                                  \
230           ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
231 
232 #define FT_NEXT_UOFF3( buffer )                                           \
233           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
234 
235 #define FT_NEXT_LONG( buffer )                                  \
236           ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
</pre>
<hr />
<pre>
241 
242 #define FT_NEXT_SHORT_LE( buffer )                                   \
243           ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
244 
245 #define FT_NEXT_USHORT_LE( buffer )                                            \
246           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
247 
248 #define FT_NEXT_OFF3_LE( buffer )                                  \
249           ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
250 
251 #define FT_NEXT_UOFF3_LE( buffer )                                           \
252           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
253 
254 #define FT_NEXT_LONG_LE( buffer )                                  \
255           ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
256 
257 #define FT_NEXT_ULONG_LE( buffer )                                           \
258           ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
259 
260 
<span class="line-modified">261   /*************************************************************************/</span>
<span class="line-modified">262   /*                                                                       */</span>
<span class="line-modified">263   /* Each GET_xxxx() macro uses an implicit `stream&#39; variable.             */</span>
<span class="line-modified">264   /*                                                                       */</span>




265 #if 0
266 #define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream-&gt;cursor )
267 
268 #define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
269 #define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
270 #define FT_GET_SHORT()      FT_GET_MACRO( SHORT )
271 #define FT_GET_USHORT()     FT_GET_MACRO( USHORT )
272 #define FT_GET_OFF3()       FT_GET_MACRO( OFF3 )
273 #define FT_GET_UOFF3()      FT_GET_MACRO( UOFF3 )
274 #define FT_GET_LONG()       FT_GET_MACRO( LONG )
275 #define FT_GET_ULONG()      FT_GET_MACRO( ULONG )
276 #define FT_GET_TAG4()       FT_GET_MACRO( ULONG )
277 
278 #define FT_GET_SHORT_LE()   FT_GET_MACRO( SHORT_LE )
279 #define FT_GET_USHORT_LE()  FT_GET_MACRO( USHORT_LE )
280 #define FT_GET_LONG_LE()    FT_GET_MACRO( LONG_LE )
281 #define FT_GET_ULONG_LE()   FT_GET_MACRO( ULONG_LE )
282 
283 #else
284 #define FT_GET_MACRO( func, type )        ( (type)func( stream ) )
285 
286 #define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
287 #define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
288 #define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )
289 #define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )
290 #define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )
291 #define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )
292 #define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )
293 #define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
294 #define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
295 
296 #define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )
297 #define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )
298 #define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )
299 #define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )
300 #endif
301 

302 #define FT_READ_MACRO( func, type, var )        \
303           ( var = (type)func( stream, &amp;error ), \
304             error != FT_Err_Ok )
305 







306 #define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
307 #define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
308 #define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )
309 #define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )
310 #define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )
311 #define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )
312 #define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )
313 #define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )
314 
315 #define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )
316 #define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )
317 #define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )
318 #define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )
319 
320 
321 #ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
322 
323   /* initialize a stream for reading a regular system stream */
324   FT_BASE( FT_Error )
325   FT_Stream_Open( FT_Stream    stream,
</pre>
<hr />
<pre>
370   FT_Stream_Read( FT_Stream  stream,
371                   FT_Byte*   buffer,
372                   FT_ULong   count );
373 
374   /* read bytes from a stream at a given position */
375   FT_BASE( FT_Error )
376   FT_Stream_ReadAt( FT_Stream  stream,
377                     FT_ULong   pos,
378                     FT_Byte*   buffer,
379                     FT_ULong   count );
380 
381   /* try to read bytes at the end of a stream; return number of bytes */
382   /* really available                                                 */
383   FT_BASE( FT_ULong )
384   FT_Stream_TryRead( FT_Stream  stream,
385                      FT_Byte*   buffer,
386                      FT_ULong   count );
387 
388   /* Enter a frame of `count&#39; consecutive bytes in a stream.  Returns an */
389   /* error if the frame could not be read/accessed.  The caller can use  */
<span class="line-modified">390   /* the FT_Stream_Get_XXX functions to retrieve frame data without      */</span>
391   /* error checks.                                                       */
392   /*                                                                     */
<span class="line-modified">393   /* You must _always_ call FT_Stream_ExitFrame() once you have entered  */</span>
394   /* a stream frame!                                                     */
395   /*                                                                     */


396   FT_BASE( FT_Error )
397   FT_Stream_EnterFrame( FT_Stream  stream,
398                         FT_ULong   count );
399 
400   /* exit a stream frame */
401   FT_BASE( void )
402   FT_Stream_ExitFrame( FT_Stream  stream );
403 

404   /* Extract a stream frame.  If the stream is disk-based, a heap block */
405   /* is allocated and the frame bytes are read into it.  If the stream  */
<span class="line-modified">406   /* is memory-based, this function simply set a pointer to the data.   */</span>
407   /*                                                                    */
408   /* Useful to optimize access to memory-based streams transparently.   */
409   /*                                                                    */
<span class="line-modified">410   /* All extracted frames must be `freed&#39; with a call to the function   */</span>
<span class="line-modified">411   /* FT_Stream_ReleaseFrame().                                          */</span>


412   /*                                                                    */
413   FT_BASE( FT_Error )
414   FT_Stream_ExtractFrame( FT_Stream  stream,
415                           FT_ULong   count,
416                           FT_Byte**  pbytes );
417 
<span class="line-modified">418   /* release an extract frame (see FT_Stream_ExtractFrame) */</span>
419   FT_BASE( void )
420   FT_Stream_ReleaseFrame( FT_Stream  stream,
421                           FT_Byte**  pbytes );
422 

423   /* read a byte from an entered frame */
424   FT_BASE( FT_Char )
425   FT_Stream_GetChar( FT_Stream  stream );
426 
427   /* read a 16-bit big-endian unsigned integer from an entered frame */
428   FT_BASE( FT_UShort )
429   FT_Stream_GetUShort( FT_Stream  stream );
430 
431   /* read a 24-bit big-endian unsigned integer from an entered frame */
432   FT_BASE( FT_ULong )
433   FT_Stream_GetUOffset( FT_Stream  stream );
434 
435   /* read a 32-bit big-endian unsigned integer from an entered frame */
436   FT_BASE( FT_ULong )
437   FT_Stream_GetULong( FT_Stream  stream );
438 
439   /* read a 16-bit little-endian unsigned integer from an entered frame */
440   FT_BASE( FT_UShort )
441   FT_Stream_GetUShortLE( FT_Stream  stream );
442 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftstream.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Stream handling (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef FTSTREAM_H_
 20 #define FTSTREAM_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_SYSTEM_H
 25 #include FT_INTERNAL_OBJECTS_H
 26 
 27 
 28 FT_BEGIN_HEADER
 29 
 30 
 31   /* format of an 8-bit frame_op value:           */
 32   /*                                              */
 33   /* bit  76543210                                */
 34   /*      xxxxxxes                                */
 35   /*                                              */
 36   /* s is set to 1 if the value is signed.        */
</pre>
<hr />
<pre>
 79 
 80     ft_frame_bytes     = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 0 ),
 81     ft_frame_skip      = FT_MAKE_FRAME_OP( FT_FRAME_OP_BYTES, 0, 1 )
 82 
 83   } FT_Frame_Op;
 84 
 85 
 86   typedef struct  FT_Frame_Field_
 87   {
 88     FT_Byte    value;
 89     FT_Byte    size;
 90     FT_UShort  offset;
 91 
 92   } FT_Frame_Field;
 93 
 94 
 95   /* Construct an FT_Frame_Field out of a structure type and a field name. */
 96   /* The structure type must be set in the FT_STRUCTURE macro before       */
 97   /* calling the FT_FRAME_START() macro.                                   */
 98   /*                                                                       */
<span class="line-modified"> 99 #define FT_FIELD_SIZE( f )                          \</span>
100           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f )
101 
<span class="line-modified">102 #define FT_FIELD_SIZE_DELTA( f )                       \</span>
103           (FT_Byte)sizeof ( ((FT_STRUCTURE*)0)-&gt;f[0] )
104 
<span class="line-modified">105 #define FT_FIELD_OFFSET( f )                         \</span>
106           (FT_UShort)( offsetof( FT_STRUCTURE, f ) )
107 
108 #define FT_FRAME_FIELD( frame_op, field ) \
109           {                               \
110             frame_op,                     \
111             FT_FIELD_SIZE( field ),       \
112             FT_FIELD_OFFSET( field )      \
113           }
114 
115 #define FT_MAKE_EMPTY_FIELD( frame_op )  { frame_op, 0, 0 }
116 
117 #define FT_FRAME_START( size )   { ft_frame_start, 0, size }
118 #define FT_FRAME_END             { ft_frame_end, 0, 0 }
119 
120 #define FT_FRAME_LONG( f )       FT_FRAME_FIELD( ft_frame_long_be, f )
121 #define FT_FRAME_ULONG( f )      FT_FRAME_FIELD( ft_frame_ulong_be, f )
122 #define FT_FRAME_SHORT( f )      FT_FRAME_FIELD( ft_frame_short_be, f )
123 #define FT_FRAME_USHORT( f )     FT_FRAME_FIELD( ft_frame_ushort_be, f )
124 #define FT_FRAME_OFF3( f )       FT_FRAME_FIELD( ft_frame_off3_be, f )
125 #define FT_FRAME_UOFF3( f )      FT_FRAME_FIELD( ft_frame_uoff3_be, f )
</pre>
<hr />
<pre>
130 #define FT_FRAME_ULONG_LE( f )   FT_FRAME_FIELD( ft_frame_ulong_le, f )
131 #define FT_FRAME_SHORT_LE( f )   FT_FRAME_FIELD( ft_frame_short_le, f )
132 #define FT_FRAME_USHORT_LE( f )  FT_FRAME_FIELD( ft_frame_ushort_le, f )
133 #define FT_FRAME_OFF3_LE( f )    FT_FRAME_FIELD( ft_frame_off3_le, f )
134 #define FT_FRAME_UOFF3_LE( f )   FT_FRAME_FIELD( ft_frame_uoff3_le, f )
135 
136 #define FT_FRAME_SKIP_LONG       { ft_frame_long_be, 0, 0 }
137 #define FT_FRAME_SKIP_SHORT      { ft_frame_short_be, 0, 0 }
138 #define FT_FRAME_SKIP_BYTE       { ft_frame_byte, 0, 0 }
139 
140 #define FT_FRAME_BYTES( field, count ) \
141           {                            \
142             ft_frame_bytes,            \
143             count,                     \
144             FT_FIELD_OFFSET( field )   \
145           }
146 
147 #define FT_FRAME_SKIP_BYTES( count )  { ft_frame_skip, count, 0 }
148 
149 
<span class="line-modified">150   /**************************************************************************</span>
<span class="line-modified">151    *</span>
<span class="line-modified">152    * Integer extraction macros -- the &#39;buffer&#39; parameter must ALWAYS be of</span>
<span class="line-modified">153    * type &#39;char*&#39; or equivalent (1-byte elements).</span>
<span class="line-modified">154    */</span>
155 
156 #define FT_BYTE_( p, i )  ( ((const FT_Byte*)(p))[(i)] )
157 
158 #define FT_INT16( x )   ( (FT_Int16)(x)  )
159 #define FT_UINT16( x )  ( (FT_UInt16)(x) )
160 #define FT_INT32( x )   ( (FT_Int32)(x)  )
161 #define FT_UINT32( x )  ( (FT_UInt32)(x) )
162 
163 
164 #define FT_BYTE_U16( p, i, s )  ( FT_UINT16( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
165 #define FT_BYTE_U32( p, i, s )  ( FT_UINT32( FT_BYTE_( p, i ) ) &lt;&lt; (s) )
166 
167 
<span class="line-added">168   /*</span>
<span class="line-added">169    *    function      acts on      increases  does range   for    emits</span>
<span class="line-added">170    *                                pointer    checking   frames  error</span>
<span class="line-added">171    *  -------------------------------------------------------------------</span>
<span class="line-added">172    *   FT_PEEK_XXX  buffer pointer      no         no        no     no</span>
<span class="line-added">173    *   FT_NEXT_XXX  buffer pointer     yes         no        no     no</span>
<span class="line-added">174    *   FT_GET_XXX   stream-&gt;cursor     yes        yes       yes     no</span>
<span class="line-added">175    *   FT_READ_XXX  stream-&gt;pos        yes        yes        no    yes</span>
<span class="line-added">176    */</span>
<span class="line-added">177 </span>
<span class="line-added">178 </span>
<span class="line-added">179   /*</span>
<span class="line-added">180    * `FT_PEEK_XXX&#39; are generic macros to get data from a buffer position.  No</span>
<span class="line-added">181    * safety checks are performed.</span>
<span class="line-added">182    */</span>
183 #define FT_PEEK_SHORT( p )  FT_INT16( FT_BYTE_U16( p, 0, 8 ) | \
184                                       FT_BYTE_U16( p, 1, 0 ) )
185 
186 #define FT_PEEK_USHORT( p )  FT_UINT16( FT_BYTE_U16( p, 0, 8 ) | \
187                                         FT_BYTE_U16( p, 1, 0 ) )
188 
189 #define FT_PEEK_LONG( p )  FT_INT32( FT_BYTE_U32( p, 0, 24 ) | \
190                                      FT_BYTE_U32( p, 1, 16 ) | \
191                                      FT_BYTE_U32( p, 2,  8 ) | \
192                                      FT_BYTE_U32( p, 3,  0 ) )
193 
194 #define FT_PEEK_ULONG( p )  FT_UINT32( FT_BYTE_U32( p, 0, 24 ) | \
195                                        FT_BYTE_U32( p, 1, 16 ) | \
196                                        FT_BYTE_U32( p, 2,  8 ) | \
197                                        FT_BYTE_U32( p, 3,  0 ) )
198 
199 #define FT_PEEK_OFF3( p )  FT_INT32( FT_BYTE_U32( p, 0, 16 ) | \
200                                      FT_BYTE_U32( p, 1,  8 ) | \
201                                      FT_BYTE_U32( p, 2,  0 ) )
202 
</pre>
<hr />
<pre>
211                                            FT_BYTE_U16( p, 0, 0 ) )
212 
213 #define FT_PEEK_LONG_LE( p )  FT_INT32( FT_BYTE_U32( p, 3, 24 ) | \
214                                         FT_BYTE_U32( p, 2, 16 ) | \
215                                         FT_BYTE_U32( p, 1,  8 ) | \
216                                         FT_BYTE_U32( p, 0,  0 ) )
217 
218 #define FT_PEEK_ULONG_LE( p )  FT_UINT32( FT_BYTE_U32( p, 3, 24 ) | \
219                                           FT_BYTE_U32( p, 2, 16 ) | \
220                                           FT_BYTE_U32( p, 1,  8 ) | \
221                                           FT_BYTE_U32( p, 0,  0 ) )
222 
223 #define FT_PEEK_OFF3_LE( p )  FT_INT32( FT_BYTE_U32( p, 2, 16 ) | \
224                                         FT_BYTE_U32( p, 1,  8 ) | \
225                                         FT_BYTE_U32( p, 0,  0 ) )
226 
227 #define FT_PEEK_UOFF3_LE( p )  FT_UINT32( FT_BYTE_U32( p, 2, 16 ) | \
228                                           FT_BYTE_U32( p, 1,  8 ) | \
229                                           FT_BYTE_U32( p, 0,  0 ) )
230 
<span class="line-modified">231   /*</span>
<span class="line-added">232    * `FT_NEXT_XXX&#39; are generic macros to get data from a buffer position</span>
<span class="line-added">233    * which is then increased appropriately.  No safety checks are performed.</span>
<span class="line-added">234    */</span>
235 #define FT_NEXT_CHAR( buffer )       \
236           ( (signed char)*buffer++ )
237 
238 #define FT_NEXT_BYTE( buffer )         \
239           ( (unsigned char)*buffer++ )
240 
241 #define FT_NEXT_SHORT( buffer )                                   \
242           ( (short)( buffer += 2, FT_PEEK_SHORT( buffer - 2 ) ) )
243 
244 #define FT_NEXT_USHORT( buffer )                                            \
245           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT( buffer - 2 ) ) )
246 
247 #define FT_NEXT_OFF3( buffer )                                  \
248           ( (long)( buffer += 3, FT_PEEK_OFF3( buffer - 3 ) ) )
249 
250 #define FT_NEXT_UOFF3( buffer )                                           \
251           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3( buffer - 3 ) ) )
252 
253 #define FT_NEXT_LONG( buffer )                                  \
254           ( (long)( buffer += 4, FT_PEEK_LONG( buffer - 4 ) ) )
</pre>
<hr />
<pre>
259 
260 #define FT_NEXT_SHORT_LE( buffer )                                   \
261           ( (short)( buffer += 2, FT_PEEK_SHORT_LE( buffer - 2 ) ) )
262 
263 #define FT_NEXT_USHORT_LE( buffer )                                            \
264           ( (unsigned short)( buffer += 2, FT_PEEK_USHORT_LE( buffer - 2 ) ) )
265 
266 #define FT_NEXT_OFF3_LE( buffer )                                  \
267           ( (long)( buffer += 3, FT_PEEK_OFF3_LE( buffer - 3 ) ) )
268 
269 #define FT_NEXT_UOFF3_LE( buffer )                                           \
270           ( (unsigned long)( buffer += 3, FT_PEEK_UOFF3_LE( buffer - 3 ) ) )
271 
272 #define FT_NEXT_LONG_LE( buffer )                                  \
273           ( (long)( buffer += 4, FT_PEEK_LONG_LE( buffer - 4 ) ) )
274 
275 #define FT_NEXT_ULONG_LE( buffer )                                           \
276           ( (unsigned long)( buffer += 4, FT_PEEK_ULONG_LE( buffer - 4 ) ) )
277 
278 
<span class="line-modified">279   /**************************************************************************</span>
<span class="line-modified">280    *</span>
<span class="line-modified">281    * The `FT_GET_XXX` macros use an implicit &#39;stream&#39; variable.</span>
<span class="line-modified">282    *</span>
<span class="line-added">283    * Note that a call to `FT_STREAM_SEEK` or `FT_STREAM_POS` has **no**</span>
<span class="line-added">284    * effect on `FT_GET_XXX`!  They operate on `stream-&gt;pos`, while</span>
<span class="line-added">285    * `FT_GET_XXX` use `stream-&gt;cursor`.</span>
<span class="line-added">286    */</span>
287 #if 0
288 #define FT_GET_MACRO( type )    FT_NEXT_ ## type ( stream-&gt;cursor )
289 
290 #define FT_GET_CHAR()       FT_GET_MACRO( CHAR )
291 #define FT_GET_BYTE()       FT_GET_MACRO( BYTE )
292 #define FT_GET_SHORT()      FT_GET_MACRO( SHORT )
293 #define FT_GET_USHORT()     FT_GET_MACRO( USHORT )
294 #define FT_GET_OFF3()       FT_GET_MACRO( OFF3 )
295 #define FT_GET_UOFF3()      FT_GET_MACRO( UOFF3 )
296 #define FT_GET_LONG()       FT_GET_MACRO( LONG )
297 #define FT_GET_ULONG()      FT_GET_MACRO( ULONG )
298 #define FT_GET_TAG4()       FT_GET_MACRO( ULONG )
299 
300 #define FT_GET_SHORT_LE()   FT_GET_MACRO( SHORT_LE )
301 #define FT_GET_USHORT_LE()  FT_GET_MACRO( USHORT_LE )
302 #define FT_GET_LONG_LE()    FT_GET_MACRO( LONG_LE )
303 #define FT_GET_ULONG_LE()   FT_GET_MACRO( ULONG_LE )
304 
305 #else
306 #define FT_GET_MACRO( func, type )        ( (type)func( stream ) )
307 
308 #define FT_GET_CHAR()       FT_GET_MACRO( FT_Stream_GetChar, FT_Char )
309 #define FT_GET_BYTE()       FT_GET_MACRO( FT_Stream_GetChar, FT_Byte )
310 #define FT_GET_SHORT()      FT_GET_MACRO( FT_Stream_GetUShort, FT_Short )
311 #define FT_GET_USHORT()     FT_GET_MACRO( FT_Stream_GetUShort, FT_UShort )
312 #define FT_GET_OFF3()       FT_GET_MACRO( FT_Stream_GetUOffset, FT_Long )
313 #define FT_GET_UOFF3()      FT_GET_MACRO( FT_Stream_GetUOffset, FT_ULong )
314 #define FT_GET_LONG()       FT_GET_MACRO( FT_Stream_GetULong, FT_Long )
315 #define FT_GET_ULONG()      FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
316 #define FT_GET_TAG4()       FT_GET_MACRO( FT_Stream_GetULong, FT_ULong )
317 
318 #define FT_GET_SHORT_LE()   FT_GET_MACRO( FT_Stream_GetUShortLE, FT_Short )
319 #define FT_GET_USHORT_LE()  FT_GET_MACRO( FT_Stream_GetUShortLE, FT_UShort )
320 #define FT_GET_LONG_LE()    FT_GET_MACRO( FT_Stream_GetULongLE, FT_Long )
321 #define FT_GET_ULONG_LE()   FT_GET_MACRO( FT_Stream_GetULongLE, FT_ULong )
322 #endif
323 
<span class="line-added">324 </span>
325 #define FT_READ_MACRO( func, type, var )        \
326           ( var = (type)func( stream, &amp;error ), \
327             error != FT_Err_Ok )
328 
<span class="line-added">329   /*</span>
<span class="line-added">330    * The `FT_READ_XXX&#39; macros use implicit `stream&#39; and `error&#39; variables.</span>
<span class="line-added">331    *</span>
<span class="line-added">332    * `FT_READ_XXX&#39; can be controlled with `FT_STREAM_SEEK&#39; and</span>
<span class="line-added">333    * `FT_STREAM_POS&#39;.  They use the full machinery to check whether a read is</span>
<span class="line-added">334    * valid.</span>
<span class="line-added">335    */</span>
336 #define FT_READ_BYTE( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Byte, var )
337 #define FT_READ_CHAR( var )       FT_READ_MACRO( FT_Stream_ReadChar, FT_Char, var )
338 #define FT_READ_SHORT( var )      FT_READ_MACRO( FT_Stream_ReadUShort, FT_Short, var )
339 #define FT_READ_USHORT( var )     FT_READ_MACRO( FT_Stream_ReadUShort, FT_UShort, var )
340 #define FT_READ_OFF3( var )       FT_READ_MACRO( FT_Stream_ReadUOffset, FT_Long, var )
341 #define FT_READ_UOFF3( var )      FT_READ_MACRO( FT_Stream_ReadUOffset, FT_ULong, var )
342 #define FT_READ_LONG( var )       FT_READ_MACRO( FT_Stream_ReadULong, FT_Long, var )
343 #define FT_READ_ULONG( var )      FT_READ_MACRO( FT_Stream_ReadULong, FT_ULong, var )
344 
345 #define FT_READ_SHORT_LE( var )   FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_Short, var )
346 #define FT_READ_USHORT_LE( var )  FT_READ_MACRO( FT_Stream_ReadUShortLE, FT_UShort, var )
347 #define FT_READ_LONG_LE( var )    FT_READ_MACRO( FT_Stream_ReadULongLE, FT_Long, var )
348 #define FT_READ_ULONG_LE( var )   FT_READ_MACRO( FT_Stream_ReadULongLE, FT_ULong, var )
349 
350 
351 #ifndef FT_CONFIG_OPTION_NO_DEFAULT_SYSTEM
352 
353   /* initialize a stream for reading a regular system stream */
354   FT_BASE( FT_Error )
355   FT_Stream_Open( FT_Stream    stream,
</pre>
<hr />
<pre>
400   FT_Stream_Read( FT_Stream  stream,
401                   FT_Byte*   buffer,
402                   FT_ULong   count );
403 
404   /* read bytes from a stream at a given position */
405   FT_BASE( FT_Error )
406   FT_Stream_ReadAt( FT_Stream  stream,
407                     FT_ULong   pos,
408                     FT_Byte*   buffer,
409                     FT_ULong   count );
410 
411   /* try to read bytes at the end of a stream; return number of bytes */
412   /* really available                                                 */
413   FT_BASE( FT_ULong )
414   FT_Stream_TryRead( FT_Stream  stream,
415                      FT_Byte*   buffer,
416                      FT_ULong   count );
417 
418   /* Enter a frame of `count&#39; consecutive bytes in a stream.  Returns an */
419   /* error if the frame could not be read/accessed.  The caller can use  */
<span class="line-modified">420   /* the `FT_Stream_GetXXX&#39; functions to retrieve frame data without     */</span>
421   /* error checks.                                                       */
422   /*                                                                     */
<span class="line-modified">423   /* You must _always_ call `FT_Stream_ExitFrame&#39; once you have entered  */</span>
424   /* a stream frame!                                                     */
425   /*                                                                     */
<span class="line-added">426   /* Nested frames are not permitted.                                    */</span>
<span class="line-added">427   /*                                                                     */</span>
428   FT_BASE( FT_Error )
429   FT_Stream_EnterFrame( FT_Stream  stream,
430                         FT_ULong   count );
431 
432   /* exit a stream frame */
433   FT_BASE( void )
434   FT_Stream_ExitFrame( FT_Stream  stream );
435 
<span class="line-added">436 </span>
437   /* Extract a stream frame.  If the stream is disk-based, a heap block */
438   /* is allocated and the frame bytes are read into it.  If the stream  */
<span class="line-modified">439   /* is memory-based, this function simply sets a pointer to the data.  */</span>
440   /*                                                                    */
441   /* Useful to optimize access to memory-based streams transparently.   */
442   /*                                                                    */
<span class="line-modified">443   /* `FT_Stream_GetXXX&#39; functions can&#39;t be used.                        */</span>
<span class="line-modified">444   /*                                                                    */</span>
<span class="line-added">445   /* An extracted frame must be `freed&#39; with a call to the function     */</span>
<span class="line-added">446   /* `FT_Stream_ReleaseFrame&#39;.                                          */</span>
447   /*                                                                    */
448   FT_BASE( FT_Error )
449   FT_Stream_ExtractFrame( FT_Stream  stream,
450                           FT_ULong   count,
451                           FT_Byte**  pbytes );
452 
<span class="line-modified">453   /* release an extract frame (see `FT_Stream_ExtractFrame&#39;) */</span>
454   FT_BASE( void )
455   FT_Stream_ReleaseFrame( FT_Stream  stream,
456                           FT_Byte**  pbytes );
457 
<span class="line-added">458 </span>
459   /* read a byte from an entered frame */
460   FT_BASE( FT_Char )
461   FT_Stream_GetChar( FT_Stream  stream );
462 
463   /* read a 16-bit big-endian unsigned integer from an entered frame */
464   FT_BASE( FT_UShort )
465   FT_Stream_GetUShort( FT_Stream  stream );
466 
467   /* read a 24-bit big-endian unsigned integer from an entered frame */
468   FT_BASE( FT_ULong )
469   FT_Stream_GetUOffset( FT_Stream  stream );
470 
471   /* read a 32-bit big-endian unsigned integer from an entered frame */
472   FT_BASE( FT_ULong )
473   FT_Stream_GetULong( FT_Stream  stream );
474 
475   /* read a 16-bit little-endian unsigned integer from an entered frame */
476   FT_BASE( FT_UShort )
477   FT_Stream_GetUShortLE( FT_Stream  stream );
478 
</pre>
</td>
</tr>
</table>
<center><a href="ftserv.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="fttrace.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
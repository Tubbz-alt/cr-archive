<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfreetype/src/cid/cidload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /***************************************************************************/
  2 /*                                                                         */
  3 /*  cidload.c                                                              */
  4 /*                                                                         */
  5 /*    CID-keyed Type1 font loader (body).                                  */
  6 /*                                                                         */
  7 /*  Copyright 1996-2018 by                                                 */
  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
  9 /*                                                                         */
 10 /*  This file is part of the FreeType project, and may only be used,       */
 11 /*  modified, and distributed under the terms of the FreeType project      */
 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 13 /*  this file you indicate that you have read the license and              */
 14 /*  understand and accept it fully.                                        */
 15 /*                                                                         */
 16 /***************************************************************************/
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_CONFIG_CONFIG_H
 22 #include FT_MULTIPLE_MASTERS_H
 23 #include FT_INTERNAL_TYPE1_TYPES_H
 24 
 25 #include &quot;cidload.h&quot;
 26 
 27 #include &quot;ciderrs.h&quot;
 28 
 29 
 30   /*************************************************************************/
 31   /*                                                                       */
 32   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
 33   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
 34   /* messages during execution.                                            */
 35   /*                                                                       */
 36 #undef  FT_COMPONENT
 37 #define FT_COMPONENT  trace_cidload
 38 
 39 
 40   /* read a single offset */
 41   FT_LOCAL_DEF( FT_ULong )
 42   cid_get_offset( FT_Byte*  *start,
 43                   FT_Byte    offsize )
 44   {
 45     FT_ULong  result;
 46     FT_Byte*  p = *start;
 47 
 48 
 49     for ( result = 0; offsize &gt; 0; offsize-- )
 50     {
 51       result &lt;&lt;= 8;
 52       result  |= *p++;
 53     }
 54 
 55     *start = p;
 56     return result;
 57   }
 58 
 59 
 60   /*************************************************************************/
 61   /*************************************************************************/
 62   /*****                                                               *****/
 63   /*****                    TYPE 1 SYMBOL PARSING                      *****/
 64   /*****                                                               *****/
 65   /*************************************************************************/
 66   /*************************************************************************/
 67 
 68 
 69   static FT_Error
 70   cid_load_keyword( CID_Face        face,
 71                     CID_Loader*     loader,
 72                     const T1_Field  keyword )
 73   {
 74     FT_Error      error;
 75     CID_Parser*   parser = &amp;loader-&gt;parser;
 76     FT_Byte*      object;
 77     void*         dummy_object;
 78     CID_FaceInfo  cid = &amp;face-&gt;cid;
 79 
 80 
 81     /* if the keyword has a dedicated callback, call it */
 82     if ( keyword-&gt;type == T1_FIELD_TYPE_CALLBACK )
 83     {
 84       keyword-&gt;reader( (FT_Face)face, parser );
 85       error = parser-&gt;root.error;
 86       goto Exit;
 87     }
 88 
 89     /* we must now compute the address of our target object */
 90     switch ( keyword-&gt;location )
 91     {
 92     case T1_FIELD_LOCATION_CID_INFO:
 93       object = (FT_Byte*)cid;
 94       break;
 95 
 96     case T1_FIELD_LOCATION_FONT_INFO:
 97       object = (FT_Byte*)&amp;cid-&gt;font_info;
 98       break;
 99 
100     case T1_FIELD_LOCATION_FONT_EXTRA:
101       object = (FT_Byte*)&amp;face-&gt;font_extra;
102       break;
103 
104     case T1_FIELD_LOCATION_BBOX:
105       object = (FT_Byte*)&amp;cid-&gt;font_bbox;
106       break;
107 
108     default:
109       {
110         CID_FaceDict  dict;
111 
112 
113         if ( parser-&gt;num_dict &lt; 0 || parser-&gt;num_dict &gt;= cid-&gt;num_dicts )
114         {
115           FT_ERROR(( &quot;cid_load_keyword: invalid use of `%s&#39;\n&quot;,
116                      keyword-&gt;ident ));
117           error = FT_THROW( Syntax_Error );
118           goto Exit;
119         }
120 
121         dict = cid-&gt;font_dicts + parser-&gt;num_dict;
122         switch ( keyword-&gt;location )
123         {
124         case T1_FIELD_LOCATION_PRIVATE:
125           object = (FT_Byte*)&amp;dict-&gt;private_dict;
126           break;
127 
128         default:
129           object = (FT_Byte*)dict;
130         }
131       }
132     }
133 
134     dummy_object = object;
135 
136     /* now, load the keyword data in the object&#39;s field(s) */
137     if ( keyword-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
138          keyword-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
139       error = cid_parser_load_field_table( &amp;loader-&gt;parser, keyword,
140                                            &amp;dummy_object );
141     else
142       error = cid_parser_load_field( &amp;loader-&gt;parser,
143                                      keyword, &amp;dummy_object );
144   Exit:
145     return error;
146   }
147 
148 
149   FT_CALLBACK_DEF( FT_Error )
150   cid_parse_font_matrix( CID_Face     face,
151                          CID_Parser*  parser )
152   {
153     CID_FaceDict  dict;
154     FT_Face       root = (FT_Face)&amp;face-&gt;root;
155     FT_Fixed      temp[6];
156     FT_Fixed      temp_scale;
157 
158 
159     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
160     {
161       FT_Matrix*  matrix;
162       FT_Vector*  offset;
163       FT_Int      result;
164 
165 
166       dict   = face-&gt;cid.font_dicts + parser-&gt;num_dict;
167       matrix = &amp;dict-&gt;font_matrix;
168       offset = &amp;dict-&gt;font_offset;
169 
170       /* input is scaled by 1000 to accommodate default FontMatrix */
171       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
172 
173       if ( result &lt; 6 )
174         return FT_THROW( Invalid_File_Format );
175 
176       temp_scale = FT_ABS( temp[3] );
177 
178       if ( temp_scale == 0 )
179       {
180         FT_ERROR(( &quot;cid_parse_font_matrix: invalid font matrix\n&quot; ));
181         return FT_THROW( Invalid_File_Format );
182       }
183 
184       /* atypical case */
185       if ( temp_scale != 0x10000L )
186       {
187         /* set units per EM based on FontMatrix values */
188         root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
189 
190         temp[0] = FT_DivFix( temp[0], temp_scale );
191         temp[1] = FT_DivFix( temp[1], temp_scale );
192         temp[2] = FT_DivFix( temp[2], temp_scale );
193         temp[4] = FT_DivFix( temp[4], temp_scale );
194         temp[5] = FT_DivFix( temp[5], temp_scale );
195         temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
196       }
197 
198       matrix-&gt;xx = temp[0];
199       matrix-&gt;yx = temp[1];
200       matrix-&gt;xy = temp[2];
201       matrix-&gt;yy = temp[3];
202 
203       /* note that the font offsets are expressed in integer font units */
204       offset-&gt;x  = temp[4] &gt;&gt; 16;
205       offset-&gt;y  = temp[5] &gt;&gt; 16;
206     }
207 
208     return FT_Err_Ok;
209   }
210 
211 
212   FT_CALLBACK_DEF( FT_Error )
213   parse_fd_array( CID_Face     face,
214                   CID_Parser*  parser )
215   {
216     CID_FaceInfo  cid    = &amp;face-&gt;cid;
217     FT_Memory     memory = face-&gt;root.memory;
218     FT_Stream     stream = parser-&gt;stream;
219     FT_Error      error  = FT_Err_Ok;
220     FT_Long       num_dicts;
221 
222 
223     num_dicts = cid_parser_to_int( parser );
224     if ( num_dicts &lt; 0 )
225     {
226       FT_ERROR(( &quot;parse_fd_array: invalid number of dictionaries\n&quot; ));
227       error = FT_THROW( Invalid_File_Format );
228       goto Exit;
229     }
230 
231     /*
232      * A single entry in the FDArray must (at least) contain the following
233      * structure elements.
234      *
235      *   %ADOBeginFontDict              18
236      *   X dict begin                   13
237      *     /FontMatrix [X X X X]        22
238      *     /Private X dict begin        22
239      *     end                           4
240      *   end                             4
241      *   %ADOEndFontDict                16
242      *
243      * This needs 18+13+22+22+4+4+16=99 bytes or more.  Normally, you also
244      * need a `dup X&#39; at the very beginning and a `put&#39; at the end, so a
245      * rough guess using 100 bytes as the minimum is justified.
246      */
247     if ( (FT_ULong)num_dicts &gt; stream-&gt;size / 100 )
248     {
249       FT_TRACE0(( &quot;parse_fd_array: adjusting FDArray size&quot;
250                   &quot; (from %d to %d)\n&quot;,
251                   num_dicts,
252                   stream-&gt;size / 100 ));
253       num_dicts = (FT_Long)( stream-&gt;size / 100 );
254     }
255 
256     if ( !cid-&gt;font_dicts )
257     {
258       FT_Int  n;
259 
260 
261       if ( FT_NEW_ARRAY( cid-&gt;font_dicts, num_dicts ) )
262         goto Exit;
263 
264       cid-&gt;num_dicts = num_dicts;
265 
266       /* don&#39;t forget to set a few defaults */
267       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
268       {
269         CID_FaceDict  dict = cid-&gt;font_dicts + n;
270 
271 
272         /* default value for lenIV */
273         dict-&gt;private_dict.lenIV = 4;
274       }
275     }
276 
277   Exit:
278     return error;
279   }
280 
281 
282   /* by mistake, `expansion_factor&#39; appears both in PS_PrivateRec */
283   /* and CID_FaceDictRec (both are public header files and can&#39;t  */
284   /* changed); we simply copy the value                           */
285 
286   FT_CALLBACK_DEF( FT_Error )
287   parse_expansion_factor( CID_Face     face,
288                           CID_Parser*  parser )
289   {
290     CID_FaceDict  dict;
291 
292 
293     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
294     {
295       dict = face-&gt;cid.font_dicts + parser-&gt;num_dict;
296 
297       dict-&gt;expansion_factor              = cid_parser_to_fixed( parser, 0 );
298       dict-&gt;private_dict.expansion_factor = dict-&gt;expansion_factor;
299     }
300 
301     return FT_Err_Ok;
302   }
303 
304 
305   static
306   const T1_FieldRec  cid_field_records[] =
307   {
308 
309 #include &quot;cidtoken.h&quot;
310 
311     T1_FIELD_CALLBACK( &quot;FDArray&quot;,         parse_fd_array, 0 )
312     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,      cid_parse_font_matrix, 0 )
313     T1_FIELD_CALLBACK( &quot;ExpansionFactor&quot;, parse_expansion_factor, 0 )
314 
315     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
316   };
317 
318 
319   static FT_Error
320   cid_parse_dict( CID_Face     face,
321                   CID_Loader*  loader,
322                   FT_Byte*     base,
323                   FT_ULong     size )
324   {
325     CID_Parser*  parser = &amp;loader-&gt;parser;
326 
327 
328     parser-&gt;root.cursor = base;
329     parser-&gt;root.limit  = base + size;
330     parser-&gt;root.error  = FT_Err_Ok;
331 
332     {
333       FT_Byte*  cur   = base;
334       FT_Byte*  limit = cur + size;
335 
336 
337       for (;;)
338       {
339         FT_Byte*  newlimit;
340 
341 
342         parser-&gt;root.cursor = cur;
343         cid_parser_skip_spaces( parser );
344 
345         if ( parser-&gt;root.cursor &gt;= limit )
346           newlimit = limit - 1 - 17;
347         else
348           newlimit = parser-&gt;root.cursor - 17;
349 
350         /* look for `%ADOBeginFontDict&#39; */
351         for ( ; cur &lt; newlimit; cur++ )
352         {
353           if ( *cur == &#39;%&#39;                                            &amp;&amp;
354                ft_strncmp( (char*)cur, &quot;%ADOBeginFontDict&quot;, 17 ) == 0 )
355           {
356             /* if /FDArray was found, then cid-&gt;num_dicts is &gt; 0, and */
357             /* we can start increasing parser-&gt;num_dict               */
358             if ( face-&gt;cid.num_dicts &gt; 0 )
359               parser-&gt;num_dict++;
360           }
361         }
362 
363         cur = parser-&gt;root.cursor;
364         /* no error can occur in cid_parser_skip_spaces */
365         if ( cur &gt;= limit )
366           break;
367 
368         cid_parser_skip_PS_token( parser );
369         if ( parser-&gt;root.cursor &gt;= limit || parser-&gt;root.error )
370           break;
371 
372         /* look for immediates */
373         if ( *cur == &#39;/&#39; &amp;&amp; cur + 2 &lt; limit )
374         {
375           FT_UInt  len;
376 
377 
378           cur++;
379           len = (FT_UInt)( parser-&gt;root.cursor - cur );
380 
381           if ( len &gt; 0 &amp;&amp; len &lt; 22 )
382           {
383             /* now compare the immediate name to the keyword table */
384             T1_Field  keyword = (T1_Field)cid_field_records;
385 
386 
387             for (;;)
388             {
389               FT_Byte*  name;
390 
391 
392               name = (FT_Byte*)keyword-&gt;ident;
393               if ( !name )
394                 break;
395 
396               if ( cur[0] == name[0]                     &amp;&amp;
397                    len == ft_strlen( (const char*)name ) )
398               {
399                 FT_UInt  n;
400 
401 
402                 for ( n = 1; n &lt; len; n++ )
403                   if ( cur[n] != name[n] )
404                     break;
405 
406                 if ( n &gt;= len )
407                 {
408                   /* we found it - run the parsing callback */
409                   parser-&gt;root.error = cid_load_keyword( face,
410                                                          loader,
411                                                          keyword );
412                   if ( parser-&gt;root.error )
413                     return parser-&gt;root.error;
414                   break;
415                 }
416               }
417               keyword++;
418             }
419           }
420         }
421 
422         cur = parser-&gt;root.cursor;
423       }
424 
425       if ( !face-&gt;cid.num_dicts )
426       {
427         FT_ERROR(( &quot;cid_parse_dict: No font dictionary found\n&quot; ));
428         return FT_THROW( Invalid_File_Format );
429       }
430     }
431 
432     return parser-&gt;root.error;
433   }
434 
435 
436   /* read the subrmap and the subrs of each font dict */
437   static FT_Error
438   cid_read_subrs( CID_Face  face )
439   {
440     CID_FaceInfo   cid    = &amp;face-&gt;cid;
441     FT_Memory      memory = face-&gt;root.memory;
442     FT_Stream      stream = face-&gt;cid_stream;
443     FT_Error       error;
444     FT_Int         n;
445     CID_Subrs      subr;
446     FT_UInt        max_offsets = 0;
447     FT_ULong*      offsets = NULL;
448     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
449 
450 
451     if ( FT_NEW_ARRAY( face-&gt;subrs, cid-&gt;num_dicts ) )
452       goto Exit;
453 
454     subr = face-&gt;subrs;
455     for ( n = 0; n &lt; cid-&gt;num_dicts; n++, subr++ )
456     {
457       CID_FaceDict  dict  = cid-&gt;font_dicts + n;
458       FT_Int        lenIV = dict-&gt;private_dict.lenIV;
459       FT_UInt       count, num_subrs = dict-&gt;num_subrs;
460       FT_ULong      data_len;
461       FT_Byte*      p;
462 
463 
464       if ( !num_subrs )
465         continue;
466 
467       /* reallocate offsets array if needed */
468       if ( num_subrs + 1 &gt; max_offsets )
469       {
470         FT_UInt  new_max = FT_PAD_CEIL( num_subrs + 1, 4 );
471 
472 
473         if ( new_max &lt;= max_offsets )
474         {
475           error = FT_THROW( Syntax_Error );
476           goto Fail;
477         }
478 
479         if ( FT_RENEW_ARRAY( offsets, max_offsets, new_max ) )
480           goto Fail;
481 
482         max_offsets = new_max;
483       }
484 
485       /* read the subrmap&#39;s offsets */
486       if ( FT_STREAM_SEEK( cid-&gt;data_offset + dict-&gt;subrmap_offset )     ||
487            FT_FRAME_ENTER( ( num_subrs + 1 ) * (FT_UInt)dict-&gt;sd_bytes ) )
488         goto Fail;
489 
490       p = (FT_Byte*)stream-&gt;cursor;
491       for ( count = 0; count &lt;= num_subrs; count++ )
492         offsets[count] = cid_get_offset( &amp;p, (FT_Byte)dict-&gt;sd_bytes );
493 
494       FT_FRAME_EXIT();
495 
496       /* offsets must be ordered */
497       for ( count = 1; count &lt;= num_subrs; count++ )
498         if ( offsets[count - 1] &gt; offsets[count] )
499         {
500           FT_ERROR(( &quot;cid_read_subrs: offsets are not ordered\n&quot; ));
501           error = FT_THROW( Invalid_File_Format );
502           goto Fail;
503         }
504 
505       if ( offsets[num_subrs] &gt; stream-&gt;size - cid-&gt;data_offset )
506       {
507         FT_ERROR(( &quot;cid_read_subrs: too large `subrs&#39; offsets\n&quot; ));
508         error = FT_THROW( Invalid_File_Format );
509         goto Fail;
510       }
511 
512       /* now, compute the size of subrs charstrings, */
513       /* allocate, and read them                     */
514       data_len = offsets[num_subrs] - offsets[0];
515 
516       if ( FT_NEW_ARRAY( subr-&gt;code, num_subrs + 1 ) ||
517            FT_ALLOC( subr-&gt;code[0], data_len )       )
518         goto Fail;
519 
520       if ( FT_STREAM_SEEK( cid-&gt;data_offset + offsets[0] ) ||
521            FT_STREAM_READ( subr-&gt;code[0], data_len )  )
522         goto Fail;
523 
524       /* set up pointers */
525       for ( count = 1; count &lt;= num_subrs; count++ )
526       {
527         FT_ULong  len;
528 
529 
530         len               = offsets[count] - offsets[count - 1];
531         subr-&gt;code[count] = subr-&gt;code[count - 1] + len;
532       }
533 
534       /* decrypt subroutines, but only if lenIV &gt;= 0 */
535       if ( lenIV &gt;= 0 )
536       {
537         for ( count = 0; count &lt; num_subrs; count++ )
538         {
539           FT_ULong  len;
540 
541 
542           len = offsets[count + 1] - offsets[count];
543           psaux-&gt;t1_decrypt( subr-&gt;code[count], len, 4330 );
544         }
545       }
546 
547       subr-&gt;num_subrs = (FT_Int)num_subrs;
548     }
549 
550   Exit:
551     FT_FREE( offsets );
552     return error;
553 
554   Fail:
555     if ( face-&gt;subrs )
556     {
557       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
558       {
559         if ( face-&gt;subrs[n].code )
560           FT_FREE( face-&gt;subrs[n].code[0] );
561 
562         FT_FREE( face-&gt;subrs[n].code );
563       }
564       FT_FREE( face-&gt;subrs );
565     }
566     goto Exit;
567   }
568 
569 
570   static void
571   cid_init_loader( CID_Loader*  loader,
572                    CID_Face     face )
573   {
574     FT_UNUSED( face );
575 
576     FT_ZERO( loader );
577   }
578 
579 
580   static  void
581   cid_done_loader( CID_Loader*  loader )
582   {
583     CID_Parser*  parser = &amp;loader-&gt;parser;
584 
585 
586     /* finalize parser */
587     cid_parser_done( parser );
588   }
589 
590 
591   static FT_Error
592   cid_hex_to_binary( FT_Byte*  data,
593                      FT_ULong  data_len,
594                      FT_ULong  offset,
595                      CID_Face  face )
596   {
597     FT_Stream  stream = face-&gt;root.stream;
598     FT_Error   error;
599 
600     FT_Byte    buffer[256];
601     FT_Byte   *p, *plimit;
602     FT_Byte   *d, *dlimit;
603     FT_Byte    val;
604 
605     FT_Bool    upper_nibble, done;
606 
607 
608     if ( FT_STREAM_SEEK( offset ) )
609       goto Exit;
610 
611     d      = data;
612     dlimit = d + data_len;
613     p      = buffer;
614     plimit = p;
615 
616     upper_nibble = 1;
617     done         = 0;
618 
619     while ( d &lt; dlimit )
620     {
621       if ( p &gt;= plimit )
622       {
623         FT_ULong  oldpos = FT_STREAM_POS();
624         FT_ULong  size   = stream-&gt;size - oldpos;
625 
626 
627         if ( size == 0 )
628         {
629           error = FT_THROW( Syntax_Error );
630           goto Exit;
631         }
632 
633         if ( FT_STREAM_READ( buffer, 256 &gt; size ? size : 256 ) )
634           goto Exit;
635         p      = buffer;
636         plimit = p + FT_STREAM_POS() - oldpos;
637       }
638 
639       if ( ft_isdigit( *p ) )
640         val = (FT_Byte)( *p - &#39;0&#39; );
641       else if ( *p &gt;= &#39;a&#39; &amp;&amp; *p &lt;= &#39;f&#39; )
642         val = (FT_Byte)( *p - &#39;a&#39; );
643       else if ( *p &gt;= &#39;A&#39; &amp;&amp; *p &lt;= &#39;F&#39; )
644         val = (FT_Byte)( *p - &#39;A&#39; + 10 );
645       else if ( *p == &#39; &#39;  ||
646                 *p == &#39;\t&#39; ||
647                 *p == &#39;\r&#39; ||
648                 *p == &#39;\n&#39; ||
649                 *p == &#39;\f&#39; ||
650                 *p == &#39;\0&#39; )
651       {
652         p++;
653         continue;
654       }
655       else if ( *p == &#39;&gt;&#39; )
656       {
657         val  = 0;
658         done = 1;
659       }
660       else
661       {
662         error = FT_THROW( Syntax_Error );
663         goto Exit;
664       }
665 
666       if ( upper_nibble )
667         *d = (FT_Byte)( val &lt;&lt; 4 );
668       else
669       {
670         *d = (FT_Byte)( *d + val );
671         d++;
672       }
673 
674       upper_nibble = (FT_Byte)( 1 - upper_nibble );
675 
676       if ( done )
677         break;
678 
679       p++;
680     }
681 
682     error = FT_Err_Ok;
683 
684   Exit:
685     return error;
686   }
687 
688 
689   FT_LOCAL_DEF( FT_Error )
690   cid_face_open( CID_Face  face,
691                  FT_Int    face_index )
692   {
693     CID_Loader   loader;
694     CID_Parser*  parser;
695     FT_Memory    memory = face-&gt;root.memory;
696     FT_Error     error;
697     FT_Int       n;
698 
699     CID_FaceInfo  cid = &amp;face-&gt;cid;
700 
701     FT_ULong  binary_length;
702     FT_ULong  entry_len;
703 
704 
705     cid_init_loader( &amp;loader, face );
706 
707     parser = &amp;loader.parser;
708     error = cid_parser_new( parser, face-&gt;root.stream, face-&gt;root.memory,
709                             (PSAux_Service)face-&gt;psaux );
710     if ( error )
711       goto Exit;
712 
713     error = cid_parse_dict( face, &amp;loader,
714                             parser-&gt;postscript,
715                             parser-&gt;postscript_len );
716     if ( error )
717       goto Exit;
718 
719     if ( face_index &lt; 0 )
720       goto Exit;
721 
722     if ( FT_NEW( face-&gt;cid_stream ) )
723       goto Exit;
724 
725     if ( parser-&gt;binary_length )
726     {
727       if ( parser-&gt;binary_length &gt;
728              face-&gt;root.stream-&gt;size - parser-&gt;data_offset )
729       {
730         FT_TRACE0(( &quot;cid_face_open: adjusting length of binary data\n&quot;
731                     &quot;               (from %d to %d bytes)\n&quot;,
732                     parser-&gt;binary_length,
733                     face-&gt;root.stream-&gt;size - parser-&gt;data_offset ));
734         parser-&gt;binary_length = face-&gt;root.stream-&gt;size -
735                                 parser-&gt;data_offset;
736       }
737 
738       /* we must convert the data section from hexadecimal to binary */
739       if ( FT_ALLOC( face-&gt;binary_data, parser-&gt;binary_length )    ||
740            FT_SET_ERROR( cid_hex_to_binary( face-&gt;binary_data,
741                                             parser-&gt;binary_length,
742                                             parser-&gt;data_offset,
743                                             face ) )               )
744         goto Exit;
745 
746       FT_Stream_OpenMemory( face-&gt;cid_stream,
747                             face-&gt;binary_data, parser-&gt;binary_length );
748       cid-&gt;data_offset = 0;
749     }
750     else
751     {
752       *face-&gt;cid_stream = *face-&gt;root.stream;
753       cid-&gt;data_offset  = loader.parser.data_offset;
754     }
755 
756     /* sanity tests */
757 
758     if ( cid-&gt;fd_bytes &lt; 0 || cid-&gt;gd_bytes &lt; 1 )
759     {
760       FT_ERROR(( &quot;cid_parse_dict:&quot;
761                  &quot; Invalid `FDBytes&#39; or `GDBytes&#39; value\n&quot; ));
762       error = FT_THROW( Invalid_File_Format );
763       goto Exit;
764     }
765 
766     /* allow at most 32bit offsets */
767     if ( cid-&gt;fd_bytes &gt; 4 || cid-&gt;gd_bytes &gt; 4 )
768     {
769       FT_ERROR(( &quot;cid_parse_dict:&quot;
770                  &quot; Values of `FDBytes&#39; or `GDBytes&#39; larger than 4\n&quot;
771                  &quot;               &quot;
772                  &quot; are not supported\n&quot; ));
773       error = FT_THROW( Invalid_File_Format );
774       goto Exit;
775     }
776 
777     binary_length = face-&gt;cid_stream-&gt;size - cid-&gt;data_offset;
778     entry_len     = (FT_ULong)( cid-&gt;fd_bytes + cid-&gt;gd_bytes );
779 
780     for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
781     {
782       CID_FaceDict  dict = cid-&gt;font_dicts + n;
783 
784 
785       if ( dict-&gt;sd_bytes &lt; 0                        ||
786            ( dict-&gt;num_subrs &amp;&amp; dict-&gt;sd_bytes &lt; 1 ) )
787       {
788         FT_ERROR(( &quot;cid_parse_dict: Invalid `SDBytes&#39; value\n&quot; ));
789         error = FT_THROW( Invalid_File_Format );
790         goto Exit;
791       }
792 
793       if ( dict-&gt;sd_bytes &gt; 4 )
794       {
795         FT_ERROR(( &quot;cid_parse_dict:&quot;
796                    &quot; Values of `SDBytes&#39; larger than 4&quot;
797                    &quot; are not supported\n&quot; ));
798         error = FT_THROW( Invalid_File_Format );
799         goto Exit;
800       }
801 
802       if ( dict-&gt;subrmap_offset &gt; binary_length )
803       {
804         FT_ERROR(( &quot;cid_parse_dict: Invalid `SubrMapOffset&#39; value\n&quot; ));
805         error = FT_THROW( Invalid_File_Format );
806         goto Exit;
807       }
808 
809       /* `num_subrs&#39; is scanned as a signed integer */
810       if ( (FT_Int)dict-&gt;num_subrs &lt; 0                                     ||
811            ( dict-&gt;sd_bytes                                              &amp;&amp;
812              dict-&gt;num_subrs &gt; ( binary_length - dict-&gt;subrmap_offset ) /
813                                  (FT_UInt)dict-&gt;sd_bytes                 ) )
814       {
815         FT_ERROR(( &quot;cid_parse_dict: Invalid `SubrCount&#39; value\n&quot; ));
816         error = FT_THROW( Invalid_File_Format );
817         goto Exit;
818       }
819     }
820 
821     if ( cid-&gt;cidmap_offset &gt; binary_length )
822     {
823       FT_ERROR(( &quot;cid_parse_dict: Invalid `CIDMapOffset&#39; value\n&quot; ));
824       error = FT_THROW( Invalid_File_Format );
825       goto Exit;
826     }
827 
828     if ( entry_len                                            &amp;&amp;
829          cid-&gt;cid_count &gt;
830            ( binary_length - cid-&gt;cidmap_offset ) / entry_len )
831     {
832       FT_ERROR(( &quot;cid_parse_dict: Invalid `CIDCount&#39; value\n&quot; ));
833       error = FT_THROW( Invalid_File_Format );
834       goto Exit;
835     }
836 
837     /* we can now safely proceed */
838     error = cid_read_subrs( face );
839 
840   Exit:
841     cid_done_loader( &amp;loader );
842     return error;
843   }
844 
845 
846 /* END */
    </pre>
  </body>
</html>
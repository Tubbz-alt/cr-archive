<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/include/freetype/internal/ftcalc.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="cfftypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftdebug.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/include/freetype/internal/ftcalc.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftcalc.h                                                               */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Arithmetic computations (specification).                             */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #ifndef FTCALC_H_
 20 #define FTCALC_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_FREETYPE_H
 25 
 26 
 27 FT_BEGIN_HEADER
 28 
 29 
<span class="line-modified"> 30   /*************************************************************************/</span>
<span class="line-modified"> 31   /*                                                                       */</span>
<span class="line-modified"> 32   /* FT_MulDiv() and FT_MulFix() are declared in freetype.h.               */</span>
<span class="line-modified"> 33   /*                                                                       */</span>
<span class="line-modified"> 34   /*************************************************************************/</span>
 35 
 36 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
 37   /* Provide assembler fragments for performance-critical functions. */
 38   /* These must be defined `static __inline__&#39; with GCC.             */
 39 
 40 #if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
 41 
 42 #define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
 43 
 44   /* documentation is in freetype.h */
 45 
 46   static __inline FT_Int32
 47   FT_MulFix_arm( FT_Int32  a,
 48                  FT_Int32  b )
 49   {
 50     FT_Int32  t, t2;
 51 
 52 
 53     __asm
 54     {
</pre>
<hr />
<pre>
229     return (FT_Int32)result;
230 #endif
231 
232 #if __GNUC__ &gt; 4 || ( __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 6 )
233 #pragma GCC diagnostic pop
234 #endif
235   }
236 
237 #endif /* __GNUC__ &amp;&amp; __x86_64__ */
238 
239 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
240 
241 
242 #ifdef FT_CONFIG_OPTION_INLINE_MULFIX
243 #ifdef FT_MULFIX_ASSEMBLER
244 #define FT_MulFix( a, b )  FT_MULFIX_ASSEMBLER( (FT_Int32)(a), (FT_Int32)(b) )
245 #endif
246 #endif
247 
248 
<span class="line-modified">249   /*************************************************************************/</span>
<span class="line-modified">250   /*                                                                       */</span>
<span class="line-modified">251   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">252   /*    FT_MulDiv_No_Round                                                 */</span>
<span class="line-modified">253   /*                                                                       */</span>
<span class="line-modified">254   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">255   /*    A very simple function used to perform the computation `(a*b)/c&#39;   */</span>
<span class="line-modified">256   /*    (without rounding) with maximum accuracy (it uses a 64-bit         */</span>
<span class="line-modified">257   /*    intermediate integer whenever necessary).                          */</span>
<span class="line-modified">258   /*                                                                       */</span>
<span class="line-modified">259   /*    This function isn&#39;t necessarily as fast as some processor specific */</span>
<span class="line-modified">260   /*    operations, but is at least completely portable.                   */</span>
<span class="line-modified">261   /*                                                                       */</span>
<span class="line-modified">262   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">263   /*    a :: The first multiplier.                                         */</span>
<span class="line-modified">264   /*    b :: The second multiplier.                                        */</span>
<span class="line-modified">265   /*    c :: The divisor.                                                  */</span>
<span class="line-modified">266   /*                                                                       */</span>
<span class="line-modified">267   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">268   /*    The result of `(a*b)/c&#39;.  This function never traps when trying to */</span>
<span class="line-modified">269   /*    divide by zero; it simply returns `MaxInt&#39; or `MinInt&#39; depending   */</span>
<span class="line-modified">270   /*    on the signs of `a&#39; and `b&#39;.                                       */</span>
<span class="line-modified">271   /*                                                                       */</span>



272   FT_BASE( FT_Long )
273   FT_MulDiv_No_Round( FT_Long  a,
274                       FT_Long  b,
275                       FT_Long  c );
276 
277 
278   /*
<span class="line-modified">279    *  A variant of FT_Matrix_Multiply which scales its result afterwards.</span>
<span class="line-modified">280    *  The idea is that both `a&#39; and `b&#39; are scaled by factors of 10 so that</span>
<span class="line-modified">281    *  the values are as precise as possible to get a correct result during</span>
<span class="line-modified">282    *  the 64bit multiplication.  Let `sa&#39; and `sb&#39; be the scaling factors of</span>
<span class="line-modified">283    *  `a&#39; and `b&#39;, respectively, then the scaling factor of the result is</span>
<span class="line-removed">284    *  `sa*sb&#39;.</span>
285    */
286   FT_BASE( void )
287   FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
288                              FT_Matrix        *b,
289                              FT_Long           scaling );
290 
291 
292   /*
<span class="line-modified">293    *  A variant of FT_Vector_Transform.  See comments for</span>
<span class="line-modified">294    *  FT_Matrix_Multiply_Scaled.</span>















295    */
296   FT_BASE( void )
297   FT_Vector_Transform_Scaled( FT_Vector*        vector,
298                               const FT_Matrix*  matrix,
299                               FT_Long           scaling );
300 
301 
302   /*
<span class="line-modified">303    *  This function normalizes a vector and returns its original length.</span>
<span class="line-modified">304    *  The normalized vector is a 16.16 fixed-point unit vector with length</span>
<span class="line-modified">305    *  close to 0x10000.  The accuracy of the returned length is limited to</span>
<span class="line-modified">306    *  16 bits also.  The function utilizes quick inverse square root</span>
<span class="line-modified">307    *  approximation without divisions and square roots relying on Newton&#39;s</span>
<span class="line-modified">308    *  iterations instead.</span>
309    */
310   FT_BASE( FT_UInt32 )
311   FT_Vector_NormLen( FT_Vector*  vector );
312 
313 
314   /*
<span class="line-modified">315    *  Return -1, 0, or +1, depending on the orientation of a given corner.</span>
<span class="line-modified">316    *  We use the Cartesian coordinate system, with positive vertical values</span>
<span class="line-modified">317    *  going upwards.  The function returns +1 if the corner turns to the</span>
<span class="line-modified">318    *  left, -1 to the right, and 0 for undecidable cases.</span>
319    */
320   FT_BASE( FT_Int )
321   ft_corner_orientation( FT_Pos  in_x,
322                          FT_Pos  in_y,
323                          FT_Pos  out_x,
324                          FT_Pos  out_y );
325 
326 
327   /*
<span class="line-modified">328    *  Return TRUE if a corner is flat or nearly flat.  This is equivalent to</span>
<span class="line-modified">329    *  saying that the corner point is close to its neighbors, or inside an</span>
<span class="line-modified">330    *  ellipse defined by the neighbor focal points to be more precise.</span>
331    */
332   FT_BASE( FT_Int )
333   ft_corner_is_flat( FT_Pos  in_x,
334                      FT_Pos  in_y,
335                      FT_Pos  out_x,
336                      FT_Pos  out_y );
337 
338 
339   /*
<span class="line-modified">340    *  Return the most significant bit index.</span>
341    */
342 
343 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER

344 #if defined( __GNUC__ )                                          &amp;&amp; \
345     ( __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4 ) )
346 
347 #if FT_SIZEOF_INT == 4
348 
349 #define FT_MSB( x )  ( 31 - __builtin_clz( x ) )
350 
351 #elif FT_SIZEOF_LONG == 4
352 
353 #define FT_MSB( x )  ( 31 - __builtin_clzl( x ) )
354 























355 #endif
356 
<span class="line-modified">357 #endif /* __GNUC__ */</span>


358 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
359 
360 #ifndef FT_MSB
361 
362   FT_BASE( FT_Int )
363   FT_MSB( FT_UInt32  z );
364 
365 #endif
366 
367 
368   /*
<span class="line-modified">369    *  Return sqrt(x*x+y*y), which is the same as `FT_Vector_Length&#39; but uses</span>
<span class="line-modified">370    *  two fixed-point arguments instead.</span>
371    */
372   FT_BASE( FT_Fixed )
373   FT_Hypot( FT_Fixed  x,
374             FT_Fixed  y );
375 
376 
377 #if 0
378 
<span class="line-modified">379   /*************************************************************************/</span>
<span class="line-modified">380   /*                                                                       */</span>
<span class="line-modified">381   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">382   /*    FT_SqrtFixed                                                       */</span>
<span class="line-modified">383   /*                                                                       */</span>
<span class="line-modified">384   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">385   /*    Computes the square root of a 16.16 fixed-point value.             */</span>
<span class="line-modified">386   /*                                                                       */</span>
<span class="line-modified">387   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">388   /*    x :: The value to compute the root for.                            */</span>
<span class="line-modified">389   /*                                                                       */</span>
<span class="line-modified">390   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">391   /*    The result of `sqrt(x)&#39;.                                           */</span>
<span class="line-modified">392   /*                                                                       */</span>
<span class="line-modified">393   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">394   /*    This function is not very fast.                                    */</span>
<span class="line-modified">395   /*                                                                       */</span>

396   FT_BASE( FT_Int32 )
397   FT_SqrtFixed( FT_Int32  x );
398 
399 #endif /* 0 */
400 
401 
402 #define INT_TO_F26DOT6( x )    ( (FT_Long)(x) * 64  )    /* &lt;&lt; 6  */
403 #define INT_TO_F2DOT14( x )    ( (FT_Long)(x) * 16384 )  /* &lt;&lt; 14 */
404 #define INT_TO_FIXED( x )      ( (FT_Long)(x) * 65536 )  /* &lt;&lt; 16 */
405 #define F2DOT14_TO_FIXED( x )  ( (FT_Long)(x) * 4 )      /* &lt;&lt; 2  */
406 #define FIXED_TO_INT( x )      ( FT_RoundFix( x ) &gt;&gt; 16 )
407 
408 #define ROUND_F26DOT6( x )     ( x &gt;= 0 ? (    ( (x) + 32 ) &amp; -64 )     \
409                                         : ( -( ( 32 - (x) ) &amp; -64 ) ) )
410 
411   /*
<span class="line-modified">412    *  The following macros have two purposes.</span>
413    *
<span class="line-modified">414    *  . Tag places where overflow is expected and harmless.</span>
415    *
<span class="line-modified">416    *  . Avoid run-time sanitizer errors.</span>
417    *
<span class="line-modified">418    *  Use with care!</span>
419    */









420 #define ADD_LONG( a, b )                             \
421           (FT_Long)( (FT_ULong)(a) + (FT_ULong)(b) )
422 #define SUB_LONG( a, b )                             \
423           (FT_Long)( (FT_ULong)(a) - (FT_ULong)(b) )
424 #define MUL_LONG( a, b )                             \
425           (FT_Long)( (FT_ULong)(a) * (FT_ULong)(b) )
426 #define NEG_LONG( a )                                \
427           (FT_Long)( (FT_ULong)0 - (FT_ULong)(a) )
428 
429 #define ADD_INT32( a, b )                               \
430           (FT_Int32)( (FT_UInt32)(a) + (FT_UInt32)(b) )
431 #define SUB_INT32( a, b )                               \
432           (FT_Int32)( (FT_UInt32)(a) - (FT_UInt32)(b) )
433 #define MUL_INT32( a, b )                               \
434           (FT_Int32)( (FT_UInt32)(a) * (FT_UInt32)(b) )
435 #define NEG_INT32( a )                                  \
436           (FT_Int32)( (FT_UInt32)0 - (FT_UInt32)(a) )
437 













438 
439 FT_END_HEADER
440 
441 #endif /* FTCALC_H_ */
442 
443 
444 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftcalc.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Arithmetic computations (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef FTCALC_H_
 20 #define FTCALC_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_FREETYPE_H
 25 
 26 
 27 FT_BEGIN_HEADER
 28 
 29 
<span class="line-modified"> 30   /**************************************************************************</span>
<span class="line-modified"> 31    *</span>
<span class="line-modified"> 32    * FT_MulDiv() and FT_MulFix() are declared in freetype.h.</span>
<span class="line-modified"> 33    *</span>
<span class="line-modified"> 34    */</span>
 35 
 36 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
 37   /* Provide assembler fragments for performance-critical functions. */
 38   /* These must be defined `static __inline__&#39; with GCC.             */
 39 
 40 #if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
 41 
 42 #define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
 43 
 44   /* documentation is in freetype.h */
 45 
 46   static __inline FT_Int32
 47   FT_MulFix_arm( FT_Int32  a,
 48                  FT_Int32  b )
 49   {
 50     FT_Int32  t, t2;
 51 
 52 
 53     __asm
 54     {
</pre>
<hr />
<pre>
229     return (FT_Int32)result;
230 #endif
231 
232 #if __GNUC__ &gt; 4 || ( __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 6 )
233 #pragma GCC diagnostic pop
234 #endif
235   }
236 
237 #endif /* __GNUC__ &amp;&amp; __x86_64__ */
238 
239 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
240 
241 
242 #ifdef FT_CONFIG_OPTION_INLINE_MULFIX
243 #ifdef FT_MULFIX_ASSEMBLER
244 #define FT_MulFix( a, b )  FT_MULFIX_ASSEMBLER( (FT_Int32)(a), (FT_Int32)(b) )
245 #endif
246 #endif
247 
248 
<span class="line-modified">249   /**************************************************************************</span>
<span class="line-modified">250    *</span>
<span class="line-modified">251    * @function:</span>
<span class="line-modified">252    *   FT_MulDiv_No_Round</span>
<span class="line-modified">253    *</span>
<span class="line-modified">254    * @description:</span>
<span class="line-modified">255    *   A very simple function used to perform the computation &#39;(a*b)/c&#39;</span>
<span class="line-modified">256    *   (without rounding) with maximum accuracy (it uses a 64-bit</span>
<span class="line-modified">257    *   intermediate integer whenever necessary).</span>
<span class="line-modified">258    *</span>
<span class="line-modified">259    *   This function isn&#39;t necessarily as fast as some processor-specific</span>
<span class="line-modified">260    *   operations, but is at least completely portable.</span>
<span class="line-modified">261    *</span>
<span class="line-modified">262    * @input:</span>
<span class="line-modified">263    *   a ::</span>
<span class="line-modified">264    *     The first multiplier.</span>
<span class="line-modified">265    *   b ::</span>
<span class="line-modified">266    *     The second multiplier.</span>
<span class="line-modified">267    *   c ::</span>
<span class="line-modified">268    *     The divisor.</span>
<span class="line-modified">269    *</span>
<span class="line-modified">270    * @return:</span>
<span class="line-modified">271    *   The result of &#39;(a*b)/c&#39;.  This function never traps when trying to</span>
<span class="line-added">272    *   divide by zero; it simply returns &#39;MaxInt&#39; or &#39;MinInt&#39; depending on</span>
<span class="line-added">273    *   the signs of &#39;a&#39; and &#39;b&#39;.</span>
<span class="line-added">274    */</span>
275   FT_BASE( FT_Long )
276   FT_MulDiv_No_Round( FT_Long  a,
277                       FT_Long  b,
278                       FT_Long  c );
279 
280 
281   /*
<span class="line-modified">282    * A variant of FT_Matrix_Multiply which scales its result afterwards.  The</span>
<span class="line-modified">283    * idea is that both `a&#39; and `b&#39; are scaled by factors of 10 so that the</span>
<span class="line-modified">284    * values are as precise as possible to get a correct result during the</span>
<span class="line-modified">285    * 64bit multiplication.  Let `sa&#39; and `sb&#39; be the scaling factors of `a&#39;</span>
<span class="line-modified">286    * and `b&#39;, respectively, then the scaling factor of the result is `sa*sb&#39;.</span>

287    */
288   FT_BASE( void )
289   FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
290                              FT_Matrix        *b,
291                              FT_Long           scaling );
292 
293 
294   /*
<span class="line-modified">295    * Check a matrix.  If the transformation would lead to extreme shear or</span>
<span class="line-modified">296    * extreme scaling, for example, return 0.  If everything is OK, return 1.</span>
<span class="line-added">297    *</span>
<span class="line-added">298    * Based on geometric considerations we use the following inequality to</span>
<span class="line-added">299    * identify a degenerate matrix.</span>
<span class="line-added">300    *</span>
<span class="line-added">301    *   50 * abs(xx*yy - xy*yx) &lt; xx^2 + xy^2 + yx^2 + yy^2</span>
<span class="line-added">302    *</span>
<span class="line-added">303    * Value 50 is heuristic.</span>
<span class="line-added">304    */</span>
<span class="line-added">305   FT_BASE( FT_Bool )</span>
<span class="line-added">306   FT_Matrix_Check( const FT_Matrix*  matrix );</span>
<span class="line-added">307 </span>
<span class="line-added">308 </span>
<span class="line-added">309   /*</span>
<span class="line-added">310    * A variant of FT_Vector_Transform.  See comments for</span>
<span class="line-added">311    * FT_Matrix_Multiply_Scaled.</span>
312    */
313   FT_BASE( void )
314   FT_Vector_Transform_Scaled( FT_Vector*        vector,
315                               const FT_Matrix*  matrix,
316                               FT_Long           scaling );
317 
318 
319   /*
<span class="line-modified">320    * This function normalizes a vector and returns its original length.  The</span>
<span class="line-modified">321    * normalized vector is a 16.16 fixed-point unit vector with length close</span>
<span class="line-modified">322    * to 0x10000.  The accuracy of the returned length is limited to 16 bits</span>
<span class="line-modified">323    * also.  The function utilizes quick inverse square root approximation</span>
<span class="line-modified">324    * without divisions and square roots relying on Newton&#39;s iterations</span>
<span class="line-modified">325    * instead.</span>
326    */
327   FT_BASE( FT_UInt32 )
328   FT_Vector_NormLen( FT_Vector*  vector );
329 
330 
331   /*
<span class="line-modified">332    * Return -1, 0, or +1, depending on the orientation of a given corner.  We</span>
<span class="line-modified">333    * use the Cartesian coordinate system, with positive vertical values going</span>
<span class="line-modified">334    * upwards.  The function returns +1 if the corner turns to the left, -1 to</span>
<span class="line-modified">335    * the right, and 0 for undecidable cases.</span>
336    */
337   FT_BASE( FT_Int )
338   ft_corner_orientation( FT_Pos  in_x,
339                          FT_Pos  in_y,
340                          FT_Pos  out_x,
341                          FT_Pos  out_y );
342 
343 
344   /*
<span class="line-modified">345    * Return TRUE if a corner is flat or nearly flat.  This is equivalent to</span>
<span class="line-modified">346    * saying that the corner point is close to its neighbors, or inside an</span>
<span class="line-modified">347    * ellipse defined by the neighbor focal points to be more precise.</span>
348    */
349   FT_BASE( FT_Int )
350   ft_corner_is_flat( FT_Pos  in_x,
351                      FT_Pos  in_y,
352                      FT_Pos  out_x,
353                      FT_Pos  out_y );
354 
355 
356   /*
<span class="line-modified">357    * Return the most significant bit index.</span>
358    */
359 
360 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
<span class="line-added">361 </span>
362 #if defined( __GNUC__ )                                          &amp;&amp; \
363     ( __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4 ) )
364 
365 #if FT_SIZEOF_INT == 4
366 
367 #define FT_MSB( x )  ( 31 - __builtin_clz( x ) )
368 
369 #elif FT_SIZEOF_LONG == 4
370 
371 #define FT_MSB( x )  ( 31 - __builtin_clzl( x ) )
372 
<span class="line-added">373 #endif /* __GNUC__ */</span>
<span class="line-added">374 </span>
<span class="line-added">375 </span>
<span class="line-added">376 #elif defined( _MSC_VER ) &amp;&amp; ( _MSC_VER &gt;= 1400 )</span>
<span class="line-added">377 </span>
<span class="line-added">378 #if FT_SIZEOF_INT == 4</span>
<span class="line-added">379 </span>
<span class="line-added">380 #include &lt;intrin.h&gt;</span>
<span class="line-added">381 #pragma intrinsic( _BitScanReverse )</span>
<span class="line-added">382 </span>
<span class="line-added">383   static __inline FT_Int32</span>
<span class="line-added">384   FT_MSB_i386( FT_UInt32  x )</span>
<span class="line-added">385   {</span>
<span class="line-added">386     unsigned long  where;</span>
<span class="line-added">387 </span>
<span class="line-added">388 </span>
<span class="line-added">389     _BitScanReverse( &amp;where, x );</span>
<span class="line-added">390 </span>
<span class="line-added">391     return (FT_Int32)where;</span>
<span class="line-added">392   }</span>
<span class="line-added">393 </span>
<span class="line-added">394 #define FT_MSB( x )  ( FT_MSB_i386( x ) )</span>
<span class="line-added">395 </span>
396 #endif
397 
<span class="line-modified">398 #endif /* _MSC_VER */</span>
<span class="line-added">399 </span>
<span class="line-added">400 </span>
401 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
402 
403 #ifndef FT_MSB
404 
405   FT_BASE( FT_Int )
406   FT_MSB( FT_UInt32  z );
407 
408 #endif
409 
410 
411   /*
<span class="line-modified">412    * Return sqrt(x*x+y*y), which is the same as `FT_Vector_Length&#39; but uses</span>
<span class="line-modified">413    * two fixed-point arguments instead.</span>
414    */
415   FT_BASE( FT_Fixed )
416   FT_Hypot( FT_Fixed  x,
417             FT_Fixed  y );
418 
419 
420 #if 0
421 
<span class="line-modified">422   /**************************************************************************</span>
<span class="line-modified">423    *</span>
<span class="line-modified">424    * @function:</span>
<span class="line-modified">425    *   FT_SqrtFixed</span>
<span class="line-modified">426    *</span>
<span class="line-modified">427    * @description:</span>
<span class="line-modified">428    *   Computes the square root of a 16.16 fixed-point value.</span>
<span class="line-modified">429    *</span>
<span class="line-modified">430    * @input:</span>
<span class="line-modified">431    *   x ::</span>
<span class="line-modified">432    *     The value to compute the root for.</span>
<span class="line-modified">433    *</span>
<span class="line-modified">434    * @return:</span>
<span class="line-modified">435    *   The result of &#39;sqrt(x)&#39;.</span>
<span class="line-modified">436    *</span>
<span class="line-modified">437    * @note:</span>
<span class="line-modified">438    *   This function is not very fast.</span>
<span class="line-added">439    */</span>
440   FT_BASE( FT_Int32 )
441   FT_SqrtFixed( FT_Int32  x );
442 
443 #endif /* 0 */
444 
445 
446 #define INT_TO_F26DOT6( x )    ( (FT_Long)(x) * 64  )    /* &lt;&lt; 6  */
447 #define INT_TO_F2DOT14( x )    ( (FT_Long)(x) * 16384 )  /* &lt;&lt; 14 */
448 #define INT_TO_FIXED( x )      ( (FT_Long)(x) * 65536 )  /* &lt;&lt; 16 */
449 #define F2DOT14_TO_FIXED( x )  ( (FT_Long)(x) * 4 )      /* &lt;&lt; 2  */
450 #define FIXED_TO_INT( x )      ( FT_RoundFix( x ) &gt;&gt; 16 )
451 
452 #define ROUND_F26DOT6( x )     ( x &gt;= 0 ? (    ( (x) + 32 ) &amp; -64 )     \
453                                         : ( -( ( 32 - (x) ) &amp; -64 ) ) )
454 
455   /*
<span class="line-modified">456    * The following macros have two purposes.</span>
457    *
<span class="line-modified">458    * - Tag places where overflow is expected and harmless.</span>
459    *
<span class="line-modified">460    * - Avoid run-time sanitizer errors.</span>
461    *
<span class="line-modified">462    * Use with care!</span>
463    */
<span class="line-added">464 #define ADD_INT( a, b )                           \</span>
<span class="line-added">465           (FT_Int)( (FT_UInt)(a) + (FT_UInt)(b) )</span>
<span class="line-added">466 #define SUB_INT( a, b )                           \</span>
<span class="line-added">467           (FT_Int)( (FT_UInt)(a) - (FT_UInt)(b) )</span>
<span class="line-added">468 #define MUL_INT( a, b )                           \</span>
<span class="line-added">469           (FT_Int)( (FT_UInt)(a) * (FT_UInt)(b) )</span>
<span class="line-added">470 #define NEG_INT( a )                              \</span>
<span class="line-added">471           (FT_Int)( (FT_UInt)0 - (FT_UInt)(a) )</span>
<span class="line-added">472 </span>
473 #define ADD_LONG( a, b )                             \
474           (FT_Long)( (FT_ULong)(a) + (FT_ULong)(b) )
475 #define SUB_LONG( a, b )                             \
476           (FT_Long)( (FT_ULong)(a) - (FT_ULong)(b) )
477 #define MUL_LONG( a, b )                             \
478           (FT_Long)( (FT_ULong)(a) * (FT_ULong)(b) )
479 #define NEG_LONG( a )                                \
480           (FT_Long)( (FT_ULong)0 - (FT_ULong)(a) )
481 
482 #define ADD_INT32( a, b )                               \
483           (FT_Int32)( (FT_UInt32)(a) + (FT_UInt32)(b) )
484 #define SUB_INT32( a, b )                               \
485           (FT_Int32)( (FT_UInt32)(a) - (FT_UInt32)(b) )
486 #define MUL_INT32( a, b )                               \
487           (FT_Int32)( (FT_UInt32)(a) * (FT_UInt32)(b) )
488 #define NEG_INT32( a )                                  \
489           (FT_Int32)( (FT_UInt32)0 - (FT_UInt32)(a) )
490 
<span class="line-added">491 #ifdef FT_LONG64</span>
<span class="line-added">492 </span>
<span class="line-added">493 #define ADD_INT64( a, b )                               \</span>
<span class="line-added">494           (FT_Int64)( (FT_UInt64)(a) + (FT_UInt64)(b) )</span>
<span class="line-added">495 #define SUB_INT64( a, b )                               \</span>
<span class="line-added">496           (FT_Int64)( (FT_UInt64)(a) - (FT_UInt64)(b) )</span>
<span class="line-added">497 #define MUL_INT64( a, b )                               \</span>
<span class="line-added">498           (FT_Int64)( (FT_UInt64)(a) * (FT_UInt64)(b) )</span>
<span class="line-added">499 #define NEG_INT64( a )                                  \</span>
<span class="line-added">500           (FT_Int64)( (FT_UInt64)0 - (FT_UInt64)(a) )</span>
<span class="line-added">501 </span>
<span class="line-added">502 #endif /* FT_LONG64 */</span>
<span class="line-added">503 </span>
504 
505 FT_END_HEADER
506 
507 #endif /* FTCALC_H_ */
508 
509 
510 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="cfftypes.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftdebug.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
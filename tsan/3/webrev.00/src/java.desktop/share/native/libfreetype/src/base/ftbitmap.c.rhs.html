<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/base/ftbitmap.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ftbitmap.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   FreeType utility functions for bitmaps (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2004-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_INTERNAL_DEBUG_H
  21 
  22 #include FT_BITMAP_H
  23 #include FT_IMAGE_H
  24 #include FT_INTERNAL_OBJECTS_H
  25 
  26 
<a name="2" id="anc2"></a><span class="line-added">  27   /**************************************************************************</span>
<span class="line-added">  28    *</span>
<span class="line-added">  29    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-added">  30    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-added">  31    * messages during execution.</span>
<span class="line-added">  32    */</span>
<span class="line-added">  33 #undef  FT_COMPONENT</span>
<span class="line-added">  34 #define FT_COMPONENT  bitmap</span>
<span class="line-added">  35 </span>
<span class="line-added">  36 </span>
  37   static
<a name="3" id="anc3"></a><span class="line-modified">  38   const FT_Bitmap  null_bitmap = { 0, 0, 0, NULL, 0, 0, 0, NULL };</span>
  39 
  40 
  41   /* documentation is in ftbitmap.h */
  42 
  43   FT_EXPORT_DEF( void )
  44   FT_Bitmap_Init( FT_Bitmap  *abitmap )
  45   {
  46     if ( abitmap )
  47       *abitmap = null_bitmap;
  48   }
  49 
  50 
  51   /* deprecated function name; retained for ABI compatibility */
  52 
  53   FT_EXPORT_DEF( void )
  54   FT_Bitmap_New( FT_Bitmap  *abitmap )
  55   {
  56     if ( abitmap )
  57       *abitmap = null_bitmap;
  58   }
  59 
  60 
  61   /* documentation is in ftbitmap.h */
  62 
  63   FT_EXPORT_DEF( FT_Error )
  64   FT_Bitmap_Copy( FT_Library        library,
  65                   const FT_Bitmap  *source,
  66                   FT_Bitmap        *target)
  67   {
  68     FT_Memory  memory;
  69     FT_Error   error  = FT_Err_Ok;
  70 
  71     FT_Int    pitch;
  72     FT_ULong  size;
  73 
  74     FT_Int  source_pitch_sign, target_pitch_sign;
  75 
  76 
  77     if ( !library )
  78       return FT_THROW( Invalid_Library_Handle );
  79 
  80     if ( !source || !target )
  81       return FT_THROW( Invalid_Argument );
  82 
  83     if ( source == target )
  84       return FT_Err_Ok;
  85 
  86     source_pitch_sign = source-&gt;pitch &lt; 0 ? -1 : 1;
  87     target_pitch_sign = target-&gt;pitch &lt; 0 ? -1 : 1;
  88 
  89     if ( !source-&gt;buffer )
  90     {
  91       *target = *source;
  92       if ( source_pitch_sign != target_pitch_sign )
  93         target-&gt;pitch = -target-&gt;pitch;
  94 
  95       return FT_Err_Ok;
  96     }
  97 
  98     memory = library-&gt;memory;
  99     pitch  = source-&gt;pitch;
 100 
 101     if ( pitch &lt; 0 )
 102       pitch = -pitch;
 103     size = (FT_ULong)pitch * source-&gt;rows;
 104 
 105     if ( target-&gt;buffer )
 106     {
 107       FT_Int    target_pitch = target-&gt;pitch;
 108       FT_ULong  target_size;
 109 
 110 
 111       if ( target_pitch &lt; 0 )
 112         target_pitch = -target_pitch;
 113       target_size = (FT_ULong)target_pitch * target-&gt;rows;
 114 
 115       if ( target_size != size )
 116         (void)FT_QREALLOC( target-&gt;buffer, target_size, size );
 117     }
 118     else
 119       (void)FT_QALLOC( target-&gt;buffer, size );
 120 
 121     if ( !error )
 122     {
 123       unsigned char *p;
 124 
 125 
 126       p = target-&gt;buffer;
 127       *target = *source;
 128       target-&gt;buffer = p;
 129 
 130       if ( source_pitch_sign == target_pitch_sign )
 131         FT_MEM_COPY( target-&gt;buffer, source-&gt;buffer, size );
 132       else
 133       {
 134         /* take care of bitmap flow */
 135         FT_UInt   i;
 136         FT_Byte*  s = source-&gt;buffer;
 137         FT_Byte*  t = target-&gt;buffer;
 138 
 139 
 140         t += (FT_ULong)pitch * ( target-&gt;rows - 1 );
 141 
 142         for ( i = target-&gt;rows; i &gt; 0; i-- )
 143         {
 144           FT_ARRAY_COPY( t, s, pitch );
 145 
 146           s += pitch;
 147           t -= pitch;
 148         }
 149       }
 150     }
 151 
 152     return error;
 153   }
 154 
 155 
 156   /* Enlarge `bitmap&#39; horizontally and vertically by `xpixels&#39; */
 157   /* and `ypixels&#39;, respectively.                              */
 158 
 159   static FT_Error
 160   ft_bitmap_assure_buffer( FT_Memory   memory,
 161                            FT_Bitmap*  bitmap,
 162                            FT_UInt     xpixels,
 163                            FT_UInt     ypixels )
 164   {
 165     FT_Error        error;
 166     unsigned int    pitch;
 167     unsigned int    new_pitch;
 168     FT_UInt         bpp;
 169     FT_UInt         width, height;
 170     unsigned char*  buffer = NULL;
 171 
 172 
 173     width  = bitmap-&gt;width;
 174     height = bitmap-&gt;rows;
 175     pitch  = (unsigned int)FT_ABS( bitmap-&gt;pitch );
 176 
 177     switch ( bitmap-&gt;pixel_mode )
 178     {
 179     case FT_PIXEL_MODE_MONO:
 180       bpp       = 1;
 181       new_pitch = ( width + xpixels + 7 ) &gt;&gt; 3;
 182       break;
 183     case FT_PIXEL_MODE_GRAY2:
 184       bpp       = 2;
 185       new_pitch = ( width + xpixels + 3 ) &gt;&gt; 2;
 186       break;
 187     case FT_PIXEL_MODE_GRAY4:
 188       bpp       = 4;
 189       new_pitch = ( width + xpixels + 1 ) &gt;&gt; 1;
 190       break;
 191     case FT_PIXEL_MODE_GRAY:
 192     case FT_PIXEL_MODE_LCD:
 193     case FT_PIXEL_MODE_LCD_V:
 194       bpp       = 8;
 195       new_pitch = width + xpixels;
 196       break;
 197     default:
 198       return FT_THROW( Invalid_Glyph_Format );
 199     }
 200 
 201     /* if no need to allocate memory */
 202     if ( ypixels == 0 &amp;&amp; new_pitch &lt;= pitch )
 203     {
 204       /* zero the padding */
 205       FT_UInt  bit_width = pitch * 8;
 206       FT_UInt  bit_last  = ( width + xpixels ) * bpp;
 207 
 208 
 209       if ( bit_last &lt; bit_width )
 210       {
 211         FT_Byte*  line  = bitmap-&gt;buffer + ( bit_last &gt;&gt; 3 );
 212         FT_Byte*  end   = bitmap-&gt;buffer + pitch;
 213         FT_UInt   shift = bit_last &amp; 7;
 214         FT_UInt   mask  = 0xFF00U &gt;&gt; shift;
 215         FT_UInt   count = height;
 216 
 217 
 218         for ( ; count &gt; 0; count--, line += pitch, end += pitch )
 219         {
 220           FT_Byte*  write = line;
 221 
 222 
 223           if ( shift &gt; 0 )
 224           {
 225             write[0] = (FT_Byte)( write[0] &amp; mask );
 226             write++;
 227           }
 228           if ( write &lt; end )
 229             FT_MEM_ZERO( write, end - write );
 230         }
 231       }
 232 
 233       return FT_Err_Ok;
 234     }
 235 
 236     /* otherwise allocate new buffer */
 237     if ( FT_QALLOC_MULT( buffer, bitmap-&gt;rows + ypixels, new_pitch ) )
 238       return error;
 239 
 240     /* new rows get added at the top of the bitmap, */
 241     /* thus take care of the flow direction         */
 242     if ( bitmap-&gt;pitch &gt; 0 )
 243     {
 244       FT_UInt  len = ( width * bpp + 7 ) &gt;&gt; 3;
 245 
 246       unsigned char*  in  = bitmap-&gt;buffer;
 247       unsigned char*  out = buffer;
 248 
 249       unsigned char*  limit = bitmap-&gt;buffer + pitch * bitmap-&gt;rows;
 250       unsigned int    delta = new_pitch - len;
 251 
 252 
 253       FT_MEM_ZERO( out, new_pitch * ypixels );
 254       out += new_pitch * ypixels;
 255 
 256       while ( in &lt; limit )
 257       {
 258         FT_MEM_COPY( out, in, len );
 259         in  += pitch;
 260         out += len;
 261 
 262         /* we use FT_QALLOC_MULT, which doesn&#39;t zero out the buffer;      */
 263         /* consequently, we have to manually zero out the remaining bytes */
 264         FT_MEM_ZERO( out, delta );
 265         out += delta;
 266       }
 267     }
 268     else
 269     {
 270       FT_UInt  len = ( width * bpp + 7 ) &gt;&gt; 3;
 271 
 272       unsigned char*  in  = bitmap-&gt;buffer;
 273       unsigned char*  out = buffer;
 274 
 275       unsigned char*  limit = bitmap-&gt;buffer + pitch * bitmap-&gt;rows;
 276       unsigned int    delta = new_pitch - len;
 277 
 278 
 279       while ( in &lt; limit )
 280       {
 281         FT_MEM_COPY( out, in, len );
 282         in  += pitch;
 283         out += len;
 284 
 285         FT_MEM_ZERO( out, delta );
 286         out += delta;
 287       }
 288 
 289       FT_MEM_ZERO( out, new_pitch * ypixels );
 290     }
 291 
 292     FT_FREE( bitmap-&gt;buffer );
 293     bitmap-&gt;buffer = buffer;
 294 
 295     /* set pitch only, width and height are left untouched */
 296     if ( bitmap-&gt;pitch &lt; 0 )
 297       bitmap-&gt;pitch = -(int)new_pitch;
 298     else
 299       bitmap-&gt;pitch = (int)new_pitch;
 300 
 301     return FT_Err_Ok;
 302   }
 303 
 304 
 305   /* documentation is in ftbitmap.h */
 306 
 307   FT_EXPORT_DEF( FT_Error )
 308   FT_Bitmap_Embolden( FT_Library  library,
 309                       FT_Bitmap*  bitmap,
 310                       FT_Pos      xStrength,
 311                       FT_Pos      yStrength )
 312   {
 313     FT_Error        error;
 314     unsigned char*  p;
 315     FT_Int          i, x, pitch;
 316     FT_UInt         y;
 317     FT_Int          xstr, ystr;
 318 
 319 
 320     if ( !library )
 321       return FT_THROW( Invalid_Library_Handle );
 322 
 323     if ( !bitmap || !bitmap-&gt;buffer )
 324       return FT_THROW( Invalid_Argument );
 325 
 326     if ( ( ( FT_PIX_ROUND( xStrength ) &gt;&gt; 6 ) &gt; FT_INT_MAX ) ||
 327          ( ( FT_PIX_ROUND( yStrength ) &gt;&gt; 6 ) &gt; FT_INT_MAX ) )
 328       return FT_THROW( Invalid_Argument );
 329 
 330     xstr = (FT_Int)FT_PIX_ROUND( xStrength ) &gt;&gt; 6;
 331     ystr = (FT_Int)FT_PIX_ROUND( yStrength ) &gt;&gt; 6;
 332 
 333     if ( xstr == 0 &amp;&amp; ystr == 0 )
 334       return FT_Err_Ok;
 335     else if ( xstr &lt; 0 || ystr &lt; 0 )
 336       return FT_THROW( Invalid_Argument );
 337 
 338     switch ( bitmap-&gt;pixel_mode )
 339     {
 340     case FT_PIXEL_MODE_GRAY2:
 341     case FT_PIXEL_MODE_GRAY4:
 342       {
 343         FT_Bitmap  tmp;
 344 
 345 
 346         /* convert to 8bpp */
 347         FT_Bitmap_Init( &amp;tmp );
 348         error = FT_Bitmap_Convert( library, bitmap, &amp;tmp, 1 );
 349         if ( error )
 350           return error;
 351 
 352         FT_Bitmap_Done( library, bitmap );
 353         *bitmap = tmp;
 354       }
 355       break;
 356 
 357     case FT_PIXEL_MODE_MONO:
 358       if ( xstr &gt; 8 )
 359         xstr = 8;
 360       break;
 361 
 362     case FT_PIXEL_MODE_LCD:
 363       xstr *= 3;
 364       break;
 365 
 366     case FT_PIXEL_MODE_LCD_V:
 367       ystr *= 3;
 368       break;
 369 
 370     case FT_PIXEL_MODE_BGRA:
 371       /* We don&#39;t embolden color glyphs. */
 372       return FT_Err_Ok;
 373     }
 374 
 375     error = ft_bitmap_assure_buffer( library-&gt;memory, bitmap,
 376                                      (FT_UInt)xstr, (FT_UInt)ystr );
 377     if ( error )
 378       return error;
 379 
 380     /* take care of bitmap flow */
 381     pitch = bitmap-&gt;pitch;
 382     if ( pitch &gt; 0 )
 383       p = bitmap-&gt;buffer + pitch * ystr;
 384     else
 385     {
 386       pitch = -pitch;
 387       p = bitmap-&gt;buffer + (FT_UInt)pitch * ( bitmap-&gt;rows - 1 );
 388     }
 389 
 390     /* for each row */
 391     for ( y = 0; y &lt; bitmap-&gt;rows; y++ )
 392     {
 393       /*
 394        * Horizontally:
 395        *
 396        * From the last pixel on, make each pixel or&#39;ed with the
 397        * `xstr&#39; pixels before it.
 398        */
 399       for ( x = pitch - 1; x &gt;= 0; x-- )
 400       {
 401         unsigned char  tmp;
 402 
 403 
 404         tmp = p[x];
 405         for ( i = 1; i &lt;= xstr; i++ )
 406         {
 407           if ( bitmap-&gt;pixel_mode == FT_PIXEL_MODE_MONO )
 408           {
 409             p[x] |= tmp &gt;&gt; i;
 410 
 411             /* the maximum value of 8 for `xstr&#39; comes from here */
 412             if ( x &gt; 0 )
 413               p[x] |= p[x - 1] &lt;&lt; ( 8 - i );
 414 
 415 #if 0
 416             if ( p[x] == 0xFF )
 417               break;
 418 #endif
 419           }
 420           else
 421           {
 422             if ( x - i &gt;= 0 )
 423             {
 424               if ( p[x] + p[x - i] &gt; bitmap-&gt;num_grays - 1 )
 425               {
 426                 p[x] = (unsigned char)( bitmap-&gt;num_grays - 1 );
 427                 break;
 428               }
 429               else
 430               {
 431                 p[x] = (unsigned char)( p[x] + p[x - i] );
 432                 if ( p[x] == bitmap-&gt;num_grays - 1 )
 433                   break;
 434               }
 435             }
 436             else
 437               break;
 438           }
 439         }
 440       }
 441 
 442       /*
 443        * Vertically:
 444        *
 445        * Make the above `ystr&#39; rows or&#39;ed with it.
 446        */
 447       for ( x = 1; x &lt;= ystr; x++ )
 448       {
 449         unsigned char*  q;
 450 
 451 
 452         q = p - bitmap-&gt;pitch * x;
 453         for ( i = 0; i &lt; pitch; i++ )
 454           q[i] |= p[i];
 455       }
 456 
 457       p += bitmap-&gt;pitch;
 458     }
 459 
 460     bitmap-&gt;width += (FT_UInt)xstr;
 461     bitmap-&gt;rows += (FT_UInt)ystr;
 462 
 463     return FT_Err_Ok;
 464   }
 465 
 466 
 467   static FT_Byte
 468   ft_gray_for_premultiplied_srgb_bgra( const FT_Byte*  bgra )
 469   {
 470     FT_UInt  a = bgra[3];
 471     FT_UInt  l;
 472 
 473 
 474     /* Short-circuit transparent color to avoid division by zero. */
 475     if ( !a )
 476       return 0;
 477 
 478     /*
 479      * Luminosity for sRGB is defined using ~0.2126,0.7152,0.0722
 480      * coefficients for RGB channels *on the linear colors*.
 481      * A gamma of 2.2 is fair to assume.  And then, we need to
 482      * undo the premultiplication too.
 483      *
 484      *   https://accessibility.kde.org/hsl-adjusted.php
 485      *
 486      * We do the computation with integers only, applying a gamma of 2.0.
 487      * We guarantee 32-bit arithmetic to avoid overflow but the resulting
 488      * luminosity fits into 16 bits.
 489      *
 490      */
 491 
 492     l = (  4732UL /* 0.0722 * 65536 */ * bgra[0] * bgra[0] +
 493           46871UL /* 0.7152 * 65536 */ * bgra[1] * bgra[1] +
 494           13933UL /* 0.2126 * 65536 */ * bgra[2] * bgra[2] ) &gt;&gt; 16;
 495 
 496     /*
 497      * Final transparency can be determined as follows.
 498      *
 499      * - If alpha is zero, we want 0.
 500      * - If alpha is zero and luminosity is zero, we want 255.
 501      * - If alpha is zero and luminosity is one, we want 0.
 502      *
 503      * So the formula is a * (1 - l) = a - l * a.
 504      *
 505      * We still need to undo premultiplication by dividing l by a*a.
 506      *
 507      */
 508 
 509     return (FT_Byte)( a - l / a );
 510   }
 511 
 512 
 513   /* documentation is in ftbitmap.h */
 514 
 515   FT_EXPORT_DEF( FT_Error )
 516   FT_Bitmap_Convert( FT_Library        library,
 517                      const FT_Bitmap  *source,
 518                      FT_Bitmap        *target,
 519                      FT_Int            alignment )
 520   {
 521     FT_Error   error = FT_Err_Ok;
 522     FT_Memory  memory;
 523 
 524     FT_Byte*  s;
 525     FT_Byte*  t;
 526 
 527 
 528     if ( !library )
 529       return FT_THROW( Invalid_Library_Handle );
 530 
 531     if ( !source || !target )
 532       return FT_THROW( Invalid_Argument );
 533 
 534     memory = library-&gt;memory;
 535 
 536     switch ( source-&gt;pixel_mode )
 537     {
 538     case FT_PIXEL_MODE_MONO:
 539     case FT_PIXEL_MODE_GRAY:
 540     case FT_PIXEL_MODE_GRAY2:
 541     case FT_PIXEL_MODE_GRAY4:
 542     case FT_PIXEL_MODE_LCD:
 543     case FT_PIXEL_MODE_LCD_V:
 544     case FT_PIXEL_MODE_BGRA:
 545       {
 546         FT_Int    pad, old_target_pitch, target_pitch;
 547         FT_ULong  old_size;
 548 
 549 
 550         old_target_pitch = target-&gt;pitch;
 551         if ( old_target_pitch &lt; 0 )
 552           old_target_pitch = -old_target_pitch;
 553 
 554         old_size = target-&gt;rows * (FT_UInt)old_target_pitch;
 555 
 556         target-&gt;pixel_mode = FT_PIXEL_MODE_GRAY;
 557         target-&gt;rows       = source-&gt;rows;
 558         target-&gt;width      = source-&gt;width;
 559 
 560         pad = 0;
 561         if ( alignment &gt; 0 )
 562         {
 563           pad = (FT_Int)source-&gt;width % alignment;
 564           if ( pad != 0 )
 565             pad = alignment - pad;
 566         }
 567 
 568         target_pitch = (FT_Int)source-&gt;width + pad;
 569 
 570         if ( target_pitch &gt; 0                                               &amp;&amp;
 571              (FT_ULong)target-&gt;rows &gt; FT_ULONG_MAX / (FT_ULong)target_pitch )
 572           return FT_THROW( Invalid_Argument );
 573 
 574         if ( FT_QREALLOC( target-&gt;buffer,
 575                           old_size, target-&gt;rows * (FT_UInt)target_pitch ) )
 576           return error;
 577 
 578         target-&gt;pitch = target-&gt;pitch &lt; 0 ? -target_pitch : target_pitch;
 579       }
 580       break;
 581 
 582     default:
 583       error = FT_THROW( Invalid_Argument );
 584     }
 585 
 586     s = source-&gt;buffer;
 587     t = target-&gt;buffer;
 588 
 589     /* take care of bitmap flow */
 590     if ( source-&gt;pitch &lt; 0 )
 591       s -= source-&gt;pitch * (FT_Int)( source-&gt;rows - 1 );
 592     if ( target-&gt;pitch &lt; 0 )
 593       t -= target-&gt;pitch * (FT_Int)( target-&gt;rows - 1 );
 594 
 595     switch ( source-&gt;pixel_mode )
 596     {
 597     case FT_PIXEL_MODE_MONO:
 598       {
 599         FT_UInt  i;
 600 
 601 
 602         target-&gt;num_grays = 2;
 603 
 604         for ( i = source-&gt;rows; i &gt; 0; i-- )
 605         {
 606           FT_Byte*  ss = s;
 607           FT_Byte*  tt = t;
 608           FT_UInt   j;
 609 
 610 
 611           /* get the full bytes */
 612           for ( j = source-&gt;width &gt;&gt; 3; j &gt; 0; j-- )
 613           {
 614             FT_Int  val = ss[0]; /* avoid a byte-&gt;int cast on each line */
 615 
 616 
 617             tt[0] = (FT_Byte)( ( val &amp; 0x80 ) &gt;&gt; 7 );
 618             tt[1] = (FT_Byte)( ( val &amp; 0x40 ) &gt;&gt; 6 );
 619             tt[2] = (FT_Byte)( ( val &amp; 0x20 ) &gt;&gt; 5 );
 620             tt[3] = (FT_Byte)( ( val &amp; 0x10 ) &gt;&gt; 4 );
 621             tt[4] = (FT_Byte)( ( val &amp; 0x08 ) &gt;&gt; 3 );
 622             tt[5] = (FT_Byte)( ( val &amp; 0x04 ) &gt;&gt; 2 );
 623             tt[6] = (FT_Byte)( ( val &amp; 0x02 ) &gt;&gt; 1 );
 624             tt[7] = (FT_Byte)(   val &amp; 0x01 );
 625 
 626             tt += 8;
 627             ss += 1;
 628           }
 629 
 630           /* get remaining pixels (if any) */
 631           j = source-&gt;width &amp; 7;
 632           if ( j &gt; 0 )
 633           {
 634             FT_Int  val = *ss;
 635 
 636 
 637             for ( ; j &gt; 0; j-- )
 638             {
 639               tt[0] = (FT_Byte)( ( val &amp; 0x80 ) &gt;&gt; 7);
 640               val &lt;&lt;= 1;
 641               tt   += 1;
 642             }
 643           }
 644 
 645           s += source-&gt;pitch;
 646           t += target-&gt;pitch;
 647         }
 648       }
 649       break;
 650 
 651 
 652     case FT_PIXEL_MODE_GRAY:
 653     case FT_PIXEL_MODE_LCD:
 654     case FT_PIXEL_MODE_LCD_V:
 655       {
 656         FT_UInt  width = source-&gt;width;
 657         FT_UInt  i;
 658 
 659 
 660         target-&gt;num_grays = 256;
 661 
 662         for ( i = source-&gt;rows; i &gt; 0; i-- )
 663         {
 664           FT_ARRAY_COPY( t, s, width );
 665 
 666           s += source-&gt;pitch;
 667           t += target-&gt;pitch;
 668         }
 669       }
 670       break;
 671 
 672 
 673     case FT_PIXEL_MODE_GRAY2:
 674       {
 675         FT_UInt  i;
 676 
 677 
 678         target-&gt;num_grays = 4;
 679 
 680         for ( i = source-&gt;rows; i &gt; 0; i-- )
 681         {
 682           FT_Byte*  ss = s;
 683           FT_Byte*  tt = t;
 684           FT_UInt   j;
 685 
 686 
 687           /* get the full bytes */
 688           for ( j = source-&gt;width &gt;&gt; 2; j &gt; 0; j-- )
 689           {
 690             FT_Int  val = ss[0];
 691 
 692 
 693             tt[0] = (FT_Byte)( ( val &amp; 0xC0 ) &gt;&gt; 6 );
 694             tt[1] = (FT_Byte)( ( val &amp; 0x30 ) &gt;&gt; 4 );
 695             tt[2] = (FT_Byte)( ( val &amp; 0x0C ) &gt;&gt; 2 );
 696             tt[3] = (FT_Byte)( ( val &amp; 0x03 ) );
 697 
 698             ss += 1;
 699             tt += 4;
 700           }
 701 
 702           j = source-&gt;width &amp; 3;
 703           if ( j &gt; 0 )
 704           {
 705             FT_Int  val = ss[0];
 706 
 707 
 708             for ( ; j &gt; 0; j-- )
 709             {
 710               tt[0]  = (FT_Byte)( ( val &amp; 0xC0 ) &gt;&gt; 6 );
 711               val  &lt;&lt;= 2;
 712               tt    += 1;
 713             }
 714           }
 715 
 716           s += source-&gt;pitch;
 717           t += target-&gt;pitch;
 718         }
 719       }
 720       break;
 721 
 722 
 723     case FT_PIXEL_MODE_GRAY4:
 724       {
 725         FT_UInt  i;
 726 
 727 
 728         target-&gt;num_grays = 16;
 729 
 730         for ( i = source-&gt;rows; i &gt; 0; i-- )
 731         {
 732           FT_Byte*  ss = s;
 733           FT_Byte*  tt = t;
 734           FT_UInt   j;
 735 
 736 
 737           /* get the full bytes */
 738           for ( j = source-&gt;width &gt;&gt; 1; j &gt; 0; j-- )
 739           {
 740             FT_Int  val = ss[0];
 741 
 742 
 743             tt[0] = (FT_Byte)( ( val &amp; 0xF0 ) &gt;&gt; 4 );
 744             tt[1] = (FT_Byte)( ( val &amp; 0x0F ) );
 745 
 746             ss += 1;
 747             tt += 2;
 748           }
 749 
 750           if ( source-&gt;width &amp; 1 )
 751             tt[0] = (FT_Byte)( ( ss[0] &amp; 0xF0 ) &gt;&gt; 4 );
 752 
 753           s += source-&gt;pitch;
 754           t += target-&gt;pitch;
 755         }
 756       }
 757       break;
 758 
 759 
 760     case FT_PIXEL_MODE_BGRA:
 761       {
 762         FT_UInt  i;
 763 
 764 
 765         target-&gt;num_grays = 256;
 766 
 767         for ( i = source-&gt;rows; i &gt; 0; i-- )
 768         {
 769           FT_Byte*  ss = s;
 770           FT_Byte*  tt = t;
 771           FT_UInt   j;
 772 
 773 
 774           for ( j = source-&gt;width; j &gt; 0; j-- )
 775           {
 776             tt[0] = ft_gray_for_premultiplied_srgb_bgra( ss );
 777 
 778             ss += 4;
 779             tt += 1;
 780           }
 781 
 782           s += source-&gt;pitch;
 783           t += target-&gt;pitch;
 784         }
 785       }
 786       break;
 787 
 788     default:
 789       ;
 790     }
 791 
 792     return error;
 793   }
 794 
 795 
<a name="4" id="anc4"></a><span class="line-added"> 796   /* documentation is in ftbitmap.h */</span>
<span class="line-added"> 797 </span>
<span class="line-added"> 798   FT_EXPORT_DEF( FT_Error )</span>
<span class="line-added"> 799   FT_Bitmap_Blend( FT_Library        library,</span>
<span class="line-added"> 800                    const FT_Bitmap*  source_,</span>
<span class="line-added"> 801                    const FT_Vector   source_offset_,</span>
<span class="line-added"> 802                    FT_Bitmap*        target,</span>
<span class="line-added"> 803                    FT_Vector        *atarget_offset,</span>
<span class="line-added"> 804                    FT_Color          color )</span>
<span class="line-added"> 805   {</span>
<span class="line-added"> 806     FT_Error   error = FT_Err_Ok;</span>
<span class="line-added"> 807     FT_Memory  memory;</span>
<span class="line-added"> 808 </span>
<span class="line-added"> 809     FT_Bitmap         source_bitmap;</span>
<span class="line-added"> 810     const FT_Bitmap*  source;</span>
<span class="line-added"> 811 </span>
<span class="line-added"> 812     FT_Vector  source_offset;</span>
<span class="line-added"> 813     FT_Vector  target_offset;</span>
<span class="line-added"> 814 </span>
<span class="line-added"> 815     FT_Bool  free_source_bitmap          = 0;</span>
<span class="line-added"> 816     FT_Bool  free_target_bitmap_on_error = 0;</span>
<span class="line-added"> 817 </span>
<span class="line-added"> 818     FT_Pos  source_llx, source_lly, source_urx, source_ury;</span>
<span class="line-added"> 819     FT_Pos  target_llx, target_lly, target_urx, target_ury;</span>
<span class="line-added"> 820     FT_Pos  final_llx, final_lly, final_urx, final_ury;</span>
<span class="line-added"> 821 </span>
<span class="line-added"> 822     unsigned int  final_rows, final_width;</span>
<span class="line-added"> 823     long          x, y;</span>
<span class="line-added"> 824 </span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826     if ( !library || !target || !source_ || !atarget_offset )</span>
<span class="line-added"> 827       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 828 </span>
<span class="line-added"> 829     memory = library-&gt;memory;</span>
<span class="line-added"> 830 </span>
<span class="line-added"> 831     if ( !( target-&gt;pixel_mode == FT_PIXEL_MODE_NONE     ||</span>
<span class="line-added"> 832             ( target-&gt;pixel_mode == FT_PIXEL_MODE_BGRA &amp;&amp;</span>
<span class="line-added"> 833               target-&gt;buffer                           ) ) )</span>
<span class="line-added"> 834       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     if ( source_-&gt;pixel_mode == FT_PIXEL_MODE_NONE )</span>
<span class="line-added"> 837       return FT_Err_Ok;               /* nothing to do */</span>
<span class="line-added"> 838 </span>
<span class="line-added"> 839     /* pitches must have the same sign */</span>
<span class="line-added"> 840     if ( target-&gt;pixel_mode == FT_PIXEL_MODE_BGRA &amp;&amp;</span>
<span class="line-added"> 841          ( source_-&gt;pitch ^ target-&gt;pitch ) &lt; 0   )</span>
<span class="line-added"> 842       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844     if ( !( source_-&gt;width &amp;&amp; source_-&gt;rows ) )</span>
<span class="line-added"> 845       return FT_Err_Ok;               /* nothing to do */</span>
<span class="line-added"> 846 </span>
<span class="line-added"> 847     /* assure integer pixel offsets */</span>
<span class="line-added"> 848     source_offset.x = FT_PIX_FLOOR( source_offset_.x );</span>
<span class="line-added"> 849     source_offset.y = FT_PIX_FLOOR( source_offset_.y );</span>
<span class="line-added"> 850     target_offset.x = FT_PIX_FLOOR( atarget_offset-&gt;x );</span>
<span class="line-added"> 851     target_offset.y = FT_PIX_FLOOR( atarget_offset-&gt;y );</span>
<span class="line-added"> 852 </span>
<span class="line-added"> 853     /* get source bitmap dimensions */</span>
<span class="line-added"> 854     source_llx = source_offset.x;</span>
<span class="line-added"> 855     if ( FT_LONG_MIN + (FT_Pos)( source_-&gt;rows &lt;&lt; 6 ) + 64 &gt; source_offset.y )</span>
<span class="line-added"> 856     {</span>
<span class="line-added"> 857       FT_TRACE5((</span>
<span class="line-added"> 858         &quot;FT_Bitmap_Blend: y coordinate overflow in source bitmap\n&quot; ));</span>
<span class="line-added"> 859       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 860     }</span>
<span class="line-added"> 861     source_lly = source_offset.y - ( source_-&gt;rows &lt;&lt; 6 );</span>
<span class="line-added"> 862 </span>
<span class="line-added"> 863     if ( FT_LONG_MAX - (FT_Pos)( source_-&gt;width &lt;&lt; 6 ) - 64 &lt; source_llx )</span>
<span class="line-added"> 864     {</span>
<span class="line-added"> 865       FT_TRACE5((</span>
<span class="line-added"> 866         &quot;FT_Bitmap_Blend: x coordinate overflow in source bitmap\n&quot; ));</span>
<span class="line-added"> 867       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 868     }</span>
<span class="line-added"> 869     source_urx = source_llx + ( source_-&gt;width &lt;&lt; 6 );</span>
<span class="line-added"> 870     source_ury = source_offset.y;</span>
<span class="line-added"> 871 </span>
<span class="line-added"> 872     /* get target bitmap dimensions */</span>
<span class="line-added"> 873     if ( target-&gt;width &amp;&amp; target-&gt;rows )</span>
<span class="line-added"> 874     {</span>
<span class="line-added"> 875       target_llx = target_offset.x;</span>
<span class="line-added"> 876       if ( FT_LONG_MIN + (FT_Pos)( target-&gt;rows &lt;&lt; 6 ) &gt; target_offset.y )</span>
<span class="line-added"> 877       {</span>
<span class="line-added"> 878         FT_TRACE5((</span>
<span class="line-added"> 879           &quot;FT_Bitmap_Blend: y coordinate overflow in target bitmap\n&quot; ));</span>
<span class="line-added"> 880         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 881       }</span>
<span class="line-added"> 882       target_lly = target_offset.y - ( target-&gt;rows &lt;&lt; 6 );</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884       if ( FT_LONG_MAX - (FT_Pos)( target-&gt;width &lt;&lt; 6 ) &lt; target_llx )</span>
<span class="line-added"> 885       {</span>
<span class="line-added"> 886         FT_TRACE5((</span>
<span class="line-added"> 887           &quot;FT_Bitmap_Blend: x coordinate overflow in target bitmap\n&quot; ));</span>
<span class="line-added"> 888         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 889       }</span>
<span class="line-added"> 890       target_urx = target_llx + ( target-&gt;width &lt;&lt; 6 );</span>
<span class="line-added"> 891       target_ury = target_offset.y;</span>
<span class="line-added"> 892     }</span>
<span class="line-added"> 893     else</span>
<span class="line-added"> 894     {</span>
<span class="line-added"> 895       target_llx = FT_LONG_MAX;</span>
<span class="line-added"> 896       target_lly = FT_LONG_MAX;</span>
<span class="line-added"> 897       target_urx = FT_LONG_MIN;</span>
<span class="line-added"> 898       target_ury = FT_LONG_MIN;</span>
<span class="line-added"> 899     }</span>
<span class="line-added"> 900 </span>
<span class="line-added"> 901     /* compute final bitmap dimensions */</span>
<span class="line-added"> 902     final_llx = FT_MIN( source_llx, target_llx );</span>
<span class="line-added"> 903     final_lly = FT_MIN( source_lly, target_lly );</span>
<span class="line-added"> 904     final_urx = FT_MAX( source_urx, target_urx );</span>
<span class="line-added"> 905     final_ury = FT_MAX( source_ury, target_ury );</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907     final_width = ( final_urx - final_llx ) &gt;&gt; 6;</span>
<span class="line-added"> 908     final_rows  = ( final_ury - final_lly ) &gt;&gt; 6;</span>
<span class="line-added"> 909 </span>
<span class="line-added"> 910 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added"> 911     FT_TRACE5(( &quot;FT_Bitmap_Blend:\n&quot;</span>
<span class="line-added"> 912                 &quot;  source bitmap: (%d, %d) -- (%d, %d); %d x %d\n&quot;,</span>
<span class="line-added"> 913       source_llx / 64, source_lly / 64,</span>
<span class="line-added"> 914       source_urx / 64, source_ury / 64,</span>
<span class="line-added"> 915       source_-&gt;width, source_-&gt;rows ));</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     if ( target-&gt;width &amp;&amp; target-&gt;rows )</span>
<span class="line-added"> 918       FT_TRACE5(( &quot;  target bitmap: (%d, %d) -- (%d, %d); %d x %d\n&quot;,</span>
<span class="line-added"> 919         target_llx / 64, target_lly / 64,</span>
<span class="line-added"> 920         target_urx / 64, target_ury / 64,</span>
<span class="line-added"> 921         target-&gt;width, target-&gt;rows ));</span>
<span class="line-added"> 922     else</span>
<span class="line-added"> 923       FT_TRACE5(( &quot;  target bitmap: empty\n&quot; ));</span>
<span class="line-added"> 924 </span>
<span class="line-added"> 925     if ( final_width &amp;&amp; final_rows )</span>
<span class="line-added"> 926       FT_TRACE5(( &quot;  final bitmap: (%d, %d) -- (%d, %d); %d x %d\n&quot;,</span>
<span class="line-added"> 927         final_llx / 64, final_lly / 64,</span>
<span class="line-added"> 928         final_urx / 64, final_ury / 64,</span>
<span class="line-added"> 929         final_width, final_rows ));</span>
<span class="line-added"> 930     else</span>
<span class="line-added"> 931       FT_TRACE5(( &quot;  final bitmap: empty\n&quot; ));</span>
<span class="line-added"> 932 #endif /* FT_DEBUG_LEVEL_TRACE */</span>
<span class="line-added"> 933 </span>
<span class="line-added"> 934     if ( !( final_width &amp;&amp; final_rows ) )</span>
<span class="line-added"> 935       return FT_Err_Ok;               /* nothing to do */</span>
<span class="line-added"> 936 </span>
<span class="line-added"> 937     /* for blending, set offset vector of final bitmap */</span>
<span class="line-added"> 938     /* temporarily to (0,0)                            */</span>
<span class="line-added"> 939     source_llx -= final_llx;</span>
<span class="line-added"> 940     source_lly -= final_lly;</span>
<span class="line-added"> 941 </span>
<span class="line-added"> 942     if ( target-&gt;width &amp;&amp; target-&gt;rows )</span>
<span class="line-added"> 943     {</span>
<span class="line-added"> 944       target_llx -= final_llx;</span>
<span class="line-added"> 945       target_lly -= final_lly;</span>
<span class="line-added"> 946     }</span>
<span class="line-added"> 947 </span>
<span class="line-added"> 948     /* set up target bitmap */</span>
<span class="line-added"> 949     if ( target-&gt;pixel_mode == FT_PIXEL_MODE_NONE )</span>
<span class="line-added"> 950     {</span>
<span class="line-added"> 951       /* create new empty bitmap */</span>
<span class="line-added"> 952       target-&gt;width      = final_width;</span>
<span class="line-added"> 953       target-&gt;rows       = final_rows;</span>
<span class="line-added"> 954       target-&gt;pixel_mode = FT_PIXEL_MODE_BGRA;</span>
<span class="line-added"> 955       target-&gt;pitch      = (int)final_width * 4;</span>
<span class="line-added"> 956       target-&gt;num_grays  = 256;</span>
<span class="line-added"> 957 </span>
<span class="line-added"> 958       if ( FT_LONG_MAX / target-&gt;pitch &lt; (int)target-&gt;rows )</span>
<span class="line-added"> 959       {</span>
<span class="line-added"> 960         FT_TRACE5(( &quot;FT_Blend_Bitmap: target bitmap too large (%d x %d)\n&quot;,</span>
<span class="line-added"> 961                      final_width, final_rows ));</span>
<span class="line-added"> 962         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 963       }</span>
<span class="line-added"> 964 </span>
<span class="line-added"> 965       if ( FT_ALLOC( target-&gt;buffer, target-&gt;pitch * (int)target-&gt;rows ) )</span>
<span class="line-added"> 966         return error;</span>
<span class="line-added"> 967 </span>
<span class="line-added"> 968       free_target_bitmap_on_error = 1;</span>
<span class="line-added"> 969     }</span>
<span class="line-added"> 970     else if ( target-&gt;width != final_width ||</span>
<span class="line-added"> 971               target-&gt;rows  != final_rows  )</span>
<span class="line-added"> 972     {</span>
<span class="line-added"> 973       /* adjust old bitmap to enlarged size */</span>
<span class="line-added"> 974       int  pitch, new_pitch;</span>
<span class="line-added"> 975 </span>
<span class="line-added"> 976       unsigned char*  buffer = NULL;</span>
<span class="line-added"> 977 </span>
<span class="line-added"> 978 </span>
<span class="line-added"> 979       pitch = target-&gt;pitch;</span>
<span class="line-added"> 980 </span>
<span class="line-added"> 981       if ( pitch &lt; 0 )</span>
<span class="line-added"> 982         pitch = -pitch;</span>
<span class="line-added"> 983 </span>
<span class="line-added"> 984       new_pitch = (int)final_width * 4;</span>
<span class="line-added"> 985 </span>
<span class="line-added"> 986       if ( FT_LONG_MAX / new_pitch &lt; (int)final_rows )</span>
<span class="line-added"> 987       {</span>
<span class="line-added"> 988         FT_TRACE5(( &quot;FT_Blend_Bitmap: target bitmap too large (%d x %d)\n&quot;,</span>
<span class="line-added"> 989                      final_width, final_rows ));</span>
<span class="line-added"> 990         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 991       }</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993       /* TODO: provide an in-buffer solution for large bitmaps */</span>
<span class="line-added"> 994       /*       to avoid allocation of a new buffer             */</span>
<span class="line-added"> 995       if ( FT_ALLOC( buffer, new_pitch * (int)final_rows ) )</span>
<span class="line-added"> 996         goto Error;</span>
<span class="line-added"> 997 </span>
<span class="line-added"> 998       /* copy data to new buffer */</span>
<span class="line-added"> 999       x = target_llx &gt;&gt; 6;</span>
<span class="line-added">1000       y = target_lly &gt;&gt; 6;</span>
<span class="line-added">1001 </span>
<span class="line-added">1002       /* the bitmap flow is from top to bottom, */</span>
<span class="line-added">1003       /* but y is measured from bottom to top   */</span>
<span class="line-added">1004       if ( target-&gt;pitch &lt; 0 )</span>
<span class="line-added">1005       {</span>
<span class="line-added">1006         /* XXX */</span>
<span class="line-added">1007       }</span>
<span class="line-added">1008       else</span>
<span class="line-added">1009       {</span>
<span class="line-added">1010         unsigned char*  p =</span>
<span class="line-added">1011           target-&gt;buffer;</span>
<span class="line-added">1012         unsigned char*  q =</span>
<span class="line-added">1013           buffer +</span>
<span class="line-added">1014           ( final_rows - y - target-&gt;rows ) * new_pitch +</span>
<span class="line-added">1015           x * 4;</span>
<span class="line-added">1016         unsigned char*  limit_p =</span>
<span class="line-added">1017           p + pitch * (int)target-&gt;rows;</span>
<span class="line-added">1018 </span>
<span class="line-added">1019 </span>
<span class="line-added">1020         while ( p &lt; limit_p )</span>
<span class="line-added">1021         {</span>
<span class="line-added">1022           FT_MEM_COPY( q, p, pitch );</span>
<span class="line-added">1023 </span>
<span class="line-added">1024           p += pitch;</span>
<span class="line-added">1025           q += new_pitch;</span>
<span class="line-added">1026         }</span>
<span class="line-added">1027       }</span>
<span class="line-added">1028 </span>
<span class="line-added">1029       FT_FREE( target-&gt;buffer );</span>
<span class="line-added">1030 </span>
<span class="line-added">1031       target-&gt;width = final_width;</span>
<span class="line-added">1032       target-&gt;rows  = final_rows;</span>
<span class="line-added">1033 </span>
<span class="line-added">1034       if ( target-&gt;pitch &lt; 0 )</span>
<span class="line-added">1035         target-&gt;pitch = -new_pitch;</span>
<span class="line-added">1036       else</span>
<span class="line-added">1037         target-&gt;pitch = new_pitch;</span>
<span class="line-added">1038 </span>
<span class="line-added">1039       target-&gt;buffer = buffer;</span>
<span class="line-added">1040     }</span>
<span class="line-added">1041 </span>
<span class="line-added">1042     /* adjust source bitmap if necessary */</span>
<span class="line-added">1043     if ( source_-&gt;pixel_mode != FT_PIXEL_MODE_GRAY )</span>
<span class="line-added">1044     {</span>
<span class="line-added">1045       FT_Bitmap_Init( &amp;source_bitmap );</span>
<span class="line-added">1046       error = FT_Bitmap_Convert( library, source_, &amp;source_bitmap, 1 );</span>
<span class="line-added">1047       if ( error )</span>
<span class="line-added">1048         goto Error;</span>
<span class="line-added">1049 </span>
<span class="line-added">1050       source             = &amp;source_bitmap;</span>
<span class="line-added">1051       free_source_bitmap = 1;</span>
<span class="line-added">1052     }</span>
<span class="line-added">1053     else</span>
<span class="line-added">1054       source = source_;</span>
<span class="line-added">1055 </span>
<span class="line-added">1056     /* do blending; the code below returns pre-multiplied channels, */</span>
<span class="line-added">1057     /* similar to what FreeType gets from `CBDT&#39; tables             */</span>
<span class="line-added">1058     x = source_llx &gt;&gt; 6;</span>
<span class="line-added">1059     y = source_lly &gt;&gt; 6;</span>
<span class="line-added">1060 </span>
<span class="line-added">1061     /* the bitmap flow is from top to bottom, */</span>
<span class="line-added">1062     /* but y is measured from bottom to top   */</span>
<span class="line-added">1063     if ( target-&gt;pitch &lt; 0 )</span>
<span class="line-added">1064     {</span>
<span class="line-added">1065       /* XXX */</span>
<span class="line-added">1066     }</span>
<span class="line-added">1067     else</span>
<span class="line-added">1068     {</span>
<span class="line-added">1069       unsigned char*  p =</span>
<span class="line-added">1070         source-&gt;buffer;</span>
<span class="line-added">1071       unsigned char*  q =</span>
<span class="line-added">1072         target-&gt;buffer +</span>
<span class="line-added">1073         ( target-&gt;rows - y - source-&gt;rows ) * target-&gt;pitch +</span>
<span class="line-added">1074         x * 4;</span>
<span class="line-added">1075       unsigned char*  limit_p =</span>
<span class="line-added">1076         p + source-&gt;pitch * (int)source-&gt;rows;</span>
<span class="line-added">1077 </span>
<span class="line-added">1078 </span>
<span class="line-added">1079       while ( p &lt; limit_p )</span>
<span class="line-added">1080       {</span>
<span class="line-added">1081         unsigned char*  r       = p;</span>
<span class="line-added">1082         unsigned char*  s       = q;</span>
<span class="line-added">1083         unsigned char*  limit_r = r + source-&gt;width;</span>
<span class="line-added">1084 </span>
<span class="line-added">1085 </span>
<span class="line-added">1086         while ( r &lt; limit_r )</span>
<span class="line-added">1087         {</span>
<span class="line-added">1088           int  aa = *r++;</span>
<span class="line-added">1089           int  fa = color.alpha * aa / 255;</span>
<span class="line-added">1090 </span>
<span class="line-added">1091           int  fb = color.blue * fa / 255;</span>
<span class="line-added">1092           int  fg = color.green * fa / 255;</span>
<span class="line-added">1093           int  fr = color.red * fa / 255;</span>
<span class="line-added">1094 </span>
<span class="line-added">1095           int  ba2 = 255 - fa;</span>
<span class="line-added">1096 </span>
<span class="line-added">1097           int  bb = s[0];</span>
<span class="line-added">1098           int  bg = s[1];</span>
<span class="line-added">1099           int  br = s[2];</span>
<span class="line-added">1100           int  ba = s[3];</span>
<span class="line-added">1101 </span>
<span class="line-added">1102 </span>
<span class="line-added">1103           *s++ = (unsigned char)( bb * ba2 / 255 + fb );</span>
<span class="line-added">1104           *s++ = (unsigned char)( bg * ba2 / 255 + fg );</span>
<span class="line-added">1105           *s++ = (unsigned char)( br * ba2 / 255 + fr );</span>
<span class="line-added">1106           *s++ = (unsigned char)( ba * ba2 / 255 + fa );</span>
<span class="line-added">1107         }</span>
<span class="line-added">1108 </span>
<span class="line-added">1109         p += source-&gt;pitch;</span>
<span class="line-added">1110         q += target-&gt;pitch;</span>
<span class="line-added">1111       }</span>
<span class="line-added">1112     }</span>
<span class="line-added">1113 </span>
<span class="line-added">1114     atarget_offset-&gt;x = final_llx;</span>
<span class="line-added">1115     atarget_offset-&gt;y = final_lly + ( final_rows &lt;&lt; 6 );</span>
<span class="line-added">1116 </span>
<span class="line-added">1117   Error:</span>
<span class="line-added">1118     if ( error &amp;&amp; free_target_bitmap_on_error )</span>
<span class="line-added">1119       FT_Bitmap_Done( library, target );</span>
<span class="line-added">1120 </span>
<span class="line-added">1121     if ( free_source_bitmap )</span>
<span class="line-added">1122       FT_Bitmap_Done( library, &amp;source_bitmap );</span>
<span class="line-added">1123 </span>
<span class="line-added">1124     return error;</span>
<span class="line-added">1125   }</span>
<span class="line-added">1126 </span>
<span class="line-added">1127 </span>
1128   /* documentation is in ftbitmap.h */
1129 
1130   FT_EXPORT_DEF( FT_Error )
1131   FT_GlyphSlot_Own_Bitmap( FT_GlyphSlot  slot )
1132   {
1133     if ( slot &amp;&amp; slot-&gt;format == FT_GLYPH_FORMAT_BITMAP   &amp;&amp;
1134          !( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )
1135     {
1136       FT_Bitmap  bitmap;
1137       FT_Error   error;
1138 
1139 
1140       FT_Bitmap_Init( &amp;bitmap );
1141       error = FT_Bitmap_Copy( slot-&gt;library, &amp;slot-&gt;bitmap, &amp;bitmap );
1142       if ( error )
1143         return error;
1144 
1145       slot-&gt;bitmap = bitmap;
1146       slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;
1147     }
1148 
1149     return FT_Err_Ok;
1150   }
1151 
1152 
1153   /* documentation is in ftbitmap.h */
1154 
1155   FT_EXPORT_DEF( FT_Error )
1156   FT_Bitmap_Done( FT_Library  library,
1157                   FT_Bitmap  *bitmap )
1158   {
1159     FT_Memory  memory;
1160 
1161 
1162     if ( !library )
1163       return FT_THROW( Invalid_Library_Handle );
1164 
1165     if ( !bitmap )
1166       return FT_THROW( Invalid_Argument );
1167 
1168     memory = library-&gt;memory;
1169 
1170     FT_FREE( bitmap-&gt;buffer );
1171     *bitmap = null_bitmap;
1172 
1173     return FT_Err_Ok;
1174   }
1175 
1176 
1177 /* END */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
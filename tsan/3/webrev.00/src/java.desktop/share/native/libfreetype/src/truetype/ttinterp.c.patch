diff a/src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c b/src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c
--- a/src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c
+++ b/src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c
@@ -1,21 +1,21 @@
-/***************************************************************************/
-/*                                                                         */
-/*  ttinterp.c                                                             */
-/*                                                                         */
-/*    TrueType bytecode interpreter (body).                                */
-/*                                                                         */
-/*  Copyright 1996-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * ttinterp.c
+ *
+ *   TrueType bytecode interpreter (body).
+ *
+ * Copyright (C) 1996-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 /* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
 /* issues; many thanks!                                                */
 
@@ -37,18 +37,18 @@
 
 
 #ifdef TT_USE_BYTECODE_INTERPRETER
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_ttinterp
+#define FT_COMPONENT  ttinterp
 
 
 #define NO_SUBPIXEL_HINTING                                                  \
           ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
             TT_INTERPRETER_VERSION_35 )
@@ -80,14 +80,14 @@
 
 #define FAST_DUALPROJ( v )                          \
           exc->func_dualproj( exc, (v)->x, (v)->y )
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Two simple bounds-checking macros.                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * Two simple bounds-checking macros.
+   */
 #define BOUNDS( x, n )   ( (FT_UInt)(x)  >= (FT_UInt)(n)  )
 #define BOUNDSL( x, n )  ( (FT_ULong)(x) >= (FT_ULong)(n) )
 
 
 #undef  SUCCESS
@@ -95,34 +95,37 @@
 
 #undef  FAILURE
 #define FAILURE  1
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /*                        CODERANGE FUNCTIONS                            */
-  /*                                                                       */
-  /*************************************************************************/
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Goto_CodeRange                                                  */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Switches to a new code range (updates the code related elements in */
-  /*    `exec', and `IP').                                                 */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    range :: The new execution code range.                             */
-  /*                                                                       */
-  /*    IP    :: The new IP in the new code range.                         */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    exec  :: The target execution context.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   *                       CODERANGE FUNCTIONS
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Goto_CodeRange
+   *
+   * @Description:
+   *   Switches to a new code range (updates the code related elements in
+   *   `exec', and `IP').
+   *
+   * @Input:
+   *   range ::
+   *     The new execution code range.
+   *
+   *   IP ::
+   *     The new IP in the new code range.
+   *
+   * @InOut:
+   *   exec ::
+   *     The target execution context.
+   */
   FT_LOCAL_DEF( void )
   TT_Goto_CodeRange( TT_ExecContext  exec,
                      FT_Int          range,
                      FT_Long         IP )
   {
@@ -146,28 +149,32 @@
     exec->IP       = IP;
     exec->curRange = range;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Set_CodeRange                                                   */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Sets a code range.                                                 */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    range  :: The code range index.                                    */
-  /*                                                                       */
-  /*    base   :: The new code base.                                       */
-  /*                                                                       */
-  /*    length :: The range size in bytes.                                 */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    exec   :: The target execution context.                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Set_CodeRange
+   *
+   * @Description:
+   *   Sets a code range.
+   *
+   * @Input:
+   *   range ::
+   *     The code range index.
+   *
+   *   base ::
+   *     The new code base.
+   *
+   *   length ::
+   *     The range size in bytes.
+   *
+   * @InOut:
+   *   exec ::
+   *     The target execution context.
+   */
   FT_LOCAL_DEF( void )
   TT_Set_CodeRange( TT_ExecContext  exec,
                     FT_Int          range,
                     void*           base,
                     FT_Long         length )
@@ -177,24 +184,26 @@
     exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
     exec->codeRangeTable[range - 1].size = length;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Clear_CodeRange                                                 */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Clears a code range.                                               */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    range :: The code range index.                                     */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    exec  :: The target execution context.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Clear_CodeRange
+   *
+   * @Description:
+   *   Clears a code range.
+   *
+   * @Input:
+   *   range ::
+   *     The code range index.
+   *
+   * @InOut:
+   *   exec ::
+   *     The target execution context.
+   */
   FT_LOCAL_DEF( void )
   TT_Clear_CodeRange( TT_ExecContext  exec,
                       FT_Int          range )
   {
     FT_ASSERT( range >= 1 && range <= 3 );
@@ -202,33 +211,35 @@
     exec->codeRangeTable[range - 1].base = NULL;
     exec->codeRangeTable[range - 1].size = 0;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /*                   EXECUTION CONTEXT ROUTINES                          */
-  /*                                                                       */
-  /*************************************************************************/
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Done_Context                                                    */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Destroys a given context.                                          */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    exec   :: A handle to the target execution context.                */
-  /*                                                                       */
-  /*    memory :: A handle to the parent memory object.                    */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    Only the glyph loader and debugger should call this function.      */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   *                  EXECUTION CONTEXT ROUTINES
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Done_Context
+   *
+   * @Description:
+   *   Destroys a given context.
+   *
+   * @Input:
+   *   exec ::
+   *     A handle to the target execution context.
+   *
+   *   memory ::
+   *     A handle to the parent memory object.
+   *
+   * @Note:
+   *   Only the glyph loader and debugger should call this function.
+   */
   FT_LOCAL_DEF( void )
   TT_Done_Context( TT_ExecContext  exec )
   {
     FT_Memory  memory = exec->memory;
 
@@ -255,27 +266,29 @@
 
     FT_FREE( exec );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Init_Context                                                       */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Initializes a context object.                                      */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    memory :: A handle to the parent memory object.                    */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    exec   :: A handle to the target execution context.                */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Init_Context
+   *
+   * @Description:
+   *   Initializes a context object.
+   *
+   * @Input:
+   *   memory ::
+   *     A handle to the parent memory object.
+   *
+   * @InOut:
+   *   exec ::
+   *     A handle to the target execution context.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   */
   static FT_Error
   Init_Context( TT_ExecContext  exec,
                 FT_Memory       memory )
   {
     FT_Error  error;
@@ -311,34 +324,39 @@
 
     return error;
  }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Update_Max                                                         */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Checks the size of a buffer and reallocates it if necessary.       */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    memory     :: A handle to the parent memory object.                */
-  /*                                                                       */
-  /*    multiplier :: The size in bytes of each element in the buffer.     */
-  /*                                                                       */
-  /*    new_max    :: The new capacity (size) of the buffer.               */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    size       :: The address of the buffer's current size expressed   */
-  /*                  in elements.                                         */
-  /*                                                                       */
-  /*    buff       :: The address of the buffer base pointer.              */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Update_Max
+   *
+   * @Description:
+   *   Checks the size of a buffer and reallocates it if necessary.
+   *
+   * @Input:
+   *   memory ::
+   *     A handle to the parent memory object.
+   *
+   *   multiplier ::
+   *     The size in bytes of each element in the buffer.
+   *
+   *   new_max ::
+   *     The new capacity (size) of the buffer.
+   *
+   * @InOut:
+   *   size ::
+   *     The address of the buffer's current size expressed
+   *     in elements.
+   *
+   *   buff ::
+   *     The address of the buffer base pointer.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   */
   FT_LOCAL_DEF( FT_Error )
   Update_Max( FT_Memory  memory,
               FT_ULong*  size,
               FT_ULong   multiplier,
               void*      _pbuff,
@@ -357,32 +375,35 @@
 
     return FT_Err_Ok;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Load_Context                                                    */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Prepare an execution context for glyph hinting.                    */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    face :: A handle to the source face object.                        */
-  /*                                                                       */
-  /*    size :: A handle to the source size object.                        */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    exec :: A handle to the target execution context.                  */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    FreeType error code.  0 means success.                             */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    Only the glyph loader and debugger should call this function.      */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Load_Context
+   *
+   * @Description:
+   *   Prepare an execution context for glyph hinting.
+   *
+   * @Input:
+   *   face ::
+   *     A handle to the source face object.
+   *
+   *   size ::
+   *     A handle to the source size object.
+   *
+   * @InOut:
+   *   exec ::
+   *     A handle to the target execution context.
+   *
+   * @Return:
+   *   FreeType error code.  0 means success.
+   *
+   * @Note:
+   *   Only the glyph loader and debugger should call this function.
+   */
   FT_LOCAL_DEF( FT_Error )
   TT_Load_Context( TT_ExecContext  exec,
                    TT_Face         face,
                    TT_Size         size )
   {
@@ -465,27 +486,29 @@
 
     return FT_Err_Ok;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Save_Context                                                    */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Saves the code ranges in a `size' object.                          */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    exec :: A handle to the source execution context.                  */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    size :: A handle to the target size object.                        */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    Only the glyph loader and debugger should call this function.      */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Save_Context
+   *
+   * @Description:
+   *   Saves the code ranges in a `size' object.
+   *
+   * @Input:
+   *   exec ::
+   *     A handle to the source execution context.
+   *
+   * @InOut:
+   *   size ::
+   *     A handle to the target size object.
+   *
+   * @Note:
+   *   Only the glyph loader and debugger should call this function.
+   */
   FT_LOCAL_DEF( void )
   TT_Save_Context( TT_ExecContext  exec,
                    TT_Size         size )
   {
     FT_Int  i;
@@ -503,31 +526,25 @@
     for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
       size->codeRangeTable[i] = exec->codeRangeTable[i];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    TT_Run_Context                                                     */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Executes one or more instructions in the execution context.        */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    debug :: A Boolean flag.  If set, the function sets some internal  */
-  /*             variables and returns immediately, otherwise TT_RunIns()  */
-  /*             is called.                                                */
-  /*                                                                       */
-  /*             This is commented out currently.                          */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    exec  :: A handle to the target execution context.                 */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    TrueType error code.  0 means success.                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   TT_Run_Context
+   *
+   * @Description:
+   *   Executes one or more instructions in the execution context.
+   *
+   * @Input:
+   *   exec ::
+   *     A handle to the target execution context.
+   *
+   * @Return:
+   *   TrueType error code.  0 means success.
+   */
   FT_LOCAL_DEF( FT_Error )
   TT_Run_Context( TT_ExecContext  exec )
   {
     TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );
 
@@ -607,26 +624,26 @@
   Fail:
     return NULL;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Before an opcode is executed, the interpreter verifies that there are */
-  /* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
-  /* table.                                                                */
-  /*                                                                       */
-  /* For each opcode, the first column gives the number of arguments that  */
-  /* are popped from the stack; the second one gives the number of those   */
-  /* that are pushed in result.                                            */
-  /*                                                                       */
-  /* Opcodes which have a varying number of parameters in the data stream  */
-  /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
-  /* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
-  /* to zero.                                                              */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * Before an opcode is executed, the interpreter verifies that there are
+   * enough arguments on the stack, with the help of the `Pop_Push_Count'
+   * table.
+   *
+   * For each opcode, the first column gives the number of arguments that
+   * are popped from the stack; the second one gives the number of those
+   * that are pushed in result.
+   *
+   * Opcodes which have a varying number of parameters in the data stream
+   * (NPUSHB, NPUSHW) are handled specially; they have a negative value in
+   * the `opcode_length' table, and the value in `Pop_Push_Count' is set
+   * to zero.
+   *
+   */
 
 
 #undef  PACK
 #define PACK( x, y )  ( ( x << 4 ) | y )
 
@@ -635,27 +652,29 @@
   const FT_Byte  Pop_Push_Count[256] =
   {
     /* opcodes are gathered in groups of 16 */
     /* please keep the spaces as they are   */
 
-    /*  SVTCA  y  */  PACK( 0, 0 ),
-    /*  SVTCA  x  */  PACK( 0, 0 ),
-    /*  SPvTCA y  */  PACK( 0, 0 ),
-    /*  SPvTCA x  */  PACK( 0, 0 ),
-    /*  SFvTCA y  */  PACK( 0, 0 ),
-    /*  SFvTCA x  */  PACK( 0, 0 ),
-    /*  SPvTL //  */  PACK( 2, 0 ),
-    /*  SPvTL +   */  PACK( 2, 0 ),
-    /*  SFvTL //  */  PACK( 2, 0 ),
-    /*  SFvTL +   */  PACK( 2, 0 ),
-    /*  SPvFS     */  PACK( 2, 0 ),
-    /*  SFvFS     */  PACK( 2, 0 ),
-    /*  GPv       */  PACK( 0, 2 ),
-    /*  GFv       */  PACK( 0, 2 ),
-    /*  SFvTPv    */  PACK( 0, 0 ),
+    /* 0x00 */
+    /*  SVTCA[0]  */  PACK( 0, 0 ),
+    /*  SVTCA[1]  */  PACK( 0, 0 ),
+    /*  SPVTCA[0] */  PACK( 0, 0 ),
+    /*  SPVTCA[1] */  PACK( 0, 0 ),
+    /*  SFVTCA[0] */  PACK( 0, 0 ),
+    /*  SFVTCA[1] */  PACK( 0, 0 ),
+    /*  SPVTL[0]  */  PACK( 2, 0 ),
+    /*  SPVTL[1]  */  PACK( 2, 0 ),
+    /*  SFVTL[0]  */  PACK( 2, 0 ),
+    /*  SFVTL[1]  */  PACK( 2, 0 ),
+    /*  SPVFS     */  PACK( 2, 0 ),
+    /*  SFVFS     */  PACK( 2, 0 ),
+    /*  GPV       */  PACK( 0, 2 ),
+    /*  GFV       */  PACK( 0, 2 ),
+    /*  SFVTPV    */  PACK( 0, 0 ),
     /*  ISECT     */  PACK( 5, 0 ),
 
+    /* 0x10 */
     /*  SRP0      */  PACK( 1, 0 ),
     /*  SRP1      */  PACK( 1, 0 ),
     /*  SRP2      */  PACK( 1, 0 ),
     /*  SZP0      */  PACK( 1, 0 ),
     /*  SZP1      */  PACK( 1, 0 ),
@@ -665,31 +684,33 @@
     /*  RTG       */  PACK( 0, 0 ),
     /*  RTHG      */  PACK( 0, 0 ),
     /*  SMD       */  PACK( 1, 0 ),
     /*  ELSE      */  PACK( 0, 0 ),
     /*  JMPR      */  PACK( 1, 0 ),
-    /*  SCvTCi    */  PACK( 1, 0 ),
-    /*  SSwCi     */  PACK( 1, 0 ),
+    /*  SCVTCI    */  PACK( 1, 0 ),
+    /*  SSWCI     */  PACK( 1, 0 ),
     /*  SSW       */  PACK( 1, 0 ),
 
+    /* 0x20 */
     /*  DUP       */  PACK( 1, 2 ),
     /*  POP       */  PACK( 1, 0 ),
     /*  CLEAR     */  PACK( 0, 0 ),
     /*  SWAP      */  PACK( 2, 2 ),
     /*  DEPTH     */  PACK( 0, 1 ),
     /*  CINDEX    */  PACK( 1, 1 ),
     /*  MINDEX    */  PACK( 1, 0 ),
-    /*  AlignPTS  */  PACK( 2, 0 ),
+    /*  ALIGNPTS  */  PACK( 2, 0 ),
     /*  INS_$28   */  PACK( 0, 0 ),
     /*  UTP       */  PACK( 1, 0 ),
     /*  LOOPCALL  */  PACK( 2, 0 ),
     /*  CALL      */  PACK( 1, 0 ),
     /*  FDEF      */  PACK( 1, 0 ),
     /*  ENDF      */  PACK( 0, 0 ),
     /*  MDAP[0]   */  PACK( 1, 0 ),
     /*  MDAP[1]   */  PACK( 1, 0 ),
 
+    /* 0x30 */
     /*  IUP[0]    */  PACK( 0, 0 ),
     /*  IUP[1]    */  PACK( 0, 0 ),
     /*  SHP[0]    */  PACK( 0, 0 ), /* loops */
     /*  SHP[1]    */  PACK( 0, 0 ), /* loops */
     /*  SHC[0]    */  PACK( 1, 0 ),
@@ -698,32 +719,34 @@
     /*  SHZ[1]    */  PACK( 1, 0 ),
     /*  SHPIX     */  PACK( 1, 0 ), /* loops */
     /*  IP        */  PACK( 0, 0 ), /* loops */
     /*  MSIRP[0]  */  PACK( 2, 0 ),
     /*  MSIRP[1]  */  PACK( 2, 0 ),
-    /*  AlignRP   */  PACK( 0, 0 ), /* loops */
+    /*  ALIGNRP   */  PACK( 0, 0 ), /* loops */
     /*  RTDG      */  PACK( 0, 0 ),
     /*  MIAP[0]   */  PACK( 2, 0 ),
     /*  MIAP[1]   */  PACK( 2, 0 ),
 
-    /*  NPushB    */  PACK( 0, 0 ),
-    /*  NPushW    */  PACK( 0, 0 ),
+    /* 0x40 */
+    /*  NPUSHB    */  PACK( 0, 0 ),
+    /*  NPUSHW    */  PACK( 0, 0 ),
     /*  WS        */  PACK( 2, 0 ),
     /*  RS        */  PACK( 1, 1 ),
-    /*  WCvtP     */  PACK( 2, 0 ),
-    /*  RCvt      */  PACK( 1, 1 ),
+    /*  WCVTP     */  PACK( 2, 0 ),
+    /*  RCVT      */  PACK( 1, 1 ),
     /*  GC[0]     */  PACK( 1, 1 ),
     /*  GC[1]     */  PACK( 1, 1 ),
     /*  SCFS      */  PACK( 2, 0 ),
     /*  MD[0]     */  PACK( 2, 1 ),
     /*  MD[1]     */  PACK( 2, 1 ),
     /*  MPPEM     */  PACK( 0, 1 ),
     /*  MPS       */  PACK( 0, 1 ),
-    /*  FlipON    */  PACK( 0, 0 ),
-    /*  FlipOFF   */  PACK( 0, 0 ),
+    /*  FLIPON    */  PACK( 0, 0 ),
+    /*  FLIPOFF   */  PACK( 0, 0 ),
     /*  DEBUG     */  PACK( 1, 0 ),
 
+    /* 0x50 */
     /*  LT        */  PACK( 2, 1 ),
     /*  LTEQ      */  PACK( 2, 1 ),
     /*  GT        */  PACK( 2, 1 ),
     /*  GTEQ      */  PACK( 2, 1 ),
     /*  EQ        */  PACK( 2, 1 ),
@@ -733,14 +756,15 @@
     /*  IF        */  PACK( 1, 0 ),
     /*  EIF       */  PACK( 0, 0 ),
     /*  AND       */  PACK( 2, 1 ),
     /*  OR        */  PACK( 2, 1 ),
     /*  NOT       */  PACK( 1, 1 ),
-    /*  DeltaP1   */  PACK( 1, 0 ),
+    /*  DELTAP1   */  PACK( 1, 0 ),
     /*  SDB       */  PACK( 1, 0 ),
     /*  SDS       */  PACK( 1, 0 ),
 
+    /* 0x60 */
     /*  ADD       */  PACK( 2, 1 ),
     /*  SUB       */  PACK( 2, 1 ),
     /*  DIV       */  PACK( 2, 1 ),
     /*  MUL       */  PACK( 2, 1 ),
     /*  ABS       */  PACK( 1, 1 ),
@@ -754,44 +778,47 @@
     /*  NROUND[0] */  PACK( 1, 1 ),
     /*  NROUND[1] */  PACK( 1, 1 ),
     /*  NROUND[2] */  PACK( 1, 1 ),
     /*  NROUND[3] */  PACK( 1, 1 ),
 
-    /*  WCvtF     */  PACK( 2, 0 ),
-    /*  DeltaP2   */  PACK( 1, 0 ),
-    /*  DeltaP3   */  PACK( 1, 0 ),
-    /*  DeltaCn[0] */ PACK( 1, 0 ),
-    /*  DeltaCn[1] */ PACK( 1, 0 ),
-    /*  DeltaCn[2] */ PACK( 1, 0 ),
+    /* 0x70 */
+    /*  WCVTF     */  PACK( 2, 0 ),
+    /*  DELTAP2   */  PACK( 1, 0 ),
+    /*  DELTAP3   */  PACK( 1, 0 ),
+    /*  DELTAC1   */  PACK( 1, 0 ),
+    /*  DELTAC2   */  PACK( 1, 0 ),
+    /*  DELTAC3   */  PACK( 1, 0 ),
     /*  SROUND    */  PACK( 1, 0 ),
-    /*  S45Round  */  PACK( 1, 0 ),
+    /*  S45ROUND  */  PACK( 1, 0 ),
     /*  JROT      */  PACK( 2, 0 ),
     /*  JROF      */  PACK( 2, 0 ),
     /*  ROFF      */  PACK( 0, 0 ),
     /*  INS_$7B   */  PACK( 0, 0 ),
     /*  RUTG      */  PACK( 0, 0 ),
     /*  RDTG      */  PACK( 0, 0 ),
     /*  SANGW     */  PACK( 1, 0 ),
     /*  AA        */  PACK( 1, 0 ),
 
-    /*  FlipPT    */  PACK( 0, 0 ), /* loops */
-    /*  FlipRgON  */  PACK( 2, 0 ),
-    /*  FlipRgOFF */  PACK( 2, 0 ),
+    /* 0x80 */
+    /*  FLIPPT    */  PACK( 0, 0 ), /* loops */
+    /*  FLIPRGON  */  PACK( 2, 0 ),
+    /*  FLIPRGOFF */  PACK( 2, 0 ),
     /*  INS_$83   */  PACK( 0, 0 ),
     /*  INS_$84   */  PACK( 0, 0 ),
-    /*  ScanCTRL  */  PACK( 1, 0 ),
-    /*  SDPvTL[0] */  PACK( 2, 0 ),
-    /*  SDPvTL[1] */  PACK( 2, 0 ),
-    /*  GetINFO   */  PACK( 1, 1 ),
+    /*  SCANCTRL  */  PACK( 1, 0 ),
+    /*  SDPVTL[0] */  PACK( 2, 0 ),
+    /*  SDPVTL[1] */  PACK( 2, 0 ),
+    /*  GETINFO   */  PACK( 1, 1 ),
     /*  IDEF      */  PACK( 1, 0 ),
     /*  ROLL      */  PACK( 3, 3 ),
     /*  MAX       */  PACK( 2, 1 ),
     /*  MIN       */  PACK( 2, 1 ),
-    /*  ScanTYPE  */  PACK( 1, 0 ),
-    /*  InstCTRL  */  PACK( 2, 0 ),
+    /*  SCANTYPE  */  PACK( 1, 0 ),
+    /*  INSTCTRL  */  PACK( 2, 0 ),
     /*  INS_$8F   */  PACK( 0, 0 ),
 
+    /* 0x90 */
     /*  INS_$90  */   PACK( 0, 0 ),
     /*  GETVAR   */   PACK( 0, 0 ), /* will be handled specially */
     /*  GETDATA  */   PACK( 0, 1 ),
     /*  INS_$93  */   PACK( 0, 0 ),
     /*  INS_$94  */   PACK( 0, 0 ),
@@ -805,10 +832,11 @@
     /*  INS_$9C  */   PACK( 0, 0 ),
     /*  INS_$9D  */   PACK( 0, 0 ),
     /*  INS_$9E  */   PACK( 0, 0 ),
     /*  INS_$9F  */   PACK( 0, 0 ),
 
+    /* 0xA0 */
     /*  INS_$A0  */   PACK( 0, 0 ),
     /*  INS_$A1  */   PACK( 0, 0 ),
     /*  INS_$A2  */   PACK( 0, 0 ),
     /*  INS_$A3  */   PACK( 0, 0 ),
     /*  INS_$A4  */   PACK( 0, 0 ),
@@ -822,27 +850,29 @@
     /*  INS_$AC  */   PACK( 0, 0 ),
     /*  INS_$AD  */   PACK( 0, 0 ),
     /*  INS_$AE  */   PACK( 0, 0 ),
     /*  INS_$AF  */   PACK( 0, 0 ),
 
-    /*  PushB[0]  */  PACK( 0, 1 ),
-    /*  PushB[1]  */  PACK( 0, 2 ),
-    /*  PushB[2]  */  PACK( 0, 3 ),
-    /*  PushB[3]  */  PACK( 0, 4 ),
-    /*  PushB[4]  */  PACK( 0, 5 ),
-    /*  PushB[5]  */  PACK( 0, 6 ),
-    /*  PushB[6]  */  PACK( 0, 7 ),
-    /*  PushB[7]  */  PACK( 0, 8 ),
-    /*  PushW[0]  */  PACK( 0, 1 ),
-    /*  PushW[1]  */  PACK( 0, 2 ),
-    /*  PushW[2]  */  PACK( 0, 3 ),
-    /*  PushW[3]  */  PACK( 0, 4 ),
-    /*  PushW[4]  */  PACK( 0, 5 ),
-    /*  PushW[5]  */  PACK( 0, 6 ),
-    /*  PushW[6]  */  PACK( 0, 7 ),
-    /*  PushW[7]  */  PACK( 0, 8 ),
-
+    /* 0xB0 */
+    /*  PUSHB[0]  */  PACK( 0, 1 ),
+    /*  PUSHB[1]  */  PACK( 0, 2 ),
+    /*  PUSHB[2]  */  PACK( 0, 3 ),
+    /*  PUSHB[3]  */  PACK( 0, 4 ),
+    /*  PUSHB[4]  */  PACK( 0, 5 ),
+    /*  PUSHB[5]  */  PACK( 0, 6 ),
+    /*  PUSHB[6]  */  PACK( 0, 7 ),
+    /*  PUSHB[7]  */  PACK( 0, 8 ),
+    /*  PUSHW[0]  */  PACK( 0, 1 ),
+    /*  PUSHW[1]  */  PACK( 0, 2 ),
+    /*  PUSHW[2]  */  PACK( 0, 3 ),
+    /*  PUSHW[3]  */  PACK( 0, 4 ),
+    /*  PUSHW[4]  */  PACK( 0, 5 ),
+    /*  PUSHW[5]  */  PACK( 0, 6 ),
+    /*  PUSHW[6]  */  PACK( 0, 7 ),
+    /*  PUSHW[7]  */  PACK( 0, 8 ),
+
+    /* 0xC0 */
     /*  MDRP[00]  */  PACK( 1, 0 ),
     /*  MDRP[01]  */  PACK( 1, 0 ),
     /*  MDRP[02]  */  PACK( 1, 0 ),
     /*  MDRP[03]  */  PACK( 1, 0 ),
     /*  MDRP[04]  */  PACK( 1, 0 ),
@@ -856,10 +886,11 @@
     /*  MDRP[12]  */  PACK( 1, 0 ),
     /*  MDRP[13]  */  PACK( 1, 0 ),
     /*  MDRP[14]  */  PACK( 1, 0 ),
     /*  MDRP[15]  */  PACK( 1, 0 ),
 
+    /* 0xD0 */
     /*  MDRP[16]  */  PACK( 1, 0 ),
     /*  MDRP[17]  */  PACK( 1, 0 ),
     /*  MDRP[18]  */  PACK( 1, 0 ),
     /*  MDRP[19]  */  PACK( 1, 0 ),
     /*  MDRP[20]  */  PACK( 1, 0 ),
@@ -873,10 +904,11 @@
     /*  MDRP[28]  */  PACK( 1, 0 ),
     /*  MDRP[29]  */  PACK( 1, 0 ),
     /*  MDRP[30]  */  PACK( 1, 0 ),
     /*  MDRP[31]  */  PACK( 1, 0 ),
 
+    /* 0xE0 */
     /*  MIRP[00]  */  PACK( 2, 0 ),
     /*  MIRP[01]  */  PACK( 2, 0 ),
     /*  MIRP[02]  */  PACK( 2, 0 ),
     /*  MIRP[03]  */  PACK( 2, 0 ),
     /*  MIRP[04]  */  PACK( 2, 0 ),
@@ -890,10 +922,11 @@
     /*  MIRP[12]  */  PACK( 2, 0 ),
     /*  MIRP[13]  */  PACK( 2, 0 ),
     /*  MIRP[14]  */  PACK( 2, 0 ),
     /*  MIRP[15]  */  PACK( 2, 0 ),
 
+    /* 0xF0 */
     /*  MIRP[16]  */  PACK( 2, 0 ),
     /*  MIRP[17]  */  PACK( 2, 0 ),
     /*  MIRP[18]  */  PACK( 2, 0 ),
     /*  MIRP[19]  */  PACK( 2, 0 ),
     /*  MIRP[20]  */  PACK( 2, 0 ),
@@ -918,27 +951,29 @@
   /* code                                                               */
 
   static
   const char*  const opcode_name[256] =
   {
-    "7 SVTCA y",
-    "7 SVTCA x",
-    "8 SPvTCA y",
-    "8 SPvTCA x",
-    "8 SFvTCA y",
-    "8 SFvTCA x",
-    "8 SPvTL ||",
-    "7 SPvTL +",
-    "8 SFvTL ||",
-    "7 SFvTL +",
-    "5 SPvFS",
-    "5 SFvFS",
-    "3 GPv",
-    "3 GFv",
-    "6 SFvTPv",
+    /* 0x00 */
+    "8 SVTCA[y]",
+    "8 SVTCA[x]",
+    "9 SPVTCA[y]",
+    "9 SPVTCA[x]",
+    "9 SFVTCA[y]",
+    "9 SFVTCA[x]",
+    "9 SPVTL[||]",
+    "8 SPVTL[+]",
+    "9 SFVTL[||]",
+    "8 SFVTL[+]",
+    "5 SPVFS",
+    "5 SFVFS",
+    "3 GPV",
+    "3 GFV",
+    "6 SFVTPV",
     "5 ISECT",
 
+    /* 0x10 */
     "4 SRP0",
     "4 SRP1",
     "4 SRP2",
     "4 SZP0",
     "4 SZP1",
@@ -948,65 +983,69 @@
     "3 RTG",
     "4 RTHG",
     "3 SMD",
     "4 ELSE",
     "4 JMPR",
-    "6 SCvTCi",
-    "5 SSwCi",
+    "6 SCVTCI",
+    "5 SSWCI",
     "3 SSW",
 
+    /* 0x20 */
     "3 DUP",
     "3 POP",
     "5 CLEAR",
     "4 SWAP",
     "5 DEPTH",
     "6 CINDEX",
     "6 MINDEX",
-    "8 AlignPTS",
+    "8 ALIGNPTS",
     "7 INS_$28",
     "3 UTP",
     "8 LOOPCALL",
     "4 CALL",
     "4 FDEF",
     "4 ENDF",
-    "7 MDAP[0]",
-    "7 MDAP[1]",
-
-    "6 IUP[0]",
-    "6 IUP[1]",
-    "6 SHP[0]",
-    "6 SHP[1]",
-    "6 SHC[0]",
-    "6 SHC[1]",
-    "6 SHZ[0]",
-    "6 SHZ[1]",
+    "6 MDAP[]",
+    "9 MDAP[rnd]",
+
+    /* 0x30 */
+    "6 IUP[y]",
+    "6 IUP[x]",
+    "8 SHP[rp2]",
+    "8 SHP[rp1]",
+    "8 SHC[rp2]",
+    "8 SHC[rp1]",
+    "8 SHZ[rp2]",
+    "8 SHZ[rp1]",
     "5 SHPIX",
     "2 IP",
-    "8 MSIRP[0]",
-    "8 MSIRP[1]",
-    "7 AlignRP",
+    "7 MSIRP[]",
+    "A MSIRP[rp0]",
+    "7 ALIGNRP",
     "4 RTDG",
-    "7 MIAP[0]",
-    "7 MIAP[1]",
+    "6 MIAP[]",
+    "9 MIAP[rnd]",
 
-    "6 NPushB",
-    "6 NPushW",
+    /* 0x40 */
+    "6 NPUSHB",
+    "6 NPUSHW",
     "2 WS",
     "2 RS",
-    "5 WCvtP",
-    "4 RCvt",
-    "5 GC[0]",
-    "5 GC[1]",
+    "5 WCVTP",
+    "4 RCVT",
+    "8 GC[curr]",
+    "8 GC[orig]",
     "4 SCFS",
-    "5 MD[0]",
-    "5 MD[1]",
+    "8 MD[curr]",
+    "8 MD[orig]",
     "5 MPPEM",
     "3 MPS",
-    "6 FlipON",
-    "7 FlipOFF",
+    "6 FLIPON",
+    "7 FLIPOFF",
     "5 DEBUG",
 
+    /* 0x50 */
     "2 LT",
     "4 LTEQ",
     "2 GT",
     "4 GTEQ",
     "2 EQ",
@@ -1016,68 +1055,72 @@
     "2 IF",
     "3 EIF",
     "3 AND",
     "2 OR",
     "3 NOT",
-    "7 DeltaP1",
+    "7 DELTAP1",
     "3 SDB",
     "3 SDS",
 
+    /* 0x60 */
     "3 ADD",
     "3 SUB",
     "3 DIV",
     "3 MUL",
     "3 ABS",
     "3 NEG",
     "5 FLOOR",
     "7 CEILING",
-    "8 ROUND[0]",
-    "8 ROUND[1]",
-    "8 ROUND[2]",
-    "8 ROUND[3]",
-    "9 NROUND[0]",
-    "9 NROUND[1]",
-    "9 NROUND[2]",
-    "9 NROUND[3]",
-
-    "5 WCvtF",
-    "7 DeltaP2",
-    "7 DeltaP3",
-    "A DeltaCn[0]",
-    "A DeltaCn[1]",
-    "A DeltaCn[2]",
+    "8 ROUND[G]",
+    "8 ROUND[B]",
+    "8 ROUND[W]",
+    "7 ROUND[]",
+    "9 NROUND[G]",
+    "9 NROUND[B]",
+    "9 NROUND[W]",
+    "8 NROUND[]",
+
+    /* 0x70 */
+    "5 WCVTF",
+    "7 DELTAP2",
+    "7 DELTAP3",
+    "7 DELTAC1",
+    "7 DELTAC2",
+    "7 DELTAC3",
     "6 SROUND",
-    "8 S45Round",
+    "8 S45ROUND",
     "4 JROT",
     "4 JROF",
     "4 ROFF",
     "7 INS_$7B",
     "4 RUTG",
     "4 RDTG",
     "5 SANGW",
     "2 AA",
 
-    "6 FlipPT",
-    "8 FlipRgON",
-    "9 FlipRgOFF",
+    /* 0x80 */
+    "6 FLIPPT",
+    "8 FLIPRGON",
+    "9 FLIPRGOFF",
     "7 INS_$83",
     "7 INS_$84",
-    "8 ScanCTRL",
-    "9 SDPvTL[0]",
-    "9 SDPvTL[1]",
-    "7 GetINFO",
+    "8 SCANCTRL",
+    "A SDPVTL[||]",
+    "9 SDPVTL[+]",
+    "7 GETINFO",
     "4 IDEF",
     "4 ROLL",
     "3 MAX",
     "3 MIN",
-    "8 ScanTYPE",
-    "8 InstCTRL",
+    "8 SCANTYPE",
+    "8 INSTCTRL",
     "7 INS_$8F",
 
+    /* 0x90 */
     "7 INS_$90",
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
-    "6 GETVAR",
+    "C GETVARIATION",
     "7 GETDATA",
 #else
     "7 INS_$91",
     "7 INS_$92",
 #endif
@@ -1093,10 +1136,11 @@
     "7 INS_$9C",
     "7 INS_$9D",
     "7 INS_$9E",
     "7 INS_$9F",
 
+    /* 0xA0 */
     "7 INS_$A0",
     "7 INS_$A1",
     "7 INS_$A2",
     "7 INS_$A3",
     "7 INS_$A4",
@@ -1110,94 +1154,99 @@
     "7 INS_$AC",
     "7 INS_$AD",
     "7 INS_$AE",
     "7 INS_$AF",
 
-    "8 PushB[0]",
-    "8 PushB[1]",
-    "8 PushB[2]",
-    "8 PushB[3]",
-    "8 PushB[4]",
-    "8 PushB[5]",
-    "8 PushB[6]",
-    "8 PushB[7]",
-    "8 PushW[0]",
-    "8 PushW[1]",
-    "8 PushW[2]",
-    "8 PushW[3]",
-    "8 PushW[4]",
-    "8 PushW[5]",
-    "8 PushW[6]",
-    "8 PushW[7]",
-
-    "8 MDRP[00]",
-    "8 MDRP[01]",
-    "8 MDRP[02]",
-    "8 MDRP[03]",
-    "8 MDRP[04]",
-    "8 MDRP[05]",
-    "8 MDRP[06]",
-    "8 MDRP[07]",
-    "8 MDRP[08]",
-    "8 MDRP[09]",
-    "8 MDRP[10]",
-    "8 MDRP[11]",
-    "8 MDRP[12]",
-    "8 MDRP[13]",
-    "8 MDRP[14]",
-    "8 MDRP[15]",
-
-    "8 MDRP[16]",
-    "8 MDRP[17]",
-    "8 MDRP[18]",
-    "8 MDRP[19]",
-    "8 MDRP[20]",
-    "8 MDRP[21]",
-    "8 MDRP[22]",
-    "8 MDRP[23]",
-    "8 MDRP[24]",
-    "8 MDRP[25]",
-    "8 MDRP[26]",
-    "8 MDRP[27]",
-    "8 MDRP[28]",
-    "8 MDRP[29]",
-    "8 MDRP[30]",
-    "8 MDRP[31]",
-
-    "8 MIRP[00]",
-    "8 MIRP[01]",
-    "8 MIRP[02]",
-    "8 MIRP[03]",
-    "8 MIRP[04]",
-    "8 MIRP[05]",
-    "8 MIRP[06]",
-    "8 MIRP[07]",
-    "8 MIRP[08]",
-    "8 MIRP[09]",
-    "8 MIRP[10]",
-    "8 MIRP[11]",
-    "8 MIRP[12]",
-    "8 MIRP[13]",
-    "8 MIRP[14]",
-    "8 MIRP[15]",
-
-    "8 MIRP[16]",
-    "8 MIRP[17]",
-    "8 MIRP[18]",
-    "8 MIRP[19]",
-    "8 MIRP[20]",
-    "8 MIRP[21]",
-    "8 MIRP[22]",
-    "8 MIRP[23]",
-    "8 MIRP[24]",
-    "8 MIRP[25]",
-    "8 MIRP[26]",
-    "8 MIRP[27]",
-    "8 MIRP[28]",
-    "8 MIRP[29]",
-    "8 MIRP[30]",
-    "8 MIRP[31]"
+    /* 0xB0 */
+    "8 PUSHB[0]",
+    "8 PUSHB[1]",
+    "8 PUSHB[2]",
+    "8 PUSHB[3]",
+    "8 PUSHB[4]",
+    "8 PUSHB[5]",
+    "8 PUSHB[6]",
+    "8 PUSHB[7]",
+    "8 PUSHW[0]",
+    "8 PUSHW[1]",
+    "8 PUSHW[2]",
+    "8 PUSHW[3]",
+    "8 PUSHW[4]",
+    "8 PUSHW[5]",
+    "8 PUSHW[6]",
+    "8 PUSHW[7]",
+
+    /* 0xC0 */
+    "7 MDRP[G]",
+    "7 MDRP[B]",
+    "7 MDRP[W]",
+    "6 MDRP[]",
+    "8 MDRP[rG]",
+    "8 MDRP[rB]",
+    "8 MDRP[rW]",
+    "7 MDRP[r]",
+    "8 MDRP[mG]",
+    "8 MDRP[mB]",
+    "8 MDRP[mW]",
+    "7 MDRP[m]",
+    "9 MDRP[mrG]",
+    "9 MDRP[mrB]",
+    "9 MDRP[mrW]",
+    "8 MDRP[mr]",
+
+    /* 0xD0 */
+    "8 MDRP[pG]",
+    "8 MDRP[pB]",
+    "8 MDRP[pW]",
+    "7 MDRP[p]",
+    "9 MDRP[prG]",
+    "9 MDRP[prB]",
+    "9 MDRP[prW]",
+    "8 MDRP[pr]",
+    "9 MDRP[pmG]",
+    "9 MDRP[pmB]",
+    "9 MDRP[pmW]",
+    "8 MDRP[pm]",
+    "A MDRP[pmrG]",
+    "A MDRP[pmrB]",
+    "A MDRP[pmrW]",
+    "9 MDRP[pmr]",
+
+    /* 0xE0 */
+    "7 MIRP[G]",
+    "7 MIRP[B]",
+    "7 MIRP[W]",
+    "6 MIRP[]",
+    "8 MIRP[rG]",
+    "8 MIRP[rB]",
+    "8 MIRP[rW]",
+    "7 MIRP[r]",
+    "8 MIRP[mG]",
+    "8 MIRP[mB]",
+    "8 MIRP[mW]",
+    "7 MIRP[m]",
+    "9 MIRP[mrG]",
+    "9 MIRP[mrB]",
+    "9 MIRP[mrW]",
+    "8 MIRP[mr]",
+
+    /* 0xF0 */
+    "8 MIRP[pG]",
+    "8 MIRP[pB]",
+    "8 MIRP[pW]",
+    "7 MIRP[p]",
+    "9 MIRP[prG]",
+    "9 MIRP[prB]",
+    "9 MIRP[prW]",
+    "8 MIRP[pr]",
+    "9 MIRP[pmG]",
+    "9 MIRP[pmB]",
+    "9 MIRP[pmW]",
+    "8 MIRP[pm]",
+    "A MIRP[pmrG]",
+    "A MIRP[pmrB]",
+    "A MIRP[pmrW]",
+    "9 MIRP[pmr]"
   };
 
 #endif /* FT_DEBUG_LEVEL_TRACE */
 
 
@@ -1446,22 +1495,22 @@
   }
 
 #endif /* TT_DotFix14 */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Current_Ratio                                                      */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Returns the current aspect ratio scaling factor depending on the   */
-  /*    projection vector's state and device resolutions.                  */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Current_Ratio
+   *
+   * @Description:
+   *   Returns the current aspect ratio scaling factor depending on the
+   *   projection vector's state and device resolutions.
+   *
+   * @Return:
+   *   The aspect ratio in 16.16 format, always <= 1.0 .
+   */
   static FT_Long
   Current_Ratio( TT_ExecContext  exc )
   {
     if ( !exc->tt_metrics.ratio )
     {
@@ -1499,15 +1548,15 @@
   {
     return FT_MulFix( exc->tt_metrics.ppem, Current_Ratio( exc ) );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Functions related to the control value table (CVT).                   */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * Functions related to the control value table (CVT).
+   *
+   */
 
 
   FT_CALLBACK_DEF( FT_F26Dot6 )
   Read_CVT( TT_ExecContext  exc,
             FT_ULong        idx )
@@ -1545,64 +1594,67 @@
   FT_CALLBACK_DEF( void )
   Move_CVT( TT_ExecContext  exc,
             FT_ULong        idx,
             FT_F26Dot6      value )
   {
-    exc->cvt[idx] += value;
+    exc->cvt[idx] = ADD_LONG( exc->cvt[idx], value );
   }
 
 
   FT_CALLBACK_DEF( void )
   Move_CVT_Stretched( TT_ExecContext  exc,
                       FT_ULong        idx,
                       FT_F26Dot6      value )
   {
-    exc->cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );
-  }
-
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    GetShortIns                                                        */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Returns a short integer taken from the instruction stream at       */
-  /*    address IP.                                                        */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Short read at code[IP].                                            */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    This one could become a macro.                                     */
-  /*                                                                       */
+    exc->cvt[idx] = ADD_LONG( exc->cvt[idx],
+                              FT_DivFix( value, Current_Ratio( exc ) ) );
+  }
+
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   GetShortIns
+   *
+   * @Description:
+   *   Returns a short integer taken from the instruction stream at
+   *   address IP.
+   *
+   * @Return:
+   *   Short read at code[IP].
+   *
+   * @Note:
+   *   This one could become a macro.
+   */
   static FT_Short
   GetShortIns( TT_ExecContext  exc )
   {
     /* Reading a byte stream so there is no endianness (DaveP) */
     exc->IP += 2;
     return (FT_Short)( ( exc->code[exc->IP - 2] << 8 ) +
                          exc->code[exc->IP - 1]      );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Ins_Goto_CodeRange                                                 */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Goes to a certain code range in the instruction stream.            */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    aRange :: The index of the code range.                             */
-  /*                                                                       */
-  /*    aIP    :: The new IP address in the code range.                    */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    SUCCESS or FAILURE.                                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Ins_Goto_CodeRange
+   *
+   * @Description:
+   *   Goes to a certain code range in the instruction stream.
+   *
+   * @Input:
+   *   aRange ::
+   *     The index of the code range.
+   *
+   *   aIP ::
+   *     The new IP address in the code range.
+   *
+   * @Return:
+   *   SUCCESS or FAILURE.
+   */
   static FT_Bool
   Ins_Goto_CodeRange( TT_ExecContext  exc,
                       FT_Int          aRange,
                       FT_Long         aIP )
   {
@@ -1640,31 +1692,60 @@
 
     return SUCCESS;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Direct_Move                                                        */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Moves a point by a given distance along the freedom vector.  The   */
-  /*    point will be `touched'.                                           */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    point    :: The index of the point to move.                        */
-  /*                                                                       */
-  /*    distance :: The distance to apply.                                 */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    zone     :: The affected glyph zone.                               */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    See `ttinterp.h' for details on backward compatibility mode.       */
-  /*    `Touches' the point.                                               */
-  /*                                                                       */
+  /*
+   *
+   * Apple's TrueType specification at
+   *
+   *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM02/Chap2.html#order
+   *
+   * gives the following order of operations in instructions that move
+   * points.
+   *
+   *   - check single width cut-in (MIRP, MDRP)
+   *
+   *   - check control value cut-in (MIRP, MIAP)
+   *
+   *   - apply engine compensation (MIRP, MDRP)
+   *
+   *   - round distance (MIRP, MDRP) or value (MIAP, MDAP)
+   *
+   *   - check minimum distance (MIRP,MDRP)
+   *
+   *   - move point (MIRP, MDRP, MIAP, MSIRP, MDAP)
+   *
+   * For rounding instructions, engine compensation happens before rounding.
+   *
+   */
+
+
+  /**************************************************************************
+   *
+   * @Function:
+   *   Direct_Move
+   *
+   * @Description:
+   *   Moves a point by a given distance along the freedom vector.  The
+   *   point will be `touched'.
+   *
+   * @Input:
+   *   point ::
+   *     The index of the point to move.
+   *
+   *   distance ::
+   *     The distance to apply.
+   *
+   * @InOut:
+   *   zone ::
+   *     The affected glyph zone.
+   *
+   * @Note:
+   *   See `ttinterp.h' for details on backward compatibility mode.
+   *   `Touches' the point.
+   */
   static void
   Direct_Move( TT_ExecContext  exc,
                TT_GlyphZone    zone,
                FT_UShort       point,
                FT_F26Dot6      distance )
@@ -1726,27 +1807,30 @@
       zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Direct_Move_Orig                                                   */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Moves the *original* position of a point by a given distance along */
-  /*    the freedom vector.  Obviously, the point will not be `touched'.   */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    point    :: The index of the point to move.                        */
-  /*                                                                       */
-  /*    distance :: The distance to apply.                                 */
-  /*                                                                       */
-  /* <InOut>                                                               */
-  /*    zone     :: The affected glyph zone.                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Direct_Move_Orig
+   *
+   * @Description:
+   *   Moves the *original* position of a point by a given distance along
+   *   the freedom vector.  Obviously, the point will not be `touched'.
+   *
+   * @Input:
+   *   point ::
+   *     The index of the point to move.
+   *
+   *   distance ::
+   *     The distance to apply.
+   *
+   * @InOut:
+   *   zone ::
+   *     The affected glyph zone.
+   */
   static void
   Direct_Move_Orig( TT_ExecContext  exc,
                     TT_GlyphZone    zone,
                     FT_UShort       point,
                     FT_F26Dot6      distance )
@@ -1770,19 +1854,19 @@
                                                 v,
                                                 exc->F_dot_P ) );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Special versions of Direct_Move()                                     */
-  /*                                                                       */
-  /*   The following versions are used whenever both vectors are both      */
-  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
-  /*   See `ttinterp.h' for details on backward compatibility mode.        */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * Special versions of Direct_Move()
+   *
+   *   The following versions are used whenever both vectors are both
+   *   along one of the coordinate unit vectors, i.e. in 90% of the cases.
+   *   See `ttinterp.h' for details on backward compatibility mode.
+   *
+   */
 
 
   static void
   Direct_Move_X( TT_ExecContext  exc,
                  TT_GlyphZone    zone,
@@ -1825,18 +1909,18 @@
 
     zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Special versions of Direct_Move_Orig()                                */
-  /*                                                                       */
-  /*   The following versions are used whenever both vectors are both      */
-  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * Special versions of Direct_Move_Orig()
+   *
+   *   The following versions are used whenever both vectors are both
+   *   along one of the coordinate unit vectors, i.e. in 90% of the cases.
+   *
+   */
 
 
   static void
   Direct_Move_Orig_X( TT_ExecContext  exc,
                       TT_GlyphZone    zone,
@@ -1858,33 +1942,28 @@
     FT_UNUSED( exc );
 
     zone->org[point].y = ADD_LONG( zone->org[point].y, distance );
   }
 
-
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_None                                                         */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Does not round, but adds engine compensation.                      */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance (not) to round.                       */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The compensated distance.                                          */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    The TrueType specification says very few about the relationship    */
-  /*    between rounding and engine compensation.  However, it seems from  */
-  /*    the description of super round that we should add the compensation */
-  /*    before rounding.                                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_None
+   *
+   * @Description:
+   *   Does not round, but adds engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance (not) to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   The compensated distance.
+   */
   static FT_F26Dot6
   Round_None( TT_ExecContext  exc,
               FT_F26Dot6      distance,
               FT_F26Dot6      compensation )
   {
@@ -1907,26 +1986,28 @@
     }
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_To_Grid                                                      */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Rounds value to grid after adding engine compensation.             */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_To_Grid
+   *
+   * @Description:
+   *   Rounds value to grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   */
   static FT_F26Dot6
   Round_To_Grid( TT_ExecContext  exc,
                  FT_F26Dot6      distance,
                  FT_F26Dot6      compensation )
   {
@@ -1951,26 +2032,28 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_To_Half_Grid                                                 */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Rounds value to half grid after adding engine compensation.        */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_To_Half_Grid
+   *
+   * @Description:
+   *   Rounds value to half grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   */
   static FT_F26Dot6
   Round_To_Half_Grid( TT_ExecContext  exc,
                       FT_F26Dot6      distance,
                       FT_F26Dot6      compensation )
   {
@@ -1997,26 +2080,28 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_Down_To_Grid                                                 */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Rounds value down to grid after adding engine compensation.        */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_Down_To_Grid
+   *
+   * @Description:
+   *   Rounds value down to grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   */
   static FT_F26Dot6
   Round_Down_To_Grid( TT_ExecContext  exc,
                       FT_F26Dot6      distance,
                       FT_F26Dot6      compensation )
   {
@@ -2040,26 +2125,28 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_Up_To_Grid                                                   */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Rounds value up to grid after adding engine compensation.          */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_Up_To_Grid
+   *
+   * @Description:
+   *   Rounds value up to grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   */
   static FT_F26Dot6
   Round_Up_To_Grid( TT_ExecContext  exc,
                     FT_F26Dot6      distance,
                     FT_F26Dot6      compensation )
   {
@@ -2084,26 +2171,28 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_To_Double_Grid                                               */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Rounds value to double grid after adding engine compensation.      */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_To_Double_Grid
+   *
+   * @Description:
+   *   Rounds value to double grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   */
   static FT_F26Dot6
   Round_To_Double_Grid( TT_ExecContext  exc,
                         FT_F26Dot6      distance,
                         FT_F26Dot6      compensation )
   {
@@ -2128,32 +2217,34 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_Super                                                        */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Super-rounds value to grid after adding engine compensation.       */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    The TrueType specification says very little about the relationship */
-  /*    between rounding and engine compensation.  However, it seems from  */
-  /*    the description of super round that we should add the compensation */
-  /*    before rounding.                                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_Super
+   *
+   * @Description:
+   *   Super-rounds value to grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   *
+   * @Note:
+   *   The TrueType specification says very little about the relationship
+   *   between rounding and engine compensation.  However, it seems from
+   *   the description of super round that we should add the compensation
+   *   before rounding.
+   */
   static FT_F26Dot6
   Round_Super( TT_ExecContext  exc,
                FT_F26Dot6      distance,
                FT_F26Dot6      compensation )
   {
@@ -2181,30 +2272,32 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Round_Super_45                                                     */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Super-rounds value to grid after adding engine compensation.       */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    distance     :: The distance to round.                             */
-  /*                                                                       */
-  /*    compensation :: The engine compensation.                           */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Rounded distance.                                                  */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    There is a separate function for Round_Super_45() as we may need   */
-  /*    greater precision.                                                 */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Round_Super_45
+   *
+   * @Description:
+   *   Super-rounds value to grid after adding engine compensation.
+   *
+   * @Input:
+   *   distance ::
+   *     The distance to round.
+   *
+   *   compensation ::
+   *     The engine compensation.
+   *
+   * @Return:
+   *   Rounded distance.
+   *
+   * @Note:
+   *   There is a separate function for Round_Super_45() as we may need
+   *   greater precision.
+   */
   static FT_F26Dot6
   Round_Super_45( TT_ExecContext  exc,
                   FT_F26Dot6      distance,
                   FT_F26Dot6      compensation )
   {
@@ -2232,21 +2325,22 @@
 
     return val;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Compute_Round                                                      */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Sets the rounding mode.                                            */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    round_mode :: The rounding mode to be used.                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Compute_Round
+   *
+   * @Description:
+   *   Sets the rounding mode.
+   *
+   * @Input:
+   *   round_mode ::
+   *     The rounding mode to be used.
+   */
   static void
   Compute_Round( TT_ExecContext  exc,
                  FT_Byte         round_mode )
   {
     switch ( round_mode )
@@ -2284,23 +2378,25 @@
       break;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    SetSuperRound                                                      */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Sets Super Round parameters.                                       */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    GridPeriod :: The grid period.                                     */
-  /*                                                                       */
-  /*    selector   :: The SROUND opcode.                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   SetSuperRound
+   *
+   * @Description:
+   *   Sets Super Round parameters.
+   *
+   * @Input:
+   *   GridPeriod ::
+   *     The grid period.
+   *
+   *   selector ::
+   *     The SROUND opcode.
+   */
   static void
   SetSuperRound( TT_ExecContext  exc,
                  FT_F2Dot14      GridPeriod,
                  FT_Long         selector )
   {
@@ -2353,26 +2449,28 @@
     exc->phase     >>= 8;
     exc->threshold >>= 8;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Project                                                            */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Computes the projection of vector given by (v2-v1) along the       */
-  /*    current projection vector.                                         */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    v1 :: First input vector.                                          */
-  /*    v2 :: Second input vector.                                         */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The distance in F26dot6 format.                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Project
+   *
+   * @Description:
+   *   Computes the projection of vector given by (v2-v1) along the
+   *   current projection vector.
+   *
+   * @Input:
+   *   v1 ::
+   *     First input vector.
+   *   v2 ::
+   *     Second input vector.
+   *
+   * @Return:
+   *   The distance in F26dot6 format.
+   */
   static FT_F26Dot6
   Project( TT_ExecContext  exc,
            FT_Pos          dx,
            FT_Pos          dy )
   {
@@ -2380,26 +2478,28 @@
                         exc->GS.projVector.x,
                         exc->GS.projVector.y );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Dual_Project                                                       */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Computes the projection of the vector given by (v2-v1) along the   */
-  /*    current dual vector.                                               */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    v1 :: First input vector.                                          */
-  /*    v2 :: Second input vector.                                         */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The distance in F26dot6 format.                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Dual_Project
+   *
+   * @Description:
+   *   Computes the projection of the vector given by (v2-v1) along the
+   *   current dual vector.
+   *
+   * @Input:
+   *   v1 ::
+   *     First input vector.
+   *   v2 ::
+   *     Second input vector.
+   *
+   * @Return:
+   *   The distance in F26dot6 format.
+   */
   static FT_F26Dot6
   Dual_Project( TT_ExecContext  exc,
                 FT_Pos          dx,
                 FT_Pos          dy )
   {
@@ -2407,26 +2507,28 @@
                         exc->GS.dualVector.x,
                         exc->GS.dualVector.y );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Project_x                                                          */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Computes the projection of the vector given by (v2-v1) along the   */
-  /*    horizontal axis.                                                   */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    v1 :: First input vector.                                          */
-  /*    v2 :: Second input vector.                                         */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The distance in F26dot6 format.                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Project_x
+   *
+   * @Description:
+   *   Computes the projection of the vector given by (v2-v1) along the
+   *   horizontal axis.
+   *
+   * @Input:
+   *   v1 ::
+   *     First input vector.
+   *   v2 ::
+   *     Second input vector.
+   *
+   * @Return:
+   *   The distance in F26dot6 format.
+   */
   static FT_F26Dot6
   Project_x( TT_ExecContext  exc,
              FT_Pos          dx,
              FT_Pos          dy )
   {
@@ -2435,26 +2537,28 @@
 
     return dx;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Project_y                                                          */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Computes the projection of the vector given by (v2-v1) along the   */
-  /*    vertical axis.                                                     */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    v1 :: First input vector.                                          */
-  /*    v2 :: Second input vector.                                         */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    The distance in F26dot6 format.                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Project_y
+   *
+   * @Description:
+   *   Computes the projection of the vector given by (v2-v1) along the
+   *   vertical axis.
+   *
+   * @Input:
+   *   v1 ::
+   *     First input vector.
+   *   v2 ::
+   *     Second input vector.
+   *
+   * @Return:
+   *   The distance in F26dot6 format.
+   */
   static FT_F26Dot6
   Project_y( TT_ExecContext  exc,
              FT_Pos          dx,
              FT_Pos          dy )
   {
@@ -2463,19 +2567,19 @@
 
     return dy;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Compute_Funcs                                                      */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Computes the projection and movement function pointers according   */
-  /*    to the current graphics state.                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Compute_Funcs
+   *
+   * @Description:
+   *   Computes the projection and movement function pointers according
+   *   to the current graphics state.
+   */
   static void
   Compute_Funcs( TT_ExecContext  exc )
   {
     if ( exc->GS.freeVector.x == 0x4000 )
       exc->F_dot_P = exc->GS.projVector.x;
@@ -2526,32 +2630,35 @@
     /* Disable cached aspect ratio */
     exc->tt_metrics.ratio = 0;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* <Function>                                                            */
-  /*    Normalize                                                          */
-  /*                                                                       */
-  /* <Description>                                                         */
-  /*    Norms a vector.                                                    */
-  /*                                                                       */
-  /* <Input>                                                               */
-  /*    Vx :: The horizontal input vector coordinate.                      */
-  /*    Vy :: The vertical input vector coordinate.                        */
-  /*                                                                       */
-  /* <Output>                                                              */
-  /*    R  :: The normed unit vector.                                      */
-  /*                                                                       */
-  /* <Return>                                                              */
-  /*    Returns FAILURE if a vector parameter is zero.                     */
-  /*                                                                       */
-  /* <Note>                                                                */
-  /*    In case Vx and Vy are both zero, `Normalize' returns SUCCESS, and  */
-  /*    R is undefined.                                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * @Function:
+   *   Normalize
+   *
+   * @Description:
+   *   Norms a vector.
+   *
+   * @Input:
+   *   Vx ::
+   *     The horizontal input vector coordinate.
+   *   Vy ::
+   *     The vertical input vector coordinate.
+   *
+   * @Output:
+   *   R ::
+   *     The normed unit vector.
+   *
+   * @Return:
+   *   Returns FAILURE if a vector parameter is zero.
+   *
+   * @Note:
+   *   In case Vx and Vy are both zero, `Normalize' returns SUCCESS, and
+   *   R is undefined.
+   */
   static FT_Bool
   Normalize( FT_F26Dot6      Vx,
              FT_F26Dot6      Vy,
              FT_UnitVector*  R )
   {
@@ -2575,45 +2682,45 @@
 
     return SUCCESS;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* Here we start with the implementation of the various opcodes.         */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * Here we start with the implementation of the various opcodes.
+   *
+   */
 
 
 #define ARRAY_BOUND_ERROR                         \
     do                                            \
     {                                             \
       exc->error = FT_THROW( Invalid_Reference ); \
       return;                                     \
     } while (0)
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MPPEM[]:      Measure Pixel Per EM                                    */
-  /* Opcode range: 0x4B                                                    */
-  /* Stack:        --> Euint16                                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MPPEM[]:      Measure Pixel Per EM
+   * Opcode range: 0x4B
+   * Stack:        --> Euint16
+   */
   static void
   Ins_MPPEM( TT_ExecContext  exc,
              FT_Long*        args )
   {
     args[0] = exc->func_cur_ppem( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MPS[]:        Measure Point Size                                      */
-  /* Opcode range: 0x4C                                                    */
-  /* Stack:        --> Euint16                                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MPS[]:        Measure Point Size
+   * Opcode range: 0x4C
+   * Stack:        --> Euint16
+   */
   static void
   Ins_MPS( TT_ExecContext  exc,
            FT_Long*        args )
   {
     if ( NO_SUBPIXEL_HINTING )
@@ -2631,55 +2738,55 @@
       args[0] = exc->pointSize;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DUP[]:        DUPlicate the stack's top element                       */
-  /* Opcode range: 0x20                                                    */
-  /* Stack:        StkElt --> StkElt StkElt                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DUP[]:        DUPlicate the stack's top element
+   * Opcode range: 0x20
+   * Stack:        StkElt --> StkElt StkElt
+   */
   static void
   Ins_DUP( FT_Long*  args )
   {
     args[1] = args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* POP[]:        POP the stack's top element                             */
-  /* Opcode range: 0x21                                                    */
-  /* Stack:        StkElt -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * POP[]:        POP the stack's top element
+   * Opcode range: 0x21
+   * Stack:        StkElt -->
+   */
   static void
   Ins_POP( void )
   {
     /* nothing to do */
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* CLEAR[]:      CLEAR the entire stack                                  */
-  /* Opcode range: 0x22                                                    */
-  /* Stack:        StkElt... -->                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * CLEAR[]:      CLEAR the entire stack
+   * Opcode range: 0x22
+   * Stack:        StkElt... -->
+   */
   static void
   Ins_CLEAR( TT_ExecContext  exc )
   {
     exc->new_top = 0;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SWAP[]:       SWAP the stack's top two elements                       */
-  /* Opcode range: 0x23                                                    */
-  /* Stack:        2 * StkElt --> 2 * StkElt                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SWAP[]:       SWAP the stack's top two elements
+   * Opcode range: 0x23
+   * Stack:        2 * StkElt --> 2 * StkElt
+   */
   static void
   Ins_SWAP( FT_Long*  args )
   {
     FT_Long  L;
 
@@ -2688,201 +2795,201 @@
     args[0] = args[1];
     args[1] = L;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DEPTH[]:      return the stack DEPTH                                  */
-  /* Opcode range: 0x24                                                    */
-  /* Stack:        --> uint32                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DEPTH[]:      return the stack DEPTH
+   * Opcode range: 0x24
+   * Stack:        --> uint32
+   */
   static void
   Ins_DEPTH( TT_ExecContext  exc,
              FT_Long*        args )
   {
     args[0] = exc->top;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* LT[]:         Less Than                                               */
-  /* Opcode range: 0x50                                                    */
-  /* Stack:        int32? int32? --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * LT[]:         Less Than
+   * Opcode range: 0x50
+   * Stack:        int32? int32? --> bool
+   */
   static void
   Ins_LT( FT_Long*  args )
   {
     args[0] = ( args[0] < args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* LTEQ[]:       Less Than or EQual                                      */
-  /* Opcode range: 0x51                                                    */
-  /* Stack:        int32? int32? --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * LTEQ[]:       Less Than or EQual
+   * Opcode range: 0x51
+   * Stack:        int32? int32? --> bool
+   */
   static void
   Ins_LTEQ( FT_Long*  args )
   {
     args[0] = ( args[0] <= args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GT[]:         Greater Than                                            */
-  /* Opcode range: 0x52                                                    */
-  /* Stack:        int32? int32? --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GT[]:         Greater Than
+   * Opcode range: 0x52
+   * Stack:        int32? int32? --> bool
+   */
   static void
   Ins_GT( FT_Long*  args )
   {
     args[0] = ( args[0] > args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GTEQ[]:       Greater Than or EQual                                   */
-  /* Opcode range: 0x53                                                    */
-  /* Stack:        int32? int32? --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GTEQ[]:       Greater Than or EQual
+   * Opcode range: 0x53
+   * Stack:        int32? int32? --> bool
+   */
   static void
   Ins_GTEQ( FT_Long*  args )
   {
     args[0] = ( args[0] >= args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* EQ[]:         EQual                                                   */
-  /* Opcode range: 0x54                                                    */
-  /* Stack:        StkElt StkElt --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * EQ[]:         EQual
+   * Opcode range: 0x54
+   * Stack:        StkElt StkElt --> bool
+   */
   static void
   Ins_EQ( FT_Long*  args )
   {
     args[0] = ( args[0] == args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NEQ[]:        Not EQual                                               */
-  /* Opcode range: 0x55                                                    */
-  /* Stack:        StkElt StkElt --> bool                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NEQ[]:        Not EQual
+   * Opcode range: 0x55
+   * Stack:        StkElt StkElt --> bool
+   */
   static void
   Ins_NEQ( FT_Long*  args )
   {
     args[0] = ( args[0] != args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ODD[]:        Is ODD                                                  */
-  /* Opcode range: 0x56                                                    */
-  /* Stack:        f26.6 --> bool                                          */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ODD[]:        Is ODD
+   * Opcode range: 0x56
+   * Stack:        f26.6 --> bool
+   */
   static void
   Ins_ODD( TT_ExecContext  exc,
            FT_Long*        args )
   {
     args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 64 );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* EVEN[]:       Is EVEN                                                 */
-  /* Opcode range: 0x57                                                    */
-  /* Stack:        f26.6 --> bool                                          */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * EVEN[]:       Is EVEN
+   * Opcode range: 0x57
+   * Stack:        f26.6 --> bool
+   */
   static void
   Ins_EVEN( TT_ExecContext  exc,
             FT_Long*        args )
   {
     args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 0 );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* AND[]:        logical AND                                             */
-  /* Opcode range: 0x5A                                                    */
-  /* Stack:        uint32 uint32 --> uint32                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * AND[]:        logical AND
+   * Opcode range: 0x5A
+   * Stack:        uint32 uint32 --> uint32
+   */
   static void
   Ins_AND( FT_Long*  args )
   {
     args[0] = ( args[0] && args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* OR[]:         logical OR                                              */
-  /* Opcode range: 0x5B                                                    */
-  /* Stack:        uint32 uint32 --> uint32                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * OR[]:         logical OR
+   * Opcode range: 0x5B
+   * Stack:        uint32 uint32 --> uint32
+   */
   static void
   Ins_OR( FT_Long*  args )
   {
     args[0] = ( args[0] || args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NOT[]:        logical NOT                                             */
-  /* Opcode range: 0x5C                                                    */
-  /* Stack:        StkElt --> uint32                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NOT[]:        logical NOT
+   * Opcode range: 0x5C
+   * Stack:        StkElt --> uint32
+   */
   static void
   Ins_NOT( FT_Long*  args )
   {
     args[0] = !args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ADD[]:        ADD                                                     */
-  /* Opcode range: 0x60                                                    */
-  /* Stack:        f26.6 f26.6 --> f26.6                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ADD[]:        ADD
+   * Opcode range: 0x60
+   * Stack:        f26.6 f26.6 --> f26.6
+   */
   static void
   Ins_ADD( FT_Long*  args )
   {
     args[0] = ADD_LONG( args[0], args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SUB[]:        SUBtract                                                */
-  /* Opcode range: 0x61                                                    */
-  /* Stack:        f26.6 f26.6 --> f26.6                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SUB[]:        SUBtract
+   * Opcode range: 0x61
+   * Stack:        f26.6 f26.6 --> f26.6
+   */
   static void
   Ins_SUB( FT_Long*  args )
   {
     args[0] = SUB_LONG( args[0], args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DIV[]:        DIVide                                                  */
-  /* Opcode range: 0x62                                                    */
-  /* Stack:        f26.6 f26.6 --> f26.6                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DIV[]:        DIVide
+   * Opcode range: 0x62
+   * Stack:        f26.6 f26.6 --> f26.6
+   */
   static void
   Ins_DIV( TT_ExecContext  exc,
            FT_Long*        args )
   {
     if ( args[1] == 0 )
@@ -2890,82 +2997,82 @@
     else
       args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MUL[]:        MULtiply                                                */
-  /* Opcode range: 0x63                                                    */
-  /* Stack:        f26.6 f26.6 --> f26.6                                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MUL[]:        MULtiply
+   * Opcode range: 0x63
+   * Stack:        f26.6 f26.6 --> f26.6
+   */
   static void
   Ins_MUL( FT_Long*  args )
   {
     args[0] = FT_MulDiv( args[0], args[1], 64L );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ABS[]:        ABSolute value                                          */
-  /* Opcode range: 0x64                                                    */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ABS[]:        ABSolute value
+   * Opcode range: 0x64
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_ABS( FT_Long*  args )
   {
     if ( args[0] < 0 )
       args[0] = NEG_LONG( args[0] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NEG[]:        NEGate                                                  */
-  /* Opcode range: 0x65                                                    */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NEG[]:        NEGate
+   * Opcode range: 0x65
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_NEG( FT_Long*  args )
   {
     args[0] = NEG_LONG( args[0] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLOOR[]:      FLOOR                                                   */
-  /* Opcode range: 0x66                                                    */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLOOR[]:      FLOOR
+   * Opcode range: 0x66
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_FLOOR( FT_Long*  args )
   {
     args[0] = FT_PIX_FLOOR( args[0] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* CEILING[]:    CEILING                                                 */
-  /* Opcode range: 0x67                                                    */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * CEILING[]:    CEILING
+   * Opcode range: 0x67
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_CEILING( FT_Long*  args )
   {
     args[0] = FT_PIX_CEIL_LONG( args[0] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RS[]:         Read Store                                              */
-  /* Opcode range: 0x43                                                    */
-  /* Stack:        uint32 --> uint32                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * RS[]:         Read Store
+   * Opcode range: 0x43
+   * Stack:        uint32 --> uint32
+   */
   static void
   Ins_RS( TT_ExecContext  exc,
           FT_Long*        args )
   {
     FT_ULong  I = (FT_ULong)args[0];
@@ -3002,16 +3109,16 @@
         args[0] = exc->storage[I];
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* WS[]:         Write Store                                             */
-  /* Opcode range: 0x42                                                    */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * WS[]:         Write Store
+   * Opcode range: 0x42
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_WS( TT_ExecContext  exc,
           FT_Long*        args )
   {
     FT_ULong  I = (FT_ULong)args[0];
@@ -3025,16 +3132,16 @@
     else
       exc->storage[I] = args[1];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* WCVTP[]:      Write CVT in Pixel units                                */
-  /* Opcode range: 0x44                                                    */
-  /* Stack:        f26.6 uint32 -->                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * WCVTP[]:      Write CVT in Pixel units
+   * Opcode range: 0x44
+   * Stack:        f26.6 uint32 -->
+   */
   static void
   Ins_WCVTP( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_ULong  I = (FT_ULong)args[0];
@@ -3048,16 +3155,16 @@
     else
       exc->func_write_cvt( exc, I, args[1] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* WCVTF[]:      Write CVT in Funits                                     */
-  /* Opcode range: 0x70                                                    */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * WCVTF[]:      Write CVT in Funits
+   * Opcode range: 0x70
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_WCVTF( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_ULong  I = (FT_ULong)args[0];
@@ -3071,16 +3178,16 @@
     else
       exc->cvt[I] = FT_MulFix( args[1], exc->tt_metrics.scale );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RCVT[]:       Read CVT                                                */
-  /* Opcode range: 0x45                                                    */
-  /* Stack:        uint32 --> f26.6                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * RCVT[]:       Read CVT
+   * Opcode range: 0x45
+   * Stack:        uint32 --> f26.6
+   */
   static void
   Ins_RCVT( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_ULong  I = (FT_ULong)args[0];
@@ -3096,44 +3203,44 @@
     else
       args[0] = exc->func_read_cvt( exc, I );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* AA[]:         Adjust Angle                                            */
-  /* Opcode range: 0x7F                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * AA[]:         Adjust Angle
+   * Opcode range: 0x7F
+   * Stack:        uint32 -->
+   */
   static void
   Ins_AA( void )
   {
     /* intentionally no longer supported */
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DEBUG[]:      DEBUG.  Unsupported.                                    */
-  /* Opcode range: 0x4F                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
-  /* Note: The original instruction pops a value from the stack.           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DEBUG[]:      DEBUG.  Unsupported.
+   * Opcode range: 0x4F
+   * Stack:        uint32 -->
+   *
+   * Note: The original instruction pops a value from the stack.
+   */
   static void
   Ins_DEBUG( TT_ExecContext  exc )
   {
     exc->error = FT_THROW( Debug_OpCode );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ROUND[ab]:    ROUND value                                             */
-  /* Opcode range: 0x68-0x6B                                               */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ROUND[ab]:    ROUND value
+   * Opcode range: 0x68-0x6B
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_ROUND( TT_ExecContext  exc,
              FT_Long*        args )
   {
     args[0] = exc->func_round(
@@ -3141,16 +3248,16 @@
                 args[0],
                 exc->tt_metrics.compensations[exc->opcode - 0x68] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NROUND[ab]:   No ROUNDing of value                                    */
-  /* Opcode range: 0x6C-0x6F                                               */
-  /* Stack:        f26.6 --> f26.6                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NROUND[ab]:   No ROUNDing of value
+   * Opcode range: 0x6C-0x6F
+   * Stack:        f26.6 --> f26.6
+   */
   static void
   Ins_NROUND( TT_ExecContext  exc,
               FT_Long*        args )
   {
     args[0] = Round_None(
@@ -3158,44 +3265,44 @@
                 args[0],
                 exc->tt_metrics.compensations[exc->opcode - 0x6C] );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MAX[]:        MAXimum                                                 */
-  /* Opcode range: 0x8B                                                    */
-  /* Stack:        int32? int32? --> int32                                 */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MAX[]:        MAXimum
+   * Opcode range: 0x8B
+   * Stack:        int32? int32? --> int32
+   */
   static void
   Ins_MAX( FT_Long*  args )
   {
     if ( args[1] > args[0] )
       args[0] = args[1];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MIN[]:        MINimum                                                 */
-  /* Opcode range: 0x8C                                                    */
-  /* Stack:        int32? int32? --> int32                                 */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MIN[]:        MINimum
+   * Opcode range: 0x8C
+   * Stack:        int32? int32? --> int32
+   */
   static void
   Ins_MIN( FT_Long*  args )
   {
     if ( args[1] < args[0] )
       args[0] = args[1];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MINDEX[]:     Move INDEXed element                                    */
-  /* Opcode range: 0x26                                                    */
-  /* Stack:        int32? --> StkElt                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MINDEX[]:     Move INDEXed element
+   * Opcode range: 0x26
+   * Stack:        int32? --> StkElt
+   */
   static void
   Ins_MINDEX( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_Long  L, K;
@@ -3219,16 +3326,16 @@
       exc->stack[exc->args - 1] = K;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* CINDEX[]:     Copy INDEXed element                                    */
-  /* Opcode range: 0x25                                                    */
-  /* Stack:        int32 --> StkElt                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * CINDEX[]:     Copy INDEXed element
+   * Opcode range: 0x25
+   * Stack:        int32 --> StkElt
+   */
   static void
   Ins_CINDEX( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_Long  L;
@@ -3245,16 +3352,16 @@
     else
       args[0] = exc->stack[exc->args - L];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ROLL[]:       ROLL top three elements                                 */
-  /* Opcode range: 0x8A                                                    */
-  /* Stack:        3 * StkElt --> 3 * StkElt                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ROLL[]:       ROLL top three elements
+   * Opcode range: 0x8A
+   * Stack:        3 * StkElt --> 3 * StkElt
+   */
   static void
   Ins_ROLL( FT_Long*  args )
   {
     FT_Long  A, B, C;
 
@@ -3267,23 +3374,23 @@
     args[1] = A;
     args[0] = B;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MANAGING THE FLOW OF CONTROL                                          */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * MANAGING THE FLOW OF CONTROL
+   *
+   */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SLOOP[]:      Set LOOP variable                                       */
-  /* Opcode range: 0x17                                                    */
-  /* Stack:        int32? -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SLOOP[]:      Set LOOP variable
+   * Opcode range: 0x17
+   * Stack:        int32? -->
+   */
   static void
   Ins_SLOOP( TT_ExecContext  exc,
              FT_Long*        args )
   {
     if ( args[0] < 0 )
@@ -3321,16 +3428,16 @@
     exc->error = FT_THROW( Code_Overflow );
     return FAILURE;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* IF[]:         IF test                                                 */
-  /* Opcode range: 0x58                                                    */
-  /* Stack:        StkElt -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * IF[]:         IF test
+   * Opcode range: 0x58
+   * Stack:        StkElt -->
+   */
   static void
   Ins_IF( TT_ExecContext  exc,
           FT_Long*        args )
   {
     FT_Int   nIfs;
@@ -3365,16 +3472,16 @@
       }
     } while ( Out == 0 );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ELSE[]:       ELSE                                                    */
-  /* Opcode range: 0x1B                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ELSE[]:       ELSE
+   * Opcode range: 0x1B
+   * Stack:        -->
+   */
   static void
   Ins_ELSE( TT_ExecContext  exc )
   {
     FT_Int  nIfs;
 
@@ -3398,29 +3505,29 @@
       }
     } while ( nIfs != 0 );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* EIF[]:        End IF                                                  */
-  /* Opcode range: 0x59                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * EIF[]:        End IF
+   * Opcode range: 0x59
+   * Stack:        -->
+   */
   static void
   Ins_EIF( void )
   {
     /* nothing to do */
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* JMPR[]:       JuMP Relative                                           */
-  /* Opcode range: 0x1C                                                    */
-  /* Stack:        int32 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * JMPR[]:       JuMP Relative
+   * Opcode range: 0x1C
+   * Stack:        int32 -->
+   */
   static void
   Ins_JMPR( TT_ExecContext  exc,
             FT_Long*        args )
   {
     if ( args[0] == 0 && exc->args == 0 )
@@ -3446,53 +3553,53 @@
         exc->error = FT_THROW( Execution_Too_Long );
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* JROT[]:       Jump Relative On True                                   */
-  /* Opcode range: 0x78                                                    */
-  /* Stack:        StkElt int32 -->                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * JROT[]:       Jump Relative On True
+   * Opcode range: 0x78
+   * Stack:        StkElt int32 -->
+   */
   static void
   Ins_JROT( TT_ExecContext  exc,
             FT_Long*        args )
   {
     if ( args[1] != 0 )
       Ins_JMPR( exc, args );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* JROF[]:       Jump Relative On False                                  */
-  /* Opcode range: 0x79                                                    */
-  /* Stack:        StkElt int32 -->                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * JROF[]:       Jump Relative On False
+   * Opcode range: 0x79
+   * Stack:        StkElt int32 -->
+   */
   static void
   Ins_JROF( TT_ExecContext  exc,
             FT_Long*        args )
   {
     if ( args[1] == 0 )
       Ins_JMPR( exc, args );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * DEFINING AND USING FUNCTIONS AND INSTRUCTIONS
+   *
+   */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FDEF[]:       Function DEFinition                                     */
-  /* Opcode range: 0x2C                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FDEF[]:       Function DEFinition
+   * Opcode range: 0x2C
+   * Stack:        uint32 -->
+   */
   static void
   Ins_FDEF( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_ULong       n;
@@ -3786,16 +3893,16 @@
       }
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ENDF[]:       END Function definition                                 */
-  /* Opcode range: 0x2D                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ENDF[]:       END Function definition
+   * Opcode range: 0x2D
+   * Stack:        -->
+   */
   static void
   Ins_ENDF( TT_ExecContext  exc )
   {
     TT_CallRec*  pRec;
 
@@ -3835,16 +3942,16 @@
     /*       valid address, and it is why we do not test */
     /*       the result of Ins_Goto_CodeRange() here!    */
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* CALL[]:       CALL function                                           */
-  /* Opcode range: 0x2B                                                    */
-  /* Stack:        uint32? -->                                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * CALL[]:       CALL function
+   * Opcode range: 0x2B
+   * Stack:        uint32? -->
+   */
   static void
   Ins_CALL( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_ULong       F;
@@ -3924,16 +4031,16 @@
   Fail:
     exc->error = FT_THROW( Invalid_Reference );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* LOOPCALL[]:   LOOP and CALL function                                  */
-  /* Opcode range: 0x2A                                                    */
-  /* Stack:        uint32? Eint16? -->                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * LOOPCALL[]:   LOOP and CALL function
+   * Opcode range: 0x2A
+   * Stack:        uint32? Eint16? -->
+   */
   static void
   Ins_LOOPCALL( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     FT_ULong       F;
@@ -4017,16 +4124,16 @@
   Fail:
     exc->error = FT_THROW( Invalid_Reference );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* IDEF[]:       Instruction DEFinition                                  */
-  /* Opcode range: 0x89                                                    */
-  /* Stack:        Eint8 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * IDEF[]:       Instruction DEFinition
+   * Opcode range: 0x89
+   * Stack:        Eint8 -->
+   */
   static void
   Ins_IDEF( TT_ExecContext  exc,
             FT_Long*        args )
   {
     TT_DefRecord*  def;
@@ -4092,23 +4199,23 @@
       }
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* PUSHING DATA ONTO THE INTERPRETER STACK                               */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * PUSHING DATA ONTO THE INTERPRETER STACK
+   *
+   */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NPUSHB[]:     PUSH N Bytes                                            */
-  /* Opcode range: 0x40                                                    */
-  /* Stack:        --> uint32...                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NPUSHB[]:     PUSH N Bytes
+   * Opcode range: 0x40
+   * Stack:        --> uint32...
+   */
   static void
   Ins_NPUSHB( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_UShort  L, K;
@@ -4127,16 +4234,16 @@
 
     exc->new_top += L;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* NPUSHW[]:     PUSH N Words                                            */
-  /* Opcode range: 0x41                                                    */
-  /* Stack:        --> int32...                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * NPUSHW[]:     PUSH N Words
+   * Opcode range: 0x41
+   * Stack:        --> int32...
+   */
   static void
   Ins_NPUSHW( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_UShort  L, K;
@@ -4158,16 +4265,16 @@
     exc->step_ins = FALSE;
     exc->new_top += L;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* PUSHB[abc]:   PUSH Bytes                                              */
-  /* Opcode range: 0xB0-0xB7                                               */
-  /* Stack:        --> uint32...                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * PUSHB[abc]:   PUSH Bytes
+   * Opcode range: 0xB0-0xB7
+   * Stack:        --> uint32...
+   */
   static void
   Ins_PUSHB( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_UShort  L, K;
@@ -4184,16 +4291,16 @@
     for ( K = 1; K <= L; K++ )
       args[K - 1] = exc->code[exc->IP + K];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* PUSHW[abc]:   PUSH Words                                              */
-  /* Opcode range: 0xB8-0xBF                                               */
-  /* Stack:        --> int32...                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * PUSHW[abc]:   PUSH Words
+   * Opcode range: 0xB8-0xBF
+   * Stack:        --> int32...
+   */
   static void
   Ins_PUSHW( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_UShort  L, K;
@@ -4214,15 +4321,15 @@
 
     exc->step_ins = FALSE;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MANAGING THE GRAPHICS STATE                                           */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * MANAGING THE GRAPHICS STATE
+   *
+   */
 
 
   static FT_Bool
   Ins_SxVTL( TT_ExecContext  exc,
              FT_UShort       aIdx1,
@@ -4272,24 +4379,24 @@
 
     return SUCCESS;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
-  /* Opcode range: 0x00-0x01                                               */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
-  /* SPvTCA[a]:    Set PVector to Coordinate Axis                          */
-  /* Opcode range: 0x02-0x03                                               */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
-  /* SFvTCA[a]:    Set FVector to Coordinate Axis                          */
-  /* Opcode range: 0x04-0x05                                               */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis
+   * Opcode range: 0x00-0x01
+   * Stack:        -->
+   *
+   * SPvTCA[a]:    Set PVector to Coordinate Axis
+   * Opcode range: 0x02-0x03
+   * Stack:        -->
+   *
+   * SFvTCA[a]:    Set FVector to Coordinate Axis
+   * Opcode range: 0x04-0x05
+   * Stack:        -->
+   */
   static void
   Ins_SxyTCA( TT_ExecContext  exc )
   {
     FT_Short  AA, BB;
 
@@ -4316,16 +4423,16 @@
 
     Compute_Funcs( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SPvTL[a]:     Set PVector To Line                                     */
-  /* Opcode range: 0x06-0x07                                               */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SPvTL[a]:     Set PVector To Line
+   * Opcode range: 0x06-0x07
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_SPVTL( TT_ExecContext  exc,
              FT_Long*        args )
   {
     if ( Ins_SxVTL( exc,
@@ -4337,16 +4444,16 @@
       Compute_Funcs( exc );
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SFvTL[a]:     Set FVector To Line                                     */
-  /* Opcode range: 0x08-0x09                                               */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SFvTL[a]:     Set FVector To Line
+   * Opcode range: 0x08-0x09
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_SFVTL( TT_ExecContext  exc,
              FT_Long*        args )
   {
     if ( Ins_SxVTL( exc,
@@ -4357,30 +4464,30 @@
       Compute_Funcs( exc );
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SFvTPv[]:     Set FVector To PVector                                  */
-  /* Opcode range: 0x0E                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SFvTPv[]:     Set FVector To PVector
+   * Opcode range: 0x0E
+   * Stack:        -->
+   */
   static void
   Ins_SFVTPV( TT_ExecContext  exc )
   {
     exc->GS.freeVector = exc->GS.projVector;
     Compute_Funcs( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SPvFS[]:      Set PVector From Stack                                  */
-  /* Opcode range: 0x0A                                                    */
-  /* Stack:        f2.14 f2.14 -->                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SPvFS[]:      Set PVector From Stack
+   * Opcode range: 0x0A
+   * Stack:        f2.14 f2.14 -->
+   */
   static void
   Ins_SPVFS( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_Short  S;
@@ -4398,16 +4505,16 @@
     exc->GS.dualVector = exc->GS.projVector;
     Compute_Funcs( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SFvFS[]:      Set FVector From Stack                                  */
-  /* Opcode range: 0x0B                                                    */
-  /* Stack:        f2.14 f2.14 -->                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SFvFS[]:      Set FVector From Stack
+   * Opcode range: 0x0B
+   * Stack:        f2.14 f2.14 -->
+   */
   static void
   Ins_SFVFS( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_Short  S;
@@ -4423,198 +4530,198 @@
     Normalize( X, Y, &exc->GS.freeVector );
     Compute_Funcs( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GPv[]:        Get Projection Vector                                   */
-  /* Opcode range: 0x0C                                                    */
-  /* Stack:        ef2.14 --> ef2.14                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GPv[]:        Get Projection Vector
+   * Opcode range: 0x0C
+   * Stack:        ef2.14 --> ef2.14
+   */
   static void
   Ins_GPV( TT_ExecContext  exc,
            FT_Long*        args )
   {
     args[0] = exc->GS.projVector.x;
     args[1] = exc->GS.projVector.y;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GFv[]:        Get Freedom Vector                                      */
-  /* Opcode range: 0x0D                                                    */
-  /* Stack:        ef2.14 --> ef2.14                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GFv[]:        Get Freedom Vector
+   * Opcode range: 0x0D
+   * Stack:        ef2.14 --> ef2.14
+   */
   static void
   Ins_GFV( TT_ExecContext  exc,
            FT_Long*        args )
   {
     args[0] = exc->GS.freeVector.x;
     args[1] = exc->GS.freeVector.y;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SRP0[]:       Set Reference Point 0                                   */
-  /* Opcode range: 0x10                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SRP0[]:       Set Reference Point 0
+   * Opcode range: 0x10
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SRP0( TT_ExecContext  exc,
             FT_Long*        args )
   {
     exc->GS.rp0 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SRP1[]:       Set Reference Point 1                                   */
-  /* Opcode range: 0x11                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SRP1[]:       Set Reference Point 1
+   * Opcode range: 0x11
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SRP1( TT_ExecContext  exc,
             FT_Long*        args )
   {
     exc->GS.rp1 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SRP2[]:       Set Reference Point 2                                   */
-  /* Opcode range: 0x12                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SRP2[]:       Set Reference Point 2
+   * Opcode range: 0x12
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SRP2( TT_ExecContext  exc,
             FT_Long*        args )
   {
     exc->GS.rp2 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SMD[]:        Set Minimum Distance                                    */
-  /* Opcode range: 0x1A                                                    */
-  /* Stack:        f26.6 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SMD[]:        Set Minimum Distance
+   * Opcode range: 0x1A
+   * Stack:        f26.6 -->
+   */
   static void
   Ins_SMD( TT_ExecContext  exc,
            FT_Long*        args )
   {
     exc->GS.minimum_distance = args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SCVTCI[]:     Set Control Value Table Cut In                          */
-  /* Opcode range: 0x1D                                                    */
-  /* Stack:        f26.6 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SCVTCI[]:     Set Control Value Table Cut In
+   * Opcode range: 0x1D
+   * Stack:        f26.6 -->
+   */
   static void
   Ins_SCVTCI( TT_ExecContext  exc,
               FT_Long*        args )
   {
     exc->GS.control_value_cutin = (FT_F26Dot6)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SSWCI[]:      Set Single Width Cut In                                 */
-  /* Opcode range: 0x1E                                                    */
-  /* Stack:        f26.6 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SSWCI[]:      Set Single Width Cut In
+   * Opcode range: 0x1E
+   * Stack:        f26.6 -->
+   */
   static void
   Ins_SSWCI( TT_ExecContext  exc,
              FT_Long*        args )
   {
     exc->GS.single_width_cutin = (FT_F26Dot6)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SSW[]:        Set Single Width                                        */
-  /* Opcode range: 0x1F                                                    */
-  /* Stack:        int32? -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SSW[]:        Set Single Width
+   * Opcode range: 0x1F
+   * Stack:        int32? -->
+   */
   static void
   Ins_SSW( TT_ExecContext  exc,
            FT_Long*        args )
   {
     exc->GS.single_width_value = FT_MulFix( args[0],
                                             exc->tt_metrics.scale );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLIPON[]:     Set auto-FLIP to ON                                     */
-  /* Opcode range: 0x4D                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLIPON[]:     Set auto-FLIP to ON
+   * Opcode range: 0x4D
+   * Stack:        -->
+   */
   static void
   Ins_FLIPON( TT_ExecContext  exc )
   {
     exc->GS.auto_flip = TRUE;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
-  /* Opcode range: 0x4E                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLIPOFF[]:    Set auto-FLIP to OFF
+   * Opcode range: 0x4E
+   * Stack:        -->
+   */
   static void
   Ins_FLIPOFF( TT_ExecContext  exc )
   {
     exc->GS.auto_flip = FALSE;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SANGW[]:      Set ANGle Weight                                        */
-  /* Opcode range: 0x7E                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SANGW[]:      Set ANGle Weight
+   * Opcode range: 0x7E
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SANGW( void )
   {
     /* instruction not supported anymore */
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SDB[]:        Set Delta Base                                          */
-  /* Opcode range: 0x5E                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SDB[]:        Set Delta Base
+   * Opcode range: 0x5E
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SDB( TT_ExecContext  exc,
            FT_Long*        args )
   {
     exc->GS.delta_base = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SDS[]:        Set Delta Shift                                         */
-  /* Opcode range: 0x5F                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SDS[]:        Set Delta Shift
+   * Opcode range: 0x5F
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SDS( TT_ExecContext  exc,
            FT_Long*        args )
   {
     if ( (FT_ULong)args[0] > 6UL )
@@ -4622,98 +4729,98 @@
     else
       exc->GS.delta_shift = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RTHG[]:       Round To Half Grid                                      */
-  /* Opcode range: 0x19                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * RTHG[]:       Round To Half Grid
+   * Opcode range: 0x19
+   * Stack:        -->
+   */
   static void
   Ins_RTHG( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_To_Half_Grid;
     exc->func_round     = (TT_Round_Func)Round_To_Half_Grid;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RTG[]:        Round To Grid                                           */
-  /* Opcode range: 0x18                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * RTG[]:        Round To Grid
+   * Opcode range: 0x18
+   * Stack:        -->
+   */
   static void
   Ins_RTG( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_To_Grid;
     exc->func_round     = (TT_Round_Func)Round_To_Grid;
   }
 
 
-  /*************************************************************************/
-  /* RTDG[]:       Round To Double Grid                                    */
-  /* Opcode range: 0x3D                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   * RTDG[]:       Round To Double Grid
+   * Opcode range: 0x3D
+   * Stack:        -->
+   */
   static void
   Ins_RTDG( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_To_Double_Grid;
     exc->func_round     = (TT_Round_Func)Round_To_Double_Grid;
   }
 
 
-  /*************************************************************************/
-  /* RUTG[]:       Round Up To Grid                                        */
-  /* Opcode range: 0x7C                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   * RUTG[]:       Round Up To Grid
+   * Opcode range: 0x7C
+   * Stack:        -->
+   */
   static void
   Ins_RUTG( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_Up_To_Grid;
     exc->func_round     = (TT_Round_Func)Round_Up_To_Grid;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RDTG[]:       Round Down To Grid                                      */
-  /* Opcode range: 0x7D                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * RDTG[]:       Round Down To Grid
+   * Opcode range: 0x7D
+   * Stack:        -->
+   */
   static void
   Ins_RDTG( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_Down_To_Grid;
     exc->func_round     = (TT_Round_Func)Round_Down_To_Grid;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ROFF[]:       Round OFF                                               */
-  /* Opcode range: 0x7A                                                    */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ROFF[]:       Round OFF
+   * Opcode range: 0x7A
+   * Stack:        -->
+   */
   static void
   Ins_ROFF( TT_ExecContext  exc )
   {
     exc->GS.round_state = TT_Round_Off;
     exc->func_round     = (TT_Round_Func)Round_None;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SROUND[]:     Super ROUND                                             */
-  /* Opcode range: 0x76                                                    */
-  /* Stack:        Eint8 -->                                               */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SROUND[]:     Super ROUND
+   * Opcode range: 0x76
+   * Stack:        Eint8 -->
+   */
   static void
   Ins_SROUND( TT_ExecContext  exc,
               FT_Long*        args )
   {
     SetSuperRound( exc, 0x4000, args[0] );
@@ -4721,16 +4828,16 @@
     exc->GS.round_state = TT_Round_Super;
     exc->func_round     = (TT_Round_Func)Round_Super;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* S45ROUND[]:   Super ROUND 45 degrees                                  */
-  /* Opcode range: 0x77                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * S45ROUND[]:   Super ROUND 45 degrees
+   * Opcode range: 0x77
+   * Stack:        uint32 -->
+   */
   static void
   Ins_S45ROUND( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     SetSuperRound( exc, 0x2D41, args[0] );
@@ -4738,19 +4845,19 @@
     exc->GS.round_state = TT_Round_Super_45;
     exc->func_round     = (TT_Round_Func)Round_Super_45;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GC[a]:        Get Coordinate projected onto                           */
-  /* Opcode range: 0x46-0x47                                               */
-  /* Stack:        uint32 --> f26.6                                        */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */
-  /*      along the dual projection vector!                                */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GC[a]:        Get Coordinate projected onto
+   * Opcode range: 0x46-0x47
+   * Stack:        uint32 --> f26.6
+   *
+   * XXX: UNDOCUMENTED: Measures from the original glyph must be taken
+   *      along the dual projection vector!
+   */
   static void
   Ins_GC( TT_ExecContext  exc,
           FT_Long*        args )
   {
     FT_ULong    L;
@@ -4775,20 +4882,20 @@
 
     args[0] = R;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SCFS[]:       Set Coordinate From Stack                               */
-  /* Opcode range: 0x48                                                    */
-  /* Stack:        f26.6 uint32 -->                                        */
-  /*                                                                       */
-  /* Formula:                                                              */
-  /*                                                                       */
-  /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SCFS[]:       Set Coordinate From Stack
+   * Opcode range: 0x48
+   * Stack:        f26.6 uint32 -->
+   *
+   * Formula:
+   *
+   *   OA := OA + ( value - OA.p )/( f.p ) * f
+   */
   static void
   Ins_SCFS( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_Long    K;
@@ -4813,25 +4920,25 @@
     if ( exc->GS.gep2 == 0 )
       exc->zp2.org[L] = exc->zp2.cur[L];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MD[a]:        Measure Distance                                        */
-  /* Opcode range: 0x49-0x4A                                               */
-  /* Stack:        uint32 uint32 --> f26.6                                 */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */
-  /*                    the dual projection vector.                        */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */
-  /*                      0 => measure distance in original outline        */
-  /*                      1 => measure distance in grid-fitted outline     */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MD[a]:        Measure Distance
+   * Opcode range: 0x49-0x4A
+   * Stack:        uint32 uint32 --> f26.6
+   *
+   * XXX: UNDOCUMENTED: Measure taken in the original glyph must be along
+   *                    the dual projection vector.
+   *
+   * XXX: UNDOCUMENTED: Flag attributes are inverted!
+   *                      0 => measure distance in original outline
+   *                      1 => measure distance in grid-fitted outline
+   *
+   * XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!
+   */
   static void
   Ins_MD( TT_ExecContext  exc,
           FT_Long*        args )
   {
     FT_UShort   K, L;
@@ -4900,16 +5007,16 @@
 
     args[0] = D;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SDPvTL[a]:    Set Dual PVector to Line                                */
-  /* Opcode range: 0x86-0x87                                               */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SDPvTL[a]:    Set Dual PVector to Line
+   * Opcode range: 0x86-0x87
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_SDPVTL( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_Long    A, B, C;
@@ -4983,16 +5090,16 @@
     Normalize( A, B, &exc->GS.projVector );
     Compute_Funcs( exc );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SZP0[]:       Set Zone Pointer 0                                      */
-  /* Opcode range: 0x13                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SZP0[]:       Set Zone Pointer 0
+   * Opcode range: 0x13
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SZP0( TT_ExecContext  exc,
             FT_Long*        args )
   {
     switch ( (FT_Int)args[0] )
@@ -5013,16 +5120,16 @@
 
     exc->GS.gep0 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SZP1[]:       Set Zone Pointer 1                                      */
-  /* Opcode range: 0x14                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SZP1[]:       Set Zone Pointer 1
+   * Opcode range: 0x14
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SZP1( TT_ExecContext  exc,
             FT_Long*        args )
   {
     switch ( (FT_Int)args[0] )
@@ -5043,16 +5150,16 @@
 
     exc->GS.gep1 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SZP2[]:       Set Zone Pointer 2                                      */
-  /* Opcode range: 0x15                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SZP2[]:       Set Zone Pointer 2
+   * Opcode range: 0x15
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SZP2( TT_ExecContext  exc,
             FT_Long*        args )
   {
     switch ( (FT_Int)args[0] )
@@ -5073,16 +5180,16 @@
 
     exc->GS.gep2 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SZPS[]:       Set Zone PointerS                                       */
-  /* Opcode range: 0x16                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SZPS[]:       Set Zone PointerS
+   * Opcode range: 0x16
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SZPS( TT_ExecContext  exc,
             FT_Long*        args )
   {
     switch ( (FT_Int)args[0] )
@@ -5108,16 +5215,16 @@
     exc->GS.gep1 = (FT_UShort)args[0];
     exc->GS.gep2 = (FT_UShort)args[0];
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* INSTCTRL[]:   INSTruction ConTRoL                                     */
-  /* Opcode range: 0x8E                                                    */
-  /* Stack:        int32 int32 -->                                         */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * INSTCTRL[]:   INSTruction ConTRoL
+   * Opcode range: 0x8E
+   * Stack:        int32 int32 -->
+   */
   static void
   Ins_INSTCTRL( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     FT_ULong  K, L, Kf;
@@ -5170,16 +5277,16 @@
 #endif
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SCANCTRL[]:   SCAN ConTRoL                                            */
-  /* Opcode range: 0x85                                                    */
-  /* Stack:        uint32? -->                                             */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SCANCTRL[]:   SCAN ConTRoL
+   * Opcode range: 0x85
+   * Stack:        uint32? -->
+   */
   static void
   Ins_SCANCTRL( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     FT_Int  A;
@@ -5217,38 +5324,38 @@
     if ( ( args[0] & 0x2000 ) != 0 && exc->tt_metrics.stretched )
       exc->GS.scan_control = FALSE;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SCANTYPE[]:   SCAN TYPE                                               */
-  /* Opcode range: 0x8D                                                    */
-  /* Stack:        uint16 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SCANTYPE[]:   SCAN TYPE
+   * Opcode range: 0x8D
+   * Stack:        uint16 -->
+   */
   static void
   Ins_SCANTYPE( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     if ( args[0] >= 0 )
       exc->GS.scan_type = (FT_Int)args[0] & 0xFFFF;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MANAGING OUTLINES                                                     */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * MANAGING OUTLINES
+   *
+   */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLIPPT[]:     FLIP PoinT                                              */
-  /* Opcode range: 0x80                                                    */
-  /* Stack:        uint32... -->                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLIPPT[]:     FLIP PoinT
+   * Opcode range: 0x80
+   * Stack:        uint32... -->
+   */
   static void
   Ins_FLIPPT( TT_ExecContext  exc )
   {
     FT_UShort  point;
 
@@ -5293,16 +5400,16 @@
     exc->GS.loop = 1;
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLIPRGON[]:   FLIP RanGe ON                                           */
-  /* Opcode range: 0x81                                                    */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLIPRGON[]:   FLIP RanGe ON
+   * Opcode range: 0x81
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_FLIPRGON( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     FT_UShort  I, K, L;
@@ -5331,16 +5438,16 @@
     for ( I = L; I <= K; I++ )
       exc->pts.tags[I] |= FT_CURVE_TAG_ON;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* FLIPRGOFF:    FLIP RanGe OFF                                          */
-  /* Opcode range: 0x82                                                    */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * FLIPRGOFF:    FLIP RanGe OFF
+   * Opcode range: 0x82
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_FLIPRGOFF( TT_ExecContext  exc,
                  FT_Long*        args )
   {
     FT_UShort  I, K, L;
@@ -5448,16 +5555,16 @@
         exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SHP[a]:       SHift Point by the last point                           */
-  /* Opcode range: 0x32-0x33                                               */
-  /* Stack:        uint32... -->                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SHP[a]:       SHift Point by the last point
+   * Opcode range: 0x32-0x33
+   * Stack:        uint32... -->
+   */
   static void
   Ins_SHP( TT_ExecContext  exc )
   {
     TT_GlyphZoneRec  zp;
     FT_UShort        refp;
@@ -5505,20 +5612,20 @@
     exc->GS.loop = 1;
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SHC[a]:       SHift Contour                                           */
-  /* Opcode range: 0x34-35                                                 */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
-  /* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */
-  /*               contour in the twilight zone, namely contour number     */
-  /*               zero which includes all points of it.                   */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SHC[a]:       SHift Contour
+   * Opcode range: 0x34-35
+   * Stack:        uint32 -->
+   *
+   * UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)
+   *               contour in the twilight zone, namely contour number
+   *               zero which includes all points of it.
+   */
   static void
   Ins_SHC( TT_ExecContext  exc,
            FT_Long*        args )
   {
     TT_GlyphZoneRec  zp;
@@ -5561,16 +5668,16 @@
         Move_Zp2_Point( exc, i, dx, dy, TRUE );
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SHZ[a]:       SHift Zone                                              */
-  /* Opcode range: 0x36-37                                                 */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SHZ[a]:       SHift Zone
+   * Opcode range: 0x36-37
+   * Stack:        uint32 -->
+   */
   static void
   Ins_SHZ( TT_ExecContext  exc,
            FT_Long*        args )
   {
     TT_GlyphZoneRec  zp;
@@ -5609,16 +5716,16 @@
         Move_Zp2_Point( exc, i, dx, dy, FALSE );
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* SHPIX[]:      SHift points by a PIXel amount                          */
-  /* Opcode range: 0x38                                                    */
-  /* Stack:        f26.6 uint32... -->                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * SHPIX[]:      SHift points by a PIXel amount
+   * Opcode range: 0x38
+   * Stack:        f26.6 uint32... -->
+   */
   static void
   Ins_SHPIX( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_F26Dot6  dx, dy;
@@ -5769,16 +5876,16 @@
     exc->GS.loop = 1;
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MSIRP[a]:     Move Stack Indirect Relative Position                   */
-  /* Opcode range: 0x3A-0x3B                                               */
-  /* Stack:        f26.6 uint32 -->                                        */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MSIRP[a]:     Move Stack Indirect Relative Position
+   * Opcode range: 0x3A-0x3B
+   * Stack:        f26.6 uint32 -->
+   */
   static void
   Ins_MSIRP( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_UShort   point = 0;
@@ -5844,16 +5951,16 @@
     if ( ( exc->opcode & 1 ) != 0 )
       exc->GS.rp0 = point;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MDAP[a]:      Move Direct Absolute Point                              */
-  /* Opcode range: 0x2E-0x2F                                               */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MDAP[a]:      Move Direct Absolute Point
+   * Opcode range: 0x2E-0x2F
+   * Stack:        uint32 -->
+   */
   static void
   Ins_MDAP( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_UShort   point;
@@ -5898,16 +6005,16 @@
     exc->GS.rp0 = point;
     exc->GS.rp1 = point;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MIAP[a]:      Move Indirect Absolute Point                            */
-  /* Opcode range: 0x3E-0x3F                                               */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MIAP[a]:      Move Indirect Absolute Point
+   * Opcode range: 0x3E-0x3F
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_MIAP( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_ULong    cvtEntry;
@@ -6018,16 +6125,16 @@
     exc->GS.rp0 = point;
     exc->GS.rp1 = point;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MDRP[abcde]:  Move Direct Relative Point                              */
-  /* Opcode range: 0xC0-0xDF                                               */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MDRP[abcde]:  Move Direct Relative Point
+   * Opcode range: 0xC0-0xDF
+   * Stack:        uint32 -->
+   */
   static void
   Ins_MDRP( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_UShort   point = 0;
@@ -6162,16 +6269,16 @@
     if ( ( exc->opcode & 16 ) != 0 )
       exc->GS.rp0 = point;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MIRP[abcde]:  Move Indirect Relative Point                            */
-  /* Opcode range: 0xE0-0xFF                                               */
-  /* Stack:        int32? uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * MIRP[abcde]:  Move Indirect Relative Point
+   * Opcode range: 0xE0-0xFF
+   * Stack:        int32? uint32 -->
+   */
   static void
   Ins_MIRP( TT_ExecContext  exc,
             FT_Long*        args )
   {
     FT_UShort   point;
@@ -6187,10 +6294,12 @@
     FT_Int      B1           = 0; /* pacify compiler */
     FT_Int      B2           = 0;
     FT_Bool     reverse_move = FALSE;
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
+    FT_F26Dot6  delta;
+
 
     minimum_distance    = exc->GS.minimum_distance;
     control_value_cutin = exc->GS.control_value_cutin;
     point               = (FT_UShort)args[0];
     cvtEntry            = (FT_ULong)( ADD_LONG( args[1], 1 ) );
@@ -6219,12 +6328,15 @@
     else
       cvt_dist = exc->func_read_cvt( exc, cvtEntry - 1 );
 
     /* single width test */
 
-    if ( FT_ABS( cvt_dist - exc->GS.single_width_value ) <
-         exc->GS.single_width_cutin )
+    delta = SUB_LONG( cvt_dist, exc->GS.single_width_value );
+    if ( delta < 0 )
+      delta = NEG_LONG( delta );
+
+    if ( delta < exc->GS.single_width_cutin )
     {
       if ( cvt_dist >= 0 )
         cvt_dist =  exc->GS.single_width_value;
       else
         cvt_dist = -exc->GS.single_width_value;
@@ -6249,11 +6361,11 @@
     /* auto-flip test */
 
     if ( exc->GS.auto_flip )
     {
       if ( ( org_dist ^ cvt_dist ) < 0 )
-        cvt_dist = -cvt_dist;
+        cvt_dist = NEG_LONG( cvt_dist );
     }
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
     if ( SUBPIXEL_HINTING_INFINALITY                               &&
          exc->ignore_x_mode                                        &&
@@ -6274,13 +6386,10 @@
       /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
       /*      refer to the same zone.                                  */
 
       if ( exc->GS.gep0 == exc->GS.gep1 )
       {
-        FT_F26Dot6  delta;
-
-
         /* XXX: According to Greg Hitchcock, the following wording is */
         /*      the right one:                                        */
         /*                                                            */
         /*        When the absolute difference between the value in   */
         /*        the table [CVT] and the measurement directly from   */
@@ -6311,13 +6420,10 @@
       /* do cvt cut-in always in MIRP for sph */
       if ( SUBPIXEL_HINTING_INFINALITY  &&
            exc->ignore_x_mode           &&
            exc->GS.gep0 == exc->GS.gep1 )
       {
-        FT_F26Dot6  delta;
-
-
         delta = SUB_LONG( cvt_dist, org_dist );
         if ( delta < 0 )
           delta = NEG_LONG( delta );
 
         if ( delta > control_value_cutin )
@@ -6410,16 +6516,16 @@
 
     exc->GS.rp2 = point;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ALIGNRP[]:    ALIGN Relative Point                                    */
-  /* Opcode range: 0x3C                                                    */
-  /* Stack:        uint32 uint32... -->                                    */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ALIGNRP[]:    ALIGN Relative Point
+   * Opcode range: 0x3C
+   * Stack:        uint32 uint32... -->
+   */
   static void
   Ins_ALIGNRP( TT_ExecContext  exc )
   {
     FT_UShort   point;
     FT_F26Dot6  distance;
@@ -6473,16 +6579,16 @@
     exc->GS.loop = 1;
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ISECT[]:      moves point to InterSECTion                             */
-  /* Opcode range: 0x0F                                                    */
-  /* Stack:        5 * uint32 -->                                          */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ISECT[]:      moves point to InterSECTion
+   * Opcode range: 0x0F
+   * Stack:        5 * uint32 -->
+   */
   static void
   Ins_ISECT( TT_ExecContext  exc,
              FT_Long*        args )
   {
     FT_UShort   point,
@@ -6569,16 +6675,16 @@
 
     exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* ALIGNPTS[]:   ALIGN PoinTS                                            */
-  /* Opcode range: 0x27                                                    */
-  /* Stack:        uint32 uint32 -->                                       */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * ALIGNPTS[]:   ALIGN PoinTS
+   * Opcode range: 0x27
+   * Stack:        uint32 uint32 -->
+   */
   static void
   Ins_ALIGNPTS( TT_ExecContext  exc,
                 FT_Long*        args )
   {
     FT_UShort   p1, p2;
@@ -6601,16 +6707,16 @@
     exc->func_move( exc, &exc->zp1, p1, distance );
     exc->func_move( exc, &exc->zp0, p2, NEG_LONG( distance ) );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* IP[]:         Interpolate Point                                       */
-  /* Opcode range: 0x39                                                    */
-  /* Stack:        uint32... -->                                           */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * IP[]:         Interpolate Point
+   * Opcode range: 0x39
+   * Stack:        uint32... -->
+   */
 
   /* SOMETIMES, DUMBER CODE IS BETTER CODE */
 
   static void
   Ins_IP( TT_ExecContext  exc )
@@ -6761,16 +6867,16 @@
     exc->GS.loop = 1;
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* UTP[a]:       UnTouch Point                                           */
-  /* Opcode range: 0x29                                                    */
-  /* Stack:        uint32 -->                                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * UTP[a]:       UnTouch Point
+   * Opcode range: 0x29
+   * Stack:        uint32 -->
+   */
   static void
   Ins_UTP( TT_ExecContext  exc,
            FT_Long*        args )
   {
     FT_UShort  point;
@@ -6930,16 +7036,16 @@
       }
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* IUP[a]:       Interpolate Untouched Points                            */
-  /* Opcode range: 0x30-0x31                                               */
-  /* Stack:        -->                                                     */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * IUP[a]:       Interpolate Untouched Points
+   * Opcode range: 0x30-0x31
+   * Stack:        -->
+   */
   static void
   Ins_IUP( TT_ExecContext  exc )
   {
     IUP_WorkerRec  V;
     FT_Byte        mask;
@@ -7058,16 +7164,16 @@
       contour++;
     } while ( contour < exc->pts.n_contours );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
-  /* Opcode range: 0x5D,0x71,0x72                                          */
-  /* Stack:        uint32 (2 * uint32)... -->                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DELTAPn[]:    DELTA exceptions P1, P2, P3
+   * Opcode range: 0x5D,0x71,0x72
+   * Stack:        uint32 (2 * uint32)... -->
+   */
   static void
   Ins_DELTAP( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_ULong   nump, k;
@@ -7140,16 +7246,16 @@
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
 
           if ( SUBPIXEL_HINTING_INFINALITY )
           {
             /*
-             *  Allow delta move if
+             * Allow delta move if
              *
-             *  - not using ignore_x_mode rendering,
-             *  - glyph is specifically set to allow it, or
-             *  - glyph is composite and freedom vector is not in subpixel
-             *    direction.
+             * - not using ignore_x_mode rendering,
+             * - glyph is specifically set to allow it, or
+             * - glyph is composite and freedom vector is not in subpixel
+             *   direction.
              */
             if ( !exc->ignore_x_mode                                   ||
                  ( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
                  ( exc->is_composite && exc->GS.freeVector.y != 0 )    )
               exc->func_move( exc, &exc->zp0, A, B );
@@ -7225,16 +7331,16 @@
   Fail:
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
-  /* Opcode range: 0x73,0x74,0x75                                          */
-  /* Stack:        uint32 (2 * uint32)... -->                              */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * DELTACn[]:    DELTA exceptions C1, C2, C3
+   * Opcode range: 0x73,0x74,0x75
+   * Stack:        uint32 (2 * uint32)... -->
+   */
   static void
   Ins_DELTAC( TT_ExecContext  exc,
               FT_Long*        args )
   {
     FT_ULong  nump, k;
@@ -7303,31 +7409,31 @@
   Fail:
     exc->new_top = exc->args;
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* MISC. INSTRUCTIONS                                                    */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * MISC. INSTRUCTIONS
+   *
+   */
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GETINFO[]:    GET INFOrmation                                         */
-  /* Opcode range: 0x88                                                    */
-  /* Stack:        uint32 --> uint32                                       */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May     */
-  /*      2015) not documented in the OpenType specification.              */
-  /*                                                                       */
-  /*      Selector bit 11 is incorrectly described as bit 8, while the     */
-  /*      real meaning of bit 8 (vertical LCD subpixels) stays             */
-  /*      undocumented.  The same mistake can be found in Greg Hitchcock's */
-  /*      whitepaper.                                                      */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GETINFO[]:    GET INFOrmation
+   * Opcode range: 0x88
+   * Stack:        uint32 --> uint32
+   *
+   * XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May
+   *      2015) not documented in the OpenType specification.
+   *
+   *      Selector bit 11 is incorrectly described as bit 8, while the
+   *      real meaning of bit 8 (vertical LCD subpixels) stays
+   *      undocumented.  The same mistake can be found in Greg Hitchcock's
+   *      whitepaper.
+   */
   static void
   Ins_GETINFO( TT_ExecContext  exc,
                FT_Long*        args )
   {
     FT_Long    K;
@@ -7335,15 +7441,15 @@
 
 
     K = 0;
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
-    /********************************/
-    /* RASTERIZER VERSION           */
-    /* Selector Bit:  0             */
-    /* Return Bit(s): 0-7           */
-    /*                              */
+    /*********************************
+     * RASTERIZER VERSION
+     * Selector Bit:  0
+     * Return Bit(s): 0-7
+     */
     if ( SUBPIXEL_HINTING_INFINALITY &&
          ( args[0] & 1 ) != 0        &&
          exc->subpixel_hinting       )
     {
       if ( exc->ignore_x_mode )
@@ -7360,97 +7466,102 @@
     else
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
       if ( ( args[0] & 1 ) != 0 )
         K = driver->interpreter_version;
 
-    /********************************/
-    /* GLYPH ROTATED                */
-    /* Selector Bit:  1             */
-    /* Return Bit(s): 8             */
-    /*                              */
+    /*********************************
+     * GLYPH ROTATED
+     * Selector Bit:  1
+     * Return Bit(s): 8
+     */
     if ( ( args[0] & 2 ) != 0 && exc->tt_metrics.rotated )
       K |= 1 << 8;
 
-    /********************************/
-    /* GLYPH STRETCHED              */
-    /* Selector Bit:  2             */
-    /* Return Bit(s): 9             */
-    /*                              */
+    /*********************************
+     * GLYPH STRETCHED
+     * Selector Bit:  2
+     * Return Bit(s): 9
+     */
     if ( ( args[0] & 4 ) != 0 && exc->tt_metrics.stretched )
       K |= 1 << 9;
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
-    /********************************/
-    /* VARIATION GLYPH              */
-    /* Selector Bit:  3             */
-    /* Return Bit(s): 10            */
-    /*                              */
-    /* XXX: UNDOCUMENTED!           */
+    /*********************************
+     * VARIATION GLYPH
+     * Selector Bit:  3
+     * Return Bit(s): 10
+     *
+     * XXX: UNDOCUMENTED!
+     */
     if ( (args[0] & 8 ) != 0 && exc->face->blend )
       K |= 1 << 10;
 #endif
 
-    /********************************/
-    /* BI-LEVEL HINTING AND         */
-    /* GRAYSCALE RENDERING          */
-    /* Selector Bit:  5             */
-    /* Return Bit(s): 12            */
-    /*                              */
+    /*********************************
+     * BI-LEVEL HINTING AND
+     * GRAYSCALE RENDERING
+     * Selector Bit:  5
+     * Return Bit(s): 12
+     */
     if ( ( args[0] & 32 ) != 0 && exc->grayscale )
       K |= 1 << 12;
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     /* Toggle the following flags only outside of monochrome mode.      */
     /* Otherwise, instructions may behave weirdly and rendering results */
     /* may differ between v35 and v40 mode, e.g., in `Times New Roman   */
     /* Bold Italic'. */
     if ( SUBPIXEL_HINTING_MINIMAL && exc->subpixel_hinting_lean )
     {
-      /********************************/
-      /* HINTING FOR SUBPIXEL         */
-      /* Selector Bit:  6             */
-      /* Return Bit(s): 13            */
-      /*                              */
-      /* v40 does subpixel hinting by default. */
+      /*********************************
+       * HINTING FOR SUBPIXEL
+       * Selector Bit:  6
+       * Return Bit(s): 13
+       *
+       * v40 does subpixel hinting by default.
+       */
       if ( ( args[0] & 64 ) != 0 )
         K |= 1 << 13;
 
-      /********************************/
-      /* VERTICAL LCD SUBPIXELS?      */
-      /* Selector Bit:  8             */
-      /* Return Bit(s): 15            */
-      /*                              */
+      /*********************************
+       * VERTICAL LCD SUBPIXELS?
+       * Selector Bit:  8
+       * Return Bit(s): 15
+       */
       if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd_lean )
         K |= 1 << 15;
 
-      /********************************/
-      /* SUBPIXEL POSITIONED?         */
-      /* Selector Bit:  10            */
-      /* Return Bit(s): 17            */
-      /*                              */
-      /* XXX: FreeType supports it, dependent on what client does? */
+      /*********************************
+       * SUBPIXEL POSITIONED?
+       * Selector Bit:  10
+       * Return Bit(s): 17
+       *
+       * XXX: FreeType supports it, dependent on what client does?
+       */
       if ( ( args[0] & 1024 ) != 0 )
         K |= 1 << 17;
 
-      /********************************/
-      /* SYMMETRICAL SMOOTHING        */
-      /* Selector Bit:  11            */
-      /* Return Bit(s): 18            */
-      /*                              */
-      /* The only smoothing method FreeType supports unless someone sets */
-      /* FT_LOAD_TARGET_MONO.                                            */
+      /*********************************
+       * SYMMETRICAL SMOOTHING
+       * Selector Bit:  11
+       * Return Bit(s): 18
+       *
+       * The only smoothing method FreeType supports unless someone sets
+       * FT_LOAD_TARGET_MONO.
+       */
       if ( ( args[0] & 2048 ) != 0 && exc->subpixel_hinting_lean )
         K |= 1 << 18;
 
-      /********************************/
-      /* CLEARTYPE HINTING AND        */
-      /* GRAYSCALE RENDERING          */
-      /* Selector Bit:  12            */
-      /* Return Bit(s): 19            */
-      /*                              */
-      /* Grayscale rendering is what FreeType does anyway unless someone */
-      /* sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)              */
+      /*********************************
+       * CLEARTYPE HINTING AND
+       * GRAYSCALE RENDERING
+       * Selector Bit:  12
+       * Return Bit(s): 19
+       *
+       * Grayscale rendering is what FreeType does anyway unless someone
+       * sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)
+       */
       if ( ( args[0] & 4096 ) != 0 && exc->grayscale_cleartype )
         K |= 1 << 19;
     }
 #endif
 
@@ -7460,71 +7571,77 @@
          exc->rasterizer_version >= TT_INTERPRETER_VERSION_35 )
     {
 
       if ( exc->rasterizer_version >= 37 )
       {
-        /********************************/
-        /* HINTING FOR SUBPIXEL         */
-        /* Selector Bit:  6             */
-        /* Return Bit(s): 13            */
-        /*                              */
+        /*********************************
+         * HINTING FOR SUBPIXEL
+         * Selector Bit:  6
+         * Return Bit(s): 13
+         */
         if ( ( args[0] & 64 ) != 0 && exc->subpixel_hinting )
           K |= 1 << 13;
 
-        /********************************/
-        /* COMPATIBLE WIDTHS ENABLED    */
-        /* Selector Bit:  7             */
-        /* Return Bit(s): 14            */
-        /*                              */
-        /* Functionality still needs to be added */
+        /*********************************
+         * COMPATIBLE WIDTHS ENABLED
+         * Selector Bit:  7
+         * Return Bit(s): 14
+         *
+         * Functionality still needs to be added
+         */
         if ( ( args[0] & 128 ) != 0 && exc->compatible_widths )
           K |= 1 << 14;
 
-        /********************************/
-        /* VERTICAL LCD SUBPIXELS?      */
-        /* Selector Bit:  8             */
-        /* Return Bit(s): 15            */
-        /*                              */
-        /* Functionality still needs to be added */
+        /*********************************
+         * VERTICAL LCD SUBPIXELS?
+         * Selector Bit:  8
+         * Return Bit(s): 15
+         *
+         * Functionality still needs to be added
+         */
         if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd )
           K |= 1 << 15;
 
-        /********************************/
-        /* HINTING FOR BGR?             */
-        /* Selector Bit:  9             */
-        /* Return Bit(s): 16            */
-        /*                              */
-        /* Functionality still needs to be added */
+        /*********************************
+         * HINTING FOR BGR?
+         * Selector Bit:  9
+         * Return Bit(s): 16
+         *
+         * Functionality still needs to be added
+         */
         if ( ( args[0] & 512 ) != 0 && exc->bgr )
           K |= 1 << 16;
 
         if ( exc->rasterizer_version >= 38 )
         {
-          /********************************/
-          /* SUBPIXEL POSITIONED?         */
-          /* Selector Bit:  10            */
-          /* Return Bit(s): 17            */
-          /*                              */
-          /* Functionality still needs to be added */
+          /*********************************
+           * SUBPIXEL POSITIONED?
+           * Selector Bit:  10
+           * Return Bit(s): 17
+           *
+           * Functionality still needs to be added
+           */
           if ( ( args[0] & 1024 ) != 0 && exc->subpixel_positioned )
             K |= 1 << 17;
 
-          /********************************/
-          /* SYMMETRICAL SMOOTHING        */
-          /* Selector Bit:  11            */
-          /* Return Bit(s): 18            */
-          /*                              */
-          /* Functionality still needs to be added */
+          /*********************************
+           * SYMMETRICAL SMOOTHING
+           * Selector Bit:  11
+           * Return Bit(s): 18
+           *
+           * Functionality still needs to be added
+           */
           if ( ( args[0] & 2048 ) != 0 && exc->symmetrical_smoothing )
             K |= 1 << 18;
 
-          /********************************/
-          /* GRAY CLEARTYPE               */
-          /* Selector Bit:  12            */
-          /* Return Bit(s): 19            */
-          /*                              */
-          /* Functionality still needs to be added */
+          /*********************************
+           * GRAY CLEARTYPE
+           * Selector Bit:  12
+           * Return Bit(s): 19
+           *
+           * Functionality still needs to be added
+           */
           if ( ( args[0] & 4096 ) != 0 && exc->gray_cleartype )
             K |= 1 << 19;
         }
       }
     }
@@ -7535,20 +7652,20 @@
   }
 
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GETVARIATION[]: get normalized variation (blend) coordinates          */
-  /* Opcode range: 0x91                                                    */
-  /* Stack:        --> f2.14...                                            */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED!  There is no official documentation from Apple for */
-  /*      this bytecode instruction.  Active only if a font has GX         */
-  /*      variation axes.                                                  */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GETVARIATION[]: get normalized variation (blend) coordinates
+   * Opcode range: 0x91
+   * Stack:        --> f2.14...
+   *
+   * XXX: UNDOCUMENTED!  There is no official documentation from Apple for
+   *      this bytecode instruction.  Active only if a font has GX
+   *      variation axes.
+   */
   static void
   Ins_GETVARIATION( TT_ExecContext  exc,
                     FT_Long*        args )
   {
     FT_UInt    num_axes = exc->face->blend->num_axis;
@@ -7574,19 +7691,19 @@
         args[i] = 0;
     }
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* GETDATA[]:    no idea what this is good for                           */
-  /* Opcode range: 0x92                                                    */
-  /* Stack:        --> 17                                                  */
-  /*                                                                       */
-  /* XXX: UNDOCUMENTED!  There is no documentation from Apple for this     */
-  /*      very weird bytecode instruction.                                 */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * GETDATA[]:    no idea what this is good for
+   * Opcode range: 0x92
+   * Stack:        --> 17
+   *
+   * XXX: UNDOCUMENTED!  There is no documentation from Apple for this
+   *      very weird bytecode instruction.
+   */
   static void
   Ins_GETDATA( FT_Long*  args )
   {
     args[0] = 17;
   }
@@ -7630,38 +7747,38 @@
 
     exc->error = FT_THROW( Invalid_Opcode );
   }
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* RUN                                                                   */
-  /*                                                                       */
-  /*  This function executes a run of opcodes.  It will exit in the        */
-  /*  following cases:                                                     */
-  /*                                                                       */
-  /*  - Errors (in which case it returns FALSE).                           */
-  /*                                                                       */
-  /*  - Reaching the end of the main code range (returns TRUE).            */
-  /*    Reaching the end of a code range within a function call is an      */
-  /*    error.                                                             */
-  /*                                                                       */
-  /*  - After executing one single opcode, if the flag `Instruction_Trap'  */
-  /*    is set to TRUE (returns TRUE).                                     */
-  /*                                                                       */
-  /*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
-  /*  an instruction trap or a normal termination.                         */
-  /*                                                                       */
-  /*                                                                       */
-  /*  Note: The documented DEBUG opcode pops a value from the stack.  This */
-  /*        behaviour is unsupported; here a DEBUG opcode is always an     */
-  /*        error.                                                         */
-  /*                                                                       */
-  /*                                                                       */
-  /* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
-  /*                                                                       */
-  /*************************************************************************/
+  /**************************************************************************
+   *
+   * RUN
+   *
+   * This function executes a run of opcodes.  It will exit in the
+   * following cases:
+   *
+   * - Errors (in which case it returns FALSE).
+   *
+   * - Reaching the end of the main code range (returns TRUE).
+   *   Reaching the end of a code range within a function call is an
+   *   error.
+   *
+   * - After executing one single opcode, if the flag `Instruction_Trap'
+   *   is set to TRUE (returns TRUE).
+   *
+   * On exit with TRUE, test IP < CodeSize to know whether it comes from
+   * an instruction trap or a normal termination.
+   *
+   *
+   * Note: The documented DEBUG opcode pops a value from the stack.  This
+   *       behaviour is unsupported; here a DEBUG opcode is always an
+   *       error.
+   *
+   *
+   * THIS IS THE INTERPRETER'S MAIN LOOP.
+   *
+   */
 
 
   /* documentation is in ttinterp.h */
 
   FT_EXPORT_DEF( FT_Error )
@@ -7689,20 +7806,20 @@
     exc->iup_called = FALSE;
 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
 
 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
     /*
-     *  Toggle backward compatibility according to what font wants, except
-     *  when
+     * Toggle backward compatibility according to what font wants, except
+     * when
      *
-     *  1) we have a `tricky' font that heavily relies on the interpreter to
-     *     render glyphs correctly, for example DFKai-SB, or
-     *  2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.
+     * 1) we have a `tricky' font that heavily relies on the interpreter to
+     *    render glyphs correctly, for example DFKai-SB, or
+     * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.
      *
-     *  In those cases, backward compatibility needs to be turned off to get
-     *  correct rendering.  The rendering is then completely up to the
-     *  font's programming.
+     * In those cases, backward compatibility needs to be turned off to get
+     * correct rendering.  The rendering is then completely up to the
+     * font's programming.
      *
      */
     if ( SUBPIXEL_HINTING_MINIMAL          &&
          exc->subpixel_hinting_lean        &&
          !FT_IS_TRICKY( &exc->face->root ) )
@@ -7799,11 +7916,11 @@
 
         /* if tracing level is 7, show current code position */
         /* and the first few stack elements also             */
         FT_TRACE6(( "  " ));
         FT_TRACE7(( "%06d ", exc->IP ));
-        FT_TRACE6(( opcode_name[exc->opcode] + 2 ));
+        FT_TRACE6(( "%s", opcode_name[exc->opcode] + 2 ));
         FT_TRACE7(( "%*s", *opcode_name[exc->opcode] == 'A'
                               ? 2
                               : 12 - ( *opcode_name[exc->opcode] - '0' ),
                               "#" ));
         for ( n = 1; n <= cnt; n++ )

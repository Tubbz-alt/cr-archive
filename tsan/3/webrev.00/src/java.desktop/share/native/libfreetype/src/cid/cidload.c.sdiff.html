<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/cid/cidload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="cidgload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cidload.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/cid/cidload.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  cidload.c                                                              */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    CID-keyed Type1 font loader (body).                                  */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_CONFIG_CONFIG_H
 22 #include FT_MULTIPLE_MASTERS_H
 23 #include FT_INTERNAL_TYPE1_TYPES_H

 24 
 25 #include &quot;cidload.h&quot;
 26 
 27 #include &quot;ciderrs.h&quot;
 28 
 29 
<span class="line-modified"> 30   /*************************************************************************/</span>
<span class="line-modified"> 31   /*                                                                       */</span>
<span class="line-modified"> 32   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 33   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 34   /* messages during execution.                                            */</span>
<span class="line-modified"> 35   /*                                                                       */</span>
 36 #undef  FT_COMPONENT
<span class="line-modified"> 37 #define FT_COMPONENT  trace_cidload</span>
 38 
 39 
 40   /* read a single offset */
 41   FT_LOCAL_DEF( FT_ULong )
 42   cid_get_offset( FT_Byte*  *start,
 43                   FT_Byte    offsize )
 44   {
 45     FT_ULong  result;
 46     FT_Byte*  p = *start;
 47 
 48 
 49     for ( result = 0; offsize &gt; 0; offsize-- )
 50     {
 51       result &lt;&lt;= 8;
 52       result  |= *p++;
 53     }
 54 
 55     *start = p;
 56     return result;
 57   }
</pre>
<hr />
<pre>
 64   /*****                                                               *****/
 65   /*************************************************************************/
 66   /*************************************************************************/
 67 
 68 
 69   static FT_Error
 70   cid_load_keyword( CID_Face        face,
 71                     CID_Loader*     loader,
 72                     const T1_Field  keyword )
 73   {
 74     FT_Error      error;
 75     CID_Parser*   parser = &amp;loader-&gt;parser;
 76     FT_Byte*      object;
 77     void*         dummy_object;
 78     CID_FaceInfo  cid = &amp;face-&gt;cid;
 79 
 80 
 81     /* if the keyword has a dedicated callback, call it */
 82     if ( keyword-&gt;type == T1_FIELD_TYPE_CALLBACK )
 83     {


 84       keyword-&gt;reader( (FT_Face)face, parser );
 85       error = parser-&gt;root.error;
 86       goto Exit;
 87     }
 88 
 89     /* we must now compute the address of our target object */
 90     switch ( keyword-&gt;location )
 91     {
 92     case T1_FIELD_LOCATION_CID_INFO:
 93       object = (FT_Byte*)cid;
 94       break;
 95 
 96     case T1_FIELD_LOCATION_FONT_INFO:
 97       object = (FT_Byte*)&amp;cid-&gt;font_info;
 98       break;
 99 
100     case T1_FIELD_LOCATION_FONT_EXTRA:
101       object = (FT_Byte*)&amp;face-&gt;font_extra;
102       break;
103 
</pre>
<hr />
<pre>
114         {
115           FT_ERROR(( &quot;cid_load_keyword: invalid use of `%s&#39;\n&quot;,
116                      keyword-&gt;ident ));
117           error = FT_THROW( Syntax_Error );
118           goto Exit;
119         }
120 
121         dict = cid-&gt;font_dicts + parser-&gt;num_dict;
122         switch ( keyword-&gt;location )
123         {
124         case T1_FIELD_LOCATION_PRIVATE:
125           object = (FT_Byte*)&amp;dict-&gt;private_dict;
126           break;
127 
128         default:
129           object = (FT_Byte*)dict;
130         }
131       }
132     }
133 


134     dummy_object = object;
135 
136     /* now, load the keyword data in the object&#39;s field(s) */
137     if ( keyword-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
138          keyword-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
139       error = cid_parser_load_field_table( &amp;loader-&gt;parser, keyword,
140                                            &amp;dummy_object );
141     else
142       error = cid_parser_load_field( &amp;loader-&gt;parser,
143                                      keyword, &amp;dummy_object );



144   Exit:
145     return error;
146   }
147 
148 
<span class="line-modified">149   FT_CALLBACK_DEF( FT_Error )</span>
150   cid_parse_font_matrix( CID_Face     face,
151                          CID_Parser*  parser )
152   {
153     CID_FaceDict  dict;
154     FT_Face       root = (FT_Face)&amp;face-&gt;root;
155     FT_Fixed      temp[6];
156     FT_Fixed      temp_scale;
157 
158 
159     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
160     {
161       FT_Matrix*  matrix;
162       FT_Vector*  offset;
163       FT_Int      result;
164 
165 
166       dict   = face-&gt;cid.font_dicts + parser-&gt;num_dict;
167       matrix = &amp;dict-&gt;font_matrix;
168       offset = &amp;dict-&gt;font_offset;
169 
170       /* input is scaled by 1000 to accommodate default FontMatrix */
171       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
172 
173       if ( result &lt; 6 )
<span class="line-modified">174         return FT_THROW( Invalid_File_Format );</span>











175 
176       temp_scale = FT_ABS( temp[3] );
177 
178       if ( temp_scale == 0 )
179       {
180         FT_ERROR(( &quot;cid_parse_font_matrix: invalid font matrix\n&quot; ));
<span class="line-modified">181         return FT_THROW( Invalid_File_Format );</span>
182       }
183 
184       /* atypical case */
185       if ( temp_scale != 0x10000L )
186       {
187         /* set units per EM based on FontMatrix values */
188         root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
189 
190         temp[0] = FT_DivFix( temp[0], temp_scale );
191         temp[1] = FT_DivFix( temp[1], temp_scale );
192         temp[2] = FT_DivFix( temp[2], temp_scale );
193         temp[4] = FT_DivFix( temp[4], temp_scale );
194         temp[5] = FT_DivFix( temp[5], temp_scale );
195         temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
196       }
197 
198       matrix-&gt;xx = temp[0];
199       matrix-&gt;yx = temp[1];
200       matrix-&gt;xy = temp[2];
201       matrix-&gt;yy = temp[3];
202 







203       /* note that the font offsets are expressed in integer font units */
204       offset-&gt;x  = temp[4] &gt;&gt; 16;
205       offset-&gt;y  = temp[5] &gt;&gt; 16;
206     }
207 
<span class="line-modified">208     return FT_Err_Ok;</span>

209   }
210 
211 
<span class="line-modified">212   FT_CALLBACK_DEF( FT_Error )</span>
213   parse_fd_array( CID_Face     face,
214                   CID_Parser*  parser )
215   {
216     CID_FaceInfo  cid    = &amp;face-&gt;cid;
217     FT_Memory     memory = face-&gt;root.memory;
218     FT_Stream     stream = parser-&gt;stream;
219     FT_Error      error  = FT_Err_Ok;
220     FT_Long       num_dicts;
221 
222 
223     num_dicts = cid_parser_to_int( parser );
224     if ( num_dicts &lt; 0 )
225     {
226       FT_ERROR(( &quot;parse_fd_array: invalid number of dictionaries\n&quot; ));
<span class="line-removed">227       error = FT_THROW( Invalid_File_Format );</span>
228       goto Exit;
229     }
230 


231     /*
232      * A single entry in the FDArray must (at least) contain the following
233      * structure elements.
234      *
235      *   %ADOBeginFontDict              18
236      *   X dict begin                   13
237      *     /FontMatrix [X X X X]        22
238      *     /Private X dict begin        22
239      *     end                           4
240      *   end                             4
241      *   %ADOEndFontDict                16
242      *
243      * This needs 18+13+22+22+4+4+16=99 bytes or more.  Normally, you also
244      * need a `dup X&#39; at the very beginning and a `put&#39; at the end, so a
245      * rough guess using 100 bytes as the minimum is justified.
246      */
247     if ( (FT_ULong)num_dicts &gt; stream-&gt;size / 100 )
248     {
249       FT_TRACE0(( &quot;parse_fd_array: adjusting FDArray size&quot;
250                   &quot; (from %d to %d)\n&quot;,
251                   num_dicts,
252                   stream-&gt;size / 100 ));
253       num_dicts = (FT_Long)( stream-&gt;size / 100 );
254     }
255 
256     if ( !cid-&gt;font_dicts )
257     {
258       FT_Int  n;
259 
260 
261       if ( FT_NEW_ARRAY( cid-&gt;font_dicts, num_dicts ) )
262         goto Exit;
263 
264       cid-&gt;num_dicts = num_dicts;
265 
<span class="line-modified">266       /* don&#39;t forget to set a few defaults */</span>
267       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
268       {
269         CID_FaceDict  dict = cid-&gt;font_dicts + n;
270 
271 
<span class="line-modified">272         /* default value for lenIV */</span>
<span class="line-modified">273         dict-&gt;private_dict.lenIV = 4;</span>




274       }
275     }
276 
277   Exit:
<span class="line-modified">278     return error;</span>
279   }
280 
281 
<span class="line-modified">282   /* by mistake, `expansion_factor&#39; appears both in PS_PrivateRec */</span>
283   /* and CID_FaceDictRec (both are public header files and can&#39;t  */
<span class="line-modified">284   /* changed); we simply copy the value                           */</span>
285 
<span class="line-modified">286   FT_CALLBACK_DEF( FT_Error )</span>
287   parse_expansion_factor( CID_Face     face,
288                           CID_Parser*  parser )
289   {
290     CID_FaceDict  dict;
291 
292 
293     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
294     {
295       dict = face-&gt;cid.font_dicts + parser-&gt;num_dict;
296 
297       dict-&gt;expansion_factor              = cid_parser_to_fixed( parser, 0 );
298       dict-&gt;private_dict.expansion_factor = dict-&gt;expansion_factor;






























299     }




300 
<span class="line-modified">301     return FT_Err_Ok;</span>
302   }
303 
304 
305   static
306   const T1_FieldRec  cid_field_records[] =
307   {
308 
309 #include &quot;cidtoken.h&quot;
310 
311     T1_FIELD_CALLBACK( &quot;FDArray&quot;,         parse_fd_array, 0 )
312     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,      cid_parse_font_matrix, 0 )
313     T1_FIELD_CALLBACK( &quot;ExpansionFactor&quot;, parse_expansion_factor, 0 )

314 
315     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
316   };
317 
318 
319   static FT_Error
320   cid_parse_dict( CID_Face     face,
321                   CID_Loader*  loader,
322                   FT_Byte*     base,
323                   FT_ULong     size )
324   {
325     CID_Parser*  parser = &amp;loader-&gt;parser;
326 
327 
328     parser-&gt;root.cursor = base;
329     parser-&gt;root.limit  = base + size;
330     parser-&gt;root.error  = FT_Err_Ok;
331 
332     {
333       FT_Byte*  cur   = base;
</pre>
<hr />
<pre>
339         FT_Byte*  newlimit;
340 
341 
342         parser-&gt;root.cursor = cur;
343         cid_parser_skip_spaces( parser );
344 
345         if ( parser-&gt;root.cursor &gt;= limit )
346           newlimit = limit - 1 - 17;
347         else
348           newlimit = parser-&gt;root.cursor - 17;
349 
350         /* look for `%ADOBeginFontDict&#39; */
351         for ( ; cur &lt; newlimit; cur++ )
352         {
353           if ( *cur == &#39;%&#39;                                            &amp;&amp;
354                ft_strncmp( (char*)cur, &quot;%ADOBeginFontDict&quot;, 17 ) == 0 )
355           {
356             /* if /FDArray was found, then cid-&gt;num_dicts is &gt; 0, and */
357             /* we can start increasing parser-&gt;num_dict               */
358             if ( face-&gt;cid.num_dicts &gt; 0 )

359               parser-&gt;num_dict++;








360           }
361         }
362 
363         cur = parser-&gt;root.cursor;
364         /* no error can occur in cid_parser_skip_spaces */
365         if ( cur &gt;= limit )
366           break;
367 
368         cid_parser_skip_PS_token( parser );
369         if ( parser-&gt;root.cursor &gt;= limit || parser-&gt;root.error )
370           break;
371 
372         /* look for immediates */
373         if ( *cur == &#39;/&#39; &amp;&amp; cur + 2 &lt; limit )
374         {
375           FT_UInt  len;
376 
377 
378           cur++;
379           len = (FT_UInt)( parser-&gt;root.cursor - cur );
</pre>
<hr />
<pre>
740            FT_SET_ERROR( cid_hex_to_binary( face-&gt;binary_data,
741                                             parser-&gt;binary_length,
742                                             parser-&gt;data_offset,
743                                             face ) )               )
744         goto Exit;
745 
746       FT_Stream_OpenMemory( face-&gt;cid_stream,
747                             face-&gt;binary_data, parser-&gt;binary_length );
748       cid-&gt;data_offset = 0;
749     }
750     else
751     {
752       *face-&gt;cid_stream = *face-&gt;root.stream;
753       cid-&gt;data_offset  = loader.parser.data_offset;
754     }
755 
756     /* sanity tests */
757 
758     if ( cid-&gt;fd_bytes &lt; 0 || cid-&gt;gd_bytes &lt; 1 )
759     {
<span class="line-modified">760       FT_ERROR(( &quot;cid_parse_dict:&quot;</span>
761                  &quot; Invalid `FDBytes&#39; or `GDBytes&#39; value\n&quot; ));
762       error = FT_THROW( Invalid_File_Format );
763       goto Exit;
764     }
765 
766     /* allow at most 32bit offsets */
767     if ( cid-&gt;fd_bytes &gt; 4 || cid-&gt;gd_bytes &gt; 4 )
768     {
<span class="line-modified">769       FT_ERROR(( &quot;cid_parse_dict:&quot;</span>
770                  &quot; Values of `FDBytes&#39; or `GDBytes&#39; larger than 4\n&quot;
771                  &quot;               &quot;
772                  &quot; are not supported\n&quot; ));
773       error = FT_THROW( Invalid_File_Format );
774       goto Exit;
775     }
776 
777     binary_length = face-&gt;cid_stream-&gt;size - cid-&gt;data_offset;
778     entry_len     = (FT_ULong)( cid-&gt;fd_bytes + cid-&gt;gd_bytes );
779 
780     for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
781     {
782       CID_FaceDict  dict = cid-&gt;font_dicts + n;
783 
784 



















785       if ( dict-&gt;sd_bytes &lt; 0                        ||
786            ( dict-&gt;num_subrs &amp;&amp; dict-&gt;sd_bytes &lt; 1 ) )
787       {
<span class="line-modified">788         FT_ERROR(( &quot;cid_parse_dict: Invalid `SDBytes&#39; value\n&quot; ));</span>
789         error = FT_THROW( Invalid_File_Format );
790         goto Exit;
791       }
792 
793       if ( dict-&gt;sd_bytes &gt; 4 )
794       {
<span class="line-modified">795         FT_ERROR(( &quot;cid_parse_dict:&quot;</span>
796                    &quot; Values of `SDBytes&#39; larger than 4&quot;
797                    &quot; are not supported\n&quot; ));
798         error = FT_THROW( Invalid_File_Format );
799         goto Exit;
800       }
801 
802       if ( dict-&gt;subrmap_offset &gt; binary_length )
803       {
<span class="line-modified">804         FT_ERROR(( &quot;cid_parse_dict: Invalid `SubrMapOffset&#39; value\n&quot; ));</span>
805         error = FT_THROW( Invalid_File_Format );
806         goto Exit;
807       }
808 
809       /* `num_subrs&#39; is scanned as a signed integer */
810       if ( (FT_Int)dict-&gt;num_subrs &lt; 0                                     ||
811            ( dict-&gt;sd_bytes                                              &amp;&amp;
812              dict-&gt;num_subrs &gt; ( binary_length - dict-&gt;subrmap_offset ) /
813                                  (FT_UInt)dict-&gt;sd_bytes                 ) )
814       {
<span class="line-modified">815         FT_ERROR(( &quot;cid_parse_dict: Invalid `SubrCount&#39; value\n&quot; ));</span>
816         error = FT_THROW( Invalid_File_Format );
817         goto Exit;
818       }
819     }
820 
821     if ( cid-&gt;cidmap_offset &gt; binary_length )
822     {
<span class="line-modified">823       FT_ERROR(( &quot;cid_parse_dict: Invalid `CIDMapOffset&#39; value\n&quot; ));</span>
824       error = FT_THROW( Invalid_File_Format );
825       goto Exit;
826     }
827 
828     if ( entry_len                                            &amp;&amp;
829          cid-&gt;cid_count &gt;
830            ( binary_length - cid-&gt;cidmap_offset ) / entry_len )
831     {
<span class="line-modified">832       FT_ERROR(( &quot;cid_parse_dict: Invalid `CIDCount&#39; value\n&quot; ));</span>
833       error = FT_THROW( Invalid_File_Format );
834       goto Exit;
835     }
836 
837     /* we can now safely proceed */
838     error = cid_read_subrs( face );
839 
840   Exit:
841     cid_done_loader( &amp;loader );
842     return error;
843   }
844 
845 
846 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * cidload.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   CID-keyed Type1 font loader (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_CONFIG_CONFIG_H
 22 #include FT_MULTIPLE_MASTERS_H
 23 #include FT_INTERNAL_TYPE1_TYPES_H
<span class="line-added"> 24 #include FT_INTERNAL_POSTSCRIPT_AUX_H</span>
 25 
 26 #include &quot;cidload.h&quot;
 27 
 28 #include &quot;ciderrs.h&quot;
 29 
 30 
<span class="line-modified"> 31   /**************************************************************************</span>
<span class="line-modified"> 32    *</span>
<span class="line-modified"> 33    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 34    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 35    * messages during execution.</span>
<span class="line-modified"> 36    */</span>
 37 #undef  FT_COMPONENT
<span class="line-modified"> 38 #define FT_COMPONENT  cidload</span>
 39 
 40 
 41   /* read a single offset */
 42   FT_LOCAL_DEF( FT_ULong )
 43   cid_get_offset( FT_Byte*  *start,
 44                   FT_Byte    offsize )
 45   {
 46     FT_ULong  result;
 47     FT_Byte*  p = *start;
 48 
 49 
 50     for ( result = 0; offsize &gt; 0; offsize-- )
 51     {
 52       result &lt;&lt;= 8;
 53       result  |= *p++;
 54     }
 55 
 56     *start = p;
 57     return result;
 58   }
</pre>
<hr />
<pre>
 65   /*****                                                               *****/
 66   /*************************************************************************/
 67   /*************************************************************************/
 68 
 69 
 70   static FT_Error
 71   cid_load_keyword( CID_Face        face,
 72                     CID_Loader*     loader,
 73                     const T1_Field  keyword )
 74   {
 75     FT_Error      error;
 76     CID_Parser*   parser = &amp;loader-&gt;parser;
 77     FT_Byte*      object;
 78     void*         dummy_object;
 79     CID_FaceInfo  cid = &amp;face-&gt;cid;
 80 
 81 
 82     /* if the keyword has a dedicated callback, call it */
 83     if ( keyword-&gt;type == T1_FIELD_TYPE_CALLBACK )
 84     {
<span class="line-added"> 85       FT_TRACE4(( &quot;  %s&quot;, keyword-&gt;ident ));</span>
<span class="line-added"> 86 </span>
 87       keyword-&gt;reader( (FT_Face)face, parser );
 88       error = parser-&gt;root.error;
 89       goto Exit;
 90     }
 91 
 92     /* we must now compute the address of our target object */
 93     switch ( keyword-&gt;location )
 94     {
 95     case T1_FIELD_LOCATION_CID_INFO:
 96       object = (FT_Byte*)cid;
 97       break;
 98 
 99     case T1_FIELD_LOCATION_FONT_INFO:
100       object = (FT_Byte*)&amp;cid-&gt;font_info;
101       break;
102 
103     case T1_FIELD_LOCATION_FONT_EXTRA:
104       object = (FT_Byte*)&amp;face-&gt;font_extra;
105       break;
106 
</pre>
<hr />
<pre>
117         {
118           FT_ERROR(( &quot;cid_load_keyword: invalid use of `%s&#39;\n&quot;,
119                      keyword-&gt;ident ));
120           error = FT_THROW( Syntax_Error );
121           goto Exit;
122         }
123 
124         dict = cid-&gt;font_dicts + parser-&gt;num_dict;
125         switch ( keyword-&gt;location )
126         {
127         case T1_FIELD_LOCATION_PRIVATE:
128           object = (FT_Byte*)&amp;dict-&gt;private_dict;
129           break;
130 
131         default:
132           object = (FT_Byte*)dict;
133         }
134       }
135     }
136 
<span class="line-added">137     FT_TRACE4(( &quot;  %s&quot;, keyword-&gt;ident ));</span>
<span class="line-added">138 </span>
139     dummy_object = object;
140 
141     /* now, load the keyword data in the object&#39;s field(s) */
142     if ( keyword-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
143          keyword-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
144       error = cid_parser_load_field_table( &amp;loader-&gt;parser, keyword,
145                                            &amp;dummy_object );
146     else
147       error = cid_parser_load_field( &amp;loader-&gt;parser,
148                                      keyword, &amp;dummy_object );
<span class="line-added">149 </span>
<span class="line-added">150     FT_TRACE4(( &quot;\n&quot; ));</span>
<span class="line-added">151 </span>
152   Exit:
153     return error;
154   }
155 
156 
<span class="line-modified">157   FT_CALLBACK_DEF( void )</span>
158   cid_parse_font_matrix( CID_Face     face,
159                          CID_Parser*  parser )
160   {
161     CID_FaceDict  dict;
162     FT_Face       root = (FT_Face)&amp;face-&gt;root;
163     FT_Fixed      temp[6];
164     FT_Fixed      temp_scale;
165 
166 
167     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
168     {
169       FT_Matrix*  matrix;
170       FT_Vector*  offset;
171       FT_Int      result;
172 
173 
174       dict   = face-&gt;cid.font_dicts + parser-&gt;num_dict;
175       matrix = &amp;dict-&gt;font_matrix;
176       offset = &amp;dict-&gt;font_offset;
177 
178       /* input is scaled by 1000 to accommodate default FontMatrix */
179       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
180 
181       if ( result &lt; 6 )
<span class="line-modified">182       {</span>
<span class="line-added">183         FT_ERROR(( &quot;cid_parse_font_matrix: not enough matrix elements\n&quot; ));</span>
<span class="line-added">184         goto Exit;</span>
<span class="line-added">185       }</span>
<span class="line-added">186 </span>
<span class="line-added">187       FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,</span>
<span class="line-added">188                   (double)temp[0] / 65536 / 1000,</span>
<span class="line-added">189                   (double)temp[1] / 65536 / 1000,</span>
<span class="line-added">190                   (double)temp[2] / 65536 / 1000,</span>
<span class="line-added">191                   (double)temp[3] / 65536 / 1000,</span>
<span class="line-added">192                   (double)temp[4] / 65536 / 1000,</span>
<span class="line-added">193                   (double)temp[5] / 65536 / 1000 ));</span>
194 
195       temp_scale = FT_ABS( temp[3] );
196 
197       if ( temp_scale == 0 )
198       {
199         FT_ERROR(( &quot;cid_parse_font_matrix: invalid font matrix\n&quot; ));
<span class="line-modified">200         goto Exit;</span>
201       }
202 
203       /* atypical case */
204       if ( temp_scale != 0x10000L )
205       {
206         /* set units per EM based on FontMatrix values */
207         root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
208 
209         temp[0] = FT_DivFix( temp[0], temp_scale );
210         temp[1] = FT_DivFix( temp[1], temp_scale );
211         temp[2] = FT_DivFix( temp[2], temp_scale );
212         temp[4] = FT_DivFix( temp[4], temp_scale );
213         temp[5] = FT_DivFix( temp[5], temp_scale );
214         temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
215       }
216 
217       matrix-&gt;xx = temp[0];
218       matrix-&gt;yx = temp[1];
219       matrix-&gt;xy = temp[2];
220       matrix-&gt;yy = temp[3];
221 
<span class="line-added">222       if ( !FT_Matrix_Check( matrix ) )</span>
<span class="line-added">223       {</span>
<span class="line-added">224         FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));</span>
<span class="line-added">225         parser-&gt;root.error = FT_THROW( Invalid_File_Format );</span>
<span class="line-added">226         goto Exit;</span>
<span class="line-added">227       }</span>
<span class="line-added">228 </span>
229       /* note that the font offsets are expressed in integer font units */
230       offset-&gt;x  = temp[4] &gt;&gt; 16;
231       offset-&gt;y  = temp[5] &gt;&gt; 16;
232     }
233 
<span class="line-modified">234   Exit:</span>
<span class="line-added">235     return;</span>
236   }
237 
238 
<span class="line-modified">239   FT_CALLBACK_DEF( void )</span>
240   parse_fd_array( CID_Face     face,
241                   CID_Parser*  parser )
242   {
243     CID_FaceInfo  cid    = &amp;face-&gt;cid;
244     FT_Memory     memory = face-&gt;root.memory;
245     FT_Stream     stream = parser-&gt;stream;
246     FT_Error      error  = FT_Err_Ok;
247     FT_Long       num_dicts;
248 
249 
250     num_dicts = cid_parser_to_int( parser );
251     if ( num_dicts &lt; 0 )
252     {
253       FT_ERROR(( &quot;parse_fd_array: invalid number of dictionaries\n&quot; ));

254       goto Exit;
255     }
256 
<span class="line-added">257     FT_TRACE4(( &quot; %d\n&quot;, num_dicts ));</span>
<span class="line-added">258 </span>
259     /*
260      * A single entry in the FDArray must (at least) contain the following
261      * structure elements.
262      *
263      *   %ADOBeginFontDict              18
264      *   X dict begin                   13
265      *     /FontMatrix [X X X X]        22
266      *     /Private X dict begin        22
267      *     end                           4
268      *   end                             4
269      *   %ADOEndFontDict                16
270      *
271      * This needs 18+13+22+22+4+4+16=99 bytes or more.  Normally, you also
272      * need a `dup X&#39; at the very beginning and a `put&#39; at the end, so a
273      * rough guess using 100 bytes as the minimum is justified.
274      */
275     if ( (FT_ULong)num_dicts &gt; stream-&gt;size / 100 )
276     {
277       FT_TRACE0(( &quot;parse_fd_array: adjusting FDArray size&quot;
278                   &quot; (from %d to %d)\n&quot;,
279                   num_dicts,
280                   stream-&gt;size / 100 ));
281       num_dicts = (FT_Long)( stream-&gt;size / 100 );
282     }
283 
284     if ( !cid-&gt;font_dicts )
285     {
286       FT_Int  n;
287 
288 
289       if ( FT_NEW_ARRAY( cid-&gt;font_dicts, num_dicts ) )
290         goto Exit;
291 
292       cid-&gt;num_dicts = num_dicts;
293 
<span class="line-modified">294       /* set some default values (the same as for Type 1 fonts) */</span>
295       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
296       {
297         CID_FaceDict  dict = cid-&gt;font_dicts + n;
298 
299 
<span class="line-modified">300         dict-&gt;private_dict.blue_shift       = 7;</span>
<span class="line-modified">301         dict-&gt;private_dict.blue_fuzz        = 1;</span>
<span class="line-added">302         dict-&gt;private_dict.lenIV            = 4;</span>
<span class="line-added">303         dict-&gt;private_dict.expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );</span>
<span class="line-added">304         dict-&gt;private_dict.blue_scale       = (FT_Fixed)(</span>
<span class="line-added">305                                                 0.039625 * 0x10000L * 1000 );</span>
306       }
307     }
308 
309   Exit:
<span class="line-modified">310     return;</span>
311   }
312 
313 
<span class="line-modified">314   /* By mistake, `expansion_factor&#39; appears both in PS_PrivateRec */</span>
315   /* and CID_FaceDictRec (both are public header files and can&#39;t  */
<span class="line-modified">316   /* changed).  We simply copy the value.                         */</span>
317 
<span class="line-modified">318   FT_CALLBACK_DEF( void )</span>
319   parse_expansion_factor( CID_Face     face,
320                           CID_Parser*  parser )
321   {
322     CID_FaceDict  dict;
323 
324 
325     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
326     {
327       dict = face-&gt;cid.font_dicts + parser-&gt;num_dict;
328 
329       dict-&gt;expansion_factor              = cid_parser_to_fixed( parser, 0 );
330       dict-&gt;private_dict.expansion_factor = dict-&gt;expansion_factor;
<span class="line-added">331 </span>
<span class="line-added">332       FT_TRACE4(( &quot;%d\n&quot;, dict-&gt;expansion_factor ));</span>
<span class="line-added">333     }</span>
<span class="line-added">334 </span>
<span class="line-added">335     return;</span>
<span class="line-added">336   }</span>
<span class="line-added">337 </span>
<span class="line-added">338 </span>
<span class="line-added">339   /* By mistake, `CID_FaceDictRec&#39; doesn&#39;t contain a field for the */</span>
<span class="line-added">340   /* `FontName&#39; keyword.  FreeType doesn&#39;t need it, but it is nice */</span>
<span class="line-added">341   /* to catch it for producing better trace output.                */</span>
<span class="line-added">342 </span>
<span class="line-added">343   FT_CALLBACK_DEF( void )</span>
<span class="line-added">344   parse_font_name( CID_Face     face,</span>
<span class="line-added">345                    CID_Parser*  parser )</span>
<span class="line-added">346   {</span>
<span class="line-added">347 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">348     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )</span>
<span class="line-added">349     {</span>
<span class="line-added">350       T1_TokenRec  token;</span>
<span class="line-added">351       FT_UInt      len;</span>
<span class="line-added">352 </span>
<span class="line-added">353 </span>
<span class="line-added">354       cid_parser_to_token( parser, &amp;token );</span>
<span class="line-added">355 </span>
<span class="line-added">356       len = (FT_UInt)( token.limit - token.start );</span>
<span class="line-added">357       if ( len )</span>
<span class="line-added">358         FT_TRACE4(( &quot; %.*s\n&quot;, len, token.start ));</span>
<span class="line-added">359       else</span>
<span class="line-added">360         FT_TRACE4(( &quot; &lt;no value&gt;\n&quot; ));</span>
361     }
<span class="line-added">362 #else</span>
<span class="line-added">363     FT_UNUSED( face );</span>
<span class="line-added">364     FT_UNUSED( parser );</span>
<span class="line-added">365 #endif</span>
366 
<span class="line-modified">367     return;</span>
368   }
369 
370 
371   static
372   const T1_FieldRec  cid_field_records[] =
373   {
374 
375 #include &quot;cidtoken.h&quot;
376 
377     T1_FIELD_CALLBACK( &quot;FDArray&quot;,         parse_fd_array, 0 )
378     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,      cid_parse_font_matrix, 0 )
379     T1_FIELD_CALLBACK( &quot;ExpansionFactor&quot;, parse_expansion_factor, 0 )
<span class="line-added">380     T1_FIELD_CALLBACK( &quot;FontName&quot;,        parse_font_name, 0 )</span>
381 
382     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
383   };
384 
385 
386   static FT_Error
387   cid_parse_dict( CID_Face     face,
388                   CID_Loader*  loader,
389                   FT_Byte*     base,
390                   FT_ULong     size )
391   {
392     CID_Parser*  parser = &amp;loader-&gt;parser;
393 
394 
395     parser-&gt;root.cursor = base;
396     parser-&gt;root.limit  = base + size;
397     parser-&gt;root.error  = FT_Err_Ok;
398 
399     {
400       FT_Byte*  cur   = base;
</pre>
<hr />
<pre>
406         FT_Byte*  newlimit;
407 
408 
409         parser-&gt;root.cursor = cur;
410         cid_parser_skip_spaces( parser );
411 
412         if ( parser-&gt;root.cursor &gt;= limit )
413           newlimit = limit - 1 - 17;
414         else
415           newlimit = parser-&gt;root.cursor - 17;
416 
417         /* look for `%ADOBeginFontDict&#39; */
418         for ( ; cur &lt; newlimit; cur++ )
419         {
420           if ( *cur == &#39;%&#39;                                            &amp;&amp;
421                ft_strncmp( (char*)cur, &quot;%ADOBeginFontDict&quot;, 17 ) == 0 )
422           {
423             /* if /FDArray was found, then cid-&gt;num_dicts is &gt; 0, and */
424             /* we can start increasing parser-&gt;num_dict               */
425             if ( face-&gt;cid.num_dicts &gt; 0 )
<span class="line-added">426             {</span>
427               parser-&gt;num_dict++;
<span class="line-added">428 </span>
<span class="line-added">429 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">430               FT_TRACE4(( &quot; FontDict %d&quot;, parser-&gt;num_dict ));</span>
<span class="line-added">431               if ( parser-&gt;num_dict &gt; face-&gt;cid.num_dicts )</span>
<span class="line-added">432                 FT_TRACE4(( &quot; (ignored)&quot; ));</span>
<span class="line-added">433               FT_TRACE4(( &quot;\n&quot; ));</span>
<span class="line-added">434 #endif</span>
<span class="line-added">435             }</span>
436           }
437         }
438 
439         cur = parser-&gt;root.cursor;
440         /* no error can occur in cid_parser_skip_spaces */
441         if ( cur &gt;= limit )
442           break;
443 
444         cid_parser_skip_PS_token( parser );
445         if ( parser-&gt;root.cursor &gt;= limit || parser-&gt;root.error )
446           break;
447 
448         /* look for immediates */
449         if ( *cur == &#39;/&#39; &amp;&amp; cur + 2 &lt; limit )
450         {
451           FT_UInt  len;
452 
453 
454           cur++;
455           len = (FT_UInt)( parser-&gt;root.cursor - cur );
</pre>
<hr />
<pre>
816            FT_SET_ERROR( cid_hex_to_binary( face-&gt;binary_data,
817                                             parser-&gt;binary_length,
818                                             parser-&gt;data_offset,
819                                             face ) )               )
820         goto Exit;
821 
822       FT_Stream_OpenMemory( face-&gt;cid_stream,
823                             face-&gt;binary_data, parser-&gt;binary_length );
824       cid-&gt;data_offset = 0;
825     }
826     else
827     {
828       *face-&gt;cid_stream = *face-&gt;root.stream;
829       cid-&gt;data_offset  = loader.parser.data_offset;
830     }
831 
832     /* sanity tests */
833 
834     if ( cid-&gt;fd_bytes &lt; 0 || cid-&gt;gd_bytes &lt; 1 )
835     {
<span class="line-modified">836       FT_ERROR(( &quot;cid_face_open:&quot;</span>
837                  &quot; Invalid `FDBytes&#39; or `GDBytes&#39; value\n&quot; ));
838       error = FT_THROW( Invalid_File_Format );
839       goto Exit;
840     }
841 
842     /* allow at most 32bit offsets */
843     if ( cid-&gt;fd_bytes &gt; 4 || cid-&gt;gd_bytes &gt; 4 )
844     {
<span class="line-modified">845       FT_ERROR(( &quot;cid_face_open:&quot;</span>
846                  &quot; Values of `FDBytes&#39; or `GDBytes&#39; larger than 4\n&quot;
847                  &quot;               &quot;
848                  &quot; are not supported\n&quot; ));
849       error = FT_THROW( Invalid_File_Format );
850       goto Exit;
851     }
852 
853     binary_length = face-&gt;cid_stream-&gt;size - cid-&gt;data_offset;
854     entry_len     = (FT_ULong)( cid-&gt;fd_bytes + cid-&gt;gd_bytes );
855 
856     for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
857     {
858       CID_FaceDict  dict = cid-&gt;font_dicts + n;
859 
860 
<span class="line-added">861       /* the upper limits are ad-hoc values */</span>
<span class="line-added">862       if ( dict-&gt;private_dict.blue_shift &gt; 1000 ||</span>
<span class="line-added">863            dict-&gt;private_dict.blue_shift &lt; 0    )</span>
<span class="line-added">864       {</span>
<span class="line-added">865         FT_TRACE2(( &quot;cid_face_open:&quot;</span>
<span class="line-added">866                     &quot; setting unlikely BlueShift value %d to default (7)\n&quot;,</span>
<span class="line-added">867                     dict-&gt;private_dict.blue_shift ));</span>
<span class="line-added">868         dict-&gt;private_dict.blue_shift = 7;</span>
<span class="line-added">869       }</span>
<span class="line-added">870 </span>
<span class="line-added">871       if ( dict-&gt;private_dict.blue_fuzz &gt; 1000 ||</span>
<span class="line-added">872            dict-&gt;private_dict.blue_fuzz &lt; 0    )</span>
<span class="line-added">873       {</span>
<span class="line-added">874         FT_TRACE2(( &quot;cid_face_open:&quot;</span>
<span class="line-added">875                     &quot; setting unlikely BlueFuzz value %d to default (1)\n&quot;,</span>
<span class="line-added">876                     dict-&gt;private_dict.blue_fuzz ));</span>
<span class="line-added">877         dict-&gt;private_dict.blue_fuzz = 1;</span>
<span class="line-added">878       }</span>
<span class="line-added">879 </span>
880       if ( dict-&gt;sd_bytes &lt; 0                        ||
881            ( dict-&gt;num_subrs &amp;&amp; dict-&gt;sd_bytes &lt; 1 ) )
882       {
<span class="line-modified">883         FT_ERROR(( &quot;cid_face_open: Invalid `SDBytes&#39; value\n&quot; ));</span>
884         error = FT_THROW( Invalid_File_Format );
885         goto Exit;
886       }
887 
888       if ( dict-&gt;sd_bytes &gt; 4 )
889       {
<span class="line-modified">890         FT_ERROR(( &quot;cid_face_open:&quot;</span>
891                    &quot; Values of `SDBytes&#39; larger than 4&quot;
892                    &quot; are not supported\n&quot; ));
893         error = FT_THROW( Invalid_File_Format );
894         goto Exit;
895       }
896 
897       if ( dict-&gt;subrmap_offset &gt; binary_length )
898       {
<span class="line-modified">899         FT_ERROR(( &quot;cid_face_open: Invalid `SubrMapOffset&#39; value\n&quot; ));</span>
900         error = FT_THROW( Invalid_File_Format );
901         goto Exit;
902       }
903 
904       /* `num_subrs&#39; is scanned as a signed integer */
905       if ( (FT_Int)dict-&gt;num_subrs &lt; 0                                     ||
906            ( dict-&gt;sd_bytes                                              &amp;&amp;
907              dict-&gt;num_subrs &gt; ( binary_length - dict-&gt;subrmap_offset ) /
908                                  (FT_UInt)dict-&gt;sd_bytes                 ) )
909       {
<span class="line-modified">910         FT_ERROR(( &quot;cid_face_open: Invalid `SubrCount&#39; value\n&quot; ));</span>
911         error = FT_THROW( Invalid_File_Format );
912         goto Exit;
913       }
914     }
915 
916     if ( cid-&gt;cidmap_offset &gt; binary_length )
917     {
<span class="line-modified">918       FT_ERROR(( &quot;cid_face_open: Invalid `CIDMapOffset&#39; value\n&quot; ));</span>
919       error = FT_THROW( Invalid_File_Format );
920       goto Exit;
921     }
922 
923     if ( entry_len                                            &amp;&amp;
924          cid-&gt;cid_count &gt;
925            ( binary_length - cid-&gt;cidmap_offset ) / entry_len )
926     {
<span class="line-modified">927       FT_ERROR(( &quot;cid_face_open: Invalid `CIDCount&#39; value\n&quot; ));</span>
928       error = FT_THROW( Invalid_File_Format );
929       goto Exit;
930     }
931 
932     /* we can now safely proceed */
933     error = cid_read_subrs( face );
934 
935   Exit:
936     cid_done_loader( &amp;loader );
937     return error;
938   }
939 
940 
941 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="cidgload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cidload.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
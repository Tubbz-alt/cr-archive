<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftlcdfil.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftinit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftmac.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftlcdfil.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftlcdfil.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    FreeType API for color filtering of subpixel bitmap glyphs (body).   */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2006-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 
 22 #include FT_LCD_FILTER_H
 23 #include FT_IMAGE_H
 24 #include FT_INTERNAL_OBJECTS_H
 25 
 26 
 27 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 28 
 29 /* define USE_LEGACY to implement the legacy filter */
 30 #define  USE_LEGACY
 31 
 32 #define FT_SHIFTCLAMP( x )  ( x &gt;&gt;= 8, (FT_Byte)( x &gt; 255 ? 255 : x ) )
 33 
 34 
 35   /* add padding according to filter weights */
 36   FT_BASE_DEF (void)
<span class="line-modified"> 37   ft_lcd_padding( FT_Pos*       Min,</span>
<span class="line-modified"> 38                   FT_Pos*       Max,</span>
<span class="line-modified"> 39                   FT_GlyphSlot  slot )</span>
 40   {
 41     FT_Byte*                 lcd_weights;
 42     FT_Bitmap_LcdFilterFunc  lcd_filter_func;
 43 
 44 
 45     /* Per-face LCD filtering takes priority if set up. */
 46     if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
 47     {
 48       lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
 49       lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
 50     }
 51     else
 52     {
 53       lcd_weights     = slot-&gt;library-&gt;lcd_weights;
 54       lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
 55     }
 56 
 57     if ( lcd_filter_func == ft_lcd_filter_fir )
 58     {
<span class="line-modified"> 59       *Min -= lcd_weights[0] ? 43 :</span>
<span class="line-modified"> 60               lcd_weights[1] ? 22 : 0;</span>
<span class="line-modified"> 61       *Max += lcd_weights[4] ? 43 :</span>
<span class="line-modified"> 62               lcd_weights[3] ? 22 : 0;</span>










 63     }
 64   }
 65 
 66 
 67   /* FIR filter used by the default and light filters */
 68   FT_BASE_DEF( void )
 69   ft_lcd_filter_fir( FT_Bitmap*           bitmap,
<span class="line-removed"> 70                      FT_Render_Mode       mode,</span>
 71                      FT_LcdFiveTapFilter  weights )
 72   {
 73     FT_UInt   width  = (FT_UInt)bitmap-&gt;width;
 74     FT_UInt   height = (FT_UInt)bitmap-&gt;rows;
 75     FT_Int    pitch  = bitmap-&gt;pitch;
 76     FT_Byte*  origin = bitmap-&gt;buffer;

 77 
 78 
 79     /* take care of bitmap flow */
 80     if ( pitch &gt; 0 &amp;&amp; height &gt; 0 )
 81       origin += pitch * (FT_Int)( height - 1 );
 82 
 83     /* horizontal in-place FIR filter */
<span class="line-modified"> 84     if ( mode == FT_RENDER_MODE_LCD &amp;&amp; width &gt;= 2 )</span>
 85     {
 86       FT_Byte*  line = origin;
 87 
 88 
 89       /* `fir&#39; must be at least 32 bit wide, since the sum of */
 90       /* the values in `weights&#39; can exceed 0xFF              */
 91 
 92       for ( ; height &gt; 0; height--, line -= pitch )
 93       {
 94         FT_UInt  fir[5];
 95         FT_UInt  val, xx;
 96 
 97 
 98         val    = line[0];
 99         fir[2] = weights[2] * val;
100         fir[3] = weights[3] * val;
101         fir[4] = weights[4] * val;
102 
103         val    = line[1];
104         fir[1] = fir[2] + weights[1] * val;
</pre>
<hr />
<pre>
107         fir[4] =          weights[4] * val;
108 
109         for ( xx = 2; xx &lt; width; xx++ )
110         {
111           val    = line[xx];
112           fir[0] = fir[1] + weights[0] * val;
113           fir[1] = fir[2] + weights[1] * val;
114           fir[2] = fir[3] + weights[2] * val;
115           fir[3] = fir[4] + weights[3] * val;
116           fir[4] =          weights[4] * val;
117 
118           line[xx - 2] = FT_SHIFTCLAMP( fir[0] );
119         }
120 
121         line[xx - 2] = FT_SHIFTCLAMP( fir[1] );
122         line[xx - 1] = FT_SHIFTCLAMP( fir[2] );
123       }
124     }
125 
126     /* vertical in-place FIR filter */
<span class="line-modified">127     else if ( mode == FT_RENDER_MODE_LCD_V &amp;&amp; height &gt;= 2 )</span>
128     {
129       FT_Byte*  column = origin;
130 
131 
132       for ( ; width &gt; 0; width--, column++ )
133       {
134         FT_Byte*  col = column;
135         FT_UInt   fir[5];
136         FT_UInt   val, yy;
137 
138 
139         val    = col[0];
140         fir[2] = weights[2] * val;
141         fir[3] = weights[3] * val;
142         fir[4] = weights[4] * val;
143         col   -= pitch;
144 
145         val    = col[0];
146         fir[1] = fir[2] + weights[1] * val;
147         fir[2] = fir[3] + weights[2] * val;
</pre>
<hr />
<pre>
156           fir[1] = fir[2] + weights[1] * val;
157           fir[2] = fir[3] + weights[2] * val;
158           fir[3] = fir[4] + weights[3] * val;
159           fir[4] =          weights[4] * val;
160 
161           col[pitch * 2]  = FT_SHIFTCLAMP( fir[0] );
162         }
163 
164         col[pitch * 2]  = FT_SHIFTCLAMP( fir[1] );
165         col[pitch]      = FT_SHIFTCLAMP( fir[2] );
166       }
167     }
168   }
169 
170 
171 #ifdef USE_LEGACY
172 
173   /* intra-pixel filter used by the legacy filter */
174   static void
175   _ft_lcd_filter_legacy( FT_Bitmap*      bitmap,
<span class="line-removed">176                          FT_Render_Mode  mode,</span>
177                          FT_Byte*        weights )
178   {
179     FT_UInt   width  = (FT_UInt)bitmap-&gt;width;
180     FT_UInt   height = (FT_UInt)bitmap-&gt;rows;
181     FT_Int    pitch  = bitmap-&gt;pitch;
182     FT_Byte*  origin = bitmap-&gt;buffer;

183 
184     static const unsigned int  filters[3][3] =
185     {
186       { 65538 * 9/13, 65538 * 1/6, 65538 * 1/13 },
187       { 65538 * 3/13, 65538 * 4/6, 65538 * 3/13 },
188       { 65538 * 1/13, 65538 * 1/6, 65538 * 9/13 }
189     };
190 
191     FT_UNUSED( weights );
192 
193 
194     /* take care of bitmap flow */
195     if ( pitch &gt; 0 &amp;&amp; height &gt; 0 )
196       origin += pitch * (FT_Int)( height - 1 );
197 
198     /* horizontal in-place intra-pixel filter */
<span class="line-modified">199     if ( mode == FT_RENDER_MODE_LCD &amp;&amp; width &gt;= 3 )</span>
200     {
201       FT_Byte*  line = origin;
202 
203 
204       for ( ; height &gt; 0; height--, line -= pitch )
205       {
206         FT_UInt  xx;
207 
208 
209         for ( xx = 0; xx &lt; width; xx += 3 )
210         {
211           FT_UInt  r, g, b;
212           FT_UInt  p;
213 
214 
215           p  = line[xx];
216           r  = filters[0][0] * p;
217           g  = filters[0][1] * p;
218           b  = filters[0][2] * p;
219 
220           p  = line[xx + 1];
221           r += filters[1][0] * p;
222           g += filters[1][1] * p;
223           b += filters[1][2] * p;
224 
225           p  = line[xx + 2];
226           r += filters[2][0] * p;
227           g += filters[2][1] * p;
228           b += filters[2][2] * p;
229 
230           line[xx]     = (FT_Byte)( r / 65536 );
231           line[xx + 1] = (FT_Byte)( g / 65536 );
232           line[xx + 2] = (FT_Byte)( b / 65536 );
233         }
234       }
235     }
<span class="line-modified">236     else if ( mode == FT_RENDER_MODE_LCD_V &amp;&amp; height &gt;= 3 )</span>
237     {
238       FT_Byte*  column = origin;
239 
240 
241       for ( ; width &gt; 0; width--, column++ )
242       {
243         FT_Byte*  col = column - 2 * pitch;
244 
245 
246         for ( ; height &gt; 0; height -= 3, col -= 3 * pitch )
247         {
248           FT_UInt  r, g, b;
249           FT_UInt  p;
250 
251 
252           p  = col[0];
253           r  = filters[0][0] * p;
254           g  = filters[0][1] * p;
255           b  = filters[0][2] * p;
256 
</pre>
<hr />
<pre>
258           r += filters[1][0] * p;
259           g += filters[1][1] * p;
260           b += filters[1][2] * p;
261 
262           p  = col[pitch * 2];
263           r += filters[2][0] * p;
264           g += filters[2][1] * p;
265           b += filters[2][2] * p;
266 
267           col[0]         = (FT_Byte)( r / 65536 );
268           col[pitch]     = (FT_Byte)( g / 65536 );
269           col[pitch * 2] = (FT_Byte)( b / 65536 );
270         }
271       }
272     }
273   }
274 
275 #endif /* USE_LEGACY */
276 
277 


278   FT_EXPORT_DEF( FT_Error )
279   FT_Library_SetLcdFilterWeights( FT_Library      library,
280                                   unsigned char  *weights )
281   {
282     if ( !library )
283       return FT_THROW( Invalid_Library_Handle );
284 
285     if ( !weights )
286       return FT_THROW( Invalid_Argument );
287 
288     ft_memcpy( library-&gt;lcd_weights, weights, FT_LCD_FILTER_FIVE_TAPS );
289     library-&gt;lcd_filter_func = ft_lcd_filter_fir;
290 
291     return FT_Err_Ok;
292   }
293 
294 


295   FT_EXPORT_DEF( FT_Error )
296   FT_Library_SetLcdFilter( FT_Library    library,
297                            FT_LcdFilter  filter )
298   {
299     static const FT_LcdFiveTapFilter  default_weights =
300                    { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
301     static const FT_LcdFiveTapFilter  light_weights =
302                    { 0x00, 0x55, 0x56, 0x55, 0x00 };
303 
304 
305     if ( !library )
306       return FT_THROW( Invalid_Library_Handle );
307 
308     switch ( filter )
309     {
310     case FT_LCD_FILTER_NONE:
311       library-&gt;lcd_filter_func = NULL;
312       break;
313 
314     case FT_LCD_FILTER_DEFAULT:
</pre>
<hr />
<pre>
324                  FT_LCD_FILTER_FIVE_TAPS );
325       library-&gt;lcd_filter_func = ft_lcd_filter_fir;
326       break;
327 
328 #ifdef USE_LEGACY
329 
330     case FT_LCD_FILTER_LEGACY:
331     case FT_LCD_FILTER_LEGACY1:
332       library-&gt;lcd_filter_func = _ft_lcd_filter_legacy;
333       break;
334 
335 #endif
336 
337     default:
338       return FT_THROW( Invalid_Argument );
339     }
340 
341     return FT_Err_Ok;
342   }
343 











344 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
345 
<span class="line-modified">346   /* add padding according to accommodate outline shifts */</span>
347   FT_BASE_DEF (void)
<span class="line-modified">348   ft_lcd_padding( FT_Pos*       Min,</span>
<span class="line-modified">349                   FT_Pos*       Max,</span>
<span class="line-modified">350                   FT_GlyphSlot  slot )</span>
351   {
<span class="line-modified">352     FT_UNUSED( slot );</span>
353 
<span class="line-modified">354     *Min -= 21;</span>
<span class="line-modified">355     *Max += 21;</span>












356   }
357 
358 
359   FT_EXPORT_DEF( FT_Error )
360   FT_Library_SetLcdFilterWeights( FT_Library      library,
361                                   unsigned char  *weights )
362   {
363     FT_UNUSED( library );
364     FT_UNUSED( weights );
365 
366     return FT_THROW( Unimplemented_Feature );
367   }
368 
369 
370   FT_EXPORT_DEF( FT_Error )
371   FT_Library_SetLcdFilter( FT_Library    library,
372                            FT_LcdFilter  filter )
373   {
374     FT_UNUSED( library );
375     FT_UNUSED( filter );
376 
377     return FT_THROW( Unimplemented_Feature );
378   }
379 


















380 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
381 
382 
383 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftlcdfil.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   FreeType API for color filtering of subpixel bitmap glyphs (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2006-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 
 22 #include FT_LCD_FILTER_H
 23 #include FT_IMAGE_H
 24 #include FT_INTERNAL_OBJECTS_H
 25 
 26 
 27 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 28 
 29 /* define USE_LEGACY to implement the legacy filter */
 30 #define  USE_LEGACY
 31 
 32 #define FT_SHIFTCLAMP( x )  ( x &gt;&gt;= 8, (FT_Byte)( x &gt; 255 ? 255 : x ) )
 33 
 34 
 35   /* add padding according to filter weights */
 36   FT_BASE_DEF (void)
<span class="line-modified"> 37   ft_lcd_padding( FT_BBox*        cbox,</span>
<span class="line-modified"> 38                   FT_GlyphSlot    slot,</span>
<span class="line-modified"> 39                   FT_Render_Mode  mode )</span>
 40   {
 41     FT_Byte*                 lcd_weights;
 42     FT_Bitmap_LcdFilterFunc  lcd_filter_func;
 43 
 44 
 45     /* Per-face LCD filtering takes priority if set up. */
 46     if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
 47     {
 48       lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
 49       lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
 50     }
 51     else
 52     {
 53       lcd_weights     = slot-&gt;library-&gt;lcd_weights;
 54       lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
 55     }
 56 
 57     if ( lcd_filter_func == ft_lcd_filter_fir )
 58     {
<span class="line-modified"> 59       if ( mode == FT_RENDER_MODE_LCD )</span>
<span class="line-modified"> 60       {</span>
<span class="line-modified"> 61         cbox-&gt;xMin -= lcd_weights[0] ? 43 :</span>
<span class="line-modified"> 62                       lcd_weights[1] ? 22 : 0;</span>
<span class="line-added"> 63         cbox-&gt;xMax += lcd_weights[4] ? 43 :</span>
<span class="line-added"> 64                       lcd_weights[3] ? 22 : 0;</span>
<span class="line-added"> 65       }</span>
<span class="line-added"> 66       else if ( mode == FT_RENDER_MODE_LCD_V )</span>
<span class="line-added"> 67       {</span>
<span class="line-added"> 68         cbox-&gt;yMin -= lcd_weights[0] ? 43 :</span>
<span class="line-added"> 69                       lcd_weights[1] ? 22 : 0;</span>
<span class="line-added"> 70         cbox-&gt;yMax += lcd_weights[4] ? 43 :</span>
<span class="line-added"> 71                       lcd_weights[3] ? 22 : 0;</span>
<span class="line-added"> 72       }</span>
 73     }
 74   }
 75 
 76 
 77   /* FIR filter used by the default and light filters */
 78   FT_BASE_DEF( void )
 79   ft_lcd_filter_fir( FT_Bitmap*           bitmap,

 80                      FT_LcdFiveTapFilter  weights )
 81   {
 82     FT_UInt   width  = (FT_UInt)bitmap-&gt;width;
 83     FT_UInt   height = (FT_UInt)bitmap-&gt;rows;
 84     FT_Int    pitch  = bitmap-&gt;pitch;
 85     FT_Byte*  origin = bitmap-&gt;buffer;
<span class="line-added"> 86     FT_Byte   mode   = bitmap-&gt;pixel_mode;</span>
 87 
 88 
 89     /* take care of bitmap flow */
 90     if ( pitch &gt; 0 &amp;&amp; height &gt; 0 )
 91       origin += pitch * (FT_Int)( height - 1 );
 92 
 93     /* horizontal in-place FIR filter */
<span class="line-modified"> 94     if ( mode == FT_PIXEL_MODE_LCD &amp;&amp; width &gt;= 2 )</span>
 95     {
 96       FT_Byte*  line = origin;
 97 
 98 
 99       /* `fir&#39; must be at least 32 bit wide, since the sum of */
100       /* the values in `weights&#39; can exceed 0xFF              */
101 
102       for ( ; height &gt; 0; height--, line -= pitch )
103       {
104         FT_UInt  fir[5];
105         FT_UInt  val, xx;
106 
107 
108         val    = line[0];
109         fir[2] = weights[2] * val;
110         fir[3] = weights[3] * val;
111         fir[4] = weights[4] * val;
112 
113         val    = line[1];
114         fir[1] = fir[2] + weights[1] * val;
</pre>
<hr />
<pre>
117         fir[4] =          weights[4] * val;
118 
119         for ( xx = 2; xx &lt; width; xx++ )
120         {
121           val    = line[xx];
122           fir[0] = fir[1] + weights[0] * val;
123           fir[1] = fir[2] + weights[1] * val;
124           fir[2] = fir[3] + weights[2] * val;
125           fir[3] = fir[4] + weights[3] * val;
126           fir[4] =          weights[4] * val;
127 
128           line[xx - 2] = FT_SHIFTCLAMP( fir[0] );
129         }
130 
131         line[xx - 2] = FT_SHIFTCLAMP( fir[1] );
132         line[xx - 1] = FT_SHIFTCLAMP( fir[2] );
133       }
134     }
135 
136     /* vertical in-place FIR filter */
<span class="line-modified">137     else if ( mode == FT_PIXEL_MODE_LCD_V &amp;&amp; height &gt;= 2 )</span>
138     {
139       FT_Byte*  column = origin;
140 
141 
142       for ( ; width &gt; 0; width--, column++ )
143       {
144         FT_Byte*  col = column;
145         FT_UInt   fir[5];
146         FT_UInt   val, yy;
147 
148 
149         val    = col[0];
150         fir[2] = weights[2] * val;
151         fir[3] = weights[3] * val;
152         fir[4] = weights[4] * val;
153         col   -= pitch;
154 
155         val    = col[0];
156         fir[1] = fir[2] + weights[1] * val;
157         fir[2] = fir[3] + weights[2] * val;
</pre>
<hr />
<pre>
166           fir[1] = fir[2] + weights[1] * val;
167           fir[2] = fir[3] + weights[2] * val;
168           fir[3] = fir[4] + weights[3] * val;
169           fir[4] =          weights[4] * val;
170 
171           col[pitch * 2]  = FT_SHIFTCLAMP( fir[0] );
172         }
173 
174         col[pitch * 2]  = FT_SHIFTCLAMP( fir[1] );
175         col[pitch]      = FT_SHIFTCLAMP( fir[2] );
176       }
177     }
178   }
179 
180 
181 #ifdef USE_LEGACY
182 
183   /* intra-pixel filter used by the legacy filter */
184   static void
185   _ft_lcd_filter_legacy( FT_Bitmap*      bitmap,

186                          FT_Byte*        weights )
187   {
188     FT_UInt   width  = (FT_UInt)bitmap-&gt;width;
189     FT_UInt   height = (FT_UInt)bitmap-&gt;rows;
190     FT_Int    pitch  = bitmap-&gt;pitch;
191     FT_Byte*  origin = bitmap-&gt;buffer;
<span class="line-added">192     FT_Byte   mode   = bitmap-&gt;pixel_mode;</span>
193 
194     static const unsigned int  filters[3][3] =
195     {
196       { 65538 * 9/13, 65538 * 1/6, 65538 * 1/13 },
197       { 65538 * 3/13, 65538 * 4/6, 65538 * 3/13 },
198       { 65538 * 1/13, 65538 * 1/6, 65538 * 9/13 }
199     };
200 
201     FT_UNUSED( weights );
202 
203 
204     /* take care of bitmap flow */
205     if ( pitch &gt; 0 &amp;&amp; height &gt; 0 )
206       origin += pitch * (FT_Int)( height - 1 );
207 
208     /* horizontal in-place intra-pixel filter */
<span class="line-modified">209     if ( mode == FT_PIXEL_MODE_LCD &amp;&amp; width &gt;= 3 )</span>
210     {
211       FT_Byte*  line = origin;
212 
213 
214       for ( ; height &gt; 0; height--, line -= pitch )
215       {
216         FT_UInt  xx;
217 
218 
219         for ( xx = 0; xx &lt; width; xx += 3 )
220         {
221           FT_UInt  r, g, b;
222           FT_UInt  p;
223 
224 
225           p  = line[xx];
226           r  = filters[0][0] * p;
227           g  = filters[0][1] * p;
228           b  = filters[0][2] * p;
229 
230           p  = line[xx + 1];
231           r += filters[1][0] * p;
232           g += filters[1][1] * p;
233           b += filters[1][2] * p;
234 
235           p  = line[xx + 2];
236           r += filters[2][0] * p;
237           g += filters[2][1] * p;
238           b += filters[2][2] * p;
239 
240           line[xx]     = (FT_Byte)( r / 65536 );
241           line[xx + 1] = (FT_Byte)( g / 65536 );
242           line[xx + 2] = (FT_Byte)( b / 65536 );
243         }
244       }
245     }
<span class="line-modified">246     else if ( mode == FT_PIXEL_MODE_LCD_V &amp;&amp; height &gt;= 3 )</span>
247     {
248       FT_Byte*  column = origin;
249 
250 
251       for ( ; width &gt; 0; width--, column++ )
252       {
253         FT_Byte*  col = column - 2 * pitch;
254 
255 
256         for ( ; height &gt; 0; height -= 3, col -= 3 * pitch )
257         {
258           FT_UInt  r, g, b;
259           FT_UInt  p;
260 
261 
262           p  = col[0];
263           r  = filters[0][0] * p;
264           g  = filters[0][1] * p;
265           b  = filters[0][2] * p;
266 
</pre>
<hr />
<pre>
268           r += filters[1][0] * p;
269           g += filters[1][1] * p;
270           b += filters[1][2] * p;
271 
272           p  = col[pitch * 2];
273           r += filters[2][0] * p;
274           g += filters[2][1] * p;
275           b += filters[2][2] * p;
276 
277           col[0]         = (FT_Byte)( r / 65536 );
278           col[pitch]     = (FT_Byte)( g / 65536 );
279           col[pitch * 2] = (FT_Byte)( b / 65536 );
280         }
281       }
282     }
283   }
284 
285 #endif /* USE_LEGACY */
286 
287 
<span class="line-added">288   /* documentation in ftlcdfil.h */</span>
<span class="line-added">289 </span>
290   FT_EXPORT_DEF( FT_Error )
291   FT_Library_SetLcdFilterWeights( FT_Library      library,
292                                   unsigned char  *weights )
293   {
294     if ( !library )
295       return FT_THROW( Invalid_Library_Handle );
296 
297     if ( !weights )
298       return FT_THROW( Invalid_Argument );
299 
300     ft_memcpy( library-&gt;lcd_weights, weights, FT_LCD_FILTER_FIVE_TAPS );
301     library-&gt;lcd_filter_func = ft_lcd_filter_fir;
302 
303     return FT_Err_Ok;
304   }
305 
306 
<span class="line-added">307   /* documentation in ftlcdfil.h */</span>
<span class="line-added">308 </span>
309   FT_EXPORT_DEF( FT_Error )
310   FT_Library_SetLcdFilter( FT_Library    library,
311                            FT_LcdFilter  filter )
312   {
313     static const FT_LcdFiveTapFilter  default_weights =
314                    { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
315     static const FT_LcdFiveTapFilter  light_weights =
316                    { 0x00, 0x55, 0x56, 0x55, 0x00 };
317 
318 
319     if ( !library )
320       return FT_THROW( Invalid_Library_Handle );
321 
322     switch ( filter )
323     {
324     case FT_LCD_FILTER_NONE:
325       library-&gt;lcd_filter_func = NULL;
326       break;
327 
328     case FT_LCD_FILTER_DEFAULT:
</pre>
<hr />
<pre>
338                  FT_LCD_FILTER_FIVE_TAPS );
339       library-&gt;lcd_filter_func = ft_lcd_filter_fir;
340       break;
341 
342 #ifdef USE_LEGACY
343 
344     case FT_LCD_FILTER_LEGACY:
345     case FT_LCD_FILTER_LEGACY1:
346       library-&gt;lcd_filter_func = _ft_lcd_filter_legacy;
347       break;
348 
349 #endif
350 
351     default:
352       return FT_THROW( Invalid_Argument );
353     }
354 
355     return FT_Err_Ok;
356   }
357 
<span class="line-added">358 </span>
<span class="line-added">359   FT_EXPORT_DEF( FT_Error )</span>
<span class="line-added">360   FT_Library_SetLcdGeometry( FT_Library  library,</span>
<span class="line-added">361                              FT_Vector*  sub )</span>
<span class="line-added">362   {</span>
<span class="line-added">363     FT_UNUSED( library );</span>
<span class="line-added">364     FT_UNUSED( sub );</span>
<span class="line-added">365 </span>
<span class="line-added">366     return FT_THROW( Unimplemented_Feature );</span>
<span class="line-added">367   }</span>
<span class="line-added">368 </span>
369 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
370 
<span class="line-modified">371   /* add padding to accommodate outline shifts */</span>
372   FT_BASE_DEF (void)
<span class="line-modified">373   ft_lcd_padding( FT_BBox*        cbox,</span>
<span class="line-modified">374                   FT_GlyphSlot    slot,</span>
<span class="line-modified">375                   FT_Render_Mode  mode )</span>
376   {
<span class="line-modified">377     FT_Vector*  sub = slot-&gt;library-&gt;lcd_geometry;</span>
378 
<span class="line-modified">379     if ( mode == FT_RENDER_MODE_LCD )</span>
<span class="line-modified">380     {</span>
<span class="line-added">381       cbox-&gt;xMin -= FT_MAX( FT_MAX( sub[0].x, sub[1].x ), sub[2].x );</span>
<span class="line-added">382       cbox-&gt;xMax -= FT_MIN( FT_MIN( sub[0].x, sub[1].x ), sub[2].x );</span>
<span class="line-added">383       cbox-&gt;yMin -= FT_MAX( FT_MAX( sub[0].y, sub[1].y ), sub[2].y );</span>
<span class="line-added">384       cbox-&gt;yMax -= FT_MIN( FT_MIN( sub[0].y, sub[1].y ), sub[2].y );</span>
<span class="line-added">385     }</span>
<span class="line-added">386     else if ( mode == FT_RENDER_MODE_LCD_V )</span>
<span class="line-added">387     {</span>
<span class="line-added">388       cbox-&gt;xMin -= FT_MAX( FT_MAX( sub[0].y, sub[1].y ), sub[2].y );</span>
<span class="line-added">389       cbox-&gt;xMax -= FT_MIN( FT_MIN( sub[0].y, sub[1].y ), sub[2].y );</span>
<span class="line-added">390       cbox-&gt;yMin += FT_MIN( FT_MIN( sub[0].x, sub[1].x ), sub[2].x );</span>
<span class="line-added">391       cbox-&gt;yMax += FT_MAX( FT_MAX( sub[0].x, sub[1].x ), sub[2].x );</span>
<span class="line-added">392     }</span>
393   }
394 
395 
396   FT_EXPORT_DEF( FT_Error )
397   FT_Library_SetLcdFilterWeights( FT_Library      library,
398                                   unsigned char  *weights )
399   {
400     FT_UNUSED( library );
401     FT_UNUSED( weights );
402 
403     return FT_THROW( Unimplemented_Feature );
404   }
405 
406 
407   FT_EXPORT_DEF( FT_Error )
408   FT_Library_SetLcdFilter( FT_Library    library,
409                            FT_LcdFilter  filter )
410   {
411     FT_UNUSED( library );
412     FT_UNUSED( filter );
413 
414     return FT_THROW( Unimplemented_Feature );
415   }
416 
<span class="line-added">417 </span>
<span class="line-added">418   /* documentation in ftlcdfil.h */</span>
<span class="line-added">419 </span>
<span class="line-added">420   FT_EXPORT_DEF( FT_Error )</span>
<span class="line-added">421   FT_Library_SetLcdGeometry( FT_Library  library,</span>
<span class="line-added">422                              FT_Vector   sub[3] )</span>
<span class="line-added">423   {</span>
<span class="line-added">424     if ( !library )</span>
<span class="line-added">425       return FT_THROW( Invalid_Library_Handle );</span>
<span class="line-added">426 </span>
<span class="line-added">427     if ( !sub )</span>
<span class="line-added">428       return FT_THROW( Invalid_Argument );</span>
<span class="line-added">429 </span>
<span class="line-added">430     ft_memcpy( library-&gt;lcd_geometry, sub, 3 * sizeof( FT_Vector ) );</span>
<span class="line-added">431 </span>
<span class="line-added">432     return FT_THROW( Unimplemented_Feature );</span>
<span class="line-added">433   }</span>
<span class="line-added">434 </span>
435 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
436 
437 
438 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="ftinit.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftmac.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
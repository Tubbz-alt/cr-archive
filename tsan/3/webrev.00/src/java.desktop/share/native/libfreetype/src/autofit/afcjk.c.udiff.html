<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afblue.hin.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,35 +1,34 @@</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  afcjk.c                                                                */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*    Auto-fitter hinting routines for CJK writing system (body).          */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  Copyright 2006-2018 by                                                 */</span>
<span class="udiff-line-modified-removed">- /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="udiff-line-modified-removed">- /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="udiff-line-modified-removed">- /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="udiff-line-modified-removed">- /*  this file you indicate that you have read the license and              */</span>
<span class="udiff-line-modified-removed">- /*  understand and accept it fully.                                        */</span>
<span class="udiff-line-modified-removed">- /*                                                                         */</span>
<span class="udiff-line-modified-removed">- /***************************************************************************/</span>
<span class="udiff-line-modified-added">+ /****************************************************************************</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * afcjk.c</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  *   Auto-fitter hinting routines for CJK writing system (body).</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2006-2019 by</span>
<span class="udiff-line-modified-added">+  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * This file is part of the FreeType project, and may only be used,</span>
<span class="udiff-line-modified-added">+  * modified, and distributed under the terms of the FreeType project</span>
<span class="udiff-line-modified-added">+  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="udiff-line-modified-added">+  * this file you indicate that you have read the license and</span>
<span class="udiff-line-modified-added">+  * understand and accept it fully.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  */</span>
  
    /*
<span class="udiff-line-modified-removed">-    *  The algorithm is based on akito&#39;s autohint patch, archived at</span>
<span class="udiff-line-modified-added">+    * The algorithm is based on akito&#39;s autohint patch, archived at</span>
     *
<span class="udiff-line-modified-removed">-    *  https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
<span class="udiff-line-modified-added">+    * https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
     *
     */
  
  #include &lt;ft2build.h&gt;
  #include FT_ADVANCES_H
  #include FT_INTERNAL_DEBUG_H
  
  #include &quot;afglobal.h&quot;
<span class="udiff-line-removed">- #include &quot;afpic.h&quot;</span>
  #include &quot;aflatin.h&quot;
  #include &quot;afcjk.h&quot;
  
  
  #ifdef AF_CONFIG_OPTION_CJK
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -42,18 +41,18 @@</span>
  #ifdef AF_CONFIG_OPTION_USE_WARPER
  #include &quot;afwarp.h&quot;
  #endif
  
  
<span class="udiff-line-modified-removed">-   /*************************************************************************/</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-removed">-   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="udiff-line-modified-removed">-   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="udiff-line-modified-removed">-   /* messages during execution.                                            */</span>
<span class="udiff-line-modified-removed">-   /*                                                                       */</span>
<span class="udiff-line-modified-added">+   /**************************************************************************</span>
<span class="udiff-line-modified-added">+    *</span>
<span class="udiff-line-modified-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="udiff-line-modified-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="udiff-line-modified-added">+    * messages during execution.</span>
<span class="udiff-line-modified-added">+    */</span>
  #undef  FT_COMPONENT
<span class="udiff-line-modified-removed">- #define FT_COMPONENT  trace_afcjk</span>
<span class="udiff-line-modified-added">+ #define FT_COMPONENT  afcjk</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*****                                                               *****/
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -90,27 +89,33 @@</span>
        FT_ULong          glyph_index;
        int               dim;
        AF_CJKMetricsRec  dummy[1];
        AF_Scaler         scaler = &amp;dummy-&gt;root.scaler;
  
<span class="udiff-line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="udiff-line-removed">-       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- </span>
        AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="udiff-line-modified-removed">-       AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="udiff-line-modified-removed">-                                        [style_class-&gt;script];</span>
<span class="udiff-line-modified-added">+       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="udiff-line-added">+       /* unsigned long value.                                        */</span>
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="udiff-line-added">+       void*     shaper_buf;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+       FT_ULong  shaper_buf_;</span>
<span class="udiff-line-added">+       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-removed">-       void*        shaper_buf;</span>
        const char*  p;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_ULong  ch = 0;
  #endif
  
<span class="udiff-line-modified-removed">-       p          = script_class-&gt;standard_charstring;</span>
<span class="udiff-line-modified-added">+       p = script_class-&gt;standard_charstring;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
        shaper_buf = af_shaper_buf_create( face );
<span class="udiff-line-added">+ #endif</span>
  
        /* We check a list of standard characters.  The first match wins. */
  
        glyph_index = 0;
        while ( *p )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -191,14 +196,14 @@</span>
                                                   (AF_Dimension)dim );
          if ( error )
            goto Exit;
  
          /*
<span class="udiff-line-modified-removed">-          *  We assume that the glyphs selected for the stem width</span>
<span class="udiff-line-modified-removed">-          *  computation are `featureless&#39; enough so that the linking</span>
<span class="udiff-line-modified-removed">-          *  algorithm works fine without adjustments of its scoring</span>
<span class="udiff-line-modified-removed">-          *  function.</span>
<span class="udiff-line-modified-added">+          * We assume that the glyphs selected for the stem width</span>
<span class="udiff-line-modified-added">+          * computation are `featureless&#39; enough so that the linking</span>
<span class="udiff-line-modified-added">+          * algorithm works fine without adjustments of its scoring</span>
<span class="udiff-line-modified-added">+          * function.</span>
           */
          af_latin_hints_link_segments( hints,
                                        0,
                                        NULL,
                                        (AF_Dimension)dim );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -294,22 +299,31 @@</span>
      AF_StyleClass  sc = metrics-&gt;root.style_class;
  
      AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
      const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
  
<span class="udiff-line-modified-removed">-     void*  shaper_buf;</span>
<span class="udiff-line-modified-added">+     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="udiff-line-added">+     /* unsigned long value.                                        */</span>
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="udiff-line-added">+     void*     shaper_buf;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     FT_ULong  shaper_buf_;</span>
<span class="udiff-line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="udiff-line-added">+ #endif</span>
  
  
      /* we walk over the blue character strings as specified in the   */
      /* style&#39;s entry in the `af_blue_stringset&#39; array, computing its */
      /* extremum points (depending on the string properties)          */
  
      FT_TRACE5(( &quot;cjk blue zones computation\n&quot;
                  &quot;==========================\n&quot;
                  &quot;\n&quot; ));
  
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="udiff-line-added">+ #endif</span>
  
      for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char*  p = &amp;af_blue_strings[bs-&gt;string];
        FT_Pos*      blue_ref;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -481,12 +495,12 @@</span>
        } /* end while loop */
  
        if ( num_flats == 0 &amp;&amp; num_fills == 0 )
        {
          /*
<span class="udiff-line-modified-removed">-          *  we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="udiff-line-modified-removed">-          *  we will simply ignore it then</span>
<span class="udiff-line-modified-added">+          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="udiff-line-modified-added">+          * we will simply ignore it then</span>
           */
          FT_TRACE5(( &quot;  empty\n&quot; ));
          continue;
        }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -563,19 +577,29 @@</span>
                                 FT_Face        face )
    {
      FT_Bool   started = 0, same_width = 1;
      FT_Fixed  advance = 0, old_advance = 0;
  
<span class="udiff-line-modified-removed">-     void*  shaper_buf;</span>
<span class="udiff-line-modified-added">+     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="udiff-line-added">+     /* unsigned long value.                                        */</span>
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="udiff-line-added">+     void*     shaper_buf;</span>
<span class="udiff-line-added">+ #else</span>
<span class="udiff-line-added">+     FT_ULong  shaper_buf_;</span>
<span class="udiff-line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="udiff-line-added">+ #endif</span>
  
      /* in all supported charmaps, digits have character codes 0x30-0x39 */
      const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
      const char*  p;
  
  
<span class="udiff-line-modified-removed">-     p          = digits;</span>
<span class="udiff-line-modified-added">+     p = digits;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="udiff-line-added">+ #endif</span>
  
      while ( *p )
      {
        FT_ULong      glyph_index;
        unsigned int  num_idx;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -888,15 +912,15 @@</span>
            }
          }
      }
  
      /*
<span class="udiff-line-modified-removed">-      *  now compute the `serif&#39; segments</span>
<span class="udiff-line-modified-added">+      * now compute the `serif&#39; segments</span>
       *
<span class="udiff-line-modified-removed">-      *  In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="udiff-line-modified-removed">-      *  We either identify the stems on the ends as serifs or remove</span>
<span class="udiff-line-modified-removed">-      *  the linkage, depending on the length of the stems.</span>
<span class="udiff-line-modified-added">+      * In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="udiff-line-modified-added">+      * We either identify the stems on the ends as serifs or remove</span>
<span class="udiff-line-modified-added">+      * the linkage, depending on the length of the stems.</span>
       *
       */
  
      {
        AF_Segment  link1, link2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -998,25 +1022,25 @@</span>
      axis-&gt;num_edges = 0;
  
      scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
                                           : hints-&gt;y_scale;
  
<span class="udiff-line-modified-removed">-     /*********************************************************************/</span>
<span class="udiff-line-modified-removed">-     /*                                                                   */</span>
<span class="udiff-line-modified-removed">-     /* We begin by generating a sorted table of edges for the current    */</span>
<span class="udiff-line-modified-removed">-     /* direction.  To do so, we simply scan each segment and try to find */</span>
<span class="udiff-line-modified-removed">-     /* an edge in our table that corresponds to its position.            */</span>
<span class="udiff-line-modified-removed">-     /*                                                                   */</span>
<span class="udiff-line-modified-removed">-     /* If no edge is found, we create and insert a new edge in the       */</span>
<span class="udiff-line-modified-removed">-     /* sorted table.  Otherwise, we simply add the segment to the edge&#39;s */</span>
<span class="udiff-line-modified-removed">-     /* list which is then processed in the second step to compute the    */</span>
<span class="udiff-line-modified-removed">-     /* edge&#39;s properties.                                                */</span>
<span class="udiff-line-modified-removed">-     /*                                                                   */</span>
<span class="udiff-line-modified-removed">-     /* Note that the edges table is sorted along the segment/edge        */</span>
<span class="udiff-line-modified-removed">-     /* position.                                                         */</span>
<span class="udiff-line-modified-removed">-     /*                                                                   */</span>
<span class="udiff-line-modified-removed">-     /*********************************************************************/</span>
<span class="udiff-line-modified-added">+     /**********************************************************************</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * We begin by generating a sorted table of edges for the current</span>
<span class="udiff-line-modified-added">+      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="udiff-line-modified-added">+      * an edge in our table that corresponds to its position.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * If no edge is found, we create and insert a new edge in the</span>
<span class="udiff-line-modified-added">+      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="udiff-line-modified-added">+      * list which is then processed in the second step to compute the</span>
<span class="udiff-line-modified-added">+      * edge&#39;s properties.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Note that the edges table is sorted along the segment/edge</span>
<span class="udiff-line-modified-added">+      * position.</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      */</span>
  
      edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
                                           scale );
      if ( edge_distance_threshold &gt; 64 / 4 )
        edge_distance_threshold = FT_DivFix( 64 / 4, scale );
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1112,21 +1136,21 @@</span>
          found-&gt;last-&gt;edge_next = seg;
          found-&gt;last            = seg;
        }
      }
  
<span class="udiff-line-modified-removed">-     /******************************************************************/</span>
<span class="udiff-line-modified-removed">-     /*                                                                */</span>
<span class="udiff-line-modified-removed">-     /* Good, we now compute each edge&#39;s properties according to the   */</span>
<span class="udiff-line-modified-removed">-     /* segments found on its position.  Basically, these are          */</span>
<span class="udiff-line-modified-removed">-     /*                                                                */</span>
<span class="udiff-line-modified-removed">-     /*  - the edge&#39;s main direction                                   */</span>
<span class="udiff-line-modified-removed">-     /*  - stem edge, serif edge or both (which defaults to stem then) */</span>
<span class="udiff-line-modified-removed">-     /*  - rounded edge, straight or both (which defaults to straight) */</span>
<span class="udiff-line-modified-removed">-     /*  - link for edge                                               */</span>
<span class="udiff-line-modified-removed">-     /*                                                                */</span>
<span class="udiff-line-modified-removed">-     /******************************************************************/</span>
<span class="udiff-line-modified-added">+     /*******************************************************************</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="udiff-line-modified-added">+      * segments found on its position.  Basically, these are</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      * - the edge&#39;s main direction</span>
<span class="udiff-line-modified-added">+      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="udiff-line-modified-added">+      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="udiff-line-modified-added">+      * - link for edge</span>
<span class="udiff-line-modified-added">+      *</span>
<span class="udiff-line-modified-added">+      */</span>
  
      /* first of all, set the `edge&#39; field in each segment -- this is */
      /* required in order to compute edge links                       */
  
      /*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1158,10 +1182,12 @@</span>
          FT_Int  is_round    = 0;  /* does it contain round segments?    */
          FT_Int  is_straight = 0;  /* does it contain straight segments? */
  
  
          seg = edge-&gt;first;
<span class="udiff-line-added">+         if ( !seg )</span>
<span class="udiff-line-added">+           goto Skip_Loop;</span>
  
          do
          {
            FT_Bool  is_serif;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1172,11 +1198,11 @@</span>
            else
              is_straight++;
  
            /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
            /* be ignored                                                   */
<span class="udiff-line-modified-removed">-           is_serif = (FT_Bool)( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
<span class="udiff-line-modified-added">+           is_serif = FT_BOOL( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
  
            if ( seg-&gt;link || is_serif )
            {
              AF_Edge     edge2;
              AF_Segment  seg2;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1213,17 +1239,18 @@</span>
              {
                edge-&gt;serif   = edge2;
                edge2-&gt;flags |= AF_EDGE_SERIF;
              }
              else
<span class="udiff-line-modified-removed">-               edge-&gt;link  = edge2;</span>
<span class="udiff-line-modified-added">+               edge-&gt;link = edge2;</span>
            }
  
            seg = seg-&gt;edge_next;
  
          } while ( seg != edge-&gt;first );
  
<span class="udiff-line-added">+       Skip_Loop:</span>
          /* set the round/straight flags */
          edge-&gt;flags = AF_EDGE_NORMAL;
  
          if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
            edge-&gt;flags |= AF_EDGE_ROUND;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1362,12 +1389,12 @@</span>
  
  
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
  
      /*
<span class="udiff-line-modified-removed">-      *  correct x_scale and y_scale when needed, since they may have</span>
<span class="udiff-line-modified-removed">-      *  been modified af_cjk_scale_dim above</span>
<span class="udiff-line-modified-added">+      * correct x_scale and y_scale when needed, since they may have</span>
<span class="udiff-line-modified-added">+      * been modified af_cjk_scale_dim above</span>
       */
      hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
      hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
      hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
      hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1382,25 +1409,25 @@</span>
  
      scaler_flags = hints-&gt;scaler_flags;
      other_flags  = 0;
  
      /*
<span class="udiff-line-modified-removed">-      *  We snap the width of vertical stems for the monochrome and</span>
<span class="udiff-line-modified-removed">-      *  horizontal LCD rendering targets only.</span>
<span class="udiff-line-modified-added">+      * We snap the width of vertical stems for the monochrome and</span>
<span class="udiff-line-modified-added">+      * horizontal LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
  
      /*
<span class="udiff-line-modified-removed">-      *  We snap the width of horizontal stems for the monochrome and</span>
<span class="udiff-line-modified-removed">-      *  vertical LCD rendering targets only.</span>
<span class="udiff-line-modified-added">+      * We snap the width of horizontal stems for the monochrome and</span>
<span class="udiff-line-modified-added">+      * vertical LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
        other_flags |= AF_LATIN_HINTS_VERT_SNAP;
  
      /*
<span class="udiff-line-modified-removed">-      *  We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
<span class="udiff-line-modified-added">+      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
       */
      if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
  
      if ( mode == FT_RENDER_MODE_MONO )
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2092,12 +2119,12 @@</span>
  
      if ( !skipped )
        goto Exit;
  
      /*
<span class="udiff-line-modified-removed">-      *  now hint the remaining edges (serifs and single) in order</span>
<span class="udiff-line-modified-removed">-      *  to complete our processing</span>
<span class="udiff-line-modified-added">+      * now hint the remaining edges (serifs and single) in order</span>
<span class="udiff-line-modified-added">+      * to complete our processing</span>
       */
      for ( edge = edges; edge &lt; edge_limit; edge++ )
      {
        if ( edge-&gt;flags &amp; AF_EDGE_DONE )
          continue;
</pre>
<center><a href="afblue.hin.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/afhints.h</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afhints.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afindic.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afhints.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  afhints.h                                                              */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Auto-fitter hinting routines (specification).                        */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #ifndef AFHINTS_H_
 20 #define AFHINTS_H_
 21 
 22 #include &quot;aftypes.h&quot;
 23 
 24 #define xxAF_SORT_SEGMENTS
 25 
 26 FT_BEGIN_HEADER
 27 
 28   /*
<span class="line-modified"> 29    *  The definition of outline glyph hints.  These are shared by all</span>
<span class="line-modified"> 30    *  writing system analysis routines (until now).</span>
 31    */
 32 
 33   typedef enum  AF_Dimension_
 34   {
 35     AF_DIMENSION_HORZ = 0,  /* x coordinates,                    */
 36                             /* i.e., vertical segments &amp; edges   */
 37     AF_DIMENSION_VERT = 1,  /* y coordinates,                    */
 38                             /* i.e., horizontal segments &amp; edges */
 39 
 40     AF_DIMENSION_MAX  /* do not remove */
 41 
 42   } AF_Dimension;
 43 
 44 
 45   /* hint directions -- the values are computed so that two vectors are */
 46   /* in opposite directions iff `dir1 + dir2 == 0&#39;                      */
 47   typedef enum  AF_Direction_
 48   {
 49     AF_DIR_NONE  =  4,
 50     AF_DIR_RIGHT =  1,
 51     AF_DIR_LEFT  = -1,
 52     AF_DIR_UP    =  2,
 53     AF_DIR_DOWN  = -2
 54 
 55   } AF_Direction;
 56 
 57 
 58   /*
<span class="line-modified"> 59    *  The following explanations are mostly taken from the article</span>
 60    *
<span class="line-modified"> 61    *    Real-Time Grid Fitting of Typographic Outlines</span>
 62    *
<span class="line-modified"> 63    *  by David Turner and Werner Lemberg</span>
 64    *
<span class="line-modified"> 65    *    https://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf</span>
 66    *
<span class="line-modified"> 67    *  with appropriate updates.</span>
 68    *
 69    *
<span class="line-modified"> 70    *  Segments</span>
 71    *
<span class="line-modified"> 72    *    `af_{cjk,latin,...}_hints_compute_segments&#39; are the functions to</span>
<span class="line-modified"> 73    *    find segments in an outline.</span>
 74    *
<span class="line-modified"> 75    *    A segment is a series of at least two consecutive points that are</span>
<span class="line-modified"> 76    *    approximately aligned along a coordinate axis.  The analysis to do</span>
<span class="line-modified"> 77    *    so is specific to a writing system.</span>
 78    *
 79    *
<span class="line-modified"> 80    *  Edges</span>
 81    *
<span class="line-modified"> 82    *    `af_{cjk,latin,...}_hints_compute_edges&#39; are the functions to find</span>
<span class="line-modified"> 83    *    edges.</span>
 84    *
<span class="line-modified"> 85    *    As soon as segments are defined, the auto-hinter groups them into</span>
<span class="line-modified"> 86    *    edges.  An edge corresponds to a single position on the main</span>
<span class="line-modified"> 87    *    dimension that collects one or more segments (allowing for a small</span>
<span class="line-modified"> 88    *    threshold).</span>
 89    *
<span class="line-modified"> 90    *    As an example, the `latin&#39; writing system first tries to grid-fit</span>
<span class="line-modified"> 91    *    edges, then to align segments on the edges unless it detects that</span>
<span class="line-modified"> 92    *    they form a serif.</span>
 93    *
 94    *
<span class="line-modified"> 95    *                      A          H</span>
<span class="line-modified"> 96    *                       |        |</span>
<span class="line-modified"> 97    *                       |        |</span>
<span class="line-modified"> 98    *                       |        |</span>
<span class="line-modified"> 99    *                       |        |</span>
<span class="line-modified">100    *         C             |        |             F</span>
<span class="line-modified">101    *          +------&lt;-----+        +-----&lt;------+</span>
<span class="line-modified">102    *          |             B      G             |</span>
<span class="line-modified">103    *          |                                  |</span>
<span class="line-modified">104    *          |                                  |</span>
<span class="line-modified">105    *          +---------------&gt;------------------+</span>
<span class="line-modified">106    *         D                                    E</span>
107    *
108    *
<span class="line-modified">109    *  Stems</span>
110    *
<span class="line-modified">111    *    Stems are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
112    *
<span class="line-modified">113    *    Segments need to be `linked&#39; to other ones in order to detect stems.</span>
<span class="line-modified">114    *    A stem is made of two segments that face each other in opposite</span>
<span class="line-modified">115    *    directions and that are sufficiently close to each other.  Using</span>
<span class="line-modified">116    *    vocabulary from the TrueType specification, stem segments form a</span>
<span class="line-modified">117    *    `black distance&#39;.</span>
118    *
<span class="line-modified">119    *    In the above ASCII drawing, the horizontal segments are BC, DE, and</span>
<span class="line-modified">120    *    FG; the vertical segments are AB, CD, EF, and GH.</span>
121    *
<span class="line-modified">122    *    Each segment has at most one `best&#39; candidate to form a black</span>
<span class="line-modified">123    *    distance, or no candidate at all.  Notice that two distinct segments</span>
<span class="line-modified">124    *    can have the same candidate, which frequently means a serif.</span>
125    *
<span class="line-modified">126    *    A stem is recognized by the following condition:</span>
127    *
<span class="line-modified">128    *      best segment_1 = segment_2 &amp;&amp; best segment_2 = segment_1</span>
129    *
<span class="line-modified">130    *    The best candidate is stored in field `link&#39; in structure</span>
<span class="line-modified">131    *    `AF_Segment&#39;.</span>
132    *
<span class="line-modified">133    *    In the above ASCII drawing, the best candidate for both AB and CD is</span>
<span class="line-modified">134    *    GH, while the best candidate for GH is AB.  Similarly, the best</span>
<span class="line-modified">135    *    candidate for EF and GH is AB, while the best candidate for AB is</span>
<span class="line-modified">136    *    GH.</span>
137    *
<span class="line-modified">138    *    The detection and handling of stems is dependent on the writing</span>
<span class="line-modified">139    *    system.</span>
140    *
141    *
<span class="line-modified">142    *  Serifs</span>
143    *
<span class="line-modified">144    *    Serifs are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
145    *
<span class="line-modified">146    *    In comparison to a stem, a serif (as handled by the auto-hinter</span>
<span class="line-modified">147    *    module that takes care of the `latin&#39; writing system) has</span>
148    *
<span class="line-modified">149    *      best segment_1 = segment_2 &amp;&amp; best segment_2 != segment_1</span>
150    *
<span class="line-modified">151    *    where segment_1 corresponds to the serif segment (CD and EF in the</span>
<span class="line-modified">152    *    above ASCII drawing).</span>
153    *
<span class="line-modified">154    *    The best candidate is stored in field `serif&#39; in structure</span>
<span class="line-modified">155    *    `AF_Segment&#39; (and `link&#39; is set to NULL).</span>
156    *
157    *
<span class="line-modified">158    *  Touched points</span>
159    *
<span class="line-modified">160    *    A point is called `touched&#39; if it has been processed somehow by the</span>
<span class="line-modified">161    *    auto-hinter.  It basically means that it shouldn&#39;t be moved again</span>
<span class="line-modified">162    *    (or moved only under certain constraints to preserve the already</span>
<span class="line-modified">163    *    applied processing).</span>
164    *
165    *
<span class="line-modified">166    *  Flat and round segments</span>
167    *
<span class="line-modified">168    *    Segments are `round&#39; or `flat&#39;, depending on the series of points</span>
<span class="line-modified">169    *    that define them.  A segment is round if the next and previous point</span>
<span class="line-modified">170    *    of an extremum (which can be either a single point or sequence of</span>
<span class="line-modified">171    *    points) are both conic or cubic control points.  Otherwise, a</span>
<span class="line-modified">172    *    segment with an extremum is flat.</span>
173    *
174    *
<span class="line-modified">175    *  Strong Points</span>
176    *
<span class="line-modified">177    *    Experience has shown that points not part of an edge need to be</span>
<span class="line-modified">178    *    interpolated linearly between their two closest edges, even if these</span>
<span class="line-modified">179    *    are not part of the contour of those particular points.  Typical</span>
<span class="line-modified">180    *    candidates for this are</span>
181    *
<span class="line-modified">182    *    - angle points (i.e., points where the `in&#39; and `out&#39; direction</span>
<span class="line-modified">183    *      differ greatly)</span>
184    *
<span class="line-modified">185    *    - inflection points (i.e., where the `in&#39; and `out&#39; angles are the</span>
<span class="line-modified">186    *      same, but the curvature changes sign) [currently, such points</span>
<span class="line-modified">187    *      aren&#39;t handled specially in the auto-hinter]</span>
188    *
<span class="line-modified">189    *    `af_glyph_hints_align_strong_points&#39; is the function that takes</span>
<span class="line-modified">190    *    care of such situations; it is equivalent to the TrueType `IP&#39;</span>
<span class="line-modified">191    *    hinting instruction.</span>
192    *
193    *
<span class="line-modified">194    *  Weak Points</span>
195    *
<span class="line-modified">196    *    Other points in the outline must be interpolated using the</span>
<span class="line-modified">197    *    coordinates of their previous and next unfitted contour neighbours.</span>
<span class="line-modified">198    *    These are called `weak points&#39; and are touched by the function</span>
<span class="line-modified">199    *    `af_glyph_hints_align_weak_points&#39;, equivalent to the TrueType `IUP&#39;</span>
<span class="line-modified">200    *    hinting instruction.  Typical candidates are control points and</span>
<span class="line-modified">201    *    points on the contour without a major direction.</span>
202    *
<span class="line-modified">203    *    The major effect is to reduce possible distortion caused by</span>
<span class="line-modified">204    *    alignment of edges and strong points, thus weak points are processed</span>
<span class="line-modified">205    *    after strong points.</span>
206    */
207 
208 
209   /* point hint flags */
210 #define AF_FLAG_NONE  0
211 
212   /* point type flags */
213 #define AF_FLAG_CONIC    ( 1U &lt;&lt; 0 )
214 #define AF_FLAG_CUBIC    ( 1U &lt;&lt; 1 )
215 #define AF_FLAG_CONTROL  ( AF_FLAG_CONIC | AF_FLAG_CUBIC )
216 
217   /* point touch flags */
218 #define AF_FLAG_TOUCH_X  ( 1U &lt;&lt; 2 )
219 #define AF_FLAG_TOUCH_Y  ( 1U &lt;&lt; 3 )
220 
221   /* candidates for weak interpolation have this flag set */
222 #define AF_FLAG_WEAK_INTERPOLATION  ( 1U &lt;&lt; 4 )
223 
224   /* the distance to the next point is very small */
225 #define AF_FLAG_NEAR  ( 1U &lt;&lt; 5 )
</pre>
<hr />
<pre>
235 
236   typedef struct AF_PointRec_*    AF_Point;
237   typedef struct AF_SegmentRec_*  AF_Segment;
238   typedef struct AF_EdgeRec_*     AF_Edge;
239 
240 
241   typedef struct  AF_PointRec_
242   {
243     FT_UShort  flags;    /* point flags used by hinter   */
244     FT_Char    in_dir;   /* direction of inwards vector  */
245     FT_Char    out_dir;  /* direction of outwards vector */
246 
247     FT_Pos     ox, oy;   /* original, scaled position                   */
248     FT_Short   fx, fy;   /* original, unscaled position (in font units) */
249     FT_Pos     x, y;     /* current position                            */
250     FT_Pos     u, v;     /* current (x,y) or (y,x) depending on context */
251 
252     AF_Point   next;     /* next point in contour     */
253     AF_Point   prev;     /* previous point in contour */
254 






255   } AF_PointRec;
256 
257 
258   typedef struct  AF_SegmentRec_
259   {
260     FT_Byte     flags;       /* edge/segment flags for this segment */
261     FT_Char     dir;         /* segment direction                   */
262     FT_Short    pos;         /* position of segment                 */
263     FT_Short    delta;       /* deviation from segment position     */
264     FT_Short    min_coord;   /* minimum coordinate of segment       */
265     FT_Short    max_coord;   /* maximum coordinate of segment       */
266     FT_Short    height;      /* the hinted segment height           */
267 
268     AF_Edge     edge;        /* the segment&#39;s parent edge           */
269     AF_Segment  edge_next;   /* link to next segment in parent edge */
270 
271     AF_Segment  link;        /* (stem) link segment        */
272     AF_Segment  serif;       /* primary segment for serifs */
273     FT_Pos      score;       /* used during stem matching  */
274     FT_Pos      len;         /* used during stem matching  */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * afhints.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Auto-fitter hinting routines (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef AFHINTS_H_
 20 #define AFHINTS_H_
 21 
 22 #include &quot;aftypes.h&quot;
 23 
 24 #define xxAF_SORT_SEGMENTS
 25 
 26 FT_BEGIN_HEADER
 27 
 28   /*
<span class="line-modified"> 29    * The definition of outline glyph hints.  These are shared by all</span>
<span class="line-modified"> 30    * writing system analysis routines (until now).</span>
 31    */
 32 
 33   typedef enum  AF_Dimension_
 34   {
 35     AF_DIMENSION_HORZ = 0,  /* x coordinates,                    */
 36                             /* i.e., vertical segments &amp; edges   */
 37     AF_DIMENSION_VERT = 1,  /* y coordinates,                    */
 38                             /* i.e., horizontal segments &amp; edges */
 39 
 40     AF_DIMENSION_MAX  /* do not remove */
 41 
 42   } AF_Dimension;
 43 
 44 
 45   /* hint directions -- the values are computed so that two vectors are */
 46   /* in opposite directions iff `dir1 + dir2 == 0&#39;                      */
 47   typedef enum  AF_Direction_
 48   {
 49     AF_DIR_NONE  =  4,
 50     AF_DIR_RIGHT =  1,
 51     AF_DIR_LEFT  = -1,
 52     AF_DIR_UP    =  2,
 53     AF_DIR_DOWN  = -2
 54 
 55   } AF_Direction;
 56 
 57 
 58   /*
<span class="line-modified"> 59    * The following explanations are mostly taken from the article</span>
 60    *
<span class="line-modified"> 61    *   Real-Time Grid Fitting of Typographic Outlines</span>
 62    *
<span class="line-modified"> 63    * by David Turner and Werner Lemberg</span>
 64    *
<span class="line-modified"> 65    *   https://www.tug.org/TUGboat/Articles/tb24-3/lemberg.pdf</span>
 66    *
<span class="line-modified"> 67    * with appropriate updates.</span>
 68    *
 69    *
<span class="line-modified"> 70    * Segments</span>
 71    *
<span class="line-modified"> 72    *   `af_{cjk,latin,...}_hints_compute_segments&#39; are the functions to</span>
<span class="line-modified"> 73    *   find segments in an outline.</span>
 74    *
<span class="line-modified"> 75    *   A segment is a series of at least two consecutive points that are</span>
<span class="line-modified"> 76    *   approximately aligned along a coordinate axis.  The analysis to do</span>
<span class="line-modified"> 77    *   so is specific to a writing system.</span>
 78    *
 79    *
<span class="line-modified"> 80    * Edges</span>
 81    *
<span class="line-modified"> 82    *   `af_{cjk,latin,...}_hints_compute_edges&#39; are the functions to find</span>
<span class="line-modified"> 83    *   edges.</span>
 84    *
<span class="line-modified"> 85    *   As soon as segments are defined, the auto-hinter groups them into</span>
<span class="line-modified"> 86    *   edges.  An edge corresponds to a single position on the main</span>
<span class="line-modified"> 87    *   dimension that collects one or more segments (allowing for a small</span>
<span class="line-modified"> 88    *   threshold).</span>
 89    *
<span class="line-modified"> 90    *   As an example, the `latin&#39; writing system first tries to grid-fit</span>
<span class="line-modified"> 91    *   edges, then to align segments on the edges unless it detects that</span>
<span class="line-modified"> 92    *   they form a serif.</span>
 93    *
 94    *
<span class="line-modified"> 95    *                     A          H</span>
<span class="line-modified"> 96    *                      |        |</span>
<span class="line-modified"> 97    *                      |        |</span>
<span class="line-modified"> 98    *                      |        |</span>
<span class="line-modified"> 99    *                      |        |</span>
<span class="line-modified">100    *        C             |        |             F</span>
<span class="line-modified">101    *         +------&lt;-----+        +-----&lt;------+</span>
<span class="line-modified">102    *         |             B      G             |</span>
<span class="line-modified">103    *         |                                  |</span>
<span class="line-modified">104    *         |                                  |</span>
<span class="line-modified">105    *         +---------------&gt;------------------+</span>
<span class="line-modified">106    *        D                                    E</span>
107    *
108    *
<span class="line-modified">109    * Stems</span>
110    *
<span class="line-modified">111    *   Stems are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
112    *
<span class="line-modified">113    *   Segments need to be `linked&#39; to other ones in order to detect stems.</span>
<span class="line-modified">114    *   A stem is made of two segments that face each other in opposite</span>
<span class="line-modified">115    *   directions and that are sufficiently close to each other.  Using</span>
<span class="line-modified">116    *   vocabulary from the TrueType specification, stem segments form a</span>
<span class="line-modified">117    *   `black distance&#39;.</span>
118    *
<span class="line-modified">119    *   In the above ASCII drawing, the horizontal segments are BC, DE, and</span>
<span class="line-modified">120    *   FG; the vertical segments are AB, CD, EF, and GH.</span>
121    *
<span class="line-modified">122    *   Each segment has at most one `best&#39; candidate to form a black</span>
<span class="line-modified">123    *   distance, or no candidate at all.  Notice that two distinct segments</span>
<span class="line-modified">124    *   can have the same candidate, which frequently means a serif.</span>
125    *
<span class="line-modified">126    *   A stem is recognized by the following condition:</span>
127    *
<span class="line-modified">128    *     best segment_1 = segment_2 &amp;&amp; best segment_2 = segment_1</span>
129    *
<span class="line-modified">130    *   The best candidate is stored in field `link&#39; in structure</span>
<span class="line-modified">131    *   `AF_Segment&#39;.</span>
132    *
<span class="line-modified">133    *   In the above ASCII drawing, the best candidate for both AB and CD is</span>
<span class="line-modified">134    *   GH, while the best candidate for GH is AB.  Similarly, the best</span>
<span class="line-modified">135    *   candidate for EF and GH is AB, while the best candidate for AB is</span>
<span class="line-modified">136    *   GH.</span>
137    *
<span class="line-modified">138    *   The detection and handling of stems is dependent on the writing</span>
<span class="line-modified">139    *   system.</span>
140    *
141    *
<span class="line-modified">142    * Serifs</span>
143    *
<span class="line-modified">144    *   Serifs are detected by `af_{cjk,latin,...}_hint_edges&#39;.</span>
145    *
<span class="line-modified">146    *   In comparison to a stem, a serif (as handled by the auto-hinter</span>
<span class="line-modified">147    *   module that takes care of the `latin&#39; writing system) has</span>
148    *
<span class="line-modified">149    *     best segment_1 = segment_2 &amp;&amp; best segment_2 != segment_1</span>
150    *
<span class="line-modified">151    *   where segment_1 corresponds to the serif segment (CD and EF in the</span>
<span class="line-modified">152    *   above ASCII drawing).</span>
153    *
<span class="line-modified">154    *   The best candidate is stored in field `serif&#39; in structure</span>
<span class="line-modified">155    *   `AF_Segment&#39; (and `link&#39; is set to NULL).</span>
156    *
157    *
<span class="line-modified">158    * Touched points</span>
159    *
<span class="line-modified">160    *   A point is called `touched&#39; if it has been processed somehow by the</span>
<span class="line-modified">161    *   auto-hinter.  It basically means that it shouldn&#39;t be moved again</span>
<span class="line-modified">162    *   (or moved only under certain constraints to preserve the already</span>
<span class="line-modified">163    *   applied processing).</span>
164    *
165    *
<span class="line-modified">166    * Flat and round segments</span>
167    *
<span class="line-modified">168    *   Segments are `round&#39; or `flat&#39;, depending on the series of points</span>
<span class="line-modified">169    *   that define them.  A segment is round if the next and previous point</span>
<span class="line-modified">170    *   of an extremum (which can be either a single point or sequence of</span>
<span class="line-modified">171    *   points) are both conic or cubic control points.  Otherwise, a</span>
<span class="line-modified">172    *   segment with an extremum is flat.</span>
173    *
174    *
<span class="line-modified">175    * Strong Points</span>
176    *
<span class="line-modified">177    *   Experience has shown that points not part of an edge need to be</span>
<span class="line-modified">178    *   interpolated linearly between their two closest edges, even if these</span>
<span class="line-modified">179    *   are not part of the contour of those particular points.  Typical</span>
<span class="line-modified">180    *   candidates for this are</span>
181    *
<span class="line-modified">182    *   - angle points (i.e., points where the `in&#39; and `out&#39; direction</span>
<span class="line-modified">183    *     differ greatly)</span>
184    *
<span class="line-modified">185    *   - inflection points (i.e., where the `in&#39; and `out&#39; angles are the</span>
<span class="line-modified">186    *     same, but the curvature changes sign) [currently, such points</span>
<span class="line-modified">187    *     aren&#39;t handled specially in the auto-hinter]</span>
188    *
<span class="line-modified">189    *   `af_glyph_hints_align_strong_points&#39; is the function that takes</span>
<span class="line-modified">190    *   care of such situations; it is equivalent to the TrueType `IP&#39;</span>
<span class="line-modified">191    *   hinting instruction.</span>
192    *
193    *
<span class="line-modified">194    * Weak Points</span>
195    *
<span class="line-modified">196    *   Other points in the outline must be interpolated using the</span>
<span class="line-modified">197    *   coordinates of their previous and next unfitted contour neighbours.</span>
<span class="line-modified">198    *   These are called `weak points&#39; and are touched by the function</span>
<span class="line-modified">199    *   `af_glyph_hints_align_weak_points&#39;, equivalent to the TrueType `IUP&#39;</span>
<span class="line-modified">200    *   hinting instruction.  Typical candidates are control points and</span>
<span class="line-modified">201    *   points on the contour without a major direction.</span>
202    *
<span class="line-modified">203    *   The major effect is to reduce possible distortion caused by</span>
<span class="line-modified">204    *   alignment of edges and strong points, thus weak points are processed</span>
<span class="line-modified">205    *   after strong points.</span>
206    */
207 
208 
209   /* point hint flags */
210 #define AF_FLAG_NONE  0
211 
212   /* point type flags */
213 #define AF_FLAG_CONIC    ( 1U &lt;&lt; 0 )
214 #define AF_FLAG_CUBIC    ( 1U &lt;&lt; 1 )
215 #define AF_FLAG_CONTROL  ( AF_FLAG_CONIC | AF_FLAG_CUBIC )
216 
217   /* point touch flags */
218 #define AF_FLAG_TOUCH_X  ( 1U &lt;&lt; 2 )
219 #define AF_FLAG_TOUCH_Y  ( 1U &lt;&lt; 3 )
220 
221   /* candidates for weak interpolation have this flag set */
222 #define AF_FLAG_WEAK_INTERPOLATION  ( 1U &lt;&lt; 4 )
223 
224   /* the distance to the next point is very small */
225 #define AF_FLAG_NEAR  ( 1U &lt;&lt; 5 )
</pre>
<hr />
<pre>
235 
236   typedef struct AF_PointRec_*    AF_Point;
237   typedef struct AF_SegmentRec_*  AF_Segment;
238   typedef struct AF_EdgeRec_*     AF_Edge;
239 
240 
241   typedef struct  AF_PointRec_
242   {
243     FT_UShort  flags;    /* point flags used by hinter   */
244     FT_Char    in_dir;   /* direction of inwards vector  */
245     FT_Char    out_dir;  /* direction of outwards vector */
246 
247     FT_Pos     ox, oy;   /* original, scaled position                   */
248     FT_Short   fx, fy;   /* original, unscaled position (in font units) */
249     FT_Pos     x, y;     /* current position                            */
250     FT_Pos     u, v;     /* current (x,y) or (y,x) depending on context */
251 
252     AF_Point   next;     /* next point in contour     */
253     AF_Point   prev;     /* previous point in contour */
254 
<span class="line-added">255 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">256     /* track `before&#39; and `after&#39; edges for strong points */</span>
<span class="line-added">257     AF_Edge    before[2];</span>
<span class="line-added">258     AF_Edge    after[2];</span>
<span class="line-added">259 #endif</span>
<span class="line-added">260 </span>
261   } AF_PointRec;
262 
263 
264   typedef struct  AF_SegmentRec_
265   {
266     FT_Byte     flags;       /* edge/segment flags for this segment */
267     FT_Char     dir;         /* segment direction                   */
268     FT_Short    pos;         /* position of segment                 */
269     FT_Short    delta;       /* deviation from segment position     */
270     FT_Short    min_coord;   /* minimum coordinate of segment       */
271     FT_Short    max_coord;   /* maximum coordinate of segment       */
272     FT_Short    height;      /* the hinted segment height           */
273 
274     AF_Edge     edge;        /* the segment&#39;s parent edge           */
275     AF_Segment  edge_next;   /* link to next segment in parent edge */
276 
277     AF_Segment  link;        /* (stem) link segment        */
278     AF_Segment  serif;       /* primary segment for serifs */
279     FT_Pos      score;       /* used during stem matching  */
280     FT_Pos      len;         /* used during stem matching  */
</pre>
</td>
</tr>
</table>
<center><a href="afhints.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afindic.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
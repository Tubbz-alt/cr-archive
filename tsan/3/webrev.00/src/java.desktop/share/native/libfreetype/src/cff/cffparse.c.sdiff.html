<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/cff/cffparse.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="cffobjs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cffparse.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/cff/cffparse.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  cffparse.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    CFF token stream parser (body)                                       */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;cffparse.h&quot;
  21 #include FT_INTERNAL_STREAM_H
  22 #include FT_INTERNAL_DEBUG_H
  23 #include FT_INTERNAL_CALC_H
  24 #include FT_INTERNAL_POSTSCRIPT_AUX_H

  25 
  26 #include &quot;cfferrs.h&quot;
<span class="line-removed">  27 #include &quot;cffpic.h&quot;</span>
  28 #include &quot;cffload.h&quot;
  29 
  30 
<span class="line-modified">  31   /*************************************************************************/</span>
<span class="line-modified">  32   /*                                                                       */</span>
<span class="line-modified">  33   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  34   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  35   /* messages during execution.                                            */</span>
<span class="line-modified">  36   /*                                                                       */</span>
  37 #undef  FT_COMPONENT
<span class="line-modified">  38 #define FT_COMPONENT  trace_cffparse</span>
  39 
  40 
  41   FT_LOCAL_DEF( FT_Error )
  42   cff_parser_init( CFF_Parser  parser,
  43                    FT_UInt     code,
  44                    void*       object,
  45                    FT_Library  library,
  46                    FT_UInt     stackSize,
  47                    FT_UShort   num_designs,
  48                    FT_UShort   num_axes )
  49   {
  50     FT_Memory  memory = library-&gt;memory;    /* for FT_NEW_ARRAY */
  51     FT_Error   error;                       /* for FT_NEW_ARRAY */
  52 
  53 
  54     FT_ZERO( parser );
  55 
  56 #if 0
  57     parser-&gt;top         = parser-&gt;stack;
  58 #endif
</pre>
<hr />
<pre>
  60     parser-&gt;object      = object;
  61     parser-&gt;library     = library;
  62     parser-&gt;num_designs = num_designs;
  63     parser-&gt;num_axes    = num_axes;
  64 
  65     /* allocate the stack buffer */
  66     if ( FT_NEW_ARRAY( parser-&gt;stack, stackSize ) )
  67     {
  68       FT_FREE( parser-&gt;stack );
  69       goto Exit;
  70     }
  71 
  72     parser-&gt;stackSize = stackSize;
  73     parser-&gt;top       = parser-&gt;stack;    /* empty stack */
  74 
  75   Exit:
  76     return error;
  77   }
  78 
  79 

















  80   FT_LOCAL_DEF( void )
  81   cff_parser_done( CFF_Parser  parser )
  82   {
  83     FT_Memory  memory = parser-&gt;library-&gt;memory;    /* for FT_FREE */
  84 
  85 
  86     FT_FREE( parser-&gt;stack );




















































  87   }
  88 
  89 
  90   /* read an integer */
  91   static FT_Long
<span class="line-modified">  92   cff_parse_integer( FT_Byte*  start,</span>
<span class="line-modified">  93                      FT_Byte*  limit )</span>
  94   {
  95     FT_Byte*  p   = start;
  96     FT_Int    v   = *p++;
  97     FT_Long   val = 0;
  98 
  99 
 100     if ( v == 28 )
 101     {
<span class="line-modified"> 102       if ( p + 2 &gt; limit )</span>
 103         goto Bad;
 104 
 105       val = (FT_Short)( ( (FT_UShort)p[0] &lt;&lt; 8 ) | p[1] );
 106     }
 107     else if ( v == 29 )
 108     {
<span class="line-modified"> 109       if ( p + 4 &gt; limit )</span>
 110         goto Bad;
 111 
 112       val = (FT_Long)( ( (FT_ULong)p[0] &lt;&lt; 24 ) |
 113                        ( (FT_ULong)p[1] &lt;&lt; 16 ) |
 114                        ( (FT_ULong)p[2] &lt;&lt;  8 ) |
 115                          (FT_ULong)p[3]         );
 116     }
 117     else if ( v &lt; 247 )
 118     {
 119       val = v - 139;
 120     }
 121     else if ( v &lt; 251 )
 122     {
<span class="line-modified"> 123       if ( p + 1 &gt; limit )</span>
 124         goto Bad;
 125 
 126       val = ( v - 247 ) * 256 + p[0] + 108;
 127     }
 128     else
 129     {
<span class="line-modified"> 130       if ( p + 1 &gt; limit )</span>
 131         goto Bad;
 132 
 133       val = -( v - 251 ) * 256 - p[0] - 108;
 134     }
 135 
 136   Exit:
 137     return val;
 138 
 139   Bad:
 140     val = 0;
 141     FT_TRACE4(( &quot;!!!END OF DATA:!!!&quot; ));
 142     goto Exit;
 143   }
 144 
 145 
 146   static const FT_Long power_tens[] =
 147   {
 148     1L,
 149     10L,
 150     100L,
</pre>
<hr />
<pre>
 159 
 160   /* maximum values allowed for multiplying      */
 161   /* with the corresponding `power_tens&#39; element */
 162   static const FT_Long power_ten_limits[] =
 163   {
 164     FT_LONG_MAX / 1L,
 165     FT_LONG_MAX / 10L,
 166     FT_LONG_MAX / 100L,
 167     FT_LONG_MAX / 1000L,
 168     FT_LONG_MAX / 10000L,
 169     FT_LONG_MAX / 100000L,
 170     FT_LONG_MAX / 1000000L,
 171     FT_LONG_MAX / 10000000L,
 172     FT_LONG_MAX / 100000000L,
 173     FT_LONG_MAX / 1000000000L,
 174   };
 175 
 176 
 177   /* read a real */
 178   static FT_Fixed
<span class="line-modified"> 179   cff_parse_real( FT_Byte*  start,</span>
<span class="line-modified"> 180                   FT_Byte*  limit,</span>
<span class="line-modified"> 181                   FT_Long   power_ten,</span>
<span class="line-modified"> 182                   FT_Long*  scaling )</span>
 183   {
 184     FT_Byte*  p = start;
 185     FT_Int    nib;
 186     FT_UInt   phase;
 187 
 188     FT_Long   result, number, exponent;
 189     FT_Int    sign = 0, exponent_sign = 0, have_overflow = 0;
 190     FT_Long   exponent_add, integer_length, fraction_length;
 191 
 192 
 193     if ( scaling )
 194       *scaling = 0;
 195 
 196     result = 0;
 197 
 198     number   = 0;
 199     exponent = 0;
 200 
 201     exponent_add    = 0;
 202     integer_length  = 0;
 203     fraction_length = 0;
 204 
 205     /* First of all, read the integer part. */
 206     phase = 4;
 207 
 208     for (;;)
 209     {
 210       /* If we entered this iteration with phase == 4, we need to */
 211       /* read a new byte.  This also skips past the initial 0x1E. */
 212       if ( phase )
 213       {
 214         p++;
 215 
 216         /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 217         if ( p &gt;= limit )</span>
 218           goto Bad;
 219       }
 220 
 221       /* Get the nibble. */
 222       nib   = (FT_Int)( p[0] &gt;&gt; phase ) &amp; 0xF;
 223       phase = 4 - phase;
 224 
 225       if ( nib == 0xE )
 226         sign = 1;
 227       else if ( nib &gt; 9 )
 228         break;
 229       else
 230       {
 231         /* Increase exponent if we can&#39;t add the digit. */
 232         if ( number &gt;= 0xCCCCCCCL )
 233           exponent_add++;
 234         /* Skip leading zeros. */
 235         else if ( nib || number )
 236         {
 237           integer_length++;
 238           number = number * 10 + nib;
 239         }
 240       }
 241     }
 242 
 243     /* Read fraction part, if any. */
 244     if ( nib == 0xA )
 245       for (;;)
 246       {
 247         /* If we entered this iteration with phase == 4, we need */
 248         /* to read a new byte.                                   */
 249         if ( phase )
 250         {
 251           p++;
 252 
 253           /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 254           if ( p &gt;= limit )</span>
 255             goto Bad;
 256         }
 257 
 258         /* Get the nibble. */
 259         nib   = ( p[0] &gt;&gt; phase ) &amp; 0xF;
 260         phase = 4 - phase;
 261         if ( nib &gt;= 10 )
 262           break;
 263 
 264         /* Skip leading zeros if possible. */
 265         if ( !nib &amp;&amp; !number )
 266           exponent_add--;
 267         /* Only add digit if we don&#39;t overflow. */
 268         else if ( number &lt; 0xCCCCCCCL &amp;&amp; fraction_length &lt; 9 )
 269         {
 270           fraction_length++;
 271           number = number * 10 + nib;
 272         }
 273       }
 274 
 275     /* Read exponent, if any. */
 276     if ( nib == 12 )
 277     {
 278       exponent_sign = 1;
 279       nib           = 11;
 280     }
 281 
 282     if ( nib == 11 )
 283     {
 284       for (;;)
 285       {
 286         /* If we entered this iteration with phase == 4, */
 287         /* we need to read a new byte.                   */
 288         if ( phase )
 289         {
 290           p++;
 291 
 292           /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 293           if ( p &gt;= limit )</span>
 294             goto Bad;
 295         }
 296 
 297         /* Get the nibble. */
 298         nib   = ( p[0] &gt;&gt; phase ) &amp; 0xF;
 299         phase = 4 - phase;
 300         if ( nib &gt;= 10 )
 301           break;
 302 
 303         /* Arbitrarily limit exponent. */
 304         if ( exponent &gt; 1000 )
 305           have_overflow = 1;
 306         else
 307           exponent = exponent * 10 + nib;
 308       }
 309 
 310       if ( exponent_sign )
 311         exponent = -exponent;
 312     }
 313 
</pre>
<hr />
<pre>
 440   Underflow:
 441     result = 0;
 442     FT_TRACE4(( &quot;!!!UNDERFLOW:!!!&quot; ));
 443     goto Exit;
 444 
 445   Bad:
 446     result = 0;
 447     FT_TRACE4(( &quot;!!!END OF DATA:!!!&quot; ));
 448     goto Exit;
 449   }
 450 
 451 
 452   /* read a number, either integer or real */
 453   FT_LOCAL_DEF( FT_Long )
 454   cff_parse_num( CFF_Parser  parser,
 455                  FT_Byte**   d )
 456   {
 457     if ( **d == 30 )
 458     {
 459       /* binary-coded decimal is truncated to integer */
<span class="line-modified"> 460       return cff_parse_real( *d, parser-&gt;limit, 0, NULL ) &gt;&gt; 16;</span>
 461     }
 462 
 463     else if ( **d == 255 )
 464     {
 465       /* 16.16 fixed point is used internally for CFF2 blend results. */
 466       /* Since these are trusted values, a limit check is not needed. */
 467 
 468       /* After the 255, 4 bytes give the number.                 */
 469       /* The blend value is converted to integer, with rounding; */
 470       /* due to the right-shift we don&#39;t need the lowest byte.   */
 471 #if 0
 472       return (FT_Short)(
 473                ( ( ( (FT_UInt32)*( d[0] + 1 ) &lt;&lt; 24 ) |
 474                    ( (FT_UInt32)*( d[0] + 2 ) &lt;&lt; 16 ) |
 475                    ( (FT_UInt32)*( d[0] + 3 ) &lt;&lt;  8 ) |
 476                      (FT_UInt32)*( d[0] + 4 )         ) + 0x8000U ) &gt;&gt; 16 );
 477 #else
 478       return (FT_Short)(
 479                ( ( ( (FT_UInt32)*( d[0] + 1 ) &lt;&lt; 16 ) |
 480                    ( (FT_UInt32)*( d[0] + 2 ) &lt;&lt;  8 ) |
 481                      (FT_UInt32)*( d[0] + 3 )         ) + 0x80U ) &gt;&gt; 8 );
 482 #endif
 483     }
 484 
 485     else
<span class="line-modified"> 486       return cff_parse_integer( *d, parser-&gt;limit );</span>
 487   }
 488 
 489 
 490   /* read a floating point number, either integer or real */
 491   static FT_Fixed
 492   do_fixed( CFF_Parser  parser,
 493             FT_Byte**   d,
 494             FT_Long     scaling )
 495   {
 496     if ( **d == 30 )
<span class="line-modified"> 497       return cff_parse_real( *d, parser-&gt;limit, scaling, NULL );</span>
 498     else
 499     {
<span class="line-modified"> 500       FT_Long  val = cff_parse_integer( *d, parser-&gt;limit );</span>
 501 
 502 
 503       if ( scaling )
 504       {
 505         if ( FT_ABS( val ) &gt; power_ten_limits[scaling] )
 506         {
 507           val = val &gt; 0 ? 0x7FFFFFFFL : -0x7FFFFFFFL;
 508           goto Overflow;
 509         }
 510 
 511         val *= power_tens[scaling];
 512       }
 513 
 514       if ( val &gt; 0x7FFF )
 515       {
 516         val = 0x7FFFFFFFL;
 517         goto Overflow;
 518       }
 519       else if ( val &lt; -0x7FFF )
 520       {
</pre>
<hr />
<pre>
 545   static FT_Fixed
 546   cff_parse_fixed_scaled( CFF_Parser  parser,
 547                           FT_Byte**   d,
 548                           FT_Long     scaling )
 549   {
 550     return do_fixed( parser, d, scaling );
 551   }
 552 
 553 
 554   /* read a floating point number, either integer or real,     */
 555   /* and return it as precise as possible -- `scaling&#39; returns */
 556   /* the scaling factor (as a power of 10)                     */
 557   static FT_Fixed
 558   cff_parse_fixed_dynamic( CFF_Parser  parser,
 559                            FT_Byte**   d,
 560                            FT_Long*    scaling )
 561   {
 562     FT_ASSERT( scaling );
 563 
 564     if ( **d == 30 )
<span class="line-modified"> 565       return cff_parse_real( *d, parser-&gt;limit, 0, scaling );</span>
 566     else
 567     {
 568       FT_Long  number;
 569       FT_Int   integer_length;
 570 
 571 
<span class="line-modified"> 572       number = cff_parse_integer( d[0], d[1] );</span>
 573 
 574       if ( number &gt; 0x7FFFL )
 575       {
 576         for ( integer_length = 5; integer_length &lt; 10; integer_length++ )
 577           if ( number &lt; power_tens[integer_length] )
 578             break;
 579 
 580         if ( ( number / power_tens[integer_length - 5] ) &gt; 0x7FFFL )
 581         {
 582           *scaling = integer_length - 4;
 583           return FT_DivFix( number, power_tens[integer_length - 4] );
 584         }
 585         else
 586         {
 587           *scaling = integer_length - 5;
 588           return FT_DivFix( number, power_tens[integer_length - 5] );
 589         }
 590       }
 591       else
 592       {
 593         *scaling = 0;
 594         return (FT_Long)( (FT_ULong)number &lt;&lt; 16 );
 595       }
 596     }
 597   }
 598 
 599 
 600   static FT_Error
 601   cff_parse_font_matrix( CFF_Parser  parser )
 602   {
 603     CFF_FontRecDict  dict   = (CFF_FontRecDict)parser-&gt;object;
 604     FT_Matrix*       matrix = &amp;dict-&gt;font_matrix;
 605     FT_Vector*       offset = &amp;dict-&gt;font_offset;
 606     FT_ULong*        upm    = &amp;dict-&gt;units_per_em;
 607     FT_Byte**        data   = parser-&gt;stack;
<span class="line-removed"> 608     FT_Error         error  = FT_ERR( Stack_Underflow );</span>
 609 
 610 
 611     if ( parser-&gt;top &gt;= parser-&gt;stack + 6 )
 612     {
 613       FT_Fixed  values[6];
 614       FT_Long   scalings[6];
 615 
 616       FT_Long  min_scaling, max_scaling;
 617       int      i;
 618 
 619 
<span class="line-removed"> 620       error = FT_Err_Ok;</span>
<span class="line-removed"> 621 </span>
 622       dict-&gt;has_font_matrix = TRUE;
 623 
 624       /* We expect a well-formed font matrix, this is, the matrix elements */
 625       /* `xx&#39; and `yy&#39; are of approximately the same magnitude.  To avoid  */
 626       /* loss of precision, we use the magnitude of the largest matrix     */
 627       /* element to scale all other elements.  The scaling factor is then  */
 628       /* contained in the `units_per_em&#39; value.                            */
 629 
 630       max_scaling = FT_LONG_MIN;
 631       min_scaling = FT_LONG_MAX;
 632 
 633       for ( i = 0; i &lt; 6; i++ )
 634       {
 635         values[i] = cff_parse_fixed_dynamic( parser, data++, &amp;scalings[i] );
 636         if ( values[i] )
 637         {
 638           if ( scalings[i] &gt; max_scaling )
 639             max_scaling = scalings[i];
 640           if ( scalings[i] &lt; min_scaling )
 641             min_scaling = scalings[i];
 642         }
 643       }
 644 
 645       if ( max_scaling &lt; -9                  ||
 646            max_scaling &gt; 0                   ||
 647            ( max_scaling - min_scaling ) &lt; 0 ||
 648            ( max_scaling - min_scaling ) &gt; 9 )
 649       {
<span class="line-removed"> 650         /* Return default matrix in case of unlikely values. */</span>
<span class="line-removed"> 651 </span>
 652         FT_TRACE1(( &quot;cff_parse_font_matrix:&quot;
 653                     &quot; strange scaling values (minimum %d, maximum %d),\n&quot;
 654                     &quot;                      &quot;
 655                     &quot; using default matrix\n&quot;, min_scaling, max_scaling ));
<span class="line-modified"> 656 </span>
<span class="line-removed"> 657         matrix-&gt;xx = 0x10000L;</span>
<span class="line-removed"> 658         matrix-&gt;yx = 0;</span>
<span class="line-removed"> 659         matrix-&gt;xy = 0;</span>
<span class="line-removed"> 660         matrix-&gt;yy = 0x10000L;</span>
<span class="line-removed"> 661         offset-&gt;x  = 0;</span>
<span class="line-removed"> 662         offset-&gt;y  = 0;</span>
<span class="line-removed"> 663         *upm       = 1;</span>
<span class="line-removed"> 664 </span>
<span class="line-removed"> 665         goto Exit;</span>
 666       }
 667 
 668       for ( i = 0; i &lt; 6; i++ )
 669       {
 670         FT_Fixed  value = values[i];
 671         FT_Long   divisor, half_divisor;
 672 
 673 
 674         if ( !value )
 675           continue;
 676 
 677         divisor      = power_tens[max_scaling - scalings[i]];
 678         half_divisor = divisor &gt;&gt; 1;
 679 
 680         if ( value &lt; 0 )
 681         {
 682           if ( FT_LONG_MIN + half_divisor &lt; value )
 683             values[i] = ( value - half_divisor ) / divisor;
 684           else
 685             values[i] = FT_LONG_MIN / divisor;
</pre>
<hr />
<pre>
 692             values[i] = FT_LONG_MAX / divisor;
 693         }
 694       }
 695 
 696       matrix-&gt;xx = values[0];
 697       matrix-&gt;yx = values[1];
 698       matrix-&gt;xy = values[2];
 699       matrix-&gt;yy = values[3];
 700       offset-&gt;x  = values[4];
 701       offset-&gt;y  = values[5];
 702 
 703       *upm = (FT_ULong)power_tens[-max_scaling];
 704 
 705       FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,
 706                   (double)matrix-&gt;xx / *upm / 65536,
 707                   (double)matrix-&gt;xy / *upm / 65536,
 708                   (double)matrix-&gt;yx / *upm / 65536,
 709                   (double)matrix-&gt;yy / *upm / 65536,
 710                   (double)offset-&gt;x  / *upm / 65536,
 711                   (double)offset-&gt;y  / *upm / 65536 ));









 712     }


 713 
<span class="line-modified"> 714   Exit:</span>
<span class="line-modified"> 715     return error;</span>










 716   }
 717 
 718 
 719   static FT_Error
 720   cff_parse_font_bbox( CFF_Parser  parser )
 721   {
 722     CFF_FontRecDict  dict = (CFF_FontRecDict)parser-&gt;object;
 723     FT_BBox*         bbox = &amp;dict-&gt;font_bbox;
 724     FT_Byte**        data = parser-&gt;stack;
 725     FT_Error         error;
 726 
 727 
 728     error = FT_ERR( Stack_Underflow );
 729 
 730     if ( parser-&gt;top &gt;= parser-&gt;stack + 4 )
 731     {
 732       bbox-&gt;xMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 733       bbox-&gt;yMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 734       bbox-&gt;xMax = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 735       bbox-&gt;yMax = FT_RoundFix( cff_parse_fixed( parser, data   ) );
</pre>
<hr />
<pre>
 785       error = FT_Err_Ok;
 786     }
 787 
 788   Fail:
 789     return error;
 790   }
 791 
 792 
 793   /* The `MultipleMaster&#39; operator comes before any  */
 794   /* top DICT operators that contain T2 charstrings. */
 795 
 796   static FT_Error
 797   cff_parse_multiple_master( CFF_Parser  parser )
 798   {
 799     CFF_FontRecDict  dict = (CFF_FontRecDict)parser-&gt;object;
 800     FT_Error         error;
 801 
 802 
 803 #ifdef FT_DEBUG_LEVEL_TRACE
 804     /* beautify tracing message */
<span class="line-modified"> 805     if ( ft_trace_levels[FT_COMPONENT] &lt; 4 )</span>
 806       FT_TRACE1(( &quot;Multiple Master CFFs not supported yet,&quot;
 807                   &quot; handling first master design only\n&quot; ));
 808     else
 809       FT_TRACE1(( &quot; (not supported yet,&quot;
 810                   &quot; handling first master design only)\n&quot; ));
 811 #endif
 812 
 813     error = FT_ERR( Stack_Underflow );
 814 
 815     /* currently, we handle only the first argument */
 816     if ( parser-&gt;top &gt;= parser-&gt;stack + 5 )
 817     {
 818       FT_Long  num_designs = cff_parse_num( parser, parser-&gt;stack );
 819 
 820 
 821       if ( num_designs &gt; 16 || num_designs &lt; 2 )
 822       {
 823         FT_ERROR(( &quot;cff_parse_multiple_master:&quot;
 824                    &quot; Invalid number of designs\n&quot; ));
 825         error = FT_THROW( Invalid_File_Format );
</pre>
<hr />
<pre>
 986 
 987     FT_TRACE4(( &quot; %d\n&quot;, dict-&gt;maxstack ));
 988 
 989   Exit:
 990     return error;
 991   }
 992 
 993 
 994 #define CFF_FIELD_NUM( code, name, id )             \
 995           CFF_FIELD( code, name, id, cff_kind_num )
 996 #define CFF_FIELD_FIXED( code, name, id )             \
 997           CFF_FIELD( code, name, id, cff_kind_fixed )
 998 #define CFF_FIELD_FIXED_1000( code, name, id )                 \
 999           CFF_FIELD( code, name, id, cff_kind_fixed_thousand )
1000 #define CFF_FIELD_STRING( code, name, id )             \
1001           CFF_FIELD( code, name, id, cff_kind_string )
1002 #define CFF_FIELD_BOOL( code, name, id )             \
1003           CFF_FIELD( code, name, id, cff_kind_bool )
1004 
1005 
<span class="line-removed">1006 #ifndef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">1007 </span>
<span class="line-removed">1008 </span>
1009 #undef  CFF_FIELD
1010 #undef  CFF_FIELD_DELTA
1011 
1012 
1013 #ifndef FT_DEBUG_LEVEL_TRACE
1014 
1015 
1016 #define CFF_FIELD_CALLBACK( code, name, id ) \
1017           {                                  \
1018             cff_kind_callback,               \
1019             code | CFFCODE,                  \
1020             0, 0,                            \
1021             cff_parse_ ## name,              \
1022             0, 0                             \
1023           },
1024 
1025 #define CFF_FIELD_BLEND( code, id ) \
1026           {                         \
1027             cff_kind_blend,         \
1028             code | CFFCODE,         \
</pre>
<hr />
<pre>
1101             FT_FIELD_OFFSET( name ),           \
1102             FT_FIELD_SIZE_DELTA( name ),       \
1103             0,                                 \
1104             max,                               \
1105             FT_FIELD_OFFSET( num_ ## name ),   \
1106             id                                 \
1107           },
1108 
1109   static const CFF_Field_Handler  cff_field_handlers[] =
1110   {
1111 
1112 #include &quot;cfftoken.h&quot;
1113 
1114     { 0, 0, 0, 0, 0, 0, 0, 0 }
1115   };
1116 
1117 
1118 #endif /* FT_DEBUG_LEVEL_TRACE */
1119 
1120 
<span class="line-removed">1121 #else /* FT_CONFIG_OPTION_PIC */</span>
<span class="line-removed">1122 </span>
<span class="line-removed">1123 </span>
<span class="line-removed">1124   void</span>
<span class="line-removed">1125   FT_Destroy_Class_cff_field_handlers( FT_Library          library,</span>
<span class="line-removed">1126                                        CFF_Field_Handler*  clazz )</span>
<span class="line-removed">1127   {</span>
<span class="line-removed">1128     FT_Memory  memory = library-&gt;memory;</span>
<span class="line-removed">1129 </span>
<span class="line-removed">1130 </span>
<span class="line-removed">1131     if ( clazz )</span>
<span class="line-removed">1132       FT_FREE( clazz );</span>
<span class="line-removed">1133   }</span>
<span class="line-removed">1134 </span>
<span class="line-removed">1135 </span>
<span class="line-removed">1136   FT_Error</span>
<span class="line-removed">1137   FT_Create_Class_cff_field_handlers( FT_Library           library,</span>
<span class="line-removed">1138                                       CFF_Field_Handler**  output_class )</span>
<span class="line-removed">1139   {</span>
<span class="line-removed">1140     CFF_Field_Handler*  clazz  = NULL;</span>
<span class="line-removed">1141     FT_Error            error;</span>
<span class="line-removed">1142     FT_Memory           memory = library-&gt;memory;</span>
<span class="line-removed">1143 </span>
<span class="line-removed">1144     int  i = 0;</span>
<span class="line-removed">1145 </span>
<span class="line-removed">1146 </span>
<span class="line-removed">1147 #undef CFF_FIELD</span>
<span class="line-removed">1148 #define CFF_FIELD( code, name, id, kind ) i++;</span>
<span class="line-removed">1149 #undef CFF_FIELD_DELTA</span>
<span class="line-removed">1150 #define CFF_FIELD_DELTA( code, name, max, id ) i++;</span>
<span class="line-removed">1151 #undef CFF_FIELD_CALLBACK</span>
<span class="line-removed">1152 #define CFF_FIELD_CALLBACK( code, name, id ) i++;</span>
<span class="line-removed">1153 #undef CFF_FIELD_BLEND</span>
<span class="line-removed">1154 #define CFF_FIELD_BLEND( code, id ) i++;</span>
<span class="line-removed">1155 </span>
<span class="line-removed">1156 #include &quot;cfftoken.h&quot;</span>
<span class="line-removed">1157 </span>
<span class="line-removed">1158     i++; /* { 0, 0, 0, 0, 0, 0, 0 } */</span>
<span class="line-removed">1159 </span>
<span class="line-removed">1160     if ( FT_ALLOC( clazz, sizeof ( CFF_Field_Handler ) * i ) )</span>
<span class="line-removed">1161       return error;</span>
<span class="line-removed">1162 </span>
<span class="line-removed">1163     i = 0;</span>
<span class="line-removed">1164 </span>
<span class="line-removed">1165 </span>
<span class="line-removed">1166 #ifndef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-removed">1167 </span>
<span class="line-removed">1168 </span>
<span class="line-removed">1169 #undef CFF_FIELD_CALLBACK</span>
<span class="line-removed">1170 #define CFF_FIELD_CALLBACK( code_, name_, id_ )        \</span>
<span class="line-removed">1171           clazz[i].kind         = cff_kind_callback;   \</span>
<span class="line-removed">1172           clazz[i].code         = code_ | CFFCODE;     \</span>
<span class="line-removed">1173           clazz[i].offset       = 0;                   \</span>
<span class="line-removed">1174           clazz[i].size         = 0;                   \</span>
<span class="line-removed">1175           clazz[i].reader       = cff_parse_ ## name_; \</span>
<span class="line-removed">1176           clazz[i].array_max    = 0;                   \</span>
<span class="line-removed">1177           clazz[i].count_offset = 0;                   \</span>
<span class="line-removed">1178           i++;</span>
<span class="line-removed">1179 </span>
<span class="line-removed">1180 #undef  CFF_FIELD</span>
<span class="line-removed">1181 #define CFF_FIELD( code_, name_, id_, kind_ )               \</span>
<span class="line-removed">1182           clazz[i].kind         = kind_;                    \</span>
<span class="line-removed">1183           clazz[i].code         = code_ | CFFCODE;          \</span>
<span class="line-removed">1184           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \</span>
<span class="line-removed">1185           clazz[i].size         = FT_FIELD_SIZE( name_ );   \</span>
<span class="line-removed">1186           clazz[i].reader       = 0;                        \</span>
<span class="line-removed">1187           clazz[i].array_max    = 0;                        \</span>
<span class="line-removed">1188           clazz[i].count_offset = 0;                        \</span>
<span class="line-removed">1189           i++;                                              \</span>
<span class="line-removed">1190 </span>
<span class="line-removed">1191 #undef  CFF_FIELD_DELTA</span>
<span class="line-removed">1192 #define CFF_FIELD_DELTA( code_, name_, max_, id_ )                  \</span>
<span class="line-removed">1193           clazz[i].kind         = cff_kind_delta;                   \</span>
<span class="line-removed">1194           clazz[i].code         = code_ | CFFCODE;                  \</span>
<span class="line-removed">1195           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \</span>
<span class="line-removed">1196           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \</span>
<span class="line-removed">1197           clazz[i].reader       = 0;                                \</span>
<span class="line-removed">1198           clazz[i].array_max    = max_;                             \</span>
<span class="line-removed">1199           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \</span>
<span class="line-removed">1200           i++;</span>
<span class="line-removed">1201 </span>
<span class="line-removed">1202 #undef  CFF_FIELD_BLEND</span>
<span class="line-removed">1203 #define CFF_FIELD_BLEND( code_, id_ )              \</span>
<span class="line-removed">1204           clazz[i].kind         = cff_kind_blend;  \</span>
<span class="line-removed">1205           clazz[i].code         = code_ | CFFCODE; \</span>
<span class="line-removed">1206           clazz[i].offset       = 0;               \</span>
<span class="line-removed">1207           clazz[i].size         = 0;               \</span>
<span class="line-removed">1208           clazz[i].reader       = cff_parse_blend; \</span>
<span class="line-removed">1209           clazz[i].array_max    = 0;               \</span>
<span class="line-removed">1210           clazz[i].count_offset = 0;               \</span>
<span class="line-removed">1211           i++;</span>
<span class="line-removed">1212 </span>
<span class="line-removed">1213 #include &quot;cfftoken.h&quot;</span>
<span class="line-removed">1214 </span>
<span class="line-removed">1215     clazz[i].kind         = 0;</span>
<span class="line-removed">1216     clazz[i].code         = 0;</span>
<span class="line-removed">1217     clazz[i].offset       = 0;</span>
<span class="line-removed">1218     clazz[i].size         = 0;</span>
<span class="line-removed">1219     clazz[i].reader       = 0;</span>
<span class="line-removed">1220     clazz[i].array_max    = 0;</span>
<span class="line-removed">1221     clazz[i].count_offset = 0;</span>
<span class="line-removed">1222 </span>
<span class="line-removed">1223 </span>
<span class="line-removed">1224 #else /* FT_DEBUG_LEVEL_TRACE */</span>
<span class="line-removed">1225 </span>
<span class="line-removed">1226 </span>
<span class="line-removed">1227 #undef CFF_FIELD_CALLBACK</span>
<span class="line-removed">1228 #define CFF_FIELD_CALLBACK( code_, name_, id_ )        \</span>
<span class="line-removed">1229           clazz[i].kind         = cff_kind_callback;   \</span>
<span class="line-removed">1230           clazz[i].code         = code_ | CFFCODE;     \</span>
<span class="line-removed">1231           clazz[i].offset       = 0;                   \</span>
<span class="line-removed">1232           clazz[i].size         = 0;                   \</span>
<span class="line-removed">1233           clazz[i].reader       = cff_parse_ ## name_; \</span>
<span class="line-removed">1234           clazz[i].array_max    = 0;                   \</span>
<span class="line-removed">1235           clazz[i].count_offset = 0;                   \</span>
<span class="line-removed">1236           clazz[i].id           = id_;                 \</span>
<span class="line-removed">1237           i++;</span>
<span class="line-removed">1238 </span>
<span class="line-removed">1239 #undef  CFF_FIELD</span>
<span class="line-removed">1240 #define CFF_FIELD( code_, name_, id_, kind_ )               \</span>
<span class="line-removed">1241           clazz[i].kind         = kind_;                    \</span>
<span class="line-removed">1242           clazz[i].code         = code_ | CFFCODE;          \</span>
<span class="line-removed">1243           clazz[i].offset       = FT_FIELD_OFFSET( name_ ); \</span>
<span class="line-removed">1244           clazz[i].size         = FT_FIELD_SIZE( name_ );   \</span>
<span class="line-removed">1245           clazz[i].reader       = 0;                        \</span>
<span class="line-removed">1246           clazz[i].array_max    = 0;                        \</span>
<span class="line-removed">1247           clazz[i].count_offset = 0;                        \</span>
<span class="line-removed">1248           clazz[i].id           = id_;                      \</span>
<span class="line-removed">1249           i++;                                              \</span>
<span class="line-removed">1250 </span>
<span class="line-removed">1251 #undef  CFF_FIELD_DELTA</span>
<span class="line-removed">1252 #define CFF_FIELD_DELTA( code_, name_, max_, id_ )                  \</span>
<span class="line-removed">1253           clazz[i].kind         = cff_kind_delta;                   \</span>
<span class="line-removed">1254           clazz[i].code         = code_ | CFFCODE;                  \</span>
<span class="line-removed">1255           clazz[i].offset       = FT_FIELD_OFFSET( name_ );         \</span>
<span class="line-removed">1256           clazz[i].size         = FT_FIELD_SIZE_DELTA( name_ );     \</span>
<span class="line-removed">1257           clazz[i].reader       = 0;                                \</span>
<span class="line-removed">1258           clazz[i].array_max    = max_;                             \</span>
<span class="line-removed">1259           clazz[i].count_offset = FT_FIELD_OFFSET( num_ ## name_ ); \</span>
<span class="line-removed">1260           clazz[i].id           = id_;                              \</span>
<span class="line-removed">1261           i++;</span>
<span class="line-removed">1262 </span>
<span class="line-removed">1263 #undef  CFF_FIELD_BLEND</span>
<span class="line-removed">1264 #define CFF_FIELD_BLEND( code_, id_ )              \</span>
<span class="line-removed">1265           clazz[i].kind         = cff_kind_blend;  \</span>
<span class="line-removed">1266           clazz[i].code         = code_ | CFFCODE; \</span>
<span class="line-removed">1267           clazz[i].offset       = 0;               \</span>
<span class="line-removed">1268           clazz[i].size         = 0;               \</span>
<span class="line-removed">1269           clazz[i].reader       = cff_parse_blend; \</span>
<span class="line-removed">1270           clazz[i].array_max    = 0;               \</span>
<span class="line-removed">1271           clazz[i].count_offset = 0;               \</span>
<span class="line-removed">1272           clazz[i].id           = id_;             \</span>
<span class="line-removed">1273           i++;</span>
<span class="line-removed">1274 </span>
<span class="line-removed">1275 #include &quot;cfftoken.h&quot;</span>
<span class="line-removed">1276 </span>
<span class="line-removed">1277     clazz[i].kind         = 0;</span>
<span class="line-removed">1278     clazz[i].code         = 0;</span>
<span class="line-removed">1279     clazz[i].offset       = 0;</span>
<span class="line-removed">1280     clazz[i].size         = 0;</span>
<span class="line-removed">1281     clazz[i].reader       = 0;</span>
<span class="line-removed">1282     clazz[i].array_max    = 0;</span>
<span class="line-removed">1283     clazz[i].count_offset = 0;</span>
<span class="line-removed">1284     clazz[i].id           = 0;</span>
<span class="line-removed">1285 </span>
<span class="line-removed">1286 </span>
<span class="line-removed">1287 #endif /* FT_DEBUG_LEVEL_TRACE */</span>
<span class="line-removed">1288 </span>
<span class="line-removed">1289 </span>
<span class="line-removed">1290     *output_class = clazz;</span>
<span class="line-removed">1291 </span>
<span class="line-removed">1292     return FT_Err_Ok;</span>
<span class="line-removed">1293   }</span>
<span class="line-removed">1294 </span>
<span class="line-removed">1295 </span>
<span class="line-removed">1296 #endif /* FT_CONFIG_OPTION_PIC */</span>
<span class="line-removed">1297 </span>
<span class="line-removed">1298 </span>
1299   FT_LOCAL_DEF( FT_Error )
1300   cff_parser_run( CFF_Parser  parser,
1301                   FT_Byte*    start,
1302                   FT_Byte*    limit )
1303   {



1304 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1305     PSAux_Service  psaux;
<span class="line-removed">1306 #endif</span>
1307 
<span class="line-removed">1308     FT_Byte*    p       = start;</span>
<span class="line-removed">1309     FT_Error    error   = FT_Err_Ok;</span>
1310     FT_Library  library = parser-&gt;library;
<span class="line-modified">1311 </span>
<span class="line-modified">1312     FT_UNUSED( library );</span>
<span class="line-removed">1313 </span>
1314 
1315     parser-&gt;top    = parser-&gt;stack;
1316     parser-&gt;start  = start;
1317     parser-&gt;limit  = limit;
1318     parser-&gt;cursor = start;
1319 
1320     while ( p &lt; limit )
1321     {
1322       FT_UInt  v = *p;
1323 

1324       /* Opcode 31 is legacy MM T2 operator, not a number.      */
1325       /* Opcode 255 is reserved and should not appear in fonts; */
1326       /* it is used internally for CFF2 blends.                 */
1327       if ( v &gt;= 27 &amp;&amp; v != 31 &amp;&amp; v != 255 )
1328       {
1329         /* it&#39;s a number; we will push its position on the stack */
1330         if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1331           goto Stack_Overflow;
1332 
1333         *parser-&gt;top++ = p;
1334 
1335         /* now, skip it */
1336         if ( v == 30 )
1337         {
1338           /* skip real number */
1339           p++;
1340           for (;;)
1341           {
1342             /* An unterminated floating point number at the */
1343             /* end of a dictionary is invalid but harmless. */
</pre>
<hr />
<pre>
1352             p++;
1353           }
1354         }
1355         else if ( v == 28 )
1356           p += 2;
1357         else if ( v == 29 )
1358           p += 4;
1359         else if ( v &gt; 246 )
1360           p += 1;
1361       }
1362 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1363       else if ( v == 31 )
1364       {
1365         /* a Type 2 charstring */
1366 
1367         CFF_Decoder  decoder;
1368         CFF_FontRec  cff_rec;
1369         FT_Byte*     charstring_base;
1370         FT_ULong     charstring_len;
1371 
<span class="line-modified">1372         FT_Fixed*  stack;</span>
<span class="line-modified">1373         FT_Byte*   q;</span>



1374 
1375 
1376         charstring_base = ++p;
1377 
1378         /* search `endchar&#39; operator */
1379         for (;;)
1380         {
1381           if ( p &gt;= limit )
1382             goto Exit;
1383           if ( *p == 14 )
1384             break;
1385           p++;
1386         }
1387 
1388         charstring_len = (FT_ULong)( p - charstring_base ) + 1;
1389 
1390         /* construct CFF_Decoder object */
1391         FT_ZERO( &amp;decoder );
1392         FT_ZERO( &amp;cff_rec );
1393 
1394         cff_rec.top_font.font_dict.num_designs = parser-&gt;num_designs;
1395         cff_rec.top_font.font_dict.num_axes    = parser-&gt;num_axes;
1396         decoder.cff                            = &amp;cff_rec;
1397 
1398         psaux = (PSAux_Service)FT_Get_Module_Interface( library, &quot;psaux&quot; );
1399         if ( !psaux )
1400         {
1401           FT_ERROR(( &quot;cff_parser_run: cannot access `psaux&#39; module\n&quot; ));
1402           error = FT_THROW( Missing_Module );
1403           goto Exit;
1404         }
1405 
1406         error = psaux-&gt;cff_decoder_funcs-&gt;parse_charstrings_old(
1407                   &amp;decoder, charstring_base, charstring_len, 1 );


1408 
1409         /* Now copy the stack data in the temporary decoder object,    */
1410         /* converting it back to charstring number representations     */
1411         /* (this is ugly, I know).                                     */
<span class="line-removed">1412         /*                                                             */</span>
<span class="line-removed">1413         /* We overwrite the original top DICT charstring under the     */</span>
<span class="line-removed">1414         /* assumption that the charstring representation of the result */</span>
<span class="line-removed">1415         /* of `cff_decoder_parse_charstrings&#39; is shorter, which should */</span>
<span class="line-removed">1416         /* be always true.                                             */</span>
1417 
<span class="line-modified">1418         q     = charstring_base - 1;</span>

























1419         stack = decoder.stack;
1420 
1421         while ( stack &lt; decoder.top )
1422         {
1423           FT_ULong  num;
1424           FT_Bool   neg;
1425 
1426 
1427           if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1428             goto Stack_Overflow;
1429 
1430           *parser-&gt;top++ = q;
1431 
1432           if ( *stack &lt; 0 )
1433           {
<span class="line-modified">1434             num = (FT_ULong)-*stack;</span>
1435             neg = 1;
1436           }
1437           else
1438           {
1439             num = (FT_ULong)*stack;
1440             neg = 0;
1441           }
1442 
1443           if ( num &amp; 0xFFFFU )
1444           {
1445             if ( neg )
1446               num = (FT_ULong)-num;
1447 
1448             *q++ = 255;
1449             *q++ = ( num &amp; 0xFF000000U ) &gt;&gt; 24;
1450             *q++ = ( num &amp; 0x00FF0000U ) &gt;&gt; 16;
1451             *q++ = ( num &amp; 0x0000FF00U ) &gt;&gt;  8;
1452             *q++ =   num &amp; 0x000000FFU;
1453           }
1454           else
</pre>
<hr />
<pre>
1506 
1507 
1508         if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1509           goto Stack_Overflow;
1510 
1511         num_args     = (FT_UInt)( parser-&gt;top - parser-&gt;stack );
1512         *parser-&gt;top = p;
1513         code         = v;
1514 
1515         if ( v == 12 )
1516         {
1517           /* two byte operator */
1518           p++;
1519           if ( p &gt;= limit )
1520             goto Syntax_Error;
1521 
1522           code = 0x100 | p[0];
1523         }
1524         code = code | parser-&gt;object_code;
1525 
<span class="line-modified">1526         for ( field = CFF_FIELD_HANDLERS_GET; field-&gt;kind; field++ )</span>
1527         {
1528           if ( field-&gt;code == (FT_Int)code )
1529           {
1530             /* we found our field&#39;s handler; read it */
1531             FT_Long   val;
1532             FT_Byte*  q = (FT_Byte*)parser-&gt;object + field-&gt;offset;
1533 
1534 
1535 #ifdef FT_DEBUG_LEVEL_TRACE
1536             FT_TRACE4(( &quot;  %s&quot;, field-&gt;id ));
1537 #endif
1538 
1539             /* check that we have enough arguments -- except for */
1540             /* delta encoded arrays, which can be empty          */
1541             if ( field-&gt;kind != cff_kind_delta &amp;&amp; num_args &lt; 1 )
1542               goto Stack_Underflow;
1543 
1544             switch ( field-&gt;kind )
1545             {
1546             case cff_kind_bool:
</pre>
<hr />
<pre>
1655             default:  /* callback or blend */
1656               error = field-&gt;reader( parser );
1657               if ( error )
1658                 goto Exit;
1659             }
1660             goto Found;
1661           }
1662         }
1663 
1664         /* this is an unknown operator, or it is unsupported; */
1665         /* we will ignore it for now.                         */
1666 
1667       Found:
1668         /* clear stack */
1669         /* TODO: could clear blend stack here,       */
1670         /*       but we don&#39;t have access to subFont */
1671         if ( field-&gt;kind != cff_kind_blend )
1672           parser-&gt;top = parser-&gt;stack;
1673       }
1674       p++;
<span class="line-modified">1675     }</span>
1676 
1677   Exit:
1678     return error;
1679 






1680   Stack_Overflow:
1681     error = FT_THROW( Invalid_Argument );
1682     goto Exit;
1683 
1684   Stack_Underflow:
1685     error = FT_THROW( Invalid_Argument );
1686     goto Exit;
1687 
1688   Syntax_Error:
1689     error = FT_THROW( Invalid_Argument );
1690     goto Exit;
1691   }
1692 
1693 
1694 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * cffparse.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   CFF token stream parser (body)</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;cffparse.h&quot;
  21 #include FT_INTERNAL_STREAM_H
  22 #include FT_INTERNAL_DEBUG_H
  23 #include FT_INTERNAL_CALC_H
  24 #include FT_INTERNAL_POSTSCRIPT_AUX_H
<span class="line-added">  25 #include FT_LIST_H</span>
  26 
  27 #include &quot;cfferrs.h&quot;

  28 #include &quot;cffload.h&quot;
  29 
  30 
<span class="line-modified">  31   /**************************************************************************</span>
<span class="line-modified">  32    *</span>
<span class="line-modified">  33    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  34    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  35    * messages during execution.</span>
<span class="line-modified">  36    */</span>
  37 #undef  FT_COMPONENT
<span class="line-modified">  38 #define FT_COMPONENT  cffparse</span>
  39 
  40 
  41   FT_LOCAL_DEF( FT_Error )
  42   cff_parser_init( CFF_Parser  parser,
  43                    FT_UInt     code,
  44                    void*       object,
  45                    FT_Library  library,
  46                    FT_UInt     stackSize,
  47                    FT_UShort   num_designs,
  48                    FT_UShort   num_axes )
  49   {
  50     FT_Memory  memory = library-&gt;memory;    /* for FT_NEW_ARRAY */
  51     FT_Error   error;                       /* for FT_NEW_ARRAY */
  52 
  53 
  54     FT_ZERO( parser );
  55 
  56 #if 0
  57     parser-&gt;top         = parser-&gt;stack;
  58 #endif
</pre>
<hr />
<pre>
  60     parser-&gt;object      = object;
  61     parser-&gt;library     = library;
  62     parser-&gt;num_designs = num_designs;
  63     parser-&gt;num_axes    = num_axes;
  64 
  65     /* allocate the stack buffer */
  66     if ( FT_NEW_ARRAY( parser-&gt;stack, stackSize ) )
  67     {
  68       FT_FREE( parser-&gt;stack );
  69       goto Exit;
  70     }
  71 
  72     parser-&gt;stackSize = stackSize;
  73     parser-&gt;top       = parser-&gt;stack;    /* empty stack */
  74 
  75   Exit:
  76     return error;
  77   }
  78 
  79 
<span class="line-added">  80 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE</span>
<span class="line-added">  81   static void</span>
<span class="line-added">  82   finalize_t2_strings( FT_Memory  memory,</span>
<span class="line-added">  83                        void*      data,</span>
<span class="line-added">  84                        void*      user )</span>
<span class="line-added">  85   {</span>
<span class="line-added">  86     CFF_T2_String  t2 = (CFF_T2_String)data;</span>
<span class="line-added">  87 </span>
<span class="line-added">  88 </span>
<span class="line-added">  89     FT_UNUSED( user );</span>
<span class="line-added">  90 </span>
<span class="line-added">  91     memory-&gt;free( memory, t2-&gt;start );</span>
<span class="line-added">  92     memory-&gt;free( memory, data );</span>
<span class="line-added">  93   }</span>
<span class="line-added">  94 #endif /* CFF_CONFIG_OPTION_OLD_ENGINE */</span>
<span class="line-added">  95 </span>
<span class="line-added">  96 </span>
  97   FT_LOCAL_DEF( void )
  98   cff_parser_done( CFF_Parser  parser )
  99   {
 100     FT_Memory  memory = parser-&gt;library-&gt;memory;    /* for FT_FREE */
 101 
 102 
 103     FT_FREE( parser-&gt;stack );
<span class="line-added"> 104 </span>
<span class="line-added"> 105 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE</span>
<span class="line-added"> 106     FT_List_Finalize( &amp;parser-&gt;t2_strings,</span>
<span class="line-added"> 107                       finalize_t2_strings,</span>
<span class="line-added"> 108                       memory,</span>
<span class="line-added"> 109                       NULL );</span>
<span class="line-added"> 110 #endif</span>
<span class="line-added"> 111   }</span>
<span class="line-added"> 112 </span>
<span class="line-added"> 113 </span>
<span class="line-added"> 114   /* Assuming `first &gt;= last&#39;. */</span>
<span class="line-added"> 115 </span>
<span class="line-added"> 116   static FT_Error</span>
<span class="line-added"> 117   cff_parser_within_limits( CFF_Parser  parser,</span>
<span class="line-added"> 118                             FT_Byte*    first,</span>
<span class="line-added"> 119                             FT_Byte*    last )</span>
<span class="line-added"> 120   {</span>
<span class="line-added"> 121 #ifndef CFF_CONFIG_OPTION_OLD_ENGINE</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123     /* Fast path for regular FreeType builds with the &quot;new&quot; engine; */</span>
<span class="line-added"> 124     /*   `first &gt;= parser-&gt;start&#39; can be assumed.                   */</span>
<span class="line-added"> 125 </span>
<span class="line-added"> 126     FT_UNUSED( first );</span>
<span class="line-added"> 127 </span>
<span class="line-added"> 128     return last &lt; parser-&gt;limit ? FT_Err_Ok : FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 129 </span>
<span class="line-added"> 130 #else /* CFF_CONFIG_OPTION_OLD_ENGINE */</span>
<span class="line-added"> 131 </span>
<span class="line-added"> 132     FT_ListNode  node;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134 </span>
<span class="line-added"> 135     if ( first &gt;= parser-&gt;start &amp;&amp;</span>
<span class="line-added"> 136          last  &lt;  parser-&gt;limit )</span>
<span class="line-added"> 137       return FT_Err_Ok;</span>
<span class="line-added"> 138 </span>
<span class="line-added"> 139     node = parser-&gt;t2_strings.head;</span>
<span class="line-added"> 140 </span>
<span class="line-added"> 141     while ( node )</span>
<span class="line-added"> 142     {</span>
<span class="line-added"> 143       CFF_T2_String  t2 = (CFF_T2_String)node-&gt;data;</span>
<span class="line-added"> 144 </span>
<span class="line-added"> 145 </span>
<span class="line-added"> 146       if ( first &gt;= t2-&gt;start &amp;&amp;</span>
<span class="line-added"> 147            last  &lt;  t2-&gt;limit )</span>
<span class="line-added"> 148         return FT_Err_Ok;</span>
<span class="line-added"> 149 </span>
<span class="line-added"> 150       node = node-&gt;next;</span>
<span class="line-added"> 151     }</span>
<span class="line-added"> 152 </span>
<span class="line-added"> 153     return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 154 </span>
<span class="line-added"> 155 #endif /* CFF_CONFIG_OPTION_OLD_ENGINE */</span>
 156   }
 157 
 158 
 159   /* read an integer */
 160   static FT_Long
<span class="line-modified"> 161   cff_parse_integer( CFF_Parser  parser,</span>
<span class="line-modified"> 162                      FT_Byte*    start )</span>
 163   {
 164     FT_Byte*  p   = start;
 165     FT_Int    v   = *p++;
 166     FT_Long   val = 0;
 167 
 168 
 169     if ( v == 28 )
 170     {
<span class="line-modified"> 171       if ( cff_parser_within_limits( parser, p, p + 1 ) )</span>
 172         goto Bad;
 173 
 174       val = (FT_Short)( ( (FT_UShort)p[0] &lt;&lt; 8 ) | p[1] );
 175     }
 176     else if ( v == 29 )
 177     {
<span class="line-modified"> 178       if ( cff_parser_within_limits( parser, p, p + 3 ) )</span>
 179         goto Bad;
 180 
 181       val = (FT_Long)( ( (FT_ULong)p[0] &lt;&lt; 24 ) |
 182                        ( (FT_ULong)p[1] &lt;&lt; 16 ) |
 183                        ( (FT_ULong)p[2] &lt;&lt;  8 ) |
 184                          (FT_ULong)p[3]         );
 185     }
 186     else if ( v &lt; 247 )
 187     {
 188       val = v - 139;
 189     }
 190     else if ( v &lt; 251 )
 191     {
<span class="line-modified"> 192       if ( cff_parser_within_limits( parser, p, p ) )</span>
 193         goto Bad;
 194 
 195       val = ( v - 247 ) * 256 + p[0] + 108;
 196     }
 197     else
 198     {
<span class="line-modified"> 199       if ( cff_parser_within_limits( parser, p, p ) )</span>
 200         goto Bad;
 201 
 202       val = -( v - 251 ) * 256 - p[0] - 108;
 203     }
 204 
 205   Exit:
 206     return val;
 207 
 208   Bad:
 209     val = 0;
 210     FT_TRACE4(( &quot;!!!END OF DATA:!!!&quot; ));
 211     goto Exit;
 212   }
 213 
 214 
 215   static const FT_Long power_tens[] =
 216   {
 217     1L,
 218     10L,
 219     100L,
</pre>
<hr />
<pre>
 228 
 229   /* maximum values allowed for multiplying      */
 230   /* with the corresponding `power_tens&#39; element */
 231   static const FT_Long power_ten_limits[] =
 232   {
 233     FT_LONG_MAX / 1L,
 234     FT_LONG_MAX / 10L,
 235     FT_LONG_MAX / 100L,
 236     FT_LONG_MAX / 1000L,
 237     FT_LONG_MAX / 10000L,
 238     FT_LONG_MAX / 100000L,
 239     FT_LONG_MAX / 1000000L,
 240     FT_LONG_MAX / 10000000L,
 241     FT_LONG_MAX / 100000000L,
 242     FT_LONG_MAX / 1000000000L,
 243   };
 244 
 245 
 246   /* read a real */
 247   static FT_Fixed
<span class="line-modified"> 248   cff_parse_real( CFF_Parser  parser,</span>
<span class="line-modified"> 249                   FT_Byte*    start,</span>
<span class="line-modified"> 250                   FT_Long     power_ten,</span>
<span class="line-modified"> 251                   FT_Long*    scaling )</span>
 252   {
 253     FT_Byte*  p = start;
 254     FT_Int    nib;
 255     FT_UInt   phase;
 256 
 257     FT_Long   result, number, exponent;
 258     FT_Int    sign = 0, exponent_sign = 0, have_overflow = 0;
 259     FT_Long   exponent_add, integer_length, fraction_length;
 260 
 261 
 262     if ( scaling )
 263       *scaling = 0;
 264 
 265     result = 0;
 266 
 267     number   = 0;
 268     exponent = 0;
 269 
 270     exponent_add    = 0;
 271     integer_length  = 0;
 272     fraction_length = 0;
 273 
 274     /* First of all, read the integer part. */
 275     phase = 4;
 276 
 277     for (;;)
 278     {
 279       /* If we entered this iteration with phase == 4, we need to */
 280       /* read a new byte.  This also skips past the initial 0x1E. */
 281       if ( phase )
 282       {
 283         p++;
 284 
 285         /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 286         if ( cff_parser_within_limits( parser, p, p ) )</span>
 287           goto Bad;
 288       }
 289 
 290       /* Get the nibble. */
 291       nib   = (FT_Int)( p[0] &gt;&gt; phase ) &amp; 0xF;
 292       phase = 4 - phase;
 293 
 294       if ( nib == 0xE )
 295         sign = 1;
 296       else if ( nib &gt; 9 )
 297         break;
 298       else
 299       {
 300         /* Increase exponent if we can&#39;t add the digit. */
 301         if ( number &gt;= 0xCCCCCCCL )
 302           exponent_add++;
 303         /* Skip leading zeros. */
 304         else if ( nib || number )
 305         {
 306           integer_length++;
 307           number = number * 10 + nib;
 308         }
 309       }
 310     }
 311 
 312     /* Read fraction part, if any. */
 313     if ( nib == 0xA )
 314       for (;;)
 315       {
 316         /* If we entered this iteration with phase == 4, we need */
 317         /* to read a new byte.                                   */
 318         if ( phase )
 319         {
 320           p++;
 321 
 322           /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 323           if ( cff_parser_within_limits( parser, p, p ) )</span>
 324             goto Bad;
 325         }
 326 
 327         /* Get the nibble. */
 328         nib   = ( p[0] &gt;&gt; phase ) &amp; 0xF;
 329         phase = 4 - phase;
 330         if ( nib &gt;= 10 )
 331           break;
 332 
 333         /* Skip leading zeros if possible. */
 334         if ( !nib &amp;&amp; !number )
 335           exponent_add--;
 336         /* Only add digit if we don&#39;t overflow. */
 337         else if ( number &lt; 0xCCCCCCCL &amp;&amp; fraction_length &lt; 9 )
 338         {
 339           fraction_length++;
 340           number = number * 10 + nib;
 341         }
 342       }
 343 
 344     /* Read exponent, if any. */
 345     if ( nib == 12 )
 346     {
 347       exponent_sign = 1;
 348       nib           = 11;
 349     }
 350 
 351     if ( nib == 11 )
 352     {
 353       for (;;)
 354       {
 355         /* If we entered this iteration with phase == 4, */
 356         /* we need to read a new byte.                   */
 357         if ( phase )
 358         {
 359           p++;
 360 
 361           /* Make sure we don&#39;t read past the end. */
<span class="line-modified"> 362           if ( cff_parser_within_limits( parser, p, p ) )</span>
 363             goto Bad;
 364         }
 365 
 366         /* Get the nibble. */
 367         nib   = ( p[0] &gt;&gt; phase ) &amp; 0xF;
 368         phase = 4 - phase;
 369         if ( nib &gt;= 10 )
 370           break;
 371 
 372         /* Arbitrarily limit exponent. */
 373         if ( exponent &gt; 1000 )
 374           have_overflow = 1;
 375         else
 376           exponent = exponent * 10 + nib;
 377       }
 378 
 379       if ( exponent_sign )
 380         exponent = -exponent;
 381     }
 382 
</pre>
<hr />
<pre>
 509   Underflow:
 510     result = 0;
 511     FT_TRACE4(( &quot;!!!UNDERFLOW:!!!&quot; ));
 512     goto Exit;
 513 
 514   Bad:
 515     result = 0;
 516     FT_TRACE4(( &quot;!!!END OF DATA:!!!&quot; ));
 517     goto Exit;
 518   }
 519 
 520 
 521   /* read a number, either integer or real */
 522   FT_LOCAL_DEF( FT_Long )
 523   cff_parse_num( CFF_Parser  parser,
 524                  FT_Byte**   d )
 525   {
 526     if ( **d == 30 )
 527     {
 528       /* binary-coded decimal is truncated to integer */
<span class="line-modified"> 529       return cff_parse_real( parser, *d, 0, NULL ) &gt;&gt; 16;</span>
 530     }
 531 
 532     else if ( **d == 255 )
 533     {
 534       /* 16.16 fixed point is used internally for CFF2 blend results. */
 535       /* Since these are trusted values, a limit check is not needed. */
 536 
 537       /* After the 255, 4 bytes give the number.                 */
 538       /* The blend value is converted to integer, with rounding; */
 539       /* due to the right-shift we don&#39;t need the lowest byte.   */
 540 #if 0
 541       return (FT_Short)(
 542                ( ( ( (FT_UInt32)*( d[0] + 1 ) &lt;&lt; 24 ) |
 543                    ( (FT_UInt32)*( d[0] + 2 ) &lt;&lt; 16 ) |
 544                    ( (FT_UInt32)*( d[0] + 3 ) &lt;&lt;  8 ) |
 545                      (FT_UInt32)*( d[0] + 4 )         ) + 0x8000U ) &gt;&gt; 16 );
 546 #else
 547       return (FT_Short)(
 548                ( ( ( (FT_UInt32)*( d[0] + 1 ) &lt;&lt; 16 ) |
 549                    ( (FT_UInt32)*( d[0] + 2 ) &lt;&lt;  8 ) |
 550                      (FT_UInt32)*( d[0] + 3 )         ) + 0x80U ) &gt;&gt; 8 );
 551 #endif
 552     }
 553 
 554     else
<span class="line-modified"> 555       return cff_parse_integer( parser, *d );</span>
 556   }
 557 
 558 
 559   /* read a floating point number, either integer or real */
 560   static FT_Fixed
 561   do_fixed( CFF_Parser  parser,
 562             FT_Byte**   d,
 563             FT_Long     scaling )
 564   {
 565     if ( **d == 30 )
<span class="line-modified"> 566       return cff_parse_real( parser, *d, scaling, NULL );</span>
 567     else
 568     {
<span class="line-modified"> 569       FT_Long  val = cff_parse_integer( parser, *d );</span>
 570 
 571 
 572       if ( scaling )
 573       {
 574         if ( FT_ABS( val ) &gt; power_ten_limits[scaling] )
 575         {
 576           val = val &gt; 0 ? 0x7FFFFFFFL : -0x7FFFFFFFL;
 577           goto Overflow;
 578         }
 579 
 580         val *= power_tens[scaling];
 581       }
 582 
 583       if ( val &gt; 0x7FFF )
 584       {
 585         val = 0x7FFFFFFFL;
 586         goto Overflow;
 587       }
 588       else if ( val &lt; -0x7FFF )
 589       {
</pre>
<hr />
<pre>
 614   static FT_Fixed
 615   cff_parse_fixed_scaled( CFF_Parser  parser,
 616                           FT_Byte**   d,
 617                           FT_Long     scaling )
 618   {
 619     return do_fixed( parser, d, scaling );
 620   }
 621 
 622 
 623   /* read a floating point number, either integer or real,     */
 624   /* and return it as precise as possible -- `scaling&#39; returns */
 625   /* the scaling factor (as a power of 10)                     */
 626   static FT_Fixed
 627   cff_parse_fixed_dynamic( CFF_Parser  parser,
 628                            FT_Byte**   d,
 629                            FT_Long*    scaling )
 630   {
 631     FT_ASSERT( scaling );
 632 
 633     if ( **d == 30 )
<span class="line-modified"> 634       return cff_parse_real( parser, *d, 0, scaling );</span>
 635     else
 636     {
 637       FT_Long  number;
 638       FT_Int   integer_length;
 639 
 640 
<span class="line-modified"> 641       number = cff_parse_integer( parser, d[0] );</span>
 642 
 643       if ( number &gt; 0x7FFFL )
 644       {
 645         for ( integer_length = 5; integer_length &lt; 10; integer_length++ )
 646           if ( number &lt; power_tens[integer_length] )
 647             break;
 648 
 649         if ( ( number / power_tens[integer_length - 5] ) &gt; 0x7FFFL )
 650         {
 651           *scaling = integer_length - 4;
 652           return FT_DivFix( number, power_tens[integer_length - 4] );
 653         }
 654         else
 655         {
 656           *scaling = integer_length - 5;
 657           return FT_DivFix( number, power_tens[integer_length - 5] );
 658         }
 659       }
 660       else
 661       {
 662         *scaling = 0;
 663         return (FT_Long)( (FT_ULong)number &lt;&lt; 16 );
 664       }
 665     }
 666   }
 667 
 668 
 669   static FT_Error
 670   cff_parse_font_matrix( CFF_Parser  parser )
 671   {
 672     CFF_FontRecDict  dict   = (CFF_FontRecDict)parser-&gt;object;
 673     FT_Matrix*       matrix = &amp;dict-&gt;font_matrix;
 674     FT_Vector*       offset = &amp;dict-&gt;font_offset;
 675     FT_ULong*        upm    = &amp;dict-&gt;units_per_em;
 676     FT_Byte**        data   = parser-&gt;stack;

 677 
 678 
 679     if ( parser-&gt;top &gt;= parser-&gt;stack + 6 )
 680     {
 681       FT_Fixed  values[6];
 682       FT_Long   scalings[6];
 683 
 684       FT_Long  min_scaling, max_scaling;
 685       int      i;
 686 
 687 


 688       dict-&gt;has_font_matrix = TRUE;
 689 
 690       /* We expect a well-formed font matrix, this is, the matrix elements */
 691       /* `xx&#39; and `yy&#39; are of approximately the same magnitude.  To avoid  */
 692       /* loss of precision, we use the magnitude of the largest matrix     */
 693       /* element to scale all other elements.  The scaling factor is then  */
 694       /* contained in the `units_per_em&#39; value.                            */
 695 
 696       max_scaling = FT_LONG_MIN;
 697       min_scaling = FT_LONG_MAX;
 698 
 699       for ( i = 0; i &lt; 6; i++ )
 700       {
 701         values[i] = cff_parse_fixed_dynamic( parser, data++, &amp;scalings[i] );
 702         if ( values[i] )
 703         {
 704           if ( scalings[i] &gt; max_scaling )
 705             max_scaling = scalings[i];
 706           if ( scalings[i] &lt; min_scaling )
 707             min_scaling = scalings[i];
 708         }
 709       }
 710 
 711       if ( max_scaling &lt; -9                  ||
 712            max_scaling &gt; 0                   ||
 713            ( max_scaling - min_scaling ) &lt; 0 ||
 714            ( max_scaling - min_scaling ) &gt; 9 )
 715       {


 716         FT_TRACE1(( &quot;cff_parse_font_matrix:&quot;
 717                     &quot; strange scaling values (minimum %d, maximum %d),\n&quot;
 718                     &quot;                      &quot;
 719                     &quot; using default matrix\n&quot;, min_scaling, max_scaling ));
<span class="line-modified"> 720         goto Unlikely;</span>









 721       }
 722 
 723       for ( i = 0; i &lt; 6; i++ )
 724       {
 725         FT_Fixed  value = values[i];
 726         FT_Long   divisor, half_divisor;
 727 
 728 
 729         if ( !value )
 730           continue;
 731 
 732         divisor      = power_tens[max_scaling - scalings[i]];
 733         half_divisor = divisor &gt;&gt; 1;
 734 
 735         if ( value &lt; 0 )
 736         {
 737           if ( FT_LONG_MIN + half_divisor &lt; value )
 738             values[i] = ( value - half_divisor ) / divisor;
 739           else
 740             values[i] = FT_LONG_MIN / divisor;
</pre>
<hr />
<pre>
 747             values[i] = FT_LONG_MAX / divisor;
 748         }
 749       }
 750 
 751       matrix-&gt;xx = values[0];
 752       matrix-&gt;yx = values[1];
 753       matrix-&gt;xy = values[2];
 754       matrix-&gt;yy = values[3];
 755       offset-&gt;x  = values[4];
 756       offset-&gt;y  = values[5];
 757 
 758       *upm = (FT_ULong)power_tens[-max_scaling];
 759 
 760       FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,
 761                   (double)matrix-&gt;xx / *upm / 65536,
 762                   (double)matrix-&gt;xy / *upm / 65536,
 763                   (double)matrix-&gt;yx / *upm / 65536,
 764                   (double)matrix-&gt;yy / *upm / 65536,
 765                   (double)offset-&gt;x  / *upm / 65536,
 766                   (double)offset-&gt;y  / *upm / 65536 ));
<span class="line-added"> 767 </span>
<span class="line-added"> 768       if ( !FT_Matrix_Check( matrix ) )</span>
<span class="line-added"> 769       {</span>
<span class="line-added"> 770         FT_TRACE1(( &quot;cff_parse_font_matrix:&quot;</span>
<span class="line-added"> 771                     &quot; degenerate values, using default matrix\n&quot; ));</span>
<span class="line-added"> 772         goto Unlikely;</span>
<span class="line-added"> 773       }</span>
<span class="line-added"> 774 </span>
<span class="line-added"> 775       return FT_Err_Ok;</span>
 776     }
<span class="line-added"> 777     else</span>
<span class="line-added"> 778       return FT_THROW( Stack_Underflow );</span>
 779 
<span class="line-modified"> 780   Unlikely:</span>
<span class="line-modified"> 781     /* Return default matrix in case of unlikely values. */</span>
<span class="line-added"> 782 </span>
<span class="line-added"> 783     matrix-&gt;xx = 0x10000L;</span>
<span class="line-added"> 784     matrix-&gt;yx = 0;</span>
<span class="line-added"> 785     matrix-&gt;xy = 0;</span>
<span class="line-added"> 786     matrix-&gt;yy = 0x10000L;</span>
<span class="line-added"> 787     offset-&gt;x  = 0;</span>
<span class="line-added"> 788     offset-&gt;y  = 0;</span>
<span class="line-added"> 789     *upm       = 1;</span>
<span class="line-added"> 790 </span>
<span class="line-added"> 791     return FT_Err_Ok;</span>
 792   }
 793 
 794 
 795   static FT_Error
 796   cff_parse_font_bbox( CFF_Parser  parser )
 797   {
 798     CFF_FontRecDict  dict = (CFF_FontRecDict)parser-&gt;object;
 799     FT_BBox*         bbox = &amp;dict-&gt;font_bbox;
 800     FT_Byte**        data = parser-&gt;stack;
 801     FT_Error         error;
 802 
 803 
 804     error = FT_ERR( Stack_Underflow );
 805 
 806     if ( parser-&gt;top &gt;= parser-&gt;stack + 4 )
 807     {
 808       bbox-&gt;xMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 809       bbox-&gt;yMin = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 810       bbox-&gt;xMax = FT_RoundFix( cff_parse_fixed( parser, data++ ) );
 811       bbox-&gt;yMax = FT_RoundFix( cff_parse_fixed( parser, data   ) );
</pre>
<hr />
<pre>
 861       error = FT_Err_Ok;
 862     }
 863 
 864   Fail:
 865     return error;
 866   }
 867 
 868 
 869   /* The `MultipleMaster&#39; operator comes before any  */
 870   /* top DICT operators that contain T2 charstrings. */
 871 
 872   static FT_Error
 873   cff_parse_multiple_master( CFF_Parser  parser )
 874   {
 875     CFF_FontRecDict  dict = (CFF_FontRecDict)parser-&gt;object;
 876     FT_Error         error;
 877 
 878 
 879 #ifdef FT_DEBUG_LEVEL_TRACE
 880     /* beautify tracing message */
<span class="line-modified"> 881     if ( ft_trace_levels[FT_TRACE_COMP( FT_COMPONENT )] &lt; 4 )</span>
 882       FT_TRACE1(( &quot;Multiple Master CFFs not supported yet,&quot;
 883                   &quot; handling first master design only\n&quot; ));
 884     else
 885       FT_TRACE1(( &quot; (not supported yet,&quot;
 886                   &quot; handling first master design only)\n&quot; ));
 887 #endif
 888 
 889     error = FT_ERR( Stack_Underflow );
 890 
 891     /* currently, we handle only the first argument */
 892     if ( parser-&gt;top &gt;= parser-&gt;stack + 5 )
 893     {
 894       FT_Long  num_designs = cff_parse_num( parser, parser-&gt;stack );
 895 
 896 
 897       if ( num_designs &gt; 16 || num_designs &lt; 2 )
 898       {
 899         FT_ERROR(( &quot;cff_parse_multiple_master:&quot;
 900                    &quot; Invalid number of designs\n&quot; ));
 901         error = FT_THROW( Invalid_File_Format );
</pre>
<hr />
<pre>
1062 
1063     FT_TRACE4(( &quot; %d\n&quot;, dict-&gt;maxstack ));
1064 
1065   Exit:
1066     return error;
1067   }
1068 
1069 
1070 #define CFF_FIELD_NUM( code, name, id )             \
1071           CFF_FIELD( code, name, id, cff_kind_num )
1072 #define CFF_FIELD_FIXED( code, name, id )             \
1073           CFF_FIELD( code, name, id, cff_kind_fixed )
1074 #define CFF_FIELD_FIXED_1000( code, name, id )                 \
1075           CFF_FIELD( code, name, id, cff_kind_fixed_thousand )
1076 #define CFF_FIELD_STRING( code, name, id )             \
1077           CFF_FIELD( code, name, id, cff_kind_string )
1078 #define CFF_FIELD_BOOL( code, name, id )             \
1079           CFF_FIELD( code, name, id, cff_kind_bool )
1080 
1081 



1082 #undef  CFF_FIELD
1083 #undef  CFF_FIELD_DELTA
1084 
1085 
1086 #ifndef FT_DEBUG_LEVEL_TRACE
1087 
1088 
1089 #define CFF_FIELD_CALLBACK( code, name, id ) \
1090           {                                  \
1091             cff_kind_callback,               \
1092             code | CFFCODE,                  \
1093             0, 0,                            \
1094             cff_parse_ ## name,              \
1095             0, 0                             \
1096           },
1097 
1098 #define CFF_FIELD_BLEND( code, id ) \
1099           {                         \
1100             cff_kind_blend,         \
1101             code | CFFCODE,         \
</pre>
<hr />
<pre>
1174             FT_FIELD_OFFSET( name ),           \
1175             FT_FIELD_SIZE_DELTA( name ),       \
1176             0,                                 \
1177             max,                               \
1178             FT_FIELD_OFFSET( num_ ## name ),   \
1179             id                                 \
1180           },
1181 
1182   static const CFF_Field_Handler  cff_field_handlers[] =
1183   {
1184 
1185 #include &quot;cfftoken.h&quot;
1186 
1187     { 0, 0, 0, 0, 0, 0, 0, 0 }
1188   };
1189 
1190 
1191 #endif /* FT_DEBUG_LEVEL_TRACE */
1192 
1193 


















































































































































































1194   FT_LOCAL_DEF( FT_Error )
1195   cff_parser_run( CFF_Parser  parser,
1196                   FT_Byte*    start,
1197                   FT_Byte*    limit )
1198   {
<span class="line-added">1199     FT_Byte*  p     = start;</span>
<span class="line-added">1200     FT_Error  error = FT_Err_Ok;</span>
<span class="line-added">1201 </span>
1202 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1203     PSAux_Service  psaux;

1204 


1205     FT_Library  library = parser-&gt;library;
<span class="line-modified">1206     FT_Memory   memory  = library-&gt;memory;</span>
<span class="line-modified">1207 #endif</span>

1208 
1209     parser-&gt;top    = parser-&gt;stack;
1210     parser-&gt;start  = start;
1211     parser-&gt;limit  = limit;
1212     parser-&gt;cursor = start;
1213 
1214     while ( p &lt; limit )
1215     {
1216       FT_UInt  v = *p;
1217 
<span class="line-added">1218 </span>
1219       /* Opcode 31 is legacy MM T2 operator, not a number.      */
1220       /* Opcode 255 is reserved and should not appear in fonts; */
1221       /* it is used internally for CFF2 blends.                 */
1222       if ( v &gt;= 27 &amp;&amp; v != 31 &amp;&amp; v != 255 )
1223       {
1224         /* it&#39;s a number; we will push its position on the stack */
1225         if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1226           goto Stack_Overflow;
1227 
1228         *parser-&gt;top++ = p;
1229 
1230         /* now, skip it */
1231         if ( v == 30 )
1232         {
1233           /* skip real number */
1234           p++;
1235           for (;;)
1236           {
1237             /* An unterminated floating point number at the */
1238             /* end of a dictionary is invalid but harmless. */
</pre>
<hr />
<pre>
1247             p++;
1248           }
1249         }
1250         else if ( v == 28 )
1251           p += 2;
1252         else if ( v == 29 )
1253           p += 4;
1254         else if ( v &gt; 246 )
1255           p += 1;
1256       }
1257 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE
1258       else if ( v == 31 )
1259       {
1260         /* a Type 2 charstring */
1261 
1262         CFF_Decoder  decoder;
1263         CFF_FontRec  cff_rec;
1264         FT_Byte*     charstring_base;
1265         FT_ULong     charstring_len;
1266 
<span class="line-modified">1267         FT_Fixed*     stack;</span>
<span class="line-modified">1268         FT_ListNode   node;</span>
<span class="line-added">1269         CFF_T2_String t2;</span>
<span class="line-added">1270         size_t        t2_size;</span>
<span class="line-added">1271         FT_Byte*      q;</span>
1272 
1273 
1274         charstring_base = ++p;
1275 
1276         /* search `endchar&#39; operator */
1277         for (;;)
1278         {
1279           if ( p &gt;= limit )
1280             goto Exit;
1281           if ( *p == 14 )
1282             break;
1283           p++;
1284         }
1285 
1286         charstring_len = (FT_ULong)( p - charstring_base ) + 1;
1287 
1288         /* construct CFF_Decoder object */
1289         FT_ZERO( &amp;decoder );
1290         FT_ZERO( &amp;cff_rec );
1291 
1292         cff_rec.top_font.font_dict.num_designs = parser-&gt;num_designs;
1293         cff_rec.top_font.font_dict.num_axes    = parser-&gt;num_axes;
1294         decoder.cff                            = &amp;cff_rec;
1295 
1296         psaux = (PSAux_Service)FT_Get_Module_Interface( library, &quot;psaux&quot; );
1297         if ( !psaux )
1298         {
1299           FT_ERROR(( &quot;cff_parser_run: cannot access `psaux&#39; module\n&quot; ));
1300           error = FT_THROW( Missing_Module );
1301           goto Exit;
1302         }
1303 
1304         error = psaux-&gt;cff_decoder_funcs-&gt;parse_charstrings_old(
1305                   &amp;decoder, charstring_base, charstring_len, 1 );
<span class="line-added">1306         if ( error )</span>
<span class="line-added">1307           goto Exit;</span>
1308 
1309         /* Now copy the stack data in the temporary decoder object,    */
1310         /* converting it back to charstring number representations     */
1311         /* (this is ugly, I know).                                     */





1312 
<span class="line-modified">1313         node = (FT_ListNode)memory-&gt;alloc( memory,</span>
<span class="line-added">1314                                            sizeof ( FT_ListNodeRec ) );</span>
<span class="line-added">1315         if ( !node )</span>
<span class="line-added">1316           goto Out_Of_Memory_Error;</span>
<span class="line-added">1317 </span>
<span class="line-added">1318         FT_List_Add( &amp;parser-&gt;t2_strings, node );</span>
<span class="line-added">1319 </span>
<span class="line-added">1320         t2 = (CFF_T2_String)memory-&gt;alloc( memory,</span>
<span class="line-added">1321                                            sizeof ( CFF_T2_StringRec ) );</span>
<span class="line-added">1322         if ( !t2 )</span>
<span class="line-added">1323           goto Out_Of_Memory_Error;</span>
<span class="line-added">1324 </span>
<span class="line-added">1325         node-&gt;data = t2;</span>
<span class="line-added">1326 </span>
<span class="line-added">1327         /* `5&#39; is the conservative upper bound of required bytes per stack */</span>
<span class="line-added">1328         /* element.                                                        */</span>
<span class="line-added">1329 </span>
<span class="line-added">1330         t2_size = 5 * ( decoder.top - decoder.stack );</span>
<span class="line-added">1331 </span>
<span class="line-added">1332         q = (FT_Byte*)memory-&gt;alloc( memory, t2_size );</span>
<span class="line-added">1333         if ( !q )</span>
<span class="line-added">1334           goto Out_Of_Memory_Error;</span>
<span class="line-added">1335 </span>
<span class="line-added">1336         t2-&gt;start = q;</span>
<span class="line-added">1337         t2-&gt;limit = q + t2_size;</span>
<span class="line-added">1338 </span>
1339         stack = decoder.stack;
1340 
1341         while ( stack &lt; decoder.top )
1342         {
1343           FT_ULong  num;
1344           FT_Bool   neg;
1345 
1346 
1347           if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1348             goto Stack_Overflow;
1349 
1350           *parser-&gt;top++ = q;
1351 
1352           if ( *stack &lt; 0 )
1353           {
<span class="line-modified">1354             num = (FT_ULong)NEG_LONG( *stack );</span>
1355             neg = 1;
1356           }
1357           else
1358           {
1359             num = (FT_ULong)*stack;
1360             neg = 0;
1361           }
1362 
1363           if ( num &amp; 0xFFFFU )
1364           {
1365             if ( neg )
1366               num = (FT_ULong)-num;
1367 
1368             *q++ = 255;
1369             *q++ = ( num &amp; 0xFF000000U ) &gt;&gt; 24;
1370             *q++ = ( num &amp; 0x00FF0000U ) &gt;&gt; 16;
1371             *q++ = ( num &amp; 0x0000FF00U ) &gt;&gt;  8;
1372             *q++ =   num &amp; 0x000000FFU;
1373           }
1374           else
</pre>
<hr />
<pre>
1426 
1427 
1428         if ( (FT_UInt)( parser-&gt;top - parser-&gt;stack ) &gt;= parser-&gt;stackSize )
1429           goto Stack_Overflow;
1430 
1431         num_args     = (FT_UInt)( parser-&gt;top - parser-&gt;stack );
1432         *parser-&gt;top = p;
1433         code         = v;
1434 
1435         if ( v == 12 )
1436         {
1437           /* two byte operator */
1438           p++;
1439           if ( p &gt;= limit )
1440             goto Syntax_Error;
1441 
1442           code = 0x100 | p[0];
1443         }
1444         code = code | parser-&gt;object_code;
1445 
<span class="line-modified">1446         for ( field = cff_field_handlers; field-&gt;kind; field++ )</span>
1447         {
1448           if ( field-&gt;code == (FT_Int)code )
1449           {
1450             /* we found our field&#39;s handler; read it */
1451             FT_Long   val;
1452             FT_Byte*  q = (FT_Byte*)parser-&gt;object + field-&gt;offset;
1453 
1454 
1455 #ifdef FT_DEBUG_LEVEL_TRACE
1456             FT_TRACE4(( &quot;  %s&quot;, field-&gt;id ));
1457 #endif
1458 
1459             /* check that we have enough arguments -- except for */
1460             /* delta encoded arrays, which can be empty          */
1461             if ( field-&gt;kind != cff_kind_delta &amp;&amp; num_args &lt; 1 )
1462               goto Stack_Underflow;
1463 
1464             switch ( field-&gt;kind )
1465             {
1466             case cff_kind_bool:
</pre>
<hr />
<pre>
1575             default:  /* callback or blend */
1576               error = field-&gt;reader( parser );
1577               if ( error )
1578                 goto Exit;
1579             }
1580             goto Found;
1581           }
1582         }
1583 
1584         /* this is an unknown operator, or it is unsupported; */
1585         /* we will ignore it for now.                         */
1586 
1587       Found:
1588         /* clear stack */
1589         /* TODO: could clear blend stack here,       */
1590         /*       but we don&#39;t have access to subFont */
1591         if ( field-&gt;kind != cff_kind_blend )
1592           parser-&gt;top = parser-&gt;stack;
1593       }
1594       p++;
<span class="line-modified">1595     } /* while ( p &lt; limit ) */</span>
1596 
1597   Exit:
1598     return error;
1599 
<span class="line-added">1600 #ifdef CFF_CONFIG_OPTION_OLD_ENGINE</span>
<span class="line-added">1601   Out_Of_Memory_Error:</span>
<span class="line-added">1602     error = FT_THROW( Out_Of_Memory );</span>
<span class="line-added">1603     goto Exit;</span>
<span class="line-added">1604 #endif</span>
<span class="line-added">1605 </span>
1606   Stack_Overflow:
1607     error = FT_THROW( Invalid_Argument );
1608     goto Exit;
1609 
1610   Stack_Underflow:
1611     error = FT_THROW( Invalid_Argument );
1612     goto Exit;
1613 
1614   Syntax_Error:
1615     error = FT_THROW( Invalid_Argument );
1616     goto Exit;
1617   }
1618 
1619 
1620 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="cffobjs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="cffparse.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
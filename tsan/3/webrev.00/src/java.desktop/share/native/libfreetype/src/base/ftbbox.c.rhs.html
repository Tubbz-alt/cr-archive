<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/base/ftbbox.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftbbox.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   FreeType bbox computation (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used</span>
<span class="line-modified"> 11  * modified and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
<span class="line-modified"> 17 </span>
<span class="line-modified"> 18 </span>
<span class="line-modified"> 19   /**************************************************************************</span>
<span class="line-modified"> 20    *</span>
<span class="line-modified"> 21    * This component has a _single_ role: to compute exact outline bounding</span>
<span class="line-modified"> 22    * boxes.</span>
<span class="line-modified"> 23    *</span>
<span class="line-modified"> 24    */</span>
 25 
 26 
 27 #include &lt;ft2build.h&gt;
 28 #include FT_INTERNAL_DEBUG_H
 29 
 30 #include FT_BBOX_H
 31 #include FT_IMAGE_H
 32 #include FT_OUTLINE_H
 33 #include FT_INTERNAL_CALC_H
 34 #include FT_INTERNAL_OBJECTS_H
 35 
 36 
 37   typedef struct  TBBox_Rec_
 38   {
 39     FT_Vector  last;
 40     FT_BBox    bbox;
 41 
 42   } TBBox_Rec;
 43 
 44 
 45 #define FT_UPDATE_BBOX( p, bbox ) \
 46   FT_BEGIN_STMNT                  \
 47     if ( p-&gt;x &lt; bbox.xMin )       \
 48       bbox.xMin = p-&gt;x;           \
 49     if ( p-&gt;x &gt; bbox.xMax )       \
 50       bbox.xMax = p-&gt;x;           \
 51     if ( p-&gt;y &lt; bbox.yMin )       \
 52       bbox.yMin = p-&gt;y;           \
 53     if ( p-&gt;y &gt; bbox.yMax )       \
 54       bbox.yMax = p-&gt;y;           \
 55   FT_END_STMNT
 56 
 57 #define CHECK_X( p, bbox )                         \
 58           ( p-&gt;x &lt; bbox.xMin || p-&gt;x &gt; bbox.xMax )
 59 
 60 #define CHECK_Y( p, bbox )                         \
 61           ( p-&gt;y &lt; bbox.yMin || p-&gt;y &gt; bbox.yMax )
 62 
 63 
<a name="2" id="anc2"></a><span class="line-modified"> 64   /**************************************************************************</span>
<span class="line-modified"> 65    *</span>
<span class="line-modified"> 66    * @Function:</span>
<span class="line-modified"> 67    *   BBox_Move_To</span>
<span class="line-modified"> 68    *</span>
<span class="line-modified"> 69    * @Description:</span>
<span class="line-modified"> 70    *   This function is used as a `move_to&#39; emitter during</span>
<span class="line-modified"> 71    *   FT_Outline_Decompose().  It simply records the destination point</span>
<span class="line-modified"> 72    *   in `user-&gt;last&#39;. We also update bbox in case contour starts with</span>
<span class="line-modified"> 73    *   an implicit `on&#39; point.</span>
<span class="line-modified"> 74    *</span>
<span class="line-modified"> 75    * @Input:</span>
<span class="line-modified"> 76    *   to ::</span>
<span class="line-modified"> 77    *     A pointer to the destination vector.</span>
<span class="line-modified"> 78    *</span>
<span class="line-modified"> 79    * @InOut:</span>
<span class="line-modified"> 80    *   user ::</span>
<span class="line-modified"> 81    *     A pointer to the current walk context.</span>
<span class="line-modified"> 82    *</span>
<span class="line-modified"> 83    * @Return:</span>
<span class="line-added"> 84    *   Always 0.  Needed for the interface only.</span>
<span class="line-added"> 85    */</span>
 86   static int
 87   BBox_Move_To( FT_Vector*  to,
 88                 TBBox_Rec*  user )
 89   {
 90     FT_UPDATE_BBOX( to, user-&gt;bbox );
 91 
 92     user-&gt;last = *to;
 93 
 94     return 0;
 95   }
 96 
 97 
<a name="3" id="anc3"></a><span class="line-modified"> 98   /**************************************************************************</span>
<span class="line-modified"> 99    *</span>
<span class="line-modified">100    * @Function:</span>
<span class="line-modified">101    *   BBox_Line_To</span>
<span class="line-modified">102    *</span>
<span class="line-modified">103    * @Description:</span>
<span class="line-modified">104    *   This function is used as a `line_to&#39; emitter during</span>
<span class="line-modified">105    *   FT_Outline_Decompose().  It simply records the destination point</span>
<span class="line-modified">106    *   in `user-&gt;last&#39;; no further computations are necessary because</span>
<span class="line-modified">107    *   bbox already contains both explicit ends of the line segment.</span>
<span class="line-modified">108    *</span>
<span class="line-modified">109    * @Input:</span>
<span class="line-modified">110    *   to ::</span>
<span class="line-modified">111    *     A pointer to the destination vector.</span>
<span class="line-modified">112    *</span>
<span class="line-modified">113    * @InOut:</span>
<span class="line-modified">114    *   user ::</span>
<span class="line-modified">115    *     A pointer to the current walk context.</span>
<span class="line-modified">116    *</span>
<span class="line-modified">117    * @Return:</span>
<span class="line-added">118    *   Always 0.  Needed for the interface only.</span>
<span class="line-added">119    */</span>
120   static int
121   BBox_Line_To( FT_Vector*  to,
122                 TBBox_Rec*  user )
123   {
124     user-&gt;last = *to;
125 
126     return 0;
127   }
128 
129 
<a name="4" id="anc4"></a><span class="line-modified">130   /**************************************************************************</span>
<span class="line-modified">131    *</span>
<span class="line-modified">132    * @Function:</span>
<span class="line-modified">133    *   BBox_Conic_Check</span>
<span class="line-modified">134    *</span>
<span class="line-modified">135    * @Description:</span>
<span class="line-modified">136    *   Find the extrema of a 1-dimensional conic Bezier curve and update</span>
<span class="line-modified">137    *   a bounding range.  This version uses direct computation, as it</span>
<span class="line-modified">138    *   doesn&#39;t need square roots.</span>
<span class="line-modified">139    *</span>
<span class="line-modified">140    * @Input:</span>
<span class="line-modified">141    *   y1 ::</span>
<span class="line-modified">142    *     The start coordinate.</span>
<span class="line-modified">143    *</span>
<span class="line-modified">144    *   y2 ::</span>
<span class="line-modified">145    *     The coordinate of the control point.</span>
<span class="line-modified">146    *</span>
<span class="line-modified">147    *   y3 ::</span>
<span class="line-modified">148    *     The end coordinate.</span>
<span class="line-modified">149    *</span>
<span class="line-modified">150    * @InOut:</span>
<span class="line-modified">151    *   min ::</span>
<span class="line-added">152    *     The address of the current minimum.</span>
<span class="line-added">153    *</span>
<span class="line-added">154    *   max ::</span>
<span class="line-added">155    *     The address of the current maximum.</span>
<span class="line-added">156    */</span>
157   static void
158   BBox_Conic_Check( FT_Pos   y1,
159                     FT_Pos   y2,
160                     FT_Pos   y3,
161                     FT_Pos*  min,
162                     FT_Pos*  max )
163   {
164     /* This function is only called when a control off-point is outside */
165     /* the bbox that contains all on-points.  It finds a local extremum */
166     /* within the segment, equal to (y1*y3 - y2*y2)/(y1 - 2*y2 + y3).   */
167     /* Or, offsetting from y2, we get                                   */
168 
169     y1 -= y2;
170     y3 -= y2;
171     y2 += FT_MulDiv( y1, y3, y1 + y3 );
172 
173     if ( y2 &lt; *min )
174       *min = y2;
175     if ( y2 &gt; *max )
176       *max = y2;
177   }
178 
179 
<a name="5" id="anc5"></a><span class="line-modified">180   /**************************************************************************</span>
<span class="line-modified">181    *</span>
<span class="line-modified">182    * @Function:</span>
<span class="line-modified">183    *   BBox_Conic_To</span>
<span class="line-modified">184    *</span>
<span class="line-modified">185    * @Description:</span>
<span class="line-modified">186    *   This function is used as a `conic_to&#39; emitter during</span>
<span class="line-modified">187    *   FT_Outline_Decompose().  It checks a conic Bezier curve with the</span>
<span class="line-modified">188    *   current bounding box, and computes its extrema if necessary to</span>
<span class="line-modified">189    *   update it.</span>
<span class="line-modified">190    *</span>
<span class="line-modified">191    * @Input:</span>
<span class="line-modified">192    *   control ::</span>
<span class="line-modified">193    *     A pointer to a control point.</span>
<span class="line-modified">194    *</span>
<span class="line-modified">195    *   to ::</span>
<span class="line-modified">196    *     A pointer to the destination vector.</span>
<span class="line-modified">197    *</span>
<span class="line-modified">198    * @InOut:</span>
<span class="line-modified">199    *   user ::</span>
<span class="line-modified">200    *     The address of the current walk context.</span>
<span class="line-modified">201    *</span>
<span class="line-modified">202    * @Return:</span>
<span class="line-modified">203    *   Always 0.  Needed for the interface only.</span>
<span class="line-modified">204    *</span>
<span class="line-modified">205    * @Note:</span>
<span class="line-added">206    *   In the case of a non-monotonous arc, we compute directly the</span>
<span class="line-added">207    *   extremum coordinates, as it is sufficiently fast.</span>
<span class="line-added">208    */</span>
209   static int
210   BBox_Conic_To( FT_Vector*  control,
211                  FT_Vector*  to,
212                  TBBox_Rec*  user )
213   {
214     /* in case `to&#39; is implicit and not included in bbox yet */
215     FT_UPDATE_BBOX( to, user-&gt;bbox );
216 
217     if ( CHECK_X( control, user-&gt;bbox ) )
218       BBox_Conic_Check( user-&gt;last.x,
219                         control-&gt;x,
220                         to-&gt;x,
221                         &amp;user-&gt;bbox.xMin,
222                         &amp;user-&gt;bbox.xMax );
223 
224     if ( CHECK_Y( control, user-&gt;bbox ) )
225       BBox_Conic_Check( user-&gt;last.y,
226                         control-&gt;y,
227                         to-&gt;y,
228                         &amp;user-&gt;bbox.yMin,
229                         &amp;user-&gt;bbox.yMax );
230 
231     user-&gt;last = *to;
232 
233     return 0;
234   }
235 
236 
<a name="6" id="anc6"></a><span class="line-modified">237   /**************************************************************************</span>
<span class="line-modified">238    *</span>
<span class="line-modified">239    * @Function:</span>
<span class="line-modified">240    *   BBox_Cubic_Check</span>
<span class="line-modified">241    *</span>
<span class="line-modified">242    * @Description:</span>
<span class="line-modified">243    *   Find the extrema of a 1-dimensional cubic Bezier curve and</span>
<span class="line-modified">244    *   update a bounding range.  This version uses iterative splitting</span>
<span class="line-modified">245    *   because it is faster than the exact solution with square roots.</span>
<span class="line-modified">246    *</span>
<span class="line-modified">247    * @Input:</span>
<span class="line-modified">248    *   p1 ::</span>
<span class="line-modified">249    *     The start coordinate.</span>
<span class="line-modified">250    *</span>
<span class="line-modified">251    *   p2 ::</span>
<span class="line-modified">252    *     The coordinate of the first control point.</span>
<span class="line-modified">253    *</span>
<span class="line-modified">254    *   p3 ::</span>
<span class="line-modified">255    *     The coordinate of the second control point.</span>
<span class="line-modified">256    *</span>
<span class="line-modified">257    *   p4 ::</span>
<span class="line-modified">258    *     The end coordinate.</span>
<span class="line-modified">259    *</span>
<span class="line-modified">260    * @InOut:</span>
<span class="line-added">261    *   min ::</span>
<span class="line-added">262    *     The address of the current minimum.</span>
<span class="line-added">263    *</span>
<span class="line-added">264    *   max ::</span>
<span class="line-added">265    *     The address of the current maximum.</span>
<span class="line-added">266    */</span>
267   static FT_Pos
268   cubic_peak( FT_Pos  q1,
269               FT_Pos  q2,
270               FT_Pos  q3,
271               FT_Pos  q4 )
272   {
273     FT_Pos  peak = 0;
274     FT_Int  shift;
275 
276 
277     /* This function finds a peak of a cubic segment if it is above 0    */
278     /* using iterative bisection of the segment, or returns 0.           */
279     /* The fixed-point arithmetic of bisection is inherently stable      */
280     /* but may loose accuracy in the two lowest bits.  To compensate,    */
281     /* we upscale the segment if there is room.  Large values may need   */
282     /* to be downscaled to avoid overflows during bisection.             */
283     /* It is called with either q2 or q3 positive, which is necessary    */
284     /* for the peak to exist and avoids undefined FT_MSB.                */
285 
286     shift = 27 - FT_MSB( (FT_UInt32)( FT_ABS( q1 ) |
287                                       FT_ABS( q2 ) |
288                                       FT_ABS( q3 ) |
289                                       FT_ABS( q4 ) ) );
290 
291     if ( shift &gt; 0 )
292     {
293       /* upscaling too much just wastes time */
294       if ( shift &gt; 2 )
295         shift = 2;
296 
297       q1 &lt;&lt;=  shift;
298       q2 &lt;&lt;=  shift;
299       q3 &lt;&lt;=  shift;
300       q4 &lt;&lt;=  shift;
301     }
302     else
303     {
304       q1 &gt;&gt;= -shift;
305       q2 &gt;&gt;= -shift;
306       q3 &gt;&gt;= -shift;
307       q4 &gt;&gt;= -shift;
308     }
309 
310     /* for a peak to exist above 0, the cubic segment must have */
311     /* at least one of its control off-points above 0.          */
312     while ( q2 &gt; 0 || q3 &gt; 0 )
313     {
314       /* determine which half contains the maximum and split */
315       if ( q1 + q2 &gt; q3 + q4 ) /* first half */
316       {
317         q4 = q4 + q3;
318         q3 = q3 + q2;
319         q2 = q2 + q1;
320         q4 = q4 + q3;
321         q3 = q3 + q2;
<a name="7" id="anc7"></a><span class="line-modified">322         q4 = ( q4 + q3 ) &gt;&gt; 3;</span>
<span class="line-modified">323         q3 = q3 &gt;&gt; 2;</span>
<span class="line-modified">324         q2 = q2 &gt;&gt; 1;</span>
325       }
326       else                     /* second half */
327       {
328         q1 = q1 + q2;
329         q2 = q2 + q3;
330         q3 = q3 + q4;
331         q1 = q1 + q2;
332         q2 = q2 + q3;
<a name="8" id="anc8"></a><span class="line-modified">333         q1 = ( q1 + q2 ) &gt;&gt; 3;</span>
<span class="line-modified">334         q2 = q2 &gt;&gt; 2;</span>
<span class="line-modified">335         q3 = q3 &gt;&gt; 1;</span>
336       }
337 
338       /* check whether either end reached the maximum */
339       if ( q1 == q2 &amp;&amp; q1 &gt;= q3 )
340       {
341         peak = q1;
342         break;
343       }
344       if ( q3 == q4 &amp;&amp; q2 &lt;= q4 )
345       {
346         peak = q4;
347         break;
348       }
349     }
350 
351     if ( shift &gt; 0 )
352       peak &gt;&gt;=  shift;
353     else
354       peak &lt;&lt;= -shift;
355 
356     return peak;
357   }
358 
359 
360   static void
361   BBox_Cubic_Check( FT_Pos   p1,
362                     FT_Pos   p2,
363                     FT_Pos   p3,
364                     FT_Pos   p4,
365                     FT_Pos*  min,
366                     FT_Pos*  max )
367   {
368     /* This function is only called when a control off-point is outside  */
369     /* the bbox that contains all on-points.  So at least one of the     */
370     /* conditions below holds and cubic_peak is called with at least one */
371     /* non-zero argument.                                                */
372 
373     if ( p2 &gt; *max || p3 &gt; *max )
374       *max += cubic_peak( p1 - *max, p2 - *max, p3 - *max, p4 - *max );
375 
376     /* now flip the signs to update the minimum */
377     if ( p2 &lt; *min || p3 &lt; *min )
378       *min -= cubic_peak( *min - p1, *min - p2, *min - p3, *min - p4 );
379   }
380 
381 
<a name="9" id="anc9"></a><span class="line-modified">382   /**************************************************************************</span>
<span class="line-modified">383    *</span>
<span class="line-modified">384    * @Function:</span>
<span class="line-modified">385    *   BBox_Cubic_To</span>
<span class="line-modified">386    *</span>
<span class="line-modified">387    * @Description:</span>
<span class="line-modified">388    *   This function is used as a `cubic_to&#39; emitter during</span>
<span class="line-modified">389    *   FT_Outline_Decompose().  It checks a cubic Bezier curve with the</span>
<span class="line-modified">390    *   current bounding box, and computes its extrema if necessary to</span>
<span class="line-modified">391    *   update it.</span>
<span class="line-modified">392    *</span>
<span class="line-modified">393    * @Input:</span>
<span class="line-modified">394    *   control1 ::</span>
<span class="line-modified">395    *     A pointer to the first control point.</span>
<span class="line-modified">396    *</span>
<span class="line-modified">397    *   control2 ::</span>
<span class="line-modified">398    *     A pointer to the second control point.</span>
<span class="line-modified">399    *</span>
<span class="line-modified">400    *   to ::</span>
<span class="line-modified">401    *     A pointer to the destination vector.</span>
<span class="line-modified">402    *</span>
<span class="line-modified">403    * @InOut:</span>
<span class="line-modified">404    *   user ::</span>
<span class="line-modified">405    *     The address of the current walk context.</span>
<span class="line-modified">406    *</span>
<span class="line-modified">407    * @Return:</span>
<span class="line-modified">408    *   Always 0.  Needed for the interface only.</span>
<span class="line-modified">409    *</span>
<span class="line-added">410    * @Note:</span>
<span class="line-added">411    *   In the case of a non-monotonous arc, we don&#39;t compute directly</span>
<span class="line-added">412    *   extremum coordinates, we subdivide instead.</span>
<span class="line-added">413    */</span>
414   static int
415   BBox_Cubic_To( FT_Vector*  control1,
416                  FT_Vector*  control2,
417                  FT_Vector*  to,
418                  TBBox_Rec*  user )
419   {
420     /* We don&#39;t need to check `to&#39; since it is always an on-point,    */
421     /* thus within the bbox.  Only segments with an off-point outside */
422     /* the bbox can possibly reach new extreme values.                */
423 
424     if ( CHECK_X( control1, user-&gt;bbox ) ||
425          CHECK_X( control2, user-&gt;bbox ) )
426       BBox_Cubic_Check( user-&gt;last.x,
427                         control1-&gt;x,
428                         control2-&gt;x,
429                         to-&gt;x,
430                         &amp;user-&gt;bbox.xMin,
431                         &amp;user-&gt;bbox.xMax );
432 
433     if ( CHECK_Y( control1, user-&gt;bbox ) ||
434          CHECK_Y( control2, user-&gt;bbox ) )
435       BBox_Cubic_Check( user-&gt;last.y,
436                         control1-&gt;y,
437                         control2-&gt;y,
438                         to-&gt;y,
439                         &amp;user-&gt;bbox.yMin,
440                         &amp;user-&gt;bbox.yMax );
441 
442     user-&gt;last = *to;
443 
444     return 0;
445   }
446 
447 
448   FT_DEFINE_OUTLINE_FUNCS(
449     bbox_interface,
450 
451     (FT_Outline_MoveTo_Func) BBox_Move_To,   /* move_to  */
452     (FT_Outline_LineTo_Func) BBox_Line_To,   /* line_to  */
453     (FT_Outline_ConicTo_Func)BBox_Conic_To,  /* conic_to */
454     (FT_Outline_CubicTo_Func)BBox_Cubic_To,  /* cubic_to */
455     0,                                       /* shift    */
456     0                                        /* delta    */
457   )
458 
459 
460   /* documentation is in ftbbox.h */
461 
462   FT_EXPORT_DEF( FT_Error )
463   FT_Outline_Get_BBox( FT_Outline*  outline,
464                        FT_BBox     *abbox )
465   {
466     FT_BBox     cbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
467                          -0x7FFFFFFFL, -0x7FFFFFFFL };
468     FT_BBox     bbox = {  0x7FFFFFFFL,  0x7FFFFFFFL,
469                          -0x7FFFFFFFL, -0x7FFFFFFFL };
470     FT_Vector*  vec;
471     FT_UShort   n;
472 
473 
474     if ( !abbox )
475       return FT_THROW( Invalid_Argument );
476 
477     if ( !outline )
478       return FT_THROW( Invalid_Outline );
479 
480     /* if outline is empty, return (0,0,0,0) */
481     if ( outline-&gt;n_points == 0 || outline-&gt;n_contours &lt;= 0 )
482     {
483       abbox-&gt;xMin = abbox-&gt;xMax = 0;
484       abbox-&gt;yMin = abbox-&gt;yMax = 0;
485 
486       return 0;
487     }
488 
489     /* We compute the control box as well as the bounding box of  */
490     /* all `on&#39; points in the outline.  Then, if the two boxes    */
491     /* coincide, we exit immediately.                             */
492 
493     vec = outline-&gt;points;
494 
495     for ( n = 0; n &lt; outline-&gt;n_points; n++ )
496     {
497       FT_UPDATE_BBOX( vec, cbox );
498 
499       if ( FT_CURVE_TAG( outline-&gt;tags[n] ) == FT_CURVE_TAG_ON )
500         FT_UPDATE_BBOX( vec, bbox );
501 
502       vec++;
503     }
504 
505     /* test two boxes for equality */
506     if ( cbox.xMin &lt; bbox.xMin || cbox.xMax &gt; bbox.xMax ||
507          cbox.yMin &lt; bbox.yMin || cbox.yMax &gt; bbox.yMax )
508     {
509       /* the two boxes are different, now walk over the outline to */
510       /* get the Bezier arc extrema.                               */
511 
512       FT_Error   error;
513       TBBox_Rec  user;
514 
<a name="10" id="anc10"></a>





515 
516       user.bbox = bbox;
517 
518       error = FT_Outline_Decompose( outline, &amp;bbox_interface, &amp;user );
519       if ( error )
520         return error;
521 
522       *abbox = user.bbox;
523     }
524     else
525       *abbox = bbox;
526 
527     return FT_Err_Ok;
528   }
529 
530 
531 /* END */
<a name="11" id="anc11"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="11" type="hidden" />
</body>
</html>
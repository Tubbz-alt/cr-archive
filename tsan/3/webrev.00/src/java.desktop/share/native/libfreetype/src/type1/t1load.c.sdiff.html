<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/type1/t1load.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="t1gload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1load.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/type1/t1load.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  t1load.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Type 1 font loader (body).                                           */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18 </span>
<span class="line-modified">  19   /*************************************************************************/</span>
<span class="line-modified">  20   /*                                                                       */</span>
<span class="line-modified">  21   /* This is the new and improved Type 1 data loader for FreeType 2.  The  */</span>
<span class="line-modified">  22   /* old loader has several problems: it is slow, complex, difficult to    */</span>
<span class="line-modified">  23   /* maintain, and contains incredible hacks to make it accept some        */</span>
<span class="line-modified">  24   /* ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of    */</span>
<span class="line-modified">  25   /* the Type 1 fonts on my machine still aren&#39;t loaded correctly by it.   */</span>
<span class="line-modified">  26   /*                                                                       */</span>
<span class="line-modified">  27   /* This version is much simpler, much faster and also easier to read and */</span>
<span class="line-modified">  28   /* maintain by a great order of magnitude.  The idea behind it is to     */</span>
<span class="line-modified">  29   /* _not_ try to read the Type 1 token stream with a state machine (i.e.  */</span>
<span class="line-modified">  30   /* a Postscript-like interpreter) but rather to perform simple pattern   */</span>
<span class="line-modified">  31   /* matching.                                                             */</span>
<span class="line-modified">  32   /*                                                                       */</span>
<span class="line-modified">  33   /* Indeed, nearly all data definitions follow a simple pattern like      */</span>
<span class="line-modified">  34   /*                                                                       */</span>
<span class="line-modified">  35   /*  ... /Field &lt;data&gt; ...                                                */</span>
<span class="line-modified">  36   /*                                                                       */</span>
<span class="line-modified">  37   /* where &lt;data&gt; can be a number, a boolean, a string, or an array of     */</span>
<span class="line-modified">  38   /* numbers.  There are a few exceptions, namely the encoding, font name, */</span>
<span class="line-modified">  39   /* charstrings, and subrs; they are handled with a special pattern       */</span>
<span class="line-modified">  40   /* matching routine.                                                     */</span>
<span class="line-modified">  41   /*                                                                       */</span>
<span class="line-modified">  42   /* All other common cases are handled very simply.  The matching rules   */</span>
<span class="line-modified">  43   /* are defined in the file `t1tokens.h&#39; through the use of several       */</span>
<span class="line-modified">  44   /* macros calls PARSE_XXX.  This file is included twice here; the first  */</span>
<span class="line-modified">  45   /* time to generate parsing callback functions, the second time to       */</span>
<span class="line-modified">  46   /* generate a table of keywords (with pointers to the associated         */</span>
<span class="line-modified">  47   /* callback functions).                                                  */</span>
<span class="line-modified">  48   /*                                                                       */</span>
<span class="line-modified">  49   /* The function `parse_dict&#39; simply scans *linearly* a given dictionary  */</span>
<span class="line-modified">  50   /* (either the top-level or private one) and calls the appropriate       */</span>
<span class="line-modified">  51   /* callback when it encounters an immediate keyword.                     */</span>
<span class="line-modified">  52   /*                                                                       */</span>
<span class="line-modified">  53   /* This is by far the fastest way one can find to parse and read all     */</span>
<span class="line-modified">  54   /* data.                                                                 */</span>
<span class="line-modified">  55   /*                                                                       */</span>
<span class="line-modified">  56   /* This led to tremendous code size reduction.  Note that later, the     */</span>
<span class="line-modified">  57   /* glyph loader will also be _greatly_ simplified, and the automatic     */</span>
<span class="line-modified">  58   /* hinter will replace the clumsy `t1hinter&#39;.                            */</span>
<span class="line-modified">  59   /*                                                                       */</span>
<span class="line-modified">  60   /*************************************************************************/</span>
  61 
  62 
  63 #include &lt;ft2build.h&gt;
  64 #include FT_INTERNAL_DEBUG_H
  65 #include FT_CONFIG_CONFIG_H
  66 #include FT_MULTIPLE_MASTERS_H
  67 #include FT_INTERNAL_TYPE1_TYPES_H
  68 #include FT_INTERNAL_CALC_H
  69 #include FT_INTERNAL_HASH_H
  70 
  71 #include &quot;t1load.h&quot;
  72 #include &quot;t1errors.h&quot;
  73 
  74 
  75 #ifdef FT_CONFIG_OPTION_INCREMENTAL
<span class="line-modified">  76 #define IS_INCREMENTAL  (FT_Bool)( face-&gt;root.internal-&gt;incremental_interface != 0 )</span>
  77 #else
  78 #define IS_INCREMENTAL  0
  79 #endif
  80 
  81 
<span class="line-modified">  82   /*************************************************************************/</span>
<span class="line-modified">  83   /*                                                                       */</span>
<span class="line-modified">  84   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  85   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  86   /* messages during execution.                                            */</span>
<span class="line-modified">  87   /*                                                                       */</span>
  88 #undef  FT_COMPONENT
<span class="line-modified">  89 #define FT_COMPONENT  trace_t1load</span>
  90 
  91 
  92 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
  93 
  94 
  95   /*************************************************************************/
  96   /*************************************************************************/
  97   /*****                                                               *****/
  98   /*****                    MULTIPLE MASTERS SUPPORT                   *****/
  99   /*****                                                               *****/
 100   /*************************************************************************/
 101   /*************************************************************************/
 102 
 103   static FT_Error
 104   t1_allocate_blend( T1_Face  face,
 105                      FT_UInt  num_designs,
 106                      FT_UInt  num_axis )
 107   {
 108     PS_Blend   blend;
 109     FT_Memory  memory = face-&gt;root.memory;
</pre>
<hr />
<pre>
 205       master-&gt;num_designs = blend-&gt;num_designs;
 206 
 207       for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
 208       {
 209         FT_MM_Axis*   axis = master-&gt;axis + n;
 210         PS_DesignMap  map = blend-&gt;design_map + n;
 211 
 212 
 213         axis-&gt;name    = blend-&gt;axis_names[n];
 214         axis-&gt;minimum = map-&gt;design_points[0];
 215         axis-&gt;maximum = map-&gt;design_points[map-&gt;num_points - 1];
 216       }
 217 
 218       error = FT_Err_Ok;
 219     }
 220 
 221     return error;
 222   }
 223 
 224 
<span class="line-modified"> 225   /*************************************************************************/</span>
<span class="line-modified"> 226   /*                                                                       */</span>
<span class="line-modified"> 227   /* Given a normalized (blend) coordinate, figure out the design          */</span>
<span class="line-modified"> 228   /* coordinate appropriate for that value.                                */</span>
<span class="line-modified"> 229   /*                                                                       */</span>
 230   static FT_Fixed
 231   mm_axis_unmap( PS_DesignMap  axismap,
 232                  FT_Fixed      ncv )
 233   {
 234     int  j;
 235 
 236 
 237     if ( ncv &lt;= axismap-&gt;blend_points[0] )
 238       return INT_TO_FIXED( axismap-&gt;design_points[0] );
 239 
 240     for ( j = 1; j &lt; axismap-&gt;num_points; j++ )
 241     {
 242       if ( ncv &lt;= axismap-&gt;blend_points[j] )
 243         return INT_TO_FIXED( axismap-&gt;design_points[j - 1] ) +
 244                ( axismap-&gt;design_points[j] - axismap-&gt;design_points[j - 1] ) *
 245                FT_DivFix( ncv - axismap-&gt;blend_points[j - 1],
 246                           axismap-&gt;blend_points[j] -
 247                             axismap-&gt;blend_points[j - 1] );
 248     }
 249 
 250     return INT_TO_FIXED( axismap-&gt;design_points[axismap-&gt;num_points - 1] );
 251   }
 252 
 253 
<span class="line-modified"> 254   /*************************************************************************/</span>
<span class="line-modified"> 255   /*                                                                       */</span>
<span class="line-modified"> 256   /* Given a vector of weights, one for each design, figure out the        */</span>
<span class="line-modified"> 257   /* normalized axis coordinates which gave rise to those weights.         */</span>
<span class="line-modified"> 258   /*                                                                       */</span>
 259   static void
 260   mm_weights_unmap( FT_Fixed*  weights,
 261                     FT_Fixed*  axiscoords,
 262                     FT_UInt    axis_count )
 263   {
 264     FT_ASSERT( axis_count &lt;= T1_MAX_MM_AXIS );
 265 
 266     if ( axis_count == 1 )
 267       axiscoords[0] = weights[1];
 268 
 269     else if ( axis_count == 2 )
 270     {
 271       axiscoords[0] = weights[3] + weights[1];
 272       axiscoords[1] = weights[3] + weights[2];
 273     }
 274 
 275     else if ( axis_count == 3 )
 276     {
 277       axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
 278       axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
 279       axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
 280     }
 281 
 282     else
 283     {
 284       axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
 285                         weights[7] + weights[5] + weights[3] + weights[1];
 286       axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
 287                         weights[7] + weights[6] + weights[3] + weights[2];
 288       axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
 289                         weights[7] + weights[6] + weights[5] + weights[4];
 290       axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
 291                         weights[11] + weights[10] + weights[9] + weights[8];
 292     }
 293   }
 294 
 295 
<span class="line-modified"> 296   /*************************************************************************/</span>
<span class="line-modified"> 297   /*                                                                       */</span>
<span class="line-modified"> 298   /* Just a wrapper around T1_Get_Multi_Master to support the different    */</span>
<span class="line-modified"> 299   /*  arguments needed by the GX var distortable fonts.                    */</span>
<span class="line-modified"> 300   /*                                                                       */</span>
 301   FT_LOCAL_DEF( FT_Error )
 302   T1_Get_MM_Var( T1_Face      face,
 303                  FT_MM_Var*  *master )
 304   {
 305     FT_Memory        memory = face-&gt;root.memory;
 306     FT_MM_Var       *mmvar = NULL;
 307     FT_Multi_Master  mmaster;
 308     FT_Error         error;
 309     FT_UInt          i;
 310     FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
 311     PS_Blend         blend = face-&gt;blend;
 312 
 313 
 314     error = T1_Get_Multi_Master( face, &amp;mmaster );
 315     if ( error )
 316       goto Exit;
 317     if ( FT_ALLOC( mmvar,
 318                    sizeof ( FT_MM_Var ) +
 319                      mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
 320       goto Exit;
</pre>
<hr />
<pre>
 331       mmvar-&gt;axis[i].name    = mmaster.axis[i].name;
 332       mmvar-&gt;axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum );
 333       mmvar-&gt;axis[i].maximum = INT_TO_FIXED( mmaster.axis[i].maximum );
 334       mmvar-&gt;axis[i].def     = ( mmvar-&gt;axis[i].minimum +
 335                                    mmvar-&gt;axis[i].maximum ) / 2;
 336                             /* Does not apply.  But this value is in range */
 337       mmvar-&gt;axis[i].strid   = ~0U;                      /* Does not apply */
 338       mmvar-&gt;axis[i].tag     = ~0U;                      /* Does not apply */
 339 
 340       if ( !mmvar-&gt;axis[i].name )
 341         continue;
 342 
 343       if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Weight&quot; ) == 0 )
 344         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;g&#39;, &#39;h&#39;, &#39;t&#39; );
 345       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Width&quot; ) == 0 )
 346         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39; );
 347       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;OpticalSize&quot; ) == 0 )
 348         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;o&#39;, &#39;p&#39;, &#39;s&#39;, &#39;z&#39; );
 349     }
 350 
<span class="line-modified"> 351     if ( blend-&gt;num_designs == ( 1U &lt;&lt; blend-&gt;num_axis ) )</span>
<span class="line-modified"> 352     {</span>
<span class="line-modified"> 353       mm_weights_unmap( blend-&gt;default_weight_vector,</span>
<span class="line-removed"> 354                         axiscoords,</span>
<span class="line-removed"> 355                         blend-&gt;num_axis );</span>
 356 
<span class="line-modified"> 357       for ( i = 0; i &lt; mmaster.num_axis; i++ )</span>
<span class="line-modified"> 358         mmvar-&gt;axis[i].def = mm_axis_unmap( &amp;blend-&gt;design_map[i],</span>
<span class="line-modified"> 359                                             axiscoords[i] );</span>
<span class="line-removed"> 360     }</span>
 361 
 362     *master = mmvar;
 363 
 364   Exit:
 365     return error;
 366   }
 367 
 368 
 369   static FT_Error
 370   t1_set_mm_blend( T1_Face    face,
 371                    FT_UInt    num_coords,
 372                    FT_Fixed*  coords )
 373   {
 374     PS_Blend  blend = face-&gt;blend;
 375     FT_UInt   n, m;
 376 
 377     FT_Bool  have_diff = 0;
 378 
 379 
 380     if ( !blend )
 381       return FT_THROW( Invalid_Argument );
 382 
 383     if ( num_coords &gt; blend-&gt;num_axis )
 384       num_coords = blend-&gt;num_axis;
 385 
 386     /* recompute the weight vector from the blend coordinates */
 387     for ( n = 0; n &lt; blend-&gt;num_designs; n++ )
 388     {
 389       FT_Fixed  result = 0x10000L;  /* 1.0 fixed */

 390 
 391 
 392       for ( m = 0; m &lt; blend-&gt;num_axis; m++ )
 393       {
<span class="line-removed"> 394         FT_Fixed  factor;</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396 </span>
<span class="line-removed"> 397         /* get current blend axis position;                  */</span>
 398         /* use a default value if we don&#39;t have a coordinate */
<span class="line-modified"> 399         factor = m &lt; num_coords ? coords[m] : 0x8000;</span>
<span class="line-modified"> 400         if ( factor &lt; 0 )</span>
<span class="line-modified"> 401           factor = 0;</span>
<span class="line-modified"> 402         if ( factor &gt; 0x10000L )</span>
<span class="line-modified"> 403           factor = 0x10000L;</span>
 404 


 405         if ( ( n &amp; ( 1 &lt;&lt; m ) ) == 0 )
 406           factor = 0x10000L - factor;
 407 








 408         result = FT_MulFix( result, factor );
 409       }
 410 
 411       if ( blend-&gt;weight_vector[n] != result )
 412       {
 413         blend-&gt;weight_vector[n] = result;
 414         have_diff               = 1;
 415       }
 416     }
 417 
 418     /* return value -1 indicates `no change&#39; */
 419     return have_diff ? FT_Err_Ok : -1;
 420   }
 421 
 422 
 423   FT_LOCAL_DEF( FT_Error )
 424   T1_Set_MM_Blend( T1_Face    face,
 425                    FT_UInt    num_coords,
 426                    FT_Fixed*  coords )
 427   {
</pre>
<hr />
<pre>
 459                       axiscoords,
 460                       blend-&gt;num_axis );
 461 
 462     nc = num_coords;
 463     if ( num_coords &gt; blend-&gt;num_axis )
 464     {
 465       FT_TRACE2(( &quot;T1_Get_MM_Blend: only using first %d of %d coordinates\n&quot;,
 466                   blend-&gt;num_axis, num_coords ));
 467       nc = blend-&gt;num_axis;
 468     }
 469 
 470     for ( i = 0; i &lt; nc; i++ )
 471       coords[i] = axiscoords[i];
 472     for ( ; i &lt; num_coords; i++ )
 473       coords[i] = 0x8000;
 474 
 475     return FT_Err_Ok;
 476   }
 477 
 478 





































































 479   FT_LOCAL_DEF( FT_Error )
 480   T1_Set_MM_Design( T1_Face   face,
 481                     FT_UInt   num_coords,
 482                     FT_Long*  coords )
 483   {
 484     FT_Error  error;
 485     PS_Blend  blend = face-&gt;blend;
 486     FT_UInt   n, p;
 487     FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];
 488 
 489 
 490     if ( !blend )
 491       return FT_THROW( Invalid_Argument );
 492 
 493     if ( num_coords &gt; blend-&gt;num_axis )
 494       num_coords = blend-&gt;num_axis;
 495 
 496     /* compute the blend coordinates through the blend design map */
 497 
 498     for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
</pre>
<hr />
<pre>
 556       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
 557     else
 558       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
 559 
 560     return FT_Err_Ok;
 561   }
 562 
 563 
 564   /* MM fonts don&#39;t have named instances, so only the design is reset */
 565 
 566   FT_LOCAL_DEF( FT_Error )
 567   T1_Reset_MM_Blend( T1_Face  face,
 568                      FT_UInt  instance_index )
 569   {
 570     FT_UNUSED( instance_index );
 571 
 572     return T1_Set_MM_Blend( face, 0, NULL );
 573   }
 574 
 575 
<span class="line-modified"> 576   /*************************************************************************/</span>
<span class="line-modified"> 577   /*                                                                       */</span>
<span class="line-modified"> 578   /* Just a wrapper around T1_Set_MM_Design to support the different       */</span>
<span class="line-modified"> 579   /* arguments needed by the GX var distortable fonts.                     */</span>
<span class="line-modified"> 580   /*                                                                       */</span>
 581   FT_LOCAL_DEF( FT_Error )
 582   T1_Set_Var_Design( T1_Face    face,
 583                      FT_UInt    num_coords,
 584                      FT_Fixed*  coords )
 585   {
 586      FT_Long  lcoords[T1_MAX_MM_AXIS];
 587      FT_UInt  i;
 588 
 589 
 590      if ( num_coords &gt; T1_MAX_MM_AXIS )
 591        num_coords = T1_MAX_MM_AXIS;
 592 
 593      for ( i = 0; i &lt; num_coords; i++ )
 594        lcoords[i] = FIXED_TO_INT( coords[i] );
 595 
 596      return T1_Set_MM_Design( face, num_coords, lcoords );
 597   }
 598 
 599 
 600   FT_LOCAL_DEF( FT_Error )
</pre>
<hr />
<pre>
 702     T1_ToTokenArray( &amp;loader-&gt;parser, axis_tokens,
 703                      T1_MAX_MM_AXIS, &amp;num_axis );
 704     if ( num_axis &lt; 0 )
 705     {
 706       error = FT_ERR( Ignore );
 707       goto Exit;
 708     }
 709     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 710     {
 711       FT_ERROR(( &quot;parse_blend_axis_types: incorrect number of axes: %d\n&quot;,
 712                  num_axis ));
 713       error = FT_THROW( Invalid_File_Format );
 714       goto Exit;
 715     }
 716 
 717     /* allocate blend if necessary */
 718     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 719     if ( error )
 720       goto Exit;
 721 


 722     blend  = face-&gt;blend;
 723     memory = face-&gt;root.memory;
 724 
 725     /* each token is an immediate containing the name of the axis */
 726     for ( n = 0; n &lt; num_axis; n++ )
 727     {
 728       T1_Token  token = axis_tokens + n;
 729       FT_Byte*  name;
 730       FT_UInt   len;
 731 
 732 
 733       /* skip first slash, if any */
 734       if ( token-&gt;start[0] == &#39;/&#39; )
 735         token-&gt;start++;
 736 
 737       len = (FT_UInt)( token-&gt;limit - token-&gt;start );
 738       if ( len == 0 )
 739       {
 740         error = FT_THROW( Invalid_File_Format );
 741         goto Exit;
 742       }
 743 


 744       name = (FT_Byte*)blend-&gt;axis_names[n];
 745       if ( name )
 746       {
 747         FT_TRACE0(( &quot;parse_blend_axis_types:&quot;
<span class="line-modified"> 748                     &quot; overwriting axis name `%s&#39; with `%*.s&#39;\n&quot;,</span>
 749                     name, len, token-&gt;start ));
 750         FT_FREE( name );
 751       }
 752 
 753       if ( FT_ALLOC( blend-&gt;axis_names[n], len + 1 ) )
 754         goto Exit;
 755 
 756       name = (FT_Byte*)blend-&gt;axis_names[n];
 757       FT_MEM_COPY( name, token-&gt;start, len );
 758       name[len] = &#39;\0&#39;;
 759     }
 760 


 761   Exit:
 762     loader-&gt;parser.root.error = error;
 763   }
 764 
 765 
 766   static void
 767   parse_blend_design_positions( T1_Face    face,
 768                                 T1_Loader  loader )
 769   {
 770     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
 771     FT_Int       num_designs;
 772     FT_Int       num_axis;
 773     T1_Parser    parser = &amp;loader-&gt;parser;
 774 
 775     FT_Error     error = FT_Err_Ok;
 776     PS_Blend     blend;
 777 
 778 
 779     /* get the array of design tokens -- compute number of designs */
 780     T1_ToTokenArray( parser, design_tokens,
</pre>
<hr />
<pre>
 785       goto Exit;
 786     }
 787     if ( num_designs == 0 || num_designs &gt; T1_MAX_MM_DESIGNS )
 788     {
 789       FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 790                  &quot; incorrect number of designs: %d\n&quot;,
 791                  num_designs ));
 792       error = FT_THROW( Invalid_File_Format );
 793       goto Exit;
 794     }
 795 
 796     {
 797       FT_Byte*  old_cursor = parser-&gt;root.cursor;
 798       FT_Byte*  old_limit  = parser-&gt;root.limit;
 799       FT_Int    n;
 800 
 801 
 802       blend    = face-&gt;blend;
 803       num_axis = 0;  /* make compiler happy */
 804 


 805       for ( n = 0; n &lt; num_designs; n++ )
 806       {
 807         T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 808         T1_Token     token;
 809         FT_Int       axis, n_axis;
 810 
 811 
 812         /* read axis/coordinates tokens */
 813         token = design_tokens + n;
 814         parser-&gt;root.cursor = token-&gt;start;
 815         parser-&gt;root.limit  = token-&gt;limit;
 816         T1_ToTokenArray( parser, axis_tokens, T1_MAX_MM_AXIS, &amp;n_axis );
 817 
 818         if ( n == 0 )
 819         {
 820           if ( n_axis &lt;= 0 || n_axis &gt; T1_MAX_MM_AXIS )
 821           {
 822             FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 823                        &quot; invalid number of axes: %d\n&quot;,
 824                        n_axis ));
 825             error = FT_THROW( Invalid_File_Format );
 826             goto Exit;
 827           }
 828 
 829           num_axis = n_axis;
 830           error = t1_allocate_blend( face,
 831                                      (FT_UInt)num_designs,
 832                                      (FT_UInt)num_axis );
 833           if ( error )
 834             goto Exit;
 835           blend = face-&gt;blend;
 836         }
 837         else if ( n_axis != num_axis )
 838         {
 839           FT_ERROR(( &quot;parse_blend_design_positions: incorrect table\n&quot; ));
 840           error = FT_THROW( Invalid_File_Format );
 841           goto Exit;
 842         }
 843 
 844         /* now read each axis token into the design position */

 845         for ( axis = 0; axis &lt; n_axis; axis++ )
 846         {
 847           T1_Token  token2 = axis_tokens + axis;
 848 
 849 
 850           parser-&gt;root.cursor = token2-&gt;start;
 851           parser-&gt;root.limit  = token2-&gt;limit;
 852           blend-&gt;design_pos[n][axis] = T1_ToFixed( parser, 0 );

 853         }

 854       }
 855 


 856       loader-&gt;parser.root.cursor = old_cursor;
 857       loader-&gt;parser.root.limit  = old_limit;
 858     }
 859 
 860   Exit:
 861     loader-&gt;parser.root.error = error;
 862   }
 863 
 864 
 865   static void
 866   parse_blend_design_map( T1_Face    face,
 867                           T1_Loader  loader )
 868   {
 869     FT_Error     error  = FT_Err_Ok;
 870     T1_Parser    parser = &amp;loader-&gt;parser;
 871     PS_Blend     blend;
 872     T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 873     FT_Int       n, num_axis;
 874     FT_Byte*     old_cursor;
 875     FT_Byte*     old_limit;
</pre>
<hr />
<pre>
 882     {
 883       error = FT_ERR( Ignore );
 884       goto Exit;
 885     }
 886     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 887     {
 888       FT_ERROR(( &quot;parse_blend_design_map: incorrect number of axes: %d\n&quot;,
 889                  num_axis ));
 890       error = FT_THROW( Invalid_File_Format );
 891       goto Exit;
 892     }
 893 
 894     old_cursor = parser-&gt;root.cursor;
 895     old_limit  = parser-&gt;root.limit;
 896 
 897     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 898     if ( error )
 899       goto Exit;
 900     blend = face-&gt;blend;
 901 


 902     /* now read each axis design map */
 903     for ( n = 0; n &lt; num_axis; n++ )
 904     {
 905       PS_DesignMap  map = blend-&gt;design_map + n;
 906       T1_Token      axis_token;
 907       T1_TokenRec   point_tokens[T1_MAX_MM_MAP_POINTS];
 908       FT_Int        p, num_points;
 909 
 910 
 911       axis_token = axis_tokens + n;
 912 
 913       parser-&gt;root.cursor = axis_token-&gt;start;
 914       parser-&gt;root.limit  = axis_token-&gt;limit;
 915       T1_ToTokenArray( parser, point_tokens,
 916                        T1_MAX_MM_MAP_POINTS, &amp;num_points );
 917 


 918       if ( num_points &lt;= 0 || num_points &gt; T1_MAX_MM_MAP_POINTS )
 919       {
 920         FT_ERROR(( &quot;parse_blend_design_map: incorrect table\n&quot; ));
 921         error = FT_THROW( Invalid_File_Format );
 922         goto Exit;
 923       }
 924 
 925       if ( map-&gt;design_points )
 926       {
 927         FT_ERROR(( &quot;parse_blend_design_map: duplicate table\n&quot; ));
 928         error = FT_THROW( Invalid_File_Format );
 929         goto Exit;
 930       }
 931 
 932       /* allocate design map data */
 933       if ( FT_NEW_ARRAY( map-&gt;design_points, num_points * 2 ) )
 934         goto Exit;
 935       map-&gt;blend_points = map-&gt;design_points + num_points;
 936       map-&gt;num_points   = (FT_Byte)num_points;
 937 
 938       for ( p = 0; p &lt; num_points; p++ )
 939       {
 940         T1_Token  point_token;
 941 
 942 
 943         point_token = point_tokens + p;
 944 
 945         /* don&#39;t include delimiting brackets */
 946         parser-&gt;root.cursor = point_token-&gt;start + 1;
 947         parser-&gt;root.limit  = point_token-&gt;limit - 1;
 948 
 949         map-&gt;design_points[p] = T1_ToInt( parser );
 950         map-&gt;blend_points [p] = T1_ToFixed( parser, 0 );




 951       }


 952     }
 953 


 954     parser-&gt;root.cursor = old_cursor;
 955     parser-&gt;root.limit  = old_limit;
 956 
 957   Exit:
 958     parser-&gt;root.error = error;
 959   }
 960 
 961 
 962   static void
 963   parse_weight_vector( T1_Face    face,
 964                        T1_Loader  loader )
 965   {
 966     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
 967     FT_Int       num_designs;
 968     FT_Error     error  = FT_Err_Ok;
 969     T1_Parser    parser = &amp;loader-&gt;parser;
 970     PS_Blend     blend  = face-&gt;blend;
 971     T1_Token     token;
 972     FT_Int       n;
 973     FT_Byte*     old_cursor;
</pre>
<hr />
<pre>
 993     if ( !blend || !blend-&gt;num_designs )
 994     {
 995       error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );
 996       if ( error )
 997         goto Exit;
 998       blend = face-&gt;blend;
 999     }
1000     else if ( blend-&gt;num_designs != (FT_UInt)num_designs )
1001     {
1002       FT_ERROR(( &quot;parse_weight_vector:&quot;
1003                  &quot; /BlendDesignPosition and /WeightVector have\n&quot;
1004                  &quot;                    &quot;
1005                  &quot; different number of elements\n&quot; ));
1006       error = FT_THROW( Invalid_File_Format );
1007       goto Exit;
1008     }
1009 
1010     old_cursor = parser-&gt;root.cursor;
1011     old_limit  = parser-&gt;root.limit;
1012 


1013     for ( n = 0; n &lt; num_designs; n++ )
1014     {
1015       token = design_tokens + n;
1016       parser-&gt;root.cursor = token-&gt;start;
1017       parser-&gt;root.limit  = token-&gt;limit;
1018 
1019       blend-&gt;default_weight_vector[n] =
1020       blend-&gt;weight_vector[n]         = T1_ToFixed( parser, 0 );


1021     }
1022 


1023     parser-&gt;root.cursor = old_cursor;
1024     parser-&gt;root.limit  = old_limit;
1025 
1026   Exit:
1027     parser-&gt;root.error = error;
1028   }
1029 
1030 
1031   /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
1032   /* we&#39;re only interested in the number of array elements */
1033   static void
1034   parse_buildchar( T1_Face    face,
1035                    T1_Loader  loader )
1036   {
1037     face-&gt;len_buildchar = (FT_UInt)T1_ToFixedArray( &amp;loader-&gt;parser,
1038                                                     0, NULL, 0 );














1039     return;
1040   }
1041 
1042 
1043 #endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
1044 
1045 
1046 
1047 
1048   /*************************************************************************/
1049   /*************************************************************************/
1050   /*****                                                               *****/
1051   /*****                      TYPE 1 SYMBOL PARSING                    *****/
1052   /*****                                                               *****/
1053   /*************************************************************************/
1054   /*************************************************************************/
1055 
1056   static FT_Error
1057   t1_load_keyword( T1_Face         face,
1058                    T1_Loader       loader,
1059                    const T1_Field  field )
1060   {
1061     FT_Error  error;
1062     void*     dummy_object;
1063     void**    objects;
1064     FT_UInt   max_objects;
1065     PS_Blend  blend = face-&gt;blend;
1066 
1067 
1068     if ( blend &amp;&amp; blend-&gt;num_designs == 0 )
1069       blend = NULL;
1070 
1071     /* if the keyword has a dedicated callback, call it */
1072     if ( field-&gt;type == T1_FIELD_TYPE_CALLBACK )
1073     {


1074       field-&gt;reader( (FT_Face)face, loader );
1075       error = loader-&gt;parser.root.error;
1076       goto Exit;
1077     }
1078 
1079     /* now, the keyword is either a simple field, or a table of fields; */
1080     /* we are now going to take care of it                              */
1081     switch ( field-&gt;location )
1082     {
1083     case T1_FIELD_LOCATION_FONT_INFO:
1084       dummy_object = &amp;face-&gt;type1.font_info;
1085       objects      = &amp;dummy_object;
1086       max_objects  = 0;
1087 
1088       if ( blend )
1089       {
1090         objects     = (void**)blend-&gt;font_infos;
1091         max_objects = blend-&gt;num_designs;
1092       }
1093       break;
</pre>
<hr />
<pre>
1131     case T1_FIELD_LOCATION_FACE:
1132       dummy_object = face;
1133       objects      = &amp;dummy_object;
1134       max_objects  = 0;
1135       break;
1136 
1137 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
1138     case T1_FIELD_LOCATION_BLEND:
1139       dummy_object = face-&gt;blend;
1140       objects      = &amp;dummy_object;
1141       max_objects  = 0;
1142       break;
1143 #endif
1144 
1145     default:
1146       dummy_object = &amp;face-&gt;type1;
1147       objects      = &amp;dummy_object;
1148       max_objects  = 0;
1149     }
1150 


1151     if ( *objects )
1152     {
1153       if ( field-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
1154            field-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
1155         error = T1_Load_Field_Table( &amp;loader-&gt;parser, field,
1156                                      objects, max_objects, 0 );
1157       else
1158         error = T1_Load_Field( &amp;loader-&gt;parser, field,
1159                                objects, max_objects, 0 );
1160     }
1161     else
1162     {
1163       FT_TRACE1(( &quot;t1_load_keyword: ignoring keyword `%s&#39;&quot;
1164                   &quot; which is not valid at this point\n&quot;
1165                   &quot;                 (probably due to missing keywords)\n&quot;,
1166                  field-&gt;ident ));
1167       error = FT_Err_Ok;
1168     }
1169 


1170   Exit:
1171     return error;
1172   }
1173 
1174 
1175   static void
1176   parse_private( T1_Face    face,
1177                  T1_Loader  loader )
1178   {
1179     FT_UNUSED( face );
1180 
1181     loader-&gt;keywords_encountered |= T1_PRIVATE;


1182   }
1183 
1184 
1185   /* return 1 in case of success */
1186 
1187   static int
1188   read_binary_data( T1_Parser  parser,
1189                     FT_ULong*  size,
1190                     FT_Byte**  base,
1191                     FT_Bool    incremental )
1192   {
1193     FT_Byte*  cur;
1194     FT_Byte*  limit = parser-&gt;root.limit;
1195 
1196 
1197     /* the binary data has one of the following formats */
1198     /*                                                  */
1199     /*   `size&#39; [white*] RD white ....... ND            */
1200     /*   `size&#39; [white*] -| white ....... |-            */
1201     /*                                                  */
</pre>
<hr />
<pre>
1241                         T1_Loader  loader )
1242   {
1243     T1_Parser   parser = &amp;loader-&gt;parser;
1244     FT_Matrix*  matrix = &amp;face-&gt;type1.font_matrix;
1245     FT_Vector*  offset = &amp;face-&gt;type1.font_offset;
1246     FT_Face     root   = (FT_Face)&amp;face-&gt;root;
1247     FT_Fixed    temp[6];
1248     FT_Fixed    temp_scale;
1249     FT_Int      result;
1250 
1251 
1252     /* input is scaled by 1000 to accommodate default FontMatrix */
1253     result = T1_ToFixedArray( parser, 6, temp, 3 );
1254 
1255     if ( result &lt; 6 )
1256     {
1257       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1258       return;
1259     }
1260 








1261     temp_scale = FT_ABS( temp[3] );
1262 
1263     if ( temp_scale == 0 )
1264     {
1265       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));
1266       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1267       return;
1268     }
1269 
1270     /* atypical case */
1271     if ( temp_scale != 0x10000L )
1272     {
1273       /* set units per EM based on FontMatrix values */
1274       root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
1275 
1276       temp[0] = FT_DivFix( temp[0], temp_scale );
1277       temp[1] = FT_DivFix( temp[1], temp_scale );
1278       temp[2] = FT_DivFix( temp[2], temp_scale );
1279       temp[4] = FT_DivFix( temp[4], temp_scale );
1280       temp[5] = FT_DivFix( temp[5], temp_scale );
1281       temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
1282     }
<span class="line-removed">1283 </span>
1284     matrix-&gt;xx = temp[0];
1285     matrix-&gt;yx = temp[1];
1286     matrix-&gt;xy = temp[2];
1287     matrix-&gt;yy = temp[3];
1288 







1289     /* note that the offsets must be expressed in integer font units */
1290     offset-&gt;x = temp[4] &gt;&gt; 16;
1291     offset-&gt;y = temp[5] &gt;&gt; 16;
1292   }
1293 
1294 
1295   static void
1296   parse_encoding( T1_Face    face,
1297                   T1_Loader  loader )
1298   {
1299     T1_Parser  parser = &amp;loader-&gt;parser;
1300     FT_Byte*   cur;
1301     FT_Byte*   limit  = parser-&gt;root.limit;
1302 
1303     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1304 
1305 
1306     T1_Skip_Spaces( parser );
1307     cur = parser-&gt;root.cursor;
1308     if ( cur &gt;= limit )
</pre>
<hr />
<pre>
1350       if ( encode-&gt;char_index )
1351       {
1352         FT_FREE( encode-&gt;char_index );
1353         FT_FREE( encode-&gt;char_name );
1354         T1_Release_Table( char_table );
1355       }
1356 
1357       /* we use a T1_Table to store our charnames */
1358       loader-&gt;num_chars = encode-&gt;num_chars = array_size;
1359       if ( FT_NEW_ARRAY( encode-&gt;char_index, array_size )     ||
1360            FT_NEW_ARRAY( encode-&gt;char_name,  array_size )     ||
1361            FT_SET_ERROR( psaux-&gt;ps_table_funcs-&gt;init(
1362                            char_table, array_size, memory ) ) )
1363       {
1364         parser-&gt;root.error = error;
1365         return;
1366       }
1367 
1368       /* We need to `zero&#39; out encoding_table.elements */
1369       for ( n = 0; n &lt; array_size; n++ )
<span class="line-modified">1370       {</span>
<span class="line-removed">1371         char*  notdef = (char *)&quot;.notdef&quot;;</span>
<span class="line-removed">1372 </span>
<span class="line-removed">1373 </span>
<span class="line-removed">1374         (void)T1_Add_Table( char_table, n, notdef, 8 );</span>
<span class="line-removed">1375       }</span>
1376 
1377       /* Now we need to read records of the form                */
1378       /*                                                        */
1379       /*   ... charcode /charname ...                           */
1380       /*                                                        */
1381       /* for each entry in our table.                           */
1382       /*                                                        */
1383       /* We simply look for a number followed by an immediate   */
1384       /* name.  Note that this ignores correctly the sequence   */
1385       /* that is often seen in type1 fonts:                     */
1386       /*                                                        */
1387       /*   0 1 255 { 1 index exch /.notdef put } for dup        */
1388       /*                                                        */
1389       /* used to clean the encoding array before anything else. */
1390       /*                                                        */
1391       /* Alternatively, if the array is directly given as       */
1392       /*                                                        */
1393       /*   /Encoding [ ... ]                                    */
1394       /*                                                        */
1395       /* we only read immediates.                               */
</pre>
<hr />
<pre>
1477             /* we don&#39;t do anything here.                              */
1478             /*                                                         */
1479             /* This encoding array is not valid according to the type1 */
1480             /* specification (it might be an encoding for a CID type1  */
1481             /* font, however), so we conclude that this font is NOT a  */
1482             /* type1 font.                                             */
1483             parser-&gt;root.error = FT_THROW( Unknown_File_Format );
1484             return;
1485           }
1486         }
1487         else
1488         {
1489           T1_Skip_PS_Token( parser );
1490           if ( parser-&gt;root.error )
1491             return;
1492         }
1493 
1494         T1_Skip_Spaces( parser );
1495       }
1496 









1497       face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
1498       parser-&gt;root.cursor       = cur;
1499     }
1500 
1501     /* Otherwise, we should have either `StandardEncoding&#39;, */
1502     /* `ExpertEncoding&#39;, or `ISOLatin1Encoding&#39;             */
1503     else
1504     {
1505       if ( cur + 17 &lt; limit                                            &amp;&amp;
1506            ft_strncmp( (const char*)cur, &quot;StandardEncoding&quot;, 16 ) == 0 )

1507         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_STANDARD;


1508 
1509       else if ( cur + 15 &lt; limit                                          &amp;&amp;
1510                 ft_strncmp( (const char*)cur, &quot;ExpertEncoding&quot;, 14 ) == 0 )

1511         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_EXPERT;


1512 
1513       else if ( cur + 18 &lt; limit                                             &amp;&amp;
1514                 ft_strncmp( (const char*)cur, &quot;ISOLatin1Encoding&quot;, 17 ) == 0 )

1515         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;


1516 
1517       else

1518         parser-&gt;root.error = FT_ERR( Ignore );


1519     }
1520   }
1521 
1522 
1523   static void
1524   parse_subrs( T1_Face    face,
1525                T1_Loader  loader )
1526   {
1527     T1_Parser  parser = &amp;loader-&gt;parser;
1528     PS_Table   table  = &amp;loader-&gt;subrs;
1529     FT_Memory  memory = parser-&gt;root.memory;
1530     FT_Error   error;
1531     FT_Int     num_subrs;
1532     FT_UInt    count;
1533 
1534     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1535 
1536 
1537     T1_Skip_Spaces( parser );
1538 
</pre>
<hr />
<pre>
1679 
1680         /* t1_decrypt() shouldn&#39;t write to base -- make temporary copy */
1681         if ( FT_ALLOC( temp, size ) )
1682           goto Fail;
1683         FT_MEM_COPY( temp, base, size );
1684         psaux-&gt;t1_decrypt( temp, size, 4330 );
1685         size -= (FT_ULong)face-&gt;type1.private_dict.lenIV;
1686         error = T1_Add_Table( table, (FT_Int)idx,
1687                               temp + face-&gt;type1.private_dict.lenIV, size );
1688         FT_FREE( temp );
1689       }
1690       else
1691         error = T1_Add_Table( table, (FT_Int)idx, base, size );
1692       if ( error )
1693         goto Fail;
1694     }
1695 
1696     if ( !loader-&gt;num_subrs )
1697       loader-&gt;num_subrs = num_subrs;
1698 









1699     return;
1700 
1701   Fail:
1702     parser-&gt;root.error = error;
1703   }
1704 
1705 
1706 #define TABLE_EXTEND  5
1707 
1708 
1709   static void
1710   parse_charstrings( T1_Face    face,
1711                      T1_Loader  loader )
1712   {
1713     T1_Parser      parser       = &amp;loader-&gt;parser;
1714     PS_Table       code_table   = &amp;loader-&gt;charstrings;
1715     PS_Table       name_table   = &amp;loader-&gt;glyph_names;
1716     PS_Table       swap_table   = &amp;loader-&gt;swap_table;
1717     FT_Memory      memory       = parser-&gt;root.memory;
1718     FT_Error       error;
</pre>
<hr />
<pre>
1960                             swap_table-&gt;lengths [2] );
1961       if ( error )
1962         goto Fail;
1963 
1964       error = T1_Add_Table( code_table, 0,
1965                             swap_table-&gt;elements[3],
1966                             swap_table-&gt;lengths [3] );
1967       if ( error )
1968         goto Fail;
1969 
1970     }
1971     else if ( !notdef_found )
1972     {
1973       /* notdef_index is already 0, or /.notdef is undefined in   */
1974       /* charstrings dictionary.  Worry about /.notdef undefined. */
1975       /* We take index 0 and add it to the end of the table(s)    */
1976       /* and add our own /.notdef glyph to index 0.               */
1977 
1978       /* 0 333 hsbw endchar */
1979       FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };
<span class="line-removed">1980       char*    notdef_name    = (char *)&quot;.notdef&quot;;</span>
1981 
1982 
1983       error = T1_Add_Table( swap_table, 0,
1984                             name_table-&gt;elements[0],
1985                             name_table-&gt;lengths [0] );
1986       if ( error )
1987         goto Fail;
1988 
1989       error = T1_Add_Table( swap_table, 1,
1990                             code_table-&gt;elements[0],
1991                             code_table-&gt;lengths [0] );
1992       if ( error )
1993         goto Fail;
1994 
<span class="line-modified">1995       error = T1_Add_Table( name_table, 0, notdef_name, 8 );</span>
1996       if ( error )
1997         goto Fail;
1998 
1999       error = T1_Add_Table( code_table, 0, notdef_glyph, 5 );
2000 
2001       if ( error )
2002         goto Fail;
2003 
2004       error = T1_Add_Table( name_table, n,
2005                             swap_table-&gt;elements[0],
2006                             swap_table-&gt;lengths [0] );
2007       if ( error )
2008         goto Fail;
2009 
2010       error = T1_Add_Table( code_table, n,
2011                             swap_table-&gt;elements[1],
2012                             swap_table-&gt;lengths [1] );
2013       if ( error )
2014         goto Fail;
2015 
2016       /* we added a glyph. */
2017       loader-&gt;num_glyphs += 1;
2018     }
2019 









2020     return;
2021 
2022   Fail:
2023     parser-&gt;root.error = error;
2024   }
2025 
2026 
<span class="line-modified">2027   /*************************************************************************/</span>
<span class="line-modified">2028   /*                                                                       */</span>
<span class="line-modified">2029   /* Define the token field static variables.  This is a set of            */</span>
<span class="line-modified">2030   /* T1_FieldRec variables.                                                */</span>
<span class="line-modified">2031   /*                                                                       */</span>
<span class="line-modified">2032   /*************************************************************************/</span>
2033 
2034 
2035   static
2036   const T1_FieldRec  t1_keywords[] =
2037   {
2038 
2039 #include &quot;t1tokens.h&quot;
2040 
2041     /* now add the special functions... */
2042     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,           t1_parse_font_matrix,
2043                        T1_FIELD_DICT_FONTDICT )
2044     T1_FIELD_CALLBACK( &quot;Encoding&quot;,             parse_encoding,
2045                        T1_FIELD_DICT_FONTDICT )
2046     T1_FIELD_CALLBACK( &quot;Subrs&quot;,                parse_subrs,
2047                        T1_FIELD_DICT_PRIVATE )
2048     T1_FIELD_CALLBACK( &quot;CharStrings&quot;,          parse_charstrings,
2049                        T1_FIELD_DICT_PRIVATE )
2050     T1_FIELD_CALLBACK( &quot;Private&quot;,              parse_private,
2051                        T1_FIELD_DICT_FONTDICT )
2052 
</pre>
<hr />
<pre>
2199               /* `FontDirectory&#39;.                             */
2200 
2201               /* MM fonts have more than one /Private token at */
2202               /* the top level; let&#39;s hope that all the junk   */
2203               /* that follows the first /Private token is not  */
2204               /* interesting to us.                            */
2205 
2206               /* According to Adobe Tech Note #5175 (CID-Keyed */
2207               /* Font Installation for ATM Software) a `begin&#39; */
2208               /* must be followed by exactly one `end&#39;, and    */
2209               /* `begin&#39; -- `end&#39; pairs must be accurately     */
2210               /* paired.  We could use this to distinguish     */
2211               /* between the global Private and the Private    */
2212               /* dict that is a member of the Blend dict.      */
2213 
2214               const FT_UInt dict =
2215                 ( loader-&gt;keywords_encountered &amp; T1_PRIVATE )
2216                     ? T1_FIELD_DICT_PRIVATE
2217                     : T1_FIELD_DICT_FONTDICT;
2218 

2219               if ( !( dict &amp; keyword-&gt;dict ) )
2220               {
2221                 FT_TRACE1(( &quot;parse_dict: found `%s&#39; but ignoring it&quot;
2222                             &quot; since it is in the wrong dictionary\n&quot;,
2223                             keyword-&gt;ident ));
2224                 break;
2225               }
2226 
2227               if ( !( loader-&gt;keywords_encountered &amp;
2228                       T1_FONTDIR_AFTER_PRIVATE     )                  ||
2229                    ft_strcmp( (const char*)name, &quot;CharStrings&quot; ) == 0 )
2230               {
2231                 parser-&gt;root.error = t1_load_keyword( face,
2232                                                       loader,
2233                                                       keyword );
2234                 if ( parser-&gt;root.error )
2235                 {
2236                   if ( FT_ERR_EQ( parser-&gt;root.error, Ignore ) )
2237                     parser-&gt;root.error = FT_Err_Ok;
2238                   else
</pre>
<hr />
<pre>
2313 
2314     /* default values */
2315     face-&gt;ndv_idx          = -1;
2316     face-&gt;cdv_idx          = -1;
2317     face-&gt;len_buildchar    = 0;
2318 
2319     priv-&gt;blue_shift       = 7;
2320     priv-&gt;blue_fuzz        = 1;
2321     priv-&gt;lenIV            = 4;
2322     priv-&gt;expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
2323     priv-&gt;blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );
2324 
2325     parser = &amp;loader.parser;
2326     error  = T1_New_Parser( parser,
2327                             face-&gt;root.stream,
2328                             face-&gt;root.memory,
2329                             psaux );
2330     if ( error )
2331       goto Exit;
2332 

2333     error = parse_dict( face, &amp;loader,
2334                         parser-&gt;base_dict, parser-&gt;base_len );
2335     if ( error )
2336       goto Exit;
2337 
2338     error = T1_Get_Private_Dict( parser, psaux );
2339     if ( error )
2340       goto Exit;
2341 

2342     error = parse_dict( face, &amp;loader,
2343                         parser-&gt;private_dict, parser-&gt;private_len );
2344     if ( error )
2345       goto Exit;
2346 
2347     /* ensure even-ness of `num_blue_values&#39; */
2348     priv-&gt;num_blue_values &amp;= ~1;
2349 
2350 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
2351 










2352     if ( face-&gt;blend                                                     &amp;&amp;
2353          face-&gt;blend-&gt;num_default_design_vector != 0                     &amp;&amp;
2354          face-&gt;blend-&gt;num_default_design_vector != face-&gt;blend-&gt;num_axis )
2355     {
2356       /* we don&#39;t use it currently so just warn, reset, and ignore */
2357       FT_ERROR(( &quot;T1_Open_Face(): /DesignVector contains %u entries &quot;
2358                  &quot;while there are %u axes.\n&quot;,
2359                  face-&gt;blend-&gt;num_default_design_vector,
2360                  face-&gt;blend-&gt;num_axis ));
2361 
2362       face-&gt;blend-&gt;num_default_design_vector = 0;
2363     }
2364 
2365     /* the following can happen for MM instances; we then treat the */
2366     /* font as a normal PS font                                     */
2367     if ( face-&gt;blend                                             &amp;&amp;
2368          ( !face-&gt;blend-&gt;num_designs || !face-&gt;blend-&gt;num_axis ) )
2369       T1_Done_Blend( face );
2370 
2371     /* another safety check */
</pre>
<hr />
<pre>
2424       {
2425         FT_ERROR(( &quot;T1_Open_Face: no `/CharStrings&#39; array in face\n&quot; ));
2426         error = FT_THROW( Invalid_File_Format );
2427       }
2428 
2429     loader.charstrings.init  = 0;
2430     type1-&gt;charstrings_block = loader.charstrings.block;
2431     type1-&gt;charstrings       = loader.charstrings.elements;
2432     type1-&gt;charstrings_len   = loader.charstrings.lengths;
2433 
2434     /* we copy the glyph names `block&#39; and `elements&#39; fields; */
2435     /* the `lengths&#39; field must be released later             */
2436     type1-&gt;glyph_names_block    = loader.glyph_names.block;
2437     type1-&gt;glyph_names          = (FT_String**)loader.glyph_names.elements;
2438     loader.glyph_names.block    = NULL;
2439     loader.glyph_names.elements = NULL;
2440 
2441     /* we must now build type1.encoding when we have a custom array */
2442     if ( type1-&gt;encoding_type == T1_ENCODING_TYPE_ARRAY )
2443     {
<span class="line-modified">2444       FT_Int    charcode, idx, min_char, max_char;</span>
<span class="line-removed">2445       FT_Byte*  glyph_name;</span>
2446 
2447 
2448       /* OK, we do the following: for each element in the encoding  */
2449       /* table, look up the index of the glyph having the same name */
2450       /* the index is then stored in type1.encoding.char_index, and */
2451       /* the name to type1.encoding.char_name                       */
2452 
2453       min_char = 0;
2454       max_char = 0;
2455 
2456       charcode = 0;
2457       for ( ; charcode &lt; loader.encoding_table.max_elems; charcode++ )
2458       {
<span class="line-modified">2459         FT_Byte*  char_name;</span>

2460 
2461 
2462         type1-&gt;encoding.char_index[charcode] = 0;
<span class="line-modified">2463         type1-&gt;encoding.char_name [charcode] = (char *)&quot;.notdef&quot;;</span>
2464 
<span class="line-removed">2465         char_name = loader.encoding_table.elements[charcode];</span>
2466         if ( char_name )
2467           for ( idx = 0; idx &lt; type1-&gt;num_glyphs; idx++ )
2468           {
<span class="line-modified">2469             glyph_name = (FT_Byte*)type1-&gt;glyph_names[idx];</span>
<span class="line-modified">2470             if ( ft_strcmp( (const char*)char_name,</span>
<span class="line-modified">2471                             (const char*)glyph_name ) == 0 )</span>

2472             {
2473               type1-&gt;encoding.char_index[charcode] = (FT_UShort)idx;
<span class="line-modified">2474               type1-&gt;encoding.char_name [charcode] = (char*)glyph_name;</span>
2475 
2476               /* Change min/max encoded char only if glyph name is */
2477               /* not /.notdef                                      */
<span class="line-modified">2478               if ( ft_strcmp( (const char*)&quot;.notdef&quot;,</span>
<span class="line-removed">2479                               (const char*)glyph_name ) != 0 )</span>
2480               {
2481                 if ( charcode &lt; min_char )
2482                   min_char = charcode;
2483                 if ( charcode &gt;= max_char )
2484                   max_char = charcode + 1;
2485               }
2486               break;
2487             }
2488           }
2489       }
2490 
2491       type1-&gt;encoding.code_first = min_char;
2492       type1-&gt;encoding.code_last  = max_char;
2493       type1-&gt;encoding.num_chars  = loader.num_chars;
2494     }
2495 
2496     /* some sanitizing to avoid overflows later on; */
2497     /* the upper limits are ad-hoc values           */
2498     if ( priv-&gt;blue_shift &gt; 1000 || priv-&gt;blue_shift &lt; 0 )
2499     {
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * t1load.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Type 1 font loader (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
<span class="line-modified">  17 </span>
<span class="line-modified">  18 </span>
<span class="line-modified">  19   /**************************************************************************</span>
<span class="line-modified">  20    *</span>
<span class="line-modified">  21    * This is the new and improved Type 1 data loader for FreeType 2.  The</span>
<span class="line-modified">  22    * old loader has several problems: it is slow, complex, difficult to</span>
<span class="line-modified">  23    * maintain, and contains incredible hacks to make it accept some</span>
<span class="line-modified">  24    * ill-formed Type 1 fonts without hiccup-ing.  Moreover, about 5% of</span>
<span class="line-modified">  25    * the Type 1 fonts on my machine still aren&#39;t loaded correctly by it.</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * This version is much simpler, much faster and also easier to read and</span>
<span class="line-modified">  28    * maintain by a great order of magnitude.  The idea behind it is to</span>
<span class="line-modified">  29    * _not_ try to read the Type 1 token stream with a state machine (i.e.</span>
<span class="line-modified">  30    * a Postscript-like interpreter) but rather to perform simple pattern</span>
<span class="line-modified">  31    * matching.</span>
<span class="line-modified">  32    *</span>
<span class="line-modified">  33    * Indeed, nearly all data definitions follow a simple pattern like</span>
<span class="line-modified">  34    *</span>
<span class="line-modified">  35    * ... /Field &lt;data&gt; ...</span>
<span class="line-modified">  36    *</span>
<span class="line-modified">  37    * where &lt;data&gt; can be a number, a boolean, a string, or an array of</span>
<span class="line-modified">  38    * numbers.  There are a few exceptions, namely the encoding, font name,</span>
<span class="line-modified">  39    * charstrings, and subrs; they are handled with a special pattern</span>
<span class="line-modified">  40    * matching routine.</span>
<span class="line-modified">  41    *</span>
<span class="line-modified">  42    * All other common cases are handled very simply.  The matching rules</span>
<span class="line-modified">  43    * are defined in the file `t1tokens.h&#39; through the use of several</span>
<span class="line-modified">  44    * macros calls PARSE_XXX.  This file is included twice here; the first</span>
<span class="line-modified">  45    * time to generate parsing callback functions, the second time to</span>
<span class="line-modified">  46    * generate a table of keywords (with pointers to the associated</span>
<span class="line-modified">  47    * callback functions).</span>
<span class="line-modified">  48    *</span>
<span class="line-modified">  49    * The function `parse_dict&#39; simply scans *linearly* a given dictionary</span>
<span class="line-modified">  50    * (either the top-level or private one) and calls the appropriate</span>
<span class="line-modified">  51    * callback when it encounters an immediate keyword.</span>
<span class="line-modified">  52    *</span>
<span class="line-modified">  53    * This is by far the fastest way one can find to parse and read all</span>
<span class="line-modified">  54    * data.</span>
<span class="line-modified">  55    *</span>
<span class="line-modified">  56    * This led to tremendous code size reduction.  Note that later, the</span>
<span class="line-modified">  57    * glyph loader will also be _greatly_ simplified, and the automatic</span>
<span class="line-modified">  58    * hinter will replace the clumsy `t1hinter&#39;.</span>
<span class="line-modified">  59    *</span>
<span class="line-modified">  60    */</span>
  61 
  62 
  63 #include &lt;ft2build.h&gt;
  64 #include FT_INTERNAL_DEBUG_H
  65 #include FT_CONFIG_CONFIG_H
  66 #include FT_MULTIPLE_MASTERS_H
  67 #include FT_INTERNAL_TYPE1_TYPES_H
  68 #include FT_INTERNAL_CALC_H
  69 #include FT_INTERNAL_HASH_H
  70 
  71 #include &quot;t1load.h&quot;
  72 #include &quot;t1errors.h&quot;
  73 
  74 
  75 #ifdef FT_CONFIG_OPTION_INCREMENTAL
<span class="line-modified">  76 #define IS_INCREMENTAL  FT_BOOL( face-&gt;root.internal-&gt;incremental_interface )</span>
  77 #else
  78 #define IS_INCREMENTAL  0
  79 #endif
  80 
  81 
<span class="line-modified">  82   /**************************************************************************</span>
<span class="line-modified">  83    *</span>
<span class="line-modified">  84    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  85    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  86    * messages during execution.</span>
<span class="line-modified">  87    */</span>
  88 #undef  FT_COMPONENT
<span class="line-modified">  89 #define FT_COMPONENT  t1load</span>
  90 
  91 
  92 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
  93 
  94 
  95   /*************************************************************************/
  96   /*************************************************************************/
  97   /*****                                                               *****/
  98   /*****                    MULTIPLE MASTERS SUPPORT                   *****/
  99   /*****                                                               *****/
 100   /*************************************************************************/
 101   /*************************************************************************/
 102 
 103   static FT_Error
 104   t1_allocate_blend( T1_Face  face,
 105                      FT_UInt  num_designs,
 106                      FT_UInt  num_axis )
 107   {
 108     PS_Blend   blend;
 109     FT_Memory  memory = face-&gt;root.memory;
</pre>
<hr />
<pre>
 205       master-&gt;num_designs = blend-&gt;num_designs;
 206 
 207       for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
 208       {
 209         FT_MM_Axis*   axis = master-&gt;axis + n;
 210         PS_DesignMap  map = blend-&gt;design_map + n;
 211 
 212 
 213         axis-&gt;name    = blend-&gt;axis_names[n];
 214         axis-&gt;minimum = map-&gt;design_points[0];
 215         axis-&gt;maximum = map-&gt;design_points[map-&gt;num_points - 1];
 216       }
 217 
 218       error = FT_Err_Ok;
 219     }
 220 
 221     return error;
 222   }
 223 
 224 
<span class="line-modified"> 225   /**************************************************************************</span>
<span class="line-modified"> 226    *</span>
<span class="line-modified"> 227    * Given a normalized (blend) coordinate, figure out the design</span>
<span class="line-modified"> 228    * coordinate appropriate for that value.</span>
<span class="line-modified"> 229    */</span>
 230   static FT_Fixed
 231   mm_axis_unmap( PS_DesignMap  axismap,
 232                  FT_Fixed      ncv )
 233   {
 234     int  j;
 235 
 236 
 237     if ( ncv &lt;= axismap-&gt;blend_points[0] )
 238       return INT_TO_FIXED( axismap-&gt;design_points[0] );
 239 
 240     for ( j = 1; j &lt; axismap-&gt;num_points; j++ )
 241     {
 242       if ( ncv &lt;= axismap-&gt;blend_points[j] )
 243         return INT_TO_FIXED( axismap-&gt;design_points[j - 1] ) +
 244                ( axismap-&gt;design_points[j] - axismap-&gt;design_points[j - 1] ) *
 245                FT_DivFix( ncv - axismap-&gt;blend_points[j - 1],
 246                           axismap-&gt;blend_points[j] -
 247                             axismap-&gt;blend_points[j - 1] );
 248     }
 249 
 250     return INT_TO_FIXED( axismap-&gt;design_points[axismap-&gt;num_points - 1] );
 251   }
 252 
 253 
<span class="line-modified"> 254   /**************************************************************************</span>
<span class="line-modified"> 255    *</span>
<span class="line-modified"> 256    * Given a vector of weights, one for each design, figure out the</span>
<span class="line-modified"> 257    * normalized axis coordinates which gave rise to those weights.</span>
<span class="line-modified"> 258    */</span>
 259   static void
 260   mm_weights_unmap( FT_Fixed*  weights,
 261                     FT_Fixed*  axiscoords,
 262                     FT_UInt    axis_count )
 263   {
 264     FT_ASSERT( axis_count &lt;= T1_MAX_MM_AXIS );
 265 
 266     if ( axis_count == 1 )
 267       axiscoords[0] = weights[1];
 268 
 269     else if ( axis_count == 2 )
 270     {
 271       axiscoords[0] = weights[3] + weights[1];
 272       axiscoords[1] = weights[3] + weights[2];
 273     }
 274 
 275     else if ( axis_count == 3 )
 276     {
 277       axiscoords[0] = weights[7] + weights[5] + weights[3] + weights[1];
 278       axiscoords[1] = weights[7] + weights[6] + weights[3] + weights[2];
 279       axiscoords[2] = weights[7] + weights[6] + weights[5] + weights[4];
 280     }
 281 
 282     else
 283     {
 284       axiscoords[0] = weights[15] + weights[13] + weights[11] + weights[9] +
 285                         weights[7] + weights[5] + weights[3] + weights[1];
 286       axiscoords[1] = weights[15] + weights[14] + weights[11] + weights[10] +
 287                         weights[7] + weights[6] + weights[3] + weights[2];
 288       axiscoords[2] = weights[15] + weights[14] + weights[13] + weights[12] +
 289                         weights[7] + weights[6] + weights[5] + weights[4];
 290       axiscoords[3] = weights[15] + weights[14] + weights[13] + weights[12] +
 291                         weights[11] + weights[10] + weights[9] + weights[8];
 292     }
 293   }
 294 
 295 
<span class="line-modified"> 296   /**************************************************************************</span>
<span class="line-modified"> 297    *</span>
<span class="line-modified"> 298    * Just a wrapper around T1_Get_Multi_Master to support the different</span>
<span class="line-modified"> 299    * arguments needed by the GX var distortable fonts.</span>
<span class="line-modified"> 300    */</span>
 301   FT_LOCAL_DEF( FT_Error )
 302   T1_Get_MM_Var( T1_Face      face,
 303                  FT_MM_Var*  *master )
 304   {
 305     FT_Memory        memory = face-&gt;root.memory;
 306     FT_MM_Var       *mmvar = NULL;
 307     FT_Multi_Master  mmaster;
 308     FT_Error         error;
 309     FT_UInt          i;
 310     FT_Fixed         axiscoords[T1_MAX_MM_AXIS];
 311     PS_Blend         blend = face-&gt;blend;
 312 
 313 
 314     error = T1_Get_Multi_Master( face, &amp;mmaster );
 315     if ( error )
 316       goto Exit;
 317     if ( FT_ALLOC( mmvar,
 318                    sizeof ( FT_MM_Var ) +
 319                      mmaster.num_axis * sizeof ( FT_Var_Axis ) ) )
 320       goto Exit;
</pre>
<hr />
<pre>
 331       mmvar-&gt;axis[i].name    = mmaster.axis[i].name;
 332       mmvar-&gt;axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum );
 333       mmvar-&gt;axis[i].maximum = INT_TO_FIXED( mmaster.axis[i].maximum );
 334       mmvar-&gt;axis[i].def     = ( mmvar-&gt;axis[i].minimum +
 335                                    mmvar-&gt;axis[i].maximum ) / 2;
 336                             /* Does not apply.  But this value is in range */
 337       mmvar-&gt;axis[i].strid   = ~0U;                      /* Does not apply */
 338       mmvar-&gt;axis[i].tag     = ~0U;                      /* Does not apply */
 339 
 340       if ( !mmvar-&gt;axis[i].name )
 341         continue;
 342 
 343       if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Weight&quot; ) == 0 )
 344         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;g&#39;, &#39;h&#39;, &#39;t&#39; );
 345       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;Width&quot; ) == 0 )
 346         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;w&#39;, &#39;d&#39;, &#39;t&#39;, &#39;h&#39; );
 347       else if ( ft_strcmp( mmvar-&gt;axis[i].name, &quot;OpticalSize&quot; ) == 0 )
 348         mmvar-&gt;axis[i].tag = FT_MAKE_TAG( &#39;o&#39;, &#39;p&#39;, &#39;s&#39;, &#39;z&#39; );
 349     }
 350 
<span class="line-modified"> 351     mm_weights_unmap( blend-&gt;default_weight_vector,</span>
<span class="line-modified"> 352                       axiscoords,</span>
<span class="line-modified"> 353                       blend-&gt;num_axis );</span>


 354 
<span class="line-modified"> 355     for ( i = 0; i &lt; mmaster.num_axis; i++ )</span>
<span class="line-modified"> 356       mmvar-&gt;axis[i].def = mm_axis_unmap( &amp;blend-&gt;design_map[i],</span>
<span class="line-modified"> 357                                           axiscoords[i] );</span>

 358 
 359     *master = mmvar;
 360 
 361   Exit:
 362     return error;
 363   }
 364 
 365 
 366   static FT_Error
 367   t1_set_mm_blend( T1_Face    face,
 368                    FT_UInt    num_coords,
 369                    FT_Fixed*  coords )
 370   {
 371     PS_Blend  blend = face-&gt;blend;
 372     FT_UInt   n, m;
 373 
 374     FT_Bool  have_diff = 0;
 375 
 376 
 377     if ( !blend )
 378       return FT_THROW( Invalid_Argument );
 379 
 380     if ( num_coords &gt; blend-&gt;num_axis )
 381       num_coords = blend-&gt;num_axis;
 382 
 383     /* recompute the weight vector from the blend coordinates */
 384     for ( n = 0; n &lt; blend-&gt;num_designs; n++ )
 385     {
 386       FT_Fixed  result = 0x10000L;  /* 1.0 fixed */
<span class="line-added"> 387       FT_Fixed  factor;</span>
 388 
 389 
 390       for ( m = 0; m &lt; blend-&gt;num_axis; m++ )
 391       {




 392         /* use a default value if we don&#39;t have a coordinate */
<span class="line-modified"> 393         if ( m &gt;= num_coords )</span>
<span class="line-modified"> 394         {</span>
<span class="line-modified"> 395           result &gt;&gt;= 1;</span>
<span class="line-modified"> 396           continue;</span>
<span class="line-modified"> 397         }</span>
 398 
<span class="line-added"> 399         /* get current blend axis position */</span>
<span class="line-added"> 400         factor = coords[m];</span>
 401         if ( ( n &amp; ( 1 &lt;&lt; m ) ) == 0 )
 402           factor = 0x10000L - factor;
 403 
<span class="line-added"> 404         if ( factor &lt;= 0 )</span>
<span class="line-added"> 405         {</span>
<span class="line-added"> 406           result = 0;</span>
<span class="line-added"> 407           break;</span>
<span class="line-added"> 408         }</span>
<span class="line-added"> 409         else if ( factor &gt;= 0x10000L )</span>
<span class="line-added"> 410           continue;</span>
<span class="line-added"> 411 </span>
 412         result = FT_MulFix( result, factor );
 413       }
 414 
 415       if ( blend-&gt;weight_vector[n] != result )
 416       {
 417         blend-&gt;weight_vector[n] = result;
 418         have_diff               = 1;
 419       }
 420     }
 421 
 422     /* return value -1 indicates `no change&#39; */
 423     return have_diff ? FT_Err_Ok : -1;
 424   }
 425 
 426 
 427   FT_LOCAL_DEF( FT_Error )
 428   T1_Set_MM_Blend( T1_Face    face,
 429                    FT_UInt    num_coords,
 430                    FT_Fixed*  coords )
 431   {
</pre>
<hr />
<pre>
 463                       axiscoords,
 464                       blend-&gt;num_axis );
 465 
 466     nc = num_coords;
 467     if ( num_coords &gt; blend-&gt;num_axis )
 468     {
 469       FT_TRACE2(( &quot;T1_Get_MM_Blend: only using first %d of %d coordinates\n&quot;,
 470                   blend-&gt;num_axis, num_coords ));
 471       nc = blend-&gt;num_axis;
 472     }
 473 
 474     for ( i = 0; i &lt; nc; i++ )
 475       coords[i] = axiscoords[i];
 476     for ( ; i &lt; num_coords; i++ )
 477       coords[i] = 0x8000;
 478 
 479     return FT_Err_Ok;
 480   }
 481 
 482 
<span class="line-added"> 483   FT_LOCAL_DEF( FT_Error )</span>
<span class="line-added"> 484   T1_Set_MM_WeightVector( T1_Face    face,</span>
<span class="line-added"> 485                           FT_UInt    len,</span>
<span class="line-added"> 486                           FT_Fixed*  weightvector )</span>
<span class="line-added"> 487   {</span>
<span class="line-added"> 488     PS_Blend  blend = face-&gt;blend;</span>
<span class="line-added"> 489     FT_UInt   i, n;</span>
<span class="line-added"> 490 </span>
<span class="line-added"> 491 </span>
<span class="line-added"> 492     if ( !blend )</span>
<span class="line-added"> 493      return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 494 </span>
<span class="line-added"> 495     if ( !len &amp;&amp; !weightvector )</span>
<span class="line-added"> 496     {</span>
<span class="line-added"> 497       for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 498         blend-&gt;weight_vector[i] = blend-&gt;default_weight_vector[i];</span>
<span class="line-added"> 499     }</span>
<span class="line-added"> 500     else</span>
<span class="line-added"> 501     {</span>
<span class="line-added"> 502       if ( !weightvector )</span>
<span class="line-added"> 503         return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 504 </span>
<span class="line-added"> 505       n = len &lt; blend-&gt;num_designs ? len : blend-&gt;num_designs;</span>
<span class="line-added"> 506 </span>
<span class="line-added"> 507       for ( i = 0; i &lt; n; i++ )</span>
<span class="line-added"> 508         blend-&gt;weight_vector[i] = weightvector[i];</span>
<span class="line-added"> 509 </span>
<span class="line-added"> 510       for ( ; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 511         blend-&gt;weight_vector[i] = (FT_Fixed)0;</span>
<span class="line-added"> 512 </span>
<span class="line-added"> 513       if ( len )</span>
<span class="line-added"> 514         face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;</span>
<span class="line-added"> 515       else</span>
<span class="line-added"> 516         face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;</span>
<span class="line-added"> 517     }</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519     return FT_Err_Ok;</span>
<span class="line-added"> 520   }</span>
<span class="line-added"> 521 </span>
<span class="line-added"> 522 </span>
<span class="line-added"> 523   FT_LOCAL_DEF( FT_Error )</span>
<span class="line-added"> 524   T1_Get_MM_WeightVector( T1_Face    face,</span>
<span class="line-added"> 525                           FT_UInt*   len,</span>
<span class="line-added"> 526                           FT_Fixed*  weightvector )</span>
<span class="line-added"> 527   {</span>
<span class="line-added"> 528     PS_Blend  blend = face-&gt;blend;</span>
<span class="line-added"> 529     FT_UInt   i;</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531 </span>
<span class="line-added"> 532     if ( !blend )</span>
<span class="line-added"> 533       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535     if ( *len &lt; blend-&gt;num_designs )</span>
<span class="line-added"> 536     {</span>
<span class="line-added"> 537       *len = blend-&gt;num_designs;</span>
<span class="line-added"> 538       return FT_THROW( Invalid_Argument );</span>
<span class="line-added"> 539     }</span>
<span class="line-added"> 540 </span>
<span class="line-added"> 541     for ( i = 0; i &lt; blend-&gt;num_designs; i++ )</span>
<span class="line-added"> 542       weightvector[i] = blend-&gt;weight_vector[i];</span>
<span class="line-added"> 543     for ( ; i &lt; *len; i++ )</span>
<span class="line-added"> 544       weightvector[i] = (FT_Fixed)0;</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     *len = blend-&gt;num_designs;</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548     return FT_Err_Ok;</span>
<span class="line-added"> 549   }</span>
<span class="line-added"> 550 </span>
<span class="line-added"> 551 </span>
 552   FT_LOCAL_DEF( FT_Error )
 553   T1_Set_MM_Design( T1_Face   face,
 554                     FT_UInt   num_coords,
 555                     FT_Long*  coords )
 556   {
 557     FT_Error  error;
 558     PS_Blend  blend = face-&gt;blend;
 559     FT_UInt   n, p;
 560     FT_Fixed  final_blends[T1_MAX_MM_DESIGNS];
 561 
 562 
 563     if ( !blend )
 564       return FT_THROW( Invalid_Argument );
 565 
 566     if ( num_coords &gt; blend-&gt;num_axis )
 567       num_coords = blend-&gt;num_axis;
 568 
 569     /* compute the blend coordinates through the blend design map */
 570 
 571     for ( n = 0; n &lt; blend-&gt;num_axis; n++ )
</pre>
<hr />
<pre>
 629       face-&gt;root.face_flags |= FT_FACE_FLAG_VARIATION;
 630     else
 631       face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_VARIATION;
 632 
 633     return FT_Err_Ok;
 634   }
 635 
 636 
 637   /* MM fonts don&#39;t have named instances, so only the design is reset */
 638 
 639   FT_LOCAL_DEF( FT_Error )
 640   T1_Reset_MM_Blend( T1_Face  face,
 641                      FT_UInt  instance_index )
 642   {
 643     FT_UNUSED( instance_index );
 644 
 645     return T1_Set_MM_Blend( face, 0, NULL );
 646   }
 647 
 648 
<span class="line-modified"> 649   /**************************************************************************</span>
<span class="line-modified"> 650    *</span>
<span class="line-modified"> 651    * Just a wrapper around T1_Set_MM_Design to support the different</span>
<span class="line-modified"> 652    * arguments needed by the GX var distortable fonts.</span>
<span class="line-modified"> 653    */</span>
 654   FT_LOCAL_DEF( FT_Error )
 655   T1_Set_Var_Design( T1_Face    face,
 656                      FT_UInt    num_coords,
 657                      FT_Fixed*  coords )
 658   {
 659      FT_Long  lcoords[T1_MAX_MM_AXIS];
 660      FT_UInt  i;
 661 
 662 
 663      if ( num_coords &gt; T1_MAX_MM_AXIS )
 664        num_coords = T1_MAX_MM_AXIS;
 665 
 666      for ( i = 0; i &lt; num_coords; i++ )
 667        lcoords[i] = FIXED_TO_INT( coords[i] );
 668 
 669      return T1_Set_MM_Design( face, num_coords, lcoords );
 670   }
 671 
 672 
 673   FT_LOCAL_DEF( FT_Error )
</pre>
<hr />
<pre>
 775     T1_ToTokenArray( &amp;loader-&gt;parser, axis_tokens,
 776                      T1_MAX_MM_AXIS, &amp;num_axis );
 777     if ( num_axis &lt; 0 )
 778     {
 779       error = FT_ERR( Ignore );
 780       goto Exit;
 781     }
 782     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 783     {
 784       FT_ERROR(( &quot;parse_blend_axis_types: incorrect number of axes: %d\n&quot;,
 785                  num_axis ));
 786       error = FT_THROW( Invalid_File_Format );
 787       goto Exit;
 788     }
 789 
 790     /* allocate blend if necessary */
 791     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 792     if ( error )
 793       goto Exit;
 794 
<span class="line-added"> 795     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 796 </span>
 797     blend  = face-&gt;blend;
 798     memory = face-&gt;root.memory;
 799 
 800     /* each token is an immediate containing the name of the axis */
 801     for ( n = 0; n &lt; num_axis; n++ )
 802     {
 803       T1_Token  token = axis_tokens + n;
 804       FT_Byte*  name;
 805       FT_UInt   len;
 806 
 807 
 808       /* skip first slash, if any */
 809       if ( token-&gt;start[0] == &#39;/&#39; )
 810         token-&gt;start++;
 811 
 812       len = (FT_UInt)( token-&gt;limit - token-&gt;start );
 813       if ( len == 0 )
 814       {
 815         error = FT_THROW( Invalid_File_Format );
 816         goto Exit;
 817       }
 818 
<span class="line-added"> 819       FT_TRACE4(( &quot; /%.*s&quot;, len, token-&gt;start ));</span>
<span class="line-added"> 820 </span>
 821       name = (FT_Byte*)blend-&gt;axis_names[n];
 822       if ( name )
 823       {
 824         FT_TRACE0(( &quot;parse_blend_axis_types:&quot;
<span class="line-modified"> 825                     &quot; overwriting axis name `%s&#39; with `%.*s&#39;\n&quot;,</span>
 826                     name, len, token-&gt;start ));
 827         FT_FREE( name );
 828       }
 829 
 830       if ( FT_ALLOC( blend-&gt;axis_names[n], len + 1 ) )
 831         goto Exit;
 832 
 833       name = (FT_Byte*)blend-&gt;axis_names[n];
 834       FT_MEM_COPY( name, token-&gt;start, len );
 835       name[len] = &#39;\0&#39;;
 836     }
 837 
<span class="line-added"> 838     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added"> 839 </span>
 840   Exit:
 841     loader-&gt;parser.root.error = error;
 842   }
 843 
 844 
 845   static void
 846   parse_blend_design_positions( T1_Face    face,
 847                                 T1_Loader  loader )
 848   {
 849     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
 850     FT_Int       num_designs;
 851     FT_Int       num_axis;
 852     T1_Parser    parser = &amp;loader-&gt;parser;
 853 
 854     FT_Error     error = FT_Err_Ok;
 855     PS_Blend     blend;
 856 
 857 
 858     /* get the array of design tokens -- compute number of designs */
 859     T1_ToTokenArray( parser, design_tokens,
</pre>
<hr />
<pre>
 864       goto Exit;
 865     }
 866     if ( num_designs == 0 || num_designs &gt; T1_MAX_MM_DESIGNS )
 867     {
 868       FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 869                  &quot; incorrect number of designs: %d\n&quot;,
 870                  num_designs ));
 871       error = FT_THROW( Invalid_File_Format );
 872       goto Exit;
 873     }
 874 
 875     {
 876       FT_Byte*  old_cursor = parser-&gt;root.cursor;
 877       FT_Byte*  old_limit  = parser-&gt;root.limit;
 878       FT_Int    n;
 879 
 880 
 881       blend    = face-&gt;blend;
 882       num_axis = 0;  /* make compiler happy */
 883 
<span class="line-added"> 884       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 885 </span>
 886       for ( n = 0; n &lt; num_designs; n++ )
 887       {
 888         T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 889         T1_Token     token;
 890         FT_Int       axis, n_axis;
 891 
 892 
 893         /* read axis/coordinates tokens */
 894         token = design_tokens + n;
 895         parser-&gt;root.cursor = token-&gt;start;
 896         parser-&gt;root.limit  = token-&gt;limit;
 897         T1_ToTokenArray( parser, axis_tokens, T1_MAX_MM_AXIS, &amp;n_axis );
 898 
 899         if ( n == 0 )
 900         {
 901           if ( n_axis &lt;= 0 || n_axis &gt; T1_MAX_MM_AXIS )
 902           {
 903             FT_ERROR(( &quot;parse_blend_design_positions:&quot;
 904                        &quot; invalid number of axes: %d\n&quot;,
 905                        n_axis ));
 906             error = FT_THROW( Invalid_File_Format );
 907             goto Exit;
 908           }
 909 
 910           num_axis = n_axis;
 911           error = t1_allocate_blend( face,
 912                                      (FT_UInt)num_designs,
 913                                      (FT_UInt)num_axis );
 914           if ( error )
 915             goto Exit;
 916           blend = face-&gt;blend;
 917         }
 918         else if ( n_axis != num_axis )
 919         {
 920           FT_ERROR(( &quot;parse_blend_design_positions: incorrect table\n&quot; ));
 921           error = FT_THROW( Invalid_File_Format );
 922           goto Exit;
 923         }
 924 
 925         /* now read each axis token into the design position */
<span class="line-added"> 926         FT_TRACE4(( &quot; [&quot; )) ;</span>
 927         for ( axis = 0; axis &lt; n_axis; axis++ )
 928         {
 929           T1_Token  token2 = axis_tokens + axis;
 930 
 931 
 932           parser-&gt;root.cursor = token2-&gt;start;
 933           parser-&gt;root.limit  = token2-&gt;limit;
 934           blend-&gt;design_pos[n][axis] = T1_ToFixed( parser, 0 );
<span class="line-added"> 935           FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;design_pos[n][axis] / 65536 ));</span>
 936         }
<span class="line-added"> 937         FT_TRACE4(( &quot;]&quot; )) ;</span>
 938       }
 939 
<span class="line-added"> 940       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added"> 941 </span>
 942       loader-&gt;parser.root.cursor = old_cursor;
 943       loader-&gt;parser.root.limit  = old_limit;
 944     }
 945 
 946   Exit:
 947     loader-&gt;parser.root.error = error;
 948   }
 949 
 950 
 951   static void
 952   parse_blend_design_map( T1_Face    face,
 953                           T1_Loader  loader )
 954   {
 955     FT_Error     error  = FT_Err_Ok;
 956     T1_Parser    parser = &amp;loader-&gt;parser;
 957     PS_Blend     blend;
 958     T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];
 959     FT_Int       n, num_axis;
 960     FT_Byte*     old_cursor;
 961     FT_Byte*     old_limit;
</pre>
<hr />
<pre>
 968     {
 969       error = FT_ERR( Ignore );
 970       goto Exit;
 971     }
 972     if ( num_axis == 0 || num_axis &gt; T1_MAX_MM_AXIS )
 973     {
 974       FT_ERROR(( &quot;parse_blend_design_map: incorrect number of axes: %d\n&quot;,
 975                  num_axis ));
 976       error = FT_THROW( Invalid_File_Format );
 977       goto Exit;
 978     }
 979 
 980     old_cursor = parser-&gt;root.cursor;
 981     old_limit  = parser-&gt;root.limit;
 982 
 983     error = t1_allocate_blend( face, 0, (FT_UInt)num_axis );
 984     if ( error )
 985       goto Exit;
 986     blend = face-&gt;blend;
 987 
<span class="line-added"> 988     FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added"> 989 </span>
 990     /* now read each axis design map */
 991     for ( n = 0; n &lt; num_axis; n++ )
 992     {
 993       PS_DesignMap  map = blend-&gt;design_map + n;
 994       T1_Token      axis_token;
 995       T1_TokenRec   point_tokens[T1_MAX_MM_MAP_POINTS];
 996       FT_Int        p, num_points;
 997 
 998 
 999       axis_token = axis_tokens + n;
1000 
1001       parser-&gt;root.cursor = axis_token-&gt;start;
1002       parser-&gt;root.limit  = axis_token-&gt;limit;
1003       T1_ToTokenArray( parser, point_tokens,
1004                        T1_MAX_MM_MAP_POINTS, &amp;num_points );
1005 
<span class="line-added">1006       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1007 </span>
1008       if ( num_points &lt;= 0 || num_points &gt; T1_MAX_MM_MAP_POINTS )
1009       {
1010         FT_ERROR(( &quot;parse_blend_design_map: incorrect table\n&quot; ));
1011         error = FT_THROW( Invalid_File_Format );
1012         goto Exit;
1013       }
1014 
1015       if ( map-&gt;design_points )
1016       {
1017         FT_ERROR(( &quot;parse_blend_design_map: duplicate table\n&quot; ));
1018         error = FT_THROW( Invalid_File_Format );
1019         goto Exit;
1020       }
1021 
1022       /* allocate design map data */
1023       if ( FT_NEW_ARRAY( map-&gt;design_points, num_points * 2 ) )
1024         goto Exit;
1025       map-&gt;blend_points = map-&gt;design_points + num_points;
1026       map-&gt;num_points   = (FT_Byte)num_points;
1027 
1028       for ( p = 0; p &lt; num_points; p++ )
1029       {
1030         T1_Token  point_token;
1031 
1032 
1033         point_token = point_tokens + p;
1034 
1035         /* don&#39;t include delimiting brackets */
1036         parser-&gt;root.cursor = point_token-&gt;start + 1;
1037         parser-&gt;root.limit  = point_token-&gt;limit - 1;
1038 
1039         map-&gt;design_points[p] = T1_ToInt( parser );
1040         map-&gt;blend_points [p] = T1_ToFixed( parser, 0 );
<span class="line-added">1041 </span>
<span class="line-added">1042         FT_TRACE4(( &quot; [%d %f]&quot;,</span>
<span class="line-added">1043                     map-&gt;design_points[p],</span>
<span class="line-added">1044                     (double)map-&gt;blend_points[p] / 65536 ));</span>
1045       }
<span class="line-added">1046 </span>
<span class="line-added">1047       FT_TRACE4(( &quot;]&quot; ));</span>
1048     }
1049 
<span class="line-added">1050     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1051 </span>
1052     parser-&gt;root.cursor = old_cursor;
1053     parser-&gt;root.limit  = old_limit;
1054 
1055   Exit:
1056     parser-&gt;root.error = error;
1057   }
1058 
1059 
1060   static void
1061   parse_weight_vector( T1_Face    face,
1062                        T1_Loader  loader )
1063   {
1064     T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];
1065     FT_Int       num_designs;
1066     FT_Error     error  = FT_Err_Ok;
1067     T1_Parser    parser = &amp;loader-&gt;parser;
1068     PS_Blend     blend  = face-&gt;blend;
1069     T1_Token     token;
1070     FT_Int       n;
1071     FT_Byte*     old_cursor;
</pre>
<hr />
<pre>
1091     if ( !blend || !blend-&gt;num_designs )
1092     {
1093       error = t1_allocate_blend( face, (FT_UInt)num_designs, 0 );
1094       if ( error )
1095         goto Exit;
1096       blend = face-&gt;blend;
1097     }
1098     else if ( blend-&gt;num_designs != (FT_UInt)num_designs )
1099     {
1100       FT_ERROR(( &quot;parse_weight_vector:&quot;
1101                  &quot; /BlendDesignPosition and /WeightVector have\n&quot;
1102                  &quot;                    &quot;
1103                  &quot; different number of elements\n&quot; ));
1104       error = FT_THROW( Invalid_File_Format );
1105       goto Exit;
1106     }
1107 
1108     old_cursor = parser-&gt;root.cursor;
1109     old_limit  = parser-&gt;root.limit;
1110 
<span class="line-added">1111     FT_TRACE4(( &quot;[&quot; ));</span>
<span class="line-added">1112 </span>
1113     for ( n = 0; n &lt; num_designs; n++ )
1114     {
1115       token = design_tokens + n;
1116       parser-&gt;root.cursor = token-&gt;start;
1117       parser-&gt;root.limit  = token-&gt;limit;
1118 
1119       blend-&gt;default_weight_vector[n] =
1120       blend-&gt;weight_vector[n]         = T1_ToFixed( parser, 0 );
<span class="line-added">1121 </span>
<span class="line-added">1122       FT_TRACE4(( &quot; %f&quot;, (double)blend-&gt;weight_vector[n] / 65536 ));</span>
1123     }
1124 
<span class="line-added">1125     FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1126 </span>
1127     parser-&gt;root.cursor = old_cursor;
1128     parser-&gt;root.limit  = old_limit;
1129 
1130   Exit:
1131     parser-&gt;root.error = error;
1132   }
1133 
1134 
1135   /* e.g., /BuildCharArray [0 0 0 0 0 0 0 0] def           */
1136   /* we&#39;re only interested in the number of array elements */
1137   static void
1138   parse_buildchar( T1_Face    face,
1139                    T1_Loader  loader )
1140   {
1141     face-&gt;len_buildchar = (FT_UInt)T1_ToFixedArray( &amp;loader-&gt;parser,
1142                                                     0, NULL, 0 );
<span class="line-added">1143 </span>
<span class="line-added">1144 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1145     {</span>
<span class="line-added">1146       FT_UInt  i;</span>
<span class="line-added">1147 </span>
<span class="line-added">1148 </span>
<span class="line-added">1149       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1150       for ( i = 0; i &lt; face-&gt;len_buildchar; i++ )</span>
<span class="line-added">1151         FT_TRACE4(( &quot; 0&quot; ));</span>
<span class="line-added">1152 </span>
<span class="line-added">1153       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1154     }</span>
<span class="line-added">1155 #endif</span>
<span class="line-added">1156 </span>
1157     return;
1158   }
1159 
1160 
1161 #endif /* !T1_CONFIG_OPTION_NO_MM_SUPPORT */
1162 
1163 
1164 
1165 
1166   /*************************************************************************/
1167   /*************************************************************************/
1168   /*****                                                               *****/
1169   /*****                      TYPE 1 SYMBOL PARSING                    *****/
1170   /*****                                                               *****/
1171   /*************************************************************************/
1172   /*************************************************************************/
1173 
1174   static FT_Error
1175   t1_load_keyword( T1_Face         face,
1176                    T1_Loader       loader,
1177                    const T1_Field  field )
1178   {
1179     FT_Error  error;
1180     void*     dummy_object;
1181     void**    objects;
1182     FT_UInt   max_objects;
1183     PS_Blend  blend = face-&gt;blend;
1184 
1185 
1186     if ( blend &amp;&amp; blend-&gt;num_designs == 0 )
1187       blend = NULL;
1188 
1189     /* if the keyword has a dedicated callback, call it */
1190     if ( field-&gt;type == T1_FIELD_TYPE_CALLBACK )
1191     {
<span class="line-added">1192       FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="line-added">1193 </span>
1194       field-&gt;reader( (FT_Face)face, loader );
1195       error = loader-&gt;parser.root.error;
1196       goto Exit;
1197     }
1198 
1199     /* now, the keyword is either a simple field, or a table of fields; */
1200     /* we are now going to take care of it                              */
1201     switch ( field-&gt;location )
1202     {
1203     case T1_FIELD_LOCATION_FONT_INFO:
1204       dummy_object = &amp;face-&gt;type1.font_info;
1205       objects      = &amp;dummy_object;
1206       max_objects  = 0;
1207 
1208       if ( blend )
1209       {
1210         objects     = (void**)blend-&gt;font_infos;
1211         max_objects = blend-&gt;num_designs;
1212       }
1213       break;
</pre>
<hr />
<pre>
1251     case T1_FIELD_LOCATION_FACE:
1252       dummy_object = face;
1253       objects      = &amp;dummy_object;
1254       max_objects  = 0;
1255       break;
1256 
1257 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
1258     case T1_FIELD_LOCATION_BLEND:
1259       dummy_object = face-&gt;blend;
1260       objects      = &amp;dummy_object;
1261       max_objects  = 0;
1262       break;
1263 #endif
1264 
1265     default:
1266       dummy_object = &amp;face-&gt;type1;
1267       objects      = &amp;dummy_object;
1268       max_objects  = 0;
1269     }
1270 
<span class="line-added">1271     FT_TRACE4(( &quot;  %s&quot;, field-&gt;ident ));</span>
<span class="line-added">1272 </span>
1273     if ( *objects )
1274     {
1275       if ( field-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
1276            field-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
1277         error = T1_Load_Field_Table( &amp;loader-&gt;parser, field,
1278                                      objects, max_objects, 0 );
1279       else
1280         error = T1_Load_Field( &amp;loader-&gt;parser, field,
1281                                objects, max_objects, 0 );
1282     }
1283     else
1284     {
1285       FT_TRACE1(( &quot;t1_load_keyword: ignoring keyword `%s&#39;&quot;
1286                   &quot; which is not valid at this point\n&quot;
1287                   &quot;                 (probably due to missing keywords)\n&quot;,
1288                  field-&gt;ident ));
1289       error = FT_Err_Ok;
1290     }
1291 
<span class="line-added">1292     FT_TRACE4(( &quot;\n&quot; ));</span>
<span class="line-added">1293 </span>
1294   Exit:
1295     return error;
1296   }
1297 
1298 
1299   static void
1300   parse_private( T1_Face    face,
1301                  T1_Loader  loader )
1302   {
1303     FT_UNUSED( face );
1304 
1305     loader-&gt;keywords_encountered |= T1_PRIVATE;
<span class="line-added">1306 </span>
<span class="line-added">1307     FT_TRACE4(( &quot;\n&quot; ));</span>
1308   }
1309 
1310 
1311   /* return 1 in case of success */
1312 
1313   static int
1314   read_binary_data( T1_Parser  parser,
1315                     FT_ULong*  size,
1316                     FT_Byte**  base,
1317                     FT_Bool    incremental )
1318   {
1319     FT_Byte*  cur;
1320     FT_Byte*  limit = parser-&gt;root.limit;
1321 
1322 
1323     /* the binary data has one of the following formats */
1324     /*                                                  */
1325     /*   `size&#39; [white*] RD white ....... ND            */
1326     /*   `size&#39; [white*] -| white ....... |-            */
1327     /*                                                  */
</pre>
<hr />
<pre>
1367                         T1_Loader  loader )
1368   {
1369     T1_Parser   parser = &amp;loader-&gt;parser;
1370     FT_Matrix*  matrix = &amp;face-&gt;type1.font_matrix;
1371     FT_Vector*  offset = &amp;face-&gt;type1.font_offset;
1372     FT_Face     root   = (FT_Face)&amp;face-&gt;root;
1373     FT_Fixed    temp[6];
1374     FT_Fixed    temp_scale;
1375     FT_Int      result;
1376 
1377 
1378     /* input is scaled by 1000 to accommodate default FontMatrix */
1379     result = T1_ToFixedArray( parser, 6, temp, 3 );
1380 
1381     if ( result &lt; 6 )
1382     {
1383       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1384       return;
1385     }
1386 
<span class="line-added">1387     FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,</span>
<span class="line-added">1388                 (double)temp[0] / 65536 / 1000,</span>
<span class="line-added">1389                 (double)temp[1] / 65536 / 1000,</span>
<span class="line-added">1390                 (double)temp[2] / 65536 / 1000,</span>
<span class="line-added">1391                 (double)temp[3] / 65536 / 1000,</span>
<span class="line-added">1392                 (double)temp[4] / 65536 / 1000,</span>
<span class="line-added">1393                 (double)temp[5] / 65536 / 1000 ));</span>
<span class="line-added">1394 </span>
1395     temp_scale = FT_ABS( temp[3] );
1396 
1397     if ( temp_scale == 0 )
1398     {
1399       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));
1400       parser-&gt;root.error = FT_THROW( Invalid_File_Format );
1401       return;
1402     }
1403 
1404     /* atypical case */
1405     if ( temp_scale != 0x10000L )
1406     {
1407       /* set units per EM based on FontMatrix values */
1408       root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
1409 
1410       temp[0] = FT_DivFix( temp[0], temp_scale );
1411       temp[1] = FT_DivFix( temp[1], temp_scale );
1412       temp[2] = FT_DivFix( temp[2], temp_scale );
1413       temp[4] = FT_DivFix( temp[4], temp_scale );
1414       temp[5] = FT_DivFix( temp[5], temp_scale );
1415       temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
1416     }

1417     matrix-&gt;xx = temp[0];
1418     matrix-&gt;yx = temp[1];
1419     matrix-&gt;xy = temp[2];
1420     matrix-&gt;yy = temp[3];
1421 
<span class="line-added">1422     if ( !FT_Matrix_Check( matrix ) )</span>
<span class="line-added">1423     {</span>
<span class="line-added">1424       FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));</span>
<span class="line-added">1425       parser-&gt;root.error = FT_THROW( Invalid_File_Format );</span>
<span class="line-added">1426       return;</span>
<span class="line-added">1427     }</span>
<span class="line-added">1428 </span>
1429     /* note that the offsets must be expressed in integer font units */
1430     offset-&gt;x = temp[4] &gt;&gt; 16;
1431     offset-&gt;y = temp[5] &gt;&gt; 16;
1432   }
1433 
1434 
1435   static void
1436   parse_encoding( T1_Face    face,
1437                   T1_Loader  loader )
1438   {
1439     T1_Parser  parser = &amp;loader-&gt;parser;
1440     FT_Byte*   cur;
1441     FT_Byte*   limit  = parser-&gt;root.limit;
1442 
1443     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1444 
1445 
1446     T1_Skip_Spaces( parser );
1447     cur = parser-&gt;root.cursor;
1448     if ( cur &gt;= limit )
</pre>
<hr />
<pre>
1490       if ( encode-&gt;char_index )
1491       {
1492         FT_FREE( encode-&gt;char_index );
1493         FT_FREE( encode-&gt;char_name );
1494         T1_Release_Table( char_table );
1495       }
1496 
1497       /* we use a T1_Table to store our charnames */
1498       loader-&gt;num_chars = encode-&gt;num_chars = array_size;
1499       if ( FT_NEW_ARRAY( encode-&gt;char_index, array_size )     ||
1500            FT_NEW_ARRAY( encode-&gt;char_name,  array_size )     ||
1501            FT_SET_ERROR( psaux-&gt;ps_table_funcs-&gt;init(
1502                            char_table, array_size, memory ) ) )
1503       {
1504         parser-&gt;root.error = error;
1505         return;
1506       }
1507 
1508       /* We need to `zero&#39; out encoding_table.elements */
1509       for ( n = 0; n &lt; array_size; n++ )
<span class="line-modified">1510         (void)T1_Add_Table( char_table, n, &quot;.notdef&quot;, 8 );</span>





1511 
1512       /* Now we need to read records of the form                */
1513       /*                                                        */
1514       /*   ... charcode /charname ...                           */
1515       /*                                                        */
1516       /* for each entry in our table.                           */
1517       /*                                                        */
1518       /* We simply look for a number followed by an immediate   */
1519       /* name.  Note that this ignores correctly the sequence   */
1520       /* that is often seen in type1 fonts:                     */
1521       /*                                                        */
1522       /*   0 1 255 { 1 index exch /.notdef put } for dup        */
1523       /*                                                        */
1524       /* used to clean the encoding array before anything else. */
1525       /*                                                        */
1526       /* Alternatively, if the array is directly given as       */
1527       /*                                                        */
1528       /*   /Encoding [ ... ]                                    */
1529       /*                                                        */
1530       /* we only read immediates.                               */
</pre>
<hr />
<pre>
1612             /* we don&#39;t do anything here.                              */
1613             /*                                                         */
1614             /* This encoding array is not valid according to the type1 */
1615             /* specification (it might be an encoding for a CID type1  */
1616             /* font, however), so we conclude that this font is NOT a  */
1617             /* type1 font.                                             */
1618             parser-&gt;root.error = FT_THROW( Unknown_File_Format );
1619             return;
1620           }
1621         }
1622         else
1623         {
1624           T1_Skip_PS_Token( parser );
1625           if ( parser-&gt;root.error )
1626             return;
1627         }
1628 
1629         T1_Skip_Spaces( parser );
1630       }
1631 
<span class="line-added">1632 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1633       FT_TRACE4(( &quot; [&quot; ));</span>
<span class="line-added">1634 </span>
<span class="line-added">1635       /* XXX show encoding vector */</span>
<span class="line-added">1636       FT_TRACE4(( &quot;...&quot; ));</span>
<span class="line-added">1637 </span>
<span class="line-added">1638       FT_TRACE4(( &quot;]\n&quot; ));</span>
<span class="line-added">1639 #endif</span>
<span class="line-added">1640 </span>
1641       face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ARRAY;
1642       parser-&gt;root.cursor       = cur;
1643     }
1644 
1645     /* Otherwise, we should have either `StandardEncoding&#39;, */
1646     /* `ExpertEncoding&#39;, or `ISOLatin1Encoding&#39;             */
1647     else
1648     {
1649       if ( cur + 17 &lt; limit                                            &amp;&amp;
1650            ft_strncmp( (const char*)cur, &quot;StandardEncoding&quot;, 16 ) == 0 )
<span class="line-added">1651       {</span>
1652         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_STANDARD;
<span class="line-added">1653         FT_TRACE4(( &quot; StandardEncoding\n&quot; ));</span>
<span class="line-added">1654       }</span>
1655 
1656       else if ( cur + 15 &lt; limit                                          &amp;&amp;
1657                 ft_strncmp( (const char*)cur, &quot;ExpertEncoding&quot;, 14 ) == 0 )
<span class="line-added">1658       {</span>
1659         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_EXPERT;
<span class="line-added">1660         FT_TRACE4(( &quot; ExpertEncoding\n&quot; ));</span>
<span class="line-added">1661       }</span>
1662 
1663       else if ( cur + 18 &lt; limit                                             &amp;&amp;
1664                 ft_strncmp( (const char*)cur, &quot;ISOLatin1Encoding&quot;, 17 ) == 0 )
<span class="line-added">1665       {</span>
1666         face-&gt;type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;
<span class="line-added">1667         FT_TRACE4(( &quot; ISOLatin1Encoding\n&quot; ));</span>
<span class="line-added">1668       }</span>
1669 
1670       else
<span class="line-added">1671       {</span>
1672         parser-&gt;root.error = FT_ERR( Ignore );
<span class="line-added">1673         FT_TRACE4(( &quot;&lt;unknown&gt;\n&quot; ));</span>
<span class="line-added">1674       }</span>
1675     }
1676   }
1677 
1678 
1679   static void
1680   parse_subrs( T1_Face    face,
1681                T1_Loader  loader )
1682   {
1683     T1_Parser  parser = &amp;loader-&gt;parser;
1684     PS_Table   table  = &amp;loader-&gt;subrs;
1685     FT_Memory  memory = parser-&gt;root.memory;
1686     FT_Error   error;
1687     FT_Int     num_subrs;
1688     FT_UInt    count;
1689 
1690     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
1691 
1692 
1693     T1_Skip_Spaces( parser );
1694 
</pre>
<hr />
<pre>
1835 
1836         /* t1_decrypt() shouldn&#39;t write to base -- make temporary copy */
1837         if ( FT_ALLOC( temp, size ) )
1838           goto Fail;
1839         FT_MEM_COPY( temp, base, size );
1840         psaux-&gt;t1_decrypt( temp, size, 4330 );
1841         size -= (FT_ULong)face-&gt;type1.private_dict.lenIV;
1842         error = T1_Add_Table( table, (FT_Int)idx,
1843                               temp + face-&gt;type1.private_dict.lenIV, size );
1844         FT_FREE( temp );
1845       }
1846       else
1847         error = T1_Add_Table( table, (FT_Int)idx, base, size );
1848       if ( error )
1849         goto Fail;
1850     }
1851 
1852     if ( !loader-&gt;num_subrs )
1853       loader-&gt;num_subrs = num_subrs;
1854 
<span class="line-added">1855 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">1856       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="line-added">1857 </span>
<span class="line-added">1858       /* XXX show subrs? */</span>
<span class="line-added">1859       FT_TRACE4(( &quot;%d elements&quot;, num_subrs ));</span>
<span class="line-added">1860 </span>
<span class="line-added">1861       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="line-added">1862 #endif</span>
<span class="line-added">1863 </span>
1864     return;
1865 
1866   Fail:
1867     parser-&gt;root.error = error;
1868   }
1869 
1870 
1871 #define TABLE_EXTEND  5
1872 
1873 
1874   static void
1875   parse_charstrings( T1_Face    face,
1876                      T1_Loader  loader )
1877   {
1878     T1_Parser      parser       = &amp;loader-&gt;parser;
1879     PS_Table       code_table   = &amp;loader-&gt;charstrings;
1880     PS_Table       name_table   = &amp;loader-&gt;glyph_names;
1881     PS_Table       swap_table   = &amp;loader-&gt;swap_table;
1882     FT_Memory      memory       = parser-&gt;root.memory;
1883     FT_Error       error;
</pre>
<hr />
<pre>
2125                             swap_table-&gt;lengths [2] );
2126       if ( error )
2127         goto Fail;
2128 
2129       error = T1_Add_Table( code_table, 0,
2130                             swap_table-&gt;elements[3],
2131                             swap_table-&gt;lengths [3] );
2132       if ( error )
2133         goto Fail;
2134 
2135     }
2136     else if ( !notdef_found )
2137     {
2138       /* notdef_index is already 0, or /.notdef is undefined in   */
2139       /* charstrings dictionary.  Worry about /.notdef undefined. */
2140       /* We take index 0 and add it to the end of the table(s)    */
2141       /* and add our own /.notdef glyph to index 0.               */
2142 
2143       /* 0 333 hsbw endchar */
2144       FT_Byte  notdef_glyph[] = { 0x8B, 0xF7, 0xE1, 0x0D, 0x0E };

2145 
2146 
2147       error = T1_Add_Table( swap_table, 0,
2148                             name_table-&gt;elements[0],
2149                             name_table-&gt;lengths [0] );
2150       if ( error )
2151         goto Fail;
2152 
2153       error = T1_Add_Table( swap_table, 1,
2154                             code_table-&gt;elements[0],
2155                             code_table-&gt;lengths [0] );
2156       if ( error )
2157         goto Fail;
2158 
<span class="line-modified">2159       error = T1_Add_Table( name_table, 0, &quot;.notdef&quot;, 8 );</span>
2160       if ( error )
2161         goto Fail;
2162 
2163       error = T1_Add_Table( code_table, 0, notdef_glyph, 5 );
2164 
2165       if ( error )
2166         goto Fail;
2167 
2168       error = T1_Add_Table( name_table, n,
2169                             swap_table-&gt;elements[0],
2170                             swap_table-&gt;lengths [0] );
2171       if ( error )
2172         goto Fail;
2173 
2174       error = T1_Add_Table( code_table, n,
2175                             swap_table-&gt;elements[1],
2176                             swap_table-&gt;lengths [1] );
2177       if ( error )
2178         goto Fail;
2179 
2180       /* we added a glyph. */
2181       loader-&gt;num_glyphs += 1;
2182     }
2183 
<span class="line-added">2184 #ifdef FT_DEBUG_LEVEL_TRACE</span>
<span class="line-added">2185       FT_TRACE4(( &quot; &lt;&quot; ));</span>
<span class="line-added">2186 </span>
<span class="line-added">2187       /* XXX show charstrings? */</span>
<span class="line-added">2188       FT_TRACE4(( &quot;%d elements&quot;, loader-&gt;num_glyphs ));</span>
<span class="line-added">2189 </span>
<span class="line-added">2190       FT_TRACE4(( &quot;&gt;\n&quot; ));</span>
<span class="line-added">2191 #endif</span>
<span class="line-added">2192 </span>
2193     return;
2194 
2195   Fail:
2196     parser-&gt;root.error = error;
2197   }
2198 
2199 
<span class="line-modified">2200   /**************************************************************************</span>
<span class="line-modified">2201    *</span>
<span class="line-modified">2202    * Define the token field static variables.  This is a set of</span>
<span class="line-modified">2203    * T1_FieldRec variables.</span>
<span class="line-modified">2204    *</span>
<span class="line-modified">2205    */</span>
2206 
2207 
2208   static
2209   const T1_FieldRec  t1_keywords[] =
2210   {
2211 
2212 #include &quot;t1tokens.h&quot;
2213 
2214     /* now add the special functions... */
2215     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,           t1_parse_font_matrix,
2216                        T1_FIELD_DICT_FONTDICT )
2217     T1_FIELD_CALLBACK( &quot;Encoding&quot;,             parse_encoding,
2218                        T1_FIELD_DICT_FONTDICT )
2219     T1_FIELD_CALLBACK( &quot;Subrs&quot;,                parse_subrs,
2220                        T1_FIELD_DICT_PRIVATE )
2221     T1_FIELD_CALLBACK( &quot;CharStrings&quot;,          parse_charstrings,
2222                        T1_FIELD_DICT_PRIVATE )
2223     T1_FIELD_CALLBACK( &quot;Private&quot;,              parse_private,
2224                        T1_FIELD_DICT_FONTDICT )
2225 
</pre>
<hr />
<pre>
2372               /* `FontDirectory&#39;.                             */
2373 
2374               /* MM fonts have more than one /Private token at */
2375               /* the top level; let&#39;s hope that all the junk   */
2376               /* that follows the first /Private token is not  */
2377               /* interesting to us.                            */
2378 
2379               /* According to Adobe Tech Note #5175 (CID-Keyed */
2380               /* Font Installation for ATM Software) a `begin&#39; */
2381               /* must be followed by exactly one `end&#39;, and    */
2382               /* `begin&#39; -- `end&#39; pairs must be accurately     */
2383               /* paired.  We could use this to distinguish     */
2384               /* between the global Private and the Private    */
2385               /* dict that is a member of the Blend dict.      */
2386 
2387               const FT_UInt dict =
2388                 ( loader-&gt;keywords_encountered &amp; T1_PRIVATE )
2389                     ? T1_FIELD_DICT_PRIVATE
2390                     : T1_FIELD_DICT_FONTDICT;
2391 
<span class="line-added">2392 </span>
2393               if ( !( dict &amp; keyword-&gt;dict ) )
2394               {
2395                 FT_TRACE1(( &quot;parse_dict: found `%s&#39; but ignoring it&quot;
2396                             &quot; since it is in the wrong dictionary\n&quot;,
2397                             keyword-&gt;ident ));
2398                 break;
2399               }
2400 
2401               if ( !( loader-&gt;keywords_encountered &amp;
2402                       T1_FONTDIR_AFTER_PRIVATE     )                  ||
2403                    ft_strcmp( (const char*)name, &quot;CharStrings&quot; ) == 0 )
2404               {
2405                 parser-&gt;root.error = t1_load_keyword( face,
2406                                                       loader,
2407                                                       keyword );
2408                 if ( parser-&gt;root.error )
2409                 {
2410                   if ( FT_ERR_EQ( parser-&gt;root.error, Ignore ) )
2411                     parser-&gt;root.error = FT_Err_Ok;
2412                   else
</pre>
<hr />
<pre>
2487 
2488     /* default values */
2489     face-&gt;ndv_idx          = -1;
2490     face-&gt;cdv_idx          = -1;
2491     face-&gt;len_buildchar    = 0;
2492 
2493     priv-&gt;blue_shift       = 7;
2494     priv-&gt;blue_fuzz        = 1;
2495     priv-&gt;lenIV            = 4;
2496     priv-&gt;expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
2497     priv-&gt;blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );
2498 
2499     parser = &amp;loader.parser;
2500     error  = T1_New_Parser( parser,
2501                             face-&gt;root.stream,
2502                             face-&gt;root.memory,
2503                             psaux );
2504     if ( error )
2505       goto Exit;
2506 
<span class="line-added">2507     FT_TRACE4(( &quot; top dictionary:\n&quot; ));</span>
2508     error = parse_dict( face, &amp;loader,
2509                         parser-&gt;base_dict, parser-&gt;base_len );
2510     if ( error )
2511       goto Exit;
2512 
2513     error = T1_Get_Private_Dict( parser, psaux );
2514     if ( error )
2515       goto Exit;
2516 
<span class="line-added">2517     FT_TRACE4(( &quot; private dictionary:\n&quot; ));</span>
2518     error = parse_dict( face, &amp;loader,
2519                         parser-&gt;private_dict, parser-&gt;private_len );
2520     if ( error )
2521       goto Exit;
2522 
2523     /* ensure even-ness of `num_blue_values&#39; */
2524     priv-&gt;num_blue_values &amp;= ~1;
2525 
2526 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
2527 
<span class="line-added">2528     /* we don&#39;t support Multiple Master fonts with intermediate designs; */</span>
<span class="line-added">2529     /* this implies that `num_designs&#39; must be equal to `2^^num_axis&#39;    */</span>
<span class="line-added">2530     if ( face-&gt;blend                                                 &amp;&amp;</span>
<span class="line-added">2531          face-&gt;blend-&gt;num_designs != ( 1U &lt;&lt; face-&gt;blend-&gt;num_axis ) )</span>
<span class="line-added">2532     {</span>
<span class="line-added">2533       FT_ERROR(( &quot;T1_Open_Face:&quot;</span>
<span class="line-added">2534                  &quot; number-of-designs != 2 ^^ number-of-axes\n&quot; ));</span>
<span class="line-added">2535       T1_Done_Blend( face );</span>
<span class="line-added">2536     }</span>
<span class="line-added">2537 </span>
2538     if ( face-&gt;blend                                                     &amp;&amp;
2539          face-&gt;blend-&gt;num_default_design_vector != 0                     &amp;&amp;
2540          face-&gt;blend-&gt;num_default_design_vector != face-&gt;blend-&gt;num_axis )
2541     {
2542       /* we don&#39;t use it currently so just warn, reset, and ignore */
2543       FT_ERROR(( &quot;T1_Open_Face(): /DesignVector contains %u entries &quot;
2544                  &quot;while there are %u axes.\n&quot;,
2545                  face-&gt;blend-&gt;num_default_design_vector,
2546                  face-&gt;blend-&gt;num_axis ));
2547 
2548       face-&gt;blend-&gt;num_default_design_vector = 0;
2549     }
2550 
2551     /* the following can happen for MM instances; we then treat the */
2552     /* font as a normal PS font                                     */
2553     if ( face-&gt;blend                                             &amp;&amp;
2554          ( !face-&gt;blend-&gt;num_designs || !face-&gt;blend-&gt;num_axis ) )
2555       T1_Done_Blend( face );
2556 
2557     /* another safety check */
</pre>
<hr />
<pre>
2610       {
2611         FT_ERROR(( &quot;T1_Open_Face: no `/CharStrings&#39; array in face\n&quot; ));
2612         error = FT_THROW( Invalid_File_Format );
2613       }
2614 
2615     loader.charstrings.init  = 0;
2616     type1-&gt;charstrings_block = loader.charstrings.block;
2617     type1-&gt;charstrings       = loader.charstrings.elements;
2618     type1-&gt;charstrings_len   = loader.charstrings.lengths;
2619 
2620     /* we copy the glyph names `block&#39; and `elements&#39; fields; */
2621     /* the `lengths&#39; field must be released later             */
2622     type1-&gt;glyph_names_block    = loader.glyph_names.block;
2623     type1-&gt;glyph_names          = (FT_String**)loader.glyph_names.elements;
2624     loader.glyph_names.block    = NULL;
2625     loader.glyph_names.elements = NULL;
2626 
2627     /* we must now build type1.encoding when we have a custom array */
2628     if ( type1-&gt;encoding_type == T1_ENCODING_TYPE_ARRAY )
2629     {
<span class="line-modified">2630       FT_Int  charcode, idx, min_char, max_char;</span>

2631 
2632 
2633       /* OK, we do the following: for each element in the encoding  */
2634       /* table, look up the index of the glyph having the same name */
2635       /* the index is then stored in type1.encoding.char_index, and */
2636       /* the name to type1.encoding.char_name                       */
2637 
2638       min_char = 0;
2639       max_char = 0;
2640 
2641       charcode = 0;
2642       for ( ; charcode &lt; loader.encoding_table.max_elems; charcode++ )
2643       {
<span class="line-modified">2644         const FT_String*  char_name =</span>
<span class="line-added">2645               (const FT_String*)loader.encoding_table.elements[charcode];</span>
2646 
2647 
2648         type1-&gt;encoding.char_index[charcode] = 0;
<span class="line-modified">2649         type1-&gt;encoding.char_name [charcode] = &quot;.notdef&quot;;</span>
2650 

2651         if ( char_name )
2652           for ( idx = 0; idx &lt; type1-&gt;num_glyphs; idx++ )
2653           {
<span class="line-modified">2654             const FT_String*  glyph_name = type1-&gt;glyph_names[idx];</span>
<span class="line-modified">2655 </span>
<span class="line-modified">2656 </span>
<span class="line-added">2657             if ( ft_strcmp( char_name, glyph_name ) == 0 )</span>
2658             {
2659               type1-&gt;encoding.char_index[charcode] = (FT_UShort)idx;
<span class="line-modified">2660               type1-&gt;encoding.char_name [charcode] = glyph_name;</span>
2661 
2662               /* Change min/max encoded char only if glyph name is */
2663               /* not /.notdef                                      */
<span class="line-modified">2664               if ( ft_strcmp( &quot;.notdef&quot;, glyph_name ) != 0 )</span>

2665               {
2666                 if ( charcode &lt; min_char )
2667                   min_char = charcode;
2668                 if ( charcode &gt;= max_char )
2669                   max_char = charcode + 1;
2670               }
2671               break;
2672             }
2673           }
2674       }
2675 
2676       type1-&gt;encoding.code_first = min_char;
2677       type1-&gt;encoding.code_last  = max_char;
2678       type1-&gt;encoding.num_chars  = loader.num_chars;
2679     }
2680 
2681     /* some sanitizing to avoid overflows later on; */
2682     /* the upper limits are ad-hoc values           */
2683     if ( priv-&gt;blue_shift &gt; 1000 || priv-&gt;blue_shift &lt; 0 )
2684     {
</pre>
</td>
</tr>
</table>
<center><a href="t1gload.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1load.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
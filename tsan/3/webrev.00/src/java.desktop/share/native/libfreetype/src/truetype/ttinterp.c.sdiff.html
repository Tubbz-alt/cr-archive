<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ttgxvar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttinterp.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/truetype/ttinterp.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ttinterp.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    TrueType bytecode interpreter (body).                                */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 /* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
  20 /* issues; many thanks!                                                */
  21 
  22 
  23 #include &lt;ft2build.h&gt;
  24 #include FT_INTERNAL_DEBUG_H
  25 #include FT_INTERNAL_CALC_H
  26 #include FT_TRIGONOMETRY_H
  27 #include FT_SYSTEM_H
  28 #include FT_DRIVER_H
  29 #include FT_MULTIPLE_MASTERS_H
  30 
  31 #include &quot;ttinterp.h&quot;
  32 #include &quot;tterrors.h&quot;
  33 #include &quot;ttsubpix.h&quot;
  34 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  35 #include &quot;ttgxvar.h&quot;
  36 #endif
  37 
  38 
  39 #ifdef TT_USE_BYTECODE_INTERPRETER
  40 
  41 
<span class="line-modified">  42   /*************************************************************************/</span>
<span class="line-modified">  43   /*                                                                       */</span>
<span class="line-modified">  44   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  45   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  46   /* messages during execution.                                            */</span>
<span class="line-modified">  47   /*                                                                       */</span>
  48 #undef  FT_COMPONENT
<span class="line-modified">  49 #define FT_COMPONENT  trace_ttinterp</span>
  50 
  51 
  52 #define NO_SUBPIXEL_HINTING                                                  \
  53           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  54             TT_INTERPRETER_VERSION_35 )
  55 
  56 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
  57 #define SUBPIXEL_HINTING_INFINALITY                                          \
  58           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  59             TT_INTERPRETER_VERSION_38 )
  60 #endif
  61 
  62 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
  63 #define SUBPIXEL_HINTING_MINIMAL                                             \
  64           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  65             TT_INTERPRETER_VERSION_40 )
  66 #endif
  67 
  68 #define PROJECT( v1, v2 )                                   \
  69           exc-&gt;func_project( exc,                           \
  70                              SUB_LONG( (v1)-&gt;x, (v2)-&gt;x ),  \
  71                              SUB_LONG( (v1)-&gt;y, (v2)-&gt;y ) )
  72 
  73 #define DUALPROJ( v1, v2 )                                   \
  74           exc-&gt;func_dualproj( exc,                           \
  75                               SUB_LONG( (v1)-&gt;x, (v2)-&gt;x ),  \
  76                               SUB_LONG( (v1)-&gt;y, (v2)-&gt;y ) )
  77 
  78 #define FAST_PROJECT( v )                          \
  79           exc-&gt;func_project( exc, (v)-&gt;x, (v)-&gt;y )
  80 
  81 #define FAST_DUALPROJ( v )                          \
  82           exc-&gt;func_dualproj( exc, (v)-&gt;x, (v)-&gt;y )
  83 
  84 
<span class="line-modified">  85   /*************************************************************************/</span>
<span class="line-modified">  86   /*                                                                       */</span>
<span class="line-modified">  87   /* Two simple bounds-checking macros.                                    */</span>
<span class="line-modified">  88   /*                                                                       */</span>
  89 #define BOUNDS( x, n )   ( (FT_UInt)(x)  &gt;= (FT_UInt)(n)  )
  90 #define BOUNDSL( x, n )  ( (FT_ULong)(x) &gt;= (FT_ULong)(n) )
  91 
  92 
  93 #undef  SUCCESS
  94 #define SUCCESS  0
  95 
  96 #undef  FAILURE
  97 #define FAILURE  1
  98 
  99 
<span class="line-modified"> 100   /*************************************************************************/</span>
<span class="line-modified"> 101   /*                                                                       */</span>
<span class="line-modified"> 102   /*                        CODERANGE FUNCTIONS                            */</span>
<span class="line-modified"> 103   /*                                                                       */</span>
<span class="line-modified"> 104   /*************************************************************************/</span>
<span class="line-modified"> 105 </span>
<span class="line-modified"> 106 </span>
<span class="line-modified"> 107   /*************************************************************************/</span>
<span class="line-modified"> 108   /*                                                                       */</span>
<span class="line-modified"> 109   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 110   /*    TT_Goto_CodeRange                                                  */</span>
<span class="line-modified"> 111   /*                                                                       */</span>
<span class="line-modified"> 112   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 113   /*    Switches to a new code range (updates the code related elements in */</span>
<span class="line-modified"> 114   /*    `exec&#39;, and `IP&#39;).                                                 */</span>
<span class="line-modified"> 115   /*                                                                       */</span>
<span class="line-modified"> 116   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 117   /*    range :: The new execution code range.                             */</span>
<span class="line-modified"> 118   /*                                                                       */</span>
<span class="line-modified"> 119   /*    IP    :: The new IP in the new code range.                         */</span>
<span class="line-modified"> 120   /*                                                                       */</span>
<span class="line-modified"> 121   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 122   /*    exec  :: The target execution context.                             */</span>
<span class="line-modified"> 123   /*                                                                       */</span>



 124   FT_LOCAL_DEF( void )
 125   TT_Goto_CodeRange( TT_ExecContext  exec,
 126                      FT_Int          range,
 127                      FT_Long         IP )
 128   {
 129     TT_CodeRange*  coderange;
 130 
 131 
 132     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 133 
 134     coderange = &amp;exec-&gt;codeRangeTable[range - 1];
 135 
 136     FT_ASSERT( coderange-&gt;base );
 137 
 138     /* NOTE: Because the last instruction of a program may be a CALL */
 139     /*       which will return to the first byte *after* the code    */
 140     /*       range, we test for IP &lt;= Size instead of IP &lt; Size.     */
 141     /*                                                               */
 142     FT_ASSERT( IP &lt;= coderange-&gt;size );
 143 
 144     exec-&gt;code     = coderange-&gt;base;
 145     exec-&gt;codeSize = coderange-&gt;size;
 146     exec-&gt;IP       = IP;
 147     exec-&gt;curRange = range;
 148   }
 149 
 150 
<span class="line-modified"> 151   /*************************************************************************/</span>
<span class="line-modified"> 152   /*                                                                       */</span>
<span class="line-modified"> 153   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 154   /*    TT_Set_CodeRange                                                   */</span>
<span class="line-modified"> 155   /*                                                                       */</span>
<span class="line-modified"> 156   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 157   /*    Sets a code range.                                                 */</span>
<span class="line-modified"> 158   /*                                                                       */</span>
<span class="line-modified"> 159   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 160   /*    range  :: The code range index.                                    */</span>
<span class="line-modified"> 161   /*                                                                       */</span>
<span class="line-modified"> 162   /*    base   :: The new code base.                                       */</span>
<span class="line-modified"> 163   /*                                                                       */</span>
<span class="line-modified"> 164   /*    length :: The range size in bytes.                                 */</span>
<span class="line-modified"> 165   /*                                                                       */</span>
<span class="line-modified"> 166   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 167   /*    exec   :: The target execution context.                            */</span>
<span class="line-modified"> 168   /*                                                                       */</span>




 169   FT_LOCAL_DEF( void )
 170   TT_Set_CodeRange( TT_ExecContext  exec,
 171                     FT_Int          range,
 172                     void*           base,
 173                     FT_Long         length )
 174   {
 175     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 176 
 177     exec-&gt;codeRangeTable[range - 1].base = (FT_Byte*)base;
 178     exec-&gt;codeRangeTable[range - 1].size = length;
 179   }
 180 
 181 
<span class="line-modified"> 182   /*************************************************************************/</span>
<span class="line-modified"> 183   /*                                                                       */</span>
<span class="line-modified"> 184   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 185   /*    TT_Clear_CodeRange                                                 */</span>
<span class="line-modified"> 186   /*                                                                       */</span>
<span class="line-modified"> 187   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 188   /*    Clears a code range.                                               */</span>
<span class="line-modified"> 189   /*                                                                       */</span>
<span class="line-modified"> 190   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 191   /*    range :: The code range index.                                     */</span>
<span class="line-modified"> 192   /*                                                                       */</span>
<span class="line-modified"> 193   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 194   /*    exec  :: The target execution context.                             */</span>
<span class="line-modified"> 195   /*                                                                       */</span>


 196   FT_LOCAL_DEF( void )
 197   TT_Clear_CodeRange( TT_ExecContext  exec,
 198                       FT_Int          range )
 199   {
 200     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 201 
 202     exec-&gt;codeRangeTable[range - 1].base = NULL;
 203     exec-&gt;codeRangeTable[range - 1].size = 0;
 204   }
 205 
 206 
<span class="line-modified"> 207   /*************************************************************************/</span>
<span class="line-modified"> 208   /*                                                                       */</span>
<span class="line-modified"> 209   /*                   EXECUTION CONTEXT ROUTINES                          */</span>
<span class="line-modified"> 210   /*                                                                       */</span>
<span class="line-modified"> 211   /*************************************************************************/</span>
<span class="line-modified"> 212 </span>
<span class="line-modified"> 213 </span>
<span class="line-modified"> 214   /*************************************************************************/</span>
<span class="line-modified"> 215   /*                                                                       */</span>
<span class="line-modified"> 216   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 217   /*    TT_Done_Context                                                    */</span>
<span class="line-modified"> 218   /*                                                                       */</span>
<span class="line-modified"> 219   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 220   /*    Destroys a given context.                                          */</span>
<span class="line-modified"> 221   /*                                                                       */</span>
<span class="line-modified"> 222   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 223   /*    exec   :: A handle to the target execution context.                */</span>
<span class="line-modified"> 224   /*                                                                       */</span>
<span class="line-modified"> 225   /*    memory :: A handle to the parent memory object.                    */</span>
<span class="line-modified"> 226   /*                                                                       */</span>
<span class="line-modified"> 227   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 228   /*    Only the glyph loader and debugger should call this function.      */</span>
<span class="line-modified"> 229   /*                                                                       */</span>


 230   FT_LOCAL_DEF( void )
 231   TT_Done_Context( TT_ExecContext  exec )
 232   {
 233     FT_Memory  memory = exec-&gt;memory;
 234 
 235 
 236     /* points zone */
 237     exec-&gt;maxPoints   = 0;
 238     exec-&gt;maxContours = 0;
 239 
 240     /* free stack */
 241     FT_FREE( exec-&gt;stack );
 242     exec-&gt;stackSize = 0;
 243 
 244     /* free call stack */
 245     FT_FREE( exec-&gt;callStack );
 246     exec-&gt;callSize = 0;
 247     exec-&gt;callTop  = 0;
 248 
 249     /* free glyph code range */
 250     FT_FREE( exec-&gt;glyphIns );
 251     exec-&gt;glyphSize = 0;
 252 
 253     exec-&gt;size = NULL;
 254     exec-&gt;face = NULL;
 255 
 256     FT_FREE( exec );
 257   }
 258 
 259 
<span class="line-modified"> 260   /*************************************************************************/</span>
<span class="line-modified"> 261   /*                                                                       */</span>
<span class="line-modified"> 262   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 263   /*    Init_Context                                                       */</span>
<span class="line-modified"> 264   /*                                                                       */</span>
<span class="line-modified"> 265   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 266   /*    Initializes a context object.                                      */</span>
<span class="line-modified"> 267   /*                                                                       */</span>
<span class="line-modified"> 268   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 269   /*    memory :: A handle to the parent memory object.                    */</span>
<span class="line-modified"> 270   /*                                                                       */</span>
<span class="line-modified"> 271   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 272   /*    exec   :: A handle to the target execution context.                */</span>
<span class="line-modified"> 273   /*                                                                       */</span>
<span class="line-modified"> 274   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 275   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 276   /*                                                                       */</span>


 277   static FT_Error
 278   Init_Context( TT_ExecContext  exec,
 279                 FT_Memory       memory )
 280   {
 281     FT_Error  error;
 282 
 283 
 284     FT_TRACE1(( &quot;Init_Context: new object at 0x%08p\n&quot;, exec ));
 285 
 286     exec-&gt;memory   = memory;
 287     exec-&gt;callSize = 32;
 288 
 289     if ( FT_NEW_ARRAY( exec-&gt;callStack, exec-&gt;callSize ) )
 290       goto Fail_Memory;
 291 
 292     /* all values in the context are set to 0 already, but this is */
 293     /* here as a remainder                                         */
 294     exec-&gt;maxPoints   = 0;
 295     exec-&gt;maxContours = 0;
 296 
 297     exec-&gt;stackSize = 0;
 298     exec-&gt;glyphSize = 0;
 299 
 300     exec-&gt;stack    = NULL;
 301     exec-&gt;glyphIns = NULL;
 302 
 303     exec-&gt;face = NULL;
 304     exec-&gt;size = NULL;
 305 
 306     return FT_Err_Ok;
 307 
 308   Fail_Memory:
 309     FT_ERROR(( &quot;Init_Context: not enough memory for %p\n&quot;, exec ));
 310     TT_Done_Context( exec );
 311 
 312     return error;
 313  }
 314 
 315 
<span class="line-modified"> 316   /*************************************************************************/</span>
<span class="line-modified"> 317   /*                                                                       */</span>
<span class="line-modified"> 318   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 319   /*    Update_Max                                                         */</span>
<span class="line-modified"> 320   /*                                                                       */</span>
<span class="line-modified"> 321   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 322   /*    Checks the size of a buffer and reallocates it if necessary.       */</span>
<span class="line-modified"> 323   /*                                                                       */</span>
<span class="line-modified"> 324   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 325   /*    memory     :: A handle to the parent memory object.                */</span>
<span class="line-modified"> 326   /*                                                                       */</span>
<span class="line-modified"> 327   /*    multiplier :: The size in bytes of each element in the buffer.     */</span>
<span class="line-modified"> 328   /*                                                                       */</span>
<span class="line-modified"> 329   /*    new_max    :: The new capacity (size) of the buffer.               */</span>
<span class="line-modified"> 330   /*                                                                       */</span>
<span class="line-modified"> 331   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 332   /*    size       :: The address of the buffer&#39;s current size expressed   */</span>
<span class="line-modified"> 333   /*                  in elements.                                         */</span>
<span class="line-modified"> 334   /*                                                                       */</span>
<span class="line-modified"> 335   /*    buff       :: The address of the buffer base pointer.              */</span>
<span class="line-modified"> 336   /*                                                                       */</span>
<span class="line-modified"> 337   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 338   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 339   /*                                                                       */</span>





 340   FT_LOCAL_DEF( FT_Error )
 341   Update_Max( FT_Memory  memory,
 342               FT_ULong*  size,
 343               FT_ULong   multiplier,
 344               void*      _pbuff,
 345               FT_ULong   new_max )
 346   {
 347     FT_Error  error;
 348     void**    pbuff = (void**)_pbuff;
 349 
 350 
 351     if ( *size &lt; new_max )
 352     {
 353       if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
 354         return error;
 355       *size = new_max;
 356     }
 357 
 358     return FT_Err_Ok;
 359   }
 360 
 361 
<span class="line-modified"> 362   /*************************************************************************/</span>
<span class="line-modified"> 363   /*                                                                       */</span>
<span class="line-modified"> 364   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 365   /*    TT_Load_Context                                                    */</span>
<span class="line-modified"> 366   /*                                                                       */</span>
<span class="line-modified"> 367   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 368   /*    Prepare an execution context for glyph hinting.                    */</span>
<span class="line-modified"> 369   /*                                                                       */</span>
<span class="line-modified"> 370   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 371   /*    face :: A handle to the source face object.                        */</span>
<span class="line-modified"> 372   /*                                                                       */</span>
<span class="line-modified"> 373   /*    size :: A handle to the source size object.                        */</span>
<span class="line-modified"> 374   /*                                                                       */</span>
<span class="line-modified"> 375   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 376   /*    exec :: A handle to the target execution context.                  */</span>
<span class="line-modified"> 377   /*                                                                       */</span>
<span class="line-modified"> 378   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 379   /*    FreeType error code.  0 means success.                             */</span>
<span class="line-modified"> 380   /*                                                                       */</span>
<span class="line-modified"> 381   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 382   /*    Only the glyph loader and debugger should call this function.      */</span>
<span class="line-modified"> 383   /*                                                                       */</span>



 384   FT_LOCAL_DEF( FT_Error )
 385   TT_Load_Context( TT_ExecContext  exec,
 386                    TT_Face         face,
 387                    TT_Size         size )
 388   {
 389     FT_Int          i;
 390     FT_ULong        tmp;
 391     TT_MaxProfile*  maxp;
 392     FT_Error        error;
 393 
 394 
 395     exec-&gt;face = face;
 396     maxp       = &amp;face-&gt;max_profile;
 397     exec-&gt;size = size;
 398 
 399     if ( size )
 400     {
 401       exec-&gt;numFDefs   = size-&gt;num_function_defs;
 402       exec-&gt;maxFDefs   = size-&gt;max_function_defs;
 403       exec-&gt;numIDefs   = size-&gt;num_instruction_defs;
</pre>
<hr />
<pre>
 450                         sizeof ( FT_Byte ),
 451                         (void*)&amp;exec-&gt;glyphIns,
 452                         maxp-&gt;maxSizeOfInstructions );
 453     exec-&gt;glyphSize = (FT_UShort)tmp;
 454     if ( error )
 455       return error;
 456 
 457     exec-&gt;pts.n_points   = 0;
 458     exec-&gt;pts.n_contours = 0;
 459 
 460     exec-&gt;zp1 = exec-&gt;pts;
 461     exec-&gt;zp2 = exec-&gt;pts;
 462     exec-&gt;zp0 = exec-&gt;pts;
 463 
 464     exec-&gt;instruction_trap = FALSE;
 465 
 466     return FT_Err_Ok;
 467   }
 468 
 469 
<span class="line-modified"> 470   /*************************************************************************/</span>
<span class="line-modified"> 471   /*                                                                       */</span>
<span class="line-modified"> 472   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 473   /*    TT_Save_Context                                                    */</span>
<span class="line-modified"> 474   /*                                                                       */</span>
<span class="line-modified"> 475   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 476   /*    Saves the code ranges in a `size&#39; object.                          */</span>
<span class="line-modified"> 477   /*                                                                       */</span>
<span class="line-modified"> 478   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 479   /*    exec :: A handle to the source execution context.                  */</span>
<span class="line-modified"> 480   /*                                                                       */</span>
<span class="line-modified"> 481   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 482   /*    size :: A handle to the target size object.                        */</span>
<span class="line-modified"> 483   /*                                                                       */</span>
<span class="line-modified"> 484   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified"> 485   /*    Only the glyph loader and debugger should call this function.      */</span>
<span class="line-modified"> 486   /*                                                                       */</span>


 487   FT_LOCAL_DEF( void )
 488   TT_Save_Context( TT_ExecContext  exec,
 489                    TT_Size         size )
 490   {
 491     FT_Int  i;
 492 
 493 
 494     /* XXX: Will probably disappear soon with all the code range */
 495     /*      management, which is now rather obsolete.            */
 496     /*                                                           */
 497     size-&gt;num_function_defs    = exec-&gt;numFDefs;
 498     size-&gt;num_instruction_defs = exec-&gt;numIDefs;
 499 
 500     size-&gt;max_func = exec-&gt;maxFunc;
 501     size-&gt;max_ins  = exec-&gt;maxIns;
 502 
 503     for ( i = 0; i &lt; TT_MAX_CODE_RANGES; i++ )
 504       size-&gt;codeRangeTable[i] = exec-&gt;codeRangeTable[i];
 505   }
 506 
 507 
<span class="line-modified"> 508   /*************************************************************************/</span>
<span class="line-modified"> 509   /*                                                                       */</span>
<span class="line-modified"> 510   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 511   /*    TT_Run_Context                                                     */</span>
<span class="line-modified"> 512   /*                                                                       */</span>
<span class="line-modified"> 513   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 514   /*    Executes one or more instructions in the execution context.        */</span>
<span class="line-modified"> 515   /*                                                                       */</span>
<span class="line-modified"> 516   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 517   /*    debug :: A Boolean flag.  If set, the function sets some internal  */</span>
<span class="line-modified"> 518   /*             variables and returns immediately, otherwise TT_RunIns()  */</span>
<span class="line-modified"> 519   /*             is called.                                                */</span>
<span class="line-modified"> 520   /*                                                                       */</span>
<span class="line-modified"> 521   /*             This is commented out currently.                          */</span>
<span class="line-modified"> 522   /*                                                                       */</span>
<span class="line-removed"> 523   /* &lt;Input&gt;                                                               */</span>
<span class="line-removed"> 524   /*    exec  :: A handle to the target execution context.                 */</span>
<span class="line-removed"> 525   /*                                                                       */</span>
<span class="line-removed"> 526   /* &lt;Return&gt;                                                              */</span>
<span class="line-removed"> 527   /*    TrueType error code.  0 means success.                             */</span>
<span class="line-removed"> 528   /*                                                                       */</span>
 529   FT_LOCAL_DEF( FT_Error )
 530   TT_Run_Context( TT_ExecContext  exec )
 531   {
 532     TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );
 533 
 534     exec-&gt;zp0 = exec-&gt;pts;
 535     exec-&gt;zp1 = exec-&gt;pts;
 536     exec-&gt;zp2 = exec-&gt;pts;
 537 
 538     exec-&gt;GS.gep0 = 1;
 539     exec-&gt;GS.gep1 = 1;
 540     exec-&gt;GS.gep2 = 1;
 541 
 542     exec-&gt;GS.projVector.x = 0x4000;
 543     exec-&gt;GS.projVector.y = 0x0000;
 544 
 545     exec-&gt;GS.freeVector = exec-&gt;GS.projVector;
 546     exec-&gt;GS.dualVector = exec-&gt;GS.projVector;
 547 
 548     exec-&gt;GS.round_state = 1;
</pre>
<hr />
<pre>
 592       goto Fail;
 593 
 594     memory = driver-&gt;root.root.memory;
 595 
 596     /* allocate object */
 597     if ( FT_NEW( exec ) )
 598       goto Fail;
 599 
 600     /* initialize it; in case of error this deallocates `exec&#39; too */
 601     error = Init_Context( exec, memory );
 602     if ( error )
 603       goto Fail;
 604 
 605     return exec;
 606 
 607   Fail:
 608     return NULL;
 609   }
 610 
 611 
<span class="line-modified"> 612   /*************************************************************************/</span>
<span class="line-modified"> 613   /*                                                                       */</span>
<span class="line-modified"> 614   /* Before an opcode is executed, the interpreter verifies that there are */</span>
<span class="line-modified"> 615   /* enough arguments on the stack, with the help of the `Pop_Push_Count&#39;  */</span>
<span class="line-modified"> 616   /* table.                                                                */</span>
<span class="line-modified"> 617   /*                                                                       */</span>
<span class="line-modified"> 618   /* For each opcode, the first column gives the number of arguments that  */</span>
<span class="line-modified"> 619   /* are popped from the stack; the second one gives the number of those   */</span>
<span class="line-modified"> 620   /* that are pushed in result.                                            */</span>
<span class="line-modified"> 621   /*                                                                       */</span>
<span class="line-modified"> 622   /* Opcodes which have a varying number of parameters in the data stream  */</span>
<span class="line-modified"> 623   /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */</span>
<span class="line-modified"> 624   /* the `opcode_length&#39; table, and the value in `Pop_Push_Count&#39; is set   */</span>
<span class="line-modified"> 625   /* to zero.                                                              */</span>
<span class="line-modified"> 626   /*                                                                       */</span>
<span class="line-modified"> 627   /*************************************************************************/</span>
 628 
 629 
 630 #undef  PACK
 631 #define PACK( x, y )  ( ( x &lt;&lt; 4 ) | y )
 632 
 633 
 634   static
 635   const FT_Byte  Pop_Push_Count[256] =
 636   {
 637     /* opcodes are gathered in groups of 16 */
 638     /* please keep the spaces as they are   */
 639 
<span class="line-modified"> 640     /*  SVTCA  y  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 641     /*  SVTCA  x  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 642     /*  SPvTCA y  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 643     /*  SPvTCA x  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 644     /*  SFvTCA y  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 645     /*  SFvTCA x  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 646     /*  SPvTL //  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 647     /*  SPvTL +   */  PACK( 2, 0 ),</span>
<span class="line-modified"> 648     /*  SFvTL //  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 649     /*  SFvTL +   */  PACK( 2, 0 ),</span>
<span class="line-modified"> 650     /*  SPvFS     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 651     /*  SFvFS     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 652     /*  GPv       */  PACK( 0, 2 ),</span>
<span class="line-modified"> 653     /*  GFv       */  PACK( 0, 2 ),</span>
<span class="line-modified"> 654     /*  SFvTPv    */  PACK( 0, 0 ),</span>

 655     /*  ISECT     */  PACK( 5, 0 ),
 656 

 657     /*  SRP0      */  PACK( 1, 0 ),
 658     /*  SRP1      */  PACK( 1, 0 ),
 659     /*  SRP2      */  PACK( 1, 0 ),
 660     /*  SZP0      */  PACK( 1, 0 ),
 661     /*  SZP1      */  PACK( 1, 0 ),
 662     /*  SZP2      */  PACK( 1, 0 ),
 663     /*  SZPS      */  PACK( 1, 0 ),
 664     /*  SLOOP     */  PACK( 1, 0 ),
 665     /*  RTG       */  PACK( 0, 0 ),
 666     /*  RTHG      */  PACK( 0, 0 ),
 667     /*  SMD       */  PACK( 1, 0 ),
 668     /*  ELSE      */  PACK( 0, 0 ),
 669     /*  JMPR      */  PACK( 1, 0 ),
<span class="line-modified"> 670     /*  SCvTCi    */  PACK( 1, 0 ),</span>
<span class="line-modified"> 671     /*  SSwCi     */  PACK( 1, 0 ),</span>
 672     /*  SSW       */  PACK( 1, 0 ),
 673 

 674     /*  DUP       */  PACK( 1, 2 ),
 675     /*  POP       */  PACK( 1, 0 ),
 676     /*  CLEAR     */  PACK( 0, 0 ),
 677     /*  SWAP      */  PACK( 2, 2 ),
 678     /*  DEPTH     */  PACK( 0, 1 ),
 679     /*  CINDEX    */  PACK( 1, 1 ),
 680     /*  MINDEX    */  PACK( 1, 0 ),
<span class="line-modified"> 681     /*  AlignPTS  */  PACK( 2, 0 ),</span>
 682     /*  INS_$28   */  PACK( 0, 0 ),
 683     /*  UTP       */  PACK( 1, 0 ),
 684     /*  LOOPCALL  */  PACK( 2, 0 ),
 685     /*  CALL      */  PACK( 1, 0 ),
 686     /*  FDEF      */  PACK( 1, 0 ),
 687     /*  ENDF      */  PACK( 0, 0 ),
 688     /*  MDAP[0]   */  PACK( 1, 0 ),
 689     /*  MDAP[1]   */  PACK( 1, 0 ),
 690 

 691     /*  IUP[0]    */  PACK( 0, 0 ),
 692     /*  IUP[1]    */  PACK( 0, 0 ),
 693     /*  SHP[0]    */  PACK( 0, 0 ), /* loops */
 694     /*  SHP[1]    */  PACK( 0, 0 ), /* loops */
 695     /*  SHC[0]    */  PACK( 1, 0 ),
 696     /*  SHC[1]    */  PACK( 1, 0 ),
 697     /*  SHZ[0]    */  PACK( 1, 0 ),
 698     /*  SHZ[1]    */  PACK( 1, 0 ),
 699     /*  SHPIX     */  PACK( 1, 0 ), /* loops */
 700     /*  IP        */  PACK( 0, 0 ), /* loops */
 701     /*  MSIRP[0]  */  PACK( 2, 0 ),
 702     /*  MSIRP[1]  */  PACK( 2, 0 ),
<span class="line-modified"> 703     /*  AlignRP   */  PACK( 0, 0 ), /* loops */</span>
 704     /*  RTDG      */  PACK( 0, 0 ),
 705     /*  MIAP[0]   */  PACK( 2, 0 ),
 706     /*  MIAP[1]   */  PACK( 2, 0 ),
 707 
<span class="line-modified"> 708     /*  NPushB    */  PACK( 0, 0 ),</span>
<span class="line-modified"> 709     /*  NPushW    */  PACK( 0, 0 ),</span>

 710     /*  WS        */  PACK( 2, 0 ),
 711     /*  RS        */  PACK( 1, 1 ),
<span class="line-modified"> 712     /*  WCvtP     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 713     /*  RCvt      */  PACK( 1, 1 ),</span>
 714     /*  GC[0]     */  PACK( 1, 1 ),
 715     /*  GC[1]     */  PACK( 1, 1 ),
 716     /*  SCFS      */  PACK( 2, 0 ),
 717     /*  MD[0]     */  PACK( 2, 1 ),
 718     /*  MD[1]     */  PACK( 2, 1 ),
 719     /*  MPPEM     */  PACK( 0, 1 ),
 720     /*  MPS       */  PACK( 0, 1 ),
<span class="line-modified"> 721     /*  FlipON    */  PACK( 0, 0 ),</span>
<span class="line-modified"> 722     /*  FlipOFF   */  PACK( 0, 0 ),</span>
 723     /*  DEBUG     */  PACK( 1, 0 ),
 724 

 725     /*  LT        */  PACK( 2, 1 ),
 726     /*  LTEQ      */  PACK( 2, 1 ),
 727     /*  GT        */  PACK( 2, 1 ),
 728     /*  GTEQ      */  PACK( 2, 1 ),
 729     /*  EQ        */  PACK( 2, 1 ),
 730     /*  NEQ       */  PACK( 2, 1 ),
 731     /*  ODD       */  PACK( 1, 1 ),
 732     /*  EVEN      */  PACK( 1, 1 ),
 733     /*  IF        */  PACK( 1, 0 ),
 734     /*  EIF       */  PACK( 0, 0 ),
 735     /*  AND       */  PACK( 2, 1 ),
 736     /*  OR        */  PACK( 2, 1 ),
 737     /*  NOT       */  PACK( 1, 1 ),
<span class="line-modified"> 738     /*  DeltaP1   */  PACK( 1, 0 ),</span>
 739     /*  SDB       */  PACK( 1, 0 ),
 740     /*  SDS       */  PACK( 1, 0 ),
 741 

 742     /*  ADD       */  PACK( 2, 1 ),
 743     /*  SUB       */  PACK( 2, 1 ),
 744     /*  DIV       */  PACK( 2, 1 ),
 745     /*  MUL       */  PACK( 2, 1 ),
 746     /*  ABS       */  PACK( 1, 1 ),
 747     /*  NEG       */  PACK( 1, 1 ),
 748     /*  FLOOR     */  PACK( 1, 1 ),
 749     /*  CEILING   */  PACK( 1, 1 ),
 750     /*  ROUND[0]  */  PACK( 1, 1 ),
 751     /*  ROUND[1]  */  PACK( 1, 1 ),
 752     /*  ROUND[2]  */  PACK( 1, 1 ),
 753     /*  ROUND[3]  */  PACK( 1, 1 ),
 754     /*  NROUND[0] */  PACK( 1, 1 ),
 755     /*  NROUND[1] */  PACK( 1, 1 ),
 756     /*  NROUND[2] */  PACK( 1, 1 ),
 757     /*  NROUND[3] */  PACK( 1, 1 ),
 758 
<span class="line-modified"> 759     /*  WCvtF     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 760     /*  DeltaP2   */  PACK( 1, 0 ),</span>
<span class="line-modified"> 761     /*  DeltaP3   */  PACK( 1, 0 ),</span>
<span class="line-modified"> 762     /*  DeltaCn[0] */ PACK( 1, 0 ),</span>
<span class="line-modified"> 763     /*  DeltaCn[1] */ PACK( 1, 0 ),</span>
<span class="line-modified"> 764     /*  DeltaCn[2] */ PACK( 1, 0 ),</span>

 765     /*  SROUND    */  PACK( 1, 0 ),
<span class="line-modified"> 766     /*  S45Round  */  PACK( 1, 0 ),</span>
 767     /*  JROT      */  PACK( 2, 0 ),
 768     /*  JROF      */  PACK( 2, 0 ),
 769     /*  ROFF      */  PACK( 0, 0 ),
 770     /*  INS_$7B   */  PACK( 0, 0 ),
 771     /*  RUTG      */  PACK( 0, 0 ),
 772     /*  RDTG      */  PACK( 0, 0 ),
 773     /*  SANGW     */  PACK( 1, 0 ),
 774     /*  AA        */  PACK( 1, 0 ),
 775 
<span class="line-modified"> 776     /*  FlipPT    */  PACK( 0, 0 ), /* loops */</span>
<span class="line-modified"> 777     /*  FlipRgON  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 778     /*  FlipRgOFF */  PACK( 2, 0 ),</span>

 779     /*  INS_$83   */  PACK( 0, 0 ),
 780     /*  INS_$84   */  PACK( 0, 0 ),
<span class="line-modified"> 781     /*  ScanCTRL  */  PACK( 1, 0 ),</span>
<span class="line-modified"> 782     /*  SDPvTL[0] */  PACK( 2, 0 ),</span>
<span class="line-modified"> 783     /*  SDPvTL[1] */  PACK( 2, 0 ),</span>
<span class="line-modified"> 784     /*  GetINFO   */  PACK( 1, 1 ),</span>
 785     /*  IDEF      */  PACK( 1, 0 ),
 786     /*  ROLL      */  PACK( 3, 3 ),
 787     /*  MAX       */  PACK( 2, 1 ),
 788     /*  MIN       */  PACK( 2, 1 ),
<span class="line-modified"> 789     /*  ScanTYPE  */  PACK( 1, 0 ),</span>
<span class="line-modified"> 790     /*  InstCTRL  */  PACK( 2, 0 ),</span>
 791     /*  INS_$8F   */  PACK( 0, 0 ),
 792 

 793     /*  INS_$90  */   PACK( 0, 0 ),
 794     /*  GETVAR   */   PACK( 0, 0 ), /* will be handled specially */
 795     /*  GETDATA  */   PACK( 0, 1 ),
 796     /*  INS_$93  */   PACK( 0, 0 ),
 797     /*  INS_$94  */   PACK( 0, 0 ),
 798     /*  INS_$95  */   PACK( 0, 0 ),
 799     /*  INS_$96  */   PACK( 0, 0 ),
 800     /*  INS_$97  */   PACK( 0, 0 ),
 801     /*  INS_$98  */   PACK( 0, 0 ),
 802     /*  INS_$99  */   PACK( 0, 0 ),
 803     /*  INS_$9A  */   PACK( 0, 0 ),
 804     /*  INS_$9B  */   PACK( 0, 0 ),
 805     /*  INS_$9C  */   PACK( 0, 0 ),
 806     /*  INS_$9D  */   PACK( 0, 0 ),
 807     /*  INS_$9E  */   PACK( 0, 0 ),
 808     /*  INS_$9F  */   PACK( 0, 0 ),
 809 

 810     /*  INS_$A0  */   PACK( 0, 0 ),
 811     /*  INS_$A1  */   PACK( 0, 0 ),
 812     /*  INS_$A2  */   PACK( 0, 0 ),
 813     /*  INS_$A3  */   PACK( 0, 0 ),
 814     /*  INS_$A4  */   PACK( 0, 0 ),
 815     /*  INS_$A5  */   PACK( 0, 0 ),
 816     /*  INS_$A6  */   PACK( 0, 0 ),
 817     /*  INS_$A7  */   PACK( 0, 0 ),
 818     /*  INS_$A8  */   PACK( 0, 0 ),
 819     /*  INS_$A9  */   PACK( 0, 0 ),
 820     /*  INS_$AA  */   PACK( 0, 0 ),
 821     /*  INS_$AB  */   PACK( 0, 0 ),
 822     /*  INS_$AC  */   PACK( 0, 0 ),
 823     /*  INS_$AD  */   PACK( 0, 0 ),
 824     /*  INS_$AE  */   PACK( 0, 0 ),
 825     /*  INS_$AF  */   PACK( 0, 0 ),
 826 
<span class="line-modified"> 827     /*  PushB[0]  */  PACK( 0, 1 ),</span>
<span class="line-modified"> 828     /*  PushB[1]  */  PACK( 0, 2 ),</span>
<span class="line-modified"> 829     /*  PushB[2]  */  PACK( 0, 3 ),</span>
<span class="line-modified"> 830     /*  PushB[3]  */  PACK( 0, 4 ),</span>
<span class="line-modified"> 831     /*  PushB[4]  */  PACK( 0, 5 ),</span>
<span class="line-modified"> 832     /*  PushB[5]  */  PACK( 0, 6 ),</span>
<span class="line-modified"> 833     /*  PushB[6]  */  PACK( 0, 7 ),</span>
<span class="line-modified"> 834     /*  PushB[7]  */  PACK( 0, 8 ),</span>
<span class="line-modified"> 835     /*  PushW[0]  */  PACK( 0, 1 ),</span>
<span class="line-modified"> 836     /*  PushW[1]  */  PACK( 0, 2 ),</span>
<span class="line-modified"> 837     /*  PushW[2]  */  PACK( 0, 3 ),</span>
<span class="line-modified"> 838     /*  PushW[3]  */  PACK( 0, 4 ),</span>
<span class="line-modified"> 839     /*  PushW[4]  */  PACK( 0, 5 ),</span>
<span class="line-modified"> 840     /*  PushW[5]  */  PACK( 0, 6 ),</span>
<span class="line-modified"> 841     /*  PushW[6]  */  PACK( 0, 7 ),</span>
<span class="line-modified"> 842     /*  PushW[7]  */  PACK( 0, 8 ),</span>
<span class="line-modified"> 843 </span>


 844     /*  MDRP[00]  */  PACK( 1, 0 ),
 845     /*  MDRP[01]  */  PACK( 1, 0 ),
 846     /*  MDRP[02]  */  PACK( 1, 0 ),
 847     /*  MDRP[03]  */  PACK( 1, 0 ),
 848     /*  MDRP[04]  */  PACK( 1, 0 ),
 849     /*  MDRP[05]  */  PACK( 1, 0 ),
 850     /*  MDRP[06]  */  PACK( 1, 0 ),
 851     /*  MDRP[07]  */  PACK( 1, 0 ),
 852     /*  MDRP[08]  */  PACK( 1, 0 ),
 853     /*  MDRP[09]  */  PACK( 1, 0 ),
 854     /*  MDRP[10]  */  PACK( 1, 0 ),
 855     /*  MDRP[11]  */  PACK( 1, 0 ),
 856     /*  MDRP[12]  */  PACK( 1, 0 ),
 857     /*  MDRP[13]  */  PACK( 1, 0 ),
 858     /*  MDRP[14]  */  PACK( 1, 0 ),
 859     /*  MDRP[15]  */  PACK( 1, 0 ),
 860 

 861     /*  MDRP[16]  */  PACK( 1, 0 ),
 862     /*  MDRP[17]  */  PACK( 1, 0 ),
 863     /*  MDRP[18]  */  PACK( 1, 0 ),
 864     /*  MDRP[19]  */  PACK( 1, 0 ),
 865     /*  MDRP[20]  */  PACK( 1, 0 ),
 866     /*  MDRP[21]  */  PACK( 1, 0 ),
 867     /*  MDRP[22]  */  PACK( 1, 0 ),
 868     /*  MDRP[23]  */  PACK( 1, 0 ),
 869     /*  MDRP[24]  */  PACK( 1, 0 ),
 870     /*  MDRP[25]  */  PACK( 1, 0 ),
 871     /*  MDRP[26]  */  PACK( 1, 0 ),
 872     /*  MDRP[27]  */  PACK( 1, 0 ),
 873     /*  MDRP[28]  */  PACK( 1, 0 ),
 874     /*  MDRP[29]  */  PACK( 1, 0 ),
 875     /*  MDRP[30]  */  PACK( 1, 0 ),
 876     /*  MDRP[31]  */  PACK( 1, 0 ),
 877 

 878     /*  MIRP[00]  */  PACK( 2, 0 ),
 879     /*  MIRP[01]  */  PACK( 2, 0 ),
 880     /*  MIRP[02]  */  PACK( 2, 0 ),
 881     /*  MIRP[03]  */  PACK( 2, 0 ),
 882     /*  MIRP[04]  */  PACK( 2, 0 ),
 883     /*  MIRP[05]  */  PACK( 2, 0 ),
 884     /*  MIRP[06]  */  PACK( 2, 0 ),
 885     /*  MIRP[07]  */  PACK( 2, 0 ),
 886     /*  MIRP[08]  */  PACK( 2, 0 ),
 887     /*  MIRP[09]  */  PACK( 2, 0 ),
 888     /*  MIRP[10]  */  PACK( 2, 0 ),
 889     /*  MIRP[11]  */  PACK( 2, 0 ),
 890     /*  MIRP[12]  */  PACK( 2, 0 ),
 891     /*  MIRP[13]  */  PACK( 2, 0 ),
 892     /*  MIRP[14]  */  PACK( 2, 0 ),
 893     /*  MIRP[15]  */  PACK( 2, 0 ),
 894 

 895     /*  MIRP[16]  */  PACK( 2, 0 ),
 896     /*  MIRP[17]  */  PACK( 2, 0 ),
 897     /*  MIRP[18]  */  PACK( 2, 0 ),
 898     /*  MIRP[19]  */  PACK( 2, 0 ),
 899     /*  MIRP[20]  */  PACK( 2, 0 ),
 900     /*  MIRP[21]  */  PACK( 2, 0 ),
 901     /*  MIRP[22]  */  PACK( 2, 0 ),
 902     /*  MIRP[23]  */  PACK( 2, 0 ),
 903     /*  MIRP[24]  */  PACK( 2, 0 ),
 904     /*  MIRP[25]  */  PACK( 2, 0 ),
 905     /*  MIRP[26]  */  PACK( 2, 0 ),
 906     /*  MIRP[27]  */  PACK( 2, 0 ),
 907     /*  MIRP[28]  */  PACK( 2, 0 ),
 908     /*  MIRP[29]  */  PACK( 2, 0 ),
 909     /*  MIRP[30]  */  PACK( 2, 0 ),
 910     /*  MIRP[31]  */  PACK( 2, 0 )
 911   };
 912 
 913 
 914 #ifdef FT_DEBUG_LEVEL_TRACE
 915 
 916   /* the first hex digit gives the length of the opcode name; the space */
 917   /* after the digit is here just to increase readability of the source */
 918   /* code                                                               */
 919 
 920   static
 921   const char*  const opcode_name[256] =
 922   {
<span class="line-modified"> 923     &quot;7 SVTCA y&quot;,</span>
<span class="line-modified"> 924     &quot;7 SVTCA x&quot;,</span>
<span class="line-modified"> 925     &quot;8 SPvTCA y&quot;,</span>
<span class="line-modified"> 926     &quot;8 SPvTCA x&quot;,</span>
<span class="line-modified"> 927     &quot;8 SFvTCA y&quot;,</span>
<span class="line-modified"> 928     &quot;8 SFvTCA x&quot;,</span>
<span class="line-modified"> 929     &quot;8 SPvTL ||&quot;,</span>
<span class="line-modified"> 930     &quot;7 SPvTL +&quot;,</span>
<span class="line-modified"> 931     &quot;8 SFvTL ||&quot;,</span>
<span class="line-modified"> 932     &quot;7 SFvTL +&quot;,</span>
<span class="line-modified"> 933     &quot;5 SPvFS&quot;,</span>
<span class="line-modified"> 934     &quot;5 SFvFS&quot;,</span>
<span class="line-modified"> 935     &quot;3 GPv&quot;,</span>
<span class="line-modified"> 936     &quot;3 GFv&quot;,</span>
<span class="line-modified"> 937     &quot;6 SFvTPv&quot;,</span>

 938     &quot;5 ISECT&quot;,
 939 

 940     &quot;4 SRP0&quot;,
 941     &quot;4 SRP1&quot;,
 942     &quot;4 SRP2&quot;,
 943     &quot;4 SZP0&quot;,
 944     &quot;4 SZP1&quot;,
 945     &quot;4 SZP2&quot;,
 946     &quot;4 SZPS&quot;,
 947     &quot;5 SLOOP&quot;,
 948     &quot;3 RTG&quot;,
 949     &quot;4 RTHG&quot;,
 950     &quot;3 SMD&quot;,
 951     &quot;4 ELSE&quot;,
 952     &quot;4 JMPR&quot;,
<span class="line-modified"> 953     &quot;6 SCvTCi&quot;,</span>
<span class="line-modified"> 954     &quot;5 SSwCi&quot;,</span>
 955     &quot;3 SSW&quot;,
 956 

 957     &quot;3 DUP&quot;,
 958     &quot;3 POP&quot;,
 959     &quot;5 CLEAR&quot;,
 960     &quot;4 SWAP&quot;,
 961     &quot;5 DEPTH&quot;,
 962     &quot;6 CINDEX&quot;,
 963     &quot;6 MINDEX&quot;,
<span class="line-modified"> 964     &quot;8 AlignPTS&quot;,</span>
 965     &quot;7 INS_$28&quot;,
 966     &quot;3 UTP&quot;,
 967     &quot;8 LOOPCALL&quot;,
 968     &quot;4 CALL&quot;,
 969     &quot;4 FDEF&quot;,
 970     &quot;4 ENDF&quot;,
<span class="line-modified"> 971     &quot;7 MDAP[0]&quot;,</span>
<span class="line-modified"> 972     &quot;7 MDAP[1]&quot;,</span>
<span class="line-modified"> 973 </span>
<span class="line-modified"> 974     &quot;6 IUP[0]&quot;,</span>
<span class="line-modified"> 975     &quot;6 IUP[1]&quot;,</span>
<span class="line-modified"> 976     &quot;6 SHP[0]&quot;,</span>
<span class="line-modified"> 977     &quot;6 SHP[1]&quot;,</span>
<span class="line-modified"> 978     &quot;6 SHC[0]&quot;,</span>
<span class="line-modified"> 979     &quot;6 SHC[1]&quot;,</span>
<span class="line-modified"> 980     &quot;6 SHZ[0]&quot;,</span>
<span class="line-modified"> 981     &quot;6 SHZ[1]&quot;,</span>

 982     &quot;5 SHPIX&quot;,
 983     &quot;2 IP&quot;,
<span class="line-modified"> 984     &quot;8 MSIRP[0]&quot;,</span>
<span class="line-modified"> 985     &quot;8 MSIRP[1]&quot;,</span>
<span class="line-modified"> 986     &quot;7 AlignRP&quot;,</span>
 987     &quot;4 RTDG&quot;,
<span class="line-modified"> 988     &quot;7 MIAP[0]&quot;,</span>
<span class="line-modified"> 989     &quot;7 MIAP[1]&quot;,</span>
 990 
<span class="line-modified"> 991     &quot;6 NPushB&quot;,</span>
<span class="line-modified"> 992     &quot;6 NPushW&quot;,</span>

 993     &quot;2 WS&quot;,
 994     &quot;2 RS&quot;,
<span class="line-modified"> 995     &quot;5 WCvtP&quot;,</span>
<span class="line-modified"> 996     &quot;4 RCvt&quot;,</span>
<span class="line-modified"> 997     &quot;5 GC[0]&quot;,</span>
<span class="line-modified"> 998     &quot;5 GC[1]&quot;,</span>
 999     &quot;4 SCFS&quot;,
<span class="line-modified">1000     &quot;5 MD[0]&quot;,</span>
<span class="line-modified">1001     &quot;5 MD[1]&quot;,</span>
1002     &quot;5 MPPEM&quot;,
1003     &quot;3 MPS&quot;,
<span class="line-modified">1004     &quot;6 FlipON&quot;,</span>
<span class="line-modified">1005     &quot;7 FlipOFF&quot;,</span>
1006     &quot;5 DEBUG&quot;,
1007 

1008     &quot;2 LT&quot;,
1009     &quot;4 LTEQ&quot;,
1010     &quot;2 GT&quot;,
1011     &quot;4 GTEQ&quot;,
1012     &quot;2 EQ&quot;,
1013     &quot;3 NEQ&quot;,
1014     &quot;3 ODD&quot;,
1015     &quot;4 EVEN&quot;,
1016     &quot;2 IF&quot;,
1017     &quot;3 EIF&quot;,
1018     &quot;3 AND&quot;,
1019     &quot;2 OR&quot;,
1020     &quot;3 NOT&quot;,
<span class="line-modified">1021     &quot;7 DeltaP1&quot;,</span>
1022     &quot;3 SDB&quot;,
1023     &quot;3 SDS&quot;,
1024 

1025     &quot;3 ADD&quot;,
1026     &quot;3 SUB&quot;,
1027     &quot;3 DIV&quot;,
1028     &quot;3 MUL&quot;,
1029     &quot;3 ABS&quot;,
1030     &quot;3 NEG&quot;,
1031     &quot;5 FLOOR&quot;,
1032     &quot;7 CEILING&quot;,
<span class="line-modified">1033     &quot;8 ROUND[0]&quot;,</span>
<span class="line-modified">1034     &quot;8 ROUND[1]&quot;,</span>
<span class="line-modified">1035     &quot;8 ROUND[2]&quot;,</span>
<span class="line-modified">1036     &quot;8 ROUND[3]&quot;,</span>
<span class="line-modified">1037     &quot;9 NROUND[0]&quot;,</span>
<span class="line-modified">1038     &quot;9 NROUND[1]&quot;,</span>
<span class="line-modified">1039     &quot;9 NROUND[2]&quot;,</span>
<span class="line-modified">1040     &quot;9 NROUND[3]&quot;,</span>
<span class="line-modified">1041 </span>
<span class="line-modified">1042     &quot;5 WCvtF&quot;,</span>
<span class="line-modified">1043     &quot;7 DeltaP2&quot;,</span>
<span class="line-modified">1044     &quot;7 DeltaP3&quot;,</span>
<span class="line-modified">1045     &quot;A DeltaCn[0]&quot;,</span>
<span class="line-modified">1046     &quot;A DeltaCn[1]&quot;,</span>
<span class="line-modified">1047     &quot;A DeltaCn[2]&quot;,</span>

1048     &quot;6 SROUND&quot;,
<span class="line-modified">1049     &quot;8 S45Round&quot;,</span>
1050     &quot;4 JROT&quot;,
1051     &quot;4 JROF&quot;,
1052     &quot;4 ROFF&quot;,
1053     &quot;7 INS_$7B&quot;,
1054     &quot;4 RUTG&quot;,
1055     &quot;4 RDTG&quot;,
1056     &quot;5 SANGW&quot;,
1057     &quot;2 AA&quot;,
1058 
<span class="line-modified">1059     &quot;6 FlipPT&quot;,</span>
<span class="line-modified">1060     &quot;8 FlipRgON&quot;,</span>
<span class="line-modified">1061     &quot;9 FlipRgOFF&quot;,</span>

1062     &quot;7 INS_$83&quot;,
1063     &quot;7 INS_$84&quot;,
<span class="line-modified">1064     &quot;8 ScanCTRL&quot;,</span>
<span class="line-modified">1065     &quot;9 SDPvTL[0]&quot;,</span>
<span class="line-modified">1066     &quot;9 SDPvTL[1]&quot;,</span>
<span class="line-modified">1067     &quot;7 GetINFO&quot;,</span>
1068     &quot;4 IDEF&quot;,
1069     &quot;4 ROLL&quot;,
1070     &quot;3 MAX&quot;,
1071     &quot;3 MIN&quot;,
<span class="line-modified">1072     &quot;8 ScanTYPE&quot;,</span>
<span class="line-modified">1073     &quot;8 InstCTRL&quot;,</span>
1074     &quot;7 INS_$8F&quot;,
1075 

1076     &quot;7 INS_$90&quot;,
1077 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
<span class="line-modified">1078     &quot;6 GETVAR&quot;,</span>
1079     &quot;7 GETDATA&quot;,
1080 #else
1081     &quot;7 INS_$91&quot;,
1082     &quot;7 INS_$92&quot;,
1083 #endif
1084     &quot;7 INS_$93&quot;,
1085     &quot;7 INS_$94&quot;,
1086     &quot;7 INS_$95&quot;,
1087     &quot;7 INS_$96&quot;,
1088     &quot;7 INS_$97&quot;,
1089     &quot;7 INS_$98&quot;,
1090     &quot;7 INS_$99&quot;,
1091     &quot;7 INS_$9A&quot;,
1092     &quot;7 INS_$9B&quot;,
1093     &quot;7 INS_$9C&quot;,
1094     &quot;7 INS_$9D&quot;,
1095     &quot;7 INS_$9E&quot;,
1096     &quot;7 INS_$9F&quot;,
1097 

1098     &quot;7 INS_$A0&quot;,
1099     &quot;7 INS_$A1&quot;,
1100     &quot;7 INS_$A2&quot;,
1101     &quot;7 INS_$A3&quot;,
1102     &quot;7 INS_$A4&quot;,
1103     &quot;7 INS_$A5&quot;,
1104     &quot;7 INS_$A6&quot;,
1105     &quot;7 INS_$A7&quot;,
1106     &quot;7 INS_$A8&quot;,
1107     &quot;7 INS_$A9&quot;,
1108     &quot;7 INS_$AA&quot;,
1109     &quot;7 INS_$AB&quot;,
1110     &quot;7 INS_$AC&quot;,
1111     &quot;7 INS_$AD&quot;,
1112     &quot;7 INS_$AE&quot;,
1113     &quot;7 INS_$AF&quot;,
1114 
<span class="line-modified">1115     &quot;8 PushB[0]&quot;,</span>
<span class="line-modified">1116     &quot;8 PushB[1]&quot;,</span>
<span class="line-modified">1117     &quot;8 PushB[2]&quot;,</span>
<span class="line-modified">1118     &quot;8 PushB[3]&quot;,</span>
<span class="line-modified">1119     &quot;8 PushB[4]&quot;,</span>
<span class="line-modified">1120     &quot;8 PushB[5]&quot;,</span>
<span class="line-modified">1121     &quot;8 PushB[6]&quot;,</span>
<span class="line-modified">1122     &quot;8 PushB[7]&quot;,</span>
<span class="line-modified">1123     &quot;8 PushW[0]&quot;,</span>
<span class="line-modified">1124     &quot;8 PushW[1]&quot;,</span>
<span class="line-modified">1125     &quot;8 PushW[2]&quot;,</span>
<span class="line-modified">1126     &quot;8 PushW[3]&quot;,</span>
<span class="line-modified">1127     &quot;8 PushW[4]&quot;,</span>
<span class="line-modified">1128     &quot;8 PushW[5]&quot;,</span>
<span class="line-modified">1129     &quot;8 PushW[6]&quot;,</span>
<span class="line-modified">1130     &quot;8 PushW[7]&quot;,</span>
<span class="line-modified">1131 </span>
<span class="line-modified">1132     &quot;8 MDRP[00]&quot;,</span>
<span class="line-modified">1133     &quot;8 MDRP[01]&quot;,</span>
<span class="line-modified">1134     &quot;8 MDRP[02]&quot;,</span>
<span class="line-modified">1135     &quot;8 MDRP[03]&quot;,</span>
<span class="line-modified">1136     &quot;8 MDRP[04]&quot;,</span>
<span class="line-modified">1137     &quot;8 MDRP[05]&quot;,</span>
<span class="line-modified">1138     &quot;8 MDRP[06]&quot;,</span>
<span class="line-modified">1139     &quot;8 MDRP[07]&quot;,</span>
<span class="line-modified">1140     &quot;8 MDRP[08]&quot;,</span>
<span class="line-modified">1141     &quot;8 MDRP[09]&quot;,</span>
<span class="line-modified">1142     &quot;8 MDRP[10]&quot;,</span>
<span class="line-modified">1143     &quot;8 MDRP[11]&quot;,</span>
<span class="line-modified">1144     &quot;8 MDRP[12]&quot;,</span>
<span class="line-modified">1145     &quot;8 MDRP[13]&quot;,</span>
<span class="line-modified">1146     &quot;8 MDRP[14]&quot;,</span>
<span class="line-modified">1147     &quot;8 MDRP[15]&quot;,</span>
<span class="line-modified">1148 </span>
<span class="line-modified">1149     &quot;8 MDRP[16]&quot;,</span>
<span class="line-modified">1150     &quot;8 MDRP[17]&quot;,</span>
<span class="line-modified">1151     &quot;8 MDRP[18]&quot;,</span>
<span class="line-modified">1152     &quot;8 MDRP[19]&quot;,</span>
<span class="line-modified">1153     &quot;8 MDRP[20]&quot;,</span>
<span class="line-modified">1154     &quot;8 MDRP[21]&quot;,</span>
<span class="line-modified">1155     &quot;8 MDRP[22]&quot;,</span>
<span class="line-modified">1156     &quot;8 MDRP[23]&quot;,</span>
<span class="line-modified">1157     &quot;8 MDRP[24]&quot;,</span>
<span class="line-modified">1158     &quot;8 MDRP[25]&quot;,</span>
<span class="line-modified">1159     &quot;8 MDRP[26]&quot;,</span>
<span class="line-modified">1160     &quot;8 MDRP[27]&quot;,</span>
<span class="line-modified">1161     &quot;8 MDRP[28]&quot;,</span>
<span class="line-modified">1162     &quot;8 MDRP[29]&quot;,</span>
<span class="line-modified">1163     &quot;8 MDRP[30]&quot;,</span>
<span class="line-modified">1164     &quot;8 MDRP[31]&quot;,</span>
<span class="line-modified">1165 </span>
<span class="line-modified">1166     &quot;8 MIRP[00]&quot;,</span>
<span class="line-modified">1167     &quot;8 MIRP[01]&quot;,</span>
<span class="line-modified">1168     &quot;8 MIRP[02]&quot;,</span>
<span class="line-modified">1169     &quot;8 MIRP[03]&quot;,</span>
<span class="line-modified">1170     &quot;8 MIRP[04]&quot;,</span>
<span class="line-modified">1171     &quot;8 MIRP[05]&quot;,</span>
<span class="line-modified">1172     &quot;8 MIRP[06]&quot;,</span>
<span class="line-modified">1173     &quot;8 MIRP[07]&quot;,</span>
<span class="line-modified">1174     &quot;8 MIRP[08]&quot;,</span>
<span class="line-modified">1175     &quot;8 MIRP[09]&quot;,</span>
<span class="line-modified">1176     &quot;8 MIRP[10]&quot;,</span>
<span class="line-modified">1177     &quot;8 MIRP[11]&quot;,</span>
<span class="line-modified">1178     &quot;8 MIRP[12]&quot;,</span>
<span class="line-modified">1179     &quot;8 MIRP[13]&quot;,</span>
<span class="line-modified">1180     &quot;8 MIRP[14]&quot;,</span>
<span class="line-modified">1181     &quot;8 MIRP[15]&quot;,</span>
<span class="line-modified">1182 </span>
<span class="line-modified">1183     &quot;8 MIRP[16]&quot;,</span>
<span class="line-modified">1184     &quot;8 MIRP[17]&quot;,</span>
<span class="line-modified">1185     &quot;8 MIRP[18]&quot;,</span>
<span class="line-modified">1186     &quot;8 MIRP[19]&quot;,</span>
<span class="line-modified">1187     &quot;8 MIRP[20]&quot;,</span>
<span class="line-modified">1188     &quot;8 MIRP[21]&quot;,</span>
<span class="line-modified">1189     &quot;8 MIRP[22]&quot;,</span>
<span class="line-modified">1190     &quot;8 MIRP[23]&quot;,</span>
<span class="line-modified">1191     &quot;8 MIRP[24]&quot;,</span>
<span class="line-modified">1192     &quot;8 MIRP[25]&quot;,</span>
<span class="line-modified">1193     &quot;8 MIRP[26]&quot;,</span>
<span class="line-modified">1194     &quot;8 MIRP[27]&quot;,</span>
<span class="line-modified">1195     &quot;8 MIRP[28]&quot;,</span>
<span class="line-modified">1196     &quot;8 MIRP[29]&quot;,</span>
<span class="line-modified">1197     &quot;8 MIRP[30]&quot;,</span>
<span class="line-modified">1198     &quot;8 MIRP[31]&quot;</span>





1199   };
1200 
1201 #endif /* FT_DEBUG_LEVEL_TRACE */
1202 
1203 
1204   static
1205   const FT_Char  opcode_length[256] =
1206   {
1207     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1208     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1209     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1210     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1211 
1212    -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1213     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1214     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1215     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1216 
1217     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1218     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
</pre>
<hr />
<pre>
1431 
1432     /* add them */
1433     lo = lo1 + lo2;
1434     hi = hi1 + hi2 + ( lo &lt; lo1 );
1435 
1436     /* divide the result by 2^14 with rounding */
1437     s   = hi &gt;&gt; 31;
1438     l   = lo + (FT_UInt32)s;
1439     hi += s + ( l &lt; lo );
1440     lo  = l;
1441 
1442     l   = lo + 0x2000U;
1443     hi += ( l &lt; lo );
1444 
1445     return (FT_Int32)( ( (FT_UInt32)hi &lt;&lt; 18 ) | ( l &gt;&gt; 14 ) );
1446   }
1447 
1448 #endif /* TT_DotFix14 */
1449 
1450 
<span class="line-modified">1451   /*************************************************************************/</span>
<span class="line-modified">1452   /*                                                                       */</span>
<span class="line-modified">1453   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1454   /*    Current_Ratio                                                      */</span>
<span class="line-modified">1455   /*                                                                       */</span>
<span class="line-modified">1456   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1457   /*    Returns the current aspect ratio scaling factor depending on the   */</span>
<span class="line-modified">1458   /*    projection vector&#39;s state and device resolutions.                  */</span>
<span class="line-modified">1459   /*                                                                       */</span>
<span class="line-modified">1460   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1461   /*    The aspect ratio in 16.16 format, always &lt;= 1.0 .                  */</span>
<span class="line-modified">1462   /*                                                                       */</span>
1463   static FT_Long
1464   Current_Ratio( TT_ExecContext  exc )
1465   {
1466     if ( !exc-&gt;tt_metrics.ratio )
1467     {
1468       if ( exc-&gt;GS.projVector.y == 0 )
1469         exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.x_ratio;
1470 
1471       else if ( exc-&gt;GS.projVector.x == 0 )
1472         exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.y_ratio;
1473 
1474       else
1475       {
1476         FT_F26Dot6  x, y;
1477 
1478 
1479         x = TT_MulFix14( exc-&gt;tt_metrics.x_ratio,
1480                          exc-&gt;GS.projVector.x );
1481         y = TT_MulFix14( exc-&gt;tt_metrics.y_ratio,
1482                          exc-&gt;GS.projVector.y );
</pre>
<hr />
<pre>
1484       }
1485     }
1486     return exc-&gt;tt_metrics.ratio;
1487   }
1488 
1489 
1490   FT_CALLBACK_DEF( FT_Long )
1491   Current_Ppem( TT_ExecContext  exc )
1492   {
1493     return exc-&gt;tt_metrics.ppem;
1494   }
1495 
1496 
1497   FT_CALLBACK_DEF( FT_Long )
1498   Current_Ppem_Stretched( TT_ExecContext  exc )
1499   {
1500     return FT_MulFix( exc-&gt;tt_metrics.ppem, Current_Ratio( exc ) );
1501   }
1502 
1503 
<span class="line-modified">1504   /*************************************************************************/</span>
<span class="line-modified">1505   /*                                                                       */</span>
<span class="line-modified">1506   /* Functions related to the control value table (CVT).                   */</span>
<span class="line-modified">1507   /*                                                                       */</span>
<span class="line-modified">1508   /*************************************************************************/</span>
1509 
1510 
1511   FT_CALLBACK_DEF( FT_F26Dot6 )
1512   Read_CVT( TT_ExecContext  exc,
1513             FT_ULong        idx )
1514   {
1515     return exc-&gt;cvt[idx];
1516   }
1517 
1518 
1519   FT_CALLBACK_DEF( FT_F26Dot6 )
1520   Read_CVT_Stretched( TT_ExecContext  exc,
1521                       FT_ULong        idx )
1522   {
1523     return FT_MulFix( exc-&gt;cvt[idx], Current_Ratio( exc ) );
1524   }
1525 
1526 
1527   FT_CALLBACK_DEF( void )
1528   Write_CVT( TT_ExecContext  exc,
</pre>
<hr />
<pre>
1530              FT_F26Dot6      value )
1531   {
1532     exc-&gt;cvt[idx] = value;
1533   }
1534 
1535 
1536   FT_CALLBACK_DEF( void )
1537   Write_CVT_Stretched( TT_ExecContext  exc,
1538                        FT_ULong        idx,
1539                        FT_F26Dot6      value )
1540   {
1541     exc-&gt;cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
1542   }
1543 
1544 
1545   FT_CALLBACK_DEF( void )
1546   Move_CVT( TT_ExecContext  exc,
1547             FT_ULong        idx,
1548             FT_F26Dot6      value )
1549   {
<span class="line-modified">1550     exc-&gt;cvt[idx] += value;</span>
1551   }
1552 
1553 
1554   FT_CALLBACK_DEF( void )
1555   Move_CVT_Stretched( TT_ExecContext  exc,
1556                       FT_ULong        idx,
1557                       FT_F26Dot6      value )
1558   {
<span class="line-modified">1559     exc-&gt;cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );</span>
<span class="line-modified">1560   }</span>
<span class="line-modified">1561 </span>
<span class="line-modified">1562 </span>
<span class="line-modified">1563   /*************************************************************************/</span>
<span class="line-modified">1564   /*                                                                       */</span>
<span class="line-modified">1565   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1566   /*    GetShortIns                                                        */</span>
<span class="line-modified">1567   /*                                                                       */</span>
<span class="line-modified">1568   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1569   /*    Returns a short integer taken from the instruction stream at       */</span>
<span class="line-modified">1570   /*    address IP.                                                        */</span>
<span class="line-modified">1571   /*                                                                       */</span>
<span class="line-modified">1572   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1573   /*    Short read at code[IP].                                            */</span>
<span class="line-modified">1574   /*                                                                       */</span>
<span class="line-modified">1575   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">1576   /*    This one could become a macro.                                     */</span>
<span class="line-modified">1577   /*                                                                       */</span>

1578   static FT_Short
1579   GetShortIns( TT_ExecContext  exc )
1580   {
1581     /* Reading a byte stream so there is no endianness (DaveP) */
1582     exc-&gt;IP += 2;
1583     return (FT_Short)( ( exc-&gt;code[exc-&gt;IP - 2] &lt;&lt; 8 ) +
1584                          exc-&gt;code[exc-&gt;IP - 1]      );
1585   }
1586 
1587 
<span class="line-modified">1588   /*************************************************************************/</span>
<span class="line-modified">1589   /*                                                                       */</span>
<span class="line-modified">1590   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1591   /*    Ins_Goto_CodeRange                                                 */</span>
<span class="line-modified">1592   /*                                                                       */</span>
<span class="line-modified">1593   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1594   /*    Goes to a certain code range in the instruction stream.            */</span>
<span class="line-modified">1595   /*                                                                       */</span>
<span class="line-modified">1596   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1597   /*    aRange :: The index of the code range.                             */</span>
<span class="line-modified">1598   /*                                                                       */</span>
<span class="line-modified">1599   /*    aIP    :: The new IP address in the code range.                    */</span>
<span class="line-modified">1600   /*                                                                       */</span>
<span class="line-modified">1601   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1602   /*    SUCCESS or FAILURE.                                                */</span>
<span class="line-modified">1603   /*                                                                       */</span>


1604   static FT_Bool
1605   Ins_Goto_CodeRange( TT_ExecContext  exc,
1606                       FT_Int          aRange,
1607                       FT_Long         aIP )
1608   {
1609     TT_CodeRange*  range;
1610 
1611 
1612     if ( aRange &lt; 1 || aRange &gt; 3 )
1613     {
1614       exc-&gt;error = FT_THROW( Bad_Argument );
1615       return FAILURE;
1616     }
1617 
1618     range = &amp;exc-&gt;codeRangeTable[aRange - 1];
1619 
1620     if ( !range-&gt;base )     /* invalid coderange */
1621     {
1622       exc-&gt;error = FT_THROW( Invalid_CodeRange );
1623       return FAILURE;
</pre>
<hr />
<pre>
1625 
1626     /* NOTE: Because the last instruction of a program may be a CALL */
1627     /*       which will return to the first byte *after* the code    */
1628     /*       range, we test for aIP &lt;= Size, instead of aIP &lt; Size.  */
1629 
1630     if ( aIP &gt; range-&gt;size )
1631     {
1632       exc-&gt;error = FT_THROW( Code_Overflow );
1633       return FAILURE;
1634     }
1635 
1636     exc-&gt;code     = range-&gt;base;
1637     exc-&gt;codeSize = range-&gt;size;
1638     exc-&gt;IP       = aIP;
1639     exc-&gt;curRange = aRange;
1640 
1641     return SUCCESS;
1642   }
1643 
1644 
<span class="line-modified">1645   /*************************************************************************/</span>
<span class="line-modified">1646   /*                                                                       */</span>
<span class="line-modified">1647   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1648   /*    Direct_Move                                                        */</span>
<span class="line-modified">1649   /*                                                                       */</span>
<span class="line-modified">1650   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1651   /*    Moves a point by a given distance along the freedom vector.  The   */</span>
<span class="line-modified">1652   /*    point will be `touched&#39;.                                           */</span>
<span class="line-modified">1653   /*                                                                       */</span>
<span class="line-modified">1654   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1655   /*    point    :: The index of the point to move.                        */</span>
<span class="line-modified">1656   /*                                                                       */</span>
<span class="line-modified">1657   /*    distance :: The distance to apply.                                 */</span>
<span class="line-modified">1658   /*                                                                       */</span>
<span class="line-modified">1659   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1660   /*    zone     :: The affected glyph zone.                               */</span>
<span class="line-modified">1661   /*                                                                       */</span>
<span class="line-modified">1662   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">1663   /*    See `ttinterp.h&#39; for details on backward compatibility mode.       */</span>
<span class="line-modified">1664   /*    `Touches&#39; the point.                                               */</span>
<span class="line-modified">1665   /*                                                                       */</span>





























1666   static void
1667   Direct_Move( TT_ExecContext  exc,
1668                TT_GlyphZone    zone,
1669                FT_UShort       point,
1670                FT_F26Dot6      distance )
1671   {
1672     FT_F26Dot6  v;
1673 
1674 
1675     v = exc-&gt;GS.freeVector.x;
1676 
1677     if ( v != 0 )
1678     {
1679 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1680       if ( SUBPIXEL_HINTING_INFINALITY                            &amp;&amp;
1681            ( !exc-&gt;ignore_x_mode                                ||
1682              ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALLOW_X_DMOVE ) ) )
1683         zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x,
1684                                        FT_MulDiv( distance,
1685                                                   v,
</pre>
<hr />
<pre>
1711     v = exc-&gt;GS.freeVector.y;
1712 
1713     if ( v != 0 )
1714     {
1715 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1716       if ( !( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
1717               exc-&gt;backward_compatibility &amp;&amp;
1718               exc-&gt;iupx_called            &amp;&amp;
1719               exc-&gt;iupy_called            ) )
1720 #endif
1721         zone-&gt;cur[point].y = ADD_LONG( zone-&gt;cur[point].y,
1722                                        FT_MulDiv( distance,
1723                                                   v,
1724                                                   exc-&gt;F_dot_P ) );
1725 
1726       zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_Y;
1727     }
1728   }
1729 
1730 
<span class="line-modified">1731   /*************************************************************************/</span>
<span class="line-modified">1732   /*                                                                       */</span>
<span class="line-modified">1733   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1734   /*    Direct_Move_Orig                                                   */</span>
<span class="line-modified">1735   /*                                                                       */</span>
<span class="line-modified">1736   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1737   /*    Moves the *original* position of a point by a given distance along */</span>
<span class="line-modified">1738   /*    the freedom vector.  Obviously, the point will not be `touched&#39;.   */</span>
<span class="line-modified">1739   /*                                                                       */</span>
<span class="line-modified">1740   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1741   /*    point    :: The index of the point to move.                        */</span>
<span class="line-modified">1742   /*                                                                       */</span>
<span class="line-modified">1743   /*    distance :: The distance to apply.                                 */</span>
<span class="line-modified">1744   /*                                                                       */</span>
<span class="line-modified">1745   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">1746   /*    zone     :: The affected glyph zone.                               */</span>
<span class="line-modified">1747   /*                                                                       */</span>



1748   static void
1749   Direct_Move_Orig( TT_ExecContext  exc,
1750                     TT_GlyphZone    zone,
1751                     FT_UShort       point,
1752                     FT_F26Dot6      distance )
1753   {
1754     FT_F26Dot6  v;
1755 
1756 
1757     v = exc-&gt;GS.freeVector.x;
1758 
1759     if ( v != 0 )
1760       zone-&gt;org[point].x = ADD_LONG( zone-&gt;org[point].x,
1761                                      FT_MulDiv( distance,
1762                                                 v,
1763                                                 exc-&gt;F_dot_P ) );
1764 
1765     v = exc-&gt;GS.freeVector.y;
1766 
1767     if ( v != 0 )
1768       zone-&gt;org[point].y = ADD_LONG( zone-&gt;org[point].y,
1769                                      FT_MulDiv( distance,
1770                                                 v,
1771                                                 exc-&gt;F_dot_P ) );
1772   }
1773 
1774 
<span class="line-modified">1775   /*************************************************************************/</span>
<span class="line-modified">1776   /*                                                                       */</span>
<span class="line-modified">1777   /* Special versions of Direct_Move()                                     */</span>
<span class="line-modified">1778   /*                                                                       */</span>
<span class="line-modified">1779   /*   The following versions are used whenever both vectors are both      */</span>
<span class="line-modified">1780   /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */</span>
<span class="line-modified">1781   /*   See `ttinterp.h&#39; for details on backward compatibility mode.        */</span>
<span class="line-modified">1782   /*                                                                       */</span>
<span class="line-modified">1783   /*************************************************************************/</span>
1784 
1785 
1786   static void
1787   Direct_Move_X( TT_ExecContext  exc,
1788                  TT_GlyphZone    zone,
1789                  FT_UShort       point,
1790                  FT_F26Dot6      distance )
1791   {
1792 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1793     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp; !exc-&gt;ignore_x_mode )
1794       zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x, distance );
1795     else
1796 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
1797 
1798 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1799     if ( SUBPIXEL_HINTING_MINIMAL &amp;&amp; !exc-&gt;backward_compatibility )
1800       zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x, distance );
1801     else
1802 #endif
1803 
</pre>
<hr />
<pre>
1810 
1811   static void
1812   Direct_Move_Y( TT_ExecContext  exc,
1813                  TT_GlyphZone    zone,
1814                  FT_UShort       point,
1815                  FT_F26Dot6      distance )
1816   {
1817     FT_UNUSED( exc );
1818 
1819 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1820     if ( !( SUBPIXEL_HINTING_MINIMAL             &amp;&amp;
1821             exc-&gt;backward_compatibility          &amp;&amp;
1822             exc-&gt;iupx_called &amp;&amp; exc-&gt;iupy_called ) )
1823 #endif
1824       zone-&gt;cur[point].y = ADD_LONG( zone-&gt;cur[point].y, distance );
1825 
1826     zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_Y;
1827   }
1828 
1829 
<span class="line-modified">1830   /*************************************************************************/</span>
<span class="line-modified">1831   /*                                                                       */</span>
<span class="line-modified">1832   /* Special versions of Direct_Move_Orig()                                */</span>
<span class="line-modified">1833   /*                                                                       */</span>
<span class="line-modified">1834   /*   The following versions are used whenever both vectors are both      */</span>
<span class="line-modified">1835   /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */</span>
<span class="line-modified">1836   /*                                                                       */</span>
<span class="line-modified">1837   /*************************************************************************/</span>
1838 
1839 
1840   static void
1841   Direct_Move_Orig_X( TT_ExecContext  exc,
1842                       TT_GlyphZone    zone,
1843                       FT_UShort       point,
1844                       FT_F26Dot6      distance )
1845   {
1846     FT_UNUSED( exc );
1847 
1848     zone-&gt;org[point].x = ADD_LONG( zone-&gt;org[point].x, distance );
1849   }
1850 
1851 
1852   static void
1853   Direct_Move_Orig_Y( TT_ExecContext  exc,
1854                       TT_GlyphZone    zone,
1855                       FT_UShort       point,
1856                       FT_F26Dot6      distance )
1857   {
1858     FT_UNUSED( exc );
1859 
1860     zone-&gt;org[point].y = ADD_LONG( zone-&gt;org[point].y, distance );
1861   }
1862 
<span class="line-modified">1863 </span>
<span class="line-modified">1864   /*************************************************************************/</span>
<span class="line-modified">1865   /*                                                                       */</span>
<span class="line-modified">1866   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1867   /*    Round_None                                                         */</span>
<span class="line-modified">1868   /*                                                                       */</span>
<span class="line-modified">1869   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1870   /*    Does not round, but adds engine compensation.                      */</span>
<span class="line-modified">1871   /*                                                                       */</span>
<span class="line-modified">1872   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1873   /*    distance     :: The distance (not) to round.                       */</span>
<span class="line-modified">1874   /*                                                                       */</span>
<span class="line-modified">1875   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">1876   /*                                                                       */</span>
<span class="line-modified">1877   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1878   /*    The compensated distance.                                          */</span>
<span class="line-modified">1879   /*                                                                       */</span>
<span class="line-modified">1880   /* &lt;Note&gt;                                                                */</span>
<span class="line-removed">1881   /*    The TrueType specification says very few about the relationship    */</span>
<span class="line-removed">1882   /*    between rounding and engine compensation.  However, it seems from  */</span>
<span class="line-removed">1883   /*    the description of super round that we should add the compensation */</span>
<span class="line-removed">1884   /*    before rounding.                                                   */</span>
<span class="line-removed">1885   /*                                                                       */</span>
1886   static FT_F26Dot6
1887   Round_None( TT_ExecContext  exc,
1888               FT_F26Dot6      distance,
1889               FT_F26Dot6      compensation )
1890   {
1891     FT_F26Dot6  val;
1892 
1893     FT_UNUSED( exc );
1894 
1895 
1896     if ( distance &gt;= 0 )
1897     {
1898       val = ADD_LONG( distance, compensation );
1899       if ( val &lt; 0 )
1900         val = 0;
1901     }
1902     else
1903     {
1904       val = SUB_LONG( distance, compensation );
1905       if ( val &gt; 0 )
1906         val = 0;
1907     }
1908     return val;
1909   }
1910 
1911 
<span class="line-modified">1912   /*************************************************************************/</span>
<span class="line-modified">1913   /*                                                                       */</span>
<span class="line-modified">1914   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1915   /*    Round_To_Grid                                                      */</span>
<span class="line-modified">1916   /*                                                                       */</span>
<span class="line-modified">1917   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1918   /*    Rounds value to grid after adding engine compensation.             */</span>
<span class="line-modified">1919   /*                                                                       */</span>
<span class="line-modified">1920   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1921   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">1922   /*                                                                       */</span>
<span class="line-modified">1923   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">1924   /*                                                                       */</span>
<span class="line-modified">1925   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1926   /*    Rounded distance.                                                  */</span>
<span class="line-modified">1927   /*                                                                       */</span>


1928   static FT_F26Dot6
1929   Round_To_Grid( TT_ExecContext  exc,
1930                  FT_F26Dot6      distance,
1931                  FT_F26Dot6      compensation )
1932   {
1933     FT_F26Dot6  val;
1934 
1935     FT_UNUSED( exc );
1936 
1937 
1938     if ( distance &gt;= 0 )
1939     {
1940       val = FT_PIX_ROUND_LONG( ADD_LONG( distance, compensation ) );
1941       if ( val &lt; 0 )
1942         val = 0;
1943     }
1944     else
1945     {
1946       val = NEG_LONG( FT_PIX_ROUND_LONG( SUB_LONG( compensation,
1947                                                    distance ) ) );
1948       if ( val &gt; 0 )
1949         val = 0;
1950     }
1951 
1952     return val;
1953   }
1954 
1955 
<span class="line-modified">1956   /*************************************************************************/</span>
<span class="line-modified">1957   /*                                                                       */</span>
<span class="line-modified">1958   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">1959   /*    Round_To_Half_Grid                                                 */</span>
<span class="line-modified">1960   /*                                                                       */</span>
<span class="line-modified">1961   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">1962   /*    Rounds value to half grid after adding engine compensation.        */</span>
<span class="line-modified">1963   /*                                                                       */</span>
<span class="line-modified">1964   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">1965   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">1966   /*                                                                       */</span>
<span class="line-modified">1967   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">1968   /*                                                                       */</span>
<span class="line-modified">1969   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">1970   /*    Rounded distance.                                                  */</span>
<span class="line-modified">1971   /*                                                                       */</span>


1972   static FT_F26Dot6
1973   Round_To_Half_Grid( TT_ExecContext  exc,
1974                       FT_F26Dot6      distance,
1975                       FT_F26Dot6      compensation )
1976   {
1977     FT_F26Dot6  val;
1978 
1979     FT_UNUSED( exc );
1980 
1981 
1982     if ( distance &gt;= 0 )
1983     {
1984       val = ADD_LONG( FT_PIX_FLOOR( ADD_LONG( distance, compensation ) ),
1985                       32 );
1986       if ( val &lt; 0 )
1987         val = 32;
1988     }
1989     else
1990     {
1991       val = NEG_LONG( ADD_LONG( FT_PIX_FLOOR( SUB_LONG( compensation,
1992                                                         distance ) ),
1993                                 32 ) );
1994       if ( val &gt; 0 )
1995         val = -32;
1996     }
1997 
1998     return val;
1999   }
2000 
2001 
<span class="line-modified">2002   /*************************************************************************/</span>
<span class="line-modified">2003   /*                                                                       */</span>
<span class="line-modified">2004   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2005   /*    Round_Down_To_Grid                                                 */</span>
<span class="line-modified">2006   /*                                                                       */</span>
<span class="line-modified">2007   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2008   /*    Rounds value down to grid after adding engine compensation.        */</span>
<span class="line-modified">2009   /*                                                                       */</span>
<span class="line-modified">2010   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2011   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">2012   /*                                                                       */</span>
<span class="line-modified">2013   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">2014   /*                                                                       */</span>
<span class="line-modified">2015   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2016   /*    Rounded distance.                                                  */</span>
<span class="line-modified">2017   /*                                                                       */</span>


2018   static FT_F26Dot6
2019   Round_Down_To_Grid( TT_ExecContext  exc,
2020                       FT_F26Dot6      distance,
2021                       FT_F26Dot6      compensation )
2022   {
2023     FT_F26Dot6  val;
2024 
2025     FT_UNUSED( exc );
2026 
2027 
2028     if ( distance &gt;= 0 )
2029     {
2030       val = FT_PIX_FLOOR( ADD_LONG( distance, compensation ) );
2031       if ( val &lt; 0 )
2032         val = 0;
2033     }
2034     else
2035     {
2036       val = NEG_LONG( FT_PIX_FLOOR( SUB_LONG( compensation, distance ) ) );
2037       if ( val &gt; 0 )
2038         val = 0;
2039     }
2040 
2041     return val;
2042   }
2043 
2044 
<span class="line-modified">2045   /*************************************************************************/</span>
<span class="line-modified">2046   /*                                                                       */</span>
<span class="line-modified">2047   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2048   /*    Round_Up_To_Grid                                                   */</span>
<span class="line-modified">2049   /*                                                                       */</span>
<span class="line-modified">2050   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2051   /*    Rounds value up to grid after adding engine compensation.          */</span>
<span class="line-modified">2052   /*                                                                       */</span>
<span class="line-modified">2053   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2054   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">2055   /*                                                                       */</span>
<span class="line-modified">2056   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">2057   /*                                                                       */</span>
<span class="line-modified">2058   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2059   /*    Rounded distance.                                                  */</span>
<span class="line-modified">2060   /*                                                                       */</span>


2061   static FT_F26Dot6
2062   Round_Up_To_Grid( TT_ExecContext  exc,
2063                     FT_F26Dot6      distance,
2064                     FT_F26Dot6      compensation )
2065   {
2066     FT_F26Dot6  val;
2067 
2068     FT_UNUSED( exc );
2069 
2070 
2071     if ( distance &gt;= 0 )
2072     {
2073       val = FT_PIX_CEIL_LONG( ADD_LONG( distance, compensation ) );
2074       if ( val &lt; 0 )
2075         val = 0;
2076     }
2077     else
2078     {
2079       val = NEG_LONG( FT_PIX_CEIL_LONG( SUB_LONG( compensation,
2080                                                   distance ) ) );
2081       if ( val &gt; 0 )
2082         val = 0;
2083     }
2084 
2085     return val;
2086   }
2087 
2088 
<span class="line-modified">2089   /*************************************************************************/</span>
<span class="line-modified">2090   /*                                                                       */</span>
<span class="line-modified">2091   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2092   /*    Round_To_Double_Grid                                               */</span>
<span class="line-modified">2093   /*                                                                       */</span>
<span class="line-modified">2094   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2095   /*    Rounds value to double grid after adding engine compensation.      */</span>
<span class="line-modified">2096   /*                                                                       */</span>
<span class="line-modified">2097   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2098   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">2099   /*                                                                       */</span>
<span class="line-modified">2100   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">2101   /*                                                                       */</span>
<span class="line-modified">2102   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2103   /*    Rounded distance.                                                  */</span>
<span class="line-modified">2104   /*                                                                       */</span>


2105   static FT_F26Dot6
2106   Round_To_Double_Grid( TT_ExecContext  exc,
2107                         FT_F26Dot6      distance,
2108                         FT_F26Dot6      compensation )
2109   {
2110     FT_F26Dot6  val;
2111 
2112     FT_UNUSED( exc );
2113 
2114 
2115     if ( distance &gt;= 0 )
2116     {
2117       val = FT_PAD_ROUND_LONG( ADD_LONG( distance, compensation ), 32 );
2118       if ( val &lt; 0 )
2119         val = 0;
2120     }
2121     else
2122     {
2123       val = NEG_LONG( FT_PAD_ROUND_LONG( SUB_LONG( compensation, distance ),
2124                                          32 ) );
2125       if ( val &gt; 0 )
2126         val = 0;
2127     }
2128 
2129     return val;
2130   }
2131 
2132 
<span class="line-modified">2133   /*************************************************************************/</span>
<span class="line-modified">2134   /*                                                                       */</span>
<span class="line-modified">2135   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2136   /*    Round_Super                                                        */</span>
<span class="line-modified">2137   /*                                                                       */</span>
<span class="line-modified">2138   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2139   /*    Super-rounds value to grid after adding engine compensation.       */</span>
<span class="line-modified">2140   /*                                                                       */</span>
<span class="line-modified">2141   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2142   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">2143   /*                                                                       */</span>
<span class="line-modified">2144   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">2145   /*                                                                       */</span>
<span class="line-modified">2146   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2147   /*    Rounded distance.                                                  */</span>
<span class="line-modified">2148   /*                                                                       */</span>
<span class="line-modified">2149   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">2150   /*    The TrueType specification says very little about the relationship */</span>
<span class="line-modified">2151   /*    between rounding and engine compensation.  However, it seems from  */</span>
<span class="line-modified">2152   /*    the description of super round that we should add the compensation */</span>
<span class="line-modified">2153   /*    before rounding.                                                   */</span>
<span class="line-modified">2154   /*                                                                       */</span>


2155   static FT_F26Dot6
2156   Round_Super( TT_ExecContext  exc,
2157                FT_F26Dot6      distance,
2158                FT_F26Dot6      compensation )
2159   {
2160     FT_F26Dot6  val;
2161 
2162 
2163     if ( distance &gt;= 0 )
2164     {
2165       val = ADD_LONG( distance,
2166                       exc-&gt;threshold - exc-&gt;phase + compensation ) &amp;
2167               -exc-&gt;period;
2168       val = ADD_LONG( val, exc-&gt;phase );
2169       if ( val &lt; 0 )
2170         val = exc-&gt;phase;
2171     }
2172     else
2173     {
2174       val = NEG_LONG( SUB_LONG( exc-&gt;threshold - exc-&gt;phase + compensation,
2175                                 distance ) &amp;
2176                         -exc-&gt;period );
2177       val = SUB_LONG( val, exc-&gt;phase );
2178       if ( val &gt; 0 )
2179         val = -exc-&gt;phase;
2180     }
2181 
2182     return val;
2183   }
2184 
2185 
<span class="line-modified">2186   /*************************************************************************/</span>
<span class="line-modified">2187   /*                                                                       */</span>
<span class="line-modified">2188   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2189   /*    Round_Super_45                                                     */</span>
<span class="line-modified">2190   /*                                                                       */</span>
<span class="line-modified">2191   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2192   /*    Super-rounds value to grid after adding engine compensation.       */</span>
<span class="line-modified">2193   /*                                                                       */</span>
<span class="line-modified">2194   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2195   /*    distance     :: The distance to round.                             */</span>
<span class="line-modified">2196   /*                                                                       */</span>
<span class="line-modified">2197   /*    compensation :: The engine compensation.                           */</span>
<span class="line-modified">2198   /*                                                                       */</span>
<span class="line-modified">2199   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2200   /*    Rounded distance.                                                  */</span>
<span class="line-modified">2201   /*                                                                       */</span>
<span class="line-modified">2202   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">2203   /*    There is a separate function for Round_Super_45() as we may need   */</span>
<span class="line-modified">2204   /*    greater precision.                                                 */</span>
<span class="line-modified">2205   /*                                                                       */</span>


2206   static FT_F26Dot6
2207   Round_Super_45( TT_ExecContext  exc,
2208                   FT_F26Dot6      distance,
2209                   FT_F26Dot6      compensation )
2210   {
2211     FT_F26Dot6  val;
2212 
2213 
2214     if ( distance &gt;= 0 )
2215     {
2216       val = ( ADD_LONG( distance,
2217                         exc-&gt;threshold - exc-&gt;phase + compensation ) /
2218                 exc-&gt;period ) * exc-&gt;period;
2219       val = ADD_LONG( val, exc-&gt;phase );
2220       if ( val &lt; 0 )
2221         val = exc-&gt;phase;
2222     }
2223     else
2224     {
2225       val = NEG_LONG( ( SUB_LONG( exc-&gt;threshold - exc-&gt;phase + compensation,
2226                                   distance ) /
2227                           exc-&gt;period ) * exc-&gt;period );
2228       val = SUB_LONG( val, exc-&gt;phase );
2229       if ( val &gt; 0 )
2230         val = -exc-&gt;phase;
2231     }
2232 
2233     return val;
2234   }
2235 
2236 
<span class="line-modified">2237   /*************************************************************************/</span>
<span class="line-modified">2238   /*                                                                       */</span>
<span class="line-modified">2239   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2240   /*    Compute_Round                                                      */</span>
<span class="line-modified">2241   /*                                                                       */</span>
<span class="line-modified">2242   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2243   /*    Sets the rounding mode.                                            */</span>
<span class="line-modified">2244   /*                                                                       */</span>
<span class="line-modified">2245   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2246   /*    round_mode :: The rounding mode to be used.                        */</span>
<span class="line-modified">2247   /*                                                                       */</span>

2248   static void
2249   Compute_Round( TT_ExecContext  exc,
2250                  FT_Byte         round_mode )
2251   {
2252     switch ( round_mode )
2253     {
2254     case TT_Round_Off:
2255       exc-&gt;func_round = (TT_Round_Func)Round_None;
2256       break;
2257 
2258     case TT_Round_To_Grid:
2259       exc-&gt;func_round = (TT_Round_Func)Round_To_Grid;
2260       break;
2261 
2262     case TT_Round_Up_To_Grid:
2263       exc-&gt;func_round = (TT_Round_Func)Round_Up_To_Grid;
2264       break;
2265 
2266     case TT_Round_Down_To_Grid:
2267       exc-&gt;func_round = (TT_Round_Func)Round_Down_To_Grid;
</pre>
<hr />
<pre>
2269 
2270     case TT_Round_To_Half_Grid:
2271       exc-&gt;func_round = (TT_Round_Func)Round_To_Half_Grid;
2272       break;
2273 
2274     case TT_Round_To_Double_Grid:
2275       exc-&gt;func_round = (TT_Round_Func)Round_To_Double_Grid;
2276       break;
2277 
2278     case TT_Round_Super:
2279       exc-&gt;func_round = (TT_Round_Func)Round_Super;
2280       break;
2281 
2282     case TT_Round_Super_45:
2283       exc-&gt;func_round = (TT_Round_Func)Round_Super_45;
2284       break;
2285     }
2286   }
2287 
2288 
<span class="line-modified">2289   /*************************************************************************/</span>
<span class="line-modified">2290   /*                                                                       */</span>
<span class="line-modified">2291   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2292   /*    SetSuperRound                                                      */</span>
<span class="line-modified">2293   /*                                                                       */</span>
<span class="line-modified">2294   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2295   /*    Sets Super Round parameters.                                       */</span>
<span class="line-modified">2296   /*                                                                       */</span>
<span class="line-modified">2297   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2298   /*    GridPeriod :: The grid period.                                     */</span>
<span class="line-modified">2299   /*                                                                       */</span>
<span class="line-modified">2300   /*    selector   :: The SROUND opcode.                                   */</span>
<span class="line-modified">2301   /*                                                                       */</span>


2302   static void
2303   SetSuperRound( TT_ExecContext  exc,
2304                  FT_F2Dot14      GridPeriod,
2305                  FT_Long         selector )
2306   {
2307     switch ( (FT_Int)( selector &amp; 0xC0 ) )
2308     {
2309       case 0:
2310         exc-&gt;period = GridPeriod / 2;
2311         break;
2312 
2313       case 0x40:
2314         exc-&gt;period = GridPeriod;
2315         break;
2316 
2317       case 0x80:
2318         exc-&gt;period = GridPeriod * 2;
2319         break;
2320 
2321       /* This opcode is reserved, but... */
</pre>
<hr />
<pre>
2338       exc-&gt;phase = exc-&gt;period / 2;
2339       break;
2340 
2341     case 0x30:
2342       exc-&gt;phase = exc-&gt;period * 3 / 4;
2343       break;
2344     }
2345 
2346     if ( ( selector &amp; 0x0F ) == 0 )
2347       exc-&gt;threshold = exc-&gt;period - 1;
2348     else
2349       exc-&gt;threshold = ( (FT_Int)( selector &amp; 0x0F ) - 4 ) * exc-&gt;period / 8;
2350 
2351     /* convert to F26Dot6 format */
2352     exc-&gt;period    &gt;&gt;= 8;
2353     exc-&gt;phase     &gt;&gt;= 8;
2354     exc-&gt;threshold &gt;&gt;= 8;
2355   }
2356 
2357 
<span class="line-modified">2358   /*************************************************************************/</span>
<span class="line-modified">2359   /*                                                                       */</span>
<span class="line-modified">2360   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2361   /*    Project                                                            */</span>
<span class="line-modified">2362   /*                                                                       */</span>
<span class="line-modified">2363   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2364   /*    Computes the projection of vector given by (v2-v1) along the       */</span>
<span class="line-modified">2365   /*    current projection vector.                                         */</span>
<span class="line-modified">2366   /*                                                                       */</span>
<span class="line-modified">2367   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2368   /*    v1 :: First input vector.                                          */</span>
<span class="line-modified">2369   /*    v2 :: Second input vector.                                         */</span>
<span class="line-modified">2370   /*                                                                       */</span>
<span class="line-modified">2371   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2372   /*    The distance in F26dot6 format.                                    */</span>
<span class="line-modified">2373   /*                                                                       */</span>


2374   static FT_F26Dot6
2375   Project( TT_ExecContext  exc,
2376            FT_Pos          dx,
2377            FT_Pos          dy )
2378   {
2379     return TT_DotFix14( dx, dy,
2380                         exc-&gt;GS.projVector.x,
2381                         exc-&gt;GS.projVector.y );
2382   }
2383 
2384 
<span class="line-modified">2385   /*************************************************************************/</span>
<span class="line-modified">2386   /*                                                                       */</span>
<span class="line-modified">2387   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2388   /*    Dual_Project                                                       */</span>
<span class="line-modified">2389   /*                                                                       */</span>
<span class="line-modified">2390   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2391   /*    Computes the projection of the vector given by (v2-v1) along the   */</span>
<span class="line-modified">2392   /*    current dual vector.                                               */</span>
<span class="line-modified">2393   /*                                                                       */</span>
<span class="line-modified">2394   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2395   /*    v1 :: First input vector.                                          */</span>
<span class="line-modified">2396   /*    v2 :: Second input vector.                                         */</span>
<span class="line-modified">2397   /*                                                                       */</span>
<span class="line-modified">2398   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2399   /*    The distance in F26dot6 format.                                    */</span>
<span class="line-modified">2400   /*                                                                       */</span>


2401   static FT_F26Dot6
2402   Dual_Project( TT_ExecContext  exc,
2403                 FT_Pos          dx,
2404                 FT_Pos          dy )
2405   {
2406     return TT_DotFix14( dx, dy,
2407                         exc-&gt;GS.dualVector.x,
2408                         exc-&gt;GS.dualVector.y );
2409   }
2410 
2411 
<span class="line-modified">2412   /*************************************************************************/</span>
<span class="line-modified">2413   /*                                                                       */</span>
<span class="line-modified">2414   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2415   /*    Project_x                                                          */</span>
<span class="line-modified">2416   /*                                                                       */</span>
<span class="line-modified">2417   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2418   /*    Computes the projection of the vector given by (v2-v1) along the   */</span>
<span class="line-modified">2419   /*    horizontal axis.                                                   */</span>
<span class="line-modified">2420   /*                                                                       */</span>
<span class="line-modified">2421   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2422   /*    v1 :: First input vector.                                          */</span>
<span class="line-modified">2423   /*    v2 :: Second input vector.                                         */</span>
<span class="line-modified">2424   /*                                                                       */</span>
<span class="line-modified">2425   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2426   /*    The distance in F26dot6 format.                                    */</span>
<span class="line-modified">2427   /*                                                                       */</span>


2428   static FT_F26Dot6
2429   Project_x( TT_ExecContext  exc,
2430              FT_Pos          dx,
2431              FT_Pos          dy )
2432   {
2433     FT_UNUSED( exc );
2434     FT_UNUSED( dy );
2435 
2436     return dx;
2437   }
2438 
2439 
<span class="line-modified">2440   /*************************************************************************/</span>
<span class="line-modified">2441   /*                                                                       */</span>
<span class="line-modified">2442   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2443   /*    Project_y                                                          */</span>
<span class="line-modified">2444   /*                                                                       */</span>
<span class="line-modified">2445   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2446   /*    Computes the projection of the vector given by (v2-v1) along the   */</span>
<span class="line-modified">2447   /*    vertical axis.                                                     */</span>
<span class="line-modified">2448   /*                                                                       */</span>
<span class="line-modified">2449   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2450   /*    v1 :: First input vector.                                          */</span>
<span class="line-modified">2451   /*    v2 :: Second input vector.                                         */</span>
<span class="line-modified">2452   /*                                                                       */</span>
<span class="line-modified">2453   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2454   /*    The distance in F26dot6 format.                                    */</span>
<span class="line-modified">2455   /*                                                                       */</span>


2456   static FT_F26Dot6
2457   Project_y( TT_ExecContext  exc,
2458              FT_Pos          dx,
2459              FT_Pos          dy )
2460   {
2461     FT_UNUSED( exc );
2462     FT_UNUSED( dx );
2463 
2464     return dy;
2465   }
2466 
2467 
<span class="line-modified">2468   /*************************************************************************/</span>
<span class="line-modified">2469   /*                                                                       */</span>
<span class="line-modified">2470   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2471   /*    Compute_Funcs                                                      */</span>
<span class="line-modified">2472   /*                                                                       */</span>
<span class="line-modified">2473   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2474   /*    Computes the projection and movement function pointers according   */</span>
<span class="line-modified">2475   /*    to the current graphics state.                                     */</span>
<span class="line-modified">2476   /*                                                                       */</span>
2477   static void
2478   Compute_Funcs( TT_ExecContext  exc )
2479   {
2480     if ( exc-&gt;GS.freeVector.x == 0x4000 )
2481       exc-&gt;F_dot_P = exc-&gt;GS.projVector.x;
2482     else if ( exc-&gt;GS.freeVector.y == 0x4000 )
2483       exc-&gt;F_dot_P = exc-&gt;GS.projVector.y;
2484     else
2485       exc-&gt;F_dot_P =
2486         ( (FT_Long)exc-&gt;GS.projVector.x * exc-&gt;GS.freeVector.x +
2487           (FT_Long)exc-&gt;GS.projVector.y * exc-&gt;GS.freeVector.y ) &gt;&gt; 14;
2488 
2489     if ( exc-&gt;GS.projVector.x == 0x4000 )
2490       exc-&gt;func_project = (TT_Project_Func)Project_x;
2491     else if ( exc-&gt;GS.projVector.y == 0x4000 )
2492       exc-&gt;func_project = (TT_Project_Func)Project_y;
2493     else
2494       exc-&gt;func_project = (TT_Project_Func)Project;
2495 
2496     if ( exc-&gt;GS.dualVector.x == 0x4000 )
</pre>
<hr />
<pre>
2511         exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
2512       }
2513       else if ( exc-&gt;GS.freeVector.y == 0x4000 )
2514       {
2515         exc-&gt;func_move      = (TT_Move_Func)Direct_Move_Y;
2516         exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
2517       }
2518     }
2519 
2520     /* at small sizes, F_dot_P can become too small, resulting   */
2521     /* in overflows and `spikes&#39; in a number of glyphs like `w&#39;. */
2522 
2523     if ( FT_ABS( exc-&gt;F_dot_P ) &lt; 0x400L )
2524       exc-&gt;F_dot_P = 0x4000L;
2525 
2526     /* Disable cached aspect ratio */
2527     exc-&gt;tt_metrics.ratio = 0;
2528   }
2529 
2530 
<span class="line-modified">2531   /*************************************************************************/</span>
<span class="line-modified">2532   /*                                                                       */</span>
<span class="line-modified">2533   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">2534   /*    Normalize                                                          */</span>
<span class="line-modified">2535   /*                                                                       */</span>
<span class="line-modified">2536   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">2537   /*    Norms a vector.                                                    */</span>
<span class="line-modified">2538   /*                                                                       */</span>
<span class="line-modified">2539   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">2540   /*    Vx :: The horizontal input vector coordinate.                      */</span>
<span class="line-modified">2541   /*    Vy :: The vertical input vector coordinate.                        */</span>
<span class="line-modified">2542   /*                                                                       */</span>
<span class="line-modified">2543   /* &lt;Output&gt;                                                              */</span>
<span class="line-modified">2544   /*    R  :: The normed unit vector.                                      */</span>
<span class="line-modified">2545   /*                                                                       */</span>
<span class="line-modified">2546   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">2547   /*    Returns FAILURE if a vector parameter is zero.                     */</span>
<span class="line-modified">2548   /*                                                                       */</span>
<span class="line-modified">2549   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">2550   /*    In case Vx and Vy are both zero, `Normalize&#39; returns SUCCESS, and  */</span>
<span class="line-modified">2551   /*    R is undefined.                                                    */</span>
<span class="line-modified">2552   /*                                                                       */</span>



2553   static FT_Bool
2554   Normalize( FT_F26Dot6      Vx,
2555              FT_F26Dot6      Vy,
2556              FT_UnitVector*  R )
2557   {
2558     FT_Vector V;
2559 
2560 
2561     if ( Vx == 0 &amp;&amp; Vy == 0 )
2562     {
2563       /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
2564       /*      to normalize the vector (0,0).  Return immediately. */
2565       return SUCCESS;
2566     }
2567 
2568     V.x = Vx;
2569     V.y = Vy;
2570 
2571     FT_Vector_NormLen( &amp;V );
2572 
2573     R-&gt;x = (FT_F2Dot14)( V.x / 4 );
2574     R-&gt;y = (FT_F2Dot14)( V.y / 4 );
2575 
2576     return SUCCESS;
2577   }
2578 
2579 
<span class="line-modified">2580   /*************************************************************************/</span>
<span class="line-modified">2581   /*                                                                       */</span>
<span class="line-modified">2582   /* Here we start with the implementation of the various opcodes.         */</span>
<span class="line-modified">2583   /*                                                                       */</span>
<span class="line-modified">2584   /*************************************************************************/</span>
2585 
2586 
2587 #define ARRAY_BOUND_ERROR                         \
2588     do                                            \
2589     {                                             \
2590       exc-&gt;error = FT_THROW( Invalid_Reference ); \
2591       return;                                     \
2592     } while (0)
2593 
2594 
<span class="line-modified">2595   /*************************************************************************/</span>
<span class="line-modified">2596   /*                                                                       */</span>
<span class="line-modified">2597   /* MPPEM[]:      Measure Pixel Per EM                                    */</span>
<span class="line-modified">2598   /* Opcode range: 0x4B                                                    */</span>
<span class="line-modified">2599   /* Stack:        --&gt; Euint16                                             */</span>
<span class="line-modified">2600   /*                                                                       */</span>
2601   static void
2602   Ins_MPPEM( TT_ExecContext  exc,
2603              FT_Long*        args )
2604   {
2605     args[0] = exc-&gt;func_cur_ppem( exc );
2606   }
2607 
2608 
<span class="line-modified">2609   /*************************************************************************/</span>
<span class="line-modified">2610   /*                                                                       */</span>
<span class="line-modified">2611   /* MPS[]:        Measure Point Size                                      */</span>
<span class="line-modified">2612   /* Opcode range: 0x4C                                                    */</span>
<span class="line-modified">2613   /* Stack:        --&gt; Euint16                                             */</span>
<span class="line-modified">2614   /*                                                                       */</span>
2615   static void
2616   Ins_MPS( TT_ExecContext  exc,
2617            FT_Long*        args )
2618   {
2619     if ( NO_SUBPIXEL_HINTING )
2620     {
2621       /* Microsoft&#39;s GDI bytecode interpreter always returns value 12; */
2622       /* we return the current PPEM value instead.                     */
2623       args[0] = exc-&gt;func_cur_ppem( exc );
2624     }
2625     else
2626     {
2627       /* A possible practical application of the MPS instruction is to   */
2628       /* implement optical scaling and similar features, which should be */
2629       /* based on perceptual attributes, thus independent of the         */
2630       /* resolution.                                                     */
2631       args[0] = exc-&gt;pointSize;
2632     }
2633   }
2634 
2635 
<span class="line-modified">2636   /*************************************************************************/</span>
<span class="line-modified">2637   /*                                                                       */</span>
<span class="line-modified">2638   /* DUP[]:        DUPlicate the stack&#39;s top element                       */</span>
<span class="line-modified">2639   /* Opcode range: 0x20                                                    */</span>
<span class="line-modified">2640   /* Stack:        StkElt --&gt; StkElt StkElt                                */</span>
<span class="line-modified">2641   /*                                                                       */</span>
2642   static void
2643   Ins_DUP( FT_Long*  args )
2644   {
2645     args[1] = args[0];
2646   }
2647 
2648 
<span class="line-modified">2649   /*************************************************************************/</span>
<span class="line-modified">2650   /*                                                                       */</span>
<span class="line-modified">2651   /* POP[]:        POP the stack&#39;s top element                             */</span>
<span class="line-modified">2652   /* Opcode range: 0x21                                                    */</span>
<span class="line-modified">2653   /* Stack:        StkElt --&gt;                                              */</span>
<span class="line-modified">2654   /*                                                                       */</span>
2655   static void
2656   Ins_POP( void )
2657   {
2658     /* nothing to do */
2659   }
2660 
2661 
<span class="line-modified">2662   /*************************************************************************/</span>
<span class="line-modified">2663   /*                                                                       */</span>
<span class="line-modified">2664   /* CLEAR[]:      CLEAR the entire stack                                  */</span>
<span class="line-modified">2665   /* Opcode range: 0x22                                                    */</span>
<span class="line-modified">2666   /* Stack:        StkElt... --&gt;                                           */</span>
<span class="line-modified">2667   /*                                                                       */</span>
2668   static void
2669   Ins_CLEAR( TT_ExecContext  exc )
2670   {
2671     exc-&gt;new_top = 0;
2672   }
2673 
2674 
<span class="line-modified">2675   /*************************************************************************/</span>
<span class="line-modified">2676   /*                                                                       */</span>
<span class="line-modified">2677   /* SWAP[]:       SWAP the stack&#39;s top two elements                       */</span>
<span class="line-modified">2678   /* Opcode range: 0x23                                                    */</span>
<span class="line-modified">2679   /* Stack:        2 * StkElt --&gt; 2 * StkElt                               */</span>
<span class="line-modified">2680   /*                                                                       */</span>
2681   static void
2682   Ins_SWAP( FT_Long*  args )
2683   {
2684     FT_Long  L;
2685 
2686 
2687     L       = args[0];
2688     args[0] = args[1];
2689     args[1] = L;
2690   }
2691 
2692 
<span class="line-modified">2693   /*************************************************************************/</span>
<span class="line-modified">2694   /*                                                                       */</span>
<span class="line-modified">2695   /* DEPTH[]:      return the stack DEPTH                                  */</span>
<span class="line-modified">2696   /* Opcode range: 0x24                                                    */</span>
<span class="line-modified">2697   /* Stack:        --&gt; uint32                                              */</span>
<span class="line-modified">2698   /*                                                                       */</span>
2699   static void
2700   Ins_DEPTH( TT_ExecContext  exc,
2701              FT_Long*        args )
2702   {
2703     args[0] = exc-&gt;top;
2704   }
2705 
2706 
<span class="line-modified">2707   /*************************************************************************/</span>
<span class="line-modified">2708   /*                                                                       */</span>
<span class="line-modified">2709   /* LT[]:         Less Than                                               */</span>
<span class="line-modified">2710   /* Opcode range: 0x50                                                    */</span>
<span class="line-modified">2711   /* Stack:        int32? int32? --&gt; bool                                  */</span>
<span class="line-modified">2712   /*                                                                       */</span>
2713   static void
2714   Ins_LT( FT_Long*  args )
2715   {
2716     args[0] = ( args[0] &lt; args[1] );
2717   }
2718 
2719 
<span class="line-modified">2720   /*************************************************************************/</span>
<span class="line-modified">2721   /*                                                                       */</span>
<span class="line-modified">2722   /* LTEQ[]:       Less Than or EQual                                      */</span>
<span class="line-modified">2723   /* Opcode range: 0x51                                                    */</span>
<span class="line-modified">2724   /* Stack:        int32? int32? --&gt; bool                                  */</span>
<span class="line-modified">2725   /*                                                                       */</span>
2726   static void
2727   Ins_LTEQ( FT_Long*  args )
2728   {
2729     args[0] = ( args[0] &lt;= args[1] );
2730   }
2731 
2732 
<span class="line-modified">2733   /*************************************************************************/</span>
<span class="line-modified">2734   /*                                                                       */</span>
<span class="line-modified">2735   /* GT[]:         Greater Than                                            */</span>
<span class="line-modified">2736   /* Opcode range: 0x52                                                    */</span>
<span class="line-modified">2737   /* Stack:        int32? int32? --&gt; bool                                  */</span>
<span class="line-modified">2738   /*                                                                       */</span>
2739   static void
2740   Ins_GT( FT_Long*  args )
2741   {
2742     args[0] = ( args[0] &gt; args[1] );
2743   }
2744 
2745 
<span class="line-modified">2746   /*************************************************************************/</span>
<span class="line-modified">2747   /*                                                                       */</span>
<span class="line-modified">2748   /* GTEQ[]:       Greater Than or EQual                                   */</span>
<span class="line-modified">2749   /* Opcode range: 0x53                                                    */</span>
<span class="line-modified">2750   /* Stack:        int32? int32? --&gt; bool                                  */</span>
<span class="line-modified">2751   /*                                                                       */</span>
2752   static void
2753   Ins_GTEQ( FT_Long*  args )
2754   {
2755     args[0] = ( args[0] &gt;= args[1] );
2756   }
2757 
2758 
<span class="line-modified">2759   /*************************************************************************/</span>
<span class="line-modified">2760   /*                                                                       */</span>
<span class="line-modified">2761   /* EQ[]:         EQual                                                   */</span>
<span class="line-modified">2762   /* Opcode range: 0x54                                                    */</span>
<span class="line-modified">2763   /* Stack:        StkElt StkElt --&gt; bool                                  */</span>
<span class="line-modified">2764   /*                                                                       */</span>
2765   static void
2766   Ins_EQ( FT_Long*  args )
2767   {
2768     args[0] = ( args[0] == args[1] );
2769   }
2770 
2771 
<span class="line-modified">2772   /*************************************************************************/</span>
<span class="line-modified">2773   /*                                                                       */</span>
<span class="line-modified">2774   /* NEQ[]:        Not EQual                                               */</span>
<span class="line-modified">2775   /* Opcode range: 0x55                                                    */</span>
<span class="line-modified">2776   /* Stack:        StkElt StkElt --&gt; bool                                  */</span>
<span class="line-modified">2777   /*                                                                       */</span>
2778   static void
2779   Ins_NEQ( FT_Long*  args )
2780   {
2781     args[0] = ( args[0] != args[1] );
2782   }
2783 
2784 
<span class="line-modified">2785   /*************************************************************************/</span>
<span class="line-modified">2786   /*                                                                       */</span>
<span class="line-modified">2787   /* ODD[]:        Is ODD                                                  */</span>
<span class="line-modified">2788   /* Opcode range: 0x56                                                    */</span>
<span class="line-modified">2789   /* Stack:        f26.6 --&gt; bool                                          */</span>
<span class="line-modified">2790   /*                                                                       */</span>
2791   static void
2792   Ins_ODD( TT_ExecContext  exc,
2793            FT_Long*        args )
2794   {
2795     args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 64 );
2796   }
2797 
2798 
<span class="line-modified">2799   /*************************************************************************/</span>
<span class="line-modified">2800   /*                                                                       */</span>
<span class="line-modified">2801   /* EVEN[]:       Is EVEN                                                 */</span>
<span class="line-modified">2802   /* Opcode range: 0x57                                                    */</span>
<span class="line-modified">2803   /* Stack:        f26.6 --&gt; bool                                          */</span>
<span class="line-modified">2804   /*                                                                       */</span>
2805   static void
2806   Ins_EVEN( TT_ExecContext  exc,
2807             FT_Long*        args )
2808   {
2809     args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 0 );
2810   }
2811 
2812 
<span class="line-modified">2813   /*************************************************************************/</span>
<span class="line-modified">2814   /*                                                                       */</span>
<span class="line-modified">2815   /* AND[]:        logical AND                                             */</span>
<span class="line-modified">2816   /* Opcode range: 0x5A                                                    */</span>
<span class="line-modified">2817   /* Stack:        uint32 uint32 --&gt; uint32                                */</span>
<span class="line-modified">2818   /*                                                                       */</span>
2819   static void
2820   Ins_AND( FT_Long*  args )
2821   {
2822     args[0] = ( args[0] &amp;&amp; args[1] );
2823   }
2824 
2825 
<span class="line-modified">2826   /*************************************************************************/</span>
<span class="line-modified">2827   /*                                                                       */</span>
<span class="line-modified">2828   /* OR[]:         logical OR                                              */</span>
<span class="line-modified">2829   /* Opcode range: 0x5B                                                    */</span>
<span class="line-modified">2830   /* Stack:        uint32 uint32 --&gt; uint32                                */</span>
<span class="line-modified">2831   /*                                                                       */</span>
2832   static void
2833   Ins_OR( FT_Long*  args )
2834   {
2835     args[0] = ( args[0] || args[1] );
2836   }
2837 
2838 
<span class="line-modified">2839   /*************************************************************************/</span>
<span class="line-modified">2840   /*                                                                       */</span>
<span class="line-modified">2841   /* NOT[]:        logical NOT                                             */</span>
<span class="line-modified">2842   /* Opcode range: 0x5C                                                    */</span>
<span class="line-modified">2843   /* Stack:        StkElt --&gt; uint32                                       */</span>
<span class="line-modified">2844   /*                                                                       */</span>
2845   static void
2846   Ins_NOT( FT_Long*  args )
2847   {
2848     args[0] = !args[0];
2849   }
2850 
2851 
<span class="line-modified">2852   /*************************************************************************/</span>
<span class="line-modified">2853   /*                                                                       */</span>
<span class="line-modified">2854   /* ADD[]:        ADD                                                     */</span>
<span class="line-modified">2855   /* Opcode range: 0x60                                                    */</span>
<span class="line-modified">2856   /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</span>
<span class="line-modified">2857   /*                                                                       */</span>
2858   static void
2859   Ins_ADD( FT_Long*  args )
2860   {
2861     args[0] = ADD_LONG( args[0], args[1] );
2862   }
2863 
2864 
<span class="line-modified">2865   /*************************************************************************/</span>
<span class="line-modified">2866   /*                                                                       */</span>
<span class="line-modified">2867   /* SUB[]:        SUBtract                                                */</span>
<span class="line-modified">2868   /* Opcode range: 0x61                                                    */</span>
<span class="line-modified">2869   /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</span>
<span class="line-modified">2870   /*                                                                       */</span>
2871   static void
2872   Ins_SUB( FT_Long*  args )
2873   {
2874     args[0] = SUB_LONG( args[0], args[1] );
2875   }
2876 
2877 
<span class="line-modified">2878   /*************************************************************************/</span>
<span class="line-modified">2879   /*                                                                       */</span>
<span class="line-modified">2880   /* DIV[]:        DIVide                                                  */</span>
<span class="line-modified">2881   /* Opcode range: 0x62                                                    */</span>
<span class="line-modified">2882   /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</span>
<span class="line-modified">2883   /*                                                                       */</span>
2884   static void
2885   Ins_DIV( TT_ExecContext  exc,
2886            FT_Long*        args )
2887   {
2888     if ( args[1] == 0 )
2889       exc-&gt;error = FT_THROW( Divide_By_Zero );
2890     else
2891       args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
2892   }
2893 
2894 
<span class="line-modified">2895   /*************************************************************************/</span>
<span class="line-modified">2896   /*                                                                       */</span>
<span class="line-modified">2897   /* MUL[]:        MULtiply                                                */</span>
<span class="line-modified">2898   /* Opcode range: 0x63                                                    */</span>
<span class="line-modified">2899   /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</span>
<span class="line-modified">2900   /*                                                                       */</span>
2901   static void
2902   Ins_MUL( FT_Long*  args )
2903   {
2904     args[0] = FT_MulDiv( args[0], args[1], 64L );
2905   }
2906 
2907 
<span class="line-modified">2908   /*************************************************************************/</span>
<span class="line-modified">2909   /*                                                                       */</span>
<span class="line-modified">2910   /* ABS[]:        ABSolute value                                          */</span>
<span class="line-modified">2911   /* Opcode range: 0x64                                                    */</span>
<span class="line-modified">2912   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">2913   /*                                                                       */</span>
2914   static void
2915   Ins_ABS( FT_Long*  args )
2916   {
2917     if ( args[0] &lt; 0 )
2918       args[0] = NEG_LONG( args[0] );
2919   }
2920 
2921 
<span class="line-modified">2922   /*************************************************************************/</span>
<span class="line-modified">2923   /*                                                                       */</span>
<span class="line-modified">2924   /* NEG[]:        NEGate                                                  */</span>
<span class="line-modified">2925   /* Opcode range: 0x65                                                    */</span>
<span class="line-modified">2926   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">2927   /*                                                                       */</span>
2928   static void
2929   Ins_NEG( FT_Long*  args )
2930   {
2931     args[0] = NEG_LONG( args[0] );
2932   }
2933 
2934 
<span class="line-modified">2935   /*************************************************************************/</span>
<span class="line-modified">2936   /*                                                                       */</span>
<span class="line-modified">2937   /* FLOOR[]:      FLOOR                                                   */</span>
<span class="line-modified">2938   /* Opcode range: 0x66                                                    */</span>
<span class="line-modified">2939   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">2940   /*                                                                       */</span>
2941   static void
2942   Ins_FLOOR( FT_Long*  args )
2943   {
2944     args[0] = FT_PIX_FLOOR( args[0] );
2945   }
2946 
2947 
<span class="line-modified">2948   /*************************************************************************/</span>
<span class="line-modified">2949   /*                                                                       */</span>
<span class="line-modified">2950   /* CEILING[]:    CEILING                                                 */</span>
<span class="line-modified">2951   /* Opcode range: 0x67                                                    */</span>
<span class="line-modified">2952   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">2953   /*                                                                       */</span>
2954   static void
2955   Ins_CEILING( FT_Long*  args )
2956   {
2957     args[0] = FT_PIX_CEIL_LONG( args[0] );
2958   }
2959 
2960 
<span class="line-modified">2961   /*************************************************************************/</span>
<span class="line-modified">2962   /*                                                                       */</span>
<span class="line-modified">2963   /* RS[]:         Read Store                                              */</span>
<span class="line-modified">2964   /* Opcode range: 0x43                                                    */</span>
<span class="line-modified">2965   /* Stack:        uint32 --&gt; uint32                                       */</span>
<span class="line-modified">2966   /*                                                                       */</span>
2967   static void
2968   Ins_RS( TT_ExecContext  exc,
2969           FT_Long*        args )
2970   {
2971     FT_ULong  I = (FT_ULong)args[0];
2972 
2973 
2974     if ( BOUNDSL( I, exc-&gt;storeSize ) )
2975     {
2976       if ( exc-&gt;pedantic_hinting )
2977         ARRAY_BOUND_ERROR;
2978       else
2979         args[0] = 0;
2980     }
2981     else
2982     {
2983 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
2984       /* subpixel hinting - avoid Typeman Dstroke and */
2985       /* IStroke and Vacuform rounds                  */
2986       if ( SUBPIXEL_HINTING_INFINALITY                 &amp;&amp;
2987            exc-&gt;ignore_x_mode                          &amp;&amp;
2988            ( ( I == 24                             &amp;&amp;
2989                ( exc-&gt;face-&gt;sph_found_func_flags &amp;
2990                  ( SPH_FDEF_SPACING_1 |
2991                    SPH_FDEF_SPACING_2 )          ) ) ||
2992              ( I == 22                      &amp;&amp;
2993                ( exc-&gt;sph_in_func_flags   &amp;
2994                  SPH_FDEF_TYPEMAN_STROKES ) )        ||
2995              ( I == 8                              &amp;&amp;
2996                ( exc-&gt;face-&gt;sph_found_func_flags &amp;
2997                  SPH_FDEF_VACUFORM_ROUND_1       ) &amp;&amp;
2998                exc-&gt;iup_called                     ) ) )
2999         args[0] = 0;
3000       else
3001 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3002         args[0] = exc-&gt;storage[I];
3003     }
3004   }
3005 
3006 
<span class="line-modified">3007   /*************************************************************************/</span>
<span class="line-modified">3008   /*                                                                       */</span>
<span class="line-modified">3009   /* WS[]:         Write Store                                             */</span>
<span class="line-modified">3010   /* Opcode range: 0x42                                                    */</span>
<span class="line-modified">3011   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">3012   /*                                                                       */</span>
3013   static void
3014   Ins_WS( TT_ExecContext  exc,
3015           FT_Long*        args )
3016   {
3017     FT_ULong  I = (FT_ULong)args[0];
3018 
3019 
3020     if ( BOUNDSL( I, exc-&gt;storeSize ) )
3021     {
3022       if ( exc-&gt;pedantic_hinting )
3023         ARRAY_BOUND_ERROR;
3024     }
3025     else
3026       exc-&gt;storage[I] = args[1];
3027   }
3028 
3029 
<span class="line-modified">3030   /*************************************************************************/</span>
<span class="line-modified">3031   /*                                                                       */</span>
<span class="line-modified">3032   /* WCVTP[]:      Write CVT in Pixel units                                */</span>
<span class="line-modified">3033   /* Opcode range: 0x44                                                    */</span>
<span class="line-modified">3034   /* Stack:        f26.6 uint32 --&gt;                                        */</span>
<span class="line-modified">3035   /*                                                                       */</span>
3036   static void
3037   Ins_WCVTP( TT_ExecContext  exc,
3038              FT_Long*        args )
3039   {
3040     FT_ULong  I = (FT_ULong)args[0];
3041 
3042 
3043     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3044     {
3045       if ( exc-&gt;pedantic_hinting )
3046         ARRAY_BOUND_ERROR;
3047     }
3048     else
3049       exc-&gt;func_write_cvt( exc, I, args[1] );
3050   }
3051 
3052 
<span class="line-modified">3053   /*************************************************************************/</span>
<span class="line-modified">3054   /*                                                                       */</span>
<span class="line-modified">3055   /* WCVTF[]:      Write CVT in Funits                                     */</span>
<span class="line-modified">3056   /* Opcode range: 0x70                                                    */</span>
<span class="line-modified">3057   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">3058   /*                                                                       */</span>
3059   static void
3060   Ins_WCVTF( TT_ExecContext  exc,
3061              FT_Long*        args )
3062   {
3063     FT_ULong  I = (FT_ULong)args[0];
3064 
3065 
3066     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3067     {
3068       if ( exc-&gt;pedantic_hinting )
3069         ARRAY_BOUND_ERROR;
3070     }
3071     else
3072       exc-&gt;cvt[I] = FT_MulFix( args[1], exc-&gt;tt_metrics.scale );
3073   }
3074 
3075 
<span class="line-modified">3076   /*************************************************************************/</span>
<span class="line-modified">3077   /*                                                                       */</span>
<span class="line-modified">3078   /* RCVT[]:       Read CVT                                                */</span>
<span class="line-modified">3079   /* Opcode range: 0x45                                                    */</span>
<span class="line-modified">3080   /* Stack:        uint32 --&gt; f26.6                                        */</span>
<span class="line-modified">3081   /*                                                                       */</span>
3082   static void
3083   Ins_RCVT( TT_ExecContext  exc,
3084             FT_Long*        args )
3085   {
3086     FT_ULong  I = (FT_ULong)args[0];
3087 
3088 
3089     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3090     {
3091       if ( exc-&gt;pedantic_hinting )
3092         ARRAY_BOUND_ERROR;
3093       else
3094         args[0] = 0;
3095     }
3096     else
3097       args[0] = exc-&gt;func_read_cvt( exc, I );
3098   }
3099 
3100 
<span class="line-modified">3101   /*************************************************************************/</span>
<span class="line-modified">3102   /*                                                                       */</span>
<span class="line-modified">3103   /* AA[]:         Adjust Angle                                            */</span>
<span class="line-modified">3104   /* Opcode range: 0x7F                                                    */</span>
<span class="line-modified">3105   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">3106   /*                                                                       */</span>
3107   static void
3108   Ins_AA( void )
3109   {
3110     /* intentionally no longer supported */
3111   }
3112 
3113 
<span class="line-modified">3114   /*************************************************************************/</span>
<span class="line-modified">3115   /*                                                                       */</span>
<span class="line-modified">3116   /* DEBUG[]:      DEBUG.  Unsupported.                                    */</span>
<span class="line-modified">3117   /* Opcode range: 0x4F                                                    */</span>
<span class="line-modified">3118   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">3119   /*                                                                       */</span>
<span class="line-modified">3120   /* Note: The original instruction pops a value from the stack.           */</span>
<span class="line-modified">3121   /*                                                                       */</span>
3122   static void
3123   Ins_DEBUG( TT_ExecContext  exc )
3124   {
3125     exc-&gt;error = FT_THROW( Debug_OpCode );
3126   }
3127 
3128 
<span class="line-modified">3129   /*************************************************************************/</span>
<span class="line-modified">3130   /*                                                                       */</span>
<span class="line-modified">3131   /* ROUND[ab]:    ROUND value                                             */</span>
<span class="line-modified">3132   /* Opcode range: 0x68-0x6B                                               */</span>
<span class="line-modified">3133   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">3134   /*                                                                       */</span>
3135   static void
3136   Ins_ROUND( TT_ExecContext  exc,
3137              FT_Long*        args )
3138   {
3139     args[0] = exc-&gt;func_round(
3140                 exc,
3141                 args[0],
3142                 exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x68] );
3143   }
3144 
3145 
<span class="line-modified">3146   /*************************************************************************/</span>
<span class="line-modified">3147   /*                                                                       */</span>
<span class="line-modified">3148   /* NROUND[ab]:   No ROUNDing of value                                    */</span>
<span class="line-modified">3149   /* Opcode range: 0x6C-0x6F                                               */</span>
<span class="line-modified">3150   /* Stack:        f26.6 --&gt; f26.6                                         */</span>
<span class="line-modified">3151   /*                                                                       */</span>
3152   static void
3153   Ins_NROUND( TT_ExecContext  exc,
3154               FT_Long*        args )
3155   {
3156     args[0] = Round_None(
3157                 exc,
3158                 args[0],
3159                 exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x6C] );
3160   }
3161 
3162 
<span class="line-modified">3163   /*************************************************************************/</span>
<span class="line-modified">3164   /*                                                                       */</span>
<span class="line-modified">3165   /* MAX[]:        MAXimum                                                 */</span>
<span class="line-modified">3166   /* Opcode range: 0x8B                                                    */</span>
<span class="line-modified">3167   /* Stack:        int32? int32? --&gt; int32                                 */</span>
<span class="line-modified">3168   /*                                                                       */</span>
3169   static void
3170   Ins_MAX( FT_Long*  args )
3171   {
3172     if ( args[1] &gt; args[0] )
3173       args[0] = args[1];
3174   }
3175 
3176 
<span class="line-modified">3177   /*************************************************************************/</span>
<span class="line-modified">3178   /*                                                                       */</span>
<span class="line-modified">3179   /* MIN[]:        MINimum                                                 */</span>
<span class="line-modified">3180   /* Opcode range: 0x8C                                                    */</span>
<span class="line-modified">3181   /* Stack:        int32? int32? --&gt; int32                                 */</span>
<span class="line-modified">3182   /*                                                                       */</span>
3183   static void
3184   Ins_MIN( FT_Long*  args )
3185   {
3186     if ( args[1] &lt; args[0] )
3187       args[0] = args[1];
3188   }
3189 
3190 
<span class="line-modified">3191   /*************************************************************************/</span>
<span class="line-modified">3192   /*                                                                       */</span>
<span class="line-modified">3193   /* MINDEX[]:     Move INDEXed element                                    */</span>
<span class="line-modified">3194   /* Opcode range: 0x26                                                    */</span>
<span class="line-modified">3195   /* Stack:        int32? --&gt; StkElt                                       */</span>
<span class="line-modified">3196   /*                                                                       */</span>
3197   static void
3198   Ins_MINDEX( TT_ExecContext  exc,
3199               FT_Long*        args )
3200   {
3201     FT_Long  L, K;
3202 
3203 
3204     L = args[0];
3205 
3206     if ( L &lt;= 0 || L &gt; exc-&gt;args )
3207     {
3208       if ( exc-&gt;pedantic_hinting )
3209         exc-&gt;error = FT_THROW( Invalid_Reference );
3210     }
3211     else
3212     {
3213       K = exc-&gt;stack[exc-&gt;args - L];
3214 
3215       FT_ARRAY_MOVE( &amp;exc-&gt;stack[exc-&gt;args - L    ],
3216                      &amp;exc-&gt;stack[exc-&gt;args - L + 1],
3217                      ( L - 1 ) );
3218 
3219       exc-&gt;stack[exc-&gt;args - 1] = K;
3220     }
3221   }
3222 
3223 
<span class="line-modified">3224   /*************************************************************************/</span>
<span class="line-modified">3225   /*                                                                       */</span>
<span class="line-modified">3226   /* CINDEX[]:     Copy INDEXed element                                    */</span>
<span class="line-modified">3227   /* Opcode range: 0x25                                                    */</span>
<span class="line-modified">3228   /* Stack:        int32 --&gt; StkElt                                        */</span>
<span class="line-modified">3229   /*                                                                       */</span>
3230   static void
3231   Ins_CINDEX( TT_ExecContext  exc,
3232               FT_Long*        args )
3233   {
3234     FT_Long  L;
3235 
3236 
3237     L = args[0];
3238 
3239     if ( L &lt;= 0 || L &gt; exc-&gt;args )
3240     {
3241       if ( exc-&gt;pedantic_hinting )
3242         exc-&gt;error = FT_THROW( Invalid_Reference );
3243       args[0] = 0;
3244     }
3245     else
3246       args[0] = exc-&gt;stack[exc-&gt;args - L];
3247   }
3248 
3249 
<span class="line-modified">3250   /*************************************************************************/</span>
<span class="line-modified">3251   /*                                                                       */</span>
<span class="line-modified">3252   /* ROLL[]:       ROLL top three elements                                 */</span>
<span class="line-modified">3253   /* Opcode range: 0x8A                                                    */</span>
<span class="line-modified">3254   /* Stack:        3 * StkElt --&gt; 3 * StkElt                               */</span>
<span class="line-modified">3255   /*                                                                       */</span>
3256   static void
3257   Ins_ROLL( FT_Long*  args )
3258   {
3259     FT_Long  A, B, C;
3260 
3261 
3262     A = args[2];
3263     B = args[1];
3264     C = args[0];
3265 
3266     args[2] = C;
3267     args[1] = A;
3268     args[0] = B;
3269   }
3270 
3271 
<span class="line-modified">3272   /*************************************************************************/</span>
<span class="line-modified">3273   /*                                                                       */</span>
<span class="line-modified">3274   /* MANAGING THE FLOW OF CONTROL                                          */</span>
<span class="line-modified">3275   /*                                                                       */</span>
<span class="line-modified">3276   /*************************************************************************/</span>
3277 
3278 
<span class="line-modified">3279   /*************************************************************************/</span>
<span class="line-modified">3280   /*                                                                       */</span>
<span class="line-modified">3281   /* SLOOP[]:      Set LOOP variable                                       */</span>
<span class="line-modified">3282   /* Opcode range: 0x17                                                    */</span>
<span class="line-modified">3283   /* Stack:        int32? --&gt;                                              */</span>
<span class="line-modified">3284   /*                                                                       */</span>
3285   static void
3286   Ins_SLOOP( TT_ExecContext  exc,
3287              FT_Long*        args )
3288   {
3289     if ( args[0] &lt; 0 )
3290       exc-&gt;error = FT_THROW( Bad_Argument );
3291     else
3292     {
3293       /* we heuristically limit the number of loops to 16 bits */
3294       exc-&gt;GS.loop = args[0] &gt; 0xFFFFL ? 0xFFFFL : args[0];
3295     }
3296   }
3297 
3298 
3299   static FT_Bool
3300   SkipCode( TT_ExecContext  exc )
3301   {
3302     exc-&gt;IP += exc-&gt;length;
3303 
3304     if ( exc-&gt;IP &lt; exc-&gt;codeSize )
</pre>
<hr />
<pre>
3306       exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];
3307 
3308       exc-&gt;length = opcode_length[exc-&gt;opcode];
3309       if ( exc-&gt;length &lt; 0 )
3310       {
3311         if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )
3312           goto Fail_Overflow;
3313         exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];
3314       }
3315 
3316       if ( exc-&gt;IP + exc-&gt;length &lt;= exc-&gt;codeSize )
3317         return SUCCESS;
3318     }
3319 
3320   Fail_Overflow:
3321     exc-&gt;error = FT_THROW( Code_Overflow );
3322     return FAILURE;
3323   }
3324 
3325 
<span class="line-modified">3326   /*************************************************************************/</span>
<span class="line-modified">3327   /*                                                                       */</span>
<span class="line-modified">3328   /* IF[]:         IF test                                                 */</span>
<span class="line-modified">3329   /* Opcode range: 0x58                                                    */</span>
<span class="line-modified">3330   /* Stack:        StkElt --&gt;                                              */</span>
<span class="line-modified">3331   /*                                                                       */</span>
3332   static void
3333   Ins_IF( TT_ExecContext  exc,
3334           FT_Long*        args )
3335   {
3336     FT_Int   nIfs;
3337     FT_Bool  Out;
3338 
3339 
3340     if ( args[0] != 0 )
3341       return;
3342 
3343     nIfs = 1;
3344     Out = 0;
3345 
3346     do
3347     {
3348       if ( SkipCode( exc ) == FAILURE )
3349         return;
3350 
3351       switch ( exc-&gt;opcode )
3352       {
3353       case 0x58:      /* IF */
3354         nIfs++;
3355         break;
3356 
3357       case 0x1B:      /* ELSE */
3358         Out = FT_BOOL( nIfs == 1 );
3359         break;
3360 
3361       case 0x59:      /* EIF */
3362         nIfs--;
3363         Out = FT_BOOL( nIfs == 0 );
3364         break;
3365       }
3366     } while ( Out == 0 );
3367   }
3368 
3369 
<span class="line-modified">3370   /*************************************************************************/</span>
<span class="line-modified">3371   /*                                                                       */</span>
<span class="line-modified">3372   /* ELSE[]:       ELSE                                                    */</span>
<span class="line-modified">3373   /* Opcode range: 0x1B                                                    */</span>
<span class="line-modified">3374   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">3375   /*                                                                       */</span>
3376   static void
3377   Ins_ELSE( TT_ExecContext  exc )
3378   {
3379     FT_Int  nIfs;
3380 
3381 
3382     nIfs = 1;
3383 
3384     do
3385     {
3386       if ( SkipCode( exc ) == FAILURE )
3387         return;
3388 
3389       switch ( exc-&gt;opcode )
3390       {
3391       case 0x58:    /* IF */
3392         nIfs++;
3393         break;
3394 
3395       case 0x59:    /* EIF */
3396         nIfs--;
3397         break;
3398       }
3399     } while ( nIfs != 0 );
3400   }
3401 
3402 
<span class="line-modified">3403   /*************************************************************************/</span>
<span class="line-modified">3404   /*                                                                       */</span>
<span class="line-modified">3405   /* EIF[]:        End IF                                                  */</span>
<span class="line-modified">3406   /* Opcode range: 0x59                                                    */</span>
<span class="line-modified">3407   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">3408   /*                                                                       */</span>
3409   static void
3410   Ins_EIF( void )
3411   {
3412     /* nothing to do */
3413   }
3414 
3415 
<span class="line-modified">3416   /*************************************************************************/</span>
<span class="line-modified">3417   /*                                                                       */</span>
<span class="line-modified">3418   /* JMPR[]:       JuMP Relative                                           */</span>
<span class="line-modified">3419   /* Opcode range: 0x1C                                                    */</span>
<span class="line-modified">3420   /* Stack:        int32 --&gt;                                               */</span>
<span class="line-modified">3421   /*                                                                       */</span>
3422   static void
3423   Ins_JMPR( TT_ExecContext  exc,
3424             FT_Long*        args )
3425   {
3426     if ( args[0] == 0 &amp;&amp; exc-&gt;args == 0 )
3427     {
3428       exc-&gt;error = FT_THROW( Bad_Argument );
3429       return;
3430     }
3431 
3432     exc-&gt;IP += args[0];
3433     if ( exc-&gt;IP &lt; 0                                             ||
3434          ( exc-&gt;callTop &gt; 0                                    &amp;&amp;
3435            exc-&gt;IP &gt; exc-&gt;callStack[exc-&gt;callTop - 1].Def-&gt;end ) )
3436     {
3437       exc-&gt;error = FT_THROW( Bad_Argument );
3438       return;
3439     }
3440 
3441     exc-&gt;step_ins = FALSE;
3442 
3443     if ( args[0] &lt; 0 )
3444     {
3445       if ( ++exc-&gt;neg_jump_counter &gt; exc-&gt;neg_jump_counter_max )
3446         exc-&gt;error = FT_THROW( Execution_Too_Long );
3447     }
3448   }
3449 
3450 
<span class="line-modified">3451   /*************************************************************************/</span>
<span class="line-modified">3452   /*                                                                       */</span>
<span class="line-modified">3453   /* JROT[]:       Jump Relative On True                                   */</span>
<span class="line-modified">3454   /* Opcode range: 0x78                                                    */</span>
<span class="line-modified">3455   /* Stack:        StkElt int32 --&gt;                                        */</span>
<span class="line-modified">3456   /*                                                                       */</span>
3457   static void
3458   Ins_JROT( TT_ExecContext  exc,
3459             FT_Long*        args )
3460   {
3461     if ( args[1] != 0 )
3462       Ins_JMPR( exc, args );
3463   }
3464 
3465 
<span class="line-modified">3466   /*************************************************************************/</span>
<span class="line-modified">3467   /*                                                                       */</span>
<span class="line-modified">3468   /* JROF[]:       Jump Relative On False                                  */</span>
<span class="line-modified">3469   /* Opcode range: 0x79                                                    */</span>
<span class="line-modified">3470   /* Stack:        StkElt int32 --&gt;                                        */</span>
<span class="line-modified">3471   /*                                                                       */</span>
3472   static void
3473   Ins_JROF( TT_ExecContext  exc,
3474             FT_Long*        args )
3475   {
3476     if ( args[1] == 0 )
3477       Ins_JMPR( exc, args );
3478   }
3479 
3480 
<span class="line-modified">3481   /*************************************************************************/</span>
<span class="line-modified">3482   /*                                                                       */</span>
<span class="line-modified">3483   /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */</span>
<span class="line-modified">3484   /*                                                                       */</span>
<span class="line-modified">3485   /*************************************************************************/</span>
3486 
3487 
<span class="line-modified">3488   /*************************************************************************/</span>
<span class="line-modified">3489   /*                                                                       */</span>
<span class="line-modified">3490   /* FDEF[]:       Function DEFinition                                     */</span>
<span class="line-modified">3491   /* Opcode range: 0x2C                                                    */</span>
<span class="line-modified">3492   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">3493   /*                                                                       */</span>
3494   static void
3495   Ins_FDEF( TT_ExecContext  exc,
3496             FT_Long*        args )
3497   {
3498     FT_ULong       n;
3499     TT_DefRecord*  rec;
3500     TT_DefRecord*  limit;
3501 
3502 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
3503     /* arguments to opcodes are skipped by `SKIP_Code&#39; */
3504     FT_Byte    opcode_pattern[9][12] = {
3505                  /* #0 inline delta function 1 */
3506                  {
3507                    0x4B, /* PPEM    */
3508                    0x53, /* GTEQ    */
3509                    0x23, /* SWAP    */
3510                    0x4B, /* PPEM    */
3511                    0x51, /* LTEQ    */
3512                    0x5A, /* AND     */
3513                    0x58, /* IF      */
</pre>
<hr />
<pre>
3771             ( exc-&gt;face-&gt;sph_found_func_flags &amp; SPH_FDEF_INLINE_DELTA_2 ) );
3772       }
3773 
3774 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3775 
3776       switch ( exc-&gt;opcode )
3777       {
3778       case 0x89:    /* IDEF */
3779       case 0x2C:    /* FDEF */
3780         exc-&gt;error = FT_THROW( Nested_DEFS );
3781         return;
3782 
3783       case 0x2D:   /* ENDF */
3784         rec-&gt;end = exc-&gt;IP;
3785         return;
3786       }
3787     }
3788   }
3789 
3790 
<span class="line-modified">3791   /*************************************************************************/</span>
<span class="line-modified">3792   /*                                                                       */</span>
<span class="line-modified">3793   /* ENDF[]:       END Function definition                                 */</span>
<span class="line-modified">3794   /* Opcode range: 0x2D                                                    */</span>
<span class="line-modified">3795   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">3796   /*                                                                       */</span>
3797   static void
3798   Ins_ENDF( TT_ExecContext  exc )
3799   {
3800     TT_CallRec*  pRec;
3801 
3802 
3803 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
3804     exc-&gt;sph_in_func_flags = 0x0000;
3805 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3806 
3807     if ( exc-&gt;callTop &lt;= 0 )     /* We encountered an ENDF without a call */
3808     {
3809       exc-&gt;error = FT_THROW( ENDF_In_Exec_Stream );
3810       return;
3811     }
3812 
3813     exc-&gt;callTop--;
3814 
3815     pRec = &amp;exc-&gt;callStack[exc-&gt;callTop];
3816 
</pre>
<hr />
<pre>
3820 
3821     if ( pRec-&gt;Cur_Count &gt; 0 )
3822     {
3823       exc-&gt;callTop++;
3824       exc-&gt;IP = pRec-&gt;Def-&gt;start;
3825     }
3826     else
3827       /* Loop through the current function */
3828       Ins_Goto_CodeRange( exc, pRec-&gt;Caller_Range, pRec-&gt;Caller_IP );
3829 
3830     /* Exit the current call frame.                      */
3831 
3832     /* NOTE: If the last instruction of a program is a   */
3833     /*       CALL or LOOPCALL, the return address is     */
3834     /*       always out of the code range.  This is a    */
3835     /*       valid address, and it is why we do not test */
3836     /*       the result of Ins_Goto_CodeRange() here!    */
3837   }
3838 
3839 
<span class="line-modified">3840   /*************************************************************************/</span>
<span class="line-modified">3841   /*                                                                       */</span>
<span class="line-modified">3842   /* CALL[]:       CALL function                                           */</span>
<span class="line-modified">3843   /* Opcode range: 0x2B                                                    */</span>
<span class="line-modified">3844   /* Stack:        uint32? --&gt;                                             */</span>
<span class="line-modified">3845   /*                                                                       */</span>
3846   static void
3847   Ins_CALL( TT_ExecContext  exc,
3848             FT_Long*        args )
3849   {
3850     FT_ULong       F;
3851     TT_CallRec*    pCrec;
3852     TT_DefRecord*  def;
3853 
3854 
3855     /* first of all, check the index */
3856 
3857     F = (FT_ULong)args[0];
3858     if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )
3859       goto Fail;
3860 
3861     /* Except for some old Apple fonts, all functions in a TrueType */
3862     /* font are defined in increasing order, starting from 0.  This */
3863     /* means that we normally have                                  */
3864     /*                                                              */
3865     /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */
</pre>
<hr />
<pre>
3909     pCrec = exc-&gt;callStack + exc-&gt;callTop;
3910 
3911     pCrec-&gt;Caller_Range = exc-&gt;curRange;
3912     pCrec-&gt;Caller_IP    = exc-&gt;IP + 1;
3913     pCrec-&gt;Cur_Count    = 1;
3914     pCrec-&gt;Def          = def;
3915 
3916     exc-&gt;callTop++;
3917 
3918     Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
3919 
3920     exc-&gt;step_ins = FALSE;
3921 
3922     return;
3923 
3924   Fail:
3925     exc-&gt;error = FT_THROW( Invalid_Reference );
3926   }
3927 
3928 
<span class="line-modified">3929   /*************************************************************************/</span>
<span class="line-modified">3930   /*                                                                       */</span>
<span class="line-modified">3931   /* LOOPCALL[]:   LOOP and CALL function                                  */</span>
<span class="line-modified">3932   /* Opcode range: 0x2A                                                    */</span>
<span class="line-modified">3933   /* Stack:        uint32? Eint16? --&gt;                                     */</span>
<span class="line-modified">3934   /*                                                                       */</span>
3935   static void
3936   Ins_LOOPCALL( TT_ExecContext  exc,
3937                 FT_Long*        args )
3938   {
3939     FT_ULong       F;
3940     TT_CallRec*    pCrec;
3941     TT_DefRecord*  def;
3942 
3943 
3944     /* first of all, check the index */
3945     F = (FT_ULong)args[1];
3946     if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )
3947       goto Fail;
3948 
3949     /* Except for some old Apple fonts, all functions in a TrueType */
3950     /* font are defined in increasing order, starting from 0.  This */
3951     /* means that we normally have                                  */
3952     /*                                                              */
3953     /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */
3954     /*    exc-&gt;FDefs[n].opc == n for n in 0..exc-&gt;maxFunc           */
</pre>
<hr />
<pre>
4002       pCrec-&gt;Def          = def;
4003 
4004       exc-&gt;callTop++;
4005 
4006       Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
4007 
4008       exc-&gt;step_ins = FALSE;
4009 
4010       exc-&gt;loopcall_counter += (FT_ULong)args[0];
4011       if ( exc-&gt;loopcall_counter &gt; exc-&gt;loopcall_counter_max )
4012         exc-&gt;error = FT_THROW( Execution_Too_Long );
4013     }
4014 
4015     return;
4016 
4017   Fail:
4018     exc-&gt;error = FT_THROW( Invalid_Reference );
4019   }
4020 
4021 
<span class="line-modified">4022   /*************************************************************************/</span>
<span class="line-modified">4023   /*                                                                       */</span>
<span class="line-modified">4024   /* IDEF[]:       Instruction DEFinition                                  */</span>
<span class="line-modified">4025   /* Opcode range: 0x89                                                    */</span>
<span class="line-modified">4026   /* Stack:        Eint8 --&gt;                                               */</span>
<span class="line-modified">4027   /*                                                                       */</span>
4028   static void
4029   Ins_IDEF( TT_ExecContext  exc,
4030             FT_Long*        args )
4031   {
4032     TT_DefRecord*  def;
4033     TT_DefRecord*  limit;
4034 
4035 
4036     /* we enable IDEF only in `prep&#39; or `fpgm&#39; */
4037     if ( exc-&gt;curRange == tt_coderange_glyph )
4038     {
4039       exc-&gt;error = FT_THROW( DEF_In_Glyf_Bytecode );
4040       return;
4041     }
4042 
4043     /*  First of all, look for the same function in our table */
4044 
4045     def   = exc-&gt;IDefs;
4046     limit = def + exc-&gt;numIDefs;
4047 
</pre>
<hr />
<pre>
4077 
4078     /* Now skip the whole function definition. */
4079     /* We don&#39;t allow nested IDEFs &amp; FDEFs.    */
4080 
4081     while ( SkipCode( exc ) == SUCCESS )
4082     {
4083       switch ( exc-&gt;opcode )
4084       {
4085       case 0x89:   /* IDEF */
4086       case 0x2C:   /* FDEF */
4087         exc-&gt;error = FT_THROW( Nested_DEFS );
4088         return;
4089       case 0x2D:   /* ENDF */
4090         def-&gt;end = exc-&gt;IP;
4091         return;
4092       }
4093     }
4094   }
4095 
4096 
<span class="line-modified">4097   /*************************************************************************/</span>
<span class="line-modified">4098   /*                                                                       */</span>
<span class="line-modified">4099   /* PUSHING DATA ONTO THE INTERPRETER STACK                               */</span>
<span class="line-modified">4100   /*                                                                       */</span>
<span class="line-modified">4101   /*************************************************************************/</span>
4102 
4103 
<span class="line-modified">4104   /*************************************************************************/</span>
<span class="line-modified">4105   /*                                                                       */</span>
<span class="line-modified">4106   /* NPUSHB[]:     PUSH N Bytes                                            */</span>
<span class="line-modified">4107   /* Opcode range: 0x40                                                    */</span>
<span class="line-modified">4108   /* Stack:        --&gt; uint32...                                           */</span>
<span class="line-modified">4109   /*                                                                       */</span>
4110   static void
4111   Ins_NPUSHB( TT_ExecContext  exc,
4112               FT_Long*        args )
4113   {
4114     FT_UShort  L, K;
4115 
4116 
4117     L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];
4118 
4119     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4120     {
4121       exc-&gt;error = FT_THROW( Stack_Overflow );
4122       return;
4123     }
4124 
4125     for ( K = 1; K &lt;= L; K++ )
4126       args[K - 1] = exc-&gt;code[exc-&gt;IP + K + 1];
4127 
4128     exc-&gt;new_top += L;
4129   }
4130 
4131 
<span class="line-modified">4132   /*************************************************************************/</span>
<span class="line-modified">4133   /*                                                                       */</span>
<span class="line-modified">4134   /* NPUSHW[]:     PUSH N Words                                            */</span>
<span class="line-modified">4135   /* Opcode range: 0x41                                                    */</span>
<span class="line-modified">4136   /* Stack:        --&gt; int32...                                            */</span>
<span class="line-modified">4137   /*                                                                       */</span>
4138   static void
4139   Ins_NPUSHW( TT_ExecContext  exc,
4140               FT_Long*        args )
4141   {
4142     FT_UShort  L, K;
4143 
4144 
4145     L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];
4146 
4147     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4148     {
4149       exc-&gt;error = FT_THROW( Stack_Overflow );
4150       return;
4151     }
4152 
4153     exc-&gt;IP += 2;
4154 
4155     for ( K = 0; K &lt; L; K++ )
4156       args[K] = GetShortIns( exc );
4157 
4158     exc-&gt;step_ins = FALSE;
4159     exc-&gt;new_top += L;
4160   }
4161 
4162 
<span class="line-modified">4163   /*************************************************************************/</span>
<span class="line-modified">4164   /*                                                                       */</span>
<span class="line-modified">4165   /* PUSHB[abc]:   PUSH Bytes                                              */</span>
<span class="line-modified">4166   /* Opcode range: 0xB0-0xB7                                               */</span>
<span class="line-modified">4167   /* Stack:        --&gt; uint32...                                           */</span>
<span class="line-modified">4168   /*                                                                       */</span>
4169   static void
4170   Ins_PUSHB( TT_ExecContext  exc,
4171              FT_Long*        args )
4172   {
4173     FT_UShort  L, K;
4174 
4175 
4176     L = (FT_UShort)( exc-&gt;opcode - 0xB0 + 1 );
4177 
4178     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4179     {
4180       exc-&gt;error = FT_THROW( Stack_Overflow );
4181       return;
4182     }
4183 
4184     for ( K = 1; K &lt;= L; K++ )
4185       args[K - 1] = exc-&gt;code[exc-&gt;IP + K];
4186   }
4187 
4188 
<span class="line-modified">4189   /*************************************************************************/</span>
<span class="line-modified">4190   /*                                                                       */</span>
<span class="line-modified">4191   /* PUSHW[abc]:   PUSH Words                                              */</span>
<span class="line-modified">4192   /* Opcode range: 0xB8-0xBF                                               */</span>
<span class="line-modified">4193   /* Stack:        --&gt; int32...                                            */</span>
<span class="line-modified">4194   /*                                                                       */</span>
4195   static void
4196   Ins_PUSHW( TT_ExecContext  exc,
4197              FT_Long*        args )
4198   {
4199     FT_UShort  L, K;
4200 
4201 
4202     L = (FT_UShort)( exc-&gt;opcode - 0xB8 + 1 );
4203 
4204     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4205     {
4206       exc-&gt;error = FT_THROW( Stack_Overflow );
4207       return;
4208     }
4209 
4210     exc-&gt;IP++;
4211 
4212     for ( K = 0; K &lt; L; K++ )
4213       args[K] = GetShortIns( exc );
4214 
4215     exc-&gt;step_ins = FALSE;
4216   }
4217 
4218 
<span class="line-modified">4219   /*************************************************************************/</span>
<span class="line-modified">4220   /*                                                                       */</span>
<span class="line-modified">4221   /* MANAGING THE GRAPHICS STATE                                           */</span>
<span class="line-modified">4222   /*                                                                       */</span>
<span class="line-modified">4223   /*************************************************************************/</span>
4224 
4225 
4226   static FT_Bool
4227   Ins_SxVTL( TT_ExecContext  exc,
4228              FT_UShort       aIdx1,
4229              FT_UShort       aIdx2,
4230              FT_UnitVector*  Vec )
4231   {
4232     FT_Long     A, B, C;
4233     FT_Vector*  p1;
4234     FT_Vector*  p2;
4235 
4236     FT_Byte  opcode = exc-&gt;opcode;
4237 
4238 
4239     if ( BOUNDS( aIdx1, exc-&gt;zp2.n_points ) ||
4240          BOUNDS( aIdx2, exc-&gt;zp1.n_points ) )
4241     {
4242       if ( exc-&gt;pedantic_hinting )
4243         exc-&gt;error = FT_THROW( Invalid_Reference );
</pre>
<hr />
<pre>
4257 
4258     if ( A == 0 &amp;&amp; B == 0 )
4259     {
4260       A      = 0x4000;
4261       opcode = 0;
4262     }
4263 
4264     if ( ( opcode &amp; 1 ) != 0 )
4265     {
4266       C = B;   /* counter clockwise rotation */
4267       B = A;
4268       A = NEG_LONG( C );
4269     }
4270 
4271     Normalize( A, B, Vec );
4272 
4273     return SUCCESS;
4274   }
4275 
4276 
<span class="line-modified">4277   /*************************************************************************/</span>
<span class="line-modified">4278   /*                                                                       */</span>
<span class="line-modified">4279   /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */</span>
<span class="line-modified">4280   /* Opcode range: 0x00-0x01                                               */</span>
<span class="line-modified">4281   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4282   /*                                                                       */</span>
<span class="line-modified">4283   /* SPvTCA[a]:    Set PVector to Coordinate Axis                          */</span>
<span class="line-modified">4284   /* Opcode range: 0x02-0x03                                               */</span>
<span class="line-modified">4285   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4286   /*                                                                       */</span>
<span class="line-modified">4287   /* SFvTCA[a]:    Set FVector to Coordinate Axis                          */</span>
<span class="line-modified">4288   /* Opcode range: 0x04-0x05                                               */</span>
<span class="line-modified">4289   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4290   /*                                                                       */</span>
4291   static void
4292   Ins_SxyTCA( TT_ExecContext  exc )
4293   {
4294     FT_Short  AA, BB;
4295 
4296     FT_Byte  opcode = exc-&gt;opcode;
4297 
4298 
4299     AA = (FT_Short)( ( opcode &amp; 1 ) &lt;&lt; 14 );
4300     BB = (FT_Short)( AA ^ 0x4000 );
4301 
4302     if ( opcode &lt; 4 )
4303     {
4304       exc-&gt;GS.projVector.x = AA;
4305       exc-&gt;GS.projVector.y = BB;
4306 
4307       exc-&gt;GS.dualVector.x = AA;
4308       exc-&gt;GS.dualVector.y = BB;
4309     }
4310 
4311     if ( ( opcode &amp; 2 ) == 0 )
4312     {
4313       exc-&gt;GS.freeVector.x = AA;
4314       exc-&gt;GS.freeVector.y = BB;
4315     }
4316 
4317     Compute_Funcs( exc );
4318   }
4319 
4320 
<span class="line-modified">4321   /*************************************************************************/</span>
<span class="line-modified">4322   /*                                                                       */</span>
<span class="line-modified">4323   /* SPvTL[a]:     Set PVector To Line                                     */</span>
<span class="line-modified">4324   /* Opcode range: 0x06-0x07                                               */</span>
<span class="line-modified">4325   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">4326   /*                                                                       */</span>
4327   static void
4328   Ins_SPVTL( TT_ExecContext  exc,
4329              FT_Long*        args )
4330   {
4331     if ( Ins_SxVTL( exc,
4332                     (FT_UShort)args[1],
4333                     (FT_UShort)args[0],
4334                     &amp;exc-&gt;GS.projVector ) == SUCCESS )
4335     {
4336       exc-&gt;GS.dualVector = exc-&gt;GS.projVector;
4337       Compute_Funcs( exc );
4338     }
4339   }
4340 
4341 
<span class="line-modified">4342   /*************************************************************************/</span>
<span class="line-modified">4343   /*                                                                       */</span>
<span class="line-modified">4344   /* SFvTL[a]:     Set FVector To Line                                     */</span>
<span class="line-modified">4345   /* Opcode range: 0x08-0x09                                               */</span>
<span class="line-modified">4346   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">4347   /*                                                                       */</span>
4348   static void
4349   Ins_SFVTL( TT_ExecContext  exc,
4350              FT_Long*        args )
4351   {
4352     if ( Ins_SxVTL( exc,
4353                     (FT_UShort)args[1],
4354                     (FT_UShort)args[0],
4355                     &amp;exc-&gt;GS.freeVector ) == SUCCESS )
4356     {
4357       Compute_Funcs( exc );
4358     }
4359   }
4360 
4361 
<span class="line-modified">4362   /*************************************************************************/</span>
<span class="line-modified">4363   /*                                                                       */</span>
<span class="line-modified">4364   /* SFvTPv[]:     Set FVector To PVector                                  */</span>
<span class="line-modified">4365   /* Opcode range: 0x0E                                                    */</span>
<span class="line-modified">4366   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4367   /*                                                                       */</span>
4368   static void
4369   Ins_SFVTPV( TT_ExecContext  exc )
4370   {
4371     exc-&gt;GS.freeVector = exc-&gt;GS.projVector;
4372     Compute_Funcs( exc );
4373   }
4374 
4375 
<span class="line-modified">4376   /*************************************************************************/</span>
<span class="line-modified">4377   /*                                                                       */</span>
<span class="line-modified">4378   /* SPvFS[]:      Set PVector From Stack                                  */</span>
<span class="line-modified">4379   /* Opcode range: 0x0A                                                    */</span>
<span class="line-modified">4380   /* Stack:        f2.14 f2.14 --&gt;                                         */</span>
<span class="line-modified">4381   /*                                                                       */</span>
4382   static void
4383   Ins_SPVFS( TT_ExecContext  exc,
4384              FT_Long*        args )
4385   {
4386     FT_Short  S;
4387     FT_Long   X, Y;
4388 
4389 
4390     /* Only use low 16bits, then sign extend */
4391     S = (FT_Short)args[1];
4392     Y = (FT_Long)S;
4393     S = (FT_Short)args[0];
4394     X = (FT_Long)S;
4395 
4396     Normalize( X, Y, &amp;exc-&gt;GS.projVector );
4397 
4398     exc-&gt;GS.dualVector = exc-&gt;GS.projVector;
4399     Compute_Funcs( exc );
4400   }
4401 
4402 
<span class="line-modified">4403   /*************************************************************************/</span>
<span class="line-modified">4404   /*                                                                       */</span>
<span class="line-modified">4405   /* SFvFS[]:      Set FVector From Stack                                  */</span>
<span class="line-modified">4406   /* Opcode range: 0x0B                                                    */</span>
<span class="line-modified">4407   /* Stack:        f2.14 f2.14 --&gt;                                         */</span>
<span class="line-modified">4408   /*                                                                       */</span>
4409   static void
4410   Ins_SFVFS( TT_ExecContext  exc,
4411              FT_Long*        args )
4412   {
4413     FT_Short  S;
4414     FT_Long   X, Y;
4415 
4416 
4417     /* Only use low 16bits, then sign extend */
4418     S = (FT_Short)args[1];
4419     Y = (FT_Long)S;
4420     S = (FT_Short)args[0];
4421     X = S;
4422 
4423     Normalize( X, Y, &amp;exc-&gt;GS.freeVector );
4424     Compute_Funcs( exc );
4425   }
4426 
4427 
<span class="line-modified">4428   /*************************************************************************/</span>
<span class="line-modified">4429   /*                                                                       */</span>
<span class="line-modified">4430   /* GPv[]:        Get Projection Vector                                   */</span>
<span class="line-modified">4431   /* Opcode range: 0x0C                                                    */</span>
<span class="line-modified">4432   /* Stack:        ef2.14 --&gt; ef2.14                                       */</span>
<span class="line-modified">4433   /*                                                                       */</span>
4434   static void
4435   Ins_GPV( TT_ExecContext  exc,
4436            FT_Long*        args )
4437   {
4438     args[0] = exc-&gt;GS.projVector.x;
4439     args[1] = exc-&gt;GS.projVector.y;
4440   }
4441 
4442 
<span class="line-modified">4443   /*************************************************************************/</span>
<span class="line-modified">4444   /*                                                                       */</span>
<span class="line-modified">4445   /* GFv[]:        Get Freedom Vector                                      */</span>
<span class="line-modified">4446   /* Opcode range: 0x0D                                                    */</span>
<span class="line-modified">4447   /* Stack:        ef2.14 --&gt; ef2.14                                       */</span>
<span class="line-modified">4448   /*                                                                       */</span>
4449   static void
4450   Ins_GFV( TT_ExecContext  exc,
4451            FT_Long*        args )
4452   {
4453     args[0] = exc-&gt;GS.freeVector.x;
4454     args[1] = exc-&gt;GS.freeVector.y;
4455   }
4456 
4457 
<span class="line-modified">4458   /*************************************************************************/</span>
<span class="line-modified">4459   /*                                                                       */</span>
<span class="line-modified">4460   /* SRP0[]:       Set Reference Point 0                                   */</span>
<span class="line-modified">4461   /* Opcode range: 0x10                                                    */</span>
<span class="line-modified">4462   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4463   /*                                                                       */</span>
4464   static void
4465   Ins_SRP0( TT_ExecContext  exc,
4466             FT_Long*        args )
4467   {
4468     exc-&gt;GS.rp0 = (FT_UShort)args[0];
4469   }
4470 
4471 
<span class="line-modified">4472   /*************************************************************************/</span>
<span class="line-modified">4473   /*                                                                       */</span>
<span class="line-modified">4474   /* SRP1[]:       Set Reference Point 1                                   */</span>
<span class="line-modified">4475   /* Opcode range: 0x11                                                    */</span>
<span class="line-modified">4476   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4477   /*                                                                       */</span>
4478   static void
4479   Ins_SRP1( TT_ExecContext  exc,
4480             FT_Long*        args )
4481   {
4482     exc-&gt;GS.rp1 = (FT_UShort)args[0];
4483   }
4484 
4485 
<span class="line-modified">4486   /*************************************************************************/</span>
<span class="line-modified">4487   /*                                                                       */</span>
<span class="line-modified">4488   /* SRP2[]:       Set Reference Point 2                                   */</span>
<span class="line-modified">4489   /* Opcode range: 0x12                                                    */</span>
<span class="line-modified">4490   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4491   /*                                                                       */</span>
4492   static void
4493   Ins_SRP2( TT_ExecContext  exc,
4494             FT_Long*        args )
4495   {
4496     exc-&gt;GS.rp2 = (FT_UShort)args[0];
4497   }
4498 
4499 
<span class="line-modified">4500   /*************************************************************************/</span>
<span class="line-modified">4501   /*                                                                       */</span>
<span class="line-modified">4502   /* SMD[]:        Set Minimum Distance                                    */</span>
<span class="line-modified">4503   /* Opcode range: 0x1A                                                    */</span>
<span class="line-modified">4504   /* Stack:        f26.6 --&gt;                                               */</span>
<span class="line-modified">4505   /*                                                                       */</span>
4506   static void
4507   Ins_SMD( TT_ExecContext  exc,
4508            FT_Long*        args )
4509   {
4510     exc-&gt;GS.minimum_distance = args[0];
4511   }
4512 
4513 
<span class="line-modified">4514   /*************************************************************************/</span>
<span class="line-modified">4515   /*                                                                       */</span>
<span class="line-modified">4516   /* SCVTCI[]:     Set Control Value Table Cut In                          */</span>
<span class="line-modified">4517   /* Opcode range: 0x1D                                                    */</span>
<span class="line-modified">4518   /* Stack:        f26.6 --&gt;                                               */</span>
<span class="line-modified">4519   /*                                                                       */</span>
4520   static void
4521   Ins_SCVTCI( TT_ExecContext  exc,
4522               FT_Long*        args )
4523   {
4524     exc-&gt;GS.control_value_cutin = (FT_F26Dot6)args[0];
4525   }
4526 
4527 
<span class="line-modified">4528   /*************************************************************************/</span>
<span class="line-modified">4529   /*                                                                       */</span>
<span class="line-modified">4530   /* SSWCI[]:      Set Single Width Cut In                                 */</span>
<span class="line-modified">4531   /* Opcode range: 0x1E                                                    */</span>
<span class="line-modified">4532   /* Stack:        f26.6 --&gt;                                               */</span>
<span class="line-modified">4533   /*                                                                       */</span>
4534   static void
4535   Ins_SSWCI( TT_ExecContext  exc,
4536              FT_Long*        args )
4537   {
4538     exc-&gt;GS.single_width_cutin = (FT_F26Dot6)args[0];
4539   }
4540 
4541 
<span class="line-modified">4542   /*************************************************************************/</span>
<span class="line-modified">4543   /*                                                                       */</span>
<span class="line-modified">4544   /* SSW[]:        Set Single Width                                        */</span>
<span class="line-modified">4545   /* Opcode range: 0x1F                                                    */</span>
<span class="line-modified">4546   /* Stack:        int32? --&gt;                                              */</span>
<span class="line-modified">4547   /*                                                                       */</span>
4548   static void
4549   Ins_SSW( TT_ExecContext  exc,
4550            FT_Long*        args )
4551   {
4552     exc-&gt;GS.single_width_value = FT_MulFix( args[0],
4553                                             exc-&gt;tt_metrics.scale );
4554   }
4555 
4556 
<span class="line-modified">4557   /*************************************************************************/</span>
<span class="line-modified">4558   /*                                                                       */</span>
<span class="line-modified">4559   /* FLIPON[]:     Set auto-FLIP to ON                                     */</span>
<span class="line-modified">4560   /* Opcode range: 0x4D                                                    */</span>
<span class="line-modified">4561   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4562   /*                                                                       */</span>
4563   static void
4564   Ins_FLIPON( TT_ExecContext  exc )
4565   {
4566     exc-&gt;GS.auto_flip = TRUE;
4567   }
4568 
4569 
<span class="line-modified">4570   /*************************************************************************/</span>
<span class="line-modified">4571   /*                                                                       */</span>
<span class="line-modified">4572   /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */</span>
<span class="line-modified">4573   /* Opcode range: 0x4E                                                    */</span>
<span class="line-modified">4574   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4575   /*                                                                       */</span>
4576   static void
4577   Ins_FLIPOFF( TT_ExecContext  exc )
4578   {
4579     exc-&gt;GS.auto_flip = FALSE;
4580   }
4581 
4582 
<span class="line-modified">4583   /*************************************************************************/</span>
<span class="line-modified">4584   /*                                                                       */</span>
<span class="line-modified">4585   /* SANGW[]:      Set ANGle Weight                                        */</span>
<span class="line-modified">4586   /* Opcode range: 0x7E                                                    */</span>
<span class="line-modified">4587   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4588   /*                                                                       */</span>
4589   static void
4590   Ins_SANGW( void )
4591   {
4592     /* instruction not supported anymore */
4593   }
4594 
4595 
<span class="line-modified">4596   /*************************************************************************/</span>
<span class="line-modified">4597   /*                                                                       */</span>
<span class="line-modified">4598   /* SDB[]:        Set Delta Base                                          */</span>
<span class="line-modified">4599   /* Opcode range: 0x5E                                                    */</span>
<span class="line-modified">4600   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4601   /*                                                                       */</span>
4602   static void
4603   Ins_SDB( TT_ExecContext  exc,
4604            FT_Long*        args )
4605   {
4606     exc-&gt;GS.delta_base = (FT_UShort)args[0];
4607   }
4608 
4609 
<span class="line-modified">4610   /*************************************************************************/</span>
<span class="line-modified">4611   /*                                                                       */</span>
<span class="line-modified">4612   /* SDS[]:        Set Delta Shift                                         */</span>
<span class="line-modified">4613   /* Opcode range: 0x5F                                                    */</span>
<span class="line-modified">4614   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4615   /*                                                                       */</span>
4616   static void
4617   Ins_SDS( TT_ExecContext  exc,
4618            FT_Long*        args )
4619   {
4620     if ( (FT_ULong)args[0] &gt; 6UL )
4621       exc-&gt;error = FT_THROW( Bad_Argument );
4622     else
4623       exc-&gt;GS.delta_shift = (FT_UShort)args[0];
4624   }
4625 
4626 
<span class="line-modified">4627   /*************************************************************************/</span>
<span class="line-modified">4628   /*                                                                       */</span>
<span class="line-modified">4629   /* RTHG[]:       Round To Half Grid                                      */</span>
<span class="line-modified">4630   /* Opcode range: 0x19                                                    */</span>
<span class="line-modified">4631   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4632   /*                                                                       */</span>
4633   static void
4634   Ins_RTHG( TT_ExecContext  exc )
4635   {
4636     exc-&gt;GS.round_state = TT_Round_To_Half_Grid;
4637     exc-&gt;func_round     = (TT_Round_Func)Round_To_Half_Grid;
4638   }
4639 
4640 
<span class="line-modified">4641   /*************************************************************************/</span>
<span class="line-modified">4642   /*                                                                       */</span>
<span class="line-modified">4643   /* RTG[]:        Round To Grid                                           */</span>
<span class="line-modified">4644   /* Opcode range: 0x18                                                    */</span>
<span class="line-modified">4645   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4646   /*                                                                       */</span>
4647   static void
4648   Ins_RTG( TT_ExecContext  exc )
4649   {
4650     exc-&gt;GS.round_state = TT_Round_To_Grid;
4651     exc-&gt;func_round     = (TT_Round_Func)Round_To_Grid;
4652   }
4653 
4654 
<span class="line-modified">4655   /*************************************************************************/</span>
<span class="line-modified">4656   /* RTDG[]:       Round To Double Grid                                    */</span>
<span class="line-modified">4657   /* Opcode range: 0x3D                                                    */</span>
<span class="line-modified">4658   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4659   /*                                                                       */</span>
4660   static void
4661   Ins_RTDG( TT_ExecContext  exc )
4662   {
4663     exc-&gt;GS.round_state = TT_Round_To_Double_Grid;
4664     exc-&gt;func_round     = (TT_Round_Func)Round_To_Double_Grid;
4665   }
4666 
4667 
<span class="line-modified">4668   /*************************************************************************/</span>
<span class="line-modified">4669   /* RUTG[]:       Round Up To Grid                                        */</span>
<span class="line-modified">4670   /* Opcode range: 0x7C                                                    */</span>
<span class="line-modified">4671   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4672   /*                                                                       */</span>
4673   static void
4674   Ins_RUTG( TT_ExecContext  exc )
4675   {
4676     exc-&gt;GS.round_state = TT_Round_Up_To_Grid;
4677     exc-&gt;func_round     = (TT_Round_Func)Round_Up_To_Grid;
4678   }
4679 
4680 
<span class="line-modified">4681   /*************************************************************************/</span>
<span class="line-modified">4682   /*                                                                       */</span>
<span class="line-modified">4683   /* RDTG[]:       Round Down To Grid                                      */</span>
<span class="line-modified">4684   /* Opcode range: 0x7D                                                    */</span>
<span class="line-modified">4685   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4686   /*                                                                       */</span>
4687   static void
4688   Ins_RDTG( TT_ExecContext  exc )
4689   {
4690     exc-&gt;GS.round_state = TT_Round_Down_To_Grid;
4691     exc-&gt;func_round     = (TT_Round_Func)Round_Down_To_Grid;
4692   }
4693 
4694 
<span class="line-modified">4695   /*************************************************************************/</span>
<span class="line-modified">4696   /*                                                                       */</span>
<span class="line-modified">4697   /* ROFF[]:       Round OFF                                               */</span>
<span class="line-modified">4698   /* Opcode range: 0x7A                                                    */</span>
<span class="line-modified">4699   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">4700   /*                                                                       */</span>
4701   static void
4702   Ins_ROFF( TT_ExecContext  exc )
4703   {
4704     exc-&gt;GS.round_state = TT_Round_Off;
4705     exc-&gt;func_round     = (TT_Round_Func)Round_None;
4706   }
4707 
4708 
<span class="line-modified">4709   /*************************************************************************/</span>
<span class="line-modified">4710   /*                                                                       */</span>
<span class="line-modified">4711   /* SROUND[]:     Super ROUND                                             */</span>
<span class="line-modified">4712   /* Opcode range: 0x76                                                    */</span>
<span class="line-modified">4713   /* Stack:        Eint8 --&gt;                                               */</span>
<span class="line-modified">4714   /*                                                                       */</span>
4715   static void
4716   Ins_SROUND( TT_ExecContext  exc,
4717               FT_Long*        args )
4718   {
4719     SetSuperRound( exc, 0x4000, args[0] );
4720 
4721     exc-&gt;GS.round_state = TT_Round_Super;
4722     exc-&gt;func_round     = (TT_Round_Func)Round_Super;
4723   }
4724 
4725 
<span class="line-modified">4726   /*************************************************************************/</span>
<span class="line-modified">4727   /*                                                                       */</span>
<span class="line-modified">4728   /* S45ROUND[]:   Super ROUND 45 degrees                                  */</span>
<span class="line-modified">4729   /* Opcode range: 0x77                                                    */</span>
<span class="line-modified">4730   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4731   /*                                                                       */</span>
4732   static void
4733   Ins_S45ROUND( TT_ExecContext  exc,
4734                 FT_Long*        args )
4735   {
4736     SetSuperRound( exc, 0x2D41, args[0] );
4737 
4738     exc-&gt;GS.round_state = TT_Round_Super_45;
4739     exc-&gt;func_round     = (TT_Round_Func)Round_Super_45;
4740   }
4741 
4742 
<span class="line-modified">4743   /*************************************************************************/</span>
<span class="line-modified">4744   /*                                                                       */</span>
<span class="line-modified">4745   /* GC[a]:        Get Coordinate projected onto                           */</span>
<span class="line-modified">4746   /* Opcode range: 0x46-0x47                                               */</span>
<span class="line-modified">4747   /* Stack:        uint32 --&gt; f26.6                                        */</span>
<span class="line-modified">4748   /*                                                                       */</span>
<span class="line-modified">4749   /* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */</span>
<span class="line-modified">4750   /*      along the dual projection vector!                                */</span>
<span class="line-modified">4751   /*                                                                       */</span>
4752   static void
4753   Ins_GC( TT_ExecContext  exc,
4754           FT_Long*        args )
4755   {
4756     FT_ULong    L;
4757     FT_F26Dot6  R;
4758 
4759 
4760     L = (FT_ULong)args[0];
4761 
4762     if ( BOUNDSL( L, exc-&gt;zp2.n_points ) )
4763     {
4764       if ( exc-&gt;pedantic_hinting )
4765         exc-&gt;error = FT_THROW( Invalid_Reference );
4766       R = 0;
4767     }
4768     else
4769     {
4770       if ( exc-&gt;opcode &amp; 1 )
4771         R = FAST_DUALPROJ( &amp;exc-&gt;zp2.org[L] );
4772       else
4773         R = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );
4774     }
4775 
4776     args[0] = R;
4777   }
4778 
4779 
<span class="line-modified">4780   /*************************************************************************/</span>
<span class="line-modified">4781   /*                                                                       */</span>
<span class="line-modified">4782   /* SCFS[]:       Set Coordinate From Stack                               */</span>
<span class="line-modified">4783   /* Opcode range: 0x48                                                    */</span>
<span class="line-modified">4784   /* Stack:        f26.6 uint32 --&gt;                                        */</span>
<span class="line-modified">4785   /*                                                                       */</span>
<span class="line-modified">4786   /* Formula:                                                              */</span>
<span class="line-modified">4787   /*                                                                       */</span>
<span class="line-modified">4788   /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */</span>
<span class="line-modified">4789   /*                                                                       */</span>
4790   static void
4791   Ins_SCFS( TT_ExecContext  exc,
4792             FT_Long*        args )
4793   {
4794     FT_Long    K;
4795     FT_UShort  L;
4796 
4797 
4798     L = (FT_UShort)args[0];
4799 
4800     if ( BOUNDS( L, exc-&gt;zp2.n_points ) )
4801     {
4802       if ( exc-&gt;pedantic_hinting )
4803         exc-&gt;error = FT_THROW( Invalid_Reference );
4804       return;
4805     }
4806 
4807     K = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );
4808 
4809     exc-&gt;func_move( exc, &amp;exc-&gt;zp2, L, SUB_LONG( args[1], K ) );
4810 
4811     /* UNDOCUMENTED!  The MS rasterizer does that with */
4812     /* twilight points (confirmed by Greg Hitchcock)   */
4813     if ( exc-&gt;GS.gep2 == 0 )
4814       exc-&gt;zp2.org[L] = exc-&gt;zp2.cur[L];
4815   }
4816 
4817 
<span class="line-modified">4818   /*************************************************************************/</span>
<span class="line-modified">4819   /*                                                                       */</span>
<span class="line-modified">4820   /* MD[a]:        Measure Distance                                        */</span>
<span class="line-modified">4821   /* Opcode range: 0x49-0x4A                                               */</span>
<span class="line-modified">4822   /* Stack:        uint32 uint32 --&gt; f26.6                                 */</span>
<span class="line-modified">4823   /*                                                                       */</span>
<span class="line-modified">4824   /* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */</span>
<span class="line-modified">4825   /*                    the dual projection vector.                        */</span>
<span class="line-modified">4826   /*                                                                       */</span>
<span class="line-modified">4827   /* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */</span>
<span class="line-modified">4828   /*                      0 =&gt; measure distance in original outline        */</span>
<span class="line-modified">4829   /*                      1 =&gt; measure distance in grid-fitted outline     */</span>
<span class="line-modified">4830   /*                                                                       */</span>
<span class="line-modified">4831   /* XXX: UNDOCUMENTED: `zp0 - zp1&#39;, and not `zp2 - zp1!                   */</span>
<span class="line-modified">4832   /*                                                                       */</span>
4833   static void
4834   Ins_MD( TT_ExecContext  exc,
4835           FT_Long*        args )
4836   {
4837     FT_UShort   K, L;
4838     FT_F26Dot6  D;
4839 
4840 
4841     K = (FT_UShort)args[1];
4842     L = (FT_UShort)args[0];
4843 
4844     if ( BOUNDS( L, exc-&gt;zp0.n_points ) ||
4845          BOUNDS( K, exc-&gt;zp1.n_points ) )
4846     {
4847       if ( exc-&gt;pedantic_hinting )
4848         exc-&gt;error = FT_THROW( Invalid_Reference );
4849       D = 0;
4850     }
4851     else
4852     {
</pre>
<hr />
<pre>
4885             vec.y = FT_MulFix( vec1-&gt;y - vec2-&gt;y, exc-&gt;metrics.y_scale );
4886 
4887             D = FAST_DUALPROJ( &amp;vec );
4888           }
4889         }
4890       }
4891     }
4892 
4893 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
4894     /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
4895     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp;
4896          exc-&gt;ignore_x_mode          &amp;&amp;
4897          FT_ABS( D ) == 64           )
4898       D += 1;
4899 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
4900 
4901     args[0] = D;
4902   }
4903 
4904 
<span class="line-modified">4905   /*************************************************************************/</span>
<span class="line-modified">4906   /*                                                                       */</span>
<span class="line-modified">4907   /* SDPvTL[a]:    Set Dual PVector to Line                                */</span>
<span class="line-modified">4908   /* Opcode range: 0x86-0x87                                               */</span>
<span class="line-modified">4909   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">4910   /*                                                                       */</span>
4911   static void
4912   Ins_SDPVTL( TT_ExecContext  exc,
4913               FT_Long*        args )
4914   {
4915     FT_Long    A, B, C;
4916     FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */
4917 
4918     FT_Byte  opcode = exc-&gt;opcode;
4919 
4920 
4921     p1 = (FT_UShort)args[1];
4922     p2 = (FT_UShort)args[0];
4923 
4924     if ( BOUNDS( p2, exc-&gt;zp1.n_points ) ||
4925          BOUNDS( p1, exc-&gt;zp2.n_points ) )
4926     {
4927       if ( exc-&gt;pedantic_hinting )
4928         exc-&gt;error = FT_THROW( Invalid_Reference );
4929       return;
4930     }
</pre>
<hr />
<pre>
4968 
4969       if ( A == 0 &amp;&amp; B == 0 )
4970       {
4971         A      = 0x4000;
4972         opcode = 0;
4973       }
4974     }
4975 
4976     if ( ( opcode &amp; 1 ) != 0 )
4977     {
4978       C = B;   /* counter clockwise rotation */
4979       B = A;
4980       A = NEG_LONG( C );
4981     }
4982 
4983     Normalize( A, B, &amp;exc-&gt;GS.projVector );
4984     Compute_Funcs( exc );
4985   }
4986 
4987 
<span class="line-modified">4988   /*************************************************************************/</span>
<span class="line-modified">4989   /*                                                                       */</span>
<span class="line-modified">4990   /* SZP0[]:       Set Zone Pointer 0                                      */</span>
<span class="line-modified">4991   /* Opcode range: 0x13                                                    */</span>
<span class="line-modified">4992   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">4993   /*                                                                       */</span>
4994   static void
4995   Ins_SZP0( TT_ExecContext  exc,
4996             FT_Long*        args )
4997   {
4998     switch ( (FT_Int)args[0] )
4999     {
5000     case 0:
5001       exc-&gt;zp0 = exc-&gt;twilight;
5002       break;
5003 
5004     case 1:
5005       exc-&gt;zp0 = exc-&gt;pts;
5006       break;
5007 
5008     default:
5009       if ( exc-&gt;pedantic_hinting )
5010         exc-&gt;error = FT_THROW( Invalid_Reference );
5011       return;
5012     }
5013 
5014     exc-&gt;GS.gep0 = (FT_UShort)args[0];
5015   }
5016 
5017 
<span class="line-modified">5018   /*************************************************************************/</span>
<span class="line-modified">5019   /*                                                                       */</span>
<span class="line-modified">5020   /* SZP1[]:       Set Zone Pointer 1                                      */</span>
<span class="line-modified">5021   /* Opcode range: 0x14                                                    */</span>
<span class="line-modified">5022   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5023   /*                                                                       */</span>
5024   static void
5025   Ins_SZP1( TT_ExecContext  exc,
5026             FT_Long*        args )
5027   {
5028     switch ( (FT_Int)args[0] )
5029     {
5030     case 0:
5031       exc-&gt;zp1 = exc-&gt;twilight;
5032       break;
5033 
5034     case 1:
5035       exc-&gt;zp1 = exc-&gt;pts;
5036       break;
5037 
5038     default:
5039       if ( exc-&gt;pedantic_hinting )
5040         exc-&gt;error = FT_THROW( Invalid_Reference );
5041       return;
5042     }
5043 
5044     exc-&gt;GS.gep1 = (FT_UShort)args[0];
5045   }
5046 
5047 
<span class="line-modified">5048   /*************************************************************************/</span>
<span class="line-modified">5049   /*                                                                       */</span>
<span class="line-modified">5050   /* SZP2[]:       Set Zone Pointer 2                                      */</span>
<span class="line-modified">5051   /* Opcode range: 0x15                                                    */</span>
<span class="line-modified">5052   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5053   /*                                                                       */</span>
5054   static void
5055   Ins_SZP2( TT_ExecContext  exc,
5056             FT_Long*        args )
5057   {
5058     switch ( (FT_Int)args[0] )
5059     {
5060     case 0:
5061       exc-&gt;zp2 = exc-&gt;twilight;
5062       break;
5063 
5064     case 1:
5065       exc-&gt;zp2 = exc-&gt;pts;
5066       break;
5067 
5068     default:
5069       if ( exc-&gt;pedantic_hinting )
5070         exc-&gt;error = FT_THROW( Invalid_Reference );
5071       return;
5072     }
5073 
5074     exc-&gt;GS.gep2 = (FT_UShort)args[0];
5075   }
5076 
5077 
<span class="line-modified">5078   /*************************************************************************/</span>
<span class="line-modified">5079   /*                                                                       */</span>
<span class="line-modified">5080   /* SZPS[]:       Set Zone PointerS                                       */</span>
<span class="line-modified">5081   /* Opcode range: 0x16                                                    */</span>
<span class="line-modified">5082   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5083   /*                                                                       */</span>
5084   static void
5085   Ins_SZPS( TT_ExecContext  exc,
5086             FT_Long*        args )
5087   {
5088     switch ( (FT_Int)args[0] )
5089     {
5090     case 0:
5091       exc-&gt;zp0 = exc-&gt;twilight;
5092       break;
5093 
5094     case 1:
5095       exc-&gt;zp0 = exc-&gt;pts;
5096       break;
5097 
5098     default:
5099       if ( exc-&gt;pedantic_hinting )
5100         exc-&gt;error = FT_THROW( Invalid_Reference );
5101       return;
5102     }
5103 
5104     exc-&gt;zp1 = exc-&gt;zp0;
5105     exc-&gt;zp2 = exc-&gt;zp0;
5106 
5107     exc-&gt;GS.gep0 = (FT_UShort)args[0];
5108     exc-&gt;GS.gep1 = (FT_UShort)args[0];
5109     exc-&gt;GS.gep2 = (FT_UShort)args[0];
5110   }
5111 
5112 
<span class="line-modified">5113   /*************************************************************************/</span>
<span class="line-modified">5114   /*                                                                       */</span>
<span class="line-modified">5115   /* INSTCTRL[]:   INSTruction ConTRoL                                     */</span>
<span class="line-modified">5116   /* Opcode range: 0x8E                                                    */</span>
<span class="line-modified">5117   /* Stack:        int32 int32 --&gt;                                         */</span>
<span class="line-modified">5118   /*                                                                       */</span>
5119   static void
5120   Ins_INSTCTRL( TT_ExecContext  exc,
5121                 FT_Long*        args )
5122   {
5123     FT_ULong  K, L, Kf;
5124 
5125 
5126     K = (FT_ULong)args[1];
5127     L = (FT_ULong)args[0];
5128 
5129     /* selector values cannot be `OR&#39;ed;                 */
5130     /* they are indices starting with index 1, not flags */
5131     if ( K &lt; 1 || K &gt; 3 )
5132     {
5133       if ( exc-&gt;pedantic_hinting )
5134         exc-&gt;error = FT_THROW( Invalid_Reference );
5135       return;
5136     }
5137 
5138     /* convert index to flag value */
</pre>
<hr />
<pre>
5155     if ( K == 3 )
5156     {
5157 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5158       /* INSTCTRL modifying flag 3 also has an effect */
5159       /* outside of the CVT program                   */
5160       if ( SUBPIXEL_HINTING_INFINALITY )
5161         exc-&gt;ignore_x_mode = FT_BOOL( L == 4 );
5162 #endif
5163 
5164 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5165       /* Native ClearType fonts sign a waiver that turns off all backward  */
5166       /* compatibility hacks and lets them program points to the grid like */
5167       /* it&#39;s 1996.  They might sign a waiver for just one glyph, though.  */
5168       if ( SUBPIXEL_HINTING_MINIMAL )
5169         exc-&gt;backward_compatibility = !FT_BOOL( L == 4 );
5170 #endif
5171     }
5172   }
5173 
5174 
<span class="line-modified">5175   /*************************************************************************/</span>
<span class="line-modified">5176   /*                                                                       */</span>
<span class="line-modified">5177   /* SCANCTRL[]:   SCAN ConTRoL                                            */</span>
<span class="line-modified">5178   /* Opcode range: 0x85                                                    */</span>
<span class="line-modified">5179   /* Stack:        uint32? --&gt;                                             */</span>
<span class="line-modified">5180   /*                                                                       */</span>
5181   static void
5182   Ins_SCANCTRL( TT_ExecContext  exc,
5183                 FT_Long*        args )
5184   {
5185     FT_Int  A;
5186 
5187 
5188     /* Get Threshold */
5189     A = (FT_Int)( args[0] &amp; 0xFF );
5190 
5191     if ( A == 0xFF )
5192     {
5193       exc-&gt;GS.scan_control = TRUE;
5194       return;
5195     }
5196     else if ( A == 0 )
5197     {
5198       exc-&gt;GS.scan_control = FALSE;
5199       return;
5200     }
</pre>
<hr />
<pre>
5202     if ( ( args[0] &amp; 0x100 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &lt;= A )
5203       exc-&gt;GS.scan_control = TRUE;
5204 
5205     if ( ( args[0] &amp; 0x200 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
5206       exc-&gt;GS.scan_control = TRUE;
5207 
5208     if ( ( args[0] &amp; 0x400 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
5209       exc-&gt;GS.scan_control = TRUE;
5210 
5211     if ( ( args[0] &amp; 0x800 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &gt; A )
5212       exc-&gt;GS.scan_control = FALSE;
5213 
5214     if ( ( args[0] &amp; 0x1000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
5215       exc-&gt;GS.scan_control = FALSE;
5216 
5217     if ( ( args[0] &amp; 0x2000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
5218       exc-&gt;GS.scan_control = FALSE;
5219   }
5220 
5221 
<span class="line-modified">5222   /*************************************************************************/</span>
<span class="line-modified">5223   /*                                                                       */</span>
<span class="line-modified">5224   /* SCANTYPE[]:   SCAN TYPE                                               */</span>
<span class="line-modified">5225   /* Opcode range: 0x8D                                                    */</span>
<span class="line-modified">5226   /* Stack:        uint16 --&gt;                                              */</span>
<span class="line-modified">5227   /*                                                                       */</span>
5228   static void
5229   Ins_SCANTYPE( TT_ExecContext  exc,
5230                 FT_Long*        args )
5231   {
5232     if ( args[0] &gt;= 0 )
5233       exc-&gt;GS.scan_type = (FT_Int)args[0] &amp; 0xFFFF;
5234   }
5235 
5236 
<span class="line-modified">5237   /*************************************************************************/</span>
<span class="line-modified">5238   /*                                                                       */</span>
<span class="line-modified">5239   /* MANAGING OUTLINES                                                     */</span>
<span class="line-modified">5240   /*                                                                       */</span>
<span class="line-modified">5241   /*************************************************************************/</span>
5242 
5243 
<span class="line-modified">5244   /*************************************************************************/</span>
<span class="line-modified">5245   /*                                                                       */</span>
<span class="line-modified">5246   /* FLIPPT[]:     FLIP PoinT                                              */</span>
<span class="line-modified">5247   /* Opcode range: 0x80                                                    */</span>
<span class="line-modified">5248   /* Stack:        uint32... --&gt;                                           */</span>
<span class="line-modified">5249   /*                                                                       */</span>
5250   static void
5251   Ins_FLIPPT( TT_ExecContext  exc )
5252   {
5253     FT_UShort  point;
5254 
5255 
5256 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5257     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5258     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5259          exc-&gt;backward_compatibility &amp;&amp;
5260          exc-&gt;iupx_called            &amp;&amp;
5261          exc-&gt;iupy_called            )
5262       goto Fail;
5263 #endif
5264 
5265     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
5266     {
5267       if ( exc-&gt;pedantic_hinting )
5268         exc-&gt;error = FT_THROW( Too_Few_Arguments );
5269       goto Fail;
</pre>
<hr />
<pre>
5278       if ( BOUNDS( point, exc-&gt;pts.n_points ) )
5279       {
5280         if ( exc-&gt;pedantic_hinting )
5281         {
5282           exc-&gt;error = FT_THROW( Invalid_Reference );
5283           return;
5284         }
5285       }
5286       else
5287         exc-&gt;pts.tags[point] ^= FT_CURVE_TAG_ON;
5288 
5289       exc-&gt;GS.loop--;
5290     }
5291 
5292   Fail:
5293     exc-&gt;GS.loop = 1;
5294     exc-&gt;new_top = exc-&gt;args;
5295   }
5296 
5297 
<span class="line-modified">5298   /*************************************************************************/</span>
<span class="line-modified">5299   /*                                                                       */</span>
<span class="line-modified">5300   /* FLIPRGON[]:   FLIP RanGe ON                                           */</span>
<span class="line-modified">5301   /* Opcode range: 0x81                                                    */</span>
<span class="line-modified">5302   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">5303   /*                                                                       */</span>
5304   static void
5305   Ins_FLIPRGON( TT_ExecContext  exc,
5306                 FT_Long*        args )
5307   {
5308     FT_UShort  I, K, L;
5309 
5310 
5311 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5312     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5313     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5314          exc-&gt;backward_compatibility &amp;&amp;
5315          exc-&gt;iupx_called            &amp;&amp;
5316          exc-&gt;iupy_called            )
5317       return;
5318 #endif
5319 
5320     K = (FT_UShort)args[1];
5321     L = (FT_UShort)args[0];
5322 
5323     if ( BOUNDS( K, exc-&gt;pts.n_points ) ||
5324          BOUNDS( L, exc-&gt;pts.n_points ) )
5325     {
5326       if ( exc-&gt;pedantic_hinting )
5327         exc-&gt;error = FT_THROW( Invalid_Reference );
5328       return;
5329     }
5330 
5331     for ( I = L; I &lt;= K; I++ )
5332       exc-&gt;pts.tags[I] |= FT_CURVE_TAG_ON;
5333   }
5334 
5335 
<span class="line-modified">5336   /*************************************************************************/</span>
<span class="line-modified">5337   /*                                                                       */</span>
<span class="line-modified">5338   /* FLIPRGOFF:    FLIP RanGe OFF                                          */</span>
<span class="line-modified">5339   /* Opcode range: 0x82                                                    */</span>
<span class="line-modified">5340   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">5341   /*                                                                       */</span>
5342   static void
5343   Ins_FLIPRGOFF( TT_ExecContext  exc,
5344                  FT_Long*        args )
5345   {
5346     FT_UShort  I, K, L;
5347 
5348 
5349 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5350     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5351     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5352          exc-&gt;backward_compatibility &amp;&amp;
5353          exc-&gt;iupx_called            &amp;&amp;
5354          exc-&gt;iupy_called            )
5355       return;
5356 #endif
5357 
5358     K = (FT_UShort)args[1];
5359     L = (FT_UShort)args[0];
5360 
5361     if ( BOUNDS( K, exc-&gt;pts.n_points ) ||
</pre>
<hr />
<pre>
5433       if ( touch )
5434         exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
5435     }
5436 
5437     if ( exc-&gt;GS.freeVector.y != 0 )
5438     {
5439 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5440       if ( !( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5441               exc-&gt;backward_compatibility &amp;&amp;
5442               exc-&gt;iupx_called            &amp;&amp;
5443               exc-&gt;iupy_called            ) )
5444 #endif
5445         exc-&gt;zp2.cur[point].y = ADD_LONG( exc-&gt;zp2.cur[point].y, dy );
5446 
5447       if ( touch )
5448         exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
5449     }
5450   }
5451 
5452 
<span class="line-modified">5453   /*************************************************************************/</span>
<span class="line-modified">5454   /*                                                                       */</span>
<span class="line-modified">5455   /* SHP[a]:       SHift Point by the last point                           */</span>
<span class="line-modified">5456   /* Opcode range: 0x32-0x33                                               */</span>
<span class="line-modified">5457   /* Stack:        uint32... --&gt;                                           */</span>
<span class="line-modified">5458   /*                                                                       */</span>
5459   static void
5460   Ins_SHP( TT_ExecContext  exc )
5461   {
5462     TT_GlyphZoneRec  zp;
5463     FT_UShort        refp;
5464 
5465     FT_F26Dot6       dx, dy;
5466     FT_UShort        point;
5467 
5468 
5469     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
5470     {
5471       if ( exc-&gt;pedantic_hinting )
5472         exc-&gt;error = FT_THROW( Invalid_Reference );
5473       goto Fail;
5474     }
5475 
5476     if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )
5477       return;
5478 
</pre>
<hr />
<pre>
5490         }
5491       }
5492       else
5493 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5494       /* doesn&#39;t follow Cleartype spec but produces better result */
5495       if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp; exc-&gt;ignore_x_mode )
5496         Move_Zp2_Point( exc, point, 0, dy, TRUE );
5497       else
5498 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
5499         Move_Zp2_Point( exc, point, dx, dy, TRUE );
5500 
5501       exc-&gt;GS.loop--;
5502     }
5503 
5504   Fail:
5505     exc-&gt;GS.loop = 1;
5506     exc-&gt;new_top = exc-&gt;args;
5507   }
5508 
5509 
<span class="line-modified">5510   /*************************************************************************/</span>
<span class="line-modified">5511   /*                                                                       */</span>
<span class="line-modified">5512   /* SHC[a]:       SHift Contour                                           */</span>
<span class="line-modified">5513   /* Opcode range: 0x34-35                                                 */</span>
<span class="line-modified">5514   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5515   /*                                                                       */</span>
<span class="line-modified">5516   /* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */</span>
<span class="line-modified">5517   /*               contour in the twilight zone, namely contour number     */</span>
<span class="line-modified">5518   /*               zero which includes all points of it.                   */</span>
<span class="line-modified">5519   /*                                                                       */</span>
5520   static void
5521   Ins_SHC( TT_ExecContext  exc,
5522            FT_Long*        args )
5523   {
5524     TT_GlyphZoneRec  zp;
5525     FT_UShort        refp;
5526     FT_F26Dot6       dx, dy;
5527 
5528     FT_Short         contour, bounds;
5529     FT_UShort        start, limit, i;
5530 
5531 
5532     contour = (FT_Short)args[0];
5533     bounds  = ( exc-&gt;GS.gep2 == 0 ) ? 1 : exc-&gt;zp2.n_contours;
5534 
5535     if ( BOUNDS( contour, bounds ) )
5536     {
5537       if ( exc-&gt;pedantic_hinting )
5538         exc-&gt;error = FT_THROW( Invalid_Reference );
5539       return;
</pre>
<hr />
<pre>
5546       start = 0;
5547     else
5548       start = (FT_UShort)( exc-&gt;zp2.contours[contour - 1] + 1 -
5549                            exc-&gt;zp2.first_point );
5550 
5551     /* we use the number of points if in the twilight zone */
5552     if ( exc-&gt;GS.gep2 == 0 )
5553       limit = exc-&gt;zp2.n_points;
5554     else
5555       limit = (FT_UShort)( exc-&gt;zp2.contours[contour] -
5556                            exc-&gt;zp2.first_point + 1 );
5557 
5558     for ( i = start; i &lt; limit; i++ )
5559     {
5560       if ( zp.cur != exc-&gt;zp2.cur || refp != i )
5561         Move_Zp2_Point( exc, i, dx, dy, TRUE );
5562     }
5563   }
5564 
5565 
<span class="line-modified">5566   /*************************************************************************/</span>
<span class="line-modified">5567   /*                                                                       */</span>
<span class="line-modified">5568   /* SHZ[a]:       SHift Zone                                              */</span>
<span class="line-modified">5569   /* Opcode range: 0x36-37                                                 */</span>
<span class="line-modified">5570   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5571   /*                                                                       */</span>
5572   static void
5573   Ins_SHZ( TT_ExecContext  exc,
5574            FT_Long*        args )
5575   {
5576     TT_GlyphZoneRec  zp;
5577     FT_UShort        refp;
5578     FT_F26Dot6       dx,
5579                      dy;
5580 
5581     FT_UShort        limit, i;
5582 
5583 
5584     if ( BOUNDS( args[0], 2 ) )
5585     {
5586       if ( exc-&gt;pedantic_hinting )
5587         exc-&gt;error = FT_THROW( Invalid_Reference );
5588       return;
5589     }
5590 
5591     if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )
</pre>
<hr />
<pre>
5594     /* XXX: UNDOCUMENTED! SHZ doesn&#39;t move the phantom points.     */
5595     /*      Twilight zone has no real contours, so use `n_points&#39;. */
5596     /*      Normal zone&#39;s `n_points&#39; includes phantoms, so must    */
5597     /*      use end of last contour.                               */
5598     if ( exc-&gt;GS.gep2 == 0 )
5599       limit = (FT_UShort)exc-&gt;zp2.n_points;
5600     else if ( exc-&gt;GS.gep2 == 1 &amp;&amp; exc-&gt;zp2.n_contours &gt; 0 )
5601       limit = (FT_UShort)( exc-&gt;zp2.contours[exc-&gt;zp2.n_contours - 1] + 1 );
5602     else
5603       limit = 0;
5604 
5605     /* XXX: UNDOCUMENTED! SHZ doesn&#39;t touch the points */
5606     for ( i = 0; i &lt; limit; i++ )
5607     {
5608       if ( zp.cur != exc-&gt;zp2.cur || refp != i )
5609         Move_Zp2_Point( exc, i, dx, dy, FALSE );
5610     }
5611   }
5612 
5613 
<span class="line-modified">5614   /*************************************************************************/</span>
<span class="line-modified">5615   /*                                                                       */</span>
<span class="line-modified">5616   /* SHPIX[]:      SHift points by a PIXel amount                          */</span>
<span class="line-modified">5617   /* Opcode range: 0x38                                                    */</span>
<span class="line-modified">5618   /* Stack:        f26.6 uint32... --&gt;                                     */</span>
<span class="line-modified">5619   /*                                                                       */</span>
5620   static void
5621   Ins_SHPIX( TT_ExecContext  exc,
5622              FT_Long*        args )
5623   {
5624     FT_F26Dot6  dx, dy;
5625     FT_UShort   point;
5626 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5627     FT_Int      B1, B2;
5628 #endif
5629 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5630     FT_Bool     in_twilight = FT_BOOL( exc-&gt;GS.gep0 == 0 ||
5631                                        exc-&gt;GS.gep1 == 0 ||
5632                                        exc-&gt;GS.gep2 == 0 );
5633 #endif
5634 
5635 
5636 
5637     if ( exc-&gt;top &lt; exc-&gt;GS.loop + 1 )
5638     {
5639       if ( exc-&gt;pedantic_hinting )
</pre>
<hr />
<pre>
5754                ( ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 ) ||
5755                  ( exc-&gt;zp2.tags[point] &amp; FT_CURVE_TAG_TOUCH_Y )    ) ) )
5756           Move_Zp2_Point( exc, point, 0, dy, TRUE );
5757       }
5758       else
5759 #endif
5760         Move_Zp2_Point( exc, point, dx, dy, TRUE );
5761 
5762 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5763     Skip:
5764 #endif
5765       exc-&gt;GS.loop--;
5766     }
5767 
5768   Fail:
5769     exc-&gt;GS.loop = 1;
5770     exc-&gt;new_top = exc-&gt;args;
5771   }
5772 
5773 
<span class="line-modified">5774   /*************************************************************************/</span>
<span class="line-modified">5775   /*                                                                       */</span>
<span class="line-modified">5776   /* MSIRP[a]:     Move Stack Indirect Relative Position                   */</span>
<span class="line-modified">5777   /* Opcode range: 0x3A-0x3B                                               */</span>
<span class="line-modified">5778   /* Stack:        f26.6 uint32 --&gt;                                        */</span>
<span class="line-modified">5779   /*                                                                       */</span>
5780   static void
5781   Ins_MSIRP( TT_ExecContext  exc,
5782              FT_Long*        args )
5783   {
5784     FT_UShort   point = 0;
5785     FT_F26Dot6  distance;
5786 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5787     FT_F26Dot6  control_value_cutin = 0;
5788     FT_F26Dot6  delta;
5789 
5790 
5791     if ( SUBPIXEL_HINTING_INFINALITY )
5792     {
5793       control_value_cutin = exc-&gt;GS.control_value_cutin;
5794 
5795       if ( exc-&gt;ignore_x_mode                                 &amp;&amp;
5796            exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
5797            !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
5798         control_value_cutin = 0;
5799     }
</pre>
<hr />
<pre>
5829     if ( SUBPIXEL_HINTING_INFINALITY  &amp;&amp;
5830          exc-&gt;ignore_x_mode           &amp;&amp;
5831          exc-&gt;GS.freeVector.x != 0    &amp;&amp;
5832          delta &gt;= control_value_cutin )
5833       distance = args[1];
5834 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
5835 
5836     exc-&gt;func_move( exc,
5837                     &amp;exc-&gt;zp1,
5838                     point,
5839                     SUB_LONG( args[1], distance ) );
5840 
5841     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
5842     exc-&gt;GS.rp2 = point;
5843 
5844     if ( ( exc-&gt;opcode &amp; 1 ) != 0 )
5845       exc-&gt;GS.rp0 = point;
5846   }
5847 
5848 
<span class="line-modified">5849   /*************************************************************************/</span>
<span class="line-modified">5850   /*                                                                       */</span>
<span class="line-modified">5851   /* MDAP[a]:      Move Direct Absolute Point                              */</span>
<span class="line-modified">5852   /* Opcode range: 0x2E-0x2F                                               */</span>
<span class="line-modified">5853   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">5854   /*                                                                       */</span>
5855   static void
5856   Ins_MDAP( TT_ExecContext  exc,
5857             FT_Long*        args )
5858   {
5859     FT_UShort   point;
5860     FT_F26Dot6  cur_dist;
5861     FT_F26Dot6  distance;
5862 
5863 
5864     point = (FT_UShort)args[0];
5865 
5866     if ( BOUNDS( point, exc-&gt;zp0.n_points ) )
5867     {
5868       if ( exc-&gt;pedantic_hinting )
5869         exc-&gt;error = FT_THROW( Invalid_Reference );
5870       return;
5871     }
5872 
5873     if ( ( exc-&gt;opcode &amp; 1 ) != 0 )
5874     {
</pre>
<hr />
<pre>
5883                                  exc-&gt;tt_metrics.compensations[0] ),
5884                      cur_dist );
5885       else
5886 #endif
5887         distance = SUB_LONG(
5888                      exc-&gt;func_round( exc,
5889                                       cur_dist,
5890                                       exc-&gt;tt_metrics.compensations[0] ),
5891                      cur_dist );
5892     }
5893     else
5894       distance = 0;
5895 
5896     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, distance );
5897 
5898     exc-&gt;GS.rp0 = point;
5899     exc-&gt;GS.rp1 = point;
5900   }
5901 
5902 
<span class="line-modified">5903   /*************************************************************************/</span>
<span class="line-modified">5904   /*                                                                       */</span>
<span class="line-modified">5905   /* MIAP[a]:      Move Indirect Absolute Point                            */</span>
<span class="line-modified">5906   /* Opcode range: 0x3E-0x3F                                               */</span>
<span class="line-modified">5907   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">5908   /*                                                                       */</span>
5909   static void
5910   Ins_MIAP( TT_ExecContext  exc,
5911             FT_Long*        args )
5912   {
5913     FT_ULong    cvtEntry;
5914     FT_UShort   point;
5915     FT_F26Dot6  distance;
5916     FT_F26Dot6  org_dist;
5917     FT_F26Dot6  control_value_cutin;
5918 
5919 
5920     control_value_cutin = exc-&gt;GS.control_value_cutin;
5921     cvtEntry            = (FT_ULong)args[1];
5922     point               = (FT_UShort)args[0];
5923 
5924 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5925     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
5926          exc-&gt;ignore_x_mode                                 &amp;&amp;
5927          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
5928          exc-&gt;GS.freeVector.y == 0                          &amp;&amp;
</pre>
<hr />
<pre>
6003            exc-&gt;ignore_x_mode          &amp;&amp;
6004            exc-&gt;GS.freeVector.x != 0   )
6005         distance = Round_None( exc,
6006                                distance,
6007                                exc-&gt;tt_metrics.compensations[0] );
6008       else
6009 #endif
6010         distance = exc-&gt;func_round( exc,
6011                                     distance,
6012                                     exc-&gt;tt_metrics.compensations[0] );
6013     }
6014 
6015     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, SUB_LONG( distance, org_dist ) );
6016 
6017   Fail:
6018     exc-&gt;GS.rp0 = point;
6019     exc-&gt;GS.rp1 = point;
6020   }
6021 
6022 
<span class="line-modified">6023   /*************************************************************************/</span>
<span class="line-modified">6024   /*                                                                       */</span>
<span class="line-modified">6025   /* MDRP[abcde]:  Move Direct Relative Point                              */</span>
<span class="line-modified">6026   /* Opcode range: 0xC0-0xDF                                               */</span>
<span class="line-modified">6027   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">6028   /*                                                                       */</span>
6029   static void
6030   Ins_MDRP( TT_ExecContext  exc,
6031             FT_Long*        args )
6032   {
6033     FT_UShort   point = 0;
6034     FT_F26Dot6  org_dist, distance, minimum_distance;
6035 
6036 
6037     minimum_distance = exc-&gt;GS.minimum_distance;
6038 
6039 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6040     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
6041          exc-&gt;ignore_x_mode                                 &amp;&amp;
6042          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
6043          !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
6044       minimum_distance = 0;
6045 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6046 
6047     point = (FT_UShort)args[0];
6048 
</pre>
<hr />
<pre>
6147         if ( distance &gt; NEG_LONG( minimum_distance ) )
6148           distance = NEG_LONG( minimum_distance );
6149       }
6150     }
6151 
6152     /* now move the point */
6153 
6154     org_dist = PROJECT( exc-&gt;zp1.cur + point, exc-&gt;zp0.cur + exc-&gt;GS.rp0 );
6155 
6156     exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, SUB_LONG( distance, org_dist ) );
6157 
6158   Fail:
6159     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
6160     exc-&gt;GS.rp2 = point;
6161 
6162     if ( ( exc-&gt;opcode &amp; 16 ) != 0 )
6163       exc-&gt;GS.rp0 = point;
6164   }
6165 
6166 
<span class="line-modified">6167   /*************************************************************************/</span>
<span class="line-modified">6168   /*                                                                       */</span>
<span class="line-modified">6169   /* MIRP[abcde]:  Move Indirect Relative Point                            */</span>
<span class="line-modified">6170   /* Opcode range: 0xE0-0xFF                                               */</span>
<span class="line-modified">6171   /* Stack:        int32? uint32 --&gt;                                       */</span>
<span class="line-modified">6172   /*                                                                       */</span>
6173   static void
6174   Ins_MIRP( TT_ExecContext  exc,
6175             FT_Long*        args )
6176   {
6177     FT_UShort   point;
6178     FT_ULong    cvtEntry;
6179 
6180     FT_F26Dot6  cvt_dist,
6181                 distance,
6182                 cur_dist,
6183                 org_dist,
6184                 control_value_cutin,
6185                 minimum_distance;
6186 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6187     FT_Int      B1           = 0; /* pacify compiler */
6188     FT_Int      B2           = 0;
6189     FT_Bool     reverse_move = FALSE;
6190 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6191 


6192 
6193     minimum_distance    = exc-&gt;GS.minimum_distance;
6194     control_value_cutin = exc-&gt;GS.control_value_cutin;
6195     point               = (FT_UShort)args[0];
6196     cvtEntry            = (FT_ULong)( ADD_LONG( args[1], 1 ) );
6197 
6198 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6199     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
6200          exc-&gt;ignore_x_mode                                 &amp;&amp;
6201          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
6202          !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
6203       control_value_cutin = minimum_distance = 0;
6204 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6205 
6206     /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
6207 
6208     if ( BOUNDS( point,       exc-&gt;zp1.n_points ) ||
6209          BOUNDSL( cvtEntry,   exc-&gt;cvtSize + 1 )  ||
6210          BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )
6211     {
6212       if ( exc-&gt;pedantic_hinting )
6213         exc-&gt;error = FT_THROW( Invalid_Reference );
6214       goto Fail;
6215     }
6216 
6217     if ( !cvtEntry )
6218       cvt_dist = 0;
6219     else
6220       cvt_dist = exc-&gt;func_read_cvt( exc, cvtEntry - 1 );
6221 
6222     /* single width test */
6223 
<span class="line-modified">6224     if ( FT_ABS( cvt_dist - exc-&gt;GS.single_width_value ) &lt;</span>
<span class="line-modified">6225          exc-&gt;GS.single_width_cutin )</span>



6226     {
6227       if ( cvt_dist &gt;= 0 )
6228         cvt_dist =  exc-&gt;GS.single_width_value;
6229       else
6230         cvt_dist = -exc-&gt;GS.single_width_value;
6231     }
6232 
6233     /* UNDOCUMENTED!  The MS rasterizer does that with */
6234     /* twilight points (confirmed by Greg Hitchcock)   */
6235     if ( exc-&gt;GS.gep1 == 0 )
6236     {
6237       exc-&gt;zp1.org[point].x = exc-&gt;zp0.org[exc-&gt;GS.rp0].x +
6238                               TT_MulFix14( cvt_dist,
6239                                            exc-&gt;GS.freeVector.x );
6240       exc-&gt;zp1.org[point].y = exc-&gt;zp0.org[exc-&gt;GS.rp0].y +
6241                               TT_MulFix14( cvt_dist,
6242                                            exc-&gt;GS.freeVector.y );
6243       exc-&gt;zp1.cur[point]   = exc-&gt;zp1.org[point];
6244     }
6245 
6246     org_dist = DUALPROJ( &amp;exc-&gt;zp1.org[point], &amp;exc-&gt;zp0.org[exc-&gt;GS.rp0] );
6247     cur_dist = PROJECT ( &amp;exc-&gt;zp1.cur[point], &amp;exc-&gt;zp0.cur[exc-&gt;GS.rp0] );
6248 
6249     /* auto-flip test */
6250 
6251     if ( exc-&gt;GS.auto_flip )
6252     {
6253       if ( ( org_dist ^ cvt_dist ) &lt; 0 )
<span class="line-modified">6254         cvt_dist = -cvt_dist;</span>
6255     }
6256 
6257 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6258     if ( SUBPIXEL_HINTING_INFINALITY                               &amp;&amp;
6259          exc-&gt;ignore_x_mode                                        &amp;&amp;
6260          exc-&gt;GS.freeVector.y != 0                                 &amp;&amp;
6261          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
6262     {
6263       if ( cur_dist &lt; -64 )
6264         cvt_dist -= 16;
6265       else if ( cur_dist &gt; 64 &amp;&amp; cur_dist &lt; 84 )
6266         cvt_dist += 32;
6267     }
6268 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6269 
6270     /* control value cut-in and round */
6271 
6272     if ( ( exc-&gt;opcode &amp; 4 ) != 0 )
6273     {
6274       /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
6275       /*      refer to the same zone.                                  */
6276 
6277       if ( exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )
6278       {
<span class="line-removed">6279         FT_F26Dot6  delta;</span>
<span class="line-removed">6280 </span>
<span class="line-removed">6281 </span>
6282         /* XXX: According to Greg Hitchcock, the following wording is */
6283         /*      the right one:                                        */
6284         /*                                                            */
6285         /*        When the absolute difference between the value in   */
6286         /*        the table [CVT] and the measurement directly from   */
6287         /*        the outline is _greater_ than the cut_in value, the */
6288         /*        outline measurement is used.                        */
6289         /*                                                            */
6290         /*      This is from `instgly.doc&#39;.  The description in       */
6291         /*      `ttinst2.doc&#39;, version 1.66, is thus incorrect since  */
6292         /*      it implies `&gt;=&#39; instead of `&gt;&#39;.                       */
6293 
6294         delta = SUB_LONG( cvt_dist, org_dist );
6295         if ( delta &lt; 0 )
6296           delta = NEG_LONG( delta );
6297 
6298         if ( delta &gt; control_value_cutin )
6299           cvt_dist = org_dist;
6300       }
6301 
6302       distance = exc-&gt;func_round(
6303                    exc,
6304                    cvt_dist,
6305                    exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );
6306     }
6307     else
6308     {
6309 
6310 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6311       /* do cvt cut-in always in MIRP for sph */
6312       if ( SUBPIXEL_HINTING_INFINALITY  &amp;&amp;
6313            exc-&gt;ignore_x_mode           &amp;&amp;
6314            exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )
6315       {
<span class="line-removed">6316         FT_F26Dot6  delta;</span>
<span class="line-removed">6317 </span>
<span class="line-removed">6318 </span>
6319         delta = SUB_LONG( cvt_dist, org_dist );
6320         if ( delta &lt; 0 )
6321           delta = NEG_LONG( delta );
6322 
6323         if ( delta &gt; control_value_cutin )
6324           cvt_dist = org_dist;
6325       }
6326 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6327 
6328       distance = Round_None(
6329                    exc,
6330                    cvt_dist,
6331                    exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );
6332     }
6333 
6334     /* minimum distance test */
6335 
6336     if ( ( exc-&gt;opcode &amp; 8 ) != 0 )
6337     {
6338       if ( org_dist &gt;= 0 )
</pre>
<hr />
<pre>
6395 
6396       if ( reverse_move )
6397         exc-&gt;func_move( exc,
6398                         &amp;exc-&gt;zp1,
6399                         point,
6400                         SUB_LONG( cur_dist, distance ) );
6401     }
6402 
6403 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6404 
6405   Fail:
6406     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
6407 
6408     if ( ( exc-&gt;opcode &amp; 16 ) != 0 )
6409       exc-&gt;GS.rp0 = point;
6410 
6411     exc-&gt;GS.rp2 = point;
6412   }
6413 
6414 
<span class="line-modified">6415   /*************************************************************************/</span>
<span class="line-modified">6416   /*                                                                       */</span>
<span class="line-modified">6417   /* ALIGNRP[]:    ALIGN Relative Point                                    */</span>
<span class="line-modified">6418   /* Opcode range: 0x3C                                                    */</span>
<span class="line-modified">6419   /* Stack:        uint32 uint32... --&gt;                                    */</span>
<span class="line-modified">6420   /*                                                                       */</span>
6421   static void
6422   Ins_ALIGNRP( TT_ExecContext  exc )
6423   {
6424     FT_UShort   point;
6425     FT_F26Dot6  distance;
6426 
6427 
6428 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6429     if ( SUBPIXEL_HINTING_INFINALITY                               &amp;&amp;
6430          exc-&gt;ignore_x_mode                                        &amp;&amp;
6431          exc-&gt;iup_called                                           &amp;&amp;
6432          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
6433     {
6434       exc-&gt;error = FT_THROW( Invalid_Reference );
6435       goto Fail;
6436     }
6437 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6438 
6439     if ( exc-&gt;top &lt; exc-&gt;GS.loop                  ||
6440          BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )
</pre>
<hr />
<pre>
6458           return;
6459         }
6460       }
6461       else
6462       {
6463         distance = PROJECT( exc-&gt;zp1.cur + point,
6464                             exc-&gt;zp0.cur + exc-&gt;GS.rp0 );
6465 
6466         exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, NEG_LONG( distance ) );
6467       }
6468 
6469       exc-&gt;GS.loop--;
6470     }
6471 
6472   Fail:
6473     exc-&gt;GS.loop = 1;
6474     exc-&gt;new_top = exc-&gt;args;
6475   }
6476 
6477 
<span class="line-modified">6478   /*************************************************************************/</span>
<span class="line-modified">6479   /*                                                                       */</span>
<span class="line-modified">6480   /* ISECT[]:      moves point to InterSECTion                             */</span>
<span class="line-modified">6481   /* Opcode range: 0x0F                                                    */</span>
<span class="line-modified">6482   /* Stack:        5 * uint32 --&gt;                                          */</span>
<span class="line-modified">6483   /*                                                                       */</span>
6484   static void
6485   Ins_ISECT( TT_ExecContext  exc,
6486              FT_Long*        args )
6487   {
6488     FT_UShort   point,
6489                 a0, a1,
6490                 b0, b1;
6491 
6492     FT_F26Dot6  discriminant, dotproduct;
6493 
6494     FT_F26Dot6  dx,  dy,
6495                 dax, day,
6496                 dbx, dby;
6497 
6498     FT_F26Dot6  val;
6499 
6500     FT_Vector   R;
6501 
6502 
6503     point = (FT_UShort)args[0];
</pre>
<hr />
<pre>
6554       exc-&gt;zp2.cur[point].x = ADD_LONG( exc-&gt;zp1.cur[a0].x, R.x );
6555       exc-&gt;zp2.cur[point].y = ADD_LONG( exc-&gt;zp1.cur[a0].y, R.y );
6556     }
6557     else
6558     {
6559       /* else, take the middle of the middles of A and B */
6560 
6561       /* XXX: Block in backward_compatibility and/or post-IUP? */
6562       exc-&gt;zp2.cur[point].x =
6563         ADD_LONG( ADD_LONG( exc-&gt;zp1.cur[a0].x, exc-&gt;zp1.cur[a1].x ),
6564                   ADD_LONG( exc-&gt;zp0.cur[b0].x, exc-&gt;zp0.cur[b1].x ) ) / 4;
6565       exc-&gt;zp2.cur[point].y =
6566         ADD_LONG( ADD_LONG( exc-&gt;zp1.cur[a0].y, exc-&gt;zp1.cur[a1].y ),
6567                   ADD_LONG( exc-&gt;zp0.cur[b0].y, exc-&gt;zp0.cur[b1].y ) ) / 4;
6568     }
6569 
6570     exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
6571   }
6572 
6573 
<span class="line-modified">6574   /*************************************************************************/</span>
<span class="line-modified">6575   /*                                                                       */</span>
<span class="line-modified">6576   /* ALIGNPTS[]:   ALIGN PoinTS                                            */</span>
<span class="line-modified">6577   /* Opcode range: 0x27                                                    */</span>
<span class="line-modified">6578   /* Stack:        uint32 uint32 --&gt;                                       */</span>
<span class="line-modified">6579   /*                                                                       */</span>
6580   static void
6581   Ins_ALIGNPTS( TT_ExecContext  exc,
6582                 FT_Long*        args )
6583   {
6584     FT_UShort   p1, p2;
6585     FT_F26Dot6  distance;
6586 
6587 
6588     p1 = (FT_UShort)args[0];
6589     p2 = (FT_UShort)args[1];
6590 
6591     if ( BOUNDS( p1, exc-&gt;zp1.n_points ) ||
6592          BOUNDS( p2, exc-&gt;zp0.n_points ) )
6593     {
6594       if ( exc-&gt;pedantic_hinting )
6595         exc-&gt;error = FT_THROW( Invalid_Reference );
6596       return;
6597     }
6598 
6599     distance = PROJECT( exc-&gt;zp0.cur + p2, exc-&gt;zp1.cur + p1 ) / 2;
6600 
6601     exc-&gt;func_move( exc, &amp;exc-&gt;zp1, p1, distance );
6602     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, p2, NEG_LONG( distance ) );
6603   }
6604 
6605 
<span class="line-modified">6606   /*************************************************************************/</span>
<span class="line-modified">6607   /*                                                                       */</span>
<span class="line-modified">6608   /* IP[]:         Interpolate Point                                       */</span>
<span class="line-modified">6609   /* Opcode range: 0x39                                                    */</span>
<span class="line-modified">6610   /* Stack:        uint32... --&gt;                                           */</span>
<span class="line-modified">6611   /*                                                                       */</span>
6612 
6613   /* SOMETIMES, DUMBER CODE IS BETTER CODE */
6614 
6615   static void
6616   Ins_IP( TT_ExecContext  exc )
6617   {
6618     FT_F26Dot6  old_range, cur_range;
6619     FT_Vector*  orus_base;
6620     FT_Vector*  cur_base;
6621     FT_Int      twilight;
6622 
6623 
6624     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
6625     {
6626       if ( exc-&gt;pedantic_hinting )
6627         exc-&gt;error = FT_THROW( Invalid_Reference );
6628       goto Fail;
6629     }
6630 
6631     /*
</pre>
<hr />
<pre>
6746           /*              new_dist = org_dist                .       */
6747 
6748           new_dist = org_dist;
6749         }
6750       }
6751       else
6752         new_dist = 0;
6753 
6754       exc-&gt;func_move( exc,
6755                       &amp;exc-&gt;zp2,
6756                       (FT_UShort)point,
6757                       SUB_LONG( new_dist, cur_dist ) );
6758     }
6759 
6760   Fail:
6761     exc-&gt;GS.loop = 1;
6762     exc-&gt;new_top = exc-&gt;args;
6763   }
6764 
6765 
<span class="line-modified">6766   /*************************************************************************/</span>
<span class="line-modified">6767   /*                                                                       */</span>
<span class="line-modified">6768   /* UTP[a]:       UnTouch Point                                           */</span>
<span class="line-modified">6769   /* Opcode range: 0x29                                                    */</span>
<span class="line-modified">6770   /* Stack:        uint32 --&gt;                                              */</span>
<span class="line-modified">6771   /*                                                                       */</span>
6772   static void
6773   Ins_UTP( TT_ExecContext  exc,
6774            FT_Long*        args )
6775   {
6776     FT_UShort  point;
6777     FT_Byte    mask;
6778 
6779 
6780     point = (FT_UShort)args[0];
6781 
6782     if ( BOUNDS( point, exc-&gt;zp0.n_points ) )
6783     {
6784       if ( exc-&gt;pedantic_hinting )
6785         exc-&gt;error = FT_THROW( Invalid_Reference );
6786       return;
6787     }
6788 
6789     mask = 0xFF;
6790 
6791     if ( exc-&gt;GS.freeVector.x != 0 )
</pre>
<hr />
<pre>
6915 
6916         else
6917         {
6918           if ( !scale_valid )
6919           {
6920             scale_valid = 1;
6921             scale       = FT_DivFix( SUB_LONG( cur2, cur1 ),
6922                                      SUB_LONG( orus2, orus1 ) );
6923           }
6924 
6925           x = ADD_LONG( cur1,
6926                         FT_MulFix( SUB_LONG( worker-&gt;orus[i].x, orus1 ),
6927                                    scale ) );
6928         }
6929         worker-&gt;curs[i].x = x;
6930       }
6931     }
6932   }
6933 
6934 
<span class="line-modified">6935   /*************************************************************************/</span>
<span class="line-modified">6936   /*                                                                       */</span>
<span class="line-modified">6937   /* IUP[a]:       Interpolate Untouched Points                            */</span>
<span class="line-modified">6938   /* Opcode range: 0x30-0x31                                               */</span>
<span class="line-modified">6939   /* Stack:        --&gt;                                                     */</span>
<span class="line-modified">6940   /*                                                                       */</span>
6941   static void
6942   Ins_IUP( TT_ExecContext  exc )
6943   {
6944     IUP_WorkerRec  V;
6945     FT_Byte        mask;
6946 
6947     FT_UInt   first_point;   /* first point of contour        */
6948     FT_UInt   end_point;     /* end point (last+1) of contour */
6949 
6950     FT_UInt   first_touched; /* first touched point in contour   */
6951     FT_UInt   cur_touched;   /* current touched point in contour */
6952 
6953     FT_UInt   point;         /* current point   */
6954     FT_Short  contour;       /* current contour */
6955 
6956 
6957 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
6958     /* See `ttinterp.h&#39; for details on backward compatibility mode.  */
6959     /* Allow IUP until it has been called on both axes.  Immediately */
6960     /* return on subsequent ones.                                    */
</pre>
<hr />
<pre>
7043         {
7044           _iup_worker_interpolate( &amp;V,
7045                                    (FT_UShort)( cur_touched + 1 ),
7046                                    end_point,
7047                                    cur_touched,
7048                                    first_touched );
7049 
7050           if ( first_touched &gt; 0 )
7051             _iup_worker_interpolate( &amp;V,
7052                                      first_point,
7053                                      first_touched - 1,
7054                                      cur_touched,
7055                                      first_touched );
7056         }
7057       }
7058       contour++;
7059     } while ( contour &lt; exc-&gt;pts.n_contours );
7060   }
7061 
7062 
<span class="line-modified">7063   /*************************************************************************/</span>
<span class="line-modified">7064   /*                                                                       */</span>
<span class="line-modified">7065   /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */</span>
<span class="line-modified">7066   /* Opcode range: 0x5D,0x71,0x72                                          */</span>
<span class="line-modified">7067   /* Stack:        uint32 (2 * uint32)... --&gt;                              */</span>
<span class="line-modified">7068   /*                                                                       */</span>
7069   static void
7070   Ins_DELTAP( TT_ExecContext  exc,
7071               FT_Long*        args )
7072   {
7073     FT_ULong   nump, k;
7074     FT_UShort  A;
7075     FT_ULong   C, P;
7076     FT_Long    B;
7077 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7078     FT_UShort  B1, B2;
7079 
7080 
7081     if ( SUBPIXEL_HINTING_INFINALITY                              &amp;&amp;
7082          exc-&gt;ignore_x_mode                                       &amp;&amp;
7083          exc-&gt;iup_called                                          &amp;&amp;
7084          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )
7085       goto Fail;
7086 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7087 
7088     P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );
</pre>
<hr />
<pre>
7125 
7126         case 0x72:
7127           C += 32;
7128           break;
7129         }
7130 
7131         C += exc-&gt;GS.delta_base;
7132 
7133         if ( P == C )
7134         {
7135           B = ( (FT_ULong)B &amp; 0xF ) - 8;
7136           if ( B &gt;= 0 )
7137             B++;
7138           B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );
7139 
7140 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7141 
7142           if ( SUBPIXEL_HINTING_INFINALITY )
7143           {
7144             /*
<span class="line-modified">7145              *  Allow delta move if</span>
7146              *
<span class="line-modified">7147              *  - not using ignore_x_mode rendering,</span>
<span class="line-modified">7148              *  - glyph is specifically set to allow it, or</span>
<span class="line-modified">7149              *  - glyph is composite and freedom vector is not in subpixel</span>
<span class="line-modified">7150              *    direction.</span>
7151              */
7152             if ( !exc-&gt;ignore_x_mode                                   ||
7153                  ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
7154                  ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 )    )
7155               exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7156 
7157             /* Otherwise, apply subpixel hinting and compatibility mode */
7158             /* rules, always skipping deltas in subpixel direction.     */
7159             else if ( exc-&gt;ignore_x_mode &amp;&amp; exc-&gt;GS.freeVector.y != 0 )
7160             {
7161               /* save the y value of the point now; compare after move */
7162               B1 = (FT_UShort)exc-&gt;zp0.cur[A].y;
7163 
7164               /* Standard subpixel hinting: Allow y move for y-touched */
7165               /* points.  This messes up DejaVu ...                    */
7166               if ( !exc-&gt;face-&gt;sph_compatibility_mode          &amp;&amp;
7167                    ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y ) )
7168                 exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7169 
7170               /* compatibility mode */
</pre>
<hr />
<pre>
7210                    ( ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 ) ||
7211                      ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y )        ) )
7212                 exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7213             }
7214             else
7215 #endif
7216               exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7217           }
7218         }
7219       }
7220       else
7221         if ( exc-&gt;pedantic_hinting )
7222           exc-&gt;error = FT_THROW( Invalid_Reference );
7223     }
7224 
7225   Fail:
7226     exc-&gt;new_top = exc-&gt;args;
7227   }
7228 
7229 
<span class="line-modified">7230   /*************************************************************************/</span>
<span class="line-modified">7231   /*                                                                       */</span>
<span class="line-modified">7232   /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */</span>
<span class="line-modified">7233   /* Opcode range: 0x73,0x74,0x75                                          */</span>
<span class="line-modified">7234   /* Stack:        uint32 (2 * uint32)... --&gt;                              */</span>
<span class="line-modified">7235   /*                                                                       */</span>
7236   static void
7237   Ins_DELTAC( TT_ExecContext  exc,
7238               FT_Long*        args )
7239   {
7240     FT_ULong  nump, k;
7241     FT_ULong  A, C, P;
7242     FT_Long   B;
7243 
7244 
7245     P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );
7246     nump = (FT_ULong)args[0];
7247 
7248     for ( k = 1; k &lt;= nump; k++ )
7249     {
7250       if ( exc-&gt;args &lt; 2 )
7251       {
7252         if ( exc-&gt;pedantic_hinting )
7253           exc-&gt;error = FT_THROW( Too_Few_Arguments );
7254         exc-&gt;args = 0;
7255         goto Fail;
</pre>
<hr />
<pre>
7288 
7289         C += exc-&gt;GS.delta_base;
7290 
7291         if ( P == C )
7292         {
7293           B = ( (FT_ULong)B &amp; 0xF ) - 8;
7294           if ( B &gt;= 0 )
7295             B++;
7296           B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );
7297 
7298           exc-&gt;func_move_cvt( exc, A, B );
7299         }
7300       }
7301     }
7302 
7303   Fail:
7304     exc-&gt;new_top = exc-&gt;args;
7305   }
7306 
7307 
<span class="line-modified">7308   /*************************************************************************/</span>
<span class="line-modified">7309   /*                                                                       */</span>
<span class="line-modified">7310   /* MISC. INSTRUCTIONS                                                    */</span>
<span class="line-modified">7311   /*                                                                       */</span>
<span class="line-modified">7312   /*************************************************************************/</span>
7313 
7314 
<span class="line-modified">7315   /*************************************************************************/</span>
<span class="line-modified">7316   /*                                                                       */</span>
<span class="line-modified">7317   /* GETINFO[]:    GET INFOrmation                                         */</span>
<span class="line-modified">7318   /* Opcode range: 0x88                                                    */</span>
<span class="line-modified">7319   /* Stack:        uint32 --&gt; uint32                                       */</span>
<span class="line-modified">7320   /*                                                                       */</span>
<span class="line-modified">7321   /* XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May     */</span>
<span class="line-modified">7322   /*      2015) not documented in the OpenType specification.              */</span>
<span class="line-modified">7323   /*                                                                       */</span>
<span class="line-modified">7324   /*      Selector bit 11 is incorrectly described as bit 8, while the     */</span>
<span class="line-modified">7325   /*      real meaning of bit 8 (vertical LCD subpixels) stays             */</span>
<span class="line-modified">7326   /*      undocumented.  The same mistake can be found in Greg Hitchcock&#39;s */</span>
<span class="line-modified">7327   /*      whitepaper.                                                      */</span>
<span class="line-modified">7328   /*                                                                       */</span>
7329   static void
7330   Ins_GETINFO( TT_ExecContext  exc,
7331                FT_Long*        args )
7332   {
7333     FT_Long    K;
7334     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( exc-&gt;face );
7335 
7336 
7337     K = 0;
7338 
7339 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
<span class="line-modified">7340     /********************************/</span>
<span class="line-modified">7341     /* RASTERIZER VERSION           */</span>
<span class="line-modified">7342     /* Selector Bit:  0             */</span>
<span class="line-modified">7343     /* Return Bit(s): 0-7           */</span>
<span class="line-modified">7344     /*                              */</span>
7345     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp;
7346          ( args[0] &amp; 1 ) != 0        &amp;&amp;
7347          exc-&gt;subpixel_hinting       )
7348     {
7349       if ( exc-&gt;ignore_x_mode )
7350       {
7351         /* if in ClearType backward compatibility mode,         */
7352         /* we sometimes change the TrueType version dynamically */
7353         K = exc-&gt;rasterizer_version;
7354         FT_TRACE6(( &quot;Setting rasterizer version %d\n&quot;,
7355                     exc-&gt;rasterizer_version ));
7356       }
7357       else
7358         K = TT_INTERPRETER_VERSION_38;
7359     }
7360     else
7361 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7362       if ( ( args[0] &amp; 1 ) != 0 )
7363         K = driver-&gt;interpreter_version;
7364 
<span class="line-modified">7365     /********************************/</span>
<span class="line-modified">7366     /* GLYPH ROTATED                */</span>
<span class="line-modified">7367     /* Selector Bit:  1             */</span>
<span class="line-modified">7368     /* Return Bit(s): 8             */</span>
<span class="line-modified">7369     /*                              */</span>
7370     if ( ( args[0] &amp; 2 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
7371       K |= 1 &lt;&lt; 8;
7372 
<span class="line-modified">7373     /********************************/</span>
<span class="line-modified">7374     /* GLYPH STRETCHED              */</span>
<span class="line-modified">7375     /* Selector Bit:  2             */</span>
<span class="line-modified">7376     /* Return Bit(s): 9             */</span>
<span class="line-modified">7377     /*                              */</span>
7378     if ( ( args[0] &amp; 4 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
7379       K |= 1 &lt;&lt; 9;
7380 
7381 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
<span class="line-modified">7382     /********************************/</span>
<span class="line-modified">7383     /* VARIATION GLYPH              */</span>
<span class="line-modified">7384     /* Selector Bit:  3             */</span>
<span class="line-modified">7385     /* Return Bit(s): 10            */</span>
<span class="line-modified">7386     /*                              */</span>
<span class="line-modified">7387     /* XXX: UNDOCUMENTED!           */</span>

7388     if ( (args[0] &amp; 8 ) != 0 &amp;&amp; exc-&gt;face-&gt;blend )
7389       K |= 1 &lt;&lt; 10;
7390 #endif
7391 
<span class="line-modified">7392     /********************************/</span>
<span class="line-modified">7393     /* BI-LEVEL HINTING AND         */</span>
<span class="line-modified">7394     /* GRAYSCALE RENDERING          */</span>
<span class="line-modified">7395     /* Selector Bit:  5             */</span>
<span class="line-modified">7396     /* Return Bit(s): 12            */</span>
<span class="line-modified">7397     /*                              */</span>
7398     if ( ( args[0] &amp; 32 ) != 0 &amp;&amp; exc-&gt;grayscale )
7399       K |= 1 &lt;&lt; 12;
7400 
7401 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
7402     /* Toggle the following flags only outside of monochrome mode.      */
7403     /* Otherwise, instructions may behave weirdly and rendering results */
7404     /* may differ between v35 and v40 mode, e.g., in `Times New Roman   */
7405     /* Bold Italic&#39;. */
7406     if ( SUBPIXEL_HINTING_MINIMAL &amp;&amp; exc-&gt;subpixel_hinting_lean )
7407     {
<span class="line-modified">7408       /********************************/</span>
<span class="line-modified">7409       /* HINTING FOR SUBPIXEL         */</span>
<span class="line-modified">7410       /* Selector Bit:  6             */</span>
<span class="line-modified">7411       /* Return Bit(s): 13            */</span>
<span class="line-modified">7412       /*                              */</span>
<span class="line-modified">7413       /* v40 does subpixel hinting by default. */</span>

7414       if ( ( args[0] &amp; 64 ) != 0 )
7415         K |= 1 &lt;&lt; 13;
7416 
<span class="line-modified">7417       /********************************/</span>
<span class="line-modified">7418       /* VERTICAL LCD SUBPIXELS?      */</span>
<span class="line-modified">7419       /* Selector Bit:  8             */</span>
<span class="line-modified">7420       /* Return Bit(s): 15            */</span>
<span class="line-modified">7421       /*                              */</span>
7422       if ( ( args[0] &amp; 256 ) != 0 &amp;&amp; exc-&gt;vertical_lcd_lean )
7423         K |= 1 &lt;&lt; 15;
7424 
<span class="line-modified">7425       /********************************/</span>
<span class="line-modified">7426       /* SUBPIXEL POSITIONED?         */</span>
<span class="line-modified">7427       /* Selector Bit:  10            */</span>
<span class="line-modified">7428       /* Return Bit(s): 17            */</span>
<span class="line-modified">7429       /*                              */</span>
<span class="line-modified">7430       /* XXX: FreeType supports it, dependent on what client does? */</span>

7431       if ( ( args[0] &amp; 1024 ) != 0 )
7432         K |= 1 &lt;&lt; 17;
7433 
<span class="line-modified">7434       /********************************/</span>
<span class="line-modified">7435       /* SYMMETRICAL SMOOTHING        */</span>
<span class="line-modified">7436       /* Selector Bit:  11            */</span>
<span class="line-modified">7437       /* Return Bit(s): 18            */</span>
<span class="line-modified">7438       /*                              */</span>
<span class="line-modified">7439       /* The only smoothing method FreeType supports unless someone sets */</span>
<span class="line-modified">7440       /* FT_LOAD_TARGET_MONO.                                            */</span>

7441       if ( ( args[0] &amp; 2048 ) != 0 &amp;&amp; exc-&gt;subpixel_hinting_lean )
7442         K |= 1 &lt;&lt; 18;
7443 
<span class="line-modified">7444       /********************************/</span>
<span class="line-modified">7445       /* CLEARTYPE HINTING AND        */</span>
<span class="line-modified">7446       /* GRAYSCALE RENDERING          */</span>
<span class="line-modified">7447       /* Selector Bit:  12            */</span>
<span class="line-modified">7448       /* Return Bit(s): 19            */</span>
<span class="line-modified">7449       /*                              */</span>
<span class="line-modified">7450       /* Grayscale rendering is what FreeType does anyway unless someone */</span>
<span class="line-modified">7451       /* sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)              */</span>

7452       if ( ( args[0] &amp; 4096 ) != 0 &amp;&amp; exc-&gt;grayscale_cleartype )
7453         K |= 1 &lt;&lt; 19;
7454     }
7455 #endif
7456 
7457 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7458 
7459     if ( SUBPIXEL_HINTING_INFINALITY                          &amp;&amp;
7460          exc-&gt;rasterizer_version &gt;= TT_INTERPRETER_VERSION_35 )
7461     {
7462 
7463       if ( exc-&gt;rasterizer_version &gt;= 37 )
7464       {
<span class="line-modified">7465         /********************************/</span>
<span class="line-modified">7466         /* HINTING FOR SUBPIXEL         */</span>
<span class="line-modified">7467         /* Selector Bit:  6             */</span>
<span class="line-modified">7468         /* Return Bit(s): 13            */</span>
<span class="line-modified">7469         /*                              */</span>
7470         if ( ( args[0] &amp; 64 ) != 0 &amp;&amp; exc-&gt;subpixel_hinting )
7471           K |= 1 &lt;&lt; 13;
7472 
<span class="line-modified">7473         /********************************/</span>
<span class="line-modified">7474         /* COMPATIBLE WIDTHS ENABLED    */</span>
<span class="line-modified">7475         /* Selector Bit:  7             */</span>
<span class="line-modified">7476         /* Return Bit(s): 14            */</span>
<span class="line-modified">7477         /*                              */</span>
<span class="line-modified">7478         /* Functionality still needs to be added */</span>

7479         if ( ( args[0] &amp; 128 ) != 0 &amp;&amp; exc-&gt;compatible_widths )
7480           K |= 1 &lt;&lt; 14;
7481 
<span class="line-modified">7482         /********************************/</span>
<span class="line-modified">7483         /* VERTICAL LCD SUBPIXELS?      */</span>
<span class="line-modified">7484         /* Selector Bit:  8             */</span>
<span class="line-modified">7485         /* Return Bit(s): 15            */</span>
<span class="line-modified">7486         /*                              */</span>
<span class="line-modified">7487         /* Functionality still needs to be added */</span>

7488         if ( ( args[0] &amp; 256 ) != 0 &amp;&amp; exc-&gt;vertical_lcd )
7489           K |= 1 &lt;&lt; 15;
7490 
<span class="line-modified">7491         /********************************/</span>
<span class="line-modified">7492         /* HINTING FOR BGR?             */</span>
<span class="line-modified">7493         /* Selector Bit:  9             */</span>
<span class="line-modified">7494         /* Return Bit(s): 16            */</span>
<span class="line-modified">7495         /*                              */</span>
<span class="line-modified">7496         /* Functionality still needs to be added */</span>

7497         if ( ( args[0] &amp; 512 ) != 0 &amp;&amp; exc-&gt;bgr )
7498           K |= 1 &lt;&lt; 16;
7499 
7500         if ( exc-&gt;rasterizer_version &gt;= 38 )
7501         {
<span class="line-modified">7502           /********************************/</span>
<span class="line-modified">7503           /* SUBPIXEL POSITIONED?         */</span>
<span class="line-modified">7504           /* Selector Bit:  10            */</span>
<span class="line-modified">7505           /* Return Bit(s): 17            */</span>
<span class="line-modified">7506           /*                              */</span>
<span class="line-modified">7507           /* Functionality still needs to be added */</span>

7508           if ( ( args[0] &amp; 1024 ) != 0 &amp;&amp; exc-&gt;subpixel_positioned )
7509             K |= 1 &lt;&lt; 17;
7510 
<span class="line-modified">7511           /********************************/</span>
<span class="line-modified">7512           /* SYMMETRICAL SMOOTHING        */</span>
<span class="line-modified">7513           /* Selector Bit:  11            */</span>
<span class="line-modified">7514           /* Return Bit(s): 18            */</span>
<span class="line-modified">7515           /*                              */</span>
<span class="line-modified">7516           /* Functionality still needs to be added */</span>

7517           if ( ( args[0] &amp; 2048 ) != 0 &amp;&amp; exc-&gt;symmetrical_smoothing )
7518             K |= 1 &lt;&lt; 18;
7519 
<span class="line-modified">7520           /********************************/</span>
<span class="line-modified">7521           /* GRAY CLEARTYPE               */</span>
<span class="line-modified">7522           /* Selector Bit:  12            */</span>
<span class="line-modified">7523           /* Return Bit(s): 19            */</span>
<span class="line-modified">7524           /*                              */</span>
<span class="line-modified">7525           /* Functionality still needs to be added */</span>

7526           if ( ( args[0] &amp; 4096 ) != 0 &amp;&amp; exc-&gt;gray_cleartype )
7527             K |= 1 &lt;&lt; 19;
7528         }
7529       }
7530     }
7531 
7532 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7533 
7534     args[0] = K;
7535   }
7536 
7537 
7538 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
7539 
<span class="line-modified">7540   /*************************************************************************/</span>
<span class="line-modified">7541   /*                                                                       */</span>
<span class="line-modified">7542   /* GETVARIATION[]: get normalized variation (blend) coordinates          */</span>
<span class="line-modified">7543   /* Opcode range: 0x91                                                    */</span>
<span class="line-modified">7544   /* Stack:        --&gt; f2.14...                                            */</span>
<span class="line-modified">7545   /*                                                                       */</span>
<span class="line-modified">7546   /* XXX: UNDOCUMENTED!  There is no official documentation from Apple for */</span>
<span class="line-modified">7547   /*      this bytecode instruction.  Active only if a font has GX         */</span>
<span class="line-modified">7548   /*      variation axes.                                                  */</span>
<span class="line-modified">7549   /*                                                                       */</span>
7550   static void
7551   Ins_GETVARIATION( TT_ExecContext  exc,
7552                     FT_Long*        args )
7553   {
7554     FT_UInt    num_axes = exc-&gt;face-&gt;blend-&gt;num_axis;
7555     FT_Fixed*  coords   = exc-&gt;face-&gt;blend-&gt;normalizedcoords;
7556 
7557     FT_UInt  i;
7558 
7559 
7560     if ( BOUNDS( num_axes, exc-&gt;stackSize + 1 - exc-&gt;top ) )
7561     {
7562       exc-&gt;error = FT_THROW( Stack_Overflow );
7563       return;
7564     }
7565 
7566     if ( coords )
7567     {
7568       for ( i = 0; i &lt; num_axes; i++ )
7569         args[i] = coords[i] &gt;&gt; 2; /* convert 16.16 to 2.14 format */
7570     }
7571     else
7572     {
7573       for ( i = 0; i &lt; num_axes; i++ )
7574         args[i] = 0;
7575     }
7576   }
7577 
7578 
<span class="line-modified">7579   /*************************************************************************/</span>
<span class="line-modified">7580   /*                                                                       */</span>
<span class="line-modified">7581   /* GETDATA[]:    no idea what this is good for                           */</span>
<span class="line-modified">7582   /* Opcode range: 0x92                                                    */</span>
<span class="line-modified">7583   /* Stack:        --&gt; 17                                                  */</span>
<span class="line-modified">7584   /*                                                                       */</span>
<span class="line-modified">7585   /* XXX: UNDOCUMENTED!  There is no documentation from Apple for this     */</span>
<span class="line-modified">7586   /*      very weird bytecode instruction.                                 */</span>
<span class="line-modified">7587   /*                                                                       */</span>
7588   static void
7589   Ins_GETDATA( FT_Long*  args )
7590   {
7591     args[0] = 17;
7592   }
7593 
7594 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
7595 
7596 
7597   static void
7598   Ins_UNKNOWN( TT_ExecContext  exc )
7599   {
7600     TT_DefRecord*  def   = exc-&gt;IDefs;
7601     TT_DefRecord*  limit = def + exc-&gt;numIDefs;
7602 
7603 
7604     for ( ; def &lt; limit; def++ )
7605     {
7606       if ( (FT_Byte)def-&gt;opc == exc-&gt;opcode &amp;&amp; def-&gt;active )
7607       {
</pre>
<hr />
<pre>
7615         }
7616 
7617         call = exc-&gt;callStack + exc-&gt;callTop++;
7618 
7619         call-&gt;Caller_Range = exc-&gt;curRange;
7620         call-&gt;Caller_IP    = exc-&gt;IP + 1;
7621         call-&gt;Cur_Count    = 1;
7622         call-&gt;Def          = def;
7623 
7624         Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
7625 
7626         exc-&gt;step_ins = FALSE;
7627         return;
7628       }
7629     }
7630 
7631     exc-&gt;error = FT_THROW( Invalid_Opcode );
7632   }
7633 
7634 
<span class="line-modified">7635   /*************************************************************************/</span>
<span class="line-modified">7636   /*                                                                       */</span>
<span class="line-modified">7637   /* RUN                                                                   */</span>
<span class="line-modified">7638   /*                                                                       */</span>
<span class="line-modified">7639   /*  This function executes a run of opcodes.  It will exit in the        */</span>
<span class="line-modified">7640   /*  following cases:                                                     */</span>
<span class="line-modified">7641   /*                                                                       */</span>
<span class="line-modified">7642   /*  - Errors (in which case it returns FALSE).                           */</span>
<span class="line-modified">7643   /*                                                                       */</span>
<span class="line-modified">7644   /*  - Reaching the end of the main code range (returns TRUE).            */</span>
<span class="line-modified">7645   /*    Reaching the end of a code range within a function call is an      */</span>
<span class="line-modified">7646   /*    error.                                                             */</span>
<span class="line-modified">7647   /*                                                                       */</span>
<span class="line-modified">7648   /*  - After executing one single opcode, if the flag `Instruction_Trap&#39;  */</span>
<span class="line-modified">7649   /*    is set to TRUE (returns TRUE).                                     */</span>
<span class="line-modified">7650   /*                                                                       */</span>
<span class="line-modified">7651   /*  On exit with TRUE, test IP &lt; CodeSize to know whether it comes from  */</span>
<span class="line-modified">7652   /*  an instruction trap or a normal termination.                         */</span>
<span class="line-modified">7653   /*                                                                       */</span>
<span class="line-modified">7654   /*                                                                       */</span>
<span class="line-modified">7655   /*  Note: The documented DEBUG opcode pops a value from the stack.  This */</span>
<span class="line-modified">7656   /*        behaviour is unsupported; here a DEBUG opcode is always an     */</span>
<span class="line-modified">7657   /*        error.                                                         */</span>
<span class="line-modified">7658   /*                                                                       */</span>
<span class="line-modified">7659   /*                                                                       */</span>
<span class="line-modified">7660   /* THIS IS THE INTERPRETER&#39;S MAIN LOOP.                                  */</span>
<span class="line-modified">7661   /*                                                                       */</span>
<span class="line-modified">7662   /*************************************************************************/</span>
7663 
7664 
7665   /* documentation is in ttinterp.h */
7666 
7667   FT_EXPORT_DEF( FT_Error )
7668   TT_RunIns( TT_ExecContext  exc )
7669   {
7670     FT_ULong   ins_counter = 0;  /* executed instructions counter */
7671     FT_ULong   num_twilight_points;
7672     FT_UShort  i;
7673 
7674 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7675     FT_Byte    opcode_pattern[1][2] = {
7676                   /* #8 TypeMan Talk Align */
7677                   {
7678                     0x06, /* SPVTL   */
7679                     0x7D, /* RDTG    */
7680                   },
7681                 };
7682     FT_UShort  opcode_patterns   = 1;
7683     FT_UShort  opcode_pointer[1] = { 0 };
7684     FT_UShort  opcode_size[1]    = { 1 };
7685 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7686 
7687 
7688 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7689     exc-&gt;iup_called = FALSE;
7690 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7691 
7692 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
7693     /*
<span class="line-modified">7694      *  Toggle backward compatibility according to what font wants, except</span>
<span class="line-modified">7695      *  when</span>
7696      *
<span class="line-modified">7697      *  1) we have a `tricky&#39; font that heavily relies on the interpreter to</span>
<span class="line-modified">7698      *     render glyphs correctly, for example DFKai-SB, or</span>
<span class="line-modified">7699      *  2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.</span>
7700      *
<span class="line-modified">7701      *  In those cases, backward compatibility needs to be turned off to get</span>
<span class="line-modified">7702      *  correct rendering.  The rendering is then completely up to the</span>
<span class="line-modified">7703      *  font&#39;s programming.</span>
7704      *
7705      */
7706     if ( SUBPIXEL_HINTING_MINIMAL          &amp;&amp;
7707          exc-&gt;subpixel_hinting_lean        &amp;&amp;
7708          !FT_IS_TRICKY( &amp;exc-&gt;face-&gt;root ) )
7709       exc-&gt;backward_compatibility = !( exc-&gt;GS.instruct_control &amp; 4 );
7710     else
7711       exc-&gt;backward_compatibility = FALSE;
7712 
7713     exc-&gt;iupx_called = FALSE;
7714     exc-&gt;iupy_called = FALSE;
7715 #endif
7716 
7717     /* We restrict the number of twilight points to a reasonable,     */
7718     /* heuristic value to avoid slow execution of malformed bytecode. */
7719     num_twilight_points = FT_MAX( 30,
7720                                   2 * ( exc-&gt;pts.n_points + exc-&gt;cvtSize ) );
7721     if ( exc-&gt;twilight.n_points &gt; num_twilight_points )
7722     {
7723       if ( num_twilight_points &gt; 0xFFFFU )
</pre>
<hr />
<pre>
7784       exc-&gt;func_move_cvt  = Move_CVT;
7785     }
7786 
7787     Compute_Funcs( exc );
7788     Compute_Round( exc, (FT_Byte)exc-&gt;GS.round_state );
7789 
7790     do
7791     {
7792       exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];
7793 
7794 #ifdef FT_DEBUG_LEVEL_TRACE
7795       {
7796         FT_Long  cnt = FT_MIN( 8, exc-&gt;top );
7797         FT_Long  n;
7798 
7799 
7800         /* if tracing level is 7, show current code position */
7801         /* and the first few stack elements also             */
7802         FT_TRACE6(( &quot;  &quot; ));
7803         FT_TRACE7(( &quot;%06d &quot;, exc-&gt;IP ));
<span class="line-modified">7804         FT_TRACE6(( opcode_name[exc-&gt;opcode] + 2 ));</span>
7805         FT_TRACE7(( &quot;%*s&quot;, *opcode_name[exc-&gt;opcode] == &#39;A&#39;
7806                               ? 2
7807                               : 12 - ( *opcode_name[exc-&gt;opcode] - &#39;0&#39; ),
7808                               &quot;#&quot; ));
7809         for ( n = 1; n &lt;= cnt; n++ )
7810           FT_TRACE7(( &quot; %d&quot;, exc-&gt;stack[exc-&gt;top - n] ));
7811         FT_TRACE6(( &quot;\n&quot; ));
7812       }
7813 #endif /* FT_DEBUG_LEVEL_TRACE */
7814 
7815       if ( ( exc-&gt;length = opcode_length[exc-&gt;opcode] ) &lt; 0 )
7816       {
7817         if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )
7818           goto LErrorCodeOverflow_;
7819 
7820         exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];
7821       }
7822 
7823       if ( exc-&gt;IP + exc-&gt;length &gt; exc-&gt;codeSize )
7824         goto LErrorCodeOverflow_;
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ttinterp.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   TrueType bytecode interpreter (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 /* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
  20 /* issues; many thanks!                                                */
  21 
  22 
  23 #include &lt;ft2build.h&gt;
  24 #include FT_INTERNAL_DEBUG_H
  25 #include FT_INTERNAL_CALC_H
  26 #include FT_TRIGONOMETRY_H
  27 #include FT_SYSTEM_H
  28 #include FT_DRIVER_H
  29 #include FT_MULTIPLE_MASTERS_H
  30 
  31 #include &quot;ttinterp.h&quot;
  32 #include &quot;tterrors.h&quot;
  33 #include &quot;ttsubpix.h&quot;
  34 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  35 #include &quot;ttgxvar.h&quot;
  36 #endif
  37 
  38 
  39 #ifdef TT_USE_BYTECODE_INTERPRETER
  40 
  41 
<span class="line-modified">  42   /**************************************************************************</span>
<span class="line-modified">  43    *</span>
<span class="line-modified">  44    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  45    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  46    * messages during execution.</span>
<span class="line-modified">  47    */</span>
  48 #undef  FT_COMPONENT
<span class="line-modified">  49 #define FT_COMPONENT  ttinterp</span>
  50 
  51 
  52 #define NO_SUBPIXEL_HINTING                                                  \
  53           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  54             TT_INTERPRETER_VERSION_35 )
  55 
  56 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
  57 #define SUBPIXEL_HINTING_INFINALITY                                          \
  58           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  59             TT_INTERPRETER_VERSION_38 )
  60 #endif
  61 
  62 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
  63 #define SUBPIXEL_HINTING_MINIMAL                                             \
  64           ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \
  65             TT_INTERPRETER_VERSION_40 )
  66 #endif
  67 
  68 #define PROJECT( v1, v2 )                                   \
  69           exc-&gt;func_project( exc,                           \
  70                              SUB_LONG( (v1)-&gt;x, (v2)-&gt;x ),  \
  71                              SUB_LONG( (v1)-&gt;y, (v2)-&gt;y ) )
  72 
  73 #define DUALPROJ( v1, v2 )                                   \
  74           exc-&gt;func_dualproj( exc,                           \
  75                               SUB_LONG( (v1)-&gt;x, (v2)-&gt;x ),  \
  76                               SUB_LONG( (v1)-&gt;y, (v2)-&gt;y ) )
  77 
  78 #define FAST_PROJECT( v )                          \
  79           exc-&gt;func_project( exc, (v)-&gt;x, (v)-&gt;y )
  80 
  81 #define FAST_DUALPROJ( v )                          \
  82           exc-&gt;func_dualproj( exc, (v)-&gt;x, (v)-&gt;y )
  83 
  84 
<span class="line-modified">  85   /**************************************************************************</span>
<span class="line-modified">  86    *</span>
<span class="line-modified">  87    * Two simple bounds-checking macros.</span>
<span class="line-modified">  88    */</span>
  89 #define BOUNDS( x, n )   ( (FT_UInt)(x)  &gt;= (FT_UInt)(n)  )
  90 #define BOUNDSL( x, n )  ( (FT_ULong)(x) &gt;= (FT_ULong)(n) )
  91 
  92 
  93 #undef  SUCCESS
  94 #define SUCCESS  0
  95 
  96 #undef  FAILURE
  97 #define FAILURE  1
  98 
  99 
<span class="line-modified"> 100   /**************************************************************************</span>
<span class="line-modified"> 101    *</span>
<span class="line-modified"> 102    *                       CODERANGE FUNCTIONS</span>
<span class="line-modified"> 103    *</span>
<span class="line-modified"> 104    */</span>
<span class="line-modified"> 105 </span>
<span class="line-modified"> 106 </span>
<span class="line-modified"> 107   /**************************************************************************</span>
<span class="line-modified"> 108    *</span>
<span class="line-modified"> 109    * @Function:</span>
<span class="line-modified"> 110    *   TT_Goto_CodeRange</span>
<span class="line-modified"> 111    *</span>
<span class="line-modified"> 112    * @Description:</span>
<span class="line-modified"> 113    *   Switches to a new code range (updates the code related elements in</span>
<span class="line-modified"> 114    *   `exec&#39;, and `IP&#39;).</span>
<span class="line-modified"> 115    *</span>
<span class="line-modified"> 116    * @Input:</span>
<span class="line-modified"> 117    *   range ::</span>
<span class="line-modified"> 118    *     The new execution code range.</span>
<span class="line-modified"> 119    *</span>
<span class="line-modified"> 120    *   IP ::</span>
<span class="line-modified"> 121    *     The new IP in the new code range.</span>
<span class="line-modified"> 122    *</span>
<span class="line-modified"> 123    * @InOut:</span>
<span class="line-added"> 124    *   exec ::</span>
<span class="line-added"> 125    *     The target execution context.</span>
<span class="line-added"> 126    */</span>
 127   FT_LOCAL_DEF( void )
 128   TT_Goto_CodeRange( TT_ExecContext  exec,
 129                      FT_Int          range,
 130                      FT_Long         IP )
 131   {
 132     TT_CodeRange*  coderange;
 133 
 134 
 135     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 136 
 137     coderange = &amp;exec-&gt;codeRangeTable[range - 1];
 138 
 139     FT_ASSERT( coderange-&gt;base );
 140 
 141     /* NOTE: Because the last instruction of a program may be a CALL */
 142     /*       which will return to the first byte *after* the code    */
 143     /*       range, we test for IP &lt;= Size instead of IP &lt; Size.     */
 144     /*                                                               */
 145     FT_ASSERT( IP &lt;= coderange-&gt;size );
 146 
 147     exec-&gt;code     = coderange-&gt;base;
 148     exec-&gt;codeSize = coderange-&gt;size;
 149     exec-&gt;IP       = IP;
 150     exec-&gt;curRange = range;
 151   }
 152 
 153 
<span class="line-modified"> 154   /**************************************************************************</span>
<span class="line-modified"> 155    *</span>
<span class="line-modified"> 156    * @Function:</span>
<span class="line-modified"> 157    *   TT_Set_CodeRange</span>
<span class="line-modified"> 158    *</span>
<span class="line-modified"> 159    * @Description:</span>
<span class="line-modified"> 160    *   Sets a code range.</span>
<span class="line-modified"> 161    *</span>
<span class="line-modified"> 162    * @Input:</span>
<span class="line-modified"> 163    *   range ::</span>
<span class="line-modified"> 164    *     The code range index.</span>
<span class="line-modified"> 165    *</span>
<span class="line-modified"> 166    *   base ::</span>
<span class="line-modified"> 167    *     The new code base.</span>
<span class="line-modified"> 168    *</span>
<span class="line-modified"> 169    *   length ::</span>
<span class="line-modified"> 170    *     The range size in bytes.</span>
<span class="line-modified"> 171    *</span>
<span class="line-added"> 172    * @InOut:</span>
<span class="line-added"> 173    *   exec ::</span>
<span class="line-added"> 174    *     The target execution context.</span>
<span class="line-added"> 175    */</span>
 176   FT_LOCAL_DEF( void )
 177   TT_Set_CodeRange( TT_ExecContext  exec,
 178                     FT_Int          range,
 179                     void*           base,
 180                     FT_Long         length )
 181   {
 182     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 183 
 184     exec-&gt;codeRangeTable[range - 1].base = (FT_Byte*)base;
 185     exec-&gt;codeRangeTable[range - 1].size = length;
 186   }
 187 
 188 
<span class="line-modified"> 189   /**************************************************************************</span>
<span class="line-modified"> 190    *</span>
<span class="line-modified"> 191    * @Function:</span>
<span class="line-modified"> 192    *   TT_Clear_CodeRange</span>
<span class="line-modified"> 193    *</span>
<span class="line-modified"> 194    * @Description:</span>
<span class="line-modified"> 195    *   Clears a code range.</span>
<span class="line-modified"> 196    *</span>
<span class="line-modified"> 197    * @Input:</span>
<span class="line-modified"> 198    *   range ::</span>
<span class="line-modified"> 199    *     The code range index.</span>
<span class="line-modified"> 200    *</span>
<span class="line-modified"> 201    * @InOut:</span>
<span class="line-modified"> 202    *   exec ::</span>
<span class="line-added"> 203    *     The target execution context.</span>
<span class="line-added"> 204    */</span>
 205   FT_LOCAL_DEF( void )
 206   TT_Clear_CodeRange( TT_ExecContext  exec,
 207                       FT_Int          range )
 208   {
 209     FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );
 210 
 211     exec-&gt;codeRangeTable[range - 1].base = NULL;
 212     exec-&gt;codeRangeTable[range - 1].size = 0;
 213   }
 214 
 215 
<span class="line-modified"> 216   /**************************************************************************</span>
<span class="line-modified"> 217    *</span>
<span class="line-modified"> 218    *                  EXECUTION CONTEXT ROUTINES</span>
<span class="line-modified"> 219    *</span>
<span class="line-modified"> 220    */</span>
<span class="line-modified"> 221 </span>
<span class="line-modified"> 222 </span>
<span class="line-modified"> 223   /**************************************************************************</span>
<span class="line-modified"> 224    *</span>
<span class="line-modified"> 225    * @Function:</span>
<span class="line-modified"> 226    *   TT_Done_Context</span>
<span class="line-modified"> 227    *</span>
<span class="line-modified"> 228    * @Description:</span>
<span class="line-modified"> 229    *   Destroys a given context.</span>
<span class="line-modified"> 230    *</span>
<span class="line-modified"> 231    * @Input:</span>
<span class="line-modified"> 232    *   exec ::</span>
<span class="line-modified"> 233    *     A handle to the target execution context.</span>
<span class="line-modified"> 234    *</span>
<span class="line-modified"> 235    *   memory ::</span>
<span class="line-modified"> 236    *     A handle to the parent memory object.</span>
<span class="line-modified"> 237    *</span>
<span class="line-modified"> 238    * @Note:</span>
<span class="line-added"> 239    *   Only the glyph loader and debugger should call this function.</span>
<span class="line-added"> 240    */</span>
 241   FT_LOCAL_DEF( void )
 242   TT_Done_Context( TT_ExecContext  exec )
 243   {
 244     FT_Memory  memory = exec-&gt;memory;
 245 
 246 
 247     /* points zone */
 248     exec-&gt;maxPoints   = 0;
 249     exec-&gt;maxContours = 0;
 250 
 251     /* free stack */
 252     FT_FREE( exec-&gt;stack );
 253     exec-&gt;stackSize = 0;
 254 
 255     /* free call stack */
 256     FT_FREE( exec-&gt;callStack );
 257     exec-&gt;callSize = 0;
 258     exec-&gt;callTop  = 0;
 259 
 260     /* free glyph code range */
 261     FT_FREE( exec-&gt;glyphIns );
 262     exec-&gt;glyphSize = 0;
 263 
 264     exec-&gt;size = NULL;
 265     exec-&gt;face = NULL;
 266 
 267     FT_FREE( exec );
 268   }
 269 
 270 
<span class="line-modified"> 271   /**************************************************************************</span>
<span class="line-modified"> 272    *</span>
<span class="line-modified"> 273    * @Function:</span>
<span class="line-modified"> 274    *   Init_Context</span>
<span class="line-modified"> 275    *</span>
<span class="line-modified"> 276    * @Description:</span>
<span class="line-modified"> 277    *   Initializes a context object.</span>
<span class="line-modified"> 278    *</span>
<span class="line-modified"> 279    * @Input:</span>
<span class="line-modified"> 280    *   memory ::</span>
<span class="line-modified"> 281    *     A handle to the parent memory object.</span>
<span class="line-modified"> 282    *</span>
<span class="line-modified"> 283    * @InOut:</span>
<span class="line-modified"> 284    *   exec ::</span>
<span class="line-modified"> 285    *     A handle to the target execution context.</span>
<span class="line-modified"> 286    *</span>
<span class="line-modified"> 287    * @Return:</span>
<span class="line-added"> 288    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 289    */</span>
 290   static FT_Error
 291   Init_Context( TT_ExecContext  exec,
 292                 FT_Memory       memory )
 293   {
 294     FT_Error  error;
 295 
 296 
 297     FT_TRACE1(( &quot;Init_Context: new object at 0x%08p\n&quot;, exec ));
 298 
 299     exec-&gt;memory   = memory;
 300     exec-&gt;callSize = 32;
 301 
 302     if ( FT_NEW_ARRAY( exec-&gt;callStack, exec-&gt;callSize ) )
 303       goto Fail_Memory;
 304 
 305     /* all values in the context are set to 0 already, but this is */
 306     /* here as a remainder                                         */
 307     exec-&gt;maxPoints   = 0;
 308     exec-&gt;maxContours = 0;
 309 
 310     exec-&gt;stackSize = 0;
 311     exec-&gt;glyphSize = 0;
 312 
 313     exec-&gt;stack    = NULL;
 314     exec-&gt;glyphIns = NULL;
 315 
 316     exec-&gt;face = NULL;
 317     exec-&gt;size = NULL;
 318 
 319     return FT_Err_Ok;
 320 
 321   Fail_Memory:
 322     FT_ERROR(( &quot;Init_Context: not enough memory for %p\n&quot;, exec ));
 323     TT_Done_Context( exec );
 324 
 325     return error;
 326  }
 327 
 328 
<span class="line-modified"> 329   /**************************************************************************</span>
<span class="line-modified"> 330    *</span>
<span class="line-modified"> 331    * @Function:</span>
<span class="line-modified"> 332    *   Update_Max</span>
<span class="line-modified"> 333    *</span>
<span class="line-modified"> 334    * @Description:</span>
<span class="line-modified"> 335    *   Checks the size of a buffer and reallocates it if necessary.</span>
<span class="line-modified"> 336    *</span>
<span class="line-modified"> 337    * @Input:</span>
<span class="line-modified"> 338    *   memory ::</span>
<span class="line-modified"> 339    *     A handle to the parent memory object.</span>
<span class="line-modified"> 340    *</span>
<span class="line-modified"> 341    *   multiplier ::</span>
<span class="line-modified"> 342    *     The size in bytes of each element in the buffer.</span>
<span class="line-modified"> 343    *</span>
<span class="line-modified"> 344    *   new_max ::</span>
<span class="line-modified"> 345    *     The new capacity (size) of the buffer.</span>
<span class="line-modified"> 346    *</span>
<span class="line-modified"> 347    * @InOut:</span>
<span class="line-modified"> 348    *   size ::</span>
<span class="line-modified"> 349    *     The address of the buffer&#39;s current size expressed</span>
<span class="line-modified"> 350    *     in elements.</span>
<span class="line-modified"> 351    *</span>
<span class="line-modified"> 352    *   buff ::</span>
<span class="line-added"> 353    *     The address of the buffer base pointer.</span>
<span class="line-added"> 354    *</span>
<span class="line-added"> 355    * @Return:</span>
<span class="line-added"> 356    *   FreeType error code.  0 means success.</span>
<span class="line-added"> 357    */</span>
 358   FT_LOCAL_DEF( FT_Error )
 359   Update_Max( FT_Memory  memory,
 360               FT_ULong*  size,
 361               FT_ULong   multiplier,
 362               void*      _pbuff,
 363               FT_ULong   new_max )
 364   {
 365     FT_Error  error;
 366     void**    pbuff = (void**)_pbuff;
 367 
 368 
 369     if ( *size &lt; new_max )
 370     {
 371       if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
 372         return error;
 373       *size = new_max;
 374     }
 375 
 376     return FT_Err_Ok;
 377   }
 378 
 379 
<span class="line-modified"> 380   /**************************************************************************</span>
<span class="line-modified"> 381    *</span>
<span class="line-modified"> 382    * @Function:</span>
<span class="line-modified"> 383    *   TT_Load_Context</span>
<span class="line-modified"> 384    *</span>
<span class="line-modified"> 385    * @Description:</span>
<span class="line-modified"> 386    *   Prepare an execution context for glyph hinting.</span>
<span class="line-modified"> 387    *</span>
<span class="line-modified"> 388    * @Input:</span>
<span class="line-modified"> 389    *   face ::</span>
<span class="line-modified"> 390    *     A handle to the source face object.</span>
<span class="line-modified"> 391    *</span>
<span class="line-modified"> 392    *   size ::</span>
<span class="line-modified"> 393    *     A handle to the source size object.</span>
<span class="line-modified"> 394    *</span>
<span class="line-modified"> 395    * @InOut:</span>
<span class="line-modified"> 396    *   exec ::</span>
<span class="line-modified"> 397    *     A handle to the target execution context.</span>
<span class="line-modified"> 398    *</span>
<span class="line-modified"> 399    * @Return:</span>
<span class="line-modified"> 400    *   FreeType error code.  0 means success.</span>
<span class="line-modified"> 401    *</span>
<span class="line-added"> 402    * @Note:</span>
<span class="line-added"> 403    *   Only the glyph loader and debugger should call this function.</span>
<span class="line-added"> 404    */</span>
 405   FT_LOCAL_DEF( FT_Error )
 406   TT_Load_Context( TT_ExecContext  exec,
 407                    TT_Face         face,
 408                    TT_Size         size )
 409   {
 410     FT_Int          i;
 411     FT_ULong        tmp;
 412     TT_MaxProfile*  maxp;
 413     FT_Error        error;
 414 
 415 
 416     exec-&gt;face = face;
 417     maxp       = &amp;face-&gt;max_profile;
 418     exec-&gt;size = size;
 419 
 420     if ( size )
 421     {
 422       exec-&gt;numFDefs   = size-&gt;num_function_defs;
 423       exec-&gt;maxFDefs   = size-&gt;max_function_defs;
 424       exec-&gt;numIDefs   = size-&gt;num_instruction_defs;
</pre>
<hr />
<pre>
 471                         sizeof ( FT_Byte ),
 472                         (void*)&amp;exec-&gt;glyphIns,
 473                         maxp-&gt;maxSizeOfInstructions );
 474     exec-&gt;glyphSize = (FT_UShort)tmp;
 475     if ( error )
 476       return error;
 477 
 478     exec-&gt;pts.n_points   = 0;
 479     exec-&gt;pts.n_contours = 0;
 480 
 481     exec-&gt;zp1 = exec-&gt;pts;
 482     exec-&gt;zp2 = exec-&gt;pts;
 483     exec-&gt;zp0 = exec-&gt;pts;
 484 
 485     exec-&gt;instruction_trap = FALSE;
 486 
 487     return FT_Err_Ok;
 488   }
 489 
 490 
<span class="line-modified"> 491   /**************************************************************************</span>
<span class="line-modified"> 492    *</span>
<span class="line-modified"> 493    * @Function:</span>
<span class="line-modified"> 494    *   TT_Save_Context</span>
<span class="line-modified"> 495    *</span>
<span class="line-modified"> 496    * @Description:</span>
<span class="line-modified"> 497    *   Saves the code ranges in a `size&#39; object.</span>
<span class="line-modified"> 498    *</span>
<span class="line-modified"> 499    * @Input:</span>
<span class="line-modified"> 500    *   exec ::</span>
<span class="line-modified"> 501    *     A handle to the source execution context.</span>
<span class="line-modified"> 502    *</span>
<span class="line-modified"> 503    * @InOut:</span>
<span class="line-modified"> 504    *   size ::</span>
<span class="line-modified"> 505    *     A handle to the target size object.</span>
<span class="line-modified"> 506    *</span>
<span class="line-modified"> 507    * @Note:</span>
<span class="line-added"> 508    *   Only the glyph loader and debugger should call this function.</span>
<span class="line-added"> 509    */</span>
 510   FT_LOCAL_DEF( void )
 511   TT_Save_Context( TT_ExecContext  exec,
 512                    TT_Size         size )
 513   {
 514     FT_Int  i;
 515 
 516 
 517     /* XXX: Will probably disappear soon with all the code range */
 518     /*      management, which is now rather obsolete.            */
 519     /*                                                           */
 520     size-&gt;num_function_defs    = exec-&gt;numFDefs;
 521     size-&gt;num_instruction_defs = exec-&gt;numIDefs;
 522 
 523     size-&gt;max_func = exec-&gt;maxFunc;
 524     size-&gt;max_ins  = exec-&gt;maxIns;
 525 
 526     for ( i = 0; i &lt; TT_MAX_CODE_RANGES; i++ )
 527       size-&gt;codeRangeTable[i] = exec-&gt;codeRangeTable[i];
 528   }
 529 
 530 
<span class="line-modified"> 531   /**************************************************************************</span>
<span class="line-modified"> 532    *</span>
<span class="line-modified"> 533    * @Function:</span>
<span class="line-modified"> 534    *   TT_Run_Context</span>
<span class="line-modified"> 535    *</span>
<span class="line-modified"> 536    * @Description:</span>
<span class="line-modified"> 537    *   Executes one or more instructions in the execution context.</span>
<span class="line-modified"> 538    *</span>
<span class="line-modified"> 539    * @Input:</span>
<span class="line-modified"> 540    *   exec ::</span>
<span class="line-modified"> 541    *     A handle to the target execution context.</span>
<span class="line-modified"> 542    *</span>
<span class="line-modified"> 543    * @Return:</span>
<span class="line-modified"> 544    *   TrueType error code.  0 means success.</span>
<span class="line-modified"> 545    */</span>






 546   FT_LOCAL_DEF( FT_Error )
 547   TT_Run_Context( TT_ExecContext  exec )
 548   {
 549     TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );
 550 
 551     exec-&gt;zp0 = exec-&gt;pts;
 552     exec-&gt;zp1 = exec-&gt;pts;
 553     exec-&gt;zp2 = exec-&gt;pts;
 554 
 555     exec-&gt;GS.gep0 = 1;
 556     exec-&gt;GS.gep1 = 1;
 557     exec-&gt;GS.gep2 = 1;
 558 
 559     exec-&gt;GS.projVector.x = 0x4000;
 560     exec-&gt;GS.projVector.y = 0x0000;
 561 
 562     exec-&gt;GS.freeVector = exec-&gt;GS.projVector;
 563     exec-&gt;GS.dualVector = exec-&gt;GS.projVector;
 564 
 565     exec-&gt;GS.round_state = 1;
</pre>
<hr />
<pre>
 609       goto Fail;
 610 
 611     memory = driver-&gt;root.root.memory;
 612 
 613     /* allocate object */
 614     if ( FT_NEW( exec ) )
 615       goto Fail;
 616 
 617     /* initialize it; in case of error this deallocates `exec&#39; too */
 618     error = Init_Context( exec, memory );
 619     if ( error )
 620       goto Fail;
 621 
 622     return exec;
 623 
 624   Fail:
 625     return NULL;
 626   }
 627 
 628 
<span class="line-modified"> 629   /**************************************************************************</span>
<span class="line-modified"> 630    *</span>
<span class="line-modified"> 631    * Before an opcode is executed, the interpreter verifies that there are</span>
<span class="line-modified"> 632    * enough arguments on the stack, with the help of the `Pop_Push_Count&#39;</span>
<span class="line-modified"> 633    * table.</span>
<span class="line-modified"> 634    *</span>
<span class="line-modified"> 635    * For each opcode, the first column gives the number of arguments that</span>
<span class="line-modified"> 636    * are popped from the stack; the second one gives the number of those</span>
<span class="line-modified"> 637    * that are pushed in result.</span>
<span class="line-modified"> 638    *</span>
<span class="line-modified"> 639    * Opcodes which have a varying number of parameters in the data stream</span>
<span class="line-modified"> 640    * (NPUSHB, NPUSHW) are handled specially; they have a negative value in</span>
<span class="line-modified"> 641    * the `opcode_length&#39; table, and the value in `Pop_Push_Count&#39; is set</span>
<span class="line-modified"> 642    * to zero.</span>
<span class="line-modified"> 643    *</span>
<span class="line-modified"> 644    */</span>
 645 
 646 
 647 #undef  PACK
 648 #define PACK( x, y )  ( ( x &lt;&lt; 4 ) | y )
 649 
 650 
 651   static
 652   const FT_Byte  Pop_Push_Count[256] =
 653   {
 654     /* opcodes are gathered in groups of 16 */
 655     /* please keep the spaces as they are   */
 656 
<span class="line-modified"> 657     /* 0x00 */</span>
<span class="line-modified"> 658     /*  SVTCA[0]  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 659     /*  SVTCA[1]  */  PACK( 0, 0 ),</span>
<span class="line-modified"> 660     /*  SPVTCA[0] */  PACK( 0, 0 ),</span>
<span class="line-modified"> 661     /*  SPVTCA[1] */  PACK( 0, 0 ),</span>
<span class="line-modified"> 662     /*  SFVTCA[0] */  PACK( 0, 0 ),</span>
<span class="line-modified"> 663     /*  SFVTCA[1] */  PACK( 0, 0 ),</span>
<span class="line-modified"> 664     /*  SPVTL[0]  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 665     /*  SPVTL[1]  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 666     /*  SFVTL[0]  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 667     /*  SFVTL[1]  */  PACK( 2, 0 ),</span>
<span class="line-modified"> 668     /*  SPVFS     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 669     /*  SFVFS     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 670     /*  GPV       */  PACK( 0, 2 ),</span>
<span class="line-modified"> 671     /*  GFV       */  PACK( 0, 2 ),</span>
<span class="line-added"> 672     /*  SFVTPV    */  PACK( 0, 0 ),</span>
 673     /*  ISECT     */  PACK( 5, 0 ),
 674 
<span class="line-added"> 675     /* 0x10 */</span>
 676     /*  SRP0      */  PACK( 1, 0 ),
 677     /*  SRP1      */  PACK( 1, 0 ),
 678     /*  SRP2      */  PACK( 1, 0 ),
 679     /*  SZP0      */  PACK( 1, 0 ),
 680     /*  SZP1      */  PACK( 1, 0 ),
 681     /*  SZP2      */  PACK( 1, 0 ),
 682     /*  SZPS      */  PACK( 1, 0 ),
 683     /*  SLOOP     */  PACK( 1, 0 ),
 684     /*  RTG       */  PACK( 0, 0 ),
 685     /*  RTHG      */  PACK( 0, 0 ),
 686     /*  SMD       */  PACK( 1, 0 ),
 687     /*  ELSE      */  PACK( 0, 0 ),
 688     /*  JMPR      */  PACK( 1, 0 ),
<span class="line-modified"> 689     /*  SCVTCI    */  PACK( 1, 0 ),</span>
<span class="line-modified"> 690     /*  SSWCI     */  PACK( 1, 0 ),</span>
 691     /*  SSW       */  PACK( 1, 0 ),
 692 
<span class="line-added"> 693     /* 0x20 */</span>
 694     /*  DUP       */  PACK( 1, 2 ),
 695     /*  POP       */  PACK( 1, 0 ),
 696     /*  CLEAR     */  PACK( 0, 0 ),
 697     /*  SWAP      */  PACK( 2, 2 ),
 698     /*  DEPTH     */  PACK( 0, 1 ),
 699     /*  CINDEX    */  PACK( 1, 1 ),
 700     /*  MINDEX    */  PACK( 1, 0 ),
<span class="line-modified"> 701     /*  ALIGNPTS  */  PACK( 2, 0 ),</span>
 702     /*  INS_$28   */  PACK( 0, 0 ),
 703     /*  UTP       */  PACK( 1, 0 ),
 704     /*  LOOPCALL  */  PACK( 2, 0 ),
 705     /*  CALL      */  PACK( 1, 0 ),
 706     /*  FDEF      */  PACK( 1, 0 ),
 707     /*  ENDF      */  PACK( 0, 0 ),
 708     /*  MDAP[0]   */  PACK( 1, 0 ),
 709     /*  MDAP[1]   */  PACK( 1, 0 ),
 710 
<span class="line-added"> 711     /* 0x30 */</span>
 712     /*  IUP[0]    */  PACK( 0, 0 ),
 713     /*  IUP[1]    */  PACK( 0, 0 ),
 714     /*  SHP[0]    */  PACK( 0, 0 ), /* loops */
 715     /*  SHP[1]    */  PACK( 0, 0 ), /* loops */
 716     /*  SHC[0]    */  PACK( 1, 0 ),
 717     /*  SHC[1]    */  PACK( 1, 0 ),
 718     /*  SHZ[0]    */  PACK( 1, 0 ),
 719     /*  SHZ[1]    */  PACK( 1, 0 ),
 720     /*  SHPIX     */  PACK( 1, 0 ), /* loops */
 721     /*  IP        */  PACK( 0, 0 ), /* loops */
 722     /*  MSIRP[0]  */  PACK( 2, 0 ),
 723     /*  MSIRP[1]  */  PACK( 2, 0 ),
<span class="line-modified"> 724     /*  ALIGNRP   */  PACK( 0, 0 ), /* loops */</span>
 725     /*  RTDG      */  PACK( 0, 0 ),
 726     /*  MIAP[0]   */  PACK( 2, 0 ),
 727     /*  MIAP[1]   */  PACK( 2, 0 ),
 728 
<span class="line-modified"> 729     /* 0x40 */</span>
<span class="line-modified"> 730     /*  NPUSHB    */  PACK( 0, 0 ),</span>
<span class="line-added"> 731     /*  NPUSHW    */  PACK( 0, 0 ),</span>
 732     /*  WS        */  PACK( 2, 0 ),
 733     /*  RS        */  PACK( 1, 1 ),
<span class="line-modified"> 734     /*  WCVTP     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 735     /*  RCVT      */  PACK( 1, 1 ),</span>
 736     /*  GC[0]     */  PACK( 1, 1 ),
 737     /*  GC[1]     */  PACK( 1, 1 ),
 738     /*  SCFS      */  PACK( 2, 0 ),
 739     /*  MD[0]     */  PACK( 2, 1 ),
 740     /*  MD[1]     */  PACK( 2, 1 ),
 741     /*  MPPEM     */  PACK( 0, 1 ),
 742     /*  MPS       */  PACK( 0, 1 ),
<span class="line-modified"> 743     /*  FLIPON    */  PACK( 0, 0 ),</span>
<span class="line-modified"> 744     /*  FLIPOFF   */  PACK( 0, 0 ),</span>
 745     /*  DEBUG     */  PACK( 1, 0 ),
 746 
<span class="line-added"> 747     /* 0x50 */</span>
 748     /*  LT        */  PACK( 2, 1 ),
 749     /*  LTEQ      */  PACK( 2, 1 ),
 750     /*  GT        */  PACK( 2, 1 ),
 751     /*  GTEQ      */  PACK( 2, 1 ),
 752     /*  EQ        */  PACK( 2, 1 ),
 753     /*  NEQ       */  PACK( 2, 1 ),
 754     /*  ODD       */  PACK( 1, 1 ),
 755     /*  EVEN      */  PACK( 1, 1 ),
 756     /*  IF        */  PACK( 1, 0 ),
 757     /*  EIF       */  PACK( 0, 0 ),
 758     /*  AND       */  PACK( 2, 1 ),
 759     /*  OR        */  PACK( 2, 1 ),
 760     /*  NOT       */  PACK( 1, 1 ),
<span class="line-modified"> 761     /*  DELTAP1   */  PACK( 1, 0 ),</span>
 762     /*  SDB       */  PACK( 1, 0 ),
 763     /*  SDS       */  PACK( 1, 0 ),
 764 
<span class="line-added"> 765     /* 0x60 */</span>
 766     /*  ADD       */  PACK( 2, 1 ),
 767     /*  SUB       */  PACK( 2, 1 ),
 768     /*  DIV       */  PACK( 2, 1 ),
 769     /*  MUL       */  PACK( 2, 1 ),
 770     /*  ABS       */  PACK( 1, 1 ),
 771     /*  NEG       */  PACK( 1, 1 ),
 772     /*  FLOOR     */  PACK( 1, 1 ),
 773     /*  CEILING   */  PACK( 1, 1 ),
 774     /*  ROUND[0]  */  PACK( 1, 1 ),
 775     /*  ROUND[1]  */  PACK( 1, 1 ),
 776     /*  ROUND[2]  */  PACK( 1, 1 ),
 777     /*  ROUND[3]  */  PACK( 1, 1 ),
 778     /*  NROUND[0] */  PACK( 1, 1 ),
 779     /*  NROUND[1] */  PACK( 1, 1 ),
 780     /*  NROUND[2] */  PACK( 1, 1 ),
 781     /*  NROUND[3] */  PACK( 1, 1 ),
 782 
<span class="line-modified"> 783     /* 0x70 */</span>
<span class="line-modified"> 784     /*  WCVTF     */  PACK( 2, 0 ),</span>
<span class="line-modified"> 785     /*  DELTAP2   */  PACK( 1, 0 ),</span>
<span class="line-modified"> 786     /*  DELTAP3   */  PACK( 1, 0 ),</span>
<span class="line-modified"> 787     /*  DELTAC1   */  PACK( 1, 0 ),</span>
<span class="line-modified"> 788     /*  DELTAC2   */  PACK( 1, 0 ),</span>
<span class="line-added"> 789     /*  DELTAC3   */  PACK( 1, 0 ),</span>
 790     /*  SROUND    */  PACK( 1, 0 ),
<span class="line-modified"> 791     /*  S45ROUND  */  PACK( 1, 0 ),</span>
 792     /*  JROT      */  PACK( 2, 0 ),
 793     /*  JROF      */  PACK( 2, 0 ),
 794     /*  ROFF      */  PACK( 0, 0 ),
 795     /*  INS_$7B   */  PACK( 0, 0 ),
 796     /*  RUTG      */  PACK( 0, 0 ),
 797     /*  RDTG      */  PACK( 0, 0 ),
 798     /*  SANGW     */  PACK( 1, 0 ),
 799     /*  AA        */  PACK( 1, 0 ),
 800 
<span class="line-modified"> 801     /* 0x80 */</span>
<span class="line-modified"> 802     /*  FLIPPT    */  PACK( 0, 0 ), /* loops */</span>
<span class="line-modified"> 803     /*  FLIPRGON  */  PACK( 2, 0 ),</span>
<span class="line-added"> 804     /*  FLIPRGOFF */  PACK( 2, 0 ),</span>
 805     /*  INS_$83   */  PACK( 0, 0 ),
 806     /*  INS_$84   */  PACK( 0, 0 ),
<span class="line-modified"> 807     /*  SCANCTRL  */  PACK( 1, 0 ),</span>
<span class="line-modified"> 808     /*  SDPVTL[0] */  PACK( 2, 0 ),</span>
<span class="line-modified"> 809     /*  SDPVTL[1] */  PACK( 2, 0 ),</span>
<span class="line-modified"> 810     /*  GETINFO   */  PACK( 1, 1 ),</span>
 811     /*  IDEF      */  PACK( 1, 0 ),
 812     /*  ROLL      */  PACK( 3, 3 ),
 813     /*  MAX       */  PACK( 2, 1 ),
 814     /*  MIN       */  PACK( 2, 1 ),
<span class="line-modified"> 815     /*  SCANTYPE  */  PACK( 1, 0 ),</span>
<span class="line-modified"> 816     /*  INSTCTRL  */  PACK( 2, 0 ),</span>
 817     /*  INS_$8F   */  PACK( 0, 0 ),
 818 
<span class="line-added"> 819     /* 0x90 */</span>
 820     /*  INS_$90  */   PACK( 0, 0 ),
 821     /*  GETVAR   */   PACK( 0, 0 ), /* will be handled specially */
 822     /*  GETDATA  */   PACK( 0, 1 ),
 823     /*  INS_$93  */   PACK( 0, 0 ),
 824     /*  INS_$94  */   PACK( 0, 0 ),
 825     /*  INS_$95  */   PACK( 0, 0 ),
 826     /*  INS_$96  */   PACK( 0, 0 ),
 827     /*  INS_$97  */   PACK( 0, 0 ),
 828     /*  INS_$98  */   PACK( 0, 0 ),
 829     /*  INS_$99  */   PACK( 0, 0 ),
 830     /*  INS_$9A  */   PACK( 0, 0 ),
 831     /*  INS_$9B  */   PACK( 0, 0 ),
 832     /*  INS_$9C  */   PACK( 0, 0 ),
 833     /*  INS_$9D  */   PACK( 0, 0 ),
 834     /*  INS_$9E  */   PACK( 0, 0 ),
 835     /*  INS_$9F  */   PACK( 0, 0 ),
 836 
<span class="line-added"> 837     /* 0xA0 */</span>
 838     /*  INS_$A0  */   PACK( 0, 0 ),
 839     /*  INS_$A1  */   PACK( 0, 0 ),
 840     /*  INS_$A2  */   PACK( 0, 0 ),
 841     /*  INS_$A3  */   PACK( 0, 0 ),
 842     /*  INS_$A4  */   PACK( 0, 0 ),
 843     /*  INS_$A5  */   PACK( 0, 0 ),
 844     /*  INS_$A6  */   PACK( 0, 0 ),
 845     /*  INS_$A7  */   PACK( 0, 0 ),
 846     /*  INS_$A8  */   PACK( 0, 0 ),
 847     /*  INS_$A9  */   PACK( 0, 0 ),
 848     /*  INS_$AA  */   PACK( 0, 0 ),
 849     /*  INS_$AB  */   PACK( 0, 0 ),
 850     /*  INS_$AC  */   PACK( 0, 0 ),
 851     /*  INS_$AD  */   PACK( 0, 0 ),
 852     /*  INS_$AE  */   PACK( 0, 0 ),
 853     /*  INS_$AF  */   PACK( 0, 0 ),
 854 
<span class="line-modified"> 855     /* 0xB0 */</span>
<span class="line-modified"> 856     /*  PUSHB[0]  */  PACK( 0, 1 ),</span>
<span class="line-modified"> 857     /*  PUSHB[1]  */  PACK( 0, 2 ),</span>
<span class="line-modified"> 858     /*  PUSHB[2]  */  PACK( 0, 3 ),</span>
<span class="line-modified"> 859     /*  PUSHB[3]  */  PACK( 0, 4 ),</span>
<span class="line-modified"> 860     /*  PUSHB[4]  */  PACK( 0, 5 ),</span>
<span class="line-modified"> 861     /*  PUSHB[5]  */  PACK( 0, 6 ),</span>
<span class="line-modified"> 862     /*  PUSHB[6]  */  PACK( 0, 7 ),</span>
<span class="line-modified"> 863     /*  PUSHB[7]  */  PACK( 0, 8 ),</span>
<span class="line-modified"> 864     /*  PUSHW[0]  */  PACK( 0, 1 ),</span>
<span class="line-modified"> 865     /*  PUSHW[1]  */  PACK( 0, 2 ),</span>
<span class="line-modified"> 866     /*  PUSHW[2]  */  PACK( 0, 3 ),</span>
<span class="line-modified"> 867     /*  PUSHW[3]  */  PACK( 0, 4 ),</span>
<span class="line-modified"> 868     /*  PUSHW[4]  */  PACK( 0, 5 ),</span>
<span class="line-modified"> 869     /*  PUSHW[5]  */  PACK( 0, 6 ),</span>
<span class="line-modified"> 870     /*  PUSHW[6]  */  PACK( 0, 7 ),</span>
<span class="line-modified"> 871     /*  PUSHW[7]  */  PACK( 0, 8 ),</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873     /* 0xC0 */</span>
 874     /*  MDRP[00]  */  PACK( 1, 0 ),
 875     /*  MDRP[01]  */  PACK( 1, 0 ),
 876     /*  MDRP[02]  */  PACK( 1, 0 ),
 877     /*  MDRP[03]  */  PACK( 1, 0 ),
 878     /*  MDRP[04]  */  PACK( 1, 0 ),
 879     /*  MDRP[05]  */  PACK( 1, 0 ),
 880     /*  MDRP[06]  */  PACK( 1, 0 ),
 881     /*  MDRP[07]  */  PACK( 1, 0 ),
 882     /*  MDRP[08]  */  PACK( 1, 0 ),
 883     /*  MDRP[09]  */  PACK( 1, 0 ),
 884     /*  MDRP[10]  */  PACK( 1, 0 ),
 885     /*  MDRP[11]  */  PACK( 1, 0 ),
 886     /*  MDRP[12]  */  PACK( 1, 0 ),
 887     /*  MDRP[13]  */  PACK( 1, 0 ),
 888     /*  MDRP[14]  */  PACK( 1, 0 ),
 889     /*  MDRP[15]  */  PACK( 1, 0 ),
 890 
<span class="line-added"> 891     /* 0xD0 */</span>
 892     /*  MDRP[16]  */  PACK( 1, 0 ),
 893     /*  MDRP[17]  */  PACK( 1, 0 ),
 894     /*  MDRP[18]  */  PACK( 1, 0 ),
 895     /*  MDRP[19]  */  PACK( 1, 0 ),
 896     /*  MDRP[20]  */  PACK( 1, 0 ),
 897     /*  MDRP[21]  */  PACK( 1, 0 ),
 898     /*  MDRP[22]  */  PACK( 1, 0 ),
 899     /*  MDRP[23]  */  PACK( 1, 0 ),
 900     /*  MDRP[24]  */  PACK( 1, 0 ),
 901     /*  MDRP[25]  */  PACK( 1, 0 ),
 902     /*  MDRP[26]  */  PACK( 1, 0 ),
 903     /*  MDRP[27]  */  PACK( 1, 0 ),
 904     /*  MDRP[28]  */  PACK( 1, 0 ),
 905     /*  MDRP[29]  */  PACK( 1, 0 ),
 906     /*  MDRP[30]  */  PACK( 1, 0 ),
 907     /*  MDRP[31]  */  PACK( 1, 0 ),
 908 
<span class="line-added"> 909     /* 0xE0 */</span>
 910     /*  MIRP[00]  */  PACK( 2, 0 ),
 911     /*  MIRP[01]  */  PACK( 2, 0 ),
 912     /*  MIRP[02]  */  PACK( 2, 0 ),
 913     /*  MIRP[03]  */  PACK( 2, 0 ),
 914     /*  MIRP[04]  */  PACK( 2, 0 ),
 915     /*  MIRP[05]  */  PACK( 2, 0 ),
 916     /*  MIRP[06]  */  PACK( 2, 0 ),
 917     /*  MIRP[07]  */  PACK( 2, 0 ),
 918     /*  MIRP[08]  */  PACK( 2, 0 ),
 919     /*  MIRP[09]  */  PACK( 2, 0 ),
 920     /*  MIRP[10]  */  PACK( 2, 0 ),
 921     /*  MIRP[11]  */  PACK( 2, 0 ),
 922     /*  MIRP[12]  */  PACK( 2, 0 ),
 923     /*  MIRP[13]  */  PACK( 2, 0 ),
 924     /*  MIRP[14]  */  PACK( 2, 0 ),
 925     /*  MIRP[15]  */  PACK( 2, 0 ),
 926 
<span class="line-added"> 927     /* 0xF0 */</span>
 928     /*  MIRP[16]  */  PACK( 2, 0 ),
 929     /*  MIRP[17]  */  PACK( 2, 0 ),
 930     /*  MIRP[18]  */  PACK( 2, 0 ),
 931     /*  MIRP[19]  */  PACK( 2, 0 ),
 932     /*  MIRP[20]  */  PACK( 2, 0 ),
 933     /*  MIRP[21]  */  PACK( 2, 0 ),
 934     /*  MIRP[22]  */  PACK( 2, 0 ),
 935     /*  MIRP[23]  */  PACK( 2, 0 ),
 936     /*  MIRP[24]  */  PACK( 2, 0 ),
 937     /*  MIRP[25]  */  PACK( 2, 0 ),
 938     /*  MIRP[26]  */  PACK( 2, 0 ),
 939     /*  MIRP[27]  */  PACK( 2, 0 ),
 940     /*  MIRP[28]  */  PACK( 2, 0 ),
 941     /*  MIRP[29]  */  PACK( 2, 0 ),
 942     /*  MIRP[30]  */  PACK( 2, 0 ),
 943     /*  MIRP[31]  */  PACK( 2, 0 )
 944   };
 945 
 946 
 947 #ifdef FT_DEBUG_LEVEL_TRACE
 948 
 949   /* the first hex digit gives the length of the opcode name; the space */
 950   /* after the digit is here just to increase readability of the source */
 951   /* code                                                               */
 952 
 953   static
 954   const char*  const opcode_name[256] =
 955   {
<span class="line-modified"> 956     /* 0x00 */</span>
<span class="line-modified"> 957     &quot;8 SVTCA[y]&quot;,</span>
<span class="line-modified"> 958     &quot;8 SVTCA[x]&quot;,</span>
<span class="line-modified"> 959     &quot;9 SPVTCA[y]&quot;,</span>
<span class="line-modified"> 960     &quot;9 SPVTCA[x]&quot;,</span>
<span class="line-modified"> 961     &quot;9 SFVTCA[y]&quot;,</span>
<span class="line-modified"> 962     &quot;9 SFVTCA[x]&quot;,</span>
<span class="line-modified"> 963     &quot;9 SPVTL[||]&quot;,</span>
<span class="line-modified"> 964     &quot;8 SPVTL[+]&quot;,</span>
<span class="line-modified"> 965     &quot;9 SFVTL[||]&quot;,</span>
<span class="line-modified"> 966     &quot;8 SFVTL[+]&quot;,</span>
<span class="line-modified"> 967     &quot;5 SPVFS&quot;,</span>
<span class="line-modified"> 968     &quot;5 SFVFS&quot;,</span>
<span class="line-modified"> 969     &quot;3 GPV&quot;,</span>
<span class="line-modified"> 970     &quot;3 GFV&quot;,</span>
<span class="line-added"> 971     &quot;6 SFVTPV&quot;,</span>
 972     &quot;5 ISECT&quot;,
 973 
<span class="line-added"> 974     /* 0x10 */</span>
 975     &quot;4 SRP0&quot;,
 976     &quot;4 SRP1&quot;,
 977     &quot;4 SRP2&quot;,
 978     &quot;4 SZP0&quot;,
 979     &quot;4 SZP1&quot;,
 980     &quot;4 SZP2&quot;,
 981     &quot;4 SZPS&quot;,
 982     &quot;5 SLOOP&quot;,
 983     &quot;3 RTG&quot;,
 984     &quot;4 RTHG&quot;,
 985     &quot;3 SMD&quot;,
 986     &quot;4 ELSE&quot;,
 987     &quot;4 JMPR&quot;,
<span class="line-modified"> 988     &quot;6 SCVTCI&quot;,</span>
<span class="line-modified"> 989     &quot;5 SSWCI&quot;,</span>
 990     &quot;3 SSW&quot;,
 991 
<span class="line-added"> 992     /* 0x20 */</span>
 993     &quot;3 DUP&quot;,
 994     &quot;3 POP&quot;,
 995     &quot;5 CLEAR&quot;,
 996     &quot;4 SWAP&quot;,
 997     &quot;5 DEPTH&quot;,
 998     &quot;6 CINDEX&quot;,
 999     &quot;6 MINDEX&quot;,
<span class="line-modified">1000     &quot;8 ALIGNPTS&quot;,</span>
1001     &quot;7 INS_$28&quot;,
1002     &quot;3 UTP&quot;,
1003     &quot;8 LOOPCALL&quot;,
1004     &quot;4 CALL&quot;,
1005     &quot;4 FDEF&quot;,
1006     &quot;4 ENDF&quot;,
<span class="line-modified">1007     &quot;6 MDAP[]&quot;,</span>
<span class="line-modified">1008     &quot;9 MDAP[rnd]&quot;,</span>
<span class="line-modified">1009 </span>
<span class="line-modified">1010     /* 0x30 */</span>
<span class="line-modified">1011     &quot;6 IUP[y]&quot;,</span>
<span class="line-modified">1012     &quot;6 IUP[x]&quot;,</span>
<span class="line-modified">1013     &quot;8 SHP[rp2]&quot;,</span>
<span class="line-modified">1014     &quot;8 SHP[rp1]&quot;,</span>
<span class="line-modified">1015     &quot;8 SHC[rp2]&quot;,</span>
<span class="line-modified">1016     &quot;8 SHC[rp1]&quot;,</span>
<span class="line-modified">1017     &quot;8 SHZ[rp2]&quot;,</span>
<span class="line-added">1018     &quot;8 SHZ[rp1]&quot;,</span>
1019     &quot;5 SHPIX&quot;,
1020     &quot;2 IP&quot;,
<span class="line-modified">1021     &quot;7 MSIRP[]&quot;,</span>
<span class="line-modified">1022     &quot;A MSIRP[rp0]&quot;,</span>
<span class="line-modified">1023     &quot;7 ALIGNRP&quot;,</span>
1024     &quot;4 RTDG&quot;,
<span class="line-modified">1025     &quot;6 MIAP[]&quot;,</span>
<span class="line-modified">1026     &quot;9 MIAP[rnd]&quot;,</span>
1027 
<span class="line-modified">1028     /* 0x40 */</span>
<span class="line-modified">1029     &quot;6 NPUSHB&quot;,</span>
<span class="line-added">1030     &quot;6 NPUSHW&quot;,</span>
1031     &quot;2 WS&quot;,
1032     &quot;2 RS&quot;,
<span class="line-modified">1033     &quot;5 WCVTP&quot;,</span>
<span class="line-modified">1034     &quot;4 RCVT&quot;,</span>
<span class="line-modified">1035     &quot;8 GC[curr]&quot;,</span>
<span class="line-modified">1036     &quot;8 GC[orig]&quot;,</span>
1037     &quot;4 SCFS&quot;,
<span class="line-modified">1038     &quot;8 MD[curr]&quot;,</span>
<span class="line-modified">1039     &quot;8 MD[orig]&quot;,</span>
1040     &quot;5 MPPEM&quot;,
1041     &quot;3 MPS&quot;,
<span class="line-modified">1042     &quot;6 FLIPON&quot;,</span>
<span class="line-modified">1043     &quot;7 FLIPOFF&quot;,</span>
1044     &quot;5 DEBUG&quot;,
1045 
<span class="line-added">1046     /* 0x50 */</span>
1047     &quot;2 LT&quot;,
1048     &quot;4 LTEQ&quot;,
1049     &quot;2 GT&quot;,
1050     &quot;4 GTEQ&quot;,
1051     &quot;2 EQ&quot;,
1052     &quot;3 NEQ&quot;,
1053     &quot;3 ODD&quot;,
1054     &quot;4 EVEN&quot;,
1055     &quot;2 IF&quot;,
1056     &quot;3 EIF&quot;,
1057     &quot;3 AND&quot;,
1058     &quot;2 OR&quot;,
1059     &quot;3 NOT&quot;,
<span class="line-modified">1060     &quot;7 DELTAP1&quot;,</span>
1061     &quot;3 SDB&quot;,
1062     &quot;3 SDS&quot;,
1063 
<span class="line-added">1064     /* 0x60 */</span>
1065     &quot;3 ADD&quot;,
1066     &quot;3 SUB&quot;,
1067     &quot;3 DIV&quot;,
1068     &quot;3 MUL&quot;,
1069     &quot;3 ABS&quot;,
1070     &quot;3 NEG&quot;,
1071     &quot;5 FLOOR&quot;,
1072     &quot;7 CEILING&quot;,
<span class="line-modified">1073     &quot;8 ROUND[G]&quot;,</span>
<span class="line-modified">1074     &quot;8 ROUND[B]&quot;,</span>
<span class="line-modified">1075     &quot;8 ROUND[W]&quot;,</span>
<span class="line-modified">1076     &quot;7 ROUND[]&quot;,</span>
<span class="line-modified">1077     &quot;9 NROUND[G]&quot;,</span>
<span class="line-modified">1078     &quot;9 NROUND[B]&quot;,</span>
<span class="line-modified">1079     &quot;9 NROUND[W]&quot;,</span>
<span class="line-modified">1080     &quot;8 NROUND[]&quot;,</span>
<span class="line-modified">1081 </span>
<span class="line-modified">1082     /* 0x70 */</span>
<span class="line-modified">1083     &quot;5 WCVTF&quot;,</span>
<span class="line-modified">1084     &quot;7 DELTAP2&quot;,</span>
<span class="line-modified">1085     &quot;7 DELTAP3&quot;,</span>
<span class="line-modified">1086     &quot;7 DELTAC1&quot;,</span>
<span class="line-modified">1087     &quot;7 DELTAC2&quot;,</span>
<span class="line-added">1088     &quot;7 DELTAC3&quot;,</span>
1089     &quot;6 SROUND&quot;,
<span class="line-modified">1090     &quot;8 S45ROUND&quot;,</span>
1091     &quot;4 JROT&quot;,
1092     &quot;4 JROF&quot;,
1093     &quot;4 ROFF&quot;,
1094     &quot;7 INS_$7B&quot;,
1095     &quot;4 RUTG&quot;,
1096     &quot;4 RDTG&quot;,
1097     &quot;5 SANGW&quot;,
1098     &quot;2 AA&quot;,
1099 
<span class="line-modified">1100     /* 0x80 */</span>
<span class="line-modified">1101     &quot;6 FLIPPT&quot;,</span>
<span class="line-modified">1102     &quot;8 FLIPRGON&quot;,</span>
<span class="line-added">1103     &quot;9 FLIPRGOFF&quot;,</span>
1104     &quot;7 INS_$83&quot;,
1105     &quot;7 INS_$84&quot;,
<span class="line-modified">1106     &quot;8 SCANCTRL&quot;,</span>
<span class="line-modified">1107     &quot;A SDPVTL[||]&quot;,</span>
<span class="line-modified">1108     &quot;9 SDPVTL[+]&quot;,</span>
<span class="line-modified">1109     &quot;7 GETINFO&quot;,</span>
1110     &quot;4 IDEF&quot;,
1111     &quot;4 ROLL&quot;,
1112     &quot;3 MAX&quot;,
1113     &quot;3 MIN&quot;,
<span class="line-modified">1114     &quot;8 SCANTYPE&quot;,</span>
<span class="line-modified">1115     &quot;8 INSTCTRL&quot;,</span>
1116     &quot;7 INS_$8F&quot;,
1117 
<span class="line-added">1118     /* 0x90 */</span>
1119     &quot;7 INS_$90&quot;,
1120 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
<span class="line-modified">1121     &quot;C GETVARIATION&quot;,</span>
1122     &quot;7 GETDATA&quot;,
1123 #else
1124     &quot;7 INS_$91&quot;,
1125     &quot;7 INS_$92&quot;,
1126 #endif
1127     &quot;7 INS_$93&quot;,
1128     &quot;7 INS_$94&quot;,
1129     &quot;7 INS_$95&quot;,
1130     &quot;7 INS_$96&quot;,
1131     &quot;7 INS_$97&quot;,
1132     &quot;7 INS_$98&quot;,
1133     &quot;7 INS_$99&quot;,
1134     &quot;7 INS_$9A&quot;,
1135     &quot;7 INS_$9B&quot;,
1136     &quot;7 INS_$9C&quot;,
1137     &quot;7 INS_$9D&quot;,
1138     &quot;7 INS_$9E&quot;,
1139     &quot;7 INS_$9F&quot;,
1140 
<span class="line-added">1141     /* 0xA0 */</span>
1142     &quot;7 INS_$A0&quot;,
1143     &quot;7 INS_$A1&quot;,
1144     &quot;7 INS_$A2&quot;,
1145     &quot;7 INS_$A3&quot;,
1146     &quot;7 INS_$A4&quot;,
1147     &quot;7 INS_$A5&quot;,
1148     &quot;7 INS_$A6&quot;,
1149     &quot;7 INS_$A7&quot;,
1150     &quot;7 INS_$A8&quot;,
1151     &quot;7 INS_$A9&quot;,
1152     &quot;7 INS_$AA&quot;,
1153     &quot;7 INS_$AB&quot;,
1154     &quot;7 INS_$AC&quot;,
1155     &quot;7 INS_$AD&quot;,
1156     &quot;7 INS_$AE&quot;,
1157     &quot;7 INS_$AF&quot;,
1158 
<span class="line-modified">1159     /* 0xB0 */</span>
<span class="line-modified">1160     &quot;8 PUSHB[0]&quot;,</span>
<span class="line-modified">1161     &quot;8 PUSHB[1]&quot;,</span>
<span class="line-modified">1162     &quot;8 PUSHB[2]&quot;,</span>
<span class="line-modified">1163     &quot;8 PUSHB[3]&quot;,</span>
<span class="line-modified">1164     &quot;8 PUSHB[4]&quot;,</span>
<span class="line-modified">1165     &quot;8 PUSHB[5]&quot;,</span>
<span class="line-modified">1166     &quot;8 PUSHB[6]&quot;,</span>
<span class="line-modified">1167     &quot;8 PUSHB[7]&quot;,</span>
<span class="line-modified">1168     &quot;8 PUSHW[0]&quot;,</span>
<span class="line-modified">1169     &quot;8 PUSHW[1]&quot;,</span>
<span class="line-modified">1170     &quot;8 PUSHW[2]&quot;,</span>
<span class="line-modified">1171     &quot;8 PUSHW[3]&quot;,</span>
<span class="line-modified">1172     &quot;8 PUSHW[4]&quot;,</span>
<span class="line-modified">1173     &quot;8 PUSHW[5]&quot;,</span>
<span class="line-modified">1174     &quot;8 PUSHW[6]&quot;,</span>
<span class="line-modified">1175     &quot;8 PUSHW[7]&quot;,</span>
<span class="line-modified">1176 </span>
<span class="line-modified">1177     /* 0xC0 */</span>
<span class="line-modified">1178     &quot;7 MDRP[G]&quot;,</span>
<span class="line-modified">1179     &quot;7 MDRP[B]&quot;,</span>
<span class="line-modified">1180     &quot;7 MDRP[W]&quot;,</span>
<span class="line-modified">1181     &quot;6 MDRP[]&quot;,</span>
<span class="line-modified">1182     &quot;8 MDRP[rG]&quot;,</span>
<span class="line-modified">1183     &quot;8 MDRP[rB]&quot;,</span>
<span class="line-modified">1184     &quot;8 MDRP[rW]&quot;,</span>
<span class="line-modified">1185     &quot;7 MDRP[r]&quot;,</span>
<span class="line-modified">1186     &quot;8 MDRP[mG]&quot;,</span>
<span class="line-modified">1187     &quot;8 MDRP[mB]&quot;,</span>
<span class="line-modified">1188     &quot;8 MDRP[mW]&quot;,</span>
<span class="line-modified">1189     &quot;7 MDRP[m]&quot;,</span>
<span class="line-modified">1190     &quot;9 MDRP[mrG]&quot;,</span>
<span class="line-modified">1191     &quot;9 MDRP[mrB]&quot;,</span>
<span class="line-modified">1192     &quot;9 MDRP[mrW]&quot;,</span>
<span class="line-modified">1193     &quot;8 MDRP[mr]&quot;,</span>
<span class="line-modified">1194 </span>
<span class="line-modified">1195     /* 0xD0 */</span>
<span class="line-modified">1196     &quot;8 MDRP[pG]&quot;,</span>
<span class="line-modified">1197     &quot;8 MDRP[pB]&quot;,</span>
<span class="line-modified">1198     &quot;8 MDRP[pW]&quot;,</span>
<span class="line-modified">1199     &quot;7 MDRP[p]&quot;,</span>
<span class="line-modified">1200     &quot;9 MDRP[prG]&quot;,</span>
<span class="line-modified">1201     &quot;9 MDRP[prB]&quot;,</span>
<span class="line-modified">1202     &quot;9 MDRP[prW]&quot;,</span>
<span class="line-modified">1203     &quot;8 MDRP[pr]&quot;,</span>
<span class="line-modified">1204     &quot;9 MDRP[pmG]&quot;,</span>
<span class="line-modified">1205     &quot;9 MDRP[pmB]&quot;,</span>
<span class="line-modified">1206     &quot;9 MDRP[pmW]&quot;,</span>
<span class="line-modified">1207     &quot;8 MDRP[pm]&quot;,</span>
<span class="line-modified">1208     &quot;A MDRP[pmrG]&quot;,</span>
<span class="line-modified">1209     &quot;A MDRP[pmrB]&quot;,</span>
<span class="line-modified">1210     &quot;A MDRP[pmrW]&quot;,</span>
<span class="line-modified">1211     &quot;9 MDRP[pmr]&quot;,</span>
<span class="line-modified">1212 </span>
<span class="line-modified">1213     /* 0xE0 */</span>
<span class="line-modified">1214     &quot;7 MIRP[G]&quot;,</span>
<span class="line-modified">1215     &quot;7 MIRP[B]&quot;,</span>
<span class="line-modified">1216     &quot;7 MIRP[W]&quot;,</span>
<span class="line-modified">1217     &quot;6 MIRP[]&quot;,</span>
<span class="line-modified">1218     &quot;8 MIRP[rG]&quot;,</span>
<span class="line-modified">1219     &quot;8 MIRP[rB]&quot;,</span>
<span class="line-modified">1220     &quot;8 MIRP[rW]&quot;,</span>
<span class="line-modified">1221     &quot;7 MIRP[r]&quot;,</span>
<span class="line-modified">1222     &quot;8 MIRP[mG]&quot;,</span>
<span class="line-modified">1223     &quot;8 MIRP[mB]&quot;,</span>
<span class="line-modified">1224     &quot;8 MIRP[mW]&quot;,</span>
<span class="line-modified">1225     &quot;7 MIRP[m]&quot;,</span>
<span class="line-modified">1226     &quot;9 MIRP[mrG]&quot;,</span>
<span class="line-modified">1227     &quot;9 MIRP[mrB]&quot;,</span>
<span class="line-modified">1228     &quot;9 MIRP[mrW]&quot;,</span>
<span class="line-modified">1229     &quot;8 MIRP[mr]&quot;,</span>
<span class="line-modified">1230 </span>
<span class="line-modified">1231     /* 0xF0 */</span>
<span class="line-modified">1232     &quot;8 MIRP[pG]&quot;,</span>
<span class="line-modified">1233     &quot;8 MIRP[pB]&quot;,</span>
<span class="line-modified">1234     &quot;8 MIRP[pW]&quot;,</span>
<span class="line-modified">1235     &quot;7 MIRP[p]&quot;,</span>
<span class="line-modified">1236     &quot;9 MIRP[prG]&quot;,</span>
<span class="line-modified">1237     &quot;9 MIRP[prB]&quot;,</span>
<span class="line-modified">1238     &quot;9 MIRP[prW]&quot;,</span>
<span class="line-modified">1239     &quot;8 MIRP[pr]&quot;,</span>
<span class="line-modified">1240     &quot;9 MIRP[pmG]&quot;,</span>
<span class="line-modified">1241     &quot;9 MIRP[pmB]&quot;,</span>
<span class="line-modified">1242     &quot;9 MIRP[pmW]&quot;,</span>
<span class="line-added">1243     &quot;8 MIRP[pm]&quot;,</span>
<span class="line-added">1244     &quot;A MIRP[pmrG]&quot;,</span>
<span class="line-added">1245     &quot;A MIRP[pmrB]&quot;,</span>
<span class="line-added">1246     &quot;A MIRP[pmrW]&quot;,</span>
<span class="line-added">1247     &quot;9 MIRP[pmr]&quot;</span>
1248   };
1249 
1250 #endif /* FT_DEBUG_LEVEL_TRACE */
1251 
1252 
1253   static
1254   const FT_Char  opcode_length[256] =
1255   {
1256     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1257     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1258     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1259     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1260 
1261    -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1262     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1263     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1264     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1265 
1266     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
1267     1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
</pre>
<hr />
<pre>
1480 
1481     /* add them */
1482     lo = lo1 + lo2;
1483     hi = hi1 + hi2 + ( lo &lt; lo1 );
1484 
1485     /* divide the result by 2^14 with rounding */
1486     s   = hi &gt;&gt; 31;
1487     l   = lo + (FT_UInt32)s;
1488     hi += s + ( l &lt; lo );
1489     lo  = l;
1490 
1491     l   = lo + 0x2000U;
1492     hi += ( l &lt; lo );
1493 
1494     return (FT_Int32)( ( (FT_UInt32)hi &lt;&lt; 18 ) | ( l &gt;&gt; 14 ) );
1495   }
1496 
1497 #endif /* TT_DotFix14 */
1498 
1499 
<span class="line-modified">1500   /**************************************************************************</span>
<span class="line-modified">1501    *</span>
<span class="line-modified">1502    * @Function:</span>
<span class="line-modified">1503    *   Current_Ratio</span>
<span class="line-modified">1504    *</span>
<span class="line-modified">1505    * @Description:</span>
<span class="line-modified">1506    *   Returns the current aspect ratio scaling factor depending on the</span>
<span class="line-modified">1507    *   projection vector&#39;s state and device resolutions.</span>
<span class="line-modified">1508    *</span>
<span class="line-modified">1509    * @Return:</span>
<span class="line-modified">1510    *   The aspect ratio in 16.16 format, always &lt;= 1.0 .</span>
<span class="line-modified">1511    */</span>
1512   static FT_Long
1513   Current_Ratio( TT_ExecContext  exc )
1514   {
1515     if ( !exc-&gt;tt_metrics.ratio )
1516     {
1517       if ( exc-&gt;GS.projVector.y == 0 )
1518         exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.x_ratio;
1519 
1520       else if ( exc-&gt;GS.projVector.x == 0 )
1521         exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.y_ratio;
1522 
1523       else
1524       {
1525         FT_F26Dot6  x, y;
1526 
1527 
1528         x = TT_MulFix14( exc-&gt;tt_metrics.x_ratio,
1529                          exc-&gt;GS.projVector.x );
1530         y = TT_MulFix14( exc-&gt;tt_metrics.y_ratio,
1531                          exc-&gt;GS.projVector.y );
</pre>
<hr />
<pre>
1533       }
1534     }
1535     return exc-&gt;tt_metrics.ratio;
1536   }
1537 
1538 
1539   FT_CALLBACK_DEF( FT_Long )
1540   Current_Ppem( TT_ExecContext  exc )
1541   {
1542     return exc-&gt;tt_metrics.ppem;
1543   }
1544 
1545 
1546   FT_CALLBACK_DEF( FT_Long )
1547   Current_Ppem_Stretched( TT_ExecContext  exc )
1548   {
1549     return FT_MulFix( exc-&gt;tt_metrics.ppem, Current_Ratio( exc ) );
1550   }
1551 
1552 
<span class="line-modified">1553   /**************************************************************************</span>
<span class="line-modified">1554    *</span>
<span class="line-modified">1555    * Functions related to the control value table (CVT).</span>
<span class="line-modified">1556    *</span>
<span class="line-modified">1557    */</span>
1558 
1559 
1560   FT_CALLBACK_DEF( FT_F26Dot6 )
1561   Read_CVT( TT_ExecContext  exc,
1562             FT_ULong        idx )
1563   {
1564     return exc-&gt;cvt[idx];
1565   }
1566 
1567 
1568   FT_CALLBACK_DEF( FT_F26Dot6 )
1569   Read_CVT_Stretched( TT_ExecContext  exc,
1570                       FT_ULong        idx )
1571   {
1572     return FT_MulFix( exc-&gt;cvt[idx], Current_Ratio( exc ) );
1573   }
1574 
1575 
1576   FT_CALLBACK_DEF( void )
1577   Write_CVT( TT_ExecContext  exc,
</pre>
<hr />
<pre>
1579              FT_F26Dot6      value )
1580   {
1581     exc-&gt;cvt[idx] = value;
1582   }
1583 
1584 
1585   FT_CALLBACK_DEF( void )
1586   Write_CVT_Stretched( TT_ExecContext  exc,
1587                        FT_ULong        idx,
1588                        FT_F26Dot6      value )
1589   {
1590     exc-&gt;cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
1591   }
1592 
1593 
1594   FT_CALLBACK_DEF( void )
1595   Move_CVT( TT_ExecContext  exc,
1596             FT_ULong        idx,
1597             FT_F26Dot6      value )
1598   {
<span class="line-modified">1599     exc-&gt;cvt[idx] = ADD_LONG( exc-&gt;cvt[idx], value );</span>
1600   }
1601 
1602 
1603   FT_CALLBACK_DEF( void )
1604   Move_CVT_Stretched( TT_ExecContext  exc,
1605                       FT_ULong        idx,
1606                       FT_F26Dot6      value )
1607   {
<span class="line-modified">1608     exc-&gt;cvt[idx] = ADD_LONG( exc-&gt;cvt[idx],</span>
<span class="line-modified">1609                               FT_DivFix( value, Current_Ratio( exc ) ) );</span>
<span class="line-modified">1610   }</span>
<span class="line-modified">1611 </span>
<span class="line-modified">1612 </span>
<span class="line-modified">1613   /**************************************************************************</span>
<span class="line-modified">1614    *</span>
<span class="line-modified">1615    * @Function:</span>
<span class="line-modified">1616    *   GetShortIns</span>
<span class="line-modified">1617    *</span>
<span class="line-modified">1618    * @Description:</span>
<span class="line-modified">1619    *   Returns a short integer taken from the instruction stream at</span>
<span class="line-modified">1620    *   address IP.</span>
<span class="line-modified">1621    *</span>
<span class="line-modified">1622    * @Return:</span>
<span class="line-modified">1623    *   Short read at code[IP].</span>
<span class="line-modified">1624    *</span>
<span class="line-modified">1625    * @Note:</span>
<span class="line-modified">1626    *   This one could become a macro.</span>
<span class="line-added">1627    */</span>
1628   static FT_Short
1629   GetShortIns( TT_ExecContext  exc )
1630   {
1631     /* Reading a byte stream so there is no endianness (DaveP) */
1632     exc-&gt;IP += 2;
1633     return (FT_Short)( ( exc-&gt;code[exc-&gt;IP - 2] &lt;&lt; 8 ) +
1634                          exc-&gt;code[exc-&gt;IP - 1]      );
1635   }
1636 
1637 
<span class="line-modified">1638   /**************************************************************************</span>
<span class="line-modified">1639    *</span>
<span class="line-modified">1640    * @Function:</span>
<span class="line-modified">1641    *   Ins_Goto_CodeRange</span>
<span class="line-modified">1642    *</span>
<span class="line-modified">1643    * @Description:</span>
<span class="line-modified">1644    *   Goes to a certain code range in the instruction stream.</span>
<span class="line-modified">1645    *</span>
<span class="line-modified">1646    * @Input:</span>
<span class="line-modified">1647    *   aRange ::</span>
<span class="line-modified">1648    *     The index of the code range.</span>
<span class="line-modified">1649    *</span>
<span class="line-modified">1650    *   aIP ::</span>
<span class="line-modified">1651    *     The new IP address in the code range.</span>
<span class="line-modified">1652    *</span>
<span class="line-modified">1653    * @Return:</span>
<span class="line-added">1654    *   SUCCESS or FAILURE.</span>
<span class="line-added">1655    */</span>
1656   static FT_Bool
1657   Ins_Goto_CodeRange( TT_ExecContext  exc,
1658                       FT_Int          aRange,
1659                       FT_Long         aIP )
1660   {
1661     TT_CodeRange*  range;
1662 
1663 
1664     if ( aRange &lt; 1 || aRange &gt; 3 )
1665     {
1666       exc-&gt;error = FT_THROW( Bad_Argument );
1667       return FAILURE;
1668     }
1669 
1670     range = &amp;exc-&gt;codeRangeTable[aRange - 1];
1671 
1672     if ( !range-&gt;base )     /* invalid coderange */
1673     {
1674       exc-&gt;error = FT_THROW( Invalid_CodeRange );
1675       return FAILURE;
</pre>
<hr />
<pre>
1677 
1678     /* NOTE: Because the last instruction of a program may be a CALL */
1679     /*       which will return to the first byte *after* the code    */
1680     /*       range, we test for aIP &lt;= Size, instead of aIP &lt; Size.  */
1681 
1682     if ( aIP &gt; range-&gt;size )
1683     {
1684       exc-&gt;error = FT_THROW( Code_Overflow );
1685       return FAILURE;
1686     }
1687 
1688     exc-&gt;code     = range-&gt;base;
1689     exc-&gt;codeSize = range-&gt;size;
1690     exc-&gt;IP       = aIP;
1691     exc-&gt;curRange = aRange;
1692 
1693     return SUCCESS;
1694   }
1695 
1696 
<span class="line-modified">1697   /*</span>
<span class="line-modified">1698    *</span>
<span class="line-modified">1699    * Apple&#39;s TrueType specification at</span>
<span class="line-modified">1700    *</span>
<span class="line-modified">1701    *   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM02/Chap2.html#order</span>
<span class="line-modified">1702    *</span>
<span class="line-modified">1703    * gives the following order of operations in instructions that move</span>
<span class="line-modified">1704    * points.</span>
<span class="line-modified">1705    *</span>
<span class="line-modified">1706    *   - check single width cut-in (MIRP, MDRP)</span>
<span class="line-modified">1707    *</span>
<span class="line-modified">1708    *   - check control value cut-in (MIRP, MIAP)</span>
<span class="line-modified">1709    *</span>
<span class="line-modified">1710    *   - apply engine compensation (MIRP, MDRP)</span>
<span class="line-modified">1711    *</span>
<span class="line-modified">1712    *   - round distance (MIRP, MDRP) or value (MIAP, MDAP)</span>
<span class="line-modified">1713    *</span>
<span class="line-modified">1714    *   - check minimum distance (MIRP,MDRP)</span>
<span class="line-modified">1715    *</span>
<span class="line-modified">1716    *   - move point (MIRP, MDRP, MIAP, MSIRP, MDAP)</span>
<span class="line-modified">1717    *</span>
<span class="line-added">1718    * For rounding instructions, engine compensation happens before rounding.</span>
<span class="line-added">1719    *</span>
<span class="line-added">1720    */</span>
<span class="line-added">1721 </span>
<span class="line-added">1722 </span>
<span class="line-added">1723   /**************************************************************************</span>
<span class="line-added">1724    *</span>
<span class="line-added">1725    * @Function:</span>
<span class="line-added">1726    *   Direct_Move</span>
<span class="line-added">1727    *</span>
<span class="line-added">1728    * @Description:</span>
<span class="line-added">1729    *   Moves a point by a given distance along the freedom vector.  The</span>
<span class="line-added">1730    *   point will be `touched&#39;.</span>
<span class="line-added">1731    *</span>
<span class="line-added">1732    * @Input:</span>
<span class="line-added">1733    *   point ::</span>
<span class="line-added">1734    *     The index of the point to move.</span>
<span class="line-added">1735    *</span>
<span class="line-added">1736    *   distance ::</span>
<span class="line-added">1737    *     The distance to apply.</span>
<span class="line-added">1738    *</span>
<span class="line-added">1739    * @InOut:</span>
<span class="line-added">1740    *   zone ::</span>
<span class="line-added">1741    *     The affected glyph zone.</span>
<span class="line-added">1742    *</span>
<span class="line-added">1743    * @Note:</span>
<span class="line-added">1744    *   See `ttinterp.h&#39; for details on backward compatibility mode.</span>
<span class="line-added">1745    *   `Touches&#39; the point.</span>
<span class="line-added">1746    */</span>
1747   static void
1748   Direct_Move( TT_ExecContext  exc,
1749                TT_GlyphZone    zone,
1750                FT_UShort       point,
1751                FT_F26Dot6      distance )
1752   {
1753     FT_F26Dot6  v;
1754 
1755 
1756     v = exc-&gt;GS.freeVector.x;
1757 
1758     if ( v != 0 )
1759     {
1760 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1761       if ( SUBPIXEL_HINTING_INFINALITY                            &amp;&amp;
1762            ( !exc-&gt;ignore_x_mode                                ||
1763              ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALLOW_X_DMOVE ) ) )
1764         zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x,
1765                                        FT_MulDiv( distance,
1766                                                   v,
</pre>
<hr />
<pre>
1792     v = exc-&gt;GS.freeVector.y;
1793 
1794     if ( v != 0 )
1795     {
1796 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1797       if ( !( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
1798               exc-&gt;backward_compatibility &amp;&amp;
1799               exc-&gt;iupx_called            &amp;&amp;
1800               exc-&gt;iupy_called            ) )
1801 #endif
1802         zone-&gt;cur[point].y = ADD_LONG( zone-&gt;cur[point].y,
1803                                        FT_MulDiv( distance,
1804                                                   v,
1805                                                   exc-&gt;F_dot_P ) );
1806 
1807       zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_Y;
1808     }
1809   }
1810 
1811 
<span class="line-modified">1812   /**************************************************************************</span>
<span class="line-modified">1813    *</span>
<span class="line-modified">1814    * @Function:</span>
<span class="line-modified">1815    *   Direct_Move_Orig</span>
<span class="line-modified">1816    *</span>
<span class="line-modified">1817    * @Description:</span>
<span class="line-modified">1818    *   Moves the *original* position of a point by a given distance along</span>
<span class="line-modified">1819    *   the freedom vector.  Obviously, the point will not be `touched&#39;.</span>
<span class="line-modified">1820    *</span>
<span class="line-modified">1821    * @Input:</span>
<span class="line-modified">1822    *   point ::</span>
<span class="line-modified">1823    *     The index of the point to move.</span>
<span class="line-modified">1824    *</span>
<span class="line-modified">1825    *   distance ::</span>
<span class="line-modified">1826    *     The distance to apply.</span>
<span class="line-modified">1827    *</span>
<span class="line-modified">1828    * @InOut:</span>
<span class="line-added">1829    *   zone ::</span>
<span class="line-added">1830    *     The affected glyph zone.</span>
<span class="line-added">1831    */</span>
1832   static void
1833   Direct_Move_Orig( TT_ExecContext  exc,
1834                     TT_GlyphZone    zone,
1835                     FT_UShort       point,
1836                     FT_F26Dot6      distance )
1837   {
1838     FT_F26Dot6  v;
1839 
1840 
1841     v = exc-&gt;GS.freeVector.x;
1842 
1843     if ( v != 0 )
1844       zone-&gt;org[point].x = ADD_LONG( zone-&gt;org[point].x,
1845                                      FT_MulDiv( distance,
1846                                                 v,
1847                                                 exc-&gt;F_dot_P ) );
1848 
1849     v = exc-&gt;GS.freeVector.y;
1850 
1851     if ( v != 0 )
1852       zone-&gt;org[point].y = ADD_LONG( zone-&gt;org[point].y,
1853                                      FT_MulDiv( distance,
1854                                                 v,
1855                                                 exc-&gt;F_dot_P ) );
1856   }
1857 
1858 
<span class="line-modified">1859   /**************************************************************************</span>
<span class="line-modified">1860    *</span>
<span class="line-modified">1861    * Special versions of Direct_Move()</span>
<span class="line-modified">1862    *</span>
<span class="line-modified">1863    *   The following versions are used whenever both vectors are both</span>
<span class="line-modified">1864    *   along one of the coordinate unit vectors, i.e. in 90% of the cases.</span>
<span class="line-modified">1865    *   See `ttinterp.h&#39; for details on backward compatibility mode.</span>
<span class="line-modified">1866    *</span>
<span class="line-modified">1867    */</span>
1868 
1869 
1870   static void
1871   Direct_Move_X( TT_ExecContext  exc,
1872                  TT_GlyphZone    zone,
1873                  FT_UShort       point,
1874                  FT_F26Dot6      distance )
1875   {
1876 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
1877     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp; !exc-&gt;ignore_x_mode )
1878       zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x, distance );
1879     else
1880 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
1881 
1882 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1883     if ( SUBPIXEL_HINTING_MINIMAL &amp;&amp; !exc-&gt;backward_compatibility )
1884       zone-&gt;cur[point].x = ADD_LONG( zone-&gt;cur[point].x, distance );
1885     else
1886 #endif
1887 
</pre>
<hr />
<pre>
1894 
1895   static void
1896   Direct_Move_Y( TT_ExecContext  exc,
1897                  TT_GlyphZone    zone,
1898                  FT_UShort       point,
1899                  FT_F26Dot6      distance )
1900   {
1901     FT_UNUSED( exc );
1902 
1903 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
1904     if ( !( SUBPIXEL_HINTING_MINIMAL             &amp;&amp;
1905             exc-&gt;backward_compatibility          &amp;&amp;
1906             exc-&gt;iupx_called &amp;&amp; exc-&gt;iupy_called ) )
1907 #endif
1908       zone-&gt;cur[point].y = ADD_LONG( zone-&gt;cur[point].y, distance );
1909 
1910     zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_Y;
1911   }
1912 
1913 
<span class="line-modified">1914   /**************************************************************************</span>
<span class="line-modified">1915    *</span>
<span class="line-modified">1916    * Special versions of Direct_Move_Orig()</span>
<span class="line-modified">1917    *</span>
<span class="line-modified">1918    *   The following versions are used whenever both vectors are both</span>
<span class="line-modified">1919    *   along one of the coordinate unit vectors, i.e. in 90% of the cases.</span>
<span class="line-modified">1920    *</span>
<span class="line-modified">1921    */</span>
1922 
1923 
1924   static void
1925   Direct_Move_Orig_X( TT_ExecContext  exc,
1926                       TT_GlyphZone    zone,
1927                       FT_UShort       point,
1928                       FT_F26Dot6      distance )
1929   {
1930     FT_UNUSED( exc );
1931 
1932     zone-&gt;org[point].x = ADD_LONG( zone-&gt;org[point].x, distance );
1933   }
1934 
1935 
1936   static void
1937   Direct_Move_Orig_Y( TT_ExecContext  exc,
1938                       TT_GlyphZone    zone,
1939                       FT_UShort       point,
1940                       FT_F26Dot6      distance )
1941   {
1942     FT_UNUSED( exc );
1943 
1944     zone-&gt;org[point].y = ADD_LONG( zone-&gt;org[point].y, distance );
1945   }
1946 
<span class="line-modified">1947   /**************************************************************************</span>
<span class="line-modified">1948    *</span>
<span class="line-modified">1949    * @Function:</span>
<span class="line-modified">1950    *   Round_None</span>
<span class="line-modified">1951    *</span>
<span class="line-modified">1952    * @Description:</span>
<span class="line-modified">1953    *   Does not round, but adds engine compensation.</span>
<span class="line-modified">1954    *</span>
<span class="line-modified">1955    * @Input:</span>
<span class="line-modified">1956    *   distance ::</span>
<span class="line-modified">1957    *     The distance (not) to round.</span>
<span class="line-modified">1958    *</span>
<span class="line-modified">1959    *   compensation ::</span>
<span class="line-modified">1960    *     The engine compensation.</span>
<span class="line-modified">1961    *</span>
<span class="line-modified">1962    * @Return:</span>
<span class="line-modified">1963    *   The compensated distance.</span>
<span class="line-modified">1964    */</span>





1965   static FT_F26Dot6
1966   Round_None( TT_ExecContext  exc,
1967               FT_F26Dot6      distance,
1968               FT_F26Dot6      compensation )
1969   {
1970     FT_F26Dot6  val;
1971 
1972     FT_UNUSED( exc );
1973 
1974 
1975     if ( distance &gt;= 0 )
1976     {
1977       val = ADD_LONG( distance, compensation );
1978       if ( val &lt; 0 )
1979         val = 0;
1980     }
1981     else
1982     {
1983       val = SUB_LONG( distance, compensation );
1984       if ( val &gt; 0 )
1985         val = 0;
1986     }
1987     return val;
1988   }
1989 
1990 
<span class="line-modified">1991   /**************************************************************************</span>
<span class="line-modified">1992    *</span>
<span class="line-modified">1993    * @Function:</span>
<span class="line-modified">1994    *   Round_To_Grid</span>
<span class="line-modified">1995    *</span>
<span class="line-modified">1996    * @Description:</span>
<span class="line-modified">1997    *   Rounds value to grid after adding engine compensation.</span>
<span class="line-modified">1998    *</span>
<span class="line-modified">1999    * @Input:</span>
<span class="line-modified">2000    *   distance ::</span>
<span class="line-modified">2001    *     The distance to round.</span>
<span class="line-modified">2002    *</span>
<span class="line-modified">2003    *   compensation ::</span>
<span class="line-modified">2004    *     The engine compensation.</span>
<span class="line-modified">2005    *</span>
<span class="line-modified">2006    * @Return:</span>
<span class="line-added">2007    *   Rounded distance.</span>
<span class="line-added">2008    */</span>
2009   static FT_F26Dot6
2010   Round_To_Grid( TT_ExecContext  exc,
2011                  FT_F26Dot6      distance,
2012                  FT_F26Dot6      compensation )
2013   {
2014     FT_F26Dot6  val;
2015 
2016     FT_UNUSED( exc );
2017 
2018 
2019     if ( distance &gt;= 0 )
2020     {
2021       val = FT_PIX_ROUND_LONG( ADD_LONG( distance, compensation ) );
2022       if ( val &lt; 0 )
2023         val = 0;
2024     }
2025     else
2026     {
2027       val = NEG_LONG( FT_PIX_ROUND_LONG( SUB_LONG( compensation,
2028                                                    distance ) ) );
2029       if ( val &gt; 0 )
2030         val = 0;
2031     }
2032 
2033     return val;
2034   }
2035 
2036 
<span class="line-modified">2037   /**************************************************************************</span>
<span class="line-modified">2038    *</span>
<span class="line-modified">2039    * @Function:</span>
<span class="line-modified">2040    *   Round_To_Half_Grid</span>
<span class="line-modified">2041    *</span>
<span class="line-modified">2042    * @Description:</span>
<span class="line-modified">2043    *   Rounds value to half grid after adding engine compensation.</span>
<span class="line-modified">2044    *</span>
<span class="line-modified">2045    * @Input:</span>
<span class="line-modified">2046    *   distance ::</span>
<span class="line-modified">2047    *     The distance to round.</span>
<span class="line-modified">2048    *</span>
<span class="line-modified">2049    *   compensation ::</span>
<span class="line-modified">2050    *     The engine compensation.</span>
<span class="line-modified">2051    *</span>
<span class="line-modified">2052    * @Return:</span>
<span class="line-added">2053    *   Rounded distance.</span>
<span class="line-added">2054    */</span>
2055   static FT_F26Dot6
2056   Round_To_Half_Grid( TT_ExecContext  exc,
2057                       FT_F26Dot6      distance,
2058                       FT_F26Dot6      compensation )
2059   {
2060     FT_F26Dot6  val;
2061 
2062     FT_UNUSED( exc );
2063 
2064 
2065     if ( distance &gt;= 0 )
2066     {
2067       val = ADD_LONG( FT_PIX_FLOOR( ADD_LONG( distance, compensation ) ),
2068                       32 );
2069       if ( val &lt; 0 )
2070         val = 32;
2071     }
2072     else
2073     {
2074       val = NEG_LONG( ADD_LONG( FT_PIX_FLOOR( SUB_LONG( compensation,
2075                                                         distance ) ),
2076                                 32 ) );
2077       if ( val &gt; 0 )
2078         val = -32;
2079     }
2080 
2081     return val;
2082   }
2083 
2084 
<span class="line-modified">2085   /**************************************************************************</span>
<span class="line-modified">2086    *</span>
<span class="line-modified">2087    * @Function:</span>
<span class="line-modified">2088    *   Round_Down_To_Grid</span>
<span class="line-modified">2089    *</span>
<span class="line-modified">2090    * @Description:</span>
<span class="line-modified">2091    *   Rounds value down to grid after adding engine compensation.</span>
<span class="line-modified">2092    *</span>
<span class="line-modified">2093    * @Input:</span>
<span class="line-modified">2094    *   distance ::</span>
<span class="line-modified">2095    *     The distance to round.</span>
<span class="line-modified">2096    *</span>
<span class="line-modified">2097    *   compensation ::</span>
<span class="line-modified">2098    *     The engine compensation.</span>
<span class="line-modified">2099    *</span>
<span class="line-modified">2100    * @Return:</span>
<span class="line-added">2101    *   Rounded distance.</span>
<span class="line-added">2102    */</span>
2103   static FT_F26Dot6
2104   Round_Down_To_Grid( TT_ExecContext  exc,
2105                       FT_F26Dot6      distance,
2106                       FT_F26Dot6      compensation )
2107   {
2108     FT_F26Dot6  val;
2109 
2110     FT_UNUSED( exc );
2111 
2112 
2113     if ( distance &gt;= 0 )
2114     {
2115       val = FT_PIX_FLOOR( ADD_LONG( distance, compensation ) );
2116       if ( val &lt; 0 )
2117         val = 0;
2118     }
2119     else
2120     {
2121       val = NEG_LONG( FT_PIX_FLOOR( SUB_LONG( compensation, distance ) ) );
2122       if ( val &gt; 0 )
2123         val = 0;
2124     }
2125 
2126     return val;
2127   }
2128 
2129 
<span class="line-modified">2130   /**************************************************************************</span>
<span class="line-modified">2131    *</span>
<span class="line-modified">2132    * @Function:</span>
<span class="line-modified">2133    *   Round_Up_To_Grid</span>
<span class="line-modified">2134    *</span>
<span class="line-modified">2135    * @Description:</span>
<span class="line-modified">2136    *   Rounds value up to grid after adding engine compensation.</span>
<span class="line-modified">2137    *</span>
<span class="line-modified">2138    * @Input:</span>
<span class="line-modified">2139    *   distance ::</span>
<span class="line-modified">2140    *     The distance to round.</span>
<span class="line-modified">2141    *</span>
<span class="line-modified">2142    *   compensation ::</span>
<span class="line-modified">2143    *     The engine compensation.</span>
<span class="line-modified">2144    *</span>
<span class="line-modified">2145    * @Return:</span>
<span class="line-added">2146    *   Rounded distance.</span>
<span class="line-added">2147    */</span>
2148   static FT_F26Dot6
2149   Round_Up_To_Grid( TT_ExecContext  exc,
2150                     FT_F26Dot6      distance,
2151                     FT_F26Dot6      compensation )
2152   {
2153     FT_F26Dot6  val;
2154 
2155     FT_UNUSED( exc );
2156 
2157 
2158     if ( distance &gt;= 0 )
2159     {
2160       val = FT_PIX_CEIL_LONG( ADD_LONG( distance, compensation ) );
2161       if ( val &lt; 0 )
2162         val = 0;
2163     }
2164     else
2165     {
2166       val = NEG_LONG( FT_PIX_CEIL_LONG( SUB_LONG( compensation,
2167                                                   distance ) ) );
2168       if ( val &gt; 0 )
2169         val = 0;
2170     }
2171 
2172     return val;
2173   }
2174 
2175 
<span class="line-modified">2176   /**************************************************************************</span>
<span class="line-modified">2177    *</span>
<span class="line-modified">2178    * @Function:</span>
<span class="line-modified">2179    *   Round_To_Double_Grid</span>
<span class="line-modified">2180    *</span>
<span class="line-modified">2181    * @Description:</span>
<span class="line-modified">2182    *   Rounds value to double grid after adding engine compensation.</span>
<span class="line-modified">2183    *</span>
<span class="line-modified">2184    * @Input:</span>
<span class="line-modified">2185    *   distance ::</span>
<span class="line-modified">2186    *     The distance to round.</span>
<span class="line-modified">2187    *</span>
<span class="line-modified">2188    *   compensation ::</span>
<span class="line-modified">2189    *     The engine compensation.</span>
<span class="line-modified">2190    *</span>
<span class="line-modified">2191    * @Return:</span>
<span class="line-added">2192    *   Rounded distance.</span>
<span class="line-added">2193    */</span>
2194   static FT_F26Dot6
2195   Round_To_Double_Grid( TT_ExecContext  exc,
2196                         FT_F26Dot6      distance,
2197                         FT_F26Dot6      compensation )
2198   {
2199     FT_F26Dot6  val;
2200 
2201     FT_UNUSED( exc );
2202 
2203 
2204     if ( distance &gt;= 0 )
2205     {
2206       val = FT_PAD_ROUND_LONG( ADD_LONG( distance, compensation ), 32 );
2207       if ( val &lt; 0 )
2208         val = 0;
2209     }
2210     else
2211     {
2212       val = NEG_LONG( FT_PAD_ROUND_LONG( SUB_LONG( compensation, distance ),
2213                                          32 ) );
2214       if ( val &gt; 0 )
2215         val = 0;
2216     }
2217 
2218     return val;
2219   }
2220 
2221 
<span class="line-modified">2222   /**************************************************************************</span>
<span class="line-modified">2223    *</span>
<span class="line-modified">2224    * @Function:</span>
<span class="line-modified">2225    *   Round_Super</span>
<span class="line-modified">2226    *</span>
<span class="line-modified">2227    * @Description:</span>
<span class="line-modified">2228    *   Super-rounds value to grid after adding engine compensation.</span>
<span class="line-modified">2229    *</span>
<span class="line-modified">2230    * @Input:</span>
<span class="line-modified">2231    *   distance ::</span>
<span class="line-modified">2232    *     The distance to round.</span>
<span class="line-modified">2233    *</span>
<span class="line-modified">2234    *   compensation ::</span>
<span class="line-modified">2235    *     The engine compensation.</span>
<span class="line-modified">2236    *</span>
<span class="line-modified">2237    * @Return:</span>
<span class="line-modified">2238    *   Rounded distance.</span>
<span class="line-modified">2239    *</span>
<span class="line-modified">2240    * @Note:</span>
<span class="line-modified">2241    *   The TrueType specification says very little about the relationship</span>
<span class="line-modified">2242    *   between rounding and engine compensation.  However, it seems from</span>
<span class="line-modified">2243    *   the description of super round that we should add the compensation</span>
<span class="line-added">2244    *   before rounding.</span>
<span class="line-added">2245    */</span>
2246   static FT_F26Dot6
2247   Round_Super( TT_ExecContext  exc,
2248                FT_F26Dot6      distance,
2249                FT_F26Dot6      compensation )
2250   {
2251     FT_F26Dot6  val;
2252 
2253 
2254     if ( distance &gt;= 0 )
2255     {
2256       val = ADD_LONG( distance,
2257                       exc-&gt;threshold - exc-&gt;phase + compensation ) &amp;
2258               -exc-&gt;period;
2259       val = ADD_LONG( val, exc-&gt;phase );
2260       if ( val &lt; 0 )
2261         val = exc-&gt;phase;
2262     }
2263     else
2264     {
2265       val = NEG_LONG( SUB_LONG( exc-&gt;threshold - exc-&gt;phase + compensation,
2266                                 distance ) &amp;
2267                         -exc-&gt;period );
2268       val = SUB_LONG( val, exc-&gt;phase );
2269       if ( val &gt; 0 )
2270         val = -exc-&gt;phase;
2271     }
2272 
2273     return val;
2274   }
2275 
2276 
<span class="line-modified">2277   /**************************************************************************</span>
<span class="line-modified">2278    *</span>
<span class="line-modified">2279    * @Function:</span>
<span class="line-modified">2280    *   Round_Super_45</span>
<span class="line-modified">2281    *</span>
<span class="line-modified">2282    * @Description:</span>
<span class="line-modified">2283    *   Super-rounds value to grid after adding engine compensation.</span>
<span class="line-modified">2284    *</span>
<span class="line-modified">2285    * @Input:</span>
<span class="line-modified">2286    *   distance ::</span>
<span class="line-modified">2287    *     The distance to round.</span>
<span class="line-modified">2288    *</span>
<span class="line-modified">2289    *   compensation ::</span>
<span class="line-modified">2290    *     The engine compensation.</span>
<span class="line-modified">2291    *</span>
<span class="line-modified">2292    * @Return:</span>
<span class="line-modified">2293    *   Rounded distance.</span>
<span class="line-modified">2294    *</span>
<span class="line-modified">2295    * @Note:</span>
<span class="line-modified">2296    *   There is a separate function for Round_Super_45() as we may need</span>
<span class="line-added">2297    *   greater precision.</span>
<span class="line-added">2298    */</span>
2299   static FT_F26Dot6
2300   Round_Super_45( TT_ExecContext  exc,
2301                   FT_F26Dot6      distance,
2302                   FT_F26Dot6      compensation )
2303   {
2304     FT_F26Dot6  val;
2305 
2306 
2307     if ( distance &gt;= 0 )
2308     {
2309       val = ( ADD_LONG( distance,
2310                         exc-&gt;threshold - exc-&gt;phase + compensation ) /
2311                 exc-&gt;period ) * exc-&gt;period;
2312       val = ADD_LONG( val, exc-&gt;phase );
2313       if ( val &lt; 0 )
2314         val = exc-&gt;phase;
2315     }
2316     else
2317     {
2318       val = NEG_LONG( ( SUB_LONG( exc-&gt;threshold - exc-&gt;phase + compensation,
2319                                   distance ) /
2320                           exc-&gt;period ) * exc-&gt;period );
2321       val = SUB_LONG( val, exc-&gt;phase );
2322       if ( val &gt; 0 )
2323         val = -exc-&gt;phase;
2324     }
2325 
2326     return val;
2327   }
2328 
2329 
<span class="line-modified">2330   /**************************************************************************</span>
<span class="line-modified">2331    *</span>
<span class="line-modified">2332    * @Function:</span>
<span class="line-modified">2333    *   Compute_Round</span>
<span class="line-modified">2334    *</span>
<span class="line-modified">2335    * @Description:</span>
<span class="line-modified">2336    *   Sets the rounding mode.</span>
<span class="line-modified">2337    *</span>
<span class="line-modified">2338    * @Input:</span>
<span class="line-modified">2339    *   round_mode ::</span>
<span class="line-modified">2340    *     The rounding mode to be used.</span>
<span class="line-added">2341    */</span>
2342   static void
2343   Compute_Round( TT_ExecContext  exc,
2344                  FT_Byte         round_mode )
2345   {
2346     switch ( round_mode )
2347     {
2348     case TT_Round_Off:
2349       exc-&gt;func_round = (TT_Round_Func)Round_None;
2350       break;
2351 
2352     case TT_Round_To_Grid:
2353       exc-&gt;func_round = (TT_Round_Func)Round_To_Grid;
2354       break;
2355 
2356     case TT_Round_Up_To_Grid:
2357       exc-&gt;func_round = (TT_Round_Func)Round_Up_To_Grid;
2358       break;
2359 
2360     case TT_Round_Down_To_Grid:
2361       exc-&gt;func_round = (TT_Round_Func)Round_Down_To_Grid;
</pre>
<hr />
<pre>
2363 
2364     case TT_Round_To_Half_Grid:
2365       exc-&gt;func_round = (TT_Round_Func)Round_To_Half_Grid;
2366       break;
2367 
2368     case TT_Round_To_Double_Grid:
2369       exc-&gt;func_round = (TT_Round_Func)Round_To_Double_Grid;
2370       break;
2371 
2372     case TT_Round_Super:
2373       exc-&gt;func_round = (TT_Round_Func)Round_Super;
2374       break;
2375 
2376     case TT_Round_Super_45:
2377       exc-&gt;func_round = (TT_Round_Func)Round_Super_45;
2378       break;
2379     }
2380   }
2381 
2382 
<span class="line-modified">2383   /**************************************************************************</span>
<span class="line-modified">2384    *</span>
<span class="line-modified">2385    * @Function:</span>
<span class="line-modified">2386    *   SetSuperRound</span>
<span class="line-modified">2387    *</span>
<span class="line-modified">2388    * @Description:</span>
<span class="line-modified">2389    *   Sets Super Round parameters.</span>
<span class="line-modified">2390    *</span>
<span class="line-modified">2391    * @Input:</span>
<span class="line-modified">2392    *   GridPeriod ::</span>
<span class="line-modified">2393    *     The grid period.</span>
<span class="line-modified">2394    *</span>
<span class="line-modified">2395    *   selector ::</span>
<span class="line-added">2396    *     The SROUND opcode.</span>
<span class="line-added">2397    */</span>
2398   static void
2399   SetSuperRound( TT_ExecContext  exc,
2400                  FT_F2Dot14      GridPeriod,
2401                  FT_Long         selector )
2402   {
2403     switch ( (FT_Int)( selector &amp; 0xC0 ) )
2404     {
2405       case 0:
2406         exc-&gt;period = GridPeriod / 2;
2407         break;
2408 
2409       case 0x40:
2410         exc-&gt;period = GridPeriod;
2411         break;
2412 
2413       case 0x80:
2414         exc-&gt;period = GridPeriod * 2;
2415         break;
2416 
2417       /* This opcode is reserved, but... */
</pre>
<hr />
<pre>
2434       exc-&gt;phase = exc-&gt;period / 2;
2435       break;
2436 
2437     case 0x30:
2438       exc-&gt;phase = exc-&gt;period * 3 / 4;
2439       break;
2440     }
2441 
2442     if ( ( selector &amp; 0x0F ) == 0 )
2443       exc-&gt;threshold = exc-&gt;period - 1;
2444     else
2445       exc-&gt;threshold = ( (FT_Int)( selector &amp; 0x0F ) - 4 ) * exc-&gt;period / 8;
2446 
2447     /* convert to F26Dot6 format */
2448     exc-&gt;period    &gt;&gt;= 8;
2449     exc-&gt;phase     &gt;&gt;= 8;
2450     exc-&gt;threshold &gt;&gt;= 8;
2451   }
2452 
2453 
<span class="line-modified">2454   /**************************************************************************</span>
<span class="line-modified">2455    *</span>
<span class="line-modified">2456    * @Function:</span>
<span class="line-modified">2457    *   Project</span>
<span class="line-modified">2458    *</span>
<span class="line-modified">2459    * @Description:</span>
<span class="line-modified">2460    *   Computes the projection of vector given by (v2-v1) along the</span>
<span class="line-modified">2461    *   current projection vector.</span>
<span class="line-modified">2462    *</span>
<span class="line-modified">2463    * @Input:</span>
<span class="line-modified">2464    *   v1 ::</span>
<span class="line-modified">2465    *     First input vector.</span>
<span class="line-modified">2466    *   v2 ::</span>
<span class="line-modified">2467    *     Second input vector.</span>
<span class="line-modified">2468    *</span>
<span class="line-modified">2469    * @Return:</span>
<span class="line-added">2470    *   The distance in F26dot6 format.</span>
<span class="line-added">2471    */</span>
2472   static FT_F26Dot6
2473   Project( TT_ExecContext  exc,
2474            FT_Pos          dx,
2475            FT_Pos          dy )
2476   {
2477     return TT_DotFix14( dx, dy,
2478                         exc-&gt;GS.projVector.x,
2479                         exc-&gt;GS.projVector.y );
2480   }
2481 
2482 
<span class="line-modified">2483   /**************************************************************************</span>
<span class="line-modified">2484    *</span>
<span class="line-modified">2485    * @Function:</span>
<span class="line-modified">2486    *   Dual_Project</span>
<span class="line-modified">2487    *</span>
<span class="line-modified">2488    * @Description:</span>
<span class="line-modified">2489    *   Computes the projection of the vector given by (v2-v1) along the</span>
<span class="line-modified">2490    *   current dual vector.</span>
<span class="line-modified">2491    *</span>
<span class="line-modified">2492    * @Input:</span>
<span class="line-modified">2493    *   v1 ::</span>
<span class="line-modified">2494    *     First input vector.</span>
<span class="line-modified">2495    *   v2 ::</span>
<span class="line-modified">2496    *     Second input vector.</span>
<span class="line-modified">2497    *</span>
<span class="line-modified">2498    * @Return:</span>
<span class="line-added">2499    *   The distance in F26dot6 format.</span>
<span class="line-added">2500    */</span>
2501   static FT_F26Dot6
2502   Dual_Project( TT_ExecContext  exc,
2503                 FT_Pos          dx,
2504                 FT_Pos          dy )
2505   {
2506     return TT_DotFix14( dx, dy,
2507                         exc-&gt;GS.dualVector.x,
2508                         exc-&gt;GS.dualVector.y );
2509   }
2510 
2511 
<span class="line-modified">2512   /**************************************************************************</span>
<span class="line-modified">2513    *</span>
<span class="line-modified">2514    * @Function:</span>
<span class="line-modified">2515    *   Project_x</span>
<span class="line-modified">2516    *</span>
<span class="line-modified">2517    * @Description:</span>
<span class="line-modified">2518    *   Computes the projection of the vector given by (v2-v1) along the</span>
<span class="line-modified">2519    *   horizontal axis.</span>
<span class="line-modified">2520    *</span>
<span class="line-modified">2521    * @Input:</span>
<span class="line-modified">2522    *   v1 ::</span>
<span class="line-modified">2523    *     First input vector.</span>
<span class="line-modified">2524    *   v2 ::</span>
<span class="line-modified">2525    *     Second input vector.</span>
<span class="line-modified">2526    *</span>
<span class="line-modified">2527    * @Return:</span>
<span class="line-added">2528    *   The distance in F26dot6 format.</span>
<span class="line-added">2529    */</span>
2530   static FT_F26Dot6
2531   Project_x( TT_ExecContext  exc,
2532              FT_Pos          dx,
2533              FT_Pos          dy )
2534   {
2535     FT_UNUSED( exc );
2536     FT_UNUSED( dy );
2537 
2538     return dx;
2539   }
2540 
2541 
<span class="line-modified">2542   /**************************************************************************</span>
<span class="line-modified">2543    *</span>
<span class="line-modified">2544    * @Function:</span>
<span class="line-modified">2545    *   Project_y</span>
<span class="line-modified">2546    *</span>
<span class="line-modified">2547    * @Description:</span>
<span class="line-modified">2548    *   Computes the projection of the vector given by (v2-v1) along the</span>
<span class="line-modified">2549    *   vertical axis.</span>
<span class="line-modified">2550    *</span>
<span class="line-modified">2551    * @Input:</span>
<span class="line-modified">2552    *   v1 ::</span>
<span class="line-modified">2553    *     First input vector.</span>
<span class="line-modified">2554    *   v2 ::</span>
<span class="line-modified">2555    *     Second input vector.</span>
<span class="line-modified">2556    *</span>
<span class="line-modified">2557    * @Return:</span>
<span class="line-added">2558    *   The distance in F26dot6 format.</span>
<span class="line-added">2559    */</span>
2560   static FT_F26Dot6
2561   Project_y( TT_ExecContext  exc,
2562              FT_Pos          dx,
2563              FT_Pos          dy )
2564   {
2565     FT_UNUSED( exc );
2566     FT_UNUSED( dx );
2567 
2568     return dy;
2569   }
2570 
2571 
<span class="line-modified">2572   /**************************************************************************</span>
<span class="line-modified">2573    *</span>
<span class="line-modified">2574    * @Function:</span>
<span class="line-modified">2575    *   Compute_Funcs</span>
<span class="line-modified">2576    *</span>
<span class="line-modified">2577    * @Description:</span>
<span class="line-modified">2578    *   Computes the projection and movement function pointers according</span>
<span class="line-modified">2579    *   to the current graphics state.</span>
<span class="line-modified">2580    */</span>
2581   static void
2582   Compute_Funcs( TT_ExecContext  exc )
2583   {
2584     if ( exc-&gt;GS.freeVector.x == 0x4000 )
2585       exc-&gt;F_dot_P = exc-&gt;GS.projVector.x;
2586     else if ( exc-&gt;GS.freeVector.y == 0x4000 )
2587       exc-&gt;F_dot_P = exc-&gt;GS.projVector.y;
2588     else
2589       exc-&gt;F_dot_P =
2590         ( (FT_Long)exc-&gt;GS.projVector.x * exc-&gt;GS.freeVector.x +
2591           (FT_Long)exc-&gt;GS.projVector.y * exc-&gt;GS.freeVector.y ) &gt;&gt; 14;
2592 
2593     if ( exc-&gt;GS.projVector.x == 0x4000 )
2594       exc-&gt;func_project = (TT_Project_Func)Project_x;
2595     else if ( exc-&gt;GS.projVector.y == 0x4000 )
2596       exc-&gt;func_project = (TT_Project_Func)Project_y;
2597     else
2598       exc-&gt;func_project = (TT_Project_Func)Project;
2599 
2600     if ( exc-&gt;GS.dualVector.x == 0x4000 )
</pre>
<hr />
<pre>
2615         exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
2616       }
2617       else if ( exc-&gt;GS.freeVector.y == 0x4000 )
2618       {
2619         exc-&gt;func_move      = (TT_Move_Func)Direct_Move_Y;
2620         exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
2621       }
2622     }
2623 
2624     /* at small sizes, F_dot_P can become too small, resulting   */
2625     /* in overflows and `spikes&#39; in a number of glyphs like `w&#39;. */
2626 
2627     if ( FT_ABS( exc-&gt;F_dot_P ) &lt; 0x400L )
2628       exc-&gt;F_dot_P = 0x4000L;
2629 
2630     /* Disable cached aspect ratio */
2631     exc-&gt;tt_metrics.ratio = 0;
2632   }
2633 
2634 
<span class="line-modified">2635   /**************************************************************************</span>
<span class="line-modified">2636    *</span>
<span class="line-modified">2637    * @Function:</span>
<span class="line-modified">2638    *   Normalize</span>
<span class="line-modified">2639    *</span>
<span class="line-modified">2640    * @Description:</span>
<span class="line-modified">2641    *   Norms a vector.</span>
<span class="line-modified">2642    *</span>
<span class="line-modified">2643    * @Input:</span>
<span class="line-modified">2644    *   Vx ::</span>
<span class="line-modified">2645    *     The horizontal input vector coordinate.</span>
<span class="line-modified">2646    *   Vy ::</span>
<span class="line-modified">2647    *     The vertical input vector coordinate.</span>
<span class="line-modified">2648    *</span>
<span class="line-modified">2649    * @Output:</span>
<span class="line-modified">2650    *   R ::</span>
<span class="line-modified">2651    *     The normed unit vector.</span>
<span class="line-modified">2652    *</span>
<span class="line-modified">2653    * @Return:</span>
<span class="line-modified">2654    *   Returns FAILURE if a vector parameter is zero.</span>
<span class="line-modified">2655    *</span>
<span class="line-modified">2656    * @Note:</span>
<span class="line-added">2657    *   In case Vx and Vy are both zero, `Normalize&#39; returns SUCCESS, and</span>
<span class="line-added">2658    *   R is undefined.</span>
<span class="line-added">2659    */</span>
2660   static FT_Bool
2661   Normalize( FT_F26Dot6      Vx,
2662              FT_F26Dot6      Vy,
2663              FT_UnitVector*  R )
2664   {
2665     FT_Vector V;
2666 
2667 
2668     if ( Vx == 0 &amp;&amp; Vy == 0 )
2669     {
2670       /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
2671       /*      to normalize the vector (0,0).  Return immediately. */
2672       return SUCCESS;
2673     }
2674 
2675     V.x = Vx;
2676     V.y = Vy;
2677 
2678     FT_Vector_NormLen( &amp;V );
2679 
2680     R-&gt;x = (FT_F2Dot14)( V.x / 4 );
2681     R-&gt;y = (FT_F2Dot14)( V.y / 4 );
2682 
2683     return SUCCESS;
2684   }
2685 
2686 
<span class="line-modified">2687   /**************************************************************************</span>
<span class="line-modified">2688    *</span>
<span class="line-modified">2689    * Here we start with the implementation of the various opcodes.</span>
<span class="line-modified">2690    *</span>
<span class="line-modified">2691    */</span>
2692 
2693 
2694 #define ARRAY_BOUND_ERROR                         \
2695     do                                            \
2696     {                                             \
2697       exc-&gt;error = FT_THROW( Invalid_Reference ); \
2698       return;                                     \
2699     } while (0)
2700 
2701 
<span class="line-modified">2702   /**************************************************************************</span>
<span class="line-modified">2703    *</span>
<span class="line-modified">2704    * MPPEM[]:      Measure Pixel Per EM</span>
<span class="line-modified">2705    * Opcode range: 0x4B</span>
<span class="line-modified">2706    * Stack:        --&gt; Euint16</span>
<span class="line-modified">2707    */</span>
2708   static void
2709   Ins_MPPEM( TT_ExecContext  exc,
2710              FT_Long*        args )
2711   {
2712     args[0] = exc-&gt;func_cur_ppem( exc );
2713   }
2714 
2715 
<span class="line-modified">2716   /**************************************************************************</span>
<span class="line-modified">2717    *</span>
<span class="line-modified">2718    * MPS[]:        Measure Point Size</span>
<span class="line-modified">2719    * Opcode range: 0x4C</span>
<span class="line-modified">2720    * Stack:        --&gt; Euint16</span>
<span class="line-modified">2721    */</span>
2722   static void
2723   Ins_MPS( TT_ExecContext  exc,
2724            FT_Long*        args )
2725   {
2726     if ( NO_SUBPIXEL_HINTING )
2727     {
2728       /* Microsoft&#39;s GDI bytecode interpreter always returns value 12; */
2729       /* we return the current PPEM value instead.                     */
2730       args[0] = exc-&gt;func_cur_ppem( exc );
2731     }
2732     else
2733     {
2734       /* A possible practical application of the MPS instruction is to   */
2735       /* implement optical scaling and similar features, which should be */
2736       /* based on perceptual attributes, thus independent of the         */
2737       /* resolution.                                                     */
2738       args[0] = exc-&gt;pointSize;
2739     }
2740   }
2741 
2742 
<span class="line-modified">2743   /**************************************************************************</span>
<span class="line-modified">2744    *</span>
<span class="line-modified">2745    * DUP[]:        DUPlicate the stack&#39;s top element</span>
<span class="line-modified">2746    * Opcode range: 0x20</span>
<span class="line-modified">2747    * Stack:        StkElt --&gt; StkElt StkElt</span>
<span class="line-modified">2748    */</span>
2749   static void
2750   Ins_DUP( FT_Long*  args )
2751   {
2752     args[1] = args[0];
2753   }
2754 
2755 
<span class="line-modified">2756   /**************************************************************************</span>
<span class="line-modified">2757    *</span>
<span class="line-modified">2758    * POP[]:        POP the stack&#39;s top element</span>
<span class="line-modified">2759    * Opcode range: 0x21</span>
<span class="line-modified">2760    * Stack:        StkElt --&gt;</span>
<span class="line-modified">2761    */</span>
2762   static void
2763   Ins_POP( void )
2764   {
2765     /* nothing to do */
2766   }
2767 
2768 
<span class="line-modified">2769   /**************************************************************************</span>
<span class="line-modified">2770    *</span>
<span class="line-modified">2771    * CLEAR[]:      CLEAR the entire stack</span>
<span class="line-modified">2772    * Opcode range: 0x22</span>
<span class="line-modified">2773    * Stack:        StkElt... --&gt;</span>
<span class="line-modified">2774    */</span>
2775   static void
2776   Ins_CLEAR( TT_ExecContext  exc )
2777   {
2778     exc-&gt;new_top = 0;
2779   }
2780 
2781 
<span class="line-modified">2782   /**************************************************************************</span>
<span class="line-modified">2783    *</span>
<span class="line-modified">2784    * SWAP[]:       SWAP the stack&#39;s top two elements</span>
<span class="line-modified">2785    * Opcode range: 0x23</span>
<span class="line-modified">2786    * Stack:        2 * StkElt --&gt; 2 * StkElt</span>
<span class="line-modified">2787    */</span>
2788   static void
2789   Ins_SWAP( FT_Long*  args )
2790   {
2791     FT_Long  L;
2792 
2793 
2794     L       = args[0];
2795     args[0] = args[1];
2796     args[1] = L;
2797   }
2798 
2799 
<span class="line-modified">2800   /**************************************************************************</span>
<span class="line-modified">2801    *</span>
<span class="line-modified">2802    * DEPTH[]:      return the stack DEPTH</span>
<span class="line-modified">2803    * Opcode range: 0x24</span>
<span class="line-modified">2804    * Stack:        --&gt; uint32</span>
<span class="line-modified">2805    */</span>
2806   static void
2807   Ins_DEPTH( TT_ExecContext  exc,
2808              FT_Long*        args )
2809   {
2810     args[0] = exc-&gt;top;
2811   }
2812 
2813 
<span class="line-modified">2814   /**************************************************************************</span>
<span class="line-modified">2815    *</span>
<span class="line-modified">2816    * LT[]:         Less Than</span>
<span class="line-modified">2817    * Opcode range: 0x50</span>
<span class="line-modified">2818    * Stack:        int32? int32? --&gt; bool</span>
<span class="line-modified">2819    */</span>
2820   static void
2821   Ins_LT( FT_Long*  args )
2822   {
2823     args[0] = ( args[0] &lt; args[1] );
2824   }
2825 
2826 
<span class="line-modified">2827   /**************************************************************************</span>
<span class="line-modified">2828    *</span>
<span class="line-modified">2829    * LTEQ[]:       Less Than or EQual</span>
<span class="line-modified">2830    * Opcode range: 0x51</span>
<span class="line-modified">2831    * Stack:        int32? int32? --&gt; bool</span>
<span class="line-modified">2832    */</span>
2833   static void
2834   Ins_LTEQ( FT_Long*  args )
2835   {
2836     args[0] = ( args[0] &lt;= args[1] );
2837   }
2838 
2839 
<span class="line-modified">2840   /**************************************************************************</span>
<span class="line-modified">2841    *</span>
<span class="line-modified">2842    * GT[]:         Greater Than</span>
<span class="line-modified">2843    * Opcode range: 0x52</span>
<span class="line-modified">2844    * Stack:        int32? int32? --&gt; bool</span>
<span class="line-modified">2845    */</span>
2846   static void
2847   Ins_GT( FT_Long*  args )
2848   {
2849     args[0] = ( args[0] &gt; args[1] );
2850   }
2851 
2852 
<span class="line-modified">2853   /**************************************************************************</span>
<span class="line-modified">2854    *</span>
<span class="line-modified">2855    * GTEQ[]:       Greater Than or EQual</span>
<span class="line-modified">2856    * Opcode range: 0x53</span>
<span class="line-modified">2857    * Stack:        int32? int32? --&gt; bool</span>
<span class="line-modified">2858    */</span>
2859   static void
2860   Ins_GTEQ( FT_Long*  args )
2861   {
2862     args[0] = ( args[0] &gt;= args[1] );
2863   }
2864 
2865 
<span class="line-modified">2866   /**************************************************************************</span>
<span class="line-modified">2867    *</span>
<span class="line-modified">2868    * EQ[]:         EQual</span>
<span class="line-modified">2869    * Opcode range: 0x54</span>
<span class="line-modified">2870    * Stack:        StkElt StkElt --&gt; bool</span>
<span class="line-modified">2871    */</span>
2872   static void
2873   Ins_EQ( FT_Long*  args )
2874   {
2875     args[0] = ( args[0] == args[1] );
2876   }
2877 
2878 
<span class="line-modified">2879   /**************************************************************************</span>
<span class="line-modified">2880    *</span>
<span class="line-modified">2881    * NEQ[]:        Not EQual</span>
<span class="line-modified">2882    * Opcode range: 0x55</span>
<span class="line-modified">2883    * Stack:        StkElt StkElt --&gt; bool</span>
<span class="line-modified">2884    */</span>
2885   static void
2886   Ins_NEQ( FT_Long*  args )
2887   {
2888     args[0] = ( args[0] != args[1] );
2889   }
2890 
2891 
<span class="line-modified">2892   /**************************************************************************</span>
<span class="line-modified">2893    *</span>
<span class="line-modified">2894    * ODD[]:        Is ODD</span>
<span class="line-modified">2895    * Opcode range: 0x56</span>
<span class="line-modified">2896    * Stack:        f26.6 --&gt; bool</span>
<span class="line-modified">2897    */</span>
2898   static void
2899   Ins_ODD( TT_ExecContext  exc,
2900            FT_Long*        args )
2901   {
2902     args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 64 );
2903   }
2904 
2905 
<span class="line-modified">2906   /**************************************************************************</span>
<span class="line-modified">2907    *</span>
<span class="line-modified">2908    * EVEN[]:       Is EVEN</span>
<span class="line-modified">2909    * Opcode range: 0x57</span>
<span class="line-modified">2910    * Stack:        f26.6 --&gt; bool</span>
<span class="line-modified">2911    */</span>
2912   static void
2913   Ins_EVEN( TT_ExecContext  exc,
2914             FT_Long*        args )
2915   {
2916     args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 0 );
2917   }
2918 
2919 
<span class="line-modified">2920   /**************************************************************************</span>
<span class="line-modified">2921    *</span>
<span class="line-modified">2922    * AND[]:        logical AND</span>
<span class="line-modified">2923    * Opcode range: 0x5A</span>
<span class="line-modified">2924    * Stack:        uint32 uint32 --&gt; uint32</span>
<span class="line-modified">2925    */</span>
2926   static void
2927   Ins_AND( FT_Long*  args )
2928   {
2929     args[0] = ( args[0] &amp;&amp; args[1] );
2930   }
2931 
2932 
<span class="line-modified">2933   /**************************************************************************</span>
<span class="line-modified">2934    *</span>
<span class="line-modified">2935    * OR[]:         logical OR</span>
<span class="line-modified">2936    * Opcode range: 0x5B</span>
<span class="line-modified">2937    * Stack:        uint32 uint32 --&gt; uint32</span>
<span class="line-modified">2938    */</span>
2939   static void
2940   Ins_OR( FT_Long*  args )
2941   {
2942     args[0] = ( args[0] || args[1] );
2943   }
2944 
2945 
<span class="line-modified">2946   /**************************************************************************</span>
<span class="line-modified">2947    *</span>
<span class="line-modified">2948    * NOT[]:        logical NOT</span>
<span class="line-modified">2949    * Opcode range: 0x5C</span>
<span class="line-modified">2950    * Stack:        StkElt --&gt; uint32</span>
<span class="line-modified">2951    */</span>
2952   static void
2953   Ins_NOT( FT_Long*  args )
2954   {
2955     args[0] = !args[0];
2956   }
2957 
2958 
<span class="line-modified">2959   /**************************************************************************</span>
<span class="line-modified">2960    *</span>
<span class="line-modified">2961    * ADD[]:        ADD</span>
<span class="line-modified">2962    * Opcode range: 0x60</span>
<span class="line-modified">2963    * Stack:        f26.6 f26.6 --&gt; f26.6</span>
<span class="line-modified">2964    */</span>
2965   static void
2966   Ins_ADD( FT_Long*  args )
2967   {
2968     args[0] = ADD_LONG( args[0], args[1] );
2969   }
2970 
2971 
<span class="line-modified">2972   /**************************************************************************</span>
<span class="line-modified">2973    *</span>
<span class="line-modified">2974    * SUB[]:        SUBtract</span>
<span class="line-modified">2975    * Opcode range: 0x61</span>
<span class="line-modified">2976    * Stack:        f26.6 f26.6 --&gt; f26.6</span>
<span class="line-modified">2977    */</span>
2978   static void
2979   Ins_SUB( FT_Long*  args )
2980   {
2981     args[0] = SUB_LONG( args[0], args[1] );
2982   }
2983 
2984 
<span class="line-modified">2985   /**************************************************************************</span>
<span class="line-modified">2986    *</span>
<span class="line-modified">2987    * DIV[]:        DIVide</span>
<span class="line-modified">2988    * Opcode range: 0x62</span>
<span class="line-modified">2989    * Stack:        f26.6 f26.6 --&gt; f26.6</span>
<span class="line-modified">2990    */</span>
2991   static void
2992   Ins_DIV( TT_ExecContext  exc,
2993            FT_Long*        args )
2994   {
2995     if ( args[1] == 0 )
2996       exc-&gt;error = FT_THROW( Divide_By_Zero );
2997     else
2998       args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
2999   }
3000 
3001 
<span class="line-modified">3002   /**************************************************************************</span>
<span class="line-modified">3003    *</span>
<span class="line-modified">3004    * MUL[]:        MULtiply</span>
<span class="line-modified">3005    * Opcode range: 0x63</span>
<span class="line-modified">3006    * Stack:        f26.6 f26.6 --&gt; f26.6</span>
<span class="line-modified">3007    */</span>
3008   static void
3009   Ins_MUL( FT_Long*  args )
3010   {
3011     args[0] = FT_MulDiv( args[0], args[1], 64L );
3012   }
3013 
3014 
<span class="line-modified">3015   /**************************************************************************</span>
<span class="line-modified">3016    *</span>
<span class="line-modified">3017    * ABS[]:        ABSolute value</span>
<span class="line-modified">3018    * Opcode range: 0x64</span>
<span class="line-modified">3019    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3020    */</span>
3021   static void
3022   Ins_ABS( FT_Long*  args )
3023   {
3024     if ( args[0] &lt; 0 )
3025       args[0] = NEG_LONG( args[0] );
3026   }
3027 
3028 
<span class="line-modified">3029   /**************************************************************************</span>
<span class="line-modified">3030    *</span>
<span class="line-modified">3031    * NEG[]:        NEGate</span>
<span class="line-modified">3032    * Opcode range: 0x65</span>
<span class="line-modified">3033    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3034    */</span>
3035   static void
3036   Ins_NEG( FT_Long*  args )
3037   {
3038     args[0] = NEG_LONG( args[0] );
3039   }
3040 
3041 
<span class="line-modified">3042   /**************************************************************************</span>
<span class="line-modified">3043    *</span>
<span class="line-modified">3044    * FLOOR[]:      FLOOR</span>
<span class="line-modified">3045    * Opcode range: 0x66</span>
<span class="line-modified">3046    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3047    */</span>
3048   static void
3049   Ins_FLOOR( FT_Long*  args )
3050   {
3051     args[0] = FT_PIX_FLOOR( args[0] );
3052   }
3053 
3054 
<span class="line-modified">3055   /**************************************************************************</span>
<span class="line-modified">3056    *</span>
<span class="line-modified">3057    * CEILING[]:    CEILING</span>
<span class="line-modified">3058    * Opcode range: 0x67</span>
<span class="line-modified">3059    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3060    */</span>
3061   static void
3062   Ins_CEILING( FT_Long*  args )
3063   {
3064     args[0] = FT_PIX_CEIL_LONG( args[0] );
3065   }
3066 
3067 
<span class="line-modified">3068   /**************************************************************************</span>
<span class="line-modified">3069    *</span>
<span class="line-modified">3070    * RS[]:         Read Store</span>
<span class="line-modified">3071    * Opcode range: 0x43</span>
<span class="line-modified">3072    * Stack:        uint32 --&gt; uint32</span>
<span class="line-modified">3073    */</span>
3074   static void
3075   Ins_RS( TT_ExecContext  exc,
3076           FT_Long*        args )
3077   {
3078     FT_ULong  I = (FT_ULong)args[0];
3079 
3080 
3081     if ( BOUNDSL( I, exc-&gt;storeSize ) )
3082     {
3083       if ( exc-&gt;pedantic_hinting )
3084         ARRAY_BOUND_ERROR;
3085       else
3086         args[0] = 0;
3087     }
3088     else
3089     {
3090 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
3091       /* subpixel hinting - avoid Typeman Dstroke and */
3092       /* IStroke and Vacuform rounds                  */
3093       if ( SUBPIXEL_HINTING_INFINALITY                 &amp;&amp;
3094            exc-&gt;ignore_x_mode                          &amp;&amp;
3095            ( ( I == 24                             &amp;&amp;
3096                ( exc-&gt;face-&gt;sph_found_func_flags &amp;
3097                  ( SPH_FDEF_SPACING_1 |
3098                    SPH_FDEF_SPACING_2 )          ) ) ||
3099              ( I == 22                      &amp;&amp;
3100                ( exc-&gt;sph_in_func_flags   &amp;
3101                  SPH_FDEF_TYPEMAN_STROKES ) )        ||
3102              ( I == 8                              &amp;&amp;
3103                ( exc-&gt;face-&gt;sph_found_func_flags &amp;
3104                  SPH_FDEF_VACUFORM_ROUND_1       ) &amp;&amp;
3105                exc-&gt;iup_called                     ) ) )
3106         args[0] = 0;
3107       else
3108 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3109         args[0] = exc-&gt;storage[I];
3110     }
3111   }
3112 
3113 
<span class="line-modified">3114   /**************************************************************************</span>
<span class="line-modified">3115    *</span>
<span class="line-modified">3116    * WS[]:         Write Store</span>
<span class="line-modified">3117    * Opcode range: 0x42</span>
<span class="line-modified">3118    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">3119    */</span>
3120   static void
3121   Ins_WS( TT_ExecContext  exc,
3122           FT_Long*        args )
3123   {
3124     FT_ULong  I = (FT_ULong)args[0];
3125 
3126 
3127     if ( BOUNDSL( I, exc-&gt;storeSize ) )
3128     {
3129       if ( exc-&gt;pedantic_hinting )
3130         ARRAY_BOUND_ERROR;
3131     }
3132     else
3133       exc-&gt;storage[I] = args[1];
3134   }
3135 
3136 
<span class="line-modified">3137   /**************************************************************************</span>
<span class="line-modified">3138    *</span>
<span class="line-modified">3139    * WCVTP[]:      Write CVT in Pixel units</span>
<span class="line-modified">3140    * Opcode range: 0x44</span>
<span class="line-modified">3141    * Stack:        f26.6 uint32 --&gt;</span>
<span class="line-modified">3142    */</span>
3143   static void
3144   Ins_WCVTP( TT_ExecContext  exc,
3145              FT_Long*        args )
3146   {
3147     FT_ULong  I = (FT_ULong)args[0];
3148 
3149 
3150     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3151     {
3152       if ( exc-&gt;pedantic_hinting )
3153         ARRAY_BOUND_ERROR;
3154     }
3155     else
3156       exc-&gt;func_write_cvt( exc, I, args[1] );
3157   }
3158 
3159 
<span class="line-modified">3160   /**************************************************************************</span>
<span class="line-modified">3161    *</span>
<span class="line-modified">3162    * WCVTF[]:      Write CVT in Funits</span>
<span class="line-modified">3163    * Opcode range: 0x70</span>
<span class="line-modified">3164    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">3165    */</span>
3166   static void
3167   Ins_WCVTF( TT_ExecContext  exc,
3168              FT_Long*        args )
3169   {
3170     FT_ULong  I = (FT_ULong)args[0];
3171 
3172 
3173     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3174     {
3175       if ( exc-&gt;pedantic_hinting )
3176         ARRAY_BOUND_ERROR;
3177     }
3178     else
3179       exc-&gt;cvt[I] = FT_MulFix( args[1], exc-&gt;tt_metrics.scale );
3180   }
3181 
3182 
<span class="line-modified">3183   /**************************************************************************</span>
<span class="line-modified">3184    *</span>
<span class="line-modified">3185    * RCVT[]:       Read CVT</span>
<span class="line-modified">3186    * Opcode range: 0x45</span>
<span class="line-modified">3187    * Stack:        uint32 --&gt; f26.6</span>
<span class="line-modified">3188    */</span>
3189   static void
3190   Ins_RCVT( TT_ExecContext  exc,
3191             FT_Long*        args )
3192   {
3193     FT_ULong  I = (FT_ULong)args[0];
3194 
3195 
3196     if ( BOUNDSL( I, exc-&gt;cvtSize ) )
3197     {
3198       if ( exc-&gt;pedantic_hinting )
3199         ARRAY_BOUND_ERROR;
3200       else
3201         args[0] = 0;
3202     }
3203     else
3204       args[0] = exc-&gt;func_read_cvt( exc, I );
3205   }
3206 
3207 
<span class="line-modified">3208   /**************************************************************************</span>
<span class="line-modified">3209    *</span>
<span class="line-modified">3210    * AA[]:         Adjust Angle</span>
<span class="line-modified">3211    * Opcode range: 0x7F</span>
<span class="line-modified">3212    * Stack:        uint32 --&gt;</span>
<span class="line-modified">3213    */</span>
3214   static void
3215   Ins_AA( void )
3216   {
3217     /* intentionally no longer supported */
3218   }
3219 
3220 
<span class="line-modified">3221   /**************************************************************************</span>
<span class="line-modified">3222    *</span>
<span class="line-modified">3223    * DEBUG[]:      DEBUG.  Unsupported.</span>
<span class="line-modified">3224    * Opcode range: 0x4F</span>
<span class="line-modified">3225    * Stack:        uint32 --&gt;</span>
<span class="line-modified">3226    *</span>
<span class="line-modified">3227    * Note: The original instruction pops a value from the stack.</span>
<span class="line-modified">3228    */</span>
3229   static void
3230   Ins_DEBUG( TT_ExecContext  exc )
3231   {
3232     exc-&gt;error = FT_THROW( Debug_OpCode );
3233   }
3234 
3235 
<span class="line-modified">3236   /**************************************************************************</span>
<span class="line-modified">3237    *</span>
<span class="line-modified">3238    * ROUND[ab]:    ROUND value</span>
<span class="line-modified">3239    * Opcode range: 0x68-0x6B</span>
<span class="line-modified">3240    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3241    */</span>
3242   static void
3243   Ins_ROUND( TT_ExecContext  exc,
3244              FT_Long*        args )
3245   {
3246     args[0] = exc-&gt;func_round(
3247                 exc,
3248                 args[0],
3249                 exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x68] );
3250   }
3251 
3252 
<span class="line-modified">3253   /**************************************************************************</span>
<span class="line-modified">3254    *</span>
<span class="line-modified">3255    * NROUND[ab]:   No ROUNDing of value</span>
<span class="line-modified">3256    * Opcode range: 0x6C-0x6F</span>
<span class="line-modified">3257    * Stack:        f26.6 --&gt; f26.6</span>
<span class="line-modified">3258    */</span>
3259   static void
3260   Ins_NROUND( TT_ExecContext  exc,
3261               FT_Long*        args )
3262   {
3263     args[0] = Round_None(
3264                 exc,
3265                 args[0],
3266                 exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x6C] );
3267   }
3268 
3269 
<span class="line-modified">3270   /**************************************************************************</span>
<span class="line-modified">3271    *</span>
<span class="line-modified">3272    * MAX[]:        MAXimum</span>
<span class="line-modified">3273    * Opcode range: 0x8B</span>
<span class="line-modified">3274    * Stack:        int32? int32? --&gt; int32</span>
<span class="line-modified">3275    */</span>
3276   static void
3277   Ins_MAX( FT_Long*  args )
3278   {
3279     if ( args[1] &gt; args[0] )
3280       args[0] = args[1];
3281   }
3282 
3283 
<span class="line-modified">3284   /**************************************************************************</span>
<span class="line-modified">3285    *</span>
<span class="line-modified">3286    * MIN[]:        MINimum</span>
<span class="line-modified">3287    * Opcode range: 0x8C</span>
<span class="line-modified">3288    * Stack:        int32? int32? --&gt; int32</span>
<span class="line-modified">3289    */</span>
3290   static void
3291   Ins_MIN( FT_Long*  args )
3292   {
3293     if ( args[1] &lt; args[0] )
3294       args[0] = args[1];
3295   }
3296 
3297 
<span class="line-modified">3298   /**************************************************************************</span>
<span class="line-modified">3299    *</span>
<span class="line-modified">3300    * MINDEX[]:     Move INDEXed element</span>
<span class="line-modified">3301    * Opcode range: 0x26</span>
<span class="line-modified">3302    * Stack:        int32? --&gt; StkElt</span>
<span class="line-modified">3303    */</span>
3304   static void
3305   Ins_MINDEX( TT_ExecContext  exc,
3306               FT_Long*        args )
3307   {
3308     FT_Long  L, K;
3309 
3310 
3311     L = args[0];
3312 
3313     if ( L &lt;= 0 || L &gt; exc-&gt;args )
3314     {
3315       if ( exc-&gt;pedantic_hinting )
3316         exc-&gt;error = FT_THROW( Invalid_Reference );
3317     }
3318     else
3319     {
3320       K = exc-&gt;stack[exc-&gt;args - L];
3321 
3322       FT_ARRAY_MOVE( &amp;exc-&gt;stack[exc-&gt;args - L    ],
3323                      &amp;exc-&gt;stack[exc-&gt;args - L + 1],
3324                      ( L - 1 ) );
3325 
3326       exc-&gt;stack[exc-&gt;args - 1] = K;
3327     }
3328   }
3329 
3330 
<span class="line-modified">3331   /**************************************************************************</span>
<span class="line-modified">3332    *</span>
<span class="line-modified">3333    * CINDEX[]:     Copy INDEXed element</span>
<span class="line-modified">3334    * Opcode range: 0x25</span>
<span class="line-modified">3335    * Stack:        int32 --&gt; StkElt</span>
<span class="line-modified">3336    */</span>
3337   static void
3338   Ins_CINDEX( TT_ExecContext  exc,
3339               FT_Long*        args )
3340   {
3341     FT_Long  L;
3342 
3343 
3344     L = args[0];
3345 
3346     if ( L &lt;= 0 || L &gt; exc-&gt;args )
3347     {
3348       if ( exc-&gt;pedantic_hinting )
3349         exc-&gt;error = FT_THROW( Invalid_Reference );
3350       args[0] = 0;
3351     }
3352     else
3353       args[0] = exc-&gt;stack[exc-&gt;args - L];
3354   }
3355 
3356 
<span class="line-modified">3357   /**************************************************************************</span>
<span class="line-modified">3358    *</span>
<span class="line-modified">3359    * ROLL[]:       ROLL top three elements</span>
<span class="line-modified">3360    * Opcode range: 0x8A</span>
<span class="line-modified">3361    * Stack:        3 * StkElt --&gt; 3 * StkElt</span>
<span class="line-modified">3362    */</span>
3363   static void
3364   Ins_ROLL( FT_Long*  args )
3365   {
3366     FT_Long  A, B, C;
3367 
3368 
3369     A = args[2];
3370     B = args[1];
3371     C = args[0];
3372 
3373     args[2] = C;
3374     args[1] = A;
3375     args[0] = B;
3376   }
3377 
3378 
<span class="line-modified">3379   /**************************************************************************</span>
<span class="line-modified">3380    *</span>
<span class="line-modified">3381    * MANAGING THE FLOW OF CONTROL</span>
<span class="line-modified">3382    *</span>
<span class="line-modified">3383    */</span>
3384 
3385 
<span class="line-modified">3386   /**************************************************************************</span>
<span class="line-modified">3387    *</span>
<span class="line-modified">3388    * SLOOP[]:      Set LOOP variable</span>
<span class="line-modified">3389    * Opcode range: 0x17</span>
<span class="line-modified">3390    * Stack:        int32? --&gt;</span>
<span class="line-modified">3391    */</span>
3392   static void
3393   Ins_SLOOP( TT_ExecContext  exc,
3394              FT_Long*        args )
3395   {
3396     if ( args[0] &lt; 0 )
3397       exc-&gt;error = FT_THROW( Bad_Argument );
3398     else
3399     {
3400       /* we heuristically limit the number of loops to 16 bits */
3401       exc-&gt;GS.loop = args[0] &gt; 0xFFFFL ? 0xFFFFL : args[0];
3402     }
3403   }
3404 
3405 
3406   static FT_Bool
3407   SkipCode( TT_ExecContext  exc )
3408   {
3409     exc-&gt;IP += exc-&gt;length;
3410 
3411     if ( exc-&gt;IP &lt; exc-&gt;codeSize )
</pre>
<hr />
<pre>
3413       exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];
3414 
3415       exc-&gt;length = opcode_length[exc-&gt;opcode];
3416       if ( exc-&gt;length &lt; 0 )
3417       {
3418         if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )
3419           goto Fail_Overflow;
3420         exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];
3421       }
3422 
3423       if ( exc-&gt;IP + exc-&gt;length &lt;= exc-&gt;codeSize )
3424         return SUCCESS;
3425     }
3426 
3427   Fail_Overflow:
3428     exc-&gt;error = FT_THROW( Code_Overflow );
3429     return FAILURE;
3430   }
3431 
3432 
<span class="line-modified">3433   /**************************************************************************</span>
<span class="line-modified">3434    *</span>
<span class="line-modified">3435    * IF[]:         IF test</span>
<span class="line-modified">3436    * Opcode range: 0x58</span>
<span class="line-modified">3437    * Stack:        StkElt --&gt;</span>
<span class="line-modified">3438    */</span>
3439   static void
3440   Ins_IF( TT_ExecContext  exc,
3441           FT_Long*        args )
3442   {
3443     FT_Int   nIfs;
3444     FT_Bool  Out;
3445 
3446 
3447     if ( args[0] != 0 )
3448       return;
3449 
3450     nIfs = 1;
3451     Out = 0;
3452 
3453     do
3454     {
3455       if ( SkipCode( exc ) == FAILURE )
3456         return;
3457 
3458       switch ( exc-&gt;opcode )
3459       {
3460       case 0x58:      /* IF */
3461         nIfs++;
3462         break;
3463 
3464       case 0x1B:      /* ELSE */
3465         Out = FT_BOOL( nIfs == 1 );
3466         break;
3467 
3468       case 0x59:      /* EIF */
3469         nIfs--;
3470         Out = FT_BOOL( nIfs == 0 );
3471         break;
3472       }
3473     } while ( Out == 0 );
3474   }
3475 
3476 
<span class="line-modified">3477   /**************************************************************************</span>
<span class="line-modified">3478    *</span>
<span class="line-modified">3479    * ELSE[]:       ELSE</span>
<span class="line-modified">3480    * Opcode range: 0x1B</span>
<span class="line-modified">3481    * Stack:        --&gt;</span>
<span class="line-modified">3482    */</span>
3483   static void
3484   Ins_ELSE( TT_ExecContext  exc )
3485   {
3486     FT_Int  nIfs;
3487 
3488 
3489     nIfs = 1;
3490 
3491     do
3492     {
3493       if ( SkipCode( exc ) == FAILURE )
3494         return;
3495 
3496       switch ( exc-&gt;opcode )
3497       {
3498       case 0x58:    /* IF */
3499         nIfs++;
3500         break;
3501 
3502       case 0x59:    /* EIF */
3503         nIfs--;
3504         break;
3505       }
3506     } while ( nIfs != 0 );
3507   }
3508 
3509 
<span class="line-modified">3510   /**************************************************************************</span>
<span class="line-modified">3511    *</span>
<span class="line-modified">3512    * EIF[]:        End IF</span>
<span class="line-modified">3513    * Opcode range: 0x59</span>
<span class="line-modified">3514    * Stack:        --&gt;</span>
<span class="line-modified">3515    */</span>
3516   static void
3517   Ins_EIF( void )
3518   {
3519     /* nothing to do */
3520   }
3521 
3522 
<span class="line-modified">3523   /**************************************************************************</span>
<span class="line-modified">3524    *</span>
<span class="line-modified">3525    * JMPR[]:       JuMP Relative</span>
<span class="line-modified">3526    * Opcode range: 0x1C</span>
<span class="line-modified">3527    * Stack:        int32 --&gt;</span>
<span class="line-modified">3528    */</span>
3529   static void
3530   Ins_JMPR( TT_ExecContext  exc,
3531             FT_Long*        args )
3532   {
3533     if ( args[0] == 0 &amp;&amp; exc-&gt;args == 0 )
3534     {
3535       exc-&gt;error = FT_THROW( Bad_Argument );
3536       return;
3537     }
3538 
3539     exc-&gt;IP += args[0];
3540     if ( exc-&gt;IP &lt; 0                                             ||
3541          ( exc-&gt;callTop &gt; 0                                    &amp;&amp;
3542            exc-&gt;IP &gt; exc-&gt;callStack[exc-&gt;callTop - 1].Def-&gt;end ) )
3543     {
3544       exc-&gt;error = FT_THROW( Bad_Argument );
3545       return;
3546     }
3547 
3548     exc-&gt;step_ins = FALSE;
3549 
3550     if ( args[0] &lt; 0 )
3551     {
3552       if ( ++exc-&gt;neg_jump_counter &gt; exc-&gt;neg_jump_counter_max )
3553         exc-&gt;error = FT_THROW( Execution_Too_Long );
3554     }
3555   }
3556 
3557 
<span class="line-modified">3558   /**************************************************************************</span>
<span class="line-modified">3559    *</span>
<span class="line-modified">3560    * JROT[]:       Jump Relative On True</span>
<span class="line-modified">3561    * Opcode range: 0x78</span>
<span class="line-modified">3562    * Stack:        StkElt int32 --&gt;</span>
<span class="line-modified">3563    */</span>
3564   static void
3565   Ins_JROT( TT_ExecContext  exc,
3566             FT_Long*        args )
3567   {
3568     if ( args[1] != 0 )
3569       Ins_JMPR( exc, args );
3570   }
3571 
3572 
<span class="line-modified">3573   /**************************************************************************</span>
<span class="line-modified">3574    *</span>
<span class="line-modified">3575    * JROF[]:       Jump Relative On False</span>
<span class="line-modified">3576    * Opcode range: 0x79</span>
<span class="line-modified">3577    * Stack:        StkElt int32 --&gt;</span>
<span class="line-modified">3578    */</span>
3579   static void
3580   Ins_JROF( TT_ExecContext  exc,
3581             FT_Long*        args )
3582   {
3583     if ( args[1] == 0 )
3584       Ins_JMPR( exc, args );
3585   }
3586 
3587 
<span class="line-modified">3588   /**************************************************************************</span>
<span class="line-modified">3589    *</span>
<span class="line-modified">3590    * DEFINING AND USING FUNCTIONS AND INSTRUCTIONS</span>
<span class="line-modified">3591    *</span>
<span class="line-modified">3592    */</span>
3593 
3594 
<span class="line-modified">3595   /**************************************************************************</span>
<span class="line-modified">3596    *</span>
<span class="line-modified">3597    * FDEF[]:       Function DEFinition</span>
<span class="line-modified">3598    * Opcode range: 0x2C</span>
<span class="line-modified">3599    * Stack:        uint32 --&gt;</span>
<span class="line-modified">3600    */</span>
3601   static void
3602   Ins_FDEF( TT_ExecContext  exc,
3603             FT_Long*        args )
3604   {
3605     FT_ULong       n;
3606     TT_DefRecord*  rec;
3607     TT_DefRecord*  limit;
3608 
3609 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
3610     /* arguments to opcodes are skipped by `SKIP_Code&#39; */
3611     FT_Byte    opcode_pattern[9][12] = {
3612                  /* #0 inline delta function 1 */
3613                  {
3614                    0x4B, /* PPEM    */
3615                    0x53, /* GTEQ    */
3616                    0x23, /* SWAP    */
3617                    0x4B, /* PPEM    */
3618                    0x51, /* LTEQ    */
3619                    0x5A, /* AND     */
3620                    0x58, /* IF      */
</pre>
<hr />
<pre>
3878             ( exc-&gt;face-&gt;sph_found_func_flags &amp; SPH_FDEF_INLINE_DELTA_2 ) );
3879       }
3880 
3881 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3882 
3883       switch ( exc-&gt;opcode )
3884       {
3885       case 0x89:    /* IDEF */
3886       case 0x2C:    /* FDEF */
3887         exc-&gt;error = FT_THROW( Nested_DEFS );
3888         return;
3889 
3890       case 0x2D:   /* ENDF */
3891         rec-&gt;end = exc-&gt;IP;
3892         return;
3893       }
3894     }
3895   }
3896 
3897 
<span class="line-modified">3898   /**************************************************************************</span>
<span class="line-modified">3899    *</span>
<span class="line-modified">3900    * ENDF[]:       END Function definition</span>
<span class="line-modified">3901    * Opcode range: 0x2D</span>
<span class="line-modified">3902    * Stack:        --&gt;</span>
<span class="line-modified">3903    */</span>
3904   static void
3905   Ins_ENDF( TT_ExecContext  exc )
3906   {
3907     TT_CallRec*  pRec;
3908 
3909 
3910 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
3911     exc-&gt;sph_in_func_flags = 0x0000;
3912 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
3913 
3914     if ( exc-&gt;callTop &lt;= 0 )     /* We encountered an ENDF without a call */
3915     {
3916       exc-&gt;error = FT_THROW( ENDF_In_Exec_Stream );
3917       return;
3918     }
3919 
3920     exc-&gt;callTop--;
3921 
3922     pRec = &amp;exc-&gt;callStack[exc-&gt;callTop];
3923 
</pre>
<hr />
<pre>
3927 
3928     if ( pRec-&gt;Cur_Count &gt; 0 )
3929     {
3930       exc-&gt;callTop++;
3931       exc-&gt;IP = pRec-&gt;Def-&gt;start;
3932     }
3933     else
3934       /* Loop through the current function */
3935       Ins_Goto_CodeRange( exc, pRec-&gt;Caller_Range, pRec-&gt;Caller_IP );
3936 
3937     /* Exit the current call frame.                      */
3938 
3939     /* NOTE: If the last instruction of a program is a   */
3940     /*       CALL or LOOPCALL, the return address is     */
3941     /*       always out of the code range.  This is a    */
3942     /*       valid address, and it is why we do not test */
3943     /*       the result of Ins_Goto_CodeRange() here!    */
3944   }
3945 
3946 
<span class="line-modified">3947   /**************************************************************************</span>
<span class="line-modified">3948    *</span>
<span class="line-modified">3949    * CALL[]:       CALL function</span>
<span class="line-modified">3950    * Opcode range: 0x2B</span>
<span class="line-modified">3951    * Stack:        uint32? --&gt;</span>
<span class="line-modified">3952    */</span>
3953   static void
3954   Ins_CALL( TT_ExecContext  exc,
3955             FT_Long*        args )
3956   {
3957     FT_ULong       F;
3958     TT_CallRec*    pCrec;
3959     TT_DefRecord*  def;
3960 
3961 
3962     /* first of all, check the index */
3963 
3964     F = (FT_ULong)args[0];
3965     if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )
3966       goto Fail;
3967 
3968     /* Except for some old Apple fonts, all functions in a TrueType */
3969     /* font are defined in increasing order, starting from 0.  This */
3970     /* means that we normally have                                  */
3971     /*                                                              */
3972     /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */
</pre>
<hr />
<pre>
4016     pCrec = exc-&gt;callStack + exc-&gt;callTop;
4017 
4018     pCrec-&gt;Caller_Range = exc-&gt;curRange;
4019     pCrec-&gt;Caller_IP    = exc-&gt;IP + 1;
4020     pCrec-&gt;Cur_Count    = 1;
4021     pCrec-&gt;Def          = def;
4022 
4023     exc-&gt;callTop++;
4024 
4025     Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
4026 
4027     exc-&gt;step_ins = FALSE;
4028 
4029     return;
4030 
4031   Fail:
4032     exc-&gt;error = FT_THROW( Invalid_Reference );
4033   }
4034 
4035 
<span class="line-modified">4036   /**************************************************************************</span>
<span class="line-modified">4037    *</span>
<span class="line-modified">4038    * LOOPCALL[]:   LOOP and CALL function</span>
<span class="line-modified">4039    * Opcode range: 0x2A</span>
<span class="line-modified">4040    * Stack:        uint32? Eint16? --&gt;</span>
<span class="line-modified">4041    */</span>
4042   static void
4043   Ins_LOOPCALL( TT_ExecContext  exc,
4044                 FT_Long*        args )
4045   {
4046     FT_ULong       F;
4047     TT_CallRec*    pCrec;
4048     TT_DefRecord*  def;
4049 
4050 
4051     /* first of all, check the index */
4052     F = (FT_ULong)args[1];
4053     if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )
4054       goto Fail;
4055 
4056     /* Except for some old Apple fonts, all functions in a TrueType */
4057     /* font are defined in increasing order, starting from 0.  This */
4058     /* means that we normally have                                  */
4059     /*                                                              */
4060     /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */
4061     /*    exc-&gt;FDefs[n].opc == n for n in 0..exc-&gt;maxFunc           */
</pre>
<hr />
<pre>
4109       pCrec-&gt;Def          = def;
4110 
4111       exc-&gt;callTop++;
4112 
4113       Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
4114 
4115       exc-&gt;step_ins = FALSE;
4116 
4117       exc-&gt;loopcall_counter += (FT_ULong)args[0];
4118       if ( exc-&gt;loopcall_counter &gt; exc-&gt;loopcall_counter_max )
4119         exc-&gt;error = FT_THROW( Execution_Too_Long );
4120     }
4121 
4122     return;
4123 
4124   Fail:
4125     exc-&gt;error = FT_THROW( Invalid_Reference );
4126   }
4127 
4128 
<span class="line-modified">4129   /**************************************************************************</span>
<span class="line-modified">4130    *</span>
<span class="line-modified">4131    * IDEF[]:       Instruction DEFinition</span>
<span class="line-modified">4132    * Opcode range: 0x89</span>
<span class="line-modified">4133    * Stack:        Eint8 --&gt;</span>
<span class="line-modified">4134    */</span>
4135   static void
4136   Ins_IDEF( TT_ExecContext  exc,
4137             FT_Long*        args )
4138   {
4139     TT_DefRecord*  def;
4140     TT_DefRecord*  limit;
4141 
4142 
4143     /* we enable IDEF only in `prep&#39; or `fpgm&#39; */
4144     if ( exc-&gt;curRange == tt_coderange_glyph )
4145     {
4146       exc-&gt;error = FT_THROW( DEF_In_Glyf_Bytecode );
4147       return;
4148     }
4149 
4150     /*  First of all, look for the same function in our table */
4151 
4152     def   = exc-&gt;IDefs;
4153     limit = def + exc-&gt;numIDefs;
4154 
</pre>
<hr />
<pre>
4184 
4185     /* Now skip the whole function definition. */
4186     /* We don&#39;t allow nested IDEFs &amp; FDEFs.    */
4187 
4188     while ( SkipCode( exc ) == SUCCESS )
4189     {
4190       switch ( exc-&gt;opcode )
4191       {
4192       case 0x89:   /* IDEF */
4193       case 0x2C:   /* FDEF */
4194         exc-&gt;error = FT_THROW( Nested_DEFS );
4195         return;
4196       case 0x2D:   /* ENDF */
4197         def-&gt;end = exc-&gt;IP;
4198         return;
4199       }
4200     }
4201   }
4202 
4203 
<span class="line-modified">4204   /**************************************************************************</span>
<span class="line-modified">4205    *</span>
<span class="line-modified">4206    * PUSHING DATA ONTO THE INTERPRETER STACK</span>
<span class="line-modified">4207    *</span>
<span class="line-modified">4208    */</span>
4209 
4210 
<span class="line-modified">4211   /**************************************************************************</span>
<span class="line-modified">4212    *</span>
<span class="line-modified">4213    * NPUSHB[]:     PUSH N Bytes</span>
<span class="line-modified">4214    * Opcode range: 0x40</span>
<span class="line-modified">4215    * Stack:        --&gt; uint32...</span>
<span class="line-modified">4216    */</span>
4217   static void
4218   Ins_NPUSHB( TT_ExecContext  exc,
4219               FT_Long*        args )
4220   {
4221     FT_UShort  L, K;
4222 
4223 
4224     L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];
4225 
4226     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4227     {
4228       exc-&gt;error = FT_THROW( Stack_Overflow );
4229       return;
4230     }
4231 
4232     for ( K = 1; K &lt;= L; K++ )
4233       args[K - 1] = exc-&gt;code[exc-&gt;IP + K + 1];
4234 
4235     exc-&gt;new_top += L;
4236   }
4237 
4238 
<span class="line-modified">4239   /**************************************************************************</span>
<span class="line-modified">4240    *</span>
<span class="line-modified">4241    * NPUSHW[]:     PUSH N Words</span>
<span class="line-modified">4242    * Opcode range: 0x41</span>
<span class="line-modified">4243    * Stack:        --&gt; int32...</span>
<span class="line-modified">4244    */</span>
4245   static void
4246   Ins_NPUSHW( TT_ExecContext  exc,
4247               FT_Long*        args )
4248   {
4249     FT_UShort  L, K;
4250 
4251 
4252     L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];
4253 
4254     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4255     {
4256       exc-&gt;error = FT_THROW( Stack_Overflow );
4257       return;
4258     }
4259 
4260     exc-&gt;IP += 2;
4261 
4262     for ( K = 0; K &lt; L; K++ )
4263       args[K] = GetShortIns( exc );
4264 
4265     exc-&gt;step_ins = FALSE;
4266     exc-&gt;new_top += L;
4267   }
4268 
4269 
<span class="line-modified">4270   /**************************************************************************</span>
<span class="line-modified">4271    *</span>
<span class="line-modified">4272    * PUSHB[abc]:   PUSH Bytes</span>
<span class="line-modified">4273    * Opcode range: 0xB0-0xB7</span>
<span class="line-modified">4274    * Stack:        --&gt; uint32...</span>
<span class="line-modified">4275    */</span>
4276   static void
4277   Ins_PUSHB( TT_ExecContext  exc,
4278              FT_Long*        args )
4279   {
4280     FT_UShort  L, K;
4281 
4282 
4283     L = (FT_UShort)( exc-&gt;opcode - 0xB0 + 1 );
4284 
4285     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4286     {
4287       exc-&gt;error = FT_THROW( Stack_Overflow );
4288       return;
4289     }
4290 
4291     for ( K = 1; K &lt;= L; K++ )
4292       args[K - 1] = exc-&gt;code[exc-&gt;IP + K];
4293   }
4294 
4295 
<span class="line-modified">4296   /**************************************************************************</span>
<span class="line-modified">4297    *</span>
<span class="line-modified">4298    * PUSHW[abc]:   PUSH Words</span>
<span class="line-modified">4299    * Opcode range: 0xB8-0xBF</span>
<span class="line-modified">4300    * Stack:        --&gt; int32...</span>
<span class="line-modified">4301    */</span>
4302   static void
4303   Ins_PUSHW( TT_ExecContext  exc,
4304              FT_Long*        args )
4305   {
4306     FT_UShort  L, K;
4307 
4308 
4309     L = (FT_UShort)( exc-&gt;opcode - 0xB8 + 1 );
4310 
4311     if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )
4312     {
4313       exc-&gt;error = FT_THROW( Stack_Overflow );
4314       return;
4315     }
4316 
4317     exc-&gt;IP++;
4318 
4319     for ( K = 0; K &lt; L; K++ )
4320       args[K] = GetShortIns( exc );
4321 
4322     exc-&gt;step_ins = FALSE;
4323   }
4324 
4325 
<span class="line-modified">4326   /**************************************************************************</span>
<span class="line-modified">4327    *</span>
<span class="line-modified">4328    * MANAGING THE GRAPHICS STATE</span>
<span class="line-modified">4329    *</span>
<span class="line-modified">4330    */</span>
4331 
4332 
4333   static FT_Bool
4334   Ins_SxVTL( TT_ExecContext  exc,
4335              FT_UShort       aIdx1,
4336              FT_UShort       aIdx2,
4337              FT_UnitVector*  Vec )
4338   {
4339     FT_Long     A, B, C;
4340     FT_Vector*  p1;
4341     FT_Vector*  p2;
4342 
4343     FT_Byte  opcode = exc-&gt;opcode;
4344 
4345 
4346     if ( BOUNDS( aIdx1, exc-&gt;zp2.n_points ) ||
4347          BOUNDS( aIdx2, exc-&gt;zp1.n_points ) )
4348     {
4349       if ( exc-&gt;pedantic_hinting )
4350         exc-&gt;error = FT_THROW( Invalid_Reference );
</pre>
<hr />
<pre>
4364 
4365     if ( A == 0 &amp;&amp; B == 0 )
4366     {
4367       A      = 0x4000;
4368       opcode = 0;
4369     }
4370 
4371     if ( ( opcode &amp; 1 ) != 0 )
4372     {
4373       C = B;   /* counter clockwise rotation */
4374       B = A;
4375       A = NEG_LONG( C );
4376     }
4377 
4378     Normalize( A, B, Vec );
4379 
4380     return SUCCESS;
4381   }
4382 
4383 
<span class="line-modified">4384   /**************************************************************************</span>
<span class="line-modified">4385    *</span>
<span class="line-modified">4386    * SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis</span>
<span class="line-modified">4387    * Opcode range: 0x00-0x01</span>
<span class="line-modified">4388    * Stack:        --&gt;</span>
<span class="line-modified">4389    *</span>
<span class="line-modified">4390    * SPvTCA[a]:    Set PVector to Coordinate Axis</span>
<span class="line-modified">4391    * Opcode range: 0x02-0x03</span>
<span class="line-modified">4392    * Stack:        --&gt;</span>
<span class="line-modified">4393    *</span>
<span class="line-modified">4394    * SFvTCA[a]:    Set FVector to Coordinate Axis</span>
<span class="line-modified">4395    * Opcode range: 0x04-0x05</span>
<span class="line-modified">4396    * Stack:        --&gt;</span>
<span class="line-modified">4397    */</span>
4398   static void
4399   Ins_SxyTCA( TT_ExecContext  exc )
4400   {
4401     FT_Short  AA, BB;
4402 
4403     FT_Byte  opcode = exc-&gt;opcode;
4404 
4405 
4406     AA = (FT_Short)( ( opcode &amp; 1 ) &lt;&lt; 14 );
4407     BB = (FT_Short)( AA ^ 0x4000 );
4408 
4409     if ( opcode &lt; 4 )
4410     {
4411       exc-&gt;GS.projVector.x = AA;
4412       exc-&gt;GS.projVector.y = BB;
4413 
4414       exc-&gt;GS.dualVector.x = AA;
4415       exc-&gt;GS.dualVector.y = BB;
4416     }
4417 
4418     if ( ( opcode &amp; 2 ) == 0 )
4419     {
4420       exc-&gt;GS.freeVector.x = AA;
4421       exc-&gt;GS.freeVector.y = BB;
4422     }
4423 
4424     Compute_Funcs( exc );
4425   }
4426 
4427 
<span class="line-modified">4428   /**************************************************************************</span>
<span class="line-modified">4429    *</span>
<span class="line-modified">4430    * SPvTL[a]:     Set PVector To Line</span>
<span class="line-modified">4431    * Opcode range: 0x06-0x07</span>
<span class="line-modified">4432    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">4433    */</span>
4434   static void
4435   Ins_SPVTL( TT_ExecContext  exc,
4436              FT_Long*        args )
4437   {
4438     if ( Ins_SxVTL( exc,
4439                     (FT_UShort)args[1],
4440                     (FT_UShort)args[0],
4441                     &amp;exc-&gt;GS.projVector ) == SUCCESS )
4442     {
4443       exc-&gt;GS.dualVector = exc-&gt;GS.projVector;
4444       Compute_Funcs( exc );
4445     }
4446   }
4447 
4448 
<span class="line-modified">4449   /**************************************************************************</span>
<span class="line-modified">4450    *</span>
<span class="line-modified">4451    * SFvTL[a]:     Set FVector To Line</span>
<span class="line-modified">4452    * Opcode range: 0x08-0x09</span>
<span class="line-modified">4453    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">4454    */</span>
4455   static void
4456   Ins_SFVTL( TT_ExecContext  exc,
4457              FT_Long*        args )
4458   {
4459     if ( Ins_SxVTL( exc,
4460                     (FT_UShort)args[1],
4461                     (FT_UShort)args[0],
4462                     &amp;exc-&gt;GS.freeVector ) == SUCCESS )
4463     {
4464       Compute_Funcs( exc );
4465     }
4466   }
4467 
4468 
<span class="line-modified">4469   /**************************************************************************</span>
<span class="line-modified">4470    *</span>
<span class="line-modified">4471    * SFvTPv[]:     Set FVector To PVector</span>
<span class="line-modified">4472    * Opcode range: 0x0E</span>
<span class="line-modified">4473    * Stack:        --&gt;</span>
<span class="line-modified">4474    */</span>
4475   static void
4476   Ins_SFVTPV( TT_ExecContext  exc )
4477   {
4478     exc-&gt;GS.freeVector = exc-&gt;GS.projVector;
4479     Compute_Funcs( exc );
4480   }
4481 
4482 
<span class="line-modified">4483   /**************************************************************************</span>
<span class="line-modified">4484    *</span>
<span class="line-modified">4485    * SPvFS[]:      Set PVector From Stack</span>
<span class="line-modified">4486    * Opcode range: 0x0A</span>
<span class="line-modified">4487    * Stack:        f2.14 f2.14 --&gt;</span>
<span class="line-modified">4488    */</span>
4489   static void
4490   Ins_SPVFS( TT_ExecContext  exc,
4491              FT_Long*        args )
4492   {
4493     FT_Short  S;
4494     FT_Long   X, Y;
4495 
4496 
4497     /* Only use low 16bits, then sign extend */
4498     S = (FT_Short)args[1];
4499     Y = (FT_Long)S;
4500     S = (FT_Short)args[0];
4501     X = (FT_Long)S;
4502 
4503     Normalize( X, Y, &amp;exc-&gt;GS.projVector );
4504 
4505     exc-&gt;GS.dualVector = exc-&gt;GS.projVector;
4506     Compute_Funcs( exc );
4507   }
4508 
4509 
<span class="line-modified">4510   /**************************************************************************</span>
<span class="line-modified">4511    *</span>
<span class="line-modified">4512    * SFvFS[]:      Set FVector From Stack</span>
<span class="line-modified">4513    * Opcode range: 0x0B</span>
<span class="line-modified">4514    * Stack:        f2.14 f2.14 --&gt;</span>
<span class="line-modified">4515    */</span>
4516   static void
4517   Ins_SFVFS( TT_ExecContext  exc,
4518              FT_Long*        args )
4519   {
4520     FT_Short  S;
4521     FT_Long   X, Y;
4522 
4523 
4524     /* Only use low 16bits, then sign extend */
4525     S = (FT_Short)args[1];
4526     Y = (FT_Long)S;
4527     S = (FT_Short)args[0];
4528     X = S;
4529 
4530     Normalize( X, Y, &amp;exc-&gt;GS.freeVector );
4531     Compute_Funcs( exc );
4532   }
4533 
4534 
<span class="line-modified">4535   /**************************************************************************</span>
<span class="line-modified">4536    *</span>
<span class="line-modified">4537    * GPv[]:        Get Projection Vector</span>
<span class="line-modified">4538    * Opcode range: 0x0C</span>
<span class="line-modified">4539    * Stack:        ef2.14 --&gt; ef2.14</span>
<span class="line-modified">4540    */</span>
4541   static void
4542   Ins_GPV( TT_ExecContext  exc,
4543            FT_Long*        args )
4544   {
4545     args[0] = exc-&gt;GS.projVector.x;
4546     args[1] = exc-&gt;GS.projVector.y;
4547   }
4548 
4549 
<span class="line-modified">4550   /**************************************************************************</span>
<span class="line-modified">4551    *</span>
<span class="line-modified">4552    * GFv[]:        Get Freedom Vector</span>
<span class="line-modified">4553    * Opcode range: 0x0D</span>
<span class="line-modified">4554    * Stack:        ef2.14 --&gt; ef2.14</span>
<span class="line-modified">4555    */</span>
4556   static void
4557   Ins_GFV( TT_ExecContext  exc,
4558            FT_Long*        args )
4559   {
4560     args[0] = exc-&gt;GS.freeVector.x;
4561     args[1] = exc-&gt;GS.freeVector.y;
4562   }
4563 
4564 
<span class="line-modified">4565   /**************************************************************************</span>
<span class="line-modified">4566    *</span>
<span class="line-modified">4567    * SRP0[]:       Set Reference Point 0</span>
<span class="line-modified">4568    * Opcode range: 0x10</span>
<span class="line-modified">4569    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4570    */</span>
4571   static void
4572   Ins_SRP0( TT_ExecContext  exc,
4573             FT_Long*        args )
4574   {
4575     exc-&gt;GS.rp0 = (FT_UShort)args[0];
4576   }
4577 
4578 
<span class="line-modified">4579   /**************************************************************************</span>
<span class="line-modified">4580    *</span>
<span class="line-modified">4581    * SRP1[]:       Set Reference Point 1</span>
<span class="line-modified">4582    * Opcode range: 0x11</span>
<span class="line-modified">4583    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4584    */</span>
4585   static void
4586   Ins_SRP1( TT_ExecContext  exc,
4587             FT_Long*        args )
4588   {
4589     exc-&gt;GS.rp1 = (FT_UShort)args[0];
4590   }
4591 
4592 
<span class="line-modified">4593   /**************************************************************************</span>
<span class="line-modified">4594    *</span>
<span class="line-modified">4595    * SRP2[]:       Set Reference Point 2</span>
<span class="line-modified">4596    * Opcode range: 0x12</span>
<span class="line-modified">4597    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4598    */</span>
4599   static void
4600   Ins_SRP2( TT_ExecContext  exc,
4601             FT_Long*        args )
4602   {
4603     exc-&gt;GS.rp2 = (FT_UShort)args[0];
4604   }
4605 
4606 
<span class="line-modified">4607   /**************************************************************************</span>
<span class="line-modified">4608    *</span>
<span class="line-modified">4609    * SMD[]:        Set Minimum Distance</span>
<span class="line-modified">4610    * Opcode range: 0x1A</span>
<span class="line-modified">4611    * Stack:        f26.6 --&gt;</span>
<span class="line-modified">4612    */</span>
4613   static void
4614   Ins_SMD( TT_ExecContext  exc,
4615            FT_Long*        args )
4616   {
4617     exc-&gt;GS.minimum_distance = args[0];
4618   }
4619 
4620 
<span class="line-modified">4621   /**************************************************************************</span>
<span class="line-modified">4622    *</span>
<span class="line-modified">4623    * SCVTCI[]:     Set Control Value Table Cut In</span>
<span class="line-modified">4624    * Opcode range: 0x1D</span>
<span class="line-modified">4625    * Stack:        f26.6 --&gt;</span>
<span class="line-modified">4626    */</span>
4627   static void
4628   Ins_SCVTCI( TT_ExecContext  exc,
4629               FT_Long*        args )
4630   {
4631     exc-&gt;GS.control_value_cutin = (FT_F26Dot6)args[0];
4632   }
4633 
4634 
<span class="line-modified">4635   /**************************************************************************</span>
<span class="line-modified">4636    *</span>
<span class="line-modified">4637    * SSWCI[]:      Set Single Width Cut In</span>
<span class="line-modified">4638    * Opcode range: 0x1E</span>
<span class="line-modified">4639    * Stack:        f26.6 --&gt;</span>
<span class="line-modified">4640    */</span>
4641   static void
4642   Ins_SSWCI( TT_ExecContext  exc,
4643              FT_Long*        args )
4644   {
4645     exc-&gt;GS.single_width_cutin = (FT_F26Dot6)args[0];
4646   }
4647 
4648 
<span class="line-modified">4649   /**************************************************************************</span>
<span class="line-modified">4650    *</span>
<span class="line-modified">4651    * SSW[]:        Set Single Width</span>
<span class="line-modified">4652    * Opcode range: 0x1F</span>
<span class="line-modified">4653    * Stack:        int32? --&gt;</span>
<span class="line-modified">4654    */</span>
4655   static void
4656   Ins_SSW( TT_ExecContext  exc,
4657            FT_Long*        args )
4658   {
4659     exc-&gt;GS.single_width_value = FT_MulFix( args[0],
4660                                             exc-&gt;tt_metrics.scale );
4661   }
4662 
4663 
<span class="line-modified">4664   /**************************************************************************</span>
<span class="line-modified">4665    *</span>
<span class="line-modified">4666    * FLIPON[]:     Set auto-FLIP to ON</span>
<span class="line-modified">4667    * Opcode range: 0x4D</span>
<span class="line-modified">4668    * Stack:        --&gt;</span>
<span class="line-modified">4669    */</span>
4670   static void
4671   Ins_FLIPON( TT_ExecContext  exc )
4672   {
4673     exc-&gt;GS.auto_flip = TRUE;
4674   }
4675 
4676 
<span class="line-modified">4677   /**************************************************************************</span>
<span class="line-modified">4678    *</span>
<span class="line-modified">4679    * FLIPOFF[]:    Set auto-FLIP to OFF</span>
<span class="line-modified">4680    * Opcode range: 0x4E</span>
<span class="line-modified">4681    * Stack:        --&gt;</span>
<span class="line-modified">4682    */</span>
4683   static void
4684   Ins_FLIPOFF( TT_ExecContext  exc )
4685   {
4686     exc-&gt;GS.auto_flip = FALSE;
4687   }
4688 
4689 
<span class="line-modified">4690   /**************************************************************************</span>
<span class="line-modified">4691    *</span>
<span class="line-modified">4692    * SANGW[]:      Set ANGle Weight</span>
<span class="line-modified">4693    * Opcode range: 0x7E</span>
<span class="line-modified">4694    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4695    */</span>
4696   static void
4697   Ins_SANGW( void )
4698   {
4699     /* instruction not supported anymore */
4700   }
4701 
4702 
<span class="line-modified">4703   /**************************************************************************</span>
<span class="line-modified">4704    *</span>
<span class="line-modified">4705    * SDB[]:        Set Delta Base</span>
<span class="line-modified">4706    * Opcode range: 0x5E</span>
<span class="line-modified">4707    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4708    */</span>
4709   static void
4710   Ins_SDB( TT_ExecContext  exc,
4711            FT_Long*        args )
4712   {
4713     exc-&gt;GS.delta_base = (FT_UShort)args[0];
4714   }
4715 
4716 
<span class="line-modified">4717   /**************************************************************************</span>
<span class="line-modified">4718    *</span>
<span class="line-modified">4719    * SDS[]:        Set Delta Shift</span>
<span class="line-modified">4720    * Opcode range: 0x5F</span>
<span class="line-modified">4721    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4722    */</span>
4723   static void
4724   Ins_SDS( TT_ExecContext  exc,
4725            FT_Long*        args )
4726   {
4727     if ( (FT_ULong)args[0] &gt; 6UL )
4728       exc-&gt;error = FT_THROW( Bad_Argument );
4729     else
4730       exc-&gt;GS.delta_shift = (FT_UShort)args[0];
4731   }
4732 
4733 
<span class="line-modified">4734   /**************************************************************************</span>
<span class="line-modified">4735    *</span>
<span class="line-modified">4736    * RTHG[]:       Round To Half Grid</span>
<span class="line-modified">4737    * Opcode range: 0x19</span>
<span class="line-modified">4738    * Stack:        --&gt;</span>
<span class="line-modified">4739    */</span>
4740   static void
4741   Ins_RTHG( TT_ExecContext  exc )
4742   {
4743     exc-&gt;GS.round_state = TT_Round_To_Half_Grid;
4744     exc-&gt;func_round     = (TT_Round_Func)Round_To_Half_Grid;
4745   }
4746 
4747 
<span class="line-modified">4748   /**************************************************************************</span>
<span class="line-modified">4749    *</span>
<span class="line-modified">4750    * RTG[]:        Round To Grid</span>
<span class="line-modified">4751    * Opcode range: 0x18</span>
<span class="line-modified">4752    * Stack:        --&gt;</span>
<span class="line-modified">4753    */</span>
4754   static void
4755   Ins_RTG( TT_ExecContext  exc )
4756   {
4757     exc-&gt;GS.round_state = TT_Round_To_Grid;
4758     exc-&gt;func_round     = (TT_Round_Func)Round_To_Grid;
4759   }
4760 
4761 
<span class="line-modified">4762   /**************************************************************************</span>
<span class="line-modified">4763    * RTDG[]:       Round To Double Grid</span>
<span class="line-modified">4764    * Opcode range: 0x3D</span>
<span class="line-modified">4765    * Stack:        --&gt;</span>
<span class="line-modified">4766    */</span>
4767   static void
4768   Ins_RTDG( TT_ExecContext  exc )
4769   {
4770     exc-&gt;GS.round_state = TT_Round_To_Double_Grid;
4771     exc-&gt;func_round     = (TT_Round_Func)Round_To_Double_Grid;
4772   }
4773 
4774 
<span class="line-modified">4775   /**************************************************************************</span>
<span class="line-modified">4776    * RUTG[]:       Round Up To Grid</span>
<span class="line-modified">4777    * Opcode range: 0x7C</span>
<span class="line-modified">4778    * Stack:        --&gt;</span>
<span class="line-modified">4779    */</span>
4780   static void
4781   Ins_RUTG( TT_ExecContext  exc )
4782   {
4783     exc-&gt;GS.round_state = TT_Round_Up_To_Grid;
4784     exc-&gt;func_round     = (TT_Round_Func)Round_Up_To_Grid;
4785   }
4786 
4787 
<span class="line-modified">4788   /**************************************************************************</span>
<span class="line-modified">4789    *</span>
<span class="line-modified">4790    * RDTG[]:       Round Down To Grid</span>
<span class="line-modified">4791    * Opcode range: 0x7D</span>
<span class="line-modified">4792    * Stack:        --&gt;</span>
<span class="line-modified">4793    */</span>
4794   static void
4795   Ins_RDTG( TT_ExecContext  exc )
4796   {
4797     exc-&gt;GS.round_state = TT_Round_Down_To_Grid;
4798     exc-&gt;func_round     = (TT_Round_Func)Round_Down_To_Grid;
4799   }
4800 
4801 
<span class="line-modified">4802   /**************************************************************************</span>
<span class="line-modified">4803    *</span>
<span class="line-modified">4804    * ROFF[]:       Round OFF</span>
<span class="line-modified">4805    * Opcode range: 0x7A</span>
<span class="line-modified">4806    * Stack:        --&gt;</span>
<span class="line-modified">4807    */</span>
4808   static void
4809   Ins_ROFF( TT_ExecContext  exc )
4810   {
4811     exc-&gt;GS.round_state = TT_Round_Off;
4812     exc-&gt;func_round     = (TT_Round_Func)Round_None;
4813   }
4814 
4815 
<span class="line-modified">4816   /**************************************************************************</span>
<span class="line-modified">4817    *</span>
<span class="line-modified">4818    * SROUND[]:     Super ROUND</span>
<span class="line-modified">4819    * Opcode range: 0x76</span>
<span class="line-modified">4820    * Stack:        Eint8 --&gt;</span>
<span class="line-modified">4821    */</span>
4822   static void
4823   Ins_SROUND( TT_ExecContext  exc,
4824               FT_Long*        args )
4825   {
4826     SetSuperRound( exc, 0x4000, args[0] );
4827 
4828     exc-&gt;GS.round_state = TT_Round_Super;
4829     exc-&gt;func_round     = (TT_Round_Func)Round_Super;
4830   }
4831 
4832 
<span class="line-modified">4833   /**************************************************************************</span>
<span class="line-modified">4834    *</span>
<span class="line-modified">4835    * S45ROUND[]:   Super ROUND 45 degrees</span>
<span class="line-modified">4836    * Opcode range: 0x77</span>
<span class="line-modified">4837    * Stack:        uint32 --&gt;</span>
<span class="line-modified">4838    */</span>
4839   static void
4840   Ins_S45ROUND( TT_ExecContext  exc,
4841                 FT_Long*        args )
4842   {
4843     SetSuperRound( exc, 0x2D41, args[0] );
4844 
4845     exc-&gt;GS.round_state = TT_Round_Super_45;
4846     exc-&gt;func_round     = (TT_Round_Func)Round_Super_45;
4847   }
4848 
4849 
<span class="line-modified">4850   /**************************************************************************</span>
<span class="line-modified">4851    *</span>
<span class="line-modified">4852    * GC[a]:        Get Coordinate projected onto</span>
<span class="line-modified">4853    * Opcode range: 0x46-0x47</span>
<span class="line-modified">4854    * Stack:        uint32 --&gt; f26.6</span>
<span class="line-modified">4855    *</span>
<span class="line-modified">4856    * XXX: UNDOCUMENTED: Measures from the original glyph must be taken</span>
<span class="line-modified">4857    *      along the dual projection vector!</span>
<span class="line-modified">4858    */</span>
4859   static void
4860   Ins_GC( TT_ExecContext  exc,
4861           FT_Long*        args )
4862   {
4863     FT_ULong    L;
4864     FT_F26Dot6  R;
4865 
4866 
4867     L = (FT_ULong)args[0];
4868 
4869     if ( BOUNDSL( L, exc-&gt;zp2.n_points ) )
4870     {
4871       if ( exc-&gt;pedantic_hinting )
4872         exc-&gt;error = FT_THROW( Invalid_Reference );
4873       R = 0;
4874     }
4875     else
4876     {
4877       if ( exc-&gt;opcode &amp; 1 )
4878         R = FAST_DUALPROJ( &amp;exc-&gt;zp2.org[L] );
4879       else
4880         R = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );
4881     }
4882 
4883     args[0] = R;
4884   }
4885 
4886 
<span class="line-modified">4887   /**************************************************************************</span>
<span class="line-modified">4888    *</span>
<span class="line-modified">4889    * SCFS[]:       Set Coordinate From Stack</span>
<span class="line-modified">4890    * Opcode range: 0x48</span>
<span class="line-modified">4891    * Stack:        f26.6 uint32 --&gt;</span>
<span class="line-modified">4892    *</span>
<span class="line-modified">4893    * Formula:</span>
<span class="line-modified">4894    *</span>
<span class="line-modified">4895    *   OA := OA + ( value - OA.p )/( f.p ) * f</span>
<span class="line-modified">4896    */</span>
4897   static void
4898   Ins_SCFS( TT_ExecContext  exc,
4899             FT_Long*        args )
4900   {
4901     FT_Long    K;
4902     FT_UShort  L;
4903 
4904 
4905     L = (FT_UShort)args[0];
4906 
4907     if ( BOUNDS( L, exc-&gt;zp2.n_points ) )
4908     {
4909       if ( exc-&gt;pedantic_hinting )
4910         exc-&gt;error = FT_THROW( Invalid_Reference );
4911       return;
4912     }
4913 
4914     K = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );
4915 
4916     exc-&gt;func_move( exc, &amp;exc-&gt;zp2, L, SUB_LONG( args[1], K ) );
4917 
4918     /* UNDOCUMENTED!  The MS rasterizer does that with */
4919     /* twilight points (confirmed by Greg Hitchcock)   */
4920     if ( exc-&gt;GS.gep2 == 0 )
4921       exc-&gt;zp2.org[L] = exc-&gt;zp2.cur[L];
4922   }
4923 
4924 
<span class="line-modified">4925   /**************************************************************************</span>
<span class="line-modified">4926    *</span>
<span class="line-modified">4927    * MD[a]:        Measure Distance</span>
<span class="line-modified">4928    * Opcode range: 0x49-0x4A</span>
<span class="line-modified">4929    * Stack:        uint32 uint32 --&gt; f26.6</span>
<span class="line-modified">4930    *</span>
<span class="line-modified">4931    * XXX: UNDOCUMENTED: Measure taken in the original glyph must be along</span>
<span class="line-modified">4932    *                    the dual projection vector.</span>
<span class="line-modified">4933    *</span>
<span class="line-modified">4934    * XXX: UNDOCUMENTED: Flag attributes are inverted!</span>
<span class="line-modified">4935    *                      0 =&gt; measure distance in original outline</span>
<span class="line-modified">4936    *                      1 =&gt; measure distance in grid-fitted outline</span>
<span class="line-modified">4937    *</span>
<span class="line-modified">4938    * XXX: UNDOCUMENTED: `zp0 - zp1&#39;, and not `zp2 - zp1!</span>
<span class="line-modified">4939    */</span>
4940   static void
4941   Ins_MD( TT_ExecContext  exc,
4942           FT_Long*        args )
4943   {
4944     FT_UShort   K, L;
4945     FT_F26Dot6  D;
4946 
4947 
4948     K = (FT_UShort)args[1];
4949     L = (FT_UShort)args[0];
4950 
4951     if ( BOUNDS( L, exc-&gt;zp0.n_points ) ||
4952          BOUNDS( K, exc-&gt;zp1.n_points ) )
4953     {
4954       if ( exc-&gt;pedantic_hinting )
4955         exc-&gt;error = FT_THROW( Invalid_Reference );
4956       D = 0;
4957     }
4958     else
4959     {
</pre>
<hr />
<pre>
4992             vec.y = FT_MulFix( vec1-&gt;y - vec2-&gt;y, exc-&gt;metrics.y_scale );
4993 
4994             D = FAST_DUALPROJ( &amp;vec );
4995           }
4996         }
4997       }
4998     }
4999 
5000 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5001     /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
5002     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp;
5003          exc-&gt;ignore_x_mode          &amp;&amp;
5004          FT_ABS( D ) == 64           )
5005       D += 1;
5006 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
5007 
5008     args[0] = D;
5009   }
5010 
5011 
<span class="line-modified">5012   /**************************************************************************</span>
<span class="line-modified">5013    *</span>
<span class="line-modified">5014    * SDPvTL[a]:    Set Dual PVector to Line</span>
<span class="line-modified">5015    * Opcode range: 0x86-0x87</span>
<span class="line-modified">5016    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">5017    */</span>
5018   static void
5019   Ins_SDPVTL( TT_ExecContext  exc,
5020               FT_Long*        args )
5021   {
5022     FT_Long    A, B, C;
5023     FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */
5024 
5025     FT_Byte  opcode = exc-&gt;opcode;
5026 
5027 
5028     p1 = (FT_UShort)args[1];
5029     p2 = (FT_UShort)args[0];
5030 
5031     if ( BOUNDS( p2, exc-&gt;zp1.n_points ) ||
5032          BOUNDS( p1, exc-&gt;zp2.n_points ) )
5033     {
5034       if ( exc-&gt;pedantic_hinting )
5035         exc-&gt;error = FT_THROW( Invalid_Reference );
5036       return;
5037     }
</pre>
<hr />
<pre>
5075 
5076       if ( A == 0 &amp;&amp; B == 0 )
5077       {
5078         A      = 0x4000;
5079         opcode = 0;
5080       }
5081     }
5082 
5083     if ( ( opcode &amp; 1 ) != 0 )
5084     {
5085       C = B;   /* counter clockwise rotation */
5086       B = A;
5087       A = NEG_LONG( C );
5088     }
5089 
5090     Normalize( A, B, &amp;exc-&gt;GS.projVector );
5091     Compute_Funcs( exc );
5092   }
5093 
5094 
<span class="line-modified">5095   /**************************************************************************</span>
<span class="line-modified">5096    *</span>
<span class="line-modified">5097    * SZP0[]:       Set Zone Pointer 0</span>
<span class="line-modified">5098    * Opcode range: 0x13</span>
<span class="line-modified">5099    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5100    */</span>
5101   static void
5102   Ins_SZP0( TT_ExecContext  exc,
5103             FT_Long*        args )
5104   {
5105     switch ( (FT_Int)args[0] )
5106     {
5107     case 0:
5108       exc-&gt;zp0 = exc-&gt;twilight;
5109       break;
5110 
5111     case 1:
5112       exc-&gt;zp0 = exc-&gt;pts;
5113       break;
5114 
5115     default:
5116       if ( exc-&gt;pedantic_hinting )
5117         exc-&gt;error = FT_THROW( Invalid_Reference );
5118       return;
5119     }
5120 
5121     exc-&gt;GS.gep0 = (FT_UShort)args[0];
5122   }
5123 
5124 
<span class="line-modified">5125   /**************************************************************************</span>
<span class="line-modified">5126    *</span>
<span class="line-modified">5127    * SZP1[]:       Set Zone Pointer 1</span>
<span class="line-modified">5128    * Opcode range: 0x14</span>
<span class="line-modified">5129    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5130    */</span>
5131   static void
5132   Ins_SZP1( TT_ExecContext  exc,
5133             FT_Long*        args )
5134   {
5135     switch ( (FT_Int)args[0] )
5136     {
5137     case 0:
5138       exc-&gt;zp1 = exc-&gt;twilight;
5139       break;
5140 
5141     case 1:
5142       exc-&gt;zp1 = exc-&gt;pts;
5143       break;
5144 
5145     default:
5146       if ( exc-&gt;pedantic_hinting )
5147         exc-&gt;error = FT_THROW( Invalid_Reference );
5148       return;
5149     }
5150 
5151     exc-&gt;GS.gep1 = (FT_UShort)args[0];
5152   }
5153 
5154 
<span class="line-modified">5155   /**************************************************************************</span>
<span class="line-modified">5156    *</span>
<span class="line-modified">5157    * SZP2[]:       Set Zone Pointer 2</span>
<span class="line-modified">5158    * Opcode range: 0x15</span>
<span class="line-modified">5159    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5160    */</span>
5161   static void
5162   Ins_SZP2( TT_ExecContext  exc,
5163             FT_Long*        args )
5164   {
5165     switch ( (FT_Int)args[0] )
5166     {
5167     case 0:
5168       exc-&gt;zp2 = exc-&gt;twilight;
5169       break;
5170 
5171     case 1:
5172       exc-&gt;zp2 = exc-&gt;pts;
5173       break;
5174 
5175     default:
5176       if ( exc-&gt;pedantic_hinting )
5177         exc-&gt;error = FT_THROW( Invalid_Reference );
5178       return;
5179     }
5180 
5181     exc-&gt;GS.gep2 = (FT_UShort)args[0];
5182   }
5183 
5184 
<span class="line-modified">5185   /**************************************************************************</span>
<span class="line-modified">5186    *</span>
<span class="line-modified">5187    * SZPS[]:       Set Zone PointerS</span>
<span class="line-modified">5188    * Opcode range: 0x16</span>
<span class="line-modified">5189    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5190    */</span>
5191   static void
5192   Ins_SZPS( TT_ExecContext  exc,
5193             FT_Long*        args )
5194   {
5195     switch ( (FT_Int)args[0] )
5196     {
5197     case 0:
5198       exc-&gt;zp0 = exc-&gt;twilight;
5199       break;
5200 
5201     case 1:
5202       exc-&gt;zp0 = exc-&gt;pts;
5203       break;
5204 
5205     default:
5206       if ( exc-&gt;pedantic_hinting )
5207         exc-&gt;error = FT_THROW( Invalid_Reference );
5208       return;
5209     }
5210 
5211     exc-&gt;zp1 = exc-&gt;zp0;
5212     exc-&gt;zp2 = exc-&gt;zp0;
5213 
5214     exc-&gt;GS.gep0 = (FT_UShort)args[0];
5215     exc-&gt;GS.gep1 = (FT_UShort)args[0];
5216     exc-&gt;GS.gep2 = (FT_UShort)args[0];
5217   }
5218 
5219 
<span class="line-modified">5220   /**************************************************************************</span>
<span class="line-modified">5221    *</span>
<span class="line-modified">5222    * INSTCTRL[]:   INSTruction ConTRoL</span>
<span class="line-modified">5223    * Opcode range: 0x8E</span>
<span class="line-modified">5224    * Stack:        int32 int32 --&gt;</span>
<span class="line-modified">5225    */</span>
5226   static void
5227   Ins_INSTCTRL( TT_ExecContext  exc,
5228                 FT_Long*        args )
5229   {
5230     FT_ULong  K, L, Kf;
5231 
5232 
5233     K = (FT_ULong)args[1];
5234     L = (FT_ULong)args[0];
5235 
5236     /* selector values cannot be `OR&#39;ed;                 */
5237     /* they are indices starting with index 1, not flags */
5238     if ( K &lt; 1 || K &gt; 3 )
5239     {
5240       if ( exc-&gt;pedantic_hinting )
5241         exc-&gt;error = FT_THROW( Invalid_Reference );
5242       return;
5243     }
5244 
5245     /* convert index to flag value */
</pre>
<hr />
<pre>
5262     if ( K == 3 )
5263     {
5264 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5265       /* INSTCTRL modifying flag 3 also has an effect */
5266       /* outside of the CVT program                   */
5267       if ( SUBPIXEL_HINTING_INFINALITY )
5268         exc-&gt;ignore_x_mode = FT_BOOL( L == 4 );
5269 #endif
5270 
5271 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5272       /* Native ClearType fonts sign a waiver that turns off all backward  */
5273       /* compatibility hacks and lets them program points to the grid like */
5274       /* it&#39;s 1996.  They might sign a waiver for just one glyph, though.  */
5275       if ( SUBPIXEL_HINTING_MINIMAL )
5276         exc-&gt;backward_compatibility = !FT_BOOL( L == 4 );
5277 #endif
5278     }
5279   }
5280 
5281 
<span class="line-modified">5282   /**************************************************************************</span>
<span class="line-modified">5283    *</span>
<span class="line-modified">5284    * SCANCTRL[]:   SCAN ConTRoL</span>
<span class="line-modified">5285    * Opcode range: 0x85</span>
<span class="line-modified">5286    * Stack:        uint32? --&gt;</span>
<span class="line-modified">5287    */</span>
5288   static void
5289   Ins_SCANCTRL( TT_ExecContext  exc,
5290                 FT_Long*        args )
5291   {
5292     FT_Int  A;
5293 
5294 
5295     /* Get Threshold */
5296     A = (FT_Int)( args[0] &amp; 0xFF );
5297 
5298     if ( A == 0xFF )
5299     {
5300       exc-&gt;GS.scan_control = TRUE;
5301       return;
5302     }
5303     else if ( A == 0 )
5304     {
5305       exc-&gt;GS.scan_control = FALSE;
5306       return;
5307     }
</pre>
<hr />
<pre>
5309     if ( ( args[0] &amp; 0x100 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &lt;= A )
5310       exc-&gt;GS.scan_control = TRUE;
5311 
5312     if ( ( args[0] &amp; 0x200 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
5313       exc-&gt;GS.scan_control = TRUE;
5314 
5315     if ( ( args[0] &amp; 0x400 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
5316       exc-&gt;GS.scan_control = TRUE;
5317 
5318     if ( ( args[0] &amp; 0x800 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &gt; A )
5319       exc-&gt;GS.scan_control = FALSE;
5320 
5321     if ( ( args[0] &amp; 0x1000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
5322       exc-&gt;GS.scan_control = FALSE;
5323 
5324     if ( ( args[0] &amp; 0x2000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
5325       exc-&gt;GS.scan_control = FALSE;
5326   }
5327 
5328 
<span class="line-modified">5329   /**************************************************************************</span>
<span class="line-modified">5330    *</span>
<span class="line-modified">5331    * SCANTYPE[]:   SCAN TYPE</span>
<span class="line-modified">5332    * Opcode range: 0x8D</span>
<span class="line-modified">5333    * Stack:        uint16 --&gt;</span>
<span class="line-modified">5334    */</span>
5335   static void
5336   Ins_SCANTYPE( TT_ExecContext  exc,
5337                 FT_Long*        args )
5338   {
5339     if ( args[0] &gt;= 0 )
5340       exc-&gt;GS.scan_type = (FT_Int)args[0] &amp; 0xFFFF;
5341   }
5342 
5343 
<span class="line-modified">5344   /**************************************************************************</span>
<span class="line-modified">5345    *</span>
<span class="line-modified">5346    * MANAGING OUTLINES</span>
<span class="line-modified">5347    *</span>
<span class="line-modified">5348    */</span>
5349 
5350 
<span class="line-modified">5351   /**************************************************************************</span>
<span class="line-modified">5352    *</span>
<span class="line-modified">5353    * FLIPPT[]:     FLIP PoinT</span>
<span class="line-modified">5354    * Opcode range: 0x80</span>
<span class="line-modified">5355    * Stack:        uint32... --&gt;</span>
<span class="line-modified">5356    */</span>
5357   static void
5358   Ins_FLIPPT( TT_ExecContext  exc )
5359   {
5360     FT_UShort  point;
5361 
5362 
5363 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5364     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5365     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5366          exc-&gt;backward_compatibility &amp;&amp;
5367          exc-&gt;iupx_called            &amp;&amp;
5368          exc-&gt;iupy_called            )
5369       goto Fail;
5370 #endif
5371 
5372     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
5373     {
5374       if ( exc-&gt;pedantic_hinting )
5375         exc-&gt;error = FT_THROW( Too_Few_Arguments );
5376       goto Fail;
</pre>
<hr />
<pre>
5385       if ( BOUNDS( point, exc-&gt;pts.n_points ) )
5386       {
5387         if ( exc-&gt;pedantic_hinting )
5388         {
5389           exc-&gt;error = FT_THROW( Invalid_Reference );
5390           return;
5391         }
5392       }
5393       else
5394         exc-&gt;pts.tags[point] ^= FT_CURVE_TAG_ON;
5395 
5396       exc-&gt;GS.loop--;
5397     }
5398 
5399   Fail:
5400     exc-&gt;GS.loop = 1;
5401     exc-&gt;new_top = exc-&gt;args;
5402   }
5403 
5404 
<span class="line-modified">5405   /**************************************************************************</span>
<span class="line-modified">5406    *</span>
<span class="line-modified">5407    * FLIPRGON[]:   FLIP RanGe ON</span>
<span class="line-modified">5408    * Opcode range: 0x81</span>
<span class="line-modified">5409    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">5410    */</span>
5411   static void
5412   Ins_FLIPRGON( TT_ExecContext  exc,
5413                 FT_Long*        args )
5414   {
5415     FT_UShort  I, K, L;
5416 
5417 
5418 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5419     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5420     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5421          exc-&gt;backward_compatibility &amp;&amp;
5422          exc-&gt;iupx_called            &amp;&amp;
5423          exc-&gt;iupy_called            )
5424       return;
5425 #endif
5426 
5427     K = (FT_UShort)args[1];
5428     L = (FT_UShort)args[0];
5429 
5430     if ( BOUNDS( K, exc-&gt;pts.n_points ) ||
5431          BOUNDS( L, exc-&gt;pts.n_points ) )
5432     {
5433       if ( exc-&gt;pedantic_hinting )
5434         exc-&gt;error = FT_THROW( Invalid_Reference );
5435       return;
5436     }
5437 
5438     for ( I = L; I &lt;= K; I++ )
5439       exc-&gt;pts.tags[I] |= FT_CURVE_TAG_ON;
5440   }
5441 
5442 
<span class="line-modified">5443   /**************************************************************************</span>
<span class="line-modified">5444    *</span>
<span class="line-modified">5445    * FLIPRGOFF:    FLIP RanGe OFF</span>
<span class="line-modified">5446    * Opcode range: 0x82</span>
<span class="line-modified">5447    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">5448    */</span>
5449   static void
5450   Ins_FLIPRGOFF( TT_ExecContext  exc,
5451                  FT_Long*        args )
5452   {
5453     FT_UShort  I, K, L;
5454 
5455 
5456 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5457     /* See `ttinterp.h&#39; for details on backward compatibility mode. */
5458     if ( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5459          exc-&gt;backward_compatibility &amp;&amp;
5460          exc-&gt;iupx_called            &amp;&amp;
5461          exc-&gt;iupy_called            )
5462       return;
5463 #endif
5464 
5465     K = (FT_UShort)args[1];
5466     L = (FT_UShort)args[0];
5467 
5468     if ( BOUNDS( K, exc-&gt;pts.n_points ) ||
</pre>
<hr />
<pre>
5540       if ( touch )
5541         exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
5542     }
5543 
5544     if ( exc-&gt;GS.freeVector.y != 0 )
5545     {
5546 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5547       if ( !( SUBPIXEL_HINTING_MINIMAL    &amp;&amp;
5548               exc-&gt;backward_compatibility &amp;&amp;
5549               exc-&gt;iupx_called            &amp;&amp;
5550               exc-&gt;iupy_called            ) )
5551 #endif
5552         exc-&gt;zp2.cur[point].y = ADD_LONG( exc-&gt;zp2.cur[point].y, dy );
5553 
5554       if ( touch )
5555         exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
5556     }
5557   }
5558 
5559 
<span class="line-modified">5560   /**************************************************************************</span>
<span class="line-modified">5561    *</span>
<span class="line-modified">5562    * SHP[a]:       SHift Point by the last point</span>
<span class="line-modified">5563    * Opcode range: 0x32-0x33</span>
<span class="line-modified">5564    * Stack:        uint32... --&gt;</span>
<span class="line-modified">5565    */</span>
5566   static void
5567   Ins_SHP( TT_ExecContext  exc )
5568   {
5569     TT_GlyphZoneRec  zp;
5570     FT_UShort        refp;
5571 
5572     FT_F26Dot6       dx, dy;
5573     FT_UShort        point;
5574 
5575 
5576     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
5577     {
5578       if ( exc-&gt;pedantic_hinting )
5579         exc-&gt;error = FT_THROW( Invalid_Reference );
5580       goto Fail;
5581     }
5582 
5583     if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )
5584       return;
5585 
</pre>
<hr />
<pre>
5597         }
5598       }
5599       else
5600 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5601       /* doesn&#39;t follow Cleartype spec but produces better result */
5602       if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp; exc-&gt;ignore_x_mode )
5603         Move_Zp2_Point( exc, point, 0, dy, TRUE );
5604       else
5605 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
5606         Move_Zp2_Point( exc, point, dx, dy, TRUE );
5607 
5608       exc-&gt;GS.loop--;
5609     }
5610 
5611   Fail:
5612     exc-&gt;GS.loop = 1;
5613     exc-&gt;new_top = exc-&gt;args;
5614   }
5615 
5616 
<span class="line-modified">5617   /**************************************************************************</span>
<span class="line-modified">5618    *</span>
<span class="line-modified">5619    * SHC[a]:       SHift Contour</span>
<span class="line-modified">5620    * Opcode range: 0x34-35</span>
<span class="line-modified">5621    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5622    *</span>
<span class="line-modified">5623    * UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)</span>
<span class="line-modified">5624    *               contour in the twilight zone, namely contour number</span>
<span class="line-modified">5625    *               zero which includes all points of it.</span>
<span class="line-modified">5626    */</span>
5627   static void
5628   Ins_SHC( TT_ExecContext  exc,
5629            FT_Long*        args )
5630   {
5631     TT_GlyphZoneRec  zp;
5632     FT_UShort        refp;
5633     FT_F26Dot6       dx, dy;
5634 
5635     FT_Short         contour, bounds;
5636     FT_UShort        start, limit, i;
5637 
5638 
5639     contour = (FT_Short)args[0];
5640     bounds  = ( exc-&gt;GS.gep2 == 0 ) ? 1 : exc-&gt;zp2.n_contours;
5641 
5642     if ( BOUNDS( contour, bounds ) )
5643     {
5644       if ( exc-&gt;pedantic_hinting )
5645         exc-&gt;error = FT_THROW( Invalid_Reference );
5646       return;
</pre>
<hr />
<pre>
5653       start = 0;
5654     else
5655       start = (FT_UShort)( exc-&gt;zp2.contours[contour - 1] + 1 -
5656                            exc-&gt;zp2.first_point );
5657 
5658     /* we use the number of points if in the twilight zone */
5659     if ( exc-&gt;GS.gep2 == 0 )
5660       limit = exc-&gt;zp2.n_points;
5661     else
5662       limit = (FT_UShort)( exc-&gt;zp2.contours[contour] -
5663                            exc-&gt;zp2.first_point + 1 );
5664 
5665     for ( i = start; i &lt; limit; i++ )
5666     {
5667       if ( zp.cur != exc-&gt;zp2.cur || refp != i )
5668         Move_Zp2_Point( exc, i, dx, dy, TRUE );
5669     }
5670   }
5671 
5672 
<span class="line-modified">5673   /**************************************************************************</span>
<span class="line-modified">5674    *</span>
<span class="line-modified">5675    * SHZ[a]:       SHift Zone</span>
<span class="line-modified">5676    * Opcode range: 0x36-37</span>
<span class="line-modified">5677    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5678    */</span>
5679   static void
5680   Ins_SHZ( TT_ExecContext  exc,
5681            FT_Long*        args )
5682   {
5683     TT_GlyphZoneRec  zp;
5684     FT_UShort        refp;
5685     FT_F26Dot6       dx,
5686                      dy;
5687 
5688     FT_UShort        limit, i;
5689 
5690 
5691     if ( BOUNDS( args[0], 2 ) )
5692     {
5693       if ( exc-&gt;pedantic_hinting )
5694         exc-&gt;error = FT_THROW( Invalid_Reference );
5695       return;
5696     }
5697 
5698     if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )
</pre>
<hr />
<pre>
5701     /* XXX: UNDOCUMENTED! SHZ doesn&#39;t move the phantom points.     */
5702     /*      Twilight zone has no real contours, so use `n_points&#39;. */
5703     /*      Normal zone&#39;s `n_points&#39; includes phantoms, so must    */
5704     /*      use end of last contour.                               */
5705     if ( exc-&gt;GS.gep2 == 0 )
5706       limit = (FT_UShort)exc-&gt;zp2.n_points;
5707     else if ( exc-&gt;GS.gep2 == 1 &amp;&amp; exc-&gt;zp2.n_contours &gt; 0 )
5708       limit = (FT_UShort)( exc-&gt;zp2.contours[exc-&gt;zp2.n_contours - 1] + 1 );
5709     else
5710       limit = 0;
5711 
5712     /* XXX: UNDOCUMENTED! SHZ doesn&#39;t touch the points */
5713     for ( i = 0; i &lt; limit; i++ )
5714     {
5715       if ( zp.cur != exc-&gt;zp2.cur || refp != i )
5716         Move_Zp2_Point( exc, i, dx, dy, FALSE );
5717     }
5718   }
5719 
5720 
<span class="line-modified">5721   /**************************************************************************</span>
<span class="line-modified">5722    *</span>
<span class="line-modified">5723    * SHPIX[]:      SHift points by a PIXel amount</span>
<span class="line-modified">5724    * Opcode range: 0x38</span>
<span class="line-modified">5725    * Stack:        f26.6 uint32... --&gt;</span>
<span class="line-modified">5726    */</span>
5727   static void
5728   Ins_SHPIX( TT_ExecContext  exc,
5729              FT_Long*        args )
5730   {
5731     FT_F26Dot6  dx, dy;
5732     FT_UShort   point;
5733 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5734     FT_Int      B1, B2;
5735 #endif
5736 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
5737     FT_Bool     in_twilight = FT_BOOL( exc-&gt;GS.gep0 == 0 ||
5738                                        exc-&gt;GS.gep1 == 0 ||
5739                                        exc-&gt;GS.gep2 == 0 );
5740 #endif
5741 
5742 
5743 
5744     if ( exc-&gt;top &lt; exc-&gt;GS.loop + 1 )
5745     {
5746       if ( exc-&gt;pedantic_hinting )
</pre>
<hr />
<pre>
5861                ( ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 ) ||
5862                  ( exc-&gt;zp2.tags[point] &amp; FT_CURVE_TAG_TOUCH_Y )    ) ) )
5863           Move_Zp2_Point( exc, point, 0, dy, TRUE );
5864       }
5865       else
5866 #endif
5867         Move_Zp2_Point( exc, point, dx, dy, TRUE );
5868 
5869 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5870     Skip:
5871 #endif
5872       exc-&gt;GS.loop--;
5873     }
5874 
5875   Fail:
5876     exc-&gt;GS.loop = 1;
5877     exc-&gt;new_top = exc-&gt;args;
5878   }
5879 
5880 
<span class="line-modified">5881   /**************************************************************************</span>
<span class="line-modified">5882    *</span>
<span class="line-modified">5883    * MSIRP[a]:     Move Stack Indirect Relative Position</span>
<span class="line-modified">5884    * Opcode range: 0x3A-0x3B</span>
<span class="line-modified">5885    * Stack:        f26.6 uint32 --&gt;</span>
<span class="line-modified">5886    */</span>
5887   static void
5888   Ins_MSIRP( TT_ExecContext  exc,
5889              FT_Long*        args )
5890   {
5891     FT_UShort   point = 0;
5892     FT_F26Dot6  distance;
5893 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
5894     FT_F26Dot6  control_value_cutin = 0;
5895     FT_F26Dot6  delta;
5896 
5897 
5898     if ( SUBPIXEL_HINTING_INFINALITY )
5899     {
5900       control_value_cutin = exc-&gt;GS.control_value_cutin;
5901 
5902       if ( exc-&gt;ignore_x_mode                                 &amp;&amp;
5903            exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
5904            !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
5905         control_value_cutin = 0;
5906     }
</pre>
<hr />
<pre>
5936     if ( SUBPIXEL_HINTING_INFINALITY  &amp;&amp;
5937          exc-&gt;ignore_x_mode           &amp;&amp;
5938          exc-&gt;GS.freeVector.x != 0    &amp;&amp;
5939          delta &gt;= control_value_cutin )
5940       distance = args[1];
5941 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
5942 
5943     exc-&gt;func_move( exc,
5944                     &amp;exc-&gt;zp1,
5945                     point,
5946                     SUB_LONG( args[1], distance ) );
5947 
5948     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
5949     exc-&gt;GS.rp2 = point;
5950 
5951     if ( ( exc-&gt;opcode &amp; 1 ) != 0 )
5952       exc-&gt;GS.rp0 = point;
5953   }
5954 
5955 
<span class="line-modified">5956   /**************************************************************************</span>
<span class="line-modified">5957    *</span>
<span class="line-modified">5958    * MDAP[a]:      Move Direct Absolute Point</span>
<span class="line-modified">5959    * Opcode range: 0x2E-0x2F</span>
<span class="line-modified">5960    * Stack:        uint32 --&gt;</span>
<span class="line-modified">5961    */</span>
5962   static void
5963   Ins_MDAP( TT_ExecContext  exc,
5964             FT_Long*        args )
5965   {
5966     FT_UShort   point;
5967     FT_F26Dot6  cur_dist;
5968     FT_F26Dot6  distance;
5969 
5970 
5971     point = (FT_UShort)args[0];
5972 
5973     if ( BOUNDS( point, exc-&gt;zp0.n_points ) )
5974     {
5975       if ( exc-&gt;pedantic_hinting )
5976         exc-&gt;error = FT_THROW( Invalid_Reference );
5977       return;
5978     }
5979 
5980     if ( ( exc-&gt;opcode &amp; 1 ) != 0 )
5981     {
</pre>
<hr />
<pre>
5990                                  exc-&gt;tt_metrics.compensations[0] ),
5991                      cur_dist );
5992       else
5993 #endif
5994         distance = SUB_LONG(
5995                      exc-&gt;func_round( exc,
5996                                       cur_dist,
5997                                       exc-&gt;tt_metrics.compensations[0] ),
5998                      cur_dist );
5999     }
6000     else
6001       distance = 0;
6002 
6003     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, distance );
6004 
6005     exc-&gt;GS.rp0 = point;
6006     exc-&gt;GS.rp1 = point;
6007   }
6008 
6009 
<span class="line-modified">6010   /**************************************************************************</span>
<span class="line-modified">6011    *</span>
<span class="line-modified">6012    * MIAP[a]:      Move Indirect Absolute Point</span>
<span class="line-modified">6013    * Opcode range: 0x3E-0x3F</span>
<span class="line-modified">6014    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">6015    */</span>
6016   static void
6017   Ins_MIAP( TT_ExecContext  exc,
6018             FT_Long*        args )
6019   {
6020     FT_ULong    cvtEntry;
6021     FT_UShort   point;
6022     FT_F26Dot6  distance;
6023     FT_F26Dot6  org_dist;
6024     FT_F26Dot6  control_value_cutin;
6025 
6026 
6027     control_value_cutin = exc-&gt;GS.control_value_cutin;
6028     cvtEntry            = (FT_ULong)args[1];
6029     point               = (FT_UShort)args[0];
6030 
6031 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6032     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
6033          exc-&gt;ignore_x_mode                                 &amp;&amp;
6034          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
6035          exc-&gt;GS.freeVector.y == 0                          &amp;&amp;
</pre>
<hr />
<pre>
6110            exc-&gt;ignore_x_mode          &amp;&amp;
6111            exc-&gt;GS.freeVector.x != 0   )
6112         distance = Round_None( exc,
6113                                distance,
6114                                exc-&gt;tt_metrics.compensations[0] );
6115       else
6116 #endif
6117         distance = exc-&gt;func_round( exc,
6118                                     distance,
6119                                     exc-&gt;tt_metrics.compensations[0] );
6120     }
6121 
6122     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, SUB_LONG( distance, org_dist ) );
6123 
6124   Fail:
6125     exc-&gt;GS.rp0 = point;
6126     exc-&gt;GS.rp1 = point;
6127   }
6128 
6129 
<span class="line-modified">6130   /**************************************************************************</span>
<span class="line-modified">6131    *</span>
<span class="line-modified">6132    * MDRP[abcde]:  Move Direct Relative Point</span>
<span class="line-modified">6133    * Opcode range: 0xC0-0xDF</span>
<span class="line-modified">6134    * Stack:        uint32 --&gt;</span>
<span class="line-modified">6135    */</span>
6136   static void
6137   Ins_MDRP( TT_ExecContext  exc,
6138             FT_Long*        args )
6139   {
6140     FT_UShort   point = 0;
6141     FT_F26Dot6  org_dist, distance, minimum_distance;
6142 
6143 
6144     minimum_distance = exc-&gt;GS.minimum_distance;
6145 
6146 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6147     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
6148          exc-&gt;ignore_x_mode                                 &amp;&amp;
6149          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
6150          !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
6151       minimum_distance = 0;
6152 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6153 
6154     point = (FT_UShort)args[0];
6155 
</pre>
<hr />
<pre>
6254         if ( distance &gt; NEG_LONG( minimum_distance ) )
6255           distance = NEG_LONG( minimum_distance );
6256       }
6257     }
6258 
6259     /* now move the point */
6260 
6261     org_dist = PROJECT( exc-&gt;zp1.cur + point, exc-&gt;zp0.cur + exc-&gt;GS.rp0 );
6262 
6263     exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, SUB_LONG( distance, org_dist ) );
6264 
6265   Fail:
6266     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
6267     exc-&gt;GS.rp2 = point;
6268 
6269     if ( ( exc-&gt;opcode &amp; 16 ) != 0 )
6270       exc-&gt;GS.rp0 = point;
6271   }
6272 
6273 
<span class="line-modified">6274   /**************************************************************************</span>
<span class="line-modified">6275    *</span>
<span class="line-modified">6276    * MIRP[abcde]:  Move Indirect Relative Point</span>
<span class="line-modified">6277    * Opcode range: 0xE0-0xFF</span>
<span class="line-modified">6278    * Stack:        int32? uint32 --&gt;</span>
<span class="line-modified">6279    */</span>
6280   static void
6281   Ins_MIRP( TT_ExecContext  exc,
6282             FT_Long*        args )
6283   {
6284     FT_UShort   point;
6285     FT_ULong    cvtEntry;
6286 
6287     FT_F26Dot6  cvt_dist,
6288                 distance,
6289                 cur_dist,
6290                 org_dist,
6291                 control_value_cutin,
6292                 minimum_distance;
6293 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6294     FT_Int      B1           = 0; /* pacify compiler */
6295     FT_Int      B2           = 0;
6296     FT_Bool     reverse_move = FALSE;
6297 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6298 
<span class="line-added">6299     FT_F26Dot6  delta;</span>
<span class="line-added">6300 </span>
6301 
6302     minimum_distance    = exc-&gt;GS.minimum_distance;
6303     control_value_cutin = exc-&gt;GS.control_value_cutin;
6304     point               = (FT_UShort)args[0];
6305     cvtEntry            = (FT_ULong)( ADD_LONG( args[1], 1 ) );
6306 
6307 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6308     if ( SUBPIXEL_HINTING_INFINALITY                        &amp;&amp;
6309          exc-&gt;ignore_x_mode                                 &amp;&amp;
6310          exc-&gt;GS.freeVector.x != 0                          &amp;&amp;
6311          !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )
6312       control_value_cutin = minimum_distance = 0;
6313 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6314 
6315     /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
6316 
6317     if ( BOUNDS( point,       exc-&gt;zp1.n_points ) ||
6318          BOUNDSL( cvtEntry,   exc-&gt;cvtSize + 1 )  ||
6319          BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )
6320     {
6321       if ( exc-&gt;pedantic_hinting )
6322         exc-&gt;error = FT_THROW( Invalid_Reference );
6323       goto Fail;
6324     }
6325 
6326     if ( !cvtEntry )
6327       cvt_dist = 0;
6328     else
6329       cvt_dist = exc-&gt;func_read_cvt( exc, cvtEntry - 1 );
6330 
6331     /* single width test */
6332 
<span class="line-modified">6333     delta = SUB_LONG( cvt_dist, exc-&gt;GS.single_width_value );</span>
<span class="line-modified">6334     if ( delta &lt; 0 )</span>
<span class="line-added">6335       delta = NEG_LONG( delta );</span>
<span class="line-added">6336 </span>
<span class="line-added">6337     if ( delta &lt; exc-&gt;GS.single_width_cutin )</span>
6338     {
6339       if ( cvt_dist &gt;= 0 )
6340         cvt_dist =  exc-&gt;GS.single_width_value;
6341       else
6342         cvt_dist = -exc-&gt;GS.single_width_value;
6343     }
6344 
6345     /* UNDOCUMENTED!  The MS rasterizer does that with */
6346     /* twilight points (confirmed by Greg Hitchcock)   */
6347     if ( exc-&gt;GS.gep1 == 0 )
6348     {
6349       exc-&gt;zp1.org[point].x = exc-&gt;zp0.org[exc-&gt;GS.rp0].x +
6350                               TT_MulFix14( cvt_dist,
6351                                            exc-&gt;GS.freeVector.x );
6352       exc-&gt;zp1.org[point].y = exc-&gt;zp0.org[exc-&gt;GS.rp0].y +
6353                               TT_MulFix14( cvt_dist,
6354                                            exc-&gt;GS.freeVector.y );
6355       exc-&gt;zp1.cur[point]   = exc-&gt;zp1.org[point];
6356     }
6357 
6358     org_dist = DUALPROJ( &amp;exc-&gt;zp1.org[point], &amp;exc-&gt;zp0.org[exc-&gt;GS.rp0] );
6359     cur_dist = PROJECT ( &amp;exc-&gt;zp1.cur[point], &amp;exc-&gt;zp0.cur[exc-&gt;GS.rp0] );
6360 
6361     /* auto-flip test */
6362 
6363     if ( exc-&gt;GS.auto_flip )
6364     {
6365       if ( ( org_dist ^ cvt_dist ) &lt; 0 )
<span class="line-modified">6366         cvt_dist = NEG_LONG( cvt_dist );</span>
6367     }
6368 
6369 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6370     if ( SUBPIXEL_HINTING_INFINALITY                               &amp;&amp;
6371          exc-&gt;ignore_x_mode                                        &amp;&amp;
6372          exc-&gt;GS.freeVector.y != 0                                 &amp;&amp;
6373          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
6374     {
6375       if ( cur_dist &lt; -64 )
6376         cvt_dist -= 16;
6377       else if ( cur_dist &gt; 64 &amp;&amp; cur_dist &lt; 84 )
6378         cvt_dist += 32;
6379     }
6380 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6381 
6382     /* control value cut-in and round */
6383 
6384     if ( ( exc-&gt;opcode &amp; 4 ) != 0 )
6385     {
6386       /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
6387       /*      refer to the same zone.                                  */
6388 
6389       if ( exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )
6390       {



6391         /* XXX: According to Greg Hitchcock, the following wording is */
6392         /*      the right one:                                        */
6393         /*                                                            */
6394         /*        When the absolute difference between the value in   */
6395         /*        the table [CVT] and the measurement directly from   */
6396         /*        the outline is _greater_ than the cut_in value, the */
6397         /*        outline measurement is used.                        */
6398         /*                                                            */
6399         /*      This is from `instgly.doc&#39;.  The description in       */
6400         /*      `ttinst2.doc&#39;, version 1.66, is thus incorrect since  */
6401         /*      it implies `&gt;=&#39; instead of `&gt;&#39;.                       */
6402 
6403         delta = SUB_LONG( cvt_dist, org_dist );
6404         if ( delta &lt; 0 )
6405           delta = NEG_LONG( delta );
6406 
6407         if ( delta &gt; control_value_cutin )
6408           cvt_dist = org_dist;
6409       }
6410 
6411       distance = exc-&gt;func_round(
6412                    exc,
6413                    cvt_dist,
6414                    exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );
6415     }
6416     else
6417     {
6418 
6419 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6420       /* do cvt cut-in always in MIRP for sph */
6421       if ( SUBPIXEL_HINTING_INFINALITY  &amp;&amp;
6422            exc-&gt;ignore_x_mode           &amp;&amp;
6423            exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )
6424       {



6425         delta = SUB_LONG( cvt_dist, org_dist );
6426         if ( delta &lt; 0 )
6427           delta = NEG_LONG( delta );
6428 
6429         if ( delta &gt; control_value_cutin )
6430           cvt_dist = org_dist;
6431       }
6432 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6433 
6434       distance = Round_None(
6435                    exc,
6436                    cvt_dist,
6437                    exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );
6438     }
6439 
6440     /* minimum distance test */
6441 
6442     if ( ( exc-&gt;opcode &amp; 8 ) != 0 )
6443     {
6444       if ( org_dist &gt;= 0 )
</pre>
<hr />
<pre>
6501 
6502       if ( reverse_move )
6503         exc-&gt;func_move( exc,
6504                         &amp;exc-&gt;zp1,
6505                         point,
6506                         SUB_LONG( cur_dist, distance ) );
6507     }
6508 
6509 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6510 
6511   Fail:
6512     exc-&gt;GS.rp1 = exc-&gt;GS.rp0;
6513 
6514     if ( ( exc-&gt;opcode &amp; 16 ) != 0 )
6515       exc-&gt;GS.rp0 = point;
6516 
6517     exc-&gt;GS.rp2 = point;
6518   }
6519 
6520 
<span class="line-modified">6521   /**************************************************************************</span>
<span class="line-modified">6522    *</span>
<span class="line-modified">6523    * ALIGNRP[]:    ALIGN Relative Point</span>
<span class="line-modified">6524    * Opcode range: 0x3C</span>
<span class="line-modified">6525    * Stack:        uint32 uint32... --&gt;</span>
<span class="line-modified">6526    */</span>
6527   static void
6528   Ins_ALIGNRP( TT_ExecContext  exc )
6529   {
6530     FT_UShort   point;
6531     FT_F26Dot6  distance;
6532 
6533 
6534 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
6535     if ( SUBPIXEL_HINTING_INFINALITY                               &amp;&amp;
6536          exc-&gt;ignore_x_mode                                        &amp;&amp;
6537          exc-&gt;iup_called                                           &amp;&amp;
6538          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
6539     {
6540       exc-&gt;error = FT_THROW( Invalid_Reference );
6541       goto Fail;
6542     }
6543 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
6544 
6545     if ( exc-&gt;top &lt; exc-&gt;GS.loop                  ||
6546          BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )
</pre>
<hr />
<pre>
6564           return;
6565         }
6566       }
6567       else
6568       {
6569         distance = PROJECT( exc-&gt;zp1.cur + point,
6570                             exc-&gt;zp0.cur + exc-&gt;GS.rp0 );
6571 
6572         exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, NEG_LONG( distance ) );
6573       }
6574 
6575       exc-&gt;GS.loop--;
6576     }
6577 
6578   Fail:
6579     exc-&gt;GS.loop = 1;
6580     exc-&gt;new_top = exc-&gt;args;
6581   }
6582 
6583 
<span class="line-modified">6584   /**************************************************************************</span>
<span class="line-modified">6585    *</span>
<span class="line-modified">6586    * ISECT[]:      moves point to InterSECTion</span>
<span class="line-modified">6587    * Opcode range: 0x0F</span>
<span class="line-modified">6588    * Stack:        5 * uint32 --&gt;</span>
<span class="line-modified">6589    */</span>
6590   static void
6591   Ins_ISECT( TT_ExecContext  exc,
6592              FT_Long*        args )
6593   {
6594     FT_UShort   point,
6595                 a0, a1,
6596                 b0, b1;
6597 
6598     FT_F26Dot6  discriminant, dotproduct;
6599 
6600     FT_F26Dot6  dx,  dy,
6601                 dax, day,
6602                 dbx, dby;
6603 
6604     FT_F26Dot6  val;
6605 
6606     FT_Vector   R;
6607 
6608 
6609     point = (FT_UShort)args[0];
</pre>
<hr />
<pre>
6660       exc-&gt;zp2.cur[point].x = ADD_LONG( exc-&gt;zp1.cur[a0].x, R.x );
6661       exc-&gt;zp2.cur[point].y = ADD_LONG( exc-&gt;zp1.cur[a0].y, R.y );
6662     }
6663     else
6664     {
6665       /* else, take the middle of the middles of A and B */
6666 
6667       /* XXX: Block in backward_compatibility and/or post-IUP? */
6668       exc-&gt;zp2.cur[point].x =
6669         ADD_LONG( ADD_LONG( exc-&gt;zp1.cur[a0].x, exc-&gt;zp1.cur[a1].x ),
6670                   ADD_LONG( exc-&gt;zp0.cur[b0].x, exc-&gt;zp0.cur[b1].x ) ) / 4;
6671       exc-&gt;zp2.cur[point].y =
6672         ADD_LONG( ADD_LONG( exc-&gt;zp1.cur[a0].y, exc-&gt;zp1.cur[a1].y ),
6673                   ADD_LONG( exc-&gt;zp0.cur[b0].y, exc-&gt;zp0.cur[b1].y ) ) / 4;
6674     }
6675 
6676     exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
6677   }
6678 
6679 
<span class="line-modified">6680   /**************************************************************************</span>
<span class="line-modified">6681    *</span>
<span class="line-modified">6682    * ALIGNPTS[]:   ALIGN PoinTS</span>
<span class="line-modified">6683    * Opcode range: 0x27</span>
<span class="line-modified">6684    * Stack:        uint32 uint32 --&gt;</span>
<span class="line-modified">6685    */</span>
6686   static void
6687   Ins_ALIGNPTS( TT_ExecContext  exc,
6688                 FT_Long*        args )
6689   {
6690     FT_UShort   p1, p2;
6691     FT_F26Dot6  distance;
6692 
6693 
6694     p1 = (FT_UShort)args[0];
6695     p2 = (FT_UShort)args[1];
6696 
6697     if ( BOUNDS( p1, exc-&gt;zp1.n_points ) ||
6698          BOUNDS( p2, exc-&gt;zp0.n_points ) )
6699     {
6700       if ( exc-&gt;pedantic_hinting )
6701         exc-&gt;error = FT_THROW( Invalid_Reference );
6702       return;
6703     }
6704 
6705     distance = PROJECT( exc-&gt;zp0.cur + p2, exc-&gt;zp1.cur + p1 ) / 2;
6706 
6707     exc-&gt;func_move( exc, &amp;exc-&gt;zp1, p1, distance );
6708     exc-&gt;func_move( exc, &amp;exc-&gt;zp0, p2, NEG_LONG( distance ) );
6709   }
6710 
6711 
<span class="line-modified">6712   /**************************************************************************</span>
<span class="line-modified">6713    *</span>
<span class="line-modified">6714    * IP[]:         Interpolate Point</span>
<span class="line-modified">6715    * Opcode range: 0x39</span>
<span class="line-modified">6716    * Stack:        uint32... --&gt;</span>
<span class="line-modified">6717    */</span>
6718 
6719   /* SOMETIMES, DUMBER CODE IS BETTER CODE */
6720 
6721   static void
6722   Ins_IP( TT_ExecContext  exc )
6723   {
6724     FT_F26Dot6  old_range, cur_range;
6725     FT_Vector*  orus_base;
6726     FT_Vector*  cur_base;
6727     FT_Int      twilight;
6728 
6729 
6730     if ( exc-&gt;top &lt; exc-&gt;GS.loop )
6731     {
6732       if ( exc-&gt;pedantic_hinting )
6733         exc-&gt;error = FT_THROW( Invalid_Reference );
6734       goto Fail;
6735     }
6736 
6737     /*
</pre>
<hr />
<pre>
6852           /*              new_dist = org_dist                .       */
6853 
6854           new_dist = org_dist;
6855         }
6856       }
6857       else
6858         new_dist = 0;
6859 
6860       exc-&gt;func_move( exc,
6861                       &amp;exc-&gt;zp2,
6862                       (FT_UShort)point,
6863                       SUB_LONG( new_dist, cur_dist ) );
6864     }
6865 
6866   Fail:
6867     exc-&gt;GS.loop = 1;
6868     exc-&gt;new_top = exc-&gt;args;
6869   }
6870 
6871 
<span class="line-modified">6872   /**************************************************************************</span>
<span class="line-modified">6873    *</span>
<span class="line-modified">6874    * UTP[a]:       UnTouch Point</span>
<span class="line-modified">6875    * Opcode range: 0x29</span>
<span class="line-modified">6876    * Stack:        uint32 --&gt;</span>
<span class="line-modified">6877    */</span>
6878   static void
6879   Ins_UTP( TT_ExecContext  exc,
6880            FT_Long*        args )
6881   {
6882     FT_UShort  point;
6883     FT_Byte    mask;
6884 
6885 
6886     point = (FT_UShort)args[0];
6887 
6888     if ( BOUNDS( point, exc-&gt;zp0.n_points ) )
6889     {
6890       if ( exc-&gt;pedantic_hinting )
6891         exc-&gt;error = FT_THROW( Invalid_Reference );
6892       return;
6893     }
6894 
6895     mask = 0xFF;
6896 
6897     if ( exc-&gt;GS.freeVector.x != 0 )
</pre>
<hr />
<pre>
7021 
7022         else
7023         {
7024           if ( !scale_valid )
7025           {
7026             scale_valid = 1;
7027             scale       = FT_DivFix( SUB_LONG( cur2, cur1 ),
7028                                      SUB_LONG( orus2, orus1 ) );
7029           }
7030 
7031           x = ADD_LONG( cur1,
7032                         FT_MulFix( SUB_LONG( worker-&gt;orus[i].x, orus1 ),
7033                                    scale ) );
7034         }
7035         worker-&gt;curs[i].x = x;
7036       }
7037     }
7038   }
7039 
7040 
<span class="line-modified">7041   /**************************************************************************</span>
<span class="line-modified">7042    *</span>
<span class="line-modified">7043    * IUP[a]:       Interpolate Untouched Points</span>
<span class="line-modified">7044    * Opcode range: 0x30-0x31</span>
<span class="line-modified">7045    * Stack:        --&gt;</span>
<span class="line-modified">7046    */</span>
7047   static void
7048   Ins_IUP( TT_ExecContext  exc )
7049   {
7050     IUP_WorkerRec  V;
7051     FT_Byte        mask;
7052 
7053     FT_UInt   first_point;   /* first point of contour        */
7054     FT_UInt   end_point;     /* end point (last+1) of contour */
7055 
7056     FT_UInt   first_touched; /* first touched point in contour   */
7057     FT_UInt   cur_touched;   /* current touched point in contour */
7058 
7059     FT_UInt   point;         /* current point   */
7060     FT_Short  contour;       /* current contour */
7061 
7062 
7063 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
7064     /* See `ttinterp.h&#39; for details on backward compatibility mode.  */
7065     /* Allow IUP until it has been called on both axes.  Immediately */
7066     /* return on subsequent ones.                                    */
</pre>
<hr />
<pre>
7149         {
7150           _iup_worker_interpolate( &amp;V,
7151                                    (FT_UShort)( cur_touched + 1 ),
7152                                    end_point,
7153                                    cur_touched,
7154                                    first_touched );
7155 
7156           if ( first_touched &gt; 0 )
7157             _iup_worker_interpolate( &amp;V,
7158                                      first_point,
7159                                      first_touched - 1,
7160                                      cur_touched,
7161                                      first_touched );
7162         }
7163       }
7164       contour++;
7165     } while ( contour &lt; exc-&gt;pts.n_contours );
7166   }
7167 
7168 
<span class="line-modified">7169   /**************************************************************************</span>
<span class="line-modified">7170    *</span>
<span class="line-modified">7171    * DELTAPn[]:    DELTA exceptions P1, P2, P3</span>
<span class="line-modified">7172    * Opcode range: 0x5D,0x71,0x72</span>
<span class="line-modified">7173    * Stack:        uint32 (2 * uint32)... --&gt;</span>
<span class="line-modified">7174    */</span>
7175   static void
7176   Ins_DELTAP( TT_ExecContext  exc,
7177               FT_Long*        args )
7178   {
7179     FT_ULong   nump, k;
7180     FT_UShort  A;
7181     FT_ULong   C, P;
7182     FT_Long    B;
7183 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7184     FT_UShort  B1, B2;
7185 
7186 
7187     if ( SUBPIXEL_HINTING_INFINALITY                              &amp;&amp;
7188          exc-&gt;ignore_x_mode                                       &amp;&amp;
7189          exc-&gt;iup_called                                          &amp;&amp;
7190          ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )
7191       goto Fail;
7192 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7193 
7194     P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );
</pre>
<hr />
<pre>
7231 
7232         case 0x72:
7233           C += 32;
7234           break;
7235         }
7236 
7237         C += exc-&gt;GS.delta_base;
7238 
7239         if ( P == C )
7240         {
7241           B = ( (FT_ULong)B &amp; 0xF ) - 8;
7242           if ( B &gt;= 0 )
7243             B++;
7244           B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );
7245 
7246 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7247 
7248           if ( SUBPIXEL_HINTING_INFINALITY )
7249           {
7250             /*
<span class="line-modified">7251              * Allow delta move if</span>
7252              *
<span class="line-modified">7253              * - not using ignore_x_mode rendering,</span>
<span class="line-modified">7254              * - glyph is specifically set to allow it, or</span>
<span class="line-modified">7255              * - glyph is composite and freedom vector is not in subpixel</span>
<span class="line-modified">7256              *   direction.</span>
7257              */
7258             if ( !exc-&gt;ignore_x_mode                                   ||
7259                  ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
7260                  ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 )    )
7261               exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7262 
7263             /* Otherwise, apply subpixel hinting and compatibility mode */
7264             /* rules, always skipping deltas in subpixel direction.     */
7265             else if ( exc-&gt;ignore_x_mode &amp;&amp; exc-&gt;GS.freeVector.y != 0 )
7266             {
7267               /* save the y value of the point now; compare after move */
7268               B1 = (FT_UShort)exc-&gt;zp0.cur[A].y;
7269 
7270               /* Standard subpixel hinting: Allow y move for y-touched */
7271               /* points.  This messes up DejaVu ...                    */
7272               if ( !exc-&gt;face-&gt;sph_compatibility_mode          &amp;&amp;
7273                    ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y ) )
7274                 exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7275 
7276               /* compatibility mode */
</pre>
<hr />
<pre>
7316                    ( ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 ) ||
7317                      ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y )        ) )
7318                 exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7319             }
7320             else
7321 #endif
7322               exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );
7323           }
7324         }
7325       }
7326       else
7327         if ( exc-&gt;pedantic_hinting )
7328           exc-&gt;error = FT_THROW( Invalid_Reference );
7329     }
7330 
7331   Fail:
7332     exc-&gt;new_top = exc-&gt;args;
7333   }
7334 
7335 
<span class="line-modified">7336   /**************************************************************************</span>
<span class="line-modified">7337    *</span>
<span class="line-modified">7338    * DELTACn[]:    DELTA exceptions C1, C2, C3</span>
<span class="line-modified">7339    * Opcode range: 0x73,0x74,0x75</span>
<span class="line-modified">7340    * Stack:        uint32 (2 * uint32)... --&gt;</span>
<span class="line-modified">7341    */</span>
7342   static void
7343   Ins_DELTAC( TT_ExecContext  exc,
7344               FT_Long*        args )
7345   {
7346     FT_ULong  nump, k;
7347     FT_ULong  A, C, P;
7348     FT_Long   B;
7349 
7350 
7351     P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );
7352     nump = (FT_ULong)args[0];
7353 
7354     for ( k = 1; k &lt;= nump; k++ )
7355     {
7356       if ( exc-&gt;args &lt; 2 )
7357       {
7358         if ( exc-&gt;pedantic_hinting )
7359           exc-&gt;error = FT_THROW( Too_Few_Arguments );
7360         exc-&gt;args = 0;
7361         goto Fail;
</pre>
<hr />
<pre>
7394 
7395         C += exc-&gt;GS.delta_base;
7396 
7397         if ( P == C )
7398         {
7399           B = ( (FT_ULong)B &amp; 0xF ) - 8;
7400           if ( B &gt;= 0 )
7401             B++;
7402           B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );
7403 
7404           exc-&gt;func_move_cvt( exc, A, B );
7405         }
7406       }
7407     }
7408 
7409   Fail:
7410     exc-&gt;new_top = exc-&gt;args;
7411   }
7412 
7413 
<span class="line-modified">7414   /**************************************************************************</span>
<span class="line-modified">7415    *</span>
<span class="line-modified">7416    * MISC. INSTRUCTIONS</span>
<span class="line-modified">7417    *</span>
<span class="line-modified">7418    */</span>
7419 
7420 
<span class="line-modified">7421   /**************************************************************************</span>
<span class="line-modified">7422    *</span>
<span class="line-modified">7423    * GETINFO[]:    GET INFOrmation</span>
<span class="line-modified">7424    * Opcode range: 0x88</span>
<span class="line-modified">7425    * Stack:        uint32 --&gt; uint32</span>
<span class="line-modified">7426    *</span>
<span class="line-modified">7427    * XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May</span>
<span class="line-modified">7428    *      2015) not documented in the OpenType specification.</span>
<span class="line-modified">7429    *</span>
<span class="line-modified">7430    *      Selector bit 11 is incorrectly described as bit 8, while the</span>
<span class="line-modified">7431    *      real meaning of bit 8 (vertical LCD subpixels) stays</span>
<span class="line-modified">7432    *      undocumented.  The same mistake can be found in Greg Hitchcock&#39;s</span>
<span class="line-modified">7433    *      whitepaper.</span>
<span class="line-modified">7434    */</span>
7435   static void
7436   Ins_GETINFO( TT_ExecContext  exc,
7437                FT_Long*        args )
7438   {
7439     FT_Long    K;
7440     TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( exc-&gt;face );
7441 
7442 
7443     K = 0;
7444 
7445 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
<span class="line-modified">7446     /*********************************</span>
<span class="line-modified">7447      * RASTERIZER VERSION</span>
<span class="line-modified">7448      * Selector Bit:  0</span>
<span class="line-modified">7449      * Return Bit(s): 0-7</span>
<span class="line-modified">7450      */</span>
7451     if ( SUBPIXEL_HINTING_INFINALITY &amp;&amp;
7452          ( args[0] &amp; 1 ) != 0        &amp;&amp;
7453          exc-&gt;subpixel_hinting       )
7454     {
7455       if ( exc-&gt;ignore_x_mode )
7456       {
7457         /* if in ClearType backward compatibility mode,         */
7458         /* we sometimes change the TrueType version dynamically */
7459         K = exc-&gt;rasterizer_version;
7460         FT_TRACE6(( &quot;Setting rasterizer version %d\n&quot;,
7461                     exc-&gt;rasterizer_version ));
7462       }
7463       else
7464         K = TT_INTERPRETER_VERSION_38;
7465     }
7466     else
7467 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7468       if ( ( args[0] &amp; 1 ) != 0 )
7469         K = driver-&gt;interpreter_version;
7470 
<span class="line-modified">7471     /*********************************</span>
<span class="line-modified">7472      * GLYPH ROTATED</span>
<span class="line-modified">7473      * Selector Bit:  1</span>
<span class="line-modified">7474      * Return Bit(s): 8</span>
<span class="line-modified">7475      */</span>
7476     if ( ( args[0] &amp; 2 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )
7477       K |= 1 &lt;&lt; 8;
7478 
<span class="line-modified">7479     /*********************************</span>
<span class="line-modified">7480      * GLYPH STRETCHED</span>
<span class="line-modified">7481      * Selector Bit:  2</span>
<span class="line-modified">7482      * Return Bit(s): 9</span>
<span class="line-modified">7483      */</span>
7484     if ( ( args[0] &amp; 4 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )
7485       K |= 1 &lt;&lt; 9;
7486 
7487 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
<span class="line-modified">7488     /*********************************</span>
<span class="line-modified">7489      * VARIATION GLYPH</span>
<span class="line-modified">7490      * Selector Bit:  3</span>
<span class="line-modified">7491      * Return Bit(s): 10</span>
<span class="line-modified">7492      *</span>
<span class="line-modified">7493      * XXX: UNDOCUMENTED!</span>
<span class="line-added">7494      */</span>
7495     if ( (args[0] &amp; 8 ) != 0 &amp;&amp; exc-&gt;face-&gt;blend )
7496       K |= 1 &lt;&lt; 10;
7497 #endif
7498 
<span class="line-modified">7499     /*********************************</span>
<span class="line-modified">7500      * BI-LEVEL HINTING AND</span>
<span class="line-modified">7501      * GRAYSCALE RENDERING</span>
<span class="line-modified">7502      * Selector Bit:  5</span>
<span class="line-modified">7503      * Return Bit(s): 12</span>
<span class="line-modified">7504      */</span>
7505     if ( ( args[0] &amp; 32 ) != 0 &amp;&amp; exc-&gt;grayscale )
7506       K |= 1 &lt;&lt; 12;
7507 
7508 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
7509     /* Toggle the following flags only outside of monochrome mode.      */
7510     /* Otherwise, instructions may behave weirdly and rendering results */
7511     /* may differ between v35 and v40 mode, e.g., in `Times New Roman   */
7512     /* Bold Italic&#39;. */
7513     if ( SUBPIXEL_HINTING_MINIMAL &amp;&amp; exc-&gt;subpixel_hinting_lean )
7514     {
<span class="line-modified">7515       /*********************************</span>
<span class="line-modified">7516        * HINTING FOR SUBPIXEL</span>
<span class="line-modified">7517        * Selector Bit:  6</span>
<span class="line-modified">7518        * Return Bit(s): 13</span>
<span class="line-modified">7519        *</span>
<span class="line-modified">7520        * v40 does subpixel hinting by default.</span>
<span class="line-added">7521        */</span>
7522       if ( ( args[0] &amp; 64 ) != 0 )
7523         K |= 1 &lt;&lt; 13;
7524 
<span class="line-modified">7525       /*********************************</span>
<span class="line-modified">7526        * VERTICAL LCD SUBPIXELS?</span>
<span class="line-modified">7527        * Selector Bit:  8</span>
<span class="line-modified">7528        * Return Bit(s): 15</span>
<span class="line-modified">7529        */</span>
7530       if ( ( args[0] &amp; 256 ) != 0 &amp;&amp; exc-&gt;vertical_lcd_lean )
7531         K |= 1 &lt;&lt; 15;
7532 
<span class="line-modified">7533       /*********************************</span>
<span class="line-modified">7534        * SUBPIXEL POSITIONED?</span>
<span class="line-modified">7535        * Selector Bit:  10</span>
<span class="line-modified">7536        * Return Bit(s): 17</span>
<span class="line-modified">7537        *</span>
<span class="line-modified">7538        * XXX: FreeType supports it, dependent on what client does?</span>
<span class="line-added">7539        */</span>
7540       if ( ( args[0] &amp; 1024 ) != 0 )
7541         K |= 1 &lt;&lt; 17;
7542 
<span class="line-modified">7543       /*********************************</span>
<span class="line-modified">7544        * SYMMETRICAL SMOOTHING</span>
<span class="line-modified">7545        * Selector Bit:  11</span>
<span class="line-modified">7546        * Return Bit(s): 18</span>
<span class="line-modified">7547        *</span>
<span class="line-modified">7548        * The only smoothing method FreeType supports unless someone sets</span>
<span class="line-modified">7549        * FT_LOAD_TARGET_MONO.</span>
<span class="line-added">7550        */</span>
7551       if ( ( args[0] &amp; 2048 ) != 0 &amp;&amp; exc-&gt;subpixel_hinting_lean )
7552         K |= 1 &lt;&lt; 18;
7553 
<span class="line-modified">7554       /*********************************</span>
<span class="line-modified">7555        * CLEARTYPE HINTING AND</span>
<span class="line-modified">7556        * GRAYSCALE RENDERING</span>
<span class="line-modified">7557        * Selector Bit:  12</span>
<span class="line-modified">7558        * Return Bit(s): 19</span>
<span class="line-modified">7559        *</span>
<span class="line-modified">7560        * Grayscale rendering is what FreeType does anyway unless someone</span>
<span class="line-modified">7561        * sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)</span>
<span class="line-added">7562        */</span>
7563       if ( ( args[0] &amp; 4096 ) != 0 &amp;&amp; exc-&gt;grayscale_cleartype )
7564         K |= 1 &lt;&lt; 19;
7565     }
7566 #endif
7567 
7568 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7569 
7570     if ( SUBPIXEL_HINTING_INFINALITY                          &amp;&amp;
7571          exc-&gt;rasterizer_version &gt;= TT_INTERPRETER_VERSION_35 )
7572     {
7573 
7574       if ( exc-&gt;rasterizer_version &gt;= 37 )
7575       {
<span class="line-modified">7576         /*********************************</span>
<span class="line-modified">7577          * HINTING FOR SUBPIXEL</span>
<span class="line-modified">7578          * Selector Bit:  6</span>
<span class="line-modified">7579          * Return Bit(s): 13</span>
<span class="line-modified">7580          */</span>
7581         if ( ( args[0] &amp; 64 ) != 0 &amp;&amp; exc-&gt;subpixel_hinting )
7582           K |= 1 &lt;&lt; 13;
7583 
<span class="line-modified">7584         /*********************************</span>
<span class="line-modified">7585          * COMPATIBLE WIDTHS ENABLED</span>
<span class="line-modified">7586          * Selector Bit:  7</span>
<span class="line-modified">7587          * Return Bit(s): 14</span>
<span class="line-modified">7588          *</span>
<span class="line-modified">7589          * Functionality still needs to be added</span>
<span class="line-added">7590          */</span>
7591         if ( ( args[0] &amp; 128 ) != 0 &amp;&amp; exc-&gt;compatible_widths )
7592           K |= 1 &lt;&lt; 14;
7593 
<span class="line-modified">7594         /*********************************</span>
<span class="line-modified">7595          * VERTICAL LCD SUBPIXELS?</span>
<span class="line-modified">7596          * Selector Bit:  8</span>
<span class="line-modified">7597          * Return Bit(s): 15</span>
<span class="line-modified">7598          *</span>
<span class="line-modified">7599          * Functionality still needs to be added</span>
<span class="line-added">7600          */</span>
7601         if ( ( args[0] &amp; 256 ) != 0 &amp;&amp; exc-&gt;vertical_lcd )
7602           K |= 1 &lt;&lt; 15;
7603 
<span class="line-modified">7604         /*********************************</span>
<span class="line-modified">7605          * HINTING FOR BGR?</span>
<span class="line-modified">7606          * Selector Bit:  9</span>
<span class="line-modified">7607          * Return Bit(s): 16</span>
<span class="line-modified">7608          *</span>
<span class="line-modified">7609          * Functionality still needs to be added</span>
<span class="line-added">7610          */</span>
7611         if ( ( args[0] &amp; 512 ) != 0 &amp;&amp; exc-&gt;bgr )
7612           K |= 1 &lt;&lt; 16;
7613 
7614         if ( exc-&gt;rasterizer_version &gt;= 38 )
7615         {
<span class="line-modified">7616           /*********************************</span>
<span class="line-modified">7617            * SUBPIXEL POSITIONED?</span>
<span class="line-modified">7618            * Selector Bit:  10</span>
<span class="line-modified">7619            * Return Bit(s): 17</span>
<span class="line-modified">7620            *</span>
<span class="line-modified">7621            * Functionality still needs to be added</span>
<span class="line-added">7622            */</span>
7623           if ( ( args[0] &amp; 1024 ) != 0 &amp;&amp; exc-&gt;subpixel_positioned )
7624             K |= 1 &lt;&lt; 17;
7625 
<span class="line-modified">7626           /*********************************</span>
<span class="line-modified">7627            * SYMMETRICAL SMOOTHING</span>
<span class="line-modified">7628            * Selector Bit:  11</span>
<span class="line-modified">7629            * Return Bit(s): 18</span>
<span class="line-modified">7630            *</span>
<span class="line-modified">7631            * Functionality still needs to be added</span>
<span class="line-added">7632            */</span>
7633           if ( ( args[0] &amp; 2048 ) != 0 &amp;&amp; exc-&gt;symmetrical_smoothing )
7634             K |= 1 &lt;&lt; 18;
7635 
<span class="line-modified">7636           /*********************************</span>
<span class="line-modified">7637            * GRAY CLEARTYPE</span>
<span class="line-modified">7638            * Selector Bit:  12</span>
<span class="line-modified">7639            * Return Bit(s): 19</span>
<span class="line-modified">7640            *</span>
<span class="line-modified">7641            * Functionality still needs to be added</span>
<span class="line-added">7642            */</span>
7643           if ( ( args[0] &amp; 4096 ) != 0 &amp;&amp; exc-&gt;gray_cleartype )
7644             K |= 1 &lt;&lt; 19;
7645         }
7646       }
7647     }
7648 
7649 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7650 
7651     args[0] = K;
7652   }
7653 
7654 
7655 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
7656 
<span class="line-modified">7657   /**************************************************************************</span>
<span class="line-modified">7658    *</span>
<span class="line-modified">7659    * GETVARIATION[]: get normalized variation (blend) coordinates</span>
<span class="line-modified">7660    * Opcode range: 0x91</span>
<span class="line-modified">7661    * Stack:        --&gt; f2.14...</span>
<span class="line-modified">7662    *</span>
<span class="line-modified">7663    * XXX: UNDOCUMENTED!  There is no official documentation from Apple for</span>
<span class="line-modified">7664    *      this bytecode instruction.  Active only if a font has GX</span>
<span class="line-modified">7665    *      variation axes.</span>
<span class="line-modified">7666    */</span>
7667   static void
7668   Ins_GETVARIATION( TT_ExecContext  exc,
7669                     FT_Long*        args )
7670   {
7671     FT_UInt    num_axes = exc-&gt;face-&gt;blend-&gt;num_axis;
7672     FT_Fixed*  coords   = exc-&gt;face-&gt;blend-&gt;normalizedcoords;
7673 
7674     FT_UInt  i;
7675 
7676 
7677     if ( BOUNDS( num_axes, exc-&gt;stackSize + 1 - exc-&gt;top ) )
7678     {
7679       exc-&gt;error = FT_THROW( Stack_Overflow );
7680       return;
7681     }
7682 
7683     if ( coords )
7684     {
7685       for ( i = 0; i &lt; num_axes; i++ )
7686         args[i] = coords[i] &gt;&gt; 2; /* convert 16.16 to 2.14 format */
7687     }
7688     else
7689     {
7690       for ( i = 0; i &lt; num_axes; i++ )
7691         args[i] = 0;
7692     }
7693   }
7694 
7695 
<span class="line-modified">7696   /**************************************************************************</span>
<span class="line-modified">7697    *</span>
<span class="line-modified">7698    * GETDATA[]:    no idea what this is good for</span>
<span class="line-modified">7699    * Opcode range: 0x92</span>
<span class="line-modified">7700    * Stack:        --&gt; 17</span>
<span class="line-modified">7701    *</span>
<span class="line-modified">7702    * XXX: UNDOCUMENTED!  There is no documentation from Apple for this</span>
<span class="line-modified">7703    *      very weird bytecode instruction.</span>
<span class="line-modified">7704    */</span>
7705   static void
7706   Ins_GETDATA( FT_Long*  args )
7707   {
7708     args[0] = 17;
7709   }
7710 
7711 #endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
7712 
7713 
7714   static void
7715   Ins_UNKNOWN( TT_ExecContext  exc )
7716   {
7717     TT_DefRecord*  def   = exc-&gt;IDefs;
7718     TT_DefRecord*  limit = def + exc-&gt;numIDefs;
7719 
7720 
7721     for ( ; def &lt; limit; def++ )
7722     {
7723       if ( (FT_Byte)def-&gt;opc == exc-&gt;opcode &amp;&amp; def-&gt;active )
7724       {
</pre>
<hr />
<pre>
7732         }
7733 
7734         call = exc-&gt;callStack + exc-&gt;callTop++;
7735 
7736         call-&gt;Caller_Range = exc-&gt;curRange;
7737         call-&gt;Caller_IP    = exc-&gt;IP + 1;
7738         call-&gt;Cur_Count    = 1;
7739         call-&gt;Def          = def;
7740 
7741         Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );
7742 
7743         exc-&gt;step_ins = FALSE;
7744         return;
7745       }
7746     }
7747 
7748     exc-&gt;error = FT_THROW( Invalid_Opcode );
7749   }
7750 
7751 
<span class="line-modified">7752   /**************************************************************************</span>
<span class="line-modified">7753    *</span>
<span class="line-modified">7754    * RUN</span>
<span class="line-modified">7755    *</span>
<span class="line-modified">7756    * This function executes a run of opcodes.  It will exit in the</span>
<span class="line-modified">7757    * following cases:</span>
<span class="line-modified">7758    *</span>
<span class="line-modified">7759    * - Errors (in which case it returns FALSE).</span>
<span class="line-modified">7760    *</span>
<span class="line-modified">7761    * - Reaching the end of the main code range (returns TRUE).</span>
<span class="line-modified">7762    *   Reaching the end of a code range within a function call is an</span>
<span class="line-modified">7763    *   error.</span>
<span class="line-modified">7764    *</span>
<span class="line-modified">7765    * - After executing one single opcode, if the flag `Instruction_Trap&#39;</span>
<span class="line-modified">7766    *   is set to TRUE (returns TRUE).</span>
<span class="line-modified">7767    *</span>
<span class="line-modified">7768    * On exit with TRUE, test IP &lt; CodeSize to know whether it comes from</span>
<span class="line-modified">7769    * an instruction trap or a normal termination.</span>
<span class="line-modified">7770    *</span>
<span class="line-modified">7771    *</span>
<span class="line-modified">7772    * Note: The documented DEBUG opcode pops a value from the stack.  This</span>
<span class="line-modified">7773    *       behaviour is unsupported; here a DEBUG opcode is always an</span>
<span class="line-modified">7774    *       error.</span>
<span class="line-modified">7775    *</span>
<span class="line-modified">7776    *</span>
<span class="line-modified">7777    * THIS IS THE INTERPRETER&#39;S MAIN LOOP.</span>
<span class="line-modified">7778    *</span>
<span class="line-modified">7779    */</span>
7780 
7781 
7782   /* documentation is in ttinterp.h */
7783 
7784   FT_EXPORT_DEF( FT_Error )
7785   TT_RunIns( TT_ExecContext  exc )
7786   {
7787     FT_ULong   ins_counter = 0;  /* executed instructions counter */
7788     FT_ULong   num_twilight_points;
7789     FT_UShort  i;
7790 
7791 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7792     FT_Byte    opcode_pattern[1][2] = {
7793                   /* #8 TypeMan Talk Align */
7794                   {
7795                     0x06, /* SPVTL   */
7796                     0x7D, /* RDTG    */
7797                   },
7798                 };
7799     FT_UShort  opcode_patterns   = 1;
7800     FT_UShort  opcode_pointer[1] = { 0 };
7801     FT_UShort  opcode_size[1]    = { 1 };
7802 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7803 
7804 
7805 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
7806     exc-&gt;iup_called = FALSE;
7807 #endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
7808 
7809 #ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
7810     /*
<span class="line-modified">7811      * Toggle backward compatibility according to what font wants, except</span>
<span class="line-modified">7812      * when</span>
7813      *
<span class="line-modified">7814      * 1) we have a `tricky&#39; font that heavily relies on the interpreter to</span>
<span class="line-modified">7815      *    render glyphs correctly, for example DFKai-SB, or</span>
<span class="line-modified">7816      * 2) FT_RENDER_MODE_MONO (i.e, monochome rendering) is requested.</span>
7817      *
<span class="line-modified">7818      * In those cases, backward compatibility needs to be turned off to get</span>
<span class="line-modified">7819      * correct rendering.  The rendering is then completely up to the</span>
<span class="line-modified">7820      * font&#39;s programming.</span>
7821      *
7822      */
7823     if ( SUBPIXEL_HINTING_MINIMAL          &amp;&amp;
7824          exc-&gt;subpixel_hinting_lean        &amp;&amp;
7825          !FT_IS_TRICKY( &amp;exc-&gt;face-&gt;root ) )
7826       exc-&gt;backward_compatibility = !( exc-&gt;GS.instruct_control &amp; 4 );
7827     else
7828       exc-&gt;backward_compatibility = FALSE;
7829 
7830     exc-&gt;iupx_called = FALSE;
7831     exc-&gt;iupy_called = FALSE;
7832 #endif
7833 
7834     /* We restrict the number of twilight points to a reasonable,     */
7835     /* heuristic value to avoid slow execution of malformed bytecode. */
7836     num_twilight_points = FT_MAX( 30,
7837                                   2 * ( exc-&gt;pts.n_points + exc-&gt;cvtSize ) );
7838     if ( exc-&gt;twilight.n_points &gt; num_twilight_points )
7839     {
7840       if ( num_twilight_points &gt; 0xFFFFU )
</pre>
<hr />
<pre>
7901       exc-&gt;func_move_cvt  = Move_CVT;
7902     }
7903 
7904     Compute_Funcs( exc );
7905     Compute_Round( exc, (FT_Byte)exc-&gt;GS.round_state );
7906 
7907     do
7908     {
7909       exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];
7910 
7911 #ifdef FT_DEBUG_LEVEL_TRACE
7912       {
7913         FT_Long  cnt = FT_MIN( 8, exc-&gt;top );
7914         FT_Long  n;
7915 
7916 
7917         /* if tracing level is 7, show current code position */
7918         /* and the first few stack elements also             */
7919         FT_TRACE6(( &quot;  &quot; ));
7920         FT_TRACE7(( &quot;%06d &quot;, exc-&gt;IP ));
<span class="line-modified">7921         FT_TRACE6(( &quot;%s&quot;, opcode_name[exc-&gt;opcode] + 2 ));</span>
7922         FT_TRACE7(( &quot;%*s&quot;, *opcode_name[exc-&gt;opcode] == &#39;A&#39;
7923                               ? 2
7924                               : 12 - ( *opcode_name[exc-&gt;opcode] - &#39;0&#39; ),
7925                               &quot;#&quot; ));
7926         for ( n = 1; n &lt;= cnt; n++ )
7927           FT_TRACE7(( &quot; %d&quot;, exc-&gt;stack[exc-&gt;top - n] ));
7928         FT_TRACE6(( &quot;\n&quot; ));
7929       }
7930 #endif /* FT_DEBUG_LEVEL_TRACE */
7931 
7932       if ( ( exc-&gt;length = opcode_length[exc-&gt;opcode] ) &lt; 0 )
7933       {
7934         if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )
7935           goto LErrorCodeOverflow_;
7936 
7937         exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];
7938       }
7939 
7940       if ( exc-&gt;IP + exc-&gt;length &gt; exc-&gt;codeSize )
7941         goto LErrorCodeOverflow_;
</pre>
</td>
</tr>
</table>
<center><a href="ttgxvar.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ttinterp.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
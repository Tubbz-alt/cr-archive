<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/autofit/afwarp.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  afwarp.c                                                               */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Auto-fitter warping algorithm (body).                                */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2006-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19   /*
<a name="2" id="anc2"></a><span class="line-modified"> 20    *  The idea of the warping code is to slightly scale and shift a glyph</span>
<span class="line-modified"> 21    *  within a single dimension so that as much of its segments are aligned</span>
<span class="line-modified"> 22    *  (more or less) on the grid.  To find out the optimal scaling and</span>
<span class="line-modified"> 23    *  shifting value, various parameter combinations are tried and scored.</span>
 24    */
 25 
 26 #include &quot;afwarp.h&quot;
 27 
 28 #ifdef AF_CONFIG_OPTION_USE_WARPER
 29 
<a name="3" id="anc3"></a><span class="line-modified"> 30   /*************************************************************************/</span>
<span class="line-modified"> 31   /*                                                                       */</span>
<span class="line-modified"> 32   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 33   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 34   /* messages during execution.                                            */</span>
<span class="line-modified"> 35   /*                                                                       */</span>
 36 #undef  FT_COMPONENT
<a name="4" id="anc4"></a><span class="line-modified"> 37 #define FT_COMPONENT  trace_afwarp</span>
 38 
 39 
 40   /* The weights cover the range 0/64 - 63/64 of a pixel.  Obviously, */
 41   /* values around a half pixel (which means exactly between two grid */
 42   /* lines) gets the worst weight.                                    */
 43 #if 1
 44   static const AF_WarpScore
 45   af_warper_weights[64] =
 46   {
 47     35, 32, 30, 25, 20, 15, 12, 10,  5,  1,  0,  0,  0,  0,  0,  0,
 48      0,  0,  0,  0,  0,  0, -1, -2, -5, -8,-10,-10,-20,-20,-30,-30,
 49 
 50    -30,-30,-20,-20,-10,-10, -8, -5, -2, -1,  0,  0,  0,  0,  0,  0,
 51      0,  0,  0,  0,  0,  0,  0,  1,  5, 10, 12, 15, 20, 25, 30, 32,
 52   };
 53 #else
 54   static const AF_WarpScore
 55   af_warper_weights[64] =
 56   {
 57     30, 20, 10,  5,  4,  4,  3,  2,  1,  0,  0,  0,  0,  0,  0,  0,
 58      0,  0,  0,  0,  0,  0,  0, -1, -2, -2, -5, -5,-10,-10,-15,-20,
 59 
 60    -20,-15,-15,-10,-10, -5, -5, -2, -2, -1,  0,  0,  0,  0,  0,  0,
 61      0,  0,  0,  0,  0,  0,  0,  0,  1,  2,  3,  4,  4,  5, 10, 20,
 62   };
 63 #endif
 64 
 65 
 66   /* Score segments for a given `scale&#39; and `delta&#39; in the range */
 67   /* `xx1&#39; to `xx2&#39;, and store the best result in `warper&#39;.  If  */
 68   /* the new best score is equal to the old one, prefer the      */
 69   /* value with a smaller distortion (around `base_distort&#39;).    */
 70 
 71   static void
 72   af_warper_compute_line_best( AF_Warper     warper,
 73                                FT_Fixed      scale,
 74                                FT_Pos        delta,
 75                                FT_Pos        xx1,
 76                                FT_Pos        xx2,
 77                                AF_WarpScore  base_distort,
 78                                AF_Segment    segments,
 79                                FT_Int        num_segments )
 80   {
 81     FT_Int        idx_min, idx_max, idx0;
 82     FT_Int        nn;
 83     AF_WarpScore  scores[65];
 84 
 85 
 86     for ( nn = 0; nn &lt; 65; nn++ )
 87       scores[nn] = 0;
 88 
 89     idx0 = xx1 - warper-&gt;t1;
 90 
 91     /* compute minimum and maximum indices */
 92     {
 93       FT_Pos  xx1min = warper-&gt;x1min;
 94       FT_Pos  xx1max = warper-&gt;x1max;
 95       FT_Pos  w      = xx2 - xx1;
 96 
 97 
 98       if ( xx1min + w &lt; warper-&gt;x2min )
 99         xx1min = warper-&gt;x2min - w;
100 
101       if ( xx1max + w &gt; warper-&gt;x2max )
102         xx1max = warper-&gt;x2max - w;
103 
104       idx_min = xx1min - warper-&gt;t1;
105       idx_max = xx1max - warper-&gt;t1;
106 
107       if ( idx_min &lt; 0 || idx_min &gt; idx_max || idx_max &gt; 64 )
108       {
109         FT_TRACE5(( &quot;invalid indices:\n&quot;
110                     &quot;  min=%d max=%d, xx1=%ld xx2=%ld,\n&quot;
111                     &quot;  x1min=%ld x1max=%ld, x2min=%ld x2max=%ld\n&quot;,
112                     idx_min, idx_max, xx1, xx2,
113                     warper-&gt;x1min, warper-&gt;x1max,
114                     warper-&gt;x2min, warper-&gt;x2max ));
115         return;
116       }
117     }
118 
119     for ( nn = 0; nn &lt; num_segments; nn++ )
120     {
121       FT_Pos  len = segments[nn].max_coord - segments[nn].min_coord;
122       FT_Pos  y0  = FT_MulFix( segments[nn].pos, scale ) + delta;
123       FT_Pos  y   = y0 + ( idx_min - idx0 );
124       FT_Int  idx;
125 
126 
127       /* score the length of the segments for the given range */
128       for ( idx = idx_min; idx &lt;= idx_max; idx++, y++ )
129         scores[idx] += af_warper_weights[y &amp; 63] * len;
130     }
131 
132     /* find best score */
133     {
134       FT_Int  idx;
135 
136 
137       for ( idx = idx_min; idx &lt;= idx_max; idx++ )
138       {
139         AF_WarpScore  score = scores[idx];
140         AF_WarpScore  distort = base_distort + ( idx - idx0 );
141 
142 
143         if ( score &gt; warper-&gt;best_score         ||
144              ( score == warper-&gt;best_score    &amp;&amp;
145                distort &lt; warper-&gt;best_distort ) )
146         {
147           warper-&gt;best_score   = score;
148           warper-&gt;best_distort = distort;
149           warper-&gt;best_scale   = scale;
150           warper-&gt;best_delta   = delta + ( idx - idx0 );
151         }
152       }
153     }
154   }
155 
156 
157   /* Compute optimal scaling and delta values for a given glyph and */
158   /* dimension.                                                     */
159 
160   FT_LOCAL_DEF( void )
161   af_warper_compute( AF_Warper      warper,
162                      AF_GlyphHints  hints,
163                      AF_Dimension   dim,
164                      FT_Fixed      *a_scale,
165                      FT_Pos        *a_delta )
166   {
167     AF_AxisHints  axis;
168     AF_Point      points;
169 
170     FT_Fixed      org_scale;
171     FT_Pos        org_delta;
172 
173     FT_Int        nn, num_points, num_segments;
174     FT_Int        X1, X2;
175     FT_Int        w;
176 
177     AF_WarpScore  base_distort;
178     AF_Segment    segments;
179 
180 
181     /* get original scaling transformation */
182     if ( dim == AF_DIMENSION_VERT )
183     {
184       org_scale = hints-&gt;y_scale;
185       org_delta = hints-&gt;y_delta;
186     }
187     else
188     {
189       org_scale = hints-&gt;x_scale;
190       org_delta = hints-&gt;x_delta;
191     }
192 
193     warper-&gt;best_scale   = org_scale;
194     warper-&gt;best_delta   = org_delta;
195     warper-&gt;best_score   = FT_INT_MIN;
196     warper-&gt;best_distort = 0;
197 
198     axis         = &amp;hints-&gt;axis[dim];
199     segments     = axis-&gt;segments;
200     num_segments = axis-&gt;num_segments;
201     points       = hints-&gt;points;
202     num_points   = hints-&gt;num_points;
203 
204     *a_scale = org_scale;
205     *a_delta = org_delta;
206 
207     /* get X1 and X2, minimum and maximum in original coordinates */
208     if ( num_segments &lt; 1 )
209       return;
210 
211 #if 1
212     X1 = X2 = points[0].fx;
213     for ( nn = 1; nn &lt; num_points; nn++ )
214     {
215       FT_Int  X = points[nn].fx;
216 
217 
218       if ( X &lt; X1 )
219         X1 = X;
220       if ( X &gt; X2 )
221         X2 = X;
222     }
223 #else
224     X1 = X2 = segments[0].pos;
225     for ( nn = 1; nn &lt; num_segments; nn++ )
226     {
227       FT_Int  X = segments[nn].pos;
228 
229 
230       if ( X &lt; X1 )
231         X1 = X;
232       if ( X &gt; X2 )
233         X2 = X;
234     }
235 #endif
236 
237     if ( X1 &gt;= X2 )
238       return;
239 
240     warper-&gt;x1 = FT_MulFix( X1, org_scale ) + org_delta;
241     warper-&gt;x2 = FT_MulFix( X2, org_scale ) + org_delta;
242 
243     warper-&gt;t1 = AF_WARPER_FLOOR( warper-&gt;x1 );
244     warper-&gt;t2 = AF_WARPER_CEIL( warper-&gt;x2 );
245 
246     /* examine a half pixel wide range around the maximum coordinates */
247     warper-&gt;x1min = warper-&gt;x1 &amp; ~31;
248     warper-&gt;x1max = warper-&gt;x1min + 32;
249     warper-&gt;x2min = warper-&gt;x2 &amp; ~31;
250     warper-&gt;x2max = warper-&gt;x2min + 32;
251 
252     if ( warper-&gt;x1max &gt; warper-&gt;x2 )
253       warper-&gt;x1max = warper-&gt;x2;
254 
255     if ( warper-&gt;x2min &lt; warper-&gt;x1 )
256       warper-&gt;x2min = warper-&gt;x1;
257 
258     warper-&gt;w0 = warper-&gt;x2 - warper-&gt;x1;
259 
260     if ( warper-&gt;w0 &lt;= 64 )
261     {
262       warper-&gt;x1max = warper-&gt;x1;
263       warper-&gt;x2min = warper-&gt;x2;
264     }
265 
266     /* examine (at most) a pixel wide range around the natural width */
267     warper-&gt;wmin = warper-&gt;x2min - warper-&gt;x1max;
268     warper-&gt;wmax = warper-&gt;x2max - warper-&gt;x1min;
269 
270 #if 1
271     /* some heuristics to reduce the number of widths to be examined */
272     {
273       int  margin = 16;
274 
275 
276       if ( warper-&gt;w0 &lt;= 128 )
277       {
278          margin = 8;
279          if ( warper-&gt;w0 &lt;= 96 )
280            margin = 4;
281       }
282 
283       if ( warper-&gt;wmin &lt; warper-&gt;w0 - margin )
284         warper-&gt;wmin = warper-&gt;w0 - margin;
285 
286       if ( warper-&gt;wmax &gt; warper-&gt;w0 + margin )
287         warper-&gt;wmax = warper-&gt;w0 + margin;
288     }
289 
290     if ( warper-&gt;wmin &lt; warper-&gt;w0 * 3 / 4 )
291       warper-&gt;wmin = warper-&gt;w0 * 3 / 4;
292 
293     if ( warper-&gt;wmax &gt; warper-&gt;w0 * 5 / 4 )
294       warper-&gt;wmax = warper-&gt;w0 * 5 / 4;
295 #else
296     /* no scaling, just translation */
297     warper-&gt;wmin = warper-&gt;wmax = warper-&gt;w0;
298 #endif
299 
300     for ( w = warper-&gt;wmin; w &lt;= warper-&gt;wmax; w++ )
301     {
302       FT_Fixed  new_scale;
303       FT_Pos    new_delta;
304       FT_Pos    xx1, xx2;
305 
306 
307       /* compute min and max positions for given width,       */
308       /* assuring that they stay within the coordinate ranges */
309       xx1 = warper-&gt;x1;
310       xx2 = warper-&gt;x2;
311       if ( w &gt;= warper-&gt;w0 )
312       {
313         xx1 -= w - warper-&gt;w0;
314         if ( xx1 &lt; warper-&gt;x1min )
315         {
316           xx2 += warper-&gt;x1min - xx1;
317           xx1  = warper-&gt;x1min;
318         }
319       }
320       else
321       {
322         xx1 -= w - warper-&gt;w0;
323         if ( xx1 &gt; warper-&gt;x1max )
324         {
325           xx2 -= xx1 - warper-&gt;x1max;
326           xx1  = warper-&gt;x1max;
327         }
328       }
329 
330       if ( xx1 &lt; warper-&gt;x1 )
331         base_distort = warper-&gt;x1 - xx1;
332       else
333         base_distort = xx1 - warper-&gt;x1;
334 
335       if ( xx2 &lt; warper-&gt;x2 )
336         base_distort += warper-&gt;x2 - xx2;
337       else
338         base_distort += xx2 - warper-&gt;x2;
339 
340       /* give base distortion a greater weight while scoring */
341       base_distort *= 10;
342 
343       new_scale = org_scale + FT_DivFix( w - warper-&gt;w0, X2 - X1 );
344       new_delta = xx1 - FT_MulFix( X1, new_scale );
345 
346       af_warper_compute_line_best( warper, new_scale, new_delta, xx1, xx2,
347                                    base_distort,
348                                    segments, num_segments );
349     }
350 
351     {
352       FT_Fixed  best_scale = warper-&gt;best_scale;
353       FT_Pos    best_delta = warper-&gt;best_delta;
354 
355 
356       hints-&gt;xmin_delta = FT_MulFix( X1, best_scale - org_scale )
357                           + best_delta;
358       hints-&gt;xmax_delta = FT_MulFix( X2, best_scale - org_scale )
359                           + best_delta;
360 
361       *a_scale = best_scale;
362       *a_delta = best_delta;
363     }
364   }
365 
366 #else /* !AF_CONFIG_OPTION_USE_WARPER */
367 
368   /* ANSI C doesn&#39;t like empty source files */
369   typedef int  _af_warp_dummy;
370 
371 #endif /* !AF_CONFIG_OPTION_USE_WARPER */
372 
373 /* END */
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/autofit/afglobal.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="aferrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afglobal.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afglobal.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  afglobal.c                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Auto-fitter routines to compute global hinting values (body).        */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &quot;afglobal.h&quot;
 20 #include &quot;afranges.h&quot;
 21 #include &quot;afshaper.h&quot;
 22 #include FT_INTERNAL_DEBUG_H
 23 
 24 
<span class="line-modified"> 25   /*************************************************************************/</span>
<span class="line-modified"> 26   /*                                                                       */</span>
<span class="line-modified"> 27   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 28   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 29   /* messages during execution.                                            */</span>
<span class="line-modified"> 30   /*                                                                       */</span>
 31 #undef  FT_COMPONENT
<span class="line-modified"> 32 #define FT_COMPONENT  trace_afglobal</span>
 33 
 34 
 35   /* get writing system specific header files */
 36 #undef  WRITING_SYSTEM
 37 #define WRITING_SYSTEM( ws, WS )  /* empty */
 38 #include &quot;afwrtsys.h&quot;
 39 
 40 #include &quot;aferrors.h&quot;
<span class="line-removed"> 41 #include &quot;afpic.h&quot;</span>
 42 
 43 
 44 #undef  SCRIPT
 45 #define SCRIPT( s, S, d, h, H, ss )         \
 46           AF_DEFINE_SCRIPT_CLASS(           \
 47             af_ ## s ## _script_class,      \
 48             AF_SCRIPT_ ## S,                \
 49             af_ ## s ## _uniranges,         \
 50             af_ ## s ## _nonbase_uniranges, \
 51             AF_ ## H,                       \
 52             ss )
 53 
 54 #include &quot;afscript.h&quot;
 55 
 56 
 57 #undef  STYLE
 58 #define STYLE( s, S, d, ws, sc, ss, c )  \
 59           AF_DEFINE_STYLE_CLASS(         \
 60             af_ ## s ## _style_class,    \
 61             AF_STYLE_ ## S,              \
 62             ws,                          \
 63             sc,                          \
 64             ss,                          \
 65             c )
 66 
 67 #include &quot;afstyles.h&quot;
 68 
 69 
<span class="line-removed"> 70 #ifndef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed"> 71 </span>
 72 #undef  WRITING_SYSTEM
 73 #define WRITING_SYSTEM( ws, WS )               \
 74           &amp;af_ ## ws ## _writing_system_class,
 75 
 76   FT_LOCAL_ARRAY_DEF( AF_WritingSystemClass )
 77   af_writing_system_classes[] =
 78   {
 79 
 80 #include &quot;afwrtsys.h&quot;
 81 
 82     NULL  /* do not remove */
 83   };
 84 
 85 
 86 #undef  SCRIPT
 87 #define SCRIPT( s, S, d, h, H, ss )   \
 88           &amp;af_ ## s ## _script_class,
 89 
 90   FT_LOCAL_ARRAY_DEF( AF_ScriptClass )
 91   af_script_classes[] =
</pre>
<hr />
<pre>
 93 
 94 #include &quot;afscript.h&quot;
 95 
 96     NULL  /* do not remove */
 97   };
 98 
 99 
100 #undef  STYLE
101 #define STYLE( s, S, d, ws, sc, ss, c ) \
102           &amp;af_ ## s ## _style_class,
103 
104   FT_LOCAL_ARRAY_DEF( AF_StyleClass )
105   af_style_classes[] =
106   {
107 
108 #include &quot;afstyles.h&quot;
109 
110     NULL  /* do not remove */
111   };
112 
<span class="line-removed">113 #endif /* !FT_CONFIG_OPTION_PIC */</span>
<span class="line-removed">114 </span>
115 
116 #ifdef FT_DEBUG_LEVEL_TRACE
117 
118 #undef  STYLE
119 #define STYLE( s, S, d, ws, sc, ss, c )  #s,
120 
121   FT_LOCAL_ARRAY_DEF( char* )
122   af_style_names[] =
123   {
124 
125 #include &quot;afstyles.h&quot;
126 
127   };
128 
129 #endif /* FT_DEBUG_LEVEL_TRACE */
130 
131 
132   /* Compute the style index of each glyph within a given face. */
133 
134   static FT_Error
</pre>
<hr />
<pre>
142     FT_UInt     i;
143     FT_UInt     dflt        = ~0U; /* a non-valid value */
144 
145 
146     /* the value AF_STYLE_UNASSIGNED means `uncovered glyph&#39; */
147     for ( i = 0; i &lt; (FT_UInt)globals-&gt;glyph_count; i++ )
148       gstyles[i] = AF_STYLE_UNASSIGNED;
149 
150     error = FT_Select_Charmap( face, FT_ENCODING_UNICODE );
151     if ( error )
152     {
153       /*
154        * Ignore this error; we simply use the fallback style.
155        * XXX: Shouldn&#39;t we rather disable hinting?
156        */
157       error = FT_Err_Ok;
158       goto Exit;
159     }
160 
161     /* scan each style in a Unicode charmap */
<span class="line-modified">162     for ( ss = 0; AF_STYLE_CLASSES_GET[ss]; ss++ )</span>
163     {
164       AF_StyleClass       style_class =
<span class="line-modified">165                             AF_STYLE_CLASSES_GET[ss];</span>
166       AF_ScriptClass      script_class =
<span class="line-modified">167                             AF_SCRIPT_CLASSES_GET[style_class-&gt;script];</span>
168       AF_Script_UniRange  range;
169 
170 
171       if ( !script_class-&gt;script_uni_ranges )
172         continue;
173 
174       /*
<span class="line-modified">175        *  Scan all Unicode points in the range and set the corresponding</span>
<span class="line-modified">176        *  glyph style index.</span>
177        */
178       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
179       {
180         if ( (FT_UInt)style_class-&gt;script ==
181              globals-&gt;module-&gt;default_script )
182           dflt = ss;
183 
184         for ( range = script_class-&gt;script_uni_ranges;
185               range-&gt;first != 0;
186               range++ )
187         {
188           FT_ULong  charcode = range-&gt;first;
189           FT_UInt   gindex;
190 
191 
192           gindex = FT_Get_Char_Index( face, charcode );
193 
194           if ( gindex != 0                                                &amp;&amp;
195                gindex &lt; (FT_ULong)globals-&gt;glyph_count                    &amp;&amp;
196                ( gstyles[gindex] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
</pre>
<hr />
<pre>
229           {
230             charcode = FT_Get_Next_Char( face, charcode, &amp;gindex );
231 
232             if ( gindex == 0 || charcode &gt; range-&gt;last )
233               break;
234 
235             if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count              &amp;&amp;
236                  ( gstyles[gindex] &amp; AF_STYLE_MASK ) == (FT_UShort)ss )
237               gstyles[gindex] |= AF_NONBASE;
238           }
239         }
240       }
241       else
242       {
243         /* get glyphs not directly addressable by cmap */
244         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
245       }
246     }
247 
248     /* handle the remaining default OpenType features ... */
<span class="line-modified">249     for ( ss = 0; AF_STYLE_CLASSES_GET[ss]; ss++ )</span>
250     {
<span class="line-modified">251       AF_StyleClass  style_class = AF_STYLE_CLASSES_GET[ss];</span>
252 
253 
254       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
255         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
256     }
257 
258     /* ... and finally the default OpenType features of the default script */
<span class="line-modified">259     af_shaper_get_coverage( globals, AF_STYLE_CLASSES_GET[dflt], gstyles, 1 );</span>
260 
261     /* mark ASCII digits */
262     for ( i = 0x30; i &lt;= 0x39; i++ )
263     {
264       FT_UInt  gindex = FT_Get_Char_Index( face, i );
265 
266 
267       if ( gindex != 0 &amp;&amp; gindex &lt; (FT_ULong)globals-&gt;glyph_count )
268         gstyles[gindex] |= AF_DIGIT;
269     }
270 
271   Exit:
272     /*
<span class="line-modified">273      *  By default, all uncovered glyphs are set to the fallback style.</span>
<span class="line-modified">274      *  XXX: Shouldn&#39;t we disable hinting or do something similar?</span>
275      */
276     if ( globals-&gt;module-&gt;fallback_style != AF_STYLE_UNASSIGNED )
277     {
278       FT_Long  nn;
279 
280 
281       for ( nn = 0; nn &lt; globals-&gt;glyph_count; nn++ )
282       {
283         if ( ( gstyles[nn] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
284         {
285           gstyles[nn] &amp;= ~AF_STYLE_MASK;
286           gstyles[nn] |= globals-&gt;module-&gt;fallback_style;
287         }
288       }
289     }
290 
291 #ifdef FT_DEBUG_LEVEL_TRACE
292 
293     FT_TRACE4(( &quot;\n&quot;
294                 &quot;style coverage\n&quot;
295                 &quot;==============\n&quot;
296                 &quot;\n&quot; ));
297 
<span class="line-modified">298     for ( ss = 0; AF_STYLE_CLASSES_GET[ss]; ss++ )</span>
299     {
<span class="line-modified">300       AF_StyleClass  style_class = AF_STYLE_CLASSES_GET[ss];</span>
301       FT_UInt        count       = 0;
302       FT_Long        idx;
303 
304 
305       FT_TRACE4(( &quot;%s:\n&quot;, af_style_names[style_class-&gt;style] ));
306 
307       for ( idx = 0; idx &lt; globals-&gt;glyph_count; idx++ )
308       {
309         if ( ( gstyles[idx] &amp; AF_STYLE_MASK ) == style_class-&gt;style )
310         {
311           if ( !( count % 10 ) )
312             FT_TRACE4(( &quot; &quot; ));
313 
314           FT_TRACE4(( &quot; %d&quot;, idx ));
315           count++;
316 
317           if ( !( count % 10 ) )
318             FT_TRACE4(( &quot;\n&quot; ));
319         }
320       }
</pre>
<hr />
<pre>
380   Exit:
381     *aglobals = globals;
382     return error;
383   }
384 
385 
386   FT_LOCAL_DEF( void )
387   af_face_globals_free( AF_FaceGlobals  globals )
388   {
389     if ( globals )
390     {
391       FT_Memory  memory = globals-&gt;face-&gt;memory;
392       FT_UInt    nn;
393 
394 
395       for ( nn = 0; nn &lt; AF_STYLE_MAX; nn++ )
396       {
397         if ( globals-&gt;metrics[nn] )
398         {
399           AF_StyleClass          style_class =
<span class="line-modified">400             AF_STYLE_CLASSES_GET[nn];</span>
401           AF_WritingSystemClass  writing_system_class =
<span class="line-modified">402             AF_WRITING_SYSTEM_CLASSES_GET[style_class-&gt;writing_system];</span>
403 
404 
405           if ( writing_system_class-&gt;style_metrics_done )
406             writing_system_class-&gt;style_metrics_done( globals-&gt;metrics[nn] );
407 
408           FT_FREE( globals-&gt;metrics[nn] );
409         }
410       }
411 
412 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
413       hb_font_destroy( globals-&gt;hb_font );
414       hb_buffer_destroy( globals-&gt;hb_buf );
415 #endif
416 
417       /* no need to free `globals-&gt;glyph_styles&#39;; */
418       /* it is part of the `globals&#39; array        */
419       FT_FREE( globals );
420     }
421   }
422 
</pre>
<hr />
<pre>
431 
432     AF_Style               style = (AF_Style)options;
433     AF_WritingSystemClass  writing_system_class;
434     AF_StyleClass          style_class;
435 
436     FT_Error  error = FT_Err_Ok;
437 
438 
439     if ( gindex &gt;= (FT_ULong)globals-&gt;glyph_count )
440     {
441       error = FT_THROW( Invalid_Argument );
442       goto Exit;
443     }
444 
445     /* if we have a forced style (via `options&#39;), use it, */
446     /* otherwise look into `glyph_styles&#39; array           */
447     if ( style == AF_STYLE_NONE_DFLT || style + 1 &gt;= AF_STYLE_MAX )
448       style = (AF_Style)( globals-&gt;glyph_styles[gindex] &amp;
449                           AF_STYLE_UNASSIGNED           );
450 
<span class="line-modified">451     style_class          = AF_STYLE_CLASSES_GET[style];</span>
<span class="line-modified">452     writing_system_class = AF_WRITING_SYSTEM_CLASSES_GET</span>

453                              [style_class-&gt;writing_system];
454 
455     metrics = globals-&gt;metrics[style];
456     if ( !metrics )
457     {
458       /* create the global metrics object if necessary */
459       FT_Memory  memory = globals-&gt;face-&gt;memory;
460 
461 
462       if ( FT_ALLOC( metrics, writing_system_class-&gt;style_metrics_size ) )
463         goto Exit;
464 
465       metrics-&gt;style_class = style_class;
466       metrics-&gt;globals     = globals;
467 
468       if ( writing_system_class-&gt;style_metrics_init )
469       {
470         error = writing_system_class-&gt;style_metrics_init( metrics,
471                                                           globals-&gt;face );
472         if ( error )
473         {
474           if ( writing_system_class-&gt;style_metrics_done )
475             writing_system_class-&gt;style_metrics_done( metrics );
476 
477           FT_FREE( metrics );










478           goto Exit;
479         }
480       }
481 
482       globals-&gt;metrics[style] = metrics;
483     }
484 
485   Exit:
486     *ametrics = metrics;
487 
488     return error;
489   }
490 
491 
492   FT_LOCAL_DEF( FT_Bool )
493   af_face_globals_is_digit( AF_FaceGlobals  globals,
494                             FT_UInt         gindex )
495   {
496     if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count )
<span class="line-modified">497       return (FT_Bool)( globals-&gt;glyph_styles[gindex] &amp; AF_DIGIT );</span>
498 
<span class="line-modified">499     return (FT_Bool)0;</span>
500   }
501 
502 
503 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * afglobal.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Auto-fitter routines to compute global hinting values (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &quot;afglobal.h&quot;
 20 #include &quot;afranges.h&quot;
 21 #include &quot;afshaper.h&quot;
 22 #include FT_INTERNAL_DEBUG_H
 23 
 24 
<span class="line-modified"> 25   /**************************************************************************</span>
<span class="line-modified"> 26    *</span>
<span class="line-modified"> 27    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 28    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 29    * messages during execution.</span>
<span class="line-modified"> 30    */</span>
 31 #undef  FT_COMPONENT
<span class="line-modified"> 32 #define FT_COMPONENT  afglobal</span>
 33 
 34 
 35   /* get writing system specific header files */
 36 #undef  WRITING_SYSTEM
 37 #define WRITING_SYSTEM( ws, WS )  /* empty */
 38 #include &quot;afwrtsys.h&quot;
 39 
 40 #include &quot;aferrors.h&quot;

 41 
 42 
 43 #undef  SCRIPT
 44 #define SCRIPT( s, S, d, h, H, ss )         \
 45           AF_DEFINE_SCRIPT_CLASS(           \
 46             af_ ## s ## _script_class,      \
 47             AF_SCRIPT_ ## S,                \
 48             af_ ## s ## _uniranges,         \
 49             af_ ## s ## _nonbase_uniranges, \
 50             AF_ ## H,                       \
 51             ss )
 52 
 53 #include &quot;afscript.h&quot;
 54 
 55 
 56 #undef  STYLE
 57 #define STYLE( s, S, d, ws, sc, ss, c )  \
 58           AF_DEFINE_STYLE_CLASS(         \
 59             af_ ## s ## _style_class,    \
 60             AF_STYLE_ ## S,              \
 61             ws,                          \
 62             sc,                          \
 63             ss,                          \
 64             c )
 65 
 66 #include &quot;afstyles.h&quot;
 67 
 68 


 69 #undef  WRITING_SYSTEM
 70 #define WRITING_SYSTEM( ws, WS )               \
 71           &amp;af_ ## ws ## _writing_system_class,
 72 
 73   FT_LOCAL_ARRAY_DEF( AF_WritingSystemClass )
 74   af_writing_system_classes[] =
 75   {
 76 
 77 #include &quot;afwrtsys.h&quot;
 78 
 79     NULL  /* do not remove */
 80   };
 81 
 82 
 83 #undef  SCRIPT
 84 #define SCRIPT( s, S, d, h, H, ss )   \
 85           &amp;af_ ## s ## _script_class,
 86 
 87   FT_LOCAL_ARRAY_DEF( AF_ScriptClass )
 88   af_script_classes[] =
</pre>
<hr />
<pre>
 90 
 91 #include &quot;afscript.h&quot;
 92 
 93     NULL  /* do not remove */
 94   };
 95 
 96 
 97 #undef  STYLE
 98 #define STYLE( s, S, d, ws, sc, ss, c ) \
 99           &amp;af_ ## s ## _style_class,
100 
101   FT_LOCAL_ARRAY_DEF( AF_StyleClass )
102   af_style_classes[] =
103   {
104 
105 #include &quot;afstyles.h&quot;
106 
107     NULL  /* do not remove */
108   };
109 


110 
111 #ifdef FT_DEBUG_LEVEL_TRACE
112 
113 #undef  STYLE
114 #define STYLE( s, S, d, ws, sc, ss, c )  #s,
115 
116   FT_LOCAL_ARRAY_DEF( char* )
117   af_style_names[] =
118   {
119 
120 #include &quot;afstyles.h&quot;
121 
122   };
123 
124 #endif /* FT_DEBUG_LEVEL_TRACE */
125 
126 
127   /* Compute the style index of each glyph within a given face. */
128 
129   static FT_Error
</pre>
<hr />
<pre>
137     FT_UInt     i;
138     FT_UInt     dflt        = ~0U; /* a non-valid value */
139 
140 
141     /* the value AF_STYLE_UNASSIGNED means `uncovered glyph&#39; */
142     for ( i = 0; i &lt; (FT_UInt)globals-&gt;glyph_count; i++ )
143       gstyles[i] = AF_STYLE_UNASSIGNED;
144 
145     error = FT_Select_Charmap( face, FT_ENCODING_UNICODE );
146     if ( error )
147     {
148       /*
149        * Ignore this error; we simply use the fallback style.
150        * XXX: Shouldn&#39;t we rather disable hinting?
151        */
152       error = FT_Err_Ok;
153       goto Exit;
154     }
155 
156     /* scan each style in a Unicode charmap */
<span class="line-modified">157     for ( ss = 0; af_style_classes[ss]; ss++ )</span>
158     {
159       AF_StyleClass       style_class =
<span class="line-modified">160                             af_style_classes[ss];</span>
161       AF_ScriptClass      script_class =
<span class="line-modified">162                             af_script_classes[style_class-&gt;script];</span>
163       AF_Script_UniRange  range;
164 
165 
166       if ( !script_class-&gt;script_uni_ranges )
167         continue;
168 
169       /*
<span class="line-modified">170        * Scan all Unicode points in the range and set the corresponding</span>
<span class="line-modified">171        * glyph style index.</span>
172        */
173       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
174       {
175         if ( (FT_UInt)style_class-&gt;script ==
176              globals-&gt;module-&gt;default_script )
177           dflt = ss;
178 
179         for ( range = script_class-&gt;script_uni_ranges;
180               range-&gt;first != 0;
181               range++ )
182         {
183           FT_ULong  charcode = range-&gt;first;
184           FT_UInt   gindex;
185 
186 
187           gindex = FT_Get_Char_Index( face, charcode );
188 
189           if ( gindex != 0                                                &amp;&amp;
190                gindex &lt; (FT_ULong)globals-&gt;glyph_count                    &amp;&amp;
191                ( gstyles[gindex] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
</pre>
<hr />
<pre>
224           {
225             charcode = FT_Get_Next_Char( face, charcode, &amp;gindex );
226 
227             if ( gindex == 0 || charcode &gt; range-&gt;last )
228               break;
229 
230             if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count              &amp;&amp;
231                  ( gstyles[gindex] &amp; AF_STYLE_MASK ) == (FT_UShort)ss )
232               gstyles[gindex] |= AF_NONBASE;
233           }
234         }
235       }
236       else
237       {
238         /* get glyphs not directly addressable by cmap */
239         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
240       }
241     }
242 
243     /* handle the remaining default OpenType features ... */
<span class="line-modified">244     for ( ss = 0; af_style_classes[ss]; ss++ )</span>
245     {
<span class="line-modified">246       AF_StyleClass  style_class = af_style_classes[ss];</span>
247 
248 
249       if ( style_class-&gt;coverage == AF_COVERAGE_DEFAULT )
250         af_shaper_get_coverage( globals, style_class, gstyles, 0 );
251     }
252 
253     /* ... and finally the default OpenType features of the default script */
<span class="line-modified">254     af_shaper_get_coverage( globals, af_style_classes[dflt], gstyles, 1 );</span>
255 
256     /* mark ASCII digits */
257     for ( i = 0x30; i &lt;= 0x39; i++ )
258     {
259       FT_UInt  gindex = FT_Get_Char_Index( face, i );
260 
261 
262       if ( gindex != 0 &amp;&amp; gindex &lt; (FT_ULong)globals-&gt;glyph_count )
263         gstyles[gindex] |= AF_DIGIT;
264     }
265 
266   Exit:
267     /*
<span class="line-modified">268      * By default, all uncovered glyphs are set to the fallback style.</span>
<span class="line-modified">269      * XXX: Shouldn&#39;t we disable hinting or do something similar?</span>
270      */
271     if ( globals-&gt;module-&gt;fallback_style != AF_STYLE_UNASSIGNED )
272     {
273       FT_Long  nn;
274 
275 
276       for ( nn = 0; nn &lt; globals-&gt;glyph_count; nn++ )
277       {
278         if ( ( gstyles[nn] &amp; AF_STYLE_MASK ) == AF_STYLE_UNASSIGNED )
279         {
280           gstyles[nn] &amp;= ~AF_STYLE_MASK;
281           gstyles[nn] |= globals-&gt;module-&gt;fallback_style;
282         }
283       }
284     }
285 
286 #ifdef FT_DEBUG_LEVEL_TRACE
287 
288     FT_TRACE4(( &quot;\n&quot;
289                 &quot;style coverage\n&quot;
290                 &quot;==============\n&quot;
291                 &quot;\n&quot; ));
292 
<span class="line-modified">293     for ( ss = 0; af_style_classes[ss]; ss++ )</span>
294     {
<span class="line-modified">295       AF_StyleClass  style_class = af_style_classes[ss];</span>
296       FT_UInt        count       = 0;
297       FT_Long        idx;
298 
299 
300       FT_TRACE4(( &quot;%s:\n&quot;, af_style_names[style_class-&gt;style] ));
301 
302       for ( idx = 0; idx &lt; globals-&gt;glyph_count; idx++ )
303       {
304         if ( ( gstyles[idx] &amp; AF_STYLE_MASK ) == style_class-&gt;style )
305         {
306           if ( !( count % 10 ) )
307             FT_TRACE4(( &quot; &quot; ));
308 
309           FT_TRACE4(( &quot; %d&quot;, idx ));
310           count++;
311 
312           if ( !( count % 10 ) )
313             FT_TRACE4(( &quot;\n&quot; ));
314         }
315       }
</pre>
<hr />
<pre>
375   Exit:
376     *aglobals = globals;
377     return error;
378   }
379 
380 
381   FT_LOCAL_DEF( void )
382   af_face_globals_free( AF_FaceGlobals  globals )
383   {
384     if ( globals )
385     {
386       FT_Memory  memory = globals-&gt;face-&gt;memory;
387       FT_UInt    nn;
388 
389 
390       for ( nn = 0; nn &lt; AF_STYLE_MAX; nn++ )
391       {
392         if ( globals-&gt;metrics[nn] )
393         {
394           AF_StyleClass          style_class =
<span class="line-modified">395             af_style_classes[nn];</span>
396           AF_WritingSystemClass  writing_system_class =
<span class="line-modified">397             af_writing_system_classes[style_class-&gt;writing_system];</span>
398 
399 
400           if ( writing_system_class-&gt;style_metrics_done )
401             writing_system_class-&gt;style_metrics_done( globals-&gt;metrics[nn] );
402 
403           FT_FREE( globals-&gt;metrics[nn] );
404         }
405       }
406 
407 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
408       hb_font_destroy( globals-&gt;hb_font );
409       hb_buffer_destroy( globals-&gt;hb_buf );
410 #endif
411 
412       /* no need to free `globals-&gt;glyph_styles&#39;; */
413       /* it is part of the `globals&#39; array        */
414       FT_FREE( globals );
415     }
416   }
417 
</pre>
<hr />
<pre>
426 
427     AF_Style               style = (AF_Style)options;
428     AF_WritingSystemClass  writing_system_class;
429     AF_StyleClass          style_class;
430 
431     FT_Error  error = FT_Err_Ok;
432 
433 
434     if ( gindex &gt;= (FT_ULong)globals-&gt;glyph_count )
435     {
436       error = FT_THROW( Invalid_Argument );
437       goto Exit;
438     }
439 
440     /* if we have a forced style (via `options&#39;), use it, */
441     /* otherwise look into `glyph_styles&#39; array           */
442     if ( style == AF_STYLE_NONE_DFLT || style + 1 &gt;= AF_STYLE_MAX )
443       style = (AF_Style)( globals-&gt;glyph_styles[gindex] &amp;
444                           AF_STYLE_UNASSIGNED           );
445 
<span class="line-modified">446   Again:</span>
<span class="line-modified">447     style_class          = af_style_classes[style];</span>
<span class="line-added">448     writing_system_class = af_writing_system_classes</span>
449                              [style_class-&gt;writing_system];
450 
451     metrics = globals-&gt;metrics[style];
452     if ( !metrics )
453     {
454       /* create the global metrics object if necessary */
455       FT_Memory  memory = globals-&gt;face-&gt;memory;
456 
457 
458       if ( FT_ALLOC( metrics, writing_system_class-&gt;style_metrics_size ) )
459         goto Exit;
460 
461       metrics-&gt;style_class = style_class;
462       metrics-&gt;globals     = globals;
463 
464       if ( writing_system_class-&gt;style_metrics_init )
465       {
466         error = writing_system_class-&gt;style_metrics_init( metrics,
467                                                           globals-&gt;face );
468         if ( error )
469         {
470           if ( writing_system_class-&gt;style_metrics_done )
471             writing_system_class-&gt;style_metrics_done( metrics );
472 
473           FT_FREE( metrics );
<span class="line-added">474 </span>
<span class="line-added">475           /* internal error code -1 indicates   */</span>
<span class="line-added">476           /* that no blue zones have been found */</span>
<span class="line-added">477           if ( error == -1 )</span>
<span class="line-added">478           {</span>
<span class="line-added">479             style = (AF_Style)( globals-&gt;glyph_styles[gindex] &amp;</span>
<span class="line-added">480                                 AF_STYLE_UNASSIGNED           );</span>
<span class="line-added">481             goto Again;</span>
<span class="line-added">482           }</span>
<span class="line-added">483 </span>
484           goto Exit;
485         }
486       }
487 
488       globals-&gt;metrics[style] = metrics;
489     }
490 
491   Exit:
492     *ametrics = metrics;
493 
494     return error;
495   }
496 
497 
498   FT_LOCAL_DEF( FT_Bool )
499   af_face_globals_is_digit( AF_FaceGlobals  globals,
500                             FT_UInt         gindex )
501   {
502     if ( gindex &lt; (FT_ULong)globals-&gt;glyph_count )
<span class="line-modified">503       return FT_BOOL( globals-&gt;glyph_styles[gindex] &amp; AF_DIGIT );</span>
504 
<span class="line-modified">505     return FT_BOOL( 0 );</span>
506   }
507 
508 
509 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="aferrors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afglobal.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/type1/t1gload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  t1gload.c                                                              */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Type 1 Glyph Loader (body).                                          */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include &quot;t1gload.h&quot;
 21 #include FT_INTERNAL_CALC_H
 22 #include FT_INTERNAL_DEBUG_H
 23 #include FT_INTERNAL_STREAM_H
 24 #include FT_OUTLINE_H
 25 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 26 #include FT_INTERNAL_CFF_TYPES_H
 27 #include FT_DRIVER_H
 28 
 29 #include &quot;t1errors.h&quot;
 30 
 31 
<a name="2" id="anc2"></a><span class="line-modified"> 32   /*************************************************************************/</span>
<span class="line-modified"> 33   /*                                                                       */</span>
<span class="line-modified"> 34   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 35   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 36   /* messages during execution.                                            */</span>
<span class="line-modified"> 37   /*                                                                       */</span>
 38 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 39 #define FT_COMPONENT  trace_t1gload</span>
 40 
 41 
 42   static FT_Error
 43   T1_Parse_Glyph_And_Get_Char_String( T1_Decoder  decoder,
 44                                       FT_UInt     glyph_index,
 45                                       FT_Data*    char_string,
 46                                       FT_Bool*    force_scaling )
 47   {
 48     T1_Face   face  = (T1_Face)decoder-&gt;builder.face;
 49     T1_Font   type1 = &amp;face-&gt;type1;
 50     FT_Error  error = FT_Err_Ok;
 51 
 52     PSAux_Service           psaux         = (PSAux_Service)face-&gt;psaux;
 53     const T1_Decoder_Funcs  decoder_funcs = psaux-&gt;t1_decoder_funcs;
 54     PS_Decoder              psdecoder;
 55 
 56 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 57     FT_Incremental_InterfaceRec *inc =
 58                       face-&gt;root.internal-&gt;incremental_interface;
 59 #endif
 60 
 61 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 62     PS_Driver  driver = (PS_Driver)FT_FACE_DRIVER( face );
 63 #endif
 64 
<a name="4" id="anc4"></a>
 65     decoder-&gt;font_matrix = type1-&gt;font_matrix;
 66     decoder-&gt;font_offset = type1-&gt;font_offset;
 67 
 68 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 69 
 70     /* For incremental fonts get the character data using the */
 71     /* callback function.                                     */
 72     if ( inc )
 73       error = inc-&gt;funcs-&gt;get_glyph_data( inc-&gt;object,
 74                                           glyph_index, char_string );
 75     else
 76 
 77 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 78 
 79     /* For ordinary fonts get the character data stored in the face record. */
 80     {
 81       char_string-&gt;pointer = type1-&gt;charstrings[glyph_index];
 82       char_string-&gt;length  = (FT_Int)type1-&gt;charstrings_len[glyph_index];
 83     }
 84 
 85     if ( !error )
 86     {
 87       /* choose which renderer to use */
 88 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 89       if ( driver-&gt;hinting_engine == FT_HINTING_FREETYPE ||
 90            decoder-&gt;builder.metrics_only                 )
 91         error = decoder_funcs-&gt;parse_charstrings_old(
 92                   decoder,
 93                   (FT_Byte*)char_string-&gt;pointer,
 94                   (FT_UInt)char_string-&gt;length );
 95 #else
 96       if ( decoder-&gt;builder.metrics_only )
 97         error = decoder_funcs-&gt;parse_metrics(
 98                   decoder,
 99                   (FT_Byte*)char_string-&gt;pointer,
100                   (FT_UInt)char_string-&gt;length );
101 #endif
102       else
103       {
104         CFF_SubFontRec  subfont;
105 
106 
107         psaux-&gt;ps_decoder_init( &amp;psdecoder, decoder, TRUE );
108 
109         psaux-&gt;t1_make_subfont( FT_FACE( face ),
110                                 &amp;face-&gt;type1.private_dict, &amp;subfont );
111         psdecoder.current_subfont = &amp;subfont;
112 
113         error = decoder_funcs-&gt;parse_charstrings(
114                   &amp;psdecoder,
115                   (FT_Byte*)char_string-&gt;pointer,
116                   (FT_ULong)char_string-&gt;length );
117 
118         /* Adobe&#39;s engine uses 16.16 numbers everywhere;              */
119         /* as a consequence, glyphs larger than 2000ppem get rejected */
120         if ( FT_ERR_EQ( error, Glyph_Too_Big ) )
121         {
122           /* this time, we retry unhinted and scale up the glyph later on */
123           /* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
124           /* 0x400 for both `x_scale&#39; and `y_scale&#39; in this case)         */
125           ((T1_GlyphSlot)decoder-&gt;builder.glyph)-&gt;hint = FALSE;
126 
127           *force_scaling = TRUE;
128 
129           error = decoder_funcs-&gt;parse_charstrings(
130                     &amp;psdecoder,
131                     (FT_Byte*)char_string-&gt;pointer,
132                     (FT_ULong)char_string-&gt;length );
133         }
134       }
135     }
136 
137 #ifdef FT_CONFIG_OPTION_INCREMENTAL
138 
139     /* Incremental fonts can optionally override the metrics. */
140     if ( !error &amp;&amp; inc &amp;&amp; inc-&gt;funcs-&gt;get_glyph_metrics )
141     {
142       FT_Incremental_MetricsRec  metrics;
143 
144 
145       metrics.bearing_x = FIXED_TO_INT( decoder-&gt;builder.left_bearing.x );
146       metrics.bearing_y = 0;
147       metrics.advance   = FIXED_TO_INT( decoder-&gt;builder.advance.x );
148       metrics.advance_v = FIXED_TO_INT( decoder-&gt;builder.advance.y );
149 
150       error = inc-&gt;funcs-&gt;get_glyph_metrics( inc-&gt;object,
151                                              glyph_index, FALSE, &amp;metrics );
152 
153       decoder-&gt;builder.left_bearing.x = INT_TO_FIXED( metrics.bearing_x );
154       decoder-&gt;builder.advance.x      = INT_TO_FIXED( metrics.advance );
155       decoder-&gt;builder.advance.y      = INT_TO_FIXED( metrics.advance_v );
156     }
157 
158 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
159 
160     return error;
161   }
162 
163 
164   FT_CALLBACK_DEF( FT_Error )
165   T1_Parse_Glyph( T1_Decoder  decoder,
166                   FT_UInt     glyph_index )
167   {
168     FT_Data   glyph_data;
169     FT_Bool   force_scaling = FALSE;
170     FT_Error  error         = T1_Parse_Glyph_And_Get_Char_String(
171                                 decoder, glyph_index, &amp;glyph_data,
172                                 &amp;force_scaling );
173 
174 
175 #ifdef FT_CONFIG_OPTION_INCREMENTAL
176 
177     if ( !error )
178     {
179       T1_Face  face = (T1_Face)decoder-&gt;builder.face;
180 
181 
182       if ( face-&gt;root.internal-&gt;incremental_interface )
183         face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;free_glyph_data(
184           face-&gt;root.internal-&gt;incremental_interface-&gt;object,
185           &amp;glyph_data );
186     }
187 
188 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
189 
190     return error;
191   }
192 
193 
194   /*************************************************************************/
195   /*************************************************************************/
196   /*************************************************************************/
197   /**********                                                      *********/
198   /**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
199   /**********                                                      *********/
200   /**********    The following code is in charge of computing      *********/
201   /**********    the maximum advance width of the font.  It        *********/
202   /**********    quickly processes each glyph charstring to        *********/
203   /**********    extract the value from either a `sbw&#39; or `seac&#39;   *********/
204   /**********    operator.                                         *********/
205   /**********                                                      *********/
206   /*************************************************************************/
207   /*************************************************************************/
208   /*************************************************************************/
209 
210 
211   FT_LOCAL_DEF( FT_Error )
212   T1_Compute_Max_Advance( T1_Face  face,
213                           FT_Pos*  max_advance )
214   {
215     FT_Error       error;
216     T1_DecoderRec  decoder;
217     FT_Int         glyph_index;
218     T1_Font        type1 = &amp;face-&gt;type1;
219     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
220 
221 
222     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
223 
224     *max_advance = 0;
225 
226     /* initialize load decoder */
227     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
228                                            (FT_Face)face,
229                                            0, /* size       */
230                                            0, /* glyph slot */
231                                            (FT_Byte**)type1-&gt;glyph_names,
232                                            face-&gt;blend,
233                                            0,
234                                            FT_RENDER_MODE_NORMAL,
235                                            T1_Parse_Glyph );
236     if ( error )
237       return error;
238 
239     decoder.builder.metrics_only = 1;
240     decoder.builder.load_points  = 0;
241 
242     decoder.num_subrs     = type1-&gt;num_subrs;
243     decoder.subrs         = type1-&gt;subrs;
244     decoder.subrs_len     = type1-&gt;subrs_len;
245     decoder.subrs_hash    = type1-&gt;subrs_hash;
246 
247     decoder.buildchar     = face-&gt;buildchar;
248     decoder.len_buildchar = face-&gt;len_buildchar;
249 
250     *max_advance = 0;
251 
<a name="5" id="anc5"></a>

252     /* for each glyph, parse the glyph charstring and extract */
253     /* the advance width                                      */
254     for ( glyph_index = 0; glyph_index &lt; type1-&gt;num_glyphs; glyph_index++ )
255     {
256       /* now get load the unscaled outline */
257       (void)T1_Parse_Glyph( &amp;decoder, (FT_UInt)glyph_index );
258       if ( glyph_index == 0 || decoder.builder.advance.x &gt; *max_advance )
259         *max_advance = decoder.builder.advance.x;
260 
261       /* ignore the error if one occurred - skip to next glyph */
262     }
263 
<a name="6" id="anc6"></a>


264     psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
265 
266     return FT_Err_Ok;
267   }
268 
269 
270   FT_LOCAL_DEF( FT_Error )
271   T1_Get_Advances( FT_Face    t1face,        /* T1_Face */
272                    FT_UInt    first,
273                    FT_UInt    count,
274                    FT_Int32   load_flags,
275                    FT_Fixed*  advances )
276   {
277     T1_Face        face  = (T1_Face)t1face;
278     T1_DecoderRec  decoder;
279     T1_Font        type1 = &amp;face-&gt;type1;
280     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
281     FT_UInt        nn;
282     FT_Error       error;
283 
284 
<a name="7" id="anc7"></a>

285     if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
286     {
287       for ( nn = 0; nn &lt; count; nn++ )
<a name="8" id="anc8"></a>
288         advances[nn] = 0;
289 
<a name="9" id="anc9"></a>



290       return FT_Err_Ok;
291     }
292 
293     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
294                                            (FT_Face)face,
295                                            0, /* size       */
296                                            0, /* glyph slot */
297                                            (FT_Byte**)type1-&gt;glyph_names,
298                                            face-&gt;blend,
299                                            0,
300                                            FT_RENDER_MODE_NORMAL,
301                                            T1_Parse_Glyph );
302     if ( error )
303       return error;
304 
305     decoder.builder.metrics_only = 1;
306     decoder.builder.load_points  = 0;
307 
308     decoder.num_subrs  = type1-&gt;num_subrs;
309     decoder.subrs      = type1-&gt;subrs;
310     decoder.subrs_len  = type1-&gt;subrs_len;
311     decoder.subrs_hash = type1-&gt;subrs_hash;
312 
313     decoder.buildchar     = face-&gt;buildchar;
314     decoder.len_buildchar = face-&gt;len_buildchar;
315 
316     for ( nn = 0; nn &lt; count; nn++ )
317     {
318       error = T1_Parse_Glyph( &amp;decoder, first + nn );
319       if ( !error )
320         advances[nn] = FIXED_TO_INT( decoder.builder.advance.x );
321       else
322         advances[nn] = 0;
<a name="10" id="anc10"></a>




323     }
324 
325     return FT_Err_Ok;
326   }
327 
328 
329   FT_LOCAL_DEF( FT_Error )
330   T1_Load_Glyph( FT_GlyphSlot  t1glyph,          /* T1_GlyphSlot */
331                  FT_Size       t1size,           /* T1_Size      */
332                  FT_UInt       glyph_index,
333                  FT_Int32      load_flags )
334   {
335     T1_GlyphSlot            glyph = (T1_GlyphSlot)t1glyph;
336     FT_Error                error;
337     T1_DecoderRec           decoder;
338     T1_Face                 face = (T1_Face)t1glyph-&gt;face;
339     FT_Bool                 hinting;
340     FT_Bool                 scaled;
341     FT_Bool                 force_scaling = FALSE;
342     T1_Font                 type1         = &amp;face-&gt;type1;
343     PSAux_Service           psaux         = (PSAux_Service)face-&gt;psaux;
344     const T1_Decoder_Funcs  decoder_funcs = psaux-&gt;t1_decoder_funcs;
345 
346     FT_Matrix               font_matrix;
347     FT_Vector               font_offset;
348     FT_Data                 glyph_data;
349     FT_Bool                 must_finish_decoder = FALSE;
350 #ifdef FT_CONFIG_OPTION_INCREMENTAL
351     FT_Bool                 glyph_data_loaded = 0;
352 #endif
353 
354 
355 #ifdef FT_CONFIG_OPTION_INCREMENTAL
356     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs &amp;&amp;
357          !face-&gt;root.internal-&gt;incremental_interface   )
358 #else
359     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs )
360 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
361     {
362       error = FT_THROW( Invalid_Argument );
363       goto Exit;
364     }
365 
366     FT_TRACE1(( &quot;T1_Load_Glyph: glyph index %d\n&quot;, glyph_index ));
367 
368     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
369 
370     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
371       load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
372 
373     if ( t1size )
374     {
375       glyph-&gt;x_scale = t1size-&gt;metrics.x_scale;
376       glyph-&gt;y_scale = t1size-&gt;metrics.y_scale;
377     }
378     else
379     {
380       glyph-&gt;x_scale = 0x10000L;
381       glyph-&gt;y_scale = 0x10000L;
382     }
383 
384     t1glyph-&gt;outline.n_points   = 0;
385     t1glyph-&gt;outline.n_contours = 0;
386 
<a name="11" id="anc11"></a><span class="line-modified">387     hinting = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 &amp;&amp;</span>
<span class="line-modified">388                        ( load_flags &amp; FT_LOAD_NO_HINTING ) == 0 );</span>
<span class="line-modified">389     scaled  = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 );</span>
390 
391     glyph-&gt;hint     = hinting;
392     glyph-&gt;scaled   = scaled;
393     t1glyph-&gt;format = FT_GLYPH_FORMAT_OUTLINE;
394 
395     error = decoder_funcs-&gt;init( &amp;decoder,
396                                  t1glyph-&gt;face,
397                                  t1size,
398                                  t1glyph,
399                                  (FT_Byte**)type1-&gt;glyph_names,
400                                  face-&gt;blend,
<a name="12" id="anc12"></a><span class="line-modified">401                                  FT_BOOL( hinting ),</span>
402                                  FT_LOAD_TARGET_MODE( load_flags ),
403                                  T1_Parse_Glyph );
404     if ( error )
405       goto Exit;
406 
407     must_finish_decoder = TRUE;
408 
<a name="13" id="anc13"></a><span class="line-modified">409     decoder.builder.no_recurse = FT_BOOL(</span>
<span class="line-removed">410                                    ( load_flags &amp; FT_LOAD_NO_RECURSE ) != 0 );</span>
411 
412     decoder.num_subrs     = type1-&gt;num_subrs;
413     decoder.subrs         = type1-&gt;subrs;
414     decoder.subrs_len     = type1-&gt;subrs_len;
415     decoder.subrs_hash    = type1-&gt;subrs_hash;
416 
417     decoder.buildchar     = face-&gt;buildchar;
418     decoder.len_buildchar = face-&gt;len_buildchar;
419 
420     /* now load the unscaled outline */
421     error = T1_Parse_Glyph_And_Get_Char_String( &amp;decoder, glyph_index,
422                                                 &amp;glyph_data,
423                                                 &amp;force_scaling );
424     if ( error )
425       goto Exit;
426 #ifdef FT_CONFIG_OPTION_INCREMENTAL
427     glyph_data_loaded = 1;
428 #endif
429 
430     hinting     = glyph-&gt;hint;
431     font_matrix = decoder.font_matrix;
432     font_offset = decoder.font_offset;
433 
434     /* save new glyph tables */
435     decoder_funcs-&gt;done( &amp;decoder );
436 
437     must_finish_decoder = FALSE;
438 
439     /* now, set the metrics -- this is rather simple, as   */
440     /* the left side bearing is the xMin, and the top side */
441     /* bearing the yMax                                    */
442     if ( !error )
443     {
444       t1glyph-&gt;outline.flags &amp;= FT_OUTLINE_OWNER;
445       t1glyph-&gt;outline.flags |= FT_OUTLINE_REVERSE_FILL;
446 
447       /* for composite glyphs, return only left side bearing and */
448       /* advance width                                           */
449       if ( load_flags &amp; FT_LOAD_NO_RECURSE )
450       {
451         FT_Slot_Internal  internal = t1glyph-&gt;internal;
452 
453 
454         t1glyph-&gt;metrics.horiBearingX =
455           FIXED_TO_INT( decoder.builder.left_bearing.x );
456         t1glyph-&gt;metrics.horiAdvance  =
457           FIXED_TO_INT( decoder.builder.advance.x );
458 
459         internal-&gt;glyph_matrix      = font_matrix;
460         internal-&gt;glyph_delta       = font_offset;
461         internal-&gt;glyph_transformed = 1;
462       }
463       else
464       {
465         FT_BBox            cbox;
466         FT_Glyph_Metrics*  metrics = &amp;t1glyph-&gt;metrics;
467 
468 
469         /* copy the _unscaled_ advance width */
470         metrics-&gt;horiAdvance =
471           FIXED_TO_INT( decoder.builder.advance.x );
472         t1glyph-&gt;linearHoriAdvance =
473           FIXED_TO_INT( decoder.builder.advance.x );
474         t1glyph-&gt;internal-&gt;glyph_transformed = 0;
475 
476         if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
477         {
478           /* make up vertical ones */
479           metrics-&gt;vertAdvance = ( face-&gt;type1.font_bbox.yMax -
480                                    face-&gt;type1.font_bbox.yMin ) &gt;&gt; 16;
481           t1glyph-&gt;linearVertAdvance = metrics-&gt;vertAdvance;
482         }
483         else
484         {
485           metrics-&gt;vertAdvance =
486             FIXED_TO_INT( decoder.builder.advance.y );
487           t1glyph-&gt;linearVertAdvance =
488             FIXED_TO_INT( decoder.builder.advance.y );
489         }
490 
491         t1glyph-&gt;format = FT_GLYPH_FORMAT_OUTLINE;
492 
493         if ( t1size &amp;&amp; t1size-&gt;metrics.y_ppem &lt; 24 )
494           t1glyph-&gt;outline.flags |= FT_OUTLINE_HIGH_PRECISION;
495 
496 #if 1
497         /* apply the font matrix, if any */
498         if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
499              font_matrix.xy != 0        || font_matrix.yx != 0        )
500         {
501           FT_Outline_Transform( &amp;t1glyph-&gt;outline, &amp;font_matrix );
502 
503           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance,
504                                             font_matrix.xx );
505           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance,
506                                             font_matrix.yy );
507         }
508 
509         if ( font_offset.x || font_offset.y )
510         {
511           FT_Outline_Translate( &amp;t1glyph-&gt;outline,
512                                 font_offset.x,
513                                 font_offset.y );
514 
515           metrics-&gt;horiAdvance += font_offset.x;
516           metrics-&gt;vertAdvance += font_offset.y;
517         }
518 #endif
519 
520         if ( ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0 || force_scaling )
521         {
522           /* scale the outline and the metrics */
523           FT_Int       n;
524           FT_Outline*  cur = decoder.builder.base;
525           FT_Vector*   vec = cur-&gt;points;
526           FT_Fixed     x_scale = glyph-&gt;x_scale;
527           FT_Fixed     y_scale = glyph-&gt;y_scale;
528 
529 
530           /* First of all, scale the points, if we are not hinting */
<a name="14" id="anc14"></a><span class="line-modified">531           if ( !hinting || ! decoder.builder.hints_funcs )</span>
532             for ( n = cur-&gt;n_points; n &gt; 0; n--, vec++ )
533             {
534               vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );
535               vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );
536             }
537 
538           /* Then scale the metrics */
539           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance, x_scale );
540           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance, y_scale );
541         }
542 
543         /* compute the other metrics */
544         FT_Outline_Get_CBox( &amp;t1glyph-&gt;outline, &amp;cbox );
545 
546         metrics-&gt;width  = cbox.xMax - cbox.xMin;
547         metrics-&gt;height = cbox.yMax - cbox.yMin;
548 
549         metrics-&gt;horiBearingX = cbox.xMin;
550         metrics-&gt;horiBearingY = cbox.yMax;
551 
552         if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
553         {
554           /* make up vertical ones */
555           ft_synthesize_vertical_metrics( metrics,
556                                           metrics-&gt;vertAdvance );
557         }
558       }
559 
560       /* Set control data to the glyph charstrings.  Note that this is */
561       /* _not_ zero-terminated.                                        */
562       t1glyph-&gt;control_data = (FT_Byte*)glyph_data.pointer;
563       t1glyph-&gt;control_len  = glyph_data.length;
564     }
565 
566 
567   Exit:
568 
569 #ifdef FT_CONFIG_OPTION_INCREMENTAL
570     if ( glyph_data_loaded &amp;&amp; face-&gt;root.internal-&gt;incremental_interface )
571     {
572       face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;free_glyph_data(
573         face-&gt;root.internal-&gt;incremental_interface-&gt;object,
574         &amp;glyph_data );
575 
576       /* Set the control data to null - it is no longer available if   */
577       /* loaded incrementally.                                         */
578       t1glyph-&gt;control_data = NULL;
579       t1glyph-&gt;control_len  = 0;
580     }
581 #endif
582 
583     if ( must_finish_decoder )
584       decoder_funcs-&gt;done( &amp;decoder );
585 
586     return error;
587   }
588 
589 
590 /* END */
<a name="15" id="anc15"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="15" type="hidden" />
</body>
</html>
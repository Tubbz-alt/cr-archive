diff a/src/java.desktop/share/native/libfreetype/src/autofit/afloader.c b/src/java.desktop/share/native/libfreetype/src/autofit/afloader.c
--- a/src/java.desktop/share/native/libfreetype/src/autofit/afloader.c
+++ b/src/java.desktop/share/native/libfreetype/src/autofit/afloader.c
@@ -1,29 +1,28 @@
-/***************************************************************************/
-/*                                                                         */
-/*  afloader.c                                                             */
-/*                                                                         */
-/*    Auto-fitter glyph loading routines (body).                           */
-/*                                                                         */
-/*  Copyright 2003-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * afloader.c
+ *
+ *   Auto-fitter glyph loading routines (body).
+ *
+ * Copyright (C) 2003-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include "afglobal.h"
 #include "afloader.h"
 #include "afhints.h"
 #include "aferrors.h"
 #include "afmodule.h"
-#include "afpic.h"
 
 #include FT_INTERNAL_CALC_H
 
 
   /* Initialize glyph loader. */
@@ -117,16 +116,16 @@
       error = FT_ERR( Corrupted_Font_Header );
       goto Exit;
     }
 
     /*
-     *  We depend on the writing system (script analyzers) to supply
-     *  standard widths for the script of the glyph we are looking at.  If
-     *  it can't deliver, stem darkening is disabled.
+     * We depend on the writing system (script analyzers) to supply
+     * standard widths for the script of the glyph we are looking at.  If
+     * it can't deliver, stem darkening is disabled.
      */
     writing_system_class =
-      AF_WRITING_SYSTEM_CLASSES_GET[style_metrics->style_class->writing_system];
+      af_writing_system_classes[style_metrics->style_class->writing_system];
 
     if ( writing_system_class->style_metrics_getstdw )
       writing_system_class->style_metrics_getstdw( style_metrics,
                                                    &stdHW,
                                                    &stdVW );
@@ -172,26 +171,26 @@
       globals->standard_horizontal_width = stdHW;
       globals->stem_darkening_for_ppem   = size_metrics->x_ppem;
       globals->darken_y                  = af_fixedToInt( darken_y );
 
       /*
-       *  Scale outlines down on the Y-axis to keep them inside their blue
-       *  zones.  The stronger the emboldening, the stronger the downscaling
-       *  (plus heuristical padding to prevent outlines still falling out
-       *  their zones due to rounding).
+       * Scale outlines down on the Y-axis to keep them inside their blue
+       * zones.  The stronger the emboldening, the stronger the downscaling
+       * (plus heuristical padding to prevent outlines still falling out
+       * their zones due to rounding).
        *
-       *  Reason: `FT_Outline_Embolden' works by shifting the rightmost
-       *  points of stems farther to the right, and topmost points farther
-       *  up.  This positions points on the Y-axis outside their
-       *  pre-computed blue zones and leads to distortion when applying the
-       *  hints in the code further below.  Code outside this emboldening
-       *  block doesn't know we are presenting it with modified outlines the
-       *  analyzer didn't see!
+       * Reason: `FT_Outline_Embolden' works by shifting the rightmost
+       * points of stems farther to the right, and topmost points farther
+       * up.  This positions points on the Y-axis outside their
+       * pre-computed blue zones and leads to distortion when applying the
+       * hints in the code further below.  Code outside this emboldening
+       * block doesn't know we are presenting it with modified outlines the
+       * analyzer didn't see!
        *
-       *  An unfortunate side effect of downscaling is that the emboldening
-       *  effect is slightly decreased.  The loss becomes more pronounced
-       *  versus the CFF driver at smaller sizes, e.g., at 9ppem and below.
+       * An unfortunate side effect of downscaling is that the emboldening
+       * effect is slightly decreased.  The loss becomes more pronounced
+       * versus the CFF driver at smaller sizes, e.g., at 9ppem and below.
        */
       globals->scale_down_factor =
         FT_DivFix( em_size - ( darken_by_font_units_y + af_intToFixed( 8 ) ),
                    em_size );
     }
@@ -230,14 +229,10 @@
     AF_StyleMetrics        style_metrics;
     FT_UInt                style_options = AF_STYLE_NONE_DFLT;
     AF_StyleClass          style_class;
     AF_WritingSystemClass  writing_system_class;
 
-#ifdef FT_CONFIG_OPTION_PIC
-    AF_FaceGlobals  globals = loader->globals;
-#endif
-
 
     if ( !size )
       return FT_THROW( Invalid_Size_Handle );
 
     FT_ZERO( &scaler );
@@ -280,17 +275,17 @@
       }
 #endif /* AF_CONFIG_OPTION_TT_SIZE_METRICS */
     }
 
     /*
-     *  TODO: This code currently doesn't support fractional advance widths,
-     *  i.e., placing hinted glyphs at anything other than integer
-     *  x-positions.  This is only relevant for the warper code, which
-     *  scales and shifts glyphs to optimize blackness of stems (hinting on
-     *  the x-axis by nature places things on pixel integers, hinting on the
-     *  y-axis only, i.e., LIGHT mode, doesn't touch the x-axis).  The delta
-     *  values of the scaler would need to be adjusted.
+     * TODO: This code currently doesn't support fractional advance widths,
+     * i.e., placing hinted glyphs at anything other than integer
+     * x-positions.  This is only relevant for the warper code, which
+     * scales and shifts glyphs to optimize blackness of stems (hinting on
+     * the x-axis by nature places things on pixel integers, hinting on the
+     * y-axis only, i.e., LIGHT mode, doesn't touch the x-axis).  The delta
+     * values of the scaler would need to be adjusted.
      */
     scaler.face    = face;
     scaler.x_scale = size_internal->autohint_metrics.x_scale;
     scaler.x_delta = 0;
     scaler.y_scale = size_internal->autohint_metrics.y_scale;
@@ -310,23 +305,23 @@
     if ( load_flags & ( 1UL << 20 ) )
       style_options = AF_STYLE_LTN2_DFLT;
 #endif
 
     /*
-     *  Glyphs (really code points) are assigned to scripts.  Script
-     *  analysis is done lazily: For each glyph that passes through here,
-     *  the corresponding script analyzer is called, but returns immediately
-     *  if it has been run already.
+     * Glyphs (really code points) are assigned to scripts.  Script
+     * analysis is done lazily: For each glyph that passes through here,
+     * the corresponding script analyzer is called, but returns immediately
+     * if it has been run already.
      */
     error = af_face_globals_get_metrics( loader->globals, glyph_index,
                                          style_options, &style_metrics );
     if ( error )
       goto Exit;
 
     style_class          = style_metrics->style_class;
     writing_system_class =
-      AF_WRITING_SYSTEM_CLASSES_GET[style_class->writing_system];
+      af_writing_system_classes[style_class->writing_system];
 
     loader->metrics = style_metrics;
 
     if ( writing_system_class->style_metrics_scale )
       writing_system_class->style_metrics_scale( style_metrics, &scaler );
@@ -340,15 +335,15 @@
       if ( error )
         goto Exit;
     }
 
     /*
-     *  Do the main work of `af_loader_load_glyph'.  Note that we never have
-     *  to deal with composite glyphs as those get loaded into
-     *  FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph' function.
-     *  In the rare cases where FT_LOAD_NO_RECURSE is set, it implies
-     *  FT_LOAD_NO_SCALE and as such the auto-hinter is never called.
+     * Do the main work of `af_loader_load_glyph'.  Note that we never have
+     * to deal with composite glyphs as those get loaded into
+     * FT_GLYPH_FORMAT_OUTLINE by the recursed `FT_Load_Glyph' function.
+     * In the rare cases where FT_LOAD_NO_RECURSE is set, it implies
+     * FT_LOAD_NO_SCALE and as such the auto-hinter is never called.
      */
     load_flags |=  FT_LOAD_NO_SCALE         |
                    FT_LOAD_IGNORE_TRANSFORM |
                    FT_LOAD_LINEAR_DESIGN;
     load_flags &= ~FT_LOAD_RENDER;
@@ -356,30 +351,30 @@
     error = FT_Load_Glyph( face, glyph_index, load_flags );
     if ( error )
       goto Exit;
 
     /*
-     *  Apply stem darkening (emboldening) here before hints are applied to
-     *  the outline.  Glyphs are scaled down proportionally to the
-     *  emboldening so that curve points don't fall outside their
-     *  precomputed blue zones.
+     * Apply stem darkening (emboldening) here before hints are applied to
+     * the outline.  Glyphs are scaled down proportionally to the
+     * emboldening so that curve points don't fall outside their
+     * precomputed blue zones.
      *
-     *  Any emboldening done by the font driver (e.g., the CFF driver)
-     *  doesn't reach here because the autohinter loads the unprocessed
-     *  glyphs in font units for analysis (functions `af_*_metrics_init_*')
-     *  and then above to prepare it for the rasterizers by itself,
-     *  independently of the font driver.  So emboldening must be done here,
-     *  within the autohinter.
+     * Any emboldening done by the font driver (e.g., the CFF driver)
+     * doesn't reach here because the autohinter loads the unprocessed
+     * glyphs in font units for analysis (functions `af_*_metrics_init_*')
+     * and then above to prepare it for the rasterizers by itself,
+     * independently of the font driver.  So emboldening must be done here,
+     * within the autohinter.
      *
-     *  All glyphs to be autohinted pass through here one by one.  The
-     *  standard widths can therefore change from one glyph to the next,
-     *  depending on what script a glyph is assigned to (each script has its
-     *  own set of standard widths and other metrics).  The darkening amount
-     *  must therefore be recomputed for each size and
-     *  `standard_{vertical,horizontal}_width' change.
+     * All glyphs to be autohinted pass through here one by one.  The
+     * standard widths can therefore change from one glyph to the next,
+     * depending on what script a glyph is assigned to (each script has its
+     * own set of standard widths and other metrics).  The darkening amount
+     * must therefore be recomputed for each size and
+     * `standard_{vertical,horizontal}_width' change.
      *
-     *  Ignore errors and carry on without emboldening.
+     * Ignore errors and carry on without emboldening.
      *
      */
 
     /* stem darkening only works well in `light' mode */
     if ( scaler.render_mode == FT_RENDER_MODE_LIGHT    &&
@@ -424,39 +419,43 @@
         goto Hint_Metrics;
 
       /* now load the slot image into the auto-outline */
       /* and run the automatic hinting process         */
       if ( writing_system_class->style_hints_apply )
-        writing_system_class->style_hints_apply( glyph_index,
-                                                 hints,
-                                                 &gloader->base.outline,
-                                                 style_metrics );
+      {
+        error = writing_system_class->style_hints_apply(
+                  glyph_index,
+                  hints,
+                  &gloader->base.outline,
+                  style_metrics );
+        if ( error )
+          goto Exit;
+      }
 
       /* we now need to adjust the metrics according to the change in */
       /* width/positioning that occurred during the hinting process   */
       if ( scaler.render_mode != FT_RENDER_MODE_LIGHT )
       {
-        FT_Pos  old_rsb, old_lsb, new_lsb;
-        FT_Pos  pp1x_uh, pp2x_uh;
-
         AF_AxisHints  axis  = &hints->axis[AF_DIMENSION_HORZ];
-        AF_Edge       edge1 = axis->edges;         /* leftmost edge  */
-        AF_Edge       edge2 = edge1 +
-                              axis->num_edges - 1; /* rightmost edge */
 
 
         if ( axis->num_edges > 1 && AF_HINTS_DO_ADVANCE( hints ) )
         {
-          old_rsb = loader->pp2.x - edge2->opos;
+          AF_Edge  edge1 = axis->edges;         /* leftmost edge  */
+          AF_Edge  edge2 = edge1 +
+                           axis->num_edges - 1; /* rightmost edge */
+
+          FT_Pos  old_rsb = loader->pp2.x - edge2->opos;
           /* loader->pp1.x is always zero at this point of time */
-          old_lsb = edge1->opos /* - loader->pp1.x */;
-          new_lsb = edge1->pos;
+          FT_Pos  old_lsb = edge1->opos;     /* - loader->pp1.x */
+          FT_Pos  new_lsb = edge1->pos;
 
           /* remember unhinted values to later account */
           /* for rounding errors                       */
-          pp1x_uh = new_lsb    - old_lsb;
-          pp2x_uh = edge2->pos + old_rsb;
+          FT_Pos  pp1x_uh = new_lsb    - old_lsb;
+          FT_Pos  pp2x_uh = edge2->pos + old_rsb;
+
 
           /* prefer too much space over too little space */
           /* for very small sizes                        */
 
           if ( old_lsb < 24 )

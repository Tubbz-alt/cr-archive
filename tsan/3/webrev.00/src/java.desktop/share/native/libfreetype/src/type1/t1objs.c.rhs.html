<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/type1/t1objs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * t1objs.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Type 1 objects manager (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_CALC_H
 21 #include FT_INTERNAL_DEBUG_H
 22 #include FT_INTERNAL_STREAM_H
 23 #include FT_TRUETYPE_IDS_H
 24 #include FT_DRIVER_H
 25 
 26 #include &quot;t1gload.h&quot;
 27 #include &quot;t1load.h&quot;
 28 
 29 #include &quot;t1errors.h&quot;
 30 
 31 #ifndef T1_CONFIG_OPTION_NO_AFM
 32 #include &quot;t1afm.h&quot;
 33 #endif
 34 
 35 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 36 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 37 
 38 
<a name="2" id="anc2"></a><span class="line-modified"> 39   /**************************************************************************</span>
<span class="line-modified"> 40    *</span>
<span class="line-modified"> 41    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 42    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 43    * messages during execution.</span>
<span class="line-modified"> 44    */</span>
 45 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 46 #define FT_COMPONENT  t1objs</span>
 47 
 48 
<a name="4" id="anc4"></a><span class="line-modified"> 49   /**************************************************************************</span>
<span class="line-modified"> 50    *</span>
<span class="line-modified"> 51    *                           SIZE FUNCTIONS</span>
<span class="line-modified"> 52    *</span>
<span class="line-modified"> 53    */</span>
 54 
 55 
 56   static PSH_Globals_Funcs
 57   T1_Size_Get_Globals_Funcs( T1_Size  size )
 58   {
 59     T1_Face           face     = (T1_Face)size-&gt;root.face;
 60     PSHinter_Service  pshinter = (PSHinter_Service)face-&gt;pshinter;
 61     FT_Module         module;
 62 
 63 
 64     module = FT_Get_Module( size-&gt;root.face-&gt;driver-&gt;root.library,
 65                             &quot;pshinter&quot; );
 66     return ( module &amp;&amp; pshinter &amp;&amp; pshinter-&gt;get_globals_funcs )
 67            ? pshinter-&gt;get_globals_funcs( module )
 68            : 0;
 69   }
 70 
 71 
 72   FT_LOCAL_DEF( void )
 73   T1_Size_Done( FT_Size  t1size )          /* T1_Size */
 74   {
 75     T1_Size  size = (T1_Size)t1size;
 76 
 77 
 78     if ( t1size-&gt;internal-&gt;module_data )
 79     {
 80       PSH_Globals_Funcs  funcs;
 81 
 82 
 83       funcs = T1_Size_Get_Globals_Funcs( size );
 84       if ( funcs )
 85         funcs-&gt;destroy( (PSH_Globals)t1size-&gt;internal-&gt;module_data );
 86 
 87       t1size-&gt;internal-&gt;module_data = NULL;
 88     }
 89   }
 90 
 91 
 92   FT_LOCAL_DEF( FT_Error )
 93   T1_Size_Init( FT_Size  t1size )      /* T1_Size */
 94   {
 95     T1_Size            size  = (T1_Size)t1size;
 96     FT_Error           error = FT_Err_Ok;
 97     PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );
 98 
 99 
100     if ( funcs )
101     {
102       PSH_Globals  globals;
103       T1_Face      face = (T1_Face)size-&gt;root.face;
104 
105 
106       error = funcs-&gt;create( size-&gt;root.face-&gt;memory,
107                              &amp;face-&gt;type1.private_dict, &amp;globals );
108       if ( !error )
109         t1size-&gt;internal-&gt;module_data = globals;
110     }
111 
112     return error;
113   }
114 
115 
116   FT_LOCAL_DEF( FT_Error )
117   T1_Size_Request( FT_Size          t1size,     /* T1_Size */
118                    FT_Size_Request  req )
119   {
120     T1_Size            size  = (T1_Size)t1size;
121     PSH_Globals_Funcs  funcs = T1_Size_Get_Globals_Funcs( size );
122 
123 
124     FT_Request_Metrics( size-&gt;root.face, req );
125 
126     if ( funcs )
127       funcs-&gt;set_scale( (PSH_Globals)t1size-&gt;internal-&gt;module_data,
128                         size-&gt;root.metrics.x_scale,
129                         size-&gt;root.metrics.y_scale,
130                         0, 0 );
131 
132     return FT_Err_Ok;
133   }
134 
135 
<a name="5" id="anc5"></a><span class="line-modified">136   /**************************************************************************</span>
<span class="line-modified">137    *</span>
<span class="line-modified">138    *                           SLOT  FUNCTIONS</span>
<span class="line-modified">139    *</span>
<span class="line-modified">140    */</span>
141 
142   FT_LOCAL_DEF( void )
143   T1_GlyphSlot_Done( FT_GlyphSlot  slot )
144   {
145     slot-&gt;internal-&gt;glyph_hints = NULL;
146   }
147 
148 
149   FT_LOCAL_DEF( FT_Error )
150   T1_GlyphSlot_Init( FT_GlyphSlot  slot )
151   {
152     T1_Face           face;
153     PSHinter_Service  pshinter;
154 
155 
156     face     = (T1_Face)slot-&gt;face;
157     pshinter = (PSHinter_Service)face-&gt;pshinter;
158 
159     if ( pshinter )
160     {
161       FT_Module  module;
162 
163 
164       module = FT_Get_Module( slot-&gt;face-&gt;driver-&gt;root.library,
165                               &quot;pshinter&quot; );
166       if ( module )
167       {
168         T1_Hints_Funcs  funcs;
169 
170 
171         funcs = pshinter-&gt;get_t1_funcs( module );
172         slot-&gt;internal-&gt;glyph_hints = (void*)funcs;
173       }
174     }
175 
176     return 0;
177   }
178 
179 
<a name="6" id="anc6"></a><span class="line-modified">180   /**************************************************************************</span>
<span class="line-modified">181    *</span>
<span class="line-modified">182    *                           FACE  FUNCTIONS</span>
<span class="line-modified">183    *</span>
<span class="line-modified">184    */</span>
<span class="line-modified">185 </span>
<span class="line-modified">186 </span>
<span class="line-modified">187   /**************************************************************************</span>
<span class="line-modified">188    *</span>
<span class="line-modified">189    * @Function:</span>
<span class="line-modified">190    *   T1_Face_Done</span>
<span class="line-modified">191    *</span>
<span class="line-modified">192    * @Description:</span>
<span class="line-modified">193    *   The face object destructor.</span>
<span class="line-modified">194    *</span>
<span class="line-modified">195    * @Input:</span>
<span class="line-modified">196    *   face ::</span>
<span class="line-modified">197    *     A typeless pointer to the face object to destroy.</span>
<span class="line-added">198    */</span>
199   FT_LOCAL_DEF( void )
200   T1_Face_Done( FT_Face  t1face )         /* T1_Face */
201   {
202     T1_Face    face = (T1_Face)t1face;
203     FT_Memory  memory;
204     T1_Font    type1;
205 
206 
207     if ( !face )
208       return;
209 
210     memory = face-&gt;root.memory;
211     type1  = &amp;face-&gt;type1;
212 
213 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
214     /* release multiple masters information */
215     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
216 
217     if ( face-&gt;buildchar )
218     {
219       FT_FREE( face-&gt;buildchar );
220 
221       face-&gt;buildchar     = NULL;
222       face-&gt;len_buildchar = 0;
223     }
224 
225     T1_Done_Blend( face );
226     face-&gt;blend = NULL;
227 #endif
228 
229     /* release font info strings */
230     {
231       PS_FontInfo  info = &amp;type1-&gt;font_info;
232 
233 
234       FT_FREE( info-&gt;version );
235       FT_FREE( info-&gt;notice );
236       FT_FREE( info-&gt;full_name );
237       FT_FREE( info-&gt;family_name );
238       FT_FREE( info-&gt;weight );
239     }
240 
241     /* release top dictionary */
242     FT_FREE( type1-&gt;charstrings_len );
243     FT_FREE( type1-&gt;charstrings );
244     FT_FREE( type1-&gt;glyph_names );
245 
246     FT_FREE( type1-&gt;subrs );
247     FT_FREE( type1-&gt;subrs_len );
248 
249     ft_hash_num_free( type1-&gt;subrs_hash, memory );
250     FT_FREE( type1-&gt;subrs_hash );
251 
252     FT_FREE( type1-&gt;subrs_block );
253     FT_FREE( type1-&gt;charstrings_block );
254     FT_FREE( type1-&gt;glyph_names_block );
255 
256     FT_FREE( type1-&gt;encoding.char_index );
257     FT_FREE( type1-&gt;encoding.char_name );
258     FT_FREE( type1-&gt;font_name );
259 
260 #ifndef T1_CONFIG_OPTION_NO_AFM
261     /* release afm data if present */
262     if ( face-&gt;afm_data )
263       T1_Done_Metrics( memory, (AFM_FontInfo)face-&gt;afm_data );
264 #endif
265 
266     /* release unicode map, if any */
267 #if 0
268     FT_FREE( face-&gt;unicode_map_rec.maps );
269     face-&gt;unicode_map_rec.num_maps = 0;
270     face-&gt;unicode_map              = NULL;
271 #endif
272 
273     face-&gt;root.family_name = NULL;
274     face-&gt;root.style_name  = NULL;
275   }
276 
277 
<a name="7" id="anc7"></a><span class="line-modified">278   /**************************************************************************</span>
<span class="line-modified">279    *</span>
<span class="line-modified">280    * @Function:</span>
<span class="line-modified">281    *   T1_Face_Init</span>
<span class="line-modified">282    *</span>
<span class="line-modified">283    * @Description:</span>
<span class="line-modified">284    *   The face object constructor.</span>
<span class="line-modified">285    *</span>
<span class="line-modified">286    * @Input:</span>
<span class="line-modified">287    *   stream ::</span>
<span class="line-modified">288    *     input stream where to load font data.</span>
<span class="line-modified">289    *</span>
<span class="line-modified">290    *   face_index ::</span>
<span class="line-modified">291    *     The index of the font face in the resource.</span>
<span class="line-modified">292    *</span>
<span class="line-modified">293    *   num_params ::</span>
<span class="line-modified">294    *     Number of additional generic parameters.  Ignored.</span>
<span class="line-modified">295    *</span>
<span class="line-modified">296    *   params ::</span>
<span class="line-modified">297    *     Additional generic parameters.  Ignored.</span>
<span class="line-modified">298    *</span>
<span class="line-modified">299    * @InOut:</span>
<span class="line-modified">300    *   face ::</span>
<span class="line-added">301    *     The face record to build.</span>
<span class="line-added">302    *</span>
<span class="line-added">303    * @Return:</span>
<span class="line-added">304    *   FreeType error code.  0 means success.</span>
<span class="line-added">305    */</span>
306   FT_LOCAL_DEF( FT_Error )
307   T1_Face_Init( FT_Stream      stream,
308                 FT_Face        t1face,          /* T1_Face */
309                 FT_Int         face_index,
310                 FT_Int         num_params,
311                 FT_Parameter*  params )
312   {
313     T1_Face             face = (T1_Face)t1face;
314     FT_Error            error;
315     FT_Service_PsCMaps  psnames;
316     PSAux_Service       psaux;
317     T1_Font             type1 = &amp;face-&gt;type1;
318     PS_FontInfo         info = &amp;type1-&gt;font_info;
319 
320     FT_UNUSED( num_params );
321     FT_UNUSED( params );
322     FT_UNUSED( stream );
323 
324 
325     face-&gt;root.num_faces = 1;
326 
327     FT_FACE_FIND_GLOBAL_SERVICE( face, psnames, POSTSCRIPT_CMAPS );
328     face-&gt;psnames = psnames;
329 
330     face-&gt;psaux = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
331                                            &quot;psaux&quot; );
332     psaux = (PSAux_Service)face-&gt;psaux;
333     if ( !psaux )
334     {
335       FT_ERROR(( &quot;T1_Face_Init: cannot access `psaux&#39; module\n&quot; ));
336       error = FT_THROW( Missing_Module );
337       goto Exit;
338     }
339 
340     face-&gt;pshinter = FT_Get_Module_Interface( FT_FACE_LIBRARY( face ),
341                                               &quot;pshinter&quot; );
342 
343     FT_TRACE2(( &quot;Type 1 driver\n&quot; ));
344 
345     /* open the tokenizer; this will also check the font format */
346     error = T1_Open_Face( face );
347     if ( error )
348       goto Exit;
349 
<a name="8" id="anc8"></a><span class="line-added">350     FT_TRACE2(( &quot;T1_Face_Init: %08p (index %d)\n&quot;,</span>
<span class="line-added">351                 face,</span>
<span class="line-added">352                 face_index ));</span>
<span class="line-added">353 </span>
354     /* if we just wanted to check the format, leave successfully now */
355     if ( face_index &lt; 0 )
356       goto Exit;
357 
358     /* check the face index */
359     if ( ( face_index &amp; 0xFFFF ) &gt; 0 )
360     {
361       FT_ERROR(( &quot;T1_Face_Init: invalid face index\n&quot; ));
362       error = FT_THROW( Invalid_Argument );
363       goto Exit;
364     }
365 
366     /* now load the font program into the face object */
367 
368     /* initialize the face object fields */
369 
370     /* set up root face fields */
371     {
372       FT_Face  root = (FT_Face)&amp;face-&gt;root;
373 
374 
375       root-&gt;num_glyphs = type1-&gt;num_glyphs;
376       root-&gt;face_index = 0;
377 
378       root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE    |
379                           FT_FACE_FLAG_HORIZONTAL  |
380                           FT_FACE_FLAG_GLYPH_NAMES |
381                           FT_FACE_FLAG_HINTER;
382 
383       if ( info-&gt;is_fixed_pitch )
384         root-&gt;face_flags |= FT_FACE_FLAG_FIXED_WIDTH;
385 
386       if ( face-&gt;blend )
387         root-&gt;face_flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
388 
389       /* The following code to extract the family and the style is very   */
390       /* simplistic and might get some things wrong.  For a full-featured */
391       /* algorithm you might have a look at the whitepaper given at       */
392       /*                                                                  */
393       /*   https://blogs.msdn.com/text/archive/2007/04/23/wpf-font-selection-model.aspx */
394 
395       /* get style name -- be careful, some broken fonts only */
396       /* have a `/FontName&#39; dictionary entry!                 */
397       root-&gt;family_name = info-&gt;family_name;
398       root-&gt;style_name  = NULL;
399 
400       if ( root-&gt;family_name )
401       {
402         char*  full   = info-&gt;full_name;
403         char*  family = root-&gt;family_name;
404 
405 
406         if ( full )
407         {
408           FT_Bool  the_same = TRUE;
409 
410 
411           while ( *full )
412           {
413             if ( *full == *family )
414             {
415               family++;
416               full++;
417             }
418             else
419             {
420               if ( *full == &#39; &#39; || *full == &#39;-&#39; )
421                 full++;
422               else if ( *family == &#39; &#39; || *family == &#39;-&#39; )
423                 family++;
424               else
425               {
426                 the_same = FALSE;
427 
428                 if ( !*family )
429                   root-&gt;style_name = full;
430                 break;
431               }
432             }
433           }
434 
435           if ( the_same )
436             root-&gt;style_name = (char *)&quot;Regular&quot;;
437         }
438       }
439       else
440       {
441         /* do we have a `/FontName&#39;? */
442         if ( type1-&gt;font_name )
443           root-&gt;family_name = type1-&gt;font_name;
444       }
445 
446       if ( !root-&gt;style_name )
447       {
448         if ( info-&gt;weight )
449           root-&gt;style_name = info-&gt;weight;
450         else
451           /* assume `Regular&#39; style because we don&#39;t know better */
452           root-&gt;style_name = (char *)&quot;Regular&quot;;
453       }
454 
455       /* compute style flags */
456       root-&gt;style_flags = 0;
457       if ( info-&gt;italic_angle )
458         root-&gt;style_flags |= FT_STYLE_FLAG_ITALIC;
459       if ( info-&gt;weight )
460       {
461         if ( !ft_strcmp( info-&gt;weight, &quot;Bold&quot;  ) ||
462              !ft_strcmp( info-&gt;weight, &quot;Black&quot; ) )
463           root-&gt;style_flags |= FT_STYLE_FLAG_BOLD;
464       }
465 
466       /* no embedded bitmap support */
467       root-&gt;num_fixed_sizes = 0;
468       root-&gt;available_sizes = NULL;
469 
470       root-&gt;bbox.xMin =   type1-&gt;font_bbox.xMin            &gt;&gt; 16;
471       root-&gt;bbox.yMin =   type1-&gt;font_bbox.yMin            &gt;&gt; 16;
472       /* no `U&#39; suffix here to 0xFFFF! */
473       root-&gt;bbox.xMax = ( type1-&gt;font_bbox.xMax + 0xFFFF ) &gt;&gt; 16;
474       root-&gt;bbox.yMax = ( type1-&gt;font_bbox.yMax + 0xFFFF ) &gt;&gt; 16;
475 
476       /* Set units_per_EM if we didn&#39;t set it in t1_parse_font_matrix. */
477       if ( !root-&gt;units_per_EM )
478         root-&gt;units_per_EM = 1000;
479 
480       root-&gt;ascender  = (FT_Short)( root-&gt;bbox.yMax );
481       root-&gt;descender = (FT_Short)( root-&gt;bbox.yMin );
482 
483       root-&gt;height = (FT_Short)( ( root-&gt;units_per_EM * 12 ) / 10 );
484       if ( root-&gt;height &lt; root-&gt;ascender - root-&gt;descender )
485         root-&gt;height = (FT_Short)( root-&gt;ascender - root-&gt;descender );
486 
487       /* now compute the maximum advance width */
488       root-&gt;max_advance_width =
489         (FT_Short)( root-&gt;bbox.xMax );
490       {
491         FT_Pos  max_advance;
492 
493 
494         error = T1_Compute_Max_Advance( face, &amp;max_advance );
495 
496         /* in case of error, keep the standard width */
497         if ( !error )
498           root-&gt;max_advance_width = (FT_Short)FIXED_TO_INT( max_advance );
499         else
500           error = FT_Err_Ok;   /* clear error */
501       }
502 
503       root-&gt;max_advance_height = root-&gt;height;
504 
505       root-&gt;underline_position  = (FT_Short)info-&gt;underline_position;
506       root-&gt;underline_thickness = (FT_Short)info-&gt;underline_thickness;
507     }
508 
509     {
510       FT_Face  root = &amp;face-&gt;root;
511 
512 
513       if ( psnames )
514       {
515         FT_CharMapRec    charmap;
516         T1_CMap_Classes  cmap_classes = psaux-&gt;t1_cmap_classes;
517         FT_CMap_Class    clazz;
518 
519 
520         charmap.face = root;
521 
522         /* first of all, try to synthesize a Unicode charmap */
523         charmap.platform_id = TT_PLATFORM_MICROSOFT;
524         charmap.encoding_id = TT_MS_ID_UNICODE_CS;
525         charmap.encoding    = FT_ENCODING_UNICODE;
526 
527         error = FT_CMap_New( cmap_classes-&gt;unicode, NULL, &amp;charmap, NULL );
528         if ( error                                      &amp;&amp;
<a name="9" id="anc9"></a><span class="line-modified">529              FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &amp;&amp;</span>
<span class="line-added">530              FT_ERR_NEQ( error, Unimplemented_Feature ) )</span>
531           goto Exit;
532         error = FT_Err_Ok;
533 
534         /* now, generate an Adobe Standard encoding when appropriate */
535         charmap.platform_id = TT_PLATFORM_ADOBE;
536         clazz               = NULL;
537 
538         switch ( type1-&gt;encoding_type )
539         {
540         case T1_ENCODING_TYPE_STANDARD:
541           charmap.encoding    = FT_ENCODING_ADOBE_STANDARD;
542           charmap.encoding_id = TT_ADOBE_ID_STANDARD;
543           clazz               = cmap_classes-&gt;standard;
544           break;
545 
546         case T1_ENCODING_TYPE_EXPERT:
547           charmap.encoding    = FT_ENCODING_ADOBE_EXPERT;
548           charmap.encoding_id = TT_ADOBE_ID_EXPERT;
549           clazz               = cmap_classes-&gt;expert;
550           break;
551 
552         case T1_ENCODING_TYPE_ARRAY:
553           charmap.encoding    = FT_ENCODING_ADOBE_CUSTOM;
554           charmap.encoding_id = TT_ADOBE_ID_CUSTOM;
555           clazz               = cmap_classes-&gt;custom;
556           break;
557 
558         case T1_ENCODING_TYPE_ISOLATIN1:
559           charmap.encoding    = FT_ENCODING_ADOBE_LATIN_1;
560           charmap.encoding_id = TT_ADOBE_ID_LATIN_1;
561           clazz               = cmap_classes-&gt;unicode;
562           break;
563 
564         default:
565           ;
566         }
567 
568         if ( clazz )
569           error = FT_CMap_New( clazz, NULL, &amp;charmap, NULL );
570       }
571     }
572 
573   Exit:
574     return error;
575   }
576 
577 
<a name="10" id="anc10"></a><span class="line-modified">578   /**************************************************************************</span>
<span class="line-modified">579    *</span>
<span class="line-modified">580    * @Function:</span>
<span class="line-modified">581    *   T1_Driver_Init</span>
<span class="line-modified">582    *</span>
<span class="line-modified">583    * @Description:</span>
<span class="line-modified">584    *   Initializes a given Type 1 driver object.</span>
<span class="line-modified">585    *</span>
<span class="line-modified">586    * @Input:</span>
<span class="line-modified">587    *   driver ::</span>
<span class="line-modified">588    *     A handle to the target driver object.</span>
<span class="line-modified">589    *</span>
<span class="line-modified">590    * @Return:</span>
<span class="line-modified">591    *   FreeType error code.  0 means success.</span>
<span class="line-added">592    */</span>
593   FT_LOCAL_DEF( FT_Error )
594   T1_Driver_Init( FT_Module  module )
595   {
596     PS_Driver  driver = (PS_Driver)module;
597 
598     FT_UInt32  seed;
599 
600 
601     /* set default property values, cf. `ftt1drv.h&#39; */
602 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
603     driver-&gt;hinting_engine = FT_HINTING_FREETYPE;
604 #else
605     driver-&gt;hinting_engine = FT_HINTING_ADOBE;
606 #endif
607 
608     driver-&gt;no_stem_darkening = TRUE;
609 
610     driver-&gt;darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
611     driver-&gt;darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
612     driver-&gt;darken_params[2] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2;
613     driver-&gt;darken_params[3] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2;
614     driver-&gt;darken_params[4] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3;
615     driver-&gt;darken_params[5] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3;
616     driver-&gt;darken_params[6] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4;
617     driver-&gt;darken_params[7] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4;
618 
619     /* compute random seed from some memory addresses */
620     seed = (FT_UInt32)( (FT_Offset)(char*)&amp;seed          ^
621                         (FT_Offset)(char*)&amp;module        ^
622                         (FT_Offset)(char*)module-&gt;memory );
623     seed = seed ^ ( seed &gt;&gt; 10 ) ^ ( seed &gt;&gt; 20 );
624 
625     driver-&gt;random_seed = (FT_Int32)seed;
626     if ( driver-&gt;random_seed &lt; 0 )
627       driver-&gt;random_seed = -driver-&gt;random_seed;
628     else if ( driver-&gt;random_seed == 0 )
629       driver-&gt;random_seed = 123456789;
630 
631     return FT_Err_Ok;
632   }
633 
634 
<a name="11" id="anc11"></a><span class="line-modified">635   /**************************************************************************</span>
<span class="line-modified">636    *</span>
<span class="line-modified">637    * @Function:</span>
<span class="line-modified">638    *   T1_Driver_Done</span>
<span class="line-modified">639    *</span>
<span class="line-modified">640    * @Description:</span>
<span class="line-modified">641    *   Finalizes a given Type 1 driver.</span>
<span class="line-modified">642    *</span>
<span class="line-modified">643    * @Input:</span>
<span class="line-modified">644    *   driver ::</span>
<span class="line-modified">645    *     A handle to the target Type 1 driver.</span>
<span class="line-added">646    */</span>
647   FT_LOCAL_DEF( void )
648   T1_Driver_Done( FT_Module  driver )
649   {
650     FT_UNUSED( driver );
651   }
652 
653 
654 /* END */
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
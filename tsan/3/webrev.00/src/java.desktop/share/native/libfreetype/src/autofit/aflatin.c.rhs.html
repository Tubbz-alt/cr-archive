<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * aflatin.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auto-fitter hinting routines for latin writing system (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_ADVANCES_H
  21 #include FT_INTERNAL_DEBUG_H
  22 
  23 #include &quot;afglobal.h&quot;
<a name="2" id="anc2"></a>
  24 #include &quot;aflatin.h&quot;
  25 #include &quot;aferrors.h&quot;
  26 
  27 
  28 #ifdef AF_CONFIG_OPTION_USE_WARPER
  29 #include &quot;afwarp.h&quot;
  30 #endif
  31 
  32 
<a name="3" id="anc3"></a><span class="line-modified">  33   /**************************************************************************</span>
<span class="line-modified">  34    *</span>
<span class="line-modified">  35    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  36    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  37    * messages during execution.</span>
<span class="line-modified">  38    */</span>
  39 #undef  FT_COMPONENT
<a name="4" id="anc4"></a><span class="line-modified">  40 #define FT_COMPONENT  aflatin</span>
  41 
  42 
  43   /* needed for computation of round vs. flat segments */
  44 #define FLAT_THRESHOLD( x )  ( x / 14 )
  45 
  46 
  47   /*************************************************************************/
  48   /*************************************************************************/
  49   /*****                                                               *****/
  50   /*****            L A T I N   G L O B A L   M E T R I C S            *****/
  51   /*****                                                               *****/
  52   /*************************************************************************/
  53   /*************************************************************************/
  54 
  55 
  56   /* Find segments and links, compute all stem widths, and initialize */
  57   /* standard width and height for the glyph with given charcode.     */
  58 
  59   FT_LOCAL_DEF( void )
  60   af_latin_metrics_init_widths( AF_LatinMetrics  metrics,
  61                                 FT_Face          face )
  62   {
  63     /* scan the array of segments in each direction */
  64     AF_GlyphHintsRec  hints[1];
  65 
  66 
  67     FT_TRACE5(( &quot;\n&quot;
  68                 &quot;latin standard widths computation (style `%s&#39;)\n&quot;
  69                 &quot;=====================================================\n&quot;
  70                 &quot;\n&quot;,
  71                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
  72 
  73     af_glyph_hints_init( hints, face-&gt;memory );
  74 
  75     metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;
  76     metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;
  77 
  78     {
  79       FT_Error            error;
  80       FT_ULong            glyph_index;
  81       int                 dim;
  82       AF_LatinMetricsRec  dummy[1];
  83       AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;
  84 
<a name="5" id="anc5"></a>



  85       AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<a name="6" id="anc6"></a><span class="line-modified">  86       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="line-modified">  87 </span>
<span class="line-added">  88       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">  89       /* unsigned long value.                                        */</span>
<span class="line-added">  90 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">  91       void*     shaper_buf;</span>
<span class="line-added">  92 #else</span>
<span class="line-added">  93       FT_ULong  shaper_buf_;</span>
<span class="line-added">  94       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">  95 #endif</span>
  96 
<a name="7" id="anc7"></a>
  97       const char*  p;
  98 
  99 #ifdef FT_DEBUG_LEVEL_TRACE
 100       FT_ULong  ch = 0;
 101 #endif
 102 
<a name="8" id="anc8"></a>

 103 
<a name="9" id="anc9"></a><span class="line-added"> 104       p = script_class-&gt;standard_charstring;</span>
<span class="line-added"> 105 </span>
<span class="line-added"> 106 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 107       shaper_buf = af_shaper_buf_create( face );</span>
<span class="line-added"> 108 #endif</span>
 109       /*
 110        * We check a list of standard characters to catch features like
 111        * `c2sc&#39; (small caps from caps) that don&#39;t contain lowercase letters
 112        * by definition, or other features that mainly operate on numerals.
 113        * The first match wins.
 114        */
 115 
 116       glyph_index = 0;
 117       while ( *p )
 118       {
 119         unsigned int  num_idx;
 120 
 121 #ifdef FT_DEBUG_LEVEL_TRACE
 122         const char*  p_old;
 123 #endif
 124 
 125 
 126         while ( *p == &#39; &#39; )
 127           p++;
 128 
 129 #ifdef FT_DEBUG_LEVEL_TRACE
 130         p_old = p;
 131         GET_UTF8_CHAR( ch, p_old );
 132 #endif
 133 
 134         /* reject input that maps to more than a single glyph */
 135         p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 136         if ( num_idx &gt; 1 )
 137           continue;
 138 
 139         /* otherwise exit loop if we have a result */
 140         glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 141                                           shaper_buf,
 142                                           0,
 143                                           NULL,
 144                                           NULL );
 145         if ( glyph_index )
 146           break;
 147       }
 148 
 149       af_shaper_buf_destroy( face, shaper_buf );
 150 
 151       if ( !glyph_index )
<a name="10" id="anc10"></a><span class="line-added"> 152       {</span>
<span class="line-added"> 153         FT_TRACE5(( &quot;standard character missing;&quot;</span>
<span class="line-added"> 154                     &quot; using fallback stem widths\n&quot; ));</span>
 155         goto Exit;
<a name="11" id="anc11"></a><span class="line-added"> 156       }</span>
 157 
 158       FT_TRACE5(( &quot;standard character: U+%04lX (glyph index %d)\n&quot;,
 159                   ch, glyph_index ));
 160 
 161       error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
 162       if ( error || face-&gt;glyph-&gt;outline.n_points &lt;= 0 )
 163         goto Exit;
 164 
 165       FT_ZERO( dummy );
 166 
 167       dummy-&gt;units_per_em = metrics-&gt;units_per_em;
 168 
 169       scaler-&gt;x_scale = 0x10000L;
 170       scaler-&gt;y_scale = 0x10000L;
 171       scaler-&gt;x_delta = 0;
 172       scaler-&gt;y_delta = 0;
 173 
 174       scaler-&gt;face        = face;
 175       scaler-&gt;render_mode = FT_RENDER_MODE_NORMAL;
 176       scaler-&gt;flags       = 0;
 177 
 178       af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
 179 
 180       error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );
 181       if ( error )
 182         goto Exit;
 183 
 184       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 185       {
 186         AF_LatinAxis  axis    = &amp;metrics-&gt;axis[dim];
 187         AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];
 188         AF_Segment    seg, limit, link;
 189         FT_UInt       num_widths = 0;
 190 
 191 
 192         error = af_latin_hints_compute_segments( hints,
 193                                                  (AF_Dimension)dim );
 194         if ( error )
 195           goto Exit;
 196 
 197         /*
<a name="12" id="anc12"></a><span class="line-modified"> 198          * We assume that the glyphs selected for the stem width</span>
<span class="line-modified"> 199          * computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified"> 200          * algorithm works fine without adjustments of its scoring</span>
<span class="line-modified"> 201          * function.</span>
 202          */
 203         af_latin_hints_link_segments( hints,
 204                                       0,
 205                                       NULL,
 206                                       (AF_Dimension)dim );
 207 
 208         seg   = axhints-&gt;segments;
 209         limit = seg + axhints-&gt;num_segments;
 210 
 211         for ( ; seg &lt; limit; seg++ )
 212         {
 213           link = seg-&gt;link;
 214 
 215           /* we only consider stem segments there! */
 216           if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )
 217           {
 218             FT_Pos  dist;
 219 
 220 
 221             dist = seg-&gt;pos - link-&gt;pos;
 222             if ( dist &lt; 0 )
 223               dist = -dist;
 224 
 225             if ( num_widths &lt; AF_LATIN_MAX_WIDTHS )
 226               axis-&gt;widths[num_widths++].org = dist;
 227           }
 228         }
 229 
 230         /* this also replaces multiple almost identical stem widths */
 231         /* with a single one (the value 100 is heuristic)           */
 232         af_sort_and_quantize_widths( &amp;num_widths, axis-&gt;widths,
 233                                      dummy-&gt;units_per_em / 100 );
 234         axis-&gt;width_count = num_widths;
 235       }
 236 
 237     Exit:
 238       for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 239       {
 240         AF_LatinAxis  axis = &amp;metrics-&gt;axis[dim];
 241         FT_Pos        stdw;
 242 
 243 
 244         stdw = ( axis-&gt;width_count &gt; 0 ) ? axis-&gt;widths[0].org
 245                                          : AF_LATIN_CONSTANT( metrics, 50 );
 246 
 247         /* let&#39;s try 20% of the smallest width */
 248         axis-&gt;edge_distance_threshold = stdw / 5;
 249         axis-&gt;standard_width          = stdw;
 250         axis-&gt;extra_light             = 0;
 251 
 252 #ifdef FT_DEBUG_LEVEL_TRACE
 253         {
 254           FT_UInt  i;
 255 
 256 
 257           FT_TRACE5(( &quot;%s widths:\n&quot;,
 258                       dim == AF_DIMENSION_VERT ? &quot;horizontal&quot;
 259                                                : &quot;vertical&quot; ));
 260 
 261           FT_TRACE5(( &quot;  %d (standard)&quot;, axis-&gt;standard_width ));
 262           for ( i = 1; i &lt; axis-&gt;width_count; i++ )
 263             FT_TRACE5(( &quot; %d&quot;, axis-&gt;widths[i].org ));
 264 
 265           FT_TRACE5(( &quot;\n&quot; ));
 266         }
 267 #endif
 268       }
 269     }
 270 
 271     FT_TRACE5(( &quot;\n&quot; ));
 272 
 273     af_glyph_hints_done( hints );
 274   }
 275 
 276 
 277   static void
 278   af_latin_sort_blue( FT_UInt        count,
 279                       AF_LatinBlue*  table )
 280   {
 281     FT_UInt       i, j;
 282     AF_LatinBlue  swap;
 283 
 284 
 285     /* we sort from bottom to top */
 286     for ( i = 1; i &lt; count; i++ )
 287     {
 288       for ( j = i; j &gt; 0; j-- )
 289       {
 290         FT_Pos  a, b;
 291 
 292 
 293         if ( table[j - 1]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
 294                                      AF_LATIN_BLUE_SUB_TOP ) )
 295           a = table[j - 1]-&gt;ref.org;
 296         else
 297           a = table[j - 1]-&gt;shoot.org;
 298 
 299         if ( table[j]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
 300                                  AF_LATIN_BLUE_SUB_TOP ) )
 301           b = table[j]-&gt;ref.org;
 302         else
 303           b = table[j]-&gt;shoot.org;
 304 
 305         if ( b &gt;= a )
 306           break;
 307 
 308         swap         = table[j];
 309         table[j]     = table[j - 1];
 310         table[j - 1] = swap;
 311       }
 312     }
 313   }
 314 
 315 
 316   /* Find all blue zones.  Flat segments give the reference points, */
 317   /* round segments the overshoot positions.                        */
 318 
<a name="13" id="anc13"></a><span class="line-modified"> 319   static int</span>
 320   af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
 321                                FT_Face          face )
 322   {
 323     FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
 324     FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
 325 
 326     FT_UInt       num_flats;
 327     FT_UInt       num_rounds;
 328 
 329     AF_LatinBlue  blue;
 330     FT_Error      error;
 331     AF_LatinAxis  axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
 332     FT_Outline    outline;
 333 
 334     AF_StyleClass  sc = metrics-&gt;root.style_class;
 335 
 336     AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
 337     const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
 338 
 339     FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
 340 
<a name="14" id="anc14"></a><span class="line-modified"> 341     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added"> 342     /* unsigned long value.                                        */</span>
<span class="line-added"> 343 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added"> 344     void*     shaper_buf;</span>
<span class="line-added"> 345 #else</span>
<span class="line-added"> 346     FT_ULong  shaper_buf_;</span>
<span class="line-added"> 347     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added"> 348 #endif</span>
 349 
 350 
 351     /* we walk over the blue character strings as specified in the */
 352     /* style&#39;s entry in the `af_blue_stringset&#39; array              */
 353 
 354     FT_TRACE5(( &quot;latin blue zones computation\n&quot;
 355                 &quot;============================\n&quot;
 356                 &quot;\n&quot; ));
 357 
<a name="15" id="anc15"></a><span class="line-added"> 358 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
 359     shaper_buf = af_shaper_buf_create( face );
<a name="16" id="anc16"></a><span class="line-added"> 360 #endif</span>
 361 
 362     for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
 363     {
 364       const char*  p = &amp;af_blue_strings[bs-&gt;string];
 365       FT_Pos*      blue_ref;
 366       FT_Pos*      blue_shoot;
 367       FT_Pos       ascender;
 368       FT_Pos       descender;
 369 
 370 
 371 #ifdef FT_DEBUG_LEVEL_TRACE
 372       {
 373         FT_Bool  have_flag = 0;
 374 
 375 
 376         FT_TRACE5(( &quot;blue zone %d&quot;, axis-&gt;blue_count ));
 377 
 378         if ( bs-&gt;properties )
 379         {
 380           FT_TRACE5(( &quot; (&quot; ));
 381 
 382           if ( AF_LATIN_IS_TOP_BLUE( bs ) )
 383           {
 384             FT_TRACE5(( &quot;top&quot; ));
 385             have_flag = 1;
 386           }
 387           else if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
 388           {
 389             FT_TRACE5(( &quot;sub top&quot; ));
 390             have_flag = 1;
 391           }
 392 
 393           if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
 394           {
 395             if ( have_flag )
 396               FT_TRACE5(( &quot;, &quot; ));
 397             FT_TRACE5(( &quot;neutral&quot; ));
 398             have_flag = 1;
 399           }
 400 
 401           if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
 402           {
 403             if ( have_flag )
 404               FT_TRACE5(( &quot;, &quot; ));
 405             FT_TRACE5(( &quot;small top&quot; ));
 406             have_flag = 1;
 407           }
 408 
 409           if ( AF_LATIN_IS_LONG_BLUE( bs ) )
 410           {
 411             if ( have_flag )
 412               FT_TRACE5(( &quot;, &quot; ));
 413             FT_TRACE5(( &quot;long&quot; ));
 414           }
 415 
 416           FT_TRACE5(( &quot;)&quot; ));
 417         }
 418 
 419         FT_TRACE5(( &quot;:\n&quot; ));
 420       }
 421 #endif /* FT_DEBUG_LEVEL_TRACE */
 422 
 423       num_flats  = 0;
 424       num_rounds = 0;
 425       ascender   = 0;
 426       descender  = 0;
 427 
 428       while ( *p )
 429       {
 430         FT_ULong    glyph_index;
 431         FT_Long     y_offset;
 432         FT_Int      best_point, best_contour_first, best_contour_last;
 433         FT_Vector*  points;
 434 
 435         FT_Pos   best_y_extremum;                      /* same as points.y */
 436         FT_Bool  best_round = 0;
 437 
 438         unsigned int  i, num_idx;
 439 
 440 #ifdef FT_DEBUG_LEVEL_TRACE
 441         const char*  p_old;
 442         FT_ULong     ch;
 443 #endif
 444 
 445 
 446         while ( *p == &#39; &#39; )
 447           p++;
 448 
 449 #ifdef FT_DEBUG_LEVEL_TRACE
 450         p_old = p;
 451         GET_UTF8_CHAR( ch, p_old );
 452 #endif
 453 
 454         p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
 455 
 456         if ( !num_idx )
 457         {
 458           FT_TRACE5(( &quot;  U+%04lX unavailable\n&quot;, ch ));
 459           continue;
 460         }
 461 
 462         if ( AF_LATIN_IS_TOP_BLUE( bs ) )
 463           best_y_extremum = FT_INT_MIN;
 464         else
 465           best_y_extremum = FT_INT_MAX;
 466 
 467         /* iterate over all glyph elements of the character cluster */
 468         /* and get the data of the `biggest&#39; one                    */
 469         for ( i = 0; i &lt; num_idx; i++ )
 470         {
 471           FT_Pos   best_y;
 472           FT_Bool  round = 0;
 473 
 474 
 475           /* load the character in the face -- skip unknown or empty ones */
 476           glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
 477                                             shaper_buf,
 478                                             i,
 479                                             NULL,
 480                                             &amp;y_offset );
 481           if ( glyph_index == 0 )
 482           {
 483             FT_TRACE5(( &quot;  U+%04lX unavailable\n&quot;, ch ));
 484             continue;
 485           }
 486 
 487           error   = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
 488           outline = face-&gt;glyph-&gt;outline;
 489           /* reject glyphs that don&#39;t produce any rendering */
 490           if ( error || outline.n_points &lt;= 2 )
 491           {
 492 #ifdef FT_DEBUG_LEVEL_TRACE
 493             if ( num_idx == 1 )
 494               FT_TRACE5(( &quot;  U+%04lX contains no (usable) outlines\n&quot;, ch ));
 495             else
 496               FT_TRACE5(( &quot;  component %d of cluster starting with U+%04lX&quot;
 497                           &quot; contains no (usable) outlines\n&quot;, i, ch ));
 498 #endif
 499             continue;
 500           }
 501 
 502           /* now compute min or max point indices and coordinates */
 503           points             = outline.points;
 504           best_point         = -1;
 505           best_y             = 0;  /* make compiler happy */
 506           best_contour_first = 0;  /* ditto */
 507           best_contour_last  = 0;  /* ditto */
 508 
 509           {
 510             FT_Int  nn;
 511             FT_Int  first = 0;
 512             FT_Int  last  = -1;
 513 
 514 
 515             for ( nn = 0; nn &lt; outline.n_contours; first = last + 1, nn++ )
 516             {
 517               FT_Int  old_best_point = best_point;
 518               FT_Int  pp;
 519 
 520 
 521               last = outline.contours[nn];
 522 
 523               /* Avoid single-point contours since they are never      */
 524               /* rasterized.  In some fonts, they correspond to mark   */
 525               /* attachment points that are way outside of the glyph&#39;s */
 526               /* real outline.                                         */
 527               if ( last &lt;= first )
 528                 continue;
 529 
 530               if ( AF_LATIN_IS_TOP_BLUE( bs )     ||
 531                    AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
 532               {
 533                 for ( pp = first; pp &lt;= last; pp++ )
 534                 {
 535                   if ( best_point &lt; 0 || points[pp].y &gt; best_y )
 536                   {
 537                     best_point = pp;
 538                     best_y     = points[pp].y;
 539                     ascender   = FT_MAX( ascender, best_y + y_offset );
 540                   }
 541                   else
 542                     descender = FT_MIN( descender, points[pp].y + y_offset );
 543                 }
 544               }
 545               else
 546               {
 547                 for ( pp = first; pp &lt;= last; pp++ )
 548                 {
 549                   if ( best_point &lt; 0 || points[pp].y &lt; best_y )
 550                   {
 551                     best_point = pp;
 552                     best_y     = points[pp].y;
 553                     descender  = FT_MIN( descender, best_y + y_offset );
 554                   }
 555                   else
 556                     ascender = FT_MAX( ascender, points[pp].y + y_offset );
 557                 }
 558               }
 559 
 560               if ( best_point != old_best_point )
 561               {
 562                 best_contour_first = first;
 563                 best_contour_last  = last;
 564               }
 565             }
 566           }
 567 
 568           /* now check whether the point belongs to a straight or round   */
 569           /* segment; we first need to find in which contour the extremum */
 570           /* lies, then inspect its previous and next points              */
 571           if ( best_point &gt;= 0 )
 572           {
 573             FT_Pos  best_x = points[best_point].x;
 574             FT_Int  prev, next;
 575             FT_Int  best_segment_first, best_segment_last;
 576             FT_Int  best_on_point_first, best_on_point_last;
 577             FT_Pos  dist;
 578 
 579 
 580             best_segment_first = best_point;
 581             best_segment_last  = best_point;
 582 
 583             if ( FT_CURVE_TAG( outline.tags[best_point] ) == FT_CURVE_TAG_ON )
 584             {
 585               best_on_point_first = best_point;
 586               best_on_point_last  = best_point;
 587             }
 588             else
 589             {
 590               best_on_point_first = -1;
 591               best_on_point_last  = -1;
 592             }
 593 
 594             /* look for the previous and next points on the contour  */
 595             /* that are not on the same Y coordinate, then threshold */
 596             /* the `closeness&#39;...                                    */
 597             prev = best_point;
 598             next = prev;
 599 
 600             do
 601             {
 602               if ( prev &gt; best_contour_first )
 603                 prev--;
 604               else
 605                 prev = best_contour_last;
 606 
 607               dist = FT_ABS( points[prev].y - best_y );
 608               /* accept a small distance or a small angle (both values are */
 609               /* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
 610               if ( dist &gt; 5 )
 611                 if ( FT_ABS( points[prev].x - best_x ) &lt;= 20 * dist )
 612                   break;
 613 
 614               best_segment_first = prev;
 615 
 616               if ( FT_CURVE_TAG( outline.tags[prev] ) == FT_CURVE_TAG_ON )
 617               {
 618                 best_on_point_first = prev;
 619                 if ( best_on_point_last &lt; 0 )
 620                   best_on_point_last = prev;
 621               }
 622 
 623             } while ( prev != best_point );
 624 
 625             do
 626             {
 627               if ( next &lt; best_contour_last )
 628                 next++;
 629               else
 630                 next = best_contour_first;
 631 
 632               dist = FT_ABS( points[next].y - best_y );
 633               if ( dist &gt; 5 )
 634                 if ( FT_ABS( points[next].x - best_x ) &lt;= 20 * dist )
 635                   break;
 636 
 637               best_segment_last = next;
 638 
 639               if ( FT_CURVE_TAG( outline.tags[next] ) == FT_CURVE_TAG_ON )
 640               {
 641                 best_on_point_last = next;
 642                 if ( best_on_point_first &lt; 0 )
 643                   best_on_point_first = next;
 644               }
 645 
 646             } while ( next != best_point );
 647 
 648             if ( AF_LATIN_IS_LONG_BLUE( bs ) )
 649             {
 650               /* If this flag is set, we have an additional constraint to  */
 651               /* get the blue zone distance: Find a segment of the topmost */
 652               /* (or bottommost) contour that is longer than a heuristic   */
 653               /* threshold.  This ensures that small bumps in the outline  */
 654               /* are ignored (for example, the `vertical serifs&#39; found in  */
 655               /* many Hebrew glyph designs).                               */
 656 
 657               /* If this segment is long enough, we are done.  Otherwise,  */
 658               /* search the segment next to the extremum that is long      */
 659               /* enough, has the same direction, and a not too large       */
 660               /* vertical distance from the extremum.  Note that the       */
 661               /* algorithm doesn&#39;t check whether the found segment is      */
 662               /* actually the one (vertically) nearest to the extremum.    */
 663 
 664               /* heuristic threshold value */
 665               FT_Pos  length_threshold = metrics-&gt;units_per_em / 25;
 666 
 667 
 668               dist = FT_ABS( points[best_segment_last].x -
 669                                points[best_segment_first].x );
 670 
 671               if ( dist &lt; length_threshold                       &amp;&amp;
 672                    best_segment_last - best_segment_first + 2 &lt;=
 673                      best_contour_last - best_contour_first      )
 674               {
 675                 /* heuristic threshold value */
 676                 FT_Pos  height_threshold = metrics-&gt;units_per_em / 4;
 677 
 678                 FT_Int   first;
 679                 FT_Int   last;
 680                 FT_Bool  hit;
 681 
 682                 /* we intentionally declare these two variables        */
 683                 /* outside of the loop since various compilers emit    */
 684                 /* incorrect warning messages otherwise, talking about */
 685                 /* `possibly uninitialized variables&#39;                  */
 686                 FT_Int  p_first = 0;            /* make compiler happy */
 687                 FT_Int  p_last  = 0;
 688 
 689                 FT_Bool  left2right;
 690 
 691 
 692                 /* compute direction */
 693                 prev = best_point;
 694 
 695                 do
 696                 {
 697                   if ( prev &gt; best_contour_first )
 698                     prev--;
 699                   else
 700                     prev = best_contour_last;
 701 
 702                   if ( points[prev].x != best_x )
 703                     break;
 704 
 705                 } while ( prev != best_point );
 706 
 707                 /* skip glyph for the degenerate case */
 708                 if ( prev == best_point )
 709                   continue;
 710 
 711                 left2right = FT_BOOL( points[prev].x &lt; points[best_point].x );
 712 
 713                 first = best_segment_last;
 714                 last  = first;
 715                 hit   = 0;
 716 
 717                 do
 718                 {
 719                   FT_Bool  l2r;
 720                   FT_Pos   d;
 721 
 722 
 723                   if ( !hit )
 724                   {
 725                     /* no hit; adjust first point */
 726                     first = last;
 727 
 728                     /* also adjust first and last on point */
 729                     if ( FT_CURVE_TAG( outline.tags[first] ) ==
 730                            FT_CURVE_TAG_ON )
 731                     {
 732                       p_first = first;
 733                       p_last  = first;
 734                     }
 735                     else
 736                     {
 737                       p_first = -1;
 738                       p_last  = -1;
 739                     }
 740 
 741                     hit = 1;
 742                   }
 743 
 744                   if ( last &lt; best_contour_last )
 745                     last++;
 746                   else
 747                     last = best_contour_first;
 748 
 749                   if ( FT_ABS( best_y - points[first].y ) &gt; height_threshold )
 750                   {
 751                     /* vertical distance too large */
 752                     hit = 0;
 753                     continue;
 754                   }
 755 
 756                   /* same test as above */
 757                   dist = FT_ABS( points[last].y - points[first].y );
 758                   if ( dist &gt; 5 )
 759                     if ( FT_ABS( points[last].x - points[first].x ) &lt;=
 760                            20 * dist )
 761                     {
 762                       hit = 0;
 763                       continue;
 764                     }
 765 
 766                   if ( FT_CURVE_TAG( outline.tags[last] ) == FT_CURVE_TAG_ON )
 767                   {
 768                     p_last = last;
 769                     if ( p_first &lt; 0 )
 770                       p_first = last;
 771                   }
 772 
 773                   l2r = FT_BOOL( points[first].x &lt; points[last].x );
 774                   d   = FT_ABS( points[last].x - points[first].x );
 775 
 776                   if ( l2r == left2right     &amp;&amp;
 777                        d &gt;= length_threshold )
 778                   {
 779                     /* all constraints are met; update segment after */
 780                     /* finding its end                               */
 781                     do
 782                     {
 783                       if ( last &lt; best_contour_last )
 784                         last++;
 785                       else
 786                         last = best_contour_first;
 787 
 788                       d = FT_ABS( points[last].y - points[first].y );
 789                       if ( d &gt; 5 )
 790                         if ( FT_ABS( points[next].x - points[first].x ) &lt;=
 791                                20 * dist )
 792                         {
 793                           if ( last &gt; best_contour_first )
 794                             last--;
 795                           else
 796                             last = best_contour_last;
 797                           break;
 798                         }
 799 
 800                       p_last = last;
 801 
 802                       if ( FT_CURVE_TAG( outline.tags[last] ) ==
 803                              FT_CURVE_TAG_ON )
 804                       {
 805                         p_last = last;
 806                         if ( p_first &lt; 0 )
 807                           p_first = last;
 808                       }
 809 
 810                     } while ( last != best_segment_first );
 811 
 812                     best_y = points[first].y;
 813 
 814                     best_segment_first = first;
 815                     best_segment_last  = last;
 816 
 817                     best_on_point_first = p_first;
 818                     best_on_point_last  = p_last;
 819 
 820                     break;
 821                   }
 822 
 823                 } while ( last != best_segment_first );
 824               }
 825             }
 826 
 827             /* for computing blue zones, we add the y offset as returned */
 828             /* by the currently used OpenType feature -- for example,    */
 829             /* superscript glyphs might be identical to subscript glyphs */
 830             /* with a vertical shift                                     */
 831             best_y += y_offset;
 832 
 833 #ifdef FT_DEBUG_LEVEL_TRACE
 834             if ( num_idx == 1 )
 835               FT_TRACE5(( &quot;  U+%04lX: best_y = %5ld&quot;, ch, best_y ));
 836             else
 837               FT_TRACE5(( &quot;  component %d of cluster starting with U+%04lX:&quot;
 838                           &quot; best_y = %5ld&quot;, i, ch, best_y ));
 839 #endif
 840 
 841             /* now set the `round&#39; flag depending on the segment&#39;s kind: */
 842             /*                                                           */
 843             /* - if the horizontal distance between the first and last   */
 844             /*   `on&#39; point is larger than a heuristic threshold         */
 845             /*   we have a flat segment                                  */
 846             /* - if either the first or the last point of the segment is */
 847             /*   an `off&#39; point, the segment is round, otherwise it is   */
 848             /*   flat                                                    */
 849             if ( best_on_point_first &gt;= 0                               &amp;&amp;
 850                  best_on_point_last &gt;= 0                                &amp;&amp;
 851                  ( FT_ABS( points[best_on_point_last].x -
 852                            points[best_on_point_first].x ) ) &gt;
 853                    flat_threshold                                       )
 854               round = 0;
 855             else
 856               round = FT_BOOL(
 857                         FT_CURVE_TAG( outline.tags[best_segment_first] ) !=
 858                           FT_CURVE_TAG_ON                                   ||
 859                         FT_CURVE_TAG( outline.tags[best_segment_last]  ) !=
 860                           FT_CURVE_TAG_ON                                   );
 861 
 862             if ( round &amp;&amp; AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
 863             {
 864               /* only use flat segments for a neutral blue zone */
 865               FT_TRACE5(( &quot; (round, skipped)\n&quot; ));
 866               continue;
 867             }
 868 
 869             FT_TRACE5(( &quot; (%s)\n&quot;, round ? &quot;round&quot; : &quot;flat&quot; ));
 870           }
 871 
 872           if ( AF_LATIN_IS_TOP_BLUE( bs ) )
 873           {
 874             if ( best_y &gt; best_y_extremum )
 875             {
 876               best_y_extremum = best_y;
 877               best_round      = round;
 878             }
 879           }
 880           else
 881           {
 882             if ( best_y &lt; best_y_extremum )
 883             {
 884               best_y_extremum = best_y;
 885               best_round      = round;
 886             }
 887           }
 888 
 889         } /* end for loop */
 890 
 891         if ( !( best_y_extremum == FT_INT_MIN ||
 892                 best_y_extremum == FT_INT_MAX ) )
 893         {
 894           if ( best_round )
 895             rounds[num_rounds++] = best_y_extremum;
 896           else
 897             flats[num_flats++]   = best_y_extremum;
 898         }
 899 
 900       } /* end while loop */
 901 
 902       if ( num_flats == 0 &amp;&amp; num_rounds == 0 )
 903       {
 904         /*
<a name="17" id="anc17"></a><span class="line-modified"> 905          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified"> 906          * we will simply ignore it then</span>
 907          */
 908         FT_TRACE5(( &quot;  empty\n&quot; ));
 909         continue;
 910       }
 911 
 912       /* we have computed the contents of the `rounds&#39; and `flats&#39; tables, */
 913       /* now determine the reference and overshoot position of the blue -- */
 914       /* we simply take the median value after a simple sort               */
 915       af_sort_pos( num_rounds, rounds );
 916       af_sort_pos( num_flats,  flats );
 917 
 918       blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];
 919       blue_ref   = &amp;blue-&gt;ref.org;
 920       blue_shoot = &amp;blue-&gt;shoot.org;
 921 
 922       axis-&gt;blue_count++;
 923 
 924       if ( num_flats == 0 )
 925       {
 926         *blue_ref   =
 927         *blue_shoot = rounds[num_rounds / 2];
 928       }
 929       else if ( num_rounds == 0 )
 930       {
 931         *blue_ref   =
 932         *blue_shoot = flats[num_flats / 2];
 933       }
 934       else
 935       {
 936         *blue_ref   = flats [num_flats  / 2];
 937         *blue_shoot = rounds[num_rounds / 2];
 938       }
 939 
 940       /* there are sometimes problems: if the overshoot position of top     */
 941       /* zones is under its reference position, or the opposite for bottom  */
 942       /* zones.  We must thus check everything there and correct the errors */
 943       if ( *blue_shoot != *blue_ref )
 944       {
 945         FT_Pos   ref      = *blue_ref;
 946         FT_Pos   shoot    = *blue_shoot;
 947         FT_Bool  over_ref = FT_BOOL( shoot &gt; ref );
 948 
 949 
 950         if ( ( AF_LATIN_IS_TOP_BLUE( bs )    ||
 951                AF_LATIN_IS_SUB_TOP_BLUE( bs) ) ^ over_ref )
 952         {
 953           *blue_ref   =
 954           *blue_shoot = ( shoot + ref ) / 2;
 955 
 956           FT_TRACE5(( &quot;  [overshoot smaller than reference,&quot;
 957                       &quot; taking mean value]\n&quot; ));
 958         }
 959       }
 960 
 961       blue-&gt;ascender  = ascender;
 962       blue-&gt;descender = descender;
 963 
 964       blue-&gt;flags = 0;
 965       if ( AF_LATIN_IS_TOP_BLUE( bs ) )
 966         blue-&gt;flags |= AF_LATIN_BLUE_TOP;
 967       if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
 968         blue-&gt;flags |= AF_LATIN_BLUE_SUB_TOP;
 969       if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
 970         blue-&gt;flags |= AF_LATIN_BLUE_NEUTRAL;
 971 
 972       /*
 973        * The following flag is used later to adjust the y and x scales
 974        * in order to optimize the pixel grid alignment of the top of small
 975        * letters.
 976        */
 977       if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
 978         blue-&gt;flags |= AF_LATIN_BLUE_ADJUSTMENT;
 979 
 980       FT_TRACE5(( &quot;    -&gt; reference = %ld\n&quot;
 981                   &quot;       overshoot = %ld\n&quot;,
 982                   *blue_ref, *blue_shoot ));
 983 
 984     } /* end for loop */
 985 
 986     af_shaper_buf_destroy( face, shaper_buf );
 987 
<a name="18" id="anc18"></a>

 988     if ( axis-&gt;blue_count )
 989     {
<a name="19" id="anc19"></a><span class="line-added"> 990       /* we finally check whether blue zones are ordered;            */</span>
<span class="line-added"> 991       /* `ref&#39; and `shoot&#39; values of two blue zones must not overlap */</span>
<span class="line-added"> 992 </span>
 993       FT_UInt       i;
 994       AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
 995 
 996 
 997       for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
 998         blue_sorted[i] = &amp;axis-&gt;blues[i];
 999 
1000       /* sort bottoms of blue zones... */
1001       af_latin_sort_blue( axis-&gt;blue_count, blue_sorted );
1002 
1003       /* ...and adjust top values if necessary */
1004       for ( i = 0; i &lt; axis-&gt;blue_count - 1; i++ )
1005       {
1006         FT_Pos*  a;
1007         FT_Pos*  b;
1008 
1009 #ifdef FT_DEBUG_LEVEL_TRACE
1010         FT_Bool  a_is_top = 0;
1011 #endif
1012 
1013 
1014         if ( blue_sorted[i]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
1015                                        AF_LATIN_BLUE_SUB_TOP ) )
1016         {
1017           a = &amp;blue_sorted[i]-&gt;shoot.org;
1018 #ifdef FT_DEBUG_LEVEL_TRACE
1019           a_is_top = 1;
1020 #endif
1021         }
1022         else
1023           a = &amp;blue_sorted[i]-&gt;ref.org;
1024 
1025         if ( blue_sorted[i + 1]-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
1026                                            AF_LATIN_BLUE_SUB_TOP ) )
1027           b = &amp;blue_sorted[i + 1]-&gt;shoot.org;
1028         else
1029           b = &amp;blue_sorted[i + 1]-&gt;ref.org;
1030 
1031         if ( *a &gt; *b )
1032         {
1033           *a = *b;
1034           FT_TRACE5(( &quot;blue zone overlap:&quot;
1035                       &quot; adjusting %s %d to %ld\n&quot;,
1036                       a_is_top ? &quot;overshoot&quot; : &quot;reference&quot;,
1037                       blue_sorted[i] - axis-&gt;blues,
1038                       *a ));
1039         }
1040       }
<a name="20" id="anc20"></a><span class="line-added">1041 </span>
<span class="line-added">1042       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">1043 </span>
<span class="line-added">1044       return 0;</span>
1045     }
<a name="21" id="anc21"></a><span class="line-added">1046     else</span>
<span class="line-added">1047     {</span>
<span class="line-added">1048       /* disable hinting for the current style if there are no blue zones */</span>
1049 
<a name="22" id="anc22"></a><span class="line-modified">1050       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-added">1051       FT_UShort*      gstyles = globals-&gt;glyph_styles;</span>
<span class="line-added">1052 </span>
<span class="line-added">1053       FT_Long  i;</span>
<span class="line-added">1054 </span>
<span class="line-added">1055 </span>
<span class="line-added">1056       FT_TRACE5(( &quot;no blue zones found:&quot;</span>
<span class="line-added">1057                   &quot; hinting disabled for this style\n&quot; ));</span>
<span class="line-added">1058 </span>
<span class="line-added">1059       for ( i = 0; i &lt; globals-&gt;glyph_count; i++ )</span>
<span class="line-added">1060       {</span>
<span class="line-added">1061         if ( ( gstyles[i] &amp; AF_STYLE_MASK ) == sc-&gt;style )</span>
<span class="line-added">1062           gstyles[i] = AF_STYLE_NONE_DFLT;</span>
<span class="line-added">1063       }</span>
1064 
<a name="23" id="anc23"></a><span class="line-modified">1065       FT_TRACE5(( &quot;\n&quot; ));</span>
<span class="line-added">1066 </span>
<span class="line-added">1067       return 1;</span>
<span class="line-added">1068     }</span>
1069   }
1070 
1071 
1072   /* Check whether all ASCII digits have the same advance width. */
1073 
1074   FT_LOCAL_DEF( void )
1075   af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
1076                                  FT_Face          face )
1077   {
1078     FT_Bool   started = 0, same_width = 1;
1079     FT_Fixed  advance = 0, old_advance = 0;
1080 
<a name="24" id="anc24"></a><span class="line-modified">1081     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">1082     /* unsigned long value.                                        */</span>
<span class="line-added">1083 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">1084     void*     shaper_buf;</span>
<span class="line-added">1085 #else</span>
<span class="line-added">1086     FT_ULong  shaper_buf_;</span>
<span class="line-added">1087     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">1088 #endif</span>
1089 
1090     /* in all supported charmaps, digits have character codes 0x30-0x39 */
1091     const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
1092     const char*  p;
1093 
1094 
<a name="25" id="anc25"></a><span class="line-modified">1095     p = digits;</span>
<span class="line-added">1096 </span>
<span class="line-added">1097 #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
1098     shaper_buf = af_shaper_buf_create( face );
<a name="26" id="anc26"></a><span class="line-added">1099 #endif</span>
1100 
1101     while ( *p )
1102     {
1103       FT_ULong      glyph_index;
1104       unsigned int  num_idx;
1105 
1106 
1107       /* reject input that maps to more than a single glyph */
1108       p = af_shaper_get_cluster( p, &amp;metrics-&gt;root, shaper_buf, &amp;num_idx );
1109       if ( num_idx &gt; 1 )
1110         continue;
1111 
1112       glyph_index = af_shaper_get_elem( &amp;metrics-&gt;root,
1113                                         shaper_buf,
1114                                         0,
1115                                         &amp;advance,
1116                                         NULL );
1117       if ( !glyph_index )
1118         continue;
1119 
1120       if ( started )
1121       {
1122         if ( advance != old_advance )
1123         {
1124           same_width = 0;
1125           break;
1126         }
1127       }
1128       else
1129       {
1130         old_advance = advance;
1131         started     = 1;
1132       }
1133     }
1134 
1135     af_shaper_buf_destroy( face, shaper_buf );
1136 
1137     metrics-&gt;root.digits_have_same_width = same_width;
1138   }
1139 
1140 
1141   /* Initialize global metrics. */
1142 
1143   FT_LOCAL_DEF( FT_Error )
1144   af_latin_metrics_init( AF_LatinMetrics  metrics,
1145                          FT_Face          face )
1146   {
<a name="27" id="anc27"></a><span class="line-added">1147     FT_Error  error = FT_Err_Ok;</span>
<span class="line-added">1148 </span>
1149     FT_CharMap  oldmap = face-&gt;charmap;
1150 
1151 
1152     metrics-&gt;units_per_em = face-&gt;units_per_EM;
1153 
1154     if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
1155     {
1156       af_latin_metrics_init_widths( metrics, face );
<a name="28" id="anc28"></a><span class="line-modified">1157       if ( af_latin_metrics_init_blues( metrics, face ) )</span>
<span class="line-added">1158       {</span>
<span class="line-added">1159         /* use internal error code to indicate missing blue zones */</span>
<span class="line-added">1160         error = -1;</span>
<span class="line-added">1161         goto Exit;</span>
<span class="line-added">1162       }</span>
1163       af_latin_metrics_check_digits( metrics, face );
1164     }
1165 
<a name="29" id="anc29"></a><span class="line-added">1166   Exit:</span>
1167     FT_Set_Charmap( face, oldmap );
<a name="30" id="anc30"></a><span class="line-modified">1168     return error;</span>
1169   }
1170 
1171 
1172   /* Adjust scaling value, then scale and shift widths   */
1173   /* and blue zones (if applicable) for given dimension. */
1174 
1175   static void
1176   af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
1177                               AF_Scaler        scaler,
1178                               AF_Dimension     dim )
1179   {
1180     FT_Fixed      scale;
1181     FT_Pos        delta;
1182     AF_LatinAxis  axis;
1183     FT_UInt       nn;
1184 
1185 
1186     if ( dim == AF_DIMENSION_HORZ )
1187     {
1188       scale = scaler-&gt;x_scale;
1189       delta = scaler-&gt;x_delta;
1190     }
1191     else
1192     {
1193       scale = scaler-&gt;y_scale;
1194       delta = scaler-&gt;y_delta;
1195     }
1196 
1197     axis = &amp;metrics-&gt;axis[dim];
1198 
1199     if ( axis-&gt;org_scale == scale &amp;&amp; axis-&gt;org_delta == delta )
1200       return;
1201 
1202     axis-&gt;org_scale = scale;
1203     axis-&gt;org_delta = delta;
1204 
1205     /*
1206      * correct X and Y scale to optimize the alignment of the top of small
1207      * letters to the pixel grid
1208      */
1209     {
1210       AF_LatinAxis  Axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
1211       AF_LatinBlue  blue = NULL;
1212 
1213 
1214       for ( nn = 0; nn &lt; Axis-&gt;blue_count; nn++ )
1215       {
1216         if ( Axis-&gt;blues[nn].flags &amp; AF_LATIN_BLUE_ADJUSTMENT )
1217         {
1218           blue = &amp;Axis-&gt;blues[nn];
1219           break;
1220         }
1221       }
1222 
1223       if ( blue )
1224       {
1225         FT_Pos   scaled;
1226         FT_Pos   threshold;
1227         FT_Pos   fitted;
1228         FT_UInt  limit;
1229         FT_UInt  ppem;
1230 
1231 
1232         scaled    = FT_MulFix( blue-&gt;shoot.org, scale );
1233         ppem      = metrics-&gt;root.scaler.face-&gt;size-&gt;metrics.x_ppem;
1234         limit     = metrics-&gt;root.globals-&gt;increase_x_height;
1235         threshold = 40;
1236 
1237         /* if the `increase-x-height&#39; property is active, */
1238         /* we round up much more often                    */
1239         if ( limit                                 &amp;&amp;
1240              ppem &lt;= limit                         &amp;&amp;
1241              ppem &gt;= AF_PROP_INCREASE_X_HEIGHT_MIN )
1242           threshold = 52;
1243 
1244         fitted = ( scaled + threshold ) &amp; ~63;
1245 
1246         if ( scaled != fitted )
1247         {
1248 #if 0
1249           if ( dim == AF_DIMENSION_HORZ )
1250           {
1251             if ( fitted &lt; scaled )
1252               scale -= scale / 50;  /* scale *= 0.98 */
1253           }
1254           else
1255 #endif
1256           if ( dim == AF_DIMENSION_VERT )
1257           {
1258             FT_Pos    max_height;
1259             FT_Pos    dist;
1260             FT_Fixed  new_scale;
1261 
1262 
1263             new_scale = FT_MulDiv( scale, fitted, scaled );
1264 
1265             /* the scaling should not change the result by more than two pixels */
1266             max_height = metrics-&gt;units_per_em;
1267 
1268             for ( nn = 0; nn &lt; Axis-&gt;blue_count; nn++ )
1269             {
1270               max_height = FT_MAX( max_height, Axis-&gt;blues[nn].ascender );
1271               max_height = FT_MAX( max_height, -Axis-&gt;blues[nn].descender );
1272             }
1273 
1274             dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );
1275             dist &amp;= ~127;
1276 
1277             if ( dist == 0 )
1278             {
1279               FT_TRACE5((
1280                 &quot;af_latin_metrics_scale_dim:&quot;
1281                 &quot; x height alignment (style `%s&#39;):\n&quot;
1282                 &quot;                           &quot;
1283                 &quot; vertical scaling changed from %.5f to %.5f (by %d%%)\n&quot;
1284                 &quot;\n&quot;,
1285                 af_style_names[metrics-&gt;root.style_class-&gt;style],
1286                 scale / 65536.0,
1287                 new_scale / 65536.0,
1288                 ( fitted - scaled ) * 100 / scaled ));
1289 
1290               scale = new_scale;
1291             }
1292 #ifdef FT_DEBUG_LEVEL_TRACE
1293             else
1294             {
1295               FT_TRACE5((
1296                 &quot;af_latin_metrics_scale_dim:&quot;
1297                 &quot; x height alignment (style `%s&#39;):\n&quot;
1298                 &quot;                           &quot;
1299                 &quot; excessive vertical scaling abandoned\n&quot;
1300                 &quot;\n&quot;,
1301                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1302             }
1303 #endif
1304           }
1305         }
1306       }
1307     }
1308 
1309     axis-&gt;scale = scale;
1310     axis-&gt;delta = delta;
1311 
1312     if ( dim == AF_DIMENSION_HORZ )
1313     {
1314       metrics-&gt;root.scaler.x_scale = scale;
1315       metrics-&gt;root.scaler.x_delta = delta;
1316     }
1317     else
1318     {
1319       metrics-&gt;root.scaler.y_scale = scale;
1320       metrics-&gt;root.scaler.y_delta = delta;
1321     }
1322 
1323     FT_TRACE5(( &quot;%s widths (style `%s&#39;)\n&quot;,
1324                 dim == AF_DIMENSION_HORZ ? &quot;horizontal&quot; : &quot;vertical&quot;,
1325                 af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1326 
1327     /* scale the widths */
1328     for ( nn = 0; nn &lt; axis-&gt;width_count; nn++ )
1329     {
1330       AF_Width  width = axis-&gt;widths + nn;
1331 
1332 
1333       width-&gt;cur = FT_MulFix( width-&gt;org, scale );
1334       width-&gt;fit = width-&gt;cur;
1335 
1336       FT_TRACE5(( &quot;  %d scaled to %.2f\n&quot;,
1337                   width-&gt;org,
1338                   width-&gt;cur / 64.0 ));
1339     }
1340 
1341     FT_TRACE5(( &quot;\n&quot; ));
1342 
1343     /* an extra-light axis corresponds to a standard width that is */
1344     /* smaller than 5/8 pixels                                     */
1345     axis-&gt;extra_light =
<a name="31" id="anc31"></a><span class="line-modified">1346       FT_BOOL( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</span>
1347 
1348 #ifdef FT_DEBUG_LEVEL_TRACE
1349     if ( axis-&gt;extra_light )
1350       FT_TRACE5(( &quot;`%s&#39; style is extra light (at current resolution)\n&quot;
1351                   &quot;\n&quot;,
1352                   af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1353 #endif
1354 
1355     if ( dim == AF_DIMENSION_VERT )
1356     {
1357 #ifdef FT_DEBUG_LEVEL_TRACE
1358       if ( axis-&gt;blue_count )
1359         FT_TRACE5(( &quot;blue zones (style `%s&#39;)\n&quot;,
1360                     af_style_names[metrics-&gt;root.style_class-&gt;style] ));
1361 #endif
1362 
1363       /* scale the blue zones */
1364       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1365       {
1366         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
1367         FT_Pos        dist;
1368 
1369 
1370         blue-&gt;ref.cur   = FT_MulFix( blue-&gt;ref.org, scale ) + delta;
1371         blue-&gt;ref.fit   = blue-&gt;ref.cur;
1372         blue-&gt;shoot.cur = FT_MulFix( blue-&gt;shoot.org, scale ) + delta;
1373         blue-&gt;shoot.fit = blue-&gt;shoot.cur;
1374         blue-&gt;flags    &amp;= ~AF_LATIN_BLUE_ACTIVE;
1375 
1376         /* a blue zone is only active if it is less than 3/4 pixels tall */
1377         dist = FT_MulFix( blue-&gt;ref.org - blue-&gt;shoot.org, scale );
1378         if ( dist &lt;= 48 &amp;&amp; dist &gt;= -48 )
1379         {
1380 #if 0
1381           FT_Pos  delta1;
1382 #endif
1383           FT_Pos  delta2;
1384 
1385 
1386           /* use discrete values for blue zone widths */
1387 
1388 #if 0
1389 
1390           /* generic, original code */
1391           delta1 = blue-&gt;shoot.org - blue-&gt;ref.org;
1392           delta2 = delta1;
1393           if ( delta1 &lt; 0 )
1394             delta2 = -delta2;
1395 
1396           delta2 = FT_MulFix( delta2, scale );
1397 
1398           if ( delta2 &lt; 32 )
1399             delta2 = 0;
1400           else if ( delta2 &lt; 64 )
1401             delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) &amp; ~31 );
1402           else
1403             delta2 = FT_PIX_ROUND( delta2 );
1404 
1405           if ( delta1 &lt; 0 )
1406             delta2 = -delta2;
1407 
1408           blue-&gt;ref.fit   = FT_PIX_ROUND( blue-&gt;ref.cur );
1409           blue-&gt;shoot.fit = blue-&gt;ref.fit + delta2;
1410 
1411 #else
1412 
1413           /* simplified version due to abs(dist) &lt;= 48 */
1414           delta2 = dist;
1415           if ( dist &lt; 0 )
1416             delta2 = -delta2;
1417 
1418           if ( delta2 &lt; 32 )
1419             delta2 = 0;
1420           else if ( delta2 &lt; 48 )
1421             delta2 = 32;
1422           else
1423             delta2 = 64;
1424 
1425           if ( dist &lt; 0 )
1426             delta2 = -delta2;
1427 
1428           blue-&gt;ref.fit   = FT_PIX_ROUND( blue-&gt;ref.cur );
1429           blue-&gt;shoot.fit = blue-&gt;ref.fit - delta2;
1430 
1431 #endif
1432 
1433           blue-&gt;flags |= AF_LATIN_BLUE_ACTIVE;
1434         }
1435       }
1436 
1437       /* use sub-top blue zone only if it doesn&#39;t overlap with */
1438       /* another (non-sup-top) blue zone; otherwise, the       */
1439       /* effect would be similar to a neutral blue zone, which */
1440       /* is not desired here                                   */
1441       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1442       {
1443         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
1444         FT_UInt       i;
1445 
1446 
1447         if ( !( blue-&gt;flags &amp; AF_LATIN_BLUE_SUB_TOP ) )
1448           continue;
1449         if ( !( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) )
1450           continue;
1451 
1452         for ( i = 0; i &lt; axis-&gt;blue_count; i++ )
1453         {
1454           AF_LatinBlue  b = &amp;axis-&gt;blues[i];
1455 
1456 
1457           if ( b-&gt;flags &amp; AF_LATIN_BLUE_SUB_TOP )
1458             continue;
1459           if ( !( b-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) )
1460             continue;
1461 
1462           if ( b-&gt;ref.fit &lt;= blue-&gt;shoot.fit &amp;&amp;
1463                b-&gt;shoot.fit &gt;= blue-&gt;ref.fit )
1464           {
1465             blue-&gt;flags &amp;= ~AF_LATIN_BLUE_ACTIVE;
1466             break;
1467           }
1468         }
1469       }
1470 
1471 #ifdef FT_DEBUG_LEVEL_TRACE
1472       for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )
1473       {
1474         AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];
1475 
1476 
1477         FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;
1478                     &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,
1479                     nn,
1480                     blue-&gt;ref.org,
1481                     blue-&gt;ref.fit / 64.0,
<a name="32" id="anc32"></a><span class="line-modified">1482                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">1483                                                            : &quot; (inactive)&quot;,</span>
1484                     nn,
1485                     blue-&gt;shoot.org,
1486                     blue-&gt;shoot.fit / 64.0,
<a name="33" id="anc33"></a><span class="line-modified">1487                     ( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) ? &quot;&quot;</span>
<span class="line-modified">1488                                                            : &quot; (inactive)&quot; ));</span>
1489       }
1490 #endif
1491     }
1492   }
1493 
1494 
1495   /* Scale global values in both directions. */
1496 
1497   FT_LOCAL_DEF( void )
1498   af_latin_metrics_scale( AF_LatinMetrics  metrics,
1499                           AF_Scaler        scaler )
1500   {
1501     metrics-&gt;root.scaler.render_mode = scaler-&gt;render_mode;
1502     metrics-&gt;root.scaler.face        = scaler-&gt;face;
1503     metrics-&gt;root.scaler.flags       = scaler-&gt;flags;
1504 
1505     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
1506     af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
1507   }
1508 
1509 
1510   /* Extract standard_width from writing system/script specific */
1511   /* metrics class.                                             */
1512 
1513   FT_LOCAL_DEF( void )
1514   af_latin_get_standard_widths( AF_LatinMetrics  metrics,
1515                                 FT_Pos*          stdHW,
1516                                 FT_Pos*          stdVW )
1517   {
1518     if ( stdHW )
1519       *stdHW = metrics-&gt;axis[AF_DIMENSION_VERT].standard_width;
1520 
1521     if ( stdVW )
1522       *stdVW = metrics-&gt;axis[AF_DIMENSION_HORZ].standard_width;
1523   }
1524 
1525 
1526   /*************************************************************************/
1527   /*************************************************************************/
1528   /*****                                                               *****/
1529   /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
1530   /*****                                                               *****/
1531   /*************************************************************************/
1532   /*************************************************************************/
1533 
1534 
1535   /* Walk over all contours and compute its segments. */
1536 
1537   FT_LOCAL_DEF( FT_Error )
1538   af_latin_hints_compute_segments( AF_GlyphHints  hints,
1539                                    AF_Dimension   dim )
1540   {
1541     AF_LatinMetrics  metrics       = (AF_LatinMetrics)hints-&gt;metrics;
1542     AF_AxisHints     axis          = &amp;hints-&gt;axis[dim];
1543     FT_Memory        memory        = hints-&gt;memory;
1544     FT_Error         error         = FT_Err_Ok;
1545     AF_Segment       segment       = NULL;
1546     AF_SegmentRec    seg0;
1547     AF_Point*        contour       = hints-&gt;contours;
1548     AF_Point*        contour_limit = contour + hints-&gt;num_contours;
1549     AF_Direction     major_dir, segment_dir;
1550 
1551     FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );
1552 
1553 
1554     FT_ZERO( &amp;seg0 );
1555     seg0.score = 32000;
1556     seg0.flags = AF_EDGE_NORMAL;
1557 
1558     major_dir   = (AF_Direction)FT_ABS( axis-&gt;major_dir );
1559     segment_dir = major_dir;
1560 
1561     axis-&gt;num_segments = 0;
1562 
1563     /* set up (u,v) in each point */
1564     if ( dim == AF_DIMENSION_HORZ )
1565     {
1566       AF_Point  point = hints-&gt;points;
1567       AF_Point  limit = point + hints-&gt;num_points;
1568 
1569 
1570       for ( ; point &lt; limit; point++ )
1571       {
1572         point-&gt;u = point-&gt;fx;
1573         point-&gt;v = point-&gt;fy;
1574       }
1575     }
1576     else
1577     {
1578       AF_Point  point = hints-&gt;points;
1579       AF_Point  limit = point + hints-&gt;num_points;
1580 
1581 
1582       for ( ; point &lt; limit; point++ )
1583       {
1584         point-&gt;u = point-&gt;fy;
1585         point-&gt;v = point-&gt;fx;
1586       }
1587     }
1588 
1589     /* do each contour separately */
1590     for ( ; contour &lt; contour_limit; contour++ )
1591     {
1592       AF_Point  point   = contour[0];
1593       AF_Point  last    = point-&gt;prev;
1594       int       on_edge = 0;
1595 
1596       /* we call values measured along a segment (point-&gt;v)    */
1597       /* `coordinates&#39;, and values orthogonal to it (point-&gt;u) */
1598       /* `positions&#39;                                           */
1599       FT_Pos     min_pos      =  32000;
1600       FT_Pos     max_pos      = -32000;
1601       FT_Pos     min_coord    =  32000;
1602       FT_Pos     max_coord    = -32000;
1603       FT_UShort  min_flags    =  AF_FLAG_NONE;
1604       FT_UShort  max_flags    =  AF_FLAG_NONE;
1605       FT_Pos     min_on_coord =  32000;
1606       FT_Pos     max_on_coord = -32000;
1607 
1608       FT_Bool  passed;
1609 
1610       AF_Segment  prev_segment = NULL;
1611 
1612       FT_Pos     prev_min_pos      = min_pos;
1613       FT_Pos     prev_max_pos      = max_pos;
1614       FT_Pos     prev_min_coord    = min_coord;
1615       FT_Pos     prev_max_coord    = max_coord;
1616       FT_UShort  prev_min_flags    = min_flags;
1617       FT_UShort  prev_max_flags    = max_flags;
1618       FT_Pos     prev_min_on_coord = min_on_coord;
1619       FT_Pos     prev_max_on_coord = max_on_coord;
1620 
1621 
1622       if ( FT_ABS( last-&gt;out_dir )  == major_dir &amp;&amp;
1623            FT_ABS( point-&gt;out_dir ) == major_dir )
1624       {
1625         /* we are already on an edge, try to locate its start */
1626         last = point;
1627 
1628         for (;;)
1629         {
1630           point = point-&gt;prev;
1631           if ( FT_ABS( point-&gt;out_dir ) != major_dir )
1632           {
1633             point = point-&gt;next;
1634             break;
1635           }
1636           if ( point == last )
1637             break;
1638         }
1639       }
1640 
1641       last   = point;
1642       passed = 0;
1643 
1644       for (;;)
1645       {
1646         FT_Pos  u, v;
1647 
1648 
1649         if ( on_edge )
1650         {
1651           /* get minimum and maximum position */
1652           u = point-&gt;u;
1653           if ( u &lt; min_pos )
1654             min_pos = u;
1655           if ( u &gt; max_pos )
1656             max_pos = u;
1657 
1658           /* get minimum and maximum coordinate together with flags */
1659           v = point-&gt;v;
1660           if ( v &lt; min_coord )
1661           {
1662             min_coord = v;
1663             min_flags = point-&gt;flags;
1664           }
1665           if ( v &gt; max_coord )
1666           {
1667             max_coord = v;
1668             max_flags = point-&gt;flags;
1669           }
1670 
1671           /* get minimum and maximum coordinate of `on&#39; points */
1672           if ( !( point-&gt;flags &amp; AF_FLAG_CONTROL ) )
1673           {
1674             v = point-&gt;v;
1675             if ( v &lt; min_on_coord )
1676               min_on_coord = v;
1677             if ( v &gt; max_on_coord )
1678               max_on_coord = v;
1679           }
1680 
1681           if ( point-&gt;out_dir != segment_dir || point == last )
1682           {
1683             /* check whether the new segment&#39;s start point is identical to */
1684             /* the previous segment&#39;s end point; for example, this might   */
1685             /* happen for spikes                                           */
1686 
1687             if ( !prev_segment || segment-&gt;first != prev_segment-&gt;last )
1688             {
1689               /* points are different: we are just leaving an edge, thus */
1690               /* record a new segment                                    */
1691 
1692               segment-&gt;last  = point;
1693               segment-&gt;pos   = (FT_Short)( ( min_pos + max_pos ) &gt;&gt; 1 );
1694               segment-&gt;delta = (FT_Short)( ( max_pos - min_pos ) &gt;&gt; 1 );
1695 
1696               /* a segment is round if either its first or last point */
1697               /* is a control point, and the length of the on points  */
1698               /* inbetween doesn&#39;t exceed a heuristic limit           */
1699               if ( ( min_flags | max_flags ) &amp; AF_FLAG_CONTROL      &amp;&amp;
1700                    ( max_on_coord - min_on_coord ) &lt; flat_threshold )
1701                 segment-&gt;flags |= AF_EDGE_ROUND;
1702 
1703               segment-&gt;min_coord = (FT_Short)min_coord;
1704               segment-&gt;max_coord = (FT_Short)max_coord;
1705               segment-&gt;height    = segment-&gt;max_coord - segment-&gt;min_coord;
1706 
1707               prev_segment      = segment;
1708               prev_min_pos      = min_pos;
1709               prev_max_pos      = max_pos;
1710               prev_min_coord    = min_coord;
1711               prev_max_coord    = max_coord;
1712               prev_min_flags    = min_flags;
1713               prev_max_flags    = max_flags;
1714               prev_min_on_coord = min_on_coord;
1715               prev_max_on_coord = max_on_coord;
1716             }
1717             else
1718             {
1719               /* points are the same: we don&#39;t create a new segment but */
1720               /* merge the current segment with the previous one        */
1721 
1722               if ( prev_segment-&gt;last-&gt;in_dir == point-&gt;in_dir )
1723               {
1724                 /* we have identical directions (this can happen for       */
1725                 /* degenerate outlines that move zig-zag along the main    */
1726                 /* axis without changing the coordinate value of the other */
1727                 /* axis, and where the segments have just been merged):    */
1728                 /* unify segments                                          */
1729 
1730                 /* update constraints */
1731 
1732                 if ( prev_min_pos &lt; min_pos )
1733                   min_pos = prev_min_pos;
1734                 if ( prev_max_pos &gt; max_pos )
1735                   max_pos = prev_max_pos;
1736 
1737                 if ( prev_min_coord &lt; min_coord )
1738                 {
1739                   min_coord = prev_min_coord;
1740                   min_flags = prev_min_flags;
1741                 }
1742                 if ( prev_max_coord &gt; max_coord )
1743                 {
1744                   max_coord = prev_max_coord;
1745                   max_flags = prev_max_flags;
1746                 }
1747 
1748                 if ( prev_min_on_coord &lt; min_on_coord )
1749                   min_on_coord = prev_min_on_coord;
1750                 if ( prev_max_on_coord &gt; max_on_coord )
1751                   max_on_coord = prev_max_on_coord;
1752 
1753                 prev_segment-&gt;last  = point;
1754                 prev_segment-&gt;pos   = (FT_Short)( ( min_pos +
1755                                                     max_pos ) &gt;&gt; 1 );
1756                 prev_segment-&gt;delta = (FT_Short)( ( max_pos -
1757                                                     min_pos ) &gt;&gt; 1 );
1758 
1759                 if ( ( min_flags | max_flags ) &amp; AF_FLAG_CONTROL      &amp;&amp;
1760                      ( max_on_coord - min_on_coord ) &lt; flat_threshold )
1761                   prev_segment-&gt;flags |= AF_EDGE_ROUND;
1762                 else
1763                   prev_segment-&gt;flags &amp;= ~AF_EDGE_ROUND;
1764 
1765                 prev_segment-&gt;min_coord = (FT_Short)min_coord;
1766                 prev_segment-&gt;max_coord = (FT_Short)max_coord;
1767                 prev_segment-&gt;height    = prev_segment-&gt;max_coord -
1768                                           prev_segment-&gt;min_coord;
1769               }
1770               else
1771               {
1772                 /* we have different directions; use the properties of the */
1773                 /* longer segment and discard the other one                */
1774 
1775                 if ( FT_ABS( prev_max_coord - prev_min_coord ) &gt;
1776                      FT_ABS( max_coord - min_coord ) )
1777                 {
1778                   /* discard current segment */
1779 
1780                   if ( min_pos &lt; prev_min_pos )
1781                     prev_min_pos = min_pos;
1782                   if ( max_pos &gt; prev_max_pos )
1783                     prev_max_pos = max_pos;
1784 
1785                   prev_segment-&gt;last  = point;
1786                   prev_segment-&gt;pos   = (FT_Short)( ( prev_min_pos +
1787                                                       prev_max_pos ) &gt;&gt; 1 );
1788                   prev_segment-&gt;delta = (FT_Short)( ( prev_max_pos -
1789                                                       prev_min_pos ) &gt;&gt; 1 );
1790                 }
1791                 else
1792                 {
1793                   /* discard previous segment */
1794 
1795                   if ( prev_min_pos &lt; min_pos )
1796                     min_pos = prev_min_pos;
1797                   if ( prev_max_pos &gt; max_pos )
1798                     max_pos = prev_max_pos;
1799 
1800                   segment-&gt;last  = point;
1801                   segment-&gt;pos   = (FT_Short)( ( min_pos + max_pos ) &gt;&gt; 1 );
1802                   segment-&gt;delta = (FT_Short)( ( max_pos - min_pos ) &gt;&gt; 1 );
1803 
1804                   if ( ( min_flags | max_flags ) &amp; AF_FLAG_CONTROL      &amp;&amp;
1805                        ( max_on_coord - min_on_coord ) &lt; flat_threshold )
1806                     segment-&gt;flags |= AF_EDGE_ROUND;
1807 
1808                   segment-&gt;min_coord = (FT_Short)min_coord;
1809                   segment-&gt;max_coord = (FT_Short)max_coord;
1810                   segment-&gt;height    = segment-&gt;max_coord -
1811                                        segment-&gt;min_coord;
1812 
1813                   *prev_segment = *segment;
1814 
1815                   prev_min_pos      = min_pos;
1816                   prev_max_pos      = max_pos;
1817                   prev_min_coord    = min_coord;
1818                   prev_max_coord    = max_coord;
1819                   prev_min_flags    = min_flags;
1820                   prev_max_flags    = max_flags;
1821                   prev_min_on_coord = min_on_coord;
1822                   prev_max_on_coord = max_on_coord;
1823                 }
1824               }
1825 
1826               axis-&gt;num_segments--;
1827             }
1828 
1829             on_edge = 0;
1830             segment = NULL;
1831 
1832             /* fall through */
1833           }
1834         }
1835 
1836         /* now exit if we are at the start/end point */
1837         if ( point == last )
1838         {
1839           if ( passed )
1840             break;
1841           passed = 1;
1842         }
1843 
1844         /* if we are not on an edge, check whether the major direction */
1845         /* coincides with the current point&#39;s `out&#39; direction, or      */
1846         /* whether we have a single-point contour                      */
1847         if ( !on_edge                                  &amp;&amp;
1848              ( FT_ABS( point-&gt;out_dir ) == major_dir ||
1849                point == point-&gt;prev                  ) )
1850         {
1851           /* this is the start of a new segment! */
1852           segment_dir = (AF_Direction)point-&gt;out_dir;
1853 
1854           error = af_axis_hints_new_segment( axis, memory, &amp;segment );
1855           if ( error )
1856             goto Exit;
1857 
1858           /* clear all segment fields */
1859           segment[0] = seg0;
1860 
1861           segment-&gt;dir   = (FT_Char)segment_dir;
1862           segment-&gt;first = point;
1863           segment-&gt;last  = point;
1864 
1865           /* `af_axis_hints_new_segment&#39; reallocates memory,    */
1866           /* thus we have to refresh the `prev_segment&#39; pointer */
1867           if ( prev_segment )
1868             prev_segment = segment - 1;
1869 
1870           min_pos   = max_pos   = point-&gt;u;
1871           min_coord = max_coord = point-&gt;v;
1872           min_flags = max_flags = point-&gt;flags;
1873 
1874           if ( point-&gt;flags &amp; AF_FLAG_CONTROL )
1875           {
1876             min_on_coord =  32000;
1877             max_on_coord = -32000;
1878           }
1879           else
1880             min_on_coord = max_on_coord = point-&gt;v;
1881 
1882           on_edge = 1;
1883 
1884           if ( point == point-&gt;prev )
1885           {
1886             /* we have a one-point segment: this is a one-point */
1887             /* contour with `in&#39; and `out&#39; direction set to     */
1888             /* AF_DIR_NONE                                      */
1889             segment-&gt;pos = (FT_Short)min_pos;
1890 
1891             if (point-&gt;flags &amp; AF_FLAG_CONTROL)
1892               segment-&gt;flags |= AF_EDGE_ROUND;
1893 
1894             segment-&gt;min_coord = (FT_Short)point-&gt;v;
1895             segment-&gt;max_coord = (FT_Short)point-&gt;v;
1896             segment-&gt;height = 0;
1897 
1898             on_edge = 0;
1899             segment = NULL;
1900           }
1901         }
1902 
1903         point = point-&gt;next;
1904       }
1905 
1906     } /* contours */
1907 
1908 
1909     /* now slightly increase the height of segments if this makes */
1910     /* sense -- this is used to better detect and ignore serifs   */
1911     {
1912       AF_Segment  segments     = axis-&gt;segments;
1913       AF_Segment  segments_end = segments + axis-&gt;num_segments;
1914 
1915 
1916       for ( segment = segments; segment &lt; segments_end; segment++ )
1917       {
1918         AF_Point  first   = segment-&gt;first;
1919         AF_Point  last    = segment-&gt;last;
1920         FT_Pos    first_v = first-&gt;v;
1921         FT_Pos    last_v  = last-&gt;v;
1922 
1923 
1924         if ( first_v &lt; last_v )
1925         {
1926           AF_Point  p;
1927 
1928 
1929           p = first-&gt;prev;
1930           if ( p-&gt;v &lt; first_v )
1931             segment-&gt;height = (FT_Short)( segment-&gt;height +
1932                                           ( ( first_v - p-&gt;v ) &gt;&gt; 1 ) );
1933 
1934           p = last-&gt;next;
1935           if ( p-&gt;v &gt; last_v )
1936             segment-&gt;height = (FT_Short)( segment-&gt;height +
1937                                           ( ( p-&gt;v - last_v ) &gt;&gt; 1 ) );
1938         }
1939         else
1940         {
1941           AF_Point  p;
1942 
1943 
1944           p = first-&gt;prev;
1945           if ( p-&gt;v &gt; first_v )
1946             segment-&gt;height = (FT_Short)( segment-&gt;height +
1947                                           ( ( p-&gt;v - first_v ) &gt;&gt; 1 ) );
1948 
1949           p = last-&gt;next;
1950           if ( p-&gt;v &lt; last_v )
1951             segment-&gt;height = (FT_Short)( segment-&gt;height +
1952                                           ( ( last_v - p-&gt;v ) &gt;&gt; 1 ) );
1953         }
1954       }
1955     }
1956 
1957   Exit:
1958     return error;
1959   }
1960 
1961 
1962   /* Link segments to form stems and serifs.  If `width_count&#39; and      */
1963   /* `widths&#39; are non-zero, use them to fine-tune the scoring function. */
1964 
1965   FT_LOCAL_DEF( void )
1966   af_latin_hints_link_segments( AF_GlyphHints  hints,
1967                                 FT_UInt        width_count,
1968                                 AF_WidthRec*   widths,
1969                                 AF_Dimension   dim )
1970   {
1971     AF_AxisHints  axis          = &amp;hints-&gt;axis[dim];
1972     AF_Segment    segments      = axis-&gt;segments;
1973     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
1974     FT_Pos        len_threshold, len_score, dist_score, max_width;
1975     AF_Segment    seg1, seg2;
1976 
1977 
1978     if ( width_count )
1979       max_width = widths[width_count - 1].org;
1980     else
1981       max_width = 0;
1982 
1983     /* a heuristic value to set up a minimum value for overlapping */
1984     len_threshold = AF_LATIN_CONSTANT( hints-&gt;metrics, 8 );
1985     if ( len_threshold == 0 )
1986       len_threshold = 1;
1987 
1988     /* a heuristic value to weight lengths */
1989     len_score = AF_LATIN_CONSTANT( hints-&gt;metrics, 6000 );
1990 
1991     /* a heuristic value to weight distances (no call to    */
1992     /* AF_LATIN_CONSTANT needed, since we work on multiples */
1993     /* of the stem width)                                   */
1994     dist_score = 3000;
1995 
1996     /* now compare each segment to the others */
1997     for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )
1998     {
1999       if ( seg1-&gt;dir != axis-&gt;major_dir )
2000         continue;
2001 
2002       /* search for stems having opposite directions, */
2003       /* with seg1 to the `left&#39; of seg2              */
2004       for ( seg2 = segments; seg2 &lt; segment_limit; seg2++ )
2005       {
2006         FT_Pos  pos1 = seg1-&gt;pos;
2007         FT_Pos  pos2 = seg2-&gt;pos;
2008 
2009 
2010         if ( seg1-&gt;dir + seg2-&gt;dir == 0 &amp;&amp; pos2 &gt; pos1 )
2011         {
2012           /* compute distance between the two segments */
2013           FT_Pos  min = seg1-&gt;min_coord;
2014           FT_Pos  max = seg1-&gt;max_coord;
2015           FT_Pos  len;
2016 
2017 
2018           if ( min &lt; seg2-&gt;min_coord )
2019             min = seg2-&gt;min_coord;
2020 
2021           if ( max &gt; seg2-&gt;max_coord )
2022             max = seg2-&gt;max_coord;
2023 
2024           /* compute maximum coordinate difference of the two segments */
2025           /* (this is, how much they overlap)                          */
2026           len = max - min;
2027           if ( len &gt;= len_threshold )
2028           {
2029             /*
<a name="34" id="anc34"></a><span class="line-modified">2030              * The score is the sum of two demerits indicating the</span>
<span class="line-modified">2031              * `badness&#39; of a fit, measured along the segments&#39; main axis</span>
<span class="line-modified">2032              * and orthogonal to it, respectively.</span>
2033              *
<a name="35" id="anc35"></a><span class="line-modified">2034              * - The less overlapping along the main axis, the worse it</span>
<span class="line-modified">2035              *   is, causing a larger demerit.</span>
2036              *
<a name="36" id="anc36"></a><span class="line-modified">2037              * - The nearer the orthogonal distance to a stem width, the</span>
<span class="line-modified">2038              *   better it is, causing a smaller demerit.  For simplicity,</span>
<span class="line-modified">2039              *   however, we only increase the demerit for values that</span>
<span class="line-modified">2040              *   exceed the largest stem width.</span>
2041              */
2042 
2043             FT_Pos  dist = pos2 - pos1;
2044 
2045             FT_Pos  dist_demerit, score;
2046 
2047 
2048             if ( max_width )
2049             {
2050               /* distance demerits are based on multiples of `max_width&#39;; */
2051               /* we scale by 1024 for getting more precision              */
2052               FT_Pos  delta = ( dist &lt;&lt; 10 ) / max_width - ( 1 &lt;&lt; 10 );
2053 
2054 
2055               if ( delta &gt; 10000 )
2056                 dist_demerit = 32000;
2057               else if ( delta &gt; 0 )
2058                 dist_demerit = delta * delta / dist_score;
2059               else
2060                 dist_demerit = 0;
2061             }
2062             else
2063               dist_demerit = dist; /* default if no widths available */
2064 
2065             score = dist_demerit + len_score / len;
2066 
2067             /* and we search for the smallest score */
2068             if ( score &lt; seg1-&gt;score )
2069             {
2070               seg1-&gt;score = score;
2071               seg1-&gt;link  = seg2;
2072             }
2073 
2074             if ( score &lt; seg2-&gt;score )
2075             {
2076               seg2-&gt;score = score;
2077               seg2-&gt;link  = seg1;
2078             }
2079           }
2080         }
2081       }
2082     }
2083 
2084     /* now compute the `serif&#39; segments, cf. explanations in `afhints.h&#39; */
2085     for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )
2086     {
2087       seg2 = seg1-&gt;link;
2088 
2089       if ( seg2 )
2090       {
2091         if ( seg2-&gt;link != seg1 )
2092         {
2093           seg1-&gt;link  = 0;
2094           seg1-&gt;serif = seg2-&gt;link;
2095         }
2096       }
2097     }
2098   }
2099 
2100 
2101   /* Link segments to edges, using feature analysis for selection. */
2102 
2103   FT_LOCAL_DEF( FT_Error )
2104   af_latin_hints_compute_edges( AF_GlyphHints  hints,
2105                                 AF_Dimension   dim )
2106   {
2107     AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];
2108     FT_Error      error  = FT_Err_Ok;
2109     FT_Memory     memory = hints-&gt;memory;
2110     AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];
2111 
<a name="37" id="anc37"></a>



2112     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<a name="38" id="anc38"></a><span class="line-modified">2113     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>

2114 
2115     FT_Bool  top_to_bottom_hinting = 0;
2116 
2117     AF_Segment    segments      = axis-&gt;segments;
2118     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
2119     AF_Segment    seg;
2120 
2121 #if 0
2122     AF_Direction  up_dir;
2123 #endif
2124     FT_Fixed      scale;
2125     FT_Pos        edge_distance_threshold;
2126     FT_Pos        segment_length_threshold;
2127     FT_Pos        segment_width_threshold;
2128 
2129 
2130     axis-&gt;num_edges = 0;
2131 
2132     scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
2133                                          : hints-&gt;y_scale;
2134 
2135 #if 0
2136     up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
2137                                           : AF_DIR_RIGHT;
2138 #endif
2139 
2140     if ( dim == AF_DIMENSION_VERT )
2141       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
2142 
2143     /*
<a name="39" id="anc39"></a><span class="line-modified">2144      * We ignore all segments that are less than 1 pixel in length</span>
<span class="line-modified">2145      * to avoid many problems with serif fonts.  We compute the</span>
<span class="line-modified">2146      * corresponding threshold in font units.</span>
2147      */
2148     if ( dim == AF_DIMENSION_HORZ )
2149       segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );
2150     else
2151       segment_length_threshold = 0;
2152 
2153     /*
<a name="40" id="anc40"></a><span class="line-modified">2154      * Similarly, we ignore segments that have a width delta</span>
<span class="line-modified">2155      * larger than 0.5px (i.e., a width larger than 1px).</span>
2156      */
2157     segment_width_threshold = FT_DivFix( 32, scale );
2158 
<a name="41" id="anc41"></a><span class="line-modified">2159     /**********************************************************************</span>
<span class="line-modified">2160      *</span>
<span class="line-modified">2161      * We begin by generating a sorted table of edges for the current</span>
<span class="line-modified">2162      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="line-modified">2163      * an edge in our table that corresponds to its position.</span>
<span class="line-modified">2164      *</span>
<span class="line-modified">2165      * If no edge is found, we create and insert a new edge in the</span>
<span class="line-modified">2166      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="line-modified">2167      * list which gets processed in the second step to compute the</span>
<span class="line-modified">2168      * edge&#39;s properties.</span>
<span class="line-modified">2169      *</span>
<span class="line-modified">2170      * Note that the table of edges is sorted along the segment/edge</span>
<span class="line-modified">2171      * position.</span>
<span class="line-modified">2172      *</span>
<span class="line-modified">2173      */</span>
2174 
2175     /* assure that edge distance threshold is at most 0.25px */
2176     edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
2177                                          scale );
2178     if ( edge_distance_threshold &gt; 64 / 4 )
2179       edge_distance_threshold = 64 / 4;
2180 
2181     edge_distance_threshold = FT_DivFix( edge_distance_threshold,
2182                                          scale );
2183 
2184     for ( seg = segments; seg &lt; segment_limit; seg++ )
2185     {
2186       AF_Edge  found = NULL;
2187       FT_Int   ee;
2188 
2189 
2190       /* ignore too short segments, too wide ones, and, in this loop, */
2191       /* one-point segments without a direction                       */
2192       if ( seg-&gt;height &lt; segment_length_threshold ||
2193            seg-&gt;delta &gt; segment_width_threshold   ||
2194            seg-&gt;dir == AF_DIR_NONE                )
2195         continue;
2196 
2197       /* A special case for serif edges: If they are smaller than */
2198       /* 1.5 pixels we ignore them.                               */
2199       if ( seg-&gt;serif                                     &amp;&amp;
2200            2 * seg-&gt;height &lt; 3 * segment_length_threshold )
2201         continue;
2202 
2203       /* look for an edge corresponding to the segment */
2204       for ( ee = 0; ee &lt; axis-&gt;num_edges; ee++ )
2205       {
2206         AF_Edge  edge = axis-&gt;edges + ee;
2207         FT_Pos   dist;
2208 
2209 
2210         dist = seg-&gt;pos - edge-&gt;fpos;
2211         if ( dist &lt; 0 )
2212           dist = -dist;
2213 
2214         if ( dist &lt; edge_distance_threshold &amp;&amp; edge-&gt;dir == seg-&gt;dir )
2215         {
2216           found = edge;
2217           break;
2218         }
2219       }
2220 
2221       if ( !found )
2222       {
2223         AF_Edge  edge;
2224 
2225 
2226         /* insert a new edge in the list and */
2227         /* sort according to the position    */
2228         error = af_axis_hints_new_edge( axis, seg-&gt;pos,
2229                                         (AF_Direction)seg-&gt;dir,
2230                                         top_to_bottom_hinting,
2231                                         memory, &amp;edge );
2232         if ( error )
2233           goto Exit;
2234 
2235         /* add the segment to the new edge&#39;s list */
2236         FT_ZERO( edge );
2237 
2238         edge-&gt;first    = seg;
2239         edge-&gt;last     = seg;
2240         edge-&gt;dir      = seg-&gt;dir;
2241         edge-&gt;fpos     = seg-&gt;pos;
2242         edge-&gt;opos     = FT_MulFix( seg-&gt;pos, scale );
2243         edge-&gt;pos      = edge-&gt;opos;
2244         seg-&gt;edge_next = seg;
2245       }
2246       else
2247       {
2248         /* if an edge was found, simply add the segment to the edge&#39;s */
2249         /* list                                                       */
2250         seg-&gt;edge_next         = found-&gt;first;
2251         found-&gt;last-&gt;edge_next = seg;
2252         found-&gt;last            = seg;
2253       }
2254     }
2255 
2256     /* we loop again over all segments to catch one-point segments   */
2257     /* without a direction: if possible, link them to existing edges */
2258     for ( seg = segments; seg &lt; segment_limit; seg++ )
2259     {
2260       AF_Edge  found = NULL;
2261       FT_Int   ee;
2262 
2263 
2264       if ( seg-&gt;dir != AF_DIR_NONE )
2265         continue;
2266 
2267       /* look for an edge corresponding to the segment */
2268       for ( ee = 0; ee &lt; axis-&gt;num_edges; ee++ )
2269       {
2270         AF_Edge  edge = axis-&gt;edges + ee;
2271         FT_Pos   dist;
2272 
2273 
2274         dist = seg-&gt;pos - edge-&gt;fpos;
2275         if ( dist &lt; 0 )
2276           dist = -dist;
2277 
2278         if ( dist &lt; edge_distance_threshold )
2279         {
2280           found = edge;
2281           break;
2282         }
2283       }
2284 
2285       /* one-point segments without a match are ignored */
2286       if ( found )
2287       {
2288         seg-&gt;edge_next         = found-&gt;first;
2289         found-&gt;last-&gt;edge_next = seg;
2290         found-&gt;last            = seg;
2291       }
2292     }
2293 
2294 
<a name="42" id="anc42"></a><span class="line-modified">2295     /*******************************************************************</span>
<span class="line-modified">2296      *</span>
<span class="line-modified">2297      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="line-modified">2298      * segments found on its position.  Basically, these are</span>
<span class="line-modified">2299      *</span>
<span class="line-modified">2300      * - the edge&#39;s main direction</span>
<span class="line-modified">2301      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="line-modified">2302      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="line-modified">2303      * - link for edge</span>
<span class="line-modified">2304      *</span>
<span class="line-modified">2305      */</span>
2306 
2307     /* first of all, set the `edge&#39; field in each segment -- this is */
2308     /* required in order to compute edge links                       */
2309 
2310     /*
2311      * Note that removing this loop and setting the `edge&#39; field of each
2312      * segment directly in the code above slows down execution speed for
2313      * some reasons on platforms like the Sun.
2314      */
2315     {
2316       AF_Edge  edges      = axis-&gt;edges;
2317       AF_Edge  edge_limit = edges + axis-&gt;num_edges;
2318       AF_Edge  edge;
2319 
2320 
2321       for ( edge = edges; edge &lt; edge_limit; edge++ )
2322       {
2323         seg = edge-&gt;first;
2324         if ( seg )
2325           do
2326           {
2327             seg-&gt;edge = edge;
2328             seg       = seg-&gt;edge_next;
2329 
2330           } while ( seg != edge-&gt;first );
2331       }
2332 
2333       /* now compute each edge properties */
2334       for ( edge = edges; edge &lt; edge_limit; edge++ )
2335       {
2336         FT_Int  is_round    = 0;  /* does it contain round segments?    */
2337         FT_Int  is_straight = 0;  /* does it contain straight segments? */
2338 #if 0
2339         FT_Pos  ups         = 0;  /* number of upwards segments         */
2340         FT_Pos  downs       = 0;  /* number of downwards segments       */
2341 #endif
2342 
2343 
2344         seg = edge-&gt;first;
2345 
2346         do
2347         {
2348           FT_Bool  is_serif;
2349 
2350 
2351           /* check for roundness of segment */
2352           if ( seg-&gt;flags &amp; AF_EDGE_ROUND )
2353             is_round++;
2354           else
2355             is_straight++;
2356 
2357 #if 0
2358           /* check for segment direction */
2359           if ( seg-&gt;dir == up_dir )
2360             ups   += seg-&gt;max_coord - seg-&gt;min_coord;
2361           else
2362             downs += seg-&gt;max_coord - seg-&gt;min_coord;
2363 #endif
2364 
2365           /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
2366           /* be ignored                                                   */
<a name="43" id="anc43"></a><span class="line-modified">2367           is_serif = FT_BOOL( seg-&gt;serif               &amp;&amp;</span>
<span class="line-modified">2368                               seg-&gt;serif-&gt;edge         &amp;&amp;</span>
<span class="line-modified">2369                               seg-&gt;serif-&gt;edge != edge );</span>
2370 
2371           if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge ) || is_serif )
2372           {
2373             AF_Edge     edge2;
2374             AF_Segment  seg2;
2375 
2376 
2377             edge2 = edge-&gt;link;
2378             seg2  = seg-&gt;link;
2379 
2380             if ( is_serif )
2381             {
2382               seg2  = seg-&gt;serif;
2383               edge2 = edge-&gt;serif;
2384             }
2385 
2386             if ( edge2 )
2387             {
2388               FT_Pos  edge_delta;
2389               FT_Pos  seg_delta;
2390 
2391 
2392               edge_delta = edge-&gt;fpos - edge2-&gt;fpos;
2393               if ( edge_delta &lt; 0 )
2394                 edge_delta = -edge_delta;
2395 
2396               seg_delta = seg-&gt;pos - seg2-&gt;pos;
2397               if ( seg_delta &lt; 0 )
2398                 seg_delta = -seg_delta;
2399 
2400               if ( seg_delta &lt; edge_delta )
2401                 edge2 = seg2-&gt;edge;
2402             }
2403             else
2404               edge2 = seg2-&gt;edge;
2405 
2406             if ( is_serif )
2407             {
2408               edge-&gt;serif   = edge2;
2409               edge2-&gt;flags |= AF_EDGE_SERIF;
2410             }
2411             else
2412               edge-&gt;link  = edge2;
2413           }
2414 
2415           seg = seg-&gt;edge_next;
2416 
2417         } while ( seg != edge-&gt;first );
2418 
2419         /* set the round/straight flags */
2420         edge-&gt;flags = AF_EDGE_NORMAL;
2421 
2422         if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
2423           edge-&gt;flags |= AF_EDGE_ROUND;
2424 
2425 #if 0
2426         /* set the edge&#39;s main direction */
2427         edge-&gt;dir = AF_DIR_NONE;
2428 
2429         if ( ups &gt; downs )
2430           edge-&gt;dir = (FT_Char)up_dir;
2431 
2432         else if ( ups &lt; downs )
2433           edge-&gt;dir = (FT_Char)-up_dir;
2434 
2435         else if ( ups == downs )
2436           edge-&gt;dir = 0;  /* both up and down! */
2437 #endif
2438 
2439         /* get rid of serifs if link is set                 */
2440         /* XXX: This gets rid of many unpleasant artefacts! */
2441         /*      Example: the `c&#39; in cour.pfa at size 13     */
2442 
2443         if ( edge-&gt;serif &amp;&amp; edge-&gt;link )
2444           edge-&gt;serif = NULL;
2445       }
2446     }
2447 
2448   Exit:
2449     return error;
2450   }
2451 
2452 
2453   /* Detect segments and edges for given dimension. */
2454 
2455   FT_LOCAL_DEF( FT_Error )
2456   af_latin_hints_detect_features( AF_GlyphHints  hints,
2457                                   FT_UInt        width_count,
2458                                   AF_WidthRec*   widths,
2459                                   AF_Dimension   dim )
2460   {
2461     FT_Error  error;
2462 
2463 
2464     error = af_latin_hints_compute_segments( hints, dim );
2465     if ( !error )
2466     {
2467       af_latin_hints_link_segments( hints, width_count, widths, dim );
2468 
2469       error = af_latin_hints_compute_edges( hints, dim );
2470     }
2471 
2472     return error;
2473   }
2474 
2475 
2476   /* Compute all edges which lie within blue zones. */
2477 
2478   static void
2479   af_latin_hints_compute_blue_edges( AF_GlyphHints    hints,
2480                                      AF_LatinMetrics  metrics )
2481   {
2482     AF_AxisHints  axis       = &amp;hints-&gt;axis[AF_DIMENSION_VERT];
2483     AF_Edge       edge       = axis-&gt;edges;
2484     AF_Edge       edge_limit = edge + axis-&gt;num_edges;
2485     AF_LatinAxis  latin      = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
2486     FT_Fixed      scale      = latin-&gt;scale;
2487 
2488 
2489     /* compute which blue zones are active, i.e. have their scaled */
2490     /* size &lt; 3/4 pixels                                           */
2491 
2492     /* for each horizontal edge search the blue zone which is closest */
2493     for ( ; edge &lt; edge_limit; edge++ )
2494     {
2495       FT_UInt   bb;
2496       AF_Width  best_blue            = NULL;
2497       FT_Bool   best_blue_is_neutral = 0;
2498       FT_Pos    best_dist;                 /* initial threshold */
2499 
2500 
2501       /* compute the initial threshold as a fraction of the EM size */
2502       /* (the value 40 is heuristic)                                */
2503       best_dist = FT_MulFix( metrics-&gt;units_per_em / 40, scale );
2504 
2505       /* assure a minimum distance of 0.5px */
2506       if ( best_dist &gt; 64 / 2 )
2507         best_dist = 64 / 2;
2508 
2509       for ( bb = 0; bb &lt; latin-&gt;blue_count; bb++ )
2510       {
2511         AF_LatinBlue  blue = latin-&gt;blues + bb;
2512         FT_Bool       is_top_blue, is_neutral_blue, is_major_dir;
2513 
2514 
2515         /* skip inactive blue zones (i.e., those that are too large) */
2516         if ( !( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) )
2517           continue;
2518 
2519         /* if it is a top zone, check for right edges (against the major */
2520         /* direction); if it is a bottom zone, check for left edges (in  */
2521         /* the major direction) -- this assumes the TrueType convention  */
2522         /* for the orientation of contours                               */
2523         is_top_blue =
2524           (FT_Byte)( ( blue-&gt;flags &amp; ( AF_LATIN_BLUE_TOP     |
2525                                        AF_LATIN_BLUE_SUB_TOP ) ) != 0 );
2526         is_neutral_blue =
2527           (FT_Byte)( ( blue-&gt;flags &amp; AF_LATIN_BLUE_NEUTRAL ) != 0);
2528         is_major_dir =
2529           FT_BOOL( edge-&gt;dir == axis-&gt;major_dir );
2530 
2531         /* neutral blue zones are handled for both directions */
2532         if ( is_top_blue ^ is_major_dir || is_neutral_blue )
2533         {
2534           FT_Pos  dist;
2535 
2536 
2537           /* first of all, compare it to the reference position */
2538           dist = edge-&gt;fpos - blue-&gt;ref.org;
2539           if ( dist &lt; 0 )
2540             dist = -dist;
2541 
2542           dist = FT_MulFix( dist, scale );
2543           if ( dist &lt; best_dist )
2544           {
2545             best_dist            = dist;
2546             best_blue            = &amp;blue-&gt;ref;
2547             best_blue_is_neutral = is_neutral_blue;
2548           }
2549 
2550           /* now compare it to the overshoot position and check whether */
2551           /* the edge is rounded, and whether the edge is over the      */
2552           /* reference position of a top zone, or under the reference   */
2553           /* position of a bottom zone (provided we don&#39;t have a        */
2554           /* neutral blue zone)                                         */
2555           if ( edge-&gt;flags &amp; AF_EDGE_ROUND &amp;&amp;
2556                dist != 0                   &amp;&amp;
2557                !is_neutral_blue            )
2558           {
2559             FT_Bool  is_under_ref = FT_BOOL( edge-&gt;fpos &lt; blue-&gt;ref.org );
2560 
2561 
2562             if ( is_top_blue ^ is_under_ref )
2563             {
2564               dist = edge-&gt;fpos - blue-&gt;shoot.org;
2565               if ( dist &lt; 0 )
2566                 dist = -dist;
2567 
2568               dist = FT_MulFix( dist, scale );
2569               if ( dist &lt; best_dist )
2570               {
2571                 best_dist            = dist;
2572                 best_blue            = &amp;blue-&gt;shoot;
2573                 best_blue_is_neutral = is_neutral_blue;
2574               }
2575             }
2576           }
2577         }
2578       }
2579 
2580       if ( best_blue )
2581       {
2582         edge-&gt;blue_edge = best_blue;
2583         if ( best_blue_is_neutral )
2584           edge-&gt;flags |= AF_EDGE_NEUTRAL;
2585       }
2586     }
2587   }
2588 
2589 
2590   /* Initalize hinting engine. */
2591 
2592   static FT_Error
2593   af_latin_hints_init( AF_GlyphHints    hints,
2594                        AF_LatinMetrics  metrics )
2595   {
2596     FT_Render_Mode  mode;
2597     FT_UInt32       scaler_flags, other_flags;
2598     FT_Face         face = metrics-&gt;root.scaler.face;
2599 
2600 
2601     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
2602 
2603     /*
<a name="44" id="anc44"></a><span class="line-modified">2604      * correct x_scale and y_scale if needed, since they may have</span>
<span class="line-modified">2605      * been modified by `af_latin_metrics_scale_dim&#39; above</span>
2606      */
2607     hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
2608     hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
2609     hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
2610     hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
2611 
2612     /* compute flags depending on render mode, etc. */
2613     mode = metrics-&gt;root.scaler.render_mode;
2614 
2615 #if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
2616     if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
2617       metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
2618 #endif
2619 
2620     scaler_flags = hints-&gt;scaler_flags;
2621     other_flags  = 0;
2622 
2623     /*
<a name="45" id="anc45"></a><span class="line-modified">2624      * We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">2625      * horizontal LCD rendering targets only.</span>
2626      */
2627     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
2628       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
2629 
2630     /*
<a name="46" id="anc46"></a><span class="line-modified">2631      * We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">2632      * vertical LCD rendering targets only.</span>
2633      */
2634     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
2635       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
2636 
2637     /*
<a name="47" id="anc47"></a><span class="line-modified">2638      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
2639      */
2640     if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
2641       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
2642 
2643     if ( mode == FT_RENDER_MODE_MONO )
2644       other_flags |= AF_LATIN_HINTS_MONO;
2645 
2646     /*
<a name="48" id="anc48"></a><span class="line-modified">2647      * In `light&#39; or `lcd&#39; mode we disable horizontal hinting completely.</span>
<span class="line-modified">2648      * We also do it if the face is italic.</span>
2649      *
<a name="49" id="anc49"></a><span class="line-modified">2650      * However, if warping is enabled (which only works in `light&#39; hinting</span>
<span class="line-modified">2651      * mode), advance widths get adjusted, too.</span>
2652      */
2653     if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
2654          ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0          )
2655       scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
2656 
2657 #ifdef AF_CONFIG_OPTION_USE_WARPER
2658     /* get (global) warper flag */
2659     if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )
2660       scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
2661 #endif
2662 
2663     hints-&gt;scaler_flags = scaler_flags;
2664     hints-&gt;other_flags  = other_flags;
2665 
2666     return FT_Err_Ok;
2667   }
2668 
2669 
2670   /*************************************************************************/
2671   /*************************************************************************/
2672   /*****                                                               *****/
2673   /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
2674   /*****                                                               *****/
2675   /*************************************************************************/
2676   /*************************************************************************/
2677 
2678   /* Snap a given width in scaled coordinates to one of the */
2679   /* current standard widths.                               */
2680 
2681   static FT_Pos
2682   af_latin_snap_width( AF_Width  widths,
2683                        FT_UInt   count,
2684                        FT_Pos    width )
2685   {
2686     FT_UInt  n;
2687     FT_Pos   best      = 64 + 32 + 2;
2688     FT_Pos   reference = width;
2689     FT_Pos   scaled;
2690 
2691 
2692     for ( n = 0; n &lt; count; n++ )
2693     {
2694       FT_Pos  w;
2695       FT_Pos  dist;
2696 
2697 
2698       w = widths[n].cur;
2699       dist = width - w;
2700       if ( dist &lt; 0 )
2701         dist = -dist;
2702       if ( dist &lt; best )
2703       {
2704         best      = dist;
2705         reference = w;
2706       }
2707     }
2708 
2709     scaled = FT_PIX_ROUND( reference );
2710 
2711     if ( width &gt;= reference )
2712     {
2713       if ( width &lt; scaled + 48 )
2714         width = reference;
2715     }
2716     else
2717     {
2718       if ( width &gt; scaled - 48 )
2719         width = reference;
2720     }
2721 
2722     return width;
2723   }
2724 
2725 
2726   /* Compute the snapped width of a given stem, ignoring very thin ones. */
2727   /* There is a lot of voodoo in this function; changing the hard-coded  */
2728   /* parameters influence the whole hinting process.                     */
2729 
2730   static FT_Pos
2731   af_latin_compute_stem_width( AF_GlyphHints  hints,
2732                                AF_Dimension   dim,
2733                                FT_Pos         width,
2734                                FT_Pos         base_delta,
2735                                FT_UInt        base_flags,
2736                                FT_UInt        stem_flags )
2737   {
2738     AF_LatinMetrics  metrics  = (AF_LatinMetrics)hints-&gt;metrics;
2739     AF_LatinAxis     axis     = &amp;metrics-&gt;axis[dim];
2740     FT_Pos           dist     = width;
2741     FT_Int           sign     = 0;
2742     FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
2743 
2744 
2745     if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
2746          axis-&gt;extra_light                       )
2747       return width;
2748 
2749     if ( dist &lt; 0 )
2750     {
2751       dist = -width;
2752       sign = 1;
2753     }
2754 
2755     if ( (  vertical &amp;&amp; !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
2756          ( !vertical &amp;&amp; !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )
2757     {
2758       /* smooth hinting process: very lightly quantize the stem width */
2759 
2760       /* leave the widths of serifs alone */
2761       if ( ( stem_flags &amp; AF_EDGE_SERIF ) &amp;&amp;
2762            vertical                       &amp;&amp;
2763            ( dist &lt; 3 * 64 )              )
2764         goto Done_Width;
2765 
2766       else if ( base_flags &amp; AF_EDGE_ROUND )
2767       {
2768         if ( dist &lt; 80 )
2769           dist = 64;
2770       }
2771       else if ( dist &lt; 56 )
2772         dist = 56;
2773 
2774       if ( axis-&gt;width_count &gt; 0 )
2775       {
2776         FT_Pos  delta;
2777 
2778 
2779         /* compare to standard width */
2780         delta = dist - axis-&gt;widths[0].cur;
2781 
2782         if ( delta &lt; 0 )
2783           delta = -delta;
2784 
2785         if ( delta &lt; 40 )
2786         {
2787           dist = axis-&gt;widths[0].cur;
2788           if ( dist &lt; 48 )
2789             dist = 48;
2790 
2791           goto Done_Width;
2792         }
2793 
2794         if ( dist &lt; 3 * 64 )
2795         {
2796           delta  = dist &amp; 63;
2797           dist  &amp;= -64;
2798 
2799           if ( delta &lt; 10 )
2800             dist += delta;
2801 
2802           else if ( delta &lt; 32 )
2803             dist += 10;
2804 
2805           else if ( delta &lt; 54 )
2806             dist += 54;
2807 
2808           else
2809             dist += delta;
2810         }
2811         else
2812         {
2813           /* A stem&#39;s end position depends on two values: the start        */
2814           /* position and the stem length.  The former gets usually        */
2815           /* rounded to the grid, while the latter gets rounded also if it */
2816           /* exceeds a certain length (see below in this function).  This  */
2817           /* `double rounding&#39; can lead to a great difference to the       */
2818           /* original, unhinted position; this normally doesn&#39;t matter for */
2819           /* large PPEM values, but for small sizes it can easily make     */
2820           /* outlines collide.  For this reason, we adjust the stem length */
2821           /* by a small amount depending on the PPEM value in case the     */
2822           /* former and latter rounding both point into the same           */
2823           /* direction.                                                    */
2824 
2825           FT_Pos  bdelta = 0;
2826 
2827 
2828           if ( ( ( width &gt; 0 ) &amp;&amp; ( base_delta &gt; 0 ) ) ||
2829                ( ( width &lt; 0 ) &amp;&amp; ( base_delta &lt; 0 ) ) )
2830           {
2831             FT_UInt  ppem = metrics-&gt;root.scaler.face-&gt;size-&gt;metrics.x_ppem;
2832 
2833 
2834             if ( ppem &lt; 10 )
2835               bdelta = base_delta;
2836             else if ( ppem &lt; 30 )
2837               bdelta = ( base_delta * (FT_Pos)( 30 - ppem ) ) / 20;
2838 
2839             if ( bdelta &lt; 0 )
2840               bdelta = -bdelta;
2841           }
2842 
2843           dist = ( dist - bdelta + 32 ) &amp; ~63;
2844         }
2845       }
2846     }
2847     else
2848     {
2849       /* strong hinting process: snap the stem width to integer pixels */
2850 
2851       FT_Pos  org_dist = dist;
2852 
2853 
2854       dist = af_latin_snap_width( axis-&gt;widths, axis-&gt;width_count, dist );
2855 
2856       if ( vertical )
2857       {
2858         /* in the case of vertical hinting, always round */
2859         /* the stem heights to integer pixels            */
2860 
2861         if ( dist &gt;= 64 )
2862           dist = ( dist + 16 ) &amp; ~63;
2863         else
2864           dist = 64;
2865       }
2866       else
2867       {
2868         if ( AF_LATIN_HINTS_DO_MONO( hints ) )
2869         {
2870           /* monochrome horizontal hinting: snap widths to integer pixels */
2871           /* with a different threshold                                   */
2872 
2873           if ( dist &lt; 64 )
2874             dist = 64;
2875           else
2876             dist = ( dist + 32 ) &amp; ~63;
2877         }
2878         else
2879         {
2880           /* for horizontal anti-aliased hinting, we adopt a more subtle */
2881           /* approach: we strengthen small stems, round stems whose size */
2882           /* is between 1 and 2 pixels to an integer, otherwise nothing  */
2883 
2884           if ( dist &lt; 48 )
2885             dist = ( dist + 64 ) &gt;&gt; 1;
2886 
2887           else if ( dist &lt; 128 )
2888           {
2889             /* We only round to an integer width if the corresponding */
2890             /* distortion is less than 1/4 pixel.  Otherwise this     */
2891             /* makes everything worse since the diagonals, which are  */
2892             /* not hinted, appear a lot bolder or thinner than the    */
2893             /* vertical stems.                                        */
2894 
2895             FT_Pos  delta;
2896 
2897 
2898             dist = ( dist + 22 ) &amp; ~63;
2899             delta = dist - org_dist;
2900             if ( delta &lt; 0 )
2901               delta = -delta;
2902 
2903             if ( delta &gt;= 16 )
2904             {
2905               dist = org_dist;
2906               if ( dist &lt; 48 )
2907                 dist = ( dist + 64 ) &gt;&gt; 1;
2908             }
2909           }
2910           else
2911             /* round otherwise to prevent color fringes in LCD mode */
2912             dist = ( dist + 32 ) &amp; ~63;
2913         }
2914       }
2915     }
2916 
2917   Done_Width:
2918     if ( sign )
2919       dist = -dist;
2920 
2921     return dist;
2922   }
2923 
2924 
2925   /* Align one stem edge relative to the previous stem edge. */
2926 
2927   static void
2928   af_latin_align_linked_edge( AF_GlyphHints  hints,
2929                               AF_Dimension   dim,
2930                               AF_Edge        base_edge,
2931                               AF_Edge        stem_edge )
2932   {
2933     FT_Pos  dist, base_delta;
2934     FT_Pos  fitted_width;
2935 
2936 
2937     dist       = stem_edge-&gt;opos - base_edge-&gt;opos;
2938     base_delta = base_edge-&gt;pos - base_edge-&gt;opos;
2939 
2940     fitted_width = af_latin_compute_stem_width( hints, dim,
2941                                                 dist, base_delta,
2942                                                 base_edge-&gt;flags,
2943                                                 stem_edge-&gt;flags );
2944 
2945 
2946     stem_edge-&gt;pos = base_edge-&gt;pos + fitted_width;
2947 
2948     FT_TRACE5(( &quot;  LINK: edge %d (opos=%.2f) linked to %.2f,&quot;
2949                 &quot; dist was %.2f, now %.2f\n&quot;,
2950                 stem_edge - hints-&gt;axis[dim].edges, stem_edge-&gt;opos / 64.0,
2951                 stem_edge-&gt;pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
2952   }
2953 
2954 
2955   /* Shift the coordinates of the `serif&#39; edge by the same amount */
2956   /* as the corresponding `base&#39; edge has been moved already.     */
2957 
2958   static void
2959   af_latin_align_serif_edge( AF_GlyphHints  hints,
2960                              AF_Edge        base,
2961                              AF_Edge        serif )
2962   {
2963     FT_UNUSED( hints );
2964 
2965     serif-&gt;pos = base-&gt;pos + ( serif-&gt;opos - base-&gt;opos );
2966   }
2967 
2968 
2969   /*************************************************************************/
2970   /*************************************************************************/
2971   /*************************************************************************/
2972   /****                                                                 ****/
2973   /****                    E D G E   H I N T I N G                      ****/
2974   /****                                                                 ****/
2975   /*************************************************************************/
2976   /*************************************************************************/
2977   /*************************************************************************/
2978 
2979 
2980   /* The main grid-fitting routine. */
2981 
2982   static void
2983   af_latin_hint_edges( AF_GlyphHints  hints,
2984                        AF_Dimension   dim )
2985   {
2986     AF_AxisHints  axis       = &amp;hints-&gt;axis[dim];
2987     AF_Edge       edges      = axis-&gt;edges;
2988     AF_Edge       edge_limit = edges + axis-&gt;num_edges;
2989     FT_PtrDist    n_edges;
2990     AF_Edge       edge;
2991     AF_Edge       anchor     = NULL;
2992     FT_Int        has_serifs = 0;
2993 
<a name="50" id="anc50"></a>



2994     AF_StyleClass   style_class  = hints-&gt;metrics-&gt;style_class;
<a name="51" id="anc51"></a><span class="line-modified">2995     AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>

2996 
2997     FT_Bool  top_to_bottom_hinting = 0;
2998 
2999 #ifdef FT_DEBUG_LEVEL_TRACE
3000     FT_UInt  num_actions = 0;
3001 #endif
3002 
3003 
3004     FT_TRACE5(( &quot;latin %s edge hinting (style `%s&#39;)\n&quot;,
3005                 dim == AF_DIMENSION_VERT ? &quot;horizontal&quot; : &quot;vertical&quot;,
3006                 af_style_names[hints-&gt;metrics-&gt;style_class-&gt;style] ));
3007 
3008     if ( dim == AF_DIMENSION_VERT )
3009       top_to_bottom_hinting = script_class-&gt;top_to_bottom_hinting;
3010 
3011     /* we begin by aligning all stems relative to the blue zone */
3012     /* if needed -- that&#39;s only for horizontal edges            */
3013 
3014     if ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_BLUES( hints ) )
3015     {
3016       for ( edge = edges; edge &lt; edge_limit; edge++ )
3017       {
3018         AF_Width  blue;
3019         AF_Edge   edge1, edge2; /* these edges form the stem to check */
3020 
3021 
3022         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3023           continue;
3024 
3025         edge1 = NULL;
3026         edge2 = edge-&gt;link;
3027 
3028         /*
<a name="52" id="anc52"></a><span class="line-modified">3029          * If a stem contains both a neutral and a non-neutral blue zone,</span>
<span class="line-modified">3030          * skip the neutral one.  Otherwise, outlines with different</span>
<span class="line-modified">3031          * directions might be incorrectly aligned at the same vertical</span>
<span class="line-modified">3032          * position.</span>
3033          *
<a name="53" id="anc53"></a><span class="line-modified">3034          * If we have two neutral blue zones, skip one of them.</span>
3035          *
3036          */
3037         if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )
3038         {
3039           FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;
3040           FT_Byte  neutral2 = edge2-&gt;flags &amp; AF_EDGE_NEUTRAL;
3041 
3042 
3043           if ( neutral2 )
3044           {
3045             edge2-&gt;blue_edge = NULL;
3046             edge2-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
3047           }
3048           else if ( neutral )
3049           {
3050             edge-&gt;blue_edge = NULL;
3051             edge-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;
3052           }
3053         }
3054 
3055         blue = edge-&gt;blue_edge;
3056         if ( blue )
3057           edge1 = edge;
3058 
3059         /* flip edges if the other edge is aligned to a blue zone */
3060         else if ( edge2 &amp;&amp; edge2-&gt;blue_edge )
3061         {
3062           blue  = edge2-&gt;blue_edge;
3063           edge1 = edge2;
3064           edge2 = edge;
3065         }
3066 
3067         if ( !edge1 )
3068           continue;
3069 
3070 #ifdef FT_DEBUG_LEVEL_TRACE
3071         if ( !anchor )
3072           FT_TRACE5(( &quot;  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,&quot;
3073                       &quot; was %.2f (anchor=edge %d)\n&quot;,
3074                       edge1 - edges, edge1-&gt;opos / 64.0, blue-&gt;fit / 64.0,
3075                       edge1-&gt;pos / 64.0, edge - edges ));
3076         else
3077           FT_TRACE5(( &quot;  BLUE: edge %d (opos=%.2f) snapped to %.2f,&quot;
3078                       &quot; was %.2f\n&quot;,
3079                       edge1 - edges, edge1-&gt;opos / 64.0, blue-&gt;fit / 64.0,
3080                       edge1-&gt;pos / 64.0 ));
3081 
3082         num_actions++;
3083 #endif
3084 
3085         edge1-&gt;pos    = blue-&gt;fit;
3086         edge1-&gt;flags |= AF_EDGE_DONE;
3087 
3088         if ( edge2 &amp;&amp; !edge2-&gt;blue_edge )
3089         {
3090           af_latin_align_linked_edge( hints, dim, edge1, edge2 );
3091           edge2-&gt;flags |= AF_EDGE_DONE;
3092 
3093 #ifdef FT_DEBUG_LEVEL_TRACE
3094           num_actions++;
3095 #endif
3096         }
3097 
3098         if ( !anchor )
3099           anchor = edge;
3100       }
3101     }
3102 
3103     /* now we align all other stem edges, trying to maintain the */
3104     /* relative order of stems in the glyph                      */
3105     for ( edge = edges; edge &lt; edge_limit; edge++ )
3106     {
3107       AF_Edge  edge2;
3108 
3109 
3110       if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3111         continue;
3112 
3113       /* skip all non-stem edges */
3114       edge2 = edge-&gt;link;
3115       if ( !edge2 )
3116       {
3117         has_serifs++;
3118         continue;
3119       }
3120 
3121       /* now align the stem */
3122 
3123       /* this should not happen, but it&#39;s better to be safe */
3124       if ( edge2-&gt;blue_edge )
3125       {
3126         FT_TRACE5(( &quot;  ASSERTION FAILED for edge %d\n&quot;, edge2 - edges ));
3127 
3128         af_latin_align_linked_edge( hints, dim, edge2, edge );
3129         edge-&gt;flags |= AF_EDGE_DONE;
3130 
3131 #ifdef FT_DEBUG_LEVEL_TRACE
3132         num_actions++;
3133 #endif
3134         continue;
3135       }
3136 
3137       if ( !anchor )
3138       {
3139         /* if we reach this if clause, no stem has been aligned yet */
3140 
3141         FT_Pos  org_len, org_center, cur_len;
3142         FT_Pos  cur_pos1, error1, error2, u_off, d_off;
3143 
3144 
3145         org_len = edge2-&gt;opos - edge-&gt;opos;
3146         cur_len = af_latin_compute_stem_width( hints, dim,
3147                                                org_len, 0,
3148                                                edge-&gt;flags,
3149                                                edge2-&gt;flags );
3150 
3151         /* some voodoo to specially round edges for small stem widths; */
3152         /* the idea is to align the center of a stem, then shifting    */
3153         /* the stem edges to suitable positions                        */
3154         if ( cur_len &lt;= 64 )
3155         {
3156           /* width &lt;= 1px */
3157           u_off = 32;
3158           d_off = 32;
3159         }
3160         else
3161         {
3162           /* 1px &lt; width &lt; 1.5px */
3163           u_off = 38;
3164           d_off = 26;
3165         }
3166 
3167         if ( cur_len &lt; 96 )
3168         {
3169           org_center = edge-&gt;opos + ( org_len &gt;&gt; 1 );
3170           cur_pos1   = FT_PIX_ROUND( org_center );
3171 
3172           error1 = org_center - ( cur_pos1 - u_off );
3173           if ( error1 &lt; 0 )
3174             error1 = -error1;
3175 
3176           error2 = org_center - ( cur_pos1 + d_off );
3177           if ( error2 &lt; 0 )
3178             error2 = -error2;
3179 
3180           if ( error1 &lt; error2 )
3181             cur_pos1 -= u_off;
3182           else
3183             cur_pos1 += d_off;
3184 
3185           edge-&gt;pos  = cur_pos1 - cur_len / 2;
3186           edge2-&gt;pos = edge-&gt;pos + cur_len;
3187         }
3188         else
3189           edge-&gt;pos = FT_PIX_ROUND( edge-&gt;opos );
3190 
3191         anchor       = edge;
3192         edge-&gt;flags |= AF_EDGE_DONE;
3193 
3194         FT_TRACE5(( &quot;  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)&quot;
3195                     &quot; snapped to %.2f and %.2f\n&quot;,
3196                     edge - edges, edge-&gt;opos / 64.0,
3197                     edge2 - edges, edge2-&gt;opos / 64.0,
3198                     edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));
3199 
3200         af_latin_align_linked_edge( hints, dim, edge, edge2 );
3201 
3202 #ifdef FT_DEBUG_LEVEL_TRACE
3203         num_actions += 2;
3204 #endif
3205       }
3206       else
3207       {
3208         FT_Pos  org_pos, org_len, org_center, cur_len;
3209         FT_Pos  cur_pos1, cur_pos2, delta1, delta2;
3210 
3211 
3212         org_pos    = anchor-&gt;pos + ( edge-&gt;opos - anchor-&gt;opos );
3213         org_len    = edge2-&gt;opos - edge-&gt;opos;
3214         org_center = org_pos + ( org_len &gt;&gt; 1 );
3215 
3216         cur_len = af_latin_compute_stem_width( hints, dim,
3217                                                org_len, 0,
3218                                                edge-&gt;flags,
3219                                                edge2-&gt;flags );
3220 
3221         if ( edge2-&gt;flags &amp; AF_EDGE_DONE )
3222         {
3223           FT_TRACE5(( &quot;  ADJUST: edge %d (pos=%.2f) moved to %.2f\n&quot;,
3224                       edge - edges, edge-&gt;pos / 64.0,
3225                       ( edge2-&gt;pos - cur_len ) / 64.0 ));
3226 
3227           edge-&gt;pos = edge2-&gt;pos - cur_len;
3228         }
3229 
3230         else if ( cur_len &lt; 96 )
3231         {
3232           FT_Pos  u_off, d_off;
3233 
3234 
3235           cur_pos1 = FT_PIX_ROUND( org_center );
3236 
3237           if ( cur_len &lt;= 64 )
3238           {
3239             u_off = 32;
3240             d_off = 32;
3241           }
3242           else
3243           {
3244             u_off = 38;
3245             d_off = 26;
3246           }
3247 
3248           delta1 = org_center - ( cur_pos1 - u_off );
3249           if ( delta1 &lt; 0 )
3250             delta1 = -delta1;
3251 
3252           delta2 = org_center - ( cur_pos1 + d_off );
3253           if ( delta2 &lt; 0 )
3254             delta2 = -delta2;
3255 
3256           if ( delta1 &lt; delta2 )
3257             cur_pos1 -= u_off;
3258           else
3259             cur_pos1 += d_off;
3260 
3261           edge-&gt;pos  = cur_pos1 - cur_len / 2;
3262           edge2-&gt;pos = cur_pos1 + cur_len / 2;
3263 
3264           FT_TRACE5(( &quot;  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)&quot;
3265                       &quot; snapped to %.2f and %.2f\n&quot;,
3266                       edge - edges, edge-&gt;opos / 64.0,
3267                       edge2 - edges, edge2-&gt;opos / 64.0,
3268                       edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));
3269         }
3270 
3271         else
3272         {
3273           org_pos    = anchor-&gt;pos + ( edge-&gt;opos - anchor-&gt;opos );
3274           org_len    = edge2-&gt;opos - edge-&gt;opos;
3275           org_center = org_pos + ( org_len &gt;&gt; 1 );
3276 
3277           cur_len    = af_latin_compute_stem_width( hints, dim,
3278                                                     org_len, 0,
3279                                                     edge-&gt;flags,
3280                                                     edge2-&gt;flags );
3281 
3282           cur_pos1 = FT_PIX_ROUND( org_pos );
3283           delta1   = cur_pos1 + ( cur_len &gt;&gt; 1 ) - org_center;
3284           if ( delta1 &lt; 0 )
3285             delta1 = -delta1;
3286 
3287           cur_pos2 = FT_PIX_ROUND( org_pos + org_len ) - cur_len;
3288           delta2   = cur_pos2 + ( cur_len &gt;&gt; 1 ) - org_center;
3289           if ( delta2 &lt; 0 )
3290             delta2 = -delta2;
3291 
3292           edge-&gt;pos  = ( delta1 &lt; delta2 ) ? cur_pos1 : cur_pos2;
3293           edge2-&gt;pos = edge-&gt;pos + cur_len;
3294 
3295           FT_TRACE5(( &quot;  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)&quot;
3296                       &quot; snapped to %.2f and %.2f\n&quot;,
3297                       edge - edges, edge-&gt;opos / 64.0,
3298                       edge2 - edges, edge2-&gt;opos / 64.0,
3299                       edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));
3300         }
3301 
3302 #ifdef FT_DEBUG_LEVEL_TRACE
3303         num_actions++;
3304 #endif
3305 
3306         edge-&gt;flags  |= AF_EDGE_DONE;
3307         edge2-&gt;flags |= AF_EDGE_DONE;
3308 
3309         if ( edge &gt; edges                                             &amp;&amp;
3310              ( top_to_bottom_hinting ? ( edge-&gt;pos &gt; edge[-1].pos )
3311                                      : ( edge-&gt;pos &lt; edge[-1].pos ) ) )
3312         {
3313           /* don&#39;t move if stem would (almost) disappear otherwise; */
3314           /* the ad-hoc value 16 corresponds to 1/4px               */
3315           if ( edge-&gt;link &amp;&amp; FT_ABS( edge-&gt;link-&gt;pos - edge[-1].pos ) &gt; 16 )
3316           {
3317 #ifdef FT_DEBUG_LEVEL_TRACE
3318             FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,
3319                         edge - edges,
3320                         edge-&gt;pos / 64.0,
3321                         edge[-1].pos / 64.0 ));
3322 
3323             num_actions++;
3324 #endif
3325 
3326             edge-&gt;pos = edge[-1].pos;
3327           }
3328         }
3329       }
3330     }
3331 
3332     /* make sure that lowercase m&#39;s maintain their symmetry */
3333 
3334     /* In general, lowercase m&#39;s have six vertical edges if they are sans */
3335     /* serif, or twelve if they are with serifs.  This implementation is  */
3336     /* based on that assumption, and seems to work very well with most    */
3337     /* faces.  However, if for a certain face this assumption is not      */
3338     /* true, the m is just rendered like before.  In addition, any stem   */
3339     /* correction will only be applied to symmetrical glyphs (even if the */
3340     /* glyph is not an m), so the potential for unwanted distortion is    */
3341     /* relatively low.                                                    */
3342 
3343     /* We don&#39;t handle horizontal edges since we can&#39;t easily assure that */
3344     /* the third (lowest) stem aligns with the base line; it might end up */
3345     /* one pixel higher or lower.                                         */
3346 
3347     n_edges = edge_limit - edges;
3348     if ( dim == AF_DIMENSION_HORZ &amp;&amp; ( n_edges == 6 || n_edges == 12 ) )
3349     {
3350       AF_Edge  edge1, edge2, edge3;
3351       FT_Pos   dist1, dist2, span, delta;
3352 
3353 
3354       if ( n_edges == 6 )
3355       {
3356         edge1 = edges;
3357         edge2 = edges + 2;
3358         edge3 = edges + 4;
3359       }
3360       else
3361       {
3362         edge1 = edges + 1;
3363         edge2 = edges + 5;
3364         edge3 = edges + 9;
3365       }
3366 
3367       dist1 = edge2-&gt;opos - edge1-&gt;opos;
3368       dist2 = edge3-&gt;opos - edge2-&gt;opos;
3369 
3370       span = dist1 - dist2;
3371       if ( span &lt; 0 )
3372         span = -span;
3373 
3374       if ( span &lt; 8 )
3375       {
3376         delta = edge3-&gt;pos - ( 2 * edge2-&gt;pos - edge1-&gt;pos );
3377         edge3-&gt;pos -= delta;
3378         if ( edge3-&gt;link )
3379           edge3-&gt;link-&gt;pos -= delta;
3380 
3381         /* move the serifs along with the stem */
3382         if ( n_edges == 12 )
3383         {
3384           ( edges + 8 )-&gt;pos -= delta;
3385           ( edges + 11 )-&gt;pos -= delta;
3386         }
3387 
3388         edge3-&gt;flags |= AF_EDGE_DONE;
3389         if ( edge3-&gt;link )
3390           edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;
3391       }
3392     }
3393 
3394     if ( has_serifs || !anchor )
3395     {
3396       /*
<a name="54" id="anc54"></a><span class="line-modified">3397        * now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">3398        * to complete our processing</span>
3399        */
3400       for ( edge = edges; edge &lt; edge_limit; edge++ )
3401       {
3402         FT_Pos  delta;
3403 
3404 
3405         if ( edge-&gt;flags &amp; AF_EDGE_DONE )
3406           continue;
3407 
3408         delta = 1000;
3409 
3410         if ( edge-&gt;serif )
3411         {
3412           delta = edge-&gt;serif-&gt;opos - edge-&gt;opos;
3413           if ( delta &lt; 0 )
3414             delta = -delta;
3415         }
3416 
3417         if ( delta &lt; 64 + 16 )
3418         {
3419           af_latin_align_serif_edge( hints, edge-&gt;serif, edge );
3420           FT_TRACE5(( &quot;  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)&quot;
3421                       &quot; aligned to %.2f\n&quot;,
3422                       edge - edges, edge-&gt;opos / 64.0,
3423                       edge-&gt;serif - edges, edge-&gt;serif-&gt;opos / 64.0,
3424                       edge-&gt;pos / 64.0 ));
3425         }
3426         else if ( !anchor )
3427         {
3428           edge-&gt;pos = FT_PIX_ROUND( edge-&gt;opos );
3429           anchor    = edge;
3430           FT_TRACE5(( &quot;  SERIF_ANCHOR: edge %d (opos=%.2f)&quot;
3431                       &quot; snapped to %.2f\n&quot;,
3432                       edge-edges, edge-&gt;opos / 64.0, edge-&gt;pos / 64.0 ));
3433         }
3434         else
3435         {
3436           AF_Edge  before, after;
3437 
3438 
3439           for ( before = edge - 1; before &gt;= edges; before-- )
3440             if ( before-&gt;flags &amp; AF_EDGE_DONE )
3441               break;
3442 
3443           for ( after = edge + 1; after &lt; edge_limit; after++ )
3444             if ( after-&gt;flags &amp; AF_EDGE_DONE )
3445               break;
3446 
3447           if ( before &gt;= edges &amp;&amp; before &lt; edge   &amp;&amp;
3448                after &lt; edge_limit &amp;&amp; after &gt; edge )
3449           {
3450             if ( after-&gt;opos == before-&gt;opos )
3451               edge-&gt;pos = before-&gt;pos;
3452             else
3453               edge-&gt;pos = before-&gt;pos +
3454                           FT_MulDiv( edge-&gt;opos - before-&gt;opos,
3455                                      after-&gt;pos - before-&gt;pos,
3456                                      after-&gt;opos - before-&gt;opos );
3457 
3458             FT_TRACE5(( &quot;  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f&quot;
3459                         &quot; from %d (opos=%.2f)\n&quot;,
3460                         edge - edges, edge-&gt;opos / 64.0,
3461                         edge-&gt;pos / 64.0,
3462                         before - edges, before-&gt;opos / 64.0 ));
3463           }
3464           else
3465           {
3466             edge-&gt;pos = anchor-&gt;pos +
3467                         ( ( edge-&gt;opos - anchor-&gt;opos + 16 ) &amp; ~31 );
3468             FT_TRACE5(( &quot;  SERIF_LINK2: edge %d (opos=%.2f)&quot;
3469                         &quot; snapped to %.2f\n&quot;,
3470                         edge - edges, edge-&gt;opos / 64.0, edge-&gt;pos / 64.0 ));
3471           }
3472         }
3473 
3474 #ifdef FT_DEBUG_LEVEL_TRACE
3475         num_actions++;
3476 #endif
3477         edge-&gt;flags |= AF_EDGE_DONE;
3478 
3479         if ( edge &gt; edges                                             &amp;&amp;
3480              ( top_to_bottom_hinting ? ( edge-&gt;pos &gt; edge[-1].pos )
3481                                      : ( edge-&gt;pos &lt; edge[-1].pos ) ) )
3482         {
3483           /* don&#39;t move if stem would (almost) disappear otherwise; */
3484           /* the ad-hoc value 16 corresponds to 1/4px               */
3485           if ( edge-&gt;link &amp;&amp; FT_ABS( edge-&gt;link-&gt;pos - edge[-1].pos ) &gt; 16 )
3486           {
3487 #ifdef FT_DEBUG_LEVEL_TRACE
3488             FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,
3489                         edge - edges,
3490                         edge-&gt;pos / 64.0,
3491                         edge[-1].pos / 64.0 ));
3492 
3493             num_actions++;
3494 #endif
3495             edge-&gt;pos = edge[-1].pos;
3496           }
3497         }
3498 
3499         if ( edge + 1 &lt; edge_limit                                   &amp;&amp;
3500              edge[1].flags &amp; AF_EDGE_DONE                            &amp;&amp;
3501              ( top_to_bottom_hinting ? ( edge-&gt;pos &lt; edge[1].pos )
3502                                      : ( edge-&gt;pos &gt; edge[1].pos ) ) )
3503         {
3504           /* don&#39;t move if stem would (almost) disappear otherwise; */
3505           /* the ad-hoc value 16 corresponds to 1/4px               */
3506           if ( edge-&gt;link &amp;&amp; FT_ABS( edge-&gt;link-&gt;pos - edge[-1].pos ) &gt; 16 )
3507           {
3508 #ifdef FT_DEBUG_LEVEL_TRACE
3509             FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,
3510                         edge - edges,
3511                         edge-&gt;pos / 64.0,
3512                         edge[1].pos / 64.0 ));
3513 
3514             num_actions++;
3515 #endif
3516 
3517             edge-&gt;pos = edge[1].pos;
3518           }
3519         }
3520       }
3521     }
3522 
3523 #ifdef FT_DEBUG_LEVEL_TRACE
3524     if ( !num_actions )
3525       FT_TRACE5(( &quot;  (none)\n&quot; ));
3526     FT_TRACE5(( &quot;\n&quot; ));
3527 #endif
3528   }
3529 
3530 
3531   /* Apply the complete hinting algorithm to a latin glyph. */
3532 
3533   static FT_Error
3534   af_latin_hints_apply( FT_UInt          glyph_index,
3535                         AF_GlyphHints    hints,
3536                         FT_Outline*      outline,
3537                         AF_LatinMetrics  metrics )
3538   {
3539     FT_Error  error;
3540     int       dim;
3541 
3542     AF_LatinAxis  axis;
3543 
3544 
3545     error = af_glyph_hints_reload( hints, outline );
3546     if ( error )
3547       goto Exit;
3548 
3549     /* analyze glyph outline */
3550     if ( AF_HINTS_DO_HORIZONTAL( hints ) )
3551     {
3552       axis  = &amp;metrics-&gt;axis[AF_DIMENSION_HORZ];
3553       error = af_latin_hints_detect_features( hints,
3554                                               axis-&gt;width_count,
3555                                               axis-&gt;widths,
3556                                               AF_DIMENSION_HORZ );
3557       if ( error )
3558         goto Exit;
3559     }
3560 
3561     if ( AF_HINTS_DO_VERTICAL( hints ) )
3562     {
3563       axis  = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];
3564       error = af_latin_hints_detect_features( hints,
3565                                               axis-&gt;width_count,
3566                                               axis-&gt;widths,
3567                                               AF_DIMENSION_VERT );
3568       if ( error )
3569         goto Exit;
3570 
3571       /* apply blue zones to base characters only */
3572       if ( !( metrics-&gt;root.globals-&gt;glyph_styles[glyph_index] &amp; AF_NONBASE ) )
3573         af_latin_hints_compute_blue_edges( hints, metrics );
3574     }
3575 
3576     /* grid-fit the outline */
3577     for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
3578     {
3579 #ifdef AF_CONFIG_OPTION_USE_WARPER
3580       if ( dim == AF_DIMENSION_HORZ                                  &amp;&amp;
3581            metrics-&gt;root.scaler.render_mode == FT_RENDER_MODE_NORMAL &amp;&amp;
3582            AF_HINTS_DO_WARP( hints )                                 )
3583       {
3584         AF_WarperRec  warper;
3585         FT_Fixed      scale;
3586         FT_Pos        delta;
3587 
3588 
3589         af_warper_compute( &amp;warper, hints, (AF_Dimension)dim,
3590                            &amp;scale, &amp;delta );
3591         af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,
3592                                   scale, delta );
3593         continue;
3594       }
3595 #endif /* AF_CONFIG_OPTION_USE_WARPER */
3596 
3597       if ( ( dim == AF_DIMENSION_HORZ &amp;&amp; AF_HINTS_DO_HORIZONTAL( hints ) ) ||
3598            ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_VERTICAL( hints ) )   )
3599       {
3600         af_latin_hint_edges( hints, (AF_Dimension)dim );
3601         af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
3602         af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
3603         af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
3604       }
3605     }
3606 
3607     af_glyph_hints_save( hints, outline );
3608 
3609   Exit:
3610     return error;
3611   }
3612 
3613 
3614   /*************************************************************************/
3615   /*************************************************************************/
3616   /*****                                                               *****/
3617   /*****              L A T I N   S C R I P T   C L A S S              *****/
3618   /*****                                                               *****/
3619   /*************************************************************************/
3620   /*************************************************************************/
3621 
3622 
3623   AF_DEFINE_WRITING_SYSTEM_CLASS(
3624     af_latin_writing_system_class,
3625 
3626     AF_WRITING_SYSTEM_LATIN,
3627 
3628     sizeof ( AF_LatinMetricsRec ),
3629 
3630     (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init,        /* style_metrics_init    */
3631     (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale,       /* style_metrics_scale   */
3632     (AF_WritingSystem_DoneMetricsFunc) NULL,                         /* style_metrics_done    */
3633     (AF_WritingSystem_GetStdWidthsFunc)af_latin_get_standard_widths, /* style_metrics_getstdw */
3634 
3635     (AF_WritingSystem_InitHintsFunc)   af_latin_hints_init,          /* style_hints_init      */
3636     (AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply          /* style_hints_apply     */
3637   )
3638 
3639 
3640 /* END */
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>
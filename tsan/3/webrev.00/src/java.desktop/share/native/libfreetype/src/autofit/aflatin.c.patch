diff a/src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c b/src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c
--- a/src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c
+++ b/src/java.desktop/share/native/libfreetype/src/autofit/aflatin.c
@@ -1,46 +1,45 @@
-/***************************************************************************/
-/*                                                                         */
-/*  aflatin.c                                                              */
-/*                                                                         */
-/*    Auto-fitter hinting routines for latin writing system (body).        */
-/*                                                                         */
-/*  Copyright 2003-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * aflatin.c
+ *
+ *   Auto-fitter hinting routines for latin writing system (body).
+ *
+ * Copyright (C) 2003-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include FT_ADVANCES_H
 #include FT_INTERNAL_DEBUG_H
 
 #include "afglobal.h"
-#include "afpic.h"
 #include "aflatin.h"
 #include "aferrors.h"
 
 
 #ifdef AF_CONFIG_OPTION_USE_WARPER
 #include "afwarp.h"
 #endif
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_aflatin
+#define FT_COMPONENT  aflatin
 
 
   /* needed for computation of round vs. flat segments */
 #define FLAT_THRESHOLD( x )  ( x / 14 )
 
@@ -81,28 +80,34 @@
       FT_ULong            glyph_index;
       int                 dim;
       AF_LatinMetricsRec  dummy[1];
       AF_Scaler           scaler = &dummy->root.scaler;
 
-#ifdef FT_CONFIG_OPTION_PIC
-      AF_FaceGlobals  globals = metrics->root.globals;
-#endif
-
       AF_StyleClass   style_class  = metrics->root.style_class;
-      AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
-                                       [style_class->script];
+      AF_ScriptClass  script_class = af_script_classes[style_class->script];
+
+      /* If HarfBuzz is not available, we need a pointer to a single */
+      /* unsigned long value.                                        */
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
+      void*     shaper_buf;
+#else
+      FT_ULong  shaper_buf_;
+      void*     shaper_buf = &shaper_buf_;
+#endif
 
-      void*        shaper_buf;
       const char*  p;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
       FT_ULong  ch = 0;
 #endif
 
-      p          = script_class->standard_charstring;
-      shaper_buf = af_shaper_buf_create( face );
 
+      p = script_class->standard_charstring;
+
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
+      shaper_buf = af_shaper_buf_create( face );
+#endif
       /*
        * We check a list of standard characters to catch features like
        * `c2sc' (small caps from caps) that don't contain lowercase letters
        * by definition, or other features that mainly operate on numerals.
        * The first match wins.
@@ -142,11 +147,15 @@
       }
 
       af_shaper_buf_destroy( face, shaper_buf );
 
       if ( !glyph_index )
+      {
+        FT_TRACE5(( "standard character missing;"
+                    " using fallback stem widths\n" ));
         goto Exit;
+      }
 
       FT_TRACE5(( "standard character: U+%04lX (glyph index %d)\n",
                   ch, glyph_index ));
 
       error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
@@ -184,14 +193,14 @@
                                                  (AF_Dimension)dim );
         if ( error )
           goto Exit;
 
         /*
-         *  We assume that the glyphs selected for the stem width
-         *  computation are `featureless' enough so that the linking
-         *  algorithm works fine without adjustments of its scoring
-         *  function.
+         * We assume that the glyphs selected for the stem width
+         * computation are `featureless' enough so that the linking
+         * algorithm works fine without adjustments of its scoring
+         * function.
          */
         af_latin_hints_link_segments( hints,
                                       0,
                                       NULL,
                                       (AF_Dimension)dim );
@@ -305,11 +314,11 @@
 
 
   /* Find all blue zones.  Flat segments give the reference points, */
   /* round segments the overshoot positions.                        */
 
-  static void
+  static int
   af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
                                FT_Face          face )
   {
     FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
     FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
@@ -327,21 +336,30 @@
     AF_Blue_Stringset         bss = sc->blue_stringset;
     const AF_Blue_StringRec*  bs  = &af_blue_stringsets[bss];
 
     FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );
 
-    void*  shaper_buf;
+    /* If HarfBuzz is not available, we need a pointer to a single */
+    /* unsigned long value.                                        */
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
+    void*     shaper_buf;
+#else
+    FT_ULong  shaper_buf_;
+    void*     shaper_buf = &shaper_buf_;
+#endif
 
 
     /* we walk over the blue character strings as specified in the */
     /* style's entry in the `af_blue_stringset' array              */
 
     FT_TRACE5(( "latin blue zones computation\n"
                 "============================\n"
                 "\n" ));
 
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
     shaper_buf = af_shaper_buf_create( face );
+#endif
 
     for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
     {
       const char*  p = &af_blue_strings[bs->string];
       FT_Pos*      blue_ref;
@@ -882,12 +900,12 @@
       } /* end while loop */
 
       if ( num_flats == 0 && num_rounds == 0 )
       {
         /*
-         *  we couldn't find a single glyph to compute this blue zone,
-         *  we will simply ignore it then
+         * we couldn't find a single glyph to compute this blue zone,
+         * we will simply ignore it then
          */
         FT_TRACE5(( "  empty\n" ));
         continue;
       }
 
@@ -965,14 +983,15 @@
 
     } /* end for loop */
 
     af_shaper_buf_destroy( face, shaper_buf );
 
-    /* we finally check whether blue zones are ordered; */
-    /* `ref' and `shoot' values of two blue zones must not overlap */
     if ( axis->blue_count )
     {
+      /* we finally check whether blue zones are ordered;            */
+      /* `ref' and `shoot' values of two blue zones must not overlap */
+
       FT_UInt       i;
       AF_LatinBlue  blue_sorted[AF_BLUE_STRINGSET_MAX_LEN + 2];
 
 
       for ( i = 0; i < axis->blue_count; i++ )
@@ -1017,15 +1036,38 @@
                       a_is_top ? "overshoot" : "reference",
                       blue_sorted[i] - axis->blues,
                       *a ));
         }
       }
+
+      FT_TRACE5(( "\n" ));
+
+      return 0;
     }
+    else
+    {
+      /* disable hinting for the current style if there are no blue zones */
 
-    FT_TRACE5(( "\n" ));
+      AF_FaceGlobals  globals = metrics->root.globals;
+      FT_UShort*      gstyles = globals->glyph_styles;
+
+      FT_Long  i;
+
+
+      FT_TRACE5(( "no blue zones found:"
+                  " hinting disabled for this style\n" ));
+
+      for ( i = 0; i < globals->glyph_count; i++ )
+      {
+        if ( ( gstyles[i] & AF_STYLE_MASK ) == sc->style )
+          gstyles[i] = AF_STYLE_NONE_DFLT;
+      }
 
-    return;
+      FT_TRACE5(( "\n" ));
+
+      return 1;
+    }
   }
 
 
   /* Check whether all ASCII digits have the same advance width. */
 
@@ -1034,19 +1076,29 @@
                                  FT_Face          face )
   {
     FT_Bool   started = 0, same_width = 1;
     FT_Fixed  advance = 0, old_advance = 0;
 
-    void*  shaper_buf;
+    /* If HarfBuzz is not available, we need a pointer to a single */
+    /* unsigned long value.                                        */
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
+    void*     shaper_buf;
+#else
+    FT_ULong  shaper_buf_;
+    void*     shaper_buf = &shaper_buf_;
+#endif
 
     /* in all supported charmaps, digits have character codes 0x30-0x39 */
     const char   digits[] = "0 1 2 3 4 5 6 7 8 9";
     const char*  p;
 
 
-    p          = digits;
+    p = digits;
+
+#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ
     shaper_buf = af_shaper_buf_create( face );
+#endif
 
     while ( *p )
     {
       FT_ULong      glyph_index;
       unsigned int  num_idx;
@@ -1090,24 +1142,32 @@
 
   FT_LOCAL_DEF( FT_Error )
   af_latin_metrics_init( AF_LatinMetrics  metrics,
                          FT_Face          face )
   {
+    FT_Error  error = FT_Err_Ok;
+
     FT_CharMap  oldmap = face->charmap;
 
 
     metrics->units_per_em = face->units_per_EM;
 
     if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
     {
       af_latin_metrics_init_widths( metrics, face );
-      af_latin_metrics_init_blues( metrics, face );
+      if ( af_latin_metrics_init_blues( metrics, face ) )
+      {
+        /* use internal error code to indicate missing blue zones */
+        error = -1;
+        goto Exit;
+      }
       af_latin_metrics_check_digits( metrics, face );
     }
 
+  Exit:
     FT_Set_Charmap( face, oldmap );
-    return FT_Err_Ok;
+    return error;
   }
 
 
   /* Adjust scaling value, then scale and shift widths   */
   /* and blue zones (if applicable) for given dimension. */
@@ -1281,11 +1341,11 @@
     FT_TRACE5(( "\n" ));
 
     /* an extra-light axis corresponds to a standard width that is */
     /* smaller than 5/8 pixels                                     */
     axis->extra_light =
-      (FT_Bool)( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );
+      FT_BOOL( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     if ( axis->extra_light )
       FT_TRACE5(( "`%s' style is extra light (at current resolution)\n"
                   "\n",
@@ -1417,17 +1477,17 @@
         FT_TRACE5(( "  reference %d: %d scaled to %.2f%s\n"
                     "  overshoot %d: %d scaled to %.2f%s\n",
                     nn,
                     blue->ref.org,
                     blue->ref.fit / 64.0,
-                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
-                                                       : " (inactive)",
+                    ( blue->flags & AF_LATIN_BLUE_ACTIVE ) ? ""
+                                                           : " (inactive)",
                     nn,
                     blue->shoot.org,
                     blue->shoot.fit / 64.0,
-                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
-                                                       : " (inactive)" ));
+                    ( blue->flags & AF_LATIN_BLUE_ACTIVE ) ? ""
+                                                           : " (inactive)" ));
       }
 #endif
     }
   }
 
@@ -1965,21 +2025,21 @@
           /* (this is, how much they overlap)                          */
           len = max - min;
           if ( len >= len_threshold )
           {
             /*
-             *  The score is the sum of two demerits indicating the
-             *  `badness' of a fit, measured along the segments' main axis
-             *  and orthogonal to it, respectively.
+             * The score is the sum of two demerits indicating the
+             * `badness' of a fit, measured along the segments' main axis
+             * and orthogonal to it, respectively.
              *
-             *  o The less overlapping along the main axis, the worse it
-             *    is, causing a larger demerit.
+             * - The less overlapping along the main axis, the worse it
+             *   is, causing a larger demerit.
              *
-             *  o The nearer the orthogonal distance to a stem width, the
-             *    better it is, causing a smaller demerit.  For simplicity,
-             *    however, we only increase the demerit for values that
-             *    exceed the largest stem width.
+             * - The nearer the orthogonal distance to a stem width, the
+             *   better it is, causing a smaller demerit.  For simplicity,
+             *   however, we only increase the demerit for values that
+             *   exceed the largest stem width.
              */
 
             FT_Pos  dist = pos2 - pos1;
 
             FT_Pos  dist_demerit, score;
@@ -2047,17 +2107,12 @@
     AF_AxisHints  axis   = &hints->axis[dim];
     FT_Error      error  = FT_Err_Ok;
     FT_Memory     memory = hints->memory;
     AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];
 
-#ifdef FT_CONFIG_OPTION_PIC
-    AF_FaceGlobals  globals = hints->metrics->globals;
-#endif
-
     AF_StyleClass   style_class  = hints->metrics->style_class;
-    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
-                                     [style_class->script];
+    AF_ScriptClass  script_class = af_script_classes[style_class->script];
 
     FT_Bool  top_to_bottom_hinting = 0;
 
     AF_Segment    segments      = axis->segments;
     AF_Segment    segment_limit = segments + axis->num_segments;
@@ -2084,40 +2139,40 @@
 
     if ( dim == AF_DIMENSION_VERT )
       top_to_bottom_hinting = script_class->top_to_bottom_hinting;
 
     /*
-     *  We ignore all segments that are less than 1 pixel in length
-     *  to avoid many problems with serif fonts.  We compute the
-     *  corresponding threshold in font units.
+     * We ignore all segments that are less than 1 pixel in length
+     * to avoid many problems with serif fonts.  We compute the
+     * corresponding threshold in font units.
      */
     if ( dim == AF_DIMENSION_HORZ )
       segment_length_threshold = FT_DivFix( 64, hints->y_scale );
     else
       segment_length_threshold = 0;
 
     /*
-     *  Similarly, we ignore segments that have a width delta
-     *  larger than 0.5px (i.e., a width larger than 1px).
+     * Similarly, we ignore segments that have a width delta
+     * larger than 0.5px (i.e., a width larger than 1px).
      */
     segment_width_threshold = FT_DivFix( 32, scale );
 
-    /*********************************************************************/
-    /*                                                                   */
-    /* We begin by generating a sorted table of edges for the current    */
-    /* direction.  To do so, we simply scan each segment and try to find */
-    /* an edge in our table that corresponds to its position.            */
-    /*                                                                   */
-    /* If no edge is found, we create and insert a new edge in the       */
-    /* sorted table.  Otherwise, we simply add the segment to the edge's */
-    /* list which gets processed in the second step to compute the       */
-    /* edge's properties.                                                */
-    /*                                                                   */
-    /* Note that the table of edges is sorted along the segment/edge     */
-    /* position.                                                         */
-    /*                                                                   */
-    /*********************************************************************/
+    /**********************************************************************
+     *
+     * We begin by generating a sorted table of edges for the current
+     * direction.  To do so, we simply scan each segment and try to find
+     * an edge in our table that corresponds to its position.
+     *
+     * If no edge is found, we create and insert a new edge in the
+     * sorted table.  Otherwise, we simply add the segment to the edge's
+     * list which gets processed in the second step to compute the
+     * edge's properties.
+     *
+     * Note that the table of edges is sorted along the segment/edge
+     * position.
+     *
+     */
 
     /* assure that edge distance threshold is at most 0.25px */
     edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
                                          scale );
     if ( edge_distance_threshold > 64 / 4 )
@@ -2235,21 +2290,21 @@
         found->last            = seg;
       }
     }
 
 
-    /******************************************************************/
-    /*                                                                */
-    /* Good, we now compute each edge's properties according to the   */
-    /* segments found on its position.  Basically, these are          */
-    /*                                                                */
-    /*  - the edge's main direction                                   */
-    /*  - stem edge, serif edge or both (which defaults to stem then) */
-    /*  - rounded edge, straight or both (which defaults to straight) */
-    /*  - link for edge                                               */
-    /*                                                                */
-    /******************************************************************/
+    /*******************************************************************
+     *
+     * Good, we now compute each edge's properties according to the
+     * segments found on its position.  Basically, these are
+     *
+     * - the edge's main direction
+     * - stem edge, serif edge or both (which defaults to stem then)
+     * - rounded edge, straight or both (which defaults to straight)
+     * - link for edge
+     *
+     */
 
     /* first of all, set the `edge' field in each segment -- this is */
     /* required in order to compute edge links                       */
 
     /*
@@ -2307,13 +2362,13 @@
             downs += seg->max_coord - seg->min_coord;
 #endif
 
           /* check for links -- if seg->serif is set, then seg->link must */
           /* be ignored                                                   */
-          is_serif = (FT_Bool)( seg->serif               &&
-                                seg->serif->edge         &&
-                                seg->serif->edge != edge );
+          is_serif = FT_BOOL( seg->serif               &&
+                              seg->serif->edge         &&
+                              seg->serif->edge != edge );
 
           if ( ( seg->link && seg->link->edge ) || is_serif )
           {
             AF_Edge     edge2;
             AF_Segment  seg2;
@@ -2544,12 +2599,12 @@
 
 
     af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
 
     /*
-     *  correct x_scale and y_scale if needed, since they may have
-     *  been modified by `af_latin_metrics_scale_dim' above
+     * correct x_scale and y_scale if needed, since they may have
+     * been modified by `af_latin_metrics_scale_dim' above
      */
     hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
     hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
     hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
     hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;
@@ -2564,38 +2619,38 @@
 
     scaler_flags = hints->scaler_flags;
     other_flags  = 0;
 
     /*
-     *  We snap the width of vertical stems for the monochrome and
-     *  horizontal LCD rendering targets only.
+     * We snap the width of vertical stems for the monochrome and
+     * horizontal LCD rendering targets only.
      */
     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
       other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
 
     /*
-     *  We snap the width of horizontal stems for the monochrome and
-     *  vertical LCD rendering targets only.
+     * We snap the width of horizontal stems for the monochrome and
+     * vertical LCD rendering targets only.
      */
     if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
       other_flags |= AF_LATIN_HINTS_VERT_SNAP;
 
     /*
-     *  We adjust stems to full pixels unless in `light' or `lcd' mode.
+     * We adjust stems to full pixels unless in `light' or `lcd' mode.
      */
     if ( mode != FT_RENDER_MODE_LIGHT && mode != FT_RENDER_MODE_LCD )
       other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
 
     if ( mode == FT_RENDER_MODE_MONO )
       other_flags |= AF_LATIN_HINTS_MONO;
 
     /*
-     *  In `light' or `lcd' mode we disable horizontal hinting completely.
-     *  We also do it if the face is italic.
+     * In `light' or `lcd' mode we disable horizontal hinting completely.
+     * We also do it if the face is italic.
      *
-     *  However, if warping is enabled (which only works in `light' hinting
-     *  mode), advance widths get adjusted, too.
+     * However, if warping is enabled (which only works in `light' hinting
+     * mode), advance widths get adjusted, too.
      */
     if ( mode == FT_RENDER_MODE_LIGHT || mode == FT_RENDER_MODE_LCD ||
          ( face->style_flags & FT_STYLE_FLAG_ITALIC ) != 0          )
       scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
 
@@ -2934,17 +2989,12 @@
     FT_PtrDist    n_edges;
     AF_Edge       edge;
     AF_Edge       anchor     = NULL;
     FT_Int        has_serifs = 0;
 
-#ifdef FT_CONFIG_OPTION_PIC
-    AF_FaceGlobals  globals = hints->metrics->globals;
-#endif
-
     AF_StyleClass   style_class  = hints->metrics->style_class;
-    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
-                                     [style_class->script];
+    AF_ScriptClass  script_class = af_script_classes[style_class->script];
 
     FT_Bool  top_to_bottom_hinting = 0;
 
 #ifdef FT_DEBUG_LEVEL_TRACE
     FT_UInt  num_actions = 0;
@@ -2974,16 +3024,16 @@
 
         edge1 = NULL;
         edge2 = edge->link;
 
         /*
-         *  If a stem contains both a neutral and a non-neutral blue zone,
-         *  skip the neutral one.  Otherwise, outlines with different
-         *  directions might be incorrectly aligned at the same vertical
-         *  position.
+         * If a stem contains both a neutral and a non-neutral blue zone,
+         * skip the neutral one.  Otherwise, outlines with different
+         * directions might be incorrectly aligned at the same vertical
+         * position.
          *
-         *  If we have two neutral blue zones, skip one of them.
+         * If we have two neutral blue zones, skip one of them.
          *
          */
         if ( edge->blue_edge && edge2 && edge2->blue_edge )
         {
           FT_Byte  neutral  = edge->flags  & AF_EDGE_NEUTRAL;
@@ -3342,12 +3392,12 @@
     }
 
     if ( has_serifs || !anchor )
     {
       /*
-       *  now hint the remaining edges (serifs and single) in order
-       *  to complete our processing
+       * now hint the remaining edges (serifs and single) in order
+       * to complete our processing
        */
       for ( edge = edges; edge < edge_limit; edge++ )
       {
         FT_Pos  delta;
 

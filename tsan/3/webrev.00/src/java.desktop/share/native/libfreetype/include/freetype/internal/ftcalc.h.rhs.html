<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/include/freetype/internal/ftcalc.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftcalc.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Arithmetic computations (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef FTCALC_H_
 20 #define FTCALC_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_FREETYPE_H
 25 
 26 
 27 FT_BEGIN_HEADER
 28 
 29 
<a name="2" id="anc2"></a><span class="line-modified"> 30   /**************************************************************************</span>
<span class="line-modified"> 31    *</span>
<span class="line-modified"> 32    * FT_MulDiv() and FT_MulFix() are declared in freetype.h.</span>
<span class="line-modified"> 33    *</span>
<span class="line-modified"> 34    */</span>
 35 
 36 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
 37   /* Provide assembler fragments for performance-critical functions. */
 38   /* These must be defined `static __inline__&#39; with GCC.             */
 39 
 40 #if defined( __CC_ARM ) || defined( __ARMCC__ )  /* RVCT */
 41 
 42 #define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
 43 
 44   /* documentation is in freetype.h */
 45 
 46   static __inline FT_Int32
 47   FT_MulFix_arm( FT_Int32  a,
 48                  FT_Int32  b )
 49   {
 50     FT_Int32  t, t2;
 51 
 52 
 53     __asm
 54     {
 55       smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
 56       mov   a,  t,  asr #31         /* a   = (hi &gt;&gt; 31) */
 57       add   a,  a,  #0x8000         /* a  += 0x8000 */
 58       adds  t2, t2, a               /* t2 += a */
 59       adc   t,  t,  #0              /* t  += carry */
 60       mov   a,  t2, lsr #16         /* a   = t2 &gt;&gt; 16 */
 61       orr   a,  a,  t,  lsl #16     /* a  |= t &lt;&lt; 16 */
 62     }
 63     return a;
 64   }
 65 
 66 #endif /* __CC_ARM || __ARMCC__ */
 67 
 68 
 69 #ifdef __GNUC__
 70 
 71 #if defined( __arm__ )                                 &amp;&amp; \
 72     ( !defined( __thumb__ ) || defined( __thumb2__ ) ) &amp;&amp; \
 73     !( defined( __CC_ARM ) || defined( __ARMCC__ ) )
 74 
 75 #define FT_MULFIX_ASSEMBLER  FT_MulFix_arm
 76 
 77   /* documentation is in freetype.h */
 78 
 79   static __inline__ FT_Int32
 80   FT_MulFix_arm( FT_Int32  a,
 81                  FT_Int32  b )
 82   {
 83     FT_Int32  t, t2;
 84 
 85 
 86     __asm__ __volatile__ (
 87       &quot;smull  %1, %2, %4, %3\n\t&quot;       /* (lo=%1,hi=%2) = a*b */
 88       &quot;mov    %0, %2, asr #31\n\t&quot;      /* %0  = (hi &gt;&gt; 31) */
 89 #if defined( __clang__ ) &amp;&amp; defined( __thumb2__ )
 90       &quot;add.w  %0, %0, #0x8000\n\t&quot;      /* %0 += 0x8000 */
 91 #else
 92       &quot;add    %0, %0, #0x8000\n\t&quot;      /* %0 += 0x8000 */
 93 #endif
 94       &quot;adds   %1, %1, %0\n\t&quot;           /* %1 += %0 */
 95       &quot;adc    %2, %2, #0\n\t&quot;           /* %2 += carry */
 96       &quot;mov    %0, %1, lsr #16\n\t&quot;      /* %0  = %1 &gt;&gt; 16 */
 97       &quot;orr    %0, %0, %2, lsl #16\n\t&quot;  /* %0 |= %2 &lt;&lt; 16 */
 98       : &quot;=r&quot;(a), &quot;=&amp;r&quot;(t2), &quot;=&amp;r&quot;(t)
 99       : &quot;r&quot;(a), &quot;r&quot;(b)
100       : &quot;cc&quot; );
101     return a;
102   }
103 
104 #endif /* __arm__                      &amp;&amp; */
105        /* ( __thumb2__ || !__thumb__ ) &amp;&amp; */
106        /* !( __CC_ARM || __ARMCC__ )      */
107 
108 
109 #if defined( __i386__ )
110 
111 #define FT_MULFIX_ASSEMBLER  FT_MulFix_i386
112 
113   /* documentation is in freetype.h */
114 
115   static __inline__ FT_Int32
116   FT_MulFix_i386( FT_Int32  a,
117                   FT_Int32  b )
118   {
119     FT_Int32  result;
120 
121 
122     __asm__ __volatile__ (
123       &quot;imul  %%edx\n&quot;
124       &quot;movl  %%edx, %%ecx\n&quot;
125       &quot;sarl  $31, %%ecx\n&quot;
126       &quot;addl  $0x8000, %%ecx\n&quot;
127       &quot;addl  %%ecx, %%eax\n&quot;
128       &quot;adcl  $0, %%edx\n&quot;
129       &quot;shrl  $16, %%eax\n&quot;
130       &quot;shll  $16, %%edx\n&quot;
131       &quot;addl  %%edx, %%eax\n&quot;
132       : &quot;=a&quot;(result), &quot;=d&quot;(b)
133       : &quot;a&quot;(a), &quot;d&quot;(b)
134       : &quot;%ecx&quot;, &quot;cc&quot; );
135     return result;
136   }
137 
138 #endif /* i386 */
139 
140 #endif /* __GNUC__ */
141 
142 
143 #ifdef _MSC_VER /* Visual C++ */
144 
145 #ifdef _M_IX86
146 
147 #define FT_MULFIX_ASSEMBLER  FT_MulFix_i386
148 
149   /* documentation is in freetype.h */
150 
151   static __inline FT_Int32
152   FT_MulFix_i386( FT_Int32  a,
153                   FT_Int32  b )
154   {
155     FT_Int32  result;
156 
157     __asm
158     {
159       mov eax, a
160       mov edx, b
161       imul edx
162       mov ecx, edx
163       sar ecx, 31
164       add ecx, 8000h
165       add eax, ecx
166       adc edx, 0
167       shr eax, 16
168       shl edx, 16
169       add eax, edx
170       mov result, eax
171     }
172     return result;
173   }
174 
175 #endif /* _M_IX86 */
176 
177 #endif /* _MSC_VER */
178 
179 
180 #if defined( __GNUC__ ) &amp;&amp; defined( __x86_64__ )
181 
182 #define FT_MULFIX_ASSEMBLER  FT_MulFix_x86_64
183 
184   static __inline__ FT_Int32
185   FT_MulFix_x86_64( FT_Int32  a,
186                     FT_Int32  b )
187   {
188     /* Temporarily disable the warning that C90 doesn&#39;t support */
189     /* `long long&#39;.                                             */
190 #if __GNUC__ &gt; 4 || ( __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 6 )
191 #pragma GCC diagnostic push
192 #pragma GCC diagnostic ignored &quot;-Wlong-long&quot;
193 #endif
194 
195 #if 1
196     /* Technically not an assembly fragment, but GCC does a really good */
197     /* job at inlining it and generating good machine code for it.      */
198     long long  ret, tmp;
199 
200 
201     ret  = (long long)a * b;
202     tmp  = ret &gt;&gt; 63;
203     ret += 0x8000 + tmp;
204 
205     return (FT_Int32)( ret &gt;&gt; 16 );
206 #else
207 
208     /* For some reason, GCC 4.6 on Ubuntu 12.04 generates invalid machine  */
209     /* code from the lines below.  The main issue is that `wide_a&#39; is not  */
210     /* properly initialized by sign-extending `a&#39;.  Instead, the generated */
211     /* machine code assumes that the register that contains `a&#39; on input   */
212     /* can be used directly as a 64-bit value, which is wrong most of the  */
213     /* time.                                                               */
214     long long  wide_a = (long long)a;
215     long long  wide_b = (long long)b;
216     long long  result;
217 
218 
219     __asm__ __volatile__ (
220       &quot;imul %2, %1\n&quot;
221       &quot;mov %1, %0\n&quot;
222       &quot;sar $63, %0\n&quot;
223       &quot;lea 0x8000(%1, %0), %0\n&quot;
224       &quot;sar $16, %0\n&quot;
225       : &quot;=&amp;r&quot;(result), &quot;=&amp;r&quot;(wide_a)
226       : &quot;r&quot;(wide_b)
227       : &quot;cc&quot; );
228 
229     return (FT_Int32)result;
230 #endif
231 
232 #if __GNUC__ &gt; 4 || ( __GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 6 )
233 #pragma GCC diagnostic pop
234 #endif
235   }
236 
237 #endif /* __GNUC__ &amp;&amp; __x86_64__ */
238 
239 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
240 
241 
242 #ifdef FT_CONFIG_OPTION_INLINE_MULFIX
243 #ifdef FT_MULFIX_ASSEMBLER
244 #define FT_MulFix( a, b )  FT_MULFIX_ASSEMBLER( (FT_Int32)(a), (FT_Int32)(b) )
245 #endif
246 #endif
247 
248 
<a name="3" id="anc3"></a><span class="line-modified">249   /**************************************************************************</span>
<span class="line-modified">250    *</span>
<span class="line-modified">251    * @function:</span>
<span class="line-modified">252    *   FT_MulDiv_No_Round</span>
<span class="line-modified">253    *</span>
<span class="line-modified">254    * @description:</span>
<span class="line-modified">255    *   A very simple function used to perform the computation &#39;(a*b)/c&#39;</span>
<span class="line-modified">256    *   (without rounding) with maximum accuracy (it uses a 64-bit</span>
<span class="line-modified">257    *   intermediate integer whenever necessary).</span>
<span class="line-modified">258    *</span>
<span class="line-modified">259    *   This function isn&#39;t necessarily as fast as some processor-specific</span>
<span class="line-modified">260    *   operations, but is at least completely portable.</span>
<span class="line-modified">261    *</span>
<span class="line-modified">262    * @input:</span>
<span class="line-modified">263    *   a ::</span>
<span class="line-modified">264    *     The first multiplier.</span>
<span class="line-modified">265    *   b ::</span>
<span class="line-modified">266    *     The second multiplier.</span>
<span class="line-modified">267    *   c ::</span>
<span class="line-modified">268    *     The divisor.</span>
<span class="line-modified">269    *</span>
<span class="line-modified">270    * @return:</span>
<span class="line-modified">271    *   The result of &#39;(a*b)/c&#39;.  This function never traps when trying to</span>
<span class="line-added">272    *   divide by zero; it simply returns &#39;MaxInt&#39; or &#39;MinInt&#39; depending on</span>
<span class="line-added">273    *   the signs of &#39;a&#39; and &#39;b&#39;.</span>
<span class="line-added">274    */</span>
275   FT_BASE( FT_Long )
276   FT_MulDiv_No_Round( FT_Long  a,
277                       FT_Long  b,
278                       FT_Long  c );
279 
280 
281   /*
<a name="4" id="anc4"></a><span class="line-modified">282    * A variant of FT_Matrix_Multiply which scales its result afterwards.  The</span>
<span class="line-modified">283    * idea is that both `a&#39; and `b&#39; are scaled by factors of 10 so that the</span>
<span class="line-modified">284    * values are as precise as possible to get a correct result during the</span>
<span class="line-modified">285    * 64bit multiplication.  Let `sa&#39; and `sb&#39; be the scaling factors of `a&#39;</span>
<span class="line-modified">286    * and `b&#39;, respectively, then the scaling factor of the result is `sa*sb&#39;.</span>

287    */
288   FT_BASE( void )
289   FT_Matrix_Multiply_Scaled( const FT_Matrix*  a,
290                              FT_Matrix        *b,
291                              FT_Long           scaling );
292 
293 
294   /*
<a name="5" id="anc5"></a><span class="line-modified">295    * Check a matrix.  If the transformation would lead to extreme shear or</span>
<span class="line-modified">296    * extreme scaling, for example, return 0.  If everything is OK, return 1.</span>
<span class="line-added">297    *</span>
<span class="line-added">298    * Based on geometric considerations we use the following inequality to</span>
<span class="line-added">299    * identify a degenerate matrix.</span>
<span class="line-added">300    *</span>
<span class="line-added">301    *   50 * abs(xx*yy - xy*yx) &lt; xx^2 + xy^2 + yx^2 + yy^2</span>
<span class="line-added">302    *</span>
<span class="line-added">303    * Value 50 is heuristic.</span>
<span class="line-added">304    */</span>
<span class="line-added">305   FT_BASE( FT_Bool )</span>
<span class="line-added">306   FT_Matrix_Check( const FT_Matrix*  matrix );</span>
<span class="line-added">307 </span>
<span class="line-added">308 </span>
<span class="line-added">309   /*</span>
<span class="line-added">310    * A variant of FT_Vector_Transform.  See comments for</span>
<span class="line-added">311    * FT_Matrix_Multiply_Scaled.</span>
312    */
313   FT_BASE( void )
314   FT_Vector_Transform_Scaled( FT_Vector*        vector,
315                               const FT_Matrix*  matrix,
316                               FT_Long           scaling );
317 
318 
319   /*
<a name="6" id="anc6"></a><span class="line-modified">320    * This function normalizes a vector and returns its original length.  The</span>
<span class="line-modified">321    * normalized vector is a 16.16 fixed-point unit vector with length close</span>
<span class="line-modified">322    * to 0x10000.  The accuracy of the returned length is limited to 16 bits</span>
<span class="line-modified">323    * also.  The function utilizes quick inverse square root approximation</span>
<span class="line-modified">324    * without divisions and square roots relying on Newton&#39;s iterations</span>
<span class="line-modified">325    * instead.</span>
326    */
327   FT_BASE( FT_UInt32 )
328   FT_Vector_NormLen( FT_Vector*  vector );
329 
330 
331   /*
<a name="7" id="anc7"></a><span class="line-modified">332    * Return -1, 0, or +1, depending on the orientation of a given corner.  We</span>
<span class="line-modified">333    * use the Cartesian coordinate system, with positive vertical values going</span>
<span class="line-modified">334    * upwards.  The function returns +1 if the corner turns to the left, -1 to</span>
<span class="line-modified">335    * the right, and 0 for undecidable cases.</span>
336    */
337   FT_BASE( FT_Int )
338   ft_corner_orientation( FT_Pos  in_x,
339                          FT_Pos  in_y,
340                          FT_Pos  out_x,
341                          FT_Pos  out_y );
342 
343 
344   /*
<a name="8" id="anc8"></a><span class="line-modified">345    * Return TRUE if a corner is flat or nearly flat.  This is equivalent to</span>
<span class="line-modified">346    * saying that the corner point is close to its neighbors, or inside an</span>
<span class="line-modified">347    * ellipse defined by the neighbor focal points to be more precise.</span>
348    */
349   FT_BASE( FT_Int )
350   ft_corner_is_flat( FT_Pos  in_x,
351                      FT_Pos  in_y,
352                      FT_Pos  out_x,
353                      FT_Pos  out_y );
354 
355 
356   /*
<a name="9" id="anc9"></a><span class="line-modified">357    * Return the most significant bit index.</span>
358    */
359 
360 #ifndef  FT_CONFIG_OPTION_NO_ASSEMBLER
<a name="10" id="anc10"></a><span class="line-added">361 </span>
362 #if defined( __GNUC__ )                                          &amp;&amp; \
363     ( __GNUC__ &gt; 3 || ( __GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4 ) )
364 
365 #if FT_SIZEOF_INT == 4
366 
367 #define FT_MSB( x )  ( 31 - __builtin_clz( x ) )
368 
369 #elif FT_SIZEOF_LONG == 4
370 
371 #define FT_MSB( x )  ( 31 - __builtin_clzl( x ) )
372 
<a name="11" id="anc11"></a><span class="line-added">373 #endif /* __GNUC__ */</span>
<span class="line-added">374 </span>
<span class="line-added">375 </span>
<span class="line-added">376 #elif defined( _MSC_VER ) &amp;&amp; ( _MSC_VER &gt;= 1400 )</span>
<span class="line-added">377 </span>
<span class="line-added">378 #if FT_SIZEOF_INT == 4</span>
<span class="line-added">379 </span>
<span class="line-added">380 #include &lt;intrin.h&gt;</span>
<span class="line-added">381 #pragma intrinsic( _BitScanReverse )</span>
<span class="line-added">382 </span>
<span class="line-added">383   static __inline FT_Int32</span>
<span class="line-added">384   FT_MSB_i386( FT_UInt32  x )</span>
<span class="line-added">385   {</span>
<span class="line-added">386     unsigned long  where;</span>
<span class="line-added">387 </span>
<span class="line-added">388 </span>
<span class="line-added">389     _BitScanReverse( &amp;where, x );</span>
<span class="line-added">390 </span>
<span class="line-added">391     return (FT_Int32)where;</span>
<span class="line-added">392   }</span>
<span class="line-added">393 </span>
<span class="line-added">394 #define FT_MSB( x )  ( FT_MSB_i386( x ) )</span>
<span class="line-added">395 </span>
396 #endif
397 
<a name="12" id="anc12"></a><span class="line-modified">398 #endif /* _MSC_VER */</span>
<span class="line-added">399 </span>
<span class="line-added">400 </span>
401 #endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
402 
403 #ifndef FT_MSB
404 
405   FT_BASE( FT_Int )
406   FT_MSB( FT_UInt32  z );
407 
408 #endif
409 
410 
411   /*
<a name="13" id="anc13"></a><span class="line-modified">412    * Return sqrt(x*x+y*y), which is the same as `FT_Vector_Length&#39; but uses</span>
<span class="line-modified">413    * two fixed-point arguments instead.</span>
414    */
415   FT_BASE( FT_Fixed )
416   FT_Hypot( FT_Fixed  x,
417             FT_Fixed  y );
418 
419 
420 #if 0
421 
<a name="14" id="anc14"></a><span class="line-modified">422   /**************************************************************************</span>
<span class="line-modified">423    *</span>
<span class="line-modified">424    * @function:</span>
<span class="line-modified">425    *   FT_SqrtFixed</span>
<span class="line-modified">426    *</span>
<span class="line-modified">427    * @description:</span>
<span class="line-modified">428    *   Computes the square root of a 16.16 fixed-point value.</span>
<span class="line-modified">429    *</span>
<span class="line-modified">430    * @input:</span>
<span class="line-modified">431    *   x ::</span>
<span class="line-modified">432    *     The value to compute the root for.</span>
<span class="line-modified">433    *</span>
<span class="line-modified">434    * @return:</span>
<span class="line-modified">435    *   The result of &#39;sqrt(x)&#39;.</span>
<span class="line-modified">436    *</span>
<span class="line-modified">437    * @note:</span>
<span class="line-modified">438    *   This function is not very fast.</span>
<span class="line-added">439    */</span>
440   FT_BASE( FT_Int32 )
441   FT_SqrtFixed( FT_Int32  x );
442 
443 #endif /* 0 */
444 
445 
446 #define INT_TO_F26DOT6( x )    ( (FT_Long)(x) * 64  )    /* &lt;&lt; 6  */
447 #define INT_TO_F2DOT14( x )    ( (FT_Long)(x) * 16384 )  /* &lt;&lt; 14 */
448 #define INT_TO_FIXED( x )      ( (FT_Long)(x) * 65536 )  /* &lt;&lt; 16 */
449 #define F2DOT14_TO_FIXED( x )  ( (FT_Long)(x) * 4 )      /* &lt;&lt; 2  */
450 #define FIXED_TO_INT( x )      ( FT_RoundFix( x ) &gt;&gt; 16 )
451 
452 #define ROUND_F26DOT6( x )     ( x &gt;= 0 ? (    ( (x) + 32 ) &amp; -64 )     \
453                                         : ( -( ( 32 - (x) ) &amp; -64 ) ) )
454 
455   /*
<a name="15" id="anc15"></a><span class="line-modified">456    * The following macros have two purposes.</span>
457    *
<a name="16" id="anc16"></a><span class="line-modified">458    * - Tag places where overflow is expected and harmless.</span>
459    *
<a name="17" id="anc17"></a><span class="line-modified">460    * - Avoid run-time sanitizer errors.</span>
461    *
<a name="18" id="anc18"></a><span class="line-modified">462    * Use with care!</span>
463    */
<a name="19" id="anc19"></a><span class="line-added">464 #define ADD_INT( a, b )                           \</span>
<span class="line-added">465           (FT_Int)( (FT_UInt)(a) + (FT_UInt)(b) )</span>
<span class="line-added">466 #define SUB_INT( a, b )                           \</span>
<span class="line-added">467           (FT_Int)( (FT_UInt)(a) - (FT_UInt)(b) )</span>
<span class="line-added">468 #define MUL_INT( a, b )                           \</span>
<span class="line-added">469           (FT_Int)( (FT_UInt)(a) * (FT_UInt)(b) )</span>
<span class="line-added">470 #define NEG_INT( a )                              \</span>
<span class="line-added">471           (FT_Int)( (FT_UInt)0 - (FT_UInt)(a) )</span>
<span class="line-added">472 </span>
473 #define ADD_LONG( a, b )                             \
474           (FT_Long)( (FT_ULong)(a) + (FT_ULong)(b) )
475 #define SUB_LONG( a, b )                             \
476           (FT_Long)( (FT_ULong)(a) - (FT_ULong)(b) )
477 #define MUL_LONG( a, b )                             \
478           (FT_Long)( (FT_ULong)(a) * (FT_ULong)(b) )
479 #define NEG_LONG( a )                                \
480           (FT_Long)( (FT_ULong)0 - (FT_ULong)(a) )
481 
482 #define ADD_INT32( a, b )                               \
483           (FT_Int32)( (FT_UInt32)(a) + (FT_UInt32)(b) )
484 #define SUB_INT32( a, b )                               \
485           (FT_Int32)( (FT_UInt32)(a) - (FT_UInt32)(b) )
486 #define MUL_INT32( a, b )                               \
487           (FT_Int32)( (FT_UInt32)(a) * (FT_UInt32)(b) )
488 #define NEG_INT32( a )                                  \
489           (FT_Int32)( (FT_UInt32)0 - (FT_UInt32)(a) )
490 
<a name="20" id="anc20"></a><span class="line-added">491 #ifdef FT_LONG64</span>
<span class="line-added">492 </span>
<span class="line-added">493 #define ADD_INT64( a, b )                               \</span>
<span class="line-added">494           (FT_Int64)( (FT_UInt64)(a) + (FT_UInt64)(b) )</span>
<span class="line-added">495 #define SUB_INT64( a, b )                               \</span>
<span class="line-added">496           (FT_Int64)( (FT_UInt64)(a) - (FT_UInt64)(b) )</span>
<span class="line-added">497 #define MUL_INT64( a, b )                               \</span>
<span class="line-added">498           (FT_Int64)( (FT_UInt64)(a) * (FT_UInt64)(b) )</span>
<span class="line-added">499 #define NEG_INT64( a )                                  \</span>
<span class="line-added">500           (FT_Int64)( (FT_UInt64)0 - (FT_UInt64)(a) )</span>
<span class="line-added">501 </span>
<span class="line-added">502 #endif /* FT_LONG64 */</span>
<span class="line-added">503 </span>
504 
505 FT_END_HEADER
506 
507 #endif /* FTCALC_H_ */
508 
509 
510 /* END */
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>
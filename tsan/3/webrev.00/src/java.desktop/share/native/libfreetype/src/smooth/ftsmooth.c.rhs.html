<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/smooth/ftsmooth.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftsmooth.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Anti-aliasing renderer interface (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 2000-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_INTERNAL_OBJECTS_H
 22 #include FT_OUTLINE_H
 23 #include &quot;ftsmooth.h&quot;
 24 #include &quot;ftgrays.h&quot;
<a name="2" id="anc2"></a>
 25 
 26 #include &quot;ftsmerrs.h&quot;
 27 
 28 
 29   /* initialize renderer -- init its raster */
 30   static FT_Error
 31   ft_smooth_init( FT_Renderer  render )
 32   {
<a name="3" id="anc3"></a><span class="line-added"> 33 </span>
<span class="line-added"> 34 #ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING</span>
<span class="line-added"> 35 </span>
<span class="line-added"> 36     FT_Vector*  sub = render-&gt;root.library-&gt;lcd_geometry;</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38 </span>
<span class="line-added"> 39     /* set up default subpixel geometry for striped RGB panels. */</span>
<span class="line-added"> 40     sub[0].x = -21;</span>
<span class="line-added"> 41     sub[0].y = 0;</span>
<span class="line-added"> 42     sub[1].x = 0;</span>
<span class="line-added"> 43     sub[1].y = 0;</span>
<span class="line-added"> 44     sub[2].x = 21;</span>
<span class="line-added"> 45     sub[2].y = 0;</span>
<span class="line-added"> 46 </span>
<span class="line-added"> 47 #elif 0   /* or else, once ClearType patents expire */</span>
<span class="line-added"> 48 </span>
<span class="line-added"> 49     FT_Library_SetLcdFilter( render-&gt;root.library, FT_LCD_FILTER_DEFAULT );</span>
<span class="line-added"> 50 </span>
<span class="line-added"> 51 #endif</span>
<span class="line-added"> 52 </span>
 53     render-&gt;clazz-&gt;raster_class-&gt;raster_reset( render-&gt;raster, NULL, 0 );
 54 
 55     return 0;
 56   }
 57 
 58 
 59   /* sets render-specific mode */
 60   static FT_Error
 61   ft_smooth_set_mode( FT_Renderer  render,
 62                       FT_ULong     mode_tag,
 63                       FT_Pointer   data )
 64   {
 65     /* we simply pass it to the raster */
 66     return render-&gt;clazz-&gt;raster_class-&gt;raster_set_mode( render-&gt;raster,
 67                                                          mode_tag,
 68                                                          data );
 69   }
 70 
 71   /* transform a given glyph image */
 72   static FT_Error
 73   ft_smooth_transform( FT_Renderer       render,
 74                        FT_GlyphSlot      slot,
 75                        const FT_Matrix*  matrix,
 76                        const FT_Vector*  delta )
 77   {
 78     FT_Error  error = FT_Err_Ok;
 79 
 80 
 81     if ( slot-&gt;format != render-&gt;glyph_format )
 82     {
 83       error = FT_THROW( Invalid_Argument );
 84       goto Exit;
 85     }
 86 
 87     if ( matrix )
 88       FT_Outline_Transform( &amp;slot-&gt;outline, matrix );
 89 
 90     if ( delta )
 91       FT_Outline_Translate( &amp;slot-&gt;outline, delta-&gt;x, delta-&gt;y );
 92 
 93   Exit:
 94     return error;
 95   }
 96 
 97 
 98   /* return the glyph&#39;s control box */
 99   static void
100   ft_smooth_get_cbox( FT_Renderer   render,
101                       FT_GlyphSlot  slot,
102                       FT_BBox*      cbox )
103   {
104     FT_ZERO( cbox );
105 
106     if ( slot-&gt;format == render-&gt;glyph_format )
107       FT_Outline_Get_CBox( &amp;slot-&gt;outline, cbox );
108   }
109 
110 
111   /* convert a slot&#39;s glyph image into a bitmap */
112   static FT_Error
113   ft_smooth_render_generic( FT_Renderer       render,
114                             FT_GlyphSlot      slot,
115                             FT_Render_Mode    mode,
116                             const FT_Vector*  origin,
117                             FT_Render_Mode    required_mode )
118   {
119     FT_Error     error   = FT_Err_Ok;
120     FT_Outline*  outline = &amp;slot-&gt;outline;
121     FT_Bitmap*   bitmap  = &amp;slot-&gt;bitmap;
122     FT_Memory    memory  = render-&gt;root.memory;
123     FT_Pos       x_shift = 0;
124     FT_Pos       y_shift = 0;
125     FT_Int       hmul    = ( mode == FT_RENDER_MODE_LCD );
126     FT_Int       vmul    = ( mode == FT_RENDER_MODE_LCD_V );
127 
128     FT_Raster_Params  params;
129 
130 
131     /* check glyph image format */
132     if ( slot-&gt;format != render-&gt;glyph_format )
133     {
134       error = FT_THROW( Invalid_Argument );
135       goto Exit;
136     }
137 
138     /* check mode */
139     if ( mode != required_mode )
140     {
141       error = FT_THROW( Cannot_Render_Glyph );
142       goto Exit;
143     }
144 
145     /* release old bitmap buffer */
146     if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
147     {
148       FT_FREE( bitmap-&gt;buffer );
149       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
150     }
151 
<a name="4" id="anc4"></a><span class="line-modified">152     if ( ft_glyphslot_preset_bitmap( slot, mode, origin ) )</span>
<span class="line-added">153     {</span>
<span class="line-added">154       error = FT_THROW( Raster_Overflow );</span>
<span class="line-added">155       goto Exit;</span>
<span class="line-added">156     }</span>
157 
158     /* allocate new one */
159     if ( FT_ALLOC_MULT( bitmap-&gt;buffer, bitmap-&gt;rows, bitmap-&gt;pitch ) )
160       goto Exit;
161 
162     slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;
163 
164     x_shift = 64 * -slot-&gt;bitmap_left;
165     y_shift = 64 * -slot-&gt;bitmap_top;
166     if ( bitmap-&gt;pixel_mode == FT_PIXEL_MODE_LCD_V )
167       y_shift += 64 * (FT_Int)bitmap-&gt;rows / 3;
168     else
169       y_shift += 64 * (FT_Int)bitmap-&gt;rows;
170 
171     if ( origin )
172     {
173       x_shift += origin-&gt;x;
174       y_shift += origin-&gt;y;
175     }
176 
177     /* translate outline to render it into the bitmap */
178     if ( x_shift || y_shift )
179       FT_Outline_Translate( outline, x_shift, y_shift );
180 
181     /* set up parameters */
182     params.target = bitmap;
183     params.source = outline;
184     params.flags  = FT_RASTER_FLAG_AA;
185 
186 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
187 
188     /* implode outline if needed */
189     {
190       FT_Vector*  points     = outline-&gt;points;
191       FT_Vector*  points_end = points + outline-&gt;n_points;
192       FT_Vector*  vec;
193 
194 
195       if ( hmul )
196         for ( vec = points; vec &lt; points_end; vec++ )
197           vec-&gt;x *= 3;
198 
199       if ( vmul )
200         for ( vec = points; vec &lt; points_end; vec++ )
201           vec-&gt;y *= 3;
202     }
203 
204     /* render outline into the bitmap */
205     error = render-&gt;raster_render( render-&gt;raster, &amp;params );
206 
207     /* deflate outline if needed */
208     {
209       FT_Vector*  points     = outline-&gt;points;
210       FT_Vector*  points_end = points + outline-&gt;n_points;
211       FT_Vector*  vec;
212 
213 
214       if ( hmul )
215         for ( vec = points; vec &lt; points_end; vec++ )
216           vec-&gt;x /= 3;
217 
218       if ( vmul )
219         for ( vec = points; vec &lt; points_end; vec++ )
220           vec-&gt;y /= 3;
221     }
222 
223     if ( error )
224       goto Exit;
225 
226     /* finally apply filtering */
227     if ( hmul || vmul )
228     {
229       FT_Byte*                 lcd_weights;
230       FT_Bitmap_LcdFilterFunc  lcd_filter_func;
231 
232 
233       /* Per-face LCD filtering takes priority if set up. */
234       if ( slot-&gt;face &amp;&amp; slot-&gt;face-&gt;internal-&gt;lcd_filter_func )
235       {
236         lcd_weights     = slot-&gt;face-&gt;internal-&gt;lcd_weights;
237         lcd_filter_func = slot-&gt;face-&gt;internal-&gt;lcd_filter_func;
238       }
239       else
240       {
241         lcd_weights     = slot-&gt;library-&gt;lcd_weights;
242         lcd_filter_func = slot-&gt;library-&gt;lcd_filter_func;
243       }
244 
245       if ( lcd_filter_func )
<a name="5" id="anc5"></a><span class="line-modified">246         lcd_filter_func( bitmap, lcd_weights );</span>
247     }
248 
249 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
250 
251     if ( hmul )  /* lcd */
252     {
253       FT_Byte*  line;
254       FT_Byte*  temp = NULL;
255       FT_UInt   i, j;
256 
257       unsigned int  height = bitmap-&gt;rows;
258       unsigned int  width  = bitmap-&gt;width;
259       int           pitch  = bitmap-&gt;pitch;
260 
<a name="6" id="anc6"></a><span class="line-added">261       FT_Vector*  sub = slot-&gt;library-&gt;lcd_geometry;</span>
262 
<a name="7" id="anc7"></a>


263 
<a name="8" id="anc8"></a><span class="line-modified">264       /* Render 3 separate monochrome bitmaps, shifting the outline.  */</span>
<span class="line-added">265       width /= 3;</span>
266 
<a name="9" id="anc9"></a><span class="line-added">267       FT_Outline_Translate( outline,</span>
<span class="line-added">268                             -sub[0].x,</span>
<span class="line-added">269                             -sub[0].y );</span>
270       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
271       if ( error )
272         goto Exit;
273 
<a name="10" id="anc10"></a>

274       bitmap-&gt;buffer += width;
<a name="11" id="anc11"></a><span class="line-modified">275       FT_Outline_Translate( outline,</span>
<span class="line-added">276                             sub[0].x - sub[1].x,</span>
<span class="line-added">277                             sub[0].y - sub[1].y );</span>
278       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="12" id="anc12"></a><span class="line-added">279       bitmap-&gt;buffer -= width;</span>
280       if ( error )
281         goto Exit;
282 
<a name="13" id="anc13"></a><span class="line-modified">283       bitmap-&gt;buffer += 2 * width;</span>
<span class="line-modified">284       FT_Outline_Translate( outline,</span>
<span class="line-modified">285                             sub[1].x - sub[2].x,</span>
<span class="line-modified">286                             sub[1].y - sub[2].y );</span>
287       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="14" id="anc14"></a><span class="line-added">288       bitmap-&gt;buffer -= 2 * width;</span>
289       if ( error )
290         goto Exit;
291 
<a name="15" id="anc15"></a><span class="line-added">292       x_shift -= sub[2].x;</span>
<span class="line-added">293       y_shift -= sub[2].y;</span>
<span class="line-added">294 </span>
295       /* XXX: Rearrange the bytes according to FT_PIXEL_MODE_LCD.    */
296       /* XXX: It is more efficient to render every third byte above. */
297 
298       if ( FT_ALLOC( temp, (FT_ULong)pitch ) )
299         goto Exit;
300 
301       for ( i = 0; i &lt; height; i++ )
302       {
303         line = bitmap-&gt;buffer + i * (FT_ULong)pitch;
304         for ( j = 0; j &lt; width; j++ )
305         {
306           temp[3 * j    ] = line[j];
307           temp[3 * j + 1] = line[j + width];
308           temp[3 * j + 2] = line[j + width + width];
309         }
310         FT_MEM_COPY( line, temp, pitch );
311       }
312 
313       FT_FREE( temp );
314     }
315     else if ( vmul )  /* lcd_v */
316     {
317       int  pitch  = bitmap-&gt;pitch;
318 
<a name="16" id="anc16"></a><span class="line-added">319       FT_Vector*  sub = slot-&gt;library-&gt;lcd_geometry;</span>
<span class="line-added">320 </span>
321 
<a name="17" id="anc17"></a><span class="line-modified">322       /* Render 3 separate monochrome bitmaps, shifting the outline. */</span>
<span class="line-modified">323       /* Notice that the subpixel geometry vectors are rotated.      */</span>
<span class="line-added">324       /* Triple the pitch to render on each third row.               */</span>
325       bitmap-&gt;pitch *= 3;
326       bitmap-&gt;rows  /= 3;
327 
<a name="18" id="anc18"></a><span class="line-modified">328       FT_Outline_Translate( outline,</span>
<span class="line-modified">329                             -sub[0].y,</span>
<span class="line-added">330                             sub[0].x );</span>
331       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
332       if ( error )
333         goto Exit;
334 
<a name="19" id="anc19"></a>

335       bitmap-&gt;buffer += pitch;
<a name="20" id="anc20"></a><span class="line-modified">336       FT_Outline_Translate( outline,</span>
<span class="line-added">337                             sub[0].y - sub[1].y,</span>
<span class="line-added">338                             sub[1].x - sub[0].x );</span>
339       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="21" id="anc21"></a><span class="line-added">340       bitmap-&gt;buffer -= pitch;</span>
341       if ( error )
342         goto Exit;
343 
<a name="22" id="anc22"></a><span class="line-modified">344       bitmap-&gt;buffer += 2 * pitch;</span>
<span class="line-modified">345       FT_Outline_Translate( outline,</span>
<span class="line-modified">346                             sub[1].y - sub[2].y,</span>
<span class="line-modified">347                             sub[2].x - sub[1].x );</span>
348       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
<a name="23" id="anc23"></a><span class="line-added">349       bitmap-&gt;buffer -= 2 * pitch;</span>
350       if ( error )
351         goto Exit;
352 
<a name="24" id="anc24"></a><span class="line-added">353       x_shift -= sub[2].y;</span>
<span class="line-added">354       y_shift += sub[2].x;</span>
<span class="line-added">355 </span>
356       bitmap-&gt;pitch /= 3;
357       bitmap-&gt;rows  *= 3;
358     }
359     else  /* grayscale */
360       error = render-&gt;raster_render( render-&gt;raster, &amp;params );
361 
362 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
363 
364   Exit:
365     if ( !error )
366     {
367       /* everything is fine; the glyph is now officially a bitmap */
368       slot-&gt;format = FT_GLYPH_FORMAT_BITMAP;
369     }
370     else if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )
371     {
372       FT_FREE( bitmap-&gt;buffer );
373       slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;
374     }
375 
376     if ( x_shift || y_shift )
377       FT_Outline_Translate( outline, -x_shift, -y_shift );
378 
379     return error;
380   }
381 
382 
383   /* convert a slot&#39;s glyph image into a bitmap */
384   static FT_Error
385   ft_smooth_render( FT_Renderer       render,
386                     FT_GlyphSlot      slot,
387                     FT_Render_Mode    mode,
388                     const FT_Vector*  origin )
389   {
390     if ( mode == FT_RENDER_MODE_LIGHT )
391       mode = FT_RENDER_MODE_NORMAL;
392 
393     return ft_smooth_render_generic( render, slot, mode, origin,
394                                      FT_RENDER_MODE_NORMAL );
395   }
396 
397 
398   /* convert a slot&#39;s glyph image into a horizontal LCD bitmap */
399   static FT_Error
400   ft_smooth_render_lcd( FT_Renderer       render,
401                         FT_GlyphSlot      slot,
402                         FT_Render_Mode    mode,
403                         const FT_Vector*  origin )
404   {
405     return ft_smooth_render_generic( render, slot, mode, origin,
406                                      FT_RENDER_MODE_LCD );
407   }
408 
409 
410   /* convert a slot&#39;s glyph image into a vertical LCD bitmap */
411   static FT_Error
412   ft_smooth_render_lcd_v( FT_Renderer       render,
413                           FT_GlyphSlot      slot,
414                           FT_Render_Mode    mode,
415                           const FT_Vector*  origin )
416   {
417     return ft_smooth_render_generic( render, slot, mode, origin,
418                                      FT_RENDER_MODE_LCD_V );
419   }
420 
421 
422   FT_DEFINE_RENDERER(
423     ft_smooth_renderer_class,
424 
425       FT_MODULE_RENDERER,
426       sizeof ( FT_RendererRec ),
427 
428       &quot;smooth&quot;,
429       0x10000L,
430       0x20000L,
431 
432       NULL,    /* module specific interface */
433 
434       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
435       (FT_Module_Destructor) NULL,            /* module_done   */
436       (FT_Module_Requester)  NULL,            /* get_interface */
437 
438     FT_GLYPH_FORMAT_OUTLINE,
439 
440     (FT_Renderer_RenderFunc)   ft_smooth_render,     /* render_glyph    */
441     (FT_Renderer_TransformFunc)ft_smooth_transform,  /* transform_glyph */
442     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,   /* get_glyph_cbox  */
443     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,   /* set_mode        */
444 
<a name="25" id="anc25"></a><span class="line-modified">445     (FT_Raster_Funcs*)&amp;ft_grays_raster               /* raster_class    */</span>
446   )
447 
448 
449   FT_DEFINE_RENDERER(
450     ft_smooth_lcd_renderer_class,
451 
452       FT_MODULE_RENDERER,
453       sizeof ( FT_RendererRec ),
454 
455       &quot;smooth-lcd&quot;,
456       0x10000L,
457       0x20000L,
458 
459       NULL,    /* module specific interface */
460 
461       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
462       (FT_Module_Destructor) NULL,            /* module_done   */
463       (FT_Module_Requester)  NULL,            /* get_interface */
464 
465     FT_GLYPH_FORMAT_OUTLINE,
466 
467     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd,  /* render_glyph    */
468     (FT_Renderer_TransformFunc)ft_smooth_transform,   /* transform_glyph */
469     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,    /* get_glyph_cbox  */
470     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,    /* set_mode        */
471 
<a name="26" id="anc26"></a><span class="line-modified">472     (FT_Raster_Funcs*)&amp;ft_grays_raster                /* raster_class    */</span>
473   )
474 
475 
476   FT_DEFINE_RENDERER(
477     ft_smooth_lcdv_renderer_class,
478 
479       FT_MODULE_RENDERER,
480       sizeof ( FT_RendererRec ),
481 
482       &quot;smooth-lcdv&quot;,
483       0x10000L,
484       0x20000L,
485 
486       NULL,    /* module specific interface */
487 
488       (FT_Module_Constructor)ft_smooth_init,  /* module_init   */
489       (FT_Module_Destructor) NULL,            /* module_done   */
490       (FT_Module_Requester)  NULL,            /* get_interface */
491 
492     FT_GLYPH_FORMAT_OUTLINE,
493 
494     (FT_Renderer_RenderFunc)   ft_smooth_render_lcd_v,  /* render_glyph    */
495     (FT_Renderer_TransformFunc)ft_smooth_transform,     /* transform_glyph */
496     (FT_Renderer_GetCBoxFunc)  ft_smooth_get_cbox,      /* get_glyph_cbox  */
497     (FT_Renderer_SetModeFunc)  ft_smooth_set_mode,      /* set_mode        */
498 
<a name="27" id="anc27"></a><span class="line-modified">499     (FT_Raster_Funcs*)&amp;ft_grays_raster                  /* raster_class    */</span>
500   )
501 
502 
503 /* END */
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
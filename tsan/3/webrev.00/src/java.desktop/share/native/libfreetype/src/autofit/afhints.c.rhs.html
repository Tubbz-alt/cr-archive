<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * afhints.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   Auto-fitter hinting routines (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2003-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &quot;afhints.h&quot;
  20 #include &quot;aferrors.h&quot;
  21 #include FT_INTERNAL_CALC_H
  22 #include FT_INTERNAL_DEBUG_H
  23 
  24 
<a name="2" id="anc2"></a><span class="line-modified">  25   /**************************************************************************</span>
<span class="line-modified">  26    *</span>
<span class="line-modified">  27    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">  28    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">  29    * messages during execution.</span>
<span class="line-modified">  30    */</span>
  31 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  32 #define FT_COMPONENT  afhints</span>
  33 
  34 
  35   /* Get new segment for given axis. */
  36 
  37   FT_LOCAL_DEF( FT_Error )
  38   af_axis_hints_new_segment( AF_AxisHints  axis,
  39                              FT_Memory     memory,
  40                              AF_Segment   *asegment )
  41   {
  42     FT_Error    error   = FT_Err_Ok;
  43     AF_Segment  segment = NULL;
  44 
  45 
  46     if ( axis-&gt;num_segments &lt; AF_SEGMENTS_EMBEDDED )
  47     {
  48       if ( !axis-&gt;segments )
  49       {
  50         axis-&gt;segments     = axis-&gt;embedded.segments;
  51         axis-&gt;max_segments = AF_SEGMENTS_EMBEDDED;
  52       }
  53     }
  54     else if ( axis-&gt;num_segments &gt;= axis-&gt;max_segments )
  55     {
  56       FT_Int  old_max = axis-&gt;max_segments;
  57       FT_Int  new_max = old_max;
  58       FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *segment ) );
  59 
  60 
  61       if ( old_max &gt;= big_max )
  62       {
  63         error = FT_THROW( Out_Of_Memory );
  64         goto Exit;
  65       }
  66 
  67       new_max += ( new_max &gt;&gt; 2 ) + 4;
  68       if ( new_max &lt; old_max || new_max &gt; big_max )
  69         new_max = big_max;
  70 
  71       if ( axis-&gt;segments == axis-&gt;embedded.segments )
  72       {
  73         if ( FT_NEW_ARRAY( axis-&gt;segments, new_max ) )
  74           goto Exit;
  75         ft_memcpy( axis-&gt;segments, axis-&gt;embedded.segments,
  76                    sizeof ( axis-&gt;embedded.segments ) );
  77       }
  78       else
  79       {
  80         if ( FT_RENEW_ARRAY( axis-&gt;segments, old_max, new_max ) )
  81           goto Exit;
  82       }
  83 
  84       axis-&gt;max_segments = new_max;
  85     }
  86 
  87     segment = axis-&gt;segments + axis-&gt;num_segments++;
  88 
  89   Exit:
  90     *asegment = segment;
  91     return error;
  92   }
  93 
  94 
  95   /* Get new edge for given axis, direction, and position, */
  96   /* without initializing the edge itself.                 */
  97 
  98   FT_LOCAL( FT_Error )
  99   af_axis_hints_new_edge( AF_AxisHints  axis,
 100                           FT_Int        fpos,
 101                           AF_Direction  dir,
 102                           FT_Bool       top_to_bottom_hinting,
 103                           FT_Memory     memory,
 104                           AF_Edge      *anedge )
 105   {
 106     FT_Error  error = FT_Err_Ok;
 107     AF_Edge   edge  = NULL;
 108     AF_Edge   edges;
 109 
 110 
 111     if ( axis-&gt;num_edges &lt; AF_EDGES_EMBEDDED )
 112     {
 113       if ( !axis-&gt;edges )
 114       {
 115         axis-&gt;edges     = axis-&gt;embedded.edges;
 116         axis-&gt;max_edges = AF_EDGES_EMBEDDED;
 117       }
 118     }
 119     else if ( axis-&gt;num_edges &gt;= axis-&gt;max_edges )
 120     {
 121       FT_Int  old_max = axis-&gt;max_edges;
 122       FT_Int  new_max = old_max;
 123       FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *edge ) );
 124 
 125 
 126       if ( old_max &gt;= big_max )
 127       {
 128         error = FT_THROW( Out_Of_Memory );
 129         goto Exit;
 130       }
 131 
 132       new_max += ( new_max &gt;&gt; 2 ) + 4;
 133       if ( new_max &lt; old_max || new_max &gt; big_max )
 134         new_max = big_max;
 135 
 136       if ( axis-&gt;edges == axis-&gt;embedded.edges )
 137       {
 138         if ( FT_NEW_ARRAY( axis-&gt;edges, new_max ) )
 139           goto Exit;
 140         ft_memcpy( axis-&gt;edges, axis-&gt;embedded.edges,
 141                    sizeof ( axis-&gt;embedded.edges ) );
 142       }
 143       else
 144       {
 145         if ( FT_RENEW_ARRAY( axis-&gt;edges, old_max, new_max ) )
 146           goto Exit;
 147       }
 148 
 149       axis-&gt;max_edges = new_max;
 150     }
 151 
 152     edges = axis-&gt;edges;
 153     edge  = edges + axis-&gt;num_edges;
 154 
 155     while ( edge &gt; edges )
 156     {
 157       if ( top_to_bottom_hinting ? ( edge[-1].fpos &gt; fpos )
 158                                  : ( edge[-1].fpos &lt; fpos ) )
 159         break;
 160 
 161       /* we want the edge with same position and minor direction */
 162       /* to appear before those in the major one in the list     */
 163       if ( edge[-1].fpos == fpos &amp;&amp; dir == axis-&gt;major_dir )
 164         break;
 165 
 166       edge[0] = edge[-1];
 167       edge--;
 168     }
 169 
 170     axis-&gt;num_edges++;
 171 
 172   Exit:
 173     *anedge = edge;
 174     return error;
 175   }
 176 
 177 
 178 #ifdef FT_DEBUG_AUTOFIT
 179 
 180 #include FT_CONFIG_STANDARD_LIBRARY_H
 181 
 182   /* The dump functions are used in the `ftgrid&#39; demo program, too. */
 183 #define AF_DUMP( varformat )          \
 184           do                          \
 185           {                           \
 186             if ( to_stdout )          \
 187               printf varformat;       \
 188             else                      \
 189               FT_TRACE7( varformat ); \
 190           } while ( 0 )
 191 
 192 
 193   static const char*
 194   af_dir_str( AF_Direction  dir )
 195   {
 196     const char*  result;
 197 
 198 
 199     switch ( dir )
 200     {
 201     case AF_DIR_UP:
 202       result = &quot;up&quot;;
 203       break;
 204     case AF_DIR_DOWN:
 205       result = &quot;down&quot;;
 206       break;
 207     case AF_DIR_LEFT:
 208       result = &quot;left&quot;;
 209       break;
 210     case AF_DIR_RIGHT:
 211       result = &quot;right&quot;;
 212       break;
 213     default:
 214       result = &quot;none&quot;;
 215     }
 216 
 217     return result;
 218   }
 219 
 220 
 221 #define AF_INDEX_NUM( ptr, base )  (int)( (ptr) ? ( (ptr) - (base) ) : -1 )
 222 
 223 
 224   static char*
 225   af_print_idx( char* p,
 226                 int   idx )
 227   {
 228     if ( idx == -1 )
 229     {
 230       p[0] = &#39;-&#39;;
 231       p[1] = &#39;-&#39;;
 232       p[2] = &#39;\0&#39;;
 233     }
 234     else
 235       ft_sprintf( p, &quot;%d&quot;, idx );
 236 
 237     return p;
 238   }
 239 
 240 
 241   static int
 242   af_get_segment_index( AF_GlyphHints  hints,
 243                         int            point_idx,
 244                         int            dimension )
 245   {
 246     AF_AxisHints  axis     = &amp;hints-&gt;axis[dimension];
 247     AF_Point      point    = hints-&gt;points + point_idx;
 248     AF_Segment    segments = axis-&gt;segments;
 249     AF_Segment    limit    = segments + axis-&gt;num_segments;
 250     AF_Segment    segment;
 251 
 252 
 253     for ( segment = segments; segment &lt; limit; segment++ )
 254     {
 255       if ( segment-&gt;first &lt;= segment-&gt;last )
 256       {
 257         if ( point &gt;= segment-&gt;first &amp;&amp; point &lt;= segment-&gt;last )
 258           break;
 259       }
 260       else
 261       {
 262         AF_Point  p = segment-&gt;first;
 263 
 264 
 265         for (;;)
 266         {
 267           if ( point == p )
 268             goto Exit;
 269 
 270           if ( p == segment-&gt;last )
 271             break;
 272 
 273           p = p-&gt;next;
 274         }
 275       }
 276     }
 277 
 278   Exit:
 279     if ( segment == limit )
 280       return -1;
 281 
 282     return (int)( segment - segments );
 283   }
 284 
 285 
 286   static int
 287   af_get_edge_index( AF_GlyphHints  hints,
 288                      int            segment_idx,
 289                      int            dimension )
 290   {
 291     AF_AxisHints  axis    = &amp;hints-&gt;axis[dimension];
 292     AF_Edge       edges   = axis-&gt;edges;
 293     AF_Segment    segment = axis-&gt;segments + segment_idx;
 294 
 295 
 296     return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
 297   }
 298 
 299 
<a name="4" id="anc4"></a><span class="line-added"> 300   static int</span>
<span class="line-added"> 301   af_get_strong_edge_index( AF_GlyphHints  hints,</span>
<span class="line-added"> 302                             AF_Edge*       strong_edges,</span>
<span class="line-added"> 303                             int            dimension )</span>
<span class="line-added"> 304   {</span>
<span class="line-added"> 305     AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];</span>
<span class="line-added"> 306     AF_Edge       edges = axis-&gt;edges;</span>
<span class="line-added"> 307 </span>
<span class="line-added"> 308 </span>
<span class="line-added"> 309     return AF_INDEX_NUM( strong_edges[dimension], edges );</span>
<span class="line-added"> 310   }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312 </span>
 313 #ifdef __cplusplus
 314   extern &quot;C&quot; {
 315 #endif
 316   void
 317   af_glyph_hints_dump_points( AF_GlyphHints  hints,
 318                               FT_Bool        to_stdout )
 319   {
 320     AF_Point   points  = hints-&gt;points;
 321     AF_Point   limit   = points + hints-&gt;num_points;
 322     AF_Point*  contour = hints-&gt;contours;
 323     AF_Point*  climit  = contour + hints-&gt;num_contours;
 324     AF_Point   point;
 325 
 326 
 327     AF_DUMP(( &quot;Table of points:\n&quot; ));
 328 
 329     if ( hints-&gt;num_points )
 330     {
 331       AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
 332              /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<a name="5" id="anc5"></a><span class="line-modified"> 333                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit &quot;</span>
 334              /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
<a name="6" id="anc6"></a><span class="line-added"> 335                 &quot;  hbef  haft  vbef  vaft&quot; ));</span>
<span class="line-added"> 336              /* &quot; XXXXX XXXXX XXXXX XXXXX&quot; */</span>
 337     }
 338     else
 339       AF_DUMP(( &quot;  (none)\n&quot; ));
 340 
 341     for ( point = points; point &lt; limit; point++ )
 342     {
 343       int  point_idx     = AF_INDEX_NUM( point, points );
 344       int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
 345       int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
 346 
 347       char  buf1[16], buf2[16], buf3[16], buf4[16];
<a name="7" id="anc7"></a><span class="line-added"> 348       char  buf5[16], buf6[16], buf7[16], buf8[16];</span>
 349 
 350 
 351       /* insert extra newline at the beginning of a contour */
 352       if ( contour &lt; climit &amp;&amp; *contour == point )
 353       {
 354         AF_DUMP(( &quot;\n&quot; ));
 355         contour++;
 356       }
 357 
 358       AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<a name="8" id="anc8"></a><span class="line-modified"> 359                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f&quot;</span>
<span class="line-added"> 360                 &quot; %5s %5s %5s %5s\n&quot;,</span>
 361                 point_idx,
 362                 af_print_idx( buf1,
 363                               af_get_edge_index( hints, segment_idx_1, 1 ) ),
 364                 af_print_idx( buf2, segment_idx_1 ),
 365                 af_print_idx( buf3,
 366                               af_get_edge_index( hints, segment_idx_0, 0 ) ),
 367                 af_print_idx( buf4, segment_idx_0 ),
 368                 ( point-&gt;flags &amp; AF_FLAG_NEAR )
 369                   ? &quot; near &quot;
 370                   : ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
 371                     ? &quot; weak &quot;
 372                     : &quot;strong&quot;,
 373 
 374                 point-&gt;fx,
 375                 point-&gt;fy,
 376                 point-&gt;ox / 64.0,
 377                 point-&gt;oy / 64.0,
 378                 point-&gt;x / 64.0,
<a name="9" id="anc9"></a><span class="line-modified"> 379                 point-&gt;y / 64.0,</span>
<span class="line-added"> 380 </span>
<span class="line-added"> 381                 af_print_idx( buf5, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 382                                                               point-&gt;before,</span>
<span class="line-added"> 383                                                               1 ) ),</span>
<span class="line-added"> 384                 af_print_idx( buf6, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 385                                                               point-&gt;after,</span>
<span class="line-added"> 386                                                               1 ) ),</span>
<span class="line-added"> 387                 af_print_idx( buf7, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 388                                                               point-&gt;before,</span>
<span class="line-added"> 389                                                               0 ) ),</span>
<span class="line-added"> 390                 af_print_idx( buf8, af_get_strong_edge_index( hints,</span>
<span class="line-added"> 391                                                               point-&gt;after,</span>
<span class="line-added"> 392                                                               0 ) ) ));</span>
 393     }
 394     AF_DUMP(( &quot;\n&quot; ));
 395   }
 396 #ifdef __cplusplus
 397   }
 398 #endif
 399 
 400 
 401   static const char*
 402   af_edge_flags_to_string( FT_UInt  flags )
 403   {
 404     static char  temp[32];
 405     int          pos = 0;
 406 
 407 
 408     if ( flags &amp; AF_EDGE_ROUND )
 409     {
 410       ft_memcpy( temp + pos, &quot;round&quot;, 5 );
 411       pos += 5;
 412     }
 413     if ( flags &amp; AF_EDGE_SERIF )
 414     {
 415       if ( pos &gt; 0 )
 416         temp[pos++] = &#39; &#39;;
 417       ft_memcpy( temp + pos, &quot;serif&quot;, 5 );
 418       pos += 5;
 419     }
 420     if ( pos == 0 )
 421       return &quot;normal&quot;;
 422 
 423     temp[pos] = &#39;\0&#39;;
 424 
 425     return temp;
 426   }
 427 
 428 
 429   /* Dump the array of linked segments. */
 430 
 431 #ifdef __cplusplus
 432   extern &quot;C&quot; {
 433 #endif
 434   void
 435   af_glyph_hints_dump_segments( AF_GlyphHints  hints,
 436                                 FT_Bool        to_stdout )
 437   {
 438     FT_Int  dimension;
 439 
 440 
 441     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 442     {
 443       AF_AxisHints  axis     = &amp;hints-&gt;axis[dimension];
 444       AF_Point      points   = hints-&gt;points;
 445       AF_Edge       edges    = axis-&gt;edges;
 446       AF_Segment    segments = axis-&gt;segments;
 447       AF_Segment    limit    = segments + axis-&gt;num_segments;
 448       AF_Segment    seg;
 449 
 450       char  buf1[16], buf2[16], buf3[16];
 451 
 452 
 453       AF_DUMP(( &quot;Table of %s segments:\n&quot;,
 454                 dimension == AF_DIMENSION_HORZ ? &quot;vertical&quot;
 455                                                : &quot;horizontal&quot; ));
 456       if ( axis-&gt;num_segments )
 457       {
 458         AF_DUMP(( &quot;  index   pos   delta   dir   from   to &quot;
 459                /* &quot;  XXXXX  XXXXX  XXXXX  XXXXX  XXXX  XXXX&quot; */
 460                   &quot;  link  serif  edge&quot;
 461                /* &quot;  XXXX  XXXXX  XXXX&quot; */
 462                   &quot;  height  extra     flags\n&quot; ));
 463                /* &quot;  XXXXXX  XXXXX  XXXXXXXXXXX&quot; */
 464       }
 465       else
 466         AF_DUMP(( &quot;  (none)\n&quot; ));
 467 
 468       for ( seg = segments; seg &lt; limit; seg++ )
 469         AF_DUMP(( &quot;  %5d  %5d  %5d  %5s  %4d  %4d&quot;
 470                   &quot;  %4s  %5s  %4s&quot;
 471                   &quot;  %6d  %5d  %11s\n&quot;,
 472                   AF_INDEX_NUM( seg, segments ),
 473                   seg-&gt;pos,
 474                   seg-&gt;delta,
 475                   af_dir_str( (AF_Direction)seg-&gt;dir ),
 476                   AF_INDEX_NUM( seg-&gt;first, points ),
 477                   AF_INDEX_NUM( seg-&gt;last, points ),
 478 
 479                   af_print_idx( buf1, AF_INDEX_NUM( seg-&gt;link, segments ) ),
 480                   af_print_idx( buf2, AF_INDEX_NUM( seg-&gt;serif, segments ) ),
 481                   af_print_idx( buf3, AF_INDEX_NUM( seg-&gt;edge, edges ) ),
 482 
 483                   seg-&gt;height,
 484                   seg-&gt;height - ( seg-&gt;max_coord - seg-&gt;min_coord ),
 485                   af_edge_flags_to_string( seg-&gt;flags ) ));
 486       AF_DUMP(( &quot;\n&quot; ));
 487     }
 488   }
 489 #ifdef __cplusplus
 490   }
 491 #endif
 492 
 493 
 494   /* Fetch number of segments. */
 495 
 496 #ifdef __cplusplus
 497   extern &quot;C&quot; {
 498 #endif
 499   FT_Error
 500   af_glyph_hints_get_num_segments( AF_GlyphHints  hints,
 501                                    FT_Int         dimension,
 502                                    FT_Int*        num_segments )
 503   {
 504     AF_Dimension  dim;
 505     AF_AxisHints  axis;
 506 
 507 
 508     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 509 
 510     axis          = &amp;hints-&gt;axis[dim];
 511     *num_segments = axis-&gt;num_segments;
 512 
 513     return FT_Err_Ok;
 514   }
 515 #ifdef __cplusplus
 516   }
 517 #endif
 518 
 519 
 520   /* Fetch offset of segments into user supplied offset array. */
 521 
 522 #ifdef __cplusplus
 523   extern &quot;C&quot; {
 524 #endif
 525   FT_Error
 526   af_glyph_hints_get_segment_offset( AF_GlyphHints  hints,
 527                                      FT_Int         dimension,
 528                                      FT_Int         idx,
 529                                      FT_Pos        *offset,
 530                                      FT_Bool       *is_blue,
 531                                      FT_Pos        *blue_offset )
 532   {
 533     AF_Dimension  dim;
 534     AF_AxisHints  axis;
 535     AF_Segment    seg;
 536 
 537 
 538     if ( !offset )
 539       return FT_THROW( Invalid_Argument );
 540 
 541     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 542 
 543     axis = &amp;hints-&gt;axis[dim];
 544 
 545     if ( idx &lt; 0 || idx &gt;= axis-&gt;num_segments )
 546       return FT_THROW( Invalid_Argument );
 547 
 548     seg      = &amp;axis-&gt;segments[idx];
 549     *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
 550                                             : seg-&gt;first-&gt;fy;
 551     if ( seg-&gt;edge )
<a name="10" id="anc10"></a><span class="line-modified"> 552       *is_blue = FT_BOOL( seg-&gt;edge-&gt;blue_edge );</span>
 553     else
 554       *is_blue = FALSE;
 555 
 556     if ( *is_blue )
 557       *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
 558     else
 559       *blue_offset = 0;
 560 
 561     return FT_Err_Ok;
 562   }
 563 #ifdef __cplusplus
 564   }
 565 #endif
 566 
 567 
 568   /* Dump the array of linked edges. */
 569 
 570 #ifdef __cplusplus
 571   extern &quot;C&quot; {
 572 #endif
 573   void
 574   af_glyph_hints_dump_edges( AF_GlyphHints  hints,
 575                              FT_Bool        to_stdout )
 576   {
 577     FT_Int  dimension;
 578 
 579 
 580     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 581     {
 582       AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];
 583       AF_Edge       edges = axis-&gt;edges;
 584       AF_Edge       limit = edges + axis-&gt;num_edges;
 585       AF_Edge       edge;
 586 
 587       char  buf1[16], buf2[16];
 588 
 589 
 590       /*
<a name="11" id="anc11"></a><span class="line-modified"> 591        * note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified"> 592        *       since they have a constant X coordinate.</span>
 593        */
 594       if ( dimension == AF_DIMENSION_HORZ )
 595         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 596                   &quot;vertical&quot;,
 597                   65536.0 * 64.0 / hints-&gt;x_scale,
 598                   10.0 * hints-&gt;x_scale / 65536.0 / 64.0 ));
 599       else
 600         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 601                   &quot;horizontal&quot;,
 602                   65536.0 * 64.0 / hints-&gt;y_scale,
 603                   10.0 * hints-&gt;y_scale / 65536.0 / 64.0 ));
 604 
 605       if ( axis-&gt;num_edges )
 606       {
 607         AF_DUMP(( &quot;  index    pos     dir   link  serif&quot;
 608                /* &quot;  XXXXX  XXXX.XX  XXXXX  XXXX  XXXXX&quot; */
 609                   &quot;  blue    opos     pos       flags\n&quot; ));
 610                /* &quot;    X   XXXX.XX  XXXX.XX  XXXXXXXXXXX&quot; */
 611       }
 612       else
 613         AF_DUMP(( &quot;  (none)\n&quot; ));
 614 
 615       for ( edge = edges; edge &lt; limit; edge++ )
 616         AF_DUMP(( &quot;  %5d  %7.2f  %5s  %4s  %5s&quot;
 617                   &quot;    %c   %7.2f  %7.2f  %11s\n&quot;,
 618                   AF_INDEX_NUM( edge, edges ),
 619                   (int)edge-&gt;opos / 64.0,
 620                   af_dir_str( (AF_Direction)edge-&gt;dir ),
 621                   af_print_idx( buf1, AF_INDEX_NUM( edge-&gt;link, edges ) ),
 622                   af_print_idx( buf2, AF_INDEX_NUM( edge-&gt;serif, edges ) ),
 623 
 624                   edge-&gt;blue_edge ? &#39;y&#39; : &#39;n&#39;,
 625                   edge-&gt;opos / 64.0,
 626                   edge-&gt;pos / 64.0,
 627                   af_edge_flags_to_string( edge-&gt;flags ) ));
 628       AF_DUMP(( &quot;\n&quot; ));
 629     }
 630   }
 631 #ifdef __cplusplus
 632   }
 633 #endif
 634 
 635 #undef AF_DUMP
 636 
 637 #endif /* !FT_DEBUG_AUTOFIT */
 638 
 639 
 640   /* Compute the direction value of a given vector. */
 641 
 642   FT_LOCAL_DEF( AF_Direction )
 643   af_direction_compute( FT_Pos  dx,
 644                         FT_Pos  dy )
 645   {
 646     FT_Pos        ll, ss;  /* long and short arm lengths */
 647     AF_Direction  dir;     /* candidate direction        */
 648 
 649 
 650     if ( dy &gt;= dx )
 651     {
 652       if ( dy &gt;= -dx )
 653       {
 654         dir = AF_DIR_UP;
 655         ll  = dy;
 656         ss  = dx;
 657       }
 658       else
 659       {
 660         dir = AF_DIR_LEFT;
 661         ll  = -dx;
 662         ss  = dy;
 663       }
 664     }
 665     else /* dy &lt; dx */
 666     {
 667       if ( dy &gt;= -dx )
 668       {
 669         dir = AF_DIR_RIGHT;
 670         ll  = dx;
 671         ss  = dy;
 672       }
 673       else
 674       {
 675         dir = AF_DIR_DOWN;
 676         ll  = -dy;
 677         ss  = dx;
 678       }
 679     }
 680 
 681     /* return no direction if arm lengths do not differ enough       */
 682     /* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
 683     /* the long arm is never negative                                */
 684     if ( ll &lt;= 14 * FT_ABS( ss ) )
 685       dir = AF_DIR_NONE;
 686 
 687     return dir;
 688   }
 689 
 690 
 691   FT_LOCAL_DEF( void )
 692   af_glyph_hints_init( AF_GlyphHints  hints,
 693                        FT_Memory      memory )
 694   {
 695     /* no need to initialize the embedded items */
 696     FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints-&gt;embedded ) );
 697     hints-&gt;memory = memory;
 698   }
 699 
 700 
 701   FT_LOCAL_DEF( void )
 702   af_glyph_hints_done( AF_GlyphHints  hints )
 703   {
 704     FT_Memory  memory;
 705     int        dim;
 706 
 707 
 708     if ( !( hints &amp;&amp; hints-&gt;memory ) )
 709       return;
 710 
 711     memory = hints-&gt;memory;
 712 
 713     /*
<a name="12" id="anc12"></a><span class="line-modified"> 714      * note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified"> 715      * buffers since they are really within the hints-&gt;points array</span>
 716      */
 717     for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 718     {
 719       AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
 720 
 721 
 722       axis-&gt;num_segments = 0;
 723       axis-&gt;max_segments = 0;
 724       if ( axis-&gt;segments != axis-&gt;embedded.segments )
 725         FT_FREE( axis-&gt;segments );
 726 
 727       axis-&gt;num_edges = 0;
 728       axis-&gt;max_edges = 0;
 729       if ( axis-&gt;edges != axis-&gt;embedded.edges )
 730         FT_FREE( axis-&gt;edges );
 731     }
 732 
 733     if ( hints-&gt;contours != hints-&gt;embedded.contours )
 734       FT_FREE( hints-&gt;contours );
 735     hints-&gt;max_contours = 0;
 736     hints-&gt;num_contours = 0;
 737 
 738     if ( hints-&gt;points != hints-&gt;embedded.points )
 739       FT_FREE( hints-&gt;points );
 740     hints-&gt;max_points = 0;
 741     hints-&gt;num_points = 0;
 742 
 743     hints-&gt;memory = NULL;
 744   }
 745 
 746 
 747   /* Reset metrics. */
 748 
 749   FT_LOCAL_DEF( void )
 750   af_glyph_hints_rescale( AF_GlyphHints    hints,
 751                           AF_StyleMetrics  metrics )
 752   {
 753     hints-&gt;metrics      = metrics;
 754     hints-&gt;scaler_flags = metrics-&gt;scaler.flags;
 755   }
 756 
 757 
 758   /* Recompute all AF_Point in AF_GlyphHints from the definitions */
 759   /* in a source outline.                                         */
 760 
 761   FT_LOCAL_DEF( FT_Error )
 762   af_glyph_hints_reload( AF_GlyphHints  hints,
 763                          FT_Outline*    outline )
 764   {
 765     FT_Error   error   = FT_Err_Ok;
 766     AF_Point   points;
 767     FT_UInt    old_max, new_max;
 768     FT_Fixed   x_scale = hints-&gt;x_scale;
 769     FT_Fixed   y_scale = hints-&gt;y_scale;
 770     FT_Pos     x_delta = hints-&gt;x_delta;
 771     FT_Pos     y_delta = hints-&gt;y_delta;
 772     FT_Memory  memory  = hints-&gt;memory;
 773 
 774 
 775     hints-&gt;num_points   = 0;
 776     hints-&gt;num_contours = 0;
 777 
 778     hints-&gt;axis[0].num_segments = 0;
 779     hints-&gt;axis[0].num_edges    = 0;
 780     hints-&gt;axis[1].num_segments = 0;
 781     hints-&gt;axis[1].num_edges    = 0;
 782 
 783     /* first of all, reallocate the contours array if necessary */
 784     new_max = (FT_UInt)outline-&gt;n_contours;
 785     old_max = (FT_UInt)hints-&gt;max_contours;
 786 
 787     if ( new_max &lt;= AF_CONTOURS_EMBEDDED )
 788     {
 789       if ( !hints-&gt;contours )
 790       {
 791         hints-&gt;contours     = hints-&gt;embedded.contours;
 792         hints-&gt;max_contours = AF_CONTOURS_EMBEDDED;
 793       }
 794     }
 795     else if ( new_max &gt; old_max )
 796     {
 797       if ( hints-&gt;contours == hints-&gt;embedded.contours )
 798         hints-&gt;contours = NULL;
 799 
 800       new_max = ( new_max + 3 ) &amp; ~3U; /* round up to a multiple of 4 */
 801 
 802       if ( FT_RENEW_ARRAY( hints-&gt;contours, old_max, new_max ) )
 803         goto Exit;
 804 
 805       hints-&gt;max_contours = (FT_Int)new_max;
 806     }
 807 
 808     /*
<a name="13" id="anc13"></a><span class="line-modified"> 809      * then reallocate the points arrays if necessary --</span>
<span class="line-modified"> 810      * note that we reserve two additional point positions, used to</span>
<span class="line-modified"> 811      * hint metrics appropriately</span>
 812      */
 813     new_max = (FT_UInt)( outline-&gt;n_points + 2 );
 814     old_max = (FT_UInt)hints-&gt;max_points;
 815 
 816     if ( new_max &lt;= AF_POINTS_EMBEDDED )
 817     {
 818       if ( !hints-&gt;points )
 819       {
 820         hints-&gt;points     = hints-&gt;embedded.points;
 821         hints-&gt;max_points = AF_POINTS_EMBEDDED;
 822       }
 823     }
 824     else if ( new_max &gt; old_max )
 825     {
 826       if ( hints-&gt;points == hints-&gt;embedded.points )
 827         hints-&gt;points = NULL;
 828 
 829       new_max = ( new_max + 2 + 7 ) &amp; ~7U; /* round up to a multiple of 8 */
 830 
 831       if ( FT_RENEW_ARRAY( hints-&gt;points, old_max, new_max ) )
 832         goto Exit;
 833 
 834       hints-&gt;max_points = (FT_Int)new_max;
 835     }
 836 
 837     hints-&gt;num_points   = outline-&gt;n_points;
 838     hints-&gt;num_contours = outline-&gt;n_contours;
 839 
 840     /* We can&#39;t rely on the value of `FT_Outline.flags&#39; to know the fill   */
 841     /* direction used for a glyph, given that some fonts are broken (e.g., */
 842     /* the Arphic ones).  We thus recompute it each time we need to.       */
 843     /*                                                                     */
 844     hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
 845     hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;
 846 
 847     if ( FT_Outline_Get_Orientation( outline ) == FT_ORIENTATION_POSTSCRIPT )
 848     {
 849       hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
 850       hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
 851     }
 852 
 853     hints-&gt;x_scale = x_scale;
 854     hints-&gt;y_scale = y_scale;
 855     hints-&gt;x_delta = x_delta;
 856     hints-&gt;y_delta = y_delta;
 857 
 858     hints-&gt;xmin_delta = 0;
 859     hints-&gt;xmax_delta = 0;
 860 
 861     points = hints-&gt;points;
 862     if ( hints-&gt;num_points == 0 )
 863       goto Exit;
 864 
 865     {
 866       AF_Point  point;
 867       AF_Point  point_limit = points + hints-&gt;num_points;
 868 
 869       /* value 20 in `near_limit&#39; is heuristic */
 870       FT_UInt  units_per_em = hints-&gt;metrics-&gt;scaler.face-&gt;units_per_EM;
 871       FT_Int   near_limit   = 20 * units_per_em / 2048;
 872 
 873 
 874       /* compute coordinates &amp; Bezier flags, next and prev */
 875       {
 876         FT_Vector*  vec           = outline-&gt;points;
 877         char*       tag           = outline-&gt;tags;
 878         FT_Short    endpoint      = outline-&gt;contours[0];
 879         AF_Point    end           = points + endpoint;
 880         AF_Point    prev          = end;
 881         FT_Int      contour_index = 0;
 882 
 883 
 884         for ( point = points; point &lt; point_limit; point++, vec++, tag++ )
 885         {
 886           FT_Pos  out_x, out_y;
 887 
 888 
 889           point-&gt;in_dir  = (FT_Char)AF_DIR_NONE;
 890           point-&gt;out_dir = (FT_Char)AF_DIR_NONE;
 891 
 892           point-&gt;fx = (FT_Short)vec-&gt;x;
 893           point-&gt;fy = (FT_Short)vec-&gt;y;
 894           point-&gt;ox = point-&gt;x = FT_MulFix( vec-&gt;x, x_scale ) + x_delta;
 895           point-&gt;oy = point-&gt;y = FT_MulFix( vec-&gt;y, y_scale ) + y_delta;
 896 
 897           end-&gt;fx = (FT_Short)outline-&gt;points[endpoint].x;
 898           end-&gt;fy = (FT_Short)outline-&gt;points[endpoint].y;
 899 
 900           switch ( FT_CURVE_TAG( *tag ) )
 901           {
 902           case FT_CURVE_TAG_CONIC:
 903             point-&gt;flags = AF_FLAG_CONIC;
 904             break;
 905           case FT_CURVE_TAG_CUBIC:
 906             point-&gt;flags = AF_FLAG_CUBIC;
 907             break;
 908           default:
 909             point-&gt;flags = AF_FLAG_NONE;
 910           }
 911 
 912           out_x = point-&gt;fx - prev-&gt;fx;
 913           out_y = point-&gt;fy - prev-&gt;fy;
 914 
 915           if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
 916             prev-&gt;flags |= AF_FLAG_NEAR;
 917 
 918           point-&gt;prev = prev;
 919           prev-&gt;next  = point;
 920           prev        = point;
 921 
 922           if ( point == end )
 923           {
 924             if ( ++contour_index &lt; outline-&gt;n_contours )
 925             {
 926               endpoint = outline-&gt;contours[contour_index];
 927               end      = points + endpoint;
 928               prev     = end;
 929             }
 930           }
<a name="14" id="anc14"></a><span class="line-added"> 931 </span>
<span class="line-added"> 932 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added"> 933           point-&gt;before[0] = NULL;</span>
<span class="line-added"> 934           point-&gt;before[1] = NULL;</span>
<span class="line-added"> 935           point-&gt;after[0]  = NULL;</span>
<span class="line-added"> 936           point-&gt;after[1]  = NULL;</span>
<span class="line-added"> 937 #endif</span>
<span class="line-added"> 938 </span>
 939         }
 940       }
 941 
 942       /* set up the contours array */
 943       {
 944         AF_Point*  contour       = hints-&gt;contours;
 945         AF_Point*  contour_limit = contour + hints-&gt;num_contours;
 946         short*     end           = outline-&gt;contours;
 947         short      idx           = 0;
 948 
 949 
 950         for ( ; contour &lt; contour_limit; contour++, end++ )
 951         {
 952           contour[0] = points + idx;
 953           idx        = (short)( end[0] + 1 );
 954         }
 955       }
 956 
 957       {
 958         /*
<a name="15" id="anc15"></a><span class="line-modified"> 959          * Compute directions of `in&#39; and `out&#39; vectors.</span>
 960          *
<a name="16" id="anc16"></a><span class="line-modified"> 961          * Note that distances between points that are very near to each</span>
<span class="line-modified"> 962          * other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified"> 963          * prepends the small vectors between near points to the first</span>
<span class="line-modified"> 964          * non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified"> 965          * threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified"> 966          * points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified"> 967          * be equal to the accumulated one.</span>
 968          */
 969 
 970         FT_Int  near_limit2 = 2 * near_limit - 1;
 971 
 972         AF_Point*  contour;
 973         AF_Point*  contour_limit = hints-&gt;contours + hints-&gt;num_contours;
 974 
 975 
 976         for ( contour = hints-&gt;contours; contour &lt; contour_limit; contour++ )
 977         {
 978           AF_Point  first = *contour;
 979           AF_Point  next, prev, curr;
 980 
 981           FT_Pos  out_x, out_y;
 982 
 983 
 984           /* since the first point of a contour could be part of a */
 985           /* series of near points, go backwards to find the first */
 986           /* non-near point and adjust `first&#39;                     */
 987 
 988           point = first;
 989           prev  = first-&gt;prev;
 990 
 991           while ( prev != first )
 992           {
 993             out_x = point-&gt;fx - prev-&gt;fx;
 994             out_y = point-&gt;fy - prev-&gt;fy;
 995 
 996             /*
<a name="17" id="anc17"></a><span class="line-modified"> 997              * We use Taxicab metrics to measure the vector length.</span>
 998              *
<a name="18" id="anc18"></a><span class="line-modified"> 999              * Note that the accumulated distances so far could have the</span>
<span class="line-modified">1000              * opposite direction of the distance measured here.  For this</span>
<span class="line-modified">1001              * reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified">1002              * non-near point even in the worst case.</span>
1003              */
1004             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
1005               break;
1006 
1007             point = prev;
1008             prev  = prev-&gt;prev;
1009           }
1010 
1011           /* adjust first point */
1012           first = point;
1013 
1014           /* now loop over all points of the contour to get */
1015           /* `in&#39; and `out&#39; vector directions               */
1016 
1017           curr = first;
1018 
1019           /*
<a name="19" id="anc19"></a><span class="line-modified">1020            * We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified">1021            * next and previous non-near point, respectively.</span>
1022            *
<a name="20" id="anc20"></a><span class="line-modified">1023            * To avoid problems with not having non-near points, we point to</span>
<span class="line-modified">1024            * `first&#39; by default as the next non-near point.</span>
1025            *
1026            */
1027           curr-&gt;u  = (FT_Pos)( first - curr );
1028           first-&gt;v = -curr-&gt;u;
1029 
1030           out_x = 0;
1031           out_y = 0;
1032 
1033           next = first;
1034           do
1035           {
1036             AF_Direction  out_dir;
1037 
1038 
1039             point = next;
1040             next  = point-&gt;next;
1041 
1042             out_x += next-&gt;fx - point-&gt;fx;
1043             out_y += next-&gt;fy - point-&gt;fy;
1044 
1045             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
1046             {
1047               next-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1048               continue;
1049             }
1050 
1051             curr-&gt;u = (FT_Pos)( next - curr );
1052             next-&gt;v = -curr-&gt;u;
1053 
1054             out_dir = af_direction_compute( out_x, out_y );
1055 
1056             /* adjust directions for all points inbetween; */
1057             /* the loop also updates position of `curr&#39;    */
1058             curr-&gt;out_dir = (FT_Char)out_dir;
1059             for ( curr = curr-&gt;next; curr != next; curr = curr-&gt;next )
1060             {
1061               curr-&gt;in_dir  = (FT_Char)out_dir;
1062               curr-&gt;out_dir = (FT_Char)out_dir;
1063             }
1064             next-&gt;in_dir = (FT_Char)out_dir;
1065 
1066             curr-&gt;u  = (FT_Pos)( first - curr );
1067             first-&gt;v = -curr-&gt;u;
1068 
1069             out_x = 0;
1070             out_y = 0;
1071 
1072           } while ( next != first );
1073         }
1074 
1075         /*
<a name="21" id="anc21"></a><span class="line-modified">1076          * The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">1077          * can identify local extrema more reliably: A series of</span>
<span class="line-modified">1078          * non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">1079          * quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">1080          * topological point of the view, the intermediate points are of no</span>
<span class="line-modified">1081          * interest and thus tagged as weak.</span>
1082          */
1083 
1084         for ( point = points; point &lt; point_limit; point++ )
1085         {
1086           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1087             continue;
1088 
1089           if ( point-&gt;in_dir  == AF_DIR_NONE &amp;&amp;
1090                point-&gt;out_dir == AF_DIR_NONE )
1091           {
1092             /* check whether both vectors point into the same quadrant */
1093 
1094             FT_Pos  in_x, in_y;
1095             FT_Pos  out_x, out_y;
1096 
1097             AF_Point  next_u = point + point-&gt;u;
1098             AF_Point  prev_v = point + point-&gt;v;
1099 
1100 
1101             in_x = point-&gt;fx - prev_v-&gt;fx;
1102             in_y = point-&gt;fy - prev_v-&gt;fy;
1103 
1104             out_x = next_u-&gt;fx - point-&gt;fx;
1105             out_y = next_u-&gt;fy - point-&gt;fy;
1106 
1107             if ( ( in_x ^ out_x ) &gt;= 0 &amp;&amp; ( in_y ^ out_y ) &gt;= 0 )
1108             {
1109               /* yes, so tag current point as weak */
1110               /* and update index deltas           */
1111 
1112               point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1113 
1114               prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1115               next_u-&gt;v = -prev_v-&gt;u;
1116             }
1117           }
1118         }
1119 
1120         /*
<a name="22" id="anc22"></a><span class="line-modified">1121          * Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">1122          * collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">1123          * points.</span>
1124          */
1125 
1126         for ( point = points; point &lt; point_limit; point++ )
1127         {
1128           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1129             continue;
1130 
1131           if ( point-&gt;flags &amp; AF_FLAG_CONTROL )
1132           {
1133             /* control points are always weak */
1134           Is_Weak_Point:
1135             point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1136           }
1137           else if ( point-&gt;out_dir == point-&gt;in_dir )
1138           {
1139             if ( point-&gt;out_dir != AF_DIR_NONE )
1140             {
1141               /* current point lies on a horizontal or          */
1142               /* vertical segment (but doesn&#39;t start or end it) */
1143               goto Is_Weak_Point;
1144             }
1145 
1146             {
1147               AF_Point  next_u = point + point-&gt;u;
1148               AF_Point  prev_v = point + point-&gt;v;
1149 
1150 
1151               if ( ft_corner_is_flat( point-&gt;fx  - prev_v-&gt;fx,
1152                                       point-&gt;fy  - prev_v-&gt;fy,
1153                                       next_u-&gt;fx - point-&gt;fx,
1154                                       next_u-&gt;fy - point-&gt;fy ) )
1155               {
1156                 /* either the `in&#39; or the `out&#39; vector is much more  */
1157                 /* dominant than the other one, so tag current point */
1158                 /* as weak and update index deltas                   */
1159 
1160                 prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1161                 next_u-&gt;v = -prev_v-&gt;u;
1162 
1163                 goto Is_Weak_Point;
1164               }
1165             }
1166           }
1167           else if ( point-&gt;in_dir == -point-&gt;out_dir )
1168           {
1169             /* current point forms a spike */
1170             goto Is_Weak_Point;
1171           }
1172         }
1173       }
1174     }
1175 
1176   Exit:
1177     return error;
1178   }
1179 
1180 
1181   /* Store the hinted outline in an FT_Outline structure. */
1182 
1183   FT_LOCAL_DEF( void )
1184   af_glyph_hints_save( AF_GlyphHints  hints,
1185                        FT_Outline*    outline )
1186   {
1187     AF_Point    point = hints-&gt;points;
1188     AF_Point    limit = point + hints-&gt;num_points;
1189     FT_Vector*  vec   = outline-&gt;points;
1190     char*       tag   = outline-&gt;tags;
1191 
1192 
1193     for ( ; point &lt; limit; point++, vec++, tag++ )
1194     {
1195       vec-&gt;x = point-&gt;x;
1196       vec-&gt;y = point-&gt;y;
1197 
1198       if ( point-&gt;flags &amp; AF_FLAG_CONIC )
1199         tag[0] = FT_CURVE_TAG_CONIC;
1200       else if ( point-&gt;flags &amp; AF_FLAG_CUBIC )
1201         tag[0] = FT_CURVE_TAG_CUBIC;
1202       else
1203         tag[0] = FT_CURVE_TAG_ON;
1204     }
1205   }
1206 
1207 
1208   /****************************************************************
1209    *
1210    *                     EDGE POINT GRID-FITTING
1211    *
1212    ****************************************************************/
1213 
1214 
1215   /* Align all points of an edge to the same coordinate value, */
1216   /* either horizontally or vertically.                        */
1217 
1218   FT_LOCAL_DEF( void )
1219   af_glyph_hints_align_edge_points( AF_GlyphHints  hints,
1220                                     AF_Dimension   dim )
1221   {
1222     AF_AxisHints  axis          = &amp; hints-&gt;axis[dim];
1223     AF_Segment    segments      = axis-&gt;segments;
1224     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
1225     AF_Segment    seg;
1226 
1227 
1228     if ( dim == AF_DIMENSION_HORZ )
1229     {
1230       for ( seg = segments; seg &lt; segment_limit; seg++ )
1231       {
1232         AF_Edge   edge = seg-&gt;edge;
1233         AF_Point  point, first, last;
1234 
1235 
1236         if ( !edge )
1237           continue;
1238 
1239         first = seg-&gt;first;
1240         last  = seg-&gt;last;
1241         point = first;
1242         for (;;)
1243         {
1244           point-&gt;x      = edge-&gt;pos;
1245           point-&gt;flags |= AF_FLAG_TOUCH_X;
1246 
1247           if ( point == last )
1248             break;
1249 
1250           point = point-&gt;next;
1251         }
1252       }
1253     }
1254     else
1255     {
1256       for ( seg = segments; seg &lt; segment_limit; seg++ )
1257       {
1258         AF_Edge   edge = seg-&gt;edge;
1259         AF_Point  point, first, last;
1260 
1261 
1262         if ( !edge )
1263           continue;
1264 
1265         first = seg-&gt;first;
1266         last  = seg-&gt;last;
1267         point = first;
1268         for (;;)
1269         {
1270           point-&gt;y      = edge-&gt;pos;
1271           point-&gt;flags |= AF_FLAG_TOUCH_Y;
1272 
1273           if ( point == last )
1274             break;
1275 
1276           point = point-&gt;next;
1277         }
1278       }
1279     }
1280   }
1281 
1282 
1283   /****************************************************************
1284    *
1285    *                    STRONG POINT INTERPOLATION
1286    *
1287    ****************************************************************/
1288 
1289 
1290   /* Hint the strong points -- this is equivalent to the TrueType `IP&#39; */
1291   /* hinting instruction.                                              */
1292 
1293   FT_LOCAL_DEF( void )
1294   af_glyph_hints_align_strong_points( AF_GlyphHints  hints,
1295                                       AF_Dimension   dim )
1296   {
1297     AF_Point      points      = hints-&gt;points;
1298     AF_Point      point_limit = points + hints-&gt;num_points;
1299     AF_AxisHints  axis        = &amp;hints-&gt;axis[dim];
1300     AF_Edge       edges       = axis-&gt;edges;
1301     AF_Edge       edge_limit  = edges + axis-&gt;num_edges;
1302     FT_UInt       touch_flag;
1303 
1304 
1305     if ( dim == AF_DIMENSION_HORZ )
1306       touch_flag = AF_FLAG_TOUCH_X;
1307     else
1308       touch_flag  = AF_FLAG_TOUCH_Y;
1309 
1310     if ( edges &lt; edge_limit )
1311     {
1312       AF_Point  point;
1313       AF_Edge   edge;
1314 
1315 
1316       for ( point = points; point &lt; point_limit; point++ )
1317       {
1318         FT_Pos  u, ou, fu;  /* point position */
1319         FT_Pos  delta;
1320 
1321 
1322         if ( point-&gt;flags &amp; touch_flag )
1323           continue;
1324 
1325         /* if this point is candidate to weak interpolation, we       */
1326         /* interpolate it after all strong points have been processed */
1327 
1328         if ( ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION ) )
1329           continue;
1330 
1331         if ( dim == AF_DIMENSION_VERT )
1332         {
1333           u  = point-&gt;fy;
1334           ou = point-&gt;oy;
1335         }
1336         else
1337         {
1338           u  = point-&gt;fx;
1339           ou = point-&gt;ox;
1340         }
1341 
1342         fu = u;
1343 
1344         /* is the point before the first edge? */
1345         edge  = edges;
1346         delta = edge-&gt;fpos - u;
1347         if ( delta &gt;= 0 )
1348         {
1349           u = edge-&gt;pos - ( edge-&gt;opos - ou );
<a name="23" id="anc23"></a><span class="line-added">1350 </span>
<span class="line-added">1351 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1352           point-&gt;before[dim] = edge;</span>
<span class="line-added">1353           point-&gt;after[dim]  = NULL;</span>
<span class="line-added">1354 #endif</span>
<span class="line-added">1355 </span>
1356           goto Store_Point;
1357         }
1358 
1359         /* is the point after the last edge? */
1360         edge  = edge_limit - 1;
1361         delta = u - edge-&gt;fpos;
1362         if ( delta &gt;= 0 )
1363         {
1364           u = edge-&gt;pos + ( ou - edge-&gt;opos );
<a name="24" id="anc24"></a><span class="line-added">1365 </span>
<span class="line-added">1366 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1367           point-&gt;before[dim] = NULL;</span>
<span class="line-added">1368           point-&gt;after[dim]  = edge;</span>
<span class="line-added">1369 #endif</span>
<span class="line-added">1370 </span>
1371           goto Store_Point;
1372         }
1373 
1374         {
1375           FT_PtrDist  min, max, mid;
1376           FT_Pos      fpos;
1377 
1378 
1379           /* find enclosing edges */
1380           min = 0;
1381           max = edge_limit - edges;
1382 
1383 #if 1
1384           /* for a small number of edges, a linear search is better */
1385           if ( max &lt;= 8 )
1386           {
1387             FT_PtrDist  nn;
1388 
1389 
1390             for ( nn = 0; nn &lt; max; nn++ )
1391               if ( edges[nn].fpos &gt;= u )
1392                 break;
1393 
1394             if ( edges[nn].fpos == u )
1395             {
1396               u = edges[nn].pos;
1397               goto Store_Point;
1398             }
1399             min = nn;
1400           }
1401           else
1402 #endif
1403           while ( min &lt; max )
1404           {
1405             mid  = ( max + min ) &gt;&gt; 1;
1406             edge = edges + mid;
1407             fpos = edge-&gt;fpos;
1408 
1409             if ( u &lt; fpos )
1410               max = mid;
1411             else if ( u &gt; fpos )
1412               min = mid + 1;
1413             else
1414             {
1415               /* we are on the edge */
1416               u = edge-&gt;pos;
<a name="25" id="anc25"></a><span class="line-added">1417 </span>
<span class="line-added">1418 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1419               point-&gt;before[dim] = NULL;</span>
<span class="line-added">1420               point-&gt;after[dim]  = NULL;</span>
<span class="line-added">1421 #endif</span>
<span class="line-added">1422 </span>
1423               goto Store_Point;
1424             }
1425           }
1426 
1427           /* point is not on an edge */
1428           {
1429             AF_Edge  before = edges + min - 1;
1430             AF_Edge  after  = edges + min + 0;
1431 
1432 
<a name="26" id="anc26"></a><span class="line-added">1433 #ifdef FT_DEBUG_AUTOFIT</span>
<span class="line-added">1434             point-&gt;before[dim] = before;</span>
<span class="line-added">1435             point-&gt;after[dim]  = after;</span>
<span class="line-added">1436 #endif</span>
<span class="line-added">1437 </span>
1438             /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
1439             if ( before-&gt;scale == 0 )
1440               before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
1441                                          after-&gt;fpos - before-&gt;fpos );
1442 
1443             u = before-&gt;pos + FT_MulFix( fu - before-&gt;fpos,
1444                                          before-&gt;scale );
1445           }
1446         }
1447 
1448       Store_Point:
1449         /* save the point position */
1450         if ( dim == AF_DIMENSION_HORZ )
1451           point-&gt;x = u;
1452         else
1453           point-&gt;y = u;
1454 
1455         point-&gt;flags |= touch_flag;
1456       }
1457     }
1458   }
1459 
1460 
1461   /****************************************************************
1462    *
1463    *                    WEAK POINT INTERPOLATION
1464    *
1465    ****************************************************************/
1466 
1467 
1468   /* Shift the original coordinates of all points between `p1&#39; and */
1469   /* `p2&#39; to get hinted coordinates, using the same difference as  */
1470   /* given by `ref&#39;.                                               */
1471 
1472   static void
1473   af_iup_shift( AF_Point  p1,
1474                 AF_Point  p2,
1475                 AF_Point  ref )
1476   {
1477     AF_Point  p;
1478     FT_Pos    delta = ref-&gt;u - ref-&gt;v;
1479 
1480 
1481     if ( delta == 0 )
1482       return;
1483 
1484     for ( p = p1; p &lt; ref; p++ )
1485       p-&gt;u = p-&gt;v + delta;
1486 
1487     for ( p = ref + 1; p &lt;= p2; p++ )
1488       p-&gt;u = p-&gt;v + delta;
1489   }
1490 
1491 
1492   /* Interpolate the original coordinates of all points between `p1&#39; and  */
1493   /* `p2&#39; to get hinted coordinates, using `ref1&#39; and `ref2&#39; as the       */
1494   /* reference points.  The `u&#39; and `v&#39; members are the current and       */
1495   /* original coordinate values, respectively.                            */
1496   /*                                                                      */
1497   /* Details can be found in the TrueType bytecode specification.         */
1498 
1499   static void
1500   af_iup_interp( AF_Point  p1,
1501                  AF_Point  p2,
1502                  AF_Point  ref1,
1503                  AF_Point  ref2 )
1504   {
1505     AF_Point  p;
1506     FT_Pos    u, v1, v2, u1, u2, d1, d2;
1507 
1508 
1509     if ( p1 &gt; p2 )
1510       return;
1511 
1512     if ( ref1-&gt;v &gt; ref2-&gt;v )
1513     {
1514       p    = ref1;
1515       ref1 = ref2;
1516       ref2 = p;
1517     }
1518 
1519     v1 = ref1-&gt;v;
1520     v2 = ref2-&gt;v;
1521     u1 = ref1-&gt;u;
1522     u2 = ref2-&gt;u;
1523     d1 = u1 - v1;
1524     d2 = u2 - v2;
1525 
1526     if ( u1 == u2 || v1 == v2 )
1527     {
1528       for ( p = p1; p &lt;= p2; p++ )
1529       {
1530         u = p-&gt;v;
1531 
1532         if ( u &lt;= v1 )
1533           u += d1;
1534         else if ( u &gt;= v2 )
1535           u += d2;
1536         else
1537           u = u1;
1538 
1539         p-&gt;u = u;
1540       }
1541     }
1542     else
1543     {
1544       FT_Fixed  scale = FT_DivFix( u2 - u1, v2 - v1 );
1545 
1546 
1547       for ( p = p1; p &lt;= p2; p++ )
1548       {
1549         u = p-&gt;v;
1550 
1551         if ( u &lt;= v1 )
1552           u += d1;
1553         else if ( u &gt;= v2 )
1554           u += d2;
1555         else
1556           u = u1 + FT_MulFix( u - v1, scale );
1557 
1558         p-&gt;u = u;
1559       }
1560     }
1561   }
1562 
1563 
1564   /* Hint the weak points -- this is equivalent to the TrueType `IUP&#39; */
1565   /* hinting instruction.                                             */
1566 
1567   FT_LOCAL_DEF( void )
1568   af_glyph_hints_align_weak_points( AF_GlyphHints  hints,
1569                                     AF_Dimension   dim )
1570   {
1571     AF_Point   points        = hints-&gt;points;
1572     AF_Point   point_limit   = points + hints-&gt;num_points;
1573     AF_Point*  contour       = hints-&gt;contours;
1574     AF_Point*  contour_limit = contour + hints-&gt;num_contours;
1575     FT_UInt    touch_flag;
1576     AF_Point   point;
1577     AF_Point   end_point;
1578     AF_Point   first_point;
1579 
1580 
1581     /* PASS 1: Move segment points to edge positions */
1582 
1583     if ( dim == AF_DIMENSION_HORZ )
1584     {
1585       touch_flag = AF_FLAG_TOUCH_X;
1586 
1587       for ( point = points; point &lt; point_limit; point++ )
1588       {
1589         point-&gt;u = point-&gt;x;
1590         point-&gt;v = point-&gt;ox;
1591       }
1592     }
1593     else
1594     {
1595       touch_flag = AF_FLAG_TOUCH_Y;
1596 
1597       for ( point = points; point &lt; point_limit; point++ )
1598       {
1599         point-&gt;u = point-&gt;y;
1600         point-&gt;v = point-&gt;oy;
1601       }
1602     }
1603 
1604     for ( ; contour &lt; contour_limit; contour++ )
1605     {
1606       AF_Point  first_touched, last_touched;
1607 
1608 
1609       point       = *contour;
1610       end_point   = point-&gt;prev;
1611       first_point = point;
1612 
1613       /* find first touched point */
1614       for (;;)
1615       {
1616         if ( point &gt; end_point )  /* no touched point in contour */
1617           goto NextContour;
1618 
1619         if ( point-&gt;flags &amp; touch_flag )
1620           break;
1621 
1622         point++;
1623       }
1624 
1625       first_touched = point;
1626 
1627       for (;;)
1628       {
1629         FT_ASSERT( point &lt;= end_point                 &amp;&amp;
1630                    ( point-&gt;flags &amp; touch_flag ) != 0 );
1631 
1632         /* skip any touched neighbours */
1633         while ( point &lt; end_point                    &amp;&amp;
1634                 ( point[1].flags &amp; touch_flag ) != 0 )
1635           point++;
1636 
1637         last_touched = point;
1638 
1639         /* find the next touched point, if any */
1640         point++;
1641         for (;;)
1642         {
1643           if ( point &gt; end_point )
1644             goto EndContour;
1645 
1646           if ( ( point-&gt;flags &amp; touch_flag ) != 0 )
1647             break;
1648 
1649           point++;
1650         }
1651 
1652         /* interpolate between last_touched and point */
1653         af_iup_interp( last_touched + 1, point - 1,
1654                        last_touched, point );
1655       }
1656 
1657     EndContour:
1658       /* special case: only one point was touched */
1659       if ( last_touched == first_touched )
1660         af_iup_shift( first_point, end_point, first_touched );
1661 
1662       else /* interpolate the last part */
1663       {
1664         if ( last_touched &lt; end_point )
1665           af_iup_interp( last_touched + 1, end_point,
1666                          last_touched, first_touched );
1667 
1668         if ( first_touched &gt; points )
1669           af_iup_interp( first_point, first_touched - 1,
1670                          last_touched, first_touched );
1671       }
1672 
1673     NextContour:
1674       ;
1675     }
1676 
1677     /* now save the interpolated values back to x/y */
1678     if ( dim == AF_DIMENSION_HORZ )
1679     {
1680       for ( point = points; point &lt; point_limit; point++ )
1681         point-&gt;x = point-&gt;u;
1682     }
1683     else
1684     {
1685       for ( point = points; point &lt; point_limit; point++ )
1686         point-&gt;y = point-&gt;u;
1687     }
1688   }
1689 
1690 
1691 #ifdef AF_CONFIG_OPTION_USE_WARPER
1692 
1693   /* Apply (small) warp scale and warp delta for given dimension. */
1694 
1695   FT_LOCAL_DEF( void )
1696   af_glyph_hints_scale_dim( AF_GlyphHints  hints,
1697                             AF_Dimension   dim,
1698                             FT_Fixed       scale,
1699                             FT_Pos         delta )
1700   {
1701     AF_Point  points       = hints-&gt;points;
1702     AF_Point  points_limit = points + hints-&gt;num_points;
1703     AF_Point  point;
1704 
1705 
1706     if ( dim == AF_DIMENSION_HORZ )
1707     {
1708       for ( point = points; point &lt; points_limit; point++ )
1709         point-&gt;x = FT_MulFix( point-&gt;fx, scale ) + delta;
1710     }
1711     else
1712     {
1713       for ( point = points; point &lt; points_limit; point++ )
1714         point-&gt;y = FT_MulFix( point-&gt;fy, scale ) + delta;
1715     }
1716   }
1717 
1718 #endif /* AF_CONFIG_OPTION_USE_WARPER */
1719 
1720 /* END */
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
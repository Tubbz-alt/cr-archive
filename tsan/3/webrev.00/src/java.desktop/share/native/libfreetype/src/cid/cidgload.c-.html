<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/share/native/libfreetype/src/cid/cidgload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /***************************************************************************/
  2 /*                                                                         */
  3 /*  cidgload.c                                                             */
  4 /*                                                                         */
  5 /*    CID-keyed Type1 Glyph Loader (body).                                 */
  6 /*                                                                         */
  7 /*  Copyright 1996-2018 by                                                 */
  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
  9 /*                                                                         */
 10 /*  This file is part of the FreeType project, and may only be used,       */
 11 /*  modified, and distributed under the terms of the FreeType project      */
 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
 13 /*  this file you indicate that you have read the license and              */
 14 /*  understand and accept it fully.                                        */
 15 /*                                                                         */
 16 /***************************************************************************/
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include &quot;cidload.h&quot;
 21 #include &quot;cidgload.h&quot;
 22 #include FT_INTERNAL_DEBUG_H
 23 #include FT_INTERNAL_STREAM_H
 24 #include FT_OUTLINE_H
 25 #include FT_INTERNAL_CALC_H
 26 
 27 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 28 #include FT_INTERNAL_CFF_TYPES_H
 29 #include FT_DRIVER_H
 30 
 31 #include &quot;ciderrs.h&quot;
 32 
 33 
 34   /*************************************************************************/
 35   /*                                                                       */
 36   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
 37   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
 38   /* messages during execution.                                            */
 39   /*                                                                       */
 40 #undef  FT_COMPONENT
 41 #define FT_COMPONENT  trace_cidgload
 42 
 43 
 44   FT_CALLBACK_DEF( FT_Error )
 45   cid_load_glyph( T1_Decoder  decoder,
 46                   FT_UInt     glyph_index )
 47   {
 48     CID_Face       face = (CID_Face)decoder-&gt;builder.face;
 49     CID_FaceInfo   cid  = &amp;face-&gt;cid;
 50     FT_Byte*       p;
 51     FT_ULong       fd_select;
 52     FT_Stream      stream       = face-&gt;cid_stream;
 53     FT_Error       error        = FT_Err_Ok;
 54     FT_Byte*       charstring   = NULL;
 55     FT_Memory      memory       = face-&gt;root.memory;
 56     FT_ULong       glyph_length = 0;
 57     PSAux_Service  psaux        = (PSAux_Service)face-&gt;psaux;
 58 
 59     FT_Bool  force_scaling = FALSE;
 60 
 61 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 62     FT_Incremental_InterfaceRec  *inc =
 63                                    face-&gt;root.internal-&gt;incremental_interface;
 64 #endif
 65 
 66 
 67     FT_TRACE1(( &quot;cid_load_glyph: glyph index %d\n&quot;, glyph_index ));
 68 
 69 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 70 
 71     /* For incremental fonts get the character data using */
 72     /* the callback function.                             */
 73     if ( inc )
 74     {
 75       FT_Data  glyph_data;
 76 
 77 
 78       error = inc-&gt;funcs-&gt;get_glyph_data( inc-&gt;object,
 79                                           glyph_index, &amp;glyph_data );
 80       if ( error )
 81         goto Exit;
 82 
 83       p         = (FT_Byte*)glyph_data.pointer;
 84       fd_select = cid_get_offset( &amp;p, (FT_Byte)cid-&gt;fd_bytes );
 85 
 86       if ( glyph_data.length != 0 )
 87       {
 88         glyph_length = (FT_ULong)( glyph_data.length - cid-&gt;fd_bytes );
 89         (void)FT_ALLOC( charstring, glyph_length );
 90         if ( !error )
 91           ft_memcpy( charstring, glyph_data.pointer + cid-&gt;fd_bytes,
 92                      glyph_length );
 93       }
 94 
 95       inc-&gt;funcs-&gt;free_glyph_data( inc-&gt;object, &amp;glyph_data );
 96 
 97       if ( error )
 98         goto Exit;
 99     }
100 
101     else
102 
103 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
104 
105     /* For ordinary fonts read the CID font dictionary index */
106     /* and charstring offset from the CIDMap.                */
107     {
108       FT_UInt   entry_len = (FT_UInt)( cid-&gt;fd_bytes + cid-&gt;gd_bytes );
109       FT_ULong  off1, off2;
110 
111 
112       if ( FT_STREAM_SEEK( cid-&gt;data_offset + cid-&gt;cidmap_offset +
113                            glyph_index * entry_len )               ||
114            FT_FRAME_ENTER( 2 * entry_len )                         )
115         goto Exit;
116 
117       p         = (FT_Byte*)stream-&gt;cursor;
118       fd_select = cid_get_offset( &amp;p, (FT_Byte)cid-&gt;fd_bytes );
119       off1      = cid_get_offset( &amp;p, (FT_Byte)cid-&gt;gd_bytes );
120       p        += cid-&gt;fd_bytes;
121       off2      = cid_get_offset( &amp;p, (FT_Byte)cid-&gt;gd_bytes );
122       FT_FRAME_EXIT();
123 
124       if ( fd_select &gt;= (FT_ULong)cid-&gt;num_dicts ||
125            off2 &gt; stream-&gt;size                   ||
126            off1 &gt; off2                           )
127       {
128         FT_TRACE0(( &quot;cid_load_glyph: invalid glyph stream offsets\n&quot; ));
129         error = FT_THROW( Invalid_Offset );
130         goto Exit;
131       }
132 
133       glyph_length = off2 - off1;
134       if ( glyph_length == 0 )
135         goto Exit;
136       if ( FT_ALLOC( charstring, glyph_length ) )
137         goto Exit;
138       if ( FT_STREAM_READ_AT( cid-&gt;data_offset + off1,
139                               charstring, glyph_length ) )
140         goto Exit;
141     }
142 
143     /* Now set up the subrs array and parse the charstrings. */
144     {
145       CID_FaceDict  dict;
146       CID_Subrs     cid_subrs = face-&gt;subrs + fd_select;
147       FT_UInt       cs_offset;
148 
149 
150       /* Set up subrs */
151       decoder-&gt;num_subrs  = cid_subrs-&gt;num_subrs;
152       decoder-&gt;subrs      = cid_subrs-&gt;code;
153       decoder-&gt;subrs_len  = 0;
154       decoder-&gt;subrs_hash = NULL;
155 
156       /* Set up font matrix */
157       dict                 = cid-&gt;font_dicts + fd_select;
158 
159       decoder-&gt;font_matrix = dict-&gt;font_matrix;
160       decoder-&gt;font_offset = dict-&gt;font_offset;
161       decoder-&gt;lenIV       = dict-&gt;private_dict.lenIV;
162 
163       /* Decode the charstring. */
164 
165       /* Adjustment for seed bytes. */
166       cs_offset = decoder-&gt;lenIV &gt;= 0 ? (FT_UInt)decoder-&gt;lenIV : 0;
167       if ( cs_offset &gt; glyph_length )
168       {
169         FT_TRACE0(( &quot;cid_load_glyph: invalid glyph stream offsets\n&quot; ));
170         error = FT_THROW( Invalid_Offset );
171         goto Exit;
172       }
173 
174       /* Decrypt only if lenIV &gt;= 0. */
175       if ( decoder-&gt;lenIV &gt;= 0 )
176         psaux-&gt;t1_decrypt( charstring, glyph_length, 4330 );
177 
178       /* choose which renderer to use */
179 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
180       if ( ( (PS_Driver)FT_FACE_DRIVER( face ) )-&gt;hinting_engine ==
181                FT_HINTING_FREETYPE                                  ||
182            decoder-&gt;builder.metrics_only                            )
183         error = psaux-&gt;t1_decoder_funcs-&gt;parse_charstrings_old(
184                   decoder,
185                   charstring + cs_offset,
186                   glyph_length - cs_offset );
187 #else
188       if ( decoder-&gt;builder.metrics_only )
189         error = psaux-&gt;t1_decoder_funcs-&gt;parse_metrics(
190                   decoder,
191                   charstring + cs_offset,
192                   glyph_length - cs_offset );
193 #endif
194       else
195       {
196         PS_Decoder      psdecoder;
197         CFF_SubFontRec  subfont;
198 
199 
200         psaux-&gt;ps_decoder_init( &amp;psdecoder, decoder, TRUE );
201 
202         psaux-&gt;t1_make_subfont( FT_FACE( face ),
203                                 &amp;dict-&gt;private_dict,
204                                 &amp;subfont );
205         psdecoder.current_subfont = &amp;subfont;
206 
207         error = psaux-&gt;t1_decoder_funcs-&gt;parse_charstrings(
208                   &amp;psdecoder,
209                   charstring + cs_offset,
210                   glyph_length - cs_offset );
211 
212         /* Adobe&#39;s engine uses 16.16 numbers everywhere;              */
213         /* as a consequence, glyphs larger than 2000ppem get rejected */
214         if ( FT_ERR_EQ( error, Glyph_Too_Big ) )
215         {
216           /* this time, we retry unhinted and scale up the glyph later on */
217           /* (the engine uses and sets the hardcoded value 0x10000 / 64 = */
218           /* 0x400 for both `x_scale&#39; and `y_scale&#39; in this case)         */
219           ((CID_GlyphSlot)decoder-&gt;builder.glyph)-&gt;hint = FALSE;
220 
221           force_scaling = TRUE;
222 
223           error = psaux-&gt;t1_decoder_funcs-&gt;parse_charstrings(
224                     &amp;psdecoder,
225                     charstring + cs_offset,
226                     glyph_length - cs_offset );
227         }
228       }
229     }
230 
231 #ifdef FT_CONFIG_OPTION_INCREMENTAL
232 
233     /* Incremental fonts can optionally override the metrics. */
234     if ( !error &amp;&amp; inc &amp;&amp; inc-&gt;funcs-&gt;get_glyph_metrics )
235     {
236       FT_Incremental_MetricsRec  metrics;
237 
238 
239       metrics.bearing_x = FIXED_TO_INT( decoder-&gt;builder.left_bearing.x );
240       metrics.bearing_y = 0;
241       metrics.advance   = FIXED_TO_INT( decoder-&gt;builder.advance.x );
242       metrics.advance_v = FIXED_TO_INT( decoder-&gt;builder.advance.y );
243 
244       error = inc-&gt;funcs-&gt;get_glyph_metrics( inc-&gt;object,
245                                              glyph_index, FALSE, &amp;metrics );
246 
247       decoder-&gt;builder.left_bearing.x = INT_TO_FIXED( metrics.bearing_x );
248       decoder-&gt;builder.advance.x      = INT_TO_FIXED( metrics.advance );
249       decoder-&gt;builder.advance.y      = INT_TO_FIXED( metrics.advance_v );
250     }
251 
252 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
253 
254   Exit:
255     FT_FREE( charstring );
256 
257     ((CID_GlyphSlot)decoder-&gt;builder.glyph)-&gt;scaled = force_scaling;
258 
259     return error;
260   }
261 
262 
263 #if 0
264 
265 
266   /*************************************************************************/
267   /*************************************************************************/
268   /*************************************************************************/
269   /**********                                                      *********/
270   /**********                                                      *********/
271   /**********            COMPUTE THE MAXIMUM ADVANCE WIDTH         *********/
272   /**********                                                      *********/
273   /**********    The following code is in charge of computing      *********/
274   /**********    the maximum advance width of the font.  It        *********/
275   /**********    quickly processes each glyph charstring to        *********/
276   /**********    extract the value from either a `sbw&#39; or `seac&#39;   *********/
277   /**********    operator.                                         *********/
278   /**********                                                      *********/
279   /*************************************************************************/
280   /*************************************************************************/
281   /*************************************************************************/
282 
283 
284   FT_LOCAL_DEF( FT_Error )
285   cid_face_compute_max_advance( CID_Face  face,
286                                 FT_Int*   max_advance )
287   {
288     FT_Error       error;
289     T1_DecoderRec  decoder;
290     FT_Int         glyph_index;
291 
292     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
293 
294 
295     *max_advance = 0;
296 
297     /* Initialize load decoder */
298     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
299                                            (FT_Face)face,
300                                            0, /* size       */
301                                            0, /* glyph slot */
302                                            0, /* glyph names! XXX */
303                                            0, /* blend == 0 */
304                                            0, /* hinting == 0 */
305                                            cid_load_glyph );
306     if ( error )
307       return error;
308 
309     /* TODO: initialize decoder.len_buildchar and decoder.buildchar */
310     /*       if we ever support CID-keyed multiple master fonts     */
311 
312     decoder.builder.metrics_only = 1;
313     decoder.builder.load_points  = 0;
314 
315     /* for each glyph, parse the glyph charstring and extract */
316     /* the advance width                                      */
317     for ( glyph_index = 0; glyph_index &lt; face-&gt;root.num_glyphs;
318           glyph_index++ )
319     {
320       /* now get load the unscaled outline */
321       error = cid_load_glyph( &amp;decoder, glyph_index );
322       /* ignore the error if one occurred - skip to next glyph */
323     }
324 
325     *max_advance = FIXED_TO_INT( decoder.builder.advance.x );
326 
327     psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
328 
329     return FT_Err_Ok;
330   }
331 
332 
333 #endif /* 0 */
334 
335 
336   FT_LOCAL_DEF( FT_Error )
337   cid_slot_load_glyph( FT_GlyphSlot  cidglyph,      /* CID_GlyphSlot */
338                        FT_Size       cidsize,       /* CID_Size      */
339                        FT_UInt       glyph_index,
340                        FT_Int32      load_flags )
341   {
342     CID_GlyphSlot  glyph = (CID_GlyphSlot)cidglyph;
343     FT_Error       error;
344     T1_DecoderRec  decoder;
345     CID_Face       face = (CID_Face)cidglyph-&gt;face;
346     FT_Bool        hinting;
347     FT_Bool        scaled;
348 
349     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
350     FT_Matrix      font_matrix;
351     FT_Vector      font_offset;
352     FT_Bool        must_finish_decoder = FALSE;
353 
354 
355     if ( glyph_index &gt;= (FT_UInt)face-&gt;root.num_glyphs )
356     {
357       error = FT_THROW( Invalid_Argument );
358       goto Exit;
359     }
360 
361     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
362       load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
363 
364     glyph-&gt;x_scale = cidsize-&gt;metrics.x_scale;
365     glyph-&gt;y_scale = cidsize-&gt;metrics.y_scale;
366 
367     cidglyph-&gt;outline.n_points   = 0;
368     cidglyph-&gt;outline.n_contours = 0;
369 
370     hinting = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 &amp;&amp;
371                        ( load_flags &amp; FT_LOAD_NO_HINTING ) == 0 );
372     scaled  = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 );
373 
374     glyph-&gt;hint      = hinting;
375     glyph-&gt;scaled    = scaled;
376     cidglyph-&gt;format = FT_GLYPH_FORMAT_OUTLINE;
377 
378     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
379                                            cidglyph-&gt;face,
380                                            cidsize,
381                                            cidglyph,
382                                            0, /* glyph names -- XXX */
383                                            0, /* blend == 0 */
384                                            hinting,
385                                            FT_LOAD_TARGET_MODE( load_flags ),
386                                            cid_load_glyph );
387     if ( error )
388       goto Exit;
389 
390     /* TODO: initialize decoder.len_buildchar and decoder.buildchar */
391     /*       if we ever support CID-keyed multiple master fonts     */
392 
393     must_finish_decoder = TRUE;
394 
395     /* set up the decoder */
396     decoder.builder.no_recurse = FT_BOOL(
397       ( ( load_flags &amp; FT_LOAD_NO_RECURSE ) != 0 ) );
398 
399     error = cid_load_glyph( &amp;decoder, glyph_index );
400     if ( error )
401       goto Exit;
402 
403     /* copy flags back for forced scaling */
404     hinting = glyph-&gt;hint;
405     scaled  = glyph-&gt;scaled;
406 
407     font_matrix = decoder.font_matrix;
408     font_offset = decoder.font_offset;
409 
410     /* save new glyph tables */
411     psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
412 
413     must_finish_decoder = FALSE;
414 
415     /* now set the metrics -- this is rather simple, as    */
416     /* the left side bearing is the xMin, and the top side */
417     /* bearing the yMax                                    */
418     cidglyph-&gt;outline.flags &amp;= FT_OUTLINE_OWNER;
419     cidglyph-&gt;outline.flags |= FT_OUTLINE_REVERSE_FILL;
420 
421     /* for composite glyphs, return only left side bearing and */
422     /* advance width                                           */
423     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
424     {
425       FT_Slot_Internal  internal = cidglyph-&gt;internal;
426 
427 
428       cidglyph-&gt;metrics.horiBearingX =
429         FIXED_TO_INT( decoder.builder.left_bearing.x );
430       cidglyph-&gt;metrics.horiAdvance =
431         FIXED_TO_INT( decoder.builder.advance.x );
432 
433       internal-&gt;glyph_matrix      = font_matrix;
434       internal-&gt;glyph_delta       = font_offset;
435       internal-&gt;glyph_transformed = 1;
436     }
437     else
438     {
439       FT_BBox            cbox;
440       FT_Glyph_Metrics*  metrics = &amp;cidglyph-&gt;metrics;
441 
442 
443       /* copy the _unscaled_ advance width */
444       metrics-&gt;horiAdvance =
445         FIXED_TO_INT( decoder.builder.advance.x );
446       cidglyph-&gt;linearHoriAdvance =
447         FIXED_TO_INT( decoder.builder.advance.x );
448       cidglyph-&gt;internal-&gt;glyph_transformed = 0;
449 
450       /* make up vertical ones */
451       metrics-&gt;vertAdvance        = ( face-&gt;cid.font_bbox.yMax -
452                                       face-&gt;cid.font_bbox.yMin ) &gt;&gt; 16;
453       cidglyph-&gt;linearVertAdvance = metrics-&gt;vertAdvance;
454 
455       cidglyph-&gt;format            = FT_GLYPH_FORMAT_OUTLINE;
456 
457       if ( cidsize-&gt;metrics.y_ppem &lt; 24 )
458         cidglyph-&gt;outline.flags |= FT_OUTLINE_HIGH_PRECISION;
459 
460       /* apply the font matrix, if any */
461       if ( font_matrix.xx != 0x10000L || font_matrix.yy != 0x10000L ||
462            font_matrix.xy != 0        || font_matrix.yx != 0        )
463       {
464         FT_Outline_Transform( &amp;cidglyph-&gt;outline, &amp;font_matrix );
465 
466         metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance,
467                                           font_matrix.xx );
468         metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance,
469                                           font_matrix.yy );
470       }
471 
472       if ( font_offset.x || font_offset.y )
473       {
474         FT_Outline_Translate( &amp;cidglyph-&gt;outline,
475                               font_offset.x,
476                               font_offset.y );
477 
478         metrics-&gt;horiAdvance += font_offset.x;
479         metrics-&gt;vertAdvance += font_offset.y;
480       }
481 
482       if ( ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0 || scaled )
483       {
484         /* scale the outline and the metrics */
485         FT_Int       n;
486         FT_Outline*  cur = decoder.builder.base;
487         FT_Vector*   vec = cur-&gt;points;
488         FT_Fixed     x_scale = glyph-&gt;x_scale;
489         FT_Fixed     y_scale = glyph-&gt;y_scale;
490 
491 
492         /* First of all, scale the points */
493         if ( !hinting || !decoder.builder.hints_funcs )
494           for ( n = cur-&gt;n_points; n &gt; 0; n--, vec++ )
495           {
496             vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );
497             vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );
498           }
499 
500         /* Then scale the metrics */
501         metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance, x_scale );
502         metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance, y_scale );
503       }
504 
505       /* compute the other metrics */
506       FT_Outline_Get_CBox( &amp;cidglyph-&gt;outline, &amp;cbox );
507 
508       metrics-&gt;width  = cbox.xMax - cbox.xMin;
509       metrics-&gt;height = cbox.yMax - cbox.yMin;
510 
511       metrics-&gt;horiBearingX = cbox.xMin;
512       metrics-&gt;horiBearingY = cbox.yMax;
513 
514       if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
515       {
516         /* make up vertical ones */
517         ft_synthesize_vertical_metrics( metrics,
518                                         metrics-&gt;vertAdvance );
519       }
520     }
521 
522   Exit:
523 
524     if ( must_finish_decoder )
525       psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
526 
527     return error;
528   }
529 
530 
531 /* END */
    </pre>
  </body>
</html>
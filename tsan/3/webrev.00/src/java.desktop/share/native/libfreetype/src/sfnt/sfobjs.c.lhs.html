<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  sfobjs.c                                                               */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    SFNT object management (base).                                       */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include &quot;sfobjs.h&quot;
  21 #include &quot;ttload.h&quot;
  22 #include &quot;ttcmap.h&quot;
  23 #include &quot;ttkern.h&quot;
<a name="2" id="anc2"></a>
  24 #include FT_INTERNAL_SFNT_H
  25 #include FT_INTERNAL_DEBUG_H
  26 #include FT_TRUETYPE_IDS_H
  27 #include FT_TRUETYPE_TAGS_H
  28 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
  29 #include FT_SFNT_NAMES_H
<a name="3" id="anc3"></a><span class="line-removed">  30 #include FT_GZIP_H</span>
  31 
  32 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
  33 #include FT_SERVICE_MULTIPLE_MASTERS_H
  34 #include FT_SERVICE_METRICS_VARIATIONS_H
  35 #endif
  36 
  37 #include &quot;sferrors.h&quot;
  38 
  39 #ifdef TT_CONFIG_OPTION_BDF
  40 #include &quot;ttbdf.h&quot;
  41 #endif
  42 
  43 
<a name="4" id="anc4"></a><span class="line-modified">  44   /*************************************************************************/</span>
<span class="line-modified">  45   /*                                                                       */</span>
<span class="line-modified">  46   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  47   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  48   /* messages during execution.                                            */</span>
<span class="line-modified">  49   /*                                                                       */</span>
  50 #undef  FT_COMPONENT
<a name="5" id="anc5"></a><span class="line-modified">  51 #define FT_COMPONENT  trace_sfobjs</span>
  52 
  53 
  54 
  55   /* convert a UTF-16 name entry to ASCII */
  56   static FT_String*
  57   tt_name_ascii_from_utf16( TT_Name    entry,
  58                             FT_Memory  memory )
  59   {
  60     FT_String*  string = NULL;
  61     FT_UInt     len, code, n;
  62     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  63     FT_Error    error;
  64 
  65 
  66     len = (FT_UInt)entry-&gt;stringLength / 2;
  67 
  68     if ( FT_NEW_ARRAY( string, len + 1 ) )
  69       return NULL;
  70 
  71     for ( n = 0; n &lt; len; n++ )
  72     {
  73       code = FT_NEXT_USHORT( read );
  74 
  75       if ( code == 0 )
  76         break;
  77 
  78       if ( code &lt; 32 || code &gt; 127 )
  79         code = &#39;?&#39;;
  80 
  81       string[n] = (char)code;
  82     }
  83 
  84     string[n] = 0;
  85 
  86     return string;
  87   }
  88 
  89 
  90   /* convert an Apple Roman or symbol name entry to ASCII */
  91   static FT_String*
  92   tt_name_ascii_from_other( TT_Name    entry,
  93                             FT_Memory  memory )
  94   {
  95     FT_String*  string = NULL;
  96     FT_UInt     len, code, n;
  97     FT_Byte*    read   = (FT_Byte*)entry-&gt;string;
  98     FT_Error    error;
  99 
 100 
 101     len = (FT_UInt)entry-&gt;stringLength;
 102 
 103     if ( FT_NEW_ARRAY( string, len + 1 ) )
 104       return NULL;
 105 
 106     for ( n = 0; n &lt; len; n++ )
 107     {
 108       code = *read++;
 109 
 110       if ( code == 0 )
 111         break;
 112 
 113       if ( code &lt; 32 || code &gt; 127 )
 114         code = &#39;?&#39;;
 115 
 116       string[n] = (char)code;
 117     }
 118 
 119     string[n] = 0;
 120 
 121     return string;
 122   }
 123 
 124 
 125   typedef FT_String*  (*TT_Name_ConvertFunc)( TT_Name    entry,
 126                                               FT_Memory  memory );
 127 
 128 
 129   /* documentation is in sfnt.h */
 130 
 131   FT_LOCAL_DEF( FT_Error )
 132   tt_face_get_name( TT_Face      face,
 133                     FT_UShort    nameid,
 134                     FT_String**  name )
 135   {
 136     FT_Memory   memory = face-&gt;root.memory;
 137     FT_Error    error  = FT_Err_Ok;
 138     FT_String*  result = NULL;
 139     FT_UShort   n;
 140     TT_Name     rec;
 141 
 142     FT_Int  found_apple         = -1;
 143     FT_Int  found_apple_roman   = -1;
 144     FT_Int  found_apple_english = -1;
 145     FT_Int  found_win           = -1;
 146     FT_Int  found_unicode       = -1;
 147 
 148     FT_Bool  is_english = 0;
 149 
 150     TT_Name_ConvertFunc  convert;
 151 
 152 
 153     FT_ASSERT( name );
 154 
 155     rec = face-&gt;name_table.names;
 156     for ( n = 0; n &lt; face-&gt;num_names; n++, rec++ )
 157     {
 158       /* According to the OpenType 1.3 specification, only Microsoft or  */
 159       /* Apple platform IDs might be used in the `name&#39; table.  The      */
 160       /* `Unicode&#39; platform is reserved for the `cmap&#39; table, and the    */
 161       /* `ISO&#39; one is deprecated.                                        */
 162       /*                                                                 */
 163       /* However, the Apple TrueType specification doesn&#39;t say the same  */
 164       /* thing and goes to suggest that all Unicode `name&#39; table entries */
 165       /* should be coded in UTF-16 (in big-endian format I suppose).     */
 166       /*                                                                 */
 167       if ( rec-&gt;nameID == nameid &amp;&amp; rec-&gt;stringLength &gt; 0 )
 168       {
 169         switch ( rec-&gt;platformID )
 170         {
 171         case TT_PLATFORM_APPLE_UNICODE:
 172         case TT_PLATFORM_ISO:
 173           /* there is `languageID&#39; to check there.  We should use this */
 174           /* field only as a last solution when nothing else is        */
 175           /* available.                                                */
 176           /*                                                           */
 177           found_unicode = n;
 178           break;
 179 
 180         case TT_PLATFORM_MACINTOSH:
 181           /* This is a bit special because some fonts will use either    */
 182           /* an English language id, or a Roman encoding id, to indicate */
 183           /* the English version of its font name.                       */
 184           /*                                                             */
 185           if ( rec-&gt;languageID == TT_MAC_LANGID_ENGLISH )
 186             found_apple_english = n;
 187           else if ( rec-&gt;encodingID == TT_MAC_ID_ROMAN )
 188             found_apple_roman = n;
 189           break;
 190 
 191         case TT_PLATFORM_MICROSOFT:
 192           /* we only take a non-English name when there is nothing */
 193           /* else available in the font                            */
 194           /*                                                       */
 195           if ( found_win == -1 || ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 )
 196           {
 197             switch ( rec-&gt;encodingID )
 198             {
 199             case TT_MS_ID_SYMBOL_CS:
 200             case TT_MS_ID_UNICODE_CS:
 201             case TT_MS_ID_UCS_4:
 202               is_english = FT_BOOL( ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 );
 203               found_win  = n;
 204               break;
 205 
 206             default:
 207               ;
 208             }
 209           }
 210           break;
 211 
 212         default:
 213           ;
 214         }
 215       }
 216     }
 217 
 218     found_apple = found_apple_roman;
 219     if ( found_apple_english &gt;= 0 )
 220       found_apple = found_apple_english;
 221 
 222     /* some fonts contain invalid Unicode or Macintosh formatted entries; */
 223     /* we will thus favor names encoded in Windows formats if available   */
 224     /* (provided it is an English name)                                   */
 225     /*                                                                    */
 226     convert = NULL;
 227     if ( found_win &gt;= 0 &amp;&amp; !( found_apple &gt;= 0 &amp;&amp; !is_english ) )
 228     {
 229       rec = face-&gt;name_table.names + found_win;
 230       switch ( rec-&gt;encodingID )
 231       {
 232         /* all Unicode strings are encoded using UTF-16BE */
 233       case TT_MS_ID_UNICODE_CS:
 234       case TT_MS_ID_SYMBOL_CS:
 235         convert = tt_name_ascii_from_utf16;
 236         break;
 237 
 238       case TT_MS_ID_UCS_4:
 239         /* Apparently, if this value is found in a name table entry, it is */
 240         /* documented as `full Unicode repertoire&#39;.  Experience with the   */
 241         /* MsGothic font shipped with Windows Vista shows that this really */
 242         /* means UTF-16 encoded names (UCS-4 values are only used within   */
 243         /* charmaps).                                                      */
 244         convert = tt_name_ascii_from_utf16;
 245         break;
 246 
 247       default:
 248         ;
 249       }
 250     }
 251     else if ( found_apple &gt;= 0 )
 252     {
 253       rec     = face-&gt;name_table.names + found_apple;
 254       convert = tt_name_ascii_from_other;
 255     }
 256     else if ( found_unicode &gt;= 0 )
 257     {
 258       rec     = face-&gt;name_table.names + found_unicode;
 259       convert = tt_name_ascii_from_utf16;
 260     }
 261 
 262     if ( rec &amp;&amp; convert )
 263     {
 264       if ( !rec-&gt;string )
 265       {
 266         FT_Stream  stream = face-&gt;name_table.stream;
 267 
 268 
 269         if ( FT_QNEW_ARRAY ( rec-&gt;string, rec-&gt;stringLength ) ||
 270              FT_STREAM_SEEK( rec-&gt;stringOffset )              ||
 271              FT_STREAM_READ( rec-&gt;string, rec-&gt;stringLength ) )
 272         {
 273           FT_FREE( rec-&gt;string );
 274           rec-&gt;stringLength = 0;
 275           result            = NULL;
 276           goto Exit;
 277         }
 278       }
 279 
 280       result = convert( rec, memory );
 281     }
 282 
 283   Exit:
 284     *name = result;
 285     return error;
 286   }
 287 
 288 
 289   static FT_Encoding
 290   sfnt_find_encoding( int  platform_id,
 291                       int  encoding_id )
 292   {
 293     typedef struct  TEncoding_
 294     {
 295       int          platform_id;
 296       int          encoding_id;
 297       FT_Encoding  encoding;
 298 
 299     } TEncoding;
 300 
 301     static
 302     const TEncoding  tt_encodings[] =
 303     {
 304       { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },
 305 
 306       { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },
 307 
 308       { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },
 309 
 310       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },
 311       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },
 312       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },
 313       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },
 314       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_PRC,        FT_ENCODING_PRC },
 315       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },
 316       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },
 317       { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }
 318     };
 319 
 320     const TEncoding  *cur, *limit;
 321 
 322 
 323     cur   = tt_encodings;
 324     limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );
 325 
 326     for ( ; cur &lt; limit; cur++ )
 327     {
 328       if ( cur-&gt;platform_id == platform_id )
 329       {
 330         if ( cur-&gt;encoding_id == encoding_id ||
 331              cur-&gt;encoding_id == -1          )
 332           return cur-&gt;encoding;
 333       }
 334     }
 335 
 336     return FT_ENCODING_NONE;
 337   }
 338 
 339 
<a name="6" id="anc6"></a><span class="line-removed"> 340 #define WRITE_USHORT( p, v )                \</span>
<span class="line-removed"> 341           do                                \</span>
<span class="line-removed"> 342           {                                 \</span>
<span class="line-removed"> 343             *(p)++ = (FT_Byte)( (v) &gt;&gt; 8 ); \</span>
<span class="line-removed"> 344             *(p)++ = (FT_Byte)( (v) &gt;&gt; 0 ); \</span>
<span class="line-removed"> 345                                             \</span>
<span class="line-removed"> 346           } while ( 0 )</span>
<span class="line-removed"> 347 </span>
<span class="line-removed"> 348 #define WRITE_ULONG( p, v )                  \</span>
<span class="line-removed"> 349           do                                 \</span>
<span class="line-removed"> 350           {                                  \</span>
<span class="line-removed"> 351             *(p)++ = (FT_Byte)( (v) &gt;&gt; 24 ); \</span>
<span class="line-removed"> 352             *(p)++ = (FT_Byte)( (v) &gt;&gt; 16 ); \</span>
<span class="line-removed"> 353             *(p)++ = (FT_Byte)( (v) &gt;&gt;  8 ); \</span>
<span class="line-removed"> 354             *(p)++ = (FT_Byte)( (v) &gt;&gt;  0 ); \</span>
<span class="line-removed"> 355                                              \</span>
<span class="line-removed"> 356           } while ( 0 )</span>
<span class="line-removed"> 357 </span>
<span class="line-removed"> 358 </span>
<span class="line-removed"> 359   static void</span>
<span class="line-removed"> 360   sfnt_stream_close( FT_Stream  stream )</span>
<span class="line-removed"> 361   {</span>
<span class="line-removed"> 362     FT_Memory  memory = stream-&gt;memory;</span>
<span class="line-removed"> 363 </span>
<span class="line-removed"> 364 </span>
<span class="line-removed"> 365     FT_FREE( stream-&gt;base );</span>
<span class="line-removed"> 366 </span>
<span class="line-removed"> 367     stream-&gt;size  = 0;</span>
<span class="line-removed"> 368     stream-&gt;base  = NULL;</span>
<span class="line-removed"> 369     stream-&gt;close = NULL;</span>
<span class="line-removed"> 370   }</span>
<span class="line-removed"> 371 </span>
<span class="line-removed"> 372 </span>
<span class="line-removed"> 373   FT_CALLBACK_DEF( int )</span>
<span class="line-removed"> 374   compare_offsets( const void*  a,</span>
<span class="line-removed"> 375                    const void*  b )</span>
<span class="line-removed"> 376   {</span>
<span class="line-removed"> 377     WOFF_Table  table1 = *(WOFF_Table*)a;</span>
<span class="line-removed"> 378     WOFF_Table  table2 = *(WOFF_Table*)b;</span>
<span class="line-removed"> 379 </span>
<span class="line-removed"> 380     FT_ULong  offset1 = table1-&gt;Offset;</span>
<span class="line-removed"> 381     FT_ULong  offset2 = table2-&gt;Offset;</span>
<span class="line-removed"> 382 </span>
<span class="line-removed"> 383 </span>
<span class="line-removed"> 384     if ( offset1 &gt; offset2 )</span>
<span class="line-removed"> 385       return 1;</span>
<span class="line-removed"> 386     else if ( offset1 &lt; offset2 )</span>
<span class="line-removed"> 387       return -1;</span>
<span class="line-removed"> 388     else</span>
<span class="line-removed"> 389       return 0;</span>
<span class="line-removed"> 390   }</span>
<span class="line-removed"> 391 </span>
<span class="line-removed"> 392 </span>
<span class="line-removed"> 393   /* Replace `face-&gt;root.stream&#39; with a stream containing the extracted */</span>
<span class="line-removed"> 394   /* SFNT of a WOFF font.                                               */</span>
<span class="line-removed"> 395 </span>
<span class="line-removed"> 396   static FT_Error</span>
<span class="line-removed"> 397   woff_open_font( FT_Stream  stream,</span>
<span class="line-removed"> 398                   TT_Face    face )</span>
<span class="line-removed"> 399   {</span>
<span class="line-removed"> 400     FT_Memory       memory = stream-&gt;memory;</span>
<span class="line-removed"> 401     FT_Error        error  = FT_Err_Ok;</span>
<span class="line-removed"> 402 </span>
<span class="line-removed"> 403     WOFF_HeaderRec  woff;</span>
<span class="line-removed"> 404     WOFF_Table      tables  = NULL;</span>
<span class="line-removed"> 405     WOFF_Table*     indices = NULL;</span>
<span class="line-removed"> 406 </span>
<span class="line-removed"> 407     FT_ULong        woff_offset;</span>
<span class="line-removed"> 408 </span>
<span class="line-removed"> 409     FT_Byte*        sfnt        = NULL;</span>
<span class="line-removed"> 410     FT_Stream       sfnt_stream = NULL;</span>
<span class="line-removed"> 411 </span>
<span class="line-removed"> 412     FT_Byte*        sfnt_header;</span>
<span class="line-removed"> 413     FT_ULong        sfnt_offset;</span>
<span class="line-removed"> 414 </span>
<span class="line-removed"> 415     FT_Int          nn;</span>
<span class="line-removed"> 416     FT_ULong        old_tag = 0;</span>
<span class="line-removed"> 417 </span>
<span class="line-removed"> 418     static const FT_Frame_Field  woff_header_fields[] =</span>
<span class="line-removed"> 419     {</span>
<span class="line-removed"> 420 #undef  FT_STRUCTURE</span>
<span class="line-removed"> 421 #define FT_STRUCTURE  WOFF_HeaderRec</span>
<span class="line-removed"> 422 </span>
<span class="line-removed"> 423       FT_FRAME_START( 44 ),</span>
<span class="line-removed"> 424         FT_FRAME_ULONG ( signature ),</span>
<span class="line-removed"> 425         FT_FRAME_ULONG ( flavor ),</span>
<span class="line-removed"> 426         FT_FRAME_ULONG ( length ),</span>
<span class="line-removed"> 427         FT_FRAME_USHORT( num_tables ),</span>
<span class="line-removed"> 428         FT_FRAME_USHORT( reserved ),</span>
<span class="line-removed"> 429         FT_FRAME_ULONG ( totalSfntSize ),</span>
<span class="line-removed"> 430         FT_FRAME_USHORT( majorVersion ),</span>
<span class="line-removed"> 431         FT_FRAME_USHORT( minorVersion ),</span>
<span class="line-removed"> 432         FT_FRAME_ULONG ( metaOffset ),</span>
<span class="line-removed"> 433         FT_FRAME_ULONG ( metaLength ),</span>
<span class="line-removed"> 434         FT_FRAME_ULONG ( metaOrigLength ),</span>
<span class="line-removed"> 435         FT_FRAME_ULONG ( privOffset ),</span>
<span class="line-removed"> 436         FT_FRAME_ULONG ( privLength ),</span>
<span class="line-removed"> 437       FT_FRAME_END</span>
<span class="line-removed"> 438     };</span>
<span class="line-removed"> 439 </span>
<span class="line-removed"> 440 </span>
<span class="line-removed"> 441     FT_ASSERT( stream == face-&gt;root.stream );</span>
<span class="line-removed"> 442     FT_ASSERT( FT_STREAM_POS() == 0 );</span>
<span class="line-removed"> 443 </span>
<span class="line-removed"> 444     if ( FT_STREAM_READ_FIELDS( woff_header_fields, &amp;woff ) )</span>
<span class="line-removed"> 445       return error;</span>
<span class="line-removed"> 446 </span>
<span class="line-removed"> 447     /* Make sure we don&#39;t recurse back here or hit TTC code. */</span>
<span class="line-removed"> 448     if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )</span>
<span class="line-removed"> 449       return FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 450 </span>
<span class="line-removed"> 451     /* Miscellaneous checks. */</span>
<span class="line-removed"> 452     if ( woff.length != stream-&gt;size                              ||</span>
<span class="line-removed"> 453          woff.num_tables == 0                                     ||</span>
<span class="line-removed"> 454          44 + woff.num_tables * 20UL &gt;= woff.length               ||</span>
<span class="line-removed"> 455          12 + woff.num_tables * 16UL &gt;= woff.totalSfntSize        ||</span>
<span class="line-removed"> 456          ( woff.totalSfntSize &amp; 3 ) != 0                          ||</span>
<span class="line-removed"> 457          ( woff.metaOffset == 0 &amp;&amp; ( woff.metaLength != 0     ||</span>
<span class="line-removed"> 458                                      woff.metaOrigLength != 0 ) ) ||</span>
<span class="line-removed"> 459          ( woff.metaLength != 0 &amp;&amp; woff.metaOrigLength == 0 )     ||</span>
<span class="line-removed"> 460          ( woff.privOffset == 0 &amp;&amp; woff.privLength != 0 )         )</span>
<span class="line-removed"> 461     {</span>
<span class="line-removed"> 462       FT_ERROR(( &quot;woff_font_open: invalid WOFF header\n&quot; ));</span>
<span class="line-removed"> 463       return FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 464     }</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466     /* Don&#39;t trust `totalSfntSize&#39; before thorough checks. */</span>
<span class="line-removed"> 467     if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||</span>
<span class="line-removed"> 468          FT_NEW( sfnt_stream )                         )</span>
<span class="line-removed"> 469       goto Exit;</span>
<span class="line-removed"> 470 </span>
<span class="line-removed"> 471     sfnt_header = sfnt;</span>
<span class="line-removed"> 472 </span>
<span class="line-removed"> 473     /* Write sfnt header. */</span>
<span class="line-removed"> 474     {</span>
<span class="line-removed"> 475       FT_UInt  searchRange, entrySelector, rangeShift, x;</span>
<span class="line-removed"> 476 </span>
<span class="line-removed"> 477 </span>
<span class="line-removed"> 478       x             = woff.num_tables;</span>
<span class="line-removed"> 479       entrySelector = 0;</span>
<span class="line-removed"> 480       while ( x )</span>
<span class="line-removed"> 481       {</span>
<span class="line-removed"> 482         x            &gt;&gt;= 1;</span>
<span class="line-removed"> 483         entrySelector += 1;</span>
<span class="line-removed"> 484       }</span>
<span class="line-removed"> 485       entrySelector--;</span>
<span class="line-removed"> 486 </span>
<span class="line-removed"> 487       searchRange = ( 1 &lt;&lt; entrySelector ) * 16;</span>
<span class="line-removed"> 488       rangeShift  = woff.num_tables * 16 - searchRange;</span>
<span class="line-removed"> 489 </span>
<span class="line-removed"> 490       WRITE_ULONG ( sfnt_header, woff.flavor );</span>
<span class="line-removed"> 491       WRITE_USHORT( sfnt_header, woff.num_tables );</span>
<span class="line-removed"> 492       WRITE_USHORT( sfnt_header, searchRange );</span>
<span class="line-removed"> 493       WRITE_USHORT( sfnt_header, entrySelector );</span>
<span class="line-removed"> 494       WRITE_USHORT( sfnt_header, rangeShift );</span>
<span class="line-removed"> 495     }</span>
<span class="line-removed"> 496 </span>
<span class="line-removed"> 497     /* While the entries in the sfnt header must be sorted by the */</span>
<span class="line-removed"> 498     /* tag value, the tables themselves are not.  We thus have to */</span>
<span class="line-removed"> 499     /* sort them by offset and check that they don&#39;t overlap.     */</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501     if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||</span>
<span class="line-removed"> 502          FT_NEW_ARRAY( indices, woff.num_tables ) )</span>
<span class="line-removed"> 503       goto Exit;</span>
<span class="line-removed"> 504 </span>
<span class="line-removed"> 505     FT_TRACE2(( &quot;\n&quot;</span>
<span class="line-removed"> 506                 &quot;  tag    offset    compLen  origLen  checksum\n&quot;</span>
<span class="line-removed"> 507                 &quot;  -------------------------------------------\n&quot; ));</span>
<span class="line-removed"> 508 </span>
<span class="line-removed"> 509     if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )</span>
<span class="line-removed"> 510       goto Exit;</span>
<span class="line-removed"> 511 </span>
<span class="line-removed"> 512     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 513     {</span>
<span class="line-removed"> 514       WOFF_Table  table = tables + nn;</span>
<span class="line-removed"> 515 </span>
<span class="line-removed"> 516       table-&gt;Tag        = FT_GET_TAG4();</span>
<span class="line-removed"> 517       table-&gt;Offset     = FT_GET_ULONG();</span>
<span class="line-removed"> 518       table-&gt;CompLength = FT_GET_ULONG();</span>
<span class="line-removed"> 519       table-&gt;OrigLength = FT_GET_ULONG();</span>
<span class="line-removed"> 520       table-&gt;CheckSum   = FT_GET_ULONG();</span>
<span class="line-removed"> 521 </span>
<span class="line-removed"> 522       FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n&quot;,</span>
<span class="line-removed"> 523                   (FT_Char)( table-&gt;Tag &gt;&gt; 24 ),</span>
<span class="line-removed"> 524                   (FT_Char)( table-&gt;Tag &gt;&gt; 16 ),</span>
<span class="line-removed"> 525                   (FT_Char)( table-&gt;Tag &gt;&gt; 8  ),</span>
<span class="line-removed"> 526                   (FT_Char)( table-&gt;Tag       ),</span>
<span class="line-removed"> 527                   table-&gt;Offset,</span>
<span class="line-removed"> 528                   table-&gt;CompLength,</span>
<span class="line-removed"> 529                   table-&gt;OrigLength,</span>
<span class="line-removed"> 530                   table-&gt;CheckSum ));</span>
<span class="line-removed"> 531 </span>
<span class="line-removed"> 532       if ( table-&gt;Tag &lt;= old_tag )</span>
<span class="line-removed"> 533       {</span>
<span class="line-removed"> 534         FT_FRAME_EXIT();</span>
<span class="line-removed"> 535 </span>
<span class="line-removed"> 536         FT_ERROR(( &quot;woff_font_open: table tags are not sorted\n&quot; ));</span>
<span class="line-removed"> 537         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 538         goto Exit;</span>
<span class="line-removed"> 539       }</span>
<span class="line-removed"> 540 </span>
<span class="line-removed"> 541       old_tag     = table-&gt;Tag;</span>
<span class="line-removed"> 542       indices[nn] = table;</span>
<span class="line-removed"> 543     }</span>
<span class="line-removed"> 544 </span>
<span class="line-removed"> 545     FT_FRAME_EXIT();</span>
<span class="line-removed"> 546 </span>
<span class="line-removed"> 547     /* Sort by offset. */</span>
<span class="line-removed"> 548 </span>
<span class="line-removed"> 549     ft_qsort( indices,</span>
<span class="line-removed"> 550               woff.num_tables,</span>
<span class="line-removed"> 551               sizeof ( WOFF_Table ),</span>
<span class="line-removed"> 552               compare_offsets );</span>
<span class="line-removed"> 553 </span>
<span class="line-removed"> 554     /* Check offsets and lengths. */</span>
<span class="line-removed"> 555 </span>
<span class="line-removed"> 556     woff_offset = 44 + woff.num_tables * 20L;</span>
<span class="line-removed"> 557     sfnt_offset = 12 + woff.num_tables * 16L;</span>
<span class="line-removed"> 558 </span>
<span class="line-removed"> 559     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 560     {</span>
<span class="line-removed"> 561       WOFF_Table  table = indices[nn];</span>
<span class="line-removed"> 562 </span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564       if ( table-&gt;Offset != woff_offset                         ||</span>
<span class="line-removed"> 565            table-&gt;CompLength &gt; woff.length                      ||</span>
<span class="line-removed"> 566            table-&gt;Offset &gt; woff.length - table-&gt;CompLength      ||</span>
<span class="line-removed"> 567            table-&gt;OrigLength &gt; woff.totalSfntSize               ||</span>
<span class="line-removed"> 568            sfnt_offset &gt; woff.totalSfntSize - table-&gt;OrigLength ||</span>
<span class="line-removed"> 569            table-&gt;CompLength &gt; table-&gt;OrigLength                )</span>
<span class="line-removed"> 570       {</span>
<span class="line-removed"> 571         FT_ERROR(( &quot;woff_font_open: invalid table offsets\n&quot; ));</span>
<span class="line-removed"> 572         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 573         goto Exit;</span>
<span class="line-removed"> 574       }</span>
<span class="line-removed"> 575 </span>
<span class="line-removed"> 576       table-&gt;OrigOffset = sfnt_offset;</span>
<span class="line-removed"> 577 </span>
<span class="line-removed"> 578       /* The offsets must be multiples of 4. */</span>
<span class="line-removed"> 579       woff_offset += ( table-&gt;CompLength + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 580       sfnt_offset += ( table-&gt;OrigLength + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 581     }</span>
<span class="line-removed"> 582 </span>
<span class="line-removed"> 583     /*</span>
<span class="line-removed"> 584      * Final checks!</span>
<span class="line-removed"> 585      *</span>
<span class="line-removed"> 586      * We don&#39;t decode and check the metadata block.</span>
<span class="line-removed"> 587      * We don&#39;t check table checksums either.</span>
<span class="line-removed"> 588      * But other than those, I think we implement all</span>
<span class="line-removed"> 589      * `MUST&#39; checks from the spec.</span>
<span class="line-removed"> 590      */</span>
<span class="line-removed"> 591 </span>
<span class="line-removed"> 592     if ( woff.metaOffset )</span>
<span class="line-removed"> 593     {</span>
<span class="line-removed"> 594       if ( woff.metaOffset != woff_offset                  ||</span>
<span class="line-removed"> 595            woff.metaOffset + woff.metaLength &gt; woff.length )</span>
<span class="line-removed"> 596       {</span>
<span class="line-removed"> 597         FT_ERROR(( &quot;woff_font_open:&quot;</span>
<span class="line-removed"> 598                    &quot; invalid `metadata&#39; offset or length\n&quot; ));</span>
<span class="line-removed"> 599         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 600         goto Exit;</span>
<span class="line-removed"> 601       }</span>
<span class="line-removed"> 602 </span>
<span class="line-removed"> 603       /* We have padding only ... */</span>
<span class="line-removed"> 604       woff_offset += woff.metaLength;</span>
<span class="line-removed"> 605     }</span>
<span class="line-removed"> 606 </span>
<span class="line-removed"> 607     if ( woff.privOffset )</span>
<span class="line-removed"> 608     {</span>
<span class="line-removed"> 609       /* ... if it isn&#39;t the last block. */</span>
<span class="line-removed"> 610       woff_offset = ( woff_offset + 3 ) &amp; ~3U;</span>
<span class="line-removed"> 611 </span>
<span class="line-removed"> 612       if ( woff.privOffset != woff_offset                  ||</span>
<span class="line-removed"> 613            woff.privOffset + woff.privLength &gt; woff.length )</span>
<span class="line-removed"> 614       {</span>
<span class="line-removed"> 615         FT_ERROR(( &quot;woff_font_open: invalid `private&#39; offset or length\n&quot; ));</span>
<span class="line-removed"> 616         error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 617         goto Exit;</span>
<span class="line-removed"> 618       }</span>
<span class="line-removed"> 619 </span>
<span class="line-removed"> 620       /* No padding for the last block. */</span>
<span class="line-removed"> 621       woff_offset += woff.privLength;</span>
<span class="line-removed"> 622     }</span>
<span class="line-removed"> 623 </span>
<span class="line-removed"> 624     if ( sfnt_offset != woff.totalSfntSize ||</span>
<span class="line-removed"> 625          woff_offset != woff.length        )</span>
<span class="line-removed"> 626     {</span>
<span class="line-removed"> 627       FT_ERROR(( &quot;woff_font_open: invalid `sfnt&#39; table structure\n&quot; ));</span>
<span class="line-removed"> 628       error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 629       goto Exit;</span>
<span class="line-removed"> 630     }</span>
<span class="line-removed"> 631 </span>
<span class="line-removed"> 632     /* Now use `totalSfntSize&#39;. */</span>
<span class="line-removed"> 633     if ( FT_REALLOC( sfnt,</span>
<span class="line-removed"> 634                      12 + woff.num_tables * 16UL,</span>
<span class="line-removed"> 635                      woff.totalSfntSize ) )</span>
<span class="line-removed"> 636       goto Exit;</span>
<span class="line-removed"> 637 </span>
<span class="line-removed"> 638     sfnt_header = sfnt + 12;</span>
<span class="line-removed"> 639 </span>
<span class="line-removed"> 640     /* Write the tables. */</span>
<span class="line-removed"> 641 </span>
<span class="line-removed"> 642     for ( nn = 0; nn &lt; woff.num_tables; nn++ )</span>
<span class="line-removed"> 643     {</span>
<span class="line-removed"> 644       WOFF_Table  table = tables + nn;</span>
<span class="line-removed"> 645 </span>
<span class="line-removed"> 646 </span>
<span class="line-removed"> 647       /* Write SFNT table entry. */</span>
<span class="line-removed"> 648       WRITE_ULONG( sfnt_header, table-&gt;Tag );</span>
<span class="line-removed"> 649       WRITE_ULONG( sfnt_header, table-&gt;CheckSum );</span>
<span class="line-removed"> 650       WRITE_ULONG( sfnt_header, table-&gt;OrigOffset );</span>
<span class="line-removed"> 651       WRITE_ULONG( sfnt_header, table-&gt;OrigLength );</span>
<span class="line-removed"> 652 </span>
<span class="line-removed"> 653       /* Write table data. */</span>
<span class="line-removed"> 654       if ( FT_STREAM_SEEK( table-&gt;Offset )     ||</span>
<span class="line-removed"> 655            FT_FRAME_ENTER( table-&gt;CompLength ) )</span>
<span class="line-removed"> 656         goto Exit;</span>
<span class="line-removed"> 657 </span>
<span class="line-removed"> 658       if ( table-&gt;CompLength == table-&gt;OrigLength )</span>
<span class="line-removed"> 659       {</span>
<span class="line-removed"> 660         /* Uncompressed data; just copy. */</span>
<span class="line-removed"> 661         ft_memcpy( sfnt + table-&gt;OrigOffset,</span>
<span class="line-removed"> 662                    stream-&gt;cursor,</span>
<span class="line-removed"> 663                    table-&gt;OrigLength );</span>
<span class="line-removed"> 664       }</span>
<span class="line-removed"> 665       else</span>
<span class="line-removed"> 666       {</span>
<span class="line-removed"> 667 #ifdef FT_CONFIG_OPTION_USE_ZLIB</span>
<span class="line-removed"> 668 </span>
<span class="line-removed"> 669         /* Uncompress with zlib. */</span>
<span class="line-removed"> 670         FT_ULong  output_len = table-&gt;OrigLength;</span>
<span class="line-removed"> 671 </span>
<span class="line-removed"> 672 </span>
<span class="line-removed"> 673         error = FT_Gzip_Uncompress( memory,</span>
<span class="line-removed"> 674                                     sfnt + table-&gt;OrigOffset, &amp;output_len,</span>
<span class="line-removed"> 675                                     stream-&gt;cursor, table-&gt;CompLength );</span>
<span class="line-removed"> 676         if ( error )</span>
<span class="line-removed"> 677           goto Exit;</span>
<span class="line-removed"> 678         if ( output_len != table-&gt;OrigLength )</span>
<span class="line-removed"> 679         {</span>
<span class="line-removed"> 680           FT_ERROR(( &quot;woff_font_open: compressed table length mismatch\n&quot; ));</span>
<span class="line-removed"> 681           error = FT_THROW( Invalid_Table );</span>
<span class="line-removed"> 682           goto Exit;</span>
<span class="line-removed"> 683         }</span>
<span class="line-removed"> 684 </span>
<span class="line-removed"> 685 #else /* !FT_CONFIG_OPTION_USE_ZLIB */</span>
<span class="line-removed"> 686 </span>
<span class="line-removed"> 687         error = FT_THROW( Unimplemented_Feature );</span>
<span class="line-removed"> 688         goto Exit;</span>
<span class="line-removed"> 689 </span>
<span class="line-removed"> 690 #endif /* !FT_CONFIG_OPTION_USE_ZLIB */</span>
<span class="line-removed"> 691       }</span>
<span class="line-removed"> 692 </span>
<span class="line-removed"> 693       FT_FRAME_EXIT();</span>
<span class="line-removed"> 694 </span>
<span class="line-removed"> 695       /* We don&#39;t check whether the padding bytes in the WOFF file are     */</span>
<span class="line-removed"> 696       /* actually &#39;\0&#39;.  For the output, however, we do set them properly. */</span>
<span class="line-removed"> 697       sfnt_offset = table-&gt;OrigOffset + table-&gt;OrigLength;</span>
<span class="line-removed"> 698       while ( sfnt_offset &amp; 3 )</span>
<span class="line-removed"> 699       {</span>
<span class="line-removed"> 700         sfnt[sfnt_offset] = &#39;\0&#39;;</span>
<span class="line-removed"> 701         sfnt_offset++;</span>
<span class="line-removed"> 702       }</span>
<span class="line-removed"> 703     }</span>
<span class="line-removed"> 704 </span>
<span class="line-removed"> 705     /* Ok!  Finally ready.  Swap out stream and return. */</span>
<span class="line-removed"> 706     FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );</span>
<span class="line-removed"> 707     sfnt_stream-&gt;memory = stream-&gt;memory;</span>
<span class="line-removed"> 708     sfnt_stream-&gt;close  = sfnt_stream_close;</span>
<span class="line-removed"> 709 </span>
<span class="line-removed"> 710     FT_Stream_Free(</span>
<span class="line-removed"> 711       face-&gt;root.stream,</span>
<span class="line-removed"> 712       ( face-&gt;root.face_flags &amp; FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );</span>
<span class="line-removed"> 713 </span>
<span class="line-removed"> 714     face-&gt;root.stream = sfnt_stream;</span>
<span class="line-removed"> 715 </span>
<span class="line-removed"> 716     face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_EXTERNAL_STREAM;</span>
<span class="line-removed"> 717 </span>
<span class="line-removed"> 718   Exit:</span>
<span class="line-removed"> 719     FT_FREE( tables );</span>
<span class="line-removed"> 720     FT_FREE( indices );</span>
<span class="line-removed"> 721 </span>
<span class="line-removed"> 722     if ( error )</span>
<span class="line-removed"> 723     {</span>
<span class="line-removed"> 724       FT_FREE( sfnt );</span>
<span class="line-removed"> 725       FT_Stream_Close( sfnt_stream );</span>
<span class="line-removed"> 726       FT_FREE( sfnt_stream );</span>
<span class="line-removed"> 727     }</span>
<span class="line-removed"> 728 </span>
<span class="line-removed"> 729     return error;</span>
<span class="line-removed"> 730   }</span>
<span class="line-removed"> 731 </span>
<span class="line-removed"> 732 </span>
<span class="line-removed"> 733 #undef WRITE_USHORT</span>
<span class="line-removed"> 734 #undef WRITE_ULONG</span>
<span class="line-removed"> 735 </span>
<span class="line-removed"> 736 </span>
 737   /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */
 738   /* synthesized into a TTC with one offset table.              */
 739   static FT_Error
 740   sfnt_open_font( FT_Stream  stream,
 741                   TT_Face    face )
 742   {
 743     FT_Memory  memory = stream-&gt;memory;
 744     FT_Error   error;
 745     FT_ULong   tag, offset;
 746 
 747     static const FT_Frame_Field  ttc_header_fields[] =
 748     {
 749 #undef  FT_STRUCTURE
 750 #define FT_STRUCTURE  TTC_HeaderRec
 751 
 752       FT_FRAME_START( 8 ),
 753         FT_FRAME_LONG( version ),
 754         FT_FRAME_LONG( count   ),  /* this is ULong in the specs */
 755       FT_FRAME_END
 756     };
 757 
 758 
 759     face-&gt;ttc_header.tag     = 0;
 760     face-&gt;ttc_header.version = 0;
 761     face-&gt;ttc_header.count   = 0;
 762 
 763   retry:
 764     offset = FT_STREAM_POS();
 765 
 766     if ( FT_READ_ULONG( tag ) )
 767       return error;
 768 
 769     if ( tag == TTAG_wOFF )
 770     {
 771       FT_TRACE2(( &quot;sfnt_open_font: file is a WOFF; synthesizing SFNT\n&quot; ));
 772 
 773       if ( FT_STREAM_SEEK( offset ) )
 774         return error;
 775 
 776       error = woff_open_font( stream, face );
 777       if ( error )
 778         return error;
 779 
 780       /* Swap out stream and retry! */
 781       stream = face-&gt;root.stream;
 782       goto retry;
 783     }
 784 
 785     if ( tag != 0x00010000UL &amp;&amp;
 786          tag != TTAG_ttcf    &amp;&amp;
 787          tag != TTAG_OTTO    &amp;&amp;
 788          tag != TTAG_true    &amp;&amp;
 789          tag != TTAG_typ1    &amp;&amp;
 790          tag != TTAG_0xA5kbd &amp;&amp;
 791          tag != TTAG_0xA5lst &amp;&amp;
 792          tag != 0x00020000UL )
 793     {
 794       FT_TRACE2(( &quot;  not a font using the SFNT container format\n&quot; ));
 795       return FT_THROW( Unknown_File_Format );
 796     }
 797 
 798     face-&gt;ttc_header.tag = TTAG_ttcf;
 799 
 800     if ( tag == TTAG_ttcf )
 801     {
 802       FT_Int  n;
 803 
 804 
 805       FT_TRACE3(( &quot;sfnt_open_font: file is a collection\n&quot; ));
 806 
 807       if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &amp;face-&gt;ttc_header ) )
 808         return error;
 809 
 810       FT_TRACE3(( &quot;                with %ld subfonts\n&quot;,
 811                   face-&gt;ttc_header.count ));
 812 
 813       if ( face-&gt;ttc_header.count == 0 )
 814         return FT_THROW( Invalid_Table );
 815 
 816       /* a rough size estimate: let&#39;s conservatively assume that there   */
 817       /* is just a single table info in each subfont header (12 + 16*1 = */
 818       /* 28 bytes), thus we have (at least) `12 + 4*count&#39; bytes for the */
 819       /* size of the TTC header plus `28*count&#39; bytes for all subfont    */
 820       /* headers                                                         */
 821       if ( (FT_ULong)face-&gt;ttc_header.count &gt; stream-&gt;size / ( 28 + 4 ) )
 822         return FT_THROW( Array_Too_Large );
 823 
 824       /* now read the offsets of each font in the file */
 825       if ( FT_NEW_ARRAY( face-&gt;ttc_header.offsets, face-&gt;ttc_header.count ) )
 826         return error;
 827 
 828       if ( FT_FRAME_ENTER( face-&gt;ttc_header.count * 4L ) )
 829         return error;
 830 
 831       for ( n = 0; n &lt; face-&gt;ttc_header.count; n++ )
 832         face-&gt;ttc_header.offsets[n] = FT_GET_ULONG();
 833 
 834       FT_FRAME_EXIT();
 835     }
 836     else
 837     {
 838       FT_TRACE3(( &quot;sfnt_open_font: synthesize TTC\n&quot; ));
 839 
 840       face-&gt;ttc_header.version = 1 &lt;&lt; 16;
 841       face-&gt;ttc_header.count   = 1;
 842 
 843       if ( FT_NEW( face-&gt;ttc_header.offsets ) )
 844         return error;
 845 
 846       face-&gt;ttc_header.offsets[0] = offset;
 847     }
 848 
 849     return error;
 850   }
 851 
 852 
 853   FT_LOCAL_DEF( FT_Error )
 854   sfnt_init_face( FT_Stream      stream,
 855                   TT_Face        face,
 856                   FT_Int         face_instance_index,
 857                   FT_Int         num_params,
 858                   FT_Parameter*  params )
 859   {
 860     FT_Error      error;
 861     FT_Library    library = face-&gt;root.driver-&gt;root.library;
 862     SFNT_Service  sfnt;
 863     FT_Int        face_index;
 864 
 865 
 866     /* for now, parameters are unused */
 867     FT_UNUSED( num_params );
 868     FT_UNUSED( params );
 869 
 870 
 871     sfnt = (SFNT_Service)face-&gt;sfnt;
 872     if ( !sfnt )
 873     {
 874       sfnt = (SFNT_Service)FT_Get_Module_Interface( library, &quot;sfnt&quot; );
 875       if ( !sfnt )
 876       {
 877         FT_ERROR(( &quot;sfnt_init_face: cannot access `sfnt&#39; module\n&quot; ));
 878         return FT_THROW( Missing_Module );
 879       }
 880 
 881       face-&gt;sfnt       = sfnt;
 882       face-&gt;goto_table = sfnt-&gt;goto_table;
 883     }
 884 
 885     FT_FACE_FIND_GLOBAL_SERVICE( face, face-&gt;psnames, POSTSCRIPT_CMAPS );
 886 
 887 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 888     if ( !face-&gt;mm )
 889     {
 890       /* we want the MM interface from the `truetype&#39; module only */
 891       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 892 
 893 
 894       face-&gt;mm = ft_module_get_service( tt_module,
 895                                         FT_SERVICE_ID_MULTI_MASTERS,
 896                                         0 );
 897     }
 898 
 899     if ( !face-&gt;var )
 900     {
 901       /* we want the metrics variations interface */
 902       /* from the `truetype&#39; module only          */
 903       FT_Module  tt_module = FT_Get_Module( library, &quot;truetype&quot; );
 904 
 905 
 906       face-&gt;var = ft_module_get_service( tt_module,
 907                                          FT_SERVICE_ID_METRICS_VARIATIONS,
 908                                          0 );
 909     }
 910 #endif
 911 
 912     FT_TRACE2(( &quot;SFNT driver\n&quot; ));
 913 
 914     error = sfnt_open_font( stream, face );
 915     if ( error )
 916       return error;
 917 
 918     /* Stream may have changed in sfnt_open_font. */
 919     stream = face-&gt;root.stream;
 920 
<a name="7" id="anc7"></a><span class="line-modified"> 921     FT_TRACE2(( &quot;sfnt_init_face: %08p, %d\n&quot;, face, face_instance_index ));</span>


 922 
 923     face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;
 924 
 925     /* value -(N+1) requests information on index N */
 926     if ( face_instance_index &lt; 0 )
 927       face_index--;
 928 
 929     if ( face_index &gt;= face-&gt;ttc_header.count )
 930     {
 931       if ( face_instance_index &gt;= 0 )
 932         return FT_THROW( Invalid_Argument );
 933       else
 934         face_index = 0;
 935     }
 936 
 937     if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )
 938       return error;
 939 
 940     /* check whether we have a valid TrueType file */
 941     error = sfnt-&gt;load_font_dir( face, stream );
 942     if ( error )
 943       return error;
 944 
 945 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 946     {
 947       FT_Memory  memory = face-&gt;root.memory;
 948 
 949       FT_ULong  fvar_len;
 950 
 951       FT_ULong  version;
 952       FT_ULong  offset;
 953 
 954       FT_UShort  num_axes;
 955       FT_UShort  axis_size;
 956       FT_UShort  num_instances;
 957       FT_UShort  instance_size;
 958 
 959       FT_Int  instance_index;
 960 
 961       FT_Byte*  default_values  = NULL;
 962       FT_Byte*  instance_values = NULL;
 963 
 964 
 965       instance_index = FT_ABS( face_instance_index ) &gt;&gt; 16;
 966 
 967       /* test whether current face is a GX font with named instances */
 968       if ( face-&gt;goto_table( face, TTAG_fvar, stream, &amp;fvar_len ) ||
 969            fvar_len &lt; 20                                          ||
 970            FT_READ_ULONG( version )                               ||
 971            FT_READ_USHORT( offset )                               ||
 972            FT_STREAM_SKIP( 2 ) /* reserved */                     ||
 973            FT_READ_USHORT( num_axes )                             ||
 974            FT_READ_USHORT( axis_size )                            ||
 975            FT_READ_USHORT( num_instances )                        ||
 976            FT_READ_USHORT( instance_size )                        )
 977       {
 978         version       = 0;
 979         offset        = 0;
 980         num_axes      = 0;
 981         axis_size     = 0;
 982         num_instances = 0;
 983         instance_size = 0;
 984       }
 985 
 986       /* check that the data is bound by the table length */
 987       if ( version != 0x00010000UL                    ||
 988            axis_size != 20                            ||
 989            num_axes == 0                              ||
 990            /* `num_axes&#39; limit implied by 16-bit `instance_size&#39; */
 991            num_axes &gt; 0x3FFE                          ||
 992            !( instance_size == 4 + 4 * num_axes ||
 993               instance_size == 6 + 4 * num_axes )     ||
 994            /* `num_instances&#39; limit implied by limited range of name IDs */
 995            num_instances &gt; 0x7EFF                     ||
 996            offset                          +
 997              axis_size * num_axes          +
 998              instance_size * num_instances &gt; fvar_len )
 999         num_instances = 0;
1000       else
1001         face-&gt;variation_support |= TT_FACE_FLAG_VAR_FVAR;
1002 
1003       /*
<a name="8" id="anc8"></a><span class="line-modified">1004        *  As documented in the OpenType specification, an entry for the</span>
<span class="line-modified">1005        *  default instance may be omitted in the named instance table.  In</span>
<span class="line-modified">1006        *  particular this means that even if there is no named instance</span>
<span class="line-modified">1007        *  table in the font we actually do have a named instance, namely the</span>
<span class="line-modified">1008        *  default instance.</span>
1009        *
<a name="9" id="anc9"></a><span class="line-modified">1010        *  For consistency, we always want the default instance in our list</span>
<span class="line-modified">1011        *  of named instances.  If it is missing, we try to synthesize it</span>
<span class="line-modified">1012        *  later on.  Here, we have to adjust `num_instances&#39; accordingly.</span>
1013        */
1014 
1015       if ( ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR ) &amp;&amp;
1016            !( FT_ALLOC( default_values, num_axes * 4 )  ||
1017               FT_ALLOC( instance_values, num_axes * 4 ) )      )
1018       {
1019         /* the current stream position is 16 bytes after the table start */
1020         FT_ULong  array_start = FT_STREAM_POS() - 16 + offset;
1021         FT_ULong  default_value_offset, instance_offset;
1022 
1023         FT_Byte*  p;
1024         FT_UInt   i;
1025 
1026 
1027         default_value_offset = array_start + 8;
1028         p                    = default_values;
1029 
1030         for ( i = 0; i &lt; num_axes; i++ )
1031         {
1032           (void)FT_STREAM_READ_AT( default_value_offset, p, 4 );
1033 
1034           default_value_offset += axis_size;
1035           p                    += 4;
1036         }
1037 
1038         instance_offset = array_start + axis_size * num_axes + 4;
1039 
1040         for ( i = 0; i &lt; num_instances; i++ )
1041         {
1042           (void)FT_STREAM_READ_AT( instance_offset,
1043                                    instance_values,
1044                                    num_axes * 4 );
1045 
1046           if ( !ft_memcmp( default_values, instance_values, num_axes * 4 ) )
1047             break;
1048 
1049           instance_offset += instance_size;
1050         }
1051 
1052         if ( i == num_instances )
1053         {
1054           /* no default instance in named instance table; */
1055           /* we thus have to synthesize it                */
1056           num_instances++;
1057         }
1058       }
1059 
1060       FT_FREE( default_values );
1061       FT_FREE( instance_values );
1062 
1063       /* we don&#39;t support Multiple Master CFFs yet; */
1064       /* note that `glyf&#39; or `CFF2&#39; have precedence */
1065       if ( face-&gt;goto_table( face, TTAG_glyf, stream, 0 ) &amp;&amp;
1066            face-&gt;goto_table( face, TTAG_CFF2, stream, 0 ) &amp;&amp;
1067            !face-&gt;goto_table( face, TTAG_CFF, stream, 0 ) )
1068         num_instances = 0;
1069 
1070       /* instance indices in `face_instance_index&#39; start with index 1, */
1071       /* thus `&gt;&#39; and not `&gt;=&#39;                                         */
1072       if ( instance_index &gt; num_instances )
1073       {
1074         if ( face_instance_index &gt;= 0 )
1075           return FT_THROW( Invalid_Argument );
1076         else
1077           num_instances = 0;
1078       }
1079 
1080       face-&gt;root.style_flags = (FT_Long)num_instances &lt;&lt; 16;
1081     }
1082 #endif
1083 
1084     face-&gt;root.num_faces  = face-&gt;ttc_header.count;
1085     face-&gt;root.face_index = face_instance_index;
1086 
1087     return error;
1088   }
1089 
1090 
1091 #define LOAD_( x )                                          \
1092   do                                                        \
1093   {                                                         \
1094     FT_TRACE2(( &quot;`&quot; #x &quot;&#39; &quot; ));                             \
1095     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
1096                                                             \
1097     error = sfnt-&gt;load_ ## x( face, stream );               \
1098                                                             \
1099     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
1100                         ? &quot;loaded&quot;                          \
1101                         : FT_ERR_EQ( error, Table_Missing ) \
1102                           ? &quot;missing&quot;                       \
1103                           : &quot;failed to load&quot; ));            \
1104     FT_TRACE3(( &quot;\n&quot; ));                                    \
1105   } while ( 0 )
1106 
1107 #define LOADM_( x, vertical )                               \
1108   do                                                        \
1109   {                                                         \
1110     FT_TRACE2(( &quot;`%s&quot; #x &quot;&#39; &quot;,                              \
1111                 vertical ? &quot;vertical &quot; : &quot;&quot; ));             \
1112     FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \
1113                                                             \
1114     error = sfnt-&gt;load_ ## x( face, stream, vertical );     \
1115                                                             \
1116     FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \
1117                         ? &quot;loaded&quot;                          \
1118                         : FT_ERR_EQ( error, Table_Missing ) \
1119                           ? &quot;missing&quot;                       \
1120                           : &quot;failed to load&quot; ));            \
1121     FT_TRACE3(( &quot;\n&quot; ));                                    \
1122   } while ( 0 )
1123 
1124 #define GET_NAME( id, field )                                   \
1125   do                                                            \
1126   {                                                             \
1127     error = tt_face_get_name( face, TT_NAME_ID_ ## id, field ); \
1128     if ( error )                                                \
1129       goto Exit;                                                \
1130   } while ( 0 )
1131 
1132 
1133   FT_LOCAL_DEF( FT_Error )
1134   sfnt_load_face( FT_Stream      stream,
1135                   TT_Face        face,
1136                   FT_Int         face_instance_index,
1137                   FT_Int         num_params,
1138                   FT_Parameter*  params )
1139   {
1140     FT_Error      error;
1141 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1142     FT_Error      psnames_error;
1143 #endif
1144     FT_Bool       has_outline;
1145     FT_Bool       is_apple_sbit;
1146     FT_Bool       is_apple_sbix;
1147     FT_Bool       has_CBLC;
1148     FT_Bool       has_CBDT;
1149     FT_Bool       ignore_typographic_family    = FALSE;
1150     FT_Bool       ignore_typographic_subfamily = FALSE;
1151 
1152     SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;
1153 
1154     FT_UNUSED( face_instance_index );
1155 
1156 
1157     /* Check parameters */
1158 
1159     {
1160       FT_Int  i;
1161 
1162 
1163       for ( i = 0; i &lt; num_params; i++ )
1164       {
1165         if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_FAMILY )
1166           ignore_typographic_family = TRUE;
1167         else if ( params[i].tag == FT_PARAM_TAG_IGNORE_TYPOGRAPHIC_SUBFAMILY )
1168           ignore_typographic_subfamily = TRUE;
1169       }
1170     }
1171 
1172     /* Load tables */
1173 
1174     /* We now support two SFNT-based bitmapped font formats.  They */
1175     /* are recognized easily as they do not include a `glyf&#39;       */
1176     /* table.                                                      */
1177     /*                                                             */
1178     /* The first format comes from Apple, and uses a table named   */
1179     /* `bhed&#39; instead of `head&#39; to store the font header (using    */
1180     /* the same format).  It also doesn&#39;t include horizontal and   */
1181     /* vertical metrics tables (i.e. `hhea&#39; and `vhea&#39; tables are  */
1182     /* missing).                                                   */
1183     /*                                                             */
1184     /* The other format comes from Microsoft, and is used with     */
1185     /* WinCE/PocketPC.  It looks like a standard TTF, except that  */
1186     /* it doesn&#39;t contain outlines.                                */
1187     /*                                                             */
1188 
1189     FT_TRACE2(( &quot;sfnt_load_face: %08p\n\n&quot;, face ));
1190 
1191     /* do we have outlines in there? */
1192 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1193     has_outline = FT_BOOL( face-&gt;root.internal-&gt;incremental_interface ||
1194                            tt_face_lookup_table( face, TTAG_glyf )    ||
1195                            tt_face_lookup_table( face, TTAG_CFF )     ||
1196                            tt_face_lookup_table( face, TTAG_CFF2 )    );
1197 #else
1198     has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) ||
1199                            tt_face_lookup_table( face, TTAG_CFF )  ||
1200                            tt_face_lookup_table( face, TTAG_CFF2 ) );
1201 #endif
1202 
1203     is_apple_sbit = 0;
1204     is_apple_sbix = !face-&gt;goto_table( face, TTAG_sbix, stream, 0 );
1205 
1206     /* Apple &#39;sbix&#39; color bitmaps are rendered scaled and then the &#39;glyf&#39;
1207      * outline rendered on top.  We don&#39;t support that yet, so just ignore
1208      * the &#39;glyf&#39; outline and advertise it as a bitmap-only font. */
1209     if ( is_apple_sbix )
1210       has_outline = FALSE;
1211 
1212     /* if this font doesn&#39;t contain outlines, we try to load */
1213     /* a `bhed&#39; table                                        */
1214     if ( !has_outline &amp;&amp; sfnt-&gt;load_bhed )
1215     {
1216       LOAD_( bhed );
1217       is_apple_sbit = FT_BOOL( !error );
1218     }
1219 
1220     /* load the font header (`head&#39; table) if this isn&#39;t an Apple */
1221     /* sbit font file                                             */
1222     if ( !is_apple_sbit || is_apple_sbix )
1223     {
1224       LOAD_( head );
1225       if ( error )
1226         goto Exit;
1227     }
1228 
1229     has_CBLC = !face-&gt;goto_table( face, TTAG_CBLC, stream, 0 );
1230     has_CBDT = !face-&gt;goto_table( face, TTAG_CBDT, stream, 0 );
1231 
1232     /* Ignore outlines for CBLC/CBDT fonts. */
1233     if ( has_CBLC || has_CBDT )
1234       has_outline = FALSE;
1235 
1236     /* OpenType 1.8.2 introduced limits to this value;    */
1237     /* however, they make sense for older SFNT fonts also */
1238     if ( face-&gt;header.Units_Per_EM &lt;    16 ||
1239          face-&gt;header.Units_Per_EM &gt; 16384 )
1240     {
1241       error = FT_THROW( Invalid_Table );
1242 
1243       goto Exit;
1244     }
1245 
1246     /* the following tables are often not present in embedded TrueType */
1247     /* fonts within PDF documents, so don&#39;t check for them.            */
1248     LOAD_( maxp );
1249     LOAD_( cmap );
1250 
1251     /* the following tables are optional in PCL fonts -- */
1252     /* don&#39;t check for errors                            */
1253     LOAD_( name );
1254     LOAD_( post );
1255 
1256 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1257     psnames_error = error;
1258 #endif
1259 
1260     /* do not load the metrics headers and tables if this is an Apple */
1261     /* sbit font file                                                 */
1262     if ( !is_apple_sbit )
1263     {
1264       /* load the `hhea&#39; and `hmtx&#39; tables */
1265       LOADM_( hhea, 0 );
1266       if ( !error )
1267       {
1268         LOADM_( hmtx, 0 );
1269         if ( FT_ERR_EQ( error, Table_Missing ) )
1270         {
1271           error = FT_THROW( Hmtx_Table_Missing );
1272 
1273 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1274           /* If this is an incrementally loaded font and there are */
1275           /* overriding metrics, tolerate a missing `hmtx&#39; table.  */
1276           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
1277                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
1278                  get_glyph_metrics                                 )
1279           {
1280             face-&gt;horizontal.number_Of_HMetrics = 0;
1281             error                               = FT_Err_Ok;
1282           }
1283 #endif
1284         }
1285       }
1286       else if ( FT_ERR_EQ( error, Table_Missing ) )
1287       {
1288         /* No `hhea&#39; table necessary for SFNT Mac fonts. */
1289         if ( face-&gt;format_tag == TTAG_true )
1290         {
1291           FT_TRACE2(( &quot;This is an SFNT Mac font.\n&quot; ));
1292 
1293           has_outline = 0;
1294           error       = FT_Err_Ok;
1295         }
1296         else
1297         {
1298           error = FT_THROW( Horiz_Header_Missing );
1299 
1300 #ifdef FT_CONFIG_OPTION_INCREMENTAL
1301           /* If this is an incrementally loaded font and there are */
1302           /* overriding metrics, tolerate a missing `hhea&#39; table.  */
1303           if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;
1304                face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;
1305                  get_glyph_metrics                                 )
1306           {
1307             face-&gt;horizontal.number_Of_HMetrics = 0;
1308             error                               = FT_Err_Ok;
1309           }
1310 #endif
1311 
1312         }
1313       }
1314 
1315       if ( error )
1316         goto Exit;
1317 
1318       /* try to load the `vhea&#39; and `vmtx&#39; tables */
1319       LOADM_( hhea, 1 );
1320       if ( !error )
1321       {
1322         LOADM_( hmtx, 1 );
1323         if ( !error )
1324           face-&gt;vertical_info = 1;
1325       }
1326 
1327       if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )
1328         goto Exit;
1329 
1330       LOAD_( os2 );
1331       if ( error )
1332       {
1333         /* we treat the table as missing if there are any errors */
1334         face-&gt;os2.version = 0xFFFFU;
1335       }
1336     }
1337 
1338     /* the optional tables */
1339 
1340     /* embedded bitmap support */
1341     if ( sfnt-&gt;load_eblc )
1342       LOAD_( eblc );
1343 
<a name="10" id="anc10"></a>






1344     /* consider the pclt, kerning, and gasp tables as optional */
1345     LOAD_( pclt );
1346     LOAD_( gasp );
1347     LOAD_( kern );
1348 
1349     face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;
1350 
1351     /* Bit 8 of the `fsSelection&#39; field in the `OS/2&#39; table denotes  */
1352     /* a WWS-only font face.  `WWS&#39; stands for `weight&#39;, width&#39;, and */
1353     /* `slope&#39;, a term used by Microsoft&#39;s Windows Presentation      */
1354     /* Foundation (WPF).  This flag has been introduced in version   */
1355     /* 1.5 of the OpenType specification (May 2008).                 */
1356 
1357     face-&gt;root.family_name = NULL;
1358     face-&gt;root.style_name  = NULL;
1359     if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )
1360     {
1361       if ( !ignore_typographic_family )
1362         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1363       if ( !face-&gt;root.family_name )
1364         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
1365 
1366       if ( !ignore_typographic_subfamily )
1367         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
1368       if ( !face-&gt;root.style_name )
1369         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
1370     }
1371     else
1372     {
1373       GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );
1374       if ( !face-&gt;root.family_name &amp;&amp; !ignore_typographic_family )
1375         GET_NAME( TYPOGRAPHIC_FAMILY, &amp;face-&gt;root.family_name );
1376       if ( !face-&gt;root.family_name )
1377         GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );
1378 
1379       GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );
1380       if ( !face-&gt;root.style_name &amp;&amp; !ignore_typographic_subfamily )
1381         GET_NAME( TYPOGRAPHIC_SUBFAMILY, &amp;face-&gt;root.style_name );
1382       if ( !face-&gt;root.style_name )
1383         GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );
1384     }
1385 
1386     /* now set up root fields */
1387     {
1388       FT_Face  root  = &amp;face-&gt;root;
1389       FT_Long  flags = root-&gt;face_flags;
1390 
1391 
<a name="11" id="anc11"></a><span class="line-modified">1392       /*********************************************************************/</span>
<span class="line-modified">1393       /*                                                                   */</span>
<span class="line-modified">1394       /* Compute face flags.                                               */</span>
<span class="line-modified">1395       /*                                                                   */</span>
1396       if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
<a name="12" id="anc12"></a><span class="line-modified">1397            face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )</span>

1398         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
1399 
1400       if ( has_outline == TRUE )
1401         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
1402 
1403       /* The sfnt driver only supports bitmap fonts natively, thus we */
1404       /* don&#39;t set FT_FACE_FLAG_HINTER.                               */
1405       flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */
1406                FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */
1407 
1408 #ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES
1409       if ( !psnames_error                             &amp;&amp;
1410            face-&gt;postscript.FormatType != 0x00030000L )
1411         flags |= FT_FACE_FLAG_GLYPH_NAMES;
1412 #endif
1413 
1414       /* fixed width font? */
1415       if ( face-&gt;postscript.isFixedPitch )
1416         flags |= FT_FACE_FLAG_FIXED_WIDTH;
1417 
1418       /* vertical information? */
1419       if ( face-&gt;vertical_info )
1420         flags |= FT_FACE_FLAG_VERTICAL;
1421 
1422       /* kerning available ? */
1423       if ( TT_FACE_HAS_KERNING( face ) )
1424         flags |= FT_FACE_FLAG_KERNING;
1425 
1426 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
1427       /* Don&#39;t bother to load the tables unless somebody asks for them. */
1428       /* No need to do work which will (probably) not be used.          */
1429       if ( face-&gt;variation_support &amp; TT_FACE_FLAG_VAR_FVAR )
1430       {
1431         if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;
1432              tt_face_lookup_table( face, TTAG_gvar ) != 0 )
1433           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1434         if ( tt_face_lookup_table( face, TTAG_CFF2 ) != 0 )
1435           flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;
1436       }
1437 #endif
1438 
1439       root-&gt;face_flags = flags;
1440 
<a name="13" id="anc13"></a><span class="line-modified">1441       /*********************************************************************/</span>
<span class="line-modified">1442       /*                                                                   */</span>
<span class="line-modified">1443       /* Compute style flags.                                              */</span>
<span class="line-modified">1444       /*                                                                   */</span>
1445 
1446       flags = 0;
1447       if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )
1448       {
1449         /* We have an OS/2 table; use the `fsSelection&#39; field.  Bit 9 */
1450         /* indicates an oblique font face.  This flag has been        */
1451         /* introduced in version 1.5 of the OpenType specification.   */
1452 
1453         if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */
1454           flags |= FT_STYLE_FLAG_ITALIC;
1455         else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */
1456           flags |= FT_STYLE_FLAG_ITALIC;
1457 
1458         if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */
1459           flags |= FT_STYLE_FLAG_BOLD;
1460       }
1461       else
1462       {
1463         /* this is an old Mac font, use the header field */
1464 
1465         if ( face-&gt;header.Mac_Style &amp; 1 )
1466           flags |= FT_STYLE_FLAG_BOLD;
1467 
1468         if ( face-&gt;header.Mac_Style &amp; 2 )
1469           flags |= FT_STYLE_FLAG_ITALIC;
1470       }
1471 
1472       root-&gt;style_flags |= flags;
1473 
<a name="14" id="anc14"></a><span class="line-modified">1474       /*********************************************************************/</span>
<span class="line-modified">1475       /*                                                                   */</span>
<span class="line-modified">1476       /* Polish the charmaps.                                              */</span>
<span class="line-modified">1477       /*                                                                   */</span>
<span class="line-modified">1478       /*   Try to set the charmap encoding according to the platform &amp;     */</span>
<span class="line-modified">1479       /*   encoding ID of each charmap.  Emulate Unicode charmap if one    */</span>
<span class="line-modified">1480       /*   is missing.                                                     */</span>
<span class="line-modified">1481       /*                                                                   */</span>
1482 
1483       tt_face_build_cmaps( face );  /* ignore errors */
1484 
1485 
1486       /* set the encoding fields */
1487       {
1488         FT_Int   m;
1489 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1490         FT_Bool  has_unicode = FALSE;
1491 #endif
1492 
1493 
1494         for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )
1495         {
1496           FT_CharMap  charmap = root-&gt;charmaps[m];
1497 
1498 
1499           charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,
1500                                                   charmap-&gt;encoding_id );
1501 
1502 #ifdef FT_CONFIG_OPTION_POSTSCRIPT_NAMES
1503 
1504           if ( charmap-&gt;encoding == FT_ENCODING_UNICODE   ||
1505                charmap-&gt;encoding == FT_ENCODING_MS_SYMBOL )  /* PUA */
1506             has_unicode = TRUE;
1507         }
1508 
1509         /* synthesize Unicode charmap if one is missing */
1510         if ( !has_unicode )
1511         {
1512           FT_CharMapRec cmaprec;
1513 
1514 
1515           cmaprec.face        = root;
1516           cmaprec.platform_id = TT_PLATFORM_MICROSOFT;
1517           cmaprec.encoding_id = TT_MS_ID_UNICODE_CS;
1518           cmaprec.encoding    = FT_ENCODING_UNICODE;
1519 
1520 
1521           error = FT_CMap_New( (FT_CMap_Class)&amp;tt_cmap_unicode_class_rec,
1522                                NULL, &amp;cmaprec, NULL );
1523           if ( error                                      &amp;&amp;
<a name="15" id="anc15"></a><span class="line-modified">1524                FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )</span>

1525             goto Exit;
1526           error = FT_Err_Ok;
1527 
1528 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
1529 
1530         }
1531       }
1532 
1533 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
1534 
1535       /*
<a name="16" id="anc16"></a><span class="line-modified">1536        *  Now allocate the root array of FT_Bitmap_Size records and</span>
<span class="line-modified">1537        *  populate them.  Unfortunately, it isn&#39;t possible to indicate bit</span>
<span class="line-modified">1538        *  depths in the FT_Bitmap_Size record.  This is a design error.</span>
1539        */
1540       {
1541         FT_UInt  count;
1542 
1543 
1544         count = face-&gt;sbit_num_strikes;
1545 
1546         if ( count &gt; 0 )
1547         {
1548           FT_Memory        memory   = face-&gt;root.stream-&gt;memory;
1549           FT_UShort        em_size  = face-&gt;header.Units_Per_EM;
1550           FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;
1551           FT_Size_Metrics  metrics;
1552 
1553           FT_UInt*  sbit_strike_map = NULL;
1554           FT_UInt   strike_idx, bsize_idx;
1555 
1556 
1557           if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )
1558           {
1559             avgwidth = 1;
1560             em_size = 1;
1561           }
1562 
1563           /* to avoid invalid strike data in the `available_sizes&#39; field */
1564           /* of `FT_Face&#39;, we map `available_sizes&#39; indices to strike    */
1565           /* indices                                                     */
1566           if ( FT_NEW_ARRAY( root-&gt;available_sizes, count ) ||
1567                FT_NEW_ARRAY( sbit_strike_map, count ) )
1568             goto Exit;
1569 
1570           bsize_idx = 0;
1571           for ( strike_idx = 0; strike_idx &lt; count; strike_idx++ )
1572           {
1573             FT_Bitmap_Size*  bsize = root-&gt;available_sizes + bsize_idx;
1574 
1575 
1576             error = sfnt-&gt;load_strike_metrics( face, strike_idx, &amp;metrics );
1577             if ( error )
1578               continue;
1579 
1580             bsize-&gt;height = (FT_Short)( metrics.height &gt;&gt; 6 );
1581             bsize-&gt;width  = (FT_Short)(
1582               ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );
1583 
1584             bsize-&gt;x_ppem = metrics.x_ppem &lt;&lt; 6;
1585             bsize-&gt;y_ppem = metrics.y_ppem &lt;&lt; 6;
1586 
1587             /* assume 72dpi */
1588             bsize-&gt;size   = metrics.y_ppem &lt;&lt; 6;
1589 
1590             /* only use strikes with valid PPEM values */
1591             if ( bsize-&gt;x_ppem &amp;&amp; bsize-&gt;y_ppem )
1592               sbit_strike_map[bsize_idx++] = strike_idx;
1593           }
1594 
1595           /* reduce array size to the actually used elements */
1596           (void)FT_RENEW_ARRAY( sbit_strike_map, count, bsize_idx );
1597 
1598           /* from now on, all strike indices are mapped */
1599           /* using `sbit_strike_map&#39;                    */
1600           if ( bsize_idx )
1601           {
1602             face-&gt;sbit_strike_map = sbit_strike_map;
1603 
1604             root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;
1605             root-&gt;num_fixed_sizes = (FT_Int)bsize_idx;
1606           }
1607         }
1608       }
1609 
1610 #endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */
1611 
1612       /* a font with no bitmaps and no outlines is scalable; */
1613       /* it has only empty glyphs then                       */
1614       if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )
1615         root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;
1616 
1617 
<a name="17" id="anc17"></a><span class="line-modified">1618       /*********************************************************************/</span>
<span class="line-modified">1619       /*                                                                   */</span>
<span class="line-modified">1620       /*  Set up metrics.                                                  */</span>
<span class="line-modified">1621       /*                                                                   */</span>
1622       if ( FT_IS_SCALABLE( root ) )
1623       {
1624         /* XXX What about if outline header is missing */
1625         /*     (e.g. sfnt wrapped bitmap)?             */
1626         root-&gt;bbox.xMin    = face-&gt;header.xMin;
1627         root-&gt;bbox.yMin    = face-&gt;header.yMin;
1628         root-&gt;bbox.xMax    = face-&gt;header.xMax;
1629         root-&gt;bbox.yMax    = face-&gt;header.yMax;
1630         root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;
1631 
1632 
<a name="18" id="anc18"></a><span class="line-modified">1633         /* XXX: Computing the ascender/descender/height is very different */</span>
<span class="line-modified">1634         /*      from what the specification tells you.  Apparently, we    */</span>
<span class="line-modified">1635         /*      must be careful because                                   */</span>
<span class="line-modified">1636         /*                                                                */</span>
<span class="line-modified">1637         /*      - not all fonts have an OS/2 table; in this case, we take */</span>
<span class="line-modified">1638         /*        the values in the horizontal header.  However, these    */</span>
<span class="line-modified">1639         /*        values very often are not reliable.                     */</span>
<span class="line-modified">1640         /*                                                                */</span>
<span class="line-modified">1641         /*      - otherwise, the correct typographic values are in the    */</span>
<span class="line-modified">1642         /*        sTypoAscender, sTypoDescender &amp; sTypoLineGap fields.    */</span>
<span class="line-modified">1643         /*                                                                */</span>
<span class="line-modified">1644         /*        However, certain fonts have these fields set to 0.      */</span>
<span class="line-modified">1645         /*        Rather, they have usWinAscent &amp; usWinDescent correctly  */</span>
<span class="line-modified">1646         /*        set (but with different values).                        */</span>
<span class="line-modified">1647         /*                                                                */</span>
<span class="line-modified">1648         /*      As an example, Arial Narrow is implemented through four   */</span>
<span class="line-modified">1649         /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF &amp; ARIALNBI.TTF */</span>
<span class="line-modified">1650         /*                                                                */</span>
<span class="line-modified">1651         /*      Strangely, all fonts have the same values in their        */</span>
<span class="line-modified">1652         /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */</span>
<span class="line-modified">1653         /*                                                                */</span>
<span class="line-modified">1654         /*      On the other hand, they all have different                */</span>
<span class="line-modified">1655         /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */</span>
<span class="line-modified">1656         /*      table cannot be used to compute the text height reliably! */</span>
<span class="line-modified">1657         /*                                                                */</span>
<span class="line-modified">1658 </span>
<span class="line-modified">1659         /* The ascender and descender are taken from the `hhea&#39; table. */</span>
<span class="line-modified">1660         /* If zero, they are taken from the `OS/2&#39; table.              */</span>
<span class="line-modified">1661 </span>
<span class="line-modified">1662         root-&gt;ascender  = face-&gt;horizontal.Ascender;</span>
<span class="line-modified">1663         root-&gt;descender = face-&gt;horizontal.Descender;</span>
<span class="line-modified">1664 </span>
<span class="line-modified">1665         root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1666                        face-&gt;horizontal.Line_Gap;</span>
<span class="line-modified">1667 </span>
<span class="line-modified">1668         if ( !( root-&gt;ascender || root-&gt;descender ) )</span>

1669         {
<a name="19" id="anc19"></a><span class="line-modified">1670           if ( face-&gt;os2.version != 0xFFFFU )</span>
<span class="line-modified">1671           {</span>
<span class="line-modified">1672             if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</span>
<span class="line-modified">1673             {</span>
<span class="line-modified">1674               root-&gt;ascender  = face-&gt;os2.sTypoAscender;</span>
<span class="line-modified">1675               root-&gt;descender = face-&gt;os2.sTypoDescender;</span>





1676 
<a name="20" id="anc20"></a><span class="line-modified">1677               root-&gt;height = root-&gt;ascender - root-&gt;descender +</span>
<span class="line-modified">1678                              face-&gt;os2.sTypoLineGap;</span>
<span class="line-modified">1679             }</span>
<span class="line-removed">1680             else</span>
1681             {
<a name="21" id="anc21"></a><span class="line-modified">1682               root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</span>
<span class="line-modified">1683               root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</span>
<span class="line-modified">1684 </span>
<span class="line-modified">1685               root-&gt;height = root-&gt;ascender - root-&gt;descender;</span>









1686             }
1687           }
1688         }
1689 
1690         root-&gt;max_advance_width  =
1691           (FT_Short)face-&gt;horizontal.advance_Width_Max;
1692         root-&gt;max_advance_height =
1693           (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max
1694                                           : root-&gt;height );
1695 
1696         /* See https://www.microsoft.com/typography/otspec/post.htm -- */
1697         /* Adjust underline position from top edge to centre of        */
1698         /* stroke to convert TrueType meaning to FreeType meaning.     */
1699         root-&gt;underline_position  = face-&gt;postscript.underlinePosition -
1700                                     face-&gt;postscript.underlineThickness / 2;
1701         root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;
1702       }
1703 
1704     }
1705 
1706   Exit:
1707     FT_TRACE2(( &quot;sfnt_load_face: done\n&quot; ));
1708 
1709     return error;
1710   }
1711 
1712 
1713 #undef LOAD_
1714 #undef LOADM_
1715 #undef GET_NAME
1716 
1717 
1718   FT_LOCAL_DEF( void )
1719   sfnt_done_face( TT_Face  face )
1720   {
1721     FT_Memory     memory;
1722     SFNT_Service  sfnt;
1723 
1724 
1725     if ( !face )
1726       return;
1727 
1728     memory = face-&gt;root.memory;
1729     sfnt   = (SFNT_Service)face-&gt;sfnt;
1730 
1731     if ( sfnt )
1732     {
1733       /* destroy the postscript names table if it is loaded */
1734       if ( sfnt-&gt;free_psnames )
1735         sfnt-&gt;free_psnames( face );
1736 
1737       /* destroy the embedded bitmaps table if it is loaded */
1738       if ( sfnt-&gt;free_eblc )
1739         sfnt-&gt;free_eblc( face );
<a name="22" id="anc22"></a>






1740     }
1741 
1742 #ifdef TT_CONFIG_OPTION_BDF
1743     /* freeing the embedded BDF properties */
1744     tt_face_free_bdf_props( face );
1745 #endif
1746 
1747     /* freeing the kerning table */
1748     tt_face_done_kern( face );
1749 
1750     /* freeing the collection table */
1751     FT_FREE( face-&gt;ttc_header.offsets );
1752     face-&gt;ttc_header.count = 0;
1753 
1754     /* freeing table directory */
1755     FT_FREE( face-&gt;dir_tables );
1756     face-&gt;num_tables = 0;
1757 
1758     {
1759       FT_Stream  stream = FT_FACE_STREAM( face );
1760 
1761 
1762       /* simply release the &#39;cmap&#39; table frame */
1763       FT_FRAME_RELEASE( face-&gt;cmap_table );
1764       face-&gt;cmap_size = 0;
1765     }
1766 
1767     face-&gt;horz_metrics_size = 0;
1768     face-&gt;vert_metrics_size = 0;
1769 
1770     /* freeing vertical metrics, if any */
1771     if ( face-&gt;vertical_info )
1772     {
1773       FT_FREE( face-&gt;vertical.long_metrics  );
1774       FT_FREE( face-&gt;vertical.short_metrics );
1775       face-&gt;vertical_info = 0;
1776     }
1777 
1778     /* freeing the gasp table */
1779     FT_FREE( face-&gt;gasp.gaspRanges );
1780     face-&gt;gasp.numRanges = 0;
1781 
1782     /* freeing the name table */
1783     if ( sfnt )
1784       sfnt-&gt;free_name( face );
1785 
1786     /* freeing family and style name */
1787     FT_FREE( face-&gt;root.family_name );
1788     FT_FREE( face-&gt;root.style_name );
1789 
1790     /* freeing sbit size table */
1791     FT_FREE( face-&gt;root.available_sizes );
1792     FT_FREE( face-&gt;sbit_strike_map );
1793     face-&gt;root.num_fixed_sizes = 0;
1794 
<a name="23" id="anc23"></a><span class="line-removed">1795 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</span>
1796     FT_FREE( face-&gt;postscript_name );
<a name="24" id="anc24"></a>

1797     FT_FREE( face-&gt;var_postscript_prefix );
1798 #endif
1799 
<a name="25" id="anc25"></a>





1800     face-&gt;sfnt = NULL;
1801   }
1802 
1803 
1804 /* END */
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
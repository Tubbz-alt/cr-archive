diff a/src/java.desktop/share/native/libfreetype/src/cid/cidload.c b/src/java.desktop/share/native/libfreetype/src/cid/cidload.c
--- a/src/java.desktop/share/native/libfreetype/src/cid/cidload.c
+++ b/src/java.desktop/share/native/libfreetype/src/cid/cidload.c
@@ -1,42 +1,43 @@
-/***************************************************************************/
-/*                                                                         */
-/*  cidload.c                                                              */
-/*                                                                         */
-/*    CID-keyed Type1 font loader (body).                                  */
-/*                                                                         */
-/*  Copyright 1996-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * cidload.c
+ *
+ *   CID-keyed Type1 font loader (body).
+ *
+ * Copyright (C) 1996-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include FT_INTERNAL_DEBUG_H
 #include FT_CONFIG_CONFIG_H
 #include FT_MULTIPLE_MASTERS_H
 #include FT_INTERNAL_TYPE1_TYPES_H
+#include FT_INTERNAL_POSTSCRIPT_AUX_H
 
 #include "cidload.h"
 
 #include "ciderrs.h"
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_cidload
+#define FT_COMPONENT  cidload
 
 
   /* read a single offset */
   FT_LOCAL_DEF( FT_ULong )
   cid_get_offset( FT_Byte*  *start,
@@ -79,10 +80,12 @@
 
 
     /* if the keyword has a dedicated callback, call it */
     if ( keyword->type == T1_FIELD_TYPE_CALLBACK )
     {
+      FT_TRACE4(( "  %s", keyword->ident ));
+
       keyword->reader( (FT_Face)face, parser );
       error = parser->root.error;
       goto Exit;
     }
 
@@ -129,26 +132,31 @@
           object = (FT_Byte*)dict;
         }
       }
     }
 
+    FT_TRACE4(( "  %s", keyword->ident ));
+
     dummy_object = object;
 
     /* now, load the keyword data in the object's field(s) */
     if ( keyword->type == T1_FIELD_TYPE_INTEGER_ARRAY ||
          keyword->type == T1_FIELD_TYPE_FIXED_ARRAY   )
       error = cid_parser_load_field_table( &loader->parser, keyword,
                                            &dummy_object );
     else
       error = cid_parser_load_field( &loader->parser,
                                      keyword, &dummy_object );
+
+    FT_TRACE4(( "\n" ));
+
   Exit:
     return error;
   }
 
 
-  FT_CALLBACK_DEF( FT_Error )
+  FT_CALLBACK_DEF( void )
   cid_parse_font_matrix( CID_Face     face,
                          CID_Parser*  parser )
   {
     CID_FaceDict  dict;
     FT_Face       root = (FT_Face)&face->root;
@@ -169,18 +177,29 @@
 
       /* input is scaled by 1000 to accommodate default FontMatrix */
       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
 
       if ( result < 6 )
-        return FT_THROW( Invalid_File_Format );
+      {
+        FT_ERROR(( "cid_parse_font_matrix: not enough matrix elements\n" ));
+        goto Exit;
+      }
+
+      FT_TRACE4(( " [%f %f %f %f %f %f]\n",
+                  (double)temp[0] / 65536 / 1000,
+                  (double)temp[1] / 65536 / 1000,
+                  (double)temp[2] / 65536 / 1000,
+                  (double)temp[3] / 65536 / 1000,
+                  (double)temp[4] / 65536 / 1000,
+                  (double)temp[5] / 65536 / 1000 ));
 
       temp_scale = FT_ABS( temp[3] );
 
       if ( temp_scale == 0 )
       {
         FT_ERROR(( "cid_parse_font_matrix: invalid font matrix\n" ));
-        return FT_THROW( Invalid_File_Format );
+        goto Exit;
       }
 
       /* atypical case */
       if ( temp_scale != 0x10000L )
       {
@@ -198,20 +217,28 @@
       matrix->xx = temp[0];
       matrix->yx = temp[1];
       matrix->xy = temp[2];
       matrix->yy = temp[3];
 
+      if ( !FT_Matrix_Check( matrix ) )
+      {
+        FT_ERROR(( "t1_parse_font_matrix: invalid font matrix\n" ));
+        parser->root.error = FT_THROW( Invalid_File_Format );
+        goto Exit;
+      }
+
       /* note that the font offsets are expressed in integer font units */
       offset->x  = temp[4] >> 16;
       offset->y  = temp[5] >> 16;
     }
 
-    return FT_Err_Ok;
+  Exit:
+    return;
   }
 
 
-  FT_CALLBACK_DEF( FT_Error )
+  FT_CALLBACK_DEF( void )
   parse_fd_array( CID_Face     face,
                   CID_Parser*  parser )
   {
     CID_FaceInfo  cid    = &face->cid;
     FT_Memory     memory = face->root.memory;
@@ -222,14 +249,15 @@
 
     num_dicts = cid_parser_to_int( parser );
     if ( num_dicts < 0 )
     {
       FT_ERROR(( "parse_fd_array: invalid number of dictionaries\n" ));
-      error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
+    FT_TRACE4(( " %d\n", num_dicts ));
+
     /*
      * A single entry in the FDArray must (at least) contain the following
      * structure elements.
      *
      *   %ADOBeginFontDict              18
@@ -261,31 +289,35 @@
       if ( FT_NEW_ARRAY( cid->font_dicts, num_dicts ) )
         goto Exit;
 
       cid->num_dicts = num_dicts;
 
-      /* don't forget to set a few defaults */
+      /* set some default values (the same as for Type 1 fonts) */
       for ( n = 0; n < cid->num_dicts; n++ )
       {
         CID_FaceDict  dict = cid->font_dicts + n;
 
 
-        /* default value for lenIV */
-        dict->private_dict.lenIV = 4;
+        dict->private_dict.blue_shift       = 7;
+        dict->private_dict.blue_fuzz        = 1;
+        dict->private_dict.lenIV            = 4;
+        dict->private_dict.expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
+        dict->private_dict.blue_scale       = (FT_Fixed)(
+                                                0.039625 * 0x10000L * 1000 );
       }
     }
 
   Exit:
-    return error;
+    return;
   }
 
 
-  /* by mistake, `expansion_factor' appears both in PS_PrivateRec */
+  /* By mistake, `expansion_factor' appears both in PS_PrivateRec */
   /* and CID_FaceDictRec (both are public header files and can't  */
-  /* changed); we simply copy the value                           */
+  /* changed).  We simply copy the value.                         */
 
-  FT_CALLBACK_DEF( FT_Error )
+  FT_CALLBACK_DEF( void )
   parse_expansion_factor( CID_Face     face,
                           CID_Parser*  parser )
   {
     CID_FaceDict  dict;
 
@@ -294,13 +326,47 @@
     {
       dict = face->cid.font_dicts + parser->num_dict;
 
       dict->expansion_factor              = cid_parser_to_fixed( parser, 0 );
       dict->private_dict.expansion_factor = dict->expansion_factor;
+
+      FT_TRACE4(( "%d\n", dict->expansion_factor ));
+    }
+
+    return;
+  }
+
+
+  /* By mistake, `CID_FaceDictRec' doesn't contain a field for the */
+  /* `FontName' keyword.  FreeType doesn't need it, but it is nice */
+  /* to catch it for producing better trace output.                */
+
+  FT_CALLBACK_DEF( void )
+  parse_font_name( CID_Face     face,
+                   CID_Parser*  parser )
+  {
+#ifdef FT_DEBUG_LEVEL_TRACE
+    if ( parser->num_dict >= 0 && parser->num_dict < face->cid.num_dicts )
+    {
+      T1_TokenRec  token;
+      FT_UInt      len;
+
+
+      cid_parser_to_token( parser, &token );
+
+      len = (FT_UInt)( token.limit - token.start );
+      if ( len )
+        FT_TRACE4(( " %.*s\n", len, token.start ));
+      else
+        FT_TRACE4(( " <no value>\n" ));
     }
+#else
+    FT_UNUSED( face );
+    FT_UNUSED( parser );
+#endif
 
-    return FT_Err_Ok;
+    return;
   }
 
 
   static
   const T1_FieldRec  cid_field_records[] =
@@ -309,10 +375,11 @@
 #include "cidtoken.h"
 
     T1_FIELD_CALLBACK( "FDArray",         parse_fd_array, 0 )
     T1_FIELD_CALLBACK( "FontMatrix",      cid_parse_font_matrix, 0 )
     T1_FIELD_CALLBACK( "ExpansionFactor", parse_expansion_factor, 0 )
+    T1_FIELD_CALLBACK( "FontName",        parse_font_name, 0 )
 
     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
   };
 
 
@@ -354,11 +421,20 @@
                ft_strncmp( (char*)cur, "%ADOBeginFontDict", 17 ) == 0 )
           {
             /* if /FDArray was found, then cid->num_dicts is > 0, and */
             /* we can start increasing parser->num_dict               */
             if ( face->cid.num_dicts > 0 )
+            {
               parser->num_dict++;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+              FT_TRACE4(( " FontDict %d", parser->num_dict ));
+              if ( parser->num_dict > face->cid.num_dicts )
+                FT_TRACE4(( " (ignored)" ));
+              FT_TRACE4(( "\n" ));
+#endif
+            }
           }
         }
 
         cur = parser->root.cursor;
         /* no error can occur in cid_parser_skip_spaces */
@@ -755,20 +831,20 @@
 
     /* sanity tests */
 
     if ( cid->fd_bytes < 0 || cid->gd_bytes < 1 )
     {
-      FT_ERROR(( "cid_parse_dict:"
+      FT_ERROR(( "cid_face_open:"
                  " Invalid `FDBytes' or `GDBytes' value\n" ));
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     /* allow at most 32bit offsets */
     if ( cid->fd_bytes > 4 || cid->gd_bytes > 4 )
     {
-      FT_ERROR(( "cid_parse_dict:"
+      FT_ERROR(( "cid_face_open:"
                  " Values of `FDBytes' or `GDBytes' larger than 4\n"
                  "               "
                  " are not supported\n" ));
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
@@ -780,58 +856,77 @@
     for ( n = 0; n < cid->num_dicts; n++ )
     {
       CID_FaceDict  dict = cid->font_dicts + n;
 
 
+      /* the upper limits are ad-hoc values */
+      if ( dict->private_dict.blue_shift > 1000 ||
+           dict->private_dict.blue_shift < 0    )
+      {
+        FT_TRACE2(( "cid_face_open:"
+                    " setting unlikely BlueShift value %d to default (7)\n",
+                    dict->private_dict.blue_shift ));
+        dict->private_dict.blue_shift = 7;
+      }
+
+      if ( dict->private_dict.blue_fuzz > 1000 ||
+           dict->private_dict.blue_fuzz < 0    )
+      {
+        FT_TRACE2(( "cid_face_open:"
+                    " setting unlikely BlueFuzz value %d to default (1)\n",
+                    dict->private_dict.blue_fuzz ));
+        dict->private_dict.blue_fuzz = 1;
+      }
+
       if ( dict->sd_bytes < 0                        ||
            ( dict->num_subrs && dict->sd_bytes < 1 ) )
       {
-        FT_ERROR(( "cid_parse_dict: Invalid `SDBytes' value\n" ));
+        FT_ERROR(( "cid_face_open: Invalid `SDBytes' value\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       if ( dict->sd_bytes > 4 )
       {
-        FT_ERROR(( "cid_parse_dict:"
+        FT_ERROR(( "cid_face_open:"
                    " Values of `SDBytes' larger than 4"
                    " are not supported\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       if ( dict->subrmap_offset > binary_length )
       {
-        FT_ERROR(( "cid_parse_dict: Invalid `SubrMapOffset' value\n" ));
+        FT_ERROR(( "cid_face_open: Invalid `SubrMapOffset' value\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
 
       /* `num_subrs' is scanned as a signed integer */
       if ( (FT_Int)dict->num_subrs < 0                                     ||
            ( dict->sd_bytes                                              &&
              dict->num_subrs > ( binary_length - dict->subrmap_offset ) /
                                  (FT_UInt)dict->sd_bytes                 ) )
       {
-        FT_ERROR(( "cid_parse_dict: Invalid `SubrCount' value\n" ));
+        FT_ERROR(( "cid_face_open: Invalid `SubrCount' value\n" ));
         error = FT_THROW( Invalid_File_Format );
         goto Exit;
       }
     }
 
     if ( cid->cidmap_offset > binary_length )
     {
-      FT_ERROR(( "cid_parse_dict: Invalid `CIDMapOffset' value\n" ));
+      FT_ERROR(( "cid_face_open: Invalid `CIDMapOffset' value\n" ));
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     if ( entry_len                                            &&
          cid->cid_count >
            ( binary_length - cid->cidmap_offset ) / entry_len )
     {
-      FT_ERROR(( "cid_parse_dict: Invalid `CIDCount' value\n" ));
+      FT_ERROR(( "cid_face_open: Invalid `CIDCount' value\n" ));
       error = FT_THROW( Invalid_File_Format );
       goto Exit;
     }
 
     /* we can now safely proceed */

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/autofit/afhints.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  afhints.c                                                              */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    Auto-fitter hinting routines (body).                                 */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2003-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &quot;afhints.h&quot;
  20 #include &quot;aferrors.h&quot;
  21 #include FT_INTERNAL_CALC_H
  22 #include FT_INTERNAL_DEBUG_H
  23 
  24 
<a name="2" id="anc2"></a><span class="line-modified">  25   /*************************************************************************/</span>
<span class="line-modified">  26   /*                                                                       */</span>
<span class="line-modified">  27   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">  28   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">  29   /* messages during execution.                                            */</span>
<span class="line-modified">  30   /*                                                                       */</span>
  31 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified">  32 #define FT_COMPONENT  trace_afhints</span>
  33 
  34 
  35   /* Get new segment for given axis. */
  36 
  37   FT_LOCAL_DEF( FT_Error )
  38   af_axis_hints_new_segment( AF_AxisHints  axis,
  39                              FT_Memory     memory,
  40                              AF_Segment   *asegment )
  41   {
  42     FT_Error    error   = FT_Err_Ok;
  43     AF_Segment  segment = NULL;
  44 
  45 
  46     if ( axis-&gt;num_segments &lt; AF_SEGMENTS_EMBEDDED )
  47     {
  48       if ( !axis-&gt;segments )
  49       {
  50         axis-&gt;segments     = axis-&gt;embedded.segments;
  51         axis-&gt;max_segments = AF_SEGMENTS_EMBEDDED;
  52       }
  53     }
  54     else if ( axis-&gt;num_segments &gt;= axis-&gt;max_segments )
  55     {
  56       FT_Int  old_max = axis-&gt;max_segments;
  57       FT_Int  new_max = old_max;
  58       FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *segment ) );
  59 
  60 
  61       if ( old_max &gt;= big_max )
  62       {
  63         error = FT_THROW( Out_Of_Memory );
  64         goto Exit;
  65       }
  66 
  67       new_max += ( new_max &gt;&gt; 2 ) + 4;
  68       if ( new_max &lt; old_max || new_max &gt; big_max )
  69         new_max = big_max;
  70 
  71       if ( axis-&gt;segments == axis-&gt;embedded.segments )
  72       {
  73         if ( FT_NEW_ARRAY( axis-&gt;segments, new_max ) )
  74           goto Exit;
  75         ft_memcpy( axis-&gt;segments, axis-&gt;embedded.segments,
  76                    sizeof ( axis-&gt;embedded.segments ) );
  77       }
  78       else
  79       {
  80         if ( FT_RENEW_ARRAY( axis-&gt;segments, old_max, new_max ) )
  81           goto Exit;
  82       }
  83 
  84       axis-&gt;max_segments = new_max;
  85     }
  86 
  87     segment = axis-&gt;segments + axis-&gt;num_segments++;
  88 
  89   Exit:
  90     *asegment = segment;
  91     return error;
  92   }
  93 
  94 
  95   /* Get new edge for given axis, direction, and position, */
  96   /* without initializing the edge itself.                 */
  97 
  98   FT_LOCAL( FT_Error )
  99   af_axis_hints_new_edge( AF_AxisHints  axis,
 100                           FT_Int        fpos,
 101                           AF_Direction  dir,
 102                           FT_Bool       top_to_bottom_hinting,
 103                           FT_Memory     memory,
 104                           AF_Edge      *anedge )
 105   {
 106     FT_Error  error = FT_Err_Ok;
 107     AF_Edge   edge  = NULL;
 108     AF_Edge   edges;
 109 
 110 
 111     if ( axis-&gt;num_edges &lt; AF_EDGES_EMBEDDED )
 112     {
 113       if ( !axis-&gt;edges )
 114       {
 115         axis-&gt;edges     = axis-&gt;embedded.edges;
 116         axis-&gt;max_edges = AF_EDGES_EMBEDDED;
 117       }
 118     }
 119     else if ( axis-&gt;num_edges &gt;= axis-&gt;max_edges )
 120     {
 121       FT_Int  old_max = axis-&gt;max_edges;
 122       FT_Int  new_max = old_max;
 123       FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *edge ) );
 124 
 125 
 126       if ( old_max &gt;= big_max )
 127       {
 128         error = FT_THROW( Out_Of_Memory );
 129         goto Exit;
 130       }
 131 
 132       new_max += ( new_max &gt;&gt; 2 ) + 4;
 133       if ( new_max &lt; old_max || new_max &gt; big_max )
 134         new_max = big_max;
 135 
 136       if ( axis-&gt;edges == axis-&gt;embedded.edges )
 137       {
 138         if ( FT_NEW_ARRAY( axis-&gt;edges, new_max ) )
 139           goto Exit;
 140         ft_memcpy( axis-&gt;edges, axis-&gt;embedded.edges,
 141                    sizeof ( axis-&gt;embedded.edges ) );
 142       }
 143       else
 144       {
 145         if ( FT_RENEW_ARRAY( axis-&gt;edges, old_max, new_max ) )
 146           goto Exit;
 147       }
 148 
 149       axis-&gt;max_edges = new_max;
 150     }
 151 
 152     edges = axis-&gt;edges;
 153     edge  = edges + axis-&gt;num_edges;
 154 
 155     while ( edge &gt; edges )
 156     {
 157       if ( top_to_bottom_hinting ? ( edge[-1].fpos &gt; fpos )
 158                                  : ( edge[-1].fpos &lt; fpos ) )
 159         break;
 160 
 161       /* we want the edge with same position and minor direction */
 162       /* to appear before those in the major one in the list     */
 163       if ( edge[-1].fpos == fpos &amp;&amp; dir == axis-&gt;major_dir )
 164         break;
 165 
 166       edge[0] = edge[-1];
 167       edge--;
 168     }
 169 
 170     axis-&gt;num_edges++;
 171 
 172   Exit:
 173     *anedge = edge;
 174     return error;
 175   }
 176 
 177 
 178 #ifdef FT_DEBUG_AUTOFIT
 179 
 180 #include FT_CONFIG_STANDARD_LIBRARY_H
 181 
 182   /* The dump functions are used in the `ftgrid&#39; demo program, too. */
 183 #define AF_DUMP( varformat )          \
 184           do                          \
 185           {                           \
 186             if ( to_stdout )          \
 187               printf varformat;       \
 188             else                      \
 189               FT_TRACE7( varformat ); \
 190           } while ( 0 )
 191 
 192 
 193   static const char*
 194   af_dir_str( AF_Direction  dir )
 195   {
 196     const char*  result;
 197 
 198 
 199     switch ( dir )
 200     {
 201     case AF_DIR_UP:
 202       result = &quot;up&quot;;
 203       break;
 204     case AF_DIR_DOWN:
 205       result = &quot;down&quot;;
 206       break;
 207     case AF_DIR_LEFT:
 208       result = &quot;left&quot;;
 209       break;
 210     case AF_DIR_RIGHT:
 211       result = &quot;right&quot;;
 212       break;
 213     default:
 214       result = &quot;none&quot;;
 215     }
 216 
 217     return result;
 218   }
 219 
 220 
 221 #define AF_INDEX_NUM( ptr, base )  (int)( (ptr) ? ( (ptr) - (base) ) : -1 )
 222 
 223 
 224   static char*
 225   af_print_idx( char* p,
 226                 int   idx )
 227   {
 228     if ( idx == -1 )
 229     {
 230       p[0] = &#39;-&#39;;
 231       p[1] = &#39;-&#39;;
 232       p[2] = &#39;\0&#39;;
 233     }
 234     else
 235       ft_sprintf( p, &quot;%d&quot;, idx );
 236 
 237     return p;
 238   }
 239 
 240 
 241   static int
 242   af_get_segment_index( AF_GlyphHints  hints,
 243                         int            point_idx,
 244                         int            dimension )
 245   {
 246     AF_AxisHints  axis     = &amp;hints-&gt;axis[dimension];
 247     AF_Point      point    = hints-&gt;points + point_idx;
 248     AF_Segment    segments = axis-&gt;segments;
 249     AF_Segment    limit    = segments + axis-&gt;num_segments;
 250     AF_Segment    segment;
 251 
 252 
 253     for ( segment = segments; segment &lt; limit; segment++ )
 254     {
 255       if ( segment-&gt;first &lt;= segment-&gt;last )
 256       {
 257         if ( point &gt;= segment-&gt;first &amp;&amp; point &lt;= segment-&gt;last )
 258           break;
 259       }
 260       else
 261       {
 262         AF_Point  p = segment-&gt;first;
 263 
 264 
 265         for (;;)
 266         {
 267           if ( point == p )
 268             goto Exit;
 269 
 270           if ( p == segment-&gt;last )
 271             break;
 272 
 273           p = p-&gt;next;
 274         }
 275       }
 276     }
 277 
 278   Exit:
 279     if ( segment == limit )
 280       return -1;
 281 
 282     return (int)( segment - segments );
 283   }
 284 
 285 
 286   static int
 287   af_get_edge_index( AF_GlyphHints  hints,
 288                      int            segment_idx,
 289                      int            dimension )
 290   {
 291     AF_AxisHints  axis    = &amp;hints-&gt;axis[dimension];
 292     AF_Edge       edges   = axis-&gt;edges;
 293     AF_Segment    segment = axis-&gt;segments + segment_idx;
 294 
 295 
 296     return segment_idx == -1 ? -1 : AF_INDEX_NUM( segment-&gt;edge, edges );
 297   }
 298 
 299 
<a name="4" id="anc4"></a>












 300 #ifdef __cplusplus
 301   extern &quot;C&quot; {
 302 #endif
 303   void
 304   af_glyph_hints_dump_points( AF_GlyphHints  hints,
 305                               FT_Bool        to_stdout )
 306   {
 307     AF_Point   points  = hints-&gt;points;
 308     AF_Point   limit   = points + hints-&gt;num_points;
 309     AF_Point*  contour = hints-&gt;contours;
 310     AF_Point*  climit  = contour + hints-&gt;num_contours;
 311     AF_Point   point;
 312 
 313 
 314     AF_DUMP(( &quot;Table of points:\n&quot; ));
 315 
 316     if ( hints-&gt;num_points )
 317     {
 318       AF_DUMP(( &quot;  index  hedge  hseg  vedge  vseg  flags &quot;
 319              /* &quot;  XXXXX  XXXXX XXXXX  XXXXX XXXXX  XXXXXX&quot; */
<a name="5" id="anc5"></a><span class="line-modified"> 320                 &quot;  xorg  yorg  xscale  yscale   xfit    yfit&quot; ));</span>
 321              /* &quot; XXXXX XXXXX XXXX.XX XXXX.XX XXXX.XX XXXX.XX&quot; */
<a name="6" id="anc6"></a>

 322     }
 323     else
 324       AF_DUMP(( &quot;  (none)\n&quot; ));
 325 
 326     for ( point = points; point &lt; limit; point++ )
 327     {
 328       int  point_idx     = AF_INDEX_NUM( point, points );
 329       int  segment_idx_0 = af_get_segment_index( hints, point_idx, 0 );
 330       int  segment_idx_1 = af_get_segment_index( hints, point_idx, 1 );
 331 
 332       char  buf1[16], buf2[16], buf3[16], buf4[16];
<a name="7" id="anc7"></a>
 333 
 334 
 335       /* insert extra newline at the beginning of a contour */
 336       if ( contour &lt; climit &amp;&amp; *contour == point )
 337       {
 338         AF_DUMP(( &quot;\n&quot; ));
 339         contour++;
 340       }
 341 
 342       AF_DUMP(( &quot;  %5d  %5s %5s  %5s %5s  %s&quot;
<a name="8" id="anc8"></a><span class="line-modified"> 343                 &quot; %5d %5d %7.2f %7.2f %7.2f %7.2f\n&quot;,</span>

 344                 point_idx,
 345                 af_print_idx( buf1,
 346                               af_get_edge_index( hints, segment_idx_1, 1 ) ),
 347                 af_print_idx( buf2, segment_idx_1 ),
 348                 af_print_idx( buf3,
 349                               af_get_edge_index( hints, segment_idx_0, 0 ) ),
 350                 af_print_idx( buf4, segment_idx_0 ),
 351                 ( point-&gt;flags &amp; AF_FLAG_NEAR )
 352                   ? &quot; near &quot;
 353                   : ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
 354                     ? &quot; weak &quot;
 355                     : &quot;strong&quot;,
 356 
 357                 point-&gt;fx,
 358                 point-&gt;fy,
 359                 point-&gt;ox / 64.0,
 360                 point-&gt;oy / 64.0,
 361                 point-&gt;x / 64.0,
<a name="9" id="anc9"></a><span class="line-modified"> 362                 point-&gt;y / 64.0 ));</span>













 363     }
 364     AF_DUMP(( &quot;\n&quot; ));
 365   }
 366 #ifdef __cplusplus
 367   }
 368 #endif
 369 
 370 
 371   static const char*
 372   af_edge_flags_to_string( FT_UInt  flags )
 373   {
 374     static char  temp[32];
 375     int          pos = 0;
 376 
 377 
 378     if ( flags &amp; AF_EDGE_ROUND )
 379     {
 380       ft_memcpy( temp + pos, &quot;round&quot;, 5 );
 381       pos += 5;
 382     }
 383     if ( flags &amp; AF_EDGE_SERIF )
 384     {
 385       if ( pos &gt; 0 )
 386         temp[pos++] = &#39; &#39;;
 387       ft_memcpy( temp + pos, &quot;serif&quot;, 5 );
 388       pos += 5;
 389     }
 390     if ( pos == 0 )
 391       return &quot;normal&quot;;
 392 
 393     temp[pos] = &#39;\0&#39;;
 394 
 395     return temp;
 396   }
 397 
 398 
 399   /* Dump the array of linked segments. */
 400 
 401 #ifdef __cplusplus
 402   extern &quot;C&quot; {
 403 #endif
 404   void
 405   af_glyph_hints_dump_segments( AF_GlyphHints  hints,
 406                                 FT_Bool        to_stdout )
 407   {
 408     FT_Int  dimension;
 409 
 410 
 411     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 412     {
 413       AF_AxisHints  axis     = &amp;hints-&gt;axis[dimension];
 414       AF_Point      points   = hints-&gt;points;
 415       AF_Edge       edges    = axis-&gt;edges;
 416       AF_Segment    segments = axis-&gt;segments;
 417       AF_Segment    limit    = segments + axis-&gt;num_segments;
 418       AF_Segment    seg;
 419 
 420       char  buf1[16], buf2[16], buf3[16];
 421 
 422 
 423       AF_DUMP(( &quot;Table of %s segments:\n&quot;,
 424                 dimension == AF_DIMENSION_HORZ ? &quot;vertical&quot;
 425                                                : &quot;horizontal&quot; ));
 426       if ( axis-&gt;num_segments )
 427       {
 428         AF_DUMP(( &quot;  index   pos   delta   dir   from   to &quot;
 429                /* &quot;  XXXXX  XXXXX  XXXXX  XXXXX  XXXX  XXXX&quot; */
 430                   &quot;  link  serif  edge&quot;
 431                /* &quot;  XXXX  XXXXX  XXXX&quot; */
 432                   &quot;  height  extra     flags\n&quot; ));
 433                /* &quot;  XXXXXX  XXXXX  XXXXXXXXXXX&quot; */
 434       }
 435       else
 436         AF_DUMP(( &quot;  (none)\n&quot; ));
 437 
 438       for ( seg = segments; seg &lt; limit; seg++ )
 439         AF_DUMP(( &quot;  %5d  %5d  %5d  %5s  %4d  %4d&quot;
 440                   &quot;  %4s  %5s  %4s&quot;
 441                   &quot;  %6d  %5d  %11s\n&quot;,
 442                   AF_INDEX_NUM( seg, segments ),
 443                   seg-&gt;pos,
 444                   seg-&gt;delta,
 445                   af_dir_str( (AF_Direction)seg-&gt;dir ),
 446                   AF_INDEX_NUM( seg-&gt;first, points ),
 447                   AF_INDEX_NUM( seg-&gt;last, points ),
 448 
 449                   af_print_idx( buf1, AF_INDEX_NUM( seg-&gt;link, segments ) ),
 450                   af_print_idx( buf2, AF_INDEX_NUM( seg-&gt;serif, segments ) ),
 451                   af_print_idx( buf3, AF_INDEX_NUM( seg-&gt;edge, edges ) ),
 452 
 453                   seg-&gt;height,
 454                   seg-&gt;height - ( seg-&gt;max_coord - seg-&gt;min_coord ),
 455                   af_edge_flags_to_string( seg-&gt;flags ) ));
 456       AF_DUMP(( &quot;\n&quot; ));
 457     }
 458   }
 459 #ifdef __cplusplus
 460   }
 461 #endif
 462 
 463 
 464   /* Fetch number of segments. */
 465 
 466 #ifdef __cplusplus
 467   extern &quot;C&quot; {
 468 #endif
 469   FT_Error
 470   af_glyph_hints_get_num_segments( AF_GlyphHints  hints,
 471                                    FT_Int         dimension,
 472                                    FT_Int*        num_segments )
 473   {
 474     AF_Dimension  dim;
 475     AF_AxisHints  axis;
 476 
 477 
 478     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 479 
 480     axis          = &amp;hints-&gt;axis[dim];
 481     *num_segments = axis-&gt;num_segments;
 482 
 483     return FT_Err_Ok;
 484   }
 485 #ifdef __cplusplus
 486   }
 487 #endif
 488 
 489 
 490   /* Fetch offset of segments into user supplied offset array. */
 491 
 492 #ifdef __cplusplus
 493   extern &quot;C&quot; {
 494 #endif
 495   FT_Error
 496   af_glyph_hints_get_segment_offset( AF_GlyphHints  hints,
 497                                      FT_Int         dimension,
 498                                      FT_Int         idx,
 499                                      FT_Pos        *offset,
 500                                      FT_Bool       *is_blue,
 501                                      FT_Pos        *blue_offset )
 502   {
 503     AF_Dimension  dim;
 504     AF_AxisHints  axis;
 505     AF_Segment    seg;
 506 
 507 
 508     if ( !offset )
 509       return FT_THROW( Invalid_Argument );
 510 
 511     dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;
 512 
 513     axis = &amp;hints-&gt;axis[dim];
 514 
 515     if ( idx &lt; 0 || idx &gt;= axis-&gt;num_segments )
 516       return FT_THROW( Invalid_Argument );
 517 
 518     seg      = &amp;axis-&gt;segments[idx];
 519     *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;fx
 520                                             : seg-&gt;first-&gt;fy;
 521     if ( seg-&gt;edge )
<a name="10" id="anc10"></a><span class="line-modified"> 522       *is_blue = (FT_Bool)( seg-&gt;edge-&gt;blue_edge != 0 );</span>
 523     else
 524       *is_blue = FALSE;
 525 
 526     if ( *is_blue )
 527       *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;org;
 528     else
 529       *blue_offset = 0;
 530 
 531     return FT_Err_Ok;
 532   }
 533 #ifdef __cplusplus
 534   }
 535 #endif
 536 
 537 
 538   /* Dump the array of linked edges. */
 539 
 540 #ifdef __cplusplus
 541   extern &quot;C&quot; {
 542 #endif
 543   void
 544   af_glyph_hints_dump_edges( AF_GlyphHints  hints,
 545                              FT_Bool        to_stdout )
 546   {
 547     FT_Int  dimension;
 548 
 549 
 550     for ( dimension = 1; dimension &gt;= 0; dimension-- )
 551     {
 552       AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];
 553       AF_Edge       edges = axis-&gt;edges;
 554       AF_Edge       limit = edges + axis-&gt;num_edges;
 555       AF_Edge       edge;
 556 
 557       char  buf1[16], buf2[16];
 558 
 559 
 560       /*
<a name="11" id="anc11"></a><span class="line-modified"> 561        *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</span>
<span class="line-modified"> 562        *        since they have a constant X coordinate.</span>
 563        */
 564       if ( dimension == AF_DIMENSION_HORZ )
 565         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 566                   &quot;vertical&quot;,
 567                   65536.0 * 64.0 / hints-&gt;x_scale,
 568                   10.0 * hints-&gt;x_scale / 65536.0 / 64.0 ));
 569       else
 570         AF_DUMP(( &quot;Table of %s edges (1px=%.2fu, 10u=%.2fpx):\n&quot;,
 571                   &quot;horizontal&quot;,
 572                   65536.0 * 64.0 / hints-&gt;y_scale,
 573                   10.0 * hints-&gt;y_scale / 65536.0 / 64.0 ));
 574 
 575       if ( axis-&gt;num_edges )
 576       {
 577         AF_DUMP(( &quot;  index    pos     dir   link  serif&quot;
 578                /* &quot;  XXXXX  XXXX.XX  XXXXX  XXXX  XXXXX&quot; */
 579                   &quot;  blue    opos     pos       flags\n&quot; ));
 580                /* &quot;    X   XXXX.XX  XXXX.XX  XXXXXXXXXXX&quot; */
 581       }
 582       else
 583         AF_DUMP(( &quot;  (none)\n&quot; ));
 584 
 585       for ( edge = edges; edge &lt; limit; edge++ )
 586         AF_DUMP(( &quot;  %5d  %7.2f  %5s  %4s  %5s&quot;
 587                   &quot;    %c   %7.2f  %7.2f  %11s\n&quot;,
 588                   AF_INDEX_NUM( edge, edges ),
 589                   (int)edge-&gt;opos / 64.0,
 590                   af_dir_str( (AF_Direction)edge-&gt;dir ),
 591                   af_print_idx( buf1, AF_INDEX_NUM( edge-&gt;link, edges ) ),
 592                   af_print_idx( buf2, AF_INDEX_NUM( edge-&gt;serif, edges ) ),
 593 
 594                   edge-&gt;blue_edge ? &#39;y&#39; : &#39;n&#39;,
 595                   edge-&gt;opos / 64.0,
 596                   edge-&gt;pos / 64.0,
 597                   af_edge_flags_to_string( edge-&gt;flags ) ));
 598       AF_DUMP(( &quot;\n&quot; ));
 599     }
 600   }
 601 #ifdef __cplusplus
 602   }
 603 #endif
 604 
 605 #undef AF_DUMP
 606 
 607 #endif /* !FT_DEBUG_AUTOFIT */
 608 
 609 
 610   /* Compute the direction value of a given vector. */
 611 
 612   FT_LOCAL_DEF( AF_Direction )
 613   af_direction_compute( FT_Pos  dx,
 614                         FT_Pos  dy )
 615   {
 616     FT_Pos        ll, ss;  /* long and short arm lengths */
 617     AF_Direction  dir;     /* candidate direction        */
 618 
 619 
 620     if ( dy &gt;= dx )
 621     {
 622       if ( dy &gt;= -dx )
 623       {
 624         dir = AF_DIR_UP;
 625         ll  = dy;
 626         ss  = dx;
 627       }
 628       else
 629       {
 630         dir = AF_DIR_LEFT;
 631         ll  = -dx;
 632         ss  = dy;
 633       }
 634     }
 635     else /* dy &lt; dx */
 636     {
 637       if ( dy &gt;= -dx )
 638       {
 639         dir = AF_DIR_RIGHT;
 640         ll  = dx;
 641         ss  = dy;
 642       }
 643       else
 644       {
 645         dir = AF_DIR_DOWN;
 646         ll  = -dy;
 647         ss  = dx;
 648       }
 649     }
 650 
 651     /* return no direction if arm lengths do not differ enough       */
 652     /* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */
 653     /* the long arm is never negative                                */
 654     if ( ll &lt;= 14 * FT_ABS( ss ) )
 655       dir = AF_DIR_NONE;
 656 
 657     return dir;
 658   }
 659 
 660 
 661   FT_LOCAL_DEF( void )
 662   af_glyph_hints_init( AF_GlyphHints  hints,
 663                        FT_Memory      memory )
 664   {
 665     /* no need to initialize the embedded items */
 666     FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints-&gt;embedded ) );
 667     hints-&gt;memory = memory;
 668   }
 669 
 670 
 671   FT_LOCAL_DEF( void )
 672   af_glyph_hints_done( AF_GlyphHints  hints )
 673   {
 674     FT_Memory  memory;
 675     int        dim;
 676 
 677 
 678     if ( !( hints &amp;&amp; hints-&gt;memory ) )
 679       return;
 680 
 681     memory = hints-&gt;memory;
 682 
 683     /*
<a name="12" id="anc12"></a><span class="line-modified"> 684      *  note that we don&#39;t need to free the segment and edge</span>
<span class="line-modified"> 685      *  buffers since they are really within the hints-&gt;points array</span>
 686      */
 687     for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )
 688     {
 689       AF_AxisHints  axis = &amp;hints-&gt;axis[dim];
 690 
 691 
 692       axis-&gt;num_segments = 0;
 693       axis-&gt;max_segments = 0;
 694       if ( axis-&gt;segments != axis-&gt;embedded.segments )
 695         FT_FREE( axis-&gt;segments );
 696 
 697       axis-&gt;num_edges = 0;
 698       axis-&gt;max_edges = 0;
 699       if ( axis-&gt;edges != axis-&gt;embedded.edges )
 700         FT_FREE( axis-&gt;edges );
 701     }
 702 
 703     if ( hints-&gt;contours != hints-&gt;embedded.contours )
 704       FT_FREE( hints-&gt;contours );
 705     hints-&gt;max_contours = 0;
 706     hints-&gt;num_contours = 0;
 707 
 708     if ( hints-&gt;points != hints-&gt;embedded.points )
 709       FT_FREE( hints-&gt;points );
 710     hints-&gt;max_points = 0;
 711     hints-&gt;num_points = 0;
 712 
 713     hints-&gt;memory = NULL;
 714   }
 715 
 716 
 717   /* Reset metrics. */
 718 
 719   FT_LOCAL_DEF( void )
 720   af_glyph_hints_rescale( AF_GlyphHints    hints,
 721                           AF_StyleMetrics  metrics )
 722   {
 723     hints-&gt;metrics      = metrics;
 724     hints-&gt;scaler_flags = metrics-&gt;scaler.flags;
 725   }
 726 
 727 
 728   /* Recompute all AF_Point in AF_GlyphHints from the definitions */
 729   /* in a source outline.                                         */
 730 
 731   FT_LOCAL_DEF( FT_Error )
 732   af_glyph_hints_reload( AF_GlyphHints  hints,
 733                          FT_Outline*    outline )
 734   {
 735     FT_Error   error   = FT_Err_Ok;
 736     AF_Point   points;
 737     FT_UInt    old_max, new_max;
 738     FT_Fixed   x_scale = hints-&gt;x_scale;
 739     FT_Fixed   y_scale = hints-&gt;y_scale;
 740     FT_Pos     x_delta = hints-&gt;x_delta;
 741     FT_Pos     y_delta = hints-&gt;y_delta;
 742     FT_Memory  memory  = hints-&gt;memory;
 743 
 744 
 745     hints-&gt;num_points   = 0;
 746     hints-&gt;num_contours = 0;
 747 
 748     hints-&gt;axis[0].num_segments = 0;
 749     hints-&gt;axis[0].num_edges    = 0;
 750     hints-&gt;axis[1].num_segments = 0;
 751     hints-&gt;axis[1].num_edges    = 0;
 752 
 753     /* first of all, reallocate the contours array if necessary */
 754     new_max = (FT_UInt)outline-&gt;n_contours;
 755     old_max = (FT_UInt)hints-&gt;max_contours;
 756 
 757     if ( new_max &lt;= AF_CONTOURS_EMBEDDED )
 758     {
 759       if ( !hints-&gt;contours )
 760       {
 761         hints-&gt;contours     = hints-&gt;embedded.contours;
 762         hints-&gt;max_contours = AF_CONTOURS_EMBEDDED;
 763       }
 764     }
 765     else if ( new_max &gt; old_max )
 766     {
 767       if ( hints-&gt;contours == hints-&gt;embedded.contours )
 768         hints-&gt;contours = NULL;
 769 
 770       new_max = ( new_max + 3 ) &amp; ~3U; /* round up to a multiple of 4 */
 771 
 772       if ( FT_RENEW_ARRAY( hints-&gt;contours, old_max, new_max ) )
 773         goto Exit;
 774 
 775       hints-&gt;max_contours = (FT_Int)new_max;
 776     }
 777 
 778     /*
<a name="13" id="anc13"></a><span class="line-modified"> 779      *  then reallocate the points arrays if necessary --</span>
<span class="line-modified"> 780      *  note that we reserve two additional point positions, used to</span>
<span class="line-modified"> 781      *  hint metrics appropriately</span>
 782      */
 783     new_max = (FT_UInt)( outline-&gt;n_points + 2 );
 784     old_max = (FT_UInt)hints-&gt;max_points;
 785 
 786     if ( new_max &lt;= AF_POINTS_EMBEDDED )
 787     {
 788       if ( !hints-&gt;points )
 789       {
 790         hints-&gt;points     = hints-&gt;embedded.points;
 791         hints-&gt;max_points = AF_POINTS_EMBEDDED;
 792       }
 793     }
 794     else if ( new_max &gt; old_max )
 795     {
 796       if ( hints-&gt;points == hints-&gt;embedded.points )
 797         hints-&gt;points = NULL;
 798 
 799       new_max = ( new_max + 2 + 7 ) &amp; ~7U; /* round up to a multiple of 8 */
 800 
 801       if ( FT_RENEW_ARRAY( hints-&gt;points, old_max, new_max ) )
 802         goto Exit;
 803 
 804       hints-&gt;max_points = (FT_Int)new_max;
 805     }
 806 
 807     hints-&gt;num_points   = outline-&gt;n_points;
 808     hints-&gt;num_contours = outline-&gt;n_contours;
 809 
 810     /* We can&#39;t rely on the value of `FT_Outline.flags&#39; to know the fill   */
 811     /* direction used for a glyph, given that some fonts are broken (e.g., */
 812     /* the Arphic ones).  We thus recompute it each time we need to.       */
 813     /*                                                                     */
 814     hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;
 815     hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;
 816 
 817     if ( FT_Outline_Get_Orientation( outline ) == FT_ORIENTATION_POSTSCRIPT )
 818     {
 819       hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;
 820       hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;
 821     }
 822 
 823     hints-&gt;x_scale = x_scale;
 824     hints-&gt;y_scale = y_scale;
 825     hints-&gt;x_delta = x_delta;
 826     hints-&gt;y_delta = y_delta;
 827 
 828     hints-&gt;xmin_delta = 0;
 829     hints-&gt;xmax_delta = 0;
 830 
 831     points = hints-&gt;points;
 832     if ( hints-&gt;num_points == 0 )
 833       goto Exit;
 834 
 835     {
 836       AF_Point  point;
 837       AF_Point  point_limit = points + hints-&gt;num_points;
 838 
 839       /* value 20 in `near_limit&#39; is heuristic */
 840       FT_UInt  units_per_em = hints-&gt;metrics-&gt;scaler.face-&gt;units_per_EM;
 841       FT_Int   near_limit   = 20 * units_per_em / 2048;
 842 
 843 
 844       /* compute coordinates &amp; Bezier flags, next and prev */
 845       {
 846         FT_Vector*  vec           = outline-&gt;points;
 847         char*       tag           = outline-&gt;tags;
 848         FT_Short    endpoint      = outline-&gt;contours[0];
 849         AF_Point    end           = points + endpoint;
 850         AF_Point    prev          = end;
 851         FT_Int      contour_index = 0;
 852 
 853 
 854         for ( point = points; point &lt; point_limit; point++, vec++, tag++ )
 855         {
 856           FT_Pos  out_x, out_y;
 857 
 858 
 859           point-&gt;in_dir  = (FT_Char)AF_DIR_NONE;
 860           point-&gt;out_dir = (FT_Char)AF_DIR_NONE;
 861 
 862           point-&gt;fx = (FT_Short)vec-&gt;x;
 863           point-&gt;fy = (FT_Short)vec-&gt;y;
 864           point-&gt;ox = point-&gt;x = FT_MulFix( vec-&gt;x, x_scale ) + x_delta;
 865           point-&gt;oy = point-&gt;y = FT_MulFix( vec-&gt;y, y_scale ) + y_delta;
 866 
 867           end-&gt;fx = (FT_Short)outline-&gt;points[endpoint].x;
 868           end-&gt;fy = (FT_Short)outline-&gt;points[endpoint].y;
 869 
 870           switch ( FT_CURVE_TAG( *tag ) )
 871           {
 872           case FT_CURVE_TAG_CONIC:
 873             point-&gt;flags = AF_FLAG_CONIC;
 874             break;
 875           case FT_CURVE_TAG_CUBIC:
 876             point-&gt;flags = AF_FLAG_CUBIC;
 877             break;
 878           default:
 879             point-&gt;flags = AF_FLAG_NONE;
 880           }
 881 
 882           out_x = point-&gt;fx - prev-&gt;fx;
 883           out_y = point-&gt;fy - prev-&gt;fy;
 884 
 885           if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
 886             prev-&gt;flags |= AF_FLAG_NEAR;
 887 
 888           point-&gt;prev = prev;
 889           prev-&gt;next  = point;
 890           prev        = point;
 891 
 892           if ( point == end )
 893           {
 894             if ( ++contour_index &lt; outline-&gt;n_contours )
 895             {
 896               endpoint = outline-&gt;contours[contour_index];
 897               end      = points + endpoint;
 898               prev     = end;
 899             }
 900           }
<a name="14" id="anc14"></a>







 901         }
 902       }
 903 
 904       /* set up the contours array */
 905       {
 906         AF_Point*  contour       = hints-&gt;contours;
 907         AF_Point*  contour_limit = contour + hints-&gt;num_contours;
 908         short*     end           = outline-&gt;contours;
 909         short      idx           = 0;
 910 
 911 
 912         for ( ; contour &lt; contour_limit; contour++, end++ )
 913         {
 914           contour[0] = points + idx;
 915           idx        = (short)( end[0] + 1 );
 916         }
 917       }
 918 
 919       {
 920         /*
<a name="15" id="anc15"></a><span class="line-modified"> 921          *  Compute directions of `in&#39; and `out&#39; vectors.</span>
 922          *
<a name="16" id="anc16"></a><span class="line-modified"> 923          *  Note that distances between points that are very near to each</span>
<span class="line-modified"> 924          *  other are accumulated.  In other words, the auto-hinter either</span>
<span class="line-modified"> 925          *  prepends the small vectors between near points to the first</span>
<span class="line-modified"> 926          *  non-near vector, or the sum of small vector lengths exceeds a</span>
<span class="line-modified"> 927          *  threshold, thus `grouping&#39; the small vectors.  All intermediate</span>
<span class="line-modified"> 928          *  points are tagged as weak; the directions are adjusted also to</span>
<span class="line-modified"> 929          *  be equal to the accumulated one.</span>
 930          */
 931 
 932         FT_Int  near_limit2 = 2 * near_limit - 1;
 933 
 934         AF_Point*  contour;
 935         AF_Point*  contour_limit = hints-&gt;contours + hints-&gt;num_contours;
 936 
 937 
 938         for ( contour = hints-&gt;contours; contour &lt; contour_limit; contour++ )
 939         {
 940           AF_Point  first = *contour;
 941           AF_Point  next, prev, curr;
 942 
 943           FT_Pos  out_x, out_y;
 944 
 945 
 946           /* since the first point of a contour could be part of a */
 947           /* series of near points, go backwards to find the first */
 948           /* non-near point and adjust `first&#39;                     */
 949 
 950           point = first;
 951           prev  = first-&gt;prev;
 952 
 953           while ( prev != first )
 954           {
 955             out_x = point-&gt;fx - prev-&gt;fx;
 956             out_y = point-&gt;fy - prev-&gt;fy;
 957 
 958             /*
<a name="17" id="anc17"></a><span class="line-modified"> 959              *  We use Taxicab metrics to measure the vector length.</span>
 960              *
<a name="18" id="anc18"></a><span class="line-modified"> 961              *  Note that the accumulated distances so far could have the</span>
<span class="line-modified"> 962              *  opposite direction of the distance measured here.  For this</span>
<span class="line-modified"> 963              *  reason we use `near_limit2&#39; for the comparison to get a</span>
<span class="line-modified"> 964              *  non-near point even in the worst case.</span>
 965              */
 966             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )
 967               break;
 968 
 969             point = prev;
 970             prev  = prev-&gt;prev;
 971           }
 972 
 973           /* adjust first point */
 974           first = point;
 975 
 976           /* now loop over all points of the contour to get */
 977           /* `in&#39; and `out&#39; vector directions               */
 978 
 979           curr = first;
 980 
 981           /*
<a name="19" id="anc19"></a><span class="line-modified"> 982            *  We abuse the `u&#39; and `v&#39; fields to store index deltas to the</span>
<span class="line-modified"> 983            *  next and previous non-near point, respectively.</span>
 984            *
<a name="20" id="anc20"></a><span class="line-modified"> 985            *  To avoid problems with not having non-near points, we point to</span>
<span class="line-modified"> 986            *  `first&#39; by default as the next non-near point.</span>
 987            *
 988            */
 989           curr-&gt;u  = (FT_Pos)( first - curr );
 990           first-&gt;v = -curr-&gt;u;
 991 
 992           out_x = 0;
 993           out_y = 0;
 994 
 995           next = first;
 996           do
 997           {
 998             AF_Direction  out_dir;
 999 
1000 
1001             point = next;
1002             next  = point-&gt;next;
1003 
1004             out_x += next-&gt;fx - point-&gt;fx;
1005             out_y += next-&gt;fy - point-&gt;fy;
1006 
1007             if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )
1008             {
1009               next-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1010               continue;
1011             }
1012 
1013             curr-&gt;u = (FT_Pos)( next - curr );
1014             next-&gt;v = -curr-&gt;u;
1015 
1016             out_dir = af_direction_compute( out_x, out_y );
1017 
1018             /* adjust directions for all points inbetween; */
1019             /* the loop also updates position of `curr&#39;    */
1020             curr-&gt;out_dir = (FT_Char)out_dir;
1021             for ( curr = curr-&gt;next; curr != next; curr = curr-&gt;next )
1022             {
1023               curr-&gt;in_dir  = (FT_Char)out_dir;
1024               curr-&gt;out_dir = (FT_Char)out_dir;
1025             }
1026             next-&gt;in_dir = (FT_Char)out_dir;
1027 
1028             curr-&gt;u  = (FT_Pos)( first - curr );
1029             first-&gt;v = -curr-&gt;u;
1030 
1031             out_x = 0;
1032             out_y = 0;
1033 
1034           } while ( next != first );
1035         }
1036 
1037         /*
<a name="21" id="anc21"></a><span class="line-modified">1038          *  The next step is to `simplify&#39; an outline&#39;s topology so that we</span>
<span class="line-modified">1039          *  can identify local extrema more reliably: A series of</span>
<span class="line-modified">1040          *  non-horizontal or non-vertical vectors pointing into the same</span>
<span class="line-modified">1041          *  quadrant are handled as a single, long vector.  From a</span>
<span class="line-modified">1042          *  topological point of the view, the intermediate points are of no</span>
<span class="line-modified">1043          *  interest and thus tagged as weak.</span>
1044          */
1045 
1046         for ( point = points; point &lt; point_limit; point++ )
1047         {
1048           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1049             continue;
1050 
1051           if ( point-&gt;in_dir  == AF_DIR_NONE &amp;&amp;
1052                point-&gt;out_dir == AF_DIR_NONE )
1053           {
1054             /* check whether both vectors point into the same quadrant */
1055 
1056             FT_Pos  in_x, in_y;
1057             FT_Pos  out_x, out_y;
1058 
1059             AF_Point  next_u = point + point-&gt;u;
1060             AF_Point  prev_v = point + point-&gt;v;
1061 
1062 
1063             in_x = point-&gt;fx - prev_v-&gt;fx;
1064             in_y = point-&gt;fy - prev_v-&gt;fy;
1065 
1066             out_x = next_u-&gt;fx - point-&gt;fx;
1067             out_y = next_u-&gt;fy - point-&gt;fy;
1068 
1069             if ( ( in_x ^ out_x ) &gt;= 0 &amp;&amp; ( in_y ^ out_y ) &gt;= 0 )
1070             {
1071               /* yes, so tag current point as weak */
1072               /* and update index deltas           */
1073 
1074               point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1075 
1076               prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1077               next_u-&gt;v = -prev_v-&gt;u;
1078             }
1079           }
1080         }
1081 
1082         /*
<a name="22" id="anc22"></a><span class="line-modified">1083          *  Finally, check for remaining weak points.  Everything else not</span>
<span class="line-modified">1084          *  collected in edges so far is then implicitly classified as strong</span>
<span class="line-modified">1085          *  points.</span>
1086          */
1087 
1088         for ( point = points; point &lt; point_limit; point++ )
1089         {
1090           if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )
1091             continue;
1092 
1093           if ( point-&gt;flags &amp; AF_FLAG_CONTROL )
1094           {
1095             /* control points are always weak */
1096           Is_Weak_Point:
1097             point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;
1098           }
1099           else if ( point-&gt;out_dir == point-&gt;in_dir )
1100           {
1101             if ( point-&gt;out_dir != AF_DIR_NONE )
1102             {
1103               /* current point lies on a horizontal or          */
1104               /* vertical segment (but doesn&#39;t start or end it) */
1105               goto Is_Weak_Point;
1106             }
1107 
1108             {
1109               AF_Point  next_u = point + point-&gt;u;
1110               AF_Point  prev_v = point + point-&gt;v;
1111 
1112 
1113               if ( ft_corner_is_flat( point-&gt;fx  - prev_v-&gt;fx,
1114                                       point-&gt;fy  - prev_v-&gt;fy,
1115                                       next_u-&gt;fx - point-&gt;fx,
1116                                       next_u-&gt;fy - point-&gt;fy ) )
1117               {
1118                 /* either the `in&#39; or the `out&#39; vector is much more  */
1119                 /* dominant than the other one, so tag current point */
1120                 /* as weak and update index deltas                   */
1121 
1122                 prev_v-&gt;u = (FT_Pos)( next_u - prev_v );
1123                 next_u-&gt;v = -prev_v-&gt;u;
1124 
1125                 goto Is_Weak_Point;
1126               }
1127             }
1128           }
1129           else if ( point-&gt;in_dir == -point-&gt;out_dir )
1130           {
1131             /* current point forms a spike */
1132             goto Is_Weak_Point;
1133           }
1134         }
1135       }
1136     }
1137 
1138   Exit:
1139     return error;
1140   }
1141 
1142 
1143   /* Store the hinted outline in an FT_Outline structure. */
1144 
1145   FT_LOCAL_DEF( void )
1146   af_glyph_hints_save( AF_GlyphHints  hints,
1147                        FT_Outline*    outline )
1148   {
1149     AF_Point    point = hints-&gt;points;
1150     AF_Point    limit = point + hints-&gt;num_points;
1151     FT_Vector*  vec   = outline-&gt;points;
1152     char*       tag   = outline-&gt;tags;
1153 
1154 
1155     for ( ; point &lt; limit; point++, vec++, tag++ )
1156     {
1157       vec-&gt;x = point-&gt;x;
1158       vec-&gt;y = point-&gt;y;
1159 
1160       if ( point-&gt;flags &amp; AF_FLAG_CONIC )
1161         tag[0] = FT_CURVE_TAG_CONIC;
1162       else if ( point-&gt;flags &amp; AF_FLAG_CUBIC )
1163         tag[0] = FT_CURVE_TAG_CUBIC;
1164       else
1165         tag[0] = FT_CURVE_TAG_ON;
1166     }
1167   }
1168 
1169 
1170   /****************************************************************
1171    *
1172    *                     EDGE POINT GRID-FITTING
1173    *
1174    ****************************************************************/
1175 
1176 
1177   /* Align all points of an edge to the same coordinate value, */
1178   /* either horizontally or vertically.                        */
1179 
1180   FT_LOCAL_DEF( void )
1181   af_glyph_hints_align_edge_points( AF_GlyphHints  hints,
1182                                     AF_Dimension   dim )
1183   {
1184     AF_AxisHints  axis          = &amp; hints-&gt;axis[dim];
1185     AF_Segment    segments      = axis-&gt;segments;
1186     AF_Segment    segment_limit = segments + axis-&gt;num_segments;
1187     AF_Segment    seg;
1188 
1189 
1190     if ( dim == AF_DIMENSION_HORZ )
1191     {
1192       for ( seg = segments; seg &lt; segment_limit; seg++ )
1193       {
1194         AF_Edge   edge = seg-&gt;edge;
1195         AF_Point  point, first, last;
1196 
1197 
1198         if ( !edge )
1199           continue;
1200 
1201         first = seg-&gt;first;
1202         last  = seg-&gt;last;
1203         point = first;
1204         for (;;)
1205         {
1206           point-&gt;x      = edge-&gt;pos;
1207           point-&gt;flags |= AF_FLAG_TOUCH_X;
1208 
1209           if ( point == last )
1210             break;
1211 
1212           point = point-&gt;next;
1213         }
1214       }
1215     }
1216     else
1217     {
1218       for ( seg = segments; seg &lt; segment_limit; seg++ )
1219       {
1220         AF_Edge   edge = seg-&gt;edge;
1221         AF_Point  point, first, last;
1222 
1223 
1224         if ( !edge )
1225           continue;
1226 
1227         first = seg-&gt;first;
1228         last  = seg-&gt;last;
1229         point = first;
1230         for (;;)
1231         {
1232           point-&gt;y      = edge-&gt;pos;
1233           point-&gt;flags |= AF_FLAG_TOUCH_Y;
1234 
1235           if ( point == last )
1236             break;
1237 
1238           point = point-&gt;next;
1239         }
1240       }
1241     }
1242   }
1243 
1244 
1245   /****************************************************************
1246    *
1247    *                    STRONG POINT INTERPOLATION
1248    *
1249    ****************************************************************/
1250 
1251 
1252   /* Hint the strong points -- this is equivalent to the TrueType `IP&#39; */
1253   /* hinting instruction.                                              */
1254 
1255   FT_LOCAL_DEF( void )
1256   af_glyph_hints_align_strong_points( AF_GlyphHints  hints,
1257                                       AF_Dimension   dim )
1258   {
1259     AF_Point      points      = hints-&gt;points;
1260     AF_Point      point_limit = points + hints-&gt;num_points;
1261     AF_AxisHints  axis        = &amp;hints-&gt;axis[dim];
1262     AF_Edge       edges       = axis-&gt;edges;
1263     AF_Edge       edge_limit  = edges + axis-&gt;num_edges;
1264     FT_UInt       touch_flag;
1265 
1266 
1267     if ( dim == AF_DIMENSION_HORZ )
1268       touch_flag = AF_FLAG_TOUCH_X;
1269     else
1270       touch_flag  = AF_FLAG_TOUCH_Y;
1271 
1272     if ( edges &lt; edge_limit )
1273     {
1274       AF_Point  point;
1275       AF_Edge   edge;
1276 
1277 
1278       for ( point = points; point &lt; point_limit; point++ )
1279       {
1280         FT_Pos  u, ou, fu;  /* point position */
1281         FT_Pos  delta;
1282 
1283 
1284         if ( point-&gt;flags &amp; touch_flag )
1285           continue;
1286 
1287         /* if this point is candidate to weak interpolation, we       */
1288         /* interpolate it after all strong points have been processed */
1289 
1290         if ( ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION ) )
1291           continue;
1292 
1293         if ( dim == AF_DIMENSION_VERT )
1294         {
1295           u  = point-&gt;fy;
1296           ou = point-&gt;oy;
1297         }
1298         else
1299         {
1300           u  = point-&gt;fx;
1301           ou = point-&gt;ox;
1302         }
1303 
1304         fu = u;
1305 
1306         /* is the point before the first edge? */
1307         edge  = edges;
1308         delta = edge-&gt;fpos - u;
1309         if ( delta &gt;= 0 )
1310         {
1311           u = edge-&gt;pos - ( edge-&gt;opos - ou );
<a name="23" id="anc23"></a>





1312           goto Store_Point;
1313         }
1314 
1315         /* is the point after the last edge? */
1316         edge  = edge_limit - 1;
1317         delta = u - edge-&gt;fpos;
1318         if ( delta &gt;= 0 )
1319         {
1320           u = edge-&gt;pos + ( ou - edge-&gt;opos );
<a name="24" id="anc24"></a>





1321           goto Store_Point;
1322         }
1323 
1324         {
1325           FT_PtrDist  min, max, mid;
1326           FT_Pos      fpos;
1327 
1328 
1329           /* find enclosing edges */
1330           min = 0;
1331           max = edge_limit - edges;
1332 
1333 #if 1
1334           /* for a small number of edges, a linear search is better */
1335           if ( max &lt;= 8 )
1336           {
1337             FT_PtrDist  nn;
1338 
1339 
1340             for ( nn = 0; nn &lt; max; nn++ )
1341               if ( edges[nn].fpos &gt;= u )
1342                 break;
1343 
1344             if ( edges[nn].fpos == u )
1345             {
1346               u = edges[nn].pos;
1347               goto Store_Point;
1348             }
1349             min = nn;
1350           }
1351           else
1352 #endif
1353           while ( min &lt; max )
1354           {
1355             mid  = ( max + min ) &gt;&gt; 1;
1356             edge = edges + mid;
1357             fpos = edge-&gt;fpos;
1358 
1359             if ( u &lt; fpos )
1360               max = mid;
1361             else if ( u &gt; fpos )
1362               min = mid + 1;
1363             else
1364             {
1365               /* we are on the edge */
1366               u = edge-&gt;pos;
<a name="25" id="anc25"></a>





1367               goto Store_Point;
1368             }
1369           }
1370 
1371           /* point is not on an edge */
1372           {
1373             AF_Edge  before = edges + min - 1;
1374             AF_Edge  after  = edges + min + 0;
1375 
1376 
<a name="26" id="anc26"></a>




1377             /* assert( before &amp;&amp; after &amp;&amp; before != after ) */
1378             if ( before-&gt;scale == 0 )
1379               before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,
1380                                          after-&gt;fpos - before-&gt;fpos );
1381 
1382             u = before-&gt;pos + FT_MulFix( fu - before-&gt;fpos,
1383                                          before-&gt;scale );
1384           }
1385         }
1386 
1387       Store_Point:
1388         /* save the point position */
1389         if ( dim == AF_DIMENSION_HORZ )
1390           point-&gt;x = u;
1391         else
1392           point-&gt;y = u;
1393 
1394         point-&gt;flags |= touch_flag;
1395       }
1396     }
1397   }
1398 
1399 
1400   /****************************************************************
1401    *
1402    *                    WEAK POINT INTERPOLATION
1403    *
1404    ****************************************************************/
1405 
1406 
1407   /* Shift the original coordinates of all points between `p1&#39; and */
1408   /* `p2&#39; to get hinted coordinates, using the same difference as  */
1409   /* given by `ref&#39;.                                               */
1410 
1411   static void
1412   af_iup_shift( AF_Point  p1,
1413                 AF_Point  p2,
1414                 AF_Point  ref )
1415   {
1416     AF_Point  p;
1417     FT_Pos    delta = ref-&gt;u - ref-&gt;v;
1418 
1419 
1420     if ( delta == 0 )
1421       return;
1422 
1423     for ( p = p1; p &lt; ref; p++ )
1424       p-&gt;u = p-&gt;v + delta;
1425 
1426     for ( p = ref + 1; p &lt;= p2; p++ )
1427       p-&gt;u = p-&gt;v + delta;
1428   }
1429 
1430 
1431   /* Interpolate the original coordinates of all points between `p1&#39; and  */
1432   /* `p2&#39; to get hinted coordinates, using `ref1&#39; and `ref2&#39; as the       */
1433   /* reference points.  The `u&#39; and `v&#39; members are the current and       */
1434   /* original coordinate values, respectively.                            */
1435   /*                                                                      */
1436   /* Details can be found in the TrueType bytecode specification.         */
1437 
1438   static void
1439   af_iup_interp( AF_Point  p1,
1440                  AF_Point  p2,
1441                  AF_Point  ref1,
1442                  AF_Point  ref2 )
1443   {
1444     AF_Point  p;
1445     FT_Pos    u, v1, v2, u1, u2, d1, d2;
1446 
1447 
1448     if ( p1 &gt; p2 )
1449       return;
1450 
1451     if ( ref1-&gt;v &gt; ref2-&gt;v )
1452     {
1453       p    = ref1;
1454       ref1 = ref2;
1455       ref2 = p;
1456     }
1457 
1458     v1 = ref1-&gt;v;
1459     v2 = ref2-&gt;v;
1460     u1 = ref1-&gt;u;
1461     u2 = ref2-&gt;u;
1462     d1 = u1 - v1;
1463     d2 = u2 - v2;
1464 
1465     if ( u1 == u2 || v1 == v2 )
1466     {
1467       for ( p = p1; p &lt;= p2; p++ )
1468       {
1469         u = p-&gt;v;
1470 
1471         if ( u &lt;= v1 )
1472           u += d1;
1473         else if ( u &gt;= v2 )
1474           u += d2;
1475         else
1476           u = u1;
1477 
1478         p-&gt;u = u;
1479       }
1480     }
1481     else
1482     {
1483       FT_Fixed  scale = FT_DivFix( u2 - u1, v2 - v1 );
1484 
1485 
1486       for ( p = p1; p &lt;= p2; p++ )
1487       {
1488         u = p-&gt;v;
1489 
1490         if ( u &lt;= v1 )
1491           u += d1;
1492         else if ( u &gt;= v2 )
1493           u += d2;
1494         else
1495           u = u1 + FT_MulFix( u - v1, scale );
1496 
1497         p-&gt;u = u;
1498       }
1499     }
1500   }
1501 
1502 
1503   /* Hint the weak points -- this is equivalent to the TrueType `IUP&#39; */
1504   /* hinting instruction.                                             */
1505 
1506   FT_LOCAL_DEF( void )
1507   af_glyph_hints_align_weak_points( AF_GlyphHints  hints,
1508                                     AF_Dimension   dim )
1509   {
1510     AF_Point   points        = hints-&gt;points;
1511     AF_Point   point_limit   = points + hints-&gt;num_points;
1512     AF_Point*  contour       = hints-&gt;contours;
1513     AF_Point*  contour_limit = contour + hints-&gt;num_contours;
1514     FT_UInt    touch_flag;
1515     AF_Point   point;
1516     AF_Point   end_point;
1517     AF_Point   first_point;
1518 
1519 
1520     /* PASS 1: Move segment points to edge positions */
1521 
1522     if ( dim == AF_DIMENSION_HORZ )
1523     {
1524       touch_flag = AF_FLAG_TOUCH_X;
1525 
1526       for ( point = points; point &lt; point_limit; point++ )
1527       {
1528         point-&gt;u = point-&gt;x;
1529         point-&gt;v = point-&gt;ox;
1530       }
1531     }
1532     else
1533     {
1534       touch_flag = AF_FLAG_TOUCH_Y;
1535 
1536       for ( point = points; point &lt; point_limit; point++ )
1537       {
1538         point-&gt;u = point-&gt;y;
1539         point-&gt;v = point-&gt;oy;
1540       }
1541     }
1542 
1543     for ( ; contour &lt; contour_limit; contour++ )
1544     {
1545       AF_Point  first_touched, last_touched;
1546 
1547 
1548       point       = *contour;
1549       end_point   = point-&gt;prev;
1550       first_point = point;
1551 
1552       /* find first touched point */
1553       for (;;)
1554       {
1555         if ( point &gt; end_point )  /* no touched point in contour */
1556           goto NextContour;
1557 
1558         if ( point-&gt;flags &amp; touch_flag )
1559           break;
1560 
1561         point++;
1562       }
1563 
1564       first_touched = point;
1565 
1566       for (;;)
1567       {
1568         FT_ASSERT( point &lt;= end_point                 &amp;&amp;
1569                    ( point-&gt;flags &amp; touch_flag ) != 0 );
1570 
1571         /* skip any touched neighbours */
1572         while ( point &lt; end_point                    &amp;&amp;
1573                 ( point[1].flags &amp; touch_flag ) != 0 )
1574           point++;
1575 
1576         last_touched = point;
1577 
1578         /* find the next touched point, if any */
1579         point++;
1580         for (;;)
1581         {
1582           if ( point &gt; end_point )
1583             goto EndContour;
1584 
1585           if ( ( point-&gt;flags &amp; touch_flag ) != 0 )
1586             break;
1587 
1588           point++;
1589         }
1590 
1591         /* interpolate between last_touched and point */
1592         af_iup_interp( last_touched + 1, point - 1,
1593                        last_touched, point );
1594       }
1595 
1596     EndContour:
1597       /* special case: only one point was touched */
1598       if ( last_touched == first_touched )
1599         af_iup_shift( first_point, end_point, first_touched );
1600 
1601       else /* interpolate the last part */
1602       {
1603         if ( last_touched &lt; end_point )
1604           af_iup_interp( last_touched + 1, end_point,
1605                          last_touched, first_touched );
1606 
1607         if ( first_touched &gt; points )
1608           af_iup_interp( first_point, first_touched - 1,
1609                          last_touched, first_touched );
1610       }
1611 
1612     NextContour:
1613       ;
1614     }
1615 
1616     /* now save the interpolated values back to x/y */
1617     if ( dim == AF_DIMENSION_HORZ )
1618     {
1619       for ( point = points; point &lt; point_limit; point++ )
1620         point-&gt;x = point-&gt;u;
1621     }
1622     else
1623     {
1624       for ( point = points; point &lt; point_limit; point++ )
1625         point-&gt;y = point-&gt;u;
1626     }
1627   }
1628 
1629 
1630 #ifdef AF_CONFIG_OPTION_USE_WARPER
1631 
1632   /* Apply (small) warp scale and warp delta for given dimension. */
1633 
1634   FT_LOCAL_DEF( void )
1635   af_glyph_hints_scale_dim( AF_GlyphHints  hints,
1636                             AF_Dimension   dim,
1637                             FT_Fixed       scale,
1638                             FT_Pos         delta )
1639   {
1640     AF_Point  points       = hints-&gt;points;
1641     AF_Point  points_limit = points + hints-&gt;num_points;
1642     AF_Point  point;
1643 
1644 
1645     if ( dim == AF_DIMENSION_HORZ )
1646     {
1647       for ( point = points; point &lt; points_limit; point++ )
1648         point-&gt;x = FT_MulFix( point-&gt;fx, scale ) + delta;
1649     }
1650     else
1651     {
1652       for ( point = points; point &lt; points_limit; point++ )
1653         point-&gt;y = FT_MulFix( point-&gt;fy, scale ) + delta;
1654     }
1655   }
1656 
1657 #endif /* AF_CONFIG_OPTION_USE_WARPER */
1658 
1659 /* END */
<a name="27" id="anc27"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="27" type="hidden" />
</body>
</html>
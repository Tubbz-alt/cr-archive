<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/smooth/ftgrays.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../sfnt/ttsbit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftgrays.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/smooth/ftgrays.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,96 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  ftgrays.c                                                              */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    A new `perfect&#39; anti-aliasing renderer (body).                       */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2000-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* This file can be compiled without the rest of the FreeType engine, by */</span>
<span class="line-modified">!   /* defining the STANDALONE_ macro when compiling it.  You also need to   */</span>
<span class="line-modified">!   /* put the files `ftgrays.h&#39; and `ftimage.h&#39; into the current            */</span>
<span class="line-modified">!   /* compilation directory.  Typically, you could do something like        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - copy `src/smooth/ftgrays.c&#39; (this file) to your current directory   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - copy `include/freetype/ftimage.h&#39; and `src/smooth/ftgrays.h&#39; to the */</span>
<span class="line-modified">!   /*   same directory                                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - compile `ftgrays&#39; with the STANDALONE_ macro defined, as in         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*     cc -c -DSTANDALONE_ ftgrays.c                                     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The renderer can be initialized with a call to                        */</span>
<span class="line-modified">!   /* `ft_gray_raster.raster_new&#39;; an anti-aliased bitmap can be generated  */</span>
<span class="line-modified">!   /* with a call to `ft_gray_raster.raster_render&#39;.                        */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* See the comments and documentation in the file `ftimage.h&#39; for more   */</span>
<span class="line-modified">!   /* details on how the raster works.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* This is a new anti-aliasing scan-converter for FreeType 2.  The       */</span>
<span class="line-modified">!   /* algorithm used here is _very_ different from the one in the standard  */</span>
<span class="line-modified">!   /* `ftraster&#39; module.  Actually, `ftgrays&#39; computes the _exact_          */</span>
<span class="line-modified">!   /* coverage of the outline on each pixel cell.                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* It is based on ideas that I initially found in Raph Levien&#39;s          */</span>
<span class="line-modified">!   /* excellent LibArt graphics library (see http://www.levien.com/libart   */</span>
<span class="line-modified">!   /* for more information, though the web pages do not tell anything       */</span>
<span class="line-modified">!   /* about the renderer; you&#39;ll have to dive into the source code to       */</span>
<span class="line-modified">!   /* understand how it works).                                             */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Note, however, that this is a _very_ different implementation         */</span>
<span class="line-modified">!   /* compared to Raph&#39;s.  Coverage information is stored in a very         */</span>
<span class="line-modified">!   /* different way, and I don&#39;t use sorted vector paths.  Also, it doesn&#39;t */</span>
<span class="line-modified">!   /* use floating point values.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* This renderer has the following advantages:                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - It doesn&#39;t need an intermediate bitmap.  Instead, one can supply a  */</span>
<span class="line-modified">!   /*   callback function that will be called by the renderer to draw gray  */</span>
<span class="line-modified">!   /*   spans on any target surface.  You can thus do direct composition on */</span>
<span class="line-modified">!   /*   any kind of bitmap, provided that you give the renderer the right   */</span>
<span class="line-modified">!   /*   callback.                                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on   */</span>
<span class="line-modified">!   /*   each pixel cell.                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - It performs a single pass on the outline (the `standard&#39; FT2        */</span>
<span class="line-modified">!   /*   renderer makes two passes).                                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - It can easily be modified to render to _any_ number of gray levels  */</span>
<span class="line-modified">!   /*   cheaply.                                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* - For small (&lt; 20) pixel sizes, it is faster than the standard        */</span>
<span class="line-modified">!   /*   renderer.                                                           */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_smooth</span>
  
  
  #ifdef STANDALONE_
  
  
<span class="line-new-header">--- 1,104 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * ftgrays.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   A new `perfect&#39; anti-aliasing renderer (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2000-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * This file can be compiled without the rest of the FreeType engine, by</span>
<span class="line-modified">!    * defining the STANDALONE_ macro when compiling it.  You also need to</span>
<span class="line-modified">!    * put the files `ftgrays.h&#39; and `ftimage.h&#39; into the current</span>
<span class="line-modified">!    * compilation directory.  Typically, you could do something like</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - copy `src/smooth/ftgrays.c&#39; (this file) to your current directory</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - copy `include/freetype/ftimage.h&#39; and `src/smooth/ftgrays.h&#39; to the</span>
<span class="line-modified">!    *   same directory</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - compile `ftgrays&#39; with the STANDALONE_ macro defined, as in</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *     cc -c -DSTANDALONE_ ftgrays.c</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The renderer can be initialized with a call to</span>
<span class="line-modified">!    * `ft_gray_raster.raster_new&#39;; an anti-aliased bitmap can be generated</span>
<span class="line-modified">!    * with a call to `ft_gray_raster.raster_render&#39;.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * See the comments and documentation in the file `ftimage.h&#39; for more</span>
<span class="line-modified">!    * details on how the raster works.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * This is a new anti-aliasing scan-converter for FreeType 2.  The</span>
<span class="line-modified">!    * algorithm used here is _very_ different from the one in the standard</span>
<span class="line-modified">!    * `ftraster&#39; module.  Actually, `ftgrays&#39; computes the _exact_</span>
<span class="line-modified">!    * coverage of the outline on each pixel cell by straight segments.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * It is based on ideas that I initially found in Raph Levien&#39;s</span>
<span class="line-modified">!    * excellent LibArt graphics library (see https://www.levien.com/libart</span>
<span class="line-modified">!    * for more information, though the web pages do not tell anything</span>
<span class="line-modified">!    * about the renderer; you&#39;ll have to dive into the source code to</span>
<span class="line-modified">!    * understand how it works).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Note, however, that this is a _very_ different implementation</span>
<span class="line-modified">!    * compared to Raph&#39;s.  Coverage information is stored in a very</span>
<span class="line-modified">!    * different way, and I don&#39;t use sorted vector paths.  Also, it doesn&#39;t</span>
<span class="line-modified">!    * use floating point values.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Bézier segments are flattened by splitting them until their deviation</span>
<span class="line-modified">!    * from straight line becomes much smaller than a pixel.  Therefore, the</span>
<span class="line-modified">!    * pixel coverage by a Bézier curve is calculated approximately.  To</span>
<span class="line-modified">!    * estimate the deviation, we use the distance from the control point</span>
<span class="line-modified">!    * to the conic chord centre or the cubic chord trisection.  These</span>
<span class="line-modified">!    * distances vanish fast after each split.  In the conic case, they vanish</span>
<span class="line-modified">!    * predictably and the number of necessary splits can be calculated.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * This renderer has the following advantages:</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - It doesn&#39;t need an intermediate bitmap.  Instead, one can supply a</span>
<span class="line-modified">!    *   callback function that will be called by the renderer to draw gray</span>
<span class="line-modified">!    *   spans on any target surface.  You can thus do direct composition on</span>
<span class="line-modified">!    *   any kind of bitmap, provided that you give the renderer the right</span>
<span class="line-modified">!    *   callback.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - A perfect anti-aliaser, i.e., it computes the _exact_ coverage on</span>
<span class="line-modified">!    *   each pixel cell by straight segments.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - It performs a single pass on the outline (the `standard&#39; FT2</span>
<span class="line-modified">!    *   renderer makes two passes).</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - It can easily be modified to render to _any_ number of gray levels</span>
<span class="line-modified">!    *   cheaply.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * - For small (&lt; 80) pixel sizes, it is faster than the standard</span>
<span class="line-modified">!    *   renderer.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
<span class="line-added">+   /**************************************************************************</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-added">+    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-added">+    * messages during execution.</span>
<span class="line-added">+    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  smooth</span>
  
  
  #ifdef STANDALONE_
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,13 ***</span>
  #define FT_MAX( a, b )  ( (a) &gt; (b) ? (a) : (b) )
  #define FT_ABS( a )     ( (a) &lt; 0 ? -(a) : (a) )
  
  
    /*
<span class="line-modified">!    *  Approximate sqrt(x*x+y*y) using the `alpha max plus beta min&#39;</span>
<span class="line-modified">!    *  algorithm.  We use alpha = 1, beta = 3/8, giving us results with a</span>
<span class="line-modified">!    *  largest error less than 7% compared to the exact value.</span>
     */
  #define FT_HYPOT( x, y )                 \
            ( x = FT_ABS( x ),             \
              y = FT_ABS( y ),             \
              x &gt; y ? x + ( 3 * y &gt;&gt; 3 )   \
<span class="line-new-header">--- 118,13 ---</span>
  #define FT_MAX( a, b )  ( (a) &gt; (b) ? (a) : (b) )
  #define FT_ABS( a )     ( (a) &lt; 0 ? -(a) : (a) )
  
  
    /*
<span class="line-modified">!    * Approximate sqrt(x*x+y*y) using the `alpha max plus beta min&#39;</span>
<span class="line-modified">!    * algorithm.  We use alpha = 1, beta = 3/8, giving us results with a</span>
<span class="line-modified">!    * largest error less than 7% compared to the exact value.</span>
     */
  #define FT_HYPOT( x, y )                 \
            ( x = FT_ABS( x ),             \
              y = FT_ABS( y ),             \
              x &gt; y ? x + ( 3 * y &gt;&gt; 3 )   \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,14 ***</span>
  #ifndef FT_ERROR
  #define FT_ERROR( varformat )   FT_Message varformat
  #endif
  
  #define FT_THROW( e )                               \
<span class="line-modified">!           ( FT_Throw( FT_ERR_CAT( ErrRaster, e ),   \</span>
                        __LINE__,                     \
                        __FILE__ )                  | \
<span class="line-modified">!             FT_ERR_CAT( ErrRaster, e )            )</span>
  
  #else /* !FT_DEBUG_LEVEL_TRACE */
  
  #define FT_TRACE5( x )  do { } while ( 0 )     /* nothing */
  #define FT_TRACE7( x )  do { } while ( 0 )     /* nothing */
<span class="line-new-header">--- 228,14 ---</span>
  #ifndef FT_ERROR
  #define FT_ERROR( varformat )   FT_Message varformat
  #endif
  
  #define FT_THROW( e )                               \
<span class="line-modified">!           ( FT_Throw( FT_ERR_CAT( ErrRaster_, e ),  \</span>
                        __LINE__,                     \
                        __FILE__ )                  | \
<span class="line-modified">!             FT_ERR_CAT( ErrRaster_, e )           )</span>
  
  #else /* !FT_DEBUG_LEVEL_TRACE */
  
  #define FT_TRACE5( x )  do { } while ( 0 )     /* nothing */
  #define FT_TRACE7( x )  do { } while ( 0 )     /* nothing */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 277,12 ***</span>
  #include FT_INTERNAL_CALC_H
  #include FT_OUTLINE_H
  
  #include &quot;ftsmerrs.h&quot;
  
<span class="line-removed">- #include &quot;ftspic.h&quot;</span>
<span class="line-removed">- </span>
  #define Smooth_Err_Invalid_Mode     Smooth_Err_Cannot_Render_Glyph
  #define Smooth_Err_Memory_Overflow  Smooth_Err_Out_Of_Memory
  #define ErrRaster_Memory_Overflow   Smooth_Err_Out_Of_Memory
  
  
<span class="line-new-header">--- 285,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 327,21 ***</span>
  
  
    /* must be at least 6 bits! */
  #define PIXEL_BITS  8
  
<span class="line-removed">- #undef FLOOR</span>
<span class="line-removed">- #undef CEILING</span>
<span class="line-removed">- #undef TRUNC</span>
<span class="line-removed">- #undef SCALED</span>
<span class="line-removed">- </span>
  #define ONE_PIXEL       ( 1 &lt;&lt; PIXEL_BITS )
<span class="line-modified">! #define TRUNC( x )      ( (TCoord)( (x) &gt;&gt; PIXEL_BITS ) )</span>
<span class="line-modified">! #define SUBPIXELS( x )  ( (TPos)(x) * ONE_PIXEL )</span>
<span class="line-removed">- #define FLOOR( x )      ( (x) &amp; -ONE_PIXEL )</span>
<span class="line-removed">- #define CEILING( x )    ( ( (x) + ONE_PIXEL - 1 ) &amp; -ONE_PIXEL )</span>
<span class="line-removed">- #define ROUND( x )      ( ( (x) + ONE_PIXEL / 2 ) &amp; -ONE_PIXEL )</span>
  
  #if PIXEL_BITS &gt;= 6
  #define UPSCALE( x )    ( (x) * ( ONE_PIXEL &gt;&gt; 6 ) )
  #define DOWNSCALE( x )  ( (x) &gt;&gt; ( PIXEL_BITS - 6 ) )
  #else
<span class="line-new-header">--- 333,13 ---</span>
  
  
    /* must be at least 6 bits! */
  #define PIXEL_BITS  8
  
  #define ONE_PIXEL       ( 1 &lt;&lt; PIXEL_BITS )
<span class="line-modified">! #define TRUNC( x )      (TCoord)( (x) &gt;&gt; PIXEL_BITS )</span>
<span class="line-modified">! #define FRACT( x )      (TCoord)( (x) &amp; ( ONE_PIXEL - 1 ) )</span>
  
  #if PIXEL_BITS &gt;= 6
  #define UPSCALE( x )    ( (x) * ( ONE_PIXEL &gt;&gt; 6 ) )
  #define DOWNSCALE( x )  ( (x) &gt;&gt; ( PIXEL_BITS - 6 ) )
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 388,19 ***</span>
    /* These macros speed up repetitive divisions by replacing them */
    /* with multiplications and right shifts.                       */
  #define FT_UDIVPREP( c, b )                                        \
    long  b ## _r = c ? (long)( FT_ULONG_MAX &gt;&gt; PIXEL_BITS ) / ( b ) \
                      : 0
<span class="line-modified">! #define FT_UDIV( a, b )                                        \</span>
<span class="line-modified">!   ( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) &gt;&gt;   \</span>
<span class="line-modified">!     ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )</span>
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*   TYPE DEFINITIONS                                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
  
    /* don&#39;t change the following types to FT_Int or FT_Pos, since we might */
    /* need to define them to &quot;float&quot; or &quot;double&quot; when experimenting with   */
    /* new algorithms                                                       */
  
<span class="line-new-header">--- 386,19 ---</span>
    /* These macros speed up repetitive divisions by replacing them */
    /* with multiplications and right shifts.                       */
  #define FT_UDIVPREP( c, b )                                        \
    long  b ## _r = c ? (long)( FT_ULONG_MAX &gt;&gt; PIXEL_BITS ) / ( b ) \
                      : 0
<span class="line-modified">! #define FT_UDIV( a, b )                                                \</span>
<span class="line-modified">!   (TCoord)( ( (unsigned long)( a ) * (unsigned long)( b ## _r ) ) &gt;&gt;   \</span>
<span class="line-modified">!             ( sizeof( long ) * FT_CHAR_BIT - PIXEL_BITS ) )</span>
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * TYPE DEFINITIONS</span>
<span class="line-modified">!    */</span>
  
    /* don&#39;t change the following types to FT_Int or FT_Pos, since we might */
    /* need to define them to &quot;float&quot; or &quot;double&quot; when experimenting with   */
    /* new algorithms                                                       */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 432,10 ***</span>
<span class="line-new-header">--- 430,13 ---</span>
  #define FT_MAX_GRAY_POOL  ( FT_RENDER_POOL_SIZE / sizeof ( TCell ) )
  #else
  #define FT_MAX_GRAY_POOL  ( 2048 / sizeof ( TCell ) )
  #endif
  
<span class="line-added">+   /* FT_Span buffer size for direct rendering only */</span>
<span class="line-added">+ #define FT_MAX_GRAY_SPANS  10</span>
<span class="line-added">+ </span>
  
  #if defined( _MSC_VER )      /* Visual C++ (and Intel C++) */
    /* We disable the warning `structure was padded due to   */
    /* __declspec(align())&#39; in order to compile cleanly with */
    /* the maximum level of warnings.                        */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 465,10 ***</span>
<span class="line-new-header">--- 466,12 ---</span>
      FT_Outline  outline;
      TPixmap     target;
  
      FT_Raster_Span_Func  render_span;
      void*                render_span_data;
<span class="line-added">+     FT_Span              spans[FT_MAX_GRAY_SPANS];</span>
<span class="line-added">+     int                  num_spans;</span>
  
    } gray_TWorker, *gray_PWorker;
  
  #if defined( _MSC_VER )
  #pragma warning( pop )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 514,26 ***</span>
    }
  
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Record the current cell in the table.                                 */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    gray_record_cell( RAS_ARG )
    {
      PCell  *pcell, cell;
      TCoord  x = ras.ex;
  
  
      pcell = &amp;ras.ycells[ras.ey - ras.min_ey];
<span class="line-modified">!     for (;;)</span>
      {
<span class="line-modified">!       cell = *pcell;</span>
<span class="line-removed">-       if ( !cell || cell-&gt;x &gt; x )</span>
          break;
  
        if ( cell-&gt;x == x )
          goto Found;
  
<span class="line-new-header">--- 517,25 ---</span>
    }
  
  #endif /* FT_DEBUG_LEVEL_TRACE */
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Record the current cell in the linked list.</span>
<span class="line-modified">!    */</span>
    static void
    gray_record_cell( RAS_ARG )
    {
      PCell  *pcell, cell;
      TCoord  x = ras.ex;
  
  
      pcell = &amp;ras.ycells[ras.ey - ras.min_ey];
<span class="line-modified">!     while ( ( cell = *pcell ) )</span>
      {
<span class="line-modified">!       if ( cell-&gt;x &gt; x )</span>
          break;
  
        if ( cell-&gt;x == x )
          goto Found;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 559,14 ***</span>
      cell-&gt;area  += ras.area;
      cell-&gt;cover += ras.cover;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Set the current cell to a new position.                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    gray_set_cell( RAS_ARG_ TCoord  ex,
                            TCoord  ey )
    {
      /* Move the cell pointer to a new position.  We set the `invalid&#39;      */
<span class="line-new-header">--- 561,14 ---</span>
      cell-&gt;area  += ras.area;
      cell-&gt;cover += ras.cover;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Set the current cell to a new position.</span>
<span class="line-modified">!    */</span>
    static void
    gray_set_cell( RAS_ARG_ TCoord  ex,
                            TCoord  ey )
    {
      /* Move the cell pointer to a new position.  We set the `invalid&#39;      */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 577,33 ***</span>
      /* . the new horizontal position must be strictly less than max_ex     */
      /*                                                                     */
      /* Note that if a cell is to the left of the clipping region, it is    */
      /* actually set to the (min_ex-1) horizontal position.                 */
  
<span class="line-removed">-     if ( ex &lt; ras.min_ex )</span>
<span class="line-removed">-       ex = ras.min_ex - 1;</span>
<span class="line-removed">- </span>
      /* record the current one if it is valid and substantial */
      if ( !ras.invalid &amp;&amp; ( ras.area || ras.cover ) )
        gray_record_cell( RAS_VAR );
  
      ras.area  = 0;
      ras.cover = 0;
<span class="line-modified">!     ras.ex    = ex;</span>
      ras.ey    = ey;
  
      ras.invalid = ( ey &gt;= ras.max_ey || ey &lt; ras.min_ey ||
                      ex &gt;= ras.max_ex );
    }
  
  
  #ifndef FT_LONG64
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Render a scanline as one or more cells.                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    gray_render_scanline( RAS_ARG_ TCoord  ey,
                                   TPos    x1,
                                   TCoord  y1,
                                   TPos    x2,
<span class="line-new-header">--- 579,30 ---</span>
      /* . the new horizontal position must be strictly less than max_ex     */
      /*                                                                     */
      /* Note that if a cell is to the left of the clipping region, it is    */
      /* actually set to the (min_ex-1) horizontal position.                 */
  
      /* record the current one if it is valid and substantial */
      if ( !ras.invalid &amp;&amp; ( ras.area || ras.cover ) )
        gray_record_cell( RAS_VAR );
  
      ras.area  = 0;
      ras.cover = 0;
<span class="line-modified">!     ras.ex    = FT_MAX( ex, ras.min_ex - 1 );</span>
      ras.ey    = ey;
  
      ras.invalid = ( ey &gt;= ras.max_ey || ey &lt; ras.min_ey ||
                      ex &gt;= ras.max_ex );
    }
  
  
  #ifndef FT_LONG64
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Render a scanline as one or more cells.</span>
<span class="line-modified">!    */</span>
    static void
    gray_render_scanline( RAS_ARG_ TCoord  ey,
                                   TPos    x1,
                                   TCoord  y1,
                                   TPos    x2,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 622,12 ***</span>
      {
        gray_set_cell( RAS_VAR_ ex2, ey );
        return;
      }
  
<span class="line-modified">!     fx1   = (TCoord)( x1 - SUBPIXELS( ex1 ) );</span>
<span class="line-modified">!     fx2   = (TCoord)( x2 - SUBPIXELS( ex2 ) );</span>
  
      /* everything is located in a single cell.  That is easy! */
      /*                                                        */
      if ( ex1 == ex2 )
        goto End;
<span class="line-new-header">--- 621,12 ---</span>
      {
        gray_set_cell( RAS_VAR_ ex2, ey );
        return;
      }
  
<span class="line-modified">!     fx1   = FRACT( x1 );</span>
<span class="line-modified">!     fx2   = FRACT( x2 );</span>
  
      /* everything is located in a single cell.  That is easy! */
      /*                                                        */
      if ( ex1 == ex2 )
        goto End;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,10 ***</span>
<span class="line-new-header">--- 649,13 ---</span>
        first = 0;
        incr  = -1;
        dx    = -dx;
      }
  
<span class="line-added">+     /* the fractional part of y-delta is mod/dx. It is essential to */</span>
<span class="line-added">+     /* keep track of its accumulation for accurate rendering.       */</span>
<span class="line-added">+     /* XXX: y-delta and x-delta below should be related.            */</span>
      FT_DIV_MOD( TCoord, p, dx, delta, mod );
  
      ras.area  += (TArea)( ( fx1 + first ) * delta );
      ras.cover += delta;
      y1        += delta;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,14 ***</span>
      ras.area  += (TArea)( ( fx1 + fx2 ) * dy );
      ras.cover += dy;
    }
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Render a given line as a series of scanlines.                         */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
      TCoord  ey1, ey2, fy1, fy2, first, delta, mod;
<span class="line-new-header">--- 696,14 ---</span>
      ras.area  += (TArea)( ( fx1 + fx2 ) * dy );
      ras.cover += dy;
    }
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Render a given line as a series of scanlines.</span>
<span class="line-modified">!    */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
      TCoord  ey1, ey2, fy1, fy2, first, delta, mod;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 715,12 ***</span>
      /* perform vertical clipping */
      if ( ( ey1 &gt;= ras.max_ey &amp;&amp; ey2 &gt;= ras.max_ey ) ||
           ( ey1 &lt;  ras.min_ey &amp;&amp; ey2 &lt;  ras.min_ey ) )
        goto End;
  
<span class="line-modified">!     fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );</span>
<span class="line-modified">!     fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );</span>
  
      /* everything is on a single scanline */
      if ( ey1 == ey2 )
      {
        gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, to_x, fy2 );
<span class="line-new-header">--- 717,12 ---</span>
      /* perform vertical clipping */
      if ( ( ey1 &gt;= ras.max_ey &amp;&amp; ey2 &gt;= ras.max_ey ) ||
           ( ey1 &lt;  ras.min_ey &amp;&amp; ey2 &lt;  ras.min_ey ) )
        goto End;
  
<span class="line-modified">!     fy1 = FRACT( ras.y );</span>
<span class="line-modified">!     fy2 = FRACT( to_y );</span>
  
      /* everything is on a single scanline */
      if ( ey1 == ey2 )
      {
        gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, to_x, fy2 );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 732,11 ***</span>
  
      /* vertical line - avoid calling gray_render_scanline */
      if ( dx == 0 )
      {
        TCoord  ex     = TRUNC( ras.x );
<span class="line-modified">!       TCoord  two_fx = (TCoord)( ( ras.x - SUBPIXELS( ex ) ) &lt;&lt; 1 );</span>
        TArea   area;
  
  
        if ( dy &gt; 0)
        {
<span class="line-new-header">--- 734,11 ---</span>
  
      /* vertical line - avoid calling gray_render_scanline */
      if ( dx == 0 )
      {
        TCoord  ex     = TRUNC( ras.x );
<span class="line-modified">!       TCoord  two_fx = FRACT( ras.x ) &lt;&lt; 1;</span>
        TArea   area;
  
  
        if ( dy &gt; 0)
        {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,10 ***</span>
<span class="line-new-header">--- 789,12 ---</span>
        first = 0;
        incr  = -1;
        dy    = -dy;
      }
  
<span class="line-added">+     /* the fractional part of x-delta is mod/dy. It is essential to */</span>
<span class="line-added">+     /* keep track of its accumulation for accurate rendering.       */</span>
      FT_DIV_MOD( TCoord, p, dy, delta, mod );
  
      x = ras.x + delta;
      gray_render_scanline( RAS_VAR_ ey1, ras.x, fy1, x, first );
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 835,20 ***</span>
      ras.y       = to_y;
    }
  
  #else
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* Render a straight line across multiple cells in any direction.        */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
<span class="line-modified">!     TPos    dx, dy, fx1, fy1, fx2, fy2;</span>
<span class="line-modified">!     TCoord  ex1, ex2, ey1, ey2;</span>
  
  
      ey1 = TRUNC( ras.y );
      ey2 = TRUNC( to_y );
  
<span class="line-new-header">--- 839,21 ---</span>
      ras.y       = to_y;
    }
  
  #else
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * Render a straight line across multiple cells in any direction.</span>
<span class="line-modified">!    */</span>
    static void
    gray_render_line( RAS_ARG_ TPos  to_x,
                               TPos  to_y )
    {
<span class="line-modified">!     TPos    dx, dy;</span>
<span class="line-modified">!     TCoord  fx1, fy1, fx2, fy2;</span>
<span class="line-added">+     TCoord  ex1, ey1, ex2, ey2;</span>
  
  
      ey1 = TRUNC( ras.y );
      ey2 = TRUNC( to_y );
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 858,22 ***</span>
        goto End;
  
      ex1 = TRUNC( ras.x );
      ex2 = TRUNC( to_x );
  
<span class="line-modified">!     fx1 = ras.x - SUBPIXELS( ex1 );</span>
<span class="line-modified">!     fy1 = ras.y - SUBPIXELS( ey1 );</span>
  
      dx = to_x - ras.x;
      dy = to_y - ras.y;
  
      if ( ex1 == ex2 &amp;&amp; ey1 == ey2 )       /* inside one cell */
        ;
      else if ( dy == 0 ) /* ex1 != ex2 */  /* any horizontal line */
      {
<span class="line-modified">!       ex1 = ex2;</span>
<span class="line-modified">!       gray_set_cell( RAS_VAR_ ex1, ey1 );</span>
      }
      else if ( dx == 0 )
      {
        if ( dy &gt; 0 )                       /* vertical line up */
          do
<span class="line-new-header">--- 863,22 ---</span>
        goto End;
  
      ex1 = TRUNC( ras.x );
      ex2 = TRUNC( to_x );
  
<span class="line-modified">!     fx1 = FRACT( ras.x );</span>
<span class="line-modified">!     fy1 = FRACT( ras.y );</span>
  
      dx = to_x - ras.x;
      dy = to_y - ras.y;
  
      if ( ex1 == ex2 &amp;&amp; ey1 == ey2 )       /* inside one cell */
        ;
      else if ( dy == 0 ) /* ex1 != ex2 */  /* any horizontal line */
      {
<span class="line-modified">!       gray_set_cell( RAS_VAR_ ex2, ey2 );</span>
<span class="line-modified">!       goto End;</span>
      }
      else if ( dx == 0 )
      {
        if ( dy &gt; 0 )                       /* vertical line up */
          do
</pre>
<hr />
<pre>
<span class="line-old-header">*** 896,11 ***</span>
            gray_set_cell( RAS_VAR_ ex1, ey1 );
          } while ( ey1 != ey2 );
      }
      else                                  /* any other line */
      {
<span class="line-modified">!       TPos  prod = dx * fy1 - dy * fx1;</span>
        FT_UDIVPREP( ex1 != ex2, dx );
        FT_UDIVPREP( ey1 != ey2, dy );
  
  
        /* The fundamental value `prod&#39; determines which side and the  */
<span class="line-new-header">--- 901,11 ---</span>
            gray_set_cell( RAS_VAR_ ex1, ey1 );
          } while ( ey1 != ey2 );
      }
      else                                  /* any other line */
      {
<span class="line-modified">!       TPos  prod = dx * (TPos)fy1 - dy * (TPos)fx1;</span>
        FT_UDIVPREP( ex1 != ex2, dx );
        FT_UDIVPREP( ey1 != ey2, dy );
  
  
        /* The fundamental value `prod&#39; determines which side and the  */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,11 ***</span>
        {
          if      ( prod                                   &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL                  &gt;  0 ) /* left */
          {
            fx2 = 0;
<span class="line-modified">!           fy2 = (TPos)FT_UDIV( -prod, -dx );</span>
            prod -= dy * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = ONE_PIXEL;
            fy1 = fy2;
<span class="line-new-header">--- 915,11 ---</span>
        {
          if      ( prod                                   &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL                  &gt;  0 ) /* left */
          {
            fx2 = 0;
<span class="line-modified">!           fy2 = FT_UDIV( -prod, -dx );</span>
            prod -= dy * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = ONE_PIXEL;
            fy1 = fy2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 922,11 ***</span>
          }
          else if ( prod - dx * ONE_PIXEL                  &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL + dy * ONE_PIXEL &gt;  0 ) /* up */
          {
            prod -= dx * ONE_PIXEL;
<span class="line-modified">!           fx2 = (TPos)FT_UDIV( -prod, dy );</span>
            fy2 = ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
            fy1 = 0;
<span class="line-new-header">--- 927,11 ---</span>
          }
          else if ( prod - dx * ONE_PIXEL                  &lt;= 0 &amp;&amp;
                    prod - dx * ONE_PIXEL + dy * ONE_PIXEL &gt;  0 ) /* up */
          {
            prod -= dx * ONE_PIXEL;
<span class="line-modified">!           fx2 = FT_UDIV( -prod, dy );</span>
            fy2 = ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
            fy1 = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 935,21 ***</span>
          else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL &lt;= 0 &amp;&amp;
                    prod                  + dy * ONE_PIXEL &gt;= 0 ) /* right */
          {
            prod += dy * ONE_PIXEL;
            fx2 = ONE_PIXEL;
<span class="line-modified">!           fy2 = (TPos)FT_UDIV( prod, dx );</span>
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = 0;
            fy1 = fy2;
            ex1++;
          }
          else /* ( prod                  + dy * ONE_PIXEL &lt;  0 &amp;&amp;
                    prod                                   &gt;  0 )    down */
          {
<span class="line-modified">!           fx2 = (TPos)FT_UDIV( prod, -dy );</span>
            fy2 = 0;
            prod += dx * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
<span class="line-new-header">--- 940,21 ---</span>
          else if ( prod - dx * ONE_PIXEL + dy * ONE_PIXEL &lt;= 0 &amp;&amp;
                    prod                  + dy * ONE_PIXEL &gt;= 0 ) /* right */
          {
            prod += dy * ONE_PIXEL;
            fx2 = ONE_PIXEL;
<span class="line-modified">!           fy2 = FT_UDIV( prod, dx );</span>
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = 0;
            fy1 = fy2;
            ex1++;
          }
          else /* ( prod                  + dy * ONE_PIXEL &lt;  0 &amp;&amp;
                    prod                                   &gt;  0 )    down */
          {
<span class="line-modified">!           fx2 = FT_UDIV( prod, -dy );</span>
            fy2 = 0;
            prod += dx * ONE_PIXEL;
            ras.cover += ( fy2 - fy1 );
            ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
            fx1 = fx2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 959,12 ***</span>
  
          gray_set_cell( RAS_VAR_ ex1, ey1 );
        } while ( ex1 != ex2 || ey1 != ey2 );
      }
  
<span class="line-modified">!     fx2 = to_x - SUBPIXELS( ex2 );</span>
<span class="line-modified">!     fy2 = to_y - SUBPIXELS( ey2 );</span>
  
      ras.cover += ( fy2 - fy1 );
      ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
  
    End:
<span class="line-new-header">--- 964,12 ---</span>
  
          gray_set_cell( RAS_VAR_ ex1, ey1 );
        } while ( ex1 != ex2 || ey1 != ey2 );
      }
  
<span class="line-modified">!     fx2 = FRACT( to_x );</span>
<span class="line-modified">!     fy2 = FRACT( to_y );</span>
  
      ras.cover += ( fy2 - fy1 );
      ras.area  += ( fy2 - fy1 ) * ( fx1 + fx2 );
  
    End:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 979,20 ***</span>
    {
      TPos  a, b;
  
  
      base[4].x = base[2].x;
<span class="line-modified">!     b = base[1].x;</span>
<span class="line-modified">!     a = base[3].x = ( base[2].x + b ) / 2;</span>
<span class="line-modified">!     b = base[1].x = ( base[0].x + b ) / 2;</span>
<span class="line-modified">!     base[2].x = ( a + b ) / 2;</span>
  
      base[4].y = base[2].y;
<span class="line-modified">!     b = base[1].y;</span>
<span class="line-modified">!     a = base[3].y = ( base[2].y + b ) / 2;</span>
<span class="line-modified">!     b = base[1].y = ( base[0].y + b ) / 2;</span>
<span class="line-modified">!     base[2].y = ( a + b ) / 2;</span>
    }
  
  
    static void
    gray_render_conic( RAS_ARG_ const FT_Vector*  control,
<span class="line-new-header">--- 984,22 ---</span>
    {
      TPos  a, b;
  
  
      base[4].x = base[2].x;
<span class="line-modified">!     a = base[0].x + base[1].x;</span>
<span class="line-modified">!     b = base[1].x + base[2].x;</span>
<span class="line-modified">!     base[3].x = b &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].x = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added">+     base[1].x = a &gt;&gt; 1;</span>
  
      base[4].y = base[2].y;
<span class="line-modified">!     a = base[0].y + base[1].y;</span>
<span class="line-modified">!     b = base[1].y + base[2].y;</span>
<span class="line-modified">!     base[3].y = b &gt;&gt; 1;</span>
<span class="line-modified">!     base[2].y = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added">+     base[1].y = a &gt;&gt; 1;</span>
    }
  
  
    static void
    gray_render_conic( RAS_ARG_ const FT_Vector*  control,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1042,16 ***</span>
      /* We use decrement counter to count the total number of segments */
      /* to draw starting from 2^level. Before each draw we split as    */
      /* many times as there are trailing zeros in the counter.         */
      do
      {
<span class="line-modified">!       split = 1;</span>
<span class="line-modified">!       while ( ( draw &amp; split ) == 0 )</span>
        {
          gray_split_conic( arc );
          arc += 2;
<span class="line-removed">-         split &lt;&lt;= 1;</span>
        }
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
        arc -= 2;
  
<span class="line-new-header">--- 1049,15 ---</span>
      /* We use decrement counter to count the total number of segments */
      /* to draw starting from 2^level. Before each draw we split as    */
      /* many times as there are trailing zeros in the counter.         */
      do
      {
<span class="line-modified">!       split = draw &amp; ( -draw );  /* isolate the rightmost 1-bit */</span>
<span class="line-modified">!       while ( ( split &gt;&gt;= 1 ) )</span>
        {
          gray_split_conic( arc );
          arc += 2;
        }
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
        arc -= 2;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,45 ***</span>
  
  
    static void
    gray_split_cubic( FT_Vector*  base )
    {
<span class="line-modified">!     TPos  a, b, c, d;</span>
  
  
      base[6].x = base[3].x;
<span class="line-modified">!     c = base[1].x;</span>
<span class="line-modified">!     d = base[2].x;</span>
<span class="line-modified">!     base[1].x = a = ( base[0].x + c ) / 2;</span>
<span class="line-modified">!     base[5].x = b = ( base[3].x + d ) / 2;</span>
<span class="line-modified">!     c = ( c + d ) / 2;</span>
<span class="line-modified">!     base[2].x = a = ( a + c ) / 2;</span>
<span class="line-modified">!     base[4].x = b = ( b + c ) / 2;</span>
<span class="line-modified">!     base[3].x = ( a + b ) / 2;</span>
  
      base[6].y = base[3].y;
<span class="line-modified">!     c = base[1].y;</span>
<span class="line-modified">!     d = base[2].y;</span>
<span class="line-modified">!     base[1].y = a = ( base[0].y + c ) / 2;</span>
<span class="line-modified">!     base[5].y = b = ( base[3].y + d ) / 2;</span>
<span class="line-modified">!     c = ( c + d ) / 2;</span>
<span class="line-modified">!     base[2].y = a = ( a + c ) / 2;</span>
<span class="line-modified">!     base[4].y = b = ( b + c ) / 2;</span>
<span class="line-modified">!     base[3].y = ( a + b ) / 2;</span>
    }
  
  
    static void
    gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,
                                const FT_Vector*  control2,
                                const FT_Vector*  to )
    {
      FT_Vector   bez_stack[16 * 3 + 1];  /* enough to accommodate bisections */
      FT_Vector*  arc = bez_stack;
<span class="line-removed">-     TPos        dx, dy, dx_, dy_;</span>
<span class="line-removed">-     TPos        dx1, dy1, dx2, dy2;</span>
<span class="line-removed">-     TPos        L, s, s_limit;</span>
  
  
      arc[0].x = UPSCALE( to-&gt;x );
      arc[0].y = UPSCALE( to-&gt;y );
      arc[1].x = UPSCALE( control2-&gt;x );
<span class="line-new-header">--- 1066,46 ---</span>
  
  
    static void
    gray_split_cubic( FT_Vector*  base )
    {
<span class="line-modified">!     TPos  a, b, c;</span>
  
  
      base[6].x = base[3].x;
<span class="line-modified">!     a = base[0].x + base[1].x;</span>
<span class="line-modified">!     b = base[1].x + base[2].x;</span>
<span class="line-modified">!     c = base[2].x + base[3].x;</span>
<span class="line-modified">!     base[5].x = c &gt;&gt; 1;</span>
<span class="line-modified">!     c += b;</span>
<span class="line-modified">!     base[4].x = c &gt;&gt; 2;</span>
<span class="line-modified">!     base[1].x = a &gt;&gt; 1;</span>
<span class="line-modified">!     a += b;</span>
<span class="line-added">+     base[2].x = a &gt;&gt; 2;</span>
<span class="line-added">+     base[3].x = ( a + c ) &gt;&gt; 3;</span>
  
      base[6].y = base[3].y;
<span class="line-modified">!     a = base[0].y + base[1].y;</span>
<span class="line-modified">!     b = base[1].y + base[2].y;</span>
<span class="line-modified">!     c = base[2].y + base[3].y;</span>
<span class="line-modified">!     base[5].y = c &gt;&gt; 1;</span>
<span class="line-modified">!     c += b;</span>
<span class="line-modified">!     base[4].y = c &gt;&gt; 2;</span>
<span class="line-modified">!     base[1].y = a &gt;&gt; 1;</span>
<span class="line-modified">!     a += b;</span>
<span class="line-added">+     base[2].y = a &gt;&gt; 2;</span>
<span class="line-added">+     base[3].y = ( a + c ) &gt;&gt; 3;</span>
    }
  
  
    static void
    gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,
                                const FT_Vector*  control2,
                                const FT_Vector*  to )
    {
      FT_Vector   bez_stack[16 * 3 + 1];  /* enough to accommodate bisections */
      FT_Vector*  arc = bez_stack;
  
  
      arc[0].x = UPSCALE( to-&gt;x );
      arc[0].y = UPSCALE( to-&gt;y );
      arc[1].x = UPSCALE( control2-&gt;x );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1123,49 ***</span>
        return;
      }
  
      for (;;)
      {
<span class="line-modified">!       /* Decide whether to split or draw. See `Rapid Termination          */</span>
<span class="line-modified">!       /* Evaluation for Recursive Subdivision of Bezier Curves&#39; by Thomas */</span>
<span class="line-modified">!       /* F. Hain, at                                                      */</span>
<span class="line-modified">!       /* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */</span>
<span class="line-modified">! </span>
<span class="line-modified">!       /* dx and dy are x and y components of the P0-P3 chord vector. */</span>
<span class="line-modified">!       dx = dx_ = arc[3].x - arc[0].x;</span>
<span class="line-removed">-       dy = dy_ = arc[3].y - arc[0].y;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       L = FT_HYPOT( dx_, dy_ );</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* Avoid possible arithmetic overflow below by splitting. */</span>
<span class="line-removed">-       if ( L &gt; 32767 )</span>
<span class="line-removed">-         goto Split;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* Max deviation may be as much as (s/L) * 3/4 (if Hain&#39;s v = 1). */</span>
<span class="line-removed">-       s_limit = L * (TPos)( ONE_PIXEL / 6 );</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* s is L * the perpendicular distance from P1 to the line P0-P3. */</span>
<span class="line-removed">-       dx1 = arc[1].x - arc[0].x;</span>
<span class="line-removed">-       dy1 = arc[1].y - arc[0].y;</span>
<span class="line-removed">-       s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx1 ), MUL_LONG( dx, dy1 ) ) );</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if ( s &gt; s_limit )</span>
<span class="line-removed">-         goto Split;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* s is L * the perpendicular distance from P2 to the line P0-P3. */</span>
<span class="line-removed">-       dx2 = arc[2].x - arc[0].x;</span>
<span class="line-removed">-       dy2 = arc[2].y - arc[0].y;</span>
<span class="line-removed">-       s = FT_ABS( SUB_LONG( MUL_LONG( dy, dx2 ), MUL_LONG( dx, dy2 ) ) );</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if ( s &gt; s_limit )</span>
<span class="line-removed">-         goto Split;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* Split super curvy segments where the off points are so far</span>
<span class="line-removed">-          from the chord that the angles P0-P1-P3 or P0-P2-P3 become</span>
<span class="line-removed">-          acute as detected by appropriate dot products. */</span>
<span class="line-removed">-       if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) &gt; 0 ||</span>
<span class="line-removed">-            dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) &gt; 0 )</span>
          goto Split;
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
  
        if ( arc == bez_stack )
<span class="line-new-header">--- 1130,17 ---</span>
        return;
      }
  
      for (;;)
      {
<span class="line-modified">!       /* with each split, control points quickly converge towards  */</span>
<span class="line-modified">!       /* chord trisection points and the vanishing distances below */</span>
<span class="line-modified">!       /* indicate when the segment is flat enough to draw          */</span>
<span class="line-modified">!       if ( FT_ABS( 2 * arc[0].x - 3 * arc[1].x + arc[3].x ) &gt; ONE_PIXEL / 2 ||</span>
<span class="line-modified">!            FT_ABS( 2 * arc[0].y - 3 * arc[1].y + arc[3].y ) &gt; ONE_PIXEL / 2 ||</span>
<span class="line-modified">!            FT_ABS( arc[0].x - 3 * arc[2].x + 2 * arc[3].x ) &gt; ONE_PIXEL / 2 ||</span>
<span class="line-modified">!            FT_ABS( arc[0].y - 3 * arc[2].y + 2 * arc[3].y ) &gt; ONE_PIXEL / 2 )</span>
          goto Split;
  
        gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
  
        if ( arc == bez_stack )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1236,38 ***</span>
                         TArea   coverage,
                         TCoord  acount )
    {
      /* scale the coverage from 0..(ONE_PIXEL*ONE_PIXEL*2) to 0..256  */
      coverage &gt;&gt;= PIXEL_BITS * 2 + 1 - 8;
<span class="line-removed">-     if ( coverage &lt; 0 )</span>
<span class="line-removed">-       coverage = -coverage - 1;</span>
  
      /* compute the line&#39;s coverage depending on the outline fill rule */
      if ( ras.outline.flags &amp; FT_OUTLINE_EVEN_ODD_FILL )
      {
        coverage &amp;= 511;
  
        if ( coverage &gt;= 256 )
          coverage = 511 - coverage;
      }
<span class="line-modified">!     else</span>
      {
<span class="line-modified">!       /* normal non-zero winding rule */</span>
        if ( coverage &gt;= 256 )
          coverage = 255;
      }
  
<span class="line-modified">!     if ( ras.render_span )  /* for FT_RASTER_FLAG_DIRECT only */</span>
      {
<span class="line-modified">!       FT_Span  span;</span>
  
  
<span class="line-modified">!       span.x        = (short)x;</span>
<span class="line-modified">!       span.len      = (unsigned short)acount;</span>
<span class="line-modified">!       span.coverage = (unsigned char)coverage;</span>
  
<span class="line-modified">!       ras.render_span( y, 1, &amp;span, ras.render_span_data );</span>
      }
      else
      {
        unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;
        unsigned char   c = (unsigned char)coverage;
<span class="line-new-header">--- 1211,43 ---</span>
                         TArea   coverage,
                         TCoord  acount )
    {
      /* scale the coverage from 0..(ONE_PIXEL*ONE_PIXEL*2) to 0..256  */
      coverage &gt;&gt;= PIXEL_BITS * 2 + 1 - 8;
  
      /* compute the line&#39;s coverage depending on the outline fill rule */
      if ( ras.outline.flags &amp; FT_OUTLINE_EVEN_ODD_FILL )
      {
        coverage &amp;= 511;
  
        if ( coverage &gt;= 256 )
          coverage = 511 - coverage;
      }
<span class="line-modified">!     else  /* default non-zero winding rule */</span>
      {
<span class="line-modified">!       if ( coverage &lt; 0 )</span>
<span class="line-added">+         coverage = ~coverage;  /* the same as -coverage - 1 */</span>
<span class="line-added">+ </span>
        if ( coverage &gt;= 256 )
          coverage = 255;
      }
  
<span class="line-modified">!     if ( ras.num_spans &gt;= 0 )  /* for FT_RASTER_FLAG_DIRECT only */</span>
      {
<span class="line-modified">!       FT_Span*  span = ras.spans + ras.num_spans++;</span>
  
  
<span class="line-modified">!       span-&gt;x        = (short)x;</span>
<span class="line-modified">!       span-&gt;len      = (unsigned short)acount;</span>
<span class="line-modified">!       span-&gt;coverage = (unsigned char)coverage;</span>
  
<span class="line-modified">!       if ( ras.num_spans == FT_MAX_GRAY_SPANS )</span>
<span class="line-added">+       {</span>
<span class="line-added">+         /* flush the span buffer and reset the count */</span>
<span class="line-added">+         ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );</span>
<span class="line-added">+         ras.num_spans = 0;</span>
<span class="line-added">+       }</span>
      }
      else
      {
        unsigned char*  q = ras.target.origin - ras.target.pitch * y + x;
        unsigned char   c = (unsigned char)coverage;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,18 ***</span>
         * calling `memset&#39;.  This is mainly due to the cost of the
         * function call.
         */
        switch ( acount )
        {
<span class="line-modified">!       case 7: *q++ = c;</span>
<span class="line-modified">!       case 6: *q++ = c;</span>
<span class="line-modified">!       case 5: *q++ = c;</span>
<span class="line-modified">!       case 4: *q++ = c;</span>
<span class="line-modified">!       case 3: *q++ = c;</span>
<span class="line-modified">!       case 2: *q++ = c;</span>
<span class="line-modified">!       case 1: *q   = c;</span>
<span class="line-modified">!       case 0: break;</span>
        default:
          FT_MEM_SET( q, c, acount );
        }
      }
    }
<span class="line-new-header">--- 1257,33 ---</span>
         * calling `memset&#39;.  This is mainly due to the cost of the
         * function call.
         */
        switch ( acount )
        {
<span class="line-modified">!       case 7:</span>
<span class="line-modified">!         *q++ = c;</span>
<span class="line-modified">!         /* fall through */</span>
<span class="line-modified">!       case 6:</span>
<span class="line-modified">!         *q++ = c;</span>
<span class="line-modified">!         /* fall through */</span>
<span class="line-modified">!       case 5:</span>
<span class="line-modified">!         *q++ = c;</span>
<span class="line-added">+         /* fall through */</span>
<span class="line-added">+       case 4:</span>
<span class="line-added">+         *q++ = c;</span>
<span class="line-added">+         /* fall through */</span>
<span class="line-added">+       case 3:</span>
<span class="line-added">+         *q++ = c;</span>
<span class="line-added">+         /* fall through */</span>
<span class="line-added">+       case 2:</span>
<span class="line-added">+         *q++ = c;</span>
<span class="line-added">+         /* fall through */</span>
<span class="line-added">+       case 1:</span>
<span class="line-added">+         *q = c;</span>
<span class="line-added">+         /* fall through */</span>
<span class="line-added">+       case 0:</span>
<span class="line-added">+         break;</span>
        default:
          FT_MEM_SET( q, c, acount );
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1322,57 ***</span>
          x = cell-&gt;x + 1;
        }
  
        if ( cover != 0 )
          gray_hline( RAS_VAR_ x, y, cover, ras.max_ex - x );
      }
    }
  
  
  #ifdef STANDALONE_
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*  The following functions should only compile in stand-alone mode,     */</span>
<span class="line-modified">!   /*  i.e., when building this component without the rest of FreeType.     */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">!   /*    FT_Outline_Decompose                                               */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">!   /*    Walk over an outline&#39;s structure to decompose it into individual   */</span>
<span class="line-modified">!   /*    segments and Bézier arcs.  This function is also able to emit      */</span>
<span class="line-modified">!   /*    `move to&#39; and `close to&#39; operations to indicate the start and end  */</span>
<span class="line-modified">!   /*    of new contours in the outline.                                    */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">!   /*    outline        :: A pointer to the source target.                  */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /*    func_interface :: A table of `emitters&#39;, i.e., function pointers   */</span>
<span class="line-modified">!   /*                      called during decomposition to indicate path     */</span>
<span class="line-modified">!   /*                      operations.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">!   /*    user           :: A typeless pointer which is passed to each       */</span>
<span class="line-modified">!   /*                      emitter during the decomposition.  It can be     */</span>
<span class="line-modified">!   /*                      used to store the state during the               */</span>
<span class="line-modified">!   /*                      decomposition.                                   */</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">!   /*    Error code.  0 means success.                                      */</span>
<span class="line-modified">!   /*                                                                       */</span>
    static int
    FT_Outline_Decompose( const FT_Outline*        outline,
                          const FT_Outline_Funcs*  func_interface,
                          void*                    user )
    {
  #undef SCALED
<span class="line-modified">! #define SCALED( x )  ( ( (x) &lt;&lt; shift ) - delta )</span>
  
      FT_Vector   v_last;
      FT_Vector   v_control;
      FT_Vector   v_start;
  
<span class="line-new-header">--- 1317,67 ---</span>
          x = cell-&gt;x + 1;
        }
  
        if ( cover != 0 )
          gray_hline( RAS_VAR_ x, y, cover, ras.max_ex - x );
<span class="line-added">+ </span>
<span class="line-added">+       if ( ras.num_spans &gt; 0 )  /* for FT_RASTER_FLAG_DIRECT only */</span>
<span class="line-added">+       {</span>
<span class="line-added">+         /* flush the span buffer and reset the count */</span>
<span class="line-added">+         ras.render_span( y, ras.num_spans, ras.spans, ras.render_span_data );</span>
<span class="line-added">+         ras.num_spans = 0;</span>
<span class="line-added">+       }</span>
      }
    }
  
  
  #ifdef STANDALONE_
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The following functions should only compile in stand-alone mode,</span>
<span class="line-modified">!    * i.e., when building this component without the rest of FreeType.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    */</span>
<span class="line-modified">! </span>
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Function:</span>
<span class="line-modified">!    *   FT_Outline_Decompose</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Description:</span>
<span class="line-modified">!    *   Walk over an outline&#39;s structure to decompose it into individual</span>
<span class="line-modified">!    *   segments and Bézier arcs.  This function is also able to emit</span>
<span class="line-modified">!    *   `move to&#39; and `close to&#39; operations to indicate the start and end</span>
<span class="line-modified">!    *   of new contours in the outline.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @Input:</span>
<span class="line-modified">!    *   outline ::</span>
<span class="line-modified">!    *     A pointer to the source target.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    *   func_interface ::</span>
<span class="line-modified">!    *     A table of `emitters&#39;, i.e., function pointers</span>
<span class="line-modified">!    *     called during decomposition to indicate path</span>
<span class="line-modified">!    *     operations.</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * @InOut:</span>
<span class="line-modified">!    *   user ::</span>
<span class="line-modified">!    *     A typeless pointer which is passed to each</span>
<span class="line-modified">!    *     emitter during the decomposition.  It can be</span>
<span class="line-modified">!    *     used to store the state during the</span>
<span class="line-modified">!    *     decomposition.</span>
<span class="line-modified">!    *</span>
<span class="line-added">+    * @Return:</span>
<span class="line-added">+    *   Error code.  0 means success.</span>
<span class="line-added">+    */</span>
    static int
    FT_Outline_Decompose( const FT_Outline*        outline,
                          const FT_Outline_Funcs*  func_interface,
                          void*                    user )
    {
  #undef SCALED
<span class="line-modified">! #define SCALED( x )  ( (x) * ( 1L &lt;&lt; shift ) - delta )</span>
  
      FT_Vector   v_last;
      FT_Vector   v_control;
      FT_Vector   v_start;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1608,85 ***</span>
  
    Invalid_Outline:
      return FT_THROW( Invalid_Outline );
    }
  
<span class="line-removed">- </span>
<span class="line-removed">-   /*************************************************************************/</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /* &lt;Function&gt;                                                            */</span>
<span class="line-removed">-   /*    FT_Outline_Get_CBox                                                */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /* &lt;Description&gt;                                                         */</span>
<span class="line-removed">-   /*    Return an outline&#39;s `control box&#39;.  The control box encloses all   */</span>
<span class="line-removed">-   /*    the outline&#39;s points, including Bézier control points.  Though it  */</span>
<span class="line-removed">-   /*    coincides with the exact bounding box for most glyphs, it can be   */</span>
<span class="line-removed">-   /*    slightly larger in some situations (like when rotating an outline  */</span>
<span class="line-removed">-   /*    that contains Bézier outside arcs).                                */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /*    Computing the control box is very fast, while getting the bounding */</span>
<span class="line-removed">-   /*    box can take much more time as it needs to walk over all segments  */</span>
<span class="line-removed">-   /*    and arcs in the outline.  To get the latter, you can use the       */</span>
<span class="line-removed">-   /*    `ftbbox&#39; component, which is dedicated to this single task.        */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /* &lt;Input&gt;                                                               */</span>
<span class="line-removed">-   /*    outline :: A pointer to the source outline descriptor.             */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /* &lt;Output&gt;                                                              */</span>
<span class="line-removed">-   /*    acbox   :: The outline&#39;s control box.                              */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">-   /* &lt;Note&gt;                                                                */</span>
<span class="line-removed">-   /*    See @FT_Glyph_Get_CBox for a discussion of tricky fonts.           */</span>
<span class="line-removed">-   /*                                                                       */</span>
<span class="line-removed">- </span>
<span class="line-removed">-   static void</span>
<span class="line-removed">-   FT_Outline_Get_CBox( const FT_Outline*  outline,</span>
<span class="line-removed">-                        FT_BBox           *acbox )</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     TPos  xMin, yMin, xMax, yMax;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-     if ( outline &amp;&amp; acbox )</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       if ( outline-&gt;n_points == 0 )</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         xMin = 0;</span>
<span class="line-removed">-         yMin = 0;</span>
<span class="line-removed">-         xMax = 0;</span>
<span class="line-removed">-         yMax = 0;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         FT_Vector*  vec   = outline-&gt;points;</span>
<span class="line-removed">-         FT_Vector*  limit = vec + outline-&gt;n_points;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-         xMin = xMax = vec-&gt;x;</span>
<span class="line-removed">-         yMin = yMax = vec-&gt;y;</span>
<span class="line-removed">-         vec++;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         for ( ; vec &lt; limit; vec++ )</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           TPos  x, y;</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">-           x = vec-&gt;x;</span>
<span class="line-removed">-           if ( x &lt; xMin ) xMin = x;</span>
<span class="line-removed">-           if ( x &gt; xMax ) xMax = x;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           y = vec-&gt;y;</span>
<span class="line-removed">-           if ( y &lt; yMin ) yMin = y;</span>
<span class="line-removed">-           if ( y &gt; yMax ) yMax = y;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       acbox-&gt;xMin = xMin;</span>
<span class="line-removed">-       acbox-&gt;xMax = xMax;</span>
<span class="line-removed">-       acbox-&gt;yMin = yMin;</span>
<span class="line-removed">-       acbox-&gt;yMax = yMax;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
  #endif /* STANDALONE_ */
  
  
    FT_DEFINE_OUTLINE_FUNCS(
      func_interface,
<span class="line-new-header">--- 1613,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1700,23 ***</span>
      0                                        /* delta    */
    )
  
  
    static int
<span class="line-modified">!   gray_convert_glyph_inner( RAS_ARG )</span>
    {
  
<span class="line-removed">-     volatile int  error = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-       FT_Outline_Funcs func_interface;</span>
<span class="line-removed">-       Init_Class_func_interface(&amp;func_interface);</span>
<span class="line-removed">- #endif</span>
  
      if ( ft_setjmp( ras.jump_buffer ) == 0 )
      {
        error = FT_Outline_Decompose( &amp;ras.outline, &amp;func_interface, &amp;ras );
        if ( !ras.invalid )
          gray_record_cell( RAS_VAR );
  
        FT_TRACE7(( &quot;band [%d..%d]: %d cell%s\n&quot;,
                    ras.min_ey,
<span class="line-new-header">--- 1630,24 ---</span>
      0                                        /* delta    */
    )
  
  
    static int
<span class="line-modified">!   gray_convert_glyph_inner( RAS_ARG,</span>
<span class="line-added">+                             int  continued )</span>
    {
<span class="line-added">+     int  error;</span>
  
  
      if ( ft_setjmp( ras.jump_buffer ) == 0 )
      {
<span class="line-added">+       if ( continued )</span>
<span class="line-added">+         FT_Trace_Disable();</span>
        error = FT_Outline_Decompose( &amp;ras.outline, &amp;func_interface, &amp;ras );
<span class="line-added">+       if ( continued )</span>
<span class="line-added">+         FT_Trace_Enable();</span>
<span class="line-added">+ </span>
        if ( !ras.invalid )
          gray_record_cell( RAS_VAR );
  
        FT_TRACE7(( &quot;band [%d..%d]: %d cell%s\n&quot;,
                    ras.min_ey,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1739,20 ***</span>
    static int
    gray_convert_glyph( RAS_ARG )
    {
      const TCoord  yMin = ras.min_ey;
      const TCoord  yMax = ras.max_ey;
<span class="line-removed">-     const TCoord  xMin = ras.min_ex;</span>
<span class="line-removed">-     const TCoord  xMax = ras.max_ex;</span>
  
      TCell    buffer[FT_MAX_GRAY_POOL];
      size_t   height = (size_t)( yMax - yMin );
      size_t   n = FT_MAX_GRAY_POOL / 8;
      TCoord   y;
      TCoord   bands[32];  /* enough to accommodate bisections */
      TCoord*  band;
  
  
      /* set up vertical bands */
      if ( height &gt; n )
      {
        /* two divisions rounded up */
<span class="line-new-header">--- 1670,20 ---</span>
    static int
    gray_convert_glyph( RAS_ARG )
    {
      const TCoord  yMin = ras.min_ey;
      const TCoord  yMax = ras.max_ey;
  
      TCell    buffer[FT_MAX_GRAY_POOL];
      size_t   height = (size_t)( yMax - yMin );
      size_t   n = FT_MAX_GRAY_POOL / 8;
      TCoord   y;
      TCoord   bands[32];  /* enough to accommodate bisections */
      TCoord*  band;
  
<span class="line-added">+     int  continued = 0;</span>
<span class="line-added">+ </span>
  
      /* set up vertical bands */
      if ( height &gt; n )
      {
        /* two divisions rounded up */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1772,12 ***</span>
        ras.min_ey = y;
        y         += height;
        ras.max_ey = FT_MIN( y, yMax );
  
        band    = bands;
<span class="line-modified">!       band[1] = xMin;</span>
<span class="line-modified">!       band[0] = xMax;</span>
  
        do
        {
          TCoord  width = band[0] - band[1];
          int     error;
<span class="line-new-header">--- 1703,12 ---</span>
        ras.min_ey = y;
        y         += height;
        ras.max_ey = FT_MIN( y, yMax );
  
        band    = bands;
<span class="line-modified">!       band[1] = ras.min_ey;</span>
<span class="line-modified">!       band[0] = ras.max_ey;</span>
  
        do
        {
          TCoord  width = band[0] - band[1];
          int     error;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1785,14 ***</span>
  
          FT_MEM_ZERO( ras.ycells, height * sizeof ( PCell ) );
  
          ras.num_cells = 0;
          ras.invalid   = 1;
<span class="line-modified">!         ras.min_ex    = band[1];</span>
<span class="line-modified">!         ras.max_ex    = band[0];</span>
  
<span class="line-modified">!         error = gray_convert_glyph_inner( RAS_VAR );</span>
  
          if ( !error )
          {
            gray_sweep( RAS_VAR );
            band--;
<span class="line-new-header">--- 1716,15 ---</span>
  
          FT_MEM_ZERO( ras.ycells, height * sizeof ( PCell ) );
  
          ras.num_cells = 0;
          ras.invalid   = 1;
<span class="line-modified">!         ras.min_ey    = band[1];</span>
<span class="line-modified">!         ras.max_ey    = band[0];</span>
  
<span class="line-modified">!         error     = gray_convert_glyph_inner( RAS_VAR, continued );</span>
<span class="line-added">+         continued = 1;</span>
  
          if ( !error )
          {
            gray_sweep( RAS_VAR );
            band--;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1825,11 ***</span>
    gray_raster_render( FT_Raster                raster,
                        const FT_Raster_Params*  params )
    {
      const FT_Outline*  outline    = (const FT_Outline*)params-&gt;source;
      const FT_Bitmap*   target_map = params-&gt;target;
<span class="line-removed">-     FT_BBox            cbox, clip;</span>
  
  #ifndef FT_STATIC_RASTER
      gray_TWorker  worker[1];
  #endif
  
<span class="line-new-header">--- 1757,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1862,10 ***</span>
<span class="line-new-header">--- 1793,16 ---</span>
        if ( !params-&gt;gray_spans )
          return 0;
  
        ras.render_span      = (FT_Raster_Span_Func)params-&gt;gray_spans;
        ras.render_span_data = params-&gt;user;
<span class="line-added">+       ras.num_spans        = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+       ras.min_ex = params-&gt;clip_box.xMin;</span>
<span class="line-added">+       ras.min_ey = params-&gt;clip_box.yMin;</span>
<span class="line-added">+       ras.max_ex = params-&gt;clip_box.xMax;</span>
<span class="line-added">+       ras.max_ey = params-&gt;clip_box.yMax;</span>
      }
      else
      {
        /* if direct mode is not set, we must have a target bitmap */
        if ( !target_map )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1886,50 ***</span>
  
        ras.target.pitch = target_map-&gt;pitch;
  
        ras.render_span      = (FT_Raster_Span_Func)NULL;
        ras.render_span_data = NULL;
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     FT_Outline_Get_CBox( outline, &amp;cbox );</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* reject too large outline coordinates */</span>
<span class="line-removed">-     if ( cbox.xMin &lt; -0x1000000L || cbox.xMax &gt; 0x1000000L ||</span>
<span class="line-removed">-          cbox.yMin &lt; -0x1000000L || cbox.yMax &gt; 0x1000000L )</span>
<span class="line-removed">-       return FT_THROW( Invalid_Outline );</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* truncate the bounding box to integer pixels */</span>
<span class="line-removed">-     cbox.xMin = cbox.xMin &gt;&gt; 6;</span>
<span class="line-removed">-     cbox.yMin = cbox.yMin &gt;&gt; 6;</span>
<span class="line-removed">-     cbox.xMax = ( cbox.xMax + 63 ) &gt;&gt; 6;</span>
<span class="line-removed">-     cbox.yMax = ( cbox.yMax + 63 ) &gt;&gt; 6;</span>
  
<span class="line-modified">!     /* compute clipping box */</span>
<span class="line-modified">!     if ( !( params-&gt;flags &amp; FT_RASTER_FLAG_DIRECT ) )</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* compute clip box from target pixmap */</span>
<span class="line-removed">-       clip.xMin = 0;</span>
<span class="line-removed">-       clip.yMin = 0;</span>
<span class="line-removed">-       clip.xMax = (FT_Pos)target_map-&gt;width;</span>
<span class="line-removed">-       clip.yMax = (FT_Pos)target_map-&gt;rows;</span>
      }
<span class="line-removed">-     else if ( params-&gt;flags &amp; FT_RASTER_FLAG_CLIP )</span>
<span class="line-removed">-       clip = params-&gt;clip_box;</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       clip.xMin = -32768L;</span>
<span class="line-removed">-       clip.yMin = -32768L;</span>
<span class="line-removed">-       clip.xMax =  32767L;</span>
<span class="line-removed">-       clip.yMax =  32767L;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     /* clip to target bitmap, exit if nothing to do */</span>
<span class="line-removed">-     ras.min_ex = FT_MAX( cbox.xMin, clip.xMin );</span>
<span class="line-removed">-     ras.min_ey = FT_MAX( cbox.yMin, clip.yMin );</span>
<span class="line-removed">-     ras.max_ex = FT_MIN( cbox.xMax, clip.xMax );</span>
<span class="line-removed">-     ras.max_ey = FT_MIN( cbox.yMax, clip.yMax );</span>
  
      if ( ras.max_ex &lt;= ras.min_ex || ras.max_ey &lt;= ras.min_ey )
        return 0;
  
      return gray_convert_glyph( RAS_VAR );
    }
<span class="line-new-header">--- 1823,19 ---</span>
  
        ras.target.pitch = target_map-&gt;pitch;
  
        ras.render_span      = (FT_Raster_Span_Func)NULL;
        ras.render_span_data = NULL;
<span class="line-modified">!       ras.num_spans        = -1;  /* invalid */</span>
  
<span class="line-modified">!       ras.min_ex = 0;</span>
<span class="line-modified">!       ras.min_ey = 0;</span>
<span class="line-modified">!       ras.max_ex = (FT_Pos)target_map-&gt;width;</span>
<span class="line-modified">!       ras.max_ey = (FT_Pos)target_map-&gt;rows;</span>
      }
  
<span class="line-added">+     /* exit if nothing to do */</span>
      if ( ras.max_ex &lt;= ras.min_ex || ras.max_ey &lt;= ras.min_ey )
        return 0;
  
      return gray_convert_glyph( RAS_VAR );
    }
</pre>
<center><a href="../sfnt/ttsbit.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftgrays.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
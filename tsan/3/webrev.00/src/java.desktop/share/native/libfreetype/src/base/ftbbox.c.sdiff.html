<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftbbox.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftbase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftbitmap.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftbbox.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftbbox.c                                                               */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    FreeType bbox computation (body).                                    */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used        */</span>
<span class="line-modified"> 11 /*  modified and distributed under the terms of the FreeType project       */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
<span class="line-modified"> 17 </span>
<span class="line-modified"> 18 </span>
<span class="line-modified"> 19   /*************************************************************************/</span>
<span class="line-modified"> 20   /*                                                                       */</span>
<span class="line-modified"> 21   /* This component has a _single_ role: to compute exact outline bounding */</span>
<span class="line-modified"> 22   /* boxes.                                                                */</span>
<span class="line-modified"> 23   /*                                                                       */</span>
<span class="line-modified"> 24   /*************************************************************************/</span>
 25 
 26 
 27 #include &lt;ft2build.h&gt;
 28 #include FT_INTERNAL_DEBUG_H
 29 
 30 #include FT_BBOX_H
 31 #include FT_IMAGE_H
 32 #include FT_OUTLINE_H
 33 #include FT_INTERNAL_CALC_H
 34 #include FT_INTERNAL_OBJECTS_H
 35 
 36 
 37   typedef struct  TBBox_Rec_
 38   {
 39     FT_Vector  last;
 40     FT_BBox    bbox;
 41 
 42   } TBBox_Rec;
 43 
 44 
 45 #define FT_UPDATE_BBOX( p, bbox ) \
 46   FT_BEGIN_STMNT                  \
 47     if ( p-&gt;x &lt; bbox.xMin )       \
 48       bbox.xMin = p-&gt;x;           \
 49     if ( p-&gt;x &gt; bbox.xMax )       \
 50       bbox.xMax = p-&gt;x;           \
 51     if ( p-&gt;y &lt; bbox.yMin )       \
 52       bbox.yMin = p-&gt;y;           \
 53     if ( p-&gt;y &gt; bbox.yMax )       \
 54       bbox.yMax = p-&gt;y;           \
 55   FT_END_STMNT
 56 
 57 #define CHECK_X( p, bbox )                         \
 58           ( p-&gt;x &lt; bbox.xMin || p-&gt;x &gt; bbox.xMax )
 59 
 60 #define CHECK_Y( p, bbox )                         \
 61           ( p-&gt;y &lt; bbox.yMin || p-&gt;y &gt; bbox.yMax )
 62 
 63 
<span class="line-modified"> 64   /*************************************************************************/</span>
<span class="line-modified"> 65   /*                                                                       */</span>
<span class="line-modified"> 66   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 67   /*    BBox_Move_To                                                       */</span>
<span class="line-modified"> 68   /*                                                                       */</span>
<span class="line-modified"> 69   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 70   /*    This function is used as a `move_to&#39; emitter during                */</span>
<span class="line-modified"> 71   /*    FT_Outline_Decompose().  It simply records the destination point   */</span>
<span class="line-modified"> 72   /*    in `user-&gt;last&#39;. We also update bbox in case contour starts with   */</span>
<span class="line-modified"> 73   /*    an implicit `on&#39; point.                                            */</span>
<span class="line-modified"> 74   /*                                                                       */</span>
<span class="line-modified"> 75   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified"> 76   /*    to   :: A pointer to the destination vector.                       */</span>
<span class="line-modified"> 77   /*                                                                       */</span>
<span class="line-modified"> 78   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified"> 79   /*    user :: A pointer to the current walk context.                     */</span>
<span class="line-modified"> 80   /*                                                                       */</span>
<span class="line-modified"> 81   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified"> 82   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified"> 83   /*                                                                       */</span>


 84   static int
 85   BBox_Move_To( FT_Vector*  to,
 86                 TBBox_Rec*  user )
 87   {
 88     FT_UPDATE_BBOX( to, user-&gt;bbox );
 89 
 90     user-&gt;last = *to;
 91 
 92     return 0;
 93   }
 94 
 95 
<span class="line-modified"> 96   /*************************************************************************/</span>
<span class="line-modified"> 97   /*                                                                       */</span>
<span class="line-modified"> 98   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified"> 99   /*    BBox_Line_To                                                       */</span>
<span class="line-modified">100   /*                                                                       */</span>
<span class="line-modified">101   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">102   /*    This function is used as a `line_to&#39; emitter during                */</span>
<span class="line-modified">103   /*    FT_Outline_Decompose().  It simply records the destination point   */</span>
<span class="line-modified">104   /*    in `user-&gt;last&#39;; no further computations are necessary because     */</span>
<span class="line-modified">105   /*    bbox already contains both explicit ends of the line segment.      */</span>
<span class="line-modified">106   /*                                                                       */</span>
<span class="line-modified">107   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">108   /*    to   :: A pointer to the destination vector.                       */</span>
<span class="line-modified">109   /*                                                                       */</span>
<span class="line-modified">110   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">111   /*    user :: A pointer to the current walk context.                     */</span>
<span class="line-modified">112   /*                                                                       */</span>
<span class="line-modified">113   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">114   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">115   /*                                                                       */</span>


116   static int
117   BBox_Line_To( FT_Vector*  to,
118                 TBBox_Rec*  user )
119   {
120     user-&gt;last = *to;
121 
122     return 0;
123   }
124 
125 
<span class="line-modified">126   /*************************************************************************/</span>
<span class="line-modified">127   /*                                                                       */</span>
<span class="line-modified">128   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">129   /*    BBox_Conic_Check                                                   */</span>
<span class="line-modified">130   /*                                                                       */</span>
<span class="line-modified">131   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">132   /*    Find the extrema of a 1-dimensional conic Bezier curve and update  */</span>
<span class="line-modified">133   /*    a bounding range.  This version uses direct computation, as it     */</span>
<span class="line-modified">134   /*    doesn&#39;t need square roots.                                         */</span>
<span class="line-modified">135   /*                                                                       */</span>
<span class="line-modified">136   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">137   /*    y1  :: The start coordinate.                                       */</span>
<span class="line-modified">138   /*                                                                       */</span>
<span class="line-modified">139   /*    y2  :: The coordinate of the control point.                        */</span>
<span class="line-modified">140   /*                                                                       */</span>
<span class="line-modified">141   /*    y3  :: The end coordinate.                                         */</span>
<span class="line-modified">142   /*                                                                       */</span>
<span class="line-modified">143   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">144   /*    min :: The address of the current minimum.                         */</span>
<span class="line-modified">145   /*                                                                       */</span>
<span class="line-modified">146   /*    max :: The address of the current maximum.                         */</span>
<span class="line-modified">147   /*                                                                       */</span>





148   static void
149   BBox_Conic_Check( FT_Pos   y1,
150                     FT_Pos   y2,
151                     FT_Pos   y3,
152                     FT_Pos*  min,
153                     FT_Pos*  max )
154   {
155     /* This function is only called when a control off-point is outside */
156     /* the bbox that contains all on-points.  It finds a local extremum */
157     /* within the segment, equal to (y1*y3 - y2*y2)/(y1 - 2*y2 + y3).   */
158     /* Or, offsetting from y2, we get                                   */
159 
160     y1 -= y2;
161     y3 -= y2;
162     y2 += FT_MulDiv( y1, y3, y1 + y3 );
163 
164     if ( y2 &lt; *min )
165       *min = y2;
166     if ( y2 &gt; *max )
167       *max = y2;
168   }
169 
170 
<span class="line-modified">171   /*************************************************************************/</span>
<span class="line-modified">172   /*                                                                       */</span>
<span class="line-modified">173   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">174   /*    BBox_Conic_To                                                      */</span>
<span class="line-modified">175   /*                                                                       */</span>
<span class="line-modified">176   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">177   /*    This function is used as a `conic_to&#39; emitter during               */</span>
<span class="line-modified">178   /*    FT_Outline_Decompose().  It checks a conic Bezier curve with the   */</span>
<span class="line-modified">179   /*    current bounding box, and computes its extrema if necessary to     */</span>
<span class="line-modified">180   /*    update it.                                                         */</span>
<span class="line-modified">181   /*                                                                       */</span>
<span class="line-modified">182   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">183   /*    control :: A pointer to a control point.                           */</span>
<span class="line-modified">184   /*                                                                       */</span>
<span class="line-modified">185   /*    to      :: A pointer to the destination vector.                    */</span>
<span class="line-modified">186   /*                                                                       */</span>
<span class="line-modified">187   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">188   /*    user    :: The address of the current walk context.                */</span>
<span class="line-modified">189   /*                                                                       */</span>
<span class="line-modified">190   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">191   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">192   /*                                                                       */</span>
<span class="line-modified">193   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">194   /*    In the case of a non-monotonous arc, we compute directly the       */</span>
<span class="line-modified">195   /*    extremum coordinates, as it is sufficiently fast.                  */</span>
<span class="line-modified">196   /*                                                                       */</span>



197   static int
198   BBox_Conic_To( FT_Vector*  control,
199                  FT_Vector*  to,
200                  TBBox_Rec*  user )
201   {
202     /* in case `to&#39; is implicit and not included in bbox yet */
203     FT_UPDATE_BBOX( to, user-&gt;bbox );
204 
205     if ( CHECK_X( control, user-&gt;bbox ) )
206       BBox_Conic_Check( user-&gt;last.x,
207                         control-&gt;x,
208                         to-&gt;x,
209                         &amp;user-&gt;bbox.xMin,
210                         &amp;user-&gt;bbox.xMax );
211 
212     if ( CHECK_Y( control, user-&gt;bbox ) )
213       BBox_Conic_Check( user-&gt;last.y,
214                         control-&gt;y,
215                         to-&gt;y,
216                         &amp;user-&gt;bbox.yMin,
217                         &amp;user-&gt;bbox.yMax );
218 
219     user-&gt;last = *to;
220 
221     return 0;
222   }
223 
224 
<span class="line-modified">225   /*************************************************************************/</span>
<span class="line-modified">226   /*                                                                       */</span>
<span class="line-modified">227   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">228   /*    BBox_Cubic_Check                                                   */</span>
<span class="line-modified">229   /*                                                                       */</span>
<span class="line-modified">230   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">231   /*    Find the extrema of a 1-dimensional cubic Bezier curve and         */</span>
<span class="line-modified">232   /*    update a bounding range.  This version uses iterative splitting    */</span>
<span class="line-modified">233   /*    because it is faster than the exact solution with square roots.    */</span>
<span class="line-modified">234   /*                                                                       */</span>
<span class="line-modified">235   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">236   /*    p1  :: The start coordinate.                                       */</span>
<span class="line-modified">237   /*                                                                       */</span>
<span class="line-modified">238   /*    p2  :: The coordinate of the first control point.                  */</span>
<span class="line-modified">239   /*                                                                       */</span>
<span class="line-modified">240   /*    p3  :: The coordinate of the second control point.                 */</span>
<span class="line-modified">241   /*                                                                       */</span>
<span class="line-modified">242   /*    p4  :: The end coordinate.                                         */</span>
<span class="line-modified">243   /*                                                                       */</span>
<span class="line-modified">244   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">245   /*    min :: The address of the current minimum.                         */</span>
<span class="line-modified">246   /*                                                                       */</span>
<span class="line-modified">247   /*    max :: The address of the current maximum.                         */</span>
<span class="line-modified">248   /*                                                                       */</span>






249   static FT_Pos
250   cubic_peak( FT_Pos  q1,
251               FT_Pos  q2,
252               FT_Pos  q3,
253               FT_Pos  q4 )
254   {
255     FT_Pos  peak = 0;
256     FT_Int  shift;
257 
258 
259     /* This function finds a peak of a cubic segment if it is above 0    */
260     /* using iterative bisection of the segment, or returns 0.           */
261     /* The fixed-point arithmetic of bisection is inherently stable      */
262     /* but may loose accuracy in the two lowest bits.  To compensate,    */
263     /* we upscale the segment if there is room.  Large values may need   */
264     /* to be downscaled to avoid overflows during bisection.             */
265     /* It is called with either q2 or q3 positive, which is necessary    */
266     /* for the peak to exist and avoids undefined FT_MSB.                */
267 
268     shift = 27 - FT_MSB( (FT_UInt32)( FT_ABS( q1 ) |
</pre>
<hr />
<pre>
284     else
285     {
286       q1 &gt;&gt;= -shift;
287       q2 &gt;&gt;= -shift;
288       q3 &gt;&gt;= -shift;
289       q4 &gt;&gt;= -shift;
290     }
291 
292     /* for a peak to exist above 0, the cubic segment must have */
293     /* at least one of its control off-points above 0.          */
294     while ( q2 &gt; 0 || q3 &gt; 0 )
295     {
296       /* determine which half contains the maximum and split */
297       if ( q1 + q2 &gt; q3 + q4 ) /* first half */
298       {
299         q4 = q4 + q3;
300         q3 = q3 + q2;
301         q2 = q2 + q1;
302         q4 = q4 + q3;
303         q3 = q3 + q2;
<span class="line-modified">304         q4 = ( q4 + q3 ) / 8;</span>
<span class="line-modified">305         q3 = q3 / 4;</span>
<span class="line-modified">306         q2 = q2 / 2;</span>
307       }
308       else                     /* second half */
309       {
310         q1 = q1 + q2;
311         q2 = q2 + q3;
312         q3 = q3 + q4;
313         q1 = q1 + q2;
314         q2 = q2 + q3;
<span class="line-modified">315         q1 = ( q1 + q2 ) / 8;</span>
<span class="line-modified">316         q2 = q2 / 4;</span>
<span class="line-modified">317         q3 = q3 / 2;</span>
318       }
319 
320       /* check whether either end reached the maximum */
321       if ( q1 == q2 &amp;&amp; q1 &gt;= q3 )
322       {
323         peak = q1;
324         break;
325       }
326       if ( q3 == q4 &amp;&amp; q2 &lt;= q4 )
327       {
328         peak = q4;
329         break;
330       }
331     }
332 
333     if ( shift &gt; 0 )
334       peak &gt;&gt;=  shift;
335     else
336       peak &lt;&lt;= -shift;
337 
</pre>
<hr />
<pre>
344                     FT_Pos   p2,
345                     FT_Pos   p3,
346                     FT_Pos   p4,
347                     FT_Pos*  min,
348                     FT_Pos*  max )
349   {
350     /* This function is only called when a control off-point is outside  */
351     /* the bbox that contains all on-points.  So at least one of the     */
352     /* conditions below holds and cubic_peak is called with at least one */
353     /* non-zero argument.                                                */
354 
355     if ( p2 &gt; *max || p3 &gt; *max )
356       *max += cubic_peak( p1 - *max, p2 - *max, p3 - *max, p4 - *max );
357 
358     /* now flip the signs to update the minimum */
359     if ( p2 &lt; *min || p3 &lt; *min )
360       *min -= cubic_peak( *min - p1, *min - p2, *min - p3, *min - p4 );
361   }
362 
363 
<span class="line-modified">364   /*************************************************************************/</span>
<span class="line-modified">365   /*                                                                       */</span>
<span class="line-modified">366   /* &lt;Function&gt;                                                            */</span>
<span class="line-modified">367   /*    BBox_Cubic_To                                                      */</span>
<span class="line-modified">368   /*                                                                       */</span>
<span class="line-modified">369   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified">370   /*    This function is used as a `cubic_to&#39; emitter during               */</span>
<span class="line-modified">371   /*    FT_Outline_Decompose().  It checks a cubic Bezier curve with the   */</span>
<span class="line-modified">372   /*    current bounding box, and computes its extrema if necessary to     */</span>
<span class="line-modified">373   /*    update it.                                                         */</span>
<span class="line-modified">374   /*                                                                       */</span>
<span class="line-modified">375   /* &lt;Input&gt;                                                               */</span>
<span class="line-modified">376   /*    control1 :: A pointer to the first control point.                  */</span>
<span class="line-modified">377   /*                                                                       */</span>
<span class="line-modified">378   /*    control2 :: A pointer to the second control point.                 */</span>
<span class="line-modified">379   /*                                                                       */</span>
<span class="line-modified">380   /*    to       :: A pointer to the destination vector.                   */</span>
<span class="line-modified">381   /*                                                                       */</span>
<span class="line-modified">382   /* &lt;InOut&gt;                                                               */</span>
<span class="line-modified">383   /*    user     :: The address of the current walk context.               */</span>
<span class="line-modified">384   /*                                                                       */</span>
<span class="line-modified">385   /* &lt;Return&gt;                                                              */</span>
<span class="line-modified">386   /*    Always 0.  Needed for the interface only.                          */</span>
<span class="line-modified">387   /*                                                                       */</span>
<span class="line-modified">388   /* &lt;Note&gt;                                                                */</span>
<span class="line-modified">389   /*    In the case of a non-monotonous arc, we don&#39;t compute directly     */</span>
<span class="line-modified">390   /*    extremum coordinates, we subdivide instead.                        */</span>
<span class="line-modified">391   /*                                                                       */</span>




392   static int
393   BBox_Cubic_To( FT_Vector*  control1,
394                  FT_Vector*  control2,
395                  FT_Vector*  to,
396                  TBBox_Rec*  user )
397   {
398     /* We don&#39;t need to check `to&#39; since it is always an on-point,    */
399     /* thus within the bbox.  Only segments with an off-point outside */
400     /* the bbox can possibly reach new extreme values.                */
401 
402     if ( CHECK_X( control1, user-&gt;bbox ) ||
403          CHECK_X( control2, user-&gt;bbox ) )
404       BBox_Cubic_Check( user-&gt;last.x,
405                         control1-&gt;x,
406                         control2-&gt;x,
407                         to-&gt;x,
408                         &amp;user-&gt;bbox.xMin,
409                         &amp;user-&gt;bbox.xMax );
410 
411     if ( CHECK_Y( control1, user-&gt;bbox ) ||
</pre>
<hr />
<pre>
473     for ( n = 0; n &lt; outline-&gt;n_points; n++ )
474     {
475       FT_UPDATE_BBOX( vec, cbox );
476 
477       if ( FT_CURVE_TAG( outline-&gt;tags[n] ) == FT_CURVE_TAG_ON )
478         FT_UPDATE_BBOX( vec, bbox );
479 
480       vec++;
481     }
482 
483     /* test two boxes for equality */
484     if ( cbox.xMin &lt; bbox.xMin || cbox.xMax &gt; bbox.xMax ||
485          cbox.yMin &lt; bbox.yMin || cbox.yMax &gt; bbox.yMax )
486     {
487       /* the two boxes are different, now walk over the outline to */
488       /* get the Bezier arc extrema.                               */
489 
490       FT_Error   error;
491       TBBox_Rec  user;
492 
<span class="line-removed">493 #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">494       FT_Outline_Funcs  bbox_interface;</span>
<span class="line-removed">495 </span>
<span class="line-removed">496 </span>
<span class="line-removed">497       Init_Class_bbox_interface( &amp;bbox_interface );</span>
<span class="line-removed">498 #endif</span>
499 
500       user.bbox = bbox;
501 
502       error = FT_Outline_Decompose( outline, &amp;bbox_interface, &amp;user );
503       if ( error )
504         return error;
505 
506       *abbox = user.bbox;
507     }
508     else
509       *abbox = bbox;
510 
511     return FT_Err_Ok;
512   }
513 
514 
515 /* END */
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftbbox.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   FreeType bbox computation (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used</span>
<span class="line-modified"> 11  * modified and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
<span class="line-modified"> 17 </span>
<span class="line-modified"> 18 </span>
<span class="line-modified"> 19   /**************************************************************************</span>
<span class="line-modified"> 20    *</span>
<span class="line-modified"> 21    * This component has a _single_ role: to compute exact outline bounding</span>
<span class="line-modified"> 22    * boxes.</span>
<span class="line-modified"> 23    *</span>
<span class="line-modified"> 24    */</span>
 25 
 26 
 27 #include &lt;ft2build.h&gt;
 28 #include FT_INTERNAL_DEBUG_H
 29 
 30 #include FT_BBOX_H
 31 #include FT_IMAGE_H
 32 #include FT_OUTLINE_H
 33 #include FT_INTERNAL_CALC_H
 34 #include FT_INTERNAL_OBJECTS_H
 35 
 36 
 37   typedef struct  TBBox_Rec_
 38   {
 39     FT_Vector  last;
 40     FT_BBox    bbox;
 41 
 42   } TBBox_Rec;
 43 
 44 
 45 #define FT_UPDATE_BBOX( p, bbox ) \
 46   FT_BEGIN_STMNT                  \
 47     if ( p-&gt;x &lt; bbox.xMin )       \
 48       bbox.xMin = p-&gt;x;           \
 49     if ( p-&gt;x &gt; bbox.xMax )       \
 50       bbox.xMax = p-&gt;x;           \
 51     if ( p-&gt;y &lt; bbox.yMin )       \
 52       bbox.yMin = p-&gt;y;           \
 53     if ( p-&gt;y &gt; bbox.yMax )       \
 54       bbox.yMax = p-&gt;y;           \
 55   FT_END_STMNT
 56 
 57 #define CHECK_X( p, bbox )                         \
 58           ( p-&gt;x &lt; bbox.xMin || p-&gt;x &gt; bbox.xMax )
 59 
 60 #define CHECK_Y( p, bbox )                         \
 61           ( p-&gt;y &lt; bbox.yMin || p-&gt;y &gt; bbox.yMax )
 62 
 63 
<span class="line-modified"> 64   /**************************************************************************</span>
<span class="line-modified"> 65    *</span>
<span class="line-modified"> 66    * @Function:</span>
<span class="line-modified"> 67    *   BBox_Move_To</span>
<span class="line-modified"> 68    *</span>
<span class="line-modified"> 69    * @Description:</span>
<span class="line-modified"> 70    *   This function is used as a `move_to&#39; emitter during</span>
<span class="line-modified"> 71    *   FT_Outline_Decompose().  It simply records the destination point</span>
<span class="line-modified"> 72    *   in `user-&gt;last&#39;. We also update bbox in case contour starts with</span>
<span class="line-modified"> 73    *   an implicit `on&#39; point.</span>
<span class="line-modified"> 74    *</span>
<span class="line-modified"> 75    * @Input:</span>
<span class="line-modified"> 76    *   to ::</span>
<span class="line-modified"> 77    *     A pointer to the destination vector.</span>
<span class="line-modified"> 78    *</span>
<span class="line-modified"> 79    * @InOut:</span>
<span class="line-modified"> 80    *   user ::</span>
<span class="line-modified"> 81    *     A pointer to the current walk context.</span>
<span class="line-modified"> 82    *</span>
<span class="line-modified"> 83    * @Return:</span>
<span class="line-added"> 84    *   Always 0.  Needed for the interface only.</span>
<span class="line-added"> 85    */</span>
 86   static int
 87   BBox_Move_To( FT_Vector*  to,
 88                 TBBox_Rec*  user )
 89   {
 90     FT_UPDATE_BBOX( to, user-&gt;bbox );
 91 
 92     user-&gt;last = *to;
 93 
 94     return 0;
 95   }
 96 
 97 
<span class="line-modified"> 98   /**************************************************************************</span>
<span class="line-modified"> 99    *</span>
<span class="line-modified">100    * @Function:</span>
<span class="line-modified">101    *   BBox_Line_To</span>
<span class="line-modified">102    *</span>
<span class="line-modified">103    * @Description:</span>
<span class="line-modified">104    *   This function is used as a `line_to&#39; emitter during</span>
<span class="line-modified">105    *   FT_Outline_Decompose().  It simply records the destination point</span>
<span class="line-modified">106    *   in `user-&gt;last&#39;; no further computations are necessary because</span>
<span class="line-modified">107    *   bbox already contains both explicit ends of the line segment.</span>
<span class="line-modified">108    *</span>
<span class="line-modified">109    * @Input:</span>
<span class="line-modified">110    *   to ::</span>
<span class="line-modified">111    *     A pointer to the destination vector.</span>
<span class="line-modified">112    *</span>
<span class="line-modified">113    * @InOut:</span>
<span class="line-modified">114    *   user ::</span>
<span class="line-modified">115    *     A pointer to the current walk context.</span>
<span class="line-modified">116    *</span>
<span class="line-modified">117    * @Return:</span>
<span class="line-added">118    *   Always 0.  Needed for the interface only.</span>
<span class="line-added">119    */</span>
120   static int
121   BBox_Line_To( FT_Vector*  to,
122                 TBBox_Rec*  user )
123   {
124     user-&gt;last = *to;
125 
126     return 0;
127   }
128 
129 
<span class="line-modified">130   /**************************************************************************</span>
<span class="line-modified">131    *</span>
<span class="line-modified">132    * @Function:</span>
<span class="line-modified">133    *   BBox_Conic_Check</span>
<span class="line-modified">134    *</span>
<span class="line-modified">135    * @Description:</span>
<span class="line-modified">136    *   Find the extrema of a 1-dimensional conic Bezier curve and update</span>
<span class="line-modified">137    *   a bounding range.  This version uses direct computation, as it</span>
<span class="line-modified">138    *   doesn&#39;t need square roots.</span>
<span class="line-modified">139    *</span>
<span class="line-modified">140    * @Input:</span>
<span class="line-modified">141    *   y1 ::</span>
<span class="line-modified">142    *     The start coordinate.</span>
<span class="line-modified">143    *</span>
<span class="line-modified">144    *   y2 ::</span>
<span class="line-modified">145    *     The coordinate of the control point.</span>
<span class="line-modified">146    *</span>
<span class="line-modified">147    *   y3 ::</span>
<span class="line-modified">148    *     The end coordinate.</span>
<span class="line-modified">149    *</span>
<span class="line-modified">150    * @InOut:</span>
<span class="line-modified">151    *   min ::</span>
<span class="line-added">152    *     The address of the current minimum.</span>
<span class="line-added">153    *</span>
<span class="line-added">154    *   max ::</span>
<span class="line-added">155    *     The address of the current maximum.</span>
<span class="line-added">156    */</span>
157   static void
158   BBox_Conic_Check( FT_Pos   y1,
159                     FT_Pos   y2,
160                     FT_Pos   y3,
161                     FT_Pos*  min,
162                     FT_Pos*  max )
163   {
164     /* This function is only called when a control off-point is outside */
165     /* the bbox that contains all on-points.  It finds a local extremum */
166     /* within the segment, equal to (y1*y3 - y2*y2)/(y1 - 2*y2 + y3).   */
167     /* Or, offsetting from y2, we get                                   */
168 
169     y1 -= y2;
170     y3 -= y2;
171     y2 += FT_MulDiv( y1, y3, y1 + y3 );
172 
173     if ( y2 &lt; *min )
174       *min = y2;
175     if ( y2 &gt; *max )
176       *max = y2;
177   }
178 
179 
<span class="line-modified">180   /**************************************************************************</span>
<span class="line-modified">181    *</span>
<span class="line-modified">182    * @Function:</span>
<span class="line-modified">183    *   BBox_Conic_To</span>
<span class="line-modified">184    *</span>
<span class="line-modified">185    * @Description:</span>
<span class="line-modified">186    *   This function is used as a `conic_to&#39; emitter during</span>
<span class="line-modified">187    *   FT_Outline_Decompose().  It checks a conic Bezier curve with the</span>
<span class="line-modified">188    *   current bounding box, and computes its extrema if necessary to</span>
<span class="line-modified">189    *   update it.</span>
<span class="line-modified">190    *</span>
<span class="line-modified">191    * @Input:</span>
<span class="line-modified">192    *   control ::</span>
<span class="line-modified">193    *     A pointer to a control point.</span>
<span class="line-modified">194    *</span>
<span class="line-modified">195    *   to ::</span>
<span class="line-modified">196    *     A pointer to the destination vector.</span>
<span class="line-modified">197    *</span>
<span class="line-modified">198    * @InOut:</span>
<span class="line-modified">199    *   user ::</span>
<span class="line-modified">200    *     The address of the current walk context.</span>
<span class="line-modified">201    *</span>
<span class="line-modified">202    * @Return:</span>
<span class="line-modified">203    *   Always 0.  Needed for the interface only.</span>
<span class="line-modified">204    *</span>
<span class="line-modified">205    * @Note:</span>
<span class="line-added">206    *   In the case of a non-monotonous arc, we compute directly the</span>
<span class="line-added">207    *   extremum coordinates, as it is sufficiently fast.</span>
<span class="line-added">208    */</span>
209   static int
210   BBox_Conic_To( FT_Vector*  control,
211                  FT_Vector*  to,
212                  TBBox_Rec*  user )
213   {
214     /* in case `to&#39; is implicit and not included in bbox yet */
215     FT_UPDATE_BBOX( to, user-&gt;bbox );
216 
217     if ( CHECK_X( control, user-&gt;bbox ) )
218       BBox_Conic_Check( user-&gt;last.x,
219                         control-&gt;x,
220                         to-&gt;x,
221                         &amp;user-&gt;bbox.xMin,
222                         &amp;user-&gt;bbox.xMax );
223 
224     if ( CHECK_Y( control, user-&gt;bbox ) )
225       BBox_Conic_Check( user-&gt;last.y,
226                         control-&gt;y,
227                         to-&gt;y,
228                         &amp;user-&gt;bbox.yMin,
229                         &amp;user-&gt;bbox.yMax );
230 
231     user-&gt;last = *to;
232 
233     return 0;
234   }
235 
236 
<span class="line-modified">237   /**************************************************************************</span>
<span class="line-modified">238    *</span>
<span class="line-modified">239    * @Function:</span>
<span class="line-modified">240    *   BBox_Cubic_Check</span>
<span class="line-modified">241    *</span>
<span class="line-modified">242    * @Description:</span>
<span class="line-modified">243    *   Find the extrema of a 1-dimensional cubic Bezier curve and</span>
<span class="line-modified">244    *   update a bounding range.  This version uses iterative splitting</span>
<span class="line-modified">245    *   because it is faster than the exact solution with square roots.</span>
<span class="line-modified">246    *</span>
<span class="line-modified">247    * @Input:</span>
<span class="line-modified">248    *   p1 ::</span>
<span class="line-modified">249    *     The start coordinate.</span>
<span class="line-modified">250    *</span>
<span class="line-modified">251    *   p2 ::</span>
<span class="line-modified">252    *     The coordinate of the first control point.</span>
<span class="line-modified">253    *</span>
<span class="line-modified">254    *   p3 ::</span>
<span class="line-modified">255    *     The coordinate of the second control point.</span>
<span class="line-modified">256    *</span>
<span class="line-modified">257    *   p4 ::</span>
<span class="line-modified">258    *     The end coordinate.</span>
<span class="line-modified">259    *</span>
<span class="line-modified">260    * @InOut:</span>
<span class="line-added">261    *   min ::</span>
<span class="line-added">262    *     The address of the current minimum.</span>
<span class="line-added">263    *</span>
<span class="line-added">264    *   max ::</span>
<span class="line-added">265    *     The address of the current maximum.</span>
<span class="line-added">266    */</span>
267   static FT_Pos
268   cubic_peak( FT_Pos  q1,
269               FT_Pos  q2,
270               FT_Pos  q3,
271               FT_Pos  q4 )
272   {
273     FT_Pos  peak = 0;
274     FT_Int  shift;
275 
276 
277     /* This function finds a peak of a cubic segment if it is above 0    */
278     /* using iterative bisection of the segment, or returns 0.           */
279     /* The fixed-point arithmetic of bisection is inherently stable      */
280     /* but may loose accuracy in the two lowest bits.  To compensate,    */
281     /* we upscale the segment if there is room.  Large values may need   */
282     /* to be downscaled to avoid overflows during bisection.             */
283     /* It is called with either q2 or q3 positive, which is necessary    */
284     /* for the peak to exist and avoids undefined FT_MSB.                */
285 
286     shift = 27 - FT_MSB( (FT_UInt32)( FT_ABS( q1 ) |
</pre>
<hr />
<pre>
302     else
303     {
304       q1 &gt;&gt;= -shift;
305       q2 &gt;&gt;= -shift;
306       q3 &gt;&gt;= -shift;
307       q4 &gt;&gt;= -shift;
308     }
309 
310     /* for a peak to exist above 0, the cubic segment must have */
311     /* at least one of its control off-points above 0.          */
312     while ( q2 &gt; 0 || q3 &gt; 0 )
313     {
314       /* determine which half contains the maximum and split */
315       if ( q1 + q2 &gt; q3 + q4 ) /* first half */
316       {
317         q4 = q4 + q3;
318         q3 = q3 + q2;
319         q2 = q2 + q1;
320         q4 = q4 + q3;
321         q3 = q3 + q2;
<span class="line-modified">322         q4 = ( q4 + q3 ) &gt;&gt; 3;</span>
<span class="line-modified">323         q3 = q3 &gt;&gt; 2;</span>
<span class="line-modified">324         q2 = q2 &gt;&gt; 1;</span>
325       }
326       else                     /* second half */
327       {
328         q1 = q1 + q2;
329         q2 = q2 + q3;
330         q3 = q3 + q4;
331         q1 = q1 + q2;
332         q2 = q2 + q3;
<span class="line-modified">333         q1 = ( q1 + q2 ) &gt;&gt; 3;</span>
<span class="line-modified">334         q2 = q2 &gt;&gt; 2;</span>
<span class="line-modified">335         q3 = q3 &gt;&gt; 1;</span>
336       }
337 
338       /* check whether either end reached the maximum */
339       if ( q1 == q2 &amp;&amp; q1 &gt;= q3 )
340       {
341         peak = q1;
342         break;
343       }
344       if ( q3 == q4 &amp;&amp; q2 &lt;= q4 )
345       {
346         peak = q4;
347         break;
348       }
349     }
350 
351     if ( shift &gt; 0 )
352       peak &gt;&gt;=  shift;
353     else
354       peak &lt;&lt;= -shift;
355 
</pre>
<hr />
<pre>
362                     FT_Pos   p2,
363                     FT_Pos   p3,
364                     FT_Pos   p4,
365                     FT_Pos*  min,
366                     FT_Pos*  max )
367   {
368     /* This function is only called when a control off-point is outside  */
369     /* the bbox that contains all on-points.  So at least one of the     */
370     /* conditions below holds and cubic_peak is called with at least one */
371     /* non-zero argument.                                                */
372 
373     if ( p2 &gt; *max || p3 &gt; *max )
374       *max += cubic_peak( p1 - *max, p2 - *max, p3 - *max, p4 - *max );
375 
376     /* now flip the signs to update the minimum */
377     if ( p2 &lt; *min || p3 &lt; *min )
378       *min -= cubic_peak( *min - p1, *min - p2, *min - p3, *min - p4 );
379   }
380 
381 
<span class="line-modified">382   /**************************************************************************</span>
<span class="line-modified">383    *</span>
<span class="line-modified">384    * @Function:</span>
<span class="line-modified">385    *   BBox_Cubic_To</span>
<span class="line-modified">386    *</span>
<span class="line-modified">387    * @Description:</span>
<span class="line-modified">388    *   This function is used as a `cubic_to&#39; emitter during</span>
<span class="line-modified">389    *   FT_Outline_Decompose().  It checks a cubic Bezier curve with the</span>
<span class="line-modified">390    *   current bounding box, and computes its extrema if necessary to</span>
<span class="line-modified">391    *   update it.</span>
<span class="line-modified">392    *</span>
<span class="line-modified">393    * @Input:</span>
<span class="line-modified">394    *   control1 ::</span>
<span class="line-modified">395    *     A pointer to the first control point.</span>
<span class="line-modified">396    *</span>
<span class="line-modified">397    *   control2 ::</span>
<span class="line-modified">398    *     A pointer to the second control point.</span>
<span class="line-modified">399    *</span>
<span class="line-modified">400    *   to ::</span>
<span class="line-modified">401    *     A pointer to the destination vector.</span>
<span class="line-modified">402    *</span>
<span class="line-modified">403    * @InOut:</span>
<span class="line-modified">404    *   user ::</span>
<span class="line-modified">405    *     The address of the current walk context.</span>
<span class="line-modified">406    *</span>
<span class="line-modified">407    * @Return:</span>
<span class="line-modified">408    *   Always 0.  Needed for the interface only.</span>
<span class="line-modified">409    *</span>
<span class="line-added">410    * @Note:</span>
<span class="line-added">411    *   In the case of a non-monotonous arc, we don&#39;t compute directly</span>
<span class="line-added">412    *   extremum coordinates, we subdivide instead.</span>
<span class="line-added">413    */</span>
414   static int
415   BBox_Cubic_To( FT_Vector*  control1,
416                  FT_Vector*  control2,
417                  FT_Vector*  to,
418                  TBBox_Rec*  user )
419   {
420     /* We don&#39;t need to check `to&#39; since it is always an on-point,    */
421     /* thus within the bbox.  Only segments with an off-point outside */
422     /* the bbox can possibly reach new extreme values.                */
423 
424     if ( CHECK_X( control1, user-&gt;bbox ) ||
425          CHECK_X( control2, user-&gt;bbox ) )
426       BBox_Cubic_Check( user-&gt;last.x,
427                         control1-&gt;x,
428                         control2-&gt;x,
429                         to-&gt;x,
430                         &amp;user-&gt;bbox.xMin,
431                         &amp;user-&gt;bbox.xMax );
432 
433     if ( CHECK_Y( control1, user-&gt;bbox ) ||
</pre>
<hr />
<pre>
495     for ( n = 0; n &lt; outline-&gt;n_points; n++ )
496     {
497       FT_UPDATE_BBOX( vec, cbox );
498 
499       if ( FT_CURVE_TAG( outline-&gt;tags[n] ) == FT_CURVE_TAG_ON )
500         FT_UPDATE_BBOX( vec, bbox );
501 
502       vec++;
503     }
504 
505     /* test two boxes for equality */
506     if ( cbox.xMin &lt; bbox.xMin || cbox.xMax &gt; bbox.xMax ||
507          cbox.yMin &lt; bbox.yMin || cbox.yMax &gt; bbox.yMax )
508     {
509       /* the two boxes are different, now walk over the outline to */
510       /* get the Bezier arc extrema.                               */
511 
512       FT_Error   error;
513       TBBox_Rec  user;
514 






515 
516       user.bbox = bbox;
517 
518       error = FT_Outline_Decompose( outline, &amp;bbox_interface, &amp;user );
519       if ( error )
520         return error;
521 
522       *abbox = user.bbox;
523     }
524     else
525       *abbox = bbox;
526 
527     return FT_Err_Ok;
528   }
529 
530 
531 /* END */
</pre>
</td>
</tr>
</table>
<center><a href="ftbase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftbitmap.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
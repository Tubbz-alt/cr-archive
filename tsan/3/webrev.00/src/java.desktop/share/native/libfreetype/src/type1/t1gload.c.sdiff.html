<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/type1/t1gload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="t1errors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1gload.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/type1/t1gload.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  t1gload.c                                                              */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    Type 1 Glyph Loader (body).                                          */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include &quot;t1gload.h&quot;
 21 #include FT_INTERNAL_CALC_H
 22 #include FT_INTERNAL_DEBUG_H
 23 #include FT_INTERNAL_STREAM_H
 24 #include FT_OUTLINE_H
 25 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 26 #include FT_INTERNAL_CFF_TYPES_H
 27 #include FT_DRIVER_H
 28 
 29 #include &quot;t1errors.h&quot;
 30 
 31 
<span class="line-modified"> 32   /*************************************************************************/</span>
<span class="line-modified"> 33   /*                                                                       */</span>
<span class="line-modified"> 34   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified"> 35   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified"> 36   /* messages during execution.                                            */</span>
<span class="line-modified"> 37   /*                                                                       */</span>
 38 #undef  FT_COMPONENT
<span class="line-modified"> 39 #define FT_COMPONENT  trace_t1gload</span>
 40 
 41 
 42   static FT_Error
 43   T1_Parse_Glyph_And_Get_Char_String( T1_Decoder  decoder,
 44                                       FT_UInt     glyph_index,
 45                                       FT_Data*    char_string,
 46                                       FT_Bool*    force_scaling )
 47   {
 48     T1_Face   face  = (T1_Face)decoder-&gt;builder.face;
 49     T1_Font   type1 = &amp;face-&gt;type1;
 50     FT_Error  error = FT_Err_Ok;
 51 
 52     PSAux_Service           psaux         = (PSAux_Service)face-&gt;psaux;
 53     const T1_Decoder_Funcs  decoder_funcs = psaux-&gt;t1_decoder_funcs;
 54     PS_Decoder              psdecoder;
 55 
 56 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 57     FT_Incremental_InterfaceRec *inc =
 58                       face-&gt;root.internal-&gt;incremental_interface;
 59 #endif
 60 
 61 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 62     PS_Driver  driver = (PS_Driver)FT_FACE_DRIVER( face );
 63 #endif
 64 

 65     decoder-&gt;font_matrix = type1-&gt;font_matrix;
 66     decoder-&gt;font_offset = type1-&gt;font_offset;
 67 
 68 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 69 
 70     /* For incremental fonts get the character data using the */
 71     /* callback function.                                     */
 72     if ( inc )
 73       error = inc-&gt;funcs-&gt;get_glyph_data( inc-&gt;object,
 74                                           glyph_index, char_string );
 75     else
 76 
 77 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 78 
 79     /* For ordinary fonts get the character data stored in the face record. */
 80     {
 81       char_string-&gt;pointer = type1-&gt;charstrings[glyph_index];
 82       char_string-&gt;length  = (FT_Int)type1-&gt;charstrings_len[glyph_index];
 83     }
 84 
</pre>
<hr />
<pre>
232                                            face-&gt;blend,
233                                            0,
234                                            FT_RENDER_MODE_NORMAL,
235                                            T1_Parse_Glyph );
236     if ( error )
237       return error;
238 
239     decoder.builder.metrics_only = 1;
240     decoder.builder.load_points  = 0;
241 
242     decoder.num_subrs     = type1-&gt;num_subrs;
243     decoder.subrs         = type1-&gt;subrs;
244     decoder.subrs_len     = type1-&gt;subrs_len;
245     decoder.subrs_hash    = type1-&gt;subrs_hash;
246 
247     decoder.buildchar     = face-&gt;buildchar;
248     decoder.len_buildchar = face-&gt;len_buildchar;
249 
250     *max_advance = 0;
251 


252     /* for each glyph, parse the glyph charstring and extract */
253     /* the advance width                                      */
254     for ( glyph_index = 0; glyph_index &lt; type1-&gt;num_glyphs; glyph_index++ )
255     {
256       /* now get load the unscaled outline */
257       (void)T1_Parse_Glyph( &amp;decoder, (FT_UInt)glyph_index );
258       if ( glyph_index == 0 || decoder.builder.advance.x &gt; *max_advance )
259         *max_advance = decoder.builder.advance.x;
260 
261       /* ignore the error if one occurred - skip to next glyph */
262     }
263 



264     psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
265 
266     return FT_Err_Ok;
267   }
268 
269 
270   FT_LOCAL_DEF( FT_Error )
271   T1_Get_Advances( FT_Face    t1face,        /* T1_Face */
272                    FT_UInt    first,
273                    FT_UInt    count,
274                    FT_Int32   load_flags,
275                    FT_Fixed*  advances )
276   {
277     T1_Face        face  = (T1_Face)t1face;
278     T1_DecoderRec  decoder;
279     T1_Font        type1 = &amp;face-&gt;type1;
280     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
281     FT_UInt        nn;
282     FT_Error       error;
283 
284 


285     if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
286     {
287       for ( nn = 0; nn &lt; count; nn++ )

288         advances[nn] = 0;
289 




290       return FT_Err_Ok;
291     }
292 
293     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
294                                            (FT_Face)face,
295                                            0, /* size       */
296                                            0, /* glyph slot */
297                                            (FT_Byte**)type1-&gt;glyph_names,
298                                            face-&gt;blend,
299                                            0,
300                                            FT_RENDER_MODE_NORMAL,
301                                            T1_Parse_Glyph );
302     if ( error )
303       return error;
304 
305     decoder.builder.metrics_only = 1;
306     decoder.builder.load_points  = 0;
307 
308     decoder.num_subrs  = type1-&gt;num_subrs;
309     decoder.subrs      = type1-&gt;subrs;
310     decoder.subrs_len  = type1-&gt;subrs_len;
311     decoder.subrs_hash = type1-&gt;subrs_hash;
312 
313     decoder.buildchar     = face-&gt;buildchar;
314     decoder.len_buildchar = face-&gt;len_buildchar;
315 
316     for ( nn = 0; nn &lt; count; nn++ )
317     {
318       error = T1_Parse_Glyph( &amp;decoder, first + nn );
319       if ( !error )
320         advances[nn] = FIXED_TO_INT( decoder.builder.advance.x );
321       else
322         advances[nn] = 0;





323     }
324 
325     return FT_Err_Ok;
326   }
327 
328 
329   FT_LOCAL_DEF( FT_Error )
330   T1_Load_Glyph( FT_GlyphSlot  t1glyph,          /* T1_GlyphSlot */
331                  FT_Size       t1size,           /* T1_Size      */
332                  FT_UInt       glyph_index,
333                  FT_Int32      load_flags )
334   {
335     T1_GlyphSlot            glyph = (T1_GlyphSlot)t1glyph;
336     FT_Error                error;
337     T1_DecoderRec           decoder;
338     T1_Face                 face = (T1_Face)t1glyph-&gt;face;
339     FT_Bool                 hinting;
340     FT_Bool                 scaled;
341     FT_Bool                 force_scaling = FALSE;
342     T1_Font                 type1         = &amp;face-&gt;type1;
</pre>
<hr />
<pre>
367 
368     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
369 
370     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
371       load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
372 
373     if ( t1size )
374     {
375       glyph-&gt;x_scale = t1size-&gt;metrics.x_scale;
376       glyph-&gt;y_scale = t1size-&gt;metrics.y_scale;
377     }
378     else
379     {
380       glyph-&gt;x_scale = 0x10000L;
381       glyph-&gt;y_scale = 0x10000L;
382     }
383 
384     t1glyph-&gt;outline.n_points   = 0;
385     t1glyph-&gt;outline.n_contours = 0;
386 
<span class="line-modified">387     hinting = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 &amp;&amp;</span>
<span class="line-modified">388                        ( load_flags &amp; FT_LOAD_NO_HINTING ) == 0 );</span>
<span class="line-modified">389     scaled  = FT_BOOL( ( load_flags &amp; FT_LOAD_NO_SCALE   ) == 0 );</span>
390 
391     glyph-&gt;hint     = hinting;
392     glyph-&gt;scaled   = scaled;
393     t1glyph-&gt;format = FT_GLYPH_FORMAT_OUTLINE;
394 
395     error = decoder_funcs-&gt;init( &amp;decoder,
396                                  t1glyph-&gt;face,
397                                  t1size,
398                                  t1glyph,
399                                  (FT_Byte**)type1-&gt;glyph_names,
400                                  face-&gt;blend,
<span class="line-modified">401                                  FT_BOOL( hinting ),</span>
402                                  FT_LOAD_TARGET_MODE( load_flags ),
403                                  T1_Parse_Glyph );
404     if ( error )
405       goto Exit;
406 
407     must_finish_decoder = TRUE;
408 
<span class="line-modified">409     decoder.builder.no_recurse = FT_BOOL(</span>
<span class="line-removed">410                                    ( load_flags &amp; FT_LOAD_NO_RECURSE ) != 0 );</span>
411 
412     decoder.num_subrs     = type1-&gt;num_subrs;
413     decoder.subrs         = type1-&gt;subrs;
414     decoder.subrs_len     = type1-&gt;subrs_len;
415     decoder.subrs_hash    = type1-&gt;subrs_hash;
416 
417     decoder.buildchar     = face-&gt;buildchar;
418     decoder.len_buildchar = face-&gt;len_buildchar;
419 
420     /* now load the unscaled outline */
421     error = T1_Parse_Glyph_And_Get_Char_String( &amp;decoder, glyph_index,
422                                                 &amp;glyph_data,
423                                                 &amp;force_scaling );
424     if ( error )
425       goto Exit;
426 #ifdef FT_CONFIG_OPTION_INCREMENTAL
427     glyph_data_loaded = 1;
428 #endif
429 
430     hinting     = glyph-&gt;hint;
</pre>
<hr />
<pre>
511           FT_Outline_Translate( &amp;t1glyph-&gt;outline,
512                                 font_offset.x,
513                                 font_offset.y );
514 
515           metrics-&gt;horiAdvance += font_offset.x;
516           metrics-&gt;vertAdvance += font_offset.y;
517         }
518 #endif
519 
520         if ( ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0 || force_scaling )
521         {
522           /* scale the outline and the metrics */
523           FT_Int       n;
524           FT_Outline*  cur = decoder.builder.base;
525           FT_Vector*   vec = cur-&gt;points;
526           FT_Fixed     x_scale = glyph-&gt;x_scale;
527           FT_Fixed     y_scale = glyph-&gt;y_scale;
528 
529 
530           /* First of all, scale the points, if we are not hinting */
<span class="line-modified">531           if ( !hinting || ! decoder.builder.hints_funcs )</span>
532             for ( n = cur-&gt;n_points; n &gt; 0; n--, vec++ )
533             {
534               vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );
535               vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );
536             }
537 
538           /* Then scale the metrics */
539           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance, x_scale );
540           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance, y_scale );
541         }
542 
543         /* compute the other metrics */
544         FT_Outline_Get_CBox( &amp;t1glyph-&gt;outline, &amp;cbox );
545 
546         metrics-&gt;width  = cbox.xMax - cbox.xMin;
547         metrics-&gt;height = cbox.yMax - cbox.yMin;
548 
549         metrics-&gt;horiBearingX = cbox.xMin;
550         metrics-&gt;horiBearingY = cbox.yMax;
551 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * t1gload.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Type 1 Glyph Loader (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include &quot;t1gload.h&quot;
 21 #include FT_INTERNAL_CALC_H
 22 #include FT_INTERNAL_DEBUG_H
 23 #include FT_INTERNAL_STREAM_H
 24 #include FT_OUTLINE_H
 25 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 26 #include FT_INTERNAL_CFF_TYPES_H
 27 #include FT_DRIVER_H
 28 
 29 #include &quot;t1errors.h&quot;
 30 
 31 
<span class="line-modified"> 32   /**************************************************************************</span>
<span class="line-modified"> 33    *</span>
<span class="line-modified"> 34    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 35    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 36    * messages during execution.</span>
<span class="line-modified"> 37    */</span>
 38 #undef  FT_COMPONENT
<span class="line-modified"> 39 #define FT_COMPONENT  t1gload</span>
 40 
 41 
 42   static FT_Error
 43   T1_Parse_Glyph_And_Get_Char_String( T1_Decoder  decoder,
 44                                       FT_UInt     glyph_index,
 45                                       FT_Data*    char_string,
 46                                       FT_Bool*    force_scaling )
 47   {
 48     T1_Face   face  = (T1_Face)decoder-&gt;builder.face;
 49     T1_Font   type1 = &amp;face-&gt;type1;
 50     FT_Error  error = FT_Err_Ok;
 51 
 52     PSAux_Service           psaux         = (PSAux_Service)face-&gt;psaux;
 53     const T1_Decoder_Funcs  decoder_funcs = psaux-&gt;t1_decoder_funcs;
 54     PS_Decoder              psdecoder;
 55 
 56 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 57     FT_Incremental_InterfaceRec *inc =
 58                       face-&gt;root.internal-&gt;incremental_interface;
 59 #endif
 60 
 61 #ifdef T1_CONFIG_OPTION_OLD_ENGINE
 62     PS_Driver  driver = (PS_Driver)FT_FACE_DRIVER( face );
 63 #endif
 64 
<span class="line-added"> 65 </span>
 66     decoder-&gt;font_matrix = type1-&gt;font_matrix;
 67     decoder-&gt;font_offset = type1-&gt;font_offset;
 68 
 69 #ifdef FT_CONFIG_OPTION_INCREMENTAL
 70 
 71     /* For incremental fonts get the character data using the */
 72     /* callback function.                                     */
 73     if ( inc )
 74       error = inc-&gt;funcs-&gt;get_glyph_data( inc-&gt;object,
 75                                           glyph_index, char_string );
 76     else
 77 
 78 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 79 
 80     /* For ordinary fonts get the character data stored in the face record. */
 81     {
 82       char_string-&gt;pointer = type1-&gt;charstrings[glyph_index];
 83       char_string-&gt;length  = (FT_Int)type1-&gt;charstrings_len[glyph_index];
 84     }
 85 
</pre>
<hr />
<pre>
233                                            face-&gt;blend,
234                                            0,
235                                            FT_RENDER_MODE_NORMAL,
236                                            T1_Parse_Glyph );
237     if ( error )
238       return error;
239 
240     decoder.builder.metrics_only = 1;
241     decoder.builder.load_points  = 0;
242 
243     decoder.num_subrs     = type1-&gt;num_subrs;
244     decoder.subrs         = type1-&gt;subrs;
245     decoder.subrs_len     = type1-&gt;subrs_len;
246     decoder.subrs_hash    = type1-&gt;subrs_hash;
247 
248     decoder.buildchar     = face-&gt;buildchar;
249     decoder.len_buildchar = face-&gt;len_buildchar;
250 
251     *max_advance = 0;
252 
<span class="line-added">253     FT_TRACE6(( &quot;T1_Compute_Max_Advance:\n&quot; ));</span>
<span class="line-added">254 </span>
255     /* for each glyph, parse the glyph charstring and extract */
256     /* the advance width                                      */
257     for ( glyph_index = 0; glyph_index &lt; type1-&gt;num_glyphs; glyph_index++ )
258     {
259       /* now get load the unscaled outline */
260       (void)T1_Parse_Glyph( &amp;decoder, (FT_UInt)glyph_index );
261       if ( glyph_index == 0 || decoder.builder.advance.x &gt; *max_advance )
262         *max_advance = decoder.builder.advance.x;
263 
264       /* ignore the error if one occurred - skip to next glyph */
265     }
266 
<span class="line-added">267     FT_TRACE6(( &quot;T1_Compute_Max_Advance: max advance: %f\n&quot;,</span>
<span class="line-added">268                 *max_advance / 65536.0 ));</span>
<span class="line-added">269 </span>
270     psaux-&gt;t1_decoder_funcs-&gt;done( &amp;decoder );
271 
272     return FT_Err_Ok;
273   }
274 
275 
276   FT_LOCAL_DEF( FT_Error )
277   T1_Get_Advances( FT_Face    t1face,        /* T1_Face */
278                    FT_UInt    first,
279                    FT_UInt    count,
280                    FT_Int32   load_flags,
281                    FT_Fixed*  advances )
282   {
283     T1_Face        face  = (T1_Face)t1face;
284     T1_DecoderRec  decoder;
285     T1_Font        type1 = &amp;face-&gt;type1;
286     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
287     FT_UInt        nn;
288     FT_Error       error;
289 
290 
<span class="line-added">291     FT_TRACE5(( &quot;T1_Get_Advances:\n&quot; ));</span>
<span class="line-added">292 </span>
293     if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )
294     {
295       for ( nn = 0; nn &lt; count; nn++ )
<span class="line-added">296       {</span>
297         advances[nn] = 0;
298 
<span class="line-added">299         FT_TRACE5(( &quot;  idx %d: advance height 0 font units\n&quot;,</span>
<span class="line-added">300                     first + nn ));</span>
<span class="line-added">301       }</span>
<span class="line-added">302 </span>
303       return FT_Err_Ok;
304     }
305 
306     error = psaux-&gt;t1_decoder_funcs-&gt;init( &amp;decoder,
307                                            (FT_Face)face,
308                                            0, /* size       */
309                                            0, /* glyph slot */
310                                            (FT_Byte**)type1-&gt;glyph_names,
311                                            face-&gt;blend,
312                                            0,
313                                            FT_RENDER_MODE_NORMAL,
314                                            T1_Parse_Glyph );
315     if ( error )
316       return error;
317 
318     decoder.builder.metrics_only = 1;
319     decoder.builder.load_points  = 0;
320 
321     decoder.num_subrs  = type1-&gt;num_subrs;
322     decoder.subrs      = type1-&gt;subrs;
323     decoder.subrs_len  = type1-&gt;subrs_len;
324     decoder.subrs_hash = type1-&gt;subrs_hash;
325 
326     decoder.buildchar     = face-&gt;buildchar;
327     decoder.len_buildchar = face-&gt;len_buildchar;
328 
329     for ( nn = 0; nn &lt; count; nn++ )
330     {
331       error = T1_Parse_Glyph( &amp;decoder, first + nn );
332       if ( !error )
333         advances[nn] = FIXED_TO_INT( decoder.builder.advance.x );
334       else
335         advances[nn] = 0;
<span class="line-added">336 </span>
<span class="line-added">337       FT_TRACE5(( &quot;  idx %d: advance width %d font unit%s\n&quot;,</span>
<span class="line-added">338                   first + nn,</span>
<span class="line-added">339                   advances[nn],</span>
<span class="line-added">340                   advances[nn] == 1 ? &quot;&quot; : &quot;s&quot; ));</span>
341     }
342 
343     return FT_Err_Ok;
344   }
345 
346 
347   FT_LOCAL_DEF( FT_Error )
348   T1_Load_Glyph( FT_GlyphSlot  t1glyph,          /* T1_GlyphSlot */
349                  FT_Size       t1size,           /* T1_Size      */
350                  FT_UInt       glyph_index,
351                  FT_Int32      load_flags )
352   {
353     T1_GlyphSlot            glyph = (T1_GlyphSlot)t1glyph;
354     FT_Error                error;
355     T1_DecoderRec           decoder;
356     T1_Face                 face = (T1_Face)t1glyph-&gt;face;
357     FT_Bool                 hinting;
358     FT_Bool                 scaled;
359     FT_Bool                 force_scaling = FALSE;
360     T1_Font                 type1         = &amp;face-&gt;type1;
</pre>
<hr />
<pre>
385 
386     FT_ASSERT( ( face-&gt;len_buildchar == 0 ) == ( face-&gt;buildchar == NULL ) );
387 
388     if ( load_flags &amp; FT_LOAD_NO_RECURSE )
389       load_flags |= FT_LOAD_NO_SCALE | FT_LOAD_NO_HINTING;
390 
391     if ( t1size )
392     {
393       glyph-&gt;x_scale = t1size-&gt;metrics.x_scale;
394       glyph-&gt;y_scale = t1size-&gt;metrics.y_scale;
395     }
396     else
397     {
398       glyph-&gt;x_scale = 0x10000L;
399       glyph-&gt;y_scale = 0x10000L;
400     }
401 
402     t1glyph-&gt;outline.n_points   = 0;
403     t1glyph-&gt;outline.n_contours = 0;
404 
<span class="line-modified">405     hinting = FT_BOOL( !( load_flags &amp; FT_LOAD_NO_SCALE   ) &amp;&amp;</span>
<span class="line-modified">406                        !( load_flags &amp; FT_LOAD_NO_HINTING ) );</span>
<span class="line-modified">407     scaled  = FT_BOOL( !( load_flags &amp; FT_LOAD_NO_SCALE   ) );</span>
408 
409     glyph-&gt;hint     = hinting;
410     glyph-&gt;scaled   = scaled;
411     t1glyph-&gt;format = FT_GLYPH_FORMAT_OUTLINE;
412 
413     error = decoder_funcs-&gt;init( &amp;decoder,
414                                  t1glyph-&gt;face,
415                                  t1size,
416                                  t1glyph,
417                                  (FT_Byte**)type1-&gt;glyph_names,
418                                  face-&gt;blend,
<span class="line-modified">419                                  hinting,</span>
420                                  FT_LOAD_TARGET_MODE( load_flags ),
421                                  T1_Parse_Glyph );
422     if ( error )
423       goto Exit;
424 
425     must_finish_decoder = TRUE;
426 
<span class="line-modified">427     decoder.builder.no_recurse = FT_BOOL( load_flags &amp; FT_LOAD_NO_RECURSE );</span>

428 
429     decoder.num_subrs     = type1-&gt;num_subrs;
430     decoder.subrs         = type1-&gt;subrs;
431     decoder.subrs_len     = type1-&gt;subrs_len;
432     decoder.subrs_hash    = type1-&gt;subrs_hash;
433 
434     decoder.buildchar     = face-&gt;buildchar;
435     decoder.len_buildchar = face-&gt;len_buildchar;
436 
437     /* now load the unscaled outline */
438     error = T1_Parse_Glyph_And_Get_Char_String( &amp;decoder, glyph_index,
439                                                 &amp;glyph_data,
440                                                 &amp;force_scaling );
441     if ( error )
442       goto Exit;
443 #ifdef FT_CONFIG_OPTION_INCREMENTAL
444     glyph_data_loaded = 1;
445 #endif
446 
447     hinting     = glyph-&gt;hint;
</pre>
<hr />
<pre>
528           FT_Outline_Translate( &amp;t1glyph-&gt;outline,
529                                 font_offset.x,
530                                 font_offset.y );
531 
532           metrics-&gt;horiAdvance += font_offset.x;
533           metrics-&gt;vertAdvance += font_offset.y;
534         }
535 #endif
536 
537         if ( ( load_flags &amp; FT_LOAD_NO_SCALE ) == 0 || force_scaling )
538         {
539           /* scale the outline and the metrics */
540           FT_Int       n;
541           FT_Outline*  cur = decoder.builder.base;
542           FT_Vector*   vec = cur-&gt;points;
543           FT_Fixed     x_scale = glyph-&gt;x_scale;
544           FT_Fixed     y_scale = glyph-&gt;y_scale;
545 
546 
547           /* First of all, scale the points, if we are not hinting */
<span class="line-modified">548           if ( !hinting || !decoder.builder.hints_funcs )</span>
549             for ( n = cur-&gt;n_points; n &gt; 0; n--, vec++ )
550             {
551               vec-&gt;x = FT_MulFix( vec-&gt;x, x_scale );
552               vec-&gt;y = FT_MulFix( vec-&gt;y, y_scale );
553             }
554 
555           /* Then scale the metrics */
556           metrics-&gt;horiAdvance = FT_MulFix( metrics-&gt;horiAdvance, x_scale );
557           metrics-&gt;vertAdvance = FT_MulFix( metrics-&gt;vertAdvance, y_scale );
558         }
559 
560         /* compute the other metrics */
561         FT_Outline_Get_CBox( &amp;t1glyph-&gt;outline, &amp;cbox );
562 
563         metrics-&gt;width  = cbox.xMax - cbox.xMin;
564         metrics-&gt;height = cbox.yMax - cbox.yMin;
565 
566         metrics-&gt;horiBearingX = cbox.xMin;
567         metrics-&gt;horiBearingY = cbox.yMax;
568 
</pre>
</td>
</tr>
</table>
<center><a href="t1errors.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="t1gload.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
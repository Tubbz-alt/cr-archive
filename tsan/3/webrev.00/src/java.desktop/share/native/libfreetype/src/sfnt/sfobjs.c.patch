diff a/src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c b/src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c
--- a/src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c
+++ b/src/java.desktop/share/native/libfreetype/src/sfnt/sfobjs.c
@@ -1,35 +1,35 @@
-/***************************************************************************/
-/*                                                                         */
-/*  sfobjs.c                                                               */
-/*                                                                         */
-/*    SFNT object management (base).                                       */
-/*                                                                         */
-/*  Copyright 1996-2018 by                                                 */
-/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
-/*                                                                         */
-/*  This file is part of the FreeType project, and may only be used,       */
-/*  modified, and distributed under the terms of the FreeType project      */
-/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
-/*  this file you indicate that you have read the license and              */
-/*  understand and accept it fully.                                        */
-/*                                                                         */
-/***************************************************************************/
+/****************************************************************************
+ *
+ * sfobjs.c
+ *
+ *   SFNT object management (base).
+ *
+ * Copyright (C) 1996-2019 by
+ * David Turner, Robert Wilhelm, and Werner Lemberg.
+ *
+ * This file is part of the FreeType project, and may only be used,
+ * modified, and distributed under the terms of the FreeType project
+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute
+ * this file you indicate that you have read the license and
+ * understand and accept it fully.
+ *
+ */
 
 
 #include <ft2build.h>
 #include "sfobjs.h"
 #include "ttload.h"
 #include "ttcmap.h"
 #include "ttkern.h"
+#include "sfwoff.h"
 #include FT_INTERNAL_SFNT_H
 #include FT_INTERNAL_DEBUG_H
 #include FT_TRUETYPE_IDS_H
 #include FT_TRUETYPE_TAGS_H
 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 #include FT_SFNT_NAMES_H
-#include FT_GZIP_H
 
 #ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
 #include FT_SERVICE_MULTIPLE_MASTERS_H
 #include FT_SERVICE_METRICS_VARIATIONS_H
 #endif
@@ -39,18 +39,18 @@
 #ifdef TT_CONFIG_OPTION_BDF
 #include "ttbdf.h"
 #endif
 
 
-  /*************************************************************************/
-  /*                                                                       */
-  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
-  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
-  /* messages during execution.                                            */
-  /*                                                                       */
+  /**************************************************************************
+   *
+   * The macro FT_COMPONENT is used in trace mode.  It is an implicit
+   * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
+   * messages during execution.
+   */
 #undef  FT_COMPONENT
-#define FT_COMPONENT  trace_sfobjs
+#define FT_COMPONENT  sfobjs
 
 
 
   /* convert a UTF-16 name entry to ASCII */
   static FT_String*
@@ -335,407 +335,10 @@
 
     return FT_ENCODING_NONE;
   }
 
 
-#define WRITE_USHORT( p, v )                \
-          do                                \
-          {                                 \
-            *(p)++ = (FT_Byte)( (v) >> 8 ); \
-            *(p)++ = (FT_Byte)( (v) >> 0 ); \
-                                            \
-          } while ( 0 )
-
-#define WRITE_ULONG( p, v )                  \
-          do                                 \
-          {                                  \
-            *(p)++ = (FT_Byte)( (v) >> 24 ); \
-            *(p)++ = (FT_Byte)( (v) >> 16 ); \
-            *(p)++ = (FT_Byte)( (v) >>  8 ); \
-            *(p)++ = (FT_Byte)( (v) >>  0 ); \
-                                             \
-          } while ( 0 )
-
-
-  static void
-  sfnt_stream_close( FT_Stream  stream )
-  {
-    FT_Memory  memory = stream->memory;
-
-
-    FT_FREE( stream->base );
-
-    stream->size  = 0;
-    stream->base  = NULL;
-    stream->close = NULL;
-  }
-
-
-  FT_CALLBACK_DEF( int )
-  compare_offsets( const void*  a,
-                   const void*  b )
-  {
-    WOFF_Table  table1 = *(WOFF_Table*)a;
-    WOFF_Table  table2 = *(WOFF_Table*)b;
-
-    FT_ULong  offset1 = table1->Offset;
-    FT_ULong  offset2 = table2->Offset;
-
-
-    if ( offset1 > offset2 )
-      return 1;
-    else if ( offset1 < offset2 )
-      return -1;
-    else
-      return 0;
-  }
-
-
-  /* Replace `face->root.stream' with a stream containing the extracted */
-  /* SFNT of a WOFF font.                                               */
-
-  static FT_Error
-  woff_open_font( FT_Stream  stream,
-                  TT_Face    face )
-  {
-    FT_Memory       memory = stream->memory;
-    FT_Error        error  = FT_Err_Ok;
-
-    WOFF_HeaderRec  woff;
-    WOFF_Table      tables  = NULL;
-    WOFF_Table*     indices = NULL;
-
-    FT_ULong        woff_offset;
-
-    FT_Byte*        sfnt        = NULL;
-    FT_Stream       sfnt_stream = NULL;
-
-    FT_Byte*        sfnt_header;
-    FT_ULong        sfnt_offset;
-
-    FT_Int          nn;
-    FT_ULong        old_tag = 0;
-
-    static const FT_Frame_Field  woff_header_fields[] =
-    {
-#undef  FT_STRUCTURE
-#define FT_STRUCTURE  WOFF_HeaderRec
-
-      FT_FRAME_START( 44 ),
-        FT_FRAME_ULONG ( signature ),
-        FT_FRAME_ULONG ( flavor ),
-        FT_FRAME_ULONG ( length ),
-        FT_FRAME_USHORT( num_tables ),
-        FT_FRAME_USHORT( reserved ),
-        FT_FRAME_ULONG ( totalSfntSize ),
-        FT_FRAME_USHORT( majorVersion ),
-        FT_FRAME_USHORT( minorVersion ),
-        FT_FRAME_ULONG ( metaOffset ),
-        FT_FRAME_ULONG ( metaLength ),
-        FT_FRAME_ULONG ( metaOrigLength ),
-        FT_FRAME_ULONG ( privOffset ),
-        FT_FRAME_ULONG ( privLength ),
-      FT_FRAME_END
-    };
-
-
-    FT_ASSERT( stream == face->root.stream );
-    FT_ASSERT( FT_STREAM_POS() == 0 );
-
-    if ( FT_STREAM_READ_FIELDS( woff_header_fields, &woff ) )
-      return error;
-
-    /* Make sure we don't recurse back here or hit TTC code. */
-    if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )
-      return FT_THROW( Invalid_Table );
-
-    /* Miscellaneous checks. */
-    if ( woff.length != stream->size                              ||
-         woff.num_tables == 0                                     ||
-         44 + woff.num_tables * 20UL >= woff.length               ||
-         12 + woff.num_tables * 16UL >= woff.totalSfntSize        ||
-         ( woff.totalSfntSize & 3 ) != 0                          ||
-         ( woff.metaOffset == 0 && ( woff.metaLength != 0     ||
-                                     woff.metaOrigLength != 0 ) ) ||
-         ( woff.metaLength != 0 && woff.metaOrigLength == 0 )     ||
-         ( woff.privOffset == 0 && woff.privLength != 0 )         )
-    {
-      FT_ERROR(( "woff_font_open: invalid WOFF header\n" ));
-      return FT_THROW( Invalid_Table );
-    }
-
-    /* Don't trust `totalSfntSize' before thorough checks. */
-    if ( FT_ALLOC( sfnt, 12 + woff.num_tables * 16UL ) ||
-         FT_NEW( sfnt_stream )                         )
-      goto Exit;
-
-    sfnt_header = sfnt;
-
-    /* Write sfnt header. */
-    {
-      FT_UInt  searchRange, entrySelector, rangeShift, x;
-
-
-      x             = woff.num_tables;
-      entrySelector = 0;
-      while ( x )
-      {
-        x            >>= 1;
-        entrySelector += 1;
-      }
-      entrySelector--;
-
-      searchRange = ( 1 << entrySelector ) * 16;
-      rangeShift  = woff.num_tables * 16 - searchRange;
-
-      WRITE_ULONG ( sfnt_header, woff.flavor );
-      WRITE_USHORT( sfnt_header, woff.num_tables );
-      WRITE_USHORT( sfnt_header, searchRange );
-      WRITE_USHORT( sfnt_header, entrySelector );
-      WRITE_USHORT( sfnt_header, rangeShift );
-    }
-
-    /* While the entries in the sfnt header must be sorted by the */
-    /* tag value, the tables themselves are not.  We thus have to */
-    /* sort them by offset and check that they don't overlap.     */
-
-    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||
-         FT_NEW_ARRAY( indices, woff.num_tables ) )
-      goto Exit;
-
-    FT_TRACE2(( "\n"
-                "  tag    offset    compLen  origLen  checksum\n"
-                "  -------------------------------------------\n" ));
-
-    if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )
-      goto Exit;
-
-    for ( nn = 0; nn < woff.num_tables; nn++ )
-    {
-      WOFF_Table  table = tables + nn;
-
-      table->Tag        = FT_GET_TAG4();
-      table->Offset     = FT_GET_ULONG();
-      table->CompLength = FT_GET_ULONG();
-      table->OrigLength = FT_GET_ULONG();
-      table->CheckSum   = FT_GET_ULONG();
-
-      FT_TRACE2(( "  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n",
-                  (FT_Char)( table->Tag >> 24 ),
-                  (FT_Char)( table->Tag >> 16 ),
-                  (FT_Char)( table->Tag >> 8  ),
-                  (FT_Char)( table->Tag       ),
-                  table->Offset,
-                  table->CompLength,
-                  table->OrigLength,
-                  table->CheckSum ));
-
-      if ( table->Tag <= old_tag )
-      {
-        FT_FRAME_EXIT();
-
-        FT_ERROR(( "woff_font_open: table tags are not sorted\n" ));
-        error = FT_THROW( Invalid_Table );
-        goto Exit;
-      }
-
-      old_tag     = table->Tag;
-      indices[nn] = table;
-    }
-
-    FT_FRAME_EXIT();
-
-    /* Sort by offset. */
-
-    ft_qsort( indices,
-              woff.num_tables,
-              sizeof ( WOFF_Table ),
-              compare_offsets );
-
-    /* Check offsets and lengths. */
-
-    woff_offset = 44 + woff.num_tables * 20L;
-    sfnt_offset = 12 + woff.num_tables * 16L;
-
-    for ( nn = 0; nn < woff.num_tables; nn++ )
-    {
-      WOFF_Table  table = indices[nn];
-
-
-      if ( table->Offset != woff_offset                         ||
-           table->CompLength > woff.length                      ||
-           table->Offset > woff.length - table->CompLength      ||
-           table->OrigLength > woff.totalSfntSize               ||
-           sfnt_offset > woff.totalSfntSize - table->OrigLength ||
-           table->CompLength > table->OrigLength                )
-      {
-        FT_ERROR(( "woff_font_open: invalid table offsets\n" ));
-        error = FT_THROW( Invalid_Table );
-        goto Exit;
-      }
-
-      table->OrigOffset = sfnt_offset;
-
-      /* The offsets must be multiples of 4. */
-      woff_offset += ( table->CompLength + 3 ) & ~3U;
-      sfnt_offset += ( table->OrigLength + 3 ) & ~3U;
-    }
-
-    /*
-     * Final checks!
-     *
-     * We don't decode and check the metadata block.
-     * We don't check table checksums either.
-     * But other than those, I think we implement all
-     * `MUST' checks from the spec.
-     */
-
-    if ( woff.metaOffset )
-    {
-      if ( woff.metaOffset != woff_offset                  ||
-           woff.metaOffset + woff.metaLength > woff.length )
-      {
-        FT_ERROR(( "woff_font_open:"
-                   " invalid `metadata' offset or length\n" ));
-        error = FT_THROW( Invalid_Table );
-        goto Exit;
-      }
-
-      /* We have padding only ... */
-      woff_offset += woff.metaLength;
-    }
-
-    if ( woff.privOffset )
-    {
-      /* ... if it isn't the last block. */
-      woff_offset = ( woff_offset + 3 ) & ~3U;
-
-      if ( woff.privOffset != woff_offset                  ||
-           woff.privOffset + woff.privLength > woff.length )
-      {
-        FT_ERROR(( "woff_font_open: invalid `private' offset or length\n" ));
-        error = FT_THROW( Invalid_Table );
-        goto Exit;
-      }
-
-      /* No padding for the last block. */
-      woff_offset += woff.privLength;
-    }
-
-    if ( sfnt_offset != woff.totalSfntSize ||
-         woff_offset != woff.length        )
-    {
-      FT_ERROR(( "woff_font_open: invalid `sfnt' table structure\n" ));
-      error = FT_THROW( Invalid_Table );
-      goto Exit;
-    }
-
-    /* Now use `totalSfntSize'. */
-    if ( FT_REALLOC( sfnt,
-                     12 + woff.num_tables * 16UL,
-                     woff.totalSfntSize ) )
-      goto Exit;
-
-    sfnt_header = sfnt + 12;
-
-    /* Write the tables. */
-
-    for ( nn = 0; nn < woff.num_tables; nn++ )
-    {
-      WOFF_Table  table = tables + nn;
-
-
-      /* Write SFNT table entry. */
-      WRITE_ULONG( sfnt_header, table->Tag );
-      WRITE_ULONG( sfnt_header, table->CheckSum );
-      WRITE_ULONG( sfnt_header, table->OrigOffset );
-      WRITE_ULONG( sfnt_header, table->OrigLength );
-
-      /* Write table data. */
-      if ( FT_STREAM_SEEK( table->Offset )     ||
-           FT_FRAME_ENTER( table->CompLength ) )
-        goto Exit;
-
-      if ( table->CompLength == table->OrigLength )
-      {
-        /* Uncompressed data; just copy. */
-        ft_memcpy( sfnt + table->OrigOffset,
-                   stream->cursor,
-                   table->OrigLength );
-      }
-      else
-      {
-#ifdef FT_CONFIG_OPTION_USE_ZLIB
-
-        /* Uncompress with zlib. */
-        FT_ULong  output_len = table->OrigLength;
-
-
-        error = FT_Gzip_Uncompress( memory,
-                                    sfnt + table->OrigOffset, &output_len,
-                                    stream->cursor, table->CompLength );
-        if ( error )
-          goto Exit;
-        if ( output_len != table->OrigLength )
-        {
-          FT_ERROR(( "woff_font_open: compressed table length mismatch\n" ));
-          error = FT_THROW( Invalid_Table );
-          goto Exit;
-        }
-
-#else /* !FT_CONFIG_OPTION_USE_ZLIB */
-
-        error = FT_THROW( Unimplemented_Feature );
-        goto Exit;
-
-#endif /* !FT_CONFIG_OPTION_USE_ZLIB */
-      }
-
-      FT_FRAME_EXIT();
-
-      /* We don't check whether the padding bytes in the WOFF file are     */
-      /* actually '\0'.  For the output, however, we do set them properly. */
-      sfnt_offset = table->OrigOffset + table->OrigLength;
-      while ( sfnt_offset & 3 )
-      {
-        sfnt[sfnt_offset] = '\0';
-        sfnt_offset++;
-      }
-    }
-
-    /* Ok!  Finally ready.  Swap out stream and return. */
-    FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );
-    sfnt_stream->memory = stream->memory;
-    sfnt_stream->close  = sfnt_stream_close;
-
-    FT_Stream_Free(
-      face->root.stream,
-      ( face->root.face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );
-
-    face->root.stream = sfnt_stream;
-
-    face->root.face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;
-
-  Exit:
-    FT_FREE( tables );
-    FT_FREE( indices );
-
-    if ( error )
-    {
-      FT_FREE( sfnt );
-      FT_Stream_Close( sfnt_stream );
-      FT_FREE( sfnt_stream );
-    }
-
-    return error;
-  }
-
-
-#undef WRITE_USHORT
-#undef WRITE_ULONG
-
-
   /* Fill in face->ttc_header.  If the font is not a TTC, it is */
   /* synthesized into a TTC with one offset table.              */
   static FT_Error
   sfnt_open_font( FT_Stream  stream,
                   TT_Face    face )
@@ -916,11 +519,13 @@
       return error;
 
     /* Stream may have changed in sfnt_open_font. */
     stream = face->root.stream;
 
-    FT_TRACE2(( "sfnt_init_face: %08p, %d\n", face, face_instance_index ));
+    FT_TRACE2(( "sfnt_init_face: %08p (index %d)\n",
+                face,
+                face_instance_index ));
 
     face_index = FT_ABS( face_instance_index ) & 0xFFFF;
 
     /* value -(N+1) requests information on index N */
     if ( face_instance_index < 0 )
@@ -999,19 +604,19 @@
         num_instances = 0;
       else
         face->variation_support |= TT_FACE_FLAG_VAR_FVAR;
 
       /*
-       *  As documented in the OpenType specification, an entry for the
-       *  default instance may be omitted in the named instance table.  In
-       *  particular this means that even if there is no named instance
-       *  table in the font we actually do have a named instance, namely the
-       *  default instance.
+       * As documented in the OpenType specification, an entry for the
+       * default instance may be omitted in the named instance table.  In
+       * particular this means that even if there is no named instance
+       * table in the font we actually do have a named instance, namely the
+       * default instance.
        *
-       *  For consistency, we always want the default instance in our list
-       *  of named instances.  If it is missing, we try to synthesize it
-       *  later on.  Here, we have to adjust `num_instances' accordingly.
+       * For consistency, we always want the default instance in our list
+       * of named instances.  If it is missing, we try to synthesize it
+       * later on.  Here, we have to adjust `num_instances' accordingly.
        */
 
       if ( ( face->variation_support & TT_FACE_FLAG_VAR_FVAR ) &&
            !( FT_ALLOC( default_values, num_axes * 4 )  ||
               FT_ALLOC( instance_values, num_axes * 4 ) )      )
@@ -1339,10 +944,17 @@
 
     /* embedded bitmap support */
     if ( sfnt->load_eblc )
       LOAD_( eblc );
 
+    /* colored glyph support */
+    if ( sfnt->load_cpal )
+    {
+      LOAD_( cpal );
+      LOAD_( colr );
+    }
+
     /* consider the pclt, kerning, and gasp tables as optional */
     LOAD_( pclt );
     LOAD_( gasp );
     LOAD_( kern );
 
@@ -1387,16 +999,17 @@
     {
       FT_Face  root  = &face->root;
       FT_Long  flags = root->face_flags;
 
 
-      /*********************************************************************/
-      /*                                                                   */
-      /* Compute face flags.                                               */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Compute face flags.
+       */
       if ( face->sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||
-           face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )
+           face->sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX ||
+           face->colr                                       )
         flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */
 
       if ( has_outline == TRUE )
         flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */
 
@@ -1436,14 +1049,14 @@
       }
 #endif
 
       root->face_flags = flags;
 
-      /*********************************************************************/
-      /*                                                                   */
-      /* Compute style flags.                                              */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Compute style flags.
+       */
 
       flags = 0;
       if ( has_outline == TRUE && face->os2.version != 0xFFFFU )
       {
         /* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */
@@ -1469,18 +1082,18 @@
           flags |= FT_STYLE_FLAG_ITALIC;
       }
 
       root->style_flags |= flags;
 
-      /*********************************************************************/
-      /*                                                                   */
-      /* Polish the charmaps.                                              */
-      /*                                                                   */
-      /*   Try to set the charmap encoding according to the platform &     */
-      /*   encoding ID of each charmap.  Emulate Unicode charmap if one    */
-      /*   is missing.                                                     */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Polish the charmaps.
+       *
+       *   Try to set the charmap encoding according to the platform &
+       *   encoding ID of each charmap.  Emulate Unicode charmap if one
+       *   is missing.
+       */
 
       tt_face_build_cmaps( face );  /* ignore errors */
 
 
       /* set the encoding fields */
@@ -1519,11 +1132,12 @@
 
 
           error = FT_CMap_New( (FT_CMap_Class)&tt_cmap_unicode_class_rec,
                                NULL, &cmaprec, NULL );
           if ( error                                      &&
-               FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) )
+               FT_ERR_NEQ( error, No_Unicode_Glyph_Name ) &&
+               FT_ERR_NEQ( error, Unimplemented_Feature ) )
             goto Exit;
           error = FT_Err_Ok;
 
 #endif /* FT_CONFIG_OPTION_POSTSCRIPT_NAMES */
 
@@ -1531,13 +1145,13 @@
       }
 
 #ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS
 
       /*
-       *  Now allocate the root array of FT_Bitmap_Size records and
-       *  populate them.  Unfortunately, it isn't possible to indicate bit
-       *  depths in the FT_Bitmap_Size record.  This is a design error.
+       * Now allocate the root array of FT_Bitmap_Size records and
+       * populate them.  Unfortunately, it isn't possible to indicate bit
+       * depths in the FT_Bitmap_Size record.  This is a design error.
        */
       {
         FT_UInt  count;
 
 
@@ -1613,14 +1227,14 @@
       /* it has only empty glyphs then                       */
       if ( !FT_HAS_FIXED_SIZES( root ) && !FT_IS_SCALABLE( root ) )
         root->face_flags |= FT_FACE_FLAG_SCALABLE;
 
 
-      /*********************************************************************/
-      /*                                                                   */
-      /*  Set up metrics.                                                  */
-      /*                                                                   */
+      /**********************************************************************
+       *
+       * Set up metrics.
+       */
       if ( FT_IS_SCALABLE( root ) )
       {
         /* XXX What about if outline header is missing */
         /*     (e.g. sfnt wrapped bitmap)?             */
         root->bbox.xMin    = face->header.xMin;
@@ -1628,63 +1242,77 @@
         root->bbox.xMax    = face->header.xMax;
         root->bbox.yMax    = face->header.yMax;
         root->units_per_EM = face->header.Units_Per_EM;
 
 
-        /* XXX: Computing the ascender/descender/height is very different */
-        /*      from what the specification tells you.  Apparently, we    */
-        /*      must be careful because                                   */
-        /*                                                                */
-        /*      - not all fonts have an OS/2 table; in this case, we take */
-        /*        the values in the horizontal header.  However, these    */
-        /*        values very often are not reliable.                     */
-        /*                                                                */
-        /*      - otherwise, the correct typographic values are in the    */
-        /*        sTypoAscender, sTypoDescender & sTypoLineGap fields.    */
-        /*                                                                */
-        /*        However, certain fonts have these fields set to 0.      */
-        /*        Rather, they have usWinAscent & usWinDescent correctly  */
-        /*        set (but with different values).                        */
-        /*                                                                */
-        /*      As an example, Arial Narrow is implemented through four   */
-        /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF & ARIALNBI.TTF */
-        /*                                                                */
-        /*      Strangely, all fonts have the same values in their        */
-        /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */
-        /*                                                                */
-        /*      On the other hand, they all have different                */
-        /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */
-        /*      table cannot be used to compute the text height reliably! */
-        /*                                                                */
-
-        /* The ascender and descender are taken from the `hhea' table. */
-        /* If zero, they are taken from the `OS/2' table.              */
-
-        root->ascender  = face->horizontal.Ascender;
-        root->descender = face->horizontal.Descender;
-
-        root->height = root->ascender - root->descender +
-                       face->horizontal.Line_Gap;
-
-        if ( !( root->ascender || root->descender ) )
+        /*
+         * Computing the ascender/descender/height is tricky.
+         *
+         * The OpenType specification v1.8.3 says:
+         *
+         *   [OS/2's] sTypoAscender, sTypoDescender and sTypoLineGap fields
+         *   are intended to allow applications to lay out documents in a
+         *   typographically-correct and portable fashion.
+         *
+         * This is somewhat at odds with the decades of backwards
+         * compatibility, operating systems and applications doing whatever
+         * they want, not to mention broken fonts.
+         *
+         * Not all fonts have an OS/2 table; in this case, we take the values
+         * in the horizontal header, although there is nothing stopping the
+         * values from being unreliable. Even with a OS/2 table, certain fonts
+         * set the sTypoAscender, sTypoDescender and sTypoLineGap fields to 0
+         * and instead correctly set usWinAscent and usWinDescent.
+         *
+         * As an example, Arial Narrow is shipped as four files ARIALN.TTF,
+         * ARIALNI.TTF, ARIALNB.TTF and ARIALNBI.TTF. Strangely, all fonts have
+         * the same values in their sTypo* fields, except ARIALNB.ttf which
+         * sets them to 0. All of them have different usWinAscent/Descent
+         * values. The OS/2 table therefore cannot be trusted for computing the
+         * text height reliably.
+         *
+         * As a compromise, do the following:
+         *
+         * 1. If the OS/2 table exists and the fsSelection bit 7 is set
+         *    (USE_TYPO_METRICS), trust the font and use the sTypo* metrics.
+         * 2. Otherwise, use the `hhea' table's metrics.
+         * 3. If they are zero and the OS/2 table exists,
+         *    1. use the OS/2 table's sTypo* metrics if they are non-zero.
+         *    2. Otherwise, use the OS/2 table's usWin* metrics.
+         */
+
+        if ( face->os2.version != 0xFFFFU && face->os2.fsSelection & 128 )
         {
-          if ( face->os2.version != 0xFFFFU )
-          {
-            if ( face->os2.sTypoAscender || face->os2.sTypoDescender )
-            {
-              root->ascender  = face->os2.sTypoAscender;
-              root->descender = face->os2.sTypoDescender;
+          root->ascender  = face->os2.sTypoAscender;
+          root->descender = face->os2.sTypoDescender;
+          root->height    = root->ascender - root->descender +
+                            face->os2.sTypoLineGap;
+        }
+        else
+        {
+          root->ascender  = face->horizontal.Ascender;
+          root->descender = face->horizontal.Descender;
+          root->height    = root->ascender - root->descender +
+                            face->horizontal.Line_Gap;
 
-              root->height = root->ascender - root->descender +
-                             face->os2.sTypoLineGap;
-            }
-            else
+          if ( !( root->ascender || root->descender ) )
+          {
+            if ( face->os2.version != 0xFFFFU )
             {
-              root->ascender  =  (FT_Short)face->os2.usWinAscent;
-              root->descender = -(FT_Short)face->os2.usWinDescent;
-
-              root->height = root->ascender - root->descender;
+              if ( face->os2.sTypoAscender || face->os2.sTypoDescender )
+              {
+                root->ascender  = face->os2.sTypoAscender;
+                root->descender = face->os2.sTypoDescender;
+                root->height    = root->ascender - root->descender +
+                                  face->os2.sTypoLineGap;
+              }
+              else
+              {
+                root->ascender  =  (FT_Short)face->os2.usWinAscent;
+                root->descender = -(FT_Short)face->os2.usWinDescent;
+                root->height    =  root->ascender - root->descender;
+              }
             }
           }
         }
 
         root->max_advance_width  =
@@ -1735,10 +1363,17 @@
         sfnt->free_psnames( face );
 
       /* destroy the embedded bitmaps table if it is loaded */
       if ( sfnt->free_eblc )
         sfnt->free_eblc( face );
+
+      /* destroy color table data if it is loaded */
+      if ( sfnt->free_cpal )
+      {
+        sfnt->free_cpal( face );
+        sfnt->free_colr( face );
+      }
     }
 
 #ifdef TT_CONFIG_OPTION_BDF
     /* freeing the embedded BDF properties */
     tt_face_free_bdf_props( face );
@@ -1790,15 +1425,22 @@
     /* freeing sbit size table */
     FT_FREE( face->root.available_sizes );
     FT_FREE( face->sbit_strike_map );
     face->root.num_fixed_sizes = 0;
 
-#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
     FT_FREE( face->postscript_name );
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
     FT_FREE( face->var_postscript_prefix );
 #endif
 
+    /* freeing glyph color palette data */
+    FT_FREE( face->palette_data.palette_name_ids );
+    FT_FREE( face->palette_data.palette_flags );
+    FT_FREE( face->palette_data.palette_entry_name_ids );
+    FT_FREE( face->palette );
+
     face->sfnt = NULL;
   }
 
 
 /* END */

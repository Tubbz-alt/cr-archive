<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/share/native/libfreetype/src/type1/t1driver.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre><a name="1" id="anc1"></a><span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * t1driver.c</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   Type 1 driver interface (body).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include &quot;t1driver.h&quot;
 21 #include &quot;t1gload.h&quot;
 22 #include &quot;t1load.h&quot;
 23 
 24 #include &quot;t1errors.h&quot;
 25 
 26 #ifndef T1_CONFIG_OPTION_NO_AFM
 27 #include &quot;t1afm.h&quot;
 28 #endif
 29 
 30 #include FT_INTERNAL_DEBUG_H
 31 #include FT_INTERNAL_STREAM_H
 32 #include FT_INTERNAL_HASH_H
 33 #include FT_INTERNAL_POSTSCRIPT_PROPS_H
 34 #include FT_DRIVER_H
 35 
 36 #include FT_SERVICE_MULTIPLE_MASTERS_H
 37 #include FT_SERVICE_GLYPH_DICT_H
 38 #include FT_SERVICE_FONT_FORMAT_H
 39 #include FT_SERVICE_POSTSCRIPT_NAME_H
 40 #include FT_SERVICE_POSTSCRIPT_CMAPS_H
 41 #include FT_SERVICE_POSTSCRIPT_INFO_H
 42 #include FT_SERVICE_PROPERTIES_H
 43 #include FT_SERVICE_KERNING_H
 44 
 45 
<a name="2" id="anc2"></a><span class="line-modified"> 46   /**************************************************************************</span>
<span class="line-modified"> 47    *</span>
<span class="line-modified"> 48    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified"> 49    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified"> 50    * messages during execution.</span>
<span class="line-modified"> 51    */</span>
 52 #undef  FT_COMPONENT
<a name="3" id="anc3"></a><span class="line-modified"> 53 #define FT_COMPONENT  t1driver</span>
 54 
<a name="4" id="anc4"></a><span class="line-modified"> 55   /*</span>
<span class="line-modified"> 56    * GLYPH DICT SERVICE</span>
<span class="line-modified"> 57    *</span>
<span class="line-modified"> 58    */</span>
 59 
 60   static FT_Error
 61   t1_get_glyph_name( T1_Face     face,
 62                      FT_UInt     glyph_index,
 63                      FT_Pointer  buffer,
 64                      FT_UInt     buffer_max )
 65   {
 66     FT_STRCPYN( buffer, face-&gt;type1.glyph_names[glyph_index], buffer_max );
 67 
 68     return FT_Err_Ok;
 69   }
 70 
 71 
 72   static FT_UInt
<a name="5" id="anc5"></a><span class="line-modified"> 73   t1_get_name_index( T1_Face           face,</span>
<span class="line-modified"> 74                      const FT_String*  glyph_name )</span>
 75   {
 76     FT_Int  i;
 77 
 78 
 79     for ( i = 0; i &lt; face-&gt;type1.num_glyphs; i++ )
 80     {
 81       FT_String*  gname = face-&gt;type1.glyph_names[i];
 82 
 83 
 84       if ( !ft_strcmp( glyph_name, gname ) )
 85         return (FT_UInt)i;
 86     }
 87 
 88     return 0;
 89   }
 90 
 91 
 92   static const FT_Service_GlyphDictRec  t1_service_glyph_dict =
 93   {
 94     (FT_GlyphDict_GetNameFunc)  t1_get_glyph_name,    /* get_name   */
 95     (FT_GlyphDict_NameIndexFunc)t1_get_name_index     /* name_index */
 96   };
 97 
 98 
 99   /*
<a name="6" id="anc6"></a><span class="line-modified">100    * POSTSCRIPT NAME SERVICE</span>
101    *
102    */
103 
104   static const char*
105   t1_get_ps_name( T1_Face  face )
106   {
107     return (const char*) face-&gt;type1.font_name;
108   }
109 
110 
111   static const FT_Service_PsFontNameRec  t1_service_ps_name =
112   {
113     (FT_PsName_GetFunc)t1_get_ps_name     /* get_ps_font_name */
114   };
115 
116 
117   /*
<a name="7" id="anc7"></a><span class="line-modified">118    * MULTIPLE MASTERS SERVICE</span>
119    *
120    */
121 
122 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
123   static const FT_Service_MultiMastersRec  t1_service_multi_masters =
124   {
<a name="8" id="anc8"></a><span class="line-modified">125     (FT_Get_MM_Func)             T1_Get_Multi_Master,    /* get_mm              */</span>
<span class="line-modified">126     (FT_Set_MM_Design_Func)      T1_Set_MM_Design,       /* set_mm_design       */</span>
<span class="line-modified">127     (FT_Set_MM_Blend_Func)       T1_Set_MM_Blend,        /* set_mm_blend        */</span>
<span class="line-modified">128     (FT_Get_MM_Blend_Func)       T1_Get_MM_Blend,        /* get_mm_blend        */</span>
<span class="line-modified">129     (FT_Get_MM_Var_Func)         T1_Get_MM_Var,          /* get_mm_var          */</span>
<span class="line-modified">130     (FT_Set_Var_Design_Func)     T1_Set_Var_Design,      /* set_var_design      */</span>
<span class="line-modified">131     (FT_Get_Var_Design_Func)     T1_Get_Var_Design,      /* get_var_design      */</span>
<span class="line-modified">132     (FT_Set_Instance_Func)       T1_Reset_MM_Blend,      /* set_instance        */</span>
<span class="line-modified">133     (FT_Set_MM_WeightVector_Func)T1_Set_MM_WeightVector, /* set_mm_weightvector */</span>
<span class="line-modified">134     (FT_Get_MM_WeightVector_Func)T1_Get_MM_WeightVector, /* get_mm_weightvector */</span>
<span class="line-modified">135 </span>
<span class="line-added">136     (FT_Get_Var_Blend_Func)      NULL,                   /* get_var_blend       */</span>
<span class="line-added">137     (FT_Done_Blend_Func)         T1_Done_Blend           /* done_blend          */</span>
138   };
139 #endif
140 
141 
142   /*
<a name="9" id="anc9"></a><span class="line-modified">143    * POSTSCRIPT INFO SERVICE</span>
144    *
145    */
146 
147   static FT_Error
148   t1_ps_get_font_info( FT_Face          face,
149                        PS_FontInfoRec*  afont_info )
150   {
151     *afont_info = ((T1_Face)face)-&gt;type1.font_info;
152 
153     return FT_Err_Ok;
154   }
155 
156 
157   static FT_Error
158   t1_ps_get_font_extra( FT_Face           face,
159                         PS_FontExtraRec*  afont_extra )
160   {
161     *afont_extra = ((T1_Face)face)-&gt;type1.font_extra;
162 
163     return FT_Err_Ok;
164   }
165 
166 
167   static FT_Int
168   t1_ps_has_glyph_names( FT_Face  face )
169   {
170     FT_UNUSED( face );
171 
172     return 1;
173   }
174 
175 
176   static FT_Error
177   t1_ps_get_font_private( FT_Face         face,
178                           PS_PrivateRec*  afont_private )
179   {
180     *afont_private = ((T1_Face)face)-&gt;type1.private_dict;
181 
182     return FT_Err_Ok;
183   }
184 
185 
186   static FT_Long
187   t1_ps_get_font_value( FT_Face       face,
188                         PS_Dict_Keys  key,
189                         FT_UInt       idx,
190                         void         *value,
191                         FT_Long       value_len_ )
192   {
193     FT_ULong  retval    = 0; /* always &gt;= 1 if valid */
194     FT_ULong  value_len = value_len_ &lt; 0 ? 0 : (FT_ULong)value_len_;
195 
196     T1_Face  t1face = (T1_Face)face;
197     T1_Font  type1  = &amp;t1face-&gt;type1;
198 
199 
200     switch ( key )
201     {
202     case PS_DICT_FONT_TYPE:
203       retval = sizeof ( type1-&gt;font_type );
204       if ( value &amp;&amp; value_len &gt;= retval )
205         *((FT_Byte *)value) = type1-&gt;font_type;
206       break;
207 
208     case PS_DICT_FONT_MATRIX:
209       if ( idx &lt; sizeof ( type1-&gt;font_matrix ) /
210                    sizeof ( type1-&gt;font_matrix.xx ) )
211       {
212         FT_Fixed  val = 0;
213 
214 
215         retval = sizeof ( val );
216         if ( value &amp;&amp; value_len &gt;= retval )
217         {
218           switch ( idx )
219           {
220           case 0:
221             val = type1-&gt;font_matrix.xx;
222             break;
223           case 1:
224             val = type1-&gt;font_matrix.xy;
225             break;
226           case 2:
227             val = type1-&gt;font_matrix.yx;
228             break;
229           case 3:
230             val = type1-&gt;font_matrix.yy;
231             break;
232           }
233           *((FT_Fixed *)value) = val;
234         }
235       }
236       break;
237 
238     case PS_DICT_FONT_BBOX:
239       if ( idx &lt; sizeof ( type1-&gt;font_bbox ) /
240                    sizeof ( type1-&gt;font_bbox.xMin ) )
241       {
242         FT_Fixed  val = 0;
243 
244 
245         retval = sizeof ( val );
246         if ( value &amp;&amp; value_len &gt;= retval )
247         {
248           switch ( idx )
249           {
250           case 0:
251             val = type1-&gt;font_bbox.xMin;
252             break;
253           case 1:
254             val = type1-&gt;font_bbox.yMin;
255             break;
256           case 2:
257             val = type1-&gt;font_bbox.xMax;
258             break;
259           case 3:
260             val = type1-&gt;font_bbox.yMax;
261             break;
262           }
263           *((FT_Fixed *)value) = val;
264         }
265       }
266       break;
267 
268     case PS_DICT_PAINT_TYPE:
269       retval = sizeof ( type1-&gt;paint_type );
270       if ( value &amp;&amp; value_len &gt;= retval )
271         *((FT_Byte *)value) = type1-&gt;paint_type;
272       break;
273 
274     case PS_DICT_FONT_NAME:
<a name="10" id="anc10"></a><span class="line-modified">275       if ( type1-&gt;font_name )</span>
<span class="line-modified">276       {</span>
<span class="line-modified">277         retval = ft_strlen( type1-&gt;font_name ) + 1;</span>
<span class="line-added">278         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">279           ft_memcpy( value, (void *)( type1-&gt;font_name ), retval );</span>
<span class="line-added">280       }</span>
281       break;
282 
283     case PS_DICT_UNIQUE_ID:
284       retval = sizeof ( type1-&gt;private_dict.unique_id );
285       if ( value &amp;&amp; value_len &gt;= retval )
286         *((FT_Int *)value) = type1-&gt;private_dict.unique_id;
287       break;
288 
289     case PS_DICT_NUM_CHAR_STRINGS:
290       retval = sizeof ( type1-&gt;num_glyphs );
291       if ( value &amp;&amp; value_len &gt;= retval )
292         *((FT_Int *)value) = type1-&gt;num_glyphs;
293       break;
294 
295     case PS_DICT_CHAR_STRING_KEY:
296       if ( idx &lt; (FT_UInt)type1-&gt;num_glyphs )
297       {
298         retval = ft_strlen( type1-&gt;glyph_names[idx] ) + 1;
299         if ( value &amp;&amp; value_len &gt;= retval )
300         {
301           ft_memcpy( value, (void *)( type1-&gt;glyph_names[idx] ), retval );
302           ((FT_Char *)value)[retval - 1] = (FT_Char)&#39;\0&#39;;
303         }
304       }
305       break;
306 
307     case PS_DICT_CHAR_STRING:
308       if ( idx &lt; (FT_UInt)type1-&gt;num_glyphs )
309       {
310         retval = type1-&gt;charstrings_len[idx] + 1;
311         if ( value &amp;&amp; value_len &gt;= retval )
312         {
313           ft_memcpy( value, (void *)( type1-&gt;charstrings[idx] ),
314                      retval - 1 );
315           ((FT_Char *)value)[retval - 1] = (FT_Char)&#39;\0&#39;;
316         }
317       }
318       break;
319 
320     case PS_DICT_ENCODING_TYPE:
321       retval = sizeof ( type1-&gt;encoding_type );
322       if ( value &amp;&amp; value_len &gt;= retval )
323         *((T1_EncodingType *)value) = type1-&gt;encoding_type;
324       break;
325 
326     case PS_DICT_ENCODING_ENTRY:
327       if ( type1-&gt;encoding_type == T1_ENCODING_TYPE_ARRAY &amp;&amp;
328            idx &lt; (FT_UInt)type1-&gt;encoding.num_chars       )
329       {
330         retval = ft_strlen( type1-&gt;encoding.char_name[idx] ) + 1;
331         if ( value &amp;&amp; value_len &gt;= retval )
332         {
333           ft_memcpy( value, (void *)( type1-&gt;encoding.char_name[idx] ),
334                      retval - 1 );
335           ((FT_Char *)value)[retval - 1] = (FT_Char)&#39;\0&#39;;
336         }
337       }
338       break;
339 
340     case PS_DICT_NUM_SUBRS:
341       retval = sizeof ( type1-&gt;num_subrs );
342       if ( value &amp;&amp; value_len &gt;= retval )
343         *((FT_Int *)value) = type1-&gt;num_subrs;
344       break;
345 
346     case PS_DICT_SUBR:
347       {
348         FT_Bool  ok = 0;
349 
350 
351         if ( type1-&gt;subrs_hash )
352         {
353           /* convert subr index to array index */
354           size_t*  val = ft_hash_num_lookup( (FT_Int)idx,
355                                              type1-&gt;subrs_hash );
356 
357 
358           if ( val )
359           {
360             idx = *val;
361             ok  = 1;
362           }
363         }
364         else
365         {
366           if ( idx &lt; (FT_UInt)type1-&gt;num_subrs )
367             ok = 1;
368         }
369 
<a name="11" id="anc11"></a><span class="line-modified">370         if ( ok &amp;&amp; type1-&gt;subrs )</span>
371         {
372           retval = type1-&gt;subrs_len[idx] + 1;
373           if ( value &amp;&amp; value_len &gt;= retval )
374           {
375             ft_memcpy( value, (void *)( type1-&gt;subrs[idx] ), retval - 1 );
376             ((FT_Char *)value)[retval - 1] = (FT_Char)&#39;\0&#39;;
377           }
378         }
379       }
380       break;
381 
382     case PS_DICT_STD_HW:
383       retval = sizeof ( type1-&gt;private_dict.standard_width[0] );
384       if ( value &amp;&amp; value_len &gt;= retval )
385         *((FT_UShort *)value) = type1-&gt;private_dict.standard_width[0];
386       break;
387 
388     case PS_DICT_STD_VW:
389       retval = sizeof ( type1-&gt;private_dict.standard_height[0] );
390       if ( value &amp;&amp; value_len &gt;= retval )
391         *((FT_UShort *)value) = type1-&gt;private_dict.standard_height[0];
392       break;
393 
394     case PS_DICT_NUM_BLUE_VALUES:
395       retval = sizeof ( type1-&gt;private_dict.num_blue_values );
396       if ( value &amp;&amp; value_len &gt;= retval )
397         *((FT_Byte *)value) = type1-&gt;private_dict.num_blue_values;
398       break;
399 
400     case PS_DICT_BLUE_VALUE:
401       if ( idx &lt; type1-&gt;private_dict.num_blue_values )
402       {
403         retval = sizeof ( type1-&gt;private_dict.blue_values[idx] );
404         if ( value &amp;&amp; value_len &gt;= retval )
405           *((FT_Short *)value) = type1-&gt;private_dict.blue_values[idx];
406       }
407       break;
408 
409     case PS_DICT_BLUE_SCALE:
410       retval = sizeof ( type1-&gt;private_dict.blue_scale );
411       if ( value &amp;&amp; value_len &gt;= retval )
412         *((FT_Fixed *)value) = type1-&gt;private_dict.blue_scale;
413       break;
414 
415     case PS_DICT_BLUE_FUZZ:
416       retval = sizeof ( type1-&gt;private_dict.blue_fuzz );
417       if ( value &amp;&amp; value_len &gt;= retval )
418         *((FT_Int *)value) = type1-&gt;private_dict.blue_fuzz;
419       break;
420 
421     case PS_DICT_BLUE_SHIFT:
422       retval = sizeof ( type1-&gt;private_dict.blue_shift );
423       if ( value &amp;&amp; value_len &gt;= retval )
424         *((FT_Int *)value) = type1-&gt;private_dict.blue_shift;
425       break;
426 
427     case PS_DICT_NUM_OTHER_BLUES:
428       retval = sizeof ( type1-&gt;private_dict.num_other_blues );
429       if ( value &amp;&amp; value_len &gt;= retval )
430         *((FT_Byte *)value) = type1-&gt;private_dict.num_other_blues;
431       break;
432 
433     case PS_DICT_OTHER_BLUE:
434       if ( idx &lt; type1-&gt;private_dict.num_other_blues )
435       {
436         retval = sizeof ( type1-&gt;private_dict.other_blues[idx] );
437         if ( value &amp;&amp; value_len &gt;= retval )
438           *((FT_Short *)value) = type1-&gt;private_dict.other_blues[idx];
439       }
440       break;
441 
442     case PS_DICT_NUM_FAMILY_BLUES:
443       retval = sizeof ( type1-&gt;private_dict.num_family_blues );
444       if ( value &amp;&amp; value_len &gt;= retval )
445         *((FT_Byte *)value) = type1-&gt;private_dict.num_family_blues;
446       break;
447 
448     case PS_DICT_FAMILY_BLUE:
449       if ( idx &lt; type1-&gt;private_dict.num_family_blues )
450       {
451         retval = sizeof ( type1-&gt;private_dict.family_blues[idx] );
452         if ( value &amp;&amp; value_len &gt;= retval )
453           *((FT_Short *)value) = type1-&gt;private_dict.family_blues[idx];
454       }
455       break;
456 
457     case PS_DICT_NUM_FAMILY_OTHER_BLUES:
458       retval = sizeof ( type1-&gt;private_dict.num_family_other_blues );
459       if ( value &amp;&amp; value_len &gt;= retval )
460         *((FT_Byte *)value) = type1-&gt;private_dict.num_family_other_blues;
461       break;
462 
463     case PS_DICT_FAMILY_OTHER_BLUE:
464       if ( idx &lt; type1-&gt;private_dict.num_family_other_blues )
465       {
466         retval = sizeof ( type1-&gt;private_dict.family_other_blues[idx] );
467         if ( value &amp;&amp; value_len &gt;= retval )
468           *((FT_Short *)value) = type1-&gt;private_dict.family_other_blues[idx];
469       }
470       break;
471 
472     case PS_DICT_NUM_STEM_SNAP_H:
473       retval = sizeof ( type1-&gt;private_dict.num_snap_widths );
474       if ( value &amp;&amp; value_len &gt;= retval )
475         *((FT_Byte *)value) = type1-&gt;private_dict.num_snap_widths;
476       break;
477 
478     case PS_DICT_STEM_SNAP_H:
479       if ( idx &lt; type1-&gt;private_dict.num_snap_widths )
480       {
481         retval = sizeof ( type1-&gt;private_dict.snap_widths[idx] );
482         if ( value &amp;&amp; value_len &gt;= retval )
483           *((FT_Short *)value) = type1-&gt;private_dict.snap_widths[idx];
484       }
485       break;
486 
487     case PS_DICT_NUM_STEM_SNAP_V:
488       retval = sizeof ( type1-&gt;private_dict.num_snap_heights );
489       if ( value &amp;&amp; value_len &gt;= retval )
490         *((FT_Byte *)value) = type1-&gt;private_dict.num_snap_heights;
491       break;
492 
493     case PS_DICT_STEM_SNAP_V:
494       if ( idx &lt; type1-&gt;private_dict.num_snap_heights )
495       {
496         retval = sizeof ( type1-&gt;private_dict.snap_heights[idx] );
497         if ( value &amp;&amp; value_len &gt;= retval )
498           *((FT_Short *)value) = type1-&gt;private_dict.snap_heights[idx];
499       }
500       break;
501 
502     case PS_DICT_RND_STEM_UP:
503       retval = sizeof ( type1-&gt;private_dict.round_stem_up );
504       if ( value &amp;&amp; value_len &gt;= retval )
505         *((FT_Bool *)value) = type1-&gt;private_dict.round_stem_up;
506       break;
507 
508     case PS_DICT_FORCE_BOLD:
509       retval = sizeof ( type1-&gt;private_dict.force_bold );
510       if ( value &amp;&amp; value_len &gt;= retval )
511         *((FT_Bool *)value) = type1-&gt;private_dict.force_bold;
512       break;
513 
514     case PS_DICT_MIN_FEATURE:
515       if ( idx &lt; sizeof ( type1-&gt;private_dict.min_feature ) /
516                    sizeof ( type1-&gt;private_dict.min_feature[0] ) )
517       {
518         retval = sizeof ( type1-&gt;private_dict.min_feature[idx] );
519         if ( value &amp;&amp; value_len &gt;= retval )
520           *((FT_Short *)value) = type1-&gt;private_dict.min_feature[idx];
521       }
522       break;
523 
524     case PS_DICT_LEN_IV:
525       retval = sizeof ( type1-&gt;private_dict.lenIV );
526       if ( value &amp;&amp; value_len &gt;= retval )
527         *((FT_Int *)value) = type1-&gt;private_dict.lenIV;
528       break;
529 
530     case PS_DICT_PASSWORD:
531       retval = sizeof ( type1-&gt;private_dict.password );
532       if ( value &amp;&amp; value_len &gt;= retval )
533         *((FT_Long *)value) = type1-&gt;private_dict.password;
534       break;
535 
536     case PS_DICT_LANGUAGE_GROUP:
537       retval = sizeof ( type1-&gt;private_dict.language_group );
538       if ( value &amp;&amp; value_len &gt;= retval )
539         *((FT_Long *)value) = type1-&gt;private_dict.language_group;
540       break;
541 
542     case PS_DICT_IS_FIXED_PITCH:
543       retval = sizeof ( type1-&gt;font_info.is_fixed_pitch );
544       if ( value &amp;&amp; value_len &gt;= retval )
545         *((FT_Bool *)value) = type1-&gt;font_info.is_fixed_pitch;
546       break;
547 
548     case PS_DICT_UNDERLINE_POSITION:
549       retval = sizeof ( type1-&gt;font_info.underline_position );
550       if ( value &amp;&amp; value_len &gt;= retval )
551         *((FT_Short *)value) = type1-&gt;font_info.underline_position;
552       break;
553 
554     case PS_DICT_UNDERLINE_THICKNESS:
555       retval = sizeof ( type1-&gt;font_info.underline_thickness );
556       if ( value &amp;&amp; value_len &gt;= retval )
557         *((FT_UShort *)value) = type1-&gt;font_info.underline_thickness;
558       break;
559 
560     case PS_DICT_FS_TYPE:
561       retval = sizeof ( type1-&gt;font_extra.fs_type );
562       if ( value &amp;&amp; value_len &gt;= retval )
563         *((FT_UShort *)value) = type1-&gt;font_extra.fs_type;
564       break;
565 
566     case PS_DICT_VERSION:
<a name="12" id="anc12"></a><span class="line-modified">567       if ( type1-&gt;font_info.version )</span>
<span class="line-modified">568       {</span>
<span class="line-modified">569         retval = ft_strlen( type1-&gt;font_info.version ) + 1;</span>
<span class="line-added">570         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">571           ft_memcpy( value, (void *)( type1-&gt;font_info.version ), retval );</span>
<span class="line-added">572       }</span>
573       break;
574 
575     case PS_DICT_NOTICE:
<a name="13" id="anc13"></a><span class="line-modified">576       if ( type1-&gt;font_info.notice )</span>
<span class="line-modified">577       {</span>
<span class="line-modified">578         retval = ft_strlen( type1-&gt;font_info.notice ) + 1;</span>
<span class="line-added">579         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">580           ft_memcpy( value, (void *)( type1-&gt;font_info.notice ), retval );</span>
<span class="line-added">581       }</span>
582       break;
583 
584     case PS_DICT_FULL_NAME:
<a name="14" id="anc14"></a><span class="line-modified">585       if ( type1-&gt;font_info.full_name )</span>
<span class="line-modified">586       {</span>
<span class="line-modified">587         retval = ft_strlen( type1-&gt;font_info.full_name ) + 1;</span>
<span class="line-added">588         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">589           ft_memcpy( value, (void *)( type1-&gt;font_info.full_name ), retval );</span>
<span class="line-added">590       }</span>
591       break;
592 
593     case PS_DICT_FAMILY_NAME:
<a name="15" id="anc15"></a><span class="line-modified">594       if ( type1-&gt;font_info.family_name )</span>
<span class="line-modified">595       {</span>
<span class="line-modified">596         retval = ft_strlen( type1-&gt;font_info.family_name ) + 1;</span>
<span class="line-added">597         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">598           ft_memcpy( value, (void *)( type1-&gt;font_info.family_name ),</span>
<span class="line-added">599                      retval );</span>
<span class="line-added">600       }</span>
601       break;
602 
603     case PS_DICT_WEIGHT:
<a name="16" id="anc16"></a><span class="line-modified">604       if ( type1-&gt;font_info.weight )</span>
<span class="line-modified">605       {</span>
<span class="line-modified">606         retval = ft_strlen( type1-&gt;font_info.weight ) + 1;</span>
<span class="line-added">607         if ( value &amp;&amp; value_len &gt;= retval )</span>
<span class="line-added">608           ft_memcpy( value, (void *)( type1-&gt;font_info.weight ), retval );</span>
<span class="line-added">609       }</span>
610       break;
611 
612     case PS_DICT_ITALIC_ANGLE:
613       retval = sizeof ( type1-&gt;font_info.italic_angle );
614       if ( value &amp;&amp; value_len &gt;= retval )
615         *((FT_Long *)value) = type1-&gt;font_info.italic_angle;
616       break;
617     }
618 
619     return retval == 0 ? -1 : (FT_Long)retval;
620   }
621 
622 
623   static const FT_Service_PsInfoRec  t1_service_ps_info =
624   {
625     (PS_GetFontInfoFunc)   t1_ps_get_font_info,    /* ps_get_font_info    */
626     (PS_GetFontExtraFunc)  t1_ps_get_font_extra,   /* ps_get_font_extra   */
627     (PS_HasGlyphNamesFunc) t1_ps_has_glyph_names,  /* ps_has_glyph_names  */
628     (PS_GetFontPrivateFunc)t1_ps_get_font_private, /* ps_get_font_private */
629     (PS_GetFontValueFunc)  t1_ps_get_font_value,   /* ps_get_font_value   */
630   };
631 
632 
633 #ifndef T1_CONFIG_OPTION_NO_AFM
634   static const FT_Service_KerningRec  t1_service_kerning =
635   {
636     T1_Get_Track_Kerning,       /* get_track */
637   };
638 #endif
639 
640 
641   /*
<a name="17" id="anc17"></a><span class="line-modified">642    * PROPERTY SERVICE</span>
643    *
644    */
645 
646   FT_DEFINE_SERVICE_PROPERTIESREC(
647     t1_service_properties,
648 
649     (FT_Properties_SetFunc)ps_property_set,      /* set_property */
650     (FT_Properties_GetFunc)ps_property_get )     /* get_property */
651 
652 
653   /*
<a name="18" id="anc18"></a><span class="line-modified">654    * SERVICE LIST</span>
655    *
656    */
657 
658   static const FT_ServiceDescRec  t1_services[] =
659   {
660     { FT_SERVICE_ID_POSTSCRIPT_FONT_NAME, &amp;t1_service_ps_name },
661     { FT_SERVICE_ID_GLYPH_DICT,           &amp;t1_service_glyph_dict },
662     { FT_SERVICE_ID_FONT_FORMAT,          FT_FONT_FORMAT_TYPE_1 },
663     { FT_SERVICE_ID_POSTSCRIPT_INFO,      &amp;t1_service_ps_info },
664     { FT_SERVICE_ID_PROPERTIES,           &amp;t1_service_properties },
665 
666 #ifndef T1_CONFIG_OPTION_NO_AFM
667     { FT_SERVICE_ID_KERNING,              &amp;t1_service_kerning },
668 #endif
669 
670 #ifndef T1_CONFIG_OPTION_NO_MM_SUPPORT
671     { FT_SERVICE_ID_MULTI_MASTERS,        &amp;t1_service_multi_masters },
672 #endif
673     { NULL, NULL }
674   };
675 
676 
677   FT_CALLBACK_DEF( FT_Module_Interface )
678   Get_Interface( FT_Module         module,
679                  const FT_String*  t1_interface )
680   {
681     FT_UNUSED( module );
682 
683     return ft_service_list_lookup( t1_services, t1_interface );
684   }
685 
686 
687 #ifndef T1_CONFIG_OPTION_NO_AFM
688 
<a name="19" id="anc19"></a><span class="line-modified">689   /**************************************************************************</span>
<span class="line-modified">690    *</span>
<span class="line-modified">691    * @Function:</span>
<span class="line-modified">692    *   Get_Kerning</span>
<span class="line-modified">693    *</span>
<span class="line-modified">694    * @Description:</span>
<span class="line-modified">695    *   A driver method used to return the kerning vector between two</span>
<span class="line-modified">696    *   glyphs of the same face.</span>
<span class="line-modified">697    *</span>
<span class="line-modified">698    * @Input:</span>
<span class="line-modified">699    *   face ::</span>
<span class="line-modified">700    *     A handle to the source face object.</span>
<span class="line-modified">701    *</span>
<span class="line-modified">702    *   left_glyph ::</span>
<span class="line-modified">703    *     The index of the left glyph in the kern pair.</span>
<span class="line-modified">704    *</span>
<span class="line-modified">705    *   right_glyph ::</span>
<span class="line-modified">706    *     The index of the right glyph in the kern pair.</span>
<span class="line-modified">707    *</span>
<span class="line-modified">708    * @Output:</span>
<span class="line-modified">709    *   kerning ::</span>
<span class="line-modified">710    *     The kerning vector.  This is in font units for</span>
<span class="line-modified">711    *     scalable formats, and in pixels for fixed-sizes</span>
<span class="line-modified">712    *     formats.</span>
<span class="line-modified">713    *</span>
<span class="line-modified">714    * @Return:</span>
<span class="line-modified">715    *   FreeType error code.  0 means success.</span>
<span class="line-modified">716    *</span>
<span class="line-modified">717    * @Note:</span>
<span class="line-modified">718    *   Only horizontal layouts (left-to-right &amp; right-to-left) are</span>
<span class="line-modified">719    *   supported by this function.  Other layouts, or more sophisticated</span>
<span class="line-modified">720    *   kernings are out of scope of this method (the basic driver</span>
<span class="line-added">721    *   interface is meant to be simple).</span>
<span class="line-added">722    *</span>
<span class="line-added">723    *   They can be implemented by format-specific interfaces.</span>
<span class="line-added">724    */</span>
725   static FT_Error
726   Get_Kerning( FT_Face     t1face,        /* T1_Face */
727                FT_UInt     left_glyph,
728                FT_UInt     right_glyph,
729                FT_Vector*  kerning )
730   {
731     T1_Face  face = (T1_Face)t1face;
732 
733 
734     kerning-&gt;x = 0;
735     kerning-&gt;y = 0;
736 
737     if ( face-&gt;afm_data )
738       T1_Get_Kerning( (AFM_FontInfo)face-&gt;afm_data,
739                       left_glyph,
740                       right_glyph,
741                       kerning );
742 
743     return FT_Err_Ok;
744   }
745 
746 
747 #endif /* T1_CONFIG_OPTION_NO_AFM */
748 
749 
750   FT_CALLBACK_TABLE_DEF
751   const FT_Driver_ClassRec  t1_driver_class =
752   {
753     {
754       FT_MODULE_FONT_DRIVER       |
755       FT_MODULE_DRIVER_SCALABLE   |
756       FT_MODULE_DRIVER_HAS_HINTER,
757 
758       sizeof ( PS_DriverRec ),
759 
760       &quot;type1&quot;,
761       0x10000L,
762       0x20000L,
763 
764       NULL,    /* module-specific interface */
765 
766       T1_Driver_Init,           /* FT_Module_Constructor  module_init   */
767       T1_Driver_Done,           /* FT_Module_Destructor   module_done   */
768       Get_Interface,            /* FT_Module_Requester    get_interface */
769     },
770 
771     sizeof ( T1_FaceRec ),
772     sizeof ( T1_SizeRec ),
773     sizeof ( T1_GlyphSlotRec ),
774 
775     T1_Face_Init,               /* FT_Face_InitFunc  init_face */
776     T1_Face_Done,               /* FT_Face_DoneFunc  done_face */
777     T1_Size_Init,               /* FT_Size_InitFunc  init_size */
778     T1_Size_Done,               /* FT_Size_DoneFunc  done_size */
779     T1_GlyphSlot_Init,          /* FT_Slot_InitFunc  init_slot */
780     T1_GlyphSlot_Done,          /* FT_Slot_DoneFunc  done_slot */
781 
782     T1_Load_Glyph,              /* FT_Slot_LoadFunc  load_glyph */
783 
784 #ifdef T1_CONFIG_OPTION_NO_AFM
785     NULL,                       /* FT_Face_GetKerningFunc   get_kerning  */
786     NULL,                       /* FT_Face_AttachFunc       attach_file  */
787 #else
788     Get_Kerning,                /* FT_Face_GetKerningFunc   get_kerning  */
789     T1_Read_Metrics,            /* FT_Face_AttachFunc       attach_file  */
790 #endif
791     T1_Get_Advances,            /* FT_Face_GetAdvancesFunc  get_advances */
792 
793     T1_Size_Request,            /* FT_Size_RequestFunc  request_size */
794     NULL                        /* FT_Size_SelectFunc   select_size  */
795   };
796 
797 
798 /* END */
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
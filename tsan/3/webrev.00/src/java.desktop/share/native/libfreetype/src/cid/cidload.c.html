<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.desktop/share/native/libfreetype/src/cid/cidload.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /****************************************************************************
  2  *
  3  * cidload.c
  4  *
  5  *   CID-keyed Type1 font loader (body).
  6  *
  7  * Copyright (C) 1996-2019 by
  8  * David Turner, Robert Wilhelm, and Werner Lemberg.
  9  *
 10  * This file is part of the FreeType project, and may only be used,
 11  * modified, and distributed under the terms of the FreeType project
 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute
 13  * this file you indicate that you have read the license and
 14  * understand and accept it fully.
 15  *
 16  */
 17 
 18 
 19 #include &lt;ft2build.h&gt;
 20 #include FT_INTERNAL_DEBUG_H
 21 #include FT_CONFIG_CONFIG_H
 22 #include FT_MULTIPLE_MASTERS_H
 23 #include FT_INTERNAL_TYPE1_TYPES_H
 24 #include FT_INTERNAL_POSTSCRIPT_AUX_H
 25 
 26 #include &quot;cidload.h&quot;
 27 
 28 #include &quot;ciderrs.h&quot;
 29 
 30 
 31   /**************************************************************************
 32    *
 33    * The macro FT_COMPONENT is used in trace mode.  It is an implicit
 34    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log
 35    * messages during execution.
 36    */
 37 #undef  FT_COMPONENT
 38 #define FT_COMPONENT  cidload
 39 
 40 
 41   /* read a single offset */
 42   FT_LOCAL_DEF( FT_ULong )
 43   cid_get_offset( FT_Byte*  *start,
 44                   FT_Byte    offsize )
 45   {
 46     FT_ULong  result;
 47     FT_Byte*  p = *start;
 48 
 49 
 50     for ( result = 0; offsize &gt; 0; offsize-- )
 51     {
 52       result &lt;&lt;= 8;
 53       result  |= *p++;
 54     }
 55 
 56     *start = p;
 57     return result;
 58   }
 59 
 60 
 61   /*************************************************************************/
 62   /*************************************************************************/
 63   /*****                                                               *****/
 64   /*****                    TYPE 1 SYMBOL PARSING                      *****/
 65   /*****                                                               *****/
 66   /*************************************************************************/
 67   /*************************************************************************/
 68 
 69 
 70   static FT_Error
 71   cid_load_keyword( CID_Face        face,
 72                     CID_Loader*     loader,
 73                     const T1_Field  keyword )
 74   {
 75     FT_Error      error;
 76     CID_Parser*   parser = &amp;loader-&gt;parser;
 77     FT_Byte*      object;
 78     void*         dummy_object;
 79     CID_FaceInfo  cid = &amp;face-&gt;cid;
 80 
 81 
 82     /* if the keyword has a dedicated callback, call it */
 83     if ( keyword-&gt;type == T1_FIELD_TYPE_CALLBACK )
 84     {
 85       FT_TRACE4(( &quot;  %s&quot;, keyword-&gt;ident ));
 86 
 87       keyword-&gt;reader( (FT_Face)face, parser );
 88       error = parser-&gt;root.error;
 89       goto Exit;
 90     }
 91 
 92     /* we must now compute the address of our target object */
 93     switch ( keyword-&gt;location )
 94     {
 95     case T1_FIELD_LOCATION_CID_INFO:
 96       object = (FT_Byte*)cid;
 97       break;
 98 
 99     case T1_FIELD_LOCATION_FONT_INFO:
100       object = (FT_Byte*)&amp;cid-&gt;font_info;
101       break;
102 
103     case T1_FIELD_LOCATION_FONT_EXTRA:
104       object = (FT_Byte*)&amp;face-&gt;font_extra;
105       break;
106 
107     case T1_FIELD_LOCATION_BBOX:
108       object = (FT_Byte*)&amp;cid-&gt;font_bbox;
109       break;
110 
111     default:
112       {
113         CID_FaceDict  dict;
114 
115 
116         if ( parser-&gt;num_dict &lt; 0 || parser-&gt;num_dict &gt;= cid-&gt;num_dicts )
117         {
118           FT_ERROR(( &quot;cid_load_keyword: invalid use of `%s&#39;\n&quot;,
119                      keyword-&gt;ident ));
120           error = FT_THROW( Syntax_Error );
121           goto Exit;
122         }
123 
124         dict = cid-&gt;font_dicts + parser-&gt;num_dict;
125         switch ( keyword-&gt;location )
126         {
127         case T1_FIELD_LOCATION_PRIVATE:
128           object = (FT_Byte*)&amp;dict-&gt;private_dict;
129           break;
130 
131         default:
132           object = (FT_Byte*)dict;
133         }
134       }
135     }
136 
137     FT_TRACE4(( &quot;  %s&quot;, keyword-&gt;ident ));
138 
139     dummy_object = object;
140 
141     /* now, load the keyword data in the object&#39;s field(s) */
142     if ( keyword-&gt;type == T1_FIELD_TYPE_INTEGER_ARRAY ||
143          keyword-&gt;type == T1_FIELD_TYPE_FIXED_ARRAY   )
144       error = cid_parser_load_field_table( &amp;loader-&gt;parser, keyword,
145                                            &amp;dummy_object );
146     else
147       error = cid_parser_load_field( &amp;loader-&gt;parser,
148                                      keyword, &amp;dummy_object );
149 
150     FT_TRACE4(( &quot;\n&quot; ));
151 
152   Exit:
153     return error;
154   }
155 
156 
157   FT_CALLBACK_DEF( void )
158   cid_parse_font_matrix( CID_Face     face,
159                          CID_Parser*  parser )
160   {
161     CID_FaceDict  dict;
162     FT_Face       root = (FT_Face)&amp;face-&gt;root;
163     FT_Fixed      temp[6];
164     FT_Fixed      temp_scale;
165 
166 
167     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
168     {
169       FT_Matrix*  matrix;
170       FT_Vector*  offset;
171       FT_Int      result;
172 
173 
174       dict   = face-&gt;cid.font_dicts + parser-&gt;num_dict;
175       matrix = &amp;dict-&gt;font_matrix;
176       offset = &amp;dict-&gt;font_offset;
177 
178       /* input is scaled by 1000 to accommodate default FontMatrix */
179       result = cid_parser_to_fixed_array( parser, 6, temp, 3 );
180 
181       if ( result &lt; 6 )
182       {
183         FT_ERROR(( &quot;cid_parse_font_matrix: not enough matrix elements\n&quot; ));
184         goto Exit;
185       }
186 
187       FT_TRACE4(( &quot; [%f %f %f %f %f %f]\n&quot;,
188                   (double)temp[0] / 65536 / 1000,
189                   (double)temp[1] / 65536 / 1000,
190                   (double)temp[2] / 65536 / 1000,
191                   (double)temp[3] / 65536 / 1000,
192                   (double)temp[4] / 65536 / 1000,
193                   (double)temp[5] / 65536 / 1000 ));
194 
195       temp_scale = FT_ABS( temp[3] );
196 
197       if ( temp_scale == 0 )
198       {
199         FT_ERROR(( &quot;cid_parse_font_matrix: invalid font matrix\n&quot; ));
200         goto Exit;
201       }
202 
203       /* atypical case */
204       if ( temp_scale != 0x10000L )
205       {
206         /* set units per EM based on FontMatrix values */
207         root-&gt;units_per_EM = (FT_UShort)FT_DivFix( 1000, temp_scale );
208 
209         temp[0] = FT_DivFix( temp[0], temp_scale );
210         temp[1] = FT_DivFix( temp[1], temp_scale );
211         temp[2] = FT_DivFix( temp[2], temp_scale );
212         temp[4] = FT_DivFix( temp[4], temp_scale );
213         temp[5] = FT_DivFix( temp[5], temp_scale );
214         temp[3] = temp[3] &lt; 0 ? -0x10000L : 0x10000L;
215       }
216 
217       matrix-&gt;xx = temp[0];
218       matrix-&gt;yx = temp[1];
219       matrix-&gt;xy = temp[2];
220       matrix-&gt;yy = temp[3];
221 
222       if ( !FT_Matrix_Check( matrix ) )
223       {
224         FT_ERROR(( &quot;t1_parse_font_matrix: invalid font matrix\n&quot; ));
225         parser-&gt;root.error = FT_THROW( Invalid_File_Format );
226         goto Exit;
227       }
228 
229       /* note that the font offsets are expressed in integer font units */
230       offset-&gt;x  = temp[4] &gt;&gt; 16;
231       offset-&gt;y  = temp[5] &gt;&gt; 16;
232     }
233 
234   Exit:
235     return;
236   }
237 
238 
239   FT_CALLBACK_DEF( void )
240   parse_fd_array( CID_Face     face,
241                   CID_Parser*  parser )
242   {
243     CID_FaceInfo  cid    = &amp;face-&gt;cid;
244     FT_Memory     memory = face-&gt;root.memory;
245     FT_Stream     stream = parser-&gt;stream;
246     FT_Error      error  = FT_Err_Ok;
247     FT_Long       num_dicts;
248 
249 
250     num_dicts = cid_parser_to_int( parser );
251     if ( num_dicts &lt; 0 )
252     {
253       FT_ERROR(( &quot;parse_fd_array: invalid number of dictionaries\n&quot; ));
254       goto Exit;
255     }
256 
257     FT_TRACE4(( &quot; %d\n&quot;, num_dicts ));
258 
259     /*
260      * A single entry in the FDArray must (at least) contain the following
261      * structure elements.
262      *
263      *   %ADOBeginFontDict              18
264      *   X dict begin                   13
265      *     /FontMatrix [X X X X]        22
266      *     /Private X dict begin        22
267      *     end                           4
268      *   end                             4
269      *   %ADOEndFontDict                16
270      *
271      * This needs 18+13+22+22+4+4+16=99 bytes or more.  Normally, you also
272      * need a `dup X&#39; at the very beginning and a `put&#39; at the end, so a
273      * rough guess using 100 bytes as the minimum is justified.
274      */
275     if ( (FT_ULong)num_dicts &gt; stream-&gt;size / 100 )
276     {
277       FT_TRACE0(( &quot;parse_fd_array: adjusting FDArray size&quot;
278                   &quot; (from %d to %d)\n&quot;,
279                   num_dicts,
280                   stream-&gt;size / 100 ));
281       num_dicts = (FT_Long)( stream-&gt;size / 100 );
282     }
283 
284     if ( !cid-&gt;font_dicts )
285     {
286       FT_Int  n;
287 
288 
289       if ( FT_NEW_ARRAY( cid-&gt;font_dicts, num_dicts ) )
290         goto Exit;
291 
292       cid-&gt;num_dicts = num_dicts;
293 
294       /* set some default values (the same as for Type 1 fonts) */
295       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
296       {
297         CID_FaceDict  dict = cid-&gt;font_dicts + n;
298 
299 
300         dict-&gt;private_dict.blue_shift       = 7;
301         dict-&gt;private_dict.blue_fuzz        = 1;
302         dict-&gt;private_dict.lenIV            = 4;
303         dict-&gt;private_dict.expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
304         dict-&gt;private_dict.blue_scale       = (FT_Fixed)(
305                                                 0.039625 * 0x10000L * 1000 );
306       }
307     }
308 
309   Exit:
310     return;
311   }
312 
313 
314   /* By mistake, `expansion_factor&#39; appears both in PS_PrivateRec */
315   /* and CID_FaceDictRec (both are public header files and can&#39;t  */
316   /* changed).  We simply copy the value.                         */
317 
318   FT_CALLBACK_DEF( void )
319   parse_expansion_factor( CID_Face     face,
320                           CID_Parser*  parser )
321   {
322     CID_FaceDict  dict;
323 
324 
325     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
326     {
327       dict = face-&gt;cid.font_dicts + parser-&gt;num_dict;
328 
329       dict-&gt;expansion_factor              = cid_parser_to_fixed( parser, 0 );
330       dict-&gt;private_dict.expansion_factor = dict-&gt;expansion_factor;
331 
332       FT_TRACE4(( &quot;%d\n&quot;, dict-&gt;expansion_factor ));
333     }
334 
335     return;
336   }
337 
338 
339   /* By mistake, `CID_FaceDictRec&#39; doesn&#39;t contain a field for the */
340   /* `FontName&#39; keyword.  FreeType doesn&#39;t need it, but it is nice */
341   /* to catch it for producing better trace output.                */
342 
343   FT_CALLBACK_DEF( void )
344   parse_font_name( CID_Face     face,
345                    CID_Parser*  parser )
346   {
347 #ifdef FT_DEBUG_LEVEL_TRACE
348     if ( parser-&gt;num_dict &gt;= 0 &amp;&amp; parser-&gt;num_dict &lt; face-&gt;cid.num_dicts )
349     {
350       T1_TokenRec  token;
351       FT_UInt      len;
352 
353 
354       cid_parser_to_token( parser, &amp;token );
355 
356       len = (FT_UInt)( token.limit - token.start );
357       if ( len )
358         FT_TRACE4(( &quot; %.*s\n&quot;, len, token.start ));
359       else
360         FT_TRACE4(( &quot; &lt;no value&gt;\n&quot; ));
361     }
362 #else
363     FT_UNUSED( face );
364     FT_UNUSED( parser );
365 #endif
366 
367     return;
368   }
369 
370 
371   static
372   const T1_FieldRec  cid_field_records[] =
373   {
374 
375 #include &quot;cidtoken.h&quot;
376 
377     T1_FIELD_CALLBACK( &quot;FDArray&quot;,         parse_fd_array, 0 )
378     T1_FIELD_CALLBACK( &quot;FontMatrix&quot;,      cid_parse_font_matrix, 0 )
379     T1_FIELD_CALLBACK( &quot;ExpansionFactor&quot;, parse_expansion_factor, 0 )
380     T1_FIELD_CALLBACK( &quot;FontName&quot;,        parse_font_name, 0 )
381 
382     { 0, T1_FIELD_LOCATION_CID_INFO, T1_FIELD_TYPE_NONE, 0, 0, 0, 0, 0, 0 }
383   };
384 
385 
386   static FT_Error
387   cid_parse_dict( CID_Face     face,
388                   CID_Loader*  loader,
389                   FT_Byte*     base,
390                   FT_ULong     size )
391   {
392     CID_Parser*  parser = &amp;loader-&gt;parser;
393 
394 
395     parser-&gt;root.cursor = base;
396     parser-&gt;root.limit  = base + size;
397     parser-&gt;root.error  = FT_Err_Ok;
398 
399     {
400       FT_Byte*  cur   = base;
401       FT_Byte*  limit = cur + size;
402 
403 
404       for (;;)
405       {
406         FT_Byte*  newlimit;
407 
408 
409         parser-&gt;root.cursor = cur;
410         cid_parser_skip_spaces( parser );
411 
412         if ( parser-&gt;root.cursor &gt;= limit )
413           newlimit = limit - 1 - 17;
414         else
415           newlimit = parser-&gt;root.cursor - 17;
416 
417         /* look for `%ADOBeginFontDict&#39; */
418         for ( ; cur &lt; newlimit; cur++ )
419         {
420           if ( *cur == &#39;%&#39;                                            &amp;&amp;
421                ft_strncmp( (char*)cur, &quot;%ADOBeginFontDict&quot;, 17 ) == 0 )
422           {
423             /* if /FDArray was found, then cid-&gt;num_dicts is &gt; 0, and */
424             /* we can start increasing parser-&gt;num_dict               */
425             if ( face-&gt;cid.num_dicts &gt; 0 )
426             {
427               parser-&gt;num_dict++;
428 
429 #ifdef FT_DEBUG_LEVEL_TRACE
430               FT_TRACE4(( &quot; FontDict %d&quot;, parser-&gt;num_dict ));
431               if ( parser-&gt;num_dict &gt; face-&gt;cid.num_dicts )
432                 FT_TRACE4(( &quot; (ignored)&quot; ));
433               FT_TRACE4(( &quot;\n&quot; ));
434 #endif
435             }
436           }
437         }
438 
439         cur = parser-&gt;root.cursor;
440         /* no error can occur in cid_parser_skip_spaces */
441         if ( cur &gt;= limit )
442           break;
443 
444         cid_parser_skip_PS_token( parser );
445         if ( parser-&gt;root.cursor &gt;= limit || parser-&gt;root.error )
446           break;
447 
448         /* look for immediates */
449         if ( *cur == &#39;/&#39; &amp;&amp; cur + 2 &lt; limit )
450         {
451           FT_UInt  len;
452 
453 
454           cur++;
455           len = (FT_UInt)( parser-&gt;root.cursor - cur );
456 
457           if ( len &gt; 0 &amp;&amp; len &lt; 22 )
458           {
459             /* now compare the immediate name to the keyword table */
460             T1_Field  keyword = (T1_Field)cid_field_records;
461 
462 
463             for (;;)
464             {
465               FT_Byte*  name;
466 
467 
468               name = (FT_Byte*)keyword-&gt;ident;
469               if ( !name )
470                 break;
471 
472               if ( cur[0] == name[0]                     &amp;&amp;
473                    len == ft_strlen( (const char*)name ) )
474               {
475                 FT_UInt  n;
476 
477 
478                 for ( n = 1; n &lt; len; n++ )
479                   if ( cur[n] != name[n] )
480                     break;
481 
482                 if ( n &gt;= len )
483                 {
484                   /* we found it - run the parsing callback */
485                   parser-&gt;root.error = cid_load_keyword( face,
486                                                          loader,
487                                                          keyword );
488                   if ( parser-&gt;root.error )
489                     return parser-&gt;root.error;
490                   break;
491                 }
492               }
493               keyword++;
494             }
495           }
496         }
497 
498         cur = parser-&gt;root.cursor;
499       }
500 
501       if ( !face-&gt;cid.num_dicts )
502       {
503         FT_ERROR(( &quot;cid_parse_dict: No font dictionary found\n&quot; ));
504         return FT_THROW( Invalid_File_Format );
505       }
506     }
507 
508     return parser-&gt;root.error;
509   }
510 
511 
512   /* read the subrmap and the subrs of each font dict */
513   static FT_Error
514   cid_read_subrs( CID_Face  face )
515   {
516     CID_FaceInfo   cid    = &amp;face-&gt;cid;
517     FT_Memory      memory = face-&gt;root.memory;
518     FT_Stream      stream = face-&gt;cid_stream;
519     FT_Error       error;
520     FT_Int         n;
521     CID_Subrs      subr;
522     FT_UInt        max_offsets = 0;
523     FT_ULong*      offsets = NULL;
524     PSAux_Service  psaux = (PSAux_Service)face-&gt;psaux;
525 
526 
527     if ( FT_NEW_ARRAY( face-&gt;subrs, cid-&gt;num_dicts ) )
528       goto Exit;
529 
530     subr = face-&gt;subrs;
531     for ( n = 0; n &lt; cid-&gt;num_dicts; n++, subr++ )
532     {
533       CID_FaceDict  dict  = cid-&gt;font_dicts + n;
534       FT_Int        lenIV = dict-&gt;private_dict.lenIV;
535       FT_UInt       count, num_subrs = dict-&gt;num_subrs;
536       FT_ULong      data_len;
537       FT_Byte*      p;
538 
539 
540       if ( !num_subrs )
541         continue;
542 
543       /* reallocate offsets array if needed */
544       if ( num_subrs + 1 &gt; max_offsets )
545       {
546         FT_UInt  new_max = FT_PAD_CEIL( num_subrs + 1, 4 );
547 
548 
549         if ( new_max &lt;= max_offsets )
550         {
551           error = FT_THROW( Syntax_Error );
552           goto Fail;
553         }
554 
555         if ( FT_RENEW_ARRAY( offsets, max_offsets, new_max ) )
556           goto Fail;
557 
558         max_offsets = new_max;
559       }
560 
561       /* read the subrmap&#39;s offsets */
562       if ( FT_STREAM_SEEK( cid-&gt;data_offset + dict-&gt;subrmap_offset )     ||
563            FT_FRAME_ENTER( ( num_subrs + 1 ) * (FT_UInt)dict-&gt;sd_bytes ) )
564         goto Fail;
565 
566       p = (FT_Byte*)stream-&gt;cursor;
567       for ( count = 0; count &lt;= num_subrs; count++ )
568         offsets[count] = cid_get_offset( &amp;p, (FT_Byte)dict-&gt;sd_bytes );
569 
570       FT_FRAME_EXIT();
571 
572       /* offsets must be ordered */
573       for ( count = 1; count &lt;= num_subrs; count++ )
574         if ( offsets[count - 1] &gt; offsets[count] )
575         {
576           FT_ERROR(( &quot;cid_read_subrs: offsets are not ordered\n&quot; ));
577           error = FT_THROW( Invalid_File_Format );
578           goto Fail;
579         }
580 
581       if ( offsets[num_subrs] &gt; stream-&gt;size - cid-&gt;data_offset )
582       {
583         FT_ERROR(( &quot;cid_read_subrs: too large `subrs&#39; offsets\n&quot; ));
584         error = FT_THROW( Invalid_File_Format );
585         goto Fail;
586       }
587 
588       /* now, compute the size of subrs charstrings, */
589       /* allocate, and read them                     */
590       data_len = offsets[num_subrs] - offsets[0];
591 
592       if ( FT_NEW_ARRAY( subr-&gt;code, num_subrs + 1 ) ||
593            FT_ALLOC( subr-&gt;code[0], data_len )       )
594         goto Fail;
595 
596       if ( FT_STREAM_SEEK( cid-&gt;data_offset + offsets[0] ) ||
597            FT_STREAM_READ( subr-&gt;code[0], data_len )  )
598         goto Fail;
599 
600       /* set up pointers */
601       for ( count = 1; count &lt;= num_subrs; count++ )
602       {
603         FT_ULong  len;
604 
605 
606         len               = offsets[count] - offsets[count - 1];
607         subr-&gt;code[count] = subr-&gt;code[count - 1] + len;
608       }
609 
610       /* decrypt subroutines, but only if lenIV &gt;= 0 */
611       if ( lenIV &gt;= 0 )
612       {
613         for ( count = 0; count &lt; num_subrs; count++ )
614         {
615           FT_ULong  len;
616 
617 
618           len = offsets[count + 1] - offsets[count];
619           psaux-&gt;t1_decrypt( subr-&gt;code[count], len, 4330 );
620         }
621       }
622 
623       subr-&gt;num_subrs = (FT_Int)num_subrs;
624     }
625 
626   Exit:
627     FT_FREE( offsets );
628     return error;
629 
630   Fail:
631     if ( face-&gt;subrs )
632     {
633       for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
634       {
635         if ( face-&gt;subrs[n].code )
636           FT_FREE( face-&gt;subrs[n].code[0] );
637 
638         FT_FREE( face-&gt;subrs[n].code );
639       }
640       FT_FREE( face-&gt;subrs );
641     }
642     goto Exit;
643   }
644 
645 
646   static void
647   cid_init_loader( CID_Loader*  loader,
648                    CID_Face     face )
649   {
650     FT_UNUSED( face );
651 
652     FT_ZERO( loader );
653   }
654 
655 
656   static  void
657   cid_done_loader( CID_Loader*  loader )
658   {
659     CID_Parser*  parser = &amp;loader-&gt;parser;
660 
661 
662     /* finalize parser */
663     cid_parser_done( parser );
664   }
665 
666 
667   static FT_Error
668   cid_hex_to_binary( FT_Byte*  data,
669                      FT_ULong  data_len,
670                      FT_ULong  offset,
671                      CID_Face  face )
672   {
673     FT_Stream  stream = face-&gt;root.stream;
674     FT_Error   error;
675 
676     FT_Byte    buffer[256];
677     FT_Byte   *p, *plimit;
678     FT_Byte   *d, *dlimit;
679     FT_Byte    val;
680 
681     FT_Bool    upper_nibble, done;
682 
683 
684     if ( FT_STREAM_SEEK( offset ) )
685       goto Exit;
686 
687     d      = data;
688     dlimit = d + data_len;
689     p      = buffer;
690     plimit = p;
691 
692     upper_nibble = 1;
693     done         = 0;
694 
695     while ( d &lt; dlimit )
696     {
697       if ( p &gt;= plimit )
698       {
699         FT_ULong  oldpos = FT_STREAM_POS();
700         FT_ULong  size   = stream-&gt;size - oldpos;
701 
702 
703         if ( size == 0 )
704         {
705           error = FT_THROW( Syntax_Error );
706           goto Exit;
707         }
708 
709         if ( FT_STREAM_READ( buffer, 256 &gt; size ? size : 256 ) )
710           goto Exit;
711         p      = buffer;
712         plimit = p + FT_STREAM_POS() - oldpos;
713       }
714 
715       if ( ft_isdigit( *p ) )
716         val = (FT_Byte)( *p - &#39;0&#39; );
717       else if ( *p &gt;= &#39;a&#39; &amp;&amp; *p &lt;= &#39;f&#39; )
718         val = (FT_Byte)( *p - &#39;a&#39; );
719       else if ( *p &gt;= &#39;A&#39; &amp;&amp; *p &lt;= &#39;F&#39; )
720         val = (FT_Byte)( *p - &#39;A&#39; + 10 );
721       else if ( *p == &#39; &#39;  ||
722                 *p == &#39;\t&#39; ||
723                 *p == &#39;\r&#39; ||
724                 *p == &#39;\n&#39; ||
725                 *p == &#39;\f&#39; ||
726                 *p == &#39;\0&#39; )
727       {
728         p++;
729         continue;
730       }
731       else if ( *p == &#39;&gt;&#39; )
732       {
733         val  = 0;
734         done = 1;
735       }
736       else
737       {
738         error = FT_THROW( Syntax_Error );
739         goto Exit;
740       }
741 
742       if ( upper_nibble )
743         *d = (FT_Byte)( val &lt;&lt; 4 );
744       else
745       {
746         *d = (FT_Byte)( *d + val );
747         d++;
748       }
749 
750       upper_nibble = (FT_Byte)( 1 - upper_nibble );
751 
752       if ( done )
753         break;
754 
755       p++;
756     }
757 
758     error = FT_Err_Ok;
759 
760   Exit:
761     return error;
762   }
763 
764 
765   FT_LOCAL_DEF( FT_Error )
766   cid_face_open( CID_Face  face,
767                  FT_Int    face_index )
768   {
769     CID_Loader   loader;
770     CID_Parser*  parser;
771     FT_Memory    memory = face-&gt;root.memory;
772     FT_Error     error;
773     FT_Int       n;
774 
775     CID_FaceInfo  cid = &amp;face-&gt;cid;
776 
777     FT_ULong  binary_length;
778     FT_ULong  entry_len;
779 
780 
781     cid_init_loader( &amp;loader, face );
782 
783     parser = &amp;loader.parser;
784     error = cid_parser_new( parser, face-&gt;root.stream, face-&gt;root.memory,
785                             (PSAux_Service)face-&gt;psaux );
786     if ( error )
787       goto Exit;
788 
789     error = cid_parse_dict( face, &amp;loader,
790                             parser-&gt;postscript,
791                             parser-&gt;postscript_len );
792     if ( error )
793       goto Exit;
794 
795     if ( face_index &lt; 0 )
796       goto Exit;
797 
798     if ( FT_NEW( face-&gt;cid_stream ) )
799       goto Exit;
800 
801     if ( parser-&gt;binary_length )
802     {
803       if ( parser-&gt;binary_length &gt;
804              face-&gt;root.stream-&gt;size - parser-&gt;data_offset )
805       {
806         FT_TRACE0(( &quot;cid_face_open: adjusting length of binary data\n&quot;
807                     &quot;               (from %d to %d bytes)\n&quot;,
808                     parser-&gt;binary_length,
809                     face-&gt;root.stream-&gt;size - parser-&gt;data_offset ));
810         parser-&gt;binary_length = face-&gt;root.stream-&gt;size -
811                                 parser-&gt;data_offset;
812       }
813 
814       /* we must convert the data section from hexadecimal to binary */
815       if ( FT_ALLOC( face-&gt;binary_data, parser-&gt;binary_length )    ||
816            FT_SET_ERROR( cid_hex_to_binary( face-&gt;binary_data,
817                                             parser-&gt;binary_length,
818                                             parser-&gt;data_offset,
819                                             face ) )               )
820         goto Exit;
821 
822       FT_Stream_OpenMemory( face-&gt;cid_stream,
823                             face-&gt;binary_data, parser-&gt;binary_length );
824       cid-&gt;data_offset = 0;
825     }
826     else
827     {
828       *face-&gt;cid_stream = *face-&gt;root.stream;
829       cid-&gt;data_offset  = loader.parser.data_offset;
830     }
831 
832     /* sanity tests */
833 
834     if ( cid-&gt;fd_bytes &lt; 0 || cid-&gt;gd_bytes &lt; 1 )
835     {
836       FT_ERROR(( &quot;cid_face_open:&quot;
837                  &quot; Invalid `FDBytes&#39; or `GDBytes&#39; value\n&quot; ));
838       error = FT_THROW( Invalid_File_Format );
839       goto Exit;
840     }
841 
842     /* allow at most 32bit offsets */
843     if ( cid-&gt;fd_bytes &gt; 4 || cid-&gt;gd_bytes &gt; 4 )
844     {
845       FT_ERROR(( &quot;cid_face_open:&quot;
846                  &quot; Values of `FDBytes&#39; or `GDBytes&#39; larger than 4\n&quot;
847                  &quot;               &quot;
848                  &quot; are not supported\n&quot; ));
849       error = FT_THROW( Invalid_File_Format );
850       goto Exit;
851     }
852 
853     binary_length = face-&gt;cid_stream-&gt;size - cid-&gt;data_offset;
854     entry_len     = (FT_ULong)( cid-&gt;fd_bytes + cid-&gt;gd_bytes );
855 
856     for ( n = 0; n &lt; cid-&gt;num_dicts; n++ )
857     {
858       CID_FaceDict  dict = cid-&gt;font_dicts + n;
859 
860 
861       /* the upper limits are ad-hoc values */
862       if ( dict-&gt;private_dict.blue_shift &gt; 1000 ||
863            dict-&gt;private_dict.blue_shift &lt; 0    )
864       {
865         FT_TRACE2(( &quot;cid_face_open:&quot;
866                     &quot; setting unlikely BlueShift value %d to default (7)\n&quot;,
867                     dict-&gt;private_dict.blue_shift ));
868         dict-&gt;private_dict.blue_shift = 7;
869       }
870 
871       if ( dict-&gt;private_dict.blue_fuzz &gt; 1000 ||
872            dict-&gt;private_dict.blue_fuzz &lt; 0    )
873       {
874         FT_TRACE2(( &quot;cid_face_open:&quot;
875                     &quot; setting unlikely BlueFuzz value %d to default (1)\n&quot;,
876                     dict-&gt;private_dict.blue_fuzz ));
877         dict-&gt;private_dict.blue_fuzz = 1;
878       }
879 
880       if ( dict-&gt;sd_bytes &lt; 0                        ||
881            ( dict-&gt;num_subrs &amp;&amp; dict-&gt;sd_bytes &lt; 1 ) )
882       {
883         FT_ERROR(( &quot;cid_face_open: Invalid `SDBytes&#39; value\n&quot; ));
884         error = FT_THROW( Invalid_File_Format );
885         goto Exit;
886       }
887 
888       if ( dict-&gt;sd_bytes &gt; 4 )
889       {
890         FT_ERROR(( &quot;cid_face_open:&quot;
891                    &quot; Values of `SDBytes&#39; larger than 4&quot;
892                    &quot; are not supported\n&quot; ));
893         error = FT_THROW( Invalid_File_Format );
894         goto Exit;
895       }
896 
897       if ( dict-&gt;subrmap_offset &gt; binary_length )
898       {
899         FT_ERROR(( &quot;cid_face_open: Invalid `SubrMapOffset&#39; value\n&quot; ));
900         error = FT_THROW( Invalid_File_Format );
901         goto Exit;
902       }
903 
904       /* `num_subrs&#39; is scanned as a signed integer */
905       if ( (FT_Int)dict-&gt;num_subrs &lt; 0                                     ||
906            ( dict-&gt;sd_bytes                                              &amp;&amp;
907              dict-&gt;num_subrs &gt; ( binary_length - dict-&gt;subrmap_offset ) /
908                                  (FT_UInt)dict-&gt;sd_bytes                 ) )
909       {
910         FT_ERROR(( &quot;cid_face_open: Invalid `SubrCount&#39; value\n&quot; ));
911         error = FT_THROW( Invalid_File_Format );
912         goto Exit;
913       }
914     }
915 
916     if ( cid-&gt;cidmap_offset &gt; binary_length )
917     {
918       FT_ERROR(( &quot;cid_face_open: Invalid `CIDMapOffset&#39; value\n&quot; ));
919       error = FT_THROW( Invalid_File_Format );
920       goto Exit;
921     }
922 
923     if ( entry_len                                            &amp;&amp;
924          cid-&gt;cid_count &gt;
925            ( binary_length - cid-&gt;cidmap_offset ) / entry_len )
926     {
927       FT_ERROR(( &quot;cid_face_open: Invalid `CIDCount&#39; value\n&quot; ));
928       error = FT_THROW( Invalid_File_Format );
929       goto Exit;
930     }
931 
932     /* we can now safely proceed */
933     error = cid_read_subrs( face );
934 
935   Exit:
936     cid_done_loader( &amp;loader );
937     return error;
938   }
939 
940 
941 /* END */
    </pre>
  </body>
</html>
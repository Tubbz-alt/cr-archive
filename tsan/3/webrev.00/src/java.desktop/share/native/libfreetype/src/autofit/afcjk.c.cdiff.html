<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="afblue.hin.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/autofit/afcjk.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,35 ***</span>
<span class="line-modified">! /***************************************************************************/</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  afcjk.c                                                                */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*    Auto-fitter hinting routines for CJK writing system (body).          */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  Copyright 2006-2018 by                                                 */</span>
<span class="line-modified">! /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">! /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">! /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">! /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">! /*  understand and accept it fully.                                        */</span>
<span class="line-modified">! /*                                                                         */</span>
<span class="line-modified">! /***************************************************************************/</span>
  
    /*
<span class="line-modified">!    *  The algorithm is based on akito&#39;s autohint patch, archived at</span>
     *
<span class="line-modified">!    *  https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
     *
     */
  
  #include &lt;ft2build.h&gt;
  #include FT_ADVANCES_H
  #include FT_INTERNAL_DEBUG_H
  
  #include &quot;afglobal.h&quot;
<span class="line-removed">- #include &quot;afpic.h&quot;</span>
  #include &quot;aflatin.h&quot;
  #include &quot;afcjk.h&quot;
  
  
  #ifdef AF_CONFIG_OPTION_CJK
<span class="line-new-header">--- 1,34 ---</span>
<span class="line-modified">! /****************************************************************************</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * afcjk.c</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  *   Auto-fitter hinting routines for CJK writing system (body).</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * Copyright (C) 2006-2019 by</span>
<span class="line-modified">!  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">!  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">!  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">!  * this file you indicate that you have read the license and</span>
<span class="line-modified">!  * understand and accept it fully.</span>
<span class="line-modified">!  *</span>
<span class="line-modified">!  */</span>
  
    /*
<span class="line-modified">!    * The algorithm is based on akito&#39;s autohint patch, archived at</span>
     *
<span class="line-modified">!    * https://web.archive.org/web/20051219160454/http://www.kde.gr.jp:80/~akito/patch/freetype2/2.1.7/</span>
     *
     */
  
  #include &lt;ft2build.h&gt;
  #include FT_ADVANCES_H
  #include FT_INTERNAL_DEBUG_H
  
  #include &quot;afglobal.h&quot;
  #include &quot;aflatin.h&quot;
  #include &quot;afcjk.h&quot;
  
  
  #ifdef AF_CONFIG_OPTION_CJK
</pre>
<hr />
<pre>
<span class="line-old-header">*** 42,18 ***</span>
  #ifdef AF_CONFIG_OPTION_USE_WARPER
  #include &quot;afwarp.h&quot;
  #endif
  
  
<span class="line-modified">!   /*************************************************************************/</span>
<span class="line-modified">!   /*                                                                       */</span>
<span class="line-modified">!   /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</span>
<span class="line-modified">!   /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</span>
<span class="line-modified">!   /* messages during execution.                                            */</span>
<span class="line-modified">!   /*                                                                       */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  trace_afcjk</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*****                                                               *****/
<span class="line-new-header">--- 41,18 ---</span>
  #ifdef AF_CONFIG_OPTION_USE_WARPER
  #include &quot;afwarp.h&quot;
  #endif
  
  
<span class="line-modified">!   /**************************************************************************</span>
<span class="line-modified">!    *</span>
<span class="line-modified">!    * The macro FT_COMPONENT is used in trace mode.  It is an implicit</span>
<span class="line-modified">!    * parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log</span>
<span class="line-modified">!    * messages during execution.</span>
<span class="line-modified">!    */</span>
  #undef  FT_COMPONENT
<span class="line-modified">! #define FT_COMPONENT  afcjk</span>
  
  
    /*************************************************************************/
    /*************************************************************************/
    /*****                                                               *****/
</pre>
<hr />
<pre>
<span class="line-old-header">*** 90,27 ***</span>
        FT_ULong          glyph_index;
        int               dim;
        AF_CJKMetricsRec  dummy[1];
        AF_Scaler         scaler = &amp;dummy-&gt;root.scaler;
  
<span class="line-removed">- #ifdef FT_CONFIG_OPTION_PIC</span>
<span class="line-removed">-       AF_FaceGlobals  globals = metrics-&gt;root.globals;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
        AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">!       AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</span>
<span class="line-modified">!                                        [style_class-&gt;script];</span>
  
<span class="line-removed">-       void*        shaper_buf;</span>
        const char*  p;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_ULong  ch = 0;
  #endif
  
<span class="line-modified">!       p          = script_class-&gt;standard_charstring;</span>
        shaper_buf = af_shaper_buf_create( face );
  
        /* We check a list of standard characters.  The first match wins. */
  
        glyph_index = 0;
        while ( *p )
<span class="line-new-header">--- 89,33 ---</span>
        FT_ULong          glyph_index;
        int               dim;
        AF_CJKMetricsRec  dummy[1];
        AF_Scaler         scaler = &amp;dummy-&gt;root.scaler;
  
        AF_StyleClass   style_class  = metrics-&gt;root.style_class;
<span class="line-modified">!       AF_ScriptClass  script_class = af_script_classes[style_class-&gt;script];</span>
<span class="line-modified">! </span>
<span class="line-added">+       /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+       /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+       void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+       FT_ULong  shaper_buf_;</span>
<span class="line-added">+       void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
        const char*  p;
  
  #ifdef FT_DEBUG_LEVEL_TRACE
        FT_ULong  ch = 0;
  #endif
  
<span class="line-modified">!       p = script_class-&gt;standard_charstring;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
        shaper_buf = af_shaper_buf_create( face );
<span class="line-added">+ #endif</span>
  
        /* We check a list of standard characters.  The first match wins. */
  
        glyph_index = 0;
        while ( *p )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,14 ***</span>
                                                   (AF_Dimension)dim );
          if ( error )
            goto Exit;
  
          /*
<span class="line-modified">!          *  We assume that the glyphs selected for the stem width</span>
<span class="line-modified">!          *  computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified">!          *  algorithm works fine without adjustments of its scoring</span>
<span class="line-modified">!          *  function.</span>
           */
          af_latin_hints_link_segments( hints,
                                        0,
                                        NULL,
                                        (AF_Dimension)dim );
<span class="line-new-header">--- 196,14 ---</span>
                                                   (AF_Dimension)dim );
          if ( error )
            goto Exit;
  
          /*
<span class="line-modified">!          * We assume that the glyphs selected for the stem width</span>
<span class="line-modified">!          * computation are `featureless&#39; enough so that the linking</span>
<span class="line-modified">!          * algorithm works fine without adjustments of its scoring</span>
<span class="line-modified">!          * function.</span>
           */
          af_latin_hints_link_segments( hints,
                                        0,
                                        NULL,
                                        (AF_Dimension)dim );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 294,22 ***</span>
      AF_StyleClass  sc = metrics-&gt;root.style_class;
  
      AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
      const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
  
<span class="line-modified">!     void*  shaper_buf;</span>
  
  
      /* we walk over the blue character strings as specified in the   */
      /* style&#39;s entry in the `af_blue_stringset&#39; array, computing its */
      /* extremum points (depending on the string properties)          */
  
      FT_TRACE5(( &quot;cjk blue zones computation\n&quot;
                  &quot;==========================\n&quot;
                  &quot;\n&quot; ));
  
      shaper_buf = af_shaper_buf_create( face );
  
      for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char*  p = &amp;af_blue_strings[bs-&gt;string];
        FT_Pos*      blue_ref;
<span class="line-new-header">--- 299,31 ---</span>
      AF_StyleClass  sc = metrics-&gt;root.style_class;
  
      AF_Blue_Stringset         bss = sc-&gt;blue_stringset;
      const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];
  
<span class="line-modified">!     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+     /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+     void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     FT_ULong  shaper_buf_;</span>
<span class="line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
  
      /* we walk over the blue character strings as specified in the   */
      /* style&#39;s entry in the `af_blue_stringset&#39; array, computing its */
      /* extremum points (depending on the string properties)          */
  
      FT_TRACE5(( &quot;cjk blue zones computation\n&quot;
                  &quot;==========================\n&quot;
                  &quot;\n&quot; ));
  
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="line-added">+ #endif</span>
  
      for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )
      {
        const char*  p = &amp;af_blue_strings[bs-&gt;string];
        FT_Pos*      blue_ref;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 481,12 ***</span>
        } /* end while loop */
  
        if ( num_flats == 0 &amp;&amp; num_fills == 0 )
        {
          /*
<span class="line-modified">!          *  we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified">!          *  we will simply ignore it then</span>
           */
          FT_TRACE5(( &quot;  empty\n&quot; ));
          continue;
        }
  
<span class="line-new-header">--- 495,12 ---</span>
        } /* end while loop */
  
        if ( num_flats == 0 &amp;&amp; num_fills == 0 )
        {
          /*
<span class="line-modified">!          * we couldn&#39;t find a single glyph to compute this blue zone,</span>
<span class="line-modified">!          * we will simply ignore it then</span>
           */
          FT_TRACE5(( &quot;  empty\n&quot; ));
          continue;
        }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,19 ***</span>
                                 FT_Face        face )
    {
      FT_Bool   started = 0, same_width = 1;
      FT_Fixed  advance = 0, old_advance = 0;
  
<span class="line-modified">!     void*  shaper_buf;</span>
  
      /* in all supported charmaps, digits have character codes 0x30-0x39 */
      const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
      const char*  p;
  
  
<span class="line-modified">!     p          = digits;</span>
      shaper_buf = af_shaper_buf_create( face );
  
      while ( *p )
      {
        FT_ULong      glyph_index;
        unsigned int  num_idx;
<span class="line-new-header">--- 577,29 ---</span>
                                 FT_Face        face )
    {
      FT_Bool   started = 0, same_width = 1;
      FT_Fixed  advance = 0, old_advance = 0;
  
<span class="line-modified">!     /* If HarfBuzz is not available, we need a pointer to a single */</span>
<span class="line-added">+     /* unsigned long value.                                        */</span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
<span class="line-added">+     void*     shaper_buf;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     FT_ULong  shaper_buf_;</span>
<span class="line-added">+     void*     shaper_buf = &amp;shaper_buf_;</span>
<span class="line-added">+ #endif</span>
  
      /* in all supported charmaps, digits have character codes 0x30-0x39 */
      const char   digits[] = &quot;0 1 2 3 4 5 6 7 8 9&quot;;
      const char*  p;
  
  
<span class="line-modified">!     p = digits;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #ifdef FT_CONFIG_OPTION_USE_HARFBUZZ</span>
      shaper_buf = af_shaper_buf_create( face );
<span class="line-added">+ #endif</span>
  
      while ( *p )
      {
        FT_ULong      glyph_index;
        unsigned int  num_idx;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 888,15 ***</span>
            }
          }
      }
  
      /*
<span class="line-modified">!      *  now compute the `serif&#39; segments</span>
       *
<span class="line-modified">!      *  In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="line-modified">!      *  We either identify the stems on the ends as serifs or remove</span>
<span class="line-modified">!      *  the linkage, depending on the length of the stems.</span>
       *
       */
  
      {
        AF_Segment  link1, link2;
<span class="line-new-header">--- 912,15 ---</span>
            }
          }
      }
  
      /*
<span class="line-modified">!      * now compute the `serif&#39; segments</span>
       *
<span class="line-modified">!      * In Hanzi, some strokes are wider on one or both of the ends.</span>
<span class="line-modified">!      * We either identify the stems on the ends as serifs or remove</span>
<span class="line-modified">!      * the linkage, depending on the length of the stems.</span>
       *
       */
  
      {
        AF_Segment  link1, link2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 998,25 ***</span>
      axis-&gt;num_edges = 0;
  
      scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
                                           : hints-&gt;y_scale;
  
<span class="line-modified">!     /*********************************************************************/</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* We begin by generating a sorted table of edges for the current    */</span>
<span class="line-modified">!     /* direction.  To do so, we simply scan each segment and try to find */</span>
<span class="line-modified">!     /* an edge in our table that corresponds to its position.            */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* If no edge is found, we create and insert a new edge in the       */</span>
<span class="line-modified">!     /* sorted table.  Otherwise, we simply add the segment to the edge&#39;s */</span>
<span class="line-modified">!     /* list which is then processed in the second step to compute the    */</span>
<span class="line-modified">!     /* edge&#39;s properties.                                                */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /* Note that the edges table is sorted along the segment/edge        */</span>
<span class="line-modified">!     /* position.                                                         */</span>
<span class="line-modified">!     /*                                                                   */</span>
<span class="line-modified">!     /*********************************************************************/</span>
  
      edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
                                           scale );
      if ( edge_distance_threshold &gt; 64 / 4 )
        edge_distance_threshold = FT_DivFix( 64 / 4, scale );
<span class="line-new-header">--- 1022,25 ---</span>
      axis-&gt;num_edges = 0;
  
      scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale
                                           : hints-&gt;y_scale;
  
<span class="line-modified">!     /**********************************************************************</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * We begin by generating a sorted table of edges for the current</span>
<span class="line-modified">!      * direction.  To do so, we simply scan each segment and try to find</span>
<span class="line-modified">!      * an edge in our table that corresponds to its position.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * If no edge is found, we create and insert a new edge in the</span>
<span class="line-modified">!      * sorted table.  Otherwise, we simply add the segment to the edge&#39;s</span>
<span class="line-modified">!      * list which is then processed in the second step to compute the</span>
<span class="line-modified">!      * edge&#39;s properties.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Note that the edges table is sorted along the segment/edge</span>
<span class="line-modified">!      * position.</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      */</span>
  
      edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,
                                           scale );
      if ( edge_distance_threshold &gt; 64 / 4 )
        edge_distance_threshold = FT_DivFix( 64 / 4, scale );
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1112,21 ***</span>
          found-&gt;last-&gt;edge_next = seg;
          found-&gt;last            = seg;
        }
      }
  
<span class="line-modified">!     /******************************************************************/</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /* Good, we now compute each edge&#39;s properties according to the   */</span>
<span class="line-modified">!     /* segments found on its position.  Basically, these are          */</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /*  - the edge&#39;s main direction                                   */</span>
<span class="line-modified">!     /*  - stem edge, serif edge or both (which defaults to stem then) */</span>
<span class="line-modified">!     /*  - rounded edge, straight or both (which defaults to straight) */</span>
<span class="line-modified">!     /*  - link for edge                                               */</span>
<span class="line-modified">!     /*                                                                */</span>
<span class="line-modified">!     /******************************************************************/</span>
  
      /* first of all, set the `edge&#39; field in each segment -- this is */
      /* required in order to compute edge links                       */
  
      /*
<span class="line-new-header">--- 1136,21 ---</span>
          found-&gt;last-&gt;edge_next = seg;
          found-&gt;last            = seg;
        }
      }
  
<span class="line-modified">!     /*******************************************************************</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * Good, we now compute each edge&#39;s properties according to the</span>
<span class="line-modified">!      * segments found on its position.  Basically, these are</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      * - the edge&#39;s main direction</span>
<span class="line-modified">!      * - stem edge, serif edge or both (which defaults to stem then)</span>
<span class="line-modified">!      * - rounded edge, straight or both (which defaults to straight)</span>
<span class="line-modified">!      * - link for edge</span>
<span class="line-modified">!      *</span>
<span class="line-modified">!      */</span>
  
      /* first of all, set the `edge&#39; field in each segment -- this is */
      /* required in order to compute edge links                       */
  
      /*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1158,10 ***</span>
<span class="line-new-header">--- 1182,12 ---</span>
          FT_Int  is_round    = 0;  /* does it contain round segments?    */
          FT_Int  is_straight = 0;  /* does it contain straight segments? */
  
  
          seg = edge-&gt;first;
<span class="line-added">+         if ( !seg )</span>
<span class="line-added">+           goto Skip_Loop;</span>
  
          do
          {
            FT_Bool  is_serif;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1172,11 ***</span>
            else
              is_straight++;
  
            /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
            /* be ignored                                                   */
<span class="line-modified">!           is_serif = (FT_Bool)( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
  
            if ( seg-&gt;link || is_serif )
            {
              AF_Edge     edge2;
              AF_Segment  seg2;
<span class="line-new-header">--- 1198,11 ---</span>
            else
              is_straight++;
  
            /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */
            /* be ignored                                                   */
<span class="line-modified">!           is_serif = FT_BOOL( seg-&gt;serif &amp;&amp; seg-&gt;serif-&gt;edge != edge );</span>
  
            if ( seg-&gt;link || is_serif )
            {
              AF_Edge     edge2;
              AF_Segment  seg2;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1213,17 ***</span>
              {
                edge-&gt;serif   = edge2;
                edge2-&gt;flags |= AF_EDGE_SERIF;
              }
              else
<span class="line-modified">!               edge-&gt;link  = edge2;</span>
            }
  
            seg = seg-&gt;edge_next;
  
          } while ( seg != edge-&gt;first );
  
          /* set the round/straight flags */
          edge-&gt;flags = AF_EDGE_NORMAL;
  
          if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
            edge-&gt;flags |= AF_EDGE_ROUND;
<span class="line-new-header">--- 1239,18 ---</span>
              {
                edge-&gt;serif   = edge2;
                edge2-&gt;flags |= AF_EDGE_SERIF;
              }
              else
<span class="line-modified">!               edge-&gt;link = edge2;</span>
            }
  
            seg = seg-&gt;edge_next;
  
          } while ( seg != edge-&gt;first );
  
<span class="line-added">+       Skip_Loop:</span>
          /* set the round/straight flags */
          edge-&gt;flags = AF_EDGE_NORMAL;
  
          if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )
            edge-&gt;flags |= AF_EDGE_ROUND;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1362,12 ***</span>
  
  
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
  
      /*
<span class="line-modified">!      *  correct x_scale and y_scale when needed, since they may have</span>
<span class="line-modified">!      *  been modified af_cjk_scale_dim above</span>
       */
      hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
      hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
      hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
      hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
<span class="line-new-header">--- 1389,12 ---</span>
  
  
      af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
  
      /*
<span class="line-modified">!      * correct x_scale and y_scale when needed, since they may have</span>
<span class="line-modified">!      * been modified af_cjk_scale_dim above</span>
       */
      hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;
      hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;
      hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;
      hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1382,25 ***</span>
  
      scaler_flags = hints-&gt;scaler_flags;
      other_flags  = 0;
  
      /*
<span class="line-modified">!      *  We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">!      *  horizontal LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
  
      /*
<span class="line-modified">!      *  We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">!      *  vertical LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
        other_flags |= AF_LATIN_HINTS_VERT_SNAP;
  
      /*
<span class="line-modified">!      *  We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
       */
      if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
  
      if ( mode == FT_RENDER_MODE_MONO )
<span class="line-new-header">--- 1409,25 ---</span>
  
      scaler_flags = hints-&gt;scaler_flags;
      other_flags  = 0;
  
      /*
<span class="line-modified">!      * We snap the width of vertical stems for the monochrome and</span>
<span class="line-modified">!      * horizontal LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
  
      /*
<span class="line-modified">!      * We snap the width of horizontal stems for the monochrome and</span>
<span class="line-modified">!      * vertical LCD rendering targets only.</span>
       */
      if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
        other_flags |= AF_LATIN_HINTS_VERT_SNAP;
  
      /*
<span class="line-modified">!      * We adjust stems to full pixels unless in `light&#39; or `lcd&#39; mode.</span>
       */
      if ( mode != FT_RENDER_MODE_LIGHT &amp;&amp; mode != FT_RENDER_MODE_LCD )
        other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
  
      if ( mode == FT_RENDER_MODE_MONO )
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2092,12 ***</span>
  
      if ( !skipped )
        goto Exit;
  
      /*
<span class="line-modified">!      *  now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">!      *  to complete our processing</span>
       */
      for ( edge = edges; edge &lt; edge_limit; edge++ )
      {
        if ( edge-&gt;flags &amp; AF_EDGE_DONE )
          continue;
<span class="line-new-header">--- 2119,12 ---</span>
  
      if ( !skipped )
        goto Exit;
  
      /*
<span class="line-modified">!      * now hint the remaining edges (serifs and single) in order</span>
<span class="line-modified">!      * to complete our processing</span>
       */
      for ( edge = edges; edge &lt; edge_limit; edge++ )
      {
        if ( edge-&gt;flags &amp; AF_EDGE_DONE )
          continue;
</pre>
<center><a href="afblue.hin.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="afcjk.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
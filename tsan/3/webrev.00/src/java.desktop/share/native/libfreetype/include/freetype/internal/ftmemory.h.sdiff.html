<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/include/freetype/internal/ftmemory.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="fthash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftobjs.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/include/freetype/internal/ftmemory.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">  1 /***************************************************************************/</span>
<span class="line-modified">  2 /*                                                                         */</span>
<span class="line-modified">  3 /*  ftmemory.h                                                             */</span>
<span class="line-modified">  4 /*                                                                         */</span>
<span class="line-modified">  5 /*    The FreeType memory management macros (specification).               */</span>
<span class="line-modified">  6 /*                                                                         */</span>
<span class="line-modified">  7 /*  Copyright 1996-2018 by                                                 */</span>
<span class="line-modified">  8 /*  David Turner, Robert Wilhelm, and Werner Lemberg                       */</span>
<span class="line-modified">  9 /*                                                                         */</span>
<span class="line-modified"> 10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified"> 11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified"> 12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified"> 13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified"> 14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified"> 15 /*                                                                         */</span>
<span class="line-modified"> 16 /***************************************************************************/</span>
 17 
 18 
 19 #ifndef FTMEMORY_H_
 20 #define FTMEMORY_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_CONFIG_CONFIG_H
 25 #include FT_TYPES_H
 26 
 27 
 28 FT_BEGIN_HEADER
 29 
 30 
<span class="line-modified"> 31   /*************************************************************************/</span>
<span class="line-modified"> 32   /*                                                                       */</span>
<span class="line-modified"> 33   /* &lt;Macro&gt;                                                               */</span>
<span class="line-modified"> 34   /*    FT_SET_ERROR                                                       */</span>
<span class="line-modified"> 35   /*                                                                       */</span>
<span class="line-modified"> 36   /* &lt;Description&gt;                                                         */</span>
<span class="line-modified"> 37   /*    This macro is used to set an implicit `error&#39; variable to a given  */</span>
<span class="line-modified"> 38   /*    expression&#39;s value (usually a function call), and convert it to a  */</span>
<span class="line-modified"> 39   /*    boolean which is set whenever the value is != 0.                   */</span>
<span class="line-modified"> 40   /*                                                                       */</span>
 41 #undef  FT_SET_ERROR
 42 #define FT_SET_ERROR( expression ) \
 43           ( ( error = (expression) ) != 0 )
 44 
 45 
 46 
 47   /*************************************************************************/
 48   /*************************************************************************/
 49   /*************************************************************************/
 50   /****                                                                 ****/
 51   /****                                                                 ****/
 52   /****                           M E M O R Y                           ****/
 53   /****                                                                 ****/
 54   /****                                                                 ****/
 55   /*************************************************************************/
 56   /*************************************************************************/
 57   /*************************************************************************/
 58 
 59 
 60   /*
<span class="line-modified"> 61    *  C++ refuses to handle statements like p = (void*)anything, with `p&#39; a</span>
<span class="line-modified"> 62    *  typed pointer.  Since we don&#39;t have a `typeof&#39; operator in standard</span>
<span class="line-modified"> 63    *  C++, we have to use a template to emulate it.</span>
 64    */
 65 
 66 #ifdef __cplusplus
 67 
 68 extern &quot;C++&quot;
 69 {
 70   template &lt;typename T&gt; inline T*
 71   cplusplus_typeof(        T*,
 72                     void  *v )
 73   {
 74     return static_cast &lt;T*&gt; ( v );
 75   }
 76 }
 77 
 78 #define FT_ASSIGNP( p, val )  (p) = cplusplus_typeof( (p), (val) )
 79 
 80 #else
 81 
 82 #define FT_ASSIGNP( p, val )  (p) = (val)
 83 
</pre>
<hr />
<pre>
 90   FT_BASE( const char* )  _ft_debug_file;
 91   FT_BASE( long )         _ft_debug_lineno;
 92 
 93 #define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \
 94                                  _ft_debug_lineno = __LINE__, \
 95                                  (exp) )
 96 
 97 #define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \
 98                                       _ft_debug_lineno = __LINE__, \
 99                                       FT_ASSIGNP( p, exp ) )
100 
101 #else /* !FT_DEBUG_MEMORY */
102 
103 #define FT_DEBUG_INNER( exp )       (exp)
104 #define FT_ASSIGNP_INNER( p, exp )  FT_ASSIGNP( p, exp )
105 
106 #endif /* !FT_DEBUG_MEMORY */
107 
108 
109   /*
<span class="line-modified">110    *  The allocation functions return a pointer, and the error code</span>
<span class="line-modified">111    *  is written to through the `p_error&#39; parameter.</span>
112    */
113 
114   /* The `q&#39; variants of the functions below (`q&#39; for `quick&#39;) don&#39;t fill */
115   /* the allocated or reallocated memory with zero bytes.                 */
116 
117   FT_BASE( FT_Pointer )
118   ft_mem_alloc( FT_Memory  memory,
119                 FT_Long    size,
120                 FT_Error  *p_error );
121 
122   FT_BASE( FT_Pointer )
123   ft_mem_qalloc( FT_Memory  memory,
124                  FT_Long    size,
125                  FT_Error  *p_error );
126 
127   FT_BASE( FT_Pointer )
128   ft_mem_realloc( FT_Memory  memory,
129                   FT_Long    item_size,
130                   FT_Long    cur_count,
131                   FT_Long    new_count,
</pre>
<hr />
<pre>
236 
237 #define FT_ZERO( p )                FT_MEM_ZERO( p, sizeof ( *(p) ) )
238 
239 
240 #define FT_ARRAY_ZERO( dest, count )                             \
241           FT_MEM_ZERO( dest,                                     \
242                        (FT_Offset)(count) * sizeof ( *(dest) ) )
243 
244 #define FT_ARRAY_COPY( dest, source, count )                     \
245           FT_MEM_COPY( dest,                                     \
246                        source,                                   \
247                        (FT_Offset)(count) * sizeof ( *(dest) ) )
248 
249 #define FT_ARRAY_MOVE( dest, source, count )                     \
250           FT_MEM_MOVE( dest,                                     \
251                        source,                                   \
252                        (FT_Offset)(count) * sizeof ( *(dest) ) )
253 
254 
255   /*
<span class="line-modified">256    *  Return the maximum number of addressable elements in an array.</span>
<span class="line-modified">257    *  We limit ourselves to INT_MAX, rather than UINT_MAX, to avoid</span>
<span class="line-removed">258    *  any problems.</span>
259    */
260 #define FT_ARRAY_MAX( ptr )           ( FT_INT_MAX / sizeof ( *(ptr) ) )
261 
262 #define FT_ARRAY_CHECK( ptr, count )  ( (count) &lt;= FT_ARRAY_MAX( ptr ) )
263 
264 
<span class="line-modified">265   /*************************************************************************/</span>
<span class="line-modified">266   /*                                                                       */</span>
<span class="line-modified">267   /* The following functions macros expect that their pointer argument is  */</span>
<span class="line-modified">268   /* _typed_ in order to automatically compute array element sizes.        */</span>
<span class="line-modified">269   /*                                                                       */</span>
270 
271 #define FT_MEM_NEW_ARRAY( ptr, count )                              \
272           FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
273                                                  sizeof ( *(ptr) ), \
274                                                  0,                 \
275                                                  (FT_Long)(count),  \
276                                                  NULL,              \
277                                                  &amp;error ) )
278 
279 #define FT_MEM_RENEW_ARRAY( ptr, cursz, newsz )                     \
280           FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
281                                                  sizeof ( *(ptr) ), \
282                                                  (FT_Long)(cursz),  \
283                                                  (FT_Long)(newsz),  \
284                                                  (ptr),             \
285                                                  &amp;error ) )
286 
287 #define FT_MEM_QNEW_ARRAY( ptr, count )                              \
288           FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,            \
289                                                   sizeof ( *(ptr) ), \
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">  1 /****************************************************************************</span>
<span class="line-modified">  2  *</span>
<span class="line-modified">  3  * ftmemory.h</span>
<span class="line-modified">  4  *</span>
<span class="line-modified">  5  *   The FreeType memory management macros (specification).</span>
<span class="line-modified">  6  *</span>
<span class="line-modified">  7  * Copyright (C) 1996-2019 by</span>
<span class="line-modified">  8  * David Turner, Robert Wilhelm, and Werner Lemberg</span>
<span class="line-modified">  9  *</span>
<span class="line-modified"> 10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified"> 11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified"> 12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified"> 13  * this file you indicate that you have read the license and</span>
<span class="line-modified"> 14  * understand and accept it fully.</span>
<span class="line-modified"> 15  *</span>
<span class="line-modified"> 16  */</span>
 17 
 18 
 19 #ifndef FTMEMORY_H_
 20 #define FTMEMORY_H_
 21 
 22 
 23 #include &lt;ft2build.h&gt;
 24 #include FT_CONFIG_CONFIG_H
 25 #include FT_TYPES_H
 26 
 27 
 28 FT_BEGIN_HEADER
 29 
 30 
<span class="line-modified"> 31   /**************************************************************************</span>
<span class="line-modified"> 32    *</span>
<span class="line-modified"> 33    * @macro:</span>
<span class="line-modified"> 34    *   FT_SET_ERROR</span>
<span class="line-modified"> 35    *</span>
<span class="line-modified"> 36    * @description:</span>
<span class="line-modified"> 37    *   This macro is used to set an implicit &#39;error&#39; variable to a given</span>
<span class="line-modified"> 38    *   expression&#39;s value (usually a function call), and convert it to a</span>
<span class="line-modified"> 39    *   boolean which is set whenever the value is != 0.</span>
<span class="line-modified"> 40    */</span>
 41 #undef  FT_SET_ERROR
 42 #define FT_SET_ERROR( expression ) \
 43           ( ( error = (expression) ) != 0 )
 44 
 45 
 46 
 47   /*************************************************************************/
 48   /*************************************************************************/
 49   /*************************************************************************/
 50   /****                                                                 ****/
 51   /****                                                                 ****/
 52   /****                           M E M O R Y                           ****/
 53   /****                                                                 ****/
 54   /****                                                                 ****/
 55   /*************************************************************************/
 56   /*************************************************************************/
 57   /*************************************************************************/
 58 
 59 
 60   /*
<span class="line-modified"> 61    * C++ refuses to handle statements like p = (void*)anything, with `p&#39; a</span>
<span class="line-modified"> 62    * typed pointer.  Since we don&#39;t have a `typeof&#39; operator in standard C++,</span>
<span class="line-modified"> 63    * we have to use a template to emulate it.</span>
 64    */
 65 
 66 #ifdef __cplusplus
 67 
 68 extern &quot;C++&quot;
 69 {
 70   template &lt;typename T&gt; inline T*
 71   cplusplus_typeof(        T*,
 72                     void  *v )
 73   {
 74     return static_cast &lt;T*&gt; ( v );
 75   }
 76 }
 77 
 78 #define FT_ASSIGNP( p, val )  (p) = cplusplus_typeof( (p), (val) )
 79 
 80 #else
 81 
 82 #define FT_ASSIGNP( p, val )  (p) = (val)
 83 
</pre>
<hr />
<pre>
 90   FT_BASE( const char* )  _ft_debug_file;
 91   FT_BASE( long )         _ft_debug_lineno;
 92 
 93 #define FT_DEBUG_INNER( exp )  ( _ft_debug_file   = __FILE__, \
 94                                  _ft_debug_lineno = __LINE__, \
 95                                  (exp) )
 96 
 97 #define FT_ASSIGNP_INNER( p, exp )  ( _ft_debug_file   = __FILE__, \
 98                                       _ft_debug_lineno = __LINE__, \
 99                                       FT_ASSIGNP( p, exp ) )
100 
101 #else /* !FT_DEBUG_MEMORY */
102 
103 #define FT_DEBUG_INNER( exp )       (exp)
104 #define FT_ASSIGNP_INNER( p, exp )  FT_ASSIGNP( p, exp )
105 
106 #endif /* !FT_DEBUG_MEMORY */
107 
108 
109   /*
<span class="line-modified">110    * The allocation functions return a pointer, and the error code is written</span>
<span class="line-modified">111    * to through the `p_error&#39; parameter.</span>
112    */
113 
114   /* The `q&#39; variants of the functions below (`q&#39; for `quick&#39;) don&#39;t fill */
115   /* the allocated or reallocated memory with zero bytes.                 */
116 
117   FT_BASE( FT_Pointer )
118   ft_mem_alloc( FT_Memory  memory,
119                 FT_Long    size,
120                 FT_Error  *p_error );
121 
122   FT_BASE( FT_Pointer )
123   ft_mem_qalloc( FT_Memory  memory,
124                  FT_Long    size,
125                  FT_Error  *p_error );
126 
127   FT_BASE( FT_Pointer )
128   ft_mem_realloc( FT_Memory  memory,
129                   FT_Long    item_size,
130                   FT_Long    cur_count,
131                   FT_Long    new_count,
</pre>
<hr />
<pre>
236 
237 #define FT_ZERO( p )                FT_MEM_ZERO( p, sizeof ( *(p) ) )
238 
239 
240 #define FT_ARRAY_ZERO( dest, count )                             \
241           FT_MEM_ZERO( dest,                                     \
242                        (FT_Offset)(count) * sizeof ( *(dest) ) )
243 
244 #define FT_ARRAY_COPY( dest, source, count )                     \
245           FT_MEM_COPY( dest,                                     \
246                        source,                                   \
247                        (FT_Offset)(count) * sizeof ( *(dest) ) )
248 
249 #define FT_ARRAY_MOVE( dest, source, count )                     \
250           FT_MEM_MOVE( dest,                                     \
251                        source,                                   \
252                        (FT_Offset)(count) * sizeof ( *(dest) ) )
253 
254 
255   /*
<span class="line-modified">256    * Return the maximum number of addressable elements in an array.  We limit</span>
<span class="line-modified">257    * ourselves to INT_MAX, rather than UINT_MAX, to avoid any problems.</span>

258    */
259 #define FT_ARRAY_MAX( ptr )           ( FT_INT_MAX / sizeof ( *(ptr) ) )
260 
261 #define FT_ARRAY_CHECK( ptr, count )  ( (count) &lt;= FT_ARRAY_MAX( ptr ) )
262 
263 
<span class="line-modified">264   /**************************************************************************</span>
<span class="line-modified">265    *</span>
<span class="line-modified">266    * The following functions macros expect that their pointer argument is</span>
<span class="line-modified">267    * _typed_ in order to automatically compute array element sizes.</span>
<span class="line-modified">268    */</span>
269 
270 #define FT_MEM_NEW_ARRAY( ptr, count )                              \
271           FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
272                                                  sizeof ( *(ptr) ), \
273                                                  0,                 \
274                                                  (FT_Long)(count),  \
275                                                  NULL,              \
276                                                  &amp;error ) )
277 
278 #define FT_MEM_RENEW_ARRAY( ptr, cursz, newsz )                     \
279           FT_ASSIGNP_INNER( ptr, ft_mem_realloc( memory,            \
280                                                  sizeof ( *(ptr) ), \
281                                                  (FT_Long)(cursz),  \
282                                                  (FT_Long)(newsz),  \
283                                                  (ptr),             \
284                                                  &amp;error ) )
285 
286 #define FT_MEM_QNEW_ARRAY( ptr, count )                              \
287           FT_ASSIGNP_INNER( ptr, ft_mem_qrealloc( memory,            \
288                                                   sizeof ( *(ptr) ), \
</pre>
</td>
</tr>
</table>
<center><a href="fthash.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ftobjs.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
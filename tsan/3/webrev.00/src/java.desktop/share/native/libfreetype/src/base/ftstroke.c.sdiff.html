<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/share/native/libfreetype/src/base/ftstroke.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ftstream.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftsynth.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/share/native/libfreetype/src/base/ftstroke.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
<span class="line-modified">   1 /***************************************************************************/</span>
<span class="line-modified">   2 /*                                                                         */</span>
<span class="line-modified">   3 /*  ftstroke.c                                                             */</span>
<span class="line-modified">   4 /*                                                                         */</span>
<span class="line-modified">   5 /*    FreeType path stroker (body).                                        */</span>
<span class="line-modified">   6 /*                                                                         */</span>
<span class="line-modified">   7 /*  Copyright 2002-2018 by                                                 */</span>
<span class="line-modified">   8 /*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</span>
<span class="line-modified">   9 /*                                                                         */</span>
<span class="line-modified">  10 /*  This file is part of the FreeType project, and may only be used,       */</span>
<span class="line-modified">  11 /*  modified, and distributed under the terms of the FreeType project      */</span>
<span class="line-modified">  12 /*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</span>
<span class="line-modified">  13 /*  this file you indicate that you have read the license and              */</span>
<span class="line-modified">  14 /*  understand and accept it fully.                                        */</span>
<span class="line-modified">  15 /*                                                                         */</span>
<span class="line-modified">  16 /***************************************************************************/</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_STROKER_H
  21 #include FT_TRIGONOMETRY_H
  22 #include FT_OUTLINE_H
  23 #include FT_INTERNAL_MEMORY_H
  24 #include FT_INTERNAL_DEBUG_H
  25 #include FT_INTERNAL_OBJECTS_H
  26 
<span class="line-removed">  27 #include &quot;basepic.h&quot;</span>
  28 
<span class="line-modified">  29 </span>
<span class="line-modified">  30   /* declare an extern to access `ft_outline_glyph_class&#39; globally     */</span>
<span class="line-removed">  31   /* allocated  in `ftglyph.c&#39;, and use the FT_OUTLINE_GLYPH_CLASS_GET */</span>
<span class="line-removed">  32   /* macro to access it when FT_CONFIG_OPTION_PIC is defined           */</span>
<span class="line-removed">  33 #ifndef FT_CONFIG_OPTION_PIC</span>
  34   FT_CALLBACK_TABLE const FT_Glyph_Class  ft_outline_glyph_class;
<span class="line-removed">  35 #endif</span>
  36 
  37 
  38   /* documentation is in ftstroke.h */
  39 
  40   FT_EXPORT_DEF( FT_StrokerBorder )
  41   FT_Outline_GetInsideBorder( FT_Outline*  outline )
  42   {
  43     FT_Orientation  o = FT_Outline_Get_Orientation( outline );
  44 
  45 
  46     return o == FT_ORIENTATION_TRUETYPE ? FT_STROKER_BORDER_RIGHT
  47                                         : FT_STROKER_BORDER_LEFT;
  48   }
  49 
  50 
  51   /* documentation is in ftstroke.h */
  52 
  53   FT_EXPORT_DEF( FT_StrokerBorder )
  54   FT_Outline_GetOutsideBorder( FT_Outline*  outline )
  55   {
</pre>
<hr />
<pre>
  74 
  75 #define FT_EPSILON  2
  76 
  77 #define FT_IS_SMALL( x )  ( (x) &gt; -FT_EPSILON &amp;&amp; (x) &lt; FT_EPSILON )
  78 
  79 
  80   static FT_Pos
  81   ft_pos_abs( FT_Pos  x )
  82   {
  83     return x &gt;= 0 ? x : -x;
  84   }
  85 
  86 
  87   static void
  88   ft_conic_split( FT_Vector*  base )
  89   {
  90     FT_Pos  a, b;
  91 
  92 
  93     base[4].x = base[2].x;
<span class="line-modified">  94     b = base[1].x;</span>
<span class="line-modified">  95     a = base[3].x = ( base[2].x + b ) / 2;</span>
<span class="line-modified">  96     b = base[1].x = ( base[0].x + b ) / 2;</span>
<span class="line-modified">  97     base[2].x = ( a + b ) / 2;</span>

  98 
  99     base[4].y = base[2].y;
<span class="line-modified"> 100     b = base[1].y;</span>
<span class="line-modified"> 101     a = base[3].y = ( base[2].y + b ) / 2;</span>
<span class="line-modified"> 102     b = base[1].y = ( base[0].y + b ) / 2;</span>
<span class="line-modified"> 103     base[2].y = ( a + b ) / 2;</span>

 104   }
 105 
 106 
 107   static FT_Bool
 108   ft_conic_is_small_enough( FT_Vector*  base,
 109                             FT_Angle   *angle_in,
 110                             FT_Angle   *angle_out )
 111   {
 112     FT_Vector  d1, d2;
 113     FT_Angle   theta;
 114     FT_Int     close1, close2;
 115 
 116 
 117     d1.x = base[1].x - base[2].x;
 118     d1.y = base[1].y - base[2].y;
 119     d2.x = base[0].x - base[1].x;
 120     d2.y = base[0].y - base[1].y;
 121 
 122     close1 = FT_IS_SMALL( d1.x ) &amp;&amp; FT_IS_SMALL( d1.y );
 123     close2 = FT_IS_SMALL( d2.x ) &amp;&amp; FT_IS_SMALL( d2.y );
</pre>
<hr />
<pre>
 141       {
 142         *angle_in  =
 143         *angle_out = FT_Atan2( d1.x, d1.y );
 144       }
 145       else
 146       {
 147         *angle_in  = FT_Atan2( d1.x, d1.y );
 148         *angle_out = FT_Atan2( d2.x, d2.y );
 149       }
 150     }
 151 
 152     theta = ft_pos_abs( FT_Angle_Diff( *angle_in, *angle_out ) );
 153 
 154     return FT_BOOL( theta &lt; FT_SMALL_CONIC_THRESHOLD );
 155   }
 156 
 157 
 158   static void
 159   ft_cubic_split( FT_Vector*  base )
 160   {
<span class="line-modified"> 161     FT_Pos  a, b, c, d;</span>
 162 
 163 
 164     base[6].x = base[3].x;
<span class="line-modified"> 165     c = base[1].x;</span>
<span class="line-modified"> 166     d = base[2].x;</span>
<span class="line-modified"> 167     base[1].x = a = ( base[0].x + c ) / 2;</span>
<span class="line-modified"> 168     base[5].x = b = ( base[3].x + d ) / 2;</span>
<span class="line-modified"> 169     c = ( c + d ) / 2;</span>
<span class="line-modified"> 170     base[2].x = a = ( a + c ) / 2;</span>
<span class="line-modified"> 171     base[4].x = b = ( b + c ) / 2;</span>
<span class="line-modified"> 172     base[3].x = ( a + b ) / 2;</span>


 173 
 174     base[6].y = base[3].y;
<span class="line-modified"> 175     c = base[1].y;</span>
<span class="line-modified"> 176     d = base[2].y;</span>
<span class="line-modified"> 177     base[1].y = a = ( base[0].y + c ) / 2;</span>
<span class="line-modified"> 178     base[5].y = b = ( base[3].y + d ) / 2;</span>
<span class="line-modified"> 179     c = ( c + d ) / 2;</span>
<span class="line-modified"> 180     base[2].y = a = ( a + c ) / 2;</span>
<span class="line-modified"> 181     base[4].y = b = ( b + c ) / 2;</span>
<span class="line-modified"> 182     base[3].y = ( a + b ) / 2;</span>


 183   }
 184 
 185 
 186   /* Return the average of `angle1&#39; and `angle2&#39;.            */
 187   /* This gives correct result even if `angle1&#39; and `angle2&#39; */
 188   /* have opposite signs.                                    */
 189   static FT_Angle
 190   ft_angle_mean( FT_Angle  angle1,
 191                  FT_Angle  angle2 )
 192   {
 193     return angle1 + FT_Angle_Diff( angle1, angle2 ) / 2;
 194   }
 195 
 196 
 197   static FT_Bool
 198   ft_cubic_is_small_enough( FT_Vector*  base,
 199                             FT_Angle   *angle_in,
 200                             FT_Angle   *angle_mid,
 201                             FT_Angle   *angle_out )
 202   {
</pre>
<hr />
<pre>
 355 
 356   static void
 357   ft_stroke_border_close( FT_StrokeBorder  border,
 358                           FT_Bool          reverse )
 359   {
 360     FT_UInt  start = (FT_UInt)border-&gt;start;
 361     FT_UInt  count = border-&gt;num_points;
 362 
 363 
 364     FT_ASSERT( border-&gt;start &gt;= 0 );
 365 
 366     /* don&#39;t record empty paths! */
 367     if ( count &lt;= start + 1U )
 368       border-&gt;num_points = start;
 369     else
 370     {
 371       /* copy the last point to the start of this sub-path, since */
 372       /* it contains the `adjusted&#39; starting coordinates          */
 373       border-&gt;num_points    = --count;
 374       border-&gt;points[start] = border-&gt;points[count];

 375 
 376       if ( reverse )
 377       {
 378         /* reverse the points */
 379         {
 380           FT_Vector*  vec1 = border-&gt;points + start + 1;
 381           FT_Vector*  vec2 = border-&gt;points + count - 1;
 382 
 383 
 384           for ( ; vec1 &lt; vec2; vec1++, vec2-- )
 385           {
 386             FT_Vector  tmp;
 387 
 388 
 389             tmp   = *vec1;
 390             *vec1 = *vec2;
 391             *vec2 = tmp;
 392           }
 393         }
 394 
</pre>
<hr />
<pre>
 419   }
 420 
 421 
 422   static FT_Error
 423   ft_stroke_border_lineto( FT_StrokeBorder  border,
 424                            FT_Vector*       to,
 425                            FT_Bool          movable )
 426   {
 427     FT_Error  error = FT_Err_Ok;
 428 
 429 
 430     FT_ASSERT( border-&gt;start &gt;= 0 );
 431 
 432     if ( border-&gt;movable )
 433     {
 434       /* move last point */
 435       border-&gt;points[border-&gt;num_points - 1] = *to;
 436     }
 437     else
 438     {
<span class="line-modified"> 439       /* don&#39;t add zero-length lineto */</span>
<span class="line-modified"> 440       if ( border-&gt;num_points &gt; 0                                          &amp;&amp;</span>
 441            FT_IS_SMALL( border-&gt;points[border-&gt;num_points - 1].x - to-&gt;x ) &amp;&amp;
 442            FT_IS_SMALL( border-&gt;points[border-&gt;num_points - 1].y - to-&gt;y ) )
 443         return error;
 444 
 445       /* add one point */
 446       error = ft_stroke_border_grow( border, 1 );
 447       if ( !error )
 448       {
 449         FT_Vector*  vec = border-&gt;points + border-&gt;num_points;
 450         FT_Byte*    tag = border-&gt;tags   + border-&gt;num_points;
 451 
 452 
 453         vec[0] = *to;
 454         tag[0] = FT_STROKE_TAG_ON;
 455 
 456         border-&gt;num_points += 1;
 457       }
 458     }
 459     border-&gt;movable = movable;
 460     return error;
</pre>
<hr />
<pre>
2070       if ( sborder-&gt;valid )
2071         ft_stroke_border_export( sborder, outline );
2072     }
2073   }
2074 
2075 
2076   /* documentation is in ftstroke.h */
2077 
2078   FT_EXPORT_DEF( void )
2079   FT_Stroker_Export( FT_Stroker   stroker,
2080                      FT_Outline*  outline )
2081   {
2082     FT_Stroker_ExportBorder( stroker, FT_STROKER_BORDER_LEFT, outline );
2083     FT_Stroker_ExportBorder( stroker, FT_STROKER_BORDER_RIGHT, outline );
2084   }
2085 
2086 
2087   /* documentation is in ftstroke.h */
2088 
2089   /*
<span class="line-modified">2090    *  The following is very similar to FT_Outline_Decompose, except</span>
<span class="line-modified">2091    *  that we do support opened paths, and do not scale the outline.</span>
2092    */
2093   FT_EXPORT_DEF( FT_Error )
2094   FT_Stroker_ParseOutline( FT_Stroker   stroker,
2095                            FT_Outline*  outline,
2096                            FT_Bool      opened )
2097   {
2098     FT_Vector   v_last;
2099     FT_Vector   v_control;
2100     FT_Vector   v_start;
2101 
2102     FT_Vector*  point;
2103     FT_Vector*  limit;
2104     char*       tags;
2105 
2106     FT_Error    error;
2107 
2108     FT_Int      n;         /* index of contour in outline     */
2109     FT_UInt     first;     /* index of first point in contour */
2110     FT_Int      tag;       /* current point&#39;s state           */
2111 
</pre>
<hr />
<pre>
2289     return FT_Err_Ok;
2290 
2291   Exit:
2292     return error;
2293 
2294   Invalid_Outline:
2295     return FT_THROW( Invalid_Outline );
2296   }
2297 
2298 
2299   /* documentation is in ftstroke.h */
2300 
2301   FT_EXPORT_DEF( FT_Error )
2302   FT_Glyph_Stroke( FT_Glyph    *pglyph,
2303                    FT_Stroker   stroker,
2304                    FT_Bool      destroy )
2305   {
2306     FT_Error  error = FT_ERR( Invalid_Argument );
2307     FT_Glyph  glyph = NULL;
2308 
<span class="line-removed">2309     /* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */</span>
<span class="line-removed">2310     FT_Library  library = stroker-&gt;library;</span>
<span class="line-removed">2311 </span>
<span class="line-removed">2312     FT_UNUSED( library );</span>
<span class="line-removed">2313 </span>
2314 
2315     if ( !pglyph )
2316       goto Exit;
2317 
2318     glyph = *pglyph;
<span class="line-modified">2319     if ( !glyph || glyph-&gt;clazz != FT_OUTLINE_GLYPH_CLASS_GET )</span>
2320       goto Exit;
2321 
2322     {
2323       FT_Glyph  copy;
2324 
2325 
2326       error = FT_Glyph_Copy( glyph, &amp;copy );
2327       if ( error )
2328         goto Exit;
2329 
2330       glyph = copy;
2331     }
2332 
2333     {
2334       FT_OutlineGlyph  oglyph  = (FT_OutlineGlyph)glyph;
2335       FT_Outline*      outline = &amp;oglyph-&gt;outline;
2336       FT_UInt          num_points, num_contours;
2337 
2338 
2339       error = FT_Stroker_ParseOutline( stroker, outline, FALSE );
</pre>
<hr />
<pre>
2369 
2370     if ( !destroy )
2371       *pglyph = NULL;
2372 
2373   Exit:
2374     return error;
2375   }
2376 
2377 
2378   /* documentation is in ftstroke.h */
2379 
2380   FT_EXPORT_DEF( FT_Error )
2381   FT_Glyph_StrokeBorder( FT_Glyph    *pglyph,
2382                          FT_Stroker   stroker,
2383                          FT_Bool      inside,
2384                          FT_Bool      destroy )
2385   {
2386     FT_Error  error = FT_ERR( Invalid_Argument );
2387     FT_Glyph  glyph = NULL;
2388 
<span class="line-removed">2389     /* for FT_OUTLINE_GLYPH_CLASS_GET (in PIC mode) */</span>
<span class="line-removed">2390     FT_Library  library = stroker-&gt;library;</span>
<span class="line-removed">2391 </span>
<span class="line-removed">2392     FT_UNUSED( library );</span>
<span class="line-removed">2393 </span>
2394 
2395     if ( !pglyph )
2396       goto Exit;
2397 
2398     glyph = *pglyph;
<span class="line-modified">2399     if ( !glyph || glyph-&gt;clazz != FT_OUTLINE_GLYPH_CLASS_GET )</span>
2400       goto Exit;
2401 
2402     {
2403       FT_Glyph  copy;
2404 
2405 
2406       error = FT_Glyph_Copy( glyph, &amp;copy );
2407       if ( error )
2408         goto Exit;
2409 
2410       glyph = copy;
2411     }
2412 
2413     {
2414       FT_OutlineGlyph   oglyph  = (FT_OutlineGlyph)glyph;
2415       FT_StrokerBorder  border;
2416       FT_Outline*       outline = &amp;oglyph-&gt;outline;
2417       FT_UInt           num_points, num_contours;
2418 
2419 
</pre>
</td>
<td>
<hr />
<pre>
<span class="line-modified">   1 /****************************************************************************</span>
<span class="line-modified">   2  *</span>
<span class="line-modified">   3  * ftstroke.c</span>
<span class="line-modified">   4  *</span>
<span class="line-modified">   5  *   FreeType path stroker (body).</span>
<span class="line-modified">   6  *</span>
<span class="line-modified">   7  * Copyright (C) 2002-2019 by</span>
<span class="line-modified">   8  * David Turner, Robert Wilhelm, and Werner Lemberg.</span>
<span class="line-modified">   9  *</span>
<span class="line-modified">  10  * This file is part of the FreeType project, and may only be used,</span>
<span class="line-modified">  11  * modified, and distributed under the terms of the FreeType project</span>
<span class="line-modified">  12  * license, LICENSE.TXT.  By continuing to use, modify, or distribute</span>
<span class="line-modified">  13  * this file you indicate that you have read the license and</span>
<span class="line-modified">  14  * understand and accept it fully.</span>
<span class="line-modified">  15  *</span>
<span class="line-modified">  16  */</span>
  17 
  18 
  19 #include &lt;ft2build.h&gt;
  20 #include FT_STROKER_H
  21 #include FT_TRIGONOMETRY_H
  22 #include FT_OUTLINE_H
  23 #include FT_INTERNAL_MEMORY_H
  24 #include FT_INTERNAL_DEBUG_H
  25 #include FT_INTERNAL_OBJECTS_H
  26 

  27 
<span class="line-modified">  28   /* declare an extern to access `ft_outline_glyph_class&#39; globally */</span>
<span class="line-modified">  29   /* allocated  in `ftglyph.c&#39;                                     */</span>



  30   FT_CALLBACK_TABLE const FT_Glyph_Class  ft_outline_glyph_class;

  31 
  32 
  33   /* documentation is in ftstroke.h */
  34 
  35   FT_EXPORT_DEF( FT_StrokerBorder )
  36   FT_Outline_GetInsideBorder( FT_Outline*  outline )
  37   {
  38     FT_Orientation  o = FT_Outline_Get_Orientation( outline );
  39 
  40 
  41     return o == FT_ORIENTATION_TRUETYPE ? FT_STROKER_BORDER_RIGHT
  42                                         : FT_STROKER_BORDER_LEFT;
  43   }
  44 
  45 
  46   /* documentation is in ftstroke.h */
  47 
  48   FT_EXPORT_DEF( FT_StrokerBorder )
  49   FT_Outline_GetOutsideBorder( FT_Outline*  outline )
  50   {
</pre>
<hr />
<pre>
  69 
  70 #define FT_EPSILON  2
  71 
  72 #define FT_IS_SMALL( x )  ( (x) &gt; -FT_EPSILON &amp;&amp; (x) &lt; FT_EPSILON )
  73 
  74 
  75   static FT_Pos
  76   ft_pos_abs( FT_Pos  x )
  77   {
  78     return x &gt;= 0 ? x : -x;
  79   }
  80 
  81 
  82   static void
  83   ft_conic_split( FT_Vector*  base )
  84   {
  85     FT_Pos  a, b;
  86 
  87 
  88     base[4].x = base[2].x;
<span class="line-modified">  89     a = base[0].x + base[1].x;</span>
<span class="line-modified">  90     b = base[1].x + base[2].x;</span>
<span class="line-modified">  91     base[3].x = b &gt;&gt; 1;</span>
<span class="line-modified">  92     base[2].x = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added">  93     base[1].x = a &gt;&gt; 1;</span>
  94 
  95     base[4].y = base[2].y;
<span class="line-modified">  96     a = base[0].y + base[1].y;</span>
<span class="line-modified">  97     b = base[1].y + base[2].y;</span>
<span class="line-modified">  98     base[3].y = b &gt;&gt; 1;</span>
<span class="line-modified">  99     base[2].y = ( a + b ) &gt;&gt; 2;</span>
<span class="line-added"> 100     base[1].y = a &gt;&gt; 1;</span>
 101   }
 102 
 103 
 104   static FT_Bool
 105   ft_conic_is_small_enough( FT_Vector*  base,
 106                             FT_Angle   *angle_in,
 107                             FT_Angle   *angle_out )
 108   {
 109     FT_Vector  d1, d2;
 110     FT_Angle   theta;
 111     FT_Int     close1, close2;
 112 
 113 
 114     d1.x = base[1].x - base[2].x;
 115     d1.y = base[1].y - base[2].y;
 116     d2.x = base[0].x - base[1].x;
 117     d2.y = base[0].y - base[1].y;
 118 
 119     close1 = FT_IS_SMALL( d1.x ) &amp;&amp; FT_IS_SMALL( d1.y );
 120     close2 = FT_IS_SMALL( d2.x ) &amp;&amp; FT_IS_SMALL( d2.y );
</pre>
<hr />
<pre>
 138       {
 139         *angle_in  =
 140         *angle_out = FT_Atan2( d1.x, d1.y );
 141       }
 142       else
 143       {
 144         *angle_in  = FT_Atan2( d1.x, d1.y );
 145         *angle_out = FT_Atan2( d2.x, d2.y );
 146       }
 147     }
 148 
 149     theta = ft_pos_abs( FT_Angle_Diff( *angle_in, *angle_out ) );
 150 
 151     return FT_BOOL( theta &lt; FT_SMALL_CONIC_THRESHOLD );
 152   }
 153 
 154 
 155   static void
 156   ft_cubic_split( FT_Vector*  base )
 157   {
<span class="line-modified"> 158     FT_Pos  a, b, c;</span>
 159 
 160 
 161     base[6].x = base[3].x;
<span class="line-modified"> 162     a = base[0].x + base[1].x;</span>
<span class="line-modified"> 163     b = base[1].x + base[2].x;</span>
<span class="line-modified"> 164     c = base[2].x + base[3].x;</span>
<span class="line-modified"> 165     base[5].x = c &gt;&gt; 1;</span>
<span class="line-modified"> 166     c += b;</span>
<span class="line-modified"> 167     base[4].x = c &gt;&gt; 2;</span>
<span class="line-modified"> 168     base[1].x = a &gt;&gt; 1;</span>
<span class="line-modified"> 169     a += b;</span>
<span class="line-added"> 170     base[2].x = a &gt;&gt; 2;</span>
<span class="line-added"> 171     base[3].x = ( a + c ) &gt;&gt; 3;</span>
 172 
 173     base[6].y = base[3].y;
<span class="line-modified"> 174     a = base[0].y + base[1].y;</span>
<span class="line-modified"> 175     b = base[1].y + base[2].y;</span>
<span class="line-modified"> 176     c = base[2].y + base[3].y;</span>
<span class="line-modified"> 177     base[5].y = c &gt;&gt; 1;</span>
<span class="line-modified"> 178     c += b;</span>
<span class="line-modified"> 179     base[4].y = c &gt;&gt; 2;</span>
<span class="line-modified"> 180     base[1].y = a &gt;&gt; 1;</span>
<span class="line-modified"> 181     a += b;</span>
<span class="line-added"> 182     base[2].y = a &gt;&gt; 2;</span>
<span class="line-added"> 183     base[3].y = ( a + c ) &gt;&gt; 3;</span>
 184   }
 185 
 186 
 187   /* Return the average of `angle1&#39; and `angle2&#39;.            */
 188   /* This gives correct result even if `angle1&#39; and `angle2&#39; */
 189   /* have opposite signs.                                    */
 190   static FT_Angle
 191   ft_angle_mean( FT_Angle  angle1,
 192                  FT_Angle  angle2 )
 193   {
 194     return angle1 + FT_Angle_Diff( angle1, angle2 ) / 2;
 195   }
 196 
 197 
 198   static FT_Bool
 199   ft_cubic_is_small_enough( FT_Vector*  base,
 200                             FT_Angle   *angle_in,
 201                             FT_Angle   *angle_mid,
 202                             FT_Angle   *angle_out )
 203   {
</pre>
<hr />
<pre>
 356 
 357   static void
 358   ft_stroke_border_close( FT_StrokeBorder  border,
 359                           FT_Bool          reverse )
 360   {
 361     FT_UInt  start = (FT_UInt)border-&gt;start;
 362     FT_UInt  count = border-&gt;num_points;
 363 
 364 
 365     FT_ASSERT( border-&gt;start &gt;= 0 );
 366 
 367     /* don&#39;t record empty paths! */
 368     if ( count &lt;= start + 1U )
 369       border-&gt;num_points = start;
 370     else
 371     {
 372       /* copy the last point to the start of this sub-path, since */
 373       /* it contains the `adjusted&#39; starting coordinates          */
 374       border-&gt;num_points    = --count;
 375       border-&gt;points[start] = border-&gt;points[count];
<span class="line-added"> 376       border-&gt;tags[start]   = border-&gt;tags[count];</span>
 377 
 378       if ( reverse )
 379       {
 380         /* reverse the points */
 381         {
 382           FT_Vector*  vec1 = border-&gt;points + start + 1;
 383           FT_Vector*  vec2 = border-&gt;points + count - 1;
 384 
 385 
 386           for ( ; vec1 &lt; vec2; vec1++, vec2-- )
 387           {
 388             FT_Vector  tmp;
 389 
 390 
 391             tmp   = *vec1;
 392             *vec1 = *vec2;
 393             *vec2 = tmp;
 394           }
 395         }
 396 
</pre>
<hr />
<pre>
 421   }
 422 
 423 
 424   static FT_Error
 425   ft_stroke_border_lineto( FT_StrokeBorder  border,
 426                            FT_Vector*       to,
 427                            FT_Bool          movable )
 428   {
 429     FT_Error  error = FT_Err_Ok;
 430 
 431 
 432     FT_ASSERT( border-&gt;start &gt;= 0 );
 433 
 434     if ( border-&gt;movable )
 435     {
 436       /* move last point */
 437       border-&gt;points[border-&gt;num_points - 1] = *to;
 438     }
 439     else
 440     {
<span class="line-modified"> 441       /* don&#39;t add zero-length lineto, but always add moveto */</span>
<span class="line-modified"> 442       if ( border-&gt;num_points &gt; (FT_UInt)border-&gt;start                     &amp;&amp;</span>
 443            FT_IS_SMALL( border-&gt;points[border-&gt;num_points - 1].x - to-&gt;x ) &amp;&amp;
 444            FT_IS_SMALL( border-&gt;points[border-&gt;num_points - 1].y - to-&gt;y ) )
 445         return error;
 446 
 447       /* add one point */
 448       error = ft_stroke_border_grow( border, 1 );
 449       if ( !error )
 450       {
 451         FT_Vector*  vec = border-&gt;points + border-&gt;num_points;
 452         FT_Byte*    tag = border-&gt;tags   + border-&gt;num_points;
 453 
 454 
 455         vec[0] = *to;
 456         tag[0] = FT_STROKE_TAG_ON;
 457 
 458         border-&gt;num_points += 1;
 459       }
 460     }
 461     border-&gt;movable = movable;
 462     return error;
</pre>
<hr />
<pre>
2072       if ( sborder-&gt;valid )
2073         ft_stroke_border_export( sborder, outline );
2074     }
2075   }
2076 
2077 
2078   /* documentation is in ftstroke.h */
2079 
2080   FT_EXPORT_DEF( void )
2081   FT_Stroker_Export( FT_Stroker   stroker,
2082                      FT_Outline*  outline )
2083   {
2084     FT_Stroker_ExportBorder( stroker, FT_STROKER_BORDER_LEFT, outline );
2085     FT_Stroker_ExportBorder( stroker, FT_STROKER_BORDER_RIGHT, outline );
2086   }
2087 
2088 
2089   /* documentation is in ftstroke.h */
2090 
2091   /*
<span class="line-modified">2092    * The following is very similar to FT_Outline_Decompose, except</span>
<span class="line-modified">2093    * that we do support opened paths, and do not scale the outline.</span>
2094    */
2095   FT_EXPORT_DEF( FT_Error )
2096   FT_Stroker_ParseOutline( FT_Stroker   stroker,
2097                            FT_Outline*  outline,
2098                            FT_Bool      opened )
2099   {
2100     FT_Vector   v_last;
2101     FT_Vector   v_control;
2102     FT_Vector   v_start;
2103 
2104     FT_Vector*  point;
2105     FT_Vector*  limit;
2106     char*       tags;
2107 
2108     FT_Error    error;
2109 
2110     FT_Int      n;         /* index of contour in outline     */
2111     FT_UInt     first;     /* index of first point in contour */
2112     FT_Int      tag;       /* current point&#39;s state           */
2113 
</pre>
<hr />
<pre>
2291     return FT_Err_Ok;
2292 
2293   Exit:
2294     return error;
2295 
2296   Invalid_Outline:
2297     return FT_THROW( Invalid_Outline );
2298   }
2299 
2300 
2301   /* documentation is in ftstroke.h */
2302 
2303   FT_EXPORT_DEF( FT_Error )
2304   FT_Glyph_Stroke( FT_Glyph    *pglyph,
2305                    FT_Stroker   stroker,
2306                    FT_Bool      destroy )
2307   {
2308     FT_Error  error = FT_ERR( Invalid_Argument );
2309     FT_Glyph  glyph = NULL;
2310 





2311 
2312     if ( !pglyph )
2313       goto Exit;
2314 
2315     glyph = *pglyph;
<span class="line-modified">2316     if ( !glyph || glyph-&gt;clazz != &amp;ft_outline_glyph_class )</span>
2317       goto Exit;
2318 
2319     {
2320       FT_Glyph  copy;
2321 
2322 
2323       error = FT_Glyph_Copy( glyph, &amp;copy );
2324       if ( error )
2325         goto Exit;
2326 
2327       glyph = copy;
2328     }
2329 
2330     {
2331       FT_OutlineGlyph  oglyph  = (FT_OutlineGlyph)glyph;
2332       FT_Outline*      outline = &amp;oglyph-&gt;outline;
2333       FT_UInt          num_points, num_contours;
2334 
2335 
2336       error = FT_Stroker_ParseOutline( stroker, outline, FALSE );
</pre>
<hr />
<pre>
2366 
2367     if ( !destroy )
2368       *pglyph = NULL;
2369 
2370   Exit:
2371     return error;
2372   }
2373 
2374 
2375   /* documentation is in ftstroke.h */
2376 
2377   FT_EXPORT_DEF( FT_Error )
2378   FT_Glyph_StrokeBorder( FT_Glyph    *pglyph,
2379                          FT_Stroker   stroker,
2380                          FT_Bool      inside,
2381                          FT_Bool      destroy )
2382   {
2383     FT_Error  error = FT_ERR( Invalid_Argument );
2384     FT_Glyph  glyph = NULL;
2385 





2386 
2387     if ( !pglyph )
2388       goto Exit;
2389 
2390     glyph = *pglyph;
<span class="line-modified">2391     if ( !glyph || glyph-&gt;clazz != &amp;ft_outline_glyph_class )</span>
2392       goto Exit;
2393 
2394     {
2395       FT_Glyph  copy;
2396 
2397 
2398       error = FT_Glyph_Copy( glyph, &amp;copy );
2399       if ( error )
2400         goto Exit;
2401 
2402       glyph = copy;
2403     }
2404 
2405     {
2406       FT_OutlineGlyph   oglyph  = (FT_OutlineGlyph)glyph;
2407       FT_StrokerBorder  border;
2408       FT_Outline*       outline = &amp;oglyph-&gt;outline;
2409       FT_UInt           num_points, num_contours;
2410 
2411 
</pre>
</td>
</tr>
</table>
<center><a href="ftstream.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="ftsynth.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
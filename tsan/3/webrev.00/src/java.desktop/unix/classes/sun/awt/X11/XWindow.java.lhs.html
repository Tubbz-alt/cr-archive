<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/classes/sun/awt/X11/XWindow.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.awt.X11;
  27 
  28 import java.awt.*;
  29 import java.awt.event.*;
  30 import java.awt.peer.ComponentPeer;
  31 import java.awt.image.ColorModel;
  32 
  33 import java.lang.ref.WeakReference;
  34 
  35 import sun.awt.AWTAccessor.ComponentAccessor;
  36 import sun.util.logging.PlatformLogger;
  37 
  38 import sun.awt.*;
  39 
  40 import sun.awt.image.PixelConverter;
  41 
  42 import sun.java2d.SunGraphics2D;
  43 import sun.java2d.SurfaceData;
  44 
  45 class XWindow extends XBaseWindow implements X11ComponentPeer {
  46     private static PlatformLogger log = PlatformLogger.getLogger(&quot;sun.awt.X11.XWindow&quot;);
  47     private static PlatformLogger insLog = PlatformLogger.getLogger(&quot;sun.awt.X11.insets.XWindow&quot;);
  48     private static PlatformLogger eventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.event.XWindow&quot;);
  49     private static final PlatformLogger focusLog = PlatformLogger.getLogger(&quot;sun.awt.X11.focus.XWindow&quot;);
  50     private static PlatformLogger keyEventLog = PlatformLogger.getLogger(&quot;sun.awt.X11.kye.XWindow&quot;);
  51   /* If a motion comes in while a multi-click is pending,
  52    * allow a smudge factor so that moving the mouse by a small
  53    * amount does not wipe out the multi-click state variables.
  54    */
  55     private static final int AWT_MULTICLICK_SMUDGE = 4;
  56     // ButtonXXX events stuff
  57     static int lastX = 0, lastY = 0;
  58     static long lastTime = 0;
  59     static long lastButton = 0;
  60     static WeakReference&lt;XWindow&gt; lastWindowRef = null;
  61     static int clickCount = 0;
  62 
  63     // used to check if we need to re-create surfaceData.
  64     int oldWidth = -1;
  65     int oldHeight = -1;
  66 
  67     protected PropMwmHints mwm_hints;
  68     protected static XAtom wm_protocols;
  69     protected static XAtom wm_delete_window;
  70     protected static XAtom wm_take_focus;
  71 
  72     private boolean stateChanged; // Indicates whether the value on savedState is valid
  73     private int savedState; // Holds last known state of the top-level window
  74 
  75     XWindowAttributesData winAttr;
  76 
  77     protected X11GraphicsConfig graphicsConfig;
  78     protected AwtGraphicsConfigData graphicsConfigData;
  79 
  80     private boolean reparented;
  81 
  82     XWindow parent;
  83 
  84     Component target;
  85 
  86     private static int JAWT_LOCK_ERROR=0x00000001;
  87     private static int JAWT_LOCK_CLIP_CHANGED=0x00000002;
  88     private static int JAWT_LOCK_BOUNDS_CHANGED=0x00000004;
  89     private static int JAWT_LOCK_SURFACE_CHANGED=0x00000008;
  90     private int drawState = JAWT_LOCK_CLIP_CHANGED |
  91     JAWT_LOCK_BOUNDS_CHANGED |
  92     JAWT_LOCK_SURFACE_CHANGED;
  93 
  94     public static final String TARGET = &quot;target&quot;,
  95         REPARENTED = &quot;reparented&quot;; // whether it is reparented by default
  96 
  97     SurfaceData surfaceData;
  98 
  99     XRepaintArea paintArea;
 100 
 101     // fallback default font object
 102     private static Font defaultFont;
 103 
 104     static synchronized Font getDefaultFont() {
 105         if (null == defaultFont) {
 106             defaultFont = new Font(Font.DIALOG, Font.PLAIN, 12);
 107         }
 108         return defaultFont;
 109     }
 110 
 111     /* A bitmask keeps the button&#39;s numbers as Button1Mask, Button2Mask, Button3Mask
 112      * which are allowed to
 113      * generate the CLICK event after the RELEASE has happened.
 114      * There are conditions that must be true for that sending CLICK event:
 115      * 1) button was initially PRESSED
 116      * 2) no movement or drag has happened until RELEASE
 117     */
 118     private int mouseButtonClickAllowed = 0;
 119 
 120     native int getNativeColor(Color clr, GraphicsConfiguration gc);
 121     native void getWMInsets(long window, long left, long top, long right, long bottom, long border);
 122     native long getTopWindow(long window, long rootWin);
 123     native void getWindowBounds(long window, long x, long y, long width, long height);
 124     private static native void initIDs();
 125 
 126     static {
 127         initIDs();
 128     }
 129 
 130     XWindow(XCreateWindowParams params) {
 131         super(params);
 132     }
 133 
 134     XWindow() {
 135     }
 136 
 137     XWindow(long parentWindow, Rectangle bounds) {
 138         super(new XCreateWindowParams(new Object[] {
 139             BOUNDS, bounds,
 140             PARENT_WINDOW, Long.valueOf(parentWindow)}));
 141     }
 142 
 143     XWindow(Component target, long parentWindow, Rectangle bounds) {
 144         super(new XCreateWindowParams(new Object[] {
 145             BOUNDS, bounds,
 146             PARENT_WINDOW, Long.valueOf(parentWindow),
 147             TARGET, target}));
 148     }
 149 
 150     XWindow(Component target, long parentWindow) {
 151         this(target, parentWindow, new Rectangle(target.getBounds()));
 152     }
 153 
 154     XWindow(Component target) {
 155         this(target, (target.getParent() == null) ? 0 : getParentWindowID(target), new Rectangle(target.getBounds()));
 156     }
 157 
 158     XWindow(Object target) {
 159         this(null, 0, null);
 160     }
 161 
 162     /* This create is used by the XEmbeddedFramePeer since it has to create the window
 163        as a child of the netscape window. This netscape window is passed in as wid */
 164     XWindow(long parentWindow) {
 165         super(new XCreateWindowParams(new Object[] {
 166             PARENT_WINDOW, Long.valueOf(parentWindow),
 167             REPARENTED, Boolean.TRUE,
 168             EMBEDDED, Boolean.TRUE}));
 169     }
 170 
 171     protected void initGraphicsConfiguration() {
 172         graphicsConfig = (X11GraphicsConfig) target.getGraphicsConfiguration();
 173         graphicsConfigData = new AwtGraphicsConfigData(graphicsConfig.getAData());
 174     }
 175 
 176     void preInit(XCreateWindowParams params) {
 177         super.preInit(params);
 178         reparented = Boolean.TRUE.equals(params.get(REPARENTED));
 179 
 180         target = (Component)params.get(TARGET);
 181 
 182         initGraphicsConfiguration();
 183 
 184         AwtGraphicsConfigData gData = getGraphicsConfigurationData();
 185         X11GraphicsConfig config = (X11GraphicsConfig) getGraphicsConfiguration();
 186         XVisualInfo visInfo = gData.get_awt_visInfo();
 187         params.putIfNull(EVENT_MASK, XConstants.KeyPressMask | XConstants.KeyReleaseMask
 188             | XConstants.FocusChangeMask | XConstants.ButtonPressMask | XConstants.ButtonReleaseMask
 189             | XConstants.EnterWindowMask | XConstants.LeaveWindowMask | XConstants.PointerMotionMask
 190             | XConstants.ButtonMotionMask | XConstants.ExposureMask | XConstants.StructureNotifyMask);
 191 
 192         if (target != null) {
 193             params.putIfNull(BOUNDS, new Rectangle(target.getBounds()));
 194         } else {
 195             params.putIfNull(BOUNDS, new Rectangle(0, 0, MIN_SIZE, MIN_SIZE));
 196         }
 197         params.putIfNull(BORDER_PIXEL, Long.valueOf(0));
 198         getColorModel(); // fix 4948833: this call forces the color map to be initialized
 199         params.putIfNull(COLORMAP, gData.get_awt_cmap());
 200         params.putIfNull(DEPTH, gData.get_awt_depth());
 201         params.putIfNull(VISUAL_CLASS, Integer.valueOf(XConstants.InputOutput));
 202         params.putIfNull(VISUAL, visInfo.get_visual());
 203         params.putIfNull(VALUE_MASK, XConstants.CWBorderPixel | XConstants.CWEventMask | XConstants.CWColormap);
 204         Long parentWindow = (Long)params.get(PARENT_WINDOW);
 205         if (parentWindow == null || parentWindow.longValue() == 0) {
 206             XToolkit.awtLock();
 207             try {
 208                 int screen = visInfo.get_screen();
 209                 if (screen != -1) {
 210                     params.add(PARENT_WINDOW, XlibWrapper.RootWindow(XToolkit.getDisplay(), screen));
 211                 } else {
 212                     params.add(PARENT_WINDOW, XToolkit.getDefaultRootWindow());
 213                 }
 214             } finally {
 215                 XToolkit.awtUnlock();
 216             }
 217         }
 218 
 219         paintArea = new XRepaintArea();
 220         if (target != null) {
 221             this.parent = getParentXWindowObject(target.getParent());
 222         }
 223 
 224         params.putIfNull(BACKING_STORE, XToolkit.getBackingStoreType());
 225 
 226         XToolkit.awtLock();
 227         try {
 228             if (wm_protocols == null) {
 229                 wm_protocols = XAtom.get(&quot;WM_PROTOCOLS&quot;);
 230                 wm_delete_window = XAtom.get(&quot;WM_DELETE_WINDOW&quot;);
 231                 wm_take_focus = XAtom.get(&quot;WM_TAKE_FOCUS&quot;);
 232             }
 233         }
 234         finally {
 235             XToolkit.awtUnlock();
 236         }
 237         winAttr = new XWindowAttributesData();
 238         savedState = XUtilConstants.WithdrawnState;
 239     }
 240 
 241     void postInit(XCreateWindowParams params) {
 242         super.postInit(params);
 243 
 244         setWMClass(getWMClass());
 245 
 246         surfaceData = graphicsConfig.createSurfaceData(this);
 247         Color c;
 248         if (target != null &amp;&amp; (c = target.getBackground()) != null) {
 249             // We need a version of setBackground that does not call repaint !!
 250             // and one that does not get overridden. The problem is that in postInit
 251             // we call setBackground and we don&#39;t have all the stuff initialized to
 252             // do a full paint for most peers. So we cannot call setBackground in postInit.
 253             // instead we need to call xSetBackground.
 254             xSetBackground(c);
 255         }
 256     }
 257 
 258     public GraphicsConfiguration getGraphicsConfiguration() {
 259         if (graphicsConfig == null) {
 260             initGraphicsConfiguration();
 261         }
 262         return graphicsConfig;
 263     }
 264 
 265     public AwtGraphicsConfigData getGraphicsConfigurationData() {
 266         if (graphicsConfigData == null) {
 267             initGraphicsConfiguration();
 268         }
 269         return graphicsConfigData;
 270     }
 271 
 272     protected String[] getWMClass() {
 273         return new String[] {XToolkit.getAWTAppClassName(),
 274                 XToolkit.getAWTAppClassName()};
 275     }
 276 
 277     void setReparented(boolean newValue) {
 278         reparented = newValue;
 279     }
 280 
 281     boolean isReparented() {
 282         return reparented;
 283     }
 284 
 285     static long getParentWindowID(Component target) {
 286 
 287         Component temp = target.getParent();
 288         final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 289         ComponentPeer peer = acc.getPeer(temp);
 290         while (!(peer instanceof XWindow))
 291         {
 292             temp = temp.getParent();
 293             peer = acc.getPeer(temp);
 294         }
 295 
 296         if (peer != null &amp;&amp; peer instanceof XWindow)
 297             return ((XWindow)peer).getContentWindow();
 298         else return 0;
 299     }
 300 
 301 
 302     static XWindow getParentXWindowObject(Component target) {
 303         if (target == null) return null;
 304         Component temp = target.getParent();
 305         if (temp == null) return null;
 306         final ComponentAccessor acc = AWTAccessor.getComponentAccessor();
 307         ComponentPeer peer = acc.getPeer(temp);
 308         if (peer == null) return null;
 309         while ((peer != null) &amp;&amp; !(peer instanceof XWindow))
 310         {
 311             temp = temp.getParent();
 312             peer = acc.getPeer(temp);
 313         }
 314         if (peer != null &amp;&amp; peer instanceof XWindow)
 315             return (XWindow) peer;
 316         else return null;
 317     }
 318 
 319 
 320     boolean isParentOf(XWindow win) {
 321         if (!(target instanceof Container) || win == null || win.getTarget() == null) {
 322             return false;
 323         }
 324         Container parent = AWTAccessor.getComponentAccessor().getParent(win.target);
 325         while (parent != null &amp;&amp; parent != target) {
 326             parent = AWTAccessor.getComponentAccessor().getParent(parent);
 327         }
 328         return (parent == target);
 329     }
 330 
 331     public Object getTarget() {
 332         return target;
 333     }
 334     public Component getEventSource() {
 335         return target;
 336     }
 337 
 338     public ColorModel getColorModel(int transparency) {
 339         return graphicsConfig.getColorModel (transparency);
 340     }
 341 
 342     @Override
 343     public ColorModel getColorModel() {
 344         if (graphicsConfig != null) {
 345             return graphicsConfig.getColorModel ();
 346         }
 347         else {
 348             return Toolkit.getDefaultToolkit().getColorModel();
 349         }
 350     }
 351 
 352     Graphics getGraphics(SurfaceData surfData, Color afore, Color aback, Font afont) {
 353         if (surfData == null) return null;
 354 
 355         Component target = this.target;
 356 
 357         /* Fix for bug 4746122. Color and Font shouldn&#39;t be null */
 358         Color bgColor = aback;
 359         if (bgColor == null) {
 360             bgColor = SystemColor.window;
 361         }
 362         Color fgColor = afore;
 363         if (fgColor == null) {
 364             fgColor = SystemColor.windowText;
 365         }
 366         Font font = afont;
 367         if (font == null) {
 368             font = XWindow.getDefaultFont();
 369         }
 370         return new SunGraphics2D(surfData, fgColor, bgColor, font);
 371     }
 372 
 373     public Graphics getGraphics() {
 374         return getGraphics(surfaceData,
 375                            target.getForeground(),
 376                            target.getBackground(),
 377                            target.getFont());
 378     }
 379 
 380     @SuppressWarnings(&quot;deprecation&quot;)
 381     public FontMetrics getFontMetrics(Font font) {
 382         return Toolkit.getDefaultToolkit().getFontMetrics(font);
 383     }
 384 
 385     public Rectangle getTargetBounds() {
 386         return target.getBounds();
 387     }
 388 
 389     /**
 390      * Returns true if the event has been handled and should not be
 391      * posted to Java.
 392      */
 393     boolean prePostEvent(AWTEvent e) {
 394         return false;
 395     }
 396 
 397     static void sendEvent(final AWTEvent e) {
 398         // The uses of this method imply that the incoming event is system-generated
 399         SunToolkit.setSystemGenerated(e);
 400         PeerEvent pe = new PeerEvent(Toolkit.getDefaultToolkit(), new Runnable() {
 401                 public void run() {
 402                     AWTAccessor.getAWTEventAccessor().setPosted(e);
 403                     ((Component)e.getSource()).dispatchEvent(e);
 404                 }
 405             }, PeerEvent.ULTIMATE_PRIORITY_EVENT);
 406         if (focusLog.isLoggable(PlatformLogger.Level.FINER) &amp;&amp; (e instanceof FocusEvent)) {
 407             focusLog.finer(&quot;Sending &quot; + e);
 408         }
 409         XToolkit.postEvent(XToolkit.targetToAppContext(e.getSource()), pe);
 410     }
 411 
 412 
 413 /*
 414  * Post an event to the event queue.
 415  */
 416 // NOTE: This method may be called by privileged threads.
 417 //       DO NOT INVOKE CLIENT CODE ON THIS THREAD!
 418     void postEvent(AWTEvent event) {
 419         XToolkit.postEvent(XToolkit.targetToAppContext(event.getSource()), event);
 420     }
 421 
 422     static void postEventStatic(AWTEvent event) {
 423         XToolkit.postEvent(XToolkit.targetToAppContext(event.getSource()), event);
 424     }
 425 
 426     public void postEventToEventQueue(final AWTEvent event) {
 427         //fix for 6239938 : Choice drop-down does not disappear when it loses focus, on XToolkit
 428         if (!prePostEvent(event)) {
 429             //event hasn&#39;t been handled and must be posted to EventQueue
 430             postEvent(event);
 431         }
 432     }
 433 
 434     // overriden in XCanvasPeer
 435     protected boolean doEraseBackground() {
 436         return true;
 437     }
 438 
 439     // We need a version of setBackground that does not call repaint !!
 440     // and one that does not get overridden. The problem is that in postInit
 441     // we call setBackground and we don&#39;t have all the stuff initialized to
 442     // do a full paint for most peers. So we cannot call setBackground in postInit.
 443     public final void xSetBackground(Color c) {
 444         XToolkit.awtLock();
 445         try {
 446             winBackground(c);
 447             // fix for 6558510: handle sun.awt.noerasebackground flag,
 448             // see doEraseBackground() and preInit() methods in XCanvasPeer
 449             if (!doEraseBackground()) {
 450                 return;
 451             }
<a name="1" id="anc1"></a><span class="line-modified"> 452             // 6304250: XAWT: Items in choice show a blue border on OpenGL + Solaris10 when background color is set</span>
<span class="line-removed"> 453             // Note: When OGL is enabled, surfaceData.pixelFor() will not</span>
<span class="line-removed"> 454             // return a pixel value appropriate for passing to</span>
<span class="line-removed"> 455             // XSetWindowBackground().  Therefore, we will use the ColorModel</span>
<span class="line-removed"> 456             // for this component in order to calculate a pixel value from</span>
<span class="line-removed"> 457             // the given RGB value.</span>
<span class="line-removed"> 458             ColorModel cm = getColorModel();</span>
<span class="line-removed"> 459             int pixel = PixelConverter.instance.rgbToPixel(c.getRGB(), cm);</span>
 460             XlibWrapper.XSetWindowBackground(XToolkit.getDisplay(), getContentWindow(), pixel);
 461             XlibWrapper.XClearWindow(XToolkit.getDisplay(), getContentWindow());
 462         }
 463         finally {
 464             XToolkit.awtUnlock();
 465         }
 466     }
 467 
 468     public void setBackground(Color c) {
 469         xSetBackground(c);
 470     }
 471 
 472     Color backgroundColor;
 473     void winBackground(Color c) {
 474         backgroundColor = c;
 475     }
 476 
 477     public Color getWinBackground() {
 478         Color c = null;
 479 
 480         if (backgroundColor != null) {
 481             c = backgroundColor;
 482         } else if (parent != null) {
 483             c = parent.getWinBackground();
 484         }
 485 
 486         if (c instanceof SystemColor) {
 487             c = new Color(c.getRGB());
 488         }
 489 
 490         return c;
 491     }
 492 
 493     public boolean isEmbedded() {
 494         return embedded;
 495     }
 496 
 497     public final void repaint(int x, int y, int width, int height) {
 498         if (!isVisible() || getWidth() == 0 || getHeight() == 0) {
 499             return;
 500         }
 501         Graphics g = getGraphics();
 502         if (g != null) {
 503             try {
 504                 g.setClip(x, y, width, height);
 505                 if (SunToolkit.isDispatchThreadForAppContext(getTarget())) {
 506                     paint(g); // The native and target will be painted in place.
 507                 } else {
 508                     paintPeer(g);
 509                     postPaintEvent(target, x, y, width, height);
 510                 }
 511             } finally {
 512                 g.dispose();
 513             }
 514         }
 515     }
 516 
 517     void repaint() {
 518         repaint(0, 0, getWidth(), getHeight());
 519     }
 520 
 521     public void paint(final Graphics g) {
 522         // paint peer
 523         paintPeer(g);
 524     }
 525 
 526     void paintPeer(final Graphics g) {
 527     }
 528     //used by Peers to avoid flickering withing paint()
 529     protected void flush(){
 530         XToolkit.awtLock();
 531         try {
 532             XlibWrapper.XFlush(XToolkit.getDisplay());
 533         } finally {
 534             XToolkit.awtUnlock();
 535         }
 536     }
 537 
 538     public void popup(int x, int y, int width, int height) {
 539         // TBD: grab the pointer
 540         xSetBounds(x, y, width, height);
 541     }
 542 
 543     public void handleExposeEvent(XEvent xev) {
 544         super.handleExposeEvent(xev);
 545         XExposeEvent xe = xev.get_xexpose();
 546         if (isEventDisabled(xev)) {
 547             return;
 548         }
 549 
 550         int x = scaleDown(xe.get_x());
 551         int y = scaleDown(xe.get_y());
 552         int w = scaleDown(xe.get_width());
 553         int h = scaleDown(xe.get_height());
 554 
 555         Component target = getEventSource();
 556         ComponentAccessor compAccessor = AWTAccessor.getComponentAccessor();
 557 
 558         if (!compAccessor.getIgnoreRepaint(target)
 559             &amp;&amp; compAccessor.getWidth(target) != 0
 560             &amp;&amp; compAccessor.getHeight(target) != 0)
 561         {
 562             postPaintEvent(target, x, y, w, h);
 563         }
 564     }
 565 
 566     public void postPaintEvent(Component target, int x, int y, int w, int h) {
 567         PaintEvent event = PaintEventDispatcher.getPaintEventDispatcher().
 568             createPaintEvent(target, x, y, w, h);
 569         if (event != null) {
 570             postEventToEventQueue(event);
 571         }
 572     }
 573 
 574     static int getModifiers(int state, int button, int keyCode) {
 575         return getModifiers(state, button, keyCode, false);
 576     }
 577 
 578     static int getWheelModifiers(int state, int button) {
 579         return getModifiers(state, button, 0, true);
 580     }
 581 
 582     private static int getModifiers(int state, int button, int keyCode, boolean isWheelMouse) {
 583         int modifiers = 0;
 584 
 585         if (((state &amp; XConstants.ShiftMask) != 0) ^ (keyCode == KeyEvent.VK_SHIFT)) {
 586             modifiers |= InputEvent.SHIFT_DOWN_MASK;
 587         }
 588         if (((state &amp; XConstants.ControlMask) != 0) ^ (keyCode == KeyEvent.VK_CONTROL)) {
 589             modifiers |= InputEvent.CTRL_DOWN_MASK;
 590         }
 591         if (((state &amp; XToolkit.metaMask) != 0) ^ (keyCode == KeyEvent.VK_META)) {
 592             modifiers |= InputEvent.META_DOWN_MASK;
 593         }
 594         if (((state &amp; XToolkit.altMask) != 0) ^ (keyCode == KeyEvent.VK_ALT)) {
 595             modifiers |= InputEvent.ALT_DOWN_MASK;
 596         }
 597         if (((state &amp; XToolkit.modeSwitchMask) != 0) ^ (keyCode == KeyEvent.VK_ALT_GRAPH)) {
 598             modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;
 599         }
 600         //InputEvent.BUTTON_DOWN_MASK array is starting from BUTTON1_DOWN_MASK on index == 0.
 601         // button currently reflects a real button number and starts from 1. (except NOBUTTON which is zero )
 602 
 603         /* this is an attempt to refactor button IDs in : MouseEvent, InputEvent, XlibWrapper and XWindow.*/
 604 
 605         //reflects a button number similar to MouseEvent.BUTTON1, 2, 3 etc.
 606         for (int i = 0; i &lt; XConstants.buttons.length; i ++){
 607             //modifier should be added if :
 608             // 1) current button is now still in PRESSED state (means that user just pressed mouse but not released yet) or
 609             // 2) if Xsystem reports that &quot;state&quot; represents that button was just released. This only happens on RELEASE with 1,2,3 buttons.
 610             // ONLY one of these conditions should be TRUE to add that modifier.
 611             if (((state &amp; XlibUtil.getButtonMask(i + 1)) != 0) != (button == XConstants.buttons[i])){
 612                 //exclude wheel buttons from adding their numbers as modifiers
 613                 if (!isWheelMouse || !isWheel(XConstants.buttons[i])) {
 614                     modifiers |= InputEvent.getMaskForButton(i+1);
 615                 }
 616             }
 617         }
 618         return modifiers;
 619     }
 620 
 621     static boolean isWheel(int button) {
 622         // 4 and 5 buttons are usually considered assigned to a first wheel
 623         return button == XConstants.buttons[3] || button == XConstants.buttons[4];
 624     }
 625     @SuppressWarnings(&quot;deprecation&quot;)
 626     static int getXModifiers(AWTKeyStroke stroke) {
 627         int mods = stroke.getModifiers();
 628         int res = 0;
 629         if ((mods &amp; (InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK)) != 0) {
 630             res |= XConstants.ShiftMask;
 631         }
 632         if ((mods &amp; (InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK)) != 0) {
 633             res |= XConstants.ControlMask;
 634         }
 635         if ((mods &amp; (InputEvent.ALT_DOWN_MASK | InputEvent.ALT_MASK)) != 0) {
 636             res |= XToolkit.altMask;
 637         }
 638         if ((mods &amp; (InputEvent.META_DOWN_MASK | InputEvent.META_MASK)) != 0) {
 639             res |= XToolkit.metaMask;
 640         }
 641         if ((mods &amp; (InputEvent.ALT_GRAPH_DOWN_MASK | InputEvent.ALT_GRAPH_MASK)) != 0) {
 642             res |= XToolkit.modeSwitchMask;
 643         }
 644         return res;
 645     }
 646 
 647     static int getMouseMovementSmudge() {
 648         //TODO: It&#39;s possible to read corresponding settings
 649         return AWT_MULTICLICK_SMUDGE;
 650     }
 651 
 652     public void handleButtonPressRelease(XEvent xev) {
 653         super.handleButtonPressRelease(xev);
 654         XButtonEvent xbe = xev.get_xbutton();
 655         if (isEventDisabled(xev)) {
 656             return;
 657         }
 658         if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
 659             eventLog.fine(xbe.toString());
 660         }
 661         long when;
 662         int modifiers;
 663         boolean popupTrigger = false;
 664         int button=0;
 665         int lbutton = xbe.get_button();
 666         /*
 667          * Ignore the buttons above 20 due to the bit limit for
 668          * InputEvent.BUTTON_DOWN_MASK.
 669          * One more bit is reserved for FIRST_HIGH_BIT.
 670          */
 671         if (lbutton &gt; SunToolkit.MAX_BUTTONS_SUPPORTED) {
 672             return;
 673         }
 674         int type = xev.get_type();
 675         when = xbe.get_time();
 676         long jWhen = XToolkit.nowMillisUTC_offset(when);
 677 
 678         int x = scaleDown(xbe.get_x());
 679         int y = scaleDown(xbe.get_y());
 680         if (xev.get_xany().get_window() != window) {
 681             Point localXY = toLocal(scaleDown(xbe.get_x_root()),
 682                                     scaleDown(xbe.get_y_root()));
 683             x = localXY.x;
 684             y = localXY.y;
 685         }
 686 
 687         if (type == XConstants.ButtonPress) {
 688             //Allow this mouse button to generate CLICK event on next ButtonRelease
 689             mouseButtonClickAllowed |= XlibUtil.getButtonMask(lbutton);
 690             XWindow lastWindow = (lastWindowRef != null) ? (lastWindowRef.get()):(null);
 691             /*
 692                multiclick checking
 693             */
 694             if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
 695                 eventLog.finest(&quot;lastWindow = &quot; + lastWindow + &quot;, lastButton &quot;
 696                 + lastButton + &quot;, lastTime &quot; + lastTime + &quot;, multiClickTime &quot;
 697                 + XToolkit.getMultiClickTime());
 698             }
 699             if (lastWindow == this &amp;&amp; lastButton == lbutton &amp;&amp; (when - lastTime) &lt; XToolkit.getMultiClickTime()) {
 700                 clickCount++;
 701             } else {
 702                 clickCount = 1;
 703                 lastWindowRef = new WeakReference&lt;&gt;(this);
 704                 lastButton = lbutton;
 705                 lastX = x;
 706                 lastY = y;
 707             }
 708             lastTime = when;
 709 
 710 
 711             /*
 712                Check for popup trigger !!
 713             */
 714             popupTrigger = (lbutton == 3);
 715         }
 716 
 717         button = XConstants.buttons[lbutton - 1];
 718 
 719         // mapping extra buttons to numbers starting from 4.
 720         if ((button &gt; XConstants.buttons[4]) &amp;&amp; (!Toolkit.getDefaultToolkit().areExtraMouseButtonsEnabled())){
 721             return;
 722         }
 723 
 724         if (button &gt; XConstants.buttons[4]){
 725             button -= 2;
 726         }
 727 
 728         if (!isWheel(lbutton)) {
 729             modifiers = getModifiers(xbe.get_state(), button, 0);
 730             MouseEvent me = new MouseEvent(getEventSource(),
 731                                            type == XConstants.ButtonPress ? MouseEvent.MOUSE_PRESSED : MouseEvent.MOUSE_RELEASED,
 732                                            jWhen,modifiers, x, y,
 733                                            scaleDown(xbe.get_x_root()),
 734                                            scaleDown(xbe.get_y_root()),
 735                                            clickCount,popupTrigger,button);
 736 
 737             postEventToEventQueue(me);
 738 
 739             if ((type == XConstants.ButtonRelease) &amp;&amp;
 740                 ((mouseButtonClickAllowed &amp; XlibUtil.getButtonMask(lbutton)) != 0) ) // No up-button in the drag-state
 741             {
 742                 postEventToEventQueue(me = new MouseEvent(getEventSource(),
 743                                                      MouseEvent.MOUSE_CLICKED,
 744                                                      jWhen,
 745                                                      modifiers,
 746                                                      x, y,
 747                                                      scaleDown(xbe.get_x_root()),
 748                                                      scaleDown(xbe.get_y_root()),
 749                                                      clickCount,
 750                                                      false, button));
 751             }
 752 
 753         }
 754         else {
 755             modifiers = getWheelModifiers(xbe.get_state(), button);
 756             if (xev.get_type() == XConstants.ButtonPress) {
 757                 MouseWheelEvent mwe = new MouseWheelEvent(getEventSource(),MouseEvent.MOUSE_WHEEL, jWhen,
 758                                                           modifiers,
 759                                                           x, y,
 760                                                           scaleDown(xbe.get_x_root()),
 761                                                           scaleDown(xbe.get_y_root()),
 762                                                           1,false,MouseWheelEvent.WHEEL_UNIT_SCROLL,
 763                                                           3,button==4 ?  -1 : 1);
 764                 postEventToEventQueue(mwe);
 765             }
 766         }
 767 
 768         /* Update the state variable AFTER the CLICKED event post. */
 769         if (type == XConstants.ButtonRelease) {
 770             /* Exclude this mouse button from allowed list.*/
 771             mouseButtonClickAllowed &amp;= ~ XlibUtil.getButtonMask(lbutton);
 772         }
 773     }
 774 
 775     public void handleMotionNotify(XEvent xev) {
 776         super.handleMotionNotify(xev);
 777         XMotionEvent xme = xev.get_xmotion();
 778         if (isEventDisabled(xev)) {
 779             return;
 780         }
 781 
 782         int mouseKeyState = 0; //(xme.get_state() &amp; (XConstants.buttonsMask[0] | XConstants.buttonsMask[1] | XConstants.buttonsMask[2]));
 783 
 784         //this doesn&#39;t work for extra buttons because Xsystem is sending state==0 for every extra button event.
 785         // we can&#39;t correct it in MouseEvent class as we done it with modifiers, because exact type (DRAG|MOVE)
 786         // should be passed from XWindow.
 787         final int buttonsNumber = XToolkit.getNumberOfButtonsForMask();
 788 
 789         for (int i = 0; i &lt; buttonsNumber; i++){
 790             // TODO : here is the bug in WM: extra buttons doesn&#39;t have state!=0 as they should.
 791             if ((i != 4) &amp;&amp; (i != 5)) {
 792                 mouseKeyState = mouseKeyState | (xme.get_state() &amp; XlibUtil.getButtonMask(i + 1));
 793             }
 794         }
 795 
 796         boolean isDragging = (mouseKeyState != 0);
 797         int mouseEventType = 0;
 798 
 799         if (isDragging) {
 800             mouseEventType = MouseEvent.MOUSE_DRAGGED;
 801         } else {
 802             mouseEventType = MouseEvent.MOUSE_MOVED;
 803         }
 804 
 805         /*
 806            Fix for 6176814 .  Add multiclick checking.
 807         */
 808         int x = scaleDown(xme.get_x());
 809         int y = scaleDown(xme.get_y());
 810         XWindow lastWindow = (lastWindowRef != null) ? (lastWindowRef.get()):(null);
 811 
 812         if (!(lastWindow == this &amp;&amp;
 813               (xme.get_time() - lastTime) &lt; XToolkit.getMultiClickTime()  &amp;&amp;
 814               (Math.abs(lastX - x) &lt; AWT_MULTICLICK_SMUDGE &amp;&amp;
 815                Math.abs(lastY - y) &lt; AWT_MULTICLICK_SMUDGE))) {
 816           clickCount = 0;
 817           lastWindowRef = null;
 818           mouseButtonClickAllowed = 0;
 819           lastTime = 0;
 820           lastX = 0;
 821           lastY = 0;
 822         }
 823 
 824         long jWhen = XToolkit.nowMillisUTC_offset(xme.get_time());
 825         int modifiers = getModifiers(xme.get_state(), 0, 0);
 826         boolean popupTrigger = false;
 827 
 828         Component source = getEventSource();
 829 
 830         if (xme.get_window() != window) {
 831             Point localXY = toLocal(scaleDown(xme.get_x_root()),
 832                                     scaleDown(xme.get_y_root()));
 833             x = localXY.x;
 834             y = localXY.y;
 835         }
 836         /* Fix for 5039416.
 837          * According to canvas.c we shouldn&#39;t post any MouseEvent if mouse is dragging and clickCount!=0.
 838          */
 839         if ((isDragging &amp;&amp; clickCount == 0) || !isDragging) {
 840             MouseEvent mme = new MouseEvent(source, mouseEventType, jWhen,
 841                                             modifiers, x, y,
 842                                             scaleDown(xme.get_x_root()),
 843                                             scaleDown(xme.get_y_root()),
 844                                             clickCount, popupTrigger, MouseEvent.NOBUTTON);
 845             postEventToEventQueue(mme);
 846         }
 847     }
 848 
 849 
 850     // REMIND: need to implement looking for disabled events
 851     private native boolean x11inputMethodLookupString(long event,
 852                                                       long[] keysymArray);
 853 
 854     private native boolean haveCurrentX11InputMethodInstance();
 855 
 856     private boolean mouseAboveMe;
 857 
 858     public boolean isMouseAbove() {
 859         synchronized (getStateLock()) {
 860             return mouseAboveMe;
 861         }
 862     }
 863     protected void setMouseAbove(boolean above) {
 864         synchronized (getStateLock()) {
 865             mouseAboveMe = above;
 866         }
 867     }
 868 
 869     protected void enterNotify(long window) {
 870         if (window == getWindow()) {
 871             setMouseAbove(true);
 872         }
 873     }
 874     protected void leaveNotify(long window) {
 875         if (window == getWindow()) {
 876             setMouseAbove(false);
 877         }
 878     }
 879 
 880     public void handleXCrossingEvent(XEvent xev) {
 881         super.handleXCrossingEvent(xev);
 882         XCrossingEvent xce = xev.get_xcrossing();
 883 
 884         if (eventLog.isLoggable(PlatformLogger.Level.FINEST)) {
 885             eventLog.finest(xce.toString());
 886         }
 887 
 888         if (xce.get_type() == XConstants.EnterNotify) {
 889             enterNotify(xce.get_window());
 890         } else { // LeaveNotify:
 891             leaveNotify(xce.get_window());
 892         }
 893 
 894         // Skip event If it was caused by a grab
 895         // This is needed because on displays with focus-follows-mouse on MousePress X system generates
 896         // two XCrossing events with mode != NormalNotify. First of them notifies that the mouse has left
 897         // current component. Second one notifies that it has entered into the same component.
 898         // This looks like the window under the mouse has actually changed and Java handle these  events
 899         // accordingly. This leads to impossibility to make a double click on Component (6404708)
 900         XWindowPeer toplevel = getToplevelXWindow();
 901         if (toplevel != null &amp;&amp; !toplevel.isModalBlocked()){
 902             if (xce.get_mode() != XConstants.NotifyNormal) {
 903                 // 6404708 : need update cursor in accordance with skipping Leave/EnterNotify event
 904                 // whereas it doesn&#39;t need to handled further.
 905                 if (xce.get_type() == XConstants.EnterNotify) {
 906                     XAwtState.setComponentMouseEntered(getEventSource());
 907                     XGlobalCursorManager.nativeUpdateCursor(getEventSource());
 908                 } else { // LeaveNotify:
 909                     XAwtState.setComponentMouseEntered(null);
 910                 }
 911                 return;
 912             }
 913         }
 914         // X sends XCrossing to all hierarchy so if the edge of child equals to
 915         // ancestor and mouse enters child, the ancestor will get an event too.
 916         // From java point the event is bogus as ancestor is obscured, so if
 917         // the child can get java event itself, we skip it on ancestor.
 918         long childWnd = xce.get_subwindow();
 919         if (childWnd != XConstants.None) {
 920             XBaseWindow child = XToolkit.windowToXWindow(childWnd);
 921             if (child != null &amp;&amp; child instanceof XWindow &amp;&amp;
 922                 !child.isEventDisabled(xev))
 923             {
 924                 return;
 925             }
 926         }
 927 
 928         // Remember old component with mouse to have the opportunity to send it MOUSE_EXITED.
 929         final Component compWithMouse = XAwtState.getComponentMouseEntered();
 930         if (toplevel != null) {
 931             if(!toplevel.isModalBlocked()){
 932                 if (xce.get_type() == XConstants.EnterNotify) {
 933                     // Change XAwtState&#39;s component mouse entered to the up-to-date one before requesting
 934                     // to update the cursor since XAwtState.getComponentMouseEntered() is used when the
 935                     // cursor is updated (in XGlobalCursorManager.findHeavyweightUnderCursor()).
 936                     XAwtState.setComponentMouseEntered(getEventSource());
 937                     XGlobalCursorManager.nativeUpdateCursor(getEventSource());
 938                 } else { // LeaveNotify:
 939                     XAwtState.setComponentMouseEntered(null);
 940                 }
 941             } else {
 942                 ((XComponentPeer) AWTAccessor.getComponentAccessor().getPeer(target))
 943                     .pSetCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
 944             }
 945         }
 946 
 947         if (isEventDisabled(xev)) {
 948             return;
 949         }
 950 
 951         long jWhen = XToolkit.nowMillisUTC_offset(xce.get_time());
 952         int modifiers = getModifiers(xce.get_state(),0,0);
 953         int clickCount = 0;
 954         boolean popupTrigger = false;
 955         int x = scaleDown(xce.get_x());
 956         int y = scaleDown(xce.get_y());
 957         if (xce.get_window() != window) {
 958             Point localXY = toLocal(scaleDown(xce.get_x_root()),
 959                                     scaleDown(xce.get_y_root()));
 960             x = localXY.x;
 961             y = localXY.y;
 962         }
 963 
 964         // This code tracks boundary crossing and ensures MOUSE_ENTER/EXIT
 965         // are posted in alternate pairs
 966         if (compWithMouse != null) {
 967             MouseEvent me = new MouseEvent(compWithMouse, MouseEvent.MOUSE_EXITED,
 968                                            jWhen, modifiers,
 969                                            scaleDown(xce.get_x()),
 970                                            scaleDown(xce.get_y()),
 971                                            scaleDown(xce.get_x_root()),
 972                                            scaleDown(xce.get_y_root()),
 973                                            clickCount, popupTrigger,
 974                                            MouseEvent.NOBUTTON);
 975             postEventToEventQueue(me);
 976             eventLog.finest(&quot;Clearing last window ref&quot;);
 977             lastWindowRef = null;
 978         }
 979         if (xce.get_type() == XConstants.EnterNotify) {
 980             MouseEvent me = new MouseEvent(getEventSource(), MouseEvent.MOUSE_ENTERED,
 981                                            jWhen, modifiers,
 982                                            scaleDown(xce.get_x()),
 983                                            scaleDown(xce.get_y()),
 984                                            scaleDown(xce.get_x_root()),
 985                                            scaleDown(xce.get_y_root()),
 986                                            clickCount, popupTrigger,
 987                                            MouseEvent.NOBUTTON);
 988             postEventToEventQueue(me);
 989         }
 990     }
 991 
 992     public void doLayout(int x, int y, int width, int height) {}
 993 
 994     public void handleConfigureNotifyEvent(XEvent xev) {
 995         Rectangle oldBounds = getBounds();
 996 
 997         super.handleConfigureNotifyEvent(xev);
 998         if (insLog.isLoggable(PlatformLogger.Level.FINER)) {
 999             insLog.finer(&quot;Configure, {0}, event disabled: {1}&quot;,
1000                      xev.get_xconfigure(), isEventDisabled(xev));
1001         }
1002         if (isEventDisabled(xev)) {
1003             return;
1004         }
1005 
1006 //  if ( Check if it&#39;s a resize, a move, or a stacking order change )
1007 //  {
1008         Rectangle bounds = getBounds();
1009         if (!bounds.getSize().equals(oldBounds.getSize())) {
1010             postEventToEventQueue(new ComponentEvent(getEventSource(), ComponentEvent.COMPONENT_RESIZED));
1011         }
1012         if (!bounds.getLocation().equals(oldBounds.getLocation())) {
1013             postEventToEventQueue(new ComponentEvent(getEventSource(), ComponentEvent.COMPONENT_MOVED));
1014         }
1015 //  }
1016     }
1017 
1018     public void handleMapNotifyEvent(XEvent xev) {
1019         super.handleMapNotifyEvent(xev);
1020         if (log.isLoggable(PlatformLogger.Level.FINE)) {
1021             log.fine(&quot;Mapped {0}&quot;, this);
1022         }
1023         if (isEventDisabled(xev)) {
1024             return;
1025         }
1026         ComponentEvent ce;
1027 
1028         ce = new ComponentEvent(getEventSource(), ComponentEvent.COMPONENT_SHOWN);
1029         postEventToEventQueue(ce);
1030     }
1031 
1032     public void handleUnmapNotifyEvent(XEvent xev) {
1033         super.handleUnmapNotifyEvent(xev);
1034         if (isEventDisabled(xev)) {
1035             return;
1036         }
1037         ComponentEvent ce;
1038 
1039         ce = new ComponentEvent(target, ComponentEvent.COMPONENT_HIDDEN);
1040         postEventToEventQueue(ce);
1041     }
1042 
1043     private void dumpKeysymArray(XKeyEvent ev) {
1044         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1045             keyEventLog.fine(&quot;  &quot;+Long.toHexString(XlibWrapper.XKeycodeToKeysym(XToolkit.getDisplay(), ev.get_keycode(), 0))+
1046                              &quot;\n        &quot;+Long.toHexString(XlibWrapper.XKeycodeToKeysym(XToolkit.getDisplay(), ev.get_keycode(), 1))+
1047                              &quot;\n        &quot;+Long.toHexString(XlibWrapper.XKeycodeToKeysym(XToolkit.getDisplay(), ev.get_keycode(), 2))+
1048                              &quot;\n        &quot;+Long.toHexString(XlibWrapper.XKeycodeToKeysym(XToolkit.getDisplay(), ev.get_keycode(), 3)));
1049         }
1050     }
1051     /**
1052        Return unicode character or 0 if no correspondent character found.
1053        Parameter is a keysym basically from keysymdef.h
1054        XXX: how about vendor keys? Is there some with Unicode value and not in the list?
1055     */
1056     int keysymToUnicode( long keysym, int state ) {
1057         return XKeysym.convertKeysym( keysym, state );
1058     }
1059     int keyEventType2Id( int xEventType ) {
1060         return xEventType == XConstants.KeyPress ? java.awt.event.KeyEvent.KEY_PRESSED :
1061                xEventType == XConstants.KeyRelease ? java.awt.event.KeyEvent.KEY_RELEASED : 0;
1062     }
1063     private static long xkeycodeToKeysym(XKeyEvent ev) {
1064         return XKeysym.getKeysym( ev );
1065     }
1066     private long xkeycodeToPrimaryKeysym(XKeyEvent ev) {
1067         return XKeysym.xkeycode2primary_keysym( ev );
1068     }
1069     private static int primaryUnicode2JavaKeycode(int uni) {
1070         return (uni &gt; 0? sun.awt.ExtendedKeyCodes.getExtendedKeyCodeForChar(uni) : 0);
1071         //return (uni &gt; 0? uni + 0x01000000 : 0);
1072     }
1073     void logIncomingKeyEvent(XKeyEvent ev) {
1074         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1075             keyEventLog.fine(&quot;--XWindow.java:handleKeyEvent:&quot;+ev);
1076         }
1077         dumpKeysymArray(ev);
1078         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1079             keyEventLog.fine(&quot;XXXXXXXXXXXXXX javakeycode will be most probably:0x&quot;+ Integer.toHexString(XKeysym.getJavaKeycodeOnly(ev)));
1080         }
1081     }
1082     public void handleKeyPress(XEvent xev) {
1083         super.handleKeyPress(xev);
1084         XKeyEvent ev = xev.get_xkey();
1085         if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
1086             eventLog.fine(ev.toString());
1087         }
1088         if (isEventDisabled(xev)) {
1089             return;
1090         }
1091         handleKeyPress(ev);
1092     }
1093     // called directly from this package, unlike handleKeyRelease.
1094     // un-final it if you need to override it in a subclass.
1095     final void handleKeyPress(XKeyEvent ev) {
1096         long[] keysym = new long[2];
1097         int unicodeKey = 0;
1098         keysym[0] = XConstants.NoSymbol;
1099 
1100         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1101             logIncomingKeyEvent( ev );
1102         }
1103         if ( //TODO check if there&#39;s an active input method instance
1104              // without calling a native method. Is it necessary though?
1105             haveCurrentX11InputMethodInstance()) {
1106             if (x11inputMethodLookupString(ev.pData, keysym)) {
1107                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1108                     keyEventLog.fine(&quot;--XWindow.java XIM did process event; return; dec keysym processed:&quot;+(keysym[0])+
1109                                    &quot;; hex keysym processed:&quot;+Long.toHexString(keysym[0])
1110                                    );
1111                 }
1112                 return;
1113             }else {
1114                 unicodeKey = keysymToUnicode( keysym[0], ev.get_state() );
1115                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1116                     keyEventLog.fine(&quot;--XWindow.java XIM did NOT process event, hex keysym:&quot;+Long.toHexString(keysym[0])+&quot;\n&quot;+
1117                                      &quot;                                         unicode key:&quot;+Integer.toHexString(unicodeKey));
1118                 }
1119             }
1120         }else  {
1121             // No input method instance found. For example, there&#39;s a Java Input Method.
1122             // Produce do-it-yourself keysym and perhaps unicode character.
1123             keysym[0] = xkeycodeToKeysym(ev);
1124             unicodeKey = keysymToUnicode( keysym[0], ev.get_state() );
1125             if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1126                 keyEventLog.fine(&quot;--XWindow.java XIM is absent;             hex keysym:&quot;+Long.toHexString(keysym[0])+&quot;\n&quot;+
1127                                  &quot;                                         unicode key:&quot;+Integer.toHexString(unicodeKey));
1128             }
1129         }
1130         // Keysym should be converted to Unicode, if possible and necessary,
1131         // and Java KeyEvent keycode should be calculated.
1132         // For press we should post pressed &amp; typed Java events.
1133         //
1134         // Press event might be not processed to this time because
1135         //  (1) either XIM could not handle it or
1136         //  (2) it was Latin 1:1 mapping.
1137         //
1138         // Preserve modifiers to get Java key code for dead keys
1139         boolean isDeadKey = isDeadKey(keysym[0]);
1140         XKeysym.Keysym2JavaKeycode jkc = isDeadKey ? XKeysym.getJavaKeycode(keysym[0])
1141                 : XKeysym.getJavaKeycode(ev);
1142         if( jkc == null ) {
1143             jkc = new XKeysym.Keysym2JavaKeycode(java.awt.event.KeyEvent.VK_UNDEFINED, java.awt.event.KeyEvent.KEY_LOCATION_UNKNOWN);
1144         }
1145 
1146         // Take the first keysym from a keysym array associated with the XKeyevent
1147         // and convert it to Unicode. Then, even if a Java keycode for the keystroke
1148         // is undefined, we still have a guess of what has been engraved on a keytop.
1149         int unicodeFromPrimaryKeysym = keysymToUnicode( xkeycodeToPrimaryKeysym(ev) ,0);
1150 
1151         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1152             keyEventLog.fine(&quot;&gt;&gt;&gt;Fire Event:&quot;+
1153                (ev.get_type() == XConstants.KeyPress ? &quot;KEY_PRESSED; &quot; : &quot;KEY_RELEASED; &quot;)+
1154                &quot;jkeycode:decimal=&quot;+jkc.getJavaKeycode()+
1155                &quot;, hex=0x&quot;+Integer.toHexString(jkc.getJavaKeycode())+&quot;; &quot;+
1156                &quot; legacy jkeycode: decimal=&quot;+XKeysym.getLegacyJavaKeycodeOnly(ev)+
1157                &quot;, hex=0x&quot;+Integer.toHexString(XKeysym.getLegacyJavaKeycodeOnly(ev))+&quot;; &quot;
1158             );
1159         }
1160 
1161         int jkeyToReturn = XKeysym.getLegacyJavaKeycodeOnly(ev); // someway backward compatible
1162         int jkeyExtended = jkc.getJavaKeycode() == java.awt.event.KeyEvent.VK_UNDEFINED ?
1163                            primaryUnicode2JavaKeycode( unicodeFromPrimaryKeysym ) :
1164                              jkc.getJavaKeycode();
1165         postKeyEvent( java.awt.event.KeyEvent.KEY_PRESSED,
1166                           ev.get_time(),
1167                           isDeadKey ? jkeyExtended : jkeyToReturn,
1168                           (unicodeKey == 0 ? java.awt.event.KeyEvent.CHAR_UNDEFINED : unicodeKey),
1169                           jkc.getKeyLocation(),
1170                           ev.get_state(),ev.getPData(), XKeyEvent.getSize(), (long)(ev.get_keycode()),
1171                           unicodeFromPrimaryKeysym,
1172                           jkeyExtended);
1173 
1174 
1175         if (unicodeKey &gt; 0 &amp;&amp; !isDeadKey) {
1176                 if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1177                     keyEventLog.fine(&quot;fire _TYPED on &quot;+unicodeKey);
1178                 }
1179                 postKeyEvent( java.awt.event.KeyEvent.KEY_TYPED,
1180                               ev.get_time(),
1181                               java.awt.event.KeyEvent.VK_UNDEFINED,
1182                               unicodeKey,
1183                               java.awt.event.KeyEvent.KEY_LOCATION_UNKNOWN,
1184                               ev.get_state(),ev.getPData(), XKeyEvent.getSize(), (long)0,
1185                               unicodeFromPrimaryKeysym,
1186                               java.awt.event.KeyEvent.VK_UNDEFINED);
1187 
1188         }
1189 
1190 
1191     }
1192 
1193     public void handleKeyRelease(XEvent xev) {
1194         super.handleKeyRelease(xev);
1195         XKeyEvent ev = xev.get_xkey();
1196         if (eventLog.isLoggable(PlatformLogger.Level.FINE)) {
1197             eventLog.fine(ev.toString());
1198         }
1199         if (isEventDisabled(xev)) {
1200             return;
1201         }
1202         handleKeyRelease(ev);
1203     }
1204     // un-private it if you need to call it from elsewhere
1205     private void handleKeyRelease(XKeyEvent ev) {
1206         int unicodeKey = 0;
1207 
1208         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1209             logIncomingKeyEvent( ev );
1210         }
1211         // Keysym should be converted to Unicode, if possible and necessary,
1212         // and Java KeyEvent keycode should be calculated.
1213         // For release we should post released event.
1214         //
1215         // Preserve modifiers to get Java key code for dead keys
1216         long keysym = xkeycodeToKeysym(ev);
1217         boolean isDeadKey = isDeadKey(keysym);
1218         XKeysym.Keysym2JavaKeycode jkc = isDeadKey ? XKeysym.getJavaKeycode(keysym)
1219                 : XKeysym.getJavaKeycode(ev);
1220         if( jkc == null ) {
1221             jkc = new XKeysym.Keysym2JavaKeycode(java.awt.event.KeyEvent.VK_UNDEFINED, java.awt.event.KeyEvent.KEY_LOCATION_UNKNOWN);
1222         }
1223         if (keyEventLog.isLoggable(PlatformLogger.Level.FINE)) {
1224             keyEventLog.fine(&quot;&gt;&gt;&gt;Fire Event:&quot;+
1225                (ev.get_type() == XConstants.KeyPress ? &quot;KEY_PRESSED; &quot; : &quot;KEY_RELEASED; &quot;)+
1226                &quot;jkeycode:decimal=&quot;+jkc.getJavaKeycode()+
1227                &quot;, hex=0x&quot;+Integer.toHexString(jkc.getJavaKeycode())+&quot;; &quot;+
1228                &quot; legacy jkeycode: decimal=&quot;+XKeysym.getLegacyJavaKeycodeOnly(ev)+
1229                &quot;, hex=0x&quot;+Integer.toHexString(XKeysym.getLegacyJavaKeycodeOnly(ev))+&quot;; &quot;
1230             );
1231         }
1232         // We obtain keysym from IM and derive unicodeKey from it for KeyPress only.
1233         // We used to cache that value and retrieve it on KeyRelease,
1234         // but in case for example of a dead key+vowel pair, a vowel after a deadkey
1235         // might never be cached before.
1236         // Also, switching between keyboard layouts, we might cache a wrong letter.
1237         // That&#39;s why we use the same procedure as if there was no IM instance: do-it-yourself unicode.
1238         unicodeKey = keysymToUnicode( xkeycodeToKeysym(ev), ev.get_state() );
1239 
1240         // Take a first keysym from a keysym array associated with the XKeyevent
1241         // and convert it to Unicode. Then, even if Java keycode for the keystroke
1242         // is undefined, we still will have a guess of what was engraved on a keytop.
1243         int unicodeFromPrimaryKeysym = keysymToUnicode( xkeycodeToPrimaryKeysym(ev) ,0);
1244 
1245         int jkeyToReturn = XKeysym.getLegacyJavaKeycodeOnly(ev); // someway backward compatible
1246         int jkeyExtended = jkc.getJavaKeycode() == java.awt.event.KeyEvent.VK_UNDEFINED ?
1247                            primaryUnicode2JavaKeycode( unicodeFromPrimaryKeysym ) :
1248                              jkc.getJavaKeycode();
1249         postKeyEvent(  java.awt.event.KeyEvent.KEY_RELEASED,
1250                           ev.get_time(),
1251                           isDeadKey ? jkeyExtended : jkeyToReturn,
1252                           (unicodeKey == 0 ? java.awt.event.KeyEvent.CHAR_UNDEFINED : unicodeKey),
1253                           jkc.getKeyLocation(),
1254                           ev.get_state(),ev.getPData(), XKeyEvent.getSize(), (long)(ev.get_keycode()),
1255                           unicodeFromPrimaryKeysym,
1256                           jkeyExtended);
1257 
1258 
1259     }
1260 
1261 
1262     private boolean isDeadKey(long keysym){
1263         return XKeySymConstants.XK_dead_grave &lt;= keysym &amp;&amp; keysym &lt;= XKeySymConstants.XK_dead_semivoiced_sound;
1264     }
1265 
1266     /*
1267      * XmNiconic and Map/UnmapNotify (that XmNiconic relies on) are
1268      * unreliable, since mapping changes can happen for a virtual desktop
1269      * switch or MacOS style shading that became quite popular under X as
1270      * well.  Yes, it probably should not be this way, as it violates
1271      * ICCCM, but reality is that quite a lot of window managers abuse
1272      * mapping state.
1273      */
1274     int getWMState() {
1275         if (stateChanged) {
1276             stateChanged = false;
1277             WindowPropertyGetter getter =
1278                 new WindowPropertyGetter(window, XWM.XA_WM_STATE, 0, 1, false,
1279                                          XWM.XA_WM_STATE);
1280             try {
1281                 int status = getter.execute();
1282                 if (status != XConstants.Success || getter.getData() == 0) {
1283                     return savedState = XUtilConstants.WithdrawnState;
1284                 }
1285 
1286                 if (getter.getActualType() != XWM.XA_WM_STATE.getAtom() &amp;&amp; getter.getActualFormat() != 32) {
1287                     return savedState = XUtilConstants.WithdrawnState;
1288                 }
1289                 savedState = (int)Native.getCard32(getter.getData());
1290             } finally {
1291                 getter.dispose();
1292             }
1293         }
1294         return savedState;
1295     }
1296 
1297     /**
1298      * Override this methods to get notifications when top-level window state changes. The state is
1299      * meant in terms of ICCCM: WithdrawnState, IconicState, NormalState
1300      */
1301     protected void stateChanged(long time, int oldState, int newState) {
1302     }
1303 
1304     @Override
1305     public void handlePropertyNotify(XEvent xev) {
1306         super.handlePropertyNotify(xev);
1307         XPropertyEvent ev = xev.get_xproperty();
1308         if (ev.get_atom() == XWM.XA_WM_STATE.getAtom()) {
1309             // State has changed, invalidate saved value
1310             stateChanged = true;
1311             stateChanged(ev.get_time(), savedState, getWMState());
1312         }
1313     }
1314 
1315     public void reshape(Rectangle bounds) {
1316         reshape(bounds.x, bounds.y, bounds.width, bounds.height);
1317     }
1318 
1319     public void reshape(int x, int y, int width, int height) {
1320         if (width &lt;= 0) {
1321             width = 1;
1322         }
1323         if (height &lt;= 0) {
1324             height = 1;
1325         }
1326         this.x = x;
1327         this.y = y;
1328         this.width = width;
1329         this.height = height;
1330         xSetBounds(x, y, width, height);
1331         // Fixed 6322593, 6304251, 6315137:
1332         // XWindow&#39;s SurfaceData should be invalidated and recreated as part
1333         // of the process of resizing the window
1334         // see the evaluation of the bug 6304251 for more information
1335         validateSurface();
1336         layout();
1337     }
1338 
1339     public void layout() {}
1340 
1341     boolean isShowing() {
1342         return visible;
1343     }
1344 
1345     boolean isResizable() {
1346         return true;
1347     }
1348 
1349     boolean isLocationByPlatform() {
1350         return false;
1351     }
1352 
1353     void updateSizeHints() {
1354         updateSizeHints(x, y, width, height);
1355     }
1356 
1357     void updateSizeHints(int x, int y, int width, int height) {
1358         long flags = XUtilConstants.PSize | (isLocationByPlatform() ? 0 : (XUtilConstants.PPosition | XUtilConstants.USPosition));
1359         if (!isResizable()) {
1360             if (log.isLoggable(PlatformLogger.Level.FINER)) {
1361                 log.finer(&quot;Window {0} is not resizable&quot;, this);
1362             }
1363             flags |= XUtilConstants.PMinSize | XUtilConstants.PMaxSize;
1364         } else {
1365             if (log.isLoggable(PlatformLogger.Level.FINER)) {
1366                 log.finer(&quot;Window {0} is resizable&quot;, this);
1367             }
1368         }
1369         setSizeHints(flags, x, y, width, height);
1370     }
1371 
1372     void updateSizeHints(int x, int y) {
1373         long flags = isLocationByPlatform() ? 0 : (XUtilConstants.PPosition | XUtilConstants.USPosition);
1374         if (!isResizable()) {
1375             if (log.isLoggable(PlatformLogger.Level.FINER)) {
1376                 log.finer(&quot;Window {0} is not resizable&quot;, this);
1377             }
1378             flags |= XUtilConstants.PMinSize | XUtilConstants.PMaxSize | XUtilConstants.PSize;
1379         } else {
1380             if (log.isLoggable(PlatformLogger.Level.FINER)) {
1381                 log.finer(&quot;Window {0} is resizable&quot;, this);
1382             }
1383         }
1384         setSizeHints(flags, x, y, width, height);
1385     }
1386 
1387     void validateSurface() {
1388         if ((width != oldWidth) || (height != oldHeight)) {
1389             doValidateSurface();
1390 
1391             oldWidth = width;
1392             oldHeight = height;
1393         }
1394     }
1395 
1396     final void doValidateSurface() {
1397         SurfaceData oldData = surfaceData;
1398         if (oldData != null) {
1399             surfaceData = graphicsConfig.createSurfaceData(this);
1400             oldData.invalidate();
1401         }
1402     }
1403 
1404     public SurfaceData getSurfaceData() {
1405         return surfaceData;
1406     }
1407 
1408     public void dispose() {
1409         SurfaceData oldData = surfaceData;
1410         surfaceData = null;
1411         if (oldData != null) {
1412             oldData.invalidate();
1413         }
1414         XToolkit.targetDisposedPeer(target, this);
1415         destroy();
1416     }
1417 
1418     public Point getLocationOnScreen() {
1419         synchronized (target.getTreeLock()) {
1420             Component comp = target;
1421 
1422             while (comp != null &amp;&amp; !(comp instanceof Window)) {
1423                 comp = AWTAccessor.getComponentAccessor().getParent(comp);
1424             }
1425 
1426             // applets, embedded, etc - translate directly
1427             // XXX: override in subclass?
1428             if (comp == null || comp instanceof sun.awt.EmbeddedFrame) {
1429                 return toGlobal(0, 0);
1430             }
1431 
1432             XToolkit.awtLock();
1433             try {
1434                 Object wpeer = XToolkit.targetToPeer(comp);
1435                 if (wpeer == null
1436                     || !(wpeer instanceof XDecoratedPeer)
1437                     || ((XDecoratedPeer)wpeer).configure_seen)
1438                 {
1439                     return toGlobal(0, 0);
1440                 }
1441 
1442                 // wpeer is an XDecoratedPeer not yet fully adopted by WM
1443                 Point pt = toOtherWindow(getContentWindow(),
1444                                          ((XDecoratedPeer)wpeer).getContentWindow(),
1445                                          0, 0);
1446 
1447                 if (pt == null) {
1448                     pt = new Point(((XBaseWindow)wpeer).getAbsoluteX(), ((XBaseWindow)wpeer).getAbsoluteY());
1449                 }
1450                 pt.x += comp.getX();
1451                 pt.y += comp.getY();
1452                 return pt;
1453             } finally {
1454                 XToolkit.awtUnlock();
1455             }
1456         }
1457     }
1458 
1459 
1460     static void setBData(KeyEvent e, byte[] data) {
1461         AWTAccessor.getAWTEventAccessor().setBData(e, data);
1462     }
1463 
1464     public void postKeyEvent(int id, long when, int keyCode, int keyChar,
1465         int keyLocation, int state, long event, int eventSize, long rawCode,
1466         int unicodeFromPrimaryKeysym, int extendedKeyCode)
1467 
1468     {
1469         long jWhen = XToolkit.nowMillisUTC_offset(when);
1470         int modifiers = getModifiers(state, 0, keyCode);
1471 
1472         KeyEvent ke = new KeyEvent(getEventSource(), id, jWhen,
1473                                    modifiers, keyCode, (char)keyChar, keyLocation);
1474         if (event != 0) {
1475             byte[] data = Native.toBytes(event, eventSize);
1476             setBData(ke, data);
1477         }
1478 
1479         AWTAccessor.KeyEventAccessor kea = AWTAccessor.getKeyEventAccessor();
1480         kea.setRawCode(ke, rawCode);
1481         kea.setPrimaryLevelUnicode(ke, (long)unicodeFromPrimaryKeysym);
1482         kea.setExtendedKeyCode(ke, (long)extendedKeyCode);
1483         postEventToEventQueue(ke);
1484     }
1485 
1486     static native int getAWTKeyCodeForKeySym(int keysym);
1487     static native int getKeySymForAWTKeyCode(int keycode);
1488 
1489     /* These two methods are actually applicable to toplevel windows only.
1490      * However, the functionality is required by both the XWindowPeer and
1491      * XWarningWindow, both of which have the XWindow as a common ancestor.
1492      * See XWM.setMotifDecor() for details.
1493      */
1494     public PropMwmHints getMWMHints() {
1495         if (mwm_hints == null) {
1496             mwm_hints = new PropMwmHints();
1497             if (!XWM.XA_MWM_HINTS.getAtomData(getWindow(), mwm_hints.pData, MWMConstants.PROP_MWM_HINTS_ELEMENTS)) {
1498                 mwm_hints.zero();
1499             }
1500         }
1501         return mwm_hints;
1502     }
1503 
1504     public void setMWMHints(PropMwmHints hints) {
1505         mwm_hints = hints;
1506         if (hints != null) {
1507             XWM.XA_MWM_HINTS.setAtomData(getWindow(), mwm_hints.pData, MWMConstants.PROP_MWM_HINTS_ELEMENTS);
1508         }
1509     }
1510 
1511     protected final void initWMProtocols() {
1512         wm_protocols.setAtomListProperty(this, getWMProtocols());
1513     }
1514 
1515     /**
1516      * Returns list of protocols which should be installed on this window.
1517      * Descendants can override this method to add class-specific protocols
1518      */
1519     protected XAtomList getWMProtocols() {
1520         // No protocols on simple window
1521         return new XAtomList();
1522     }
1523 
1524     /**
1525      * Indicates if the window is currently in the FSEM.
1526      * Synchronization: state lock.
1527      */
1528     private boolean fullScreenExclusiveModeState = false;
1529 
1530     // Implementation of the X11ComponentPeer
1531     @Override
1532     public void setFullScreenExclusiveModeState(boolean state) {
1533         synchronized (getStateLock()) {
1534             fullScreenExclusiveModeState = state;
1535         }
1536     }
1537 
1538     public final boolean isFullScreenExclusiveMode() {
1539         synchronized (getStateLock()) {
1540             return fullScreenExclusiveModeState;
1541         }
1542     }
1543 
1544     @Override
1545     protected int getScale() {
1546         return graphicsConfig.getScale();
1547     }
1548 
1549     @Override
1550     protected int scaleUp(int x) {
1551         return graphicsConfig.scaleUp(x);
1552     }
1553 
1554     @Override
1555     protected int scaleDown(int x) {
1556         return graphicsConfig.scaleDown(x);
1557     }
1558 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/classes/sun/java2d/opengl/GLXSurfaceData.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2003, 2017, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.java2d.opengl;
 27 
 28 import java.awt.GraphicsConfiguration;
 29 import java.awt.GraphicsDevice;
 30 import java.awt.GraphicsEnvironment;
 31 import java.awt.Image;
 32 import java.awt.Rectangle;
 33 import java.awt.image.ColorModel;
 34 
 35 import sun.awt.X11ComponentPeer;
 36 import sun.java2d.SurfaceData;
 37 
 38 public abstract class GLXSurfaceData extends OGLSurfaceData {
 39 
 40     protected X11ComponentPeer peer;
 41     private GLXGraphicsConfig graphicsConfig;
 42 
<a name="1" id="anc1"></a><span class="line-modified"> 43     private native void initOps(OGLGraphicsConfig gc, X11ComponentPeer peer,</span>
<span class="line-added"> 44                                 long aData);</span>
 45 
 46     protected GLXSurfaceData(X11ComponentPeer peer, GLXGraphicsConfig gc,
 47                              ColorModel cm, int type)
 48     {
 49         super(gc, cm, type);
 50         this.peer = peer;
 51         this.graphicsConfig = gc;
<a name="2" id="anc2"></a><span class="line-modified"> 52         initOps(gc, peer, graphicsConfig.getAData());</span>
 53     }
 54 
 55     public GraphicsConfiguration getDeviceConfiguration() {
 56         return graphicsConfig;
 57     }
 58 
 59     /**
 60      * Creates a SurfaceData object representing the primary (front) buffer
 61      * of an on-screen Window.
 62      */
 63     public static GLXWindowSurfaceData createData(X11ComponentPeer peer) {
 64         GLXGraphicsConfig gc = getGC(peer);
 65         return new GLXWindowSurfaceData(peer, gc);
 66     }
 67 
 68     /**
 69      * Creates a SurfaceData object representing the back buffer of a
 70      * double-buffered on-screen Window.
 71      */
 72     public static GLXOffScreenSurfaceData createData(X11ComponentPeer peer,
 73                                                      Image image,
 74                                                      int type)
 75     {
 76         GLXGraphicsConfig gc = getGC(peer);
 77         Rectangle r = peer.getBounds();
 78         if (type == FLIP_BACKBUFFER) {
 79             return new GLXOffScreenSurfaceData(peer, gc, r.width, r.height,
 80                                                image, peer.getColorModel(),
 81                                                FLIP_BACKBUFFER);
 82         } else {
 83             return new GLXVSyncOffScreenSurfaceData(peer, gc, r.width, r.height,
 84                                                     image, peer.getColorModel(),
 85                                                     type);
 86         }
 87     }
 88 
 89     /**
 90      * Creates a SurfaceData object representing an off-screen buffer (either
 91      * a FBO or Texture).
 92      */
 93     public static GLXOffScreenSurfaceData createData(GLXGraphicsConfig gc,
 94                                                      int width, int height,
 95                                                      ColorModel cm,
 96                                                      Image image, int type)
 97     {
 98         return new GLXOffScreenSurfaceData(null, gc, width, height,
 99                                            image, cm, type);
100     }
101 
102     public static GLXGraphicsConfig getGC(X11ComponentPeer peer) {
103         if (peer != null) {
104             return (GLXGraphicsConfig)peer.getGraphicsConfiguration();
105         } else {
106             // REMIND: this should rarely (never?) happen, but what if
107             //         default config is not GLX?
108             GraphicsEnvironment env =
109                 GraphicsEnvironment.getLocalGraphicsEnvironment();
110             GraphicsDevice gd = env.getDefaultScreenDevice();
111             return (GLXGraphicsConfig)gd.getDefaultConfiguration();
112         }
113     }
114 
115     public static class GLXWindowSurfaceData extends GLXSurfaceData {
116         protected final int scale;
117 
118         public GLXWindowSurfaceData(X11ComponentPeer peer,
119                                     GLXGraphicsConfig gc)
120         {
121             super(peer, gc, peer.getColorModel(), WINDOW);
122             scale = gc.getScale();
123         }
124 
125         public SurfaceData getReplacement() {
126             return peer.getSurfaceData();
127         }
128 
129         public Rectangle getBounds() {
130             Rectangle r = peer.getBounds();
131             r.x = r.y = 0;
132             r.width = (int) Math.ceil(r.width * scale);
133             r.height = (int) Math.ceil(r.height * scale);
134             return r;
135         }
136 
137         /**
138          * Returns destination Component associated with this SurfaceData.
139          */
140         public Object getDestination() {
141             return peer.getTarget();
142         }
143 
144         @Override
145         public double getDefaultScaleX() {
146             return scale;
147         }
148 
149         @Override
150         public double getDefaultScaleY() {
151             return scale;
152         }
153     }
154 
155     /**
156      * A surface which implements a v-synced flip back-buffer with COPIED
157      * FlipContents.
158      *
159      * This surface serves as a back-buffer to the outside world, while
160      * it is actually an offscreen surface. When the BufferStrategy this surface
161      * belongs to is showed, it is first copied to the real private
162      * FLIP_BACKBUFFER, which is then flipped.
163      */
164     public static class GLXVSyncOffScreenSurfaceData extends
165         GLXOffScreenSurfaceData
166     {
167         private GLXOffScreenSurfaceData flipSurface;
168 
169         public GLXVSyncOffScreenSurfaceData(X11ComponentPeer peer,
170                                             GLXGraphicsConfig gc,
171                                             int width, int height,
172                                             Image image, ColorModel cm,
173                                             int type)
174         {
175             super(peer, gc, width, height, image, cm, type);
176             flipSurface = GLXSurfaceData.createData(peer, image, FLIP_BACKBUFFER);
177         }
178 
179         public SurfaceData getFlipSurface() {
180             return flipSurface;
181         }
182 
183         @Override
184         public void flush() {
185             flipSurface.flush();
186             super.flush();
187         }
188 
189     }
190 
191     public static class GLXOffScreenSurfaceData extends GLXSurfaceData {
192 
193         private Image offscreenImage;
194         private int width, height;
195         private final int scale;
196 
197         public GLXOffScreenSurfaceData(X11ComponentPeer peer,
198                                        GLXGraphicsConfig gc,
199                                        int width, int height,
200                                        Image image, ColorModel cm,
201                                        int type)
202         {
203             super(peer, gc, cm, type);
204 
205             scale = gc.getDevice().getScaleFactor();
206             this.width = width * scale;
207             this.height = height * scale;
208             offscreenImage = image;
209 
210             initSurface(this.width, this.height);
211         }
212 
213         public SurfaceData getReplacement() {
214             return restoreContents(offscreenImage);
215         }
216 
217         public Rectangle getBounds() {
218             if (type == FLIP_BACKBUFFER) {
219                 Rectangle r = peer.getBounds();
220                 r.x = r.y = 0;
221                 r.width = (int) Math.ceil(r.width * scale);
222                 r.height = (int) Math.ceil(r.height * scale);
223                 return r;
224             } else {
225                 return new Rectangle(width, height);
226             }
227         }
228 
229         /**
230          * Returns destination Image associated with this SurfaceData.
231          */
232         public Object getDestination() {
233             return offscreenImage;
234         }
235 
236         @Override
237         public double getDefaultScaleX() {
238             return scale;
239         }
240 
241         @Override
242         public double getDefaultScaleY() {
243             return scale;
244         }
245     }
246 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/classes/sun/font/XRGlyphCache.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.io.*;
 29 import java.util.*;
 30 
 31 import sun.awt.*;
 32 import sun.java2d.xr.*;
 33 
 34 /**
 35  * Glyph cache used by the XRender pipeline.
 36  *
 37  * @author Clemens Eisserer
 38  */
 39 
 40 public class XRGlyphCache implements GlyphDisposedListener {
 41     XRBackend con;
 42     XRCompositeManager maskBuffer;
 43     HashMap&lt;MutableInteger, XRGlyphCacheEntry&gt; cacheMap = new HashMap&lt;MutableInteger, XRGlyphCacheEntry&gt;(256);
 44 
 45     int nextID = 1;
 46     MutableInteger tmp = new MutableInteger(0);
 47 
 48     int grayGlyphSet;
 49     int lcdGlyphSet;
 50 
 51     int time = 0;
 52     int cachedPixels = 0;
 53     static final int MAX_CACHED_PIXELS = 100000;
 54 
 55     ArrayList&lt;Integer&gt; freeGlyphIDs = new ArrayList&lt;Integer&gt;(255);
 56 
 57     static final boolean batchGlyphUpload = true; // Boolean.parseBoolean(System.getProperty(&quot;sun.java2d.xrender.batchGlyphUpload&quot;));
 58 
 59     public XRGlyphCache(XRCompositeManager maskBuf) {
 60         this.con = maskBuf.getBackend();
 61         this.maskBuffer = maskBuf;
 62 
 63         grayGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardA8);
 64         lcdGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardARGB32);
 65 
 66         StrikeCache.addGlyphDisposedListener(this);
 67     }
 68 
 69     public void glyphDisposed(ArrayList&lt;Long&gt; glyphPtrList) {
 70         try {
 71             SunToolkit.awtLock();
 72 
 73             GrowableIntArray glyphIDList = new GrowableIntArray(1, glyphPtrList.size());
 74             for (long glyphPtr : glyphPtrList) {
 75                 int glyphID = XRGlyphCacheEntry.getGlyphID(glyphPtr);
 76 
 77                 //Check if glyph hasn&#39;t been freed already
 78                 if (glyphID != 0) {
 79                    glyphIDList.addInt(glyphID);
 80                 }
 81             }
 82             freeGlyphs(glyphIDList);
 83         } finally {
 84             SunToolkit.awtUnlock();
 85         }
 86     }
 87 
 88     protected int getFreeGlyphID() {
 89         if (freeGlyphIDs.size() &gt; 0) {
 90             int newID = freeGlyphIDs.remove(freeGlyphIDs.size() - 1);
 91             return newID;
 92         }
 93         return nextID++;
 94     }
 95 
 96     protected XRGlyphCacheEntry getEntryForPointer(long imgPtr) {
 97         int id = XRGlyphCacheEntry.getGlyphID(imgPtr);
 98 
 99         if (id == 0) {
100             return null;
101         }
102 
103         tmp.setValue(id);
104         return cacheMap.get(tmp);
105     }
106 
107     public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {
108         time++;
109 
110         XRGlyphCacheEntry[] entries = new XRGlyphCacheEntry[glyphList.getNumGlyphs()];
111         long[] imgPtrs = glyphList.getImages();
112         ArrayList&lt;XRGlyphCacheEntry&gt; uncachedGlyphs = null;
113 
114         for (int i = 0; i &lt; glyphList.getNumGlyphs(); i++) {
115             XRGlyphCacheEntry glyph;
116 
<a name="1" id="anc1"></a><span class="line-added">117             if (imgPtrs[i] == 0L) {</span>
<span class="line-added">118                 continue;</span>
<span class="line-added">119             }</span>
120             // Find uncached glyphs and queue them for upload
121             if ((glyph = getEntryForPointer(imgPtrs[i])) == null) {
122                 glyph = new XRGlyphCacheEntry(imgPtrs[i], glyphList);
123                 glyph.setGlyphID(getFreeGlyphID());
124                 cacheMap.put(new MutableInteger(glyph.getGlyphID()), glyph);
125 
126                 if (uncachedGlyphs == null) {
127                     uncachedGlyphs = new ArrayList&lt;XRGlyphCacheEntry&gt;();
128                 }
129                 uncachedGlyphs.add(glyph);
130             }
131             glyph.setLastUsed(time);
132             entries[i] = glyph;
133         }
134 
135         // Add glyphs to cache
136         if (uncachedGlyphs != null) {
137             uploadGlyphs(entries, uncachedGlyphs, glyphList, null);
138         }
139 
140         return entries;
141     }
142 
143     protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList&lt;XRGlyphCacheEntry&gt; uncachedGlyphs, GlyphList gl, int[] glIndices) {
144         for (XRGlyphCacheEntry glyph : uncachedGlyphs) {
145             cachedPixels += glyph.getPixelCnt();
146         }
147 
148         if (cachedPixels &gt; MAX_CACHED_PIXELS) {
149             clearCache(glyphs);
150         }
151 
152         boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);
153         List&lt;XRGlyphCacheEntry&gt;[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);
154         List&lt;XRGlyphCacheEntry&gt; grayGlyphList = seperatedGlyphList[0];
155         List&lt;XRGlyphCacheEntry&gt; lcdGlyphList = seperatedGlyphList[1];
156 
157         /*
158          * Some XServers crash when uploading multiple glyphs at once. TODO:
159          * Implement build-switch in local case for distributors who know their
160          * XServer is fixed
161          */
162         if (batchGlyphUpload) {
163             if (grayGlyphList != null &amp;&amp; grayGlyphList.size() &gt; 0) {
164                 con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));
165             }
166             if (lcdGlyphList != null &amp;&amp; lcdGlyphList.size() &gt; 0) {
167                 con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));
168             }
169         } else {
170             ArrayList&lt;XRGlyphCacheEntry&gt; tmpList = new ArrayList&lt;XRGlyphCacheEntry&gt;(1);
171             tmpList.add(null);
172 
173             for (XRGlyphCacheEntry entry : uncachedGlyphs) {
174                 tmpList.set(0, entry);
175 
176                 if (entry.getGlyphSet() == grayGlyphSet) {
177                     con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));
178                 } else {
179                     con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));
180                 }
181             }
182         }
183     }
184 
185     /**
186      * Seperates lcd and grayscale glyphs queued for upload, and sets the
187      * appropriate glyphset for the cache entries.
188      */
189     protected List&lt;XRGlyphCacheEntry&gt;[] seperateGlyphTypes(List&lt;XRGlyphCacheEntry&gt; glyphList, boolean containsLCDGlyphs) {
190         ArrayList&lt;XRGlyphCacheEntry&gt; lcdGlyphs = null;
191         ArrayList&lt;XRGlyphCacheEntry&gt; grayGlyphs = null;
192 
193         for (XRGlyphCacheEntry cacheEntry : glyphList) {
194             if (cacheEntry.isGrayscale(containsLCDGlyphs)) {
195                 if (grayGlyphs == null) {
196                     grayGlyphs = new ArrayList&lt;&gt;(glyphList.size());
197                 }
198                 cacheEntry.setGlyphSet(grayGlyphSet);
199                 grayGlyphs.add(cacheEntry);
200             } else {
201                 if (lcdGlyphs == null) {
202                     lcdGlyphs = new ArrayList&lt;&gt;(glyphList.size());
203                 }
204                 cacheEntry.setGlyphSet(lcdGlyphSet);
205                 lcdGlyphs.add(cacheEntry);
206             }
207         }
208         // Arrays and generics don&#39;t play well together
209         @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
210         List&lt;XRGlyphCacheEntry&gt;[] tmp =
211             (List&lt;XRGlyphCacheEntry&gt;[]) (new List[] { grayGlyphs, lcdGlyphs });
212         return tmp;
213     }
214 
215     /**
216      * Copies the glyph-images into a continous buffer, required for uploading.
217      */
218     protected byte[] generateGlyphImageStream(List&lt;XRGlyphCacheEntry&gt; glyphList) {
219         boolean isLCDGlyph = glyphList.get(0).getGlyphSet() == lcdGlyphSet;
220 
221         ByteArrayOutputStream stream = new ByteArrayOutputStream((isLCDGlyph ? 4 : 1) * 48 * glyphList.size());
222         for (XRGlyphCacheEntry cacheEntry : glyphList) {
223             cacheEntry.writePixelData(stream, isLCDGlyph);
224         }
225 
226         return stream.toByteArray();
227     }
228 
229     protected boolean containsLCDGlyphs(List&lt;XRGlyphCacheEntry&gt; entries) {
230         boolean containsLCDGlyphs = false;
231 
232         for (XRGlyphCacheEntry entry : entries) {
233             containsLCDGlyphs = !(entry.getSourceRowBytes() == entry.getWidth());
234 
235             if (containsLCDGlyphs) {
236                 return true;
237             }
238         }
239         return false;
240     }
241 
242     protected void clearCache(XRGlyphCacheEntry[] glyps) {
243         /*
244          * Glyph uploading is so slow anyway, we can afford some inefficiency
245          * here, as the cache should usually be quite small. TODO: Implement
246          * something not that stupid ;)
247          */
248         ArrayList&lt;XRGlyphCacheEntry&gt; cacheList = new ArrayList&lt;XRGlyphCacheEntry&gt;(cacheMap.values());
249         Collections.sort(cacheList, new Comparator&lt;XRGlyphCacheEntry&gt;() {
250             public int compare(XRGlyphCacheEntry e1, XRGlyphCacheEntry e2) {
251                 return e2.getLastUsed() - e1.getLastUsed();
252             }
253         });
254 
255         for (XRGlyphCacheEntry glyph : glyps) {
256             glyph.setPinned();
257         }
258 
259         GrowableIntArray deleteGlyphList = new GrowableIntArray(1, 10);
260         int pixelsToRelease = cachedPixels - MAX_CACHED_PIXELS;
261 
262         for (int i = cacheList.size() - 1; i &gt;= 0 &amp;&amp; pixelsToRelease &gt; 0; i--) {
263             XRGlyphCacheEntry entry = cacheList.get(i);
264 
265             if (!entry.isPinned()) {
266                 pixelsToRelease -= entry.getPixelCnt();
267                 deleteGlyphList.addInt(entry.getGlyphID());
268             }
269         }
270 
271         for (XRGlyphCacheEntry glyph : glyps) {
272             glyph.setUnpinned();
273         }
274 
275         freeGlyphs(deleteGlyphList);
276     }
277 
278     private void freeGlyphs(GrowableIntArray glyphIdList) {
279         GrowableIntArray removedLCDGlyphs = new GrowableIntArray(1, 10);
280         GrowableIntArray removedGrayscaleGlyphs = new GrowableIntArray(1, 10);
281 
282         for (int i=0; i &lt; glyphIdList.getSize(); i++) {
283             int glyphId = glyphIdList.getInt(i);
284             freeGlyphIDs.add(glyphId);
285 
286             tmp.setValue(glyphId);
287             XRGlyphCacheEntry entry = cacheMap.get(tmp);
288             cachedPixels -= entry.getPixelCnt();
289             cacheMap.remove(tmp);
290 
291             if (entry.getGlyphSet() == grayGlyphSet) {
292                 removedGrayscaleGlyphs.addInt(glyphId);
293             } else {
294                 removedLCDGlyphs.addInt(glyphId);
295             }
296 
297             entry.setGlyphID(0);
298         }
299 
300         if (removedGrayscaleGlyphs.getSize() &gt; 0) {
301             con.XRenderFreeGlyphs(grayGlyphSet, removedGrayscaleGlyphs.getSizedArray());
302         }
303 
304         if (removedLCDGlyphs.getSize() &gt; 0) {
305             con.XRenderFreeGlyphs(lcdGlyphSet, removedLCDGlyphs.getSizedArray());
306         }
307     }
308 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
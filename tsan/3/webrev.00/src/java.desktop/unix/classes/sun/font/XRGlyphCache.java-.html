<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.desktop/unix/classes/sun/font/XRGlyphCache.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
 28 import java.io.*;
 29 import java.util.*;
 30 
 31 import sun.awt.*;
 32 import sun.java2d.xr.*;
 33 
 34 /**
 35  * Glyph cache used by the XRender pipeline.
 36  *
 37  * @author Clemens Eisserer
 38  */
 39 
 40 public class XRGlyphCache implements GlyphDisposedListener {
 41     XRBackend con;
 42     XRCompositeManager maskBuffer;
 43     HashMap&lt;MutableInteger, XRGlyphCacheEntry&gt; cacheMap = new HashMap&lt;MutableInteger, XRGlyphCacheEntry&gt;(256);
 44 
 45     int nextID = 1;
 46     MutableInteger tmp = new MutableInteger(0);
 47 
 48     int grayGlyphSet;
 49     int lcdGlyphSet;
 50 
 51     int time = 0;
 52     int cachedPixels = 0;
 53     static final int MAX_CACHED_PIXELS = 100000;
 54 
 55     ArrayList&lt;Integer&gt; freeGlyphIDs = new ArrayList&lt;Integer&gt;(255);
 56 
 57     static final boolean batchGlyphUpload = true; // Boolean.parseBoolean(System.getProperty(&quot;sun.java2d.xrender.batchGlyphUpload&quot;));
 58 
 59     public XRGlyphCache(XRCompositeManager maskBuf) {
 60         this.con = maskBuf.getBackend();
 61         this.maskBuffer = maskBuf;
 62 
 63         grayGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardA8);
 64         lcdGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardARGB32);
 65 
 66         StrikeCache.addGlyphDisposedListener(this);
 67     }
 68 
 69     public void glyphDisposed(ArrayList&lt;Long&gt; glyphPtrList) {
 70         try {
 71             SunToolkit.awtLock();
 72 
 73             GrowableIntArray glyphIDList = new GrowableIntArray(1, glyphPtrList.size());
 74             for (long glyphPtr : glyphPtrList) {
 75                 int glyphID = XRGlyphCacheEntry.getGlyphID(glyphPtr);
 76 
 77                 //Check if glyph hasn&#39;t been freed already
 78                 if (glyphID != 0) {
 79                    glyphIDList.addInt(glyphID);
 80                 }
 81             }
 82             freeGlyphs(glyphIDList);
 83         } finally {
 84             SunToolkit.awtUnlock();
 85         }
 86     }
 87 
 88     protected int getFreeGlyphID() {
 89         if (freeGlyphIDs.size() &gt; 0) {
 90             int newID = freeGlyphIDs.remove(freeGlyphIDs.size() - 1);
 91             return newID;
 92         }
 93         return nextID++;
 94     }
 95 
 96     protected XRGlyphCacheEntry getEntryForPointer(long imgPtr) {
 97         int id = XRGlyphCacheEntry.getGlyphID(imgPtr);
 98 
 99         if (id == 0) {
100             return null;
101         }
102 
103         tmp.setValue(id);
104         return cacheMap.get(tmp);
105     }
106 
107     public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {
108         time++;
109 
110         XRGlyphCacheEntry[] entries = new XRGlyphCacheEntry[glyphList.getNumGlyphs()];
111         long[] imgPtrs = glyphList.getImages();
112         ArrayList&lt;XRGlyphCacheEntry&gt; uncachedGlyphs = null;
113 
114         for (int i = 0; i &lt; glyphList.getNumGlyphs(); i++) {
115             XRGlyphCacheEntry glyph;
116 
117             // Find uncached glyphs and queue them for upload
118             if ((glyph = getEntryForPointer(imgPtrs[i])) == null) {
119                 glyph = new XRGlyphCacheEntry(imgPtrs[i], glyphList);
120                 glyph.setGlyphID(getFreeGlyphID());
121                 cacheMap.put(new MutableInteger(glyph.getGlyphID()), glyph);
122 
123                 if (uncachedGlyphs == null) {
124                     uncachedGlyphs = new ArrayList&lt;XRGlyphCacheEntry&gt;();
125                 }
126                 uncachedGlyphs.add(glyph);
127             }
128             glyph.setLastUsed(time);
129             entries[i] = glyph;
130         }
131 
132         // Add glyphs to cache
133         if (uncachedGlyphs != null) {
134             uploadGlyphs(entries, uncachedGlyphs, glyphList, null);
135         }
136 
137         return entries;
138     }
139 
140     protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList&lt;XRGlyphCacheEntry&gt; uncachedGlyphs, GlyphList gl, int[] glIndices) {
141         for (XRGlyphCacheEntry glyph : uncachedGlyphs) {
142             cachedPixels += glyph.getPixelCnt();
143         }
144 
145         if (cachedPixels &gt; MAX_CACHED_PIXELS) {
146             clearCache(glyphs);
147         }
148 
149         boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);
150         List&lt;XRGlyphCacheEntry&gt;[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);
151         List&lt;XRGlyphCacheEntry&gt; grayGlyphList = seperatedGlyphList[0];
152         List&lt;XRGlyphCacheEntry&gt; lcdGlyphList = seperatedGlyphList[1];
153 
154         /*
155          * Some XServers crash when uploading multiple glyphs at once. TODO:
156          * Implement build-switch in local case for distributors who know their
157          * XServer is fixed
158          */
159         if (batchGlyphUpload) {
160             if (grayGlyphList != null &amp;&amp; grayGlyphList.size() &gt; 0) {
161                 con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));
162             }
163             if (lcdGlyphList != null &amp;&amp; lcdGlyphList.size() &gt; 0) {
164                 con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));
165             }
166         } else {
167             ArrayList&lt;XRGlyphCacheEntry&gt; tmpList = new ArrayList&lt;XRGlyphCacheEntry&gt;(1);
168             tmpList.add(null);
169 
170             for (XRGlyphCacheEntry entry : uncachedGlyphs) {
171                 tmpList.set(0, entry);
172 
173                 if (entry.getGlyphSet() == grayGlyphSet) {
174                     con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));
175                 } else {
176                     con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));
177                 }
178             }
179         }
180     }
181 
182     /**
183      * Seperates lcd and grayscale glyphs queued for upload, and sets the
184      * appropriate glyphset for the cache entries.
185      */
186     protected List&lt;XRGlyphCacheEntry&gt;[] seperateGlyphTypes(List&lt;XRGlyphCacheEntry&gt; glyphList, boolean containsLCDGlyphs) {
187         ArrayList&lt;XRGlyphCacheEntry&gt; lcdGlyphs = null;
188         ArrayList&lt;XRGlyphCacheEntry&gt; grayGlyphs = null;
189 
190         for (XRGlyphCacheEntry cacheEntry : glyphList) {
191             if (cacheEntry.isGrayscale(containsLCDGlyphs)) {
192                 if (grayGlyphs == null) {
193                     grayGlyphs = new ArrayList&lt;&gt;(glyphList.size());
194                 }
195                 cacheEntry.setGlyphSet(grayGlyphSet);
196                 grayGlyphs.add(cacheEntry);
197             } else {
198                 if (lcdGlyphs == null) {
199                     lcdGlyphs = new ArrayList&lt;&gt;(glyphList.size());
200                 }
201                 cacheEntry.setGlyphSet(lcdGlyphSet);
202                 lcdGlyphs.add(cacheEntry);
203             }
204         }
205         // Arrays and generics don&#39;t play well together
206         @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
207         List&lt;XRGlyphCacheEntry&gt;[] tmp =
208             (List&lt;XRGlyphCacheEntry&gt;[]) (new List[] { grayGlyphs, lcdGlyphs });
209         return tmp;
210     }
211 
212     /**
213      * Copies the glyph-images into a continous buffer, required for uploading.
214      */
215     protected byte[] generateGlyphImageStream(List&lt;XRGlyphCacheEntry&gt; glyphList) {
216         boolean isLCDGlyph = glyphList.get(0).getGlyphSet() == lcdGlyphSet;
217 
218         ByteArrayOutputStream stream = new ByteArrayOutputStream((isLCDGlyph ? 4 : 1) * 48 * glyphList.size());
219         for (XRGlyphCacheEntry cacheEntry : glyphList) {
220             cacheEntry.writePixelData(stream, isLCDGlyph);
221         }
222 
223         return stream.toByteArray();
224     }
225 
226     protected boolean containsLCDGlyphs(List&lt;XRGlyphCacheEntry&gt; entries) {
227         boolean containsLCDGlyphs = false;
228 
229         for (XRGlyphCacheEntry entry : entries) {
230             containsLCDGlyphs = !(entry.getSourceRowBytes() == entry.getWidth());
231 
232             if (containsLCDGlyphs) {
233                 return true;
234             }
235         }
236         return false;
237     }
238 
239     protected void clearCache(XRGlyphCacheEntry[] glyps) {
240         /*
241          * Glyph uploading is so slow anyway, we can afford some inefficiency
242          * here, as the cache should usually be quite small. TODO: Implement
243          * something not that stupid ;)
244          */
245         ArrayList&lt;XRGlyphCacheEntry&gt; cacheList = new ArrayList&lt;XRGlyphCacheEntry&gt;(cacheMap.values());
246         Collections.sort(cacheList, new Comparator&lt;XRGlyphCacheEntry&gt;() {
247             public int compare(XRGlyphCacheEntry e1, XRGlyphCacheEntry e2) {
248                 return e2.getLastUsed() - e1.getLastUsed();
249             }
250         });
251 
252         for (XRGlyphCacheEntry glyph : glyps) {
253             glyph.setPinned();
254         }
255 
256         GrowableIntArray deleteGlyphList = new GrowableIntArray(1, 10);
257         int pixelsToRelease = cachedPixels - MAX_CACHED_PIXELS;
258 
259         for (int i = cacheList.size() - 1; i &gt;= 0 &amp;&amp; pixelsToRelease &gt; 0; i--) {
260             XRGlyphCacheEntry entry = cacheList.get(i);
261 
262             if (!entry.isPinned()) {
263                 pixelsToRelease -= entry.getPixelCnt();
264                 deleteGlyphList.addInt(entry.getGlyphID());
265             }
266         }
267 
268         for (XRGlyphCacheEntry glyph : glyps) {
269             glyph.setUnpinned();
270         }
271 
272         freeGlyphs(deleteGlyphList);
273     }
274 
275     private void freeGlyphs(GrowableIntArray glyphIdList) {
276         GrowableIntArray removedLCDGlyphs = new GrowableIntArray(1, 10);
277         GrowableIntArray removedGrayscaleGlyphs = new GrowableIntArray(1, 10);
278 
279         for (int i=0; i &lt; glyphIdList.getSize(); i++) {
280             int glyphId = glyphIdList.getInt(i);
281             freeGlyphIDs.add(glyphId);
282 
283             tmp.setValue(glyphId);
284             XRGlyphCacheEntry entry = cacheMap.get(tmp);
285             cachedPixels -= entry.getPixelCnt();
286             cacheMap.remove(tmp);
287 
288             if (entry.getGlyphSet() == grayGlyphSet) {
289                 removedGrayscaleGlyphs.addInt(glyphId);
290             } else {
291                 removedLCDGlyphs.addInt(glyphId);
292             }
293 
294             entry.setGlyphID(0);
295         }
296 
297         if (removedGrayscaleGlyphs.getSize() &gt; 0) {
298             con.XRenderFreeGlyphs(grayGlyphSet, removedGrayscaleGlyphs.getSizedArray());
299         }
300 
301         if (removedLCDGlyphs.getSize() &gt; 0) {
302             con.XRenderFreeGlyphs(lcdGlyphSet, removedLCDGlyphs.getSizedArray());
303         }
304     }
305 }
    </pre>
  </body>
</html>
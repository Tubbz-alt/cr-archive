<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../awt/X11InputMethodBase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontConfigManager.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/classes/sun/font/FcFontConfiguration.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2014, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 
<span class="line-removed"> 28 import java.awt.Font;</span>
 29 import java.io.File;
 30 import java.io.FileInputStream;
 31 import java.io.FileOutputStream;
 32 import java.io.IOException;
 33 import java.net.InetAddress;
 34 import java.net.UnknownHostException;
 35 import java.nio.charset.Charset;
 36 import java.nio.charset.StandardCharsets;
 37 import java.nio.file.Files;
 38 import java.util.HashMap;
 39 import java.util.HashSet;

 40 import java.util.Properties;
 41 import java.util.Scanner;
 42 import sun.awt.FcFontManager;
 43 import sun.awt.FontConfiguration;
 44 import sun.awt.FontDescriptor;
 45 import sun.awt.SunToolkit;
 46 import sun.font.CompositeFontDescriptor;
<span class="line-removed"> 47 import sun.font.FontManager;</span>
 48 import sun.font.FontConfigManager.FontConfigInfo;
 49 import sun.font.FontConfigManager.FcCompFont;
 50 import sun.font.FontConfigManager.FontConfigFont;
<span class="line-removed"> 51 import sun.java2d.SunGraphicsEnvironment;</span>
 52 import sun.util.logging.PlatformLogger;
 53 
 54 public class FcFontConfiguration extends FontConfiguration {
 55 
 56     /** Version of the cache file format understood by this code.
 57      * Its part of the file name so that we can rev this at
 58      * any time, even in a minor JDK update.
 59      * It is stored as the value of the &quot;version&quot; property.
 60      * This is distinct from the version of &quot;libfontconfig&quot; that generated
 61      * the cached results, and which is the &quot;fcversion&quot; property in the file.
 62      * {@code FontConfiguration.getVersion()} also returns a version string,
 63      * and has meant the version of the fontconfiguration.properties file
 64      * that was read. Since this class doesn&#39;t use such files, then what
 65      * that really means is whether the methods on this class return
 66      * values that are compatible with the classes that do directly read
 67      * from such files. It is a compatible subset of version &quot;1&quot;.
 68      */
 69     private static final String fileVersion = &quot;1&quot;;
 70     private String fcInfoFileName = null;
 71 
</pre>
<hr />
<pre>
247 
248             for (int styleIndex = 0; styleIndex &lt; NUM_STYLES; styleIndex++) {
249 
250                 String faceName = fontName + &quot;.&quot; + styleNames[styleIndex];
251                 FontConfigFont[] fcFonts =
252                     getFcFontList(fcCompFonts,
253                                   fontNames[fontIndex], styleIndex);
254 
255                 int numFonts = fcFonts.length;
256                 // fall back fonts listed in the lib/fonts/fallback directory
257                 if (installedFallbackFontFiles != null) {
258                     numFonts += installedFallbackFontFiles.length;
259                 }
260 
261                 String[] fileNames = new String[numFonts];
262                 String[] faceNames = new String[numFonts];
263 
264                 int index;
265                 for (index = 0; index &lt; fcFonts.length; index++) {
266                     fileNames[index] = fcFonts[index].fontFile;
<span class="line-modified">267                     faceNames[index] = fcFonts[index].familyName;</span>
268                 }
269 
270                 if (installedFallbackFontFiles != null) {
271                     System.arraycopy(installedFallbackFontFiles, 0,
272                                      fileNames, fcFonts.length,
273                                      installedFallbackFontFiles.length);
274                 }
275 
276                 result[fontIndex * NUM_STYLES + styleIndex]
277                         = new CompositeFontDescriptor(
278                             faceName,
279                             1,
280                             faceNames,
281                             fileNames,
282                             null, null);
283             }
284         }
285         return result;
286     }
287 
288     /**
289      * Gets the OS version string from a Linux release-specific file.
290      */
<span class="line-modified">291     private String getVersionString(File f){</span>
<span class="line-modified">292         try {</span>
<span class="line-removed">293             Scanner sc  = new Scanner(f);</span>
294             return sc.findInLine(&quot;(\\d)+((\\.)(\\d)+)*&quot;);
<span class="line-modified">295         }</span>
<span class="line-removed">296         catch (Exception e){</span>
297         }
298         return null;
299     }
300 
301     /**
302      * Sets the OS name and version from environment information.
303      */
304     @Override
305     protected void setOsNameAndVersion() {
306 
307         super.setOsNameAndVersion();
308 
309         if (!osName.equals(&quot;Linux&quot;)) {
310             return;
311         }
312         try {
313             File f;
314             if ((f = new File(&quot;/etc/lsb-release&quot;)).canRead()) {
315                     /* Ubuntu and (perhaps others) use only lsb-release.
316                      * Syntax and encoding is compatible with java properties.
</pre>
<hr />
<pre>
340         }
341     }
342 
343     private File getFcInfoFile() {
344         if (fcInfoFileName == null) {
345             // NB need security permissions to get true IP address, and
346             // we should have those as the whole initialisation is in a
347             // doPrivileged block. But in this case no exception is thrown,
348             // and it returns the loop back address, and so we end up with
349             // &quot;localhost&quot;
350             String hostname;
351             try {
352                 hostname = InetAddress.getLocalHost().getHostName();
353             } catch (UnknownHostException e) {
354                 hostname = &quot;localhost&quot;;
355             }
356             String userDir = System.getProperty(&quot;user.home&quot;);
357             String version = System.getProperty(&quot;java.version&quot;);
358             String fs = File.separator;
359             String dir = userDir+fs+&quot;.java&quot;+fs+&quot;fonts&quot;+fs+version;
<span class="line-modified">360             String lang = SunToolkit.getStartupLocale().getLanguage();</span>


361             String name = &quot;fcinfo-&quot;+fileVersion+&quot;-&quot;+hostname+&quot;-&quot;+
<span class="line-modified">362                 osName+&quot;-&quot;+osVersion+&quot;-&quot;+lang+&quot;.properties&quot;;</span>
363             fcInfoFileName = dir+fs+name;
364         }
365         return new File(fcInfoFileName);
366     }
367 
368     private void writeFcInfo() {
369         Properties props = new Properties();
370         props.setProperty(&quot;version&quot;, fileVersion);
371         FcFontManager fm = (FcFontManager) fontManager;
372         FontConfigManager fcm = fm.getFontConfigManager();
373         FontConfigInfo fcInfo = fcm.getFontConfigInfo();
374         props.setProperty(&quot;fcversion&quot;, Integer.toString(fcInfo.fcVersion));
375         if (fcInfo.cacheDirs != null) {
376             for (int i=0;i&lt;fcInfo.cacheDirs.length;i++) {
377                 if (fcInfo.cacheDirs[i] != null) {
378                    props.setProperty(&quot;cachedir.&quot;+i,  fcInfo.cacheDirs[i]);
379                 }
380             }
381         }
382         for (int i=0; i&lt;fcCompFonts.length; i++) {
383             FcCompFont fci = fcCompFonts[i];
384             String styleKey = fci.jdkName+&quot;.&quot;+fci.style;
385             props.setProperty(styleKey+&quot;.length&quot;,
386                               Integer.toString(fci.allFonts.length));
387             for (int j=0; j&lt;fci.allFonts.length; j++) {
<span class="line-removed">388                 props.setProperty(styleKey+&quot;.&quot;+j+&quot;.family&quot;,</span>
<span class="line-removed">389                                   fci.allFonts[j].familyName);</span>
390                 props.setProperty(styleKey+&quot;.&quot;+j+&quot;.file&quot;,
391                                   fci.allFonts[j].fontFile);




392             }
393         }
394         try {
395             /* This writes into a temp file then renames when done.
396              * Since the rename is an atomic action within the same
397              * directory no client will ever see a partially written file.
398              */
399             File fcInfoFile = getFcInfoFile();
400             File dir = fcInfoFile.getParentFile();
401             dir.mkdirs();
402             File tempFile = Files.createTempFile(dir.toPath(), &quot;fcinfo&quot;, null).toFile();
403             FileOutputStream fos = new FileOutputStream(tempFile);
404             props.store(fos,
405                       &quot;JDK Font Configuration Generated File: *Do Not Edit*&quot;);
406             fos.close();
407             boolean renamed = tempFile.renameTo(fcInfoFile);
408             if (!renamed &amp;&amp; FontUtilities.debugFonts()) {
409                 System.out.println(&quot;rename failed&quot;);
410                 warning(&quot;Failed renaming file to &quot;+ getFcInfoFile());
411             }
412         } catch (Exception e) {
413             if (FontUtilities.debugFonts()) {
414                 warning(&quot;IOException writing to &quot;+ getFcInfoFile());
415             }
416         }
417     }
418 
419     /* We want to be able to use this cache instead of invoking
420      * fontconfig except when we can detect the system cache has changed.
421      * But there doesn&#39;t seem to be a way to find the location of
422      * the system cache.
423      */
424     private void readFcInfo() {
425         File fcFile = getFcInfoFile();
426         if (!fcFile.exists()) {



427             return;
428         }
429         Properties props = new Properties();
<span class="line-modified">430         FcFontManager fm = (FcFontManager) fontManager;</span>
<span class="line-removed">431         FontConfigManager fcm = fm.getFontConfigManager();</span>
<span class="line-removed">432         try {</span>
<span class="line-removed">433             FileInputStream fis = new FileInputStream(fcFile);</span>
434             props.load(fis);
<span class="line-removed">435             fis.close();</span>
436         } catch (IOException e) {
437             if (FontUtilities.debugFonts()) {
<span class="line-modified">438                 warning(&quot;IOException reading from &quot;+fcFile.toString());</span>
439             }
440             return;
441         }
442         String version = (String)props.get(&quot;version&quot;);
443         if (version == null || !version.equals(fileVersion)) {




444             return;
445         }
446 
447         // If there&#39;s a new, different fontconfig installed on the
448         // system, we invalidate our fontconfig file.
449         String fcVersionStr = (String)props.get(&quot;fcversion&quot;);
450         if (fcVersionStr != null) {
451             int fcVersion;
452             try {
453                 fcVersion = Integer.parseInt(fcVersionStr);
454                 if (fcVersion != 0 &amp;&amp;
455                     fcVersion != FontConfigManager.getFontConfigVersion()) {



456                     return;
457                 }
458             } catch (Exception e) {
459                 if (FontUtilities.debugFonts()) {
460                     warning(&quot;Exception parsing version &quot; + fcVersionStr);
461                 }
462                 return;
463             }
464         }
465 
466         // If we can locate the fontconfig cache dirs, then compare the
467         // time stamp of those with our properties file. If we are out
468         // of date then re-generate.
469         long lastModified = fcFile.lastModified();
470         int cacheDirIndex = 0;
471         while (cacheDirIndex&lt;4) { // should never be more than 2 anyway.
472             String dir = (String)props.get(&quot;cachedir.&quot;+cacheDirIndex);
473             if (dir == null) {
474                 break;
475             }
476             File dirFile = new File(dir);
477             if (dirFile.exists() &amp;&amp; dirFile.lastModified() &gt; lastModified) {



478                 return;
479             }
480             cacheDirIndex++;
481         }
482 
483         String[] names = { &quot;sansserif&quot;, &quot;serif&quot;, &quot;monospaced&quot; };
484         String[] fcnames = { &quot;sans&quot;, &quot;serif&quot;, &quot;monospace&quot; };
485         int namesLen = names.length;
486         int numStyles = 4;
487         FcCompFont[] fci = new FcCompFont[namesLen*numStyles];
488 
489         try {
490             for (int i=0; i&lt;namesLen; i++) {
491                 for (int s=0; s&lt;numStyles; s++) {
492                     int index = i*numStyles+s;
493                     fci[index] = new FcCompFont();
494                     String key = names[i]+&quot;.&quot;+s;
495                     fci[index].jdkName = names[i];
496                     fci[index].fcFamily = fcnames[i];
497                     fci[index].style = s;
498                     String lenStr = (String)props.get(key+&quot;.length&quot;);
499                     int nfonts = Integer.parseInt(lenStr);
500                     if (nfonts &lt;= 0) {



501                         return; // bad file
502                     }
503                     fci[index].allFonts = new FontConfigFont[nfonts];
504                     for (int f=0; f&lt;nfonts; f++) {
505                         fci[index].allFonts[f] = new FontConfigFont();
<span class="line-modified">506                         String fkey = key+&quot;.&quot;+f+&quot;.family&quot;;</span>
<span class="line-modified">507                         String family = (String)props.get(fkey);</span>
<span class="line-modified">508                         fci[index].allFonts[f].familyName = family;</span>
509                         fkey = key+&quot;.&quot;+f+&quot;.file&quot;;
510                         String file = (String)props.get(fkey);
511                         if (file == null) {



512                             return; // bad file
513                         }
514                         fci[index].allFonts[f].fontFile = file;
515                     }
516                     fci[index].firstFont =  fci[index].allFonts[0];
517 
518                 }
519             }
520             fcCompFonts = fci;
521         } catch (Throwable t) {
522             if (FontUtilities.debugFonts()) {
523                 warning(t.toString());
524             }
525         }





526     }
527 
528     private static void warning(String msg) {
529         PlatformLogger logger = PlatformLogger.getLogger(&quot;sun.awt.FontConfiguration&quot;);
530         logger.warning(msg);
531     }
532 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2008, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.font;
 27 

 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.FileOutputStream;
 31 import java.io.IOException;
 32 import java.net.InetAddress;
 33 import java.net.UnknownHostException;
 34 import java.nio.charset.Charset;
 35 import java.nio.charset.StandardCharsets;
 36 import java.nio.file.Files;
 37 import java.util.HashMap;
 38 import java.util.HashSet;
<span class="line-added"> 39 import java.util.Locale;</span>
 40 import java.util.Properties;
 41 import java.util.Scanner;
 42 import sun.awt.FcFontManager;
 43 import sun.awt.FontConfiguration;
 44 import sun.awt.FontDescriptor;
 45 import sun.awt.SunToolkit;
 46 import sun.font.CompositeFontDescriptor;

 47 import sun.font.FontConfigManager.FontConfigInfo;
 48 import sun.font.FontConfigManager.FcCompFont;
 49 import sun.font.FontConfigManager.FontConfigFont;

 50 import sun.util.logging.PlatformLogger;
 51 
 52 public class FcFontConfiguration extends FontConfiguration {
 53 
 54     /** Version of the cache file format understood by this code.
 55      * Its part of the file name so that we can rev this at
 56      * any time, even in a minor JDK update.
 57      * It is stored as the value of the &quot;version&quot; property.
 58      * This is distinct from the version of &quot;libfontconfig&quot; that generated
 59      * the cached results, and which is the &quot;fcversion&quot; property in the file.
 60      * {@code FontConfiguration.getVersion()} also returns a version string,
 61      * and has meant the version of the fontconfiguration.properties file
 62      * that was read. Since this class doesn&#39;t use such files, then what
 63      * that really means is whether the methods on this class return
 64      * values that are compatible with the classes that do directly read
 65      * from such files. It is a compatible subset of version &quot;1&quot;.
 66      */
 67     private static final String fileVersion = &quot;1&quot;;
 68     private String fcInfoFileName = null;
 69 
</pre>
<hr />
<pre>
245 
246             for (int styleIndex = 0; styleIndex &lt; NUM_STYLES; styleIndex++) {
247 
248                 String faceName = fontName + &quot;.&quot; + styleNames[styleIndex];
249                 FontConfigFont[] fcFonts =
250                     getFcFontList(fcCompFonts,
251                                   fontNames[fontIndex], styleIndex);
252 
253                 int numFonts = fcFonts.length;
254                 // fall back fonts listed in the lib/fonts/fallback directory
255                 if (installedFallbackFontFiles != null) {
256                     numFonts += installedFallbackFontFiles.length;
257                 }
258 
259                 String[] fileNames = new String[numFonts];
260                 String[] faceNames = new String[numFonts];
261 
262                 int index;
263                 for (index = 0; index &lt; fcFonts.length; index++) {
264                     fileNames[index] = fcFonts[index].fontFile;
<span class="line-modified">265                     faceNames[index] = fcFonts[index].fullName;</span>
266                 }
267 
268                 if (installedFallbackFontFiles != null) {
269                     System.arraycopy(installedFallbackFontFiles, 0,
270                                      fileNames, fcFonts.length,
271                                      installedFallbackFontFiles.length);
272                 }
273 
274                 result[fontIndex * NUM_STYLES + styleIndex]
275                         = new CompositeFontDescriptor(
276                             faceName,
277                             1,
278                             faceNames,
279                             fileNames,
280                             null, null);
281             }
282         }
283         return result;
284     }
285 
286     /**
287      * Gets the OS version string from a Linux release-specific file.
288      */
<span class="line-modified">289     private String getVersionString(File f) {</span>
<span class="line-modified">290         try (Scanner sc  = new Scanner(f)) {</span>

291             return sc.findInLine(&quot;(\\d)+((\\.)(\\d)+)*&quot;);
<span class="line-modified">292         } catch (Exception e) {</span>

293         }
294         return null;
295     }
296 
297     /**
298      * Sets the OS name and version from environment information.
299      */
300     @Override
301     protected void setOsNameAndVersion() {
302 
303         super.setOsNameAndVersion();
304 
305         if (!osName.equals(&quot;Linux&quot;)) {
306             return;
307         }
308         try {
309             File f;
310             if ((f = new File(&quot;/etc/lsb-release&quot;)).canRead()) {
311                     /* Ubuntu and (perhaps others) use only lsb-release.
312                      * Syntax and encoding is compatible with java properties.
</pre>
<hr />
<pre>
336         }
337     }
338 
339     private File getFcInfoFile() {
340         if (fcInfoFileName == null) {
341             // NB need security permissions to get true IP address, and
342             // we should have those as the whole initialisation is in a
343             // doPrivileged block. But in this case no exception is thrown,
344             // and it returns the loop back address, and so we end up with
345             // &quot;localhost&quot;
346             String hostname;
347             try {
348                 hostname = InetAddress.getLocalHost().getHostName();
349             } catch (UnknownHostException e) {
350                 hostname = &quot;localhost&quot;;
351             }
352             String userDir = System.getProperty(&quot;user.home&quot;);
353             String version = System.getProperty(&quot;java.version&quot;);
354             String fs = File.separator;
355             String dir = userDir+fs+&quot;.java&quot;+fs+&quot;fonts&quot;+fs+version;
<span class="line-modified">356             Locale locale = SunToolkit.getStartupLocale();</span>
<span class="line-added">357             String lang = locale.getLanguage();</span>
<span class="line-added">358             String country = locale.getCountry();</span>
359             String name = &quot;fcinfo-&quot;+fileVersion+&quot;-&quot;+hostname+&quot;-&quot;+
<span class="line-modified">360                 osName+&quot;-&quot;+osVersion+&quot;-&quot;+lang+&quot;-&quot;+country+&quot;.properties&quot;;</span>
361             fcInfoFileName = dir+fs+name;
362         }
363         return new File(fcInfoFileName);
364     }
365 
366     private void writeFcInfo() {
367         Properties props = new Properties();
368         props.setProperty(&quot;version&quot;, fileVersion);
369         FcFontManager fm = (FcFontManager) fontManager;
370         FontConfigManager fcm = fm.getFontConfigManager();
371         FontConfigInfo fcInfo = fcm.getFontConfigInfo();
372         props.setProperty(&quot;fcversion&quot;, Integer.toString(fcInfo.fcVersion));
373         if (fcInfo.cacheDirs != null) {
374             for (int i=0;i&lt;fcInfo.cacheDirs.length;i++) {
375                 if (fcInfo.cacheDirs[i] != null) {
376                    props.setProperty(&quot;cachedir.&quot;+i,  fcInfo.cacheDirs[i]);
377                 }
378             }
379         }
380         for (int i=0; i&lt;fcCompFonts.length; i++) {
381             FcCompFont fci = fcCompFonts[i];
382             String styleKey = fci.jdkName+&quot;.&quot;+fci.style;
383             props.setProperty(styleKey+&quot;.length&quot;,
384                               Integer.toString(fci.allFonts.length));
385             for (int j=0; j&lt;fci.allFonts.length; j++) {


386                 props.setProperty(styleKey+&quot;.&quot;+j+&quot;.file&quot;,
387                                   fci.allFonts[j].fontFile);
<span class="line-added">388                 if (fci.allFonts[j].fullName != null) {</span>
<span class="line-added">389                     props.setProperty(styleKey+&quot;.&quot;+j+&quot;.fullName&quot;,</span>
<span class="line-added">390                                       fci.allFonts[j].fullName);</span>
<span class="line-added">391                 }</span>
392             }
393         }
394         try {
395             /* This writes into a temp file then renames when done.
396              * Since the rename is an atomic action within the same
397              * directory no client will ever see a partially written file.
398              */
399             File fcInfoFile = getFcInfoFile();
400             File dir = fcInfoFile.getParentFile();
401             dir.mkdirs();
402             File tempFile = Files.createTempFile(dir.toPath(), &quot;fcinfo&quot;, null).toFile();
403             FileOutputStream fos = new FileOutputStream(tempFile);
404             props.store(fos,
405                       &quot;JDK Font Configuration Generated File: *Do Not Edit*&quot;);
406             fos.close();
407             boolean renamed = tempFile.renameTo(fcInfoFile);
408             if (!renamed &amp;&amp; FontUtilities.debugFonts()) {
409                 System.out.println(&quot;rename failed&quot;);
410                 warning(&quot;Failed renaming file to &quot;+ getFcInfoFile());
411             }
412         } catch (Exception e) {
413             if (FontUtilities.debugFonts()) {
414                 warning(&quot;IOException writing to &quot;+ getFcInfoFile());
415             }
416         }
417     }
418 
419     /* We want to be able to use this cache instead of invoking
420      * fontconfig except when we can detect the system cache has changed.
421      * But there doesn&#39;t seem to be a way to find the location of
422      * the system cache.
423      */
424     private void readFcInfo() {
425         File fcFile = getFcInfoFile();
426         if (!fcFile.exists()) {
<span class="line-added">427             if (FontUtilities.debugFonts()) {</span>
<span class="line-added">428                 warning(&quot;fontconfig info file &quot; + fcFile.toString() + &quot; does not exist&quot;);</span>
<span class="line-added">429             }</span>
430             return;
431         }
432         Properties props = new Properties();
<span class="line-modified">433         try (FileInputStream fis = new FileInputStream(fcFile)) {</span>



434             props.load(fis);

435         } catch (IOException e) {
436             if (FontUtilities.debugFonts()) {
<span class="line-modified">437                 warning(&quot;IOException (&quot; + e.getCause() + &quot;) reading from &quot; + fcFile.toString());</span>
438             }
439             return;
440         }
441         String version = (String)props.get(&quot;version&quot;);
442         if (version == null || !version.equals(fileVersion)) {
<span class="line-added">443             if (FontUtilities.debugFonts()) {</span>
<span class="line-added">444                 warning(&quot;fontconfig info file version mismatch (found: &quot; + version +</span>
<span class="line-added">445                     &quot;, expected: &quot; + fileVersion + &quot;)&quot;);</span>
<span class="line-added">446             }</span>
447             return;
448         }
449 
450         // If there&#39;s a new, different fontconfig installed on the
451         // system, we invalidate our fontconfig file.
452         String fcVersionStr = (String)props.get(&quot;fcversion&quot;);
453         if (fcVersionStr != null) {
454             int fcVersion;
455             try {
456                 fcVersion = Integer.parseInt(fcVersionStr);
457                 if (fcVersion != 0 &amp;&amp;
458                     fcVersion != FontConfigManager.getFontConfigVersion()) {
<span class="line-added">459                     if (FontUtilities.debugFonts()) {</span>
<span class="line-added">460                         warning(&quot;new, different fontconfig detected&quot;);</span>
<span class="line-added">461                     }</span>
462                     return;
463                 }
464             } catch (Exception e) {
465                 if (FontUtilities.debugFonts()) {
466                     warning(&quot;Exception parsing version &quot; + fcVersionStr);
467                 }
468                 return;
469             }
470         }
471 
472         // If we can locate the fontconfig cache dirs, then compare the
473         // time stamp of those with our properties file. If we are out
474         // of date then re-generate.
475         long lastModified = fcFile.lastModified();
476         int cacheDirIndex = 0;
477         while (cacheDirIndex&lt;4) { // should never be more than 2 anyway.
478             String dir = (String)props.get(&quot;cachedir.&quot;+cacheDirIndex);
479             if (dir == null) {
480                 break;
481             }
482             File dirFile = new File(dir);
483             if (dirFile.exists() &amp;&amp; dirFile.lastModified() &gt; lastModified) {
<span class="line-added">484                 if (FontUtilities.debugFonts()) {</span>
<span class="line-added">485                     warning(&quot;out of date cache directories detected&quot;);</span>
<span class="line-added">486                 }</span>
487                 return;
488             }
489             cacheDirIndex++;
490         }
491 
492         String[] names = { &quot;sansserif&quot;, &quot;serif&quot;, &quot;monospaced&quot; };
493         String[] fcnames = { &quot;sans&quot;, &quot;serif&quot;, &quot;monospace&quot; };
494         int namesLen = names.length;
495         int numStyles = 4;
496         FcCompFont[] fci = new FcCompFont[namesLen*numStyles];
497 
498         try {
499             for (int i=0; i&lt;namesLen; i++) {
500                 for (int s=0; s&lt;numStyles; s++) {
501                     int index = i*numStyles+s;
502                     fci[index] = new FcCompFont();
503                     String key = names[i]+&quot;.&quot;+s;
504                     fci[index].jdkName = names[i];
505                     fci[index].fcFamily = fcnames[i];
506                     fci[index].style = s;
507                     String lenStr = (String)props.get(key+&quot;.length&quot;);
508                     int nfonts = Integer.parseInt(lenStr);
509                     if (nfonts &lt;= 0) {
<span class="line-added">510                         if (FontUtilities.debugFonts()) {</span>
<span class="line-added">511                             warning(&quot;bad non-positive .length entry in fontconfig file &quot; + fcFile.toString());</span>
<span class="line-added">512                         }</span>
513                         return; // bad file
514                     }
515                     fci[index].allFonts = new FontConfigFont[nfonts];
516                     for (int f=0; f&lt;nfonts; f++) {
517                         fci[index].allFonts[f] = new FontConfigFont();
<span class="line-modified">518                         String fkey = key+&quot;.&quot;+f+&quot;.fullName&quot;;</span>
<span class="line-modified">519                         String fullName = (String)props.get(fkey);</span>
<span class="line-modified">520                         fci[index].allFonts[f].fullName = fullName;</span>
521                         fkey = key+&quot;.&quot;+f+&quot;.file&quot;;
522                         String file = (String)props.get(fkey);
523                         if (file == null) {
<span class="line-added">524                             if (FontUtilities.debugFonts()) {</span>
<span class="line-added">525                                 warning(&quot;missing file value for key &quot; + fkey + &quot; in fontconfig file &quot; + fcFile.toString());</span>
<span class="line-added">526                             }</span>
527                             return; // bad file
528                         }
529                         fci[index].allFonts[f].fontFile = file;
530                     }
531                     fci[index].firstFont =  fci[index].allFonts[0];
532 
533                 }
534             }
535             fcCompFonts = fci;
536         } catch (Throwable t) {
537             if (FontUtilities.debugFonts()) {
538                 warning(t.toString());
539             }
540         }
<span class="line-added">541 </span>
<span class="line-added">542         if (FontUtilities.debugFonts()) {</span>
<span class="line-added">543             PlatformLogger logger = FontUtilities.getLogger();</span>
<span class="line-added">544             logger.info(&quot;successfully parsed the fontconfig file at &quot; + fcFile.toString());</span>
<span class="line-added">545         }</span>
546     }
547 
548     private static void warning(String msg) {
549         PlatformLogger logger = PlatformLogger.getLogger(&quot;sun.awt.FontConfiguration&quot;);
550         logger.warning(msg);
551     }
552 }
</pre>
</td>
</tr>
</table>
<center><a href="../awt/X11InputMethodBase.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="FontConfigManager.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
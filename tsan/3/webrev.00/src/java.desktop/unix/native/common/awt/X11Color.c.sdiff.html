<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/native/common/awt/X11Color.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../classes/sun/print/UnixPrintService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Font.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/common/awt/X11Color.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2014, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 319         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].r = col.red   &gt;&gt; 8;
 320         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].g = col.green &gt;&gt; 8;
 321         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].b = col.blue  &gt;&gt; 8;
 322         if (awt_data-&gt;color_data-&gt;awt_icmLUT != 0) {
 323             awt_data-&gt;color_data-&gt;awt_icmLUT2Colors[col.pixel] = col.pixel;
 324             awt_data-&gt;color_data-&gt;awt_icmLUT[col.pixel] =
 325                 0xff000000 |
 326                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].r&lt;&lt;16) |
 327                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].g&lt;&lt;8) |
 328                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].b);
 329         }
 330         return col.pixel;
 331 #ifdef DEBUG
 332     } else if (debug_colormap) {
 333         jio_fprintf(stdout, &quot;can&#39;t allocate (%d,%d, %d)\n&quot;, r, g, b);
 334 #endif
 335     }
 336 
 337     return awt_color_match(r, g, b, awt_data);
 338 }
<span class="line-removed"> 339 </span>
<span class="line-removed"> 340 void</span>
<span class="line-removed"> 341 awt_allocate_systemcolors(XColor *colorsPtr, int num_pixels, AwtGraphicsConfigDataPtr awtData) {</span>
<span class="line-removed"> 342     int i;</span>
<span class="line-removed"> 343     int r, g, b, pixel;</span>
<span class="line-removed"> 344 </span>
<span class="line-removed"> 345     for (i=0; i &lt; num_pixels; i++) {</span>
<span class="line-removed"> 346         r = colorsPtr[i].red   &gt;&gt; 8;</span>
<span class="line-removed"> 347         g = colorsPtr[i].green &gt;&gt; 8;</span>
<span class="line-removed"> 348         b = colorsPtr[i].blue  &gt;&gt; 8;</span>
<span class="line-removed"> 349         pixel = alloc_col(awt_display, awtData-&gt;awt_cmap, r, g, b, -1, awtData);</span>
<span class="line-removed"> 350     }</span>
<span class="line-removed"> 351 }</span>
 352 #endif /* !HEADLESS */
 353 
 354 void
 355 awt_fill_imgcv(ImgConvertFcn **array, int mask, int value, ImgConvertFcn fcn)
 356 {
 357     int i;
 358 
 359     for (i = 0; i &lt; NUM_IMGCV; i++) {
 360         if ((i &amp; mask) == value) {
 361             array[i] = fcn;
 362         }
 363     }
 364 }
 365 
 366 #ifndef HEADLESS
 367 /*
 368  * called from X11Server_create() in xlib.c
 369  */
 370 int
 371 awt_allocate_colors(AwtGraphicsConfigDataPtr awt_data)
</pre>
<hr />
<pre>
 385     char *forcemono;
 386     char *forcegray;
 387 
 388     make_uns_ordered_dither_array(img_oda_alpha, 256);
 389 
 390 
 391     forcemono = getenv(&quot;FORCEMONO&quot;);
 392     forcegray = getenv(&quot;FORCEGRAY&quot;);
 393     if (forcemono &amp;&amp; !forcegray)
 394         forcegray = forcemono;
 395 
 396     /*
 397      * Get the colormap and make sure we have the right visual
 398      */
 399     dpy = awt_display;
 400     cm = awt_data-&gt;awt_cmap;
 401     depth = awt_data-&gt;awt_depth;
 402     pVI = &amp;awt_data-&gt;awt_visInfo;
 403     awt_data-&gt;awt_num_colors = awt_data-&gt;awt_visInfo.colormap_size;
 404     awt_data-&gt;awtImage = (awtImageData *) calloc (1, sizeof (awtImageData));



 405 
 406     pPFV = XListPixmapFormats(dpy, &amp;numpfv);
 407     if (pPFV) {
 408         for (i = 0; i &lt; numpfv; i++) {
 409             if (pPFV[i].depth == depth) {
 410                 awt_data-&gt;awtImage-&gt;wsImageFormat = pPFV[i];
 411                 break;
 412             }
 413         }
 414         XFree(pPFV);
 415     }
 416     bpp = awt_data-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel;
 417     if (bpp == 24) {
 418         bpp = 32;
 419     }
 420     awt_data-&gt;awtImage-&gt;clrdata.bitsperpixel = bpp;
 421     awt_data-&gt;awtImage-&gt;Depth = depth;
 422 
 423     if ((bpp == 32 || bpp == 16) &amp;&amp; pVI-&gt;class == TrueColor &amp;&amp; depth &gt;= 15) {
 424         awt_data-&gt;AwtColorMatch = awt_color_matchTC;
</pre>
<hr />
<pre>
 555                        (IMGCV_UNSCALED | IMGCV_INTIN | IMGCV_OPAQUE
 556                         | IMGCV_RANDORDER | IMGCV_DCM8),
 557                        OrdColorDcmOpqUnsImageConvert);
 558 #endif /* NEED_IMAGE_CONVERT */
 559     } else {
 560         free (awt_data-&gt;awtImage);
 561         return 0;
 562     }
 563 
 564     if (depth &gt; 12) {
 565         return 1;
 566     }
 567 
 568     if (depth == 12) {
 569         paletteSize = MAX_PALETTE12_SIZE;
 570     } else {
 571         paletteSize = MAX_PALETTE8_SIZE;
 572     }
 573 
 574     if (awt_data-&gt;awt_num_colors &gt; paletteSize) {
<span class="line-modified"> 575         free (awt_data-&gt;awtImage);</span>
 576         return 0;
 577     }
 578 
 579     /* Allocate ColorData structure */
 580     awt_data-&gt;color_data = ZALLOC (_ColorData);





 581     awt_data-&gt;color_data-&gt;screendata = 1; /* This ColorData struct corresponds
 582                                              to some AWT screen/visual, so when
 583                                              any IndexColorModel using this
 584                                              struct is finalized, don&#39;t free
 585                                              the struct in freeICMColorData.
 586                                            */
 587 
 588     /*
 589      * Initialize colors array
 590      */
 591     for (i = 0; i &lt; awt_data-&gt;awt_num_colors; i++) {
 592         cols[i].pixel = i;
 593     }
 594 
 595     awt_data-&gt;color_data-&gt;awt_Colors =
 596         (ColorEntry *)calloc(paletteSize, sizeof (ColorEntry));





 597 
 598     XQueryColors(dpy, cm, cols, awt_data-&gt;awt_num_colors);
 599     for (i = 0; i &lt; awt_data-&gt;awt_num_colors; i++) {
 600         awt_data-&gt;color_data-&gt;awt_Colors[i].r = cols[i].red &gt;&gt; 8;
 601         awt_data-&gt;color_data-&gt;awt_Colors[i].g = cols[i].green &gt;&gt; 8;
 602         awt_data-&gt;color_data-&gt;awt_Colors[i].b = cols[i].blue &gt;&gt; 8;
 603         awt_data-&gt;color_data-&gt;awt_Colors[i].flags = LIKELY_COLOR;
 604     }
 605 
 606     /*
 607      * Determine which colors in the colormap can be allocated and mark
 608      * them in the colors array
 609      */
 610     nfree = 0;
 611     for (i = (paletteSize / 2); i &gt; 0; i &gt;&gt;= 1) {
 612         if (XAllocColorCells(dpy, cm, False, plane_masks, 0,
 613                              freecolors + nfree, i)) {
 614             nfree += i;
 615         }
 616     }
</pre>
<hr />
<pre>
 650      * Allocate more colors, filling the color space evenly.
 651      */
 652 
 653     alloc_col(dpy, cm, 255, 255, 255, -1, awt_data);
 654     alloc_col(dpy, cm, 0, 0, 0, -1, awt_data);
 655 
 656     if (awt_data-&gt;awtImage-&gt;clrdata.grayscale) {
 657         int g;
 658         ColorEntry *p;
 659 
 660         if (!forcemono) {
 661             for (i = 128; i &gt; 0; i &gt;&gt;= 1) {
 662                 for (g = i; g &lt; 256; g += (i * 2)) {
 663                     alloc_col(dpy, cm, g, g, g, -1, awt_data);
 664                 }
 665             }
 666         }
 667 
 668         awt_data-&gt;color_data-&gt;img_grays =
 669             (unsigned char *)calloc(256, sizeof(unsigned char));





 670         for (g = 0; g &lt; 256; g++) {
 671             int mindist, besti;
 672             int d;
 673 
 674             p = awt_data-&gt;color_data-&gt;awt_Colors;
 675             mindist = 256;
 676             besti = 0;
 677             for (i = 0 ; i &lt; awt_data-&gt;awt_num_colors ; i++, p++) {
 678                 if (forcegray &amp;&amp; (p-&gt;r != p-&gt;g || p-&gt;g != p-&gt;b))
 679                     continue;
 680                 if (forcemono &amp;&amp; p-&gt;g != 0 &amp;&amp; p-&gt;g != 255)
 681                     continue;
 682                 if (p-&gt;flags == ALLOCATED_COLOR) {
 683                     d = p-&gt;g - g;
 684                     if (d &lt; 0) d = -d;
 685                     if (d &lt; mindist) {
 686                         besti = i;
 687                         if (d == 0) {
 688                             break;
 689                         }
</pre>
<hr />
<pre>
 793         if (cmapsize &gt; CMAP_ALLOC_MAX) {
 794             cmapsize = CMAP_ALLOC_MAX;
 795         }
 796 
 797         if (cmapsize &lt; allocatedColorsNum) {
 798             cmapsize = allocatedColorsNum;
 799         }
 800         cmapsize -= unavailableColorsNum;
 801     }
 802 
 803     k = 0;
 804     if (getenv(&quot;VIRTCUBESIZE&quot;) != 0) {
 805         k = atoi(getenv(&quot;VIRTCUBESIZE&quot;));
 806     }
 807     if (k == 0 || (k &amp; (k - 1)) != 0 || k &gt; 32) {
 808         k = getVirtCubeSize();
 809     }
 810     awt_data-&gt;color_data-&gt;img_clr_tbl =
 811         (unsigned char *)calloc(LOOKUPSIZE * LOOKUPSIZE * LOOKUPSIZE,
 812                                 sizeof(unsigned char));





 813     img_makePalette(cmapsize, k, LOOKUPSIZE, 50, 250,
 814                     allocatedColorsNum, TRUE, reds, greens, blues,
 815                     awt_data-&gt;color_data-&gt;img_clr_tbl);
 816                     /*img_clr_tbl);*/
 817 
 818     for (i = 0; i &lt; cmapsize; i++) {
 819         indices[i] = alloc_col(dpy, cm, reds[i], greens[i], blues[i], -1,
 820                                awt_data);
 821     }
 822     for (i = 0; i &lt; LOOKUPSIZE * LOOKUPSIZE * LOOKUPSIZE  ; i++) {
 823         awt_data-&gt;color_data-&gt;img_clr_tbl[i] =
 824             indices[awt_data-&gt;color_data-&gt;img_clr_tbl[i]];
 825     }
 826 
 827     awt_data-&gt;color_data-&gt;img_oda_red   = &amp;(std_img_oda_red[0][0]);
 828     awt_data-&gt;color_data-&gt;img_oda_green = &amp;(std_img_oda_green[0][0]);
 829     awt_data-&gt;color_data-&gt;img_oda_blue  = &amp;(std_img_oda_blue[0][0]);
 830     make_dither_arrays(cmapsize, awt_data-&gt;color_data);
 831     std_odas_computed = 1;
 832 
</pre>
<hr />
<pre>
 841                 alloc_count++;
 842                 break;
 843               case LIKELY_COLOR:
 844                 reuse_count++;
 845                 break;
 846               case FREE_COLOR:
 847                 free_count++;
 848                 break;
 849             }
 850         }
 851         jio_fprintf(stdout, &quot;%d total, %d allocated, %d reused, %d still free.\n&quot;,
 852                     awt_data-&gt;awt_num_colors, alloc_count, reuse_count, free_count);
 853     }
 854 #endif
 855 
 856     /* Fill in the ICM lut and lut2cmap mapping */
 857     awt_data-&gt;color_data-&gt;awt_numICMcolors = 0;
 858     awt_data-&gt;color_data-&gt;awt_icmLUT2Colors =
 859         (unsigned char *)calloc(paletteSize, sizeof (unsigned char));
 860     awt_data-&gt;color_data-&gt;awt_icmLUT = (int *)calloc(paletteSize, sizeof(int));






 861     for (i=0; i &lt; paletteSize; i++) {
 862         /* Keep the mapping between this lut and the actual cmap */
 863         awt_data-&gt;color_data-&gt;awt_icmLUT2Colors
 864             [awt_data-&gt;color_data-&gt;awt_numICMcolors] = i;
 865 
 866         if (awt_data-&gt;color_data-&gt;awt_Colors[i].flags == ALLOCATED_COLOR) {
 867             /* Screen IndexColorModel LUTS are always xRGB */
 868             awt_data-&gt;color_data-&gt;awt_icmLUT
 869                     [awt_data-&gt;color_data-&gt;awt_numICMcolors++] = 0xff000000 |
 870                 (awt_data-&gt;color_data-&gt;awt_Colors[i].r&lt;&lt;16) |
 871                 (awt_data-&gt;color_data-&gt;awt_Colors[i].g&lt;&lt;8) |
 872                 (awt_data-&gt;color_data-&gt;awt_Colors[i].b);
 873         } else {
 874             /* Screen IndexColorModel LUTS are always xRGB */
 875             awt_data-&gt;color_data-&gt;awt_icmLUT
 876                         [awt_data-&gt;color_data-&gt;awt_numICMcolors++] = 0;
 877         }
 878     }
 879     return 1;
 880 }
</pre>
<hr />
<pre>
1230 
1231         if (awt_colormodel == NULL)
1232         {
1233             (*env)-&gt;PopLocalFrame(env, 0);
1234             return NULL;
1235         }
1236 
1237         /* Set pData field of ColorModel to point to ColorData */
1238         JNU_SetLongFieldFromPtr(env, awt_colormodel, g_CMpDataID,
1239                                 aData-&gt;color_data);
1240 
1241     }
1242 
1243     return (*env)-&gt;PopLocalFrame(env, awt_colormodel);
1244 }
1245 #endif /* !HEADLESS */
1246 
1247 extern jfieldID colorValueID;
1248 
1249 #ifndef HEADLESS
<span class="line-removed">1250 int awtJNI_GetColor(JNIEnv *env,jobject this)</span>
<span class="line-removed">1251 {</span>
<span class="line-removed">1252     /* REMIND: should not be defaultConfig. */</span>
<span class="line-removed">1253     return awtJNI_GetColorForVis (env, this, getDefaultConfig(DefaultScreen(awt_display)));</span>
<span class="line-removed">1254 }</span>
<span class="line-removed">1255 </span>
1256 int awtJNI_GetColorForVis (JNIEnv *env,jobject this, AwtGraphicsConfigDataPtr awt_data)
1257 {
1258     int col;
1259     jclass SYSCLR_class;
1260 
1261     if (!JNU_IsNull(env,this))
1262     {
1263         SYSCLR_class = (*env)-&gt;FindClass(env, &quot;java/awt/SystemColor&quot;);
1264         CHECK_NULL_RETURN(SYSCLR_class, 0);
1265 
1266         if ((*env)-&gt;IsInstanceOf(env, this, SYSCLR_class)) {
1267                 /* SECURITY: This is safe, because there is no way
1268                  *           for client code to insert an object
1269                  *           that is a subclass of SystemColor
1270                  */
1271                 col = (int) JNU_CallMethodByName(env
1272                                           ,NULL
1273                                           ,this
1274                                           ,&quot;getRGB&quot;
1275                                           ,&quot;()I&quot;).i;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 319         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].r = col.red   &gt;&gt; 8;
 320         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].g = col.green &gt;&gt; 8;
 321         awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].b = col.blue  &gt;&gt; 8;
 322         if (awt_data-&gt;color_data-&gt;awt_icmLUT != 0) {
 323             awt_data-&gt;color_data-&gt;awt_icmLUT2Colors[col.pixel] = col.pixel;
 324             awt_data-&gt;color_data-&gt;awt_icmLUT[col.pixel] =
 325                 0xff000000 |
 326                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].r&lt;&lt;16) |
 327                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].g&lt;&lt;8) |
 328                 (awt_data-&gt;color_data-&gt;awt_Colors[col.pixel].b);
 329         }
 330         return col.pixel;
 331 #ifdef DEBUG
 332     } else if (debug_colormap) {
 333         jio_fprintf(stdout, &quot;can&#39;t allocate (%d,%d, %d)\n&quot;, r, g, b);
 334 #endif
 335     }
 336 
 337     return awt_color_match(r, g, b, awt_data);
 338 }













 339 #endif /* !HEADLESS */
 340 
 341 void
 342 awt_fill_imgcv(ImgConvertFcn **array, int mask, int value, ImgConvertFcn fcn)
 343 {
 344     int i;
 345 
 346     for (i = 0; i &lt; NUM_IMGCV; i++) {
 347         if ((i &amp; mask) == value) {
 348             array[i] = fcn;
 349         }
 350     }
 351 }
 352 
 353 #ifndef HEADLESS
 354 /*
 355  * called from X11Server_create() in xlib.c
 356  */
 357 int
 358 awt_allocate_colors(AwtGraphicsConfigDataPtr awt_data)
</pre>
<hr />
<pre>
 372     char *forcemono;
 373     char *forcegray;
 374 
 375     make_uns_ordered_dither_array(img_oda_alpha, 256);
 376 
 377 
 378     forcemono = getenv(&quot;FORCEMONO&quot;);
 379     forcegray = getenv(&quot;FORCEGRAY&quot;);
 380     if (forcemono &amp;&amp; !forcegray)
 381         forcegray = forcemono;
 382 
 383     /*
 384      * Get the colormap and make sure we have the right visual
 385      */
 386     dpy = awt_display;
 387     cm = awt_data-&gt;awt_cmap;
 388     depth = awt_data-&gt;awt_depth;
 389     pVI = &amp;awt_data-&gt;awt_visInfo;
 390     awt_data-&gt;awt_num_colors = awt_data-&gt;awt_visInfo.colormap_size;
 391     awt_data-&gt;awtImage = (awtImageData *) calloc (1, sizeof (awtImageData));
<span class="line-added"> 392     if (awt_data-&gt;awtImage == NULL) {</span>
<span class="line-added"> 393         return 0;</span>
<span class="line-added"> 394     }</span>
 395 
 396     pPFV = XListPixmapFormats(dpy, &amp;numpfv);
 397     if (pPFV) {
 398         for (i = 0; i &lt; numpfv; i++) {
 399             if (pPFV[i].depth == depth) {
 400                 awt_data-&gt;awtImage-&gt;wsImageFormat = pPFV[i];
 401                 break;
 402             }
 403         }
 404         XFree(pPFV);
 405     }
 406     bpp = awt_data-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel;
 407     if (bpp == 24) {
 408         bpp = 32;
 409     }
 410     awt_data-&gt;awtImage-&gt;clrdata.bitsperpixel = bpp;
 411     awt_data-&gt;awtImage-&gt;Depth = depth;
 412 
 413     if ((bpp == 32 || bpp == 16) &amp;&amp; pVI-&gt;class == TrueColor &amp;&amp; depth &gt;= 15) {
 414         awt_data-&gt;AwtColorMatch = awt_color_matchTC;
</pre>
<hr />
<pre>
 545                        (IMGCV_UNSCALED | IMGCV_INTIN | IMGCV_OPAQUE
 546                         | IMGCV_RANDORDER | IMGCV_DCM8),
 547                        OrdColorDcmOpqUnsImageConvert);
 548 #endif /* NEED_IMAGE_CONVERT */
 549     } else {
 550         free (awt_data-&gt;awtImage);
 551         return 0;
 552     }
 553 
 554     if (depth &gt; 12) {
 555         return 1;
 556     }
 557 
 558     if (depth == 12) {
 559         paletteSize = MAX_PALETTE12_SIZE;
 560     } else {
 561         paletteSize = MAX_PALETTE8_SIZE;
 562     }
 563 
 564     if (awt_data-&gt;awt_num_colors &gt; paletteSize) {
<span class="line-modified"> 565         free(awt_data-&gt;awtImage);</span>
 566         return 0;
 567     }
 568 
 569     /* Allocate ColorData structure */
 570     awt_data-&gt;color_data = ZALLOC (_ColorData);
<span class="line-added"> 571     if (awt_data-&gt;color_data == NULL) {</span>
<span class="line-added"> 572         free(awt_data-&gt;awtImage);</span>
<span class="line-added"> 573         return 0;</span>
<span class="line-added"> 574     }</span>
<span class="line-added"> 575 </span>
 576     awt_data-&gt;color_data-&gt;screendata = 1; /* This ColorData struct corresponds
 577                                              to some AWT screen/visual, so when
 578                                              any IndexColorModel using this
 579                                              struct is finalized, don&#39;t free
 580                                              the struct in freeICMColorData.
 581                                            */
 582 
 583     /*
 584      * Initialize colors array
 585      */
 586     for (i = 0; i &lt; awt_data-&gt;awt_num_colors; i++) {
 587         cols[i].pixel = i;
 588     }
 589 
 590     awt_data-&gt;color_data-&gt;awt_Colors =
 591         (ColorEntry *)calloc(paletteSize, sizeof (ColorEntry));
<span class="line-added"> 592     if (awt_data-&gt;color_data-&gt;awt_Colors == NULL) {</span>
<span class="line-added"> 593         free(awt_data-&gt;awtImage);</span>
<span class="line-added"> 594         free(awt_data-&gt;color_data);</span>
<span class="line-added"> 595         return 0;</span>
<span class="line-added"> 596     }</span>
 597 
 598     XQueryColors(dpy, cm, cols, awt_data-&gt;awt_num_colors);
 599     for (i = 0; i &lt; awt_data-&gt;awt_num_colors; i++) {
 600         awt_data-&gt;color_data-&gt;awt_Colors[i].r = cols[i].red &gt;&gt; 8;
 601         awt_data-&gt;color_data-&gt;awt_Colors[i].g = cols[i].green &gt;&gt; 8;
 602         awt_data-&gt;color_data-&gt;awt_Colors[i].b = cols[i].blue &gt;&gt; 8;
 603         awt_data-&gt;color_data-&gt;awt_Colors[i].flags = LIKELY_COLOR;
 604     }
 605 
 606     /*
 607      * Determine which colors in the colormap can be allocated and mark
 608      * them in the colors array
 609      */
 610     nfree = 0;
 611     for (i = (paletteSize / 2); i &gt; 0; i &gt;&gt;= 1) {
 612         if (XAllocColorCells(dpy, cm, False, plane_masks, 0,
 613                              freecolors + nfree, i)) {
 614             nfree += i;
 615         }
 616     }
</pre>
<hr />
<pre>
 650      * Allocate more colors, filling the color space evenly.
 651      */
 652 
 653     alloc_col(dpy, cm, 255, 255, 255, -1, awt_data);
 654     alloc_col(dpy, cm, 0, 0, 0, -1, awt_data);
 655 
 656     if (awt_data-&gt;awtImage-&gt;clrdata.grayscale) {
 657         int g;
 658         ColorEntry *p;
 659 
 660         if (!forcemono) {
 661             for (i = 128; i &gt; 0; i &gt;&gt;= 1) {
 662                 for (g = i; g &lt; 256; g += (i * 2)) {
 663                     alloc_col(dpy, cm, g, g, g, -1, awt_data);
 664                 }
 665             }
 666         }
 667 
 668         awt_data-&gt;color_data-&gt;img_grays =
 669             (unsigned char *)calloc(256, sizeof(unsigned char));
<span class="line-added"> 670         if ( awt_data-&gt;color_data-&gt;img_grays == NULL) {</span>
<span class="line-added"> 671             free(awt_data-&gt;awtImage);</span>
<span class="line-added"> 672             free(awt_data-&gt;color_data);</span>
<span class="line-added"> 673             return 0;</span>
<span class="line-added"> 674         }</span>
 675         for (g = 0; g &lt; 256; g++) {
 676             int mindist, besti;
 677             int d;
 678 
 679             p = awt_data-&gt;color_data-&gt;awt_Colors;
 680             mindist = 256;
 681             besti = 0;
 682             for (i = 0 ; i &lt; awt_data-&gt;awt_num_colors ; i++, p++) {
 683                 if (forcegray &amp;&amp; (p-&gt;r != p-&gt;g || p-&gt;g != p-&gt;b))
 684                     continue;
 685                 if (forcemono &amp;&amp; p-&gt;g != 0 &amp;&amp; p-&gt;g != 255)
 686                     continue;
 687                 if (p-&gt;flags == ALLOCATED_COLOR) {
 688                     d = p-&gt;g - g;
 689                     if (d &lt; 0) d = -d;
 690                     if (d &lt; mindist) {
 691                         besti = i;
 692                         if (d == 0) {
 693                             break;
 694                         }
</pre>
<hr />
<pre>
 798         if (cmapsize &gt; CMAP_ALLOC_MAX) {
 799             cmapsize = CMAP_ALLOC_MAX;
 800         }
 801 
 802         if (cmapsize &lt; allocatedColorsNum) {
 803             cmapsize = allocatedColorsNum;
 804         }
 805         cmapsize -= unavailableColorsNum;
 806     }
 807 
 808     k = 0;
 809     if (getenv(&quot;VIRTCUBESIZE&quot;) != 0) {
 810         k = atoi(getenv(&quot;VIRTCUBESIZE&quot;));
 811     }
 812     if (k == 0 || (k &amp; (k - 1)) != 0 || k &gt; 32) {
 813         k = getVirtCubeSize();
 814     }
 815     awt_data-&gt;color_data-&gt;img_clr_tbl =
 816         (unsigned char *)calloc(LOOKUPSIZE * LOOKUPSIZE * LOOKUPSIZE,
 817                                 sizeof(unsigned char));
<span class="line-added"> 818     if (awt_data-&gt;color_data-&gt;img_clr_tbl == NULL) {</span>
<span class="line-added"> 819         free(awt_data-&gt;awtImage);</span>
<span class="line-added"> 820         free(awt_data-&gt;color_data);</span>
<span class="line-added"> 821         return 0;</span>
<span class="line-added"> 822     }</span>
 823     img_makePalette(cmapsize, k, LOOKUPSIZE, 50, 250,
 824                     allocatedColorsNum, TRUE, reds, greens, blues,
 825                     awt_data-&gt;color_data-&gt;img_clr_tbl);
 826                     /*img_clr_tbl);*/
 827 
 828     for (i = 0; i &lt; cmapsize; i++) {
 829         indices[i] = alloc_col(dpy, cm, reds[i], greens[i], blues[i], -1,
 830                                awt_data);
 831     }
 832     for (i = 0; i &lt; LOOKUPSIZE * LOOKUPSIZE * LOOKUPSIZE  ; i++) {
 833         awt_data-&gt;color_data-&gt;img_clr_tbl[i] =
 834             indices[awt_data-&gt;color_data-&gt;img_clr_tbl[i]];
 835     }
 836 
 837     awt_data-&gt;color_data-&gt;img_oda_red   = &amp;(std_img_oda_red[0][0]);
 838     awt_data-&gt;color_data-&gt;img_oda_green = &amp;(std_img_oda_green[0][0]);
 839     awt_data-&gt;color_data-&gt;img_oda_blue  = &amp;(std_img_oda_blue[0][0]);
 840     make_dither_arrays(cmapsize, awt_data-&gt;color_data);
 841     std_odas_computed = 1;
 842 
</pre>
<hr />
<pre>
 851                 alloc_count++;
 852                 break;
 853               case LIKELY_COLOR:
 854                 reuse_count++;
 855                 break;
 856               case FREE_COLOR:
 857                 free_count++;
 858                 break;
 859             }
 860         }
 861         jio_fprintf(stdout, &quot;%d total, %d allocated, %d reused, %d still free.\n&quot;,
 862                     awt_data-&gt;awt_num_colors, alloc_count, reuse_count, free_count);
 863     }
 864 #endif
 865 
 866     /* Fill in the ICM lut and lut2cmap mapping */
 867     awt_data-&gt;color_data-&gt;awt_numICMcolors = 0;
 868     awt_data-&gt;color_data-&gt;awt_icmLUT2Colors =
 869         (unsigned char *)calloc(paletteSize, sizeof (unsigned char));
 870     awt_data-&gt;color_data-&gt;awt_icmLUT = (int *)calloc(paletteSize, sizeof(int));
<span class="line-added"> 871     if (awt_data-&gt;color_data-&gt;awt_icmLUT2Colors == NULL || awt_data-&gt;color_data-&gt;awt_icmLUT == NULL) {</span>
<span class="line-added"> 872         free(awt_data-&gt;awtImage);</span>
<span class="line-added"> 873         free(awt_data-&gt;color_data);</span>
<span class="line-added"> 874         return 0;</span>
<span class="line-added"> 875     }</span>
<span class="line-added"> 876 </span>
 877     for (i=0; i &lt; paletteSize; i++) {
 878         /* Keep the mapping between this lut and the actual cmap */
 879         awt_data-&gt;color_data-&gt;awt_icmLUT2Colors
 880             [awt_data-&gt;color_data-&gt;awt_numICMcolors] = i;
 881 
 882         if (awt_data-&gt;color_data-&gt;awt_Colors[i].flags == ALLOCATED_COLOR) {
 883             /* Screen IndexColorModel LUTS are always xRGB */
 884             awt_data-&gt;color_data-&gt;awt_icmLUT
 885                     [awt_data-&gt;color_data-&gt;awt_numICMcolors++] = 0xff000000 |
 886                 (awt_data-&gt;color_data-&gt;awt_Colors[i].r&lt;&lt;16) |
 887                 (awt_data-&gt;color_data-&gt;awt_Colors[i].g&lt;&lt;8) |
 888                 (awt_data-&gt;color_data-&gt;awt_Colors[i].b);
 889         } else {
 890             /* Screen IndexColorModel LUTS are always xRGB */
 891             awt_data-&gt;color_data-&gt;awt_icmLUT
 892                         [awt_data-&gt;color_data-&gt;awt_numICMcolors++] = 0;
 893         }
 894     }
 895     return 1;
 896 }
</pre>
<hr />
<pre>
1246 
1247         if (awt_colormodel == NULL)
1248         {
1249             (*env)-&gt;PopLocalFrame(env, 0);
1250             return NULL;
1251         }
1252 
1253         /* Set pData field of ColorModel to point to ColorData */
1254         JNU_SetLongFieldFromPtr(env, awt_colormodel, g_CMpDataID,
1255                                 aData-&gt;color_data);
1256 
1257     }
1258 
1259     return (*env)-&gt;PopLocalFrame(env, awt_colormodel);
1260 }
1261 #endif /* !HEADLESS */
1262 
1263 extern jfieldID colorValueID;
1264 
1265 #ifndef HEADLESS






1266 int awtJNI_GetColorForVis (JNIEnv *env,jobject this, AwtGraphicsConfigDataPtr awt_data)
1267 {
1268     int col;
1269     jclass SYSCLR_class;
1270 
1271     if (!JNU_IsNull(env,this))
1272     {
1273         SYSCLR_class = (*env)-&gt;FindClass(env, &quot;java/awt/SystemColor&quot;);
1274         CHECK_NULL_RETURN(SYSCLR_class, 0);
1275 
1276         if ((*env)-&gt;IsInstanceOf(env, this, SYSCLR_class)) {
1277                 /* SECURITY: This is safe, because there is no way
1278                  *           for client code to insert an object
1279                  *           that is a subclass of SystemColor
1280                  */
1281                 col = (int) JNU_CallMethodByName(env
1282                                           ,NULL
1283                                           ,this
1284                                           ,&quot;getRGB&quot;
1285                                           ,&quot;()I&quot;).i;
</pre>
</td>
</tr>
</table>
<center><a href="../../../classes/sun/print/UnixPrintService.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Font.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
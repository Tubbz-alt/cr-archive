diff a/src/java.desktop/unix/native/common/awt/X11Color.c b/src/java.desktop/unix/native/common/awt/X11Color.c
--- a/src/java.desktop/unix/native/common/awt/X11Color.c
+++ b/src/java.desktop/unix/native/common/awt/X11Color.c
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 1995, 2014, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 1995, 2019, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -334,23 +334,10 @@
 #endif
     }
 
     return awt_color_match(r, g, b, awt_data);
 }
-
-void
-awt_allocate_systemcolors(XColor *colorsPtr, int num_pixels, AwtGraphicsConfigDataPtr awtData) {
-    int i;
-    int r, g, b, pixel;
-
-    for (i=0; i < num_pixels; i++) {
-        r = colorsPtr[i].red   >> 8;
-        g = colorsPtr[i].green >> 8;
-        b = colorsPtr[i].blue  >> 8;
-        pixel = alloc_col(awt_display, awtData->awt_cmap, r, g, b, -1, awtData);
-    }
-}
 #endif /* !HEADLESS */
 
 void
 awt_fill_imgcv(ImgConvertFcn **array, int mask, int value, ImgConvertFcn fcn)
 {
@@ -400,10 +387,13 @@
     cm = awt_data->awt_cmap;
     depth = awt_data->awt_depth;
     pVI = &awt_data->awt_visInfo;
     awt_data->awt_num_colors = awt_data->awt_visInfo.colormap_size;
     awt_data->awtImage = (awtImageData *) calloc (1, sizeof (awtImageData));
+    if (awt_data->awtImage == NULL) {
+        return 0;
+    }
 
     pPFV = XListPixmapFormats(dpy, &numpfv);
     if (pPFV) {
         for (i = 0; i < numpfv; i++) {
             if (pPFV[i].depth == depth) {
@@ -570,16 +560,21 @@
     } else {
         paletteSize = MAX_PALETTE8_SIZE;
     }
 
     if (awt_data->awt_num_colors > paletteSize) {
-        free (awt_data->awtImage);
+        free(awt_data->awtImage);
         return 0;
     }
 
     /* Allocate ColorData structure */
     awt_data->color_data = ZALLOC (_ColorData);
+    if (awt_data->color_data == NULL) {
+        free(awt_data->awtImage);
+        return 0;
+    }
+
     awt_data->color_data->screendata = 1; /* This ColorData struct corresponds
                                              to some AWT screen/visual, so when
                                              any IndexColorModel using this
                                              struct is finalized, don't free
                                              the struct in freeICMColorData.
@@ -592,10 +587,15 @@
         cols[i].pixel = i;
     }
 
     awt_data->color_data->awt_Colors =
         (ColorEntry *)calloc(paletteSize, sizeof (ColorEntry));
+    if (awt_data->color_data->awt_Colors == NULL) {
+        free(awt_data->awtImage);
+        free(awt_data->color_data);
+        return 0;
+    }
 
     XQueryColors(dpy, cm, cols, awt_data->awt_num_colors);
     for (i = 0; i < awt_data->awt_num_colors; i++) {
         awt_data->color_data->awt_Colors[i].r = cols[i].red >> 8;
         awt_data->color_data->awt_Colors[i].g = cols[i].green >> 8;
@@ -665,10 +665,15 @@
             }
         }
 
         awt_data->color_data->img_grays =
             (unsigned char *)calloc(256, sizeof(unsigned char));
+        if ( awt_data->color_data->img_grays == NULL) {
+            free(awt_data->awtImage);
+            free(awt_data->color_data);
+            return 0;
+        }
         for (g = 0; g < 256; g++) {
             int mindist, besti;
             int d;
 
             p = awt_data->color_data->awt_Colors;
@@ -808,10 +813,15 @@
         k = getVirtCubeSize();
     }
     awt_data->color_data->img_clr_tbl =
         (unsigned char *)calloc(LOOKUPSIZE * LOOKUPSIZE * LOOKUPSIZE,
                                 sizeof(unsigned char));
+    if (awt_data->color_data->img_clr_tbl == NULL) {
+        free(awt_data->awtImage);
+        free(awt_data->color_data);
+        return 0;
+    }
     img_makePalette(cmapsize, k, LOOKUPSIZE, 50, 250,
                     allocatedColorsNum, TRUE, reds, greens, blues,
                     awt_data->color_data->img_clr_tbl);
                     /*img_clr_tbl);*/
 
@@ -856,10 +866,16 @@
     /* Fill in the ICM lut and lut2cmap mapping */
     awt_data->color_data->awt_numICMcolors = 0;
     awt_data->color_data->awt_icmLUT2Colors =
         (unsigned char *)calloc(paletteSize, sizeof (unsigned char));
     awt_data->color_data->awt_icmLUT = (int *)calloc(paletteSize, sizeof(int));
+    if (awt_data->color_data->awt_icmLUT2Colors == NULL || awt_data->color_data->awt_icmLUT == NULL) {
+        free(awt_data->awtImage);
+        free(awt_data->color_data);
+        return 0;
+    }
+
     for (i=0; i < paletteSize; i++) {
         /* Keep the mapping between this lut and the actual cmap */
         awt_data->color_data->awt_icmLUT2Colors
             [awt_data->color_data->awt_numICMcolors] = i;
 
@@ -1245,16 +1261,10 @@
 #endif /* !HEADLESS */
 
 extern jfieldID colorValueID;
 
 #ifndef HEADLESS
-int awtJNI_GetColor(JNIEnv *env,jobject this)
-{
-    /* REMIND: should not be defaultConfig. */
-    return awtJNI_GetColorForVis (env, this, getDefaultConfig(DefaultScreen(awt_display)));
-}
-
 int awtJNI_GetColorForVis (JNIEnv *env,jobject this, AwtGraphicsConfigDataPtr awt_data)
 {
     int col;
     jclass SYSCLR_class;
 

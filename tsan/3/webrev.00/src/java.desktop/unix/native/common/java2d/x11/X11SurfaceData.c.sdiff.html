<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/native/common/java2d/x11/X11SurfaceData.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X11FontScaler_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X11SurfaceData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/common/java2d/x11/X11SurfaceData.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  57 
  58 static LockFunc X11SD_Lock;
  59 static GetRasInfoFunc X11SD_GetRasInfo;
  60 static UnlockFunc X11SD_Unlock;
  61 static DisposeFunc X11SD_Dispose;
  62 static GetPixmapBgFunc X11SD_GetPixmapWithBg;
  63 static ReleasePixmapBgFunc X11SD_ReleasePixmapWithBg;
  64 extern int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr);
  65 extern AwtGraphicsConfigDataPtr
  66     getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);
  67 extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
  68 
  69 static int X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  70                           X11SDOps *xsdo);
  71 static int X11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  72                             X11SDOps *xsdo);
  73 static void X11SD_SwapBytes(X11SDOps *xsdo, XImage *img, int depth, int bpp);
  74 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
  75                                SurfaceDataBounds *bounds,
  76                                jint lockFlags);

  77 
  78 extern jfieldID validID;
  79 
  80 static int nativeByteOrder;
  81 static jclass xorCompClass;
  82 
  83 jint useMitShmExt = CANT_USE_MITSHM;
  84 jint useMitShmPixmaps = CANT_USE_MITSHM;
  85 jint forceSharedPixmaps = JNI_FALSE;
  86 
  87 #ifdef MITSHM
  88 int mitShmPermissionMask = MITSHM_PERM_OWNER;
  89 #endif
  90 
  91 /* Cached shared image, one for all surface datas. */
  92 static XImage * cachedXImage;
  93 
  94 #endif /* !HEADLESS */
  95 
  96 jboolean XShared_initIDs(JNIEnv *env, jboolean allowShmPixmaps)
</pre>
<hr />
<pre>
 373 {
 374 #ifndef HEADLESS
 375     X11SDOps *xsdo = (X11SDOps *) SurfaceData_GetOps(env, xsd);
 376 
 377     if (xsdo != NULL) {
 378         xsdo-&gt;invalid = JNI_TRUE;
 379     }
 380 #endif /* !HEADLESS */
 381 }
 382 
 383 
 384 jboolean XShared_initSurface(JNIEnv *env, X11SDOps *xsdo, jint depth, jint width, jint height, jlong drawable)
 385 {
 386 #ifndef HEADLESS
 387 
 388     if (drawable != (jlong)0) {
 389         /* Double-buffering */
 390         xsdo-&gt;drawable = drawable;
 391         xsdo-&gt;isPixmap = JNI_FALSE;
 392     } else {



 393         /*
 394          * width , height must be nonzero otherwise XCreatePixmap
 395          * generates BadValue in error_handler
 396          */
 397         if (width &lt;= 0 || height &lt;= 0 || width &gt; 32767 || height &gt; 32767) {



















 398             JNU_ThrowOutOfMemoryError(env,
 399                                   &quot;Can&#39;t create offscreen surface&quot;);
 400             return JNI_FALSE;
 401         }
 402         xsdo-&gt;isPixmap = JNI_TRUE;
 403 
 404         xsdo-&gt;pmWidth = width;
 405         xsdo-&gt;pmHeight = height;
 406 
 407 #ifdef MITSHM
<span class="line-modified"> 408         xsdo-&gt;shmPMData.pmSize = width * height * depth;</span>
 409         xsdo-&gt;shmPMData.pixelsReadThreshold = width * height / 8;
 410         if (forceSharedPixmaps) {
 411             AWT_LOCK();
 412             xsdo-&gt;drawable = X11SD_CreateSharedPixmap(xsdo);
 413             AWT_UNLOCK();
 414             JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 415             if (xsdo-&gt;drawable) {
 416                 xsdo-&gt;shmPMData.usingShmPixmap = JNI_TRUE;
 417                 xsdo-&gt;shmPMData.shmPixmap = xsdo-&gt;drawable;
 418                 return JNI_TRUE;
 419             }
 420         }
 421 #endif /* MITSHM */
 422 
 423         AWT_LOCK();
 424         xsdo-&gt;drawable =
 425             XCreatePixmap(awt_display,
 426                           RootWindow(awt_display,
 427                                      xsdo-&gt;configData-&gt;awt_visInfo.screen),
 428                           width, height, depth);
</pre>
<hr />
<pre>
 491 XImage* X11SD_CreateSharedImage(X11SDOps *xsdo,
 492                                    jint width, jint height)
 493 {
 494     XImage *img = NULL;
 495     XShmSegmentInfo *shminfo;
 496 
 497     shminfo = malloc(sizeof(XShmSegmentInfo));
 498     if (shminfo == NULL) {
 499         return NULL;
 500     }
 501     memset(shminfo, 0, sizeof(XShmSegmentInfo));
 502 
 503     img = XShmCreateImage(awt_display, xsdo-&gt;configData-&gt;awt_visInfo.visual,
 504                           xsdo-&gt;depth, ZPixmap, NULL, shminfo,
 505                           width, height);
 506     if (img == NULL) {
 507         free((void *)shminfo);
 508         return NULL;
 509     }
 510     shminfo-&gt;shmid =
<span class="line-modified"> 511         shmget(IPC_PRIVATE, height * img-&gt;bytes_per_line,</span>
 512                IPC_CREAT|mitShmPermissionMask);
 513     if (shminfo-&gt;shmid &lt; 0) {
 514         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 515                        &quot;X11SD_SetupSharedSegment shmget has failed: %s&quot;,
 516                        strerror(errno));
 517         free((void *)shminfo);
 518         XDestroyImage(img);
 519         return NULL;
 520     }
 521 
 522     shminfo-&gt;shmaddr = (char *) shmat(shminfo-&gt;shmid, 0, 0);
 523     if (shminfo-&gt;shmaddr == ((char *) -1)) {
 524         shmctl(shminfo-&gt;shmid, IPC_RMID, 0);
 525         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 526                        &quot;X11SD_SetupSharedSegment shmat has failed: %s&quot;,
 527                        strerror(errno));
 528         free((void *)shminfo);
 529         XDestroyImage(img);
 530         return NULL;
 531     }
</pre>
<hr />
<pre>
 553         return NULL;
 554     }
 555 
 556     img-&gt;data = shminfo-&gt;shmaddr;
 557     img-&gt;obdata = (char *)shminfo;
 558 
 559     return img;
 560 }
 561 
 562 XImage* X11SD_GetSharedImage(X11SDOps *xsdo, jint width, jint height,
 563                              jint maxWidth, jint maxHeight, jboolean readBits)
 564 {
 565     XImage * retImage = NULL;
 566     if (cachedXImage != NULL &amp;&amp;
 567         X11SD_CachedXImageFits(width, height, maxWidth, maxHeight,
 568                                xsdo-&gt;depth, readBits)) {
 569         /* sync so previous data gets flushed */
 570         XSync(awt_display, False);
 571         retImage = cachedXImage;
 572         cachedXImage = (XImage *)NULL;
<span class="line-modified"> 573     } else if (width * height * xsdo-&gt;depth &gt; 0x10000) {</span>
 574         retImage = X11SD_CreateSharedImage(xsdo, width, height);
 575     }
 576     return retImage;
 577 }
 578 
 579 Drawable X11SD_CreateSharedPixmap(X11SDOps *xsdo)
 580 {
 581     XShmSegmentInfo *shminfo;
 582     XImage *img = NULL;
 583     Drawable pixmap;
 584     int scan;
 585     int width = xsdo-&gt;pmWidth;
 586     int height = xsdo-&gt;pmHeight;
 587 
 588     if (xsdo-&gt;shmPMData.pmSize &lt; 0x10000) {
 589         /* only use shared mem pixmaps for relatively big images */
 590         return 0;
 591     }
 592 
 593     /* need to create shared(!) image to get bytes_per_line */
</pre>
<hr />
<pre>
 853         xpriv-&gt;x = pRasInfo-&gt;bounds.x1;
 854         xpriv-&gt;y = pRasInfo-&gt;bounds.y1;
 855         pRasInfo-&gt;rasBase = xsdo-&gt;shmPMData.shmSegInfo-&gt;shmaddr;
 856         pRasInfo-&gt;pixelStride = mult;
 857         pRasInfo-&gt;pixelBitOffset = 0;
 858         pRasInfo-&gt;scanStride = xsdo-&gt;shmPMData.bytesPerLine;
 859     } else
 860 #endif /* MITSHM */
 861     if (xpriv-&gt;lockType == X11SD_LOCK_BY_XIMAGE) {
 862         int x, y, w, h;
 863         x = pRasInfo-&gt;bounds.x1;
 864         y = pRasInfo-&gt;bounds.y1;
 865         w = pRasInfo-&gt;bounds.x2 - x;
 866         h = pRasInfo-&gt;bounds.y2 - y;
 867 
 868         xpriv-&gt;img = X11SD_GetImage(env, xsdo, &amp;pRasInfo-&gt;bounds, lockFlags);
 869         if (xpriv-&gt;img) {
 870             int scan = xpriv-&gt;img-&gt;bytes_per_line;
 871             xpriv-&gt;x = x;
 872             xpriv-&gt;y = y;
<span class="line-modified"> 873             pRasInfo-&gt;rasBase = xpriv-&gt;img-&gt;data - x * mult - y * scan;</span>
 874             pRasInfo-&gt;pixelStride = mult;
 875             pRasInfo-&gt;pixelBitOffset = 0;
 876             pRasInfo-&gt;scanStride = scan;
 877         } else {
 878             pRasInfo-&gt;rasBase = NULL;
 879             pRasInfo-&gt;pixelStride = 0;
 880             pRasInfo-&gt;pixelBitOffset = 0;
 881             pRasInfo-&gt;scanStride = 0;
 882         }
 883     } else {
 884         /* They didn&#39;t lock for anything - we won&#39;t give them anything */
 885         pRasInfo-&gt;rasBase = NULL;
 886         pRasInfo-&gt;pixelStride = 0;
 887         pRasInfo-&gt;pixelBitOffset = 0;
 888         pRasInfo-&gt;scanStride = 0;
 889     }
 890     if (lockFlags &amp; SD_LOCK_LUT) {
 891         pRasInfo-&gt;lutBase = (jint *) xsdo-&gt;cData-&gt;awt_icmLUT;
 892         pRasInfo-&gt;lutSize = xsdo-&gt;cData-&gt;awt_numICMcolors;
 893     } else {
</pre>
<hr />
<pre>
1012     b-&gt;x2 = x2;
1013     b-&gt;y2 = y2;
1014 
1015     return TRUE;
1016 }
1017 
1018 /*
1019  * x1, y1, x2, y2 - our rectangle in the coord system of
1020  * the widget
1021  * px1, xy1, px2, py2 - current parent rect coords in the
1022  * same system
1023  */
1024 static int
1025 X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds, X11SDOps *xsdo)
1026 {
1027     return TRUE;
1028 }
1029 
1030 static void
1031 X11SD_SwapBytes(X11SDOps *xsdo, XImage * img, int depth, int bpp) {
<span class="line-modified">1032     int lengthInBytes = img-&gt;height * img-&gt;bytes_per_line;</span>
<span class="line-modified">1033     int i;</span>
1034 
1035     switch (depth) {
1036     case 12:
1037     case 15:
1038     case 16:
1039         {
1040             /* AB -&gt; BA */
1041             unsigned short *d = (unsigned short *)img-&gt;data;
1042             unsigned short t;
1043             for (i = 0; i &lt; lengthInBytes/2; i++) {
1044                 t = *d;
1045                 *d++ = (t &gt;&gt; 8) | (t &lt;&lt; 8);
1046             }
1047             img-&gt;byte_order = nativeByteOrder;
1048             img-&gt;bitmap_bit_order = nativeByteOrder;
1049             break;
1050         }
1051     case 24:
1052         {
1053             /* ABC -&gt; CBA */
</pre>
<hr />
<pre>
1086                 *d++ = ((t &gt;&gt; 24) |
1087                         ((t &gt;&gt; 8) &amp; 0xff00) |
1088                         ((t &amp; 0xff00) &lt;&lt; 8) |
1089                         (t &lt;&lt; 24));
1090             }
1091             break;
1092         }
1093     }
1094 }
1095 
1096 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
1097                                SurfaceDataBounds *bounds,
1098                                jint lockFlags)
1099 {
1100     int x, y, w, h, maxWidth, maxHeight;
1101     int scan;
1102     XImage * img = NULL;
1103     Drawable drawable;
1104     int depth = xsdo-&gt;depth;
1105     int mult = xsdo-&gt;configData-&gt;pixelStride;
<span class="line-modified">1106     int pad = (mult == 3) ? 32 : mult * 8; // pad must be 8, 16, or 32</span>
1107     jboolean readBits = lockFlags &amp; SD_LOCK_NEED_PIXELS;
1108 
1109     x = bounds-&gt;x1;
1110     y = bounds-&gt;y1;
1111     w = bounds-&gt;x2 - x;
1112     h = bounds-&gt;y2 - y;
1113 
1114 #ifdef MITSHM
1115     if (useMitShmExt == CAN_USE_MITSHM) {
1116         if (xsdo-&gt;isPixmap) {
1117             if (readBits) {
1118                 X11SD_PuntPixmap(xsdo, w, h);
1119             }
1120             maxWidth = xsdo-&gt;pmWidth;
1121             maxHeight = xsdo-&gt;pmHeight;
1122         } else {
1123             XWindowAttributes winAttr;
1124             if (XGetWindowAttributes(awt_display,
1125                                      (Window) xsdo-&gt;drawable, &amp;winAttr) != 0) {
1126                 maxWidth = winAttr.width;
</pre>
<hr />
<pre>
1152         }
1153         if (img == NULL) {
1154             img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1155             if (img != NULL) {
1156                 img-&gt;obdata = NULL;
1157             }
1158         }
1159 #else
1160         img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1161 #endif /* MITSHM */
1162         if (img == NULL) {
1163             SurfaceDataBounds temp;
1164             img = XCreateImage(awt_display,
1165                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1166                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1167             if (img == NULL) {
1168                 return NULL;
1169             }
1170 
1171             scan = img-&gt;bytes_per_line;
<span class="line-modified">1172             img-&gt;data = malloc(h * scan);</span>
1173             if (img-&gt;data == NULL) {
1174                 XFree(img);
1175                 return NULL;
1176             }
1177 
1178             if (xsdo-&gt;isPixmap == JNI_FALSE &amp;&amp;
1179                 X11SD_ClipToRoot(&amp;temp, bounds, xsdo)) {
1180 
1181                 XImage * temp_image;
1182                 temp_image = XGetImage(awt_display, drawable,
1183                                        temp.x1, temp.y1,
1184                                        temp.x2 - temp.x1,
1185                                        temp.y2 - temp.y1,
1186                                        -1, ZPixmap);
1187                 if (temp_image == NULL) {
1188                     XGrabServer(awt_display);
1189                     if (X11SD_FindClip(&amp;temp, bounds, xsdo)) {
1190                         temp_image =
1191                             XGetImage(awt_display, drawable,
1192                                       temp.x1, temp.y1,
1193                                       temp.x2 - temp.x1,
1194                                       temp.y2 - temp.y1,
1195                                       -1, ZPixmap);
1196                     }
1197                     XUngrabServer(awt_display);
1198                     /* Workaround for bug 5039226 */
1199                     XSync(awt_display, False);
1200                 }
1201                 if (temp_image != NULL) {
1202                     int temp_scan, bytes_to_copy;
1203                     char * img_addr, * temp_addr;
1204                     int i;
1205 
1206                     img_addr = img-&gt;data +
<span class="line-modified">1207                         (temp.y1 - y) * scan + (temp.x1 - x) * mult;</span>
1208                     temp_scan = temp_image-&gt;bytes_per_line;
1209                     temp_addr = temp_image-&gt;data;
1210                     bytes_to_copy = (temp.x2 - temp.x1) * mult;
1211                     for (i = temp.y1; i &lt; temp.y2; i++) {
1212                         memcpy(img_addr, temp_addr, bytes_to_copy);
1213                         img_addr += scan;
1214                         temp_addr += temp_scan;
1215                     }
1216                     XDestroyImage(temp_image);
1217                 }
1218             }
1219             img-&gt;obdata = NULL;
1220         }
1221         if (depth &gt; 8 &amp;&amp; img-&gt;byte_order != nativeByteOrder) {
1222             X11SD_SwapBytes(xsdo, img, depth,
1223                 xsdo-&gt;configData-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel);
1224         }
1225     } else {
1226         /*
1227          * REMIND: This might be better to move to the Lock function
1228          * to avoid lengthy I/O pauses inside what may be a critical
1229          * section.  This will be more critical when SD_LOCK_READ is
1230          * implemented.  Another solution is to cache the pixels
1231          * to avoid reading for every operation.
1232          */
1233         if (img == NULL) {
1234             img = XCreateImage(awt_display,
1235                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1236                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1237             if (img == NULL) {
1238                 return NULL;
1239             }
1240 
<span class="line-modified">1241             img-&gt;data = malloc(h * img-&gt;bytes_per_line);</span>
1242             if (img-&gt;data == NULL) {
1243                 XFree(img);
1244                 return NULL;
1245             }
1246 
1247             img-&gt;obdata = NULL;
1248 
1249             if (img-&gt;byte_order != nativeByteOrder &amp;&amp;
1250                 (depth == 15 || depth == 16 || depth == 12)) {
1251                 /* bytes will be swapped by XLib. */
1252                 img-&gt;byte_order = nativeByteOrder;
1253                 img-&gt;bitmap_bit_order = nativeByteOrder;
1254             }
1255         }
1256     }
1257     return img;
1258 }
1259 
1260 void X11SD_DisposeOrCacheXImage(XImage * image) {
1261     /* REMIND: might want to check if the new image worth caching. */
</pre>
<hr />
<pre>
1362 
1363         XFreeGC(awt_display, bmGC);
1364         XFreeGC(awt_display, srcGC);
1365         xsdo-&gt;bgPixel = pixel;
1366         xsdo-&gt;isBgInitialized = JNI_TRUE;
1367     }
1368 
1369     return xsdo-&gt;drawable;
1370 }
1371 
1372 static void
1373 X11SD_ReleasePixmapWithBg(JNIEnv *env, X11SDOps *xsdo)
1374 {
1375 #ifdef MITSHM
1376     if (xsdo-&gt;shmPMData.usingShmPixmap) {
1377         xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
1378     }
1379 #endif /* MITSHM */
1380 }
1381 





1382 #endif /* !HEADLESS */
1383 
1384 /*
1385  * Class:     sun_java2d_x11_X11SurfaceData
1386  * Method:    XCreateGC
1387  * Signature: (I)J
1388  */
1389 JNIEXPORT jlong JNICALL
1390 Java_sun_java2d_x11_XSurfaceData_XCreateGC
1391     (JNIEnv *env, jclass xsd, jlong pXSData)
1392 {
1393     jlong ret;
1394 
1395 #ifndef HEADLESS
1396     X11SDOps *xsdo;
1397 
1398     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XCreateGC&quot;);
1399 
1400     xsdo = (X11SDOps *) pXSData;
1401     if (xsdo == NULL) {
</pre>
</td>
<td>
<hr />
<pre>
  57 
  58 static LockFunc X11SD_Lock;
  59 static GetRasInfoFunc X11SD_GetRasInfo;
  60 static UnlockFunc X11SD_Unlock;
  61 static DisposeFunc X11SD_Dispose;
  62 static GetPixmapBgFunc X11SD_GetPixmapWithBg;
  63 static ReleasePixmapBgFunc X11SD_ReleasePixmapWithBg;
  64 extern int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr);
  65 extern AwtGraphicsConfigDataPtr
  66     getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);
  67 extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
  68 
  69 static int X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  70                           X11SDOps *xsdo);
  71 static int X11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  72                             X11SDOps *xsdo);
  73 static void X11SD_SwapBytes(X11SDOps *xsdo, XImage *img, int depth, int bpp);
  74 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
  75                                SurfaceDataBounds *bounds,
  76                                jint lockFlags);
<span class="line-added">  77 static int X11SD_GetBitmapPad(int pixelStride);</span>
  78 
  79 extern jfieldID validID;
  80 
  81 static int nativeByteOrder;
  82 static jclass xorCompClass;
  83 
  84 jint useMitShmExt = CANT_USE_MITSHM;
  85 jint useMitShmPixmaps = CANT_USE_MITSHM;
  86 jint forceSharedPixmaps = JNI_FALSE;
  87 
  88 #ifdef MITSHM
  89 int mitShmPermissionMask = MITSHM_PERM_OWNER;
  90 #endif
  91 
  92 /* Cached shared image, one for all surface datas. */
  93 static XImage * cachedXImage;
  94 
  95 #endif /* !HEADLESS */
  96 
  97 jboolean XShared_initIDs(JNIEnv *env, jboolean allowShmPixmaps)
</pre>
<hr />
<pre>
 374 {
 375 #ifndef HEADLESS
 376     X11SDOps *xsdo = (X11SDOps *) SurfaceData_GetOps(env, xsd);
 377 
 378     if (xsdo != NULL) {
 379         xsdo-&gt;invalid = JNI_TRUE;
 380     }
 381 #endif /* !HEADLESS */
 382 }
 383 
 384 
 385 jboolean XShared_initSurface(JNIEnv *env, X11SDOps *xsdo, jint depth, jint width, jint height, jlong drawable)
 386 {
 387 #ifndef HEADLESS
 388 
 389     if (drawable != (jlong)0) {
 390         /* Double-buffering */
 391         xsdo-&gt;drawable = drawable;
 392         xsdo-&gt;isPixmap = JNI_FALSE;
 393     } else {
<span class="line-added"> 394         jboolean sizeIsInvalid = JNI_FALSE;</span>
<span class="line-added"> 395         jlong scan = 0;</span>
<span class="line-added"> 396 </span>
 397         /*
 398          * width , height must be nonzero otherwise XCreatePixmap
 399          * generates BadValue in error_handler
 400          */
 401         if (width &lt;= 0 || height &lt;= 0 || width &gt; 32767 || height &gt; 32767) {
<span class="line-added"> 402             sizeIsInvalid = JNI_TRUE;</span>
<span class="line-added"> 403         } else {</span>
<span class="line-added"> 404             XImage* tmpImg = NULL;</span>
<span class="line-added"> 405 </span>
<span class="line-added"> 406             AWT_LOCK();</span>
<span class="line-added"> 407             tmpImg = XCreateImage(awt_display,</span>
<span class="line-added"> 408                 xsdo-&gt;configData-&gt;awt_visInfo.visual,</span>
<span class="line-added"> 409                 depth, ZPixmap, 0, NULL, width, height,</span>
<span class="line-added"> 410                 X11SD_GetBitmapPad(xsdo-&gt;configData-&gt;pixelStride), 0);</span>
<span class="line-added"> 411             if (tmpImg) {</span>
<span class="line-added"> 412                 scan = (jlong) tmpImg-&gt;bytes_per_line;</span>
<span class="line-added"> 413                 XDestroyImage(tmpImg);</span>
<span class="line-added"> 414                 tmpImg = NULL;</span>
<span class="line-added"> 415             }</span>
<span class="line-added"> 416             AWT_UNLOCK();</span>
<span class="line-added"> 417             JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="line-added"> 418         }</span>
<span class="line-added"> 419 </span>
<span class="line-added"> 420         if (sizeIsInvalid || (scan * height &gt; 0x7FFFFFFFL)) {</span>
 421             JNU_ThrowOutOfMemoryError(env,
 422                                   &quot;Can&#39;t create offscreen surface&quot;);
 423             return JNI_FALSE;
 424         }
 425         xsdo-&gt;isPixmap = JNI_TRUE;
 426 
 427         xsdo-&gt;pmWidth = width;
 428         xsdo-&gt;pmHeight = height;
 429 
 430 #ifdef MITSHM
<span class="line-modified"> 431         xsdo-&gt;shmPMData.pmSize = (jlong) width * height * depth;</span>
 432         xsdo-&gt;shmPMData.pixelsReadThreshold = width * height / 8;
 433         if (forceSharedPixmaps) {
 434             AWT_LOCK();
 435             xsdo-&gt;drawable = X11SD_CreateSharedPixmap(xsdo);
 436             AWT_UNLOCK();
 437             JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 438             if (xsdo-&gt;drawable) {
 439                 xsdo-&gt;shmPMData.usingShmPixmap = JNI_TRUE;
 440                 xsdo-&gt;shmPMData.shmPixmap = xsdo-&gt;drawable;
 441                 return JNI_TRUE;
 442             }
 443         }
 444 #endif /* MITSHM */
 445 
 446         AWT_LOCK();
 447         xsdo-&gt;drawable =
 448             XCreatePixmap(awt_display,
 449                           RootWindow(awt_display,
 450                                      xsdo-&gt;configData-&gt;awt_visInfo.screen),
 451                           width, height, depth);
</pre>
<hr />
<pre>
 514 XImage* X11SD_CreateSharedImage(X11SDOps *xsdo,
 515                                    jint width, jint height)
 516 {
 517     XImage *img = NULL;
 518     XShmSegmentInfo *shminfo;
 519 
 520     shminfo = malloc(sizeof(XShmSegmentInfo));
 521     if (shminfo == NULL) {
 522         return NULL;
 523     }
 524     memset(shminfo, 0, sizeof(XShmSegmentInfo));
 525 
 526     img = XShmCreateImage(awt_display, xsdo-&gt;configData-&gt;awt_visInfo.visual,
 527                           xsdo-&gt;depth, ZPixmap, NULL, shminfo,
 528                           width, height);
 529     if (img == NULL) {
 530         free((void *)shminfo);
 531         return NULL;
 532     }
 533     shminfo-&gt;shmid =
<span class="line-modified"> 534         shmget(IPC_PRIVATE, (size_t) height * img-&gt;bytes_per_line,</span>
 535                IPC_CREAT|mitShmPermissionMask);
 536     if (shminfo-&gt;shmid &lt; 0) {
 537         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 538                        &quot;X11SD_SetupSharedSegment shmget has failed: %s&quot;,
 539                        strerror(errno));
 540         free((void *)shminfo);
 541         XDestroyImage(img);
 542         return NULL;
 543     }
 544 
 545     shminfo-&gt;shmaddr = (char *) shmat(shminfo-&gt;shmid, 0, 0);
 546     if (shminfo-&gt;shmaddr == ((char *) -1)) {
 547         shmctl(shminfo-&gt;shmid, IPC_RMID, 0);
 548         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 549                        &quot;X11SD_SetupSharedSegment shmat has failed: %s&quot;,
 550                        strerror(errno));
 551         free((void *)shminfo);
 552         XDestroyImage(img);
 553         return NULL;
 554     }
</pre>
<hr />
<pre>
 576         return NULL;
 577     }
 578 
 579     img-&gt;data = shminfo-&gt;shmaddr;
 580     img-&gt;obdata = (char *)shminfo;
 581 
 582     return img;
 583 }
 584 
 585 XImage* X11SD_GetSharedImage(X11SDOps *xsdo, jint width, jint height,
 586                              jint maxWidth, jint maxHeight, jboolean readBits)
 587 {
 588     XImage * retImage = NULL;
 589     if (cachedXImage != NULL &amp;&amp;
 590         X11SD_CachedXImageFits(width, height, maxWidth, maxHeight,
 591                                xsdo-&gt;depth, readBits)) {
 592         /* sync so previous data gets flushed */
 593         XSync(awt_display, False);
 594         retImage = cachedXImage;
 595         cachedXImage = (XImage *)NULL;
<span class="line-modified"> 596     } else if ((jlong) width * height * xsdo-&gt;depth &gt; 0x10000) {</span>
 597         retImage = X11SD_CreateSharedImage(xsdo, width, height);
 598     }
 599     return retImage;
 600 }
 601 
 602 Drawable X11SD_CreateSharedPixmap(X11SDOps *xsdo)
 603 {
 604     XShmSegmentInfo *shminfo;
 605     XImage *img = NULL;
 606     Drawable pixmap;
 607     int scan;
 608     int width = xsdo-&gt;pmWidth;
 609     int height = xsdo-&gt;pmHeight;
 610 
 611     if (xsdo-&gt;shmPMData.pmSize &lt; 0x10000) {
 612         /* only use shared mem pixmaps for relatively big images */
 613         return 0;
 614     }
 615 
 616     /* need to create shared(!) image to get bytes_per_line */
</pre>
<hr />
<pre>
 876         xpriv-&gt;x = pRasInfo-&gt;bounds.x1;
 877         xpriv-&gt;y = pRasInfo-&gt;bounds.y1;
 878         pRasInfo-&gt;rasBase = xsdo-&gt;shmPMData.shmSegInfo-&gt;shmaddr;
 879         pRasInfo-&gt;pixelStride = mult;
 880         pRasInfo-&gt;pixelBitOffset = 0;
 881         pRasInfo-&gt;scanStride = xsdo-&gt;shmPMData.bytesPerLine;
 882     } else
 883 #endif /* MITSHM */
 884     if (xpriv-&gt;lockType == X11SD_LOCK_BY_XIMAGE) {
 885         int x, y, w, h;
 886         x = pRasInfo-&gt;bounds.x1;
 887         y = pRasInfo-&gt;bounds.y1;
 888         w = pRasInfo-&gt;bounds.x2 - x;
 889         h = pRasInfo-&gt;bounds.y2 - y;
 890 
 891         xpriv-&gt;img = X11SD_GetImage(env, xsdo, &amp;pRasInfo-&gt;bounds, lockFlags);
 892         if (xpriv-&gt;img) {
 893             int scan = xpriv-&gt;img-&gt;bytes_per_line;
 894             xpriv-&gt;x = x;
 895             xpriv-&gt;y = y;
<span class="line-modified"> 896             pRasInfo-&gt;rasBase = xpriv-&gt;img-&gt;data - x * mult - (intptr_t) y * scan;</span>
 897             pRasInfo-&gt;pixelStride = mult;
 898             pRasInfo-&gt;pixelBitOffset = 0;
 899             pRasInfo-&gt;scanStride = scan;
 900         } else {
 901             pRasInfo-&gt;rasBase = NULL;
 902             pRasInfo-&gt;pixelStride = 0;
 903             pRasInfo-&gt;pixelBitOffset = 0;
 904             pRasInfo-&gt;scanStride = 0;
 905         }
 906     } else {
 907         /* They didn&#39;t lock for anything - we won&#39;t give them anything */
 908         pRasInfo-&gt;rasBase = NULL;
 909         pRasInfo-&gt;pixelStride = 0;
 910         pRasInfo-&gt;pixelBitOffset = 0;
 911         pRasInfo-&gt;scanStride = 0;
 912     }
 913     if (lockFlags &amp; SD_LOCK_LUT) {
 914         pRasInfo-&gt;lutBase = (jint *) xsdo-&gt;cData-&gt;awt_icmLUT;
 915         pRasInfo-&gt;lutSize = xsdo-&gt;cData-&gt;awt_numICMcolors;
 916     } else {
</pre>
<hr />
<pre>
1035     b-&gt;x2 = x2;
1036     b-&gt;y2 = y2;
1037 
1038     return TRUE;
1039 }
1040 
1041 /*
1042  * x1, y1, x2, y2 - our rectangle in the coord system of
1043  * the widget
1044  * px1, xy1, px2, py2 - current parent rect coords in the
1045  * same system
1046  */
1047 static int
1048 X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds, X11SDOps *xsdo)
1049 {
1050     return TRUE;
1051 }
1052 
1053 static void
1054 X11SD_SwapBytes(X11SDOps *xsdo, XImage * img, int depth, int bpp) {
<span class="line-modified">1055     jlong lengthInBytes = (jlong) img-&gt;height * img-&gt;bytes_per_line;</span>
<span class="line-modified">1056     jlong i;</span>
1057 
1058     switch (depth) {
1059     case 12:
1060     case 15:
1061     case 16:
1062         {
1063             /* AB -&gt; BA */
1064             unsigned short *d = (unsigned short *)img-&gt;data;
1065             unsigned short t;
1066             for (i = 0; i &lt; lengthInBytes/2; i++) {
1067                 t = *d;
1068                 *d++ = (t &gt;&gt; 8) | (t &lt;&lt; 8);
1069             }
1070             img-&gt;byte_order = nativeByteOrder;
1071             img-&gt;bitmap_bit_order = nativeByteOrder;
1072             break;
1073         }
1074     case 24:
1075         {
1076             /* ABC -&gt; CBA */
</pre>
<hr />
<pre>
1109                 *d++ = ((t &gt;&gt; 24) |
1110                         ((t &gt;&gt; 8) &amp; 0xff00) |
1111                         ((t &amp; 0xff00) &lt;&lt; 8) |
1112                         (t &lt;&lt; 24));
1113             }
1114             break;
1115         }
1116     }
1117 }
1118 
1119 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
1120                                SurfaceDataBounds *bounds,
1121                                jint lockFlags)
1122 {
1123     int x, y, w, h, maxWidth, maxHeight;
1124     int scan;
1125     XImage * img = NULL;
1126     Drawable drawable;
1127     int depth = xsdo-&gt;depth;
1128     int mult = xsdo-&gt;configData-&gt;pixelStride;
<span class="line-modified">1129     int pad = X11SD_GetBitmapPad(mult);</span>
1130     jboolean readBits = lockFlags &amp; SD_LOCK_NEED_PIXELS;
1131 
1132     x = bounds-&gt;x1;
1133     y = bounds-&gt;y1;
1134     w = bounds-&gt;x2 - x;
1135     h = bounds-&gt;y2 - y;
1136 
1137 #ifdef MITSHM
1138     if (useMitShmExt == CAN_USE_MITSHM) {
1139         if (xsdo-&gt;isPixmap) {
1140             if (readBits) {
1141                 X11SD_PuntPixmap(xsdo, w, h);
1142             }
1143             maxWidth = xsdo-&gt;pmWidth;
1144             maxHeight = xsdo-&gt;pmHeight;
1145         } else {
1146             XWindowAttributes winAttr;
1147             if (XGetWindowAttributes(awt_display,
1148                                      (Window) xsdo-&gt;drawable, &amp;winAttr) != 0) {
1149                 maxWidth = winAttr.width;
</pre>
<hr />
<pre>
1175         }
1176         if (img == NULL) {
1177             img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1178             if (img != NULL) {
1179                 img-&gt;obdata = NULL;
1180             }
1181         }
1182 #else
1183         img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1184 #endif /* MITSHM */
1185         if (img == NULL) {
1186             SurfaceDataBounds temp;
1187             img = XCreateImage(awt_display,
1188                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1189                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1190             if (img == NULL) {
1191                 return NULL;
1192             }
1193 
1194             scan = img-&gt;bytes_per_line;
<span class="line-modified">1195             img-&gt;data = malloc((size_t) h * scan);</span>
1196             if (img-&gt;data == NULL) {
1197                 XFree(img);
1198                 return NULL;
1199             }
1200 
1201             if (xsdo-&gt;isPixmap == JNI_FALSE &amp;&amp;
1202                 X11SD_ClipToRoot(&amp;temp, bounds, xsdo)) {
1203 
1204                 XImage * temp_image;
1205                 temp_image = XGetImage(awt_display, drawable,
1206                                        temp.x1, temp.y1,
1207                                        temp.x2 - temp.x1,
1208                                        temp.y2 - temp.y1,
1209                                        -1, ZPixmap);
1210                 if (temp_image == NULL) {
1211                     XGrabServer(awt_display);
1212                     if (X11SD_FindClip(&amp;temp, bounds, xsdo)) {
1213                         temp_image =
1214                             XGetImage(awt_display, drawable,
1215                                       temp.x1, temp.y1,
1216                                       temp.x2 - temp.x1,
1217                                       temp.y2 - temp.y1,
1218                                       -1, ZPixmap);
1219                     }
1220                     XUngrabServer(awt_display);
1221                     /* Workaround for bug 5039226 */
1222                     XSync(awt_display, False);
1223                 }
1224                 if (temp_image != NULL) {
1225                     int temp_scan, bytes_to_copy;
1226                     char * img_addr, * temp_addr;
1227                     int i;
1228 
1229                     img_addr = img-&gt;data +
<span class="line-modified">1230                         (intptr_t) (temp.y1 - y) * scan + (temp.x1 - x) * mult;</span>
1231                     temp_scan = temp_image-&gt;bytes_per_line;
1232                     temp_addr = temp_image-&gt;data;
1233                     bytes_to_copy = (temp.x2 - temp.x1) * mult;
1234                     for (i = temp.y1; i &lt; temp.y2; i++) {
1235                         memcpy(img_addr, temp_addr, bytes_to_copy);
1236                         img_addr += scan;
1237                         temp_addr += temp_scan;
1238                     }
1239                     XDestroyImage(temp_image);
1240                 }
1241             }
1242             img-&gt;obdata = NULL;
1243         }
1244         if (depth &gt; 8 &amp;&amp; img-&gt;byte_order != nativeByteOrder) {
1245             X11SD_SwapBytes(xsdo, img, depth,
1246                 xsdo-&gt;configData-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel);
1247         }
1248     } else {
1249         /*
1250          * REMIND: This might be better to move to the Lock function
1251          * to avoid lengthy I/O pauses inside what may be a critical
1252          * section.  This will be more critical when SD_LOCK_READ is
1253          * implemented.  Another solution is to cache the pixels
1254          * to avoid reading for every operation.
1255          */
1256         if (img == NULL) {
1257             img = XCreateImage(awt_display,
1258                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1259                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1260             if (img == NULL) {
1261                 return NULL;
1262             }
1263 
<span class="line-modified">1264             img-&gt;data = malloc((size_t) h * img-&gt;bytes_per_line);</span>
1265             if (img-&gt;data == NULL) {
1266                 XFree(img);
1267                 return NULL;
1268             }
1269 
1270             img-&gt;obdata = NULL;
1271 
1272             if (img-&gt;byte_order != nativeByteOrder &amp;&amp;
1273                 (depth == 15 || depth == 16 || depth == 12)) {
1274                 /* bytes will be swapped by XLib. */
1275                 img-&gt;byte_order = nativeByteOrder;
1276                 img-&gt;bitmap_bit_order = nativeByteOrder;
1277             }
1278         }
1279     }
1280     return img;
1281 }
1282 
1283 void X11SD_DisposeOrCacheXImage(XImage * image) {
1284     /* REMIND: might want to check if the new image worth caching. */
</pre>
<hr />
<pre>
1385 
1386         XFreeGC(awt_display, bmGC);
1387         XFreeGC(awt_display, srcGC);
1388         xsdo-&gt;bgPixel = pixel;
1389         xsdo-&gt;isBgInitialized = JNI_TRUE;
1390     }
1391 
1392     return xsdo-&gt;drawable;
1393 }
1394 
1395 static void
1396 X11SD_ReleasePixmapWithBg(JNIEnv *env, X11SDOps *xsdo)
1397 {
1398 #ifdef MITSHM
1399     if (xsdo-&gt;shmPMData.usingShmPixmap) {
1400         xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
1401     }
1402 #endif /* MITSHM */
1403 }
1404 
<span class="line-added">1405 static int X11SD_GetBitmapPad(int pixelStride) {</span>
<span class="line-added">1406     // pad must be 8, 16, or 32</span>
<span class="line-added">1407     return (pixelStride == 3) ? 32 : pixelStride * 8;</span>
<span class="line-added">1408 }</span>
<span class="line-added">1409 </span>
1410 #endif /* !HEADLESS */
1411 
1412 /*
1413  * Class:     sun_java2d_x11_X11SurfaceData
1414  * Method:    XCreateGC
1415  * Signature: (I)J
1416  */
1417 JNIEXPORT jlong JNICALL
1418 Java_sun_java2d_x11_XSurfaceData_XCreateGC
1419     (JNIEnv *env, jclass xsd, jlong pXSData)
1420 {
1421     jlong ret;
1422 
1423 #ifndef HEADLESS
1424     X11SDOps *xsdo;
1425 
1426     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XCreateGC&quot;);
1427 
1428     xsdo = (X11SDOps *) pXSData;
1429     if (xsdo == NULL) {
</pre>
</td>
</tr>
</table>
<center><a href="X11FontScaler_md.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X11SurfaceData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
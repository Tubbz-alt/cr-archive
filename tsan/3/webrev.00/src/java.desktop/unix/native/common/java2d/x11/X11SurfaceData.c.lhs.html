<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/native/common/java2d/x11/X11SurfaceData.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include &quot;X11SurfaceData.h&quot;
  27 #include &quot;GraphicsPrimitiveMgr.h&quot;
  28 #include &quot;Region.h&quot;
  29 #include &quot;Trace.h&quot;
  30 
  31 /* Needed to define intptr_t */
  32 #include &quot;gdefs.h&quot;
  33 
  34 #include &quot;jni_util.h&quot;
  35 #include &quot;jvm_md.h&quot;
  36 #include &quot;awt_Component.h&quot;
  37 #include &quot;awt_GraphicsEnv.h&quot;
  38 
  39 #include &lt;dlfcn.h&gt;
  40 
  41 #ifndef HEADLESS
  42 
  43 /**
  44  * This file contains support code for loops using the SurfaceData
  45  * interface to talk to an X11 drawable from native code.
  46  */
  47 
  48 typedef struct _X11RIPrivate {
  49     jint                lockType;
  50     jint                lockFlags;
  51     XImage              *img;
  52     int                 x, y;
  53 } X11RIPrivate;
  54 
  55 #define XSD_MAX(a,b) ((a) &gt; (b) ? (a) : (b))
  56 #define XSD_MIN(a,b) ((a) &lt; (b) ? (a) : (b))
  57 
  58 static LockFunc X11SD_Lock;
  59 static GetRasInfoFunc X11SD_GetRasInfo;
  60 static UnlockFunc X11SD_Unlock;
  61 static DisposeFunc X11SD_Dispose;
  62 static GetPixmapBgFunc X11SD_GetPixmapWithBg;
  63 static ReleasePixmapBgFunc X11SD_ReleasePixmapWithBg;
  64 extern int XShmAttachXErrHandler(Display *display, XErrorEvent *xerr);
  65 extern AwtGraphicsConfigDataPtr
  66     getGraphicsConfigFromComponentPeer(JNIEnv *env, jobject this);
  67 extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
  68 
  69 static int X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  70                           X11SDOps *xsdo);
  71 static int X11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
  72                             X11SDOps *xsdo);
  73 static void X11SD_SwapBytes(X11SDOps *xsdo, XImage *img, int depth, int bpp);
  74 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
  75                                SurfaceDataBounds *bounds,
  76                                jint lockFlags);
<a name="1" id="anc1"></a>
  77 
  78 extern jfieldID validID;
  79 
  80 static int nativeByteOrder;
  81 static jclass xorCompClass;
  82 
  83 jint useMitShmExt = CANT_USE_MITSHM;
  84 jint useMitShmPixmaps = CANT_USE_MITSHM;
  85 jint forceSharedPixmaps = JNI_FALSE;
  86 
  87 #ifdef MITSHM
  88 int mitShmPermissionMask = MITSHM_PERM_OWNER;
  89 #endif
  90 
  91 /* Cached shared image, one for all surface datas. */
  92 static XImage * cachedXImage;
  93 
  94 #endif /* !HEADLESS */
  95 
  96 jboolean XShared_initIDs(JNIEnv *env, jboolean allowShmPixmaps)
  97 {
  98 #ifndef HEADLESS
  99    union {
 100         char c[4];
 101         int i;
 102     } endian;
 103 
 104     endian.i = 0xff000000;
 105     nativeByteOrder = (endian.c[0]) ? MSBFirst : LSBFirst;
 106 
 107     cachedXImage = NULL;
 108 
 109     if (sizeof(X11RIPrivate) &gt; SD_RASINFO_PRIVATE_SIZE) {
 110         JNU_ThrowInternalError(env, &quot;Private RasInfo structure too large!&quot;);
 111         return JNI_FALSE;
 112     }
 113 
 114 #ifdef MITSHM
 115     if (getenv(&quot;NO_AWT_MITSHM&quot;) == NULL &amp;&amp;
 116         getenv(&quot;NO_J2D_MITSHM&quot;) == NULL) {
 117         char * force;
 118         char * permission = getenv(&quot;J2D_MITSHM_PERMISSION&quot;);
 119         if (permission != NULL) {
 120             if (strcmp(permission, &quot;common&quot;) == 0) {
 121                 mitShmPermissionMask = MITSHM_PERM_COMMON;
 122             }
 123         }
 124 
 125         TryInitMITShm(env, &amp;useMitShmExt, &amp;useMitShmPixmaps);
 126 
 127         if(allowShmPixmaps) {
 128           useMitShmPixmaps = (useMitShmPixmaps == CAN_USE_MITSHM);
 129           force = getenv(&quot;J2D_PIXMAPS&quot;);
 130           if (force != NULL) {
 131               if (useMitShmPixmaps &amp;&amp; (strcmp(force, &quot;shared&quot;) == 0)) {
 132                   forceSharedPixmaps = JNI_TRUE;
 133               } else if (strcmp(force, &quot;server&quot;) == 0) {
 134                   useMitShmPixmaps = JNI_FALSE;
 135               }
 136           }
 137         }else {
 138           useMitShmPixmaps = JNI_FALSE;
 139         }
 140     }
 141 #endif /* MITSHM */
 142 
 143 #endif /* !HEADLESS */
 144 
 145     return JNI_TRUE;
 146 }
 147 
 148 
 149 /*
 150  * Class:     sun_java2d_x11_X11SurfaceData
 151  * Method:    initIDs
 152  * Signature: (Ljava/lang/Class;Z)V
 153  */
 154 JNIEXPORT void JNICALL
 155 Java_sun_java2d_x11_X11SurfaceData_initIDs(JNIEnv *env, jclass xsd,
 156                                            jclass XORComp)
 157 {
 158 #ifndef HEADLESS
 159   if(XShared_initIDs(env, JNI_TRUE))
 160   {
 161     xorCompClass = (*env)-&gt;NewGlobalRef(env, XORComp);
 162   }
 163 #endif /* !HEADLESS */
 164 }
 165 
 166 /*
 167  * Class:     sun_java2d_x11_X11SurfaceData
 168  * Method:    isDrawableValid
 169  * Signature: ()Z
 170  */
 171 JNIEXPORT jboolean JNICALL
 172 Java_sun_java2d_x11_XSurfaceData_isDrawableValid(JNIEnv *env, jobject this)
 173 {
 174     jboolean ret = JNI_FALSE;
 175 
 176 #ifndef HEADLESS
 177     X11SDOps *xsdo = X11SurfaceData_GetOps(env, this);
 178 
 179     AWT_LOCK();
 180     if (xsdo-&gt;drawable != 0 || X11SD_InitWindow(env, xsdo) == SD_SUCCESS) {
 181         ret = JNI_TRUE;
 182     }
 183     AWT_UNLOCK();
 184 #endif /* !HEADLESS */
 185 
 186     return ret;
 187 }
 188 
 189 /*
 190  * Class: sun_java2d_x11_X11SurfaceData
 191  * Method: isShmPMAvailable
 192  * Signature: ()Z
 193  */
 194 JNIEXPORT jboolean JNICALL
 195 Java_sun_java2d_x11_X11SurfaceData_isShmPMAvailable(JNIEnv *env, jobject this)
 196 {
 197 #if defined(HEADLESS) || !defined(MITSHM)
 198     return JNI_FALSE;
 199 #else
 200     return (jboolean)useMitShmPixmaps;
 201 #endif /* HEADLESS, MITSHM */
 202 }
 203 
 204 /*
 205  * Class:     sun_java2d_x11_X11SurfaceData
 206  * Method:    initOps
 207  * Signature: (Ljava/lang/Object;I)V
 208  */
 209 JNIEXPORT void JNICALL
 210 Java_sun_java2d_x11_XSurfaceData_initOps(JNIEnv *env, jobject xsd,
 211                                            jobject peer,
 212                                            jobject graphicsConfig, jint depth)
 213 {
 214 #ifndef HEADLESS
 215     X11SDOps *xsdo = (X11SDOps*)SurfaceData_InitOps(env, xsd, sizeof(X11SDOps));
 216     jboolean hasException;
 217     if (xsdo == NULL) {
 218         JNU_ThrowOutOfMemoryError(env, &quot;Initialization of SurfaceData failed.&quot;);
 219         return;
 220     }
 221     xsdo-&gt;sdOps.Lock = X11SD_Lock;
 222     xsdo-&gt;sdOps.GetRasInfo = X11SD_GetRasInfo;
 223     xsdo-&gt;sdOps.Unlock = X11SD_Unlock;
 224     xsdo-&gt;sdOps.Dispose = X11SD_Dispose;
 225     xsdo-&gt;GetPixmapWithBg = X11SD_GetPixmapWithBg;
 226     xsdo-&gt;ReleasePixmapWithBg = X11SD_ReleasePixmapWithBg;
 227     if (peer != NULL) {
 228         xsdo-&gt;drawable = JNU_CallMethodByName(env, &amp;hasException, peer, &quot;getWindow&quot;, &quot;()J&quot;).j;
 229         if (hasException) {
 230             return;
 231         }
 232     } else {
 233         xsdo-&gt;drawable = 0;
 234     }
 235     xsdo-&gt;depth = depth;
 236     xsdo-&gt;isPixmap = JNI_FALSE;
 237     xsdo-&gt;bitmask = 0;
 238     xsdo-&gt;bgPixel = 0;
 239     xsdo-&gt;isBgInitialized = JNI_FALSE;
 240 #ifdef MITSHM
 241     xsdo-&gt;shmPMData.shmSegInfo = NULL;
 242     xsdo-&gt;shmPMData.xRequestSent = JNI_FALSE;
 243     xsdo-&gt;shmPMData.pmSize = 0;
 244     xsdo-&gt;shmPMData.usingShmPixmap = JNI_FALSE;
 245     xsdo-&gt;shmPMData.pixmap = 0;
 246     xsdo-&gt;shmPMData.shmPixmap = 0;
 247     xsdo-&gt;shmPMData.numBltsSinceRead = 0;
 248     xsdo-&gt;shmPMData.pixelsReadSinceBlt = 0;
 249     xsdo-&gt;shmPMData.numBltsThreshold = 2;
 250 #endif /* MITSHM */
 251 
 252     xsdo-&gt;configData = (AwtGraphicsConfigDataPtr)
 253         JNU_GetLongFieldAsPtr(env,
 254                               graphicsConfig,
 255                               x11GraphicsConfigIDs.aData);
 256     if (xsdo-&gt;configData == NULL) {
 257         JNU_ThrowNullPointerException(env,
 258                                       &quot;Native GraphicsConfig data block missing&quot;);
 259         return;
 260     }
 261     if (depth &gt; 12) {
 262         xsdo-&gt;pixelmask = (xsdo-&gt;configData-&gt;awt_visInfo.red_mask |
 263                            xsdo-&gt;configData-&gt;awt_visInfo.green_mask |
 264                            xsdo-&gt;configData-&gt;awt_visInfo.blue_mask);
 265     } else if (depth == 12) {
 266         xsdo-&gt;pixelmask = 0xfff;
 267     } else {
 268         xsdo-&gt;pixelmask = 0xff;
 269     }
 270 
 271     xsdo-&gt;xrPic = None;
 272 #endif /* !HEADLESS */
 273 }
 274 
 275 /*
 276  * Class:     sun_java2d_x11_X11SurfaceData
 277  * Method:    flushNativeSurface
 278  * Signature: ()V
 279  */
 280 JNIEXPORT void JNICALL
 281 Java_sun_java2d_x11_XSurfaceData_flushNativeSurface(JNIEnv *env, jobject xsd)
 282 {
 283 #ifndef HEADLESS
 284     SurfaceDataOps *ops = SurfaceData_GetOps(env, xsd);
 285 
 286     if (ops != NULL) {
 287         X11SD_Dispose(env, ops);
 288     }
 289 #endif /* !HEADLESS */
 290 }
 291 
 292 
 293 JNIEXPORT X11SDOps * JNICALL
 294 X11SurfaceData_GetOps(JNIEnv *env, jobject sData)
 295 {
 296 #ifdef HEADLESS
 297     return NULL;
 298 #else
 299     SurfaceDataOps *ops = SurfaceData_GetOps(env, sData);
 300     if (ops != NULL &amp;&amp; ops-&gt;Lock != X11SD_Lock) {
 301         SurfaceData_ThrowInvalidPipeException(env, &quot;not an X11 SurfaceData&quot;);
 302         ops = NULL;
 303     }
 304     return (X11SDOps *) ops;
 305 #endif /* !HEADLESS */
 306 }
 307 
 308 /*
 309  * Method for disposing X11SD-specific data
 310  */
 311 static void
 312 X11SD_Dispose(JNIEnv *env, SurfaceDataOps *ops)
 313 {
 314 #ifndef HEADLESS
 315     /* ops is assumed non-null as it is checked in SurfaceData_DisposeOps */
 316     X11SDOps * xsdo = (X11SDOps*)ops;
 317 
 318     AWT_LOCK();
 319 
 320     xsdo-&gt;invalid = JNI_TRUE;
 321 
 322     if (xsdo-&gt;xrPic != None) {
 323         XRenderFreePicture(awt_display, xsdo-&gt;xrPic);
 324         xsdo-&gt;xrPic = None;
 325      }
 326 
 327     if (xsdo-&gt;isPixmap == JNI_TRUE &amp;&amp; xsdo-&gt;drawable != 0) {
 328 #ifdef MITSHM
 329         if (xsdo-&gt;shmPMData.shmSegInfo != NULL) {
 330             X11SD_DropSharedSegment(xsdo-&gt;shmPMData.shmSegInfo);
 331             xsdo-&gt;shmPMData.shmSegInfo = NULL;
 332         }
 333         if (xsdo-&gt;shmPMData.pixmap) {
 334             XFreePixmap(awt_display, xsdo-&gt;shmPMData.pixmap);
 335             xsdo-&gt;shmPMData.pixmap = 0;
 336         }
 337         if (xsdo-&gt;shmPMData.shmPixmap) {
 338             XFreePixmap(awt_display, xsdo-&gt;shmPMData.shmPixmap);
 339             xsdo-&gt;shmPMData.shmPixmap = 0;
 340         }
 341 #else
 342         XFreePixmap(awt_display, xsdo-&gt;drawable);
 343 #endif /* MITSHM */
 344         xsdo-&gt;drawable = 0;
 345     }
 346     if (xsdo-&gt;bitmask != 0) {
 347         XFreePixmap(awt_display, xsdo-&gt;bitmask);
 348         xsdo-&gt;bitmask = 0;
 349     }
 350     if (xsdo-&gt;javaGC != NULL) {
 351         XFreeGC(awt_display, xsdo-&gt;javaGC);
 352         xsdo-&gt;javaGC = NULL;
 353     }
 354     if (xsdo-&gt;cachedGC != NULL) {
 355         XFreeGC(awt_display, xsdo-&gt;cachedGC);
 356         xsdo-&gt;cachedGC = NULL;
 357     }
 358 
 359     if(xsdo-&gt;xrPic != None) {
 360       XRenderFreePicture(awt_display, xsdo-&gt;xrPic);
 361     }
 362 
 363     AWT_UNLOCK();
 364 #endif /* !HEADLESS */
 365 }
 366 /*
 367  * Class:     sun_java2d_x11_X11SurfaceData
 368  * Method:    setInvalid
 369  * Signature: ()V
 370  */
 371 JNIEXPORT void JNICALL
 372 Java_sun_java2d_x11_XSurfaceData_setInvalid(JNIEnv *env, jobject xsd)
 373 {
 374 #ifndef HEADLESS
 375     X11SDOps *xsdo = (X11SDOps *) SurfaceData_GetOps(env, xsd);
 376 
 377     if (xsdo != NULL) {
 378         xsdo-&gt;invalid = JNI_TRUE;
 379     }
 380 #endif /* !HEADLESS */
 381 }
 382 
 383 
 384 jboolean XShared_initSurface(JNIEnv *env, X11SDOps *xsdo, jint depth, jint width, jint height, jlong drawable)
 385 {
 386 #ifndef HEADLESS
 387 
 388     if (drawable != (jlong)0) {
 389         /* Double-buffering */
 390         xsdo-&gt;drawable = drawable;
 391         xsdo-&gt;isPixmap = JNI_FALSE;
 392     } else {
<a name="2" id="anc2"></a>


 393         /*
 394          * width , height must be nonzero otherwise XCreatePixmap
 395          * generates BadValue in error_handler
 396          */
 397         if (width &lt;= 0 || height &lt;= 0 || width &gt; 32767 || height &gt; 32767) {
<a name="3" id="anc3"></a>


















 398             JNU_ThrowOutOfMemoryError(env,
 399                                   &quot;Can&#39;t create offscreen surface&quot;);
 400             return JNI_FALSE;
 401         }
 402         xsdo-&gt;isPixmap = JNI_TRUE;
 403 
 404         xsdo-&gt;pmWidth = width;
 405         xsdo-&gt;pmHeight = height;
 406 
 407 #ifdef MITSHM
<a name="4" id="anc4"></a><span class="line-modified"> 408         xsdo-&gt;shmPMData.pmSize = width * height * depth;</span>
 409         xsdo-&gt;shmPMData.pixelsReadThreshold = width * height / 8;
 410         if (forceSharedPixmaps) {
 411             AWT_LOCK();
 412             xsdo-&gt;drawable = X11SD_CreateSharedPixmap(xsdo);
 413             AWT_UNLOCK();
 414             JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 415             if (xsdo-&gt;drawable) {
 416                 xsdo-&gt;shmPMData.usingShmPixmap = JNI_TRUE;
 417                 xsdo-&gt;shmPMData.shmPixmap = xsdo-&gt;drawable;
 418                 return JNI_TRUE;
 419             }
 420         }
 421 #endif /* MITSHM */
 422 
 423         AWT_LOCK();
 424         xsdo-&gt;drawable =
 425             XCreatePixmap(awt_display,
 426                           RootWindow(awt_display,
 427                                      xsdo-&gt;configData-&gt;awt_visInfo.screen),
 428                           width, height, depth);
 429         AWT_UNLOCK();
 430         JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);
 431 #ifdef MITSHM
 432         xsdo-&gt;shmPMData.usingShmPixmap = JNI_FALSE;
 433         xsdo-&gt;shmPMData.pixmap = xsdo-&gt;drawable;
 434 #endif /* MITSHM */
 435     }
 436     if (xsdo-&gt;drawable == 0) {
 437         JNU_ThrowOutOfMemoryError(env,
 438                                   &quot;Can&#39;t create offscreen surface&quot;);
 439         return JNI_FALSE;
 440     }
 441 
 442 #endif /* !HEADLESS */
 443     return JNI_TRUE;
 444 }
 445 
 446 
 447 /*
 448  * Class:     sun_java2d_x11_X11SurfaceData
 449  * Method:    initSurface
 450  * Signature: ()V
 451  */
 452 JNIEXPORT void JNICALL
 453 Java_sun_java2d_x11_X11SurfaceData_initSurface(JNIEnv *env, jclass xsd,
 454                                                jint depth,
 455                                                jint width, jint height,
 456                                                jlong drawable)
 457 {
 458 #ifndef HEADLESS
 459     X11SDOps *xsdo = X11SurfaceData_GetOps(env, xsd);
 460     if (xsdo == NULL) {
 461         return;
 462     }
 463 
 464     if (xsdo-&gt;configData-&gt;awt_cmap == (Colormap)NULL) {
 465         awtJNI_CreateColorData(env, xsdo-&gt;configData, 1);
 466         JNU_CHECK_EXCEPTION(env);
 467     }
 468     /* color_data will be initialized in awtJNI_CreateColorData for
 469        8-bit visuals */
 470     xsdo-&gt;cData = xsdo-&gt;configData-&gt;color_data;
 471 
 472     XShared_initSurface(env, xsdo, depth, width, height, drawable);
 473     xsdo-&gt;xrPic = None;
 474 #endif /* !HEADLESS */
 475 }
 476 
 477 #ifndef HEADLESS
 478 
 479 #ifdef MITSHM
 480 
 481 void X11SD_DropSharedSegment(XShmSegmentInfo *shminfo)
 482 {
 483     if (shminfo != NULL) {
 484         XShmDetach(awt_display, shminfo);
 485         shmdt(shminfo-&gt;shmaddr);
 486 /*      REMIND: we don&#39;t need shmctl(shminfo-&gt;shmid, IPC_RMID, 0); here. */
 487 /*      Check X11SD_CreateSharedImage() for the explanation */
 488     }
 489 }
 490 
 491 XImage* X11SD_CreateSharedImage(X11SDOps *xsdo,
 492                                    jint width, jint height)
 493 {
 494     XImage *img = NULL;
 495     XShmSegmentInfo *shminfo;
 496 
 497     shminfo = malloc(sizeof(XShmSegmentInfo));
 498     if (shminfo == NULL) {
 499         return NULL;
 500     }
 501     memset(shminfo, 0, sizeof(XShmSegmentInfo));
 502 
 503     img = XShmCreateImage(awt_display, xsdo-&gt;configData-&gt;awt_visInfo.visual,
 504                           xsdo-&gt;depth, ZPixmap, NULL, shminfo,
 505                           width, height);
 506     if (img == NULL) {
 507         free((void *)shminfo);
 508         return NULL;
 509     }
 510     shminfo-&gt;shmid =
<a name="5" id="anc5"></a><span class="line-modified"> 511         shmget(IPC_PRIVATE, height * img-&gt;bytes_per_line,</span>
 512                IPC_CREAT|mitShmPermissionMask);
 513     if (shminfo-&gt;shmid &lt; 0) {
 514         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 515                        &quot;X11SD_SetupSharedSegment shmget has failed: %s&quot;,
 516                        strerror(errno));
 517         free((void *)shminfo);
 518         XDestroyImage(img);
 519         return NULL;
 520     }
 521 
 522     shminfo-&gt;shmaddr = (char *) shmat(shminfo-&gt;shmid, 0, 0);
 523     if (shminfo-&gt;shmaddr == ((char *) -1)) {
 524         shmctl(shminfo-&gt;shmid, IPC_RMID, 0);
 525         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 526                        &quot;X11SD_SetupSharedSegment shmat has failed: %s&quot;,
 527                        strerror(errno));
 528         free((void *)shminfo);
 529         XDestroyImage(img);
 530         return NULL;
 531     }
 532 
 533     shminfo-&gt;readOnly = False;
 534 
 535     resetXShmAttachFailed();
 536     EXEC_WITH_XERROR_HANDLER(XShmAttachXErrHandler,
 537                              XShmAttach(awt_display, shminfo));
 538 
 539     /*
 540      * Once the XSync round trip has finished then we
 541      * can get rid of the id so that this segment does not stick
 542      * around after we go away, holding system resources.
 543      */
 544     shmctl(shminfo-&gt;shmid, IPC_RMID, 0);
 545 
 546     if (isXShmAttachFailed() == JNI_TRUE) {
 547         J2dRlsTraceLn1(J2D_TRACE_ERROR,
 548                        &quot;X11SD_SetupSharedSegment XShmAttach has failed: %s&quot;,
 549                        strerror(errno));
 550         shmdt(shminfo-&gt;shmaddr);
 551         free((void *)shminfo);
 552         XDestroyImage(img);
 553         return NULL;
 554     }
 555 
 556     img-&gt;data = shminfo-&gt;shmaddr;
 557     img-&gt;obdata = (char *)shminfo;
 558 
 559     return img;
 560 }
 561 
 562 XImage* X11SD_GetSharedImage(X11SDOps *xsdo, jint width, jint height,
 563                              jint maxWidth, jint maxHeight, jboolean readBits)
 564 {
 565     XImage * retImage = NULL;
 566     if (cachedXImage != NULL &amp;&amp;
 567         X11SD_CachedXImageFits(width, height, maxWidth, maxHeight,
 568                                xsdo-&gt;depth, readBits)) {
 569         /* sync so previous data gets flushed */
 570         XSync(awt_display, False);
 571         retImage = cachedXImage;
 572         cachedXImage = (XImage *)NULL;
<a name="6" id="anc6"></a><span class="line-modified"> 573     } else if (width * height * xsdo-&gt;depth &gt; 0x10000) {</span>
 574         retImage = X11SD_CreateSharedImage(xsdo, width, height);
 575     }
 576     return retImage;
 577 }
 578 
 579 Drawable X11SD_CreateSharedPixmap(X11SDOps *xsdo)
 580 {
 581     XShmSegmentInfo *shminfo;
 582     XImage *img = NULL;
 583     Drawable pixmap;
 584     int scan;
 585     int width = xsdo-&gt;pmWidth;
 586     int height = xsdo-&gt;pmHeight;
 587 
 588     if (xsdo-&gt;shmPMData.pmSize &lt; 0x10000) {
 589         /* only use shared mem pixmaps for relatively big images */
 590         return 0;
 591     }
 592 
 593     /* need to create shared(!) image to get bytes_per_line */
 594     img = X11SD_CreateSharedImage(xsdo, width, height);
 595     if (img == NULL) {
 596         return 0;
 597     }
 598     scan = img-&gt;bytes_per_line;
 599     shminfo = (XShmSegmentInfo*)img-&gt;obdata;
 600     XFree(img);
 601 
 602     pixmap =
 603         XShmCreatePixmap(awt_display,
 604                          RootWindow(awt_display,
 605                                     xsdo-&gt;configData-&gt;awt_visInfo.screen),
 606                          shminfo-&gt;shmaddr, shminfo,
 607                          width, height, xsdo-&gt;depth);
 608     if (pixmap == 0) {
 609         X11SD_DropSharedSegment(shminfo);
 610         return 0;
 611     }
 612 
 613     xsdo-&gt;shmPMData.shmSegInfo = shminfo;
 614     xsdo-&gt;shmPMData.bytesPerLine = scan;
 615     return pixmap;
 616 }
 617 
 618 void X11SD_PuntPixmap(X11SDOps *xsdo, jint width, jint height)
 619 {
 620 
 621     if (useMitShmPixmaps != CAN_USE_MITSHM || forceSharedPixmaps) {
 622         return;
 623     }
 624 
 625     /* we wouldn&#39;t be here if it&#39;s a shared pixmap, so no check
 626      * for !usingShmPixmap.
 627      */
 628 
 629     xsdo-&gt;shmPMData.numBltsSinceRead = 0;
 630 
 631     xsdo-&gt;shmPMData.pixelsReadSinceBlt += width * height;
 632     if (xsdo-&gt;shmPMData.pixelsReadSinceBlt &gt;
 633         xsdo-&gt;shmPMData.pixelsReadThreshold) {
 634         if (!xsdo-&gt;shmPMData.shmPixmap) {
 635             xsdo-&gt;shmPMData.shmPixmap =
 636                 X11SD_CreateSharedPixmap(xsdo);
 637         }
 638         if (xsdo-&gt;shmPMData.shmPixmap) {
 639             GC xgc = XCreateGC(awt_display, xsdo-&gt;shmPMData.shmPixmap, 0L, NULL);
 640             if (xgc != NULL) {
 641                 xsdo-&gt;shmPMData.usingShmPixmap = JNI_TRUE;
 642                 xsdo-&gt;drawable = xsdo-&gt;shmPMData.shmPixmap;
 643                 XCopyArea(awt_display,
 644                           xsdo-&gt;shmPMData.pixmap, xsdo-&gt;drawable, xgc,
 645                           0, 0, xsdo-&gt;pmWidth, xsdo-&gt;pmHeight, 0, 0);
 646                 XSync(awt_display, False);
 647                 xsdo-&gt;shmPMData.xRequestSent = JNI_FALSE;
 648                 XFreeGC(awt_display, xgc);
 649             }
 650         }
 651     }
 652 }
 653 
 654 void X11SD_UnPuntPixmap(X11SDOps *xsdo)
 655 {
 656     if (useMitShmPixmaps != CAN_USE_MITSHM || forceSharedPixmaps) {
 657         return;
 658     }
 659     xsdo-&gt;shmPMData.pixelsReadSinceBlt = 0;
 660     if (xsdo-&gt;shmPMData.numBltsSinceRead &gt;=
 661         xsdo-&gt;shmPMData.numBltsThreshold)
 662     {
 663         if (xsdo-&gt;shmPMData.usingShmPixmap) {
 664             if (!xsdo-&gt;shmPMData.pixmap) {
 665                 xsdo-&gt;shmPMData.pixmap =
 666                     XCreatePixmap(awt_display,
 667                                   RootWindow(awt_display,
 668                                              xsdo-&gt;configData-&gt;awt_visInfo.screen),
 669                                   xsdo-&gt;pmWidth, xsdo-&gt;pmHeight, xsdo-&gt;depth);
 670             }
 671             if (xsdo-&gt;shmPMData.pixmap) {
 672                 GC xgc = XCreateGC(awt_display, xsdo-&gt;shmPMData.pixmap, 0L, NULL);
 673                 if (xgc != NULL) {
 674                     xsdo-&gt;drawable = xsdo-&gt;shmPMData.pixmap;
 675                     XCopyArea(awt_display,
 676                               xsdo-&gt;shmPMData.shmPixmap, xsdo-&gt;drawable, xgc,
 677                               0, 0, xsdo-&gt;pmWidth, xsdo-&gt;pmHeight, 0, 0);
 678                     XSync(awt_display, False);
 679                     XFreeGC(awt_display, xgc);
 680                     xsdo-&gt;shmPMData.xRequestSent = JNI_FALSE;
 681                     xsdo-&gt;shmPMData.usingShmPixmap = JNI_FALSE;
 682                     xsdo-&gt;shmPMData.numBltsThreshold *= 2;
 683                 }
 684             }
 685         }
 686     } else {
 687         xsdo-&gt;shmPMData.numBltsSinceRead++;
 688     }
 689 }
 690 
 691 /**
 692  * Determines if the cached image can be used for current operation.
 693  * If the image is to be used to be read into by XShmGetImage,
 694  * it must be close enough to avoid excessive reading from the screen;
 695  * otherwise it should just be at least the size requested.
 696  */
 697 jboolean X11SD_CachedXImageFits(jint width, jint height, jint maxWidth,
 698                                 jint maxHeight, jint depth, jboolean readBits)
 699 {
 700     /* we assume here that the cached image exists */
 701     jint imgWidth = cachedXImage-&gt;width;
 702     jint imgHeight = cachedXImage-&gt;height;
 703 
 704     if (imgWidth &lt; width || imgHeight &lt; height || depth != cachedXImage-&gt;depth)  {
 705         /* doesn&#39;t fit if any of the cached image dimensions is smaller
 706            or the depths are different */
 707         return JNI_FALSE;
 708     }
 709 
 710     if (!readBits) {
 711         /* Not reading from this image, so any image at least of the
 712            size requested will do */
 713         return JNI_TRUE;
 714     }
 715 
 716     if ((imgWidth &lt; width + 64) &amp;&amp; (imgHeight &lt; height + 64)
 717          &amp;&amp; imgWidth &lt;= maxWidth &amp;&amp; imgHeight &lt;= maxHeight)
 718     {
 719         /* Cached image&#39;s width/height shouldn&#39;t be more than 64 pixels
 720          * larger than requested, because the region in XShmGetImage
 721          * can&#39;t be specified and we don&#39;t want to read too much.
 722          * Furthermore it has to be smaller than maxWidth/Height
 723          * so drawables are not read out of bounds.
 724          */
 725         return JNI_TRUE;
 726     }
 727 
 728     return JNI_FALSE;
 729 }
 730 #endif /* MITSHM */
 731 
 732 jint X11SD_InitWindow(JNIEnv *env, X11SDOps *xsdo)
 733 {
 734     if (xsdo-&gt;isPixmap == JNI_TRUE) {
 735         return SD_FAILURE;
 736     }
 737     xsdo-&gt;cData = xsdo-&gt;configData-&gt;color_data;
 738 
 739     return SD_SUCCESS;
 740 }
 741 
 742 static jint X11SD_Lock(JNIEnv *env,
 743                        SurfaceDataOps *ops,
 744                        SurfaceDataRasInfo *pRasInfo,
 745                        jint lockflags)
 746 {
 747     X11SDOps *xsdo = (X11SDOps *) ops;
 748     X11RIPrivate *xpriv = (X11RIPrivate *) &amp;(pRasInfo-&gt;priv);
 749     int ret = SD_SUCCESS;
 750 
 751     AWT_LOCK();
 752 
 753     if (xsdo-&gt;invalid) {
 754         AWT_UNLOCK();
 755         SurfaceData_ThrowInvalidPipeException(env, &quot;bounds changed&quot;);
 756         return SD_FAILURE;
 757     }
 758     xsdo-&gt;cData = xsdo-&gt;configData-&gt;color_data;
 759     if (xsdo-&gt;drawable == 0 &amp;&amp; X11SD_InitWindow(env, xsdo) == SD_FAILURE) {
 760         AWT_UNLOCK();
 761         return SD_FAILURE;
 762     }
 763     if ((lockflags &amp; SD_LOCK_LUT) != 0 &amp;&amp;
 764         (xsdo-&gt;cData == NULL ||
 765          xsdo-&gt;cData-&gt;awt_icmLUT == NULL))
 766     {
 767         AWT_UNLOCK();
 768         if (!(*env)-&gt;ExceptionCheck(env))
 769         {
 770              JNU_ThrowNullPointerException(env, &quot;colormap lookup table&quot;);
 771         }
 772         return SD_FAILURE;
 773     }
 774     if ((lockflags &amp; SD_LOCK_INVCOLOR) != 0 &amp;&amp;
 775         (xsdo-&gt;cData == NULL ||
 776          xsdo-&gt;cData-&gt;img_clr_tbl == NULL ||
 777          xsdo-&gt;cData-&gt;img_oda_red == NULL ||
 778          xsdo-&gt;cData-&gt;img_oda_green == NULL ||
 779          xsdo-&gt;cData-&gt;img_oda_blue == NULL))
 780     {
 781         AWT_UNLOCK();
 782         if (!(*env)-&gt;ExceptionCheck(env))
 783         {
 784              JNU_ThrowNullPointerException(env, &quot;inverse colormap lookup table&quot;);
 785         }
 786         return SD_FAILURE;
 787     }
 788     if ((lockflags &amp; SD_LOCK_INVGRAY) != 0 &amp;&amp;
 789         (xsdo-&gt;cData == NULL ||
 790          xsdo-&gt;cData-&gt;pGrayInverseLutData == NULL))
 791     {
 792         AWT_UNLOCK();
 793         if (!(*env)-&gt;ExceptionCheck(env))
 794         {
 795             JNU_ThrowNullPointerException(env, &quot;inverse gray lookup table&quot;);
 796         }
 797         return SD_FAILURE;
 798     }
 799     if (lockflags &amp; SD_LOCK_RD_WR) {
 800         if (lockflags &amp; SD_LOCK_FASTEST) {
 801             ret = SD_SLOWLOCK;
 802         }
 803         xpriv-&gt;lockType = X11SD_LOCK_BY_XIMAGE;
 804         if (xsdo-&gt;isPixmap) {
 805 #ifdef MITSHM
 806             if (xsdo-&gt;shmPMData.usingShmPixmap) {
 807                 xpriv-&gt;lockType = X11SD_LOCK_BY_SHMEM;
 808             }
 809 #endif /* MITSHM */
 810             if (pRasInfo-&gt;bounds.x1 &lt; 0) {
 811                 pRasInfo-&gt;bounds.x1 = 0;
 812             }
 813             if (pRasInfo-&gt;bounds.y1 &lt; 0) {
 814                 pRasInfo-&gt;bounds.y1 = 0;
 815             }
 816             if (pRasInfo-&gt;bounds.x2 &gt; xsdo-&gt;pmWidth) {
 817                 pRasInfo-&gt;bounds.x2 = xsdo-&gt;pmWidth;
 818             }
 819             if (pRasInfo-&gt;bounds.y2 &gt; xsdo-&gt;pmHeight) {
 820                 pRasInfo-&gt;bounds.y2 = xsdo-&gt;pmHeight;
 821             }
 822         }
 823     } else {
 824         /* They didn&#39;t lock for anything - we won&#39;t give them anything */
 825         xpriv-&gt;lockType = X11SD_LOCK_BY_NULL;
 826     }
 827     xpriv-&gt;lockFlags = lockflags;
 828     xpriv-&gt;img = NULL;
 829 
 830     return ret;
 831     /* AWT_UNLOCK() called in Unlock */
 832 }
 833 
 834 static void X11SD_GetRasInfo(JNIEnv *env,
 835                              SurfaceDataOps *ops,
 836                              SurfaceDataRasInfo *pRasInfo)
 837 {
 838     X11SDOps *xsdo = (X11SDOps *) ops;
 839     X11RIPrivate *xpriv = (X11RIPrivate *) &amp;(pRasInfo-&gt;priv);
 840     jint lockFlags = xpriv-&gt;lockFlags;
 841     jint depth = xsdo-&gt;depth;
 842     int mult = xsdo-&gt;configData-&gt;pixelStride;
 843 
 844 
 845 #ifdef MITSHM
 846     if (xpriv-&gt;lockType == X11SD_LOCK_BY_SHMEM) {
 847         if (xsdo-&gt;shmPMData.xRequestSent == JNI_TRUE) {
 848             /* need to sync before using shared mem pixmap
 849              if any x calls were issued for this pixmap */
 850             XSync(awt_display, False);
 851             xsdo-&gt;shmPMData.xRequestSent = JNI_FALSE;
 852         }
 853         xpriv-&gt;x = pRasInfo-&gt;bounds.x1;
 854         xpriv-&gt;y = pRasInfo-&gt;bounds.y1;
 855         pRasInfo-&gt;rasBase = xsdo-&gt;shmPMData.shmSegInfo-&gt;shmaddr;
 856         pRasInfo-&gt;pixelStride = mult;
 857         pRasInfo-&gt;pixelBitOffset = 0;
 858         pRasInfo-&gt;scanStride = xsdo-&gt;shmPMData.bytesPerLine;
 859     } else
 860 #endif /* MITSHM */
 861     if (xpriv-&gt;lockType == X11SD_LOCK_BY_XIMAGE) {
 862         int x, y, w, h;
 863         x = pRasInfo-&gt;bounds.x1;
 864         y = pRasInfo-&gt;bounds.y1;
 865         w = pRasInfo-&gt;bounds.x2 - x;
 866         h = pRasInfo-&gt;bounds.y2 - y;
 867 
 868         xpriv-&gt;img = X11SD_GetImage(env, xsdo, &amp;pRasInfo-&gt;bounds, lockFlags);
 869         if (xpriv-&gt;img) {
 870             int scan = xpriv-&gt;img-&gt;bytes_per_line;
 871             xpriv-&gt;x = x;
 872             xpriv-&gt;y = y;
<a name="7" id="anc7"></a><span class="line-modified"> 873             pRasInfo-&gt;rasBase = xpriv-&gt;img-&gt;data - x * mult - y * scan;</span>
 874             pRasInfo-&gt;pixelStride = mult;
 875             pRasInfo-&gt;pixelBitOffset = 0;
 876             pRasInfo-&gt;scanStride = scan;
 877         } else {
 878             pRasInfo-&gt;rasBase = NULL;
 879             pRasInfo-&gt;pixelStride = 0;
 880             pRasInfo-&gt;pixelBitOffset = 0;
 881             pRasInfo-&gt;scanStride = 0;
 882         }
 883     } else {
 884         /* They didn&#39;t lock for anything - we won&#39;t give them anything */
 885         pRasInfo-&gt;rasBase = NULL;
 886         pRasInfo-&gt;pixelStride = 0;
 887         pRasInfo-&gt;pixelBitOffset = 0;
 888         pRasInfo-&gt;scanStride = 0;
 889     }
 890     if (lockFlags &amp; SD_LOCK_LUT) {
 891         pRasInfo-&gt;lutBase = (jint *) xsdo-&gt;cData-&gt;awt_icmLUT;
 892         pRasInfo-&gt;lutSize = xsdo-&gt;cData-&gt;awt_numICMcolors;
 893     } else {
 894         pRasInfo-&gt;lutBase = NULL;
 895         pRasInfo-&gt;lutSize = 0;
 896     }
 897     if (lockFlags &amp; SD_LOCK_INVCOLOR) {
 898         pRasInfo-&gt;invColorTable = xsdo-&gt;cData-&gt;img_clr_tbl;
 899         pRasInfo-&gt;redErrTable = xsdo-&gt;cData-&gt;img_oda_red;
 900         pRasInfo-&gt;grnErrTable = xsdo-&gt;cData-&gt;img_oda_green;
 901         pRasInfo-&gt;bluErrTable = xsdo-&gt;cData-&gt;img_oda_blue;
 902     } else {
 903         pRasInfo-&gt;invColorTable = NULL;
 904         pRasInfo-&gt;redErrTable = NULL;
 905         pRasInfo-&gt;grnErrTable = NULL;
 906         pRasInfo-&gt;bluErrTable = NULL;
 907     }
 908     if (lockFlags &amp; SD_LOCK_INVGRAY) {
 909         pRasInfo-&gt;invGrayTable = xsdo-&gt;cData-&gt;pGrayInverseLutData;
 910     } else {
 911         pRasInfo-&gt;invGrayTable = NULL;
 912     }
 913 }
 914 
 915 static void X11SD_Unlock(JNIEnv *env,
 916                          SurfaceDataOps *ops,
 917                          SurfaceDataRasInfo *pRasInfo)
 918 {
 919     X11SDOps *xsdo = (X11SDOps *) ops;
 920     X11RIPrivate *xpriv = (X11RIPrivate *) &amp;(pRasInfo-&gt;priv);
 921 
 922     if (xpriv-&gt;lockType == X11SD_LOCK_BY_XIMAGE &amp;&amp;
 923                xpriv-&gt;img != NULL)
 924     {
 925         if (xpriv-&gt;lockFlags &amp; SD_LOCK_WRITE) {
 926             int x = xpriv-&gt;x;
 927             int y = xpriv-&gt;y;
 928             int w = pRasInfo-&gt;bounds.x2 - x;
 929             int h = pRasInfo-&gt;bounds.y2 - y;
 930             Drawable drawable = xsdo-&gt;drawable;
 931             GC xgc = xsdo-&gt;cachedGC;
 932             if (xgc == NULL) {
 933                 xsdo-&gt;cachedGC = xgc =
 934                     XCreateGC(awt_display, drawable, 0L, NULL);
 935             }
 936 
 937             if (xpriv-&gt;img-&gt;byte_order != nativeByteOrder) {
 938                 /* switching bytes back in 24 and 32 bpp cases. */
 939                 /* For 16 bit XLib will switch for us.          */
 940                 if (xsdo-&gt;depth &gt; 16) {
 941                     X11SD_SwapBytes(xsdo, xpriv-&gt;img, xsdo-&gt;depth,
 942                         xsdo-&gt;configData-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel);
 943                 }
 944             }
 945 
 946 #ifdef MITSHM
 947             if (xpriv-&gt;img-&gt;obdata != NULL) {
 948                 XShmPutImage(awt_display, drawable, xgc,
 949                              xpriv-&gt;img, 0, 0, x, y, w, h, False);
 950                 XFlush(awt_display);
 951             } else {
 952                 XPutImage(awt_display, drawable, xgc,
 953                           xpriv-&gt;img, 0, 0, x, y, w, h);
 954             }
 955             if (xsdo-&gt;shmPMData.usingShmPixmap) {
 956                 xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
 957             }
 958 #else
 959             XPutImage(awt_display, drawable, xgc,
 960                       xpriv-&gt;img, 0, 0, x, y, w, h);
 961 #endif /* MITSHM */
 962 
 963         }
 964         X11SD_DisposeOrCacheXImage(xpriv-&gt;img);
 965         xpriv-&gt;img = (XImage *)NULL;
 966     }
 967     /* the background pixel is not valid anymore */
 968     if (xpriv-&gt;lockFlags &amp; SD_LOCK_WRITE) {
 969         xsdo-&gt;isBgInitialized = JNI_FALSE;
 970     }
 971     xpriv-&gt;lockType = X11SD_LOCK_UNLOCKED;
 972     AWT_UNLOCK();
 973 }
 974 
 975 static int
 976 X11SD_ClipToRoot(SurfaceDataBounds *b, SurfaceDataBounds *bounds,
 977                  X11SDOps *xsdo)
 978 {
 979     short x1=0, y1=0, x2=0, y2=0;
 980     int tmpx, tmpy;
 981     Window tmpchild;
 982 
 983     Window window = (Window)(xsdo-&gt;drawable); /* is always a Window */
 984     XWindowAttributes winAttr;
 985 
 986     Status status = XGetWindowAttributes(awt_display, window, &amp;winAttr);
 987     if (status == 0) {
 988         /* Failure, X window no longer valid. */
 989         return FALSE;
 990     }
 991     if (!XTranslateCoordinates(awt_display, window,
 992                                RootWindowOfScreen(winAttr.screen),
 993                                0, 0, &amp;tmpx, &amp;tmpy, &amp;tmpchild)) {
 994         return FALSE;
 995     }
 996 
 997     x1 = -(x1 + tmpx);
 998     y1 = -(y1 + tmpy);
 999 
1000     x2 = x1 + DisplayWidth(awt_display, xsdo-&gt;configData-&gt;awt_visInfo.screen);
1001     y2 = y1 + DisplayHeight(awt_display, xsdo-&gt;configData-&gt;awt_visInfo.screen);
1002 
1003     x1 = XSD_MAX(bounds-&gt;x1, x1);
1004     y1 = XSD_MAX(bounds-&gt;y1, y1);
1005     x2 = XSD_MIN(bounds-&gt;x2, x2);
1006     y2 = XSD_MIN(bounds-&gt;y2, y2);
1007     if ((x1 &gt;= x2) || (y1 &gt;= y2)) {
1008         return FALSE;
1009     }
1010     b-&gt;x1 = x1;
1011     b-&gt;y1 = y1;
1012     b-&gt;x2 = x2;
1013     b-&gt;y2 = y2;
1014 
1015     return TRUE;
1016 }
1017 
1018 /*
1019  * x1, y1, x2, y2 - our rectangle in the coord system of
1020  * the widget
1021  * px1, xy1, px2, py2 - current parent rect coords in the
1022  * same system
1023  */
1024 static int
1025 X11SD_FindClip(SurfaceDataBounds *b, SurfaceDataBounds *bounds, X11SDOps *xsdo)
1026 {
1027     return TRUE;
1028 }
1029 
1030 static void
1031 X11SD_SwapBytes(X11SDOps *xsdo, XImage * img, int depth, int bpp) {
<a name="8" id="anc8"></a><span class="line-modified">1032     int lengthInBytes = img-&gt;height * img-&gt;bytes_per_line;</span>
<span class="line-modified">1033     int i;</span>
1034 
1035     switch (depth) {
1036     case 12:
1037     case 15:
1038     case 16:
1039         {
1040             /* AB -&gt; BA */
1041             unsigned short *d = (unsigned short *)img-&gt;data;
1042             unsigned short t;
1043             for (i = 0; i &lt; lengthInBytes/2; i++) {
1044                 t = *d;
1045                 *d++ = (t &gt;&gt; 8) | (t &lt;&lt; 8);
1046             }
1047             img-&gt;byte_order = nativeByteOrder;
1048             img-&gt;bitmap_bit_order = nativeByteOrder;
1049             break;
1050         }
1051     case 24:
1052         {
1053             /* ABC -&gt; CBA */
1054             if (bpp == 24) {
1055                 // 4517321: Only swap if we have a &quot;real&quot; ThreeByteBgr
1056                 // visual (denoted by a red_mask of 0xff).  Due to ambiguity
1057                 // in the X11 spec, it appears that the swap is not required
1058                 // on Linux configurations that use 24 bits per pixel (denoted
1059                 // by a red_mask of 0xff0000).
1060                 if (xsdo-&gt;configData-&gt;awt_visInfo.red_mask == 0xff) {
1061                     int scan = img-&gt;bytes_per_line;
1062                     unsigned char *d = (unsigned char *) img-&gt;data;
1063                     unsigned char *d1;
1064                     unsigned int t;
1065                     int j;
1066 
1067                     for (i = 0; i &lt; img-&gt;height; i++, d += scan) {
1068                         d1 = d;
1069                         for (j = 0; j &lt; img-&gt;width; j++, d1 += 3) {
1070                             /* not obvious opt from XLib src */
1071                             t = d1[0]; d1[0] = d1[2]; d1[2] = t;
1072                         }
1073                     }
1074                 }
1075                 break;
1076             }
1077         }
1078         /* FALL THROUGH for 32-bit case */
1079     case 32:
1080         {
1081             /* ABCD -&gt; DCBA */
1082             unsigned int *d = (unsigned int *) img-&gt;data;
1083             unsigned int t;
1084             for (i = 0; i &lt; lengthInBytes/4; i++) {
1085                 t = *d;
1086                 *d++ = ((t &gt;&gt; 24) |
1087                         ((t &gt;&gt; 8) &amp; 0xff00) |
1088                         ((t &amp; 0xff00) &lt;&lt; 8) |
1089                         (t &lt;&lt; 24));
1090             }
1091             break;
1092         }
1093     }
1094 }
1095 
1096 static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
1097                                SurfaceDataBounds *bounds,
1098                                jint lockFlags)
1099 {
1100     int x, y, w, h, maxWidth, maxHeight;
1101     int scan;
1102     XImage * img = NULL;
1103     Drawable drawable;
1104     int depth = xsdo-&gt;depth;
1105     int mult = xsdo-&gt;configData-&gt;pixelStride;
<a name="9" id="anc9"></a><span class="line-modified">1106     int pad = (mult == 3) ? 32 : mult * 8; // pad must be 8, 16, or 32</span>
1107     jboolean readBits = lockFlags &amp; SD_LOCK_NEED_PIXELS;
1108 
1109     x = bounds-&gt;x1;
1110     y = bounds-&gt;y1;
1111     w = bounds-&gt;x2 - x;
1112     h = bounds-&gt;y2 - y;
1113 
1114 #ifdef MITSHM
1115     if (useMitShmExt == CAN_USE_MITSHM) {
1116         if (xsdo-&gt;isPixmap) {
1117             if (readBits) {
1118                 X11SD_PuntPixmap(xsdo, w, h);
1119             }
1120             maxWidth = xsdo-&gt;pmWidth;
1121             maxHeight = xsdo-&gt;pmHeight;
1122         } else {
1123             XWindowAttributes winAttr;
1124             if (XGetWindowAttributes(awt_display,
1125                                      (Window) xsdo-&gt;drawable, &amp;winAttr) != 0) {
1126                 maxWidth = winAttr.width;
1127                 maxHeight = winAttr.height;
1128            } else {
1129                 /* XGWA failed which isn&#39;t a good thing. Defaulting to using
1130                  * x,y means that after the subtraction of these we will use
1131                  * w=0, h=0 which is a reasonable default on such a failure.
1132                  */
1133                 maxWidth = x;
1134                 maxHeight = y;
1135            }
1136         }
1137         maxWidth -= x;
1138         maxHeight -= y;
1139 
1140         img = X11SD_GetSharedImage(xsdo, w, h, maxWidth, maxHeight, readBits);
1141     }
1142 #endif /* MITSHM */
1143     drawable = xsdo-&gt;drawable;
1144 
1145     if (readBits) {
1146 #ifdef MITSHM
1147         if (img != NULL) {
1148             if (!XShmGetImage(awt_display, drawable, img, x, y, -1)) {
1149                 X11SD_DisposeOrCacheXImage(img);
1150                 img = NULL;
1151             }
1152         }
1153         if (img == NULL) {
1154             img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1155             if (img != NULL) {
1156                 img-&gt;obdata = NULL;
1157             }
1158         }
1159 #else
1160         img = XGetImage(awt_display, drawable, x, y, w, h, -1, ZPixmap);
1161 #endif /* MITSHM */
1162         if (img == NULL) {
1163             SurfaceDataBounds temp;
1164             img = XCreateImage(awt_display,
1165                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1166                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1167             if (img == NULL) {
1168                 return NULL;
1169             }
1170 
1171             scan = img-&gt;bytes_per_line;
<a name="10" id="anc10"></a><span class="line-modified">1172             img-&gt;data = malloc(h * scan);</span>
1173             if (img-&gt;data == NULL) {
1174                 XFree(img);
1175                 return NULL;
1176             }
1177 
1178             if (xsdo-&gt;isPixmap == JNI_FALSE &amp;&amp;
1179                 X11SD_ClipToRoot(&amp;temp, bounds, xsdo)) {
1180 
1181                 XImage * temp_image;
1182                 temp_image = XGetImage(awt_display, drawable,
1183                                        temp.x1, temp.y1,
1184                                        temp.x2 - temp.x1,
1185                                        temp.y2 - temp.y1,
1186                                        -1, ZPixmap);
1187                 if (temp_image == NULL) {
1188                     XGrabServer(awt_display);
1189                     if (X11SD_FindClip(&amp;temp, bounds, xsdo)) {
1190                         temp_image =
1191                             XGetImage(awt_display, drawable,
1192                                       temp.x1, temp.y1,
1193                                       temp.x2 - temp.x1,
1194                                       temp.y2 - temp.y1,
1195                                       -1, ZPixmap);
1196                     }
1197                     XUngrabServer(awt_display);
1198                     /* Workaround for bug 5039226 */
1199                     XSync(awt_display, False);
1200                 }
1201                 if (temp_image != NULL) {
1202                     int temp_scan, bytes_to_copy;
1203                     char * img_addr, * temp_addr;
1204                     int i;
1205 
1206                     img_addr = img-&gt;data +
<a name="11" id="anc11"></a><span class="line-modified">1207                         (temp.y1 - y) * scan + (temp.x1 - x) * mult;</span>
1208                     temp_scan = temp_image-&gt;bytes_per_line;
1209                     temp_addr = temp_image-&gt;data;
1210                     bytes_to_copy = (temp.x2 - temp.x1) * mult;
1211                     for (i = temp.y1; i &lt; temp.y2; i++) {
1212                         memcpy(img_addr, temp_addr, bytes_to_copy);
1213                         img_addr += scan;
1214                         temp_addr += temp_scan;
1215                     }
1216                     XDestroyImage(temp_image);
1217                 }
1218             }
1219             img-&gt;obdata = NULL;
1220         }
1221         if (depth &gt; 8 &amp;&amp; img-&gt;byte_order != nativeByteOrder) {
1222             X11SD_SwapBytes(xsdo, img, depth,
1223                 xsdo-&gt;configData-&gt;awtImage-&gt;wsImageFormat.bits_per_pixel);
1224         }
1225     } else {
1226         /*
1227          * REMIND: This might be better to move to the Lock function
1228          * to avoid lengthy I/O pauses inside what may be a critical
1229          * section.  This will be more critical when SD_LOCK_READ is
1230          * implemented.  Another solution is to cache the pixels
1231          * to avoid reading for every operation.
1232          */
1233         if (img == NULL) {
1234             img = XCreateImage(awt_display,
1235                                xsdo-&gt;configData-&gt;awt_visInfo.visual,
1236                                depth, ZPixmap, 0, NULL, w, h, pad, 0);
1237             if (img == NULL) {
1238                 return NULL;
1239             }
1240 
<a name="12" id="anc12"></a><span class="line-modified">1241             img-&gt;data = malloc(h * img-&gt;bytes_per_line);</span>
1242             if (img-&gt;data == NULL) {
1243                 XFree(img);
1244                 return NULL;
1245             }
1246 
1247             img-&gt;obdata = NULL;
1248 
1249             if (img-&gt;byte_order != nativeByteOrder &amp;&amp;
1250                 (depth == 15 || depth == 16 || depth == 12)) {
1251                 /* bytes will be swapped by XLib. */
1252                 img-&gt;byte_order = nativeByteOrder;
1253                 img-&gt;bitmap_bit_order = nativeByteOrder;
1254             }
1255         }
1256     }
1257     return img;
1258 }
1259 
1260 void X11SD_DisposeOrCacheXImage(XImage * image) {
1261     /* REMIND: might want to check if the new image worth caching. */
1262     /* Cache only shared images. Passed image is assumed to be non-null. */
1263     if (image-&gt;obdata != NULL) {
1264         if (cachedXImage != NULL) {
1265             X11SD_DisposeXImage(cachedXImage);
1266         }
1267         cachedXImage = image;
1268     } else {
1269         X11SD_DisposeXImage(image);
1270     }
1271 }
1272 
1273 void X11SD_DisposeXImage(XImage * image) {
1274     if (image != NULL) {
1275 #ifdef MITSHM
1276         if (image-&gt;obdata != NULL) {
1277             X11SD_DropSharedSegment((XShmSegmentInfo*)image-&gt;obdata);
1278             image-&gt;obdata = NULL;
1279         }
1280 #endif /* MITSHM */
1281         XDestroyImage(image);
1282     }
1283 }
1284 
1285 void
1286 X11SD_DirectRenderNotify(JNIEnv *env, X11SDOps *xsdo)
1287 {
1288 #ifdef MITSHM
1289     if (xsdo-&gt;shmPMData.usingShmPixmap) {
1290         xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
1291     }
1292 #endif /* MITSHM */
1293     awt_output_flush();
1294 }
1295 
1296 /*
1297  * Sets transparent pixels in the pixmap to
1298  * the specified solid background color and returns it.
1299  * Doesn&#39;t update source pixmap unless the color of the
1300  * transparent pixels is different from the specified color.
1301  *
1302  * Note: The AWT lock must be held by the current thread
1303  * while calling into this method.
1304  */
1305 static Drawable
1306 X11SD_GetPixmapWithBg(JNIEnv *env, X11SDOps *xsdo, jint pixel)
1307 {
1308     /* assert AWT_CHECK_HAVE_LOCK(); */
1309 
1310     if (xsdo-&gt;invalid) {
1311         AWT_UNLOCK();
1312         SurfaceData_ThrowInvalidPipeException(env, &quot;bounds changed&quot;);
1313         return 0;
1314     }
1315 
1316     /* the image doesn&#39;t have transparency, just return it */
1317     if (xsdo-&gt;bitmask == 0) {
1318         /* don&#39;t need to unlock here, the caller will unlock through
1319            the release call */
1320         return xsdo-&gt;drawable;
1321     }
1322 
1323     /* Check if current color of the transparent pixels is different
1324        from the specified one */
1325     if (xsdo-&gt;isBgInitialized == JNI_FALSE || xsdo-&gt;bgPixel != pixel) {
1326         GC srcGC;
1327         GC bmGC;
1328 
1329         if (xsdo-&gt;drawable == 0) {
1330             AWT_UNLOCK();
1331             return 0;
1332         }
1333 
1334         bmGC = XCreateGC(awt_display, xsdo-&gt;bitmask, 0, NULL);
1335         if (bmGC == NULL) {
1336             AWT_UNLOCK();
1337             return 0;
1338         }
1339 
1340         /* invert the bitmask */
1341         XSetFunction(awt_display, bmGC, GXxor);
1342         XSetForeground(awt_display, bmGC, 1);
1343         XFillRectangle(awt_display, xsdo-&gt;bitmask, bmGC,
1344                        0, 0, xsdo-&gt;pmWidth, xsdo-&gt;pmHeight);
1345 
1346         srcGC = XCreateGC(awt_display, xsdo-&gt;drawable, 0L, NULL);
1347         if (srcGC == NULL) {
1348             XFreeGC(awt_display, bmGC);
1349             AWT_UNLOCK();
1350             return 0;
1351         }
1352 
1353         /* set transparent pixels in the source pm to the bg color */
1354         XSetClipMask(awt_display, srcGC, xsdo-&gt;bitmask);
1355         XSetForeground(awt_display, srcGC, pixel);
1356         XFillRectangle(awt_display, xsdo-&gt;drawable, srcGC,
1357                        0, 0, xsdo-&gt;pmWidth, xsdo-&gt;pmHeight);
1358 
1359         /* invert the mask back */
1360         XFillRectangle(awt_display, xsdo-&gt;bitmask, bmGC,
1361                        0, 0, xsdo-&gt;pmWidth, xsdo-&gt;pmHeight);
1362 
1363         XFreeGC(awt_display, bmGC);
1364         XFreeGC(awt_display, srcGC);
1365         xsdo-&gt;bgPixel = pixel;
1366         xsdo-&gt;isBgInitialized = JNI_TRUE;
1367     }
1368 
1369     return xsdo-&gt;drawable;
1370 }
1371 
1372 static void
1373 X11SD_ReleasePixmapWithBg(JNIEnv *env, X11SDOps *xsdo)
1374 {
1375 #ifdef MITSHM
1376     if (xsdo-&gt;shmPMData.usingShmPixmap) {
1377         xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
1378     }
1379 #endif /* MITSHM */
1380 }
1381 
<a name="13" id="anc13"></a>




1382 #endif /* !HEADLESS */
1383 
1384 /*
1385  * Class:     sun_java2d_x11_X11SurfaceData
1386  * Method:    XCreateGC
1387  * Signature: (I)J
1388  */
1389 JNIEXPORT jlong JNICALL
1390 Java_sun_java2d_x11_XSurfaceData_XCreateGC
1391     (JNIEnv *env, jclass xsd, jlong pXSData)
1392 {
1393     jlong ret;
1394 
1395 #ifndef HEADLESS
1396     X11SDOps *xsdo;
1397 
1398     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XCreateGC&quot;);
1399 
1400     xsdo = (X11SDOps *) pXSData;
1401     if (xsdo == NULL) {
1402         return 0L;
1403     }
1404 
1405     xsdo-&gt;javaGC = XCreateGC(awt_display, xsdo-&gt;drawable, 0, NULL);
1406     ret = (jlong) xsdo-&gt;javaGC;
1407 #else /* !HEADLESS */
1408     ret = 0L;
1409 #endif /* !HEADLESS */
1410 
1411     return ret;
1412 }
1413 
1414 /*
1415  * Class:     sun_java2d_x11_X11SurfaceData
1416  * Method:    XResetClip
1417  * Signature: (JIIIILsun/java2d/pipe/Region;)V
1418  */
1419 JNIEXPORT void JNICALL
1420 Java_sun_java2d_x11_XSurfaceData_XResetClip
1421     (JNIEnv *env, jclass xsd, jlong xgc)
1422 {
1423 #ifndef HEADLESS
1424     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XResetClip&quot;);
1425     XSetClipMask(awt_display, (GC) xgc, None);
1426 #endif /* !HEADLESS */
1427 }
1428 
1429 /*
1430  * Class:     sun_java2d_x11_X11SurfaceData
1431  * Method:    XSetClip
1432  * Signature: (JIIIILsun/java2d/pipe/Region;)V
1433  */
1434 JNIEXPORT void JNICALL
1435 Java_sun_java2d_x11_XSurfaceData_XSetClip
1436     (JNIEnv *env, jclass xsd, jlong xgc,
1437      jint x1, jint y1, jint x2, jint y2,
1438      jobject complexclip)
1439 {
1440 #ifndef HEADLESS
1441     int numrects;
1442     XRectangle rects[256];
1443     XRectangle *pRect = rects;
1444 
1445     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XSetClip&quot;);
1446 
1447     numrects = RegionToYXBandedRectangles(env,
1448             x1, y1, x2, y2, complexclip,
1449             &amp;pRect, 256);
1450 
1451     XSetClipRectangles(awt_display, (GC) xgc, 0, 0, pRect, numrects, YXBanded);
1452 
1453     if (pRect != rects) {
1454         free(pRect);
1455     }
1456 #endif /* !HEADLESS */
1457 }
1458 
1459 /*
1460  * Class:     sun_java2d_x11_X11SurfaceData
1461  * Method:    XSetCopyMode
1462  * Signature: (J)V
1463  */
1464 JNIEXPORT void JNICALL
1465 Java_sun_java2d_x11_X11SurfaceData_XSetCopyMode
1466     (JNIEnv *env, jclass xsd, jlong xgc)
1467 {
1468 #ifndef HEADLESS
1469     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XSetCopyMode&quot;);
1470     XSetFunction(awt_display, (GC) xgc, GXcopy);
1471 #endif /* !HEADLESS */
1472 }
1473 
1474 /*
1475  * Class:     sun_java2d_x11_X11SurfaceData
1476  * Method:    XSetXorMode
1477  * Signature: (J)V
1478  */
1479 JNIEXPORT void JNICALL
1480 Java_sun_java2d_x11_X11SurfaceData_XSetXorMode
1481     (JNIEnv *env, jclass xr, jlong xgc)
1482 {
1483 #ifndef HEADLESS
1484     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XSetXorMode&quot;);
1485     XSetFunction(awt_display, (GC) xgc, GXxor);
1486 #endif /* !HEADLESS */
1487 }
1488 
1489 /*
1490  * Class:     sun_java2d_x11_X11SurfaceData
1491  * Method:    XSetForeground
1492  * Signature: (JI)V
1493  */
1494 JNIEXPORT void JNICALL
1495 Java_sun_java2d_x11_X11SurfaceData_XSetForeground
1496     (JNIEnv *env, jclass xsd, jlong xgc, jint pixel)
1497 {
1498 #ifndef HEADLESS
1499     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XSetForeground&quot;);
1500     XSetForeground(awt_display, (GC) xgc, pixel);
1501 #endif /* !HEADLESS */
1502 }
1503 
1504 /*
1505  * Class:     sun_java2d_x11_X11SurfaceData
1506  * Method:    XSetGraphicsExposures
1507  * Signature: (JZ)V
1508  */
1509 JNIEXPORT void JNICALL
1510 Java_sun_java2d_x11_XSurfaceData_XSetGraphicsExposures
1511     (JNIEnv *env, jclass xsd, jlong xgc, jboolean needExposures)
1512 {
1513 #ifndef HEADLESS
1514     J2dTraceLn(J2D_TRACE_INFO, &quot;in X11SurfaceData_XSetGraphicsExposures&quot;);
1515     XSetGraphicsExposures(awt_display, (GC) xgc, needExposures ? True : False);
1516 #endif /* !HEADLESS */
1517 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
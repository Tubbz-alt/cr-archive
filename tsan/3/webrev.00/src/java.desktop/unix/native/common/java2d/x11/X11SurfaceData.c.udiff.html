<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/java.desktop/unix/native/common/java2d/x11/X11SurfaceData.c</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="X11FontScaler_md.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X11SurfaceData.h.udiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/common/java2d/x11/X11SurfaceData.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -72,10 +72,11 @@</span>
                              X11SDOps *xsdo);
  static void X11SD_SwapBytes(X11SDOps *xsdo, XImage *img, int depth, int bpp);
  static XImage * X11SD_GetImage(JNIEnv *env, X11SDOps *xsdo,
                                 SurfaceDataBounds *bounds,
                                 jint lockFlags);
<span class="udiff-line-added">+ static int X11SD_GetBitmapPad(int pixelStride);</span>
  
  extern jfieldID validID;
  
  static int nativeByteOrder;
  static jclass xorCompClass;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -388,26 +389,48 @@</span>
      if (drawable != (jlong)0) {
          /* Double-buffering */
          xsdo-&gt;drawable = drawable;
          xsdo-&gt;isPixmap = JNI_FALSE;
      } else {
<span class="udiff-line-added">+         jboolean sizeIsInvalid = JNI_FALSE;</span>
<span class="udiff-line-added">+         jlong scan = 0;</span>
<span class="udiff-line-added">+ </span>
          /*
           * width , height must be nonzero otherwise XCreatePixmap
           * generates BadValue in error_handler
           */
          if (width &lt;= 0 || height &lt;= 0 || width &gt; 32767 || height &gt; 32767) {
<span class="udiff-line-added">+             sizeIsInvalid = JNI_TRUE;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             XImage* tmpImg = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             AWT_LOCK();</span>
<span class="udiff-line-added">+             tmpImg = XCreateImage(awt_display,</span>
<span class="udiff-line-added">+                 xsdo-&gt;configData-&gt;awt_visInfo.visual,</span>
<span class="udiff-line-added">+                 depth, ZPixmap, 0, NULL, width, height,</span>
<span class="udiff-line-added">+                 X11SD_GetBitmapPad(xsdo-&gt;configData-&gt;pixelStride), 0);</span>
<span class="udiff-line-added">+             if (tmpImg) {</span>
<span class="udiff-line-added">+                 scan = (jlong) tmpImg-&gt;bytes_per_line;</span>
<span class="udiff-line-added">+                 XDestroyImage(tmpImg);</span>
<span class="udiff-line-added">+                 tmpImg = NULL;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             AWT_UNLOCK();</span>
<span class="udiff-line-added">+             JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if (sizeIsInvalid || (scan * height &gt; 0x7FFFFFFFL)) {</span>
              JNU_ThrowOutOfMemoryError(env,
                                    &quot;Can&#39;t create offscreen surface&quot;);
              return JNI_FALSE;
          }
          xsdo-&gt;isPixmap = JNI_TRUE;
  
          xsdo-&gt;pmWidth = width;
          xsdo-&gt;pmHeight = height;
  
  #ifdef MITSHM
<span class="udiff-line-modified-removed">-         xsdo-&gt;shmPMData.pmSize = width * height * depth;</span>
<span class="udiff-line-modified-added">+         xsdo-&gt;shmPMData.pmSize = (jlong) width * height * depth;</span>
          xsdo-&gt;shmPMData.pixelsReadThreshold = width * height / 8;
          if (forceSharedPixmaps) {
              AWT_LOCK();
              xsdo-&gt;drawable = X11SD_CreateSharedPixmap(xsdo);
              AWT_UNLOCK();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -506,11 +529,11 @@</span>
      if (img == NULL) {
          free((void *)shminfo);
          return NULL;
      }
      shminfo-&gt;shmid =
<span class="udiff-line-modified-removed">-         shmget(IPC_PRIVATE, height * img-&gt;bytes_per_line,</span>
<span class="udiff-line-modified-added">+         shmget(IPC_PRIVATE, (size_t) height * img-&gt;bytes_per_line,</span>
                 IPC_CREAT|mitShmPermissionMask);
      if (shminfo-&gt;shmid &lt; 0) {
          J2dRlsTraceLn1(J2D_TRACE_ERROR,
                         &quot;X11SD_SetupSharedSegment shmget has failed: %s&quot;,
                         strerror(errno));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -568,11 +591,11 @@</span>
                                 xsdo-&gt;depth, readBits)) {
          /* sync so previous data gets flushed */
          XSync(awt_display, False);
          retImage = cachedXImage;
          cachedXImage = (XImage *)NULL;
<span class="udiff-line-modified-removed">-     } else if (width * height * xsdo-&gt;depth &gt; 0x10000) {</span>
<span class="udiff-line-modified-added">+     } else if ((jlong) width * height * xsdo-&gt;depth &gt; 0x10000) {</span>
          retImage = X11SD_CreateSharedImage(xsdo, width, height);
      }
      return retImage;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -868,11 +891,11 @@</span>
          xpriv-&gt;img = X11SD_GetImage(env, xsdo, &amp;pRasInfo-&gt;bounds, lockFlags);
          if (xpriv-&gt;img) {
              int scan = xpriv-&gt;img-&gt;bytes_per_line;
              xpriv-&gt;x = x;
              xpriv-&gt;y = y;
<span class="udiff-line-modified-removed">-             pRasInfo-&gt;rasBase = xpriv-&gt;img-&gt;data - x * mult - y * scan;</span>
<span class="udiff-line-modified-added">+             pRasInfo-&gt;rasBase = xpriv-&gt;img-&gt;data - x * mult - (intptr_t) y * scan;</span>
              pRasInfo-&gt;pixelStride = mult;
              pRasInfo-&gt;pixelBitOffset = 0;
              pRasInfo-&gt;scanStride = scan;
          } else {
              pRasInfo-&gt;rasBase = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,12 +1050,12 @@</span>
      return TRUE;
  }
  
  static void
  X11SD_SwapBytes(X11SDOps *xsdo, XImage * img, int depth, int bpp) {
<span class="udiff-line-modified-removed">-     int lengthInBytes = img-&gt;height * img-&gt;bytes_per_line;</span>
<span class="udiff-line-modified-removed">-     int i;</span>
<span class="udiff-line-modified-added">+     jlong lengthInBytes = (jlong) img-&gt;height * img-&gt;bytes_per_line;</span>
<span class="udiff-line-modified-added">+     jlong i;</span>
  
      switch (depth) {
      case 12:
      case 15:
      case 16:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1101,11 +1124,11 @@</span>
      int scan;
      XImage * img = NULL;
      Drawable drawable;
      int depth = xsdo-&gt;depth;
      int mult = xsdo-&gt;configData-&gt;pixelStride;
<span class="udiff-line-modified-removed">-     int pad = (mult == 3) ? 32 : mult * 8; // pad must be 8, 16, or 32</span>
<span class="udiff-line-modified-added">+     int pad = X11SD_GetBitmapPad(mult);</span>
      jboolean readBits = lockFlags &amp; SD_LOCK_NEED_PIXELS;
  
      x = bounds-&gt;x1;
      y = bounds-&gt;y1;
      w = bounds-&gt;x2 - x;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1167,11 +1190,11 @@</span>
              if (img == NULL) {
                  return NULL;
              }
  
              scan = img-&gt;bytes_per_line;
<span class="udiff-line-modified-removed">-             img-&gt;data = malloc(h * scan);</span>
<span class="udiff-line-modified-added">+             img-&gt;data = malloc((size_t) h * scan);</span>
              if (img-&gt;data == NULL) {
                  XFree(img);
                  return NULL;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1202,11 +1225,11 @@</span>
                      int temp_scan, bytes_to_copy;
                      char * img_addr, * temp_addr;
                      int i;
  
                      img_addr = img-&gt;data +
<span class="udiff-line-modified-removed">-                         (temp.y1 - y) * scan + (temp.x1 - x) * mult;</span>
<span class="udiff-line-modified-added">+                         (intptr_t) (temp.y1 - y) * scan + (temp.x1 - x) * mult;</span>
                      temp_scan = temp_image-&gt;bytes_per_line;
                      temp_addr = temp_image-&gt;data;
                      bytes_to_copy = (temp.x2 - temp.x1) * mult;
                      for (i = temp.y1; i &lt; temp.y2; i++) {
                          memcpy(img_addr, temp_addr, bytes_to_copy);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1236,11 +1259,11 @@</span>
                                 depth, ZPixmap, 0, NULL, w, h, pad, 0);
              if (img == NULL) {
                  return NULL;
              }
  
<span class="udiff-line-modified-removed">-             img-&gt;data = malloc(h * img-&gt;bytes_per_line);</span>
<span class="udiff-line-modified-added">+             img-&gt;data = malloc((size_t) h * img-&gt;bytes_per_line);</span>
              if (img-&gt;data == NULL) {
                  XFree(img);
                  return NULL;
              }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,10 +1400,15 @@</span>
          xsdo-&gt;shmPMData.xRequestSent = JNI_TRUE;
      }
  #endif /* MITSHM */
  }
  
<span class="udiff-line-added">+ static int X11SD_GetBitmapPad(int pixelStride) {</span>
<span class="udiff-line-added">+     // pad must be 8, 16, or 32</span>
<span class="udiff-line-added">+     return (pixelStride == 3) ? 32 : pixelStride * 8;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  #endif /* !HEADLESS */
  
  /*
   * Class:     sun_java2d_x11_X11SurfaceData
   * Method:    XCreateGC
</pre>
<center><a href="X11FontScaler_md.c.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="X11SurfaceData.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
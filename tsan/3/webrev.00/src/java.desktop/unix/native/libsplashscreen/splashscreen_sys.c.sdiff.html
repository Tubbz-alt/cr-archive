<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/native/libsplashscreen/splashscreen_sys.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../libawt_xawt/xawt/XWindow.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/classes/com/sun/java/swing/plaf/windows/resources/windows.properties.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/libsplashscreen/splashscreen_sys.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
388     fprintf(stderr, &quot;Xerror %s, XID %x, ser# %d\n&quot;, msg, err-&gt;resourceid,
389         err-&gt;serial);
390     sprintf(buf, &quot;%d&quot;, err-&gt;request_code);
391     XGetErrorDatabaseText(disp, &quot;XRequest&quot;, buf, &quot;Unknown&quot;, msg, sizeof(msg));
392     fprintf(stderr, &quot;Major opcode %d (%s)\n&quot;, err-&gt;request_code, msg);
393     if (err-&gt;request_code &gt; 128) {
394         fprintf(stderr, &quot;Minor opcode %d\n&quot;, err-&gt;minor_code);
395     }
396     */
397     return 0;
398 }
399 
400 int
401 HandleIOError(Display * display) {
402     // for really bad errors, we should exit the thread we&#39;re on
403     SplashCleanup(SplashGetInstance());
404     pthread_exit(NULL);
405     return 0;
406 }
407 
<span class="line-modified">408 void</span>
409 SplashInitPlatform(Splash * splash) {
410     int shapeVersionMajor, shapeVersionMinor;
411 
412     // This setting enables the synchronous Xlib mode!
413     // Don&#39;t use it == 1 in production builds!
414 #if (defined DEBUG)
415     _Xdebug = 1;
416 #endif
417 
418     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
419 
420     // We should not ignore any errors.
421     //XSetErrorHandler(HandleError);
422 //    XSetIOErrorHandler(HandleIOError);
423     XSetIOErrorHandler(NULL);
424     splash-&gt;display = XOpenDisplay(NULL);
425     if (!splash-&gt;display) {
426         splash-&gt;isVisible = -1;
<span class="line-modified">427         return;</span>
428     }
429 
430     shapeSupported = XShapeQueryExtension(splash-&gt;display, &amp;shapeEventBase,
431             &amp;shapeErrorBase);
432     if (shapeSupported) {
433         XShapeQueryVersion(splash-&gt;display, &amp;shapeVersionMajor,
434                 &amp;shapeVersionMinor);
435     }
436 
437     splash-&gt;screen = XDefaultScreenOfDisplay(splash-&gt;display);
438     splash-&gt;visual = XDefaultVisualOfScreen(splash-&gt;screen);
439     switch (splash-&gt;visual-&gt;class) {
440     case TrueColor: {
441             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
442 
443             splash-&gt;byteAlignment = 1;
444             splash-&gt;maskRequired = shapeSupported;
445             initFormat(&amp;splash-&gt;screenFormat, splash-&gt;visual-&gt;red_mask,
446                     splash-&gt;visual-&gt;green_mask, splash-&gt;visual-&gt;blue_mask, 0);
447             splash-&gt;screenFormat.byteOrder =
</pre>
<hr />
<pre>
457             int numColors;
458             int numComponents[3];
459             unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
460             XColor xColors[SPLASH_COLOR_MAP_SIZE];
461             int i;
462             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
463             int scale = 65535 / MAX_COLOR_VALUE;
464 
465             availableColors = GetNumAvailableColors(splash-&gt;display, splash-&gt;screen,
466                     splash-&gt;visual-&gt;map_entries);
467             numColors = quantizeColors(availableColors, numComponents);
468             if (numColors &gt; availableColors) {
469                 // Could not allocate the color cells. Most probably
470                 // the pool got exhausted. Disable the splash screen.
471                 XCloseDisplay(splash-&gt;display);
472                 splash-&gt;isVisible = -1;
473                 splash-&gt;display = NULL;
474                 splash-&gt;screen = NULL;
475                 splash-&gt;visual = NULL;
476                 fprintf(stderr, &quot;Warning: unable to initialize the splashscreen. Not enough available color cells.\n&quot;);
<span class="line-modified">477                 return;</span>
478             }
479             splash-&gt;cmap = AllocColors(splash-&gt;display, splash-&gt;screen,
480                     numColors, colorIndex);
481             for (i = 0; i &lt; numColors; i++) {
482                 splash-&gt;colorIndex[i] = colorIndex[i];
483             }
484             initColorCube(numComponents, splash-&gt;colorMap, splash-&gt;dithers,
485                     splash-&gt;colorIndex);
486             for (i = 0; i &lt; numColors; i++) {
487                 xColors[i].pixel = colorIndex[i];
488                 xColors[i].red = (unsigned short)
489                     QUAD_RED(splash-&gt;colorMap[colorIndex[i]]) * scale;
490                 xColors[i].green = (unsigned short)
491                     QUAD_GREEN(splash-&gt;colorMap[colorIndex[i]]) * scale;
492                 xColors[i].blue = (unsigned short)
493                     QUAD_BLUE(splash-&gt;colorMap[colorIndex[i]]) * scale;
494                 xColors[i].flags = DoRed | DoGreen | DoBlue;
495             }
496             XStoreColors(splash-&gt;display, splash-&gt;cmap, xColors, numColors);
497             initFormat(&amp;splash-&gt;screenFormat, 0, 0, 0, 0);
498             splash-&gt;screenFormat.colorIndex = splash-&gt;colorIndex;
499             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;  // or always 8?
500             splash-&gt;screenFormat.colorMap = splash-&gt;colorMap;
501             splash-&gt;screenFormat.dithers = splash-&gt;dithers;
502             splash-&gt;screenFormat.numColors = numColors;
503             splash-&gt;screenFormat.byteOrder = BYTE_ORDER_NATIVE;
504             break;
505         }
506     default:
507         ; /* FIXME: should probably be fixed, but javaws splash screen doesn&#39;t support other visuals either */
508     }

509 }
510 
511 
512 void
513 SplashCleanupPlatform(Splash * splash) {
514     int i;
515 
516     if (splash-&gt;frames) {
517         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
518             if (splash-&gt;frames[i].rects) {
519                 free(splash-&gt;frames[i].rects);
520                 splash-&gt;frames[i].rects = NULL;
521             }
522         }
523     }
524     splash-&gt;maskRequired = shapeSupported;
525 }
526 
527 void
528 SplashDonePlatform(Splash * splash) {
</pre>
<hr />
<pre>
784 void
785 SplashUnlock(Splash * splash) {
786     pthread_mutex_unlock(&amp;splash-&gt;lock);
787 }
788 
789 void
790 SplashClosePlatform(Splash * splash) {
791     sendctl(splash, SPLASHCTL_QUIT);
792 }
793 
794 void
795 SplashUpdate(Splash * splash) {
796     sendctl(splash, SPLASHCTL_UPDATE);
797 }
798 
799 void
800 SplashReconfigure(Splash * splash) {
801     sendctl(splash, SPLASHCTL_RECONFIGURE);
802 }
803 
<span class="line-modified">804 JNIEXPORT jboolean JNICALL</span>
805 SplashGetScaledImageName(const char* jarName, const char* fileName,
806                            float *scaleFactor, char *scaledImgName,
807                            const size_t scaledImageNameLength)
808 {
809     *scaleFactor = 1;
810 #ifndef __linux__
811     return JNI_FALSE;
812 #endif
813     *scaleFactor = (float)getNativeScaleFactor(NULL);
814     return GetScaledImageName(fileName, scaledImgName, scaleFactor, scaledImageNameLength);
815 }
816 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
388     fprintf(stderr, &quot;Xerror %s, XID %x, ser# %d\n&quot;, msg, err-&gt;resourceid,
389         err-&gt;serial);
390     sprintf(buf, &quot;%d&quot;, err-&gt;request_code);
391     XGetErrorDatabaseText(disp, &quot;XRequest&quot;, buf, &quot;Unknown&quot;, msg, sizeof(msg));
392     fprintf(stderr, &quot;Major opcode %d (%s)\n&quot;, err-&gt;request_code, msg);
393     if (err-&gt;request_code &gt; 128) {
394         fprintf(stderr, &quot;Minor opcode %d\n&quot;, err-&gt;minor_code);
395     }
396     */
397     return 0;
398 }
399 
400 int
401 HandleIOError(Display * display) {
402     // for really bad errors, we should exit the thread we&#39;re on
403     SplashCleanup(SplashGetInstance());
404     pthread_exit(NULL);
405     return 0;
406 }
407 
<span class="line-modified">408 int</span>
409 SplashInitPlatform(Splash * splash) {
410     int shapeVersionMajor, shapeVersionMinor;
411 
412     // This setting enables the synchronous Xlib mode!
413     // Don&#39;t use it == 1 in production builds!
414 #if (defined DEBUG)
415     _Xdebug = 1;
416 #endif
417 
418     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
419 
420     // We should not ignore any errors.
421     //XSetErrorHandler(HandleError);
422 //    XSetIOErrorHandler(HandleIOError);
423     XSetIOErrorHandler(NULL);
424     splash-&gt;display = XOpenDisplay(NULL);
425     if (!splash-&gt;display) {
426         splash-&gt;isVisible = -1;
<span class="line-modified">427         return 0;</span>
428     }
429 
430     shapeSupported = XShapeQueryExtension(splash-&gt;display, &amp;shapeEventBase,
431             &amp;shapeErrorBase);
432     if (shapeSupported) {
433         XShapeQueryVersion(splash-&gt;display, &amp;shapeVersionMajor,
434                 &amp;shapeVersionMinor);
435     }
436 
437     splash-&gt;screen = XDefaultScreenOfDisplay(splash-&gt;display);
438     splash-&gt;visual = XDefaultVisualOfScreen(splash-&gt;screen);
439     switch (splash-&gt;visual-&gt;class) {
440     case TrueColor: {
441             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
442 
443             splash-&gt;byteAlignment = 1;
444             splash-&gt;maskRequired = shapeSupported;
445             initFormat(&amp;splash-&gt;screenFormat, splash-&gt;visual-&gt;red_mask,
446                     splash-&gt;visual-&gt;green_mask, splash-&gt;visual-&gt;blue_mask, 0);
447             splash-&gt;screenFormat.byteOrder =
</pre>
<hr />
<pre>
457             int numColors;
458             int numComponents[3];
459             unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
460             XColor xColors[SPLASH_COLOR_MAP_SIZE];
461             int i;
462             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
463             int scale = 65535 / MAX_COLOR_VALUE;
464 
465             availableColors = GetNumAvailableColors(splash-&gt;display, splash-&gt;screen,
466                     splash-&gt;visual-&gt;map_entries);
467             numColors = quantizeColors(availableColors, numComponents);
468             if (numColors &gt; availableColors) {
469                 // Could not allocate the color cells. Most probably
470                 // the pool got exhausted. Disable the splash screen.
471                 XCloseDisplay(splash-&gt;display);
472                 splash-&gt;isVisible = -1;
473                 splash-&gt;display = NULL;
474                 splash-&gt;screen = NULL;
475                 splash-&gt;visual = NULL;
476                 fprintf(stderr, &quot;Warning: unable to initialize the splashscreen. Not enough available color cells.\n&quot;);
<span class="line-modified">477                 return 0;</span>
478             }
479             splash-&gt;cmap = AllocColors(splash-&gt;display, splash-&gt;screen,
480                     numColors, colorIndex);
481             for (i = 0; i &lt; numColors; i++) {
482                 splash-&gt;colorIndex[i] = colorIndex[i];
483             }
484             initColorCube(numComponents, splash-&gt;colorMap, splash-&gt;dithers,
485                     splash-&gt;colorIndex);
486             for (i = 0; i &lt; numColors; i++) {
487                 xColors[i].pixel = colorIndex[i];
488                 xColors[i].red = (unsigned short)
489                     QUAD_RED(splash-&gt;colorMap[colorIndex[i]]) * scale;
490                 xColors[i].green = (unsigned short)
491                     QUAD_GREEN(splash-&gt;colorMap[colorIndex[i]]) * scale;
492                 xColors[i].blue = (unsigned short)
493                     QUAD_BLUE(splash-&gt;colorMap[colorIndex[i]]) * scale;
494                 xColors[i].flags = DoRed | DoGreen | DoBlue;
495             }
496             XStoreColors(splash-&gt;display, splash-&gt;cmap, xColors, numColors);
497             initFormat(&amp;splash-&gt;screenFormat, 0, 0, 0, 0);
498             splash-&gt;screenFormat.colorIndex = splash-&gt;colorIndex;
499             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;  // or always 8?
500             splash-&gt;screenFormat.colorMap = splash-&gt;colorMap;
501             splash-&gt;screenFormat.dithers = splash-&gt;dithers;
502             splash-&gt;screenFormat.numColors = numColors;
503             splash-&gt;screenFormat.byteOrder = BYTE_ORDER_NATIVE;
504             break;
505         }
506     default:
507         ; /* FIXME: should probably be fixed, but javaws splash screen doesn&#39;t support other visuals either */
508     }
<span class="line-added">509     return 1;</span>
510 }
511 
512 
513 void
514 SplashCleanupPlatform(Splash * splash) {
515     int i;
516 
517     if (splash-&gt;frames) {
518         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
519             if (splash-&gt;frames[i].rects) {
520                 free(splash-&gt;frames[i].rects);
521                 splash-&gt;frames[i].rects = NULL;
522             }
523         }
524     }
525     splash-&gt;maskRequired = shapeSupported;
526 }
527 
528 void
529 SplashDonePlatform(Splash * splash) {
</pre>
<hr />
<pre>
785 void
786 SplashUnlock(Splash * splash) {
787     pthread_mutex_unlock(&amp;splash-&gt;lock);
788 }
789 
790 void
791 SplashClosePlatform(Splash * splash) {
792     sendctl(splash, SPLASHCTL_QUIT);
793 }
794 
795 void
796 SplashUpdate(Splash * splash) {
797     sendctl(splash, SPLASHCTL_UPDATE);
798 }
799 
800 void
801 SplashReconfigure(Splash * splash) {
802     sendctl(splash, SPLASHCTL_RECONFIGURE);
803 }
804 
<span class="line-modified">805 JNIEXPORT jboolean</span>
806 SplashGetScaledImageName(const char* jarName, const char* fileName,
807                            float *scaleFactor, char *scaledImgName,
808                            const size_t scaledImageNameLength)
809 {
810     *scaleFactor = 1;
811 #ifndef __linux__
812     return JNI_FALSE;
813 #endif
814     *scaleFactor = (float)getNativeScaleFactor(NULL);
815     return GetScaledImageName(fileName, scaledImgName, scaleFactor, scaledImageNameLength);
816 }
817 
</pre>
</td>
</tr>
</table>
<center><a href="../libawt_xawt/xawt/XWindow.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../windows/classes/com/sun/java/swing/plaf/windows/resources/windows.properties.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/native/libsplashscreen/splashscreen_sys.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 #include &lt;X11/Xlib.h&gt;
 28 #include &lt;X11/Xutil.h&gt;
 29 #include &lt;X11/extensions/shape.h&gt;
 30 #include &lt;X11/Xmd.h&gt;
 31 #include &lt;X11/Xatom.h&gt;
 32 #include &lt;X11/cursorfont.h&gt;
 33 #include &lt;sys/types.h&gt;
 34 #include &lt;pthread.h&gt;
 35 #include &lt;signal.h&gt;
 36 #include &lt;unistd.h&gt;
 37 #include &lt;sys/time.h&gt;
 38 #include &lt;errno.h&gt;
 39 #include &lt;iconv.h&gt;
 40 #include &lt;langinfo.h&gt;
 41 #include &lt;locale.h&gt;
 42 #include &lt;fcntl.h&gt;
 43 #include &lt;poll.h&gt;
 44 #include &lt;sizecalc.h&gt;
 45 #include &quot;jni.h&quot;
 46 
 47 static Bool shapeSupported;
 48 static int shapeEventBase, shapeErrorBase;
 49 
 50 void SplashRemoveDecoration(Splash * splash);
 51 
 52 
 53 /* Could use npt but decided to cut down on linked code size */
 54 char* SplashConvertStringAlloc(const char* in, int* size) {
 55     const char     *codeset;
 56     const char     *codeset_out;
 57     iconv_t         cd;
 58     size_t          rc;
 59     char           *buf = NULL, *out;
 60     size_t          bufSize, inSize, outSize;
 61     const char* old_locale;
 62 
 63     if (!in) {
 64         return NULL;
 65     }
 66     old_locale = setlocale(LC_ALL, &quot;&quot;);
 67 
 68     codeset = nl_langinfo(CODESET);
 69     if ( codeset == NULL || codeset[0] == 0 ) {
 70         goto done;
 71     }
 72     /* we don&#39;t need BOM in output so we choose native BE or LE encoding here */
 73     codeset_out = (platformByteOrder()==BYTE_ORDER_MSBFIRST) ?
 74         &quot;UCS-2BE&quot; : &quot;UCS-2LE&quot;;
 75 
 76     cd = iconv_open(codeset_out, codeset);
 77     if (cd == (iconv_t)-1 ) {
 78         goto done;
 79     }
 80     inSize = strlen(in);
 81     buf = SAFE_SIZE_ARRAY_ALLOC(malloc, inSize, 2);
 82     if (!buf) {
 83         return NULL;
 84     }
 85     bufSize = inSize*2; // need 2 bytes per char for UCS-2, this is
 86                         // 2 bytes per source byte max
 87     out = buf; outSize = bufSize;
 88     /* linux iconv wants char** source and solaris wants const char**...
 89        cast to void* */
 90     rc = iconv(cd, (void*)&amp;in, &amp;inSize, &amp;out, &amp;outSize);
 91     iconv_close(cd);
 92 
 93     if (rc == (size_t)-1) {
 94         free(buf);
 95         buf = NULL;
 96     } else {
 97         if (size) {
 98             *size = (bufSize-outSize)/2; /* bytes to wchars */
 99         }
100     }
101 done:
102     setlocale(LC_ALL, old_locale);
103     return buf;
104 }
105 
106 void
107 SplashInitFrameShape(Splash * splash, int imageIndex) {
108     ImageRect maskRect;
109     XRectangle *rects;
110     SplashImage *frame = splash-&gt;frames + imageIndex;
111 
112     frame-&gt;rects = NULL;
113     frame-&gt;numRects = 0;
114 
115     if (!splash-&gt;maskRequired)
116         return;
117     if (!shapeSupported)
118         return;
119     initRect(&amp;maskRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
120             splash-&gt;width * splash-&gt;imageFormat.depthBytes,
121             splash-&gt;frames[imageIndex].bitmapBits, &amp;splash-&gt;imageFormat);
122     if (!IS_SAFE_SIZE_MUL(splash-&gt;width / 2 + 1, splash-&gt;height)) {
123         return;
124     }
125     rects = SAFE_SIZE_ARRAY_ALLOC(malloc,
126             sizeof(XRectangle), (splash-&gt;width / 2 + 1) * splash-&gt;height);
127     if (!rects) {
128         return;
129     }
130 
131     frame-&gt;numRects = BitmapToYXBandedRectangles(&amp;maskRect, rects);
132     frame-&gt;rects = SAFE_SIZE_ARRAY_ALLOC(malloc, frame-&gt;numRects, sizeof(XRectangle));
133     if (frame-&gt;rects) { // handle the error after the if(){}
134         memcpy(frame-&gt;rects, rects, frame-&gt;numRects * sizeof(XRectangle));
135     }
136     free(rects);
137 }
138 
139 unsigned
140 SplashTime(void) {
141     struct timeval tv;
142     struct timezone tz;
143     unsigned long long msec;
144 
145     gettimeofday(&amp;tv, &amp;tz);
146     msec = (unsigned long long) tv.tv_sec * 1000 +
147         (unsigned long long) tv.tv_usec / 1000;
148 
149     return (unsigned) msec;
150 }
151 
152 void
153 msec2timeval(unsigned time, struct timeval *tv) {
154     tv-&gt;tv_sec = time / 1000;
155     tv-&gt;tv_usec = (time % 1000) * 1000;
156 }
157 
158 int
159 GetNumAvailableColors(Display * display, Screen * screen, unsigned map_entries) {
160     unsigned long pmr[1];
161     unsigned long pr[SPLASH_COLOR_MAP_SIZE];
162     unsigned nFailed, nAllocated, done = 0, nPlanes = 0;
163     Colormap cmap;
164     unsigned numColors = SPLASH_COLOR_MAP_SIZE; // never try allocating more than that
165 
166     if (numColors &gt; map_entries) {
167         numColors = map_entries;
168     }
169     cmap = XDefaultColormapOfScreen(screen);
170     nAllocated = 0;             /* lower bound */
171     nFailed = numColors + 1;    /* upper bound */
172 
173     /* Binary search to determine the number of available cells */
174     for (done = 0; !done;) {
175         if (XAllocColorCells(display, cmap, 0, pmr, nPlanes, pr, numColors)) {
176             nAllocated = numColors;
177             XFreeColors(display, cmap, pr, numColors, 0);
178             if (nAllocated &lt; (nFailed - 1)) {
179                 numColors = (nAllocated + nFailed) / 2;
180             } else
181                 done = 1;
182         } else {
183             nFailed = numColors;
184             if (nFailed &gt; (nAllocated + 1))
185                 numColors = (nAllocated + nFailed) / 2;
186             else
187                 done = 1;
188         }
189     }
190     return nAllocated;
191 }
192 
193 Colormap
194 AllocColors(Display * display, Screen * screen, int numColors,
195         unsigned long *pr) {
196     unsigned long pmr[1];
197     Colormap cmap = XDefaultColormapOfScreen(screen);
198 
199     XAllocColorCells(display, cmap, 0, pmr, 0, pr, numColors);
200     return cmap;
201 }
202 
203 void
204 FreeColors(Display * display, Screen * screen, int numColors,
205         unsigned long *pr) {
206     Colormap cmap = XDefaultColormapOfScreen(screen);
207 
208     XFreeColors(display, cmap, pr, numColors, 0);
209 }
210 
211 static void SplashCenter(Splash * splash) {
212     Atom type, atom, actual_type;
213     int status, actual_format;
214     unsigned long nitems, bytes_after;
215     CARD16 *prop = NULL;
216 
217     /*  try centering using Xinerama hint
218         if there&#39;s no hint, use the center of the screen */
219     atom = XInternAtom(splash-&gt;display, &quot;XINERAMA_CENTER_HINT&quot;, True);
220     if (atom != None) {
221         status = XGetWindowProperty(splash-&gt;display,
222             XRootWindowOfScreen(splash-&gt;screen), atom, 0, 1, False, XA_INTEGER,
223             &amp;actual_type, &amp;actual_format, &amp;nitems,
224             &amp;bytes_after, (unsigned char**)(&amp;prop));
225         if (status == Success &amp;&amp; actual_type != None &amp;&amp; prop != NULL) {
226             splash-&gt;x = prop[0] - splash-&gt;width/2;
227             splash-&gt;y = prop[1] - splash-&gt;height/2;
228             XFree(prop);
229             return;
230         }
231         if (prop != NULL) {
232             XFree(prop);
233         }
234     }
235     splash-&gt;x = (XWidthOfScreen(splash-&gt;screen) - splash-&gt;width) / 2;
236     splash-&gt;y = (XHeightOfScreen(splash-&gt;screen) - splash-&gt;height) / 2;
237 }
238 
239 static void SplashUpdateSizeHints(Splash * splash) {
240     if (splash-&gt;window) {
241         XSizeHints sizeHints;
242 
243         sizeHints.flags = USPosition | PPosition | USSize | PSize | PMinSize | PMaxSize | PWinGravity;
244         sizeHints.width = sizeHints.base_width = sizeHints.min_width = sizeHints.max_width = splash-&gt;width;
245         sizeHints.height = sizeHints.base_height = sizeHints.min_height = sizeHints.max_height = splash-&gt;height;
246         sizeHints.win_gravity = NorthWestGravity;
247 
248         XSetWMNormalHints(splash-&gt;display, splash-&gt;window, &amp;sizeHints);
249     }
250 }
251 
252 void
253 SplashCreateWindow(Splash * splash) {
254     XSizeHints sizeHints;
255 
256     XSetWindowAttributes attr;
257 
258     attr.backing_store = NotUseful;
259     attr.colormap = XDefaultColormapOfScreen(splash-&gt;screen);
260     attr.save_under = True;
261     attr.cursor = splash-&gt;cursor = XCreateFontCursor(splash-&gt;display, XC_watch);
262     attr.event_mask = ExposureMask;
263 
264     SplashCenter(splash);
265 
266     splash-&gt;window = XCreateWindow(splash-&gt;display, XRootWindowOfScreen(splash-&gt;screen),
267         splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height, 0, CopyFromParent,
268         InputOutput, CopyFromParent, CWColormap | CWBackingStore | CWSaveUnder | CWCursor | CWEventMask,
269         &amp;attr);
270     SplashUpdateSizeHints(splash);
271 
272 
273     splash-&gt;wmHints = XAllocWMHints();
274     if (splash-&gt;wmHints) {
275         splash-&gt;wmHints-&gt;flags = InputHint | StateHint;
276         splash-&gt;wmHints-&gt;input = False;
277         splash-&gt;wmHints-&gt;initial_state = NormalState;
278         XSetWMHints(splash-&gt;display, splash-&gt;window, splash-&gt;wmHints);
279     }
280 }
281 
282 /* for changing the visible shape of a window to an nonrectangular form */
283 void
284 SplashUpdateShape(Splash * splash) {
285     if (splash-&gt;currentFrame &lt; 0 || !shapeSupported || !splash-&gt;maskRequired) {
286         return;
287     }
288     XShapeCombineRectangles(splash-&gt;display, splash-&gt;window, ShapeClip, 0, 0,
289             splash-&gt;frames[splash-&gt;currentFrame].rects,
290             splash-&gt;frames[splash-&gt;currentFrame].numRects, ShapeSet, YXBanded);
291     XShapeCombineRectangles(splash-&gt;display, splash-&gt;window, ShapeBounding,
292             0, 0, splash-&gt;frames[splash-&gt;currentFrame].rects,
293             splash-&gt;frames[splash-&gt;currentFrame].numRects, ShapeSet, YXBanded);
294 }
295 
296 /* for reverting the visible shape of a window to an rectangular form */
297 void
298 SplashRevertShape(Splash * splash) {
299     if (!shapeSupported)
300         return;
301     if (splash-&gt;maskRequired)
302         return;
303 
304     XShapeCombineMask (splash-&gt;display, splash-&gt;window, ShapeClip,
305                        0, 0, None, ShapeSet);
306     XShapeCombineMask (splash-&gt;display, splash-&gt;window , ShapeBounding,
307                        0, 0, None, ShapeSet);
308 }
309 
310 int
311 ByteOrderToX(int byteOrder) {
312     if (byteOrder == BYTE_ORDER_NATIVE)
313         byteOrder = platformByteOrder();
314     switch (byteOrder) {
315     case BYTE_ORDER_LSBFIRST:
316         return LSBFirst;
317     case BYTE_ORDER_MSBFIRST:
318         return MSBFirst;
319     default:
320         return -1;
321     }
322 }
323 
324 void
325 SplashRedrawWindow(Splash * splash) {
326     if (splash-&gt;currentFrame &lt; 0) {
327         return;
328     }
329 
330     XImage *ximage;
331 
332     // making this method redraw a part of the image does not make
333     // much sense as SplashUpdateScreenData always re-generates
334     // the image completely, so whole window is always redrawn
335 
336     SplashUpdateScreenData(splash);
337     ximage = XCreateImage(splash-&gt;display, splash-&gt;visual,
338             splash-&gt;screenFormat.depthBytes * 8, ZPixmap, 0, (char *) NULL,
339             splash-&gt;width, splash-&gt;height, 8, 0);
340     ximage-&gt;data = (char *) splash-&gt;screenData;
341     ximage-&gt;bits_per_pixel = ximage-&gt;depth;
342     ximage-&gt;bytes_per_line = ximage-&gt;depth * ximage-&gt;width / 8;
343     ximage-&gt;byte_order = ByteOrderToX(splash-&gt;screenFormat.byteOrder);
344     ximage-&gt;bitmap_unit = 8;
345     XPutImage(splash-&gt;display, splash-&gt;window,
346             XDefaultGCOfScreen(splash-&gt;screen), ximage, 0, 0, 0, 0,
347             splash-&gt;width, splash-&gt;height);
348     ximage-&gt;data = NULL;
349     XDestroyImage(ximage);
350     SplashRemoveDecoration(splash);
351     XMapWindow(splash-&gt;display, splash-&gt;window);
352     XFlush(splash-&gt;display);
353 }
354 
355 void SplashReconfigureNow(Splash * splash) {
356     SplashCenter(splash);
357     if (splash-&gt;window) {
358         XUnmapWindow(splash-&gt;display, splash-&gt;window);
359         XMoveResizeWindow(splash-&gt;display, splash-&gt;window,
360             splash-&gt;x, splash-&gt;y,
361             splash-&gt;width, splash-&gt;height);
362         SplashUpdateSizeHints(splash);
363     }
364     if (splash-&gt;maskRequired) {
365         SplashUpdateShape(splash);
366     } else {
367         SplashRevertShape(splash);
368     }
369     SplashRedrawWindow(splash);
370 }
371 
372 
373 void
374 sendctl(Splash * splash, char code) {
375 //    if (splash-&gt;isVisible&gt;0) {
376     if (splash &amp;&amp; splash-&gt;controlpipe[1]) {
377         write(splash-&gt;controlpipe[1], &amp;code, 1);
378     }
379 }
380 
381 int
382 HandleError(Display * disp, XErrorEvent * err) {
383     // silently ignore non-fatal errors
384     /*
385     char msg[0x1000];
386     char buf[0x1000];
387     XGetErrorText(disp, err-&gt;error_code, msg, sizeof(msg));
388     fprintf(stderr, &quot;Xerror %s, XID %x, ser# %d\n&quot;, msg, err-&gt;resourceid,
389         err-&gt;serial);
390     sprintf(buf, &quot;%d&quot;, err-&gt;request_code);
391     XGetErrorDatabaseText(disp, &quot;XRequest&quot;, buf, &quot;Unknown&quot;, msg, sizeof(msg));
392     fprintf(stderr, &quot;Major opcode %d (%s)\n&quot;, err-&gt;request_code, msg);
393     if (err-&gt;request_code &gt; 128) {
394         fprintf(stderr, &quot;Minor opcode %d\n&quot;, err-&gt;minor_code);
395     }
396     */
397     return 0;
398 }
399 
400 int
401 HandleIOError(Display * display) {
402     // for really bad errors, we should exit the thread we&#39;re on
403     SplashCleanup(SplashGetInstance());
404     pthread_exit(NULL);
405     return 0;
406 }
407 
<a name="2" id="anc2"></a><span class="line-modified">408 int</span>
409 SplashInitPlatform(Splash * splash) {
410     int shapeVersionMajor, shapeVersionMinor;
411 
412     // This setting enables the synchronous Xlib mode!
413     // Don&#39;t use it == 1 in production builds!
414 #if (defined DEBUG)
415     _Xdebug = 1;
416 #endif
417 
418     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
419 
420     // We should not ignore any errors.
421     //XSetErrorHandler(HandleError);
422 //    XSetIOErrorHandler(HandleIOError);
423     XSetIOErrorHandler(NULL);
424     splash-&gt;display = XOpenDisplay(NULL);
425     if (!splash-&gt;display) {
426         splash-&gt;isVisible = -1;
<a name="3" id="anc3"></a><span class="line-modified">427         return 0;</span>
428     }
429 
430     shapeSupported = XShapeQueryExtension(splash-&gt;display, &amp;shapeEventBase,
431             &amp;shapeErrorBase);
432     if (shapeSupported) {
433         XShapeQueryVersion(splash-&gt;display, &amp;shapeVersionMajor,
434                 &amp;shapeVersionMinor);
435     }
436 
437     splash-&gt;screen = XDefaultScreenOfDisplay(splash-&gt;display);
438     splash-&gt;visual = XDefaultVisualOfScreen(splash-&gt;screen);
439     switch (splash-&gt;visual-&gt;class) {
440     case TrueColor: {
441             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
442 
443             splash-&gt;byteAlignment = 1;
444             splash-&gt;maskRequired = shapeSupported;
445             initFormat(&amp;splash-&gt;screenFormat, splash-&gt;visual-&gt;red_mask,
446                     splash-&gt;visual-&gt;green_mask, splash-&gt;visual-&gt;blue_mask, 0);
447             splash-&gt;screenFormat.byteOrder =
448                 (XImageByteOrder(splash-&gt;display) == LSBFirst ?
449                  BYTE_ORDER_LSBFIRST : BYTE_ORDER_MSBFIRST);
450             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;
451             // TrueColor depth probably can&#39;t be less
452             // than 8 bits, and it&#39;s always byte padded
453             break;
454         }
455     case PseudoColor: {
456             int availableColors;
457             int numColors;
458             int numComponents[3];
459             unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
460             XColor xColors[SPLASH_COLOR_MAP_SIZE];
461             int i;
462             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
463             int scale = 65535 / MAX_COLOR_VALUE;
464 
465             availableColors = GetNumAvailableColors(splash-&gt;display, splash-&gt;screen,
466                     splash-&gt;visual-&gt;map_entries);
467             numColors = quantizeColors(availableColors, numComponents);
468             if (numColors &gt; availableColors) {
469                 // Could not allocate the color cells. Most probably
470                 // the pool got exhausted. Disable the splash screen.
471                 XCloseDisplay(splash-&gt;display);
472                 splash-&gt;isVisible = -1;
473                 splash-&gt;display = NULL;
474                 splash-&gt;screen = NULL;
475                 splash-&gt;visual = NULL;
476                 fprintf(stderr, &quot;Warning: unable to initialize the splashscreen. Not enough available color cells.\n&quot;);
<a name="4" id="anc4"></a><span class="line-modified">477                 return 0;</span>
478             }
479             splash-&gt;cmap = AllocColors(splash-&gt;display, splash-&gt;screen,
480                     numColors, colorIndex);
481             for (i = 0; i &lt; numColors; i++) {
482                 splash-&gt;colorIndex[i] = colorIndex[i];
483             }
484             initColorCube(numComponents, splash-&gt;colorMap, splash-&gt;dithers,
485                     splash-&gt;colorIndex);
486             for (i = 0; i &lt; numColors; i++) {
487                 xColors[i].pixel = colorIndex[i];
488                 xColors[i].red = (unsigned short)
489                     QUAD_RED(splash-&gt;colorMap[colorIndex[i]]) * scale;
490                 xColors[i].green = (unsigned short)
491                     QUAD_GREEN(splash-&gt;colorMap[colorIndex[i]]) * scale;
492                 xColors[i].blue = (unsigned short)
493                     QUAD_BLUE(splash-&gt;colorMap[colorIndex[i]]) * scale;
494                 xColors[i].flags = DoRed | DoGreen | DoBlue;
495             }
496             XStoreColors(splash-&gt;display, splash-&gt;cmap, xColors, numColors);
497             initFormat(&amp;splash-&gt;screenFormat, 0, 0, 0, 0);
498             splash-&gt;screenFormat.colorIndex = splash-&gt;colorIndex;
499             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;  // or always 8?
500             splash-&gt;screenFormat.colorMap = splash-&gt;colorMap;
501             splash-&gt;screenFormat.dithers = splash-&gt;dithers;
502             splash-&gt;screenFormat.numColors = numColors;
503             splash-&gt;screenFormat.byteOrder = BYTE_ORDER_NATIVE;
504             break;
505         }
506     default:
507         ; /* FIXME: should probably be fixed, but javaws splash screen doesn&#39;t support other visuals either */
508     }
<a name="5" id="anc5"></a><span class="line-added">509     return 1;</span>
510 }
511 
512 
513 void
514 SplashCleanupPlatform(Splash * splash) {
515     int i;
516 
517     if (splash-&gt;frames) {
518         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
519             if (splash-&gt;frames[i].rects) {
520                 free(splash-&gt;frames[i].rects);
521                 splash-&gt;frames[i].rects = NULL;
522             }
523         }
524     }
525     splash-&gt;maskRequired = shapeSupported;
526 }
527 
528 void
529 SplashDonePlatform(Splash * splash) {
530     pthread_mutex_destroy(&amp;splash-&gt;lock);
531     if (splash-&gt;cmap) {
532         unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
533         int i;
534 
535         for (i = 0; i &lt; splash-&gt;screenFormat.numColors; i++) {
536             colorIndex[i] = splash-&gt;colorIndex[i];
537         }
538         FreeColors(splash-&gt;display, splash-&gt;screen,
539                 splash-&gt;screenFormat.numColors, colorIndex);
540     }
541     if (splash-&gt;window)
542         XDestroyWindow(splash-&gt;display, splash-&gt;window);
543     if (splash-&gt;wmHints)
544         XFree(splash-&gt;wmHints);
545     if (splash-&gt;cursor)
546         XFreeCursor(splash-&gt;display, splash-&gt;cursor);
547     if (splash-&gt;display)
548         XCloseDisplay(splash-&gt;display);
549 }
550 
551 void
552 SplashEventLoop(Splash * splash) {
553 
554     /*      Different from win32 implementation - this loop
555        uses poll timeouts instead of a timer */
556     /* we should have splash _locked_ on entry!!! */
557 
558     int xconn = XConnectionNumber(splash-&gt;display);
559 
560     while (1) {
561         struct pollfd pfd[2];
562         int timeout = -1;
563         int ctl = splash-&gt;controlpipe[0];
564         int rc;
565         int pipes_empty;
566 
567         pfd[0].fd = xconn;
568         pfd[0].events = POLLIN | POLLPRI;
569 
570         pfd[1].fd = ctl;
571         pfd[1].events = POLLIN | POLLPRI;
572 
573         errno = 0;
574         if (splash-&gt;isVisible&gt;0 &amp;&amp; SplashIsStillLooping(splash)) {
575             timeout = splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay
576                 - SplashTime();
577             if (timeout &lt; 0) {
578                 timeout = 0;
579             }
580         }
581         SplashUnlock(splash);
582         rc = poll(pfd, 2, timeout);
583         SplashLock(splash);
584         if (splash-&gt;isVisible &gt; 0 &amp;&amp; splash-&gt;currentFrame &gt;= 0 &amp;&amp;
585                 SplashTime() &gt;= splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay) {
586             SplashNextFrame(splash);
587             SplashUpdateShape(splash);
588             SplashRedrawWindow(splash);
589         }
590         if (rc &lt;= 0) {
591             errno = 0;
592             continue;
593         }
594         pipes_empty = 0;
595         while(!pipes_empty) {
596             char buf;
597 
598             pipes_empty = 1;
599             if (read(ctl, &amp;buf, sizeof(buf)) &gt; 0) {
600                 pipes_empty = 0;
601                 switch (buf) {
602                 case SPLASHCTL_UPDATE:
603                     if (splash-&gt;isVisible&gt;0) {
604                         SplashRedrawWindow(splash);
605                     }
606                     break;
607                 case SPLASHCTL_RECONFIGURE:
608                     if (splash-&gt;isVisible&gt;0) {
609                         SplashReconfigureNow(splash);
610                     }
611                     break;
612                 case SPLASHCTL_QUIT:
613                     return;
614                 }
615             }
616             // we&#39;re not using &quot;while(XPending)&quot;, processing one event
617             // at a time to avoid control pipe starvation
618             if (XPending(splash-&gt;display)) {
619                 XEvent evt;
620 
621                 pipes_empty = 0;
622                 XNextEvent(splash-&gt;display, &amp;evt);
623                 switch (evt.type) {
624                     case Expose:
625                         if (splash-&gt;isVisible&gt;0) {
626                             // we&#39;re doing full redraw so we just
627                             // skip the remaining painting events in the queue
628                             while(XCheckTypedEvent(splash-&gt;display, Expose,
629                                 &amp;evt));
630                             SplashRedrawWindow(splash);
631                         }
632                         break;
633                     /* ... */
634                 }
635             }
636         }
637     }
638 }
639 
640 /*  we can&#39;t use OverrideRedirect for the window as the window should not be
641     always-on-top, so we must set appropriate wm hints
642 
643     this functions sets olwm, mwm and EWMH hints for undecorated window at once
644 
645     It works for: mwm, openbox, wmaker, metacity, KWin (FIXME: test more wm&#39;s)
646     Should work for: fvwm2.5.x, blackbox, olwm
647     Maybe works for: enlightenment, icewm
648     Does not work for: twm, fvwm2.4.7
649 
650 */
651 
652 void
653 SplashRemoveDecoration(Splash * splash) {
654     Atom atom_set;
655     Atom atom_list[4];
656 
657     /* the struct below was copied from MwmUtil.h */
658 
659     struct PROPMOTIFWMHINTS {
660     /* 32-bit property items are stored as long on the client (whether
661      * that means 32 bits or 64).  XChangeProperty handles the conversion
662      * to the actual 32-bit quantities sent to the server.
663      */
664         unsigned long   flags;
665         unsigned long   functions;
666         unsigned long   decorations;
667         long            inputMode;
668         unsigned long   status;
669     }
670     mwm_hints;
671 
672     /* WM_TAKE_FOCUS hint to avoid wm&#39;s transfer of focus to this window */
673     /* WM_DELETE_WINDOW hint to avoid closing this window with Alt-F4. See bug 6474035 */
674     atom_set = XInternAtom(splash-&gt;display, &quot;WM_PROTOCOLS&quot;, True);
675     if (atom_set != None) {
676         atom_list[0] = XInternAtom(splash-&gt;display, &quot;WM_TAKE_FOCUS&quot;, True);
677         atom_list[1] = XInternAtom(splash-&gt;display, &quot;WM_DELETE_WINDOW&quot;, True);
678 
679         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
680                 PropModeReplace, (unsigned char *) atom_list, 2);
681     }
682 
683     /* mwm hints */
684     atom_set = XInternAtom(splash-&gt;display, &quot;_MOTIF_WM_HINTS&quot;, True);
685     if (atom_set != None) {
686         /* flags for decoration and functions */
687         mwm_hints.flags = (1L &lt;&lt; 1) | (1L &lt;&lt; 0);
688         mwm_hints.decorations = 0;
689         mwm_hints.functions = 0;
690         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, atom_set,
691                 32, PropModeReplace, (unsigned char *) &amp;mwm_hints, 5);
692     }
693 
694     /* olwm hints */
695     atom_set = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_DEL&quot;, True);
696     if (atom_set != None) {
697         atom_list[0] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_RESIZE&quot;, True);
698         atom_list[1] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_HEADER&quot;, True);
699         atom_list[2] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_PIN&quot;, True);
700         atom_list[3] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_CLOSE&quot;, True);
701         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
702                 PropModeReplace, (unsigned char *) atom_list, 4);
703     }
704 
705     /* generic EMWH hints
706        we do not set _NET_WM_WINDOW_TYPE to _NET_WM_WINDOW_TYPE_SPLASH
707        hint support due to gnome making this window always-on-top
708        so we have to set _NET_WM_STATE and _NET_WM_ALLOWED_ACTIONS correctly
709        _NET_WM_STATE: SKIP_TASKBAR and SKIP_PAGER
710        _NET_WM_ALLOWED_ACTIONS: disable all actions */
711     atom_set = XInternAtom(splash-&gt;display, &quot;_NET_WM_STATE&quot;, True);
712     if (atom_set != None) {
713         atom_list[0] = XInternAtom(splash-&gt;display,
714                 &quot;_NET_WM_STATE_SKIP_TASKBAR&quot;, True);
715         atom_list[1] = XInternAtom(splash-&gt;display,
716                 &quot;_NET_WM_STATE_SKIP_PAGER&quot;, True);
717         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
718                 PropModeReplace, (unsigned char *) atom_list, 2);
719     }
720     atom_set = XInternAtom(splash-&gt;display, &quot;_NET_WM_ALLOWED_ACTIONS&quot;, True);
721     if (atom_set != None) {
722         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
723                 PropModeReplace, (unsigned char *) atom_list, 0);
724     }
725 }
726 
727 void
728 SplashPThreadDestructor(void *arg) {
729     /* this will be used in case of emergency thread exit on xlib error */
730     Splash *splash = (Splash *) arg;
731 
732     if (splash) {
733         SplashCleanup(splash);
734     }
735 }
736 
737 void *
738 SplashScreenThread(void *param) {
739     Splash *splash = (Splash *) param;
740 //    pthread_key_t key;
741 
742 //    pthread_key_create(&amp;key, SplashPThreadDestructor);
743 //    pthread_setspecific(key, splash);
744 
745     SplashLock(splash);
746     pipe(splash-&gt;controlpipe);
747     fcntl(splash-&gt;controlpipe[0], F_SETFL,
748         fcntl(splash-&gt;controlpipe[0], F_GETFL, 0) | O_NONBLOCK);
749     splash-&gt;time = SplashTime();
750     SplashCreateWindow(splash);
751     fflush(stdout);
752     if (splash-&gt;window) {
753         SplashRemoveDecoration(splash);
754         XStoreName(splash-&gt;display, splash-&gt;window, &quot;Java&quot;);
755         XMapRaised(splash-&gt;display, splash-&gt;window);
756         SplashUpdateShape(splash);
757         SplashRedrawWindow(splash);
758         //map the splash co-ordinates as per system scale
759         splash-&gt;x /= splash-&gt;scaleFactor;
760         splash-&gt;y /= splash-&gt;scaleFactor;
761         SplashEventLoop(splash);
762     }
763     SplashUnlock(splash);
764     SplashDone(splash);
765 
766     splash-&gt;isVisible=-1;
767     return 0;
768 }
769 
770 void
771 SplashCreateThread(Splash * splash) {
772     pthread_t thr;
773     pthread_attr_t attr;
774     int rc;
775 
776     pthread_attr_init(&amp;attr);
777     rc = pthread_create(&amp;thr, &amp;attr, SplashScreenThread, (void *) splash);
778 }
779 
780 void
781 SplashLock(Splash * splash) {
782     pthread_mutex_lock(&amp;splash-&gt;lock);
783 }
784 
785 void
786 SplashUnlock(Splash * splash) {
787     pthread_mutex_unlock(&amp;splash-&gt;lock);
788 }
789 
790 void
791 SplashClosePlatform(Splash * splash) {
792     sendctl(splash, SPLASHCTL_QUIT);
793 }
794 
795 void
796 SplashUpdate(Splash * splash) {
797     sendctl(splash, SPLASHCTL_UPDATE);
798 }
799 
800 void
801 SplashReconfigure(Splash * splash) {
802     sendctl(splash, SPLASHCTL_RECONFIGURE);
803 }
804 
<a name="6" id="anc6"></a><span class="line-modified">805 JNIEXPORT jboolean</span>
806 SplashGetScaledImageName(const char* jarName, const char* fileName,
807                            float *scaleFactor, char *scaledImgName,
808                            const size_t scaledImageNameLength)
809 {
810     *scaleFactor = 1;
811 #ifndef __linux__
812     return JNI_FALSE;
813 #endif
814     *scaleFactor = (float)getNativeScaleFactor(NULL);
815     return GetScaledImageName(fileName, scaledImgName, scaleFactor, scaledImageNameLength);
816 }
817 
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
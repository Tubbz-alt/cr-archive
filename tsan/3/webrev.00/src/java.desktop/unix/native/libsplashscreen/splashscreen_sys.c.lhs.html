<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/native/libsplashscreen/splashscreen_sys.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 2005, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #include &quot;splashscreen_impl.h&quot;
 27 #include &lt;X11/Xlib.h&gt;
 28 #include &lt;X11/Xutil.h&gt;
 29 #include &lt;X11/extensions/shape.h&gt;
 30 #include &lt;X11/Xmd.h&gt;
 31 #include &lt;X11/Xatom.h&gt;
 32 #include &lt;X11/cursorfont.h&gt;
 33 #include &lt;sys/types.h&gt;
 34 #include &lt;pthread.h&gt;
 35 #include &lt;signal.h&gt;
 36 #include &lt;unistd.h&gt;
 37 #include &lt;sys/time.h&gt;
 38 #include &lt;errno.h&gt;
 39 #include &lt;iconv.h&gt;
 40 #include &lt;langinfo.h&gt;
 41 #include &lt;locale.h&gt;
 42 #include &lt;fcntl.h&gt;
 43 #include &lt;poll.h&gt;
 44 #include &lt;sizecalc.h&gt;
 45 #include &quot;jni.h&quot;
 46 
 47 static Bool shapeSupported;
 48 static int shapeEventBase, shapeErrorBase;
 49 
 50 void SplashRemoveDecoration(Splash * splash);
 51 
 52 
 53 /* Could use npt but decided to cut down on linked code size */
 54 char* SplashConvertStringAlloc(const char* in, int* size) {
 55     const char     *codeset;
 56     const char     *codeset_out;
 57     iconv_t         cd;
 58     size_t          rc;
 59     char           *buf = NULL, *out;
 60     size_t          bufSize, inSize, outSize;
 61     const char* old_locale;
 62 
 63     if (!in) {
 64         return NULL;
 65     }
 66     old_locale = setlocale(LC_ALL, &quot;&quot;);
 67 
 68     codeset = nl_langinfo(CODESET);
 69     if ( codeset == NULL || codeset[0] == 0 ) {
 70         goto done;
 71     }
 72     /* we don&#39;t need BOM in output so we choose native BE or LE encoding here */
 73     codeset_out = (platformByteOrder()==BYTE_ORDER_MSBFIRST) ?
 74         &quot;UCS-2BE&quot; : &quot;UCS-2LE&quot;;
 75 
 76     cd = iconv_open(codeset_out, codeset);
 77     if (cd == (iconv_t)-1 ) {
 78         goto done;
 79     }
 80     inSize = strlen(in);
 81     buf = SAFE_SIZE_ARRAY_ALLOC(malloc, inSize, 2);
 82     if (!buf) {
 83         return NULL;
 84     }
 85     bufSize = inSize*2; // need 2 bytes per char for UCS-2, this is
 86                         // 2 bytes per source byte max
 87     out = buf; outSize = bufSize;
 88     /* linux iconv wants char** source and solaris wants const char**...
 89        cast to void* */
 90     rc = iconv(cd, (void*)&amp;in, &amp;inSize, &amp;out, &amp;outSize);
 91     iconv_close(cd);
 92 
 93     if (rc == (size_t)-1) {
 94         free(buf);
 95         buf = NULL;
 96     } else {
 97         if (size) {
 98             *size = (bufSize-outSize)/2; /* bytes to wchars */
 99         }
100     }
101 done:
102     setlocale(LC_ALL, old_locale);
103     return buf;
104 }
105 
106 void
107 SplashInitFrameShape(Splash * splash, int imageIndex) {
108     ImageRect maskRect;
109     XRectangle *rects;
110     SplashImage *frame = splash-&gt;frames + imageIndex;
111 
112     frame-&gt;rects = NULL;
113     frame-&gt;numRects = 0;
114 
115     if (!splash-&gt;maskRequired)
116         return;
117     if (!shapeSupported)
118         return;
119     initRect(&amp;maskRect, 0, 0, splash-&gt;width, splash-&gt;height, 1,
120             splash-&gt;width * splash-&gt;imageFormat.depthBytes,
121             splash-&gt;frames[imageIndex].bitmapBits, &amp;splash-&gt;imageFormat);
122     if (!IS_SAFE_SIZE_MUL(splash-&gt;width / 2 + 1, splash-&gt;height)) {
123         return;
124     }
125     rects = SAFE_SIZE_ARRAY_ALLOC(malloc,
126             sizeof(XRectangle), (splash-&gt;width / 2 + 1) * splash-&gt;height);
127     if (!rects) {
128         return;
129     }
130 
131     frame-&gt;numRects = BitmapToYXBandedRectangles(&amp;maskRect, rects);
132     frame-&gt;rects = SAFE_SIZE_ARRAY_ALLOC(malloc, frame-&gt;numRects, sizeof(XRectangle));
133     if (frame-&gt;rects) { // handle the error after the if(){}
134         memcpy(frame-&gt;rects, rects, frame-&gt;numRects * sizeof(XRectangle));
135     }
136     free(rects);
137 }
138 
139 unsigned
140 SplashTime(void) {
141     struct timeval tv;
142     struct timezone tz;
143     unsigned long long msec;
144 
145     gettimeofday(&amp;tv, &amp;tz);
146     msec = (unsigned long long) tv.tv_sec * 1000 +
147         (unsigned long long) tv.tv_usec / 1000;
148 
149     return (unsigned) msec;
150 }
151 
152 void
153 msec2timeval(unsigned time, struct timeval *tv) {
154     tv-&gt;tv_sec = time / 1000;
155     tv-&gt;tv_usec = (time % 1000) * 1000;
156 }
157 
158 int
159 GetNumAvailableColors(Display * display, Screen * screen, unsigned map_entries) {
160     unsigned long pmr[1];
161     unsigned long pr[SPLASH_COLOR_MAP_SIZE];
162     unsigned nFailed, nAllocated, done = 0, nPlanes = 0;
163     Colormap cmap;
164     unsigned numColors = SPLASH_COLOR_MAP_SIZE; // never try allocating more than that
165 
166     if (numColors &gt; map_entries) {
167         numColors = map_entries;
168     }
169     cmap = XDefaultColormapOfScreen(screen);
170     nAllocated = 0;             /* lower bound */
171     nFailed = numColors + 1;    /* upper bound */
172 
173     /* Binary search to determine the number of available cells */
174     for (done = 0; !done;) {
175         if (XAllocColorCells(display, cmap, 0, pmr, nPlanes, pr, numColors)) {
176             nAllocated = numColors;
177             XFreeColors(display, cmap, pr, numColors, 0);
178             if (nAllocated &lt; (nFailed - 1)) {
179                 numColors = (nAllocated + nFailed) / 2;
180             } else
181                 done = 1;
182         } else {
183             nFailed = numColors;
184             if (nFailed &gt; (nAllocated + 1))
185                 numColors = (nAllocated + nFailed) / 2;
186             else
187                 done = 1;
188         }
189     }
190     return nAllocated;
191 }
192 
193 Colormap
194 AllocColors(Display * display, Screen * screen, int numColors,
195         unsigned long *pr) {
196     unsigned long pmr[1];
197     Colormap cmap = XDefaultColormapOfScreen(screen);
198 
199     XAllocColorCells(display, cmap, 0, pmr, 0, pr, numColors);
200     return cmap;
201 }
202 
203 void
204 FreeColors(Display * display, Screen * screen, int numColors,
205         unsigned long *pr) {
206     Colormap cmap = XDefaultColormapOfScreen(screen);
207 
208     XFreeColors(display, cmap, pr, numColors, 0);
209 }
210 
211 static void SplashCenter(Splash * splash) {
212     Atom type, atom, actual_type;
213     int status, actual_format;
214     unsigned long nitems, bytes_after;
215     CARD16 *prop = NULL;
216 
217     /*  try centering using Xinerama hint
218         if there&#39;s no hint, use the center of the screen */
219     atom = XInternAtom(splash-&gt;display, &quot;XINERAMA_CENTER_HINT&quot;, True);
220     if (atom != None) {
221         status = XGetWindowProperty(splash-&gt;display,
222             XRootWindowOfScreen(splash-&gt;screen), atom, 0, 1, False, XA_INTEGER,
223             &amp;actual_type, &amp;actual_format, &amp;nitems,
224             &amp;bytes_after, (unsigned char**)(&amp;prop));
225         if (status == Success &amp;&amp; actual_type != None &amp;&amp; prop != NULL) {
226             splash-&gt;x = prop[0] - splash-&gt;width/2;
227             splash-&gt;y = prop[1] - splash-&gt;height/2;
228             XFree(prop);
229             return;
230         }
231         if (prop != NULL) {
232             XFree(prop);
233         }
234     }
235     splash-&gt;x = (XWidthOfScreen(splash-&gt;screen) - splash-&gt;width) / 2;
236     splash-&gt;y = (XHeightOfScreen(splash-&gt;screen) - splash-&gt;height) / 2;
237 }
238 
239 static void SplashUpdateSizeHints(Splash * splash) {
240     if (splash-&gt;window) {
241         XSizeHints sizeHints;
242 
243         sizeHints.flags = USPosition | PPosition | USSize | PSize | PMinSize | PMaxSize | PWinGravity;
244         sizeHints.width = sizeHints.base_width = sizeHints.min_width = sizeHints.max_width = splash-&gt;width;
245         sizeHints.height = sizeHints.base_height = sizeHints.min_height = sizeHints.max_height = splash-&gt;height;
246         sizeHints.win_gravity = NorthWestGravity;
247 
248         XSetWMNormalHints(splash-&gt;display, splash-&gt;window, &amp;sizeHints);
249     }
250 }
251 
252 void
253 SplashCreateWindow(Splash * splash) {
254     XSizeHints sizeHints;
255 
256     XSetWindowAttributes attr;
257 
258     attr.backing_store = NotUseful;
259     attr.colormap = XDefaultColormapOfScreen(splash-&gt;screen);
260     attr.save_under = True;
261     attr.cursor = splash-&gt;cursor = XCreateFontCursor(splash-&gt;display, XC_watch);
262     attr.event_mask = ExposureMask;
263 
264     SplashCenter(splash);
265 
266     splash-&gt;window = XCreateWindow(splash-&gt;display, XRootWindowOfScreen(splash-&gt;screen),
267         splash-&gt;x, splash-&gt;y, splash-&gt;width, splash-&gt;height, 0, CopyFromParent,
268         InputOutput, CopyFromParent, CWColormap | CWBackingStore | CWSaveUnder | CWCursor | CWEventMask,
269         &amp;attr);
270     SplashUpdateSizeHints(splash);
271 
272 
273     splash-&gt;wmHints = XAllocWMHints();
274     if (splash-&gt;wmHints) {
275         splash-&gt;wmHints-&gt;flags = InputHint | StateHint;
276         splash-&gt;wmHints-&gt;input = False;
277         splash-&gt;wmHints-&gt;initial_state = NormalState;
278         XSetWMHints(splash-&gt;display, splash-&gt;window, splash-&gt;wmHints);
279     }
280 }
281 
282 /* for changing the visible shape of a window to an nonrectangular form */
283 void
284 SplashUpdateShape(Splash * splash) {
285     if (splash-&gt;currentFrame &lt; 0 || !shapeSupported || !splash-&gt;maskRequired) {
286         return;
287     }
288     XShapeCombineRectangles(splash-&gt;display, splash-&gt;window, ShapeClip, 0, 0,
289             splash-&gt;frames[splash-&gt;currentFrame].rects,
290             splash-&gt;frames[splash-&gt;currentFrame].numRects, ShapeSet, YXBanded);
291     XShapeCombineRectangles(splash-&gt;display, splash-&gt;window, ShapeBounding,
292             0, 0, splash-&gt;frames[splash-&gt;currentFrame].rects,
293             splash-&gt;frames[splash-&gt;currentFrame].numRects, ShapeSet, YXBanded);
294 }
295 
296 /* for reverting the visible shape of a window to an rectangular form */
297 void
298 SplashRevertShape(Splash * splash) {
299     if (!shapeSupported)
300         return;
301     if (splash-&gt;maskRequired)
302         return;
303 
304     XShapeCombineMask (splash-&gt;display, splash-&gt;window, ShapeClip,
305                        0, 0, None, ShapeSet);
306     XShapeCombineMask (splash-&gt;display, splash-&gt;window , ShapeBounding,
307                        0, 0, None, ShapeSet);
308 }
309 
310 int
311 ByteOrderToX(int byteOrder) {
312     if (byteOrder == BYTE_ORDER_NATIVE)
313         byteOrder = platformByteOrder();
314     switch (byteOrder) {
315     case BYTE_ORDER_LSBFIRST:
316         return LSBFirst;
317     case BYTE_ORDER_MSBFIRST:
318         return MSBFirst;
319     default:
320         return -1;
321     }
322 }
323 
324 void
325 SplashRedrawWindow(Splash * splash) {
326     if (splash-&gt;currentFrame &lt; 0) {
327         return;
328     }
329 
330     XImage *ximage;
331 
332     // making this method redraw a part of the image does not make
333     // much sense as SplashUpdateScreenData always re-generates
334     // the image completely, so whole window is always redrawn
335 
336     SplashUpdateScreenData(splash);
337     ximage = XCreateImage(splash-&gt;display, splash-&gt;visual,
338             splash-&gt;screenFormat.depthBytes * 8, ZPixmap, 0, (char *) NULL,
339             splash-&gt;width, splash-&gt;height, 8, 0);
340     ximage-&gt;data = (char *) splash-&gt;screenData;
341     ximage-&gt;bits_per_pixel = ximage-&gt;depth;
342     ximage-&gt;bytes_per_line = ximage-&gt;depth * ximage-&gt;width / 8;
343     ximage-&gt;byte_order = ByteOrderToX(splash-&gt;screenFormat.byteOrder);
344     ximage-&gt;bitmap_unit = 8;
345     XPutImage(splash-&gt;display, splash-&gt;window,
346             XDefaultGCOfScreen(splash-&gt;screen), ximage, 0, 0, 0, 0,
347             splash-&gt;width, splash-&gt;height);
348     ximage-&gt;data = NULL;
349     XDestroyImage(ximage);
350     SplashRemoveDecoration(splash);
351     XMapWindow(splash-&gt;display, splash-&gt;window);
352     XFlush(splash-&gt;display);
353 }
354 
355 void SplashReconfigureNow(Splash * splash) {
356     SplashCenter(splash);
357     if (splash-&gt;window) {
358         XUnmapWindow(splash-&gt;display, splash-&gt;window);
359         XMoveResizeWindow(splash-&gt;display, splash-&gt;window,
360             splash-&gt;x, splash-&gt;y,
361             splash-&gt;width, splash-&gt;height);
362         SplashUpdateSizeHints(splash);
363     }
364     if (splash-&gt;maskRequired) {
365         SplashUpdateShape(splash);
366     } else {
367         SplashRevertShape(splash);
368     }
369     SplashRedrawWindow(splash);
370 }
371 
372 
373 void
374 sendctl(Splash * splash, char code) {
375 //    if (splash-&gt;isVisible&gt;0) {
376     if (splash &amp;&amp; splash-&gt;controlpipe[1]) {
377         write(splash-&gt;controlpipe[1], &amp;code, 1);
378     }
379 }
380 
381 int
382 HandleError(Display * disp, XErrorEvent * err) {
383     // silently ignore non-fatal errors
384     /*
385     char msg[0x1000];
386     char buf[0x1000];
387     XGetErrorText(disp, err-&gt;error_code, msg, sizeof(msg));
388     fprintf(stderr, &quot;Xerror %s, XID %x, ser# %d\n&quot;, msg, err-&gt;resourceid,
389         err-&gt;serial);
390     sprintf(buf, &quot;%d&quot;, err-&gt;request_code);
391     XGetErrorDatabaseText(disp, &quot;XRequest&quot;, buf, &quot;Unknown&quot;, msg, sizeof(msg));
392     fprintf(stderr, &quot;Major opcode %d (%s)\n&quot;, err-&gt;request_code, msg);
393     if (err-&gt;request_code &gt; 128) {
394         fprintf(stderr, &quot;Minor opcode %d\n&quot;, err-&gt;minor_code);
395     }
396     */
397     return 0;
398 }
399 
400 int
401 HandleIOError(Display * display) {
402     // for really bad errors, we should exit the thread we&#39;re on
403     SplashCleanup(SplashGetInstance());
404     pthread_exit(NULL);
405     return 0;
406 }
407 
<a name="2" id="anc2"></a><span class="line-modified">408 void</span>
409 SplashInitPlatform(Splash * splash) {
410     int shapeVersionMajor, shapeVersionMinor;
411 
412     // This setting enables the synchronous Xlib mode!
413     // Don&#39;t use it == 1 in production builds!
414 #if (defined DEBUG)
415     _Xdebug = 1;
416 #endif
417 
418     pthread_mutex_init(&amp;splash-&gt;lock, NULL);
419 
420     // We should not ignore any errors.
421     //XSetErrorHandler(HandleError);
422 //    XSetIOErrorHandler(HandleIOError);
423     XSetIOErrorHandler(NULL);
424     splash-&gt;display = XOpenDisplay(NULL);
425     if (!splash-&gt;display) {
426         splash-&gt;isVisible = -1;
<a name="3" id="anc3"></a><span class="line-modified">427         return;</span>
428     }
429 
430     shapeSupported = XShapeQueryExtension(splash-&gt;display, &amp;shapeEventBase,
431             &amp;shapeErrorBase);
432     if (shapeSupported) {
433         XShapeQueryVersion(splash-&gt;display, &amp;shapeVersionMajor,
434                 &amp;shapeVersionMinor);
435     }
436 
437     splash-&gt;screen = XDefaultScreenOfDisplay(splash-&gt;display);
438     splash-&gt;visual = XDefaultVisualOfScreen(splash-&gt;screen);
439     switch (splash-&gt;visual-&gt;class) {
440     case TrueColor: {
441             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
442 
443             splash-&gt;byteAlignment = 1;
444             splash-&gt;maskRequired = shapeSupported;
445             initFormat(&amp;splash-&gt;screenFormat, splash-&gt;visual-&gt;red_mask,
446                     splash-&gt;visual-&gt;green_mask, splash-&gt;visual-&gt;blue_mask, 0);
447             splash-&gt;screenFormat.byteOrder =
448                 (XImageByteOrder(splash-&gt;display) == LSBFirst ?
449                  BYTE_ORDER_LSBFIRST : BYTE_ORDER_MSBFIRST);
450             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;
451             // TrueColor depth probably can&#39;t be less
452             // than 8 bits, and it&#39;s always byte padded
453             break;
454         }
455     case PseudoColor: {
456             int availableColors;
457             int numColors;
458             int numComponents[3];
459             unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
460             XColor xColors[SPLASH_COLOR_MAP_SIZE];
461             int i;
462             int depth = XDefaultDepthOfScreen(splash-&gt;screen);
463             int scale = 65535 / MAX_COLOR_VALUE;
464 
465             availableColors = GetNumAvailableColors(splash-&gt;display, splash-&gt;screen,
466                     splash-&gt;visual-&gt;map_entries);
467             numColors = quantizeColors(availableColors, numComponents);
468             if (numColors &gt; availableColors) {
469                 // Could not allocate the color cells. Most probably
470                 // the pool got exhausted. Disable the splash screen.
471                 XCloseDisplay(splash-&gt;display);
472                 splash-&gt;isVisible = -1;
473                 splash-&gt;display = NULL;
474                 splash-&gt;screen = NULL;
475                 splash-&gt;visual = NULL;
476                 fprintf(stderr, &quot;Warning: unable to initialize the splashscreen. Not enough available color cells.\n&quot;);
<a name="4" id="anc4"></a><span class="line-modified">477                 return;</span>
478             }
479             splash-&gt;cmap = AllocColors(splash-&gt;display, splash-&gt;screen,
480                     numColors, colorIndex);
481             for (i = 0; i &lt; numColors; i++) {
482                 splash-&gt;colorIndex[i] = colorIndex[i];
483             }
484             initColorCube(numComponents, splash-&gt;colorMap, splash-&gt;dithers,
485                     splash-&gt;colorIndex);
486             for (i = 0; i &lt; numColors; i++) {
487                 xColors[i].pixel = colorIndex[i];
488                 xColors[i].red = (unsigned short)
489                     QUAD_RED(splash-&gt;colorMap[colorIndex[i]]) * scale;
490                 xColors[i].green = (unsigned short)
491                     QUAD_GREEN(splash-&gt;colorMap[colorIndex[i]]) * scale;
492                 xColors[i].blue = (unsigned short)
493                     QUAD_BLUE(splash-&gt;colorMap[colorIndex[i]]) * scale;
494                 xColors[i].flags = DoRed | DoGreen | DoBlue;
495             }
496             XStoreColors(splash-&gt;display, splash-&gt;cmap, xColors, numColors);
497             initFormat(&amp;splash-&gt;screenFormat, 0, 0, 0, 0);
498             splash-&gt;screenFormat.colorIndex = splash-&gt;colorIndex;
499             splash-&gt;screenFormat.depthBytes = (depth + 7) / 8;  // or always 8?
500             splash-&gt;screenFormat.colorMap = splash-&gt;colorMap;
501             splash-&gt;screenFormat.dithers = splash-&gt;dithers;
502             splash-&gt;screenFormat.numColors = numColors;
503             splash-&gt;screenFormat.byteOrder = BYTE_ORDER_NATIVE;
504             break;
505         }
506     default:
507         ; /* FIXME: should probably be fixed, but javaws splash screen doesn&#39;t support other visuals either */
508     }
<a name="5" id="anc5"></a>
509 }
510 
511 
512 void
513 SplashCleanupPlatform(Splash * splash) {
514     int i;
515 
516     if (splash-&gt;frames) {
517         for (i = 0; i &lt; splash-&gt;frameCount; i++) {
518             if (splash-&gt;frames[i].rects) {
519                 free(splash-&gt;frames[i].rects);
520                 splash-&gt;frames[i].rects = NULL;
521             }
522         }
523     }
524     splash-&gt;maskRequired = shapeSupported;
525 }
526 
527 void
528 SplashDonePlatform(Splash * splash) {
529     pthread_mutex_destroy(&amp;splash-&gt;lock);
530     if (splash-&gt;cmap) {
531         unsigned long colorIndex[SPLASH_COLOR_MAP_SIZE];
532         int i;
533 
534         for (i = 0; i &lt; splash-&gt;screenFormat.numColors; i++) {
535             colorIndex[i] = splash-&gt;colorIndex[i];
536         }
537         FreeColors(splash-&gt;display, splash-&gt;screen,
538                 splash-&gt;screenFormat.numColors, colorIndex);
539     }
540     if (splash-&gt;window)
541         XDestroyWindow(splash-&gt;display, splash-&gt;window);
542     if (splash-&gt;wmHints)
543         XFree(splash-&gt;wmHints);
544     if (splash-&gt;cursor)
545         XFreeCursor(splash-&gt;display, splash-&gt;cursor);
546     if (splash-&gt;display)
547         XCloseDisplay(splash-&gt;display);
548 }
549 
550 void
551 SplashEventLoop(Splash * splash) {
552 
553     /*      Different from win32 implementation - this loop
554        uses poll timeouts instead of a timer */
555     /* we should have splash _locked_ on entry!!! */
556 
557     int xconn = XConnectionNumber(splash-&gt;display);
558 
559     while (1) {
560         struct pollfd pfd[2];
561         int timeout = -1;
562         int ctl = splash-&gt;controlpipe[0];
563         int rc;
564         int pipes_empty;
565 
566         pfd[0].fd = xconn;
567         pfd[0].events = POLLIN | POLLPRI;
568 
569         pfd[1].fd = ctl;
570         pfd[1].events = POLLIN | POLLPRI;
571 
572         errno = 0;
573         if (splash-&gt;isVisible&gt;0 &amp;&amp; SplashIsStillLooping(splash)) {
574             timeout = splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay
575                 - SplashTime();
576             if (timeout &lt; 0) {
577                 timeout = 0;
578             }
579         }
580         SplashUnlock(splash);
581         rc = poll(pfd, 2, timeout);
582         SplashLock(splash);
583         if (splash-&gt;isVisible &gt; 0 &amp;&amp; splash-&gt;currentFrame &gt;= 0 &amp;&amp;
584                 SplashTime() &gt;= splash-&gt;time + splash-&gt;frames[splash-&gt;currentFrame].delay) {
585             SplashNextFrame(splash);
586             SplashUpdateShape(splash);
587             SplashRedrawWindow(splash);
588         }
589         if (rc &lt;= 0) {
590             errno = 0;
591             continue;
592         }
593         pipes_empty = 0;
594         while(!pipes_empty) {
595             char buf;
596 
597             pipes_empty = 1;
598             if (read(ctl, &amp;buf, sizeof(buf)) &gt; 0) {
599                 pipes_empty = 0;
600                 switch (buf) {
601                 case SPLASHCTL_UPDATE:
602                     if (splash-&gt;isVisible&gt;0) {
603                         SplashRedrawWindow(splash);
604                     }
605                     break;
606                 case SPLASHCTL_RECONFIGURE:
607                     if (splash-&gt;isVisible&gt;0) {
608                         SplashReconfigureNow(splash);
609                     }
610                     break;
611                 case SPLASHCTL_QUIT:
612                     return;
613                 }
614             }
615             // we&#39;re not using &quot;while(XPending)&quot;, processing one event
616             // at a time to avoid control pipe starvation
617             if (XPending(splash-&gt;display)) {
618                 XEvent evt;
619 
620                 pipes_empty = 0;
621                 XNextEvent(splash-&gt;display, &amp;evt);
622                 switch (evt.type) {
623                     case Expose:
624                         if (splash-&gt;isVisible&gt;0) {
625                             // we&#39;re doing full redraw so we just
626                             // skip the remaining painting events in the queue
627                             while(XCheckTypedEvent(splash-&gt;display, Expose,
628                                 &amp;evt));
629                             SplashRedrawWindow(splash);
630                         }
631                         break;
632                     /* ... */
633                 }
634             }
635         }
636     }
637 }
638 
639 /*  we can&#39;t use OverrideRedirect for the window as the window should not be
640     always-on-top, so we must set appropriate wm hints
641 
642     this functions sets olwm, mwm and EWMH hints for undecorated window at once
643 
644     It works for: mwm, openbox, wmaker, metacity, KWin (FIXME: test more wm&#39;s)
645     Should work for: fvwm2.5.x, blackbox, olwm
646     Maybe works for: enlightenment, icewm
647     Does not work for: twm, fvwm2.4.7
648 
649 */
650 
651 void
652 SplashRemoveDecoration(Splash * splash) {
653     Atom atom_set;
654     Atom atom_list[4];
655 
656     /* the struct below was copied from MwmUtil.h */
657 
658     struct PROPMOTIFWMHINTS {
659     /* 32-bit property items are stored as long on the client (whether
660      * that means 32 bits or 64).  XChangeProperty handles the conversion
661      * to the actual 32-bit quantities sent to the server.
662      */
663         unsigned long   flags;
664         unsigned long   functions;
665         unsigned long   decorations;
666         long            inputMode;
667         unsigned long   status;
668     }
669     mwm_hints;
670 
671     /* WM_TAKE_FOCUS hint to avoid wm&#39;s transfer of focus to this window */
672     /* WM_DELETE_WINDOW hint to avoid closing this window with Alt-F4. See bug 6474035 */
673     atom_set = XInternAtom(splash-&gt;display, &quot;WM_PROTOCOLS&quot;, True);
674     if (atom_set != None) {
675         atom_list[0] = XInternAtom(splash-&gt;display, &quot;WM_TAKE_FOCUS&quot;, True);
676         atom_list[1] = XInternAtom(splash-&gt;display, &quot;WM_DELETE_WINDOW&quot;, True);
677 
678         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
679                 PropModeReplace, (unsigned char *) atom_list, 2);
680     }
681 
682     /* mwm hints */
683     atom_set = XInternAtom(splash-&gt;display, &quot;_MOTIF_WM_HINTS&quot;, True);
684     if (atom_set != None) {
685         /* flags for decoration and functions */
686         mwm_hints.flags = (1L &lt;&lt; 1) | (1L &lt;&lt; 0);
687         mwm_hints.decorations = 0;
688         mwm_hints.functions = 0;
689         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, atom_set,
690                 32, PropModeReplace, (unsigned char *) &amp;mwm_hints, 5);
691     }
692 
693     /* olwm hints */
694     atom_set = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_DEL&quot;, True);
695     if (atom_set != None) {
696         atom_list[0] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_RESIZE&quot;, True);
697         atom_list[1] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_HEADER&quot;, True);
698         atom_list[2] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_PIN&quot;, True);
699         atom_list[3] = XInternAtom(splash-&gt;display, &quot;_OL_DECOR_CLOSE&quot;, True);
700         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
701                 PropModeReplace, (unsigned char *) atom_list, 4);
702     }
703 
704     /* generic EMWH hints
705        we do not set _NET_WM_WINDOW_TYPE to _NET_WM_WINDOW_TYPE_SPLASH
706        hint support due to gnome making this window always-on-top
707        so we have to set _NET_WM_STATE and _NET_WM_ALLOWED_ACTIONS correctly
708        _NET_WM_STATE: SKIP_TASKBAR and SKIP_PAGER
709        _NET_WM_ALLOWED_ACTIONS: disable all actions */
710     atom_set = XInternAtom(splash-&gt;display, &quot;_NET_WM_STATE&quot;, True);
711     if (atom_set != None) {
712         atom_list[0] = XInternAtom(splash-&gt;display,
713                 &quot;_NET_WM_STATE_SKIP_TASKBAR&quot;, True);
714         atom_list[1] = XInternAtom(splash-&gt;display,
715                 &quot;_NET_WM_STATE_SKIP_PAGER&quot;, True);
716         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
717                 PropModeReplace, (unsigned char *) atom_list, 2);
718     }
719     atom_set = XInternAtom(splash-&gt;display, &quot;_NET_WM_ALLOWED_ACTIONS&quot;, True);
720     if (atom_set != None) {
721         XChangeProperty(splash-&gt;display, splash-&gt;window, atom_set, XA_ATOM, 32,
722                 PropModeReplace, (unsigned char *) atom_list, 0);
723     }
724 }
725 
726 void
727 SplashPThreadDestructor(void *arg) {
728     /* this will be used in case of emergency thread exit on xlib error */
729     Splash *splash = (Splash *) arg;
730 
731     if (splash) {
732         SplashCleanup(splash);
733     }
734 }
735 
736 void *
737 SplashScreenThread(void *param) {
738     Splash *splash = (Splash *) param;
739 //    pthread_key_t key;
740 
741 //    pthread_key_create(&amp;key, SplashPThreadDestructor);
742 //    pthread_setspecific(key, splash);
743 
744     SplashLock(splash);
745     pipe(splash-&gt;controlpipe);
746     fcntl(splash-&gt;controlpipe[0], F_SETFL,
747         fcntl(splash-&gt;controlpipe[0], F_GETFL, 0) | O_NONBLOCK);
748     splash-&gt;time = SplashTime();
749     SplashCreateWindow(splash);
750     fflush(stdout);
751     if (splash-&gt;window) {
752         SplashRemoveDecoration(splash);
753         XStoreName(splash-&gt;display, splash-&gt;window, &quot;Java&quot;);
754         XMapRaised(splash-&gt;display, splash-&gt;window);
755         SplashUpdateShape(splash);
756         SplashRedrawWindow(splash);
757         //map the splash co-ordinates as per system scale
758         splash-&gt;x /= splash-&gt;scaleFactor;
759         splash-&gt;y /= splash-&gt;scaleFactor;
760         SplashEventLoop(splash);
761     }
762     SplashUnlock(splash);
763     SplashDone(splash);
764 
765     splash-&gt;isVisible=-1;
766     return 0;
767 }
768 
769 void
770 SplashCreateThread(Splash * splash) {
771     pthread_t thr;
772     pthread_attr_t attr;
773     int rc;
774 
775     pthread_attr_init(&amp;attr);
776     rc = pthread_create(&amp;thr, &amp;attr, SplashScreenThread, (void *) splash);
777 }
778 
779 void
780 SplashLock(Splash * splash) {
781     pthread_mutex_lock(&amp;splash-&gt;lock);
782 }
783 
784 void
785 SplashUnlock(Splash * splash) {
786     pthread_mutex_unlock(&amp;splash-&gt;lock);
787 }
788 
789 void
790 SplashClosePlatform(Splash * splash) {
791     sendctl(splash, SPLASHCTL_QUIT);
792 }
793 
794 void
795 SplashUpdate(Splash * splash) {
796     sendctl(splash, SPLASHCTL_UPDATE);
797 }
798 
799 void
800 SplashReconfigure(Splash * splash) {
801     sendctl(splash, SPLASHCTL_RECONFIGURE);
802 }
803 
<a name="6" id="anc6"></a><span class="line-modified">804 JNIEXPORT jboolean JNICALL</span>
805 SplashGetScaledImageName(const char* jarName, const char* fileName,
806                            float *scaleFactor, char *scaledImgName,
807                            const size_t scaledImageNameLength)
808 {
809     *scaleFactor = 1;
810 #ifndef __linux__
811     return JNI_FALSE;
812 #endif
813     *scaleFactor = (float)getNativeScaleFactor(NULL);
814     return GetScaledImageName(fileName, scaledImgName, scaleFactor, scaledImageNameLength);
815 }
816 
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
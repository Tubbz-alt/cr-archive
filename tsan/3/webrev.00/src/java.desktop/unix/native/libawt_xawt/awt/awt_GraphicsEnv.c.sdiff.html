<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/native/libawt_xawt/awt/awt_GraphicsEnv.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="awt_Event.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_InputMethod.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/libawt_xawt/awt/awt_GraphicsEnv.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  37 #ifndef NO_XRANDR
  38 #include &lt;X11/extensions/Xrandr.h&gt;
  39 #endif
  40 #include &quot;GLXGraphicsConfig.h&quot;
  41 #endif /* !HEADLESS */
  42 
  43 #include &lt;jni.h&gt;
  44 #include &lt;jni_util.h&gt;
  45 #include &lt;jvm.h&gt;
  46 #include &lt;jvm_md.h&gt;
  47 #include &lt;jlong.h&gt;
  48 #include &quot;systemScale.h&quot;
  49 #include &lt;stdlib.h&gt;
  50 
  51 #include &quot;awt_GraphicsEnv.h&quot;
  52 #include &quot;awt_util.h&quot;
  53 #include &quot;gdefs.h&quot;
  54 #include &lt;dlfcn.h&gt;
  55 #include &quot;Trace.h&quot;
  56 
<span class="line-removed">  57 #ifdef NETSCAPE</span>
<span class="line-removed">  58 #include &lt;signal.h&gt;</span>
<span class="line-removed">  59 extern int awt_init_xt;</span>
<span class="line-removed">  60 #endif</span>
<span class="line-removed">  61 </span>
  62 #ifndef HEADLESS
  63 
  64 int awt_numScreens;     /* Xinerama-aware number of screens */
  65 
  66 AwtScreenDataPtr x11Screens;
  67 
  68 /*
  69  * Set in initDisplay() to indicate whether we should attempt to initialize
  70  * GLX for the default configuration.
  71  */
  72 static jboolean glxRequested = JNI_FALSE;
  73 
  74 #endif /* !HEADLESS */
  75 
  76 #ifdef HEADLESS
  77 #define Display void
  78 #endif /* HEADLESS */
  79 
  80 Display *awt_display;
  81 
</pre>
<hr />
<pre>
  95         if (method_id == NULL) return NULL; \
  96     } while (0)
  97 
  98 struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
  99 
 100 #ifndef HEADLESS
 101 int awtCreateX11Colormap(AwtGraphicsConfigDataPtr adata);
 102 #endif /* HEADLESS */
 103 
 104 static char *x11GraphicsConfigClassName = &quot;sun/awt/X11GraphicsConfig&quot;;
 105 
 106 /* AWT and Xinerama
 107  *
 108  * As of fix 4356756, AWT is Xinerama-aware.  X11GraphicsDevices are created for
 109  * each screen of a Xinerama setup, though X11 itself still only sees a single
 110  * display.
 111  * In many places where we talk to X11, a xinawareScreen variable is used to
 112  * pass the correct Display value, depending on the circumstances (a single
 113  * X display, multiple X displays, or a single X display with multiple
 114  * Xinerama screens).
<span class="line-removed"> 115  *</span>
<span class="line-removed"> 116  * Solaris and Linux differ in the functions used to access Xinerama-related</span>
<span class="line-removed"> 117  * data.  This is in part because at this time, the X consortium has not</span>
<span class="line-removed"> 118  * finalized the &quot;official&quot; Xinerama API.  Once this spec is available, and</span>
<span class="line-removed"> 119  * both OSes are conformant, one code base should be sufficient for Xinerama</span>
<span class="line-removed"> 120  * operation on both OSes.  Until then, some of the Xinerama-related code</span>
<span class="line-removed"> 121  * is ifdef&#39;d appropriately.  -bchristi, 7/12/01</span>
 122  */
 123 
 124 #define MAXFRAMEBUFFERS 16
<span class="line-removed"> 125 #if defined(__linux__) || defined(MACOSX)</span>
 126 typedef struct {
 127    int   screen_number;
 128    short x_org;
 129    short y_org;
 130    short width;
 131    short height;
 132 } XineramaScreenInfo;
 133 
 134 typedef XineramaScreenInfo* XineramaQueryScreensFunc(Display*, int*);
<span class="line-modified"> 135 </span>
<span class="line-removed"> 136 #else /* SOLARIS */</span>
<span class="line-removed"> 137 typedef Status XineramaGetInfoFunc(Display* display, int screen_number,</span>
<span class="line-removed"> 138          XRectangle* framebuffer_rects, unsigned char* framebuffer_hints,</span>
<span class="line-removed"> 139          int* num_framebuffers);</span>
<span class="line-removed"> 140 #endif</span>
<span class="line-removed"> 141 </span>
 142 Bool usingXinerama = False;
<span class="line-removed"> 143 XRectangle fbrects[MAXFRAMEBUFFERS];</span>
 144 
 145 JNIEXPORT void JNICALL
 146 Java_sun_awt_X11GraphicsConfig_initIDs (JNIEnv *env, jclass cls)
 147 {
 148     x11GraphicsConfigIDs.aData = NULL;
 149     x11GraphicsConfigIDs.bitsPerPixel = NULL;
 150 
 151     x11GraphicsConfigIDs.aData = (*env)-&gt;GetFieldID (env, cls, &quot;aData&quot;, &quot;J&quot;);
 152     CHECK_NULL(x11GraphicsConfigIDs.aData);
 153     x11GraphicsConfigIDs.bitsPerPixel = (*env)-&gt;GetFieldID (env, cls, &quot;bitsPerPixel&quot;, &quot;I&quot;);
 154     CHECK_NULL(x11GraphicsConfigIDs.bitsPerPixel);
<span class="line-removed"> 155 </span>
<span class="line-removed"> 156     if (x11GraphicsConfigIDs.aData == NULL ||</span>
<span class="line-removed"> 157             x11GraphicsConfigIDs.bitsPerPixel == NULL) {</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159             JNU_ThrowNoSuchFieldError(env, &quot;Can&#39;t find a field&quot;);</span>
<span class="line-removed"> 160             return;</span>
<span class="line-removed"> 161         }</span>
 162 }
 163 
 164 #ifndef HEADLESS
 165 
 166 /*
 167  * XIOErrorHandler
 168  */
 169 static int xioerror_handler(Display *disp)
 170 {
 171     if (awtLockInited) {
 172         if (errno == EPIPE) {
 173             jio_fprintf(stderr, &quot;X connection to %s host broken (explicit kill or server shutdown)\n&quot;, XDisplayName(NULL));
 174         }
 175         /*SignalError(lockedee-&gt;lastpc, lockedee, &quot;fp/ade/gui/GUIException&quot;, &quot;I/O error&quot;); */
 176     }
 177     return 0;
 178 }
 179 
 180 static AwtGraphicsConfigDataPtr
 181 findWithTemplate(XVisualInfo *vinfo,
 182                  long mask)
 183 {
 184 
 185     XVisualInfo *visualList;
 186     XColor color;
 187     AwtGraphicsConfigDataPtr defaultConfig;
 188     int visualsMatched, i;
 189 
 190     visualList = XGetVisualInfo(awt_display,
 191                                 mask, vinfo, &amp;visualsMatched);
 192     if (visualList) {
 193         int id = -1;
 194         VisualID defaultVisual = XVisualIDFromVisual(DefaultVisual(awt_display, vinfo-&gt;screen));
 195         defaultConfig = ZALLOC(_AwtGraphicsConfigData);




 196         for (i = 0; i &lt; visualsMatched; i++) {
 197             memcpy(&amp;defaultConfig-&gt;awt_visInfo, &amp;visualList[i], sizeof(XVisualInfo));
 198             defaultConfig-&gt;awt_depth = visualList[i].depth;
 199 
 200             /* we can&#39;t use awtJNI_CreateColorData here, because it&#39;ll pull,
 201                SystemColor, which in turn will cause toolkit to be reinitialized */
 202             if (awtCreateX11Colormap(defaultConfig)) {
 203                 if (visualList[i].visualid == defaultVisual) {
 204                     id = i;
 205                     break;
 206                 } else if (-1 == id) {
 207                     // Keep 1st match for fallback
 208                     id = i;
 209                 }
 210             }
 211         }
 212         if (-1 != id) {
 213             memcpy(&amp;defaultConfig-&gt;awt_visInfo, &amp;visualList[id], sizeof(XVisualInfo));
 214             defaultConfig-&gt;awt_depth = visualList[id].depth;
 215             /* Allocate white and black pixels for this visual */
</pre>
<hr />
<pre>
 408         AWT_UNLOCK();
 409         return;
 410     }
 411 
 412     if (screenDataPtr-&gt;defaultConfig == NULL) {
 413         /*
 414          * After a display change event, the default config field will have
 415          * been reset, so we need to recreate the default config here.
 416          */
 417         screenDataPtr-&gt;defaultConfig = makeDefaultConfig(env, screen);
 418     }
 419 
 420     defaultConfig = screenDataPtr-&gt;defaultConfig;
 421     graphicsConfigs[0] = defaultConfig;
 422     nConfig = 1; /* reserve index 0 for default config */
 423 
 424     // Only use the RENDER extension if it is available on the X server
 425     if (XQueryExtension(awt_display, &quot;RENDER&quot;,
 426                         &amp;major_opcode, &amp;first_event, &amp;first_error))
 427     {

 428         xrenderLibHandle = dlopen(&quot;libXrender.so.1&quot;, RTLD_LAZY | RTLD_GLOBAL);
 429 
 430 #ifdef MACOSX
 431 #define XRENDER_LIB &quot;/usr/X11/lib/libXrender.dylib&quot;
 432 #else
 433 #define XRENDER_LIB &quot;libXrender.so&quot;
 434 #endif
 435 
 436         if (xrenderLibHandle == NULL) {
 437             xrenderLibHandle = dlopen(XRENDER_LIB,
 438                                       RTLD_LAZY | RTLD_GLOBAL);
 439         }
 440 
<span class="line-modified"> 441 #ifndef __linux__ /* SOLARIS */</span>
 442         if (xrenderLibHandle == NULL) {
 443             xrenderLibHandle = dlopen(&quot;/usr/lib/libXrender.so.1&quot;,
 444                                       RTLD_LAZY | RTLD_GLOBAL);
 445         }





 446 #endif
<span class="line-removed"> 447 </span>
 448         if (xrenderLibHandle != NULL) {

 449             xrenderFindVisualFormat =
 450                 (XRenderFindVisualFormatFunc*)dlsym(xrenderLibHandle,
 451                                                     &quot;XRenderFindVisualFormat&quot;);





 452         }


 453     }
 454 
 455     for (i = 0; i &lt; nTrue; i++) {
 456         if (XVisualIDFromVisual(pVITrue[i].visual) ==
 457             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual) ||
 458             pVITrue[i].depth == 12) {
 459             /* Skip the non-supported 12-bit TrueColor visual */
 460             continue;
 461         } else {
 462             ind = nConfig++;
 463         }
<span class="line-modified"> 464         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 465         graphicsConfigs [ind]-&gt;awt_depth = pVITrue [i].depth;</span>




 466         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVITrue [i],
 467                 sizeof (XVisualInfo));
<span class="line-modified"> 468        if (xrenderFindVisualFormat != NULL) {</span>
 469             XRenderPictFormat *format = xrenderFindVisualFormat (awt_display,
<span class="line-modified"> 470                     pVITrue [i].visual);</span>
 471             if (format &amp;&amp;
 472                 format-&gt;type == PictTypeDirect &amp;&amp;
 473                 format-&gt;direct.alphaMask)
 474             {

 475                 graphicsConfigs [ind]-&gt;isTranslucencySupported = 1;
 476                 memcpy(&amp;graphicsConfigs [ind]-&gt;renderPictFormat, format,
 477                         sizeof(*format));




 478             }
<span class="line-modified"> 479         }</span>
 480     }
 481 
 482     if (xrenderLibHandle != NULL) {
 483         dlclose(xrenderLibHandle);
 484         xrenderLibHandle = NULL;
 485     }
 486 
 487     for (i = 0; i &lt; n8p; i++) {
 488         if (XVisualIDFromVisual(pVI8p[i].visual) ==
 489             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 490             continue;
 491         } else {
 492             ind = nConfig++;
 493         }
<span class="line-modified"> 494         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 495         graphicsConfigs [ind]-&gt;awt_depth = pVI8p [i].depth;</span>




 496         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8p [i],
 497                 sizeof (XVisualInfo));
 498     }
 499 
 500     for (i = 0; i &lt; n12p; i++) {
 501         if (XVisualIDFromVisual(pVI12p[i].visual) ==
 502             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 503             continue;
 504         } else {
 505             ind = nConfig++;
 506         }
<span class="line-modified"> 507         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 508         graphicsConfigs [ind]-&gt;awt_depth = pVI12p [i].depth;</span>




 509         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI12p [i],
 510                 sizeof (XVisualInfo));
 511     }
 512 
 513     for (i = 0; i &lt; n8s; i++) {
 514         if (XVisualIDFromVisual(pVI8s[i].visual) ==
 515             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 516             continue;
 517         } else {
 518             ind = nConfig++;
 519         }
<span class="line-modified"> 520         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 521         graphicsConfigs [ind]-&gt;awt_depth = pVI8s [i].depth;</span>




 522         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8s [i],
 523                 sizeof (XVisualInfo));
 524     }
 525 
 526     for (i = 0; i &lt; n8gs; i++) {
 527         if (XVisualIDFromVisual(pVI8gs[i].visual) ==
 528             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 529             continue;
 530         } else {
 531             ind = nConfig++;
 532         }
<span class="line-modified"> 533         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 534         graphicsConfigs [ind]-&gt;awt_depth = pVI8gs [i].depth;</span>




 535         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8gs [i],
 536                 sizeof (XVisualInfo));
 537     }
 538 
 539     for (i = 0; i &lt; n8sg; i++) {
 540         if (XVisualIDFromVisual(pVI8sg[i].visual) ==
 541             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 542             continue;
 543         } else {
 544             ind = nConfig++;
 545         }
<span class="line-modified"> 546         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 547         graphicsConfigs [ind]-&gt;awt_depth = pVI8sg [i].depth;</span>




 548         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8sg [i],
 549                 sizeof (XVisualInfo));
 550     }
 551 
 552     for (i = 0; i &lt; n1sg; i++) {
 553         if (XVisualIDFromVisual(pVI1sg[i].visual) ==
 554             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 555             continue;
 556         } else {
 557             ind = nConfig++;
 558         }
<span class="line-modified"> 559         graphicsConfigs [ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 560         graphicsConfigs [ind]-&gt;awt_depth = pVI1sg [i].depth;</span>




 561         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI1sg [i],
 562                 sizeof (XVisualInfo));
 563     }
 564 




 565     if (n8p != 0)
 566        XFree (pVI8p);
 567     if (n12p != 0)
 568        XFree (pVI12p);
 569     if (n8s != 0)
 570        XFree (pVI8s);
 571     if (n8gs != 0)
 572        XFree (pVI8gs);
 573     if (n8sg != 0)
 574        XFree (pVI8sg);
 575     if (n1sg != 0)
 576        XFree (pVI1sg);
 577 
<span class="line-removed"> 578     screenDataPtr-&gt;numConfigs = nConfig;</span>
<span class="line-removed"> 579     screenDataPtr-&gt;configs = graphicsConfigs;</span>
<span class="line-removed"> 580 </span>
 581     AWT_UNLOCK ();
 582 }
 583 
 584 #ifndef HEADLESS
<span class="line-modified"> 585 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-modified"> 586 static void xinerama_init_linux()</span>
<span class="line-modified"> 587 {</span>





 588     void* libHandle = NULL;
 589     int32_t locNumScr = 0;
 590     XineramaScreenInfo *xinInfo;
 591     char* XineramaQueryScreensName = &quot;XineramaQueryScreens&quot;;
<span class="line-modified"> 592     XineramaQueryScreensFunc* XineramaQueryScreens = NULL;</span>









 593 
 594     /* load library */
 595     libHandle = dlopen(VERSIONED_JNI_LIB_NAME(&quot;Xinerama&quot;, &quot;1&quot;),
 596                        RTLD_LAZY | RTLD_GLOBAL);
 597     if (libHandle == NULL) {



 598         libHandle = dlopen(JNI_LIB_NAME(&quot;Xinerama&quot;), RTLD_LAZY | RTLD_GLOBAL);

 599     }
 600     if (libHandle != NULL) {
 601         XineramaQueryScreens = (XineramaQueryScreensFunc*)
 602             dlsym(libHandle, XineramaQueryScreensName);
 603 
<span class="line-modified"> 604         if (XineramaQueryScreens != NULL) {</span>
<span class="line-modified"> 605             DTRACE_PRINTLN(&quot;calling XineramaQueryScreens func on Linux&quot;);</span>



 606             xinInfo = (*XineramaQueryScreens)(awt_display, &amp;locNumScr);
<span class="line-modified"> 607             if (xinInfo != NULL &amp;&amp; locNumScr &gt; XScreenCount(awt_display)) {</span>
<span class="line-modified"> 608                 int32_t idx;</span>
<span class="line-modified"> 609                 DTRACE_PRINTLN(&quot;Enabling Xinerama support&quot;);</span>
<span class="line-modified"> 610                 usingXinerama = True;</span>
<span class="line-modified"> 611                 /* set global number of screens */</span>
<span class="line-modified"> 612                 DTRACE_PRINTLN1(&quot; num screens = %i\n&quot;, locNumScr);</span>
<span class="line-modified"> 613                 awt_numScreens = locNumScr;</span>
<span class="line-modified"> 614 </span>
<span class="line-modified"> 615                 /* stuff values into fbrects */</span>
<span class="line-removed"> 616                 for (idx = 0; idx &lt; awt_numScreens; idx++) {</span>
<span class="line-removed"> 617                     DASSERT(xinInfo[idx].screen_number == idx);</span>
<span class="line-removed"> 618 </span>
<span class="line-removed"> 619                     fbrects[idx].width = xinInfo[idx].width;</span>
<span class="line-removed"> 620                     fbrects[idx].height = xinInfo[idx].height;</span>
<span class="line-removed"> 621                     fbrects[idx].x = xinInfo[idx].x_org;</span>
<span class="line-removed"> 622                     fbrects[idx].y = xinInfo[idx].y_org;</span>
 623                 }

 624             } else {
 625                 DTRACE_PRINTLN(&quot;calling XineramaQueryScreens didn&#39;t work&quot;);
 626             }
<span class="line-removed"> 627         } else {</span>
<span class="line-removed"> 628             DTRACE_PRINTLN(&quot;couldn&#39;t load XineramaQueryScreens symbol&quot;);</span>
<span class="line-removed"> 629         }</span>
<span class="line-removed"> 630         dlclose(libHandle);</span>
<span class="line-removed"> 631     } else {</span>
<span class="line-removed"> 632         DTRACE_PRINTLN1(&quot;\ncouldn&#39;t open shared library: %s\n&quot;, dlerror());</span>
<span class="line-removed"> 633     }</span>
<span class="line-removed"> 634 }</span>
<span class="line-removed"> 635 #endif</span>
<span class="line-removed"> 636 #if !defined(__linux__) &amp;&amp; !defined(MACOSX) /* Solaris */</span>
<span class="line-removed"> 637 static void xinerama_init_solaris()</span>
<span class="line-removed"> 638 {</span>
<span class="line-removed"> 639     void* libHandle = NULL;</span>
<span class="line-removed"> 640     unsigned char fbhints[MAXFRAMEBUFFERS];</span>
<span class="line-removed"> 641     int32_t locNumScr = 0;</span>
<span class="line-removed"> 642     /* load and run XineramaGetInfo */</span>
<span class="line-removed"> 643     char* XineramaGetInfoName = &quot;XineramaGetInfo&quot;;</span>
<span class="line-removed"> 644     XineramaGetInfoFunc* XineramaSolarisFunc = NULL;</span>
<span class="line-removed"> 645 </span>
<span class="line-removed"> 646     /* load library */</span>
<span class="line-removed"> 647     libHandle = dlopen(JNI_LIB_NAME(&quot;Xext&quot;), RTLD_LAZY | RTLD_GLOBAL);</span>
<span class="line-removed"> 648     if (libHandle != NULL) {</span>
<span class="line-removed"> 649         XineramaSolarisFunc = (XineramaGetInfoFunc*)dlsym(libHandle, XineramaGetInfoName);</span>
<span class="line-removed"> 650         if (XineramaSolarisFunc != NULL) {</span>
<span class="line-removed"> 651             DTRACE_PRINTLN(&quot;calling XineramaGetInfo func on Solaris&quot;);</span>
<span class="line-removed"> 652             if ((*XineramaSolarisFunc)(awt_display, 0, &amp;fbrects[0],</span>
<span class="line-removed"> 653                                        &amp;fbhints[0], &amp;locNumScr) != 0 &amp;&amp;</span>
<span class="line-removed"> 654                 locNumScr &gt; XScreenCount(awt_display))</span>
<span class="line-removed"> 655             {</span>
<span class="line-removed"> 656                 DTRACE_PRINTLN(&quot;Enabling Xinerama support&quot;);</span>
<span class="line-removed"> 657                 usingXinerama = True;</span>
<span class="line-removed"> 658                 /* set global number of screens */</span>
<span class="line-removed"> 659                 DTRACE_PRINTLN1(&quot; num screens = %i\n&quot;, locNumScr);</span>
<span class="line-removed"> 660                 awt_numScreens = locNumScr;</span>
<span class="line-removed"> 661             } else {</span>
<span class="line-removed"> 662                 DTRACE_PRINTLN(&quot;calling XineramaGetInfo didn&#39;t work&quot;);</span>
<span class="line-removed"> 663             }</span>
<span class="line-removed"> 664         } else {</span>
<span class="line-removed"> 665             DTRACE_PRINTLN(&quot;couldn&#39;t load XineramaGetInfo symbol&quot;);</span>
 666         }
<span class="line-removed"> 667         dlclose(libHandle);</span>
 668     } else {
 669         DTRACE_PRINTLN1(&quot;\ncouldn&#39;t open shared library: %s\n&quot;, dlerror());
 670     }
 671 }
<span class="line-removed"> 672 #endif</span>
<span class="line-removed"> 673 </span>
<span class="line-removed"> 674 /*</span>
<span class="line-removed"> 675  * Checks if Xinerama is running and perform Xinerama-related</span>
<span class="line-removed"> 676  * platform dependent initialization.</span>
<span class="line-removed"> 677  */</span>
<span class="line-removed"> 678 static void xineramaInit(void) {</span>
<span class="line-removed"> 679     char* XinExtName = &quot;XINERAMA&quot;;</span>
<span class="line-removed"> 680     int32_t major_opcode, first_event, first_error;</span>
<span class="line-removed"> 681     Bool gotXinExt = False;</span>
<span class="line-removed"> 682 </span>
<span class="line-removed"> 683     gotXinExt = XQueryExtension(awt_display, XinExtName, &amp;major_opcode,</span>
<span class="line-removed"> 684                                 &amp;first_event, &amp;first_error);</span>
<span class="line-removed"> 685 </span>
<span class="line-removed"> 686     if (!gotXinExt) {</span>
<span class="line-removed"> 687         DTRACE_PRINTLN(&quot;Xinerama extension is not available&quot;);</span>
<span class="line-removed"> 688         return;</span>
<span class="line-removed"> 689     }</span>
<span class="line-removed"> 690 </span>
<span class="line-removed"> 691     DTRACE_PRINTLN(&quot;Xinerama extension is available&quot;);</span>
<span class="line-removed"> 692 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-removed"> 693     xinerama_init_linux();</span>
<span class="line-removed"> 694 #else /* Solaris */</span>
<span class="line-removed"> 695     xinerama_init_solaris();</span>
<span class="line-removed"> 696 #endif /* __linux__ || MACOSX */</span>
<span class="line-removed"> 697 }</span>
 698 #endif /* HEADLESS */
 699 
 700 Display *
 701 awt_init_Display(JNIEnv *env, jobject this)
 702 {
 703     jclass klass;
 704     Display *dpy;
 705     char errmsg[128];
 706     int i;
<span class="line-removed"> 707 #ifdef NETSCAPE</span>
<span class="line-removed"> 708     sigset_t alarm_set, oldset;</span>
<span class="line-removed"> 709 #endif</span>
 710 
 711     if (awt_display) {
 712         return awt_display;
 713     }
 714 
<span class="line-removed"> 715 #ifdef NETSCAPE</span>
<span class="line-removed"> 716     /* Disable interrupts during XtOpenDisplay to avoid bugs in unix os select</span>
<span class="line-removed"> 717        code: some unix systems don&#39;t implement SA_RESTART properly and</span>
<span class="line-removed"> 718        because of this, select returns with EINTR. Most implementations of</span>
<span class="line-removed"> 719        gethostbyname don&#39;t cope with EINTR properly and as a result we get</span>
<span class="line-removed"> 720        stuck (forever) in the gethostbyname code</span>
<span class="line-removed"> 721     */</span>
<span class="line-removed"> 722     sigemptyset(&amp;alarm_set);</span>
<span class="line-removed"> 723     sigaddset(&amp;alarm_set, SIGALRM);</span>
<span class="line-removed"> 724     sigprocmask(SIG_BLOCK, &amp;alarm_set, &amp;oldset);</span>
<span class="line-removed"> 725 #endif</span>
<span class="line-removed"> 726 </span>
 727     /* Load AWT lock-related methods in SunToolkit */
 728     klass = (*env)-&gt;FindClass(env, &quot;sun/awt/SunToolkit&quot;);
 729     if (klass == NULL) return NULL;
 730     GET_STATIC_METHOD(klass, awtLockMID, &quot;awtLock&quot;, &quot;()V&quot;);
 731     GET_STATIC_METHOD(klass, awtUnlockMID, &quot;awtUnlock&quot;, &quot;()V&quot;);
 732     GET_STATIC_METHOD(klass, awtWaitMID, &quot;awtLockWait&quot;, &quot;(J)V&quot;);
 733     GET_STATIC_METHOD(klass, awtNotifyMID, &quot;awtLockNotify&quot;, &quot;()V&quot;);
 734     GET_STATIC_METHOD(klass, awtNotifyAllMID, &quot;awtLockNotifyAll&quot;, &quot;()V&quot;);
 735     tkClass = (*env)-&gt;NewGlobalRef(env, klass);
 736     awtLockInited = JNI_TRUE;
 737 
 738     if (getenv(&quot;_AWT_IGNORE_XKB&quot;) != NULL &amp;&amp;
 739         strlen(getenv(&quot;_AWT_IGNORE_XKB&quot;)) &gt; 0) {
 740         if (XkbIgnoreExtension(True)) {
 741             printf(&quot;Ignoring XKB.\n&quot;);
 742         }
 743     }
 744 
 745     dpy = awt_display = XOpenDisplay(NULL);
<span class="line-removed"> 746 #ifdef NETSCAPE</span>
<span class="line-removed"> 747     sigprocmask(SIG_SETMASK, &amp;oldset, NULL);</span>
<span class="line-removed"> 748 #endif</span>
 749     if (!dpy) {
 750         jio_snprintf(errmsg,
 751                      sizeof(errmsg),
 752                      &quot;Can&#39;t connect to X11 window server using &#39;%s&#39; as the value of the DISPLAY variable.&quot;,
 753                      (getenv(&quot;DISPLAY&quot;) == NULL) ? &quot;:0.0&quot; : getenv(&quot;DISPLAY&quot;));
 754         JNU_ThrowByName(env, &quot;java/awt/AWTError&quot;, errmsg);
 755         return NULL;
 756     }
 757 
 758     XSetIOErrorHandler(xioerror_handler);
 759     JNU_CallStaticMethodByName(env, NULL, &quot;sun/awt/X11/XErrorHandlerUtil&quot;, &quot;init&quot;, &quot;(J)V&quot;,
 760         ptr_to_jlong(awt_display));
 761     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 762 
 763     /* set awt_numScreens, and whether or not we&#39;re using Xinerama */
 764     xineramaInit();
 765 
 766     if (!usingXinerama) {
 767         awt_numScreens =  XScreenCount(awt_display);
 768     }
</pre>
<hr />
<pre>
1353     return colorModel;
1354 #endif /* !HEADLESS */
1355 }
1356 
1357 
1358 /*
1359  * Class:     sun_awt_X11GraphicsConfig
1360  * Method:    getBounds
1361  * Signature: ()Ljava/awt/Rectangle
1362  */
1363 JNIEXPORT jobject JNICALL
1364 Java_sun_awt_X11GraphicsConfig_pGetBounds(JNIEnv *env, jobject this, jint screen)
1365 {
1366 #ifdef HEADLESS
1367     return NULL;
1368 #else
1369     jclass clazz;
1370     jmethodID mid;
1371     jobject bounds = NULL;
1372     AwtGraphicsConfigDataPtr adata;


1373 
1374     adata = (AwtGraphicsConfigDataPtr)
1375         JNU_GetLongFieldAsPtr(env, this, x11GraphicsConfigIDs.aData);
1376 
1377     clazz = (*env)-&gt;FindClass(env, &quot;java/awt/Rectangle&quot;);
1378     CHECK_NULL_RETURN(clazz, NULL);
1379     mid = (*env)-&gt;GetMethodID(env, clazz, &quot;&lt;init&gt;&quot;, &quot;(IIII)V&quot;);
1380     if (mid != NULL) {
1381         if (usingXinerama) {
1382             if (0 &lt;= screen &amp;&amp; screen &lt; awt_numScreens) {
<span class="line-modified">1383                 bounds = (*env)-&gt;NewObject(env, clazz, mid, fbrects[screen].x,</span>
<span class="line-modified">1384                                                             fbrects[screen].y,</span>
<span class="line-modified">1385                                                             fbrects[screen].width,</span>
<span class="line-modified">1386                                                             fbrects[screen].height);</span>











1387             } else {
1388                 jclass exceptionClass = (*env)-&gt;FindClass(env, &quot;java/lang/IllegalArgumentException&quot;);
1389                 if (exceptionClass != NULL) {
1390                     (*env)-&gt;ThrowNew(env, exceptionClass, &quot;Illegal screen index&quot;);
1391                 }
1392             }
<span class="line-modified">1393         } else {</span>


1394             XWindowAttributes xwa;
1395             memset(&amp;xwa, 0, sizeof(xwa));
1396 
1397             AWT_LOCK ();
1398             XGetWindowAttributes(awt_display,
1399                     RootWindow(awt_display, adata-&gt;awt_visInfo.screen),
1400                     &amp;xwa);
1401             AWT_UNLOCK ();
1402 
1403             bounds = (*env)-&gt;NewObject(env, clazz, mid, 0, 0,
1404                     xwa.width, xwa.height);
1405         }
1406 
1407         if ((*env)-&gt;ExceptionOccurred(env)) {
1408             return NULL;
1409         }
1410     }
1411     return bounds;
1412 #endif /* !HEADLESS */
1413 }
</pre>
</td>
<td>
<hr />
<pre>
  37 #ifndef NO_XRANDR
  38 #include &lt;X11/extensions/Xrandr.h&gt;
  39 #endif
  40 #include &quot;GLXGraphicsConfig.h&quot;
  41 #endif /* !HEADLESS */
  42 
  43 #include &lt;jni.h&gt;
  44 #include &lt;jni_util.h&gt;
  45 #include &lt;jvm.h&gt;
  46 #include &lt;jvm_md.h&gt;
  47 #include &lt;jlong.h&gt;
  48 #include &quot;systemScale.h&quot;
  49 #include &lt;stdlib.h&gt;
  50 
  51 #include &quot;awt_GraphicsEnv.h&quot;
  52 #include &quot;awt_util.h&quot;
  53 #include &quot;gdefs.h&quot;
  54 #include &lt;dlfcn.h&gt;
  55 #include &quot;Trace.h&quot;
  56 





  57 #ifndef HEADLESS
  58 
  59 int awt_numScreens;     /* Xinerama-aware number of screens */
  60 
  61 AwtScreenDataPtr x11Screens;
  62 
  63 /*
  64  * Set in initDisplay() to indicate whether we should attempt to initialize
  65  * GLX for the default configuration.
  66  */
  67 static jboolean glxRequested = JNI_FALSE;
  68 
  69 #endif /* !HEADLESS */
  70 
  71 #ifdef HEADLESS
  72 #define Display void
  73 #endif /* HEADLESS */
  74 
  75 Display *awt_display;
  76 
</pre>
<hr />
<pre>
  90         if (method_id == NULL) return NULL; \
  91     } while (0)
  92 
  93 struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
  94 
  95 #ifndef HEADLESS
  96 int awtCreateX11Colormap(AwtGraphicsConfigDataPtr adata);
  97 #endif /* HEADLESS */
  98 
  99 static char *x11GraphicsConfigClassName = &quot;sun/awt/X11GraphicsConfig&quot;;
 100 
 101 /* AWT and Xinerama
 102  *
 103  * As of fix 4356756, AWT is Xinerama-aware.  X11GraphicsDevices are created for
 104  * each screen of a Xinerama setup, though X11 itself still only sees a single
 105  * display.
 106  * In many places where we talk to X11, a xinawareScreen variable is used to
 107  * pass the correct Display value, depending on the circumstances (a single
 108  * X display, multiple X displays, or a single X display with multiple
 109  * Xinerama screens).







 110  */
 111 
 112 #define MAXFRAMEBUFFERS 16

 113 typedef struct {
 114    int   screen_number;
 115    short x_org;
 116    short y_org;
 117    short width;
 118    short height;
 119 } XineramaScreenInfo;
 120 
 121 typedef XineramaScreenInfo* XineramaQueryScreensFunc(Display*, int*);
<span class="line-modified"> 122 static XineramaQueryScreensFunc* XineramaQueryScreens = NULL;</span>






 123 Bool usingXinerama = False;

 124 
 125 JNIEXPORT void JNICALL
 126 Java_sun_awt_X11GraphicsConfig_initIDs (JNIEnv *env, jclass cls)
 127 {
 128     x11GraphicsConfigIDs.aData = NULL;
 129     x11GraphicsConfigIDs.bitsPerPixel = NULL;
 130 
 131     x11GraphicsConfigIDs.aData = (*env)-&gt;GetFieldID (env, cls, &quot;aData&quot;, &quot;J&quot;);
 132     CHECK_NULL(x11GraphicsConfigIDs.aData);
 133     x11GraphicsConfigIDs.bitsPerPixel = (*env)-&gt;GetFieldID (env, cls, &quot;bitsPerPixel&quot;, &quot;I&quot;);
 134     CHECK_NULL(x11GraphicsConfigIDs.bitsPerPixel);







 135 }
 136 
 137 #ifndef HEADLESS
 138 
 139 /*
 140  * XIOErrorHandler
 141  */
 142 static int xioerror_handler(Display *disp)
 143 {
 144     if (awtLockInited) {
 145         if (errno == EPIPE) {
 146             jio_fprintf(stderr, &quot;X connection to %s host broken (explicit kill or server shutdown)\n&quot;, XDisplayName(NULL));
 147         }
 148         /*SignalError(lockedee-&gt;lastpc, lockedee, &quot;fp/ade/gui/GUIException&quot;, &quot;I/O error&quot;); */
 149     }
 150     return 0;
 151 }
 152 
 153 static AwtGraphicsConfigDataPtr
 154 findWithTemplate(XVisualInfo *vinfo,
 155                  long mask)
 156 {
 157 
 158     XVisualInfo *visualList;
 159     XColor color;
 160     AwtGraphicsConfigDataPtr defaultConfig;
 161     int visualsMatched, i;
 162 
 163     visualList = XGetVisualInfo(awt_display,
 164                                 mask, vinfo, &amp;visualsMatched);
 165     if (visualList) {
 166         int id = -1;
 167         VisualID defaultVisual = XVisualIDFromVisual(DefaultVisual(awt_display, vinfo-&gt;screen));
 168         defaultConfig = ZALLOC(_AwtGraphicsConfigData);
<span class="line-added"> 169         if (defaultConfig == NULL) {</span>
<span class="line-added"> 170             XFree(visualList);</span>
<span class="line-added"> 171             return NULL;</span>
<span class="line-added"> 172         }</span>
 173         for (i = 0; i &lt; visualsMatched; i++) {
 174             memcpy(&amp;defaultConfig-&gt;awt_visInfo, &amp;visualList[i], sizeof(XVisualInfo));
 175             defaultConfig-&gt;awt_depth = visualList[i].depth;
 176 
 177             /* we can&#39;t use awtJNI_CreateColorData here, because it&#39;ll pull,
 178                SystemColor, which in turn will cause toolkit to be reinitialized */
 179             if (awtCreateX11Colormap(defaultConfig)) {
 180                 if (visualList[i].visualid == defaultVisual) {
 181                     id = i;
 182                     break;
 183                 } else if (-1 == id) {
 184                     // Keep 1st match for fallback
 185                     id = i;
 186                 }
 187             }
 188         }
 189         if (-1 != id) {
 190             memcpy(&amp;defaultConfig-&gt;awt_visInfo, &amp;visualList[id], sizeof(XVisualInfo));
 191             defaultConfig-&gt;awt_depth = visualList[id].depth;
 192             /* Allocate white and black pixels for this visual */
</pre>
<hr />
<pre>
 385         AWT_UNLOCK();
 386         return;
 387     }
 388 
 389     if (screenDataPtr-&gt;defaultConfig == NULL) {
 390         /*
 391          * After a display change event, the default config field will have
 392          * been reset, so we need to recreate the default config here.
 393          */
 394         screenDataPtr-&gt;defaultConfig = makeDefaultConfig(env, screen);
 395     }
 396 
 397     defaultConfig = screenDataPtr-&gt;defaultConfig;
 398     graphicsConfigs[0] = defaultConfig;
 399     nConfig = 1; /* reserve index 0 for default config */
 400 
 401     // Only use the RENDER extension if it is available on the X server
 402     if (XQueryExtension(awt_display, &quot;RENDER&quot;,
 403                         &amp;major_opcode, &amp;first_event, &amp;first_error))
 404     {
<span class="line-added"> 405         DTRACE_PRINTLN(&quot;RENDER extension available&quot;);</span>
 406         xrenderLibHandle = dlopen(&quot;libXrender.so.1&quot;, RTLD_LAZY | RTLD_GLOBAL);
 407 
 408 #ifdef MACOSX
 409 #define XRENDER_LIB &quot;/usr/X11/lib/libXrender.dylib&quot;
 410 #else
 411 #define XRENDER_LIB &quot;libXrender.so&quot;
 412 #endif
 413 
 414         if (xrenderLibHandle == NULL) {
 415             xrenderLibHandle = dlopen(XRENDER_LIB,
 416                                       RTLD_LAZY | RTLD_GLOBAL);
 417         }
 418 
<span class="line-modified"> 419 #if defined(__solaris__)</span>
 420         if (xrenderLibHandle == NULL) {
 421             xrenderLibHandle = dlopen(&quot;/usr/lib/libXrender.so.1&quot;,
 422                                       RTLD_LAZY | RTLD_GLOBAL);
 423         }
<span class="line-added"> 424 #elif defined(_AIX)</span>
<span class="line-added"> 425         if (xrenderLibHandle == NULL) {</span>
<span class="line-added"> 426             xrenderLibHandle = dlopen(&quot;libXrender.a(libXrender.so.0)&quot;,</span>
<span class="line-added"> 427                                       RTLD_MEMBER | RTLD_LAZY | RTLD_GLOBAL);</span>
<span class="line-added"> 428         }</span>
 429 #endif

 430         if (xrenderLibHandle != NULL) {
<span class="line-added"> 431             DTRACE_PRINTLN(&quot;Loaded libXrender&quot;);</span>
 432             xrenderFindVisualFormat =
 433                 (XRenderFindVisualFormatFunc*)dlsym(xrenderLibHandle,
 434                                                     &quot;XRenderFindVisualFormat&quot;);
<span class="line-added"> 435             if (xrenderFindVisualFormat == NULL) {</span>
<span class="line-added"> 436                 DTRACE_PRINTLN1(&quot;Can&#39;t find &#39;XRenderFindVisualFormat&#39; in libXrender (%s)&quot;, dlerror());</span>
<span class="line-added"> 437             }</span>
<span class="line-added"> 438         } else {</span>
<span class="line-added"> 439             DTRACE_PRINTLN1(&quot;Can&#39;t load libXrender (%s)&quot;, dlerror());</span>
 440         }
<span class="line-added"> 441     } else {</span>
<span class="line-added"> 442         DTRACE_PRINTLN(&quot;RENDER extension NOT available&quot;);</span>
 443     }
 444 
 445     for (i = 0; i &lt; nTrue; i++) {
 446         if (XVisualIDFromVisual(pVITrue[i].visual) ==
 447             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual) ||
 448             pVITrue[i].depth == 12) {
 449             /* Skip the non-supported 12-bit TrueColor visual */
 450             continue;
 451         } else {
 452             ind = nConfig++;
 453         }
<span class="line-modified"> 454         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 455         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 456             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 457             goto cleanup;</span>
<span class="line-added"> 458         }</span>
<span class="line-added"> 459         graphicsConfigs[ind]-&gt;awt_depth = pVITrue [i].depth;</span>
 460         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVITrue [i],
 461                 sizeof (XVisualInfo));
<span class="line-modified"> 462         if (xrenderFindVisualFormat != NULL) {</span>
 463             XRenderPictFormat *format = xrenderFindVisualFormat (awt_display,
<span class="line-modified"> 464                                                                  pVITrue [i].visual);</span>
 465             if (format &amp;&amp;
 466                 format-&gt;type == PictTypeDirect &amp;&amp;
 467                 format-&gt;direct.alphaMask)
 468             {
<span class="line-added"> 469                 DTRACE_PRINTLN1(&quot;GraphicsConfig[%d] supports Translucency&quot;, ind);</span>
 470                 graphicsConfigs [ind]-&gt;isTranslucencySupported = 1;
 471                 memcpy(&amp;graphicsConfigs [ind]-&gt;renderPictFormat, format,
 472                         sizeof(*format));
<span class="line-added"> 473             } else {</span>
<span class="line-added"> 474                 DTRACE_PRINTLN1(format ?</span>
<span class="line-added"> 475                                 &quot;GraphicsConfig[%d] has no Translucency support&quot; :</span>
<span class="line-added"> 476                                 &quot;Error calling &#39;XRenderFindVisualFormat&#39;&quot;, ind);</span>
 477             }
<span class="line-modified"> 478        }</span>
 479     }
 480 
 481     if (xrenderLibHandle != NULL) {
 482         dlclose(xrenderLibHandle);
 483         xrenderLibHandle = NULL;
 484     }
 485 
 486     for (i = 0; i &lt; n8p; i++) {
 487         if (XVisualIDFromVisual(pVI8p[i].visual) ==
 488             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 489             continue;
 490         } else {
 491             ind = nConfig++;
 492         }
<span class="line-modified"> 493         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 494         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 495             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 496             goto cleanup;</span>
<span class="line-added"> 497         }</span>
<span class="line-added"> 498         graphicsConfigs[ind]-&gt;awt_depth = pVI8p [i].depth;</span>
 499         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8p [i],
 500                 sizeof (XVisualInfo));
 501     }
 502 
 503     for (i = 0; i &lt; n12p; i++) {
 504         if (XVisualIDFromVisual(pVI12p[i].visual) ==
 505             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 506             continue;
 507         } else {
 508             ind = nConfig++;
 509         }
<span class="line-modified"> 510         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 511         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 512             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 513             goto cleanup;</span>
<span class="line-added"> 514         }</span>
<span class="line-added"> 515         graphicsConfigs[ind]-&gt;awt_depth = pVI12p [i].depth;</span>
 516         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI12p [i],
 517                 sizeof (XVisualInfo));
 518     }
 519 
 520     for (i = 0; i &lt; n8s; i++) {
 521         if (XVisualIDFromVisual(pVI8s[i].visual) ==
 522             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 523             continue;
 524         } else {
 525             ind = nConfig++;
 526         }
<span class="line-modified"> 527         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 528         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 529             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 530             goto cleanup;</span>
<span class="line-added"> 531         }</span>
<span class="line-added"> 532         graphicsConfigs[ind]-&gt;awt_depth = pVI8s [i].depth;</span>
 533         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8s [i],
 534                 sizeof (XVisualInfo));
 535     }
 536 
 537     for (i = 0; i &lt; n8gs; i++) {
 538         if (XVisualIDFromVisual(pVI8gs[i].visual) ==
 539             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 540             continue;
 541         } else {
 542             ind = nConfig++;
 543         }
<span class="line-modified"> 544         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 545         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 546             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 547             goto cleanup;</span>
<span class="line-added"> 548         }</span>
<span class="line-added"> 549         graphicsConfigs[ind]-&gt;awt_depth = pVI8gs [i].depth;</span>
 550         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8gs [i],
 551                 sizeof (XVisualInfo));
 552     }
 553 
 554     for (i = 0; i &lt; n8sg; i++) {
 555         if (XVisualIDFromVisual(pVI8sg[i].visual) ==
 556             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 557             continue;
 558         } else {
 559             ind = nConfig++;
 560         }
<span class="line-modified"> 561         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 562         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 563             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 564             goto cleanup;</span>
<span class="line-added"> 565         }</span>
<span class="line-added"> 566         graphicsConfigs[ind]-&gt;awt_depth = pVI8sg [i].depth;</span>
 567         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI8sg [i],
 568                 sizeof (XVisualInfo));
 569     }
 570 
 571     for (i = 0; i &lt; n1sg; i++) {
 572         if (XVisualIDFromVisual(pVI1sg[i].visual) ==
 573             XVisualIDFromVisual(defaultConfig-&gt;awt_visInfo.visual)) {
 574             continue;
 575         } else {
 576             ind = nConfig++;
 577         }
<span class="line-modified"> 578         graphicsConfigs[ind] = ZALLOC (_AwtGraphicsConfigData);</span>
<span class="line-modified"> 579         if (graphicsConfigs[ind] == NULL) {</span>
<span class="line-added"> 580             JNU_ThrowOutOfMemoryError(env, &quot;allocation in getAllConfigs failed&quot;);</span>
<span class="line-added"> 581             goto cleanup;</span>
<span class="line-added"> 582         }</span>
<span class="line-added"> 583         graphicsConfigs[ind]-&gt;awt_depth = pVI1sg [i].depth;</span>
 584         memcpy (&amp;graphicsConfigs [ind]-&gt;awt_visInfo, &amp;pVI1sg [i],
 585                 sizeof (XVisualInfo));
 586     }
 587 
<span class="line-added"> 588     screenDataPtr-&gt;numConfigs = nConfig;</span>
<span class="line-added"> 589     screenDataPtr-&gt;configs = graphicsConfigs;</span>
<span class="line-added"> 590 </span>
<span class="line-added"> 591 cleanup:</span>
 592     if (n8p != 0)
 593        XFree (pVI8p);
 594     if (n12p != 0)
 595        XFree (pVI12p);
 596     if (n8s != 0)
 597        XFree (pVI8s);
 598     if (n8gs != 0)
 599        XFree (pVI8gs);
 600     if (n8sg != 0)
 601        XFree (pVI8sg);
 602     if (n1sg != 0)
 603        XFree (pVI1sg);
 604 



 605     AWT_UNLOCK ();
 606 }
 607 
 608 #ifndef HEADLESS
<span class="line-modified"> 609 </span>
<span class="line-modified"> 610 /*</span>
<span class="line-modified"> 611  * Checks if Xinerama is running and perform Xinerama-related initialization.</span>
<span class="line-added"> 612  */</span>
<span class="line-added"> 613 static void xineramaInit(void) {</span>
<span class="line-added"> 614     char* XinExtName = &quot;XINERAMA&quot;;</span>
<span class="line-added"> 615     int32_t major_opcode, first_event, first_error;</span>
<span class="line-added"> 616     Bool gotXinExt = False;</span>
 617     void* libHandle = NULL;
 618     int32_t locNumScr = 0;
 619     XineramaScreenInfo *xinInfo;
 620     char* XineramaQueryScreensName = &quot;XineramaQueryScreens&quot;;
<span class="line-modified"> 621 </span>
<span class="line-added"> 622     gotXinExt = XQueryExtension(awt_display, XinExtName, &amp;major_opcode,</span>
<span class="line-added"> 623                                 &amp;first_event, &amp;first_error);</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     if (!gotXinExt) {</span>
<span class="line-added"> 626         DTRACE_PRINTLN(&quot;Xinerama extension is not available&quot;);</span>
<span class="line-added"> 627         return;</span>
<span class="line-added"> 628     }</span>
<span class="line-added"> 629 </span>
<span class="line-added"> 630     DTRACE_PRINTLN(&quot;Xinerama extension is available&quot;);</span>
 631 
 632     /* load library */
 633     libHandle = dlopen(VERSIONED_JNI_LIB_NAME(&quot;Xinerama&quot;, &quot;1&quot;),
 634                        RTLD_LAZY | RTLD_GLOBAL);
 635     if (libHandle == NULL) {
<span class="line-added"> 636 #if defined(_AIX)</span>
<span class="line-added"> 637         libHandle = dlopen(&quot;libXext.a(shr_64.o)&quot;, RTLD_MEMBER | RTLD_LAZY | RTLD_GLOBAL);</span>
<span class="line-added"> 638 #else</span>
 639         libHandle = dlopen(JNI_LIB_NAME(&quot;Xinerama&quot;), RTLD_LAZY | RTLD_GLOBAL);
<span class="line-added"> 640 #endif</span>
 641     }
 642     if (libHandle != NULL) {
 643         XineramaQueryScreens = (XineramaQueryScreensFunc*)
 644             dlsym(libHandle, XineramaQueryScreensName);
 645 
<span class="line-modified"> 646         if (XineramaQueryScreens == NULL) {</span>
<span class="line-modified"> 647             DTRACE_PRINTLN(&quot;couldn&#39;t load XineramaQueryScreens symbol&quot;);</span>
<span class="line-added"> 648             dlclose(libHandle);</span>
<span class="line-added"> 649         } else {</span>
<span class="line-added"> 650             DTRACE_PRINTLN(&quot;calling XineramaQueryScreens func&quot;);</span>
 651             xinInfo = (*XineramaQueryScreens)(awt_display, &amp;locNumScr);
<span class="line-modified"> 652             if (xinInfo != NULL) {</span>
<span class="line-modified"> 653                 if (locNumScr &gt; XScreenCount(awt_display)) {</span>
<span class="line-modified"> 654                     DTRACE_PRINTLN(&quot;Enabling Xinerama support&quot;);</span>
<span class="line-modified"> 655                     usingXinerama = True;</span>
<span class="line-modified"> 656                     /* set global number of screens */</span>
<span class="line-modified"> 657                     DTRACE_PRINTLN1(&quot; num screens = %i\n&quot;, locNumScr);</span>
<span class="line-modified"> 658                     awt_numScreens = locNumScr;</span>
<span class="line-modified"> 659                 } else {</span>
<span class="line-modified"> 660                     DTRACE_PRINTLN(&quot;XineramaQueryScreens &lt;= XScreenCount&quot;);</span>







 661                 }
<span class="line-added"> 662                 XFree(xinInfo);</span>
 663             } else {
 664                 DTRACE_PRINTLN(&quot;calling XineramaQueryScreens didn&#39;t work&quot;);
 665             }







































 666         }

 667     } else {
 668         DTRACE_PRINTLN1(&quot;\ncouldn&#39;t open shared library: %s\n&quot;, dlerror());
 669     }
 670 }


























 671 #endif /* HEADLESS */
 672 
 673 Display *
 674 awt_init_Display(JNIEnv *env, jobject this)
 675 {
 676     jclass klass;
 677     Display *dpy;
 678     char errmsg[128];
 679     int i;



 680 
 681     if (awt_display) {
 682         return awt_display;
 683     }
 684 












 685     /* Load AWT lock-related methods in SunToolkit */
 686     klass = (*env)-&gt;FindClass(env, &quot;sun/awt/SunToolkit&quot;);
 687     if (klass == NULL) return NULL;
 688     GET_STATIC_METHOD(klass, awtLockMID, &quot;awtLock&quot;, &quot;()V&quot;);
 689     GET_STATIC_METHOD(klass, awtUnlockMID, &quot;awtUnlock&quot;, &quot;()V&quot;);
 690     GET_STATIC_METHOD(klass, awtWaitMID, &quot;awtLockWait&quot;, &quot;(J)V&quot;);
 691     GET_STATIC_METHOD(klass, awtNotifyMID, &quot;awtLockNotify&quot;, &quot;()V&quot;);
 692     GET_STATIC_METHOD(klass, awtNotifyAllMID, &quot;awtLockNotifyAll&quot;, &quot;()V&quot;);
 693     tkClass = (*env)-&gt;NewGlobalRef(env, klass);
 694     awtLockInited = JNI_TRUE;
 695 
 696     if (getenv(&quot;_AWT_IGNORE_XKB&quot;) != NULL &amp;&amp;
 697         strlen(getenv(&quot;_AWT_IGNORE_XKB&quot;)) &gt; 0) {
 698         if (XkbIgnoreExtension(True)) {
 699             printf(&quot;Ignoring XKB.\n&quot;);
 700         }
 701     }
 702 
 703     dpy = awt_display = XOpenDisplay(NULL);



 704     if (!dpy) {
 705         jio_snprintf(errmsg,
 706                      sizeof(errmsg),
 707                      &quot;Can&#39;t connect to X11 window server using &#39;%s&#39; as the value of the DISPLAY variable.&quot;,
 708                      (getenv(&quot;DISPLAY&quot;) == NULL) ? &quot;:0.0&quot; : getenv(&quot;DISPLAY&quot;));
 709         JNU_ThrowByName(env, &quot;java/awt/AWTError&quot;, errmsg);
 710         return NULL;
 711     }
 712 
 713     XSetIOErrorHandler(xioerror_handler);
 714     JNU_CallStaticMethodByName(env, NULL, &quot;sun/awt/X11/XErrorHandlerUtil&quot;, &quot;init&quot;, &quot;(J)V&quot;,
 715         ptr_to_jlong(awt_display));
 716     JNU_CHECK_EXCEPTION_RETURN(env, NULL);
 717 
 718     /* set awt_numScreens, and whether or not we&#39;re using Xinerama */
 719     xineramaInit();
 720 
 721     if (!usingXinerama) {
 722         awt_numScreens =  XScreenCount(awt_display);
 723     }
</pre>
<hr />
<pre>
1308     return colorModel;
1309 #endif /* !HEADLESS */
1310 }
1311 
1312 
1313 /*
1314  * Class:     sun_awt_X11GraphicsConfig
1315  * Method:    getBounds
1316  * Signature: ()Ljava/awt/Rectangle
1317  */
1318 JNIEXPORT jobject JNICALL
1319 Java_sun_awt_X11GraphicsConfig_pGetBounds(JNIEnv *env, jobject this, jint screen)
1320 {
1321 #ifdef HEADLESS
1322     return NULL;
1323 #else
1324     jclass clazz;
1325     jmethodID mid;
1326     jobject bounds = NULL;
1327     AwtGraphicsConfigDataPtr adata;
<span class="line-added">1328     int32_t locNumScr = 0;</span>
<span class="line-added">1329     XineramaScreenInfo *xinInfo;</span>
1330 
1331     adata = (AwtGraphicsConfigDataPtr)
1332         JNU_GetLongFieldAsPtr(env, this, x11GraphicsConfigIDs.aData);
1333 
1334     clazz = (*env)-&gt;FindClass(env, &quot;java/awt/Rectangle&quot;);
1335     CHECK_NULL_RETURN(clazz, NULL);
1336     mid = (*env)-&gt;GetMethodID(env, clazz, &quot;&lt;init&gt;&quot;, &quot;(IIII)V&quot;);
1337     if (mid != NULL) {
1338         if (usingXinerama) {
1339             if (0 &lt;= screen &amp;&amp; screen &lt; awt_numScreens) {
<span class="line-modified">1340                 AWT_LOCK();</span>
<span class="line-modified">1341                 xinInfo = (*XineramaQueryScreens)(awt_display, &amp;locNumScr);</span>
<span class="line-modified">1342                 AWT_UNLOCK();</span>
<span class="line-modified">1343                 if (xinInfo != NULL &amp;&amp; locNumScr &gt; 0) {</span>
<span class="line-added">1344                     if (screen &gt;= locNumScr) {</span>
<span class="line-added">1345                         screen = 0; // fallback to the main screen</span>
<span class="line-added">1346                     }</span>
<span class="line-added">1347                     DASSERT(xinInfo[screen].screen_number == screen);</span>
<span class="line-added">1348                     bounds = (*env)-&gt;NewObject(env, clazz, mid,</span>
<span class="line-added">1349                                                xinInfo[screen].x_org,</span>
<span class="line-added">1350                                                xinInfo[screen].y_org,</span>
<span class="line-added">1351                                                xinInfo[screen].width,</span>
<span class="line-added">1352                                                xinInfo[screen].height);</span>
<span class="line-added">1353                     XFree(xinInfo);</span>
<span class="line-added">1354                 }</span>
1355             } else {
1356                 jclass exceptionClass = (*env)-&gt;FindClass(env, &quot;java/lang/IllegalArgumentException&quot;);
1357                 if (exceptionClass != NULL) {
1358                     (*env)-&gt;ThrowNew(env, exceptionClass, &quot;Illegal screen index&quot;);
1359                 }
1360             }
<span class="line-modified">1361         }</span>
<span class="line-added">1362         if (!bounds) {</span>
<span class="line-added">1363             // Xinerama cannot provide correct bounds, will try X11</span>
1364             XWindowAttributes xwa;
1365             memset(&amp;xwa, 0, sizeof(xwa));
1366 
1367             AWT_LOCK ();
1368             XGetWindowAttributes(awt_display,
1369                     RootWindow(awt_display, adata-&gt;awt_visInfo.screen),
1370                     &amp;xwa);
1371             AWT_UNLOCK ();
1372 
1373             bounds = (*env)-&gt;NewObject(env, clazz, mid, 0, 0,
1374                     xwa.width, xwa.height);
1375         }
1376 
1377         if ((*env)-&gt;ExceptionOccurred(env)) {
1378             return NULL;
1379         }
1380     }
1381     return bounds;
1382 #endif /* !HEADLESS */
1383 }
</pre>
</td>
</tr>
</table>
<center><a href="awt_Event.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_InputMethod.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.desktop/unix/native/libawt_xawt/awt/awt_Robot.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (c) 1999, 2017, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 #ifdef HEADLESS
 27     #error This file should not be included in headless library
 28 #endif
 29 
 30 #include &quot;jvm_md.h&quot;
 31 #include &lt;dlfcn.h&gt;
 32 
 33 #include &quot;awt_p.h&quot;
 34 #include &quot;awt_GraphicsEnv.h&quot;
 35 #define XK_MISCELLANY
 36 #include &lt;X11/keysymdef.h&gt;
 37 #include &lt;X11/Xutil.h&gt;
 38 #include &lt;X11/Xmd.h&gt;
 39 #include &lt;X11/extensions/xtestext1.h&gt;
 40 #include &lt;X11/extensions/XTest.h&gt;
 41 #include &lt;X11/extensions/XInput.h&gt;
 42 #include &lt;X11/extensions/XI.h&gt;
 43 #include &lt;jni.h&gt;
 44 #include &lt;sizecalc.h&gt;
 45 #include &quot;canvas.h&quot;
 46 #include &quot;wsutils.h&quot;
 47 #include &quot;list.h&quot;
 48 #include &quot;multiVis.h&quot;
 49 #include &quot;gtk_interface.h&quot;
 50 
 51 #include &quot;java_awt_event_InputEvent.h&quot;
 52 
 53 #if defined(__linux__) || defined(MACOSX)
 54 #include &lt;sys/socket.h&gt;
 55 #endif
 56 
 57 static Bool   (*compositeQueryExtension)   (Display*, int*, int*);
 58 static Status (*compositeQueryVersion)     (Display*, int*, int*);
 59 static Window (*compositeGetOverlayWindow) (Display *, Window);
 60 
 61 extern struct X11GraphicsConfigIDs x11GraphicsConfigIDs;
 62 
 63 static jint * masks;
 64 static jint num_buttons;
 65 
 66 static void *xCompositeHandle;
 67 
 68 static const char* XCOMPOSITE = JNI_LIB_NAME(&quot;Xcomposite&quot;);
 69 static const char* XCOMPOSITE_VERSIONED = VERSIONED_JNI_LIB_NAME(&quot;Xcomposite&quot;, &quot;1&quot;);
 70 
 71 static Bool checkXCompositeFunctions(void) {
 72     return (compositeQueryExtension   != NULL   &amp;&amp;
 73             compositeQueryVersion     != NULL   &amp;&amp;
 74             compositeGetOverlayWindow != NULL);
 75 }
 76 
 77 static void initXCompositeFunctions(void) {
 78 
 79     if (xCompositeHandle == NULL) {
 80         xCompositeHandle = dlopen(XCOMPOSITE, RTLD_LAZY | RTLD_GLOBAL);
 81         if (xCompositeHandle == NULL) {
 82             xCompositeHandle = dlopen(XCOMPOSITE_VERSIONED, RTLD_LAZY | RTLD_GLOBAL);
 83         }
 84     }
 85     //*(void **)(&amp;asyncGetCallTraceFunction)
 86     if (xCompositeHandle != NULL) {
 87         *(void **)(&amp;compositeQueryExtension) = dlsym(xCompositeHandle, &quot;XCompositeQueryExtension&quot;);
 88         *(void **)(&amp;compositeQueryVersion) = dlsym(xCompositeHandle, &quot;XCompositeQueryVersion&quot;);
 89         *(void **)(&amp;compositeGetOverlayWindow) = dlsym(xCompositeHandle, &quot;XCompositeGetOverlayWindow&quot;);
 90     }
 91 
 92     if (xCompositeHandle &amp;&amp; !checkXCompositeFunctions()) {
 93         dlclose(xCompositeHandle);
 94     }
 95 }
 96 
 97 static int32_t isXTestAvailable() {
 98     int32_t major_opcode, first_event, first_error;
 99     int32_t  event_basep, error_basep, majorp, minorp;
100     int32_t isXTestAvailable;
101 
102     /* check if XTest is available */
103     isXTestAvailable = XQueryExtension(awt_display, XTestExtensionName, &amp;major_opcode, &amp;first_event, &amp;first_error);
104     if (isXTestAvailable) {
105         DTRACE_PRINTLN3(&quot;RobotPeer: XQueryExtension(XTEST) returns major_opcode = %d, first_event = %d, first_error = %d&quot;,
106                         major_opcode, first_event, first_error);
107         /* check if XTest version is OK */
108         XTestQueryExtension(awt_display, &amp;event_basep, &amp;error_basep, &amp;majorp, &amp;minorp);
109         DTRACE_PRINTLN4(&quot;RobotPeer: XTestQueryExtension returns event_basep = %d, error_basep = %d, majorp = %d, minorp = %d&quot;,
110                         event_basep, error_basep, majorp, minorp);
111         if (majorp &lt; 2 || (majorp == 2 &amp;&amp; minorp &lt; 2)) {
112             /* bad version*/
113             DTRACE_PRINTLN2(&quot;XRobotPeer: XTEST version is %d.%d \n&quot;, majorp, minorp);
114             if (majorp == 2 &amp;&amp; minorp == 1) {
115                 DTRACE_PRINTLN(&quot;XRobotPeer: XTEST is 2.1 - no grab is available\n&quot;);
116             } else {
117                 isXTestAvailable = False;
118             }
119         } else {
120             /* allow XTest calls even if someone else has the grab; e.g. during
121              * a window resize operation. Works only with XTEST2.2*/
122             XTestGrabControl(awt_display, True);
123         }
124     } else {
125         DTRACE_PRINTLN(&quot;RobotPeer: XTEST extension is unavailable&quot;);
126     }
127 
128     return isXTestAvailable;
129 }
130 
131 static Bool hasXCompositeOverlayExtension(Display *display) {
132 
133     int xoverlay = False;
134     int eventBase, errorBase;
135     if (checkXCompositeFunctions() &amp;&amp;
136         compositeQueryExtension(display, &amp;eventBase, &amp;errorBase))
137     {
138         int major = 0;
139         int minor = 0;
140 
141         compositeQueryVersion(display, &amp;major, &amp;minor);
142         if (major &gt; 0 || minor &gt;= 3) {
143             xoverlay = True;
144         }
145     }
146 
147     return xoverlay;
148 }
149 
150 static jboolean isXCompositeDisplay(Display *display, int screenNumber) {
151 
152     char NET_WM_CM_Sn[25];
<a name="2" id="anc2"></a><span class="line-modified">153     snprintf(NET_WM_CM_Sn, sizeof(NET_WM_CM_Sn), &quot;_NET_WM_CM_S%d\0&quot;, screenNumber);</span>
154 
155     Atom managerSelection = XInternAtom(display, NET_WM_CM_Sn, 0);
156     Window owner = XGetSelectionOwner(display, managerSelection);
157 
158     return owner != 0;
159 }
160 
161 static XImage *getWindowImage(Display * display, Window window,
162                               int32_t x, int32_t y,
163                               int32_t w, int32_t h) {
164     XImage         *image;
165     int32_t        transparentOverlays;
166     int32_t        numVisuals;
167     XVisualInfo    *pVisuals;
168     int32_t        numOverlayVisuals;
169     OverlayInfo    *pOverlayVisuals;
170     int32_t        numImageVisuals;
171     XVisualInfo    **pImageVisuals;
172     list_ptr       vis_regions;    /* list of regions to read from */
173     list_ptr       vis_image_regions ;
174     int32_t        allImage = 0 ;
175     int32_t        format = ZPixmap;
176 
177     /* prevent user from moving stuff around during the capture */
178     XGrabServer(display);
179 
180     /*
181      * The following two functions live in multiVis.c-- they are pretty
182      * much verbatim taken from the source to the xwd utility from the
183      * X11 source. This version of the xwd source was somewhat better written
184      * for reuse compared to Sun&#39;s version.
185      *
186      *        ftp.x.org/pub/R6.3/xc/programs/xwd
187      *
188      * We use these functions since they do the very tough job of capturing
189      * the screen correctly when it contains multiple visuals. They take into
190      * account the depth/colormap of each visual and produce a capture as a
191      * 24-bit RGB image so we don&#39;t have to fool around with colormaps etc.
192      */
193 
194     GetMultiVisualRegions(
195         display,
196         window,
197         x, y, w, h,
198         &amp;transparentOverlays,
199         &amp;numVisuals,
200         &amp;pVisuals,
201         &amp;numOverlayVisuals,
202         &amp;pOverlayVisuals,
203         &amp;numImageVisuals,
204         &amp;pImageVisuals,
205         &amp;vis_regions,
206         &amp;vis_image_regions,
207         &amp;allImage );
208 
209     image = ReadAreaToImage(
210         display,
211         window,
212         x, y, w, h,
213         numVisuals,
214         pVisuals,
215         numOverlayVisuals,
216         pOverlayVisuals,
217         numImageVisuals,
218         pImageVisuals,
219         vis_regions,
220         vis_image_regions,
221         format,
222         allImage );
223 
224     /* allow user to do stuff again */
225     XUngrabServer(display);
226 
227     /* make sure the grab/ungrab is flushed */
228     XSync(display, False);
229 
230     return image;
231 }
232 
233 /*********************************************************************************************/
234 
235 // this should be called from XRobotPeer constructor
236 JNIEXPORT void JNICALL
237 Java_sun_awt_X11_XRobotPeer_setup (JNIEnv * env, jclass cls, jint numberOfButtons, jintArray buttonDownMasks)
238 {
239     int32_t xtestAvailable;
240     jint *tmp;
241     int i;
242 
243     DTRACE_PRINTLN(&quot;RobotPeer: setup()&quot;);
244 
245     num_buttons = numberOfButtons;
246     tmp = (*env)-&gt;GetIntArrayElements(env, buttonDownMasks, JNI_FALSE);
247     CHECK_NULL(tmp);
248 
249     masks = (jint *)SAFE_SIZE_ARRAY_ALLOC(malloc, sizeof(jint), num_buttons);
250     if (masks == (jint *) NULL) {
251         (*env)-&gt;ExceptionClear(env);
252         (*env)-&gt;ReleaseIntArrayElements(env, buttonDownMasks, tmp, 0);
253         JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), NULL);
254         return;
255     }
256     for (i = 0; i &lt; num_buttons; i++) {
257         masks[i] = tmp[i];
258     }
259     (*env)-&gt;ReleaseIntArrayElements(env, buttonDownMasks, tmp, 0);
260 
261     AWT_LOCK();
262     xtestAvailable = isXTestAvailable();
263     DTRACE_PRINTLN1(&quot;RobotPeer: XTest available = %d&quot;, xtestAvailable);
264     if (!xtestAvailable) {
265         JNU_ThrowByName(env, &quot;java/awt/AWTException&quot;, &quot;java.awt.Robot requires your X server support the XTEST extension version 2.2&quot;);
266     }
267 
268     AWT_UNLOCK();
269 }
270 
271 
272 JNIEXPORT void JNICALL
273 Java_sun_awt_X11_XRobotPeer_getRGBPixelsImpl( JNIEnv *env,
274                              jclass cls,
275                              jobject xgc,
276                              jint jx,
277                              jint jy,
278                              jint jwidth,
279                              jint jheight,
280                              jintArray pixelArray,
281                              jboolean useGtk) {
282     XImage *image;
283     jint *ary;               /* Array of jints for sending pixel values back
284                               * to parent process.
285                               */
286     Window rootWindow;
287     XWindowAttributes attr;
288     AwtGraphicsConfigDataPtr adata;
289 
290     DTRACE_PRINTLN6(&quot;RobotPeer: getRGBPixelsImpl(%lx, %d, %d, %d, %d, %x)&quot;, xgc, jx, jy, jwidth, jheight, pixelArray);
291 
292     if (jwidth &lt;= 0 || jheight &lt;= 0) {
293         return;
294     }
295 
296     adata = (AwtGraphicsConfigDataPtr) JNU_GetLongFieldAsPtr(env, xgc, x11GraphicsConfigIDs.aData);
297     DASSERT(adata != NULL);
298 
299     AWT_LOCK();
300 
301     rootWindow = XRootWindow(awt_display, adata-&gt;awt_visInfo.screen);
302 
303     if (!useGtk) {
304         if (hasXCompositeOverlayExtension(awt_display) &amp;&amp;
305             isXCompositeDisplay(awt_display, adata-&gt;awt_visInfo.screen))
306         {
307             rootWindow = compositeGetOverlayWindow(awt_display, rootWindow);
308         }
309     }
310 
311     if (!XGetWindowAttributes(awt_display, rootWindow, &amp;attr)
312             || jx + jwidth &lt;= attr.x
313             || attr.x + attr.width &lt;= jx
314             || jy + jheight &lt;= attr.y
315             || attr.y + attr.height &lt;= jy) {
316 
317         AWT_UNLOCK();
318         return; // Does not intersect with root window
319     }
320 
321     gboolean gtk_failed = TRUE;
322     jint _x, _y;
323 
324     jint x = MAX(jx, attr.x);
325     jint y = MAX(jy, attr.y);
326     jint width = MIN(jx + jwidth, attr.x + attr.width) - x;
327     jint height = MIN(jy + jheight, attr.y + attr.height) - y;
328 
329     int dx = attr.x &gt; jx ? attr.x - jx : 0;
330     int dy = attr.y &gt; jy ? attr.y - jy : 0;
331 
332     int index;
333 
334     if (useGtk) {
335         gtk-&gt;gdk_threads_enter();
336         gtk_failed = gtk-&gt;get_drawable_data(env, pixelArray, x, y, width,
337                                             height, jwidth, dx, dy, 1);
338         gtk-&gt;gdk_threads_leave();
339     }
340 
341     if (gtk_failed) {
342         image = getWindowImage(awt_display, rootWindow, x, y, width, height);
343 
344         ary = (*env)-&gt;GetPrimitiveArrayCritical(env, pixelArray, NULL);
345 
346         if (!ary) {
347             XDestroyImage(image);
348             AWT_UNLOCK();
349             return;
350         }
351 
352         /* convert to Java ARGB pixels */
353         for (_y = 0; _y &lt; height; _y++) {
354             for (_x = 0; _x &lt; width; _x++) {
355                 jint pixel = (jint) XGetPixel(image, _x, _y);
356                                                               /* Note ignore upper
357                                                                * 32-bits on 64-bit
358                                                                * OSes.
359                                                                */
360                 pixel |= 0xff000000; /* alpha - full opacity */
361 
362                 index = (_y + dy) * jwidth + (_x + dx);
363                 ary[index] = pixel;
364             }
365         }
366 
367         XDestroyImage(image);
368         (*env)-&gt;ReleasePrimitiveArrayCritical(env, pixelArray, ary, 0);
369     }
370     AWT_UNLOCK();
371 }
372 
373 JNIEXPORT void JNICALL
374 Java_sun_awt_X11_XRobotPeer_keyPressImpl (JNIEnv *env,
375                          jclass cls,
376                          jint keycode) {
377 
378     AWT_LOCK();
379 
380     DTRACE_PRINTLN1(&quot;RobotPeer: keyPressImpl(%i)&quot;, keycode);
381 
382     XTestFakeKeyEvent(awt_display,
383                       XKeysymToKeycode(awt_display, awt_getX11KeySym(keycode)),
384                       True,
385                       CurrentTime);
386 
387     XSync(awt_display, False);
388 
389     AWT_UNLOCK();
390 
391 }
392 
393 JNIEXPORT void JNICALL
394 Java_sun_awt_X11_XRobotPeer_keyReleaseImpl (JNIEnv *env,
395                            jclass cls,
396                            jint keycode) {
397     AWT_LOCK();
398 
399     DTRACE_PRINTLN1(&quot;RobotPeer: keyReleaseImpl(%i)&quot;, keycode);
400 
401     XTestFakeKeyEvent(awt_display,
402                       XKeysymToKeycode(awt_display, awt_getX11KeySym(keycode)),
403                       False,
404                       CurrentTime);
405 
406     XSync(awt_display, False);
407 
408     AWT_UNLOCK();
409 }
410 
411 JNIEXPORT void JNICALL
412 Java_sun_awt_X11_XRobotPeer_mouseMoveImpl (JNIEnv *env,
413                           jclass cls,
414                           jobject xgc,
415                           jint root_x,
416                           jint root_y) {
417 
418     AwtGraphicsConfigDataPtr adata;
419 
420     AWT_LOCK();
421 
422     DTRACE_PRINTLN3(&quot;RobotPeer: mouseMoveImpl(%lx, %i, %i)&quot;, xgc, root_x, root_y);
423 
424     adata = (AwtGraphicsConfigDataPtr) JNU_GetLongFieldAsPtr(env, xgc, x11GraphicsConfigIDs.aData);
425     DASSERT(adata != NULL);
426 
427     XWarpPointer(awt_display, None, XRootWindow(awt_display, adata-&gt;awt_visInfo.screen), 0, 0, 0, 0, root_x, root_y);
428     XSync(awt_display, False);
429 
430     AWT_UNLOCK();
431 }
432 
433 /*
434   * Function joining the code of mousePressImpl and mouseReleaseImpl
435   */
436 void mouseAction(JNIEnv *env,
437                  jclass cls,
438                  jint buttonMask,
439                  Bool isMousePress)
440 {
441     AWT_LOCK();
442 
443     DTRACE_PRINTLN1(&quot;RobotPeer: mouseAction(%i)&quot;, buttonMask);
444     DTRACE_PRINTLN1(&quot;RobotPeer: mouseAction, press = %d&quot;, isMousePress);
445 
446     if (buttonMask &amp; java_awt_event_InputEvent_BUTTON1_MASK ||
447         buttonMask &amp; java_awt_event_InputEvent_BUTTON1_DOWN_MASK )
448     {
449         XTestFakeButtonEvent(awt_display, 1, isMousePress, CurrentTime);
450     }
451     if ((buttonMask &amp; java_awt_event_InputEvent_BUTTON2_MASK ||
452          buttonMask &amp; java_awt_event_InputEvent_BUTTON2_DOWN_MASK) &amp;&amp;
453         (num_buttons &gt;= 2)) {
454         XTestFakeButtonEvent(awt_display, 2, isMousePress, CurrentTime);
455     }
456     if ((buttonMask &amp; java_awt_event_InputEvent_BUTTON3_MASK ||
457          buttonMask &amp; java_awt_event_InputEvent_BUTTON3_DOWN_MASK) &amp;&amp;
458         (num_buttons &gt;= 3)) {
459         XTestFakeButtonEvent(awt_display, 3, isMousePress, CurrentTime);
460     }
461 
462     if (num_buttons &gt; 3){
463         int32_t i;
464         int32_t button = 0;
465         for (i = 3; i&lt;num_buttons; i++){
466             if ((buttonMask &amp; masks[i])) {
467                 // arrays starts from zero index =&gt; +1
468                 // users wants to affect 4 or 5 button but they are assigned
469                 // to the wheel so =&gt; we have to shift it to the right by 2.
470                 button = i + 3;
471                 XTestFakeButtonEvent(awt_display, button, isMousePress, CurrentTime);
472             }
473         }
474     }
475 
476     XSync(awt_display, False);
477     AWT_UNLOCK();
478 }
479 
480 JNIEXPORT void JNICALL
481 Java_sun_awt_X11_XRobotPeer_mousePressImpl (JNIEnv *env,
482                            jclass cls,
483                            jint buttonMask) {
484     mouseAction(env, cls, buttonMask, True);
485 }
486 
487 JNIEXPORT void JNICALL
488 Java_sun_awt_X11_XRobotPeer_mouseReleaseImpl (JNIEnv *env,
489                              jclass cls,
490                              jint buttonMask) {
491     mouseAction(env, cls, buttonMask, False);
492 }
493 
494 JNIEXPORT void JNICALL
495 Java_sun_awt_X11_XRobotPeer_mouseWheelImpl (JNIEnv *env,
496                            jclass cls,
497                            jint wheelAmt) {
498 /* Mouse wheel is implemented as a button press of button 4 and 5, so it */
499 /* probably could have been hacked into robot_mouseButtonEvent, but it&#39;s */
500 /* cleaner to give it its own command type, in case the implementation   */
501 /* needs to be changed later.  -bchristi, 6/20/01                        */
502 
503     int32_t repeat = abs(wheelAmt);
504     int32_t button = wheelAmt &lt; 0 ? 4 : 5;  /* wheel up:   button 4 */
505                                                  /* wheel down: button 5 */
506     int32_t loopIdx;
507 
508     AWT_LOCK();
509 
510     DTRACE_PRINTLN1(&quot;RobotPeer: mouseWheelImpl(%i)&quot;, wheelAmt);
511 
512     for (loopIdx = 0; loopIdx &lt; repeat; loopIdx++) { /* do nothing for   */
513                                                      /* wheelAmt == 0    */
514         XTestFakeButtonEvent(awt_display, button, True, CurrentTime);
515         XTestFakeButtonEvent(awt_display, button, False, CurrentTime);
516     }
517     XSync(awt_display, False);
518 
519     AWT_UNLOCK();
520 }
521 
522 JNIEXPORT void JNICALL
523 Java_sun_awt_X11_XRobotPeer_loadNativeLibraries (JNIEnv *env, jclass cls) {
524     initXCompositeFunctions();
525 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
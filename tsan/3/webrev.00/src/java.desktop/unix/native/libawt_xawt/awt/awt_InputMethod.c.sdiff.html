<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.desktop/unix/native/libawt_xawt/awt/awt_InputMethod.c</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="awt_GraphicsEnv.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Insets.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/unix/native/libawt_xawt/awt/awt_InputMethod.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 
  30 #include &quot;awt.h&quot;
  31 #include &quot;awt_p.h&quot;
  32 
  33 #include &lt;sun_awt_X11InputMethodBase.h&gt;
  34 #include &lt;sun_awt_X11_XInputMethod.h&gt;
  35 
  36 #include &lt;stdio.h&gt;
  37 #include &lt;stdlib.h&gt;
  38 #include &lt;sys/time.h&gt;
  39 #include &lt;X11/keysym.h&gt;
  40 #include &lt;X11/Xlib.h&gt;
  41 
  42 #define THROW_OUT_OF_MEMORY_ERROR() \
  43         JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), NULL)
  44 
  45 struct X11InputMethodIDs {
  46   jfieldID pData;
  47 } x11InputMethodIDs;
  48 
<span class="line-modified">  49 static void PreeditStartCallback(XIC, XPointer, XPointer);</span>
  50 static void PreeditDoneCallback(XIC, XPointer, XPointer);
  51 static void PreeditDrawCallback(XIC, XPointer,
  52                                 XIMPreeditDrawCallbackStruct *);
  53 static void PreeditCaretCallback(XIC, XPointer,
  54                                  XIMPreeditCaretCallbackStruct *);
  55 #if defined(__linux__) || defined(MACOSX)
  56 static void StatusStartCallback(XIC, XPointer, XPointer);
  57 static void StatusDoneCallback(XIC, XPointer, XPointer);
  58 static void StatusDrawCallback(XIC, XPointer,
  59                                XIMStatusDrawCallbackStruct *);
  60 #endif
  61 
  62 #define ROOT_WINDOW_STYLES      (XIMPreeditNothing | XIMStatusNothing)
  63 #define NO_STYLES               (XIMPreeditNone | XIMStatusNone)
  64 
  65 #define PreeditStartIndex       0
  66 #define PreeditDoneIndex        1
  67 #define PreeditDrawIndex        2
  68 #define PreeditCaretIndex       3
  69 #if defined(__linux__) || defined(MACOSX)
  70 #define StatusStartIndex        4
  71 #define StatusDoneIndex         5
  72 #define StatusDrawIndex         6
  73 #define NCALLBACKS              7
  74 #else
  75 #define NCALLBACKS              4
  76 #endif
  77 
  78 /*
  79  * Callback function pointers: the order has to match the *Index
  80  * values above.
  81  */
  82 static XIMProc callback_funcs[NCALLBACKS] = {
<span class="line-modified">  83     (XIMProc)PreeditStartCallback,</span>
  84     (XIMProc)PreeditDoneCallback,
  85     (XIMProc)PreeditDrawCallback,
  86     (XIMProc)PreeditCaretCallback,
  87 #if defined(__linux__) || defined(MACOSX)
  88     (XIMProc)StatusStartCallback,
  89     (XIMProc)StatusDoneCallback,
  90     (XIMProc)StatusDrawCallback,
  91 #endif
  92 };
  93 
  94 #if defined(__linux__) || defined(MACOSX)
  95 #define MAX_STATUS_LEN  100
  96 typedef struct {
  97     Window   w;                /*status window id        */
  98     Window   root;             /*the root window id      */
  99     Window   parent;           /*parent shell window     */
 100     int      x, y;             /*parent&#39;s upperleft position */
 101     int      width, height;    /*parent&#39;s width, height  */
 102     GC       lightGC;          /*gc for light border     */
 103     GC       dimGC;            /*gc for dim border       */
</pre>
<hr />
<pre>
 158 
 159 Window  currentFocusWindow = 0;  /* current window that has focus for input
 160                                        method. (the best place to put this
 161                                        information should be
 162                                        currentX11InputMethodInstance&#39;s pData) */
 163 static XIM X11im = NULL;
 164 Display * dpy = NULL;
 165 
 166 #define GetJNIEnv() (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2)
 167 
 168 static void DestroyXIMCallback(XIM, XPointer, XPointer);
 169 static void OpenXIMCallback(Display *, XPointer, XPointer);
 170 /* Solaris XIM Extention */
 171 #define XNCommitStringCallback &quot;commitStringCallback&quot;
 172 static void CommitStringCallback(XIC, XPointer, XPointer);
 173 
 174 static X11InputMethodData * getX11InputMethodData(JNIEnv *, jobject);
 175 static void setX11InputMethodData(JNIEnv *, jobject, X11InputMethodData *);
 176 static void destroyX11InputMethodData(JNIEnv *, X11InputMethodData *);
 177 static void freeX11InputMethodData(JNIEnv *, X11InputMethodData *);



 178 
 179 #ifdef __solaris__
 180 /* Prototype for this function is missing in Solaris X11R6 Xlib.h */
 181 extern char *XSetIMValues(
 182 #if NeedVarargsPrototypes
 183     XIM /* im */, ...
 184 #endif
 185 );
 186 #endif
 187 
 188 /*
 189  * This function is stolen from /src/solaris/hpi/src/system_md.c
 190  * It is used in setting the time in Java-level InputEvents
 191  */
 192 jlong
 193 awt_util_nowMillisUTC()
 194 {
 195     struct timeval t;
 196     gettimeofday(&amp;t, NULL);
 197     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
</pre>
<hr />
<pre>
1002 
1003     if (pX11IMData-&gt;ic_active == (XIC)0
1004         || pX11IMData-&gt;ic_passive == (XIC)0) {
1005         return False;
1006     }
1007 
1008     /*
1009      * Use commit string call back if possible.
1010      * This will ensure the correct order of preedit text and commit text
1011      */
1012     {
1013         XIMCallback cb;
1014         cb.client_data = (XPointer) pX11IMData-&gt;x11inputmethod;
1015         cb.callback = (XIMProc) CommitStringCallback;
1016         XSetICValues (pX11IMData-&gt;ic_active, XNCommitStringCallback, &amp;cb, NULL);
1017         if (pX11IMData-&gt;ic_active != pX11IMData-&gt;ic_passive) {
1018             XSetICValues (pX11IMData-&gt;ic_passive, XNCommitStringCallback, &amp;cb, NULL);
1019         }
1020     }
1021 














1022     /* Add the global reference object to X11InputMethod to the list. */
1023     addToX11InputMethodGRefList(pX11IMData-&gt;x11inputmethod);
1024 





1025     return True;
1026 
1027  err:
1028     if (preedit)
1029         XFree((void *)preedit);
1030     THROW_OUT_OF_MEMORY_ERROR();
1031     return False;
1032 }
1033 
<span class="line-modified">1034 static void</span>
1035 PreeditStartCallback(XIC ic, XPointer client_data, XPointer call_data)
1036 {
1037     /*ARGSUSED*/
1038     /* printf(&quot;Native: PreeditStartCallback\n&quot;); */

1039 }
1040 
1041 static void
1042 PreeditDoneCallback(XIC ic, XPointer client_data, XPointer call_data)
1043 {
1044     /*ARGSUSED*/
1045     /* printf(&quot;Native: PreeditDoneCallback\n&quot;); */
1046 }
1047 
1048 /*
1049  * Translate the preedit draw callback items to Java values and invoke
1050  * X11InputMethod.dispatchComposedText().
1051  *
1052  * client_data: X11InputMethod object
1053  */
1054 static void
1055 PreeditDrawCallback(XIC ic, XPointer client_data,
1056                     XIMPreeditDrawCallbackStruct *pre_draw)
1057 {
1058     JNIEnv *env = GetJNIEnv();
</pre>
<hr />
<pre>
1146 PreeditCaretCallback(XIC ic, XPointer client_data,
1147                      XIMPreeditCaretCallbackStruct *pre_caret)
1148 {
1149     /*ARGSUSED*/
1150     /* printf(&quot;Native: PreeditCaretCallback\n&quot;); */
1151 }
1152 
1153 #if defined(__linux__) || defined(MACOSX)
1154 static void
1155 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
1156 {
1157     /*ARGSUSED*/
1158     /*printf(&quot;StatusStartCallback:\n&quot;);  */
1159 }
1160 
1161 static void
1162 StatusDoneCallback(XIC ic, XPointer client_data, XPointer call_data)
1163 {
1164     /*ARGSUSED*/
1165     /*printf(&quot;StatusDoneCallback:\n&quot;); */























1166 }
1167 
1168 static void
1169 StatusDrawCallback(XIC ic, XPointer client_data,
1170                      XIMStatusDrawCallbackStruct *status_draw)
1171 {
1172     /*ARGSUSED*/
1173     /*printf(&quot;StatusDrawCallback:\n&quot;); */
1174     JNIEnv *env = GetJNIEnv();
1175     X11InputMethodData *pX11IMData = NULL;
1176     StatusWindow *statusWindow;
1177 
1178     AWT_LOCK();
1179 
1180     if (!isX11InputMethodGRefInList((jobject)client_data)) {
1181         if ((jobject)client_data == currentX11InputMethodInstance) {
1182             currentX11InputMethodInstance = NULL;
1183         }
1184         goto finally;
1185     }
</pre>
<hr />
<pre>
1266 
1267     X11im = XOpenIM(display, NULL, NULL, NULL);
1268     if (X11im == NULL) {
1269         return;
1270     }
1271 
1272     ximCallback.callback = (XIMProc)DestroyXIMCallback;
1273     ximCallback.client_data = NULL;
1274     XSetIMValues(X11im, XNDestroyCallback, &amp;ximCallback, NULL);
1275 }
1276 
1277 static void DestroyXIMCallback(XIM im, XPointer client_data, XPointer call_data) {
1278     /* mark that XIM server was destroyed */
1279     X11im = NULL;
1280     JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1281 
1282     AWT_LOCK();
1283     /* free the old pX11IMData and set it to null. this also avoids crashing
1284      * the jvm if the XIM server reappears */
1285     while (x11InputMethodGRefListHead != NULL) {
<span class="line-modified">1286         getX11InputMethodData(env, x11InputMethodGRefListHead-&gt;inputMethodGRef);</span>








1287     }
1288     AWT_UNLOCK();
1289 }
1290 
1291 JNIEXPORT jboolean JNICALL
1292 Java_sun_awt_X11_XInputMethod_openXIMNative(JNIEnv *env,
1293                                             jobject this,
1294                                             jlong display)
1295 {
1296     Bool registered;
1297 
1298     AWT_LOCK();
1299 
1300     dpy = (Display *)jlong_to_ptr(display);
1301 
1302 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
1303    (4768335)
1304 */
1305 #if defined(__linux__) || defined(MACOSX)
1306     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
</pre>
<hr />
<pre>
1535 }
1536 
1537 /*
1538  * Class:     sun_awt_X11InputMethodBase
1539  * Method:    setCompositionEnabledNative
1540  * Signature: (Z)Z
1541  *
1542  * This method tries to set the XNPreeditState attribute associated with the current
1543  * XIC to the passed in &#39;enable&#39; state.
1544  *
1545  * Return JNI_TRUE if XNPreeditState attribute is successfully changed to the
1546  * &#39;enable&#39; state; Otherwise, if XSetICValues fails to set this attribute,
1547  * java.lang.UnsupportedOperationException will be thrown. JNI_FALSE is returned if this
1548  * method fails due to other reasons.
1549  */
1550 JNIEXPORT jboolean JNICALL Java_sun_awt_X11InputMethodBase_setCompositionEnabledNative
1551   (JNIEnv *env, jobject this, jboolean enable)
1552 {
1553     X11InputMethodData *pX11IMData;
1554     char * ret = NULL;




1555 
1556     AWT_LOCK();
1557     pX11IMData = getX11InputMethodData(env, this);
1558 
1559     if ((pX11IMData == NULL) || (pX11IMData-&gt;current_ic == NULL)) {
1560         AWT_UNLOCK();
1561         return JNI_FALSE;
1562     }
1563 
<span class="line-modified">1564     ret = XSetICValues(pX11IMData-&gt;current_ic, XNPreeditState,</span>
<span class="line-modified">1565                        (enable ? XIMPreeditEnable : XIMPreeditDisable), NULL);</span>































1566     AWT_UNLOCK();
1567 
<span class="line-modified">1568     if ((ret != 0) &amp;&amp; (strcmp(ret, XNPreeditState) == 0)) {</span>


1569         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;&quot;);
1570     }
1571 
1572     return (jboolean)(ret == 0);
1573 }
1574 
1575 /*
1576  * Class:     sun_awt_X11InputMethodBase
1577  * Method:    isCompositionEnabledNative
1578  * Signature: ()Z
1579  *
1580  * This method tries to get the XNPreeditState attribute associated with the current XIC.
1581  *
1582  * Return JNI_TRUE if the XNPreeditState is successfully retrieved. Otherwise, if
1583  * XGetICValues fails to get this attribute, java.lang.UnsupportedOperationException
1584  * will be thrown. JNI_FALSE is returned if this method fails due to other reasons.
1585  */
1586 JNIEXPORT jboolean JNICALL Java_sun_awt_X11InputMethodBase_isCompositionEnabledNative
1587   (JNIEnv *env, jobject this)
1588 {
1589     X11InputMethodData *pX11IMData = NULL;
1590     char * ret = NULL;
<span class="line-modified">1591     XIMPreeditState state;</span>







1592 
1593     AWT_LOCK();
1594     pX11IMData = getX11InputMethodData(env, this);
1595 
1596     if ((pX11IMData == NULL) || (pX11IMData-&gt;current_ic == NULL)) {
1597         AWT_UNLOCK();
1598         return JNI_FALSE;
1599     }
1600 
<span class="line-modified">1601     ret = XGetICValues(pX11IMData-&gt;current_ic, XNPreeditState, &amp;state, NULL);</span>


1602     AWT_UNLOCK();
1603 
<span class="line-modified">1604     if ((ret != 0) &amp;&amp; (strcmp(ret, XNPreeditState) == 0)) {</span>


1605         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;&quot;);
1606         return JNI_FALSE;
1607     }
1608 
1609     return (jboolean)(state == XIMPreeditEnable);
1610 }
1611 
1612 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
1613   (JNIEnv *env, jobject this, jlong window)
1614 {
1615 #if defined(__linux__) || defined(MACOSX)
1616     AWT_LOCK();
1617     adjustStatusWindow(window);
1618     AWT_UNLOCK();
1619 #endif
1620 }

















</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  29 
  30 #include &quot;awt.h&quot;
  31 #include &quot;awt_p.h&quot;
  32 
  33 #include &lt;sun_awt_X11InputMethodBase.h&gt;
  34 #include &lt;sun_awt_X11_XInputMethod.h&gt;
  35 
  36 #include &lt;stdio.h&gt;
  37 #include &lt;stdlib.h&gt;
  38 #include &lt;sys/time.h&gt;
  39 #include &lt;X11/keysym.h&gt;
  40 #include &lt;X11/Xlib.h&gt;
  41 
  42 #define THROW_OUT_OF_MEMORY_ERROR() \
  43         JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2), NULL)
  44 
  45 struct X11InputMethodIDs {
  46   jfieldID pData;
  47 } x11InputMethodIDs;
  48 
<span class="line-modified">  49 static int PreeditStartCallback(XIC, XPointer, XPointer);</span>
  50 static void PreeditDoneCallback(XIC, XPointer, XPointer);
  51 static void PreeditDrawCallback(XIC, XPointer,
  52                                 XIMPreeditDrawCallbackStruct *);
  53 static void PreeditCaretCallback(XIC, XPointer,
  54                                  XIMPreeditCaretCallbackStruct *);
  55 #if defined(__linux__) || defined(MACOSX)
  56 static void StatusStartCallback(XIC, XPointer, XPointer);
  57 static void StatusDoneCallback(XIC, XPointer, XPointer);
  58 static void StatusDrawCallback(XIC, XPointer,
  59                                XIMStatusDrawCallbackStruct *);
  60 #endif
  61 
  62 #define ROOT_WINDOW_STYLES      (XIMPreeditNothing | XIMStatusNothing)
  63 #define NO_STYLES               (XIMPreeditNone | XIMStatusNone)
  64 
  65 #define PreeditStartIndex       0
  66 #define PreeditDoneIndex        1
  67 #define PreeditDrawIndex        2
  68 #define PreeditCaretIndex       3
  69 #if defined(__linux__) || defined(MACOSX)
  70 #define StatusStartIndex        4
  71 #define StatusDoneIndex         5
  72 #define StatusDrawIndex         6
  73 #define NCALLBACKS              7
  74 #else
  75 #define NCALLBACKS              4
  76 #endif
  77 
  78 /*
  79  * Callback function pointers: the order has to match the *Index
  80  * values above.
  81  */
  82 static XIMProc callback_funcs[NCALLBACKS] = {
<span class="line-modified">  83     (XIMProc)(void *)&amp;PreeditStartCallback,</span>
  84     (XIMProc)PreeditDoneCallback,
  85     (XIMProc)PreeditDrawCallback,
  86     (XIMProc)PreeditCaretCallback,
  87 #if defined(__linux__) || defined(MACOSX)
  88     (XIMProc)StatusStartCallback,
  89     (XIMProc)StatusDoneCallback,
  90     (XIMProc)StatusDrawCallback,
  91 #endif
  92 };
  93 
  94 #if defined(__linux__) || defined(MACOSX)
  95 #define MAX_STATUS_LEN  100
  96 typedef struct {
  97     Window   w;                /*status window id        */
  98     Window   root;             /*the root window id      */
  99     Window   parent;           /*parent shell window     */
 100     int      x, y;             /*parent&#39;s upperleft position */
 101     int      width, height;    /*parent&#39;s width, height  */
 102     GC       lightGC;          /*gc for light border     */
 103     GC       dimGC;            /*gc for dim border       */
</pre>
<hr />
<pre>
 158 
 159 Window  currentFocusWindow = 0;  /* current window that has focus for input
 160                                        method. (the best place to put this
 161                                        information should be
 162                                        currentX11InputMethodInstance&#39;s pData) */
 163 static XIM X11im = NULL;
 164 Display * dpy = NULL;
 165 
 166 #define GetJNIEnv() (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2)
 167 
 168 static void DestroyXIMCallback(XIM, XPointer, XPointer);
 169 static void OpenXIMCallback(Display *, XPointer, XPointer);
 170 /* Solaris XIM Extention */
 171 #define XNCommitStringCallback &quot;commitStringCallback&quot;
 172 static void CommitStringCallback(XIC, XPointer, XPointer);
 173 
 174 static X11InputMethodData * getX11InputMethodData(JNIEnv *, jobject);
 175 static void setX11InputMethodData(JNIEnv *, jobject, X11InputMethodData *);
 176 static void destroyX11InputMethodData(JNIEnv *, X11InputMethodData *);
 177 static void freeX11InputMethodData(JNIEnv *, X11InputMethodData *);
<span class="line-added"> 178 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-added"> 179 static Window getParentWindow(Window);</span>
<span class="line-added"> 180 #endif</span>
 181 
 182 #ifdef __solaris__
 183 /* Prototype for this function is missing in Solaris X11R6 Xlib.h */
 184 extern char *XSetIMValues(
 185 #if NeedVarargsPrototypes
 186     XIM /* im */, ...
 187 #endif
 188 );
 189 #endif
 190 
 191 /*
 192  * This function is stolen from /src/solaris/hpi/src/system_md.c
 193  * It is used in setting the time in Java-level InputEvents
 194  */
 195 jlong
 196 awt_util_nowMillisUTC()
 197 {
 198     struct timeval t;
 199     gettimeofday(&amp;t, NULL);
 200     return ((jlong)t.tv_sec) * 1000 + (jlong)(t.tv_usec/1000);
</pre>
<hr />
<pre>
1005 
1006     if (pX11IMData-&gt;ic_active == (XIC)0
1007         || pX11IMData-&gt;ic_passive == (XIC)0) {
1008         return False;
1009     }
1010 
1011     /*
1012      * Use commit string call back if possible.
1013      * This will ensure the correct order of preedit text and commit text
1014      */
1015     {
1016         XIMCallback cb;
1017         cb.client_data = (XPointer) pX11IMData-&gt;x11inputmethod;
1018         cb.callback = (XIMProc) CommitStringCallback;
1019         XSetICValues (pX11IMData-&gt;ic_active, XNCommitStringCallback, &amp;cb, NULL);
1020         if (pX11IMData-&gt;ic_active != pX11IMData-&gt;ic_passive) {
1021             XSetICValues (pX11IMData-&gt;ic_passive, XNCommitStringCallback, &amp;cb, NULL);
1022         }
1023     }
1024 
<span class="line-added">1025     // The code set the IC mode that the preedit state is not initialied</span>
<span class="line-added">1026     // at XmbResetIC.  This attribute can be set at XCreateIC.  I separately</span>
<span class="line-added">1027     // set the attribute to avoid the failure of XCreateIC at some platform</span>
<span class="line-added">1028     // which does not support the attribute.</span>
<span class="line-added">1029     if (pX11IMData-&gt;ic_active != 0)</span>
<span class="line-added">1030         XSetICValues(pX11IMData-&gt;ic_active,</span>
<span class="line-added">1031                      XNResetState, XIMInitialState,</span>
<span class="line-added">1032                      NULL);</span>
<span class="line-added">1033     if (pX11IMData-&gt;ic_passive != 0</span>
<span class="line-added">1034             &amp;&amp; pX11IMData-&gt;ic_active != pX11IMData-&gt;ic_passive)</span>
<span class="line-added">1035         XSetICValues(pX11IMData-&gt;ic_passive,</span>
<span class="line-added">1036                      XNResetState, XIMInitialState,</span>
<span class="line-added">1037                      NULL);</span>
<span class="line-added">1038 </span>
1039     /* Add the global reference object to X11InputMethod to the list. */
1040     addToX11InputMethodGRefList(pX11IMData-&gt;x11inputmethod);
1041 
<span class="line-added">1042     /* Unset focus to avoid unexpected IM on */</span>
<span class="line-added">1043     setXICFocus(pX11IMData-&gt;ic_active, False);</span>
<span class="line-added">1044     if (pX11IMData-&gt;ic_active != pX11IMData-&gt;ic_passive)</span>
<span class="line-added">1045         setXICFocus(pX11IMData-&gt;ic_passive, False);</span>
<span class="line-added">1046 </span>
1047     return True;
1048 
1049  err:
1050     if (preedit)
1051         XFree((void *)preedit);
1052     THROW_OUT_OF_MEMORY_ERROR();
1053     return False;
1054 }
1055 
<span class="line-modified">1056 static int</span>
1057 PreeditStartCallback(XIC ic, XPointer client_data, XPointer call_data)
1058 {
1059     /*ARGSUSED*/
1060     /* printf(&quot;Native: PreeditStartCallback\n&quot;); */
<span class="line-added">1061     return -1;</span>
1062 }
1063 
1064 static void
1065 PreeditDoneCallback(XIC ic, XPointer client_data, XPointer call_data)
1066 {
1067     /*ARGSUSED*/
1068     /* printf(&quot;Native: PreeditDoneCallback\n&quot;); */
1069 }
1070 
1071 /*
1072  * Translate the preedit draw callback items to Java values and invoke
1073  * X11InputMethod.dispatchComposedText().
1074  *
1075  * client_data: X11InputMethod object
1076  */
1077 static void
1078 PreeditDrawCallback(XIC ic, XPointer client_data,
1079                     XIMPreeditDrawCallbackStruct *pre_draw)
1080 {
1081     JNIEnv *env = GetJNIEnv();
</pre>
<hr />
<pre>
1169 PreeditCaretCallback(XIC ic, XPointer client_data,
1170                      XIMPreeditCaretCallbackStruct *pre_caret)
1171 {
1172     /*ARGSUSED*/
1173     /* printf(&quot;Native: PreeditCaretCallback\n&quot;); */
1174 }
1175 
1176 #if defined(__linux__) || defined(MACOSX)
1177 static void
1178 StatusStartCallback(XIC ic, XPointer client_data, XPointer call_data)
1179 {
1180     /*ARGSUSED*/
1181     /*printf(&quot;StatusStartCallback:\n&quot;);  */
1182 }
1183 
1184 static void
1185 StatusDoneCallback(XIC ic, XPointer client_data, XPointer call_data)
1186 {
1187     /*ARGSUSED*/
1188     /*printf(&quot;StatusDoneCallback:\n&quot;); */
<span class="line-added">1189     JNIEnv *env = GetJNIEnv();</span>
<span class="line-added">1190     X11InputMethodData *pX11IMData = NULL;</span>
<span class="line-added">1191     StatusWindow *statusWindow;</span>
<span class="line-added">1192 </span>
<span class="line-added">1193     AWT_LOCK();</span>
<span class="line-added">1194 </span>
<span class="line-added">1195     if (!isX11InputMethodGRefInList((jobject)client_data)) {</span>
<span class="line-added">1196         if ((jobject)client_data == currentX11InputMethodInstance) {</span>
<span class="line-added">1197             currentX11InputMethodInstance = NULL;</span>
<span class="line-added">1198         }</span>
<span class="line-added">1199         goto finally;</span>
<span class="line-added">1200     }</span>
<span class="line-added">1201 </span>
<span class="line-added">1202     if (NULL == (pX11IMData = getX11InputMethodData(env, (jobject)client_data))</span>
<span class="line-added">1203         || NULL == (statusWindow = pX11IMData-&gt;statusWindow)){</span>
<span class="line-added">1204         goto finally;</span>
<span class="line-added">1205     }</span>
<span class="line-added">1206     currentX11InputMethodInstance = (jobject)client_data;</span>
<span class="line-added">1207 </span>
<span class="line-added">1208     onoffStatusWindow(pX11IMData, 0, False);</span>
<span class="line-added">1209 </span>
<span class="line-added">1210  finally:</span>
<span class="line-added">1211     AWT_UNLOCK();</span>
1212 }
1213 
1214 static void
1215 StatusDrawCallback(XIC ic, XPointer client_data,
1216                      XIMStatusDrawCallbackStruct *status_draw)
1217 {
1218     /*ARGSUSED*/
1219     /*printf(&quot;StatusDrawCallback:\n&quot;); */
1220     JNIEnv *env = GetJNIEnv();
1221     X11InputMethodData *pX11IMData = NULL;
1222     StatusWindow *statusWindow;
1223 
1224     AWT_LOCK();
1225 
1226     if (!isX11InputMethodGRefInList((jobject)client_data)) {
1227         if ((jobject)client_data == currentX11InputMethodInstance) {
1228             currentX11InputMethodInstance = NULL;
1229         }
1230         goto finally;
1231     }
</pre>
<hr />
<pre>
1312 
1313     X11im = XOpenIM(display, NULL, NULL, NULL);
1314     if (X11im == NULL) {
1315         return;
1316     }
1317 
1318     ximCallback.callback = (XIMProc)DestroyXIMCallback;
1319     ximCallback.client_data = NULL;
1320     XSetIMValues(X11im, XNDestroyCallback, &amp;ximCallback, NULL);
1321 }
1322 
1323 static void DestroyXIMCallback(XIM im, XPointer client_data, XPointer call_data) {
1324     /* mark that XIM server was destroyed */
1325     X11im = NULL;
1326     JNIEnv* env = (JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2);
1327 
1328     AWT_LOCK();
1329     /* free the old pX11IMData and set it to null. this also avoids crashing
1330      * the jvm if the XIM server reappears */
1331     while (x11InputMethodGRefListHead != NULL) {
<span class="line-modified">1332         if (getX11InputMethodData(env,</span>
<span class="line-added">1333                 x11InputMethodGRefListHead-&gt;inputMethodGRef) == NULL) {</span>
<span class="line-added">1334             /* Clear possible exceptions</span>
<span class="line-added">1335              */</span>
<span class="line-added">1336             if ((*env)-&gt;ExceptionOccurred(env)) {</span>
<span class="line-added">1337                 (*env)-&gt;ExceptionDescribe(env);</span>
<span class="line-added">1338                 (*env)-&gt;ExceptionClear(env);</span>
<span class="line-added">1339             }</span>
<span class="line-added">1340         }</span>
1341     }
1342     AWT_UNLOCK();
1343 }
1344 
1345 JNIEXPORT jboolean JNICALL
1346 Java_sun_awt_X11_XInputMethod_openXIMNative(JNIEnv *env,
1347                                             jobject this,
1348                                             jlong display)
1349 {
1350     Bool registered;
1351 
1352     AWT_LOCK();
1353 
1354     dpy = (Display *)jlong_to_ptr(display);
1355 
1356 /* Use IMInstantiate call back only on Linux, as there is a bug in Solaris
1357    (4768335)
1358 */
1359 #if defined(__linux__) || defined(MACOSX)
1360     registered = XRegisterIMInstantiateCallback(dpy, NULL, NULL,
</pre>
<hr />
<pre>
1589 }
1590 
1591 /*
1592  * Class:     sun_awt_X11InputMethodBase
1593  * Method:    setCompositionEnabledNative
1594  * Signature: (Z)Z
1595  *
1596  * This method tries to set the XNPreeditState attribute associated with the current
1597  * XIC to the passed in &#39;enable&#39; state.
1598  *
1599  * Return JNI_TRUE if XNPreeditState attribute is successfully changed to the
1600  * &#39;enable&#39; state; Otherwise, if XSetICValues fails to set this attribute,
1601  * java.lang.UnsupportedOperationException will be thrown. JNI_FALSE is returned if this
1602  * method fails due to other reasons.
1603  */
1604 JNIEXPORT jboolean JNICALL Java_sun_awt_X11InputMethodBase_setCompositionEnabledNative
1605   (JNIEnv *env, jobject this, jboolean enable)
1606 {
1607     X11InputMethodData *pX11IMData;
1608     char * ret = NULL;
<span class="line-added">1609     XVaNestedList   pr_atrb;</span>
<span class="line-added">1610 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-added">1611     Boolean calledXSetICFocus = False;</span>
<span class="line-added">1612 #endif</span>
1613 
1614     AWT_LOCK();
1615     pX11IMData = getX11InputMethodData(env, this);
1616 
1617     if ((pX11IMData == NULL) || (pX11IMData-&gt;current_ic == NULL)) {
1618         AWT_UNLOCK();
1619         return JNI_FALSE;
1620     }
1621 
<span class="line-modified">1622 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-modified">1623     if (NULL != pX11IMData-&gt;statusWindow) {</span>
<span class="line-added">1624         Window focus = 0;</span>
<span class="line-added">1625         int revert_to;</span>
<span class="line-added">1626 #if defined(_LP64) &amp;&amp; !defined(_LITTLE_ENDIAN)</span>
<span class="line-added">1627         // The Window value which is used for XGetICValues must be 32bit on BigEndian XOrg&#39;s xlib</span>
<span class="line-added">1628         unsigned int w = 0;</span>
<span class="line-added">1629 #else</span>
<span class="line-added">1630         Window w = 0;</span>
<span class="line-added">1631 #endif</span>
<span class="line-added">1632         XGetInputFocus(awt_display, &amp;focus, &amp;revert_to);</span>
<span class="line-added">1633         XGetICValues(pX11IMData-&gt;current_ic, XNFocusWindow, &amp;w, NULL);</span>
<span class="line-added">1634         if (RevertToPointerRoot == revert_to</span>
<span class="line-added">1635                 &amp;&amp; pX11IMData-&gt;ic_active != pX11IMData-&gt;ic_passive) {</span>
<span class="line-added">1636             if (pX11IMData-&gt;current_ic == pX11IMData-&gt;ic_active) {</span>
<span class="line-added">1637                 if (getParentWindow(focus) == getParentWindow(w)) {</span>
<span class="line-added">1638                     XUnsetICFocus(pX11IMData-&gt;ic_active);</span>
<span class="line-added">1639                     calledXSetICFocus = True;</span>
<span class="line-added">1640                 }</span>
<span class="line-added">1641             }</span>
<span class="line-added">1642         }</span>
<span class="line-added">1643     }</span>
<span class="line-added">1644 #endif</span>
<span class="line-added">1645     pr_atrb = XVaCreateNestedList(0,</span>
<span class="line-added">1646                   XNPreeditState, (enable ? XIMPreeditEnable : XIMPreeditDisable),</span>
<span class="line-added">1647                   NULL);</span>
<span class="line-added">1648     ret = XSetICValues(pX11IMData-&gt;current_ic, XNPreeditAttributes, pr_atrb, NULL);</span>
<span class="line-added">1649     XFree((void *)pr_atrb);</span>
<span class="line-added">1650 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-added">1651     if (calledXSetICFocus) {</span>
<span class="line-added">1652         XSetICFocus(pX11IMData-&gt;ic_active);</span>
<span class="line-added">1653     }</span>
<span class="line-added">1654 #endif</span>
1655     AWT_UNLOCK();
1656 
<span class="line-modified">1657     if ((ret != 0)</span>
<span class="line-added">1658             &amp;&amp; ((strcmp(ret, XNPreeditAttributes) == 0)</span>
<span class="line-added">1659             || (strcmp(ret, XNPreeditState) == 0))) {</span>
1660         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;&quot;);
1661     }
1662 
1663     return (jboolean)(ret == 0);
1664 }
1665 
1666 /*
1667  * Class:     sun_awt_X11InputMethodBase
1668  * Method:    isCompositionEnabledNative
1669  * Signature: ()Z
1670  *
1671  * This method tries to get the XNPreeditState attribute associated with the current XIC.
1672  *
1673  * Return JNI_TRUE if the XNPreeditState is successfully retrieved. Otherwise, if
1674  * XGetICValues fails to get this attribute, java.lang.UnsupportedOperationException
1675  * will be thrown. JNI_FALSE is returned if this method fails due to other reasons.
1676  */
1677 JNIEXPORT jboolean JNICALL Java_sun_awt_X11InputMethodBase_isCompositionEnabledNative
1678   (JNIEnv *env, jobject this)
1679 {
1680     X11InputMethodData *pX11IMData = NULL;
1681     char * ret = NULL;
<span class="line-modified">1682 #if defined(__linux__) &amp;&amp; defined(_LP64) &amp;&amp; !defined(_LITTLE_ENDIAN)</span>
<span class="line-added">1683     // XIMPreeditState value which is used for XGetICValues must be 32bit on BigEndian XOrg&#39;s xlib</span>
<span class="line-added">1684     unsigned int state = XIMPreeditUnKnown;</span>
<span class="line-added">1685 #else</span>
<span class="line-added">1686     XIMPreeditState state = XIMPreeditUnKnown;</span>
<span class="line-added">1687 #endif</span>
<span class="line-added">1688 </span>
<span class="line-added">1689     XVaNestedList   pr_atrb;</span>
1690 
1691     AWT_LOCK();
1692     pX11IMData = getX11InputMethodData(env, this);
1693 
1694     if ((pX11IMData == NULL) || (pX11IMData-&gt;current_ic == NULL)) {
1695         AWT_UNLOCK();
1696         return JNI_FALSE;
1697     }
1698 
<span class="line-modified">1699     pr_atrb = XVaCreateNestedList(0, XNPreeditState, &amp;state, NULL);</span>
<span class="line-added">1700     ret = XGetICValues(pX11IMData-&gt;current_ic, XNPreeditAttributes, pr_atrb, NULL);</span>
<span class="line-added">1701     XFree((void *)pr_atrb);</span>
1702     AWT_UNLOCK();
1703 
<span class="line-modified">1704     if ((ret != 0)</span>
<span class="line-added">1705             &amp;&amp; ((strcmp(ret, XNPreeditAttributes) == 0)</span>
<span class="line-added">1706             || (strcmp(ret, XNPreeditState) == 0))) {</span>
1707         JNU_ThrowByName(env, &quot;java/lang/UnsupportedOperationException&quot;, &quot;&quot;);
1708         return JNI_FALSE;
1709     }
1710 
1711     return (jboolean)(state == XIMPreeditEnable);
1712 }
1713 
1714 JNIEXPORT void JNICALL Java_sun_awt_X11_XInputMethod_adjustStatusWindow
1715   (JNIEnv *env, jobject this, jlong window)
1716 {
1717 #if defined(__linux__) || defined(MACOSX)
1718     AWT_LOCK();
1719     adjustStatusWindow(window);
1720     AWT_UNLOCK();
1721 #endif
1722 }
<span class="line-added">1723 </span>
<span class="line-added">1724 #if defined(__linux__) || defined(MACOSX)</span>
<span class="line-added">1725 static Window getParentWindow(Window w)</span>
<span class="line-added">1726 {</span>
<span class="line-added">1727     Window root=None, parent=None, *ignore_children=NULL;</span>
<span class="line-added">1728     unsigned int ignore_uint=0;</span>
<span class="line-added">1729     Status status = 0;</span>
<span class="line-added">1730 </span>
<span class="line-added">1731     if (w == None)</span>
<span class="line-added">1732         return None;</span>
<span class="line-added">1733     status = XQueryTree(dpy, w, &amp;root, &amp;parent, &amp;ignore_children, &amp;ignore_uint);</span>
<span class="line-added">1734     XFree(ignore_children);</span>
<span class="line-added">1735     if (status == 0)</span>
<span class="line-added">1736         return None;</span>
<span class="line-added">1737     return parent;</span>
<span class="line-added">1738 }</span>
<span class="line-added">1739 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="awt_GraphicsEnv.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="awt_Insets.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
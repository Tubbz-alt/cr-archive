diff a/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java b/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
--- a/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
+++ b/src/java.desktop/macosx/classes/sun/awt/CGraphicsDevice.java
@@ -31,15 +31,18 @@
 import java.awt.GraphicsDevice;
 import java.awt.Insets;
 import java.awt.Rectangle;
 import java.awt.Window;
 import java.awt.geom.Rectangle2D;
+import java.awt.peer.WindowPeer;
 import java.util.Objects;
 
 import sun.java2d.SunGraphicsEnvironment;
 import sun.java2d.opengl.CGLGraphicsConfig;
 
+import static java.awt.peer.ComponentPeer.SET_BOUNDS;
+
 public final class CGraphicsDevice extends GraphicsDevice
         implements DisplayChangedListener {
 
     /**
      * CoreGraphics display ID. This identifier can become non-valid at any time
@@ -59,10 +62,14 @@
     private DisplayMode originalMode;
 
     public CGraphicsDevice(final int displayID) {
         this.displayID = displayID;
         config = CGLGraphicsConfig.getConfig(this, displayID, 0);
+        // initializes default device state, might be redundant step since we
+        // call "displayChanged()" later anyway, but we do not want to leave the
+        // device in an inconsistent state after construction
+        displayChanged();
     }
 
     /**
      * Return a list of all configurations.
      */
@@ -123,20 +130,22 @@
     public int getScaleFactor() {
         return scale;
     }
 
     public void invalidate(final int defaultDisplayID) {
+        //TODO do we need to restore the full-screen window/modes on old device?
         displayID = defaultDisplayID;
     }
 
     @Override
     public void displayChanged() {
         xResolution = nativeGetXResolution(displayID);
         yResolution = nativeGetYResolution(displayID);
         bounds = nativeGetBounds(displayID).getBounds(); //does integer rounding
         initScaleFactor();
-        //TODO configs/fullscreenWindow/modes?
+        resizeFSWindow(getFullScreenWindow(), bounds);
+        //TODO configs?
     }
 
     @Override
     public void paletteChanged() {
         // devices do not need to react to this event.
@@ -211,10 +220,22 @@
         if (peer != null) {
             peer.exitFullScreenMode();
         }
     }
 
+    /**
+     * Reapplies the size of this device to the full-screen window.
+     */
+    private static void resizeFSWindow(final Window w, final Rectangle b) {
+        if (w != null) {
+            WindowPeer peer = AWTAccessor.getComponentAccessor().getPeer(w);
+            if (peer != null) {
+                peer.setBounds(b.x, b.y, b.width, b.height, SET_BOUNDS);
+            }
+        }
+    }
+
     @Override
     public boolean isDisplayChangeSupported() {
         return true;
     }
 
@@ -223,14 +244,11 @@
         if (dm == null) {
             throw new IllegalArgumentException("Invalid display mode");
         }
         if (!Objects.equals(dm, getDisplayMode())) {
             nativeSetDisplayMode(displayID, dm.getWidth(), dm.getHeight(),
-                    dm.getBitDepth(), dm.getRefreshRate());
-            if (isFullScreenSupported() && getFullScreenWindow() != null) {
-                getFullScreenWindow().setSize(dm.getWidth(), dm.getHeight());
-            }
+                                 dm.getBitDepth(), dm.getRefreshRate());
         }
     }
 
     @Override
     public DisplayMode getDisplayMode() {
